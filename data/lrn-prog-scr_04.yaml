- en: Chapter 5. Variables
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章 变量
- en: 'This chapter explains how to create scripts that can read in and remember values.
    When you use variables, you can write applications that interact with users and
    respond to their input. Here’s what we’ll cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何创建能够读取和记住值的脚本。当你使用变量时，可以编写与用户交互并响应其输入的应用程序。以下是本章的内容：
- en: The data types supported by Scratch
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scratch支持的数据类型
- en: How to create variables and manipulate them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建变量并操作它们
- en: How to obtain input from users and write interactive programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取用户输入并编写交互式程序
- en: Though the scripts you wrote in the last four chapters helped you learn important
    Scratch programming skills, they lacked many key elements of a large-scale application.
    More complex programs can remember values and decide to take an action based on
    certain conditions. This chapter will address the first of these two deficiencies,
    and decision making will be covered in the next chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在过去四章中编写的脚本帮助你学习了重要的Scratch编程技能，但它们缺少了大型应用程序的许多关键元素。更复杂的程序可以记住值，并根据某些条件决定执行某个动作。本章将解决这两个缺陷中的第一个，决策功能将在下一章介绍。
- en: As you may have learned by now, scripts process and manipulate different types
    of data during their execution. These data can be input to command blocks (for
    example, the number 10 in the **move 10 steps** command and the “Hello!” string
    in the **say Hello!** command) or output from function blocks (like **mouse x,
    y position** and **pick random**), or data can be entered by the user in response
    to the **ask and wait** command. For more complex programs, you’ll often need
    to store and modify data to accomplish certain tasks. Data management in Scratch
    can be done using *variables* and *lists*. This chapter will explore variables
    in detail. Lists will be explored in [Chapter 9](ch09.html "Chapter 9. Lists").
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，脚本在执行过程中会处理和操作不同类型的数据。这些数据可以输入到命令块中（例如，**移动10步**命令中的数字10，或者**说你好！**命令中的“你好！”字符串），也可以是从功能块输出的数据（例如**鼠标x，y位置**和**随机选择**），或者数据可以是用户响应**询问并等待**命令时输入的。对于更复杂的程序，你通常需要存储和修改数据以完成某些任务。Scratch中的数据管理可以通过*变量*和*列表*来实现。本章将详细探讨变量，列表将在[第9章](ch09.html
    "第9章 列表")中讲解。
- en: This chapter begins with an overview of the data types supported in Scratch.
    It continues with an introduction to variables and a discussion of how to create
    and use them in your programs. Variable monitors will then be explained and used
    in several interesting applications. After mastering the basic concepts, you’ll
    learn how to use the **ask and wait** command to get inputs from the user.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从Scratch支持的数据类型概述开始。接着介绍变量，并讨论如何在程序中创建和使用它们。然后将解释变量监视器，并在几个有趣的应用程序中使用它们。在掌握了基本概念后，你将学习如何使用**询问并等待**命令来获取用户输入。
- en: Data Types in Scratch
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scratch中的数据类型
- en: 'Many computer programs manipulate different kinds of data, including numbers,
    text, images, and so on, to produce useful information. This is an important programming
    task, so you’ll need to know the data types and operations supported in Scratch.
    Scratch has built-in support for three data types that you can use in blocks:
    Booleans, numbers, and strings.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机程序操作不同种类的数据，包括数字、文本、图像等，以生成有用的信息。这是一个重要的编程任务，因此你需要了解Scratch支持的数据类型和操作。Scratch内置支持三种可以在积木中使用的数据类型：布尔值、数字和字符串。
- en: 'A *Boolean* can have only one of two values: true or false. You can use this
    data type to test one or more conditions and, based on the result, have your program
    choose a different execution path. We’ll discuss Booleans in detail in the next
    chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只有两种可能的值：真或假。你可以使用这种数据类型来测试一个或多个条件，并根据结果让程序选择不同的执行路径。我们将在下一章详细讨论布尔值。'
- en: A *number* variable can hold both integers and decimal values. Scratch doesn’t
    distinguish between the two; they’re both classified as “numbers.” You can round
    decimal numbers to the nearest whole number using the **round** block from the
    *Operators* palette. You can also use the **floor of** (or **ceiling of**) functions,
    available from the **sqrt of** block in the *Operators* palette, to get an integer
    from a specified decimal number. For example, **floor of 3.9** is 3 and **ceiling
    of 3.1** is 4.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字*变量可以存储整数和小数值。Scratch 不区分这两者，它们都被归类为“数字”。你可以使用来自*运算符*面板的**四舍五入**块将小数数字四舍五入为最接近的整数。你还可以使用来自*运算符*面板中的**取整**（或**向上取整**）功能，从指定的小数中得到一个整数。例如，**取整
    3.9**是 3，而**向上取整 3.1**是 4。'
- en: A *string* is a sequence of characters, which can include letters (both upper-
    and lowercase), numbers (0 to 9), and other symbols that you can type on your
    keyboard (+, –, &, @, and so on). You’d use a string data type to store names,
    addresses, book titles, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是由字符组成的序列，可以包括字母（大写和小写）、数字（0 到 9）以及你键盘上可以输入的其他符号（如 +、–、&、@ 等）。你会使用字符串数据类型来存储名字、地址、书名等。'
- en: What’s in the Shape?
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形状里面有什么？
- en: Have you noticed that Scratch blocks and their parameter slots each have particular
    geometric shapes? For example, the parameter slot in the **move 10 steps** block
    is a rectangle with rounded corners, while the one in the **say Hello!** block
    is a rectangle with sharp corners. The shape of the parameter slot is related
    to the data type it accepts. Try entering your name (or any other text) in the
    **move 10 steps** block; you’ll find that Scratch allows you to enter only numbers
    into the rounded-rectangle slot.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到 Scratch 块和它们的参数插槽各自有特定的几何形状？例如，**移动 10 步**块中的参数插槽是一个圆角矩形，而**说 Hello!**块中的参数插槽是一个带尖角的矩形。参数插槽的形状与它接受的数据类型有关。试着在**移动
    10 步**块中输入你的名字（或其他任何文本）；你会发现，Scratch 只允许你在圆角矩形插槽中输入数字。
- en: Similarly, the shape of a function block indicates the data type it returns.
    The meanings of the different shapes are illustrated in [Figure 5-1](ch05.html#what_the_shapes_of_command_and_function
    "Figure 5-1. What the shapes of command and function blocks mean").
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，功能块的形状也表示它返回的数据类型。不同形状的含义在[图 5-1](ch05.html#what_the_shapes_of_command_and_function
    "图 5-1. 命令块和功能块形状的含义")中有所说明。
- en: '![What the shapes of command and function blocks mean](httpatomoreillycomsourcenostarchimages2134559.png.jpg)Figure 5-1. What
    the shapes of command and function blocks mean'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![命令块和功能块形状的含义](httpatomoreillycomsourcenostarchimages2134559.png.jpg)图 5-1.
    命令块和功能块形状的含义'
- en: Parameter slots have three shapes (hexagon, rectangle, and rounded rectangle),
    while function blocks have only two shapes (hexagon and rounded rectangle). Each
    shape is associated with a particular data type, though you should note that a
    rounded-rectangle function block can report either a number or a string.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 参数插槽有三种形状（六边形、矩形和圆角矩形），而功能块只有两种形状（六边形和圆角矩形）。每种形状都与特定的数据类型相关，尽管你需要注意的是，圆角矩形的功能块既可以报告数字，也可以报告字符串。
- en: Hexagon and rounded-rectangle slots take only function blocks of the same shape,
    while a rectangular slot will accept any function block. The good news is that
    Scratch prevents you from mismatching types, so you don’t have to memorize this
    rule. Try dragging a hexagon-shaped block into a rounded-rectangle slot; you won’t
    be able to drop it there because the types are incompatible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形和圆角矩形插槽只接受相同形状的功能块，而矩形插槽可以接受任何功能块。好消息是，Scratch 会阻止你将类型不匹配的块放入插槽，所以你不需要记住这个规则。试着将一个六边形形状的块拖入圆角矩形插槽，你会发现无法放入，因为它们的类型不兼容。
- en: Automatic Data Type Conversion
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动数据类型转换
- en: 'As I mentioned above, a number parameter slot only accepts a rounded-rectangle
    function block. All of the rounded-rectangle function blocks you’ve dealt with
    so far—including **x position**, **y position**, **direction**, **costume #**,
    **size**, **volume**, **tempo**, and so on—report numbers. Therefore, using them
    inside a number slot (like the **move 10 steps** block) isn’t a problem. However,
    some rounded-rectangle function blocks, such as the **answer** block from the
    *Sensing* palette or the **join** block from the *Operators* palette, can hold
    either a number or a string. This brings up an important question: What happens
    if we, for example, insert an **answer** block containing a string into a number
    slot? Fortunately, Scratch automatically tries to convert between data types as
    needed, as illustrated in [Figure 5-2](ch05.html#scratch_automatically_converts_between_d
    "Figure 5-2. Scratch automatically converts between data types based on context.").'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在上面提到的，一个数字参数插槽只能接受圆角矩形功能块。到目前为止，你处理过的所有圆角矩形功能块——包括**x 位置**、**y 位置**、**方向**、**服装编号**、**大小**、**音量**、**节奏**等——都报告数字。因此，将它们放入数字插槽（例如**移动
    10 步**块）并不成问题。然而，一些圆角矩形功能块，如*Sensing*调色板中的**回答**块或*Operators*调色板中的**连接**块，可以包含数字或字符串。这就引出了一个重要问题：如果我们例如将包含字符串的**回答**块插入数字插槽会发生什么呢？幸运的是，Scratch
    会根据需要自动尝试在数据类型之间进行转换，如[图 5-2](ch05.html#scratch_automatically_converts_between_d
    "图 5-2. Scratch 根据上下文自动进行数据类型转换。")所示。
- en: In this example, the user enters `125` in response to the Enter a number prompt.
    The user’s input is saved in the **answer** function block. When this input is
    passed to the **say** command, it is automatically converted to a string. When
    the same answer is passed to the addition operation (which expects a number),
    it is converted to the number 125\. When the addition operation is performed,
    the result (25 + 125 = 150) is converted back to a string, and “150” is passed
    to the **say** block. Scratch automatically attempts to take care of these conversions
    for you.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户在“请输入一个数字”提示下输入了`125`。用户的输入被保存在**回答**功能块中。当这个输入传递给**说**命令时，它会自动转换为字符串。当相同的回答传递给加法运算（需要数字）时，它会转换为数字125。当加法运算执行时，结果（25
    + 125 = 150）会被转换回字符串，“150”会被传递到**说**块中。Scratch 会自动尝试为你处理这些转换。
- en: '![Scratch automatically converts between data types based on context.](httpatomoreillycomsourcenostarchimages2134561.png.jpg)Figure 5-2. Scratch
    automatically converts between data types based on context.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![Scratch 根据上下文自动进行数据类型转换。](httpatomoreillycomsourcenostarchimages2134561.png.jpg)图
    5-2. Scratch 根据上下文自动进行数据类型转换。'
- en: Understanding the data types available in Scratch, the operations permitted
    on these types, and how Scratch converts between them will help you understand
    why things work the way they do. In the next section, you’ll learn about variables
    and how to use them to store and manipulate data in your programs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Scratch 中可用的数据类型、对这些类型允许的操作，以及 Scratch 如何在它们之间进行转换，将帮助你理解为什么事物以这种方式运作。在下一部分，你将学习变量，以及如何使用变量来存储和操作程序中的数据。
- en: Introduction to Variables
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量简介
- en: Let’s say we want to create a software version of the game Whac-a-Mole. The
    original game has a flat surface with several holes. The player uses a mallet
    to smack moles as they pop out of these holes. In our version, a sprite appears
    at a random location on the Stage, stays visible for a short time, and disappears.
    It waits a bit, and then appears again at a different location. The player needs
    to click on the sprite as soon as it appears. Every time he clicks on the sprite,
    he gains one point. The question for you as a programmer is, how do you keep track
    of the player’s score? Welcome to the world of variables!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想创建一个软件版本的“打地鼠”游戏。原版游戏有一个平坦的表面，表面上有几个洞。玩家使用槌子打出洞口的地鼠。在我们的版本中，一个角色精灵会随机出现在舞台上的某个位置，保持可见一段时间后消失。然后它会等一会儿，再出现在另一个位置。玩家需要在精灵出现时尽快点击它。每次点击精灵，玩家就得一分。作为程序员，你面临的问题是，如何追踪玩家的分数？欢迎进入变量的世界！
- en: In this section, I’ll introduce variables, one of the most important elements
    of any programming language. You’ll learn how to create variables in Scratch and
    how to use them to remember (or store) different types of data. You’ll also explore
    the available blocks for setting and changing the values of variables in your
    programs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍变量，这是任何编程语言中最重要的元素之一。你将学习如何在 Scratch 中创建变量，并如何使用它们来记住（或存储）不同类型的数据。你还将探索在程序中设置和更改变量值的可用块。
- en: What Is a Variable?
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是变量？
- en: A *variable* is a named area of computer memory. You can think of it as a box
    that stores data, including numbers and text, for a program to access as needed.
    In [Figure 5-3](ch05.html#variable_is_like_a_named_box_that_contai "Figure 5-3. A
    variable is like a named box that contains some value."), for example, we depict
    a variable named `side` whose current value is 50.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量* 是计算机内存中一个命名的区域。你可以把它看作是一个用来存储数据的框，包括数字和文本，供程序根据需要访问。在[图 5-3](ch05.html#variable_is_like_a_named_box_that_contai
    "图 5-3. 变量就像一个命名的框，里面包含一些值。")中，我们展示了一个名为 `side` 的变量，它的当前值是 50。'
- en: '![A variable is like a named box that contains some value.](httpatomoreillycomsourcenostarchimages2134563.png.jpg)Figure 5-3. A
    variable is like a named box that contains some value.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![变量就像一个命名的框，里面包含一些值。](httpatomoreillycomsourcenostarchimages2134563.png.jpg)图
    5-3. 变量就像一个命名的框，里面包含一些值。'
- en: When you create a variable, your program sets aside enough memory to hold the
    value of the variable and tags the allocated memory with that variable’s name.
    After creating a variable, you can use its name in your program to refer to the
    value it represents. For example, if we have a box (that is, a variable) named
    `side` that contains the number 50, we can construct a command such as **move
    (3*side) steps**. When Scratch executes this command, it will locate the box named
    `side` in computer memory, grab its contents (in this case, the number 50), and
    use that value to replace the `side` label inside the **move (3*side) steps**
    block. As a result, the sprite will move 150 (that is, 3 × 50) steps.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量时，你的程序会分配足够的内存来存储变量的值，并用该变量的名称标记分配的内存。创建变量后，你可以在程序中使用它的名称来引用它所代表的值。例如，如果我们有一个名为
    `side` 的框（即变量），它的值是 50，我们可以构建一个像 **移动 (3*side) 步** 的命令。当 Scratch 执行这个命令时，它会在计算机内存中找到名为
    `side` 的框，取出其中的内容（在这个例子中是数字 50），并用这个值替换 **移动 (3*side) 步** 块中的 `side` 标签。结果，精灵将移动
    150 步（即 3 × 50）。
- en: In our Whac-a-Mole game, we need a way to remember the player’s score. To do
    that, we can reserve some space in the computer’s memory (like a box) to store
    the score. We also need to give that box a unique label, let’s say `score`, which
    will let us find it whenever we need to know or change what’s inside.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的打地鼠游戏中，我们需要一种方法来记住玩家的得分。为此，我们可以在计算机的内存中预留一些空间（就像一个框）来存储得分。我们还需要给这个框一个唯一的标签，比如
    `score`，这样我们就可以在需要知道或更改其中内容时找到它。
- en: When the game starts, we’ll tell Scratch to “set `score` to 0,” and Scratch
    will look for the box labeled `score` and put the value 0 inside it. We’ll also
    tell Scratch to “increase `score` by 1” any time the player clicks on the sprite.
    In response to the first click, Scratch will look inside the `score` box again,
    find our 0, add 1 to it, and put the result (which is 1) back in the box. The
    next time the player clicks on the sprite, Scratch will again follow our “increase
    `score` by 1” command to increment `score` and store the resulting value of 2
    in the box.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，我们会告诉 Scratch “将 `score` 设置为 0”，Scratch 会查找标记为 `score` 的框，并将 0 这个值放入其中。每当玩家点击精灵时，我们还会告诉
    Scratch “将 `score` 增加 1”。第一次点击时，Scratch 会再次查看 `score` 框，找到我们的 0，增加 1，并将结果（即 1）放回框中。下次玩家点击精灵时，Scratch
    会再次按照我们的“将 `score` 增加 1”命令来增加 `score`，并将结果值 2 存入框中。
- en: You’ll see the actual Scratch blocks for these operations in a moment. For now,
    notice that the value of `score` changes throughout the program. This is why we
    call it a *variable*—its value varies.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你稍后会看到这些操作的实际 Scratch 块。现在，请注意 `score` 的值在程序中是会变化的。这就是为什么我们称其为 *变量*——它的值是可变的。
- en: One important use of variables is to store the intermediary results of evaluating
    an algebraic expression. This is similar to the way you do mental math. For example,
    if you were asked to find 2 + 4 + 5 + 7, you might start by adding 2 + 4 and memorizing
    the answer (6). You’d then add 5 to the previous answer (which is stored in your
    memory) and memorize the new answer, which is 11. Finally, you’d add 7 to the
    previous result to get the final answer of 18.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的一个重要用途是存储评估代数表达式的中间结果。这类似于你做心算的方式。例如，如果让你计算2 + 4 + 5 + 7，你可能会先将2 + 4相加，并记住结果（6）。然后你会将5加到之前的结果（保存在你的记忆中），并记住新结果，即11。最后，你会将7加到之前的结果，得到最终结果18。
- en: 'To illustrate how variables can be used for temporary storage, let’s say that
    you want to write a program to compute the following expression:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明变量如何用于临时存储，假设你想编写一个程序来计算以下表达式：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134565.png.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134565.png.jpg)'
- en: 'You could evaluate the whole thing with one command, but cramming everything
    into one statement makes it hard to read, as shown below:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用一个命令来评估整个表达式，但将所有内容塞进一个语句中会让它变得很难阅读，如下所示：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134567.png.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134567.png.jpg)'
- en: Another way to write the program is to evaluate the numerator and denominator
    individually and then use the **say** block to display the result of their division.
    We can do that by creating two variables called `num` (for numerator) and `den`
    (for denominator) and setting their values as shown in [Figure 5-4](ch05.html#two_variables_left_parenthesisnum_and_de
    "Figure 5-4. Two variables (num and den) hold the value of the expression’s numerator
    and denominator, respectively.").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种编写程序的方式是分别评估分子和分母，然后使用**say**块显示它们相除的结果。我们可以通过创建两个变量来做到这一点，分别命名为`num`（用于分子）和`den`（用于分母），并设置它们的值，如[图5-4](ch05.html#two_variables_left_parenthesisnum_and_de
    "图5-4。两个变量（num和den）分别保存表达式的分子和分母的值。")所示。
- en: '![Two variables (num and den) hold the value of the expression’s numerator
    and denominator, respectively.](httpatomoreillycomsourcenostarchimages2134569.png.jpg)Figure 5-4. Two
    variables (*`num`* and *`den`*) hold the value of the expression’s numerator and
    denominator, respectively.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![两个变量（`num`和`den`）分别保存表达式的分子和分母的值。](httpatomoreillycomsourcenostarchimages2134569.png.jpg)图5-4。两个变量（*`num`*和*`den`*）分别保存表达式的分子和分母的值。'
- en: Take a look at how our variables are arranged in computer memory. Here, `num`
    is like a tag referring to the location in memory where the result of evaluating
    (1 / 5 + 5 / 7) is stored. Similarly, `den` refers to where (7 / 8 – 2 / 3) is
    stored. When the **say** command is executed, Scratch grabs the contents of memory
    labeled `num` and `den`. It then divides the two numbers and passes the result
    to the **say** command for display.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们在计算机内存中如何安排这些变量。在这里，`num`就像一个标签，指向存储评估（1 / 5 + 5 / 7）结果的内存位置。同样，`den`指向存储（7
    / 8 – 2 / 3）结果的位置。当**say**命令执行时，Scratch会获取标记为`num`和`den`的内存内容。然后，它会将这两个数字相除，并将结果传递给**say**命令进行显示。
- en: We could break this expression down even further by evaluating each fraction
    individually before displaying the result of the total expression, as shown in
    [Figure 5-5](ch05.html#using_four_variables_left_parenthesisaco "Figure 5-5. Using
    four variables (a, b, c, and d) to hold the four fractions in the expression").
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步拆解这个表达式，分别评估每个分数，然后显示总表达式的结果，如[图5-5](ch05.html#using_four_variables_left_parenthesisaco
    "图5-5。使用四个变量（a、b、c和d）来保存表达式中的四个分数")所示。
- en: '![Using four variables (a, b, c, and d) to hold the four fractions in the expression](httpatomoreillycomsourcenostarchimages2134571.png.jpg)Figure 5-5. Using
    four variables (*`a`, `b`, `c`*, and *`d`*) to hold the four fractions in the
    expression'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用四个变量（a、b、c和d）来保存表达式中的四个分数](httpatomoreillycomsourcenostarchimages2134571.png.jpg)图5-5。使用四个变量（*`a`*、*`b`*、*`c`*和*`d`*）来保存表达式中的四个分数'
- en: Here, we use four variables (named `a`, `b`, `c`, and `d`) to hold the four
    fractions in our mathematical expression. The figure also depicts the memory allocation;
    this time, you can see four variables and their contents.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用四个变量（命名为`a`、`b`、`c`和`d`）来保存数学表达式中的四个分数。图中还显示了内存分配；这次你可以看到四个变量及其内容。
- en: Although these three programs give the same answer, each implementation follows
    a different style. The first program puts everything in one statement, which is
    tough to read. The third program breaks things down to a greater level of detail,
    but that can be hard to read, too. The second solution breaks the expression down
    to a reasonable level and uses variables to both make the program easier to understand
    and clearly show the major parts of the expression (the numerator and the denominator).
    As Goldilocks would say, this one is just right.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这三个程序得出了相同的答案，但每种实现方式都有不同的风格。第一个程序将所有内容放在一条语句中，这使得它难以阅读。第三个程序将内容拆解得更为详细，但这样也可能让人难以理解。第二种解决方案将表达式分解到一个合理的层次，并使用变量来使程序更易于理解，同时清晰地展示表达式的主要部分（分子和分母）。正如金发姑娘所说，这种方法恰到好处。
- en: This simple example demonstrates how a problem can have multiple solutions.
    Sometimes you might be concerned about a program’s speed or size, and other times
    your goal might be readability. Since this is an introductory programming book,
    the scripts in this book are written to emphasize readability.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例展示了一个问题可以有多个解决方案。有时你可能关注程序的速度或大小，其他时候你的目标可能是可读性。由于这是一本入门编程书籍，书中的脚本是为了强调可读性而编写的。
- en: Now that you understand what variables are and why you’d want to use them, let’s
    make some variables and take our Scratch applications a step further.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了变量是什么以及为什么要使用它们，让我们创建一些变量，并将我们的 Scratch 应用程序更进一步。
- en: Creating and Using Variables
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和使用变量
- en: '*DiceSimulator_NoCode.sb2*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*DiceSimulator_NoCode.sb2*'
- en: In this section, we’ll explore how to create and use variables through a simple
    application that simulates rolling a pair of dice and displays their sum, as illustrated
    in [Figure 5-6](ch05.html#user_interface_of_the_dice_simulator "Figure 5-6. The
    user interface of the dice simulator").
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将通过一个简单的应用程序来探索如何创建和使用变量，该应用程序模拟掷一对骰子并显示它们的总和，如[图 5-6](ch05.html#user_interface_of_the_dice_simulator
    "图 5-6. 骰子模拟器的用户界面")所示。
- en: '![The user interface of the dice simulator](httpatomoreillycomsourcenostarchimages2134573.png.jpg)Figure 5-6. The
    user interface of the dice simulator'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![骰子模拟器的用户界面](httpatomoreillycomsourcenostarchimages2134573.png.jpg)图 5-6.
    骰子模拟器的用户界面'
- en: 'Our dice simulator contains three sprites: `Player`, `Die1`, and `Die2`. The
    `Player` sprite manages the simulation. When the green flag icon is pressed, this
    sprite generates two random numbers between 1 and 6 and saves those values in
    two variables named `rand1` and `rand2`, respectively. It then broadcasts a message
    to the other two sprites (`Die1` and `Die2`) to show the randomly generated values;
    `Die1` will show the value of `rand1`, and `Die2` will show `rand2`. After that,
    the `Player` sprite adds `rand1` to `rand2` and displays the sum using the **say**
    block.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的骰子模拟器包含三个精灵：`Player`、`Die1` 和 `Die2`。`Player` 精灵管理模拟过程。当按下绿色旗帜图标时，该精灵生成两个介于
    1 和 6 之间的随机数，并将这些值分别保存在名为 `rand1` 和 `rand2` 的两个变量中。接着，它会向另外两个精灵（`Die1` 和 `Die2`）广播消息，显示随机生成的值；`Die1`
    显示 `rand1` 的值，`Die2` 显示 `rand2` 的值。之后，`Player` 精灵将 `rand1` 和 `rand2` 相加，并使用 **say**
    块显示总和。
- en: Let’s build this application from the ground up. Open the file *DiceSimulator_NoCode.sb2*.
    This file contains the background image for the Stage as well as the three sprites
    used in the application. We’ll create all the scripts we need one at a time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头开始构建这个应用程序。打开文件 *DiceSimulator_NoCode.sb2*。该文件包含了舞台的背景图像以及应用程序中使用的三个精灵。我们将逐步创建所需的所有脚本。
- en: First, click the thumbnail of the `Player` sprite to select it. Select the *Data*
    palette and click **Make a Variable**, as shown in [Figure 5-7](ch05.html#creating_a_variablecomma_naming_itcomma
    "Figure 5-7. Creating a variable, naming it, and specifying its scope") (left).
    In the dialog that appears, as shown in [Figure 5-7](ch05.html#creating_a_variablecomma_naming_itcomma
    "Figure 5-7. Creating a variable, naming it, and specifying its scope") (right),
    type the name of the variable and select its scope. A variable’s *scope* determines
    which sprites can write to (or change the value of) that variable, as I will explain
    in more detail in the next section. For this example, enter `rand1` for the variable’s
    name and select the **For all sprites** option for the variable’s scope. Click
    **OK** when done.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，点击 `Player` 精灵的缩略图以选择它。选择 *数据* 面板并点击 **创建变量**，如[图 5-7](ch05.html#creating_a_variablecomma_naming_itcomma
    "图 5-7. 创建一个变量，命名它，并指定它的作用范围")（左）所示。在弹出的对话框中，如[图 5-7](ch05.html#creating_a_variablecomma_naming_itcomma
    "图 5-7. 创建一个变量，命名它，并指定它的作用范围")（右）所示，输入变量的名称并选择其作用范围。一个变量的 *作用范围* 决定了哪些精灵可以写入（或更改）该变量的值，下一节中我会详细解释这一点。在此示例中，输入
    `rand1` 作为变量的名称，并选择 **对所有精灵有效** 选项作为变量的作用范围。完成后点击 **确定**。
- en: '![Creating a variable, naming it, and specifying its scope](httpatomoreillycomsourcenostarchimages2134575.png.jpg)Figure 5-7. Creating
    a variable, naming it, and specifying its scope'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![创建一个变量，命名它，并指定它的作用范围](httpatomoreillycomsourcenostarchimages2134575.png.jpg)图
    5-7. 创建一个变量，命名它，并指定它的作用范围'
- en: After you create the variable, several new blocks related to it will appear
    in the *Data* palette, as illustrated in [Figure 5-8](ch05.html#new_blocks_that_appear_when_you_create_t
    "Figure 5-8. The new blocks that appear when you create the rand1 variable").
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建变量后，与其相关的几个新块将出现在 *数据* 面板中，如[图 5-8](ch05.html#new_blocks_that_appear_when_you_create_t
    "图 5-8. 创建 `rand1` 变量时出现的新块")所示。
- en: '![The new blocks that appear when you create the rand1 variable](httpatomoreillycomsourcenostarchimages2134577.png.jpg)Figure 5-8. The
    new blocks that appear when you create the *`rand1`* variable'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![创建 `rand1` 变量时出现的新块](httpatomoreillycomsourcenostarchimages2134577.png.jpg)图
    5-8. 创建 `rand1` 变量时出现的新块'
- en: You can use these blocks to set a variable to a specific value, change it by
    a fixed amount, and show (or hide) its monitor on the Stage. A variable’s *monitor*,
    as you’ll learn in [Displaying Variable Monitors](ch05.html#displaying_variable_monitors
    "Displaying Variable Monitors"), displays the current value stored in that variable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些块将变量设置为特定值、按固定值更改它，并在舞台上显示（或隐藏）其监视器。一个变量的 *监视器*，正如你将在[显示变量监视器](ch05.html#displaying_variable_monitors
    "显示变量监视器")一节中学习到的那样，显示存储在该变量中的当前值。
- en: Naming Variables
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 命名变量
- en: Over the years, people have come up with different ways to name the variables
    in their programs. One popular convention is to start the name with a lowercase
    letter and capitalize the first letter of each additional word, such as in `sideLength`,
    `firstName`, and `interestRate`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，人们提出了不同的方式来命名程序中的变量。一个常见的约定是变量名以小写字母开头，后续单词的首字母大写，例如 `sideLength`、`firstName`
    和 `interestRate`。
- en: Although Scratch allows variable names to start with numbers and contain white
    spaces (for example, `123Side` or `side length`), most programming languages don’t,
    so I recommend that you avoid these unusual names for your variables. And while
    you can name a variable anything you want, I highly recommend using descriptive
    and meaningful names. Single-letter variables like `w` and `z` should be kept
    to a minimum unless their meaning is very clear. On the other hand, names that
    are too long can make your script harder to read.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Scratch 允许变量名以数字开头并包含空格（例如，`123Side` 或 `side length`），但大多数编程语言不允许这样，因此我建议你避免使用这些不寻常的变量名。虽然你可以给变量命名任何你想要的名称，但我强烈建议使用描述性且有意义的名称。像
    `w` 和 `z` 这样的单字母变量应尽量减少使用，除非它们的含义非常明确。另一方面，过长的名称可能会让你的脚本更难阅读。
- en: Also, note that variable names in Scratch are case sensitive, meaning that `side`,
    `SIDE`, and `siDE` are all unique variables. To avoid confusion, try not to use
    variables in the same script whose names differ only in case.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，在 Scratch 中，变量名是区分大小写的，这意味着 `side`、`SIDE` 和 `siDE` 都是不同的变量。为了避免混淆，尽量不要在同一脚本中使用名字仅在大小写上有所不同的变量。
- en: Repeat the procedure I outlined above to create another variable, named `rand2`.
    The *Data* palette should now contain a second variable block (named `rand2`),
    and the down arrows on the blocks of [Figure 5-8](ch05.html#new_blocks_that_appear_when_you_create_t
    "Figure 5-8. The new blocks that appear when you create the rand1 variable") should
    let you choose between `rand1` and `rand2`. Now that we’ve created the two variables,
    we can build the script for the `Player` sprite. The complete script is shown
    in [Figure 5-9](ch05.html#script_for_the_player_sprite "Figure 5-9. The script
    for the Player sprite").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我上面描述的步骤，创建一个名为`rand2`的变量。*数据*调色板现在应该包含第二个变量积木（名为`rand2`），并且[图5-8](ch05.html#new_blocks_that_appear_when_you_create_t
    "图5-8. 创建rand1变量时出现的新积木")中的下拉箭头应该让您在`rand1`和`rand2`之间进行选择。现在我们已经创建了两个变量，我们可以为`Player`角色构建脚本。完整的脚本显示在[图5-9](ch05.html#script_for_the_player_sprite
    "图5-9. Player角色的脚本")中。
- en: '![The script for the Player sprite](httpatomoreillycomsourcenostarchimages2134579.png.jpg)Figure 5-9. The
    script for the *`Player`* sprite'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![Player角色的脚本](httpatomoreillycomsourcenostarchimages2134579.png.jpg)图5-9.
    *`Player`*角色的脚本'
- en: 'The first command sets `rand1` to a random number between 1 and 6. Think back
    to our box analogy: This command causes the sprite to find the box labeled `rand1`
    and put the generated random number inside it. The second command assigns `rand2`
    another random value between 1 and 6\. Next, the script broadcasts a message called
    `Roll` to the other two sprites (`Die1` and `Die2`) to notify them that they need
    to switch their costumes as specified by `rand1` and `rand2`. Once the `Die1`
    and `Die2` sprites have finished their job, the script resumes and displays the
    sum of the numbers on the faces of the dice using the **say** block. Let’s look
    at the `Roll` message handler for the `Die1` sprite, shown in [Figure 5-10](ch05.html#to_use_a_variable_in_a_command_blockcomm
    "Figure 5-10. To use a variable in a command block, just drag that variable over
    the parameter slot of that block.").'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令将`rand1`设置为1到6之间的随机数字。回想一下我们用盒子做类比的情况：这个命令使得角色找到标记为`rand1`的盒子，并将生成的随机数字放入其中。第二个命令将`rand2`设置为另一个1到6之间的随机值。接下来，脚本会广播一个名为`Roll`的消息给其他两个角色（`Die1`和`Die2`），通知它们需要按照`rand1`和`rand2`的指定来切换服装。一旦`Die1`和`Die2`角色完成任务，脚本将继续执行并通过**说**积木显示骰子面上的数字总和。让我们来看一下`Die1`角色的`Roll`消息处理程序，见[图5-10](ch05.html#to_use_a_variable_in_a_command_blockcomm
    "图5-10. 使用变量在命令积木中的方法")。
- en: '![To use a variable in a command block, just drag that variable over the parameter
    slot of that block.](httpatomoreillycomsourcenostarchimages2134581.png.jpg)Figure 5-10. To
    use a variable in a command block, just drag that variable over the parameter
    slot of that block.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![要在命令积木中使用变量，只需将该变量拖动到该积木的参数槽中。](httpatomoreillycomsourcenostarchimages2134581.png.jpg)图5-10.
    要在命令积木中使用变量，只需将该变量拖动到该积木的参数槽中。'
- en: After creating the script shown at the top right of the figure, drag the `rand1`
    block from the *Data* palette to the parameter slot of the **switch to costume**
    block to form the complete script (bottom right). In this script, the **repeat**
    block changes the costume of the die randomly 20 times to simulate rolling the
    die (you can change this number if you want). After that, the die sets its costume
    to the number specified by `rand1`. Recall that each die has six costumes that
    correspond to numbers 1 through 6 in order. That means if `rand1` were 5, the
    last **switch to costume** command would display the costume that has five dots
    in it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在图右上角创建如示的脚本后，将`rand1`积木从*数据*调色板拖动到**切换服装**积木的参数槽中，形成完整的脚本（右下角）。在这个脚本中，**重复**积木会将骰子的服装随机改变20次，以模拟掷骰子的过程（如果需要，您可以更改这个数字）。之后，骰子将其服装设置为由`rand1`指定的数字。回忆一下，每个骰子有六种服装，分别对应数字1到6。这意味着，如果`rand1`是5，那么最后的**切换服装**命令将显示带有五个点的服装。
- en: Now, we can create the script for the `Die2` sprite, which should be nearly
    identical to the one we made for `Die1`. Since `Die2` changes its costume based
    on `rand2`, all you need to do is duplicate the `Die1` script for `Die2` and replace
    `rand1` with `rand2`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为`Die2`角色创建脚本，这个脚本应该与我们为`Die1`创建的几乎相同。由于`Die2`根据`rand2`来更换服装，您只需要复制`Die1`的脚本到`Die2`，然后将`rand1`替换为`rand2`。
- en: Our dice simulator is now complete, so let’s test it out. Click the green flag
    icon to see the simulation in action. If the application doesn’t work, examine
    the file *DiceSimulator.sb2*, which contains the correct implementation of the
    program.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的骰子模拟器现在已经完成，接下来让我们进行测试。点击绿色旗帜图标，查看模拟效果。如果应用程序无法正常运行，请检查文件*DiceSimulator.sb2*，其中包含正确的程序实现。
- en: Try It Out 5-1
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看 5-1
- en: 'Select the `Player` sprite and create a new variable called `sum`. Set the
    scope for this variable to For this sprite only. Modify the last block of the
    `Player` script to use this new variable, like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`Player`角色，并创建一个名为`sum`的新变量。将此变量的作用域设置为“仅此角色”。修改`Player`脚本的最后一个积木，使用这个新变量，像这样：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134583.png.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2134583.png.jpg)'
- en: Now select the `Die1` (or `Die2`) sprite and look under the *Data* palette.
    Can you explain why you don’t see the `sum` variable there?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择`Die1`（或`Die2`）角色，并查看*数据*调色板。你能解释为什么在那里看不到`sum`变量吗？
- en: The Scope of Variables
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: Another important concept related to variables is *scope*. The scope of a variable
    determines which sprites can write to (or change the value of) that variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量相关的另一个重要概念是*作用域*。变量的作用域决定了哪些角色可以写入（或更改）该变量的值。
- en: '*ScopeDemo.sb2*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*ScopeDemo.sb2*'
- en: You can specify the scope of a variable when you create it by selecting one
    of the two options you saw in [Figure 5-7](ch05.html#creating_a_variablecomma_naming_itcomma
    "Figure 5-7. Creating a variable, naming it, and specifying its scope"). Choosing
    For this sprite only creates a variable that can be changed only by the sprite
    that owns it. Other sprites can still read and use the variable’s value, but they
    can’t write to it. The example shown in [Figure 5-11](ch05.html#only_the_cat_sprite_can_write_to_countdo
    "Figure 5-11. Only the Cat sprite can write to count.") illustrates this point.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在创建变量时指定其作用域，方法是选择在[图 5-7](ch05.html#creating_a_variablecomma_naming_itcomma
    "图 5-7。创建变量、命名并指定作用域")中看到的两种选项之一。选择“仅此角色”会创建一个变量，该变量只能由拥有它的角色进行更改。其他角色仍然可以读取和使用该变量的值，但不能写入它。[图
    5-11](ch05.html#only_the_cat_sprite_can_write_to_countdo "图 5-11。只有猫角色可以写入count.")中的示例说明了这一点。
- en: '![Only the Cat sprite can write to count.](httpatomoreillycomsourcenostarchimages2134585.png.jpg)Figure 5-11. Only
    the *`Cat`* sprite can write to *`count`*.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![只有猫角色可以写入count。](httpatomoreillycomsourcenostarchimages2134585.png.jpg)图
    5-11。只有*`Cat`*角色可以写入*`count`*。'
- en: In this figure, the `Cat` sprite has a variable, named `count`, with the scope
    For this sprite only. The `Penguin` sprite can read `count` with the **x position
    of Penguin** block from the *Sensing* palette. When you select `Cat` as the second
    parameter of this block, the first parameter will let you choose an attribute
    of the `Cat` sprite, including one of its variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`Cat`角色有一个名为`count`的变量，其作用域为“仅此角色”。`Penguin`角色可以使用来自*传感器*调色板的**企鹅的x位置**积木读取`count`。当你选择`Cat`作为此积木的第二个参数时，第一个参数将允许你选择`Cat`角色的一个属性，包括其变量之一。
- en: Scratch, however, doesn’t provide a block that allows the `Penguin` sprite to
    change the `count` variable. This way, the `Penguin` sprite can’t tamper with
    `count` and cause undesirable effects for scripts run by the `Cat` sprite. It’s
    good practice to use the For this sprite only scope for variables that should
    only be updated by a single sprite.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Scratch并没有提供允许`Penguin`角色更改`count`变量的积木。因此，`Penguin`角色无法篡改`count`，避免了对`Cat`角色脚本运行造成不良影响。对于那些只能由单一角色更新的变量，最好使用“仅此角色”作用域。
- en: Variables created with the For this sprite only scope are said to have *local
    scope*, and they can be called *local variables*. Different sprites can use the
    same name for their local variables without any conflict. For example, if you
    have two car sprites in a racing game, each might have a local variable named
    `speed` that determines the car’s speed of motion on the Stage. Each car sprite
    can change its `speed` variable independently of the other. This means that if
    you set the `speed` of the first car to 10 and the `speed` of the second to 20,
    the second car should move faster than the first.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“仅此角色”作用域创建的变量称为*局部作用域*，它们可以称为*局部变量*。不同的角色可以使用相同的名称来命名其局部变量而不会发生冲突。例如，如果你在赛车游戏中有两个赛车角色，每个赛车角色可能都有一个名为`speed`的局部变量，用于决定赛车在舞台上的运动速度。每个赛车角色可以独立更改其`speed`变量。这意味着，如果你将第一辆车的`speed`设置为10，第二辆车的`speed`设置为20，第二辆车应该比第一辆车移动得更快。
- en: Data Type of a Variable
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的数据类型
- en: At this point, you might wonder, “How does Scratch know the data type of a variable?”
    The answer is, it doesn’t! When you create a variable, Scratch has no idea whether
    you intend to use that variable to store to a number, a string, or a Boolean.
    Any variable can hold a value of any data type. For example, all of the following
    commands are valid in Scratch.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你可能会想，“Scratch是如何知道变量的数据类型的？”答案是，它并不知道！当你创建一个变量时，Scratch并不清楚你打算将该变量用于存储数字、字符串还是布尔值。任何变量都可以存储任何数据类型的值。例如，以下所有命令在Scratch中都是有效的。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134587.png.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134587.png.jpg)'
- en: 'It’s up to you to store the correct values in your variables. As I described
    earlier in this chapter, however, Scratch will try to convert between data types
    depending on the context. To see what happens when you store an incorrect data
    type in a variable, consider these two examples:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要自行在变量中存储正确的值。然而，正如我在本章前面所描述的，Scratch会根据上下文尝试在数据类型之间进行转换。要查看当你在变量中存储错误的数据类型时会发生什么，考虑以下两个例子：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134589.png.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134589.png.jpg)'
- en: Since the **move** command expects a number parameter, Scratch will automatically
    try to convert the value stored in the `side` variable to a number before passing
    it to the **move** command. In the first script (left), Scratch can’t convert
    the string “Nonsense” to a number. Rather than showing an error message, Scratch
    will silently set the result of the conversion to 0 and pass this value to the
    **move** command. As a result, the sprite won’t move. On the other hand, in the
    second script (right), Scratch ignores the whitespace in the string and passes
    the resulting number to the **move** block, so the sprite moves 100 steps forward.
    Note that if the target block had expected a string instead of a number, Scratch
    would have passed the string as it was, whitespace included.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**移动**命令期望一个数字参数，Scratch会在将值传递给**移动**命令之前，自动尝试将`side`变量中存储的值转换为数字。在第一个脚本（左边）中，Scratch无法将字符串“胡说八道”转换为数字。Scratch不会显示错误消息，而是默默地将转换结果设置为0，并将此值传递给**移动**命令。结果，精灵不会移动。另一方面，在第二个脚本（右边）中，Scratch忽略了字符串中的空格，并将结果数字传递给**移动**模块，因此精灵向前移动了100步。请注意，如果目标模块期望的是一个字符串而不是数字，Scratch会按原样传递字符串，包括空格。
- en: Variables with the scope For all sprites, on the other hand, can be read and
    changed by any sprite in your application. These variables, often called *global
    variables*, are useful for intersprite communication and synchronization. For
    example, if a game has three buttons that allow the user to select a level to
    play, you can create a global variable named `gameLevel` and have each button
    sprite set this variable to a different number when clicked. Then you can easily
    find out the user’s choice by examining `gameLevel`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，具有“所有精灵”作用域的变量可以被应用程序中的任何精灵读取和更改。这些变量通常被称为*全局变量*，对于精灵之间的通信和同步非常有用。例如，如果一个游戏有三个按钮，允许用户选择要玩的关卡，你可以创建一个名为`gameLevel`的全局变量，并让每个按钮精灵在被点击时将该变量设置为不同的数字。然后，你可以通过检查`gameLevel`轻松找出用户的选择。
- en: 'Selecting the For all sprites option also enables the Cloud variable check-box
    in [Figure 5-7](ch05.html#creating_a_variablecomma_naming_itcomma "Figure 5-7. Creating
    a variable, naming it, and specifying its scope"). This feature allows you to
    store your variables on Scratch’s server (in the cloud). Blocks for cloud variables
    have a small square in front of them to distinguish them from regular variables,
    like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“所有精灵”选项还会在[图5-7](ch05.html#creating_a_variablecomma_naming_itcomma "图5-7.
    创建一个变量，命名它，并指定其作用域")中启用“云变量”复选框。这个功能允许你将变量存储在Scratch的服务器上（云端）。云变量的模块前面有一个小方块，用以与常规变量区分开来，像这样：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134591.png.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134591.png.jpg)'
- en: Anyone who views a project you’ve shared on the Scratch website can read the
    cloud variables in the project. For example, if you share a game, you can use
    a cloud variable to track the highest score recorded among all the players. The
    `score` cloud variable should update almost immediately for everyone interacting
    with your game. Because these variables are stored on Scratch servers, they keep
    their value even if you exit your browser. Cloud variables make it easy to create
    surveys and other projects that store numbers over time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 任何查看你在Scratch网站上分享的项目的人都可以读取该项目中的云变量。例如，如果你分享一个游戏，你可以使用云变量来跟踪所有玩家中记录的最高分。`score`云变量应几乎立即更新，供所有与游戏互动的人查看。因为这些变量存储在Scratch服务器上，即使你退出浏览器，它们的值也会保持不变。云变量使得创建调查和其他需要随时间存储数字的项目变得容易。
- en: Now that you understand scope, it’s time to learn about updating variables—and
    then use that knowledge to create more interesting programs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了作用域，接下来是学习如何更新变量——然后使用这些知识来创建更有趣的程序。
- en: Changing Variables
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改变量
- en: Scratch provides two command blocks that allow you to alter variables. The **set
    to** command directly assigns a new value to a variable, regardless of its current
    contents. The **change by** command, on the other hand, is used to change the
    value of a variable by a specified amount relative to its current value. The three
    scripts in [Figure 5-12](ch05.html#three_methods_for_changing_the_value_of "Figure 5-12. Three
    methods for changing the value of a variable") demonstrate how you could use these
    commands in different ways to achieve the same outcome.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch提供了两个命令模块，可以让你修改变量。**set to**命令直接将一个新值赋给变量，而不管该变量当前的值是什么。另一方面，**change
    by**命令则用于根据变量当前的值，通过指定的数量来改变变量的值。[图5-12](ch05.html#three_methods_for_changing_the_value_of
    "图5-12。更改变量值的三种方法")中的三个脚本演示了如何使用这些命令以不同方式实现相同的结果。
- en: '![Three methods for changing the value of a variable](httpatomoreillycomsourcenostarchimages2134593.png.jpg)Figure 5-12. Three
    methods for changing the value of a variable'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![更改变量值的三种方法](httpatomoreillycomsourcenostarchimages2134593.png.jpg)图5-12。更改变量值的三种方法'
- en: All three scripts in the figure start by setting the values of two variables,
    `sum` and `delta`, to 0 and 5, respectively. The first script uses the **change**
    command to change the value of `sum` by the value of `delta` (that is, from 0
    to 5). The second script uses the **set** command to add the current value of
    `sum` to the value of `delta` (0 + 5) and store the result (5) back into `sum`.
    The third script achieves the same result with the aid of a temporary variable
    named `temp`. It adds the value of `sum` to `delta`, stores the result in `temp`,
    and finally copies the value of `temp` into `sum`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的三个脚本都首先将两个变量`sum`和`delta`的值分别设置为0和5。第一个脚本使用**change**命令通过`delta`的值改变`sum`的值（即，从0变为5）。第二个脚本使用**set**命令将当前`sum`的值加上`delta`的值（0
    + 5），并将结果（5）存回`sum`。第三个脚本借助一个名为`temp`的临时变量实现相同的结果。它将`sum`的值加到`delta`上，将结果存储在`temp`中，最后将`temp`的值复制到`sum`中。
- en: After executing any of the scripts in [Figure 5-12](ch05.html#three_methods_for_changing_the_value_of
    "Figure 5-12. Three methods for changing the value of a variable"), `sum` will
    contain the number 5, making these scripts functionally equivalent. Note that
    the method used in the second script is a common programming practice, and I recommend
    that you study it for a moment to become comfortable with it. Now let’s see the
    **change** command in action.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 执行[图5-12](ch05.html#three_methods_for_changing_the_value_of "图5-12。更改变量值的三种方法")中的任何脚本后，`sum`将包含数字5，因此这些脚本在功能上是等效的。请注意，第二个脚本中使用的方法是一种常见的编程实践，我建议你花一点时间研究它，熟悉这一方法。现在，让我们看看**change**命令的实际应用。
- en: Spider Web
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 蜘蛛网
- en: '*SpiderWeb.sb2*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*SpiderWeb.sb2*'
- en: We can create a spider web by drawing several hexagons of increasing size, as
    shown in [Figure 5-13](ch05.html#creating_a_spider_web_by_drawing_several "Figure 5-13. Creating
    a spider web by drawing several hexagons of increasing size"). The **Triangle**
    procedure draws an equilateral triangle with a variable side length, while the
    **Hexagon** procedure calls **Triangle** six times with a 60° (that is, 360° /
    6) right turn after each call. The figure clearly shows how the hexagon is made
    up of the six triangles.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过绘制几个逐渐增大的六边形来创建一个蜘蛛网，如[图 5-13](ch05.html#creating_a_spider_web_by_drawing_several
    "图 5-13. 通过绘制几个逐渐增大的六边形来创建蜘蛛网")所示。**Triangle** 程序绘制一个边长可变的等边三角形，而 **Hexagon**
    程序则调用 **Triangle** 六次，每次调用后右转 60°（即 360° / 6）。该图清楚地展示了六边形是如何由六个三角形组成的。
- en: '![Creating a spider web by drawing several hexagons of increasing size](httpatomoreillycomsourcenostarchimages2134595.png.jpg)Figure 5-13. Creating
    a spider web by drawing several hexagons of increasing size'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过绘制几个逐渐增大的六边形来创建蜘蛛网](httpatomoreillycomsourcenostarchimages2134595.png.jpg)图
    5-13. 通过绘制几个逐渐增大的六边形来创建蜘蛛网'
- en: The **SpiderWeb** procedure simply calls **Hexagon** repeatedly with a different
    value of the `sideLength` variable each time. This results in the concentric (that
    is, having the same center) hexagons you see in the figure. Note how the **change**
    command is used to set the value of `sideLength` inside the **repeat** loop. Reproduce
    the **SpiderWeb** procedure, run it, and see how it works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**SpiderWeb** 程序仅仅是重复调用 **Hexagon**，每次传递不同的 `sideLength` 变量值。这就产生了你在图中看到的同心六边形（即具有相同中心）。注意在
    **repeat** 循环内部如何使用 **change** 命令来设置 `sideLength` 的值。复现 **SpiderWeb** 程序，运行它，看看它是如何工作的。'
- en: Pinwheel
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pinwheel
- en: '*Pinwheel.sb2*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pinwheel.sb2*'
- en: This example is similar to the previous one except that this time, we’ll use
    a variable to control the number of triangular repetitions. The resulting procedure
    (called **Pins**) is shown in [Figure 5-14](ch05.html#creating_a_pinwheel_by_rotating_an_equil
    "Figure 5-14. Creating a pinwheel by rotating an equilateral triangle several
    times"). The **Pinwheel** procedure in the same figure works like the **SpiderWeb**
    procedure above, but we also change the pen’s color each time through the loop
    for a fun rainbow effect. Some outputs of the **Pinwheel** procedure for different
    pin counts are shown in the figure. Experiment with this procedure to see what
    else you can create.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与前一个类似，唯一不同的是这次我们将使用一个变量来控制三角形重复的次数。最终的程序（称为 **Pins**）如[图 5-14](ch05.html#creating_a_pinwheel_by_rotating_an_equil
    "图 5-14. 通过旋转等边三角形多次创建风车")所示。图中的 **Pinwheel** 程序的工作原理与上面的 **SpiderWeb** 程序相似，但我们还在每次循环时改变画笔的颜色，以达到有趣的彩虹效果。图中展示了不同针数下的
    **Pinwheel** 程序输出。试着用这个程序进行实验，看看你还能创造什么。
- en: '![Creating a pinwheel by rotating an equilateral triangle several times](httpatomoreillycomsourcenostarchimages2134597.png.jpg)Figure 5-14. Creating
    a pinwheel by rotating an equilateral triangle several times'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过旋转等边三角形多次创建风车](httpatomoreillycomsourcenostarchimages2134597.png.jpg)图
    5-14. 通过旋转等边三角形多次创建风车'
- en: Now that we’ve explored the fundamentals of variables, you might wonder what
    happens to variables when you duplicate a sprite. Does the duplicate share the
    parent sprite’s variables, or does it have its own copies? Do clones have access
    to global variables? We’ll answer these questions in the next section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了变量的基础知识，你可能会想知道，当你复制一个精灵时，变量会发生什么？复制品是否共享父精灵的变量，还是拥有自己的副本？克隆是否可以访问全局变量？我们将在下一节回答这些问题。
- en: Try It Out 5-2
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下 5-2
- en: Alter the Pinwheel program to hide the sprite. This should make it easier for
    you to watch the drawing without the sprite getting in the way.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 Pinwheel 程序，使精灵隐藏。这应该会让你在观察绘图时不会被精灵阻碍。
- en: Variables in Clones
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 克隆中的变量
- en: Every sprite has a list of properties associated with it, including its current
    *x*-position, *y*-position, direction, and so on. You can imagine that list as
    a backpack holding the current values of the sprite’s attributes, as illustrated
    in [Figure 5-15](ch05.html#clones_inherit_copies_of_their_parentapo "Figure 5-15. Clones
    inherit copies of their parent’s variables"). When you create a variable for a
    sprite with a scope of For this sprite only, that variable gets added to the sprite’s
    backpack.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个精灵都有一份与之相关的属性列表，包括它当前的*x*位置、*y*位置、方向等。你可以将这份列表想象成一个背包，里面装着精灵属性的当前值，如[图5-15](ch05.html#clones_inherit_copies_of_their_parentapo
    "图5-15. 克隆继承父精灵变量的副本")所示。当你为精灵创建一个作用域为“仅此精灵”的变量时，这个变量会被添加到精灵的背包中。
- en: When you clone a sprite, the clone inherits copies of the parent sprite’s attributes,
    including its variables. An inherited property starts out identical to the parent’s
    property at the time the clone is created. But after that, if the clone’s attributes
    and variables change, those changes don’t affect the parent. Subsequent changes
    to the parent sprite don’t affect the clone’s properties, either.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你克隆一个精灵时，克隆会继承父精灵的属性副本，包括它的变量。继承的属性在克隆创建时会与父精灵的属性完全相同。但此后，如果克隆的属性和变量发生变化，这些变化不会影响父精灵。父精灵的后续变化也不会影响克隆的属性。
- en: '![Clones inherit copies of their parent’s variables](httpatomoreillycomsourcenostarchimages2134599.png.jpg)Figure 5-15. Clones
    inherit copies of their parent’s variables'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![克隆继承父精灵的变量副本](httpatomoreillycomsourcenostarchimages2134599.png.jpg)图5-15.
    克隆继承父精灵的变量副本'
- en: To illustrate, let’s say the parent sprite owns a variable named `speed` whose
    current value is 10\. When you clone the parent, the new sprite will also have
    a variable named `speed` with the value 10\. After that, if the parent sprite
    changes `speed` to 20, the value of `speed` in the clone will stay at 10.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设父精灵拥有一个名为`speed`的变量，其当前值为10。当你克隆父精灵时，新的精灵也会有一个名为`speed`的变量，值为10。之后，如果父精灵将`speed`更改为20，克隆中的`speed`值将保持为10。
- en: '*CloneIDs.sb2*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*CloneIDs.sb2*'
- en: You can use this concept to distinguish between clones in your applications.
    For example, let’s look at the program in [Figure 5-16](ch05.html#using_variables_to_distinguish_between_c
    "Figure 5-16. Using variables to distinguish between clones").
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在应用程序中使用这个概念来区分克隆。例如，看看[图5-16](ch05.html#using_variables_to_distinguish_between_c
    "图5-16. 使用变量区分克隆")中的程序。
- en: '![Using variables to distinguish between clones](httpatomoreillycomsourcenostarchimages2134601.png.jpg)Figure 5-16. Using
    variables to distinguish between clones'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用变量区分克隆](httpatomoreillycomsourcenostarchimages2134601.png.jpg)图5-16. 使用变量区分克隆'
- en: The parent sprite in this example owns a variable named `cloneID`. When the
    green flag is clicked, it starts a loop to create three clones, and it sets `cloneID`
    to a different value (1, 2, or 3 in this case) before creating a clone. Each clone
    comes to life with its own copy of `cloneID` initialized to a different value.
    You could now use an **if** block, which we’ll study in depth in the next chapter,
    to check for the clone’s ID and have it perform a corresponding action.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，父精灵拥有一个名为`cloneID`的变量。当点击绿色旗帜时，它会启动一个循环来创建三个克隆，并在创建克隆之前将`cloneID`设置为不同的值（在这个例子中为1、2或3）。每个克隆都会拥有自己的`cloneID`副本，并初始化为不同的值。你现在可以使用**if**语句块，下一章我们将深入学习它，来检查克隆的ID，并让它执行相应的操作。
- en: '*ClonesAndGlobalVars.sb2*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*ClonesAndGlobalVars.sb2*'
- en: Now, let’s discuss how clones can interact with global variables. Recall from
    [Figure 5-15](ch05.html#clones_inherit_copies_of_their_parentapo "Figure 5-15. Clones
    inherit copies of their parent’s variables") that variables with scope For all
    sprites can be read and written by the Stage and all sprites, including clones.
    As an example, the program in [Figure 5-17](ch05.html#using_a_global_variable_to_track_when_cl
    "Figure 5-17. Using a global variable to track when clones are deleted") uses
    this fact to detect when all clones of the parent sprite have disappeared.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论克隆如何与全局变量互动。回想一下[图5-15](ch05.html#clones_inherit_copies_of_their_parentapo
    "图5-15. 克隆继承父精灵变量的副本")，变量的作用范围为“所有精灵”的变量可以被舞台和所有精灵读取和写入，包括克隆。例如，程序[图5-17](ch05.html#using_a_global_variable_to_track_when_cl
    "图5-17. 使用全局变量来追踪克隆何时被删除")就是利用这一点来检测父精灵的所有克隆何时消失。
- en: '![Using a global variable to track when clones are deleted](httpatomoreillycomsourcenostarchimages2134603.png.jpg)Figure 5-17. Using
    a global variable to track when clones are deleted'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用全局变量追踪克隆被删除的时刻](httpatomoreillycomsourcenostarchimages2134603.png.jpg)图5-17.
    使用全局变量追踪克隆被删除的时刻'
- en: In this script, the parent sprite sets the global variable `numClones` to 5
    and creates five clones. It then waits for `numClones` to become 0 before announcing
    the end of the game. The clones appear at random times and locations on the Stage,
    say “Hello!” for two seconds, and then disappear. Before a clone is deleted, it
    decreases `numClones` by 1\. When all five clones are gone, `numClones` reaches
    0, the main script stops waiting, and the original sprite says “Game Over!”
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，父精灵将全局变量`numClones`设为5，并创建了五个克隆。然后，它等待`numClones`变为0，才宣布游戏结束。这些克隆会在舞台上的随机时间和位置出现，喊一声“Hello!”持续两秒钟，然后消失。在一个克隆被删除之前，它会将`numClones`减去1。当所有五个克隆消失后，`numClones`变为0，主脚本停止等待，原始精灵说“Game
    Over!”。
- en: In the following section, you’ll learn about variables’ monitors, which allow
    you to see, and even change, the current values stored in variables. The ability
    to view and change a variable on the Stage will open the door to creating totally
    new kinds of applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，你将学习变量的监视器，它们让你可以看到甚至更改变量当前存储的值。能够在舞台上查看和更改变量，将为你创建全新的应用程序类型打开大门。
- en: Displaying Variable Monitors
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示变量监视器
- en: You’ll often find yourself wanting to see the current value stored in a variable.
    For example, when one of your scripts doesn’t work as expected, you might want
    to track some of its variables to see if they change correctly. Using variable
    monitors can help you with this debugging task.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会发现自己想查看一个变量当前存储的值。例如，当你的某个脚本没有按预期工作时，你可能希望追踪一些变量，看看它们是否正确变化。使用变量监视器可以帮助你完成这个调试任务。
- en: You can display a Scratch variable on the Stage as a *variable monitor*. Checking
    or unchecking the box next to a variable’s name allows you to show or hide a variable’s
    monitor on the Stage, as illustrated in [Figure 5-18](ch05.html#show_a_variableapostrophes_monitor_by_ch
    "Figure 5-18. Show a variable’s monitor by checking the box next to its name.").
    You can also control a monitor’s visibility from within your script with the **show
    variable** and **hide variable** commands.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将Scratch变量显示为*变量监视器*。选中或取消选中变量名称旁边的框，可以在舞台上显示或隐藏变量的监视器，如[图5-18](ch05.html#show_a_variableapostrophes_monitor_by_ch
    "图5-18. 通过勾选名称旁的框来显示变量的监视器")所示。你也可以在脚本中使用**show variable**和**hide variable**命令控制监视器的可见性。
- en: '![Show a variable’s monitor by checking the box next to its name.](httpatomoreillycomsourcenostarchimages2134605.png.jpg)Figure 5-18. Show
    a variable’s monitor by checking the box next to its name.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过勾选名称旁的框来显示变量的监视器](httpatomoreillycomsourcenostarchimages2134605.png.jpg)图5-18.
    通过勾选名称旁的框来显示变量的监视器。'
- en: Monitors can be used as readouts or controls, which display or allow you to
    change a variable’s contents, respectively. Double-click the monitor’s box on
    the Stage to choose a normal readout (the default state), large readout, or slider
    control. When you choose to display a slider, you can set its range by right-clicking
    the slider and selecting the set slider min and max option from the pop-up menu,
    as shown in [Figure 5-19](ch05.html#setting_the_minimum_and_maximum_values_f "Figure 5-19. Setting
    the minimum and maximum values for a monitor in slider mode").
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器可以作为输出或控制使用，分别显示或允许你更改变量的内容。双击舞台上的监视器框可以选择常规输出（默认状态）、大输出或滑块控制。当你选择显示滑块时，可以通过右键点击滑块并从弹出菜单中选择设置滑块最小值和最大值选项来设置其范围，如[图5-19](ch05.html#setting_the_minimum_and_maximum_values_f
    "图5-19. 设置滑块模式下监视器的最小值和最大值")所示。
- en: '![Setting the minimum and maximum values for a monitor in slider mode](httpatomoreillycomsourcenostarchimages2134607.png.jpg)Figure 5-19. Setting
    the minimum and maximum values for a monitor in slider mode'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![设置滑块模式下监视器的最小值和最大值](httpatomoreillycomsourcenostarchimages2134607.png.jpg)图5-19.
    设置滑块模式下监视器的最小值和最大值'
- en: '*StageColor.sb2*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*StageColor.sb2*'
- en: Using a slider allows you to change the value of a variable while a script is
    running, which is a convenient way for users to interact with your application.
    You can see a simple example of using the slider control in [Figure 5-20](ch05.html#adjusting_stage_color_with_a_slider
    "Figure 5-20. Adjusting Stage color with a slider").
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用滑块可以在脚本运行时改变变量的值，这是用户与您的应用程序交互的一种便捷方式。您可以在[图 5-20](ch05.html#adjusting_stage_color_with_a_slider
    "图 5-20. 使用滑块调整舞台颜色")中看到一个使用滑块控制的简单示例。
- en: '![Adjusting Stage color with a slider](httpatomoreillycomsourcenostarchimages2134609.png.jpg)Figure 5-20. Adjusting
    Stage color with a slider'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用滑块调整舞台颜色](httpatomoreillycomsourcenostarchimages2134609.png.jpg)图 5-20.
    使用滑块调整舞台颜色'
- en: In this example, dragging the slider’s handle changes the value of the `stageColor`
    variable, which is a parameter in the **set color effect to** command. Assuming
    this script belongs to the Stage, dragging the slider should change the Stage’s
    background color.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，拖动滑块的滑块柄会改变`stageColor`变量的值，该变量是**设置颜色效果为**命令中的一个参数。假设此脚本属于舞台，拖动滑块应改变舞台的背景颜色。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*A variable’s monitor also indicates its scope. If a variable belongs to one
    sprite, its monitor should show the sprite name before the variable name. For
    example, the monitor* **Cat speed 0** *indicates that* `speed` *belongs to* `Cat`*.
    If the* `speed` *variable were a global variable, its monitor would only say*
    **speed 0***. The difference between the two cases is illustrated in the following
    figure.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个变量的监视器还表示它的作用范围。如果一个变量属于某个角色，它的监视器应在变量名之前显示角色的名称。例如，监视器**Cat speed 0**表示`speed`属于`Cat`。如果`speed`变量是全局变量，那么它的监视器只会显示**speed
    0**。这两种情况的区别如下图所示。*'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134611.png.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages2134611.png.jpg)'
- en: Using Variable Monitors in Applications
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在应用程序中使用变量监视器
- en: Now that you know the basics behind variable monitors, I’ll show you some ways
    you could use them to add some extra functionality to your Scratch applications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了变量监视器的基础，我将向您展示一些使用它们为您的 Scratch 应用程序增加额外功能的方法。
- en: The ability to use monitors as both displays and controls opens the door for
    a wide range of applications, including games, simulations, and interactive programs.
    Let’s explore some examples that make use of monitors in the following subsections.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显示器作为显示器和控制器的功能为广泛的应用程序开辟了大门，包括游戏、模拟和交互式程序。接下来让我们在以下小节中探索一些利用显示器的例子。
- en: Simulating Ohm’s Law
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟欧姆定律
- en: '*OhmsLaw.sb2*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*OhmsLaw.sb2*'
- en: 'Our first example is a simulation of Ohm’s law. When a voltage (*V*) is applied
    across a resistor (*R*), a current (*I*) will flow through that resistor. According
    to Ohm’s law, the amount of current is given by this equation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例是欧姆定律的模拟。当电压（*V*）加在电阻（*R*）上时，会有电流（*I*）通过该电阻。根据欧姆定律，电流的大小由以下公式给出：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134613.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages2134613.png.jpg)'
- en: Our application allows the user to change the values of *V* and *R* using slider
    controls. Then it calculates and displays the corresponding value of the current,
    *I*. The user interface for this application is shown in [Figure 5-21](ch05.html#user_interface_for_the_ohmapostrophes_la
    "Figure 5-21. User interface for the Ohm’s law application").
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序允许用户使用滑块控制来改变*V*和*R*的值。然后，它会计算并显示相应的电流值*I*。此应用程序的用户界面显示在[图 5-21](ch05.html#user_interface_for_the_ohmapostrophes_la
    "图 5-21. 欧姆定律应用的用户界面")中。
- en: '![User interface for the Ohm’s law application](httpatomoreillycomsourcenostarchimages2134615.png.jpg)Figure 5-21. User
    interface for the Ohm’s law application'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![欧姆定律应用的用户界面](httpatomoreillycomsourcenostarchimages2134615.png.jpg)图 5-21.
    欧姆定律应用的用户界面'
- en: 'The slider for the battery voltage (*V)* has a range of [0, 10], and the slider
    for the resistor (*R*) has a range of [1, 10]. When the user changes *V* or *R*
    with the sliders, the application calculates the corresponding value of the current
    (*I*) that flows in the circuit. The brightness of the bulb changes in proportion
    to the value of the current passing through it: The higher the current, the brighter
    the light bulb. The sizes of the *V*, *I*, and *R* letters in the figure also
    change to indicate the relative values of these quantities.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 电池电压滑动条（*V*）的范围是[0, 10]，而电阻滑动条（*R*）的范围是[1, 10]。当用户通过滑动条改变*V*或*R*时，应用计算电路中流动的电流（*I*）的对应值。灯泡的亮度与通过它的电流值成正比：电流越大，灯泡越亮。图中*V*、*I*和*R*字母的大小也会变化，以表示这些量的相对值。
- en: In total, the application has five sprites (named `Volt`, `Current`, `Resistance`,
    `Equal`, and `Light`) and three variables (named `V`, `I`, and `R`). Everything
    else you see in [Figure 5-21](ch05.html#user_interface_for_the_ohmapostrophes_la
    "Figure 5-21. User interface for the Ohm’s law application") (the battery, wires,
    socket, and so on) is part of the Stage’s backdrop image. The main script that
    drives the application, which belongs to the Stage, is shown [Figure 5-22](ch05.html#main_script_of_ohmapostrophes_law_applic
    "Figure 5-22. Main script of Ohm’s law application").
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，应用有五个角色（命名为`Volt`、`Current`、`Resistance`、`Equal`和`Light`）和三个变量（命名为`V`、`I`和`R`）。你在[图 5-21](ch05.html#user_interface_for_the_ohmapostrophes_la
    "图 5-21. 欧姆定律应用的用户界面")中看到的其他一切（如电池、电线、插座等）都是舞台背景图的一部分。驱动该应用的主脚本，属于舞台，见[图 5-22](ch05.html#main_script_of_ohmapostrophes_law_applic
    "图 5-22. 欧姆定律应用的主脚本")。
- en: '![Main script of Ohm’s law application](httpatomoreillycomsourcenostarchimages2134617.png.jpg)Figure 5-22. Main
    script of Ohm’s law application'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![欧姆定律应用的主脚本](httpatomoreillycomsourcenostarchimages2134617.png.jpg)图 5-22.
    欧姆定律应用的主脚本'
- en: The script initializes the values of `V` and `R` and then enters an infinite
    loop. On each pass through the loop, it calculates `I` using the present values
    of `V` and `R`, which are set by the user through the slider controls. It then
    broadcasts a message to the other sprites in the application to update their appearance
    in relation to the calculated values. [Figure 5-23](ch05.html#scripts_triggered_in_response_to_the_upd
    "Figure 5-23. Scripts triggered in response to the Update message") shows the
    response of the `Volt`, `Current`, `Resistance`, and `Light` sprites (which show
    the letters *V*, *I*, *R*, and the light bulb, respectively) when they receive
    the `Update` message.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本初始化了`V`和`R`的值，然后进入一个无限循环。在每次循环中，它使用当前由用户通过滑动条控制设置的`V`和`R`值来计算`I`。然后，它广播一条消息给应用中的其他角色，更新它们根据计算结果的外观。[图 5-23](ch05.html#scripts_triggered_in_response_to_the_upd
    "图 5-23. 响应更新消息触发的脚本")显示了当`Volt`、`Current`、`Resistance`和`Light`角色（分别显示字母*V*、*I*、*R*和灯泡）接收到`Update`消息时的反应。
- en: '![Scripts triggered in response to the Update message](httpatomoreillycomsourcenostarchimages2134619.png.jpg)Figure 5-23. Scripts
    triggered in response to the *`Update`* message'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![响应`Update`消息触发的脚本](httpatomoreillycomsourcenostarchimages2134619.png.jpg)图 5-23.
    响应*`Update`*消息触发的脚本'
- en: When the `Update` broadcast is received, the `Volt`, `Current`, and `Resistance`
    sprites change their size (from 100 percent to 200 percent of their original size)
    in relation to the current values of their respective variables. The `Light` sprite
    executes the **set ghost effect to** command to change its transparency level
    in proportion to the value of `I`. This gives the light bulb a realistic visual
    effect that simulates an actual bulb.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到`Update`广播时，`Volt`、`Current`和`Resistance`角色根据各自变量的当前值改变大小（从原始大小的100%到200%）。`Light`角色执行**设置幽灵效果为**命令，根据`I`的值改变其透明度。这为灯泡提供了一个逼真的视觉效果，模拟了实际的灯泡。
- en: Try It Out 5-3
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看 5-3
- en: Open the Ohm’s law simulator to run it, and study the scripts to understand
    how it works. What do you think would happen if you added the command **change
    color effect by 25** at the end of the script for the `Light` sprite? Implement
    this change to check your answer. What are some ways you could enhance this application?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 打开欧姆定律模拟器运行它，并研究脚本以了解其工作原理。如果你在`Light`角色的脚本末尾添加**改变颜色效果为25**命令，你认为会发生什么？实施这个更改以检查你的答案。你认为有哪些方法可以增强这个应用？
- en: Demonstrating a Series Circuit
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演示串联电路
- en: '*SeriesCircuit.sb2*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*SeriesCircuit.sb2*'
- en: Our second example simulates a circuit that contains a battery and three resistors
    connected in series. The user can change the battery voltage as well as the resistor
    values using the sliders. The current that flows through the resistors and the
    voltages across the three resistors are shown using large display readouts. You
    can see the interface for the application in [Figure 5-24](ch05.html#application_that_demonstrates_a_series_c
    "Figure 5-24. An application that demonstrates a series circuit"). (Note that
    the color bands on the resistors do not represent the actual values of the resistors.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个示例模拟了一个包含电池和三个串联连接的电阻的电路。用户可以通过滑动条改变电池电压以及电阻值。流经电阻的电流和三个电阻两端的电压通过大显示屏显示。你可以在[图
    5-24](ch05.html#application_that_demonstrates_a_series_c "图 5-24. 展示串联电路的应用程序")中看到该应用程序的界面。（注意，电阻上的色带并不代表电阻的实际值。）
- en: '![An application that demonstrates a series circuit](httpatomoreillycomsourcenostarchimages2134621.png.jpg)Figure 5-24. An
    application that demonstrates a series circuit'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![展示串联电路的应用程序](httpatomoreillycomsourcenostarchimages2134621.png.jpg)图 5-24.
    展示串联电路的应用程序'
- en: 'The equations that govern the operation of this circuit are shown below. We
    can calculate the current that flows in the circuit by dividing the battery voltage,
    *V*, by the sum of the three resistances. After that, the voltage across each
    resistor is calculated by multiplying the current by the value of that resistor:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 控制该电路操作的方程式如下所示。我们可以通过将电池电压 *V* 除以三者电阻之和来计算电路中的电流。之后，计算每个电阻两端的电压时，使用电流与该电阻值的乘积：
- en: '| Total Resistance: *R*[tot] = *R*[1] + *R*[2] + *R*[3] |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 总电阻：*R*[tot] = *R*[1] + *R*[2] + *R*[3] |'
- en: '| Current through the circuit: *I* = *V* ÷ *R*[tot] |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 电路中的电流：*I* = *V* ÷ *R*[tot] |'
- en: '| Voltage across *R*[1]: *V*[1] = *I* × *R*[1] |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| *R*[1] 两端电压：*V*[1] = *I* × *R*[1] |'
- en: '| Voltage across *R*[2]: *V*[2] = *I* × *R*[2] |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| *R*[2] 两端电压：*V*[2] = *I* × *R*[2] |'
- en: '| Voltage across *R*[3]: *V*[3] = *I* × *R*[3] |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| *R*[3] 两端电压：*V*[3] = *I* × *R*[3] |'
- en: This application has no sprites, but when the green flag is clicked, the script
    shown in [Figure 5-25](ch05.html#script_that_runs_when_the_green_flag_is "Figure 5-25. Script
    that runs when the green flag is clicked"), which belongs to the Stage, is executed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序没有精灵，但当点击绿色旗帜时，舞台上执行的脚本如[图 5-25](ch05.html#script_that_runs_when_the_green_flag_is
    "图 5-25. 点击绿色旗帜时运行的脚本")所示。
- en: This script takes care of the math for us and displays the results in the readouts
    on the Stage. Note that while the slider controls for resistors `R2` and `R3`
    can change from 0 to 10, the minimum value for `R1` was intentionally set to 1\.
    This ensures that `Rtot` is always greater than 0 and lets us avoid dividing by
    0 when calculating the value of the current.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本为我们处理数学运算，并将结果显示在舞台上的显示屏上。注意，虽然电阻 `R2` 和 `R3` 的滑动条可以在 0 到 10 之间变化，但 `R1`
    的最小值被故意设置为 1。这确保了 `Rtot` 始终大于 0，避免在计算电流时除以 0。
- en: '![Script that runs when the green flag is clicked](httpatomoreillycomsourcenostarchimages2134623.png.jpg)Figure 5-25. Script
    that runs when the green flag is clicked'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![点击绿色旗帜时运行的脚本](httpatomoreillycomsourcenostarchimages2134623.png.jpg)图 5-25.
    点击绿色旗帜时运行的脚本'
- en: Most of the work for this application went into designing the interface (that
    is, the background of the Stage). After that, all we had to do was to position
    the displays and sliders at the right locations on the Stage.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的大部分工作集中在设计界面上（即舞台背景）。之后，我们只需将显示器和滑动条放置在舞台上的正确位置。
- en: Try It Out 5-4
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看 5-4
- en: '*SeriesCircuitWithSwitch.sb2*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*SeriesCircuitWithSwitch.sb2*'
- en: Open the series circuit simulator application and run it. Experiment with different
    values of `R1`, `R2`, `R3`, and `V`. Watch the calculated values of `V1`, `V2`,
    and `V3` as you drag the slider controls. What is the relationship between the
    voltage sum (`V1` + `V2` + `V3`) and the battery voltage? What does this tell
    you about the voltage relation in series circuits? You can make an interesting
    enhancement to the application by adding an image of a switch that opens or closes
    the circuit, as shown below. When the switch is open, no current will flow in
    the circuit. Try to implement this change using the hints given below.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 打开串联电路模拟器应用程序并运行。尝试不同的`R1`、`R2`、`R3`和`V`值。当你拖动滑块控制时，观察`V1`、`V2`和`V3`的计算值。电压总和（`V1`
    + `V2` + `V3`）和电池电压之间有什么关系？这告诉你串联电路中的电压关系是什么？你可以通过添加一个开关图像来进行有趣的增强，该开关能够打开或关闭电路，如下所示。当开关打开时，电路中不会有电流流动。尝试使用下面给出的提示来实现这个更改。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134625.png.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2134625.png.jpg)'
- en: Visualizing a Sphere’s Volume and Surface Area
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化球体的体积和表面积
- en: '*Sphere.sb2*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sphere.sb2*'
- en: Our third example is an interactive application for calculating the volume and
    surface area of a sphere. The user changes the sphere’s diameter by clicking some
    buttons on the user interface, and the application automatically calculates and
    displays the corresponding volume and surface area. To make the application more
    appealing, the size of the sphere displayed on the Stage is also changed in proportion
    to the selected diameter. The user interface for the application is illustrated
    in [Figure 5-26](ch05.html#user_interface_for_the_sphere_applicatio "Figure 5-26. User
    interface for the sphere application").
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个示例是一个用于计算球体体积和表面积的互动应用程序。用户通过点击用户界面上的一些按钮来改变球体的直径，应用程序会自动计算并显示相应的体积和表面积。为了使应用程序更具吸引力，显示在舞台上的球体大小也会根据所选的直径按比例变化。该应用程序的用户界面如[图
    5-26](ch05.html#user_interface_for_the_sphere_applicatio "图 5-26. 球体应用程序的用户界面")所示。
- en: '![User interface for the sphere application](httpatomoreillycomsourcenostarchimages2134627.png.jpg)Figure 5-26. User
    interface for the sphere application'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![球体应用程序的用户界面](httpatomoreillycomsourcenostarchimages2134627.png.jpg)图 5-26.
    球体应用程序的用户界面'
- en: 'The application contains three sprites: the two arrow buttons (named `Up` and
    `Down`) and the sphere image (named `Sphere`). The scripts associated with the
    two buttons broadcast a message to indicate that they have been clicked, as shown
    in [Figure 5-27](ch05.html#scripts_for_the_up_and_down_sprites "Figure 5-27. Scripts
    for the Up and Down sprites").'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序包含三个精灵：两个箭头按钮（分别命名为`Up`和`Down`）和一个球体图像（命名为`Sphere`）。这两个按钮的脚本会广播消息，指示它们已被点击，如[图
    5-27](ch05.html#scripts_for_the_up_and_down_sprites "图 5-27. 上下箭头精灵的脚本")所示。
- en: '![Scripts for the Up and Down sprites](httpatomoreillycomsourcenostarchimages2134629.png.jpg)Figure 5-27. Scripts
    for the *`Up`* and *`Down`* sprites'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![上下箭头精灵的脚本](httpatomoreillycomsourcenostarchimages2134629.png.jpg)图 5-27.
    *`Up`*和*`Down`*精灵的脚本'
- en: The `Sphere` sprite has nine costumes that represent spheres with diameters
    1, 1.25, 1.5, 1.75, ..., 3\. When this sprite receives the `Up` or `Down` broad-cast
    messages, it executes the scripts shown in [Figure 5-28](ch05.html#scripts_triggered_by_the_up_and_down_mes
    "Figure 5-28. Scripts triggered by the Up and Down messages").
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sphere`精灵有九个服装，分别代表直径为1、1.25、1.5、1.75、...、3的球体。当这个精灵接收到`Up`或`Down`广播消息时，它会执行如[图
    5-28](ch05.html#scripts_triggered_by_the_up_and_down_mes "图 5-28. 由“Up”和“Down”消息触发的脚本")所示的脚本。'
- en: '![Scripts triggered by the Up and Down messages](httpatomoreillycomsourcenostarchimages2134631.png.jpg)Figure 5-28. Scripts
    triggered by the *`Up`* and *`Down`* messages'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![由“Up”和“Down”消息触发的脚本](httpatomoreillycomsourcenostarchimages2134631.png.jpg)图
    5-28. 由*`Up`*和*`Down`*消息触发的脚本'
- en: The sprite switches its costume and then calls the **Recalculate** procedure
    to update the volume and surface area calculations. Note that these scripts use
    the value of the current costume to determine whether the sphere has reached its
    highest or lowest size, thus ensuring valid responses to the `Up` and `Down` buttons.
    I’ll say more about the **if** block in the next chapter, but for now, let’s discuss
    the sphere’s **Recalculate** procedure, shown in [Figure 5-29](ch05.html#recalculate_procedure
    "Figure 5-29. Recalculate procedure").
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵切换其服装，然后调用**重新计算**过程来更新体积和表面积的计算。注意，这些脚本使用当前服装的值来确定球体是否已经达到最大或最小尺寸，从而确保对`上`和`下`按钮的有效响应。我将在下一章详细讲解**if**块，但现在，让我们先讨论球体的**重新计算**过程，如[图
    5-29](ch05.html#recalculate_procedure "图 5-29. 重新计算过程")所示。
- en: '![Recalculate procedure](httpatomoreillycomsourcenostarchimages2134633.png.jpg)Figure 5-29. *Recalculate*
    procedure'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![重新计算过程](httpatomoreillycomsourcenostarchimages2134633.png.jpg)图 5-29. *重新计算*
    过程'
- en: 'First, the value of the `diameter` variable is set according to this formula:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`直径`变量的值根据以下公式设置：
- en: '*diameter* = 1 + 0.25 × (*costume number* – 1)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*直径* = 1 + 0.25 × (*服装编号* – 1)'
- en: Since the costume number ranges from 1 to 9, the corresponding values of the
    `diameter` variable will be 1, 1.25, 1.50, ..., 2.75, 3, which is what we intended.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服装编号的范围从1到9，`直径`变量的相应值将为1、1.25、1.50，...、2.75、3，这是我们想要的结果。
- en: The script finds the radius, `r`, by dividing the diameter by 2\. It then calculates
    the volume and the surface area of the sphere using the formulas shown in [Figure 5-26](ch05.html#user_interface_for_the_sphere_applicatio
    "Figure 5-26. User interface for the sphere application"). The computed values
    will show up automatically on the corresponding monitors on the Stage.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本通过将直径除以2来找到半径`r`。然后，它使用[图 5-26](ch05.html#user_interface_for_the_sphere_applicatio
    "图 5-26. 球体应用程序的用户界面")中显示的公式计算球体的体积和表面积。计算出的值将自动显示在舞台上的相应显示器上。
- en: Try It Out 5-5
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下 5-5
- en: Open the application and run it. Study the scripts to understand how the application
    works. Add a script to the `Sphere` sprite so it rotates and changes color as
    the application runs. As another exercise, modify the original program to use
    a single costume for the `Sphere` sprite and use the **change size by** block
    to change the sphere’s size. The scaled image won’t look as nice, but otherwise,
    the application should perform identically.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序并运行它。研究脚本以理解应用程序的工作原理。向`球体`精灵添加脚本，使其在应用程序运行时旋转并改变颜色。作为另一个练习，修改原始程序，使用一个服装来代替`球体`精灵，并使用**改变大小**模块来改变球体的大小。缩放后的图像可能看起来不太好，但除此之外，应用程序的功能应该完全相同。
- en: Drawing an n-Leaved Rose
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制n叶玫瑰
- en: '*N-LeavedRose.sb2*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*N-LeavedRose.sb2*'
- en: 'In this example, we’ll create an application that draws a rose with multiple
    leaves on the Stage. The rose-drawing process can be broken down into the following
    steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个在舞台上绘制具有多个叶片的玫瑰的应用程序。绘制玫瑰的过程可以分解为以下步骤：
- en: Start at the origin of the Stage.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从舞台的原点开始。
- en: Point the sprite in some direction. By convention, the Greek letter θ (pronounced
    *theta*) represents an angle, so we’ll name the variable for the sprite’s direction
    `theta`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将精灵指向某个方向。按照惯例，希腊字母θ（发音为*theta*）表示一个角度，因此我们将精灵方向的变量命名为`theta`。
- en: Move the sprite `r` steps and draw a single point on the Stage. After that,
    lift the pen up and return to the origin.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动精灵`r`步并在舞台上绘制一个点。之后，抬起画笔并返回原点。
- en: Change the angle `theta` by some amount (we’ll use 1°) and repeat steps 2–4.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按一定的角度`theta`（我们使用1°）进行变化，并重复步骤2-4。
- en: The relation between the distance `r` and the angle `theta` is given by
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 距离`r`和角度`theta`之间的关系由以下公式给出：
- en: '*r* = *a* × cos(*n* × θ)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*r* = *a* × cos(*n* × θ)'
- en: where *a* is a real number and *n* is an integer. This equation produces a rose
    whose size and number of leaves are controlled by `a` and `n`, respectively. This
    equation also involves the cosine trigonometric function (*cos*), which you’ll
    find as a reporter block in the *Operators* palette (check the **sqrt** block).
    Given the values of `a` and `n`, all we have to do is choose different values
    for `theta`, calculate the corresponding values of `r`, and mark the resulting
    points on the Stage. The user interface for this example is shown in [Figure 5-30](ch05.html#user_interface_for_the_n-leaved_rose_app
    "Figure 5-30. User interface for the n-leaved rose application").
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*a*是一个实数，*n*是一个整数。这个方程生成一个玫瑰，其大小和叶子数量分别由`a`和`n`控制。该方程还涉及余弦三角函数（*cos*），你可以在*Operators*调色板中找到它作为一个报告块（检查**sqrt**块）。给定`a`和`n`的值，我们只需要为`theta`选择不同的值，计算出相应的`r`值，并在舞台上标出结果点。这个示例的用户界面如[图5-30](ch05.html#user_interface_for_the_n-leaved_rose_app
    "图5-30. *n*叶玫瑰应用的用户界面")所示。
- en: '![User interface for the n-leaved rose application](httpatomoreillycomsourcenostarchimages2134635.png.jpg)Figure 5-30. User
    interface for the *n*-leaved rose application'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![n叶玫瑰应用的用户界面](httpatomoreillycomsourcenostarchimages2134635.png.jpg)图5-30.
    *n*叶玫瑰应用的用户界面'
- en: 'The application contains two sprites: The first sprite has the `Redraw` button
    costume, and the second sprite (called `Painter`) is a hidden sprite that draws
    the rose. The user controls the number of desired leaves by changing `n` with
    the slider control and then clicks the `Redraw` button to draw the rose. When
    the user clicks that button, the button sprite simply broadcasts a `Redraw` message.
    When the `Painter` sprite receives this message, it executes the script shown
    in [Figure 5-31](ch05.html#redraw_procedure_for_drawing_an_n-leaved "Figure 5-31. The
    Redraw procedure for drawing an n-leaved rose on the Stage").'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序包含两个角色：第一个角色具有`Redraw`按钮服装，第二个角色（名为`Painter`）是一个隐藏的角色，用于绘制玫瑰。用户通过滑块控制器调整`n`值来设定所需的叶子数量，然后点击`Redraw`按钮来绘制玫瑰。当用户点击该按钮时，按钮角色仅广播一个`Redraw`消息。当`Painter`角色接收到该消息时，它将执行[图5-31](ch05.html#redraw_procedure_for_drawing_an_n-leaved
    "图5-31. 绘制带n个叶子的玫瑰的Redraw程序")中显示的脚本。
- en: '![The Redraw procedure for drawing an n-leaved rose on the Stage](httpatomoreillycomsourcenostarchimages2134637.png.jpg)Figure 5-31. The
    *Redraw* procedure for drawing an *n*-leaved rose on the Stage'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![在舞台上绘制带有n个叶子的玫瑰的*Redraw*程序](httpatomoreillycomsourcenostarchimages2134637.png.jpg)图5-31.
    在舞台上绘制带有*n*个叶子的玫瑰的*Redraw*程序'
- en: The script first sets the pen’s color and size and clears the previous pen marks
    from the Stage. It then sets the variable `a` to 100 and calls the **Rose** procedure,
    which will run through a loop 360 times to draw the rose on the Stage. On each
    pass of the loop, the procedure points in the direction `theta`, moves `r` steps,
    and draws a pen mark at that location. It then increments `theta` by 1° to prepare
    for the next pass of the **repeat** loop.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先设置笔的颜色和大小，并清除舞台上先前的笔迹。然后，它将变量`a`设置为100，并调用**Rose**程序，该程序将通过一个循环执行360次，在舞台上绘制玫瑰。在每次循环中，程序指向`theta`方向，移动`r`步，并在该位置绘制笔迹。接着，它将`theta`增加1°，为下一次**repeat**循环做好准备。
- en: '[Figure 5-32](ch05.html#some_roses_created_by_the_rose_procedure "Figure 5-32. Some
    roses created by the Rose procedure") shows some of the roses created for different
    values of `n`. Can you figure out the relation between the value of `n` and the
    number of leaves?'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-32](ch05.html#some_roses_created_by_the_rose_procedure "图5-32. 由Rose程序创建的一些玫瑰")展示了为不同`n`值创建的一些玫瑰。你能找出`n`值与叶子数量之间的关系吗？'
- en: '![Some roses created by the Rose procedure](httpatomoreillycomsourcenostarchimages2134639.png.jpg)Figure 5-32. Some
    roses created by the *Rose* procedureTry It Out 5-6'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![由*Rose*程序创建的一些玫瑰](httpatomoreillycomsourcenostarchimages2134639.png.jpg)图5-32.
    由*Rose*程序创建的一些玫瑰 尝试 5-6'
- en: Open the application and run it. Change the value of `n` to see what else you
    can create with the **Rose** procedure. Add another slider to the application
    to allow the user to change the value of `a` and modify the scripts as needed.
    You can also modify the **Rose** procedure to take `a` as a parameter. (See [Passing
    Parameters to Custom Blocks](ch04.html#passing_parameters_to_custom_blocks "Passing
    Parameters to Custom Blocks") for a refresher on how to add parameters to procedures.)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序并运行。更改`n`的值，看看你能用**玫瑰**程序创造出什么。向应用程序添加另一个滑块，以便用户可以更改`a`的值并根据需要修改脚本。你还可以修改**玫瑰**程序，将`a`作为参数传递。（请参阅[传递参数给自定义模块](ch04.html#passing_parameters_to_custom_blocks
    "传递参数给自定义模块")，复习如何向程序添加参数。）
- en: Modeling Sunflower Seed Distribution
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟向日葵种子分布
- en: '*Sunflower.sb2*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sunflower.sb2*'
- en: 'Biologists and mathematicians have studied the arrangement of leaves on the
    stems of plants extensively. Let’s delve into botany a bit ourselves by examining
    a geometric model for representing flowers with spiral seed patterns. In particular,
    we’ll program two equations that model the distribution of seeds in a sunflower.
    To draw the *n*th seed of the sunflower, we’ll follow these steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 生物学家和数学家已广泛研究植物茎部叶子的排列方式。让我们通过研究一种几何模型来探讨一下植物学，看看如何用螺旋种子模式表示花朵。特别地，我们将编写两个方程来模拟向日葵种子的分布。为了绘制向日葵的第*n*颗种子，我们将遵循以下步骤：
- en: Point the sprite in the direction of *n* × 137.5°.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将精灵朝* n * × 137.5°的方向指向。
- en: Move a distance ![](httpatomoreillycomsourcenostarchimages2134641.png.jpg),
    where *c* is a constant scaling factor (set to 5 in our example).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动一个距离 ![](httpatomoreillycomsourcenostarchimages2134641.png.jpg)，其中*c*是常数缩放因子（在我们的示例中设置为5）。
- en: Draw a point on the Stage at the final location.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在舞台的最终位置绘制一个点。
- en: We’ll repeat these steps for each seed we want to draw. For the first seed,
    we set *n* = 1; for the second seed, we set *n* = 2; and so on. Using angles other
    than 137.5° in the first step will result in different arrangements of seeds.
    If you’re curious about these equations and want to learn more about sunflower
    seed patterns, check out *The Algorithmic Beauty of Plants* by Przemyslaw Prusinkiewicz
    and Aristid Lindenmayer (Springer-Verlag, 2004), specifically [Chapter 4](ch04.html
    "Chapter 4. Procedures"), which you’ll find on the book’s website, *[http://algorithmicbotany.org/papers/#abop](http://algorithmicbotany.org/papers/#abop)*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每颗要绘制的种子重复这些步骤。对于第一颗种子，我们设置*n* = 1；对于第二颗种子，我们设置*n* = 2；依此类推。如果第一步使用与137.5°不同的角度，将会得到不同的种子排列。如果你对这些方程感兴趣并想了解更多向日葵种子模式的内容，可以参考Przemyslaw
    Prusinkiewicz和Aristid Lindenmayer的《植物的算法美学》（Springer-Verlag, 2004），特别是[第4章](ch04.html
    "第4章. 程序")，你可以在书籍的官方网站上找到它，* [http://algorithmicbotany.org/papers/#abop](http://algorithmicbotany.org/papers/#abop)*。
- en: Our application will generate patterns similar to the ones described in that
    work, and you can see some of those patterns in [Figure 5-33](ch05.html#some_sunflower_patterns_generated_using
    "Figure 5-33. Some sunflower patterns generated using different angles").
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将生成类似于该研究中描述的模式，您可以在[图 5-33](ch05.html#some_sunflower_patterns_generated_using
    "图 5-33. 使用不同角度生成的向日葵模式")中看到其中的一些模式。
- en: '![Some sunflower patterns generated using different angles](httpatomoreillycomsourcenostarchimages2134643.png.jpg)Figure 5-33. Some
    sunflower patterns generated using different angles'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用不同角度生成的向日葵模式](httpatomoreillycomsourcenostarchimages2134643.png.jpg)图 5-33.
    使用不同角度生成的向日葵模式'
- en: The interface for this example contains a slider control to change the value
    of the angle from 137° to 138° in increments of 0.01° and a button labeled `Redraw`.
    When the user clicks that button, it broadcasts a message to the `Painter` sprite,
    which executes the scripts shown in [Figure 5-34](ch05.html#scripts_for_the_painter_sprite
    "Figure 5-34. The scripts for the Painter sprite").
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的界面包含一个滑块控件，可以将角度的值从137°更改为138°，并且每次增量为0.01°，同时有一个标记为`Redraw`的按钮。当用户点击该按钮时，它会向`Painter`精灵广播消息，精灵会执行[图
    5-34](ch05.html#scripts_for_the_painter_sprite "图 5-34. Painter精灵的脚本")中显示的脚本。
- en: The **Sunflower** procedure executes a loop that draws 420 seeds, though you
    can change this number if you like. On every iteration of the loop, the procedure
    goes to the location of the *n*th seed (by calculating the seed’s angle ① and
    moving ![](httpatomoreillycomsourcenostarchimages2134645.png.jpg) ② steps) and
    draws a pen mark at that location. The procedure then increments `n`, which represents
    the seed number, to prepare to draw the next seed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sunflower**过程执行一个循环，绘制420个种子，虽然你可以根据需要更改这个数字。在每次循环迭代中，过程会计算种子角度①，移动![](httpatomoreillycomsourcenostarchimages2134645.png.jpg)②步长，然后在该位置绘制一个笔迹。接着，过程递增`n`，表示种子编号，为绘制下一个种子做准备。'
- en: '![The scripts for the Painter sprite](httpatomoreillycomsourcenostarchimages2134647.png.jpg)Figure 5-34. The
    scripts for the *`Painter`* sprite'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![Painter精灵的脚本](httpatomoreillycomsourcenostarchimages2134647.png.jpg)图5-34.
    *`Painter`*精灵的脚本'
- en: The scripts I’ve presented in this section are just a few samples of the amazing
    applications we can create by using variables and monitors. Letting the user interact
    with our applications through the slider control is just the start of a new breed
    of interactive applications. In the following section, you’ll learn to create
    scripts that directly prompt users for input.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本节中展示的脚本只是通过使用变量和监视器所能创建的一些惊人应用的示例。通过滑块控件让用户与我们的应用程序进行交互，只是互动应用程序新型发展的起点。在接下来的章节中，你将学习如何创建直接提示用户输入的脚本。
- en: Try It Out 5-7
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试操作 5-7
- en: Open the application and run it. Change the value of the angle to see what else
    you can create with the **Sunflower** procedure. Study the procedure to understand
    how it works and then come up with some ways to enhance it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序并运行它。更改角度的值，看看你还能用**Sunflower**过程创建什么。研究这个过程，理解它是如何工作的，然后想出一些方法来增强它。
- en: Getting Input from Users
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从用户获取输入
- en: '*GettingUserInput.sb2*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*GettingUserInput.sb2*'
- en: Imagine that you want to create a game that tutors children in basic arithmetic.
    Your game would probably have a sprite that displays an addition problem and asks
    the player to enter an answer. How would you read the player’s input to see whether
    the answer was correct?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建一个教孩子们基础算术的游戏。你的游戏可能会有一个精灵，显示一个加法题目并要求玩家输入答案。你如何读取玩家的输入，以查看答案是否正确？
- en: Scratch’s *Sensing* palette provides one command block, **ask and wait**, that
    you can use to read user input. This block takes a single parameter that specifies
    a string to show to the user, usually in the form of a question. As illustrated
    in [Figure 5-35](ch05.html#ask_and_wait_block_may_produce_different "Figure 5-35. The
    ask and wait block may produce different outputs depending on whether the sprite
    that executes it is shown or hidden."), the execution of this block produces slightly
    different outputs depending on the visibility state of the sprite (that is, whether
    the sprite is shown or hidden). The output shown in [Figure 5-35](ch05.html#ask_and_wait_block_may_produce_different
    "Figure 5-35. The ask and wait block may produce different outputs depending on
    whether the sprite that executes it is shown or hidden.") (right) also appears
    when the **ask and wait** command is called from a script that is owned by the
    Stage.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch的*Sensing*调色板提供了一个命令块，**ask and wait**，你可以用它来读取用户输入。这个命令块接受一个参数，指定一个字符串，通常是一个问题，以便展示给用户。如[图5-35](ch05.html#ask_and_wait_block_may_produce_different
    "图5-35. ask and wait命令块的输出可能会根据执行它的精灵是否显示而有所不同")所示，执行该命令块时，输出会根据精灵的可见状态（即精灵是显示还是隐藏）有所不同。在[图5-35](ch05.html#ask_and_wait_block_may_produce_different
    "图5-35. ask and wait命令块的输出可能会根据执行它的精灵是否显示而有所不同")（右）中显示的输出，执行来自舞台脚本的**ask and wait**命令时也会出现。
- en: '![The ask and wait block may produce different outputs depending on whether
    the sprite that executes it is shown or hidden.](httpatomoreillycomsourcenostarchimages2134649.png.jpg)Figure 5-35. The
    *ask and wait* block may produce different outputs depending on whether the sprite
    that executes it is shown or hidden.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![ask and wait命令块的输出可能会根据执行它的精灵是否显示而有所不同。](httpatomoreillycomsourcenostarchimages2134649.png.jpg)图5-35.
    *ask and wait*命令块的输出可能会根据执行它的精灵是否显示而有所不同。'
- en: After executing the **ask and wait** command, the calling script waits for the
    user to press the ENTER key or click the check mark at the right side of the input
    box. When this happens, Scratch stores the user’s input in the **answer** block
    and continues execution at the command immediately after the **ask and wait**
    block. To see this command block in action, take a look at the following examples
    illustrating how to use it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行**ask and wait**命令后，调用脚本会等待用户按下ENTER键或点击输入框右侧的勾选框。当发生此操作时，Scratch会将用户的输入存储在**answer**块中，并在**ask
    and wait**块后面的命令中继续执行。为了看到这个命令块的实际操作，看看以下示例，说明如何使用它。
- en: Reading a Number
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取一个数字
- en: '*AskAndWait.sb2*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*AskAndWait.sb2*'
- en: The script of [Figure 5-36](ch05.html#script_that_accepts_the_userapostrophes
    "Figure 5-36. A script that accepts the user’s age as input") asks the user for
    her age, waits for an answer, and tells the user how old she will be in 10 years.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-36](ch05.html#script_that_accepts_the_userapostrophes "图5-36. 一个接受用户年龄输入的脚本")中的脚本会询问用户她的年龄，等待答案，并告诉用户她10年后会几岁。'
- en: '![A script that accepts the user’s age as input](httpatomoreillycomsourcenostarchimages2134651.png.jpg)Figure 5-36. A
    script that accepts the user’s age as input'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个接受用户年龄输入的脚本](httpatomoreillycomsourcenostarchimages2134651.png.jpg)图5-36.
    一个接受用户年龄输入的脚本'
- en: The figure shows the output of the program when the user types `18` and presses
    ENTER on the keyboard. Notice that the program uses the **join** block (from the
    *Operators* palette) to concatenate (that is, connect) two strings.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了当用户输入`18`并按下键盘上的ENTER键时程序的输出。注意，程序使用了**join**块（来自*运算符*调色板）来连接（即拼接）两个字符串。
- en: Reading Characters
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取字符
- en: '*AskAndWait2.sb2*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*AskAndWait2.sb2*'
- en: The script of [Figure 5-37](ch05.html#script_that_uses_two_variables_to_read_i
    "Figure 5-37. A script that uses two variables to read in and store the user’s
    initials") asks the user for his initials and then constructs and displays a greeting
    based on the user’s response.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-37](ch05.html#script_that_uses_two_variables_to_read_i "图5-37. 一个使用两个变量读取并存储用户姓名首字母的脚本")中的脚本会询问用户他的姓名首字母，然后根据用户的回答构造并显示问候语。'
- en: '![A script that uses two variables to read in and store the user’s initials](httpatomoreillycomsourcenostarchimages2134653.png.jpg)Figure 5-37. A
    script that uses two variables to read in and store the user’s initials'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个使用两个变量读取并存储用户姓名首字母的脚本](httpatomoreillycomsourcenostarchimages2134653.png.jpg)图5-37.
    一个使用两个变量读取并存储用户姓名首字母的脚本'
- en: The program uses two variables (`firstInitial` and `lastInitial`) to save the
    values entered by the user. You can see the final output of the program when the
    user enters the letters `M` and `S` at the two prompts, respectively. Notice that
    the program uses nested **join** blocks to construct the greeting. You can use
    this technique to create all sorts of strings and display customized messages
    in your applications.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用两个变量（`firstInitial` 和 `lastInitial`）来保存用户输入的值。当用户分别在两个提示框中输入字母`M`和`S`时，你可以看到程序的最终输出。注意，程序使用了嵌套的**join**块来构造问候语。你可以使用这种技术在应用程序中创建各种字符串，并显示定制的消息。
- en: Performing Arithmetic Operations
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行算术操作
- en: '*AskAndWait3.sb2*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*AskAndWait3.sb2*'
- en: The script of [Figure 5-38](ch05.html#computing_a_value_based_on_user_input
    "Figure 5-38. Computing a value based on user input") asks the user to input two
    numbers. It then computes the product of these two numbers and shows the answer
    in a voice bubble using the **say** command. As in the previous example, the script
    uses two variables (`num1` and `num2`) to store the values entered by the user.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-38](ch05.html#computing_a_value_based_on_user_input "图5-38. 根据用户输入计算一个值")中的脚本会要求用户输入两个数字。然后，它计算这两个数字的乘积，并使用**say**命令在语音气泡中显示答案。与之前的示例一样，脚本使用了两个变量（`num1`和`num2`）来存储用户输入的值。'
- en: '![Computing a value based on user input](httpatomoreillycomsourcenostarchimages2134655.png.jpg)Figure 5-38. Computing
    a value based on user input'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![根据用户输入计算一个值](httpatomoreillycomsourcenostarchimages2134655.png.jpg)图5-38.
    根据用户输入计算一个值'
- en: The figure shows the output when the user enters 9 and 8, respectively, in response
    to the two prompts. Again, notice that I’ve nested the **join** blocks to construct
    the output string.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了当用户分别输入9和8作为对两个提示的回应时程序的输出。同样，注意我将**join**块嵌套在一起，用来构造输出字符串。
- en: The examples I’ve presented in this section demonstrate several ways to use
    the **ask and wait** block to write scripts that take in user input and solve
    a variety of problems. You can, for example, write a program to find the roots
    of a quadratic equation of the form *ax*² + *bx* + *c* = 0 for any values of *a*,
    *b*, and *c* entered by the user. You could then use this program to check your
    own answer to the equation. I hope this will give you some ideas of how to use
    this powerful block to solve any math problem that may arise.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本节中展示的例子展示了几种使用**询问并等待**块来编写接受用户输入并解决各种问题的脚本。例如，你可以编写一个程序，求解形如 *ax*² + *bx*
    + *c* = 0 的二次方程的根，其中 *a*、*b* 和 *c* 的值由用户输入。然后，你可以使用这个程序检查你自己对方程的答案。我希望这能给你一些启示，告诉你如何使用这个强大的块来解决可能出现的任何数学问题。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Variables are one of the most important concepts in programming. A variable
    is the name of an area in computer memory where we can store a single value, such
    as a number or a string.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是编程中最重要的概念之一。变量是计算机内存中存储单一值（如数字或字符串）的区域的名称。
- en: In this chapter, you learned the basic data types supported in Scratch and the
    operations permitted on these types. You then learned how to create variables
    and use them to store a piece of data.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Scratch 支持的基本数据类型以及对这些类型进行的操作。接着，你学习了如何创建变量并使用它们存储数据。
- en: You also implemented several practical applications that used variables to demonstrate
    different features. You explored variables’ monitors and used them to create different
    kinds of interactive programs. Finally, you learned how to use the **ask and wait**
    block to prompt the user for some input and process the user’s responses in your
    program.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你还实现了几个实际应用，利用变量展示不同的功能。你探索了变量的监视器，并用它们创建了不同类型的互动程序。最后，你学会了如何使用**询问并等待**块来提示用户输入并在程序中处理用户的响应。
- en: In the next chapter, you’ll learn more about the Boolean data type and the fundamental
    role it plays in decision making. You’ll also learn about the **if** and the **if/else**
    blocks and use them to add another level of intelligence to your Scratch programs.
    So roll up your sleeves and get ready for another exciting chapter!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解更多关于布尔数据类型的知识，以及它在决策中的基本作用。你还将学习**if**和**if/else**块，并使用它们为你的 Scratch
    程序增加更高层次的智能。所以，卷起袖子，准备迎接另一个激动人心的章节吧！
- en: Problems
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '| **Q:** | 1\. Create a script that implements the following instructions:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '| **问:** | 1\. 创建一个实现以下指令的脚本：'
- en: Set the `speed` variable to 60 (mph).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `speed` 变量设置为 60（英里/小时）。
- en: Set the `time` variable to 2.5 (hours).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `time` 变量设置为 2.5（小时）。
- en: Calculate the distance traveled and save the answer in the `distance` variable.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算行驶的距离并将答案保存在 `distance` 变量中。
- en: Display the calculated distance, with an appropriate message, to the user
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户显示计算出的距离，并附上适当的消息。
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Q:** | 2\. What is the output of each of the scripts shown below? Reproduce
    these scripts and run them to test your answer.![image with no caption](httpatomoreillycomsourcenostarchimages2134657.png.jpg)
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **问:** | 2\. 以下每个脚本的输出是什么？复制这些脚本并运行它们以测试你的答案。![没有标题的图片](httpatomoreillycomsourcenostarchimages2134657.png.jpg)
    |'
- en: '| **Q:** | 3\. What are the values of `X` and `Y` at the end of each iteration
    of the repeat loop in the script to the right? Reproduce the script and run it
    to check your answer.![image with no caption](httpatomoreillycomsourcenostarchimages2134659.png.jpg)
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **问:** | 3\. 在右侧脚本的重复循环的每次迭代结束时，`X` 和 `Y` 的值分别是多少？复制脚本并运行以检查你的答案。![没有标题的图片](httpatomoreillycomsourcenostarchimages2134659.png.jpg)
    |'
- en: '| **Q:** | 4\. Let *x* and *y* be two variables. Create function blocks equivalent
    to the following statements:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '| **问:** | 4\. 设 *x* 和 *y* 为两个变量。创建与以下语句等效的功能块：'
- en: Add 5 to *x* and store the result in *y*.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 5 加到 *x* 并将结果存储在 *y* 中。
- en: Multiply *x* by 3 and store the result in *y*.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *x* 乘以 3，并将结果存储在 *y* 中。
- en: Divide *x* by 10 and store the result in *y*.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *x* 除以 10，并将结果存储在 *y* 中。
- en: Subtract 4 from *x* and store the result in *y*.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *x* 中减去 4，并将结果存储在 *y* 中。
- en: Square *x*, add *y* to the result, and store the result back in *x*.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *x* 平方，结果加上 *y*，并将结果存储回 *x* 中。
- en: Set *x* equal to twice the value of *y* plus three times the cube of *y*.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *x* 设置为 *y* 的两倍加上 *y* 的立方的三倍。
- en: Set *x* equal to minus the square of *y*.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *x* 设置为 - *y* 的平方。
- en: Set *x* equal to the result of dividing the sum of *x* and *y* by the product
    of *x* and *y*.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *x* 设置为 *x* 和 *y* 之和除以 *x* 和 *y* 的积的结果。
- en: '|'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Q:** | 5\. Write a program that asks that user to enter an article, a noun,
    and a verb. The program then creates a sentence of the form *article noun verb*.
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 5\. 编写一个程序，要求用户输入一个冠词、一个名词和一个动词。程序将根据输入的内容创建一个句子，形式为 *冠词 名词 动词*。
    |'
- en: '| **Q:** | 6\. Write a program that asks the user to enter a temperature in
    degrees Celsius. The program will convert the temperature to degrees Fahrenheit
    and display the result to the user with an appropriate message. (Hint: *F°* =
    (1.8 × *C°*) + 32.) |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 6\. 编写一个程序，要求用户输入一个摄氏度的温度。程序将把该温度转换为华氏度，并以适当的消息将结果显示给用户。（提示：*F°*
    = (1.8 × *C°*) + 32。） |'
- en: '| **Q:** | 7\. When a current *I* flows through a resistance *R*, the power
    *P* dissipated by the resistance is *I* ² *× R*. Write a program that reads *I*
    and *R* and calculates *P*. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 7\. 当电流 *I* 流过电阻 *R* 时，电阻耗散的功率 *P* 为 *I* ² *× R*。编写一个程序，读取 *I* 和
    *R* 并计算 *P*。 |'
- en: '| **Q:** | 8\. Write a program that reads the lengths of the two sides of a
    right triangle and calculates the length of the hypotenuse. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 8\. 编写一个程序，读取直角三角形两边的长度，并计算斜边的长度。 |'
- en: '| **Q:** | 9\. Write a program that prompts the user to enter the length (*L*),
    width (*W*), and height (*H*) of a box. The program will then compute and display
    the volume and surface area of the box. (Hint: *Volume = L × W × H*; *Surface
    area =* 2*×*[(*L × W*) *+* (*L × H*) *+* (*H × W*)].) |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 9\. 编写一个程序，提示用户输入一个盒子的长度（*L*）、宽度（*W*）和高度（*H*）。程序将计算并显示该盒子的体积和表面积。（提示：*体积
    = L × W × H*；*表面积 =* 2*×*[(*L × W*) *+* (*L × H*) *+* (*H × W*)]。） |'
- en: '| **Q:** | 10\. The equivalent resistance *R* of three resistors (*R*[1], *R*[2],
    and *R*[3]) connected in parallel is given by this equation:1/*R* = 1/*R*[1] *+*
    1/*R*[2] *+* 1/*R*[3]Write a program that reads the values of *R*[1], *R*[2],
    and *R*[3] and calculates *R*. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 10\. 三个电阻（*R*[1]、*R*[2] 和 *R*[3]）并联时的等效电阻 *R* 可通过以下公式计算：1/*R* =
    1/*R*[1] *+* 1/*R*[2] *+* 1/*R*[3]。编写一个程序，读取 *R*[1]、*R*[2] 和 *R*[3]* 的值，并计算 *R*。
    |'
- en: '| **Q:** | 11\. Complete the Whac-a-Mole game introduced earlier in the chapter.
    The file *Whac-a-Mole.sb2* contains a partial implementation of this program.
    When the green flag is clicked, the provided script starts a loop that moves the
    `Cat` sprite randomly over the holes. Add two scripts (one for the `Cat` and the
    other for the Stage) to change the values of the two variables (`hits` and `misses`)
    appropriately. Try adding some sound effects to make the game more fun! You could
    also add a condition that ends the game after a timer or the number of misses
    reaches a certain value.![image with no caption](httpatomoreillycomsourcenostarchimages2134661.png.jpg)
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 11\. 完成本章前面介绍的打地鼠游戏。文件 *Whac-a-Mole.sb2* 包含此程序的部分实现。当点击绿色旗帜时，提供的脚本会启动一个循环，随机移动
    `Cat` 精灵到各个洞口。为 `Cat` 和舞台（Stage）分别添加两个脚本，以适当改变两个变量（`hits` 和 `misses`）的值。你还可以尝试添加一些音效，使游戏更有趣！此外，可以增加一个条件，当计时器到达或失误次数达到一定值时结束游戏。![image
    with no caption](httpatomoreillycomsourcenostarchimages2134661.png.jpg) |'
