- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 7 LOW-LEVEL CONTROL STRUCTURES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7 低级控制结构
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: The examples in this book up to this point have created assembly control structures
    in an ad hoc manner. Now it’s time to formalize how to control the operation of
    your assembly language programs. By the time you finish this chapter, you should
    be able to convert HLL control structures into assembly language control statements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书至此为止的示例采用了临时的方法创建汇编控制结构。现在是时候规范化如何控制汇编语言程序的操作了。完成本章后，你应该能够将高级语言的控制结构转换为汇编语言控制语句。
- en: Control structures in assembly language consist of conditional branches and
    indirect jumps. This chapter discusses those instructions and how to emulate HLL
    control structures such as if...else, switch, and loop statements. This chapter
    also discusses labels, the targets of conditional branches and jump statements,
    as well as the scope of labels in an assembly language source file.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言中的控制结构包括条件分支和间接跳转。本章将讨论这些指令以及如何模拟高级语言中的控制结构，例如if...else、switch和循环语句。本章还将讨论标签、条件分支和跳转语句的目标，以及标签在汇编语言源文件中的作用域。
- en: '### 7.1 Statement Labels'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 7.1 语句标签'
- en: Before discussing the jump instructions and how to use them to emulate control
    structures, an in-depth discussion of assembly language statement labels is necessary.
    *Labels* in an assembly language program stand in as symbolic names for addresses.
    Referring to a position in your code by using a name such as LoopEntry is far
    more convenient than using a numeric address such as 0xAF1C002345B7901E. For this
    reason, assembly language low-level control structures make extensive use of labels
    within source code (see section 2.10, “Control-Transfer Instructions,” on [page
    74](chapter2.xhtml#pg_74)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论跳转指令以及如何使用它们来模拟控制结构之前，有必要深入讨论汇编语言中的语句标签。*标签*在汇编语言程序中充当地址的符号名称。使用像LoopEntry这样的名称来引用代码中的某个位置，比使用像0xAF1C002345B7901E这样的数字地址要方便得多。因此，汇编语言的低级控制结构在源代码中大量使用标签（参见第2.10节“控制转移指令”中的[第74页](chapter2.xhtml#pg_74)）。
- en: 'You can do three operations on code labels: transfer control to a label via
    a conditional or unconditional jump instruction, call a label via the bl instruction,
    and take the address of a label. The last of these is useful when you want to
    indirectly transfer control to that address at a later point in your program.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对代码标签执行三种操作：通过条件跳转或无条件跳转指令将控制转移到标签、通过bl指令调用标签、以及获取标签的地址。最后一种操作在你想要稍后在程序中间接地将控制转移到该地址时非常有用。
- en: 'The following code sequence demonstrates how to take the address of a label
    in your program by using the lea macro:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码序列演示了如何使用lea宏在程序中获取标签的地址：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because addresses are 64-bit quantities, you’ll typically load an address into
    a 64-bit general-purpose register by using the lea instruction. Also see section
    7.5, “Taking the Address of Symbols in Your Code,” on [page 364](chapter7.xhtml#pg_364)
    for more information about taking the address of a label in your programs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地址是64位的，通常会使用lea指令将地址加载到64位通用寄存器中。有关如何在程序中获取标签地址的更多信息，请参见第7.5节“获取程序中符号的地址”中的[第364页](chapter7.xhtml#pg_364)。
- en: 7.2 Initializing Arrays with Statement Labels
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 使用语句标签初始化数组
- en: Gas allows you to initialize double-word objects with the addresses of statement
    labels. The code fragment in Listing 7-1 demonstrates how to do this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Gas允许你使用语句标签的地址来初始化双字对象。列表7-1中的代码片段演示了如何做到这一点。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You might recall that pointers in the .text section cannot refer to objects
    outside that section; however, it is perfectly legitimate for pointers in other
    sections (such as .data) to refer to symbols in the .text section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，.text节中的指针不能引用该节之外的对象；然而，其他节（例如.data节）中的指针是可以引用.text节中的符号的。
- en: As addresses on the ARM are 64-bit quantities, you will typically use the .dword
    directive, as in the previous examples, to initialize a data object with the address
    of a statement label.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ARM上的地址是64位的，通常会使用.dword指令，如前面的示例所示，通过语句标签的地址来初始化数据对象。
- en: 7.3 Unconditional Transfer of Control
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 无条件控制转移
- en: 'The b.al (branch) instruction unconditionally transfers control to another
    point in the program. This instruction has three forms: two PC-relative branches
    and an indirect jump. These instructions take the following forms:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`b.al`（分支）指令无条件地将控制转移到程序中的另一点。该指令有三种形式：两种基于PC的相对分支和一个间接跳转。这些指令的形式如下：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first two instructions are *PC-relative branches*, which you’ve seen in
    various sample programs up to this point. For PC-relative branches, you normally
    specify the target address by using a statement label. The label appears either
    on the same line as an executable machine instruction or by itself on a line preceding
    it. The direct jump is completely equivalent to a goto statement in an HLL.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前两条指令是*PC相对分支*，你在之前的多个示例程序中已经见过。对于PC相对分支，通常通过使用语句标签来指定目标地址。该标签出现在可执行机器指令的同一行，或单独出现在其前一行。直接跳转完全等同于高级语言中的`goto`语句。
- en: 'Here’s an example of a direct jump that transfers control to a label elsewhere
    in the program:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个直接跳转的例子，它将控制转移到程序中其他地方的标签：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unlike HLLs, for which your instructors usually forbid you to use goto statements,
    you will find that the use of the b/b.al instruction in assembly language is essential.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与高级语言不同，通常你的老师会禁止你使用`goto`语句，你会发现，在汇编语言中使用`b/b.al`指令是必不可少的。
- en: 7.4 Register-Indirect Branches
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4 寄存器间接跳转
- en: The third form of the br reg64 branch instruction given earlier is a *register-indirect
    jump* instruction that transfers control to the instruction whose address appears
    in the specified 64-bit general-purpose register. To use the br instruction, you
    must load a 64-bit register with the address of a machine instruction prior to
    the execution of br. When several paths, each loading the register with a different
    address, converge on the same br instruction, control transfers to an appropriate
    location determined by the path up to that point.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之前给出的`br reg64`分支指令的第三种形式是*寄存器间接跳转*指令，它将控制转移到指定64位通用寄存器中地址所指向的指令。要使用`br`指令，必须在执行`br`之前，将一个64位寄存器加载为机器指令的地址。当多个路径将不同地址加载到寄存器中并汇聚到同一`br`指令时，控制将转移到由到该点为止的路径确定的适当位置。
- en: Listing 7-2 reads a string of characters from the user that contain an integer
    value. It uses strtol() to convert that string to a binary integer value. This
    C stdlib function doesn’t do the best job of reporting an error, so this program
    tests the return results to verify a correct input and uses register-indirect
    jumps to transfer control to different code paths based on the result.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7-2读取用户输入的字符字符串，这些字符串包含一个整数值。它使用`strtol()`将该字符串转换为二进制整数值。这个C语言标准库函数在报告错误方面做得不够好，因此这个程序测试返回结果以验证输入是否正确，并使用寄存器间接跳转根据结果将控制转移到不同的代码路径。
- en: The first part of Listing 7-2 contains constants, variables, external declarations,
    and the (usual) getTitle() function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7-2的第一部分包含常量、变量、外部声明和（通常的）`getTitle()`函数。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next section of Listing 7-2 is the strToInt function, a wrapper around
    the C stdlib strtol() function that does a more thorough job of handling erroneous
    inputs from the user. See the comments for the function’s return values:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7-2的下一部分是`strToInt`函数，它是C语言标准库`strtol()`函数的封装，能够更全面地处理用户输入的错误。请参见函数的返回值注释：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The strtol() ❶ function expects a pointer to an end-of-string pointer variable.
    The strToInt procedure reserved space for this pointer in the activation record.
    This code computes the address of that pointer variable to pass on to the strtol()
    function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`strtol()` ❶ 函数期望一个指向字符串结束指针变量的指针。`strToInt`过程在激活记录中为此指针预留了空间。此代码计算该指针变量的地址，并将其传递给`strtol()`函数。'
- en: Retrieving the C errno variable ❷ is done differently in macOS and Linux (or,
    more likely, in Clang versus GCC). The getErrno macro in the *aoaa.inc* include
    file generates the appropriate code for the two systems. It returns errno in X0.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 获取C语言的`errno`变量 ❷ 在macOS和Linux（或者更可能是Clang与GCC）中处理方式不同。`getErrno`宏在*aoaa.inc*包含文件中生成适合这两个系统的代码。它将`errno`返回到X0寄存器。
- en: 'The final section of Listing 7-2 is the main program and the most interesting
    part of the code, because it demonstrates how to call the strToInt function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7-2的最后部分是主程序，也是代码中最有趣的部分，因为它演示了如何调用`strToInt`函数：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The main function loads the X19 register with the address of code to execute
    based on the strToInt return results. The strToInt function returns one of the
    following states (see the comments in the previous code for an explanation):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数根据 strToInt 返回结果加载 X19 寄存器，指定要执行的代码的地址。strToInt 函数返回以下几种状态之一（请参阅前面的代码注释以了解解释）：
- en: Valid input
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效输入
- en: Illegal characters at the beginning of the string
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串开头的非法字符
- en: Illegal characters at the end of the string
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串末尾的非法字符
- en: Range error
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围错误
- en: The program then transfers control to different sections of asmMain based on
    the value held in X19, which specifies the type of result strToInt returns.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 程序接着根据 X19 中保存的值转移控制到 asmMain 的不同部分，X19 指定了 strToInt 返回结果的类型。
- en: 'The readline function returns –1 ❶ if there was an error reading the line of
    text from the user, which typically occurs when the end of the file is detected.
    This is the *only* negative value that readline returns, so rather than test for
    –1, this code just checks to see if readline returned a negative value. The test
    is a little sneaky, but it’s a standard trick; anytime you AND a value with itself,
    you get the original value back. In this case, the code uses the ands instruction,
    which also sets the Z flag if the value was 0 and sets the N flag if the number
    was negative ❷. Therefore, testing the N flag afterward checks for an error condition.
    Note that a cmp x0, #0 instruction would serve this same purpose.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 'readline 函数返回 –1 ❶ 如果读取用户输入的文本行时发生错误，这通常发生在检测到文件结尾时。这是 readline 唯一返回的负值，因此这段代码并不直接检查
    –1，而是检查 readline 是否返回了负值。这个检查有点巧妙，但它是一种标准技巧；任何时候将一个值与自己进行 AND 运算，都会得到原始值。在这个例子中，代码使用
    ands 指令，如果值为 0，Z 标志会被设置，如果数字为负数，N 标志会被设置 ❷。因此，之后测试 N 标志可以检查错误情况。注意，cmp x0, #0
    指令也能达到同样的目的。'
- en: Once again, this code uses the ands instruction ❷ to compare the result against
    0\. This time, it’s actually checking for the value 0 (via the Z flag) by using
    the beq instruction immediately afterward. This is where the program in Listing
    7-2 demonstrates using the br (branch indirect through register) instruction to
    implement the logic ❸.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，这段代码使用 ands 指令 ❷ 将结果与 0 进行比较。这一次，它实际上是在检查值是否为 0（通过 Z 标志），并紧接着使用 beq 指令进行检查。这就是列表
    7-2 中的程序使用 br（通过寄存器间接分支）指令实现逻辑 ❸ 的地方。
- en: 'Here’s the build command and a sample run of Listing 7-2:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是列表 7-2 的构建命令和示例运行：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This sample run demonstrates several bad inputs, including nonnumeric inputs,
    out-of-range values, a legitimate value, and entering 0 to exit the program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例运行展示了几种错误输入，包括非数字输入、超出范围的值、合法值，以及输入 0 来退出程序。
- en: 7.5 Taking the Address of Symbols in Your Code
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5 获取程序中符号的地址
- en: Listing 7-2 computed the address of various symbols throughout the .text section
    in order to load those addresses into a register for later use. Obtaining the
    runtime address of a symbol in the program is a common operation in assembly language
    programs, because this is how you access data (and code) indirectly via a register.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-2 计算了 .text 段中各种符号的地址，以便将这些地址加载到寄存器中以备后用。在汇编语言程序中，获取程序中符号的运行时地址是一项常见操作，因为这就是通过寄存器间接访问数据（和代码）的方法。
- en: This chapter covers control structures, and this section discusses obtaining
    addresses of statement labels in the program. Much of the information in this
    section is review material from earlier chapters in this book, but I’ve pulled
    it together here for reference purposes and extended the discussion.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了控制结构，本节讨论了如何获取程序中语句标签的地址。本节中的很多信息是本书前面章节的复习材料，但我把它们汇总在这里以供参考，并扩展了讨论。
- en: 7.5.1 Revisiting the lea Macro
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.1 重新审视 lea 宏
- en: Listing 7-2 used the lea macro to initialize 64-bit registers with the address
    of a location to jump to via the br instruction. This has been the go-to macro
    for obtaining the address of a symbol throughout this book. However, remember
    that lea is a macro and that
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-2 使用 lea 宏将 64 位寄存器初始化为一个通过 br 指令跳转到的位置的地址。这个宏在本书中一直是获取符号地址的首选方法。然而，请记住，lea
    是一个宏，并且
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'translates into this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 转换成这样：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The two-instruction sequence allows the lea macro to compute the address of
    a PC-relative symbol anywhere in a ±4GB range. The adr instruction can also compute
    the address of a symbol but it supports only a ±1MB range (see section 1.8.1,
    “ldr, str, adr, and adrp,” on [page 23](chapter1.xhtml#pg_23)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条指令序列允许 lea 宏在 ±4GB 范围内计算 PC 相对符号的地址。adr 指令也可以计算符号的地址，但它只支持 ±1MB 范围（请参见第 1.8.1
    节，“ldr、str、adr 和 adrp”，见 [第 23 页](chapter1.xhtml#pg_23)）。
- en: 'When taking the address of nearby statement labels in the .text section, it
    is going to be more efficient to use the adr instruction:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取 .text 段中附近语句标签的地址时，使用 adr 指令会更加高效：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only time this will fail is if your .text section is very large and the
    symbol is more than 1MB away from the adr instruction. The main reason for using
    the lea macro is to obtain the address of a symbol that is in a different section
    (especially on macOS, whose PIE/ASLR policy will likely locate that section farther
    than ±1MB away).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的失败情况是，如果你的 .text 段非常大，符号距离 adr 指令超过 1MB。使用 lea 宏的主要原因是为了获取位于不同段中的符号地址（特别是在
    macOS 上，PIE/ASLR 策略可能会将该段定位在距离 ±1MB 以上的位置）。
- en: If the symbol/memory location whose address you wish to compute is farther than
    ±4GB away from the current instruction, you’ll have to use one of the approaches
    in the following sections to obtain its address.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想计算的符号/内存位置的地址距离当前指令超过 ±4GB，你将不得不使用以下章节中某种方法来获取它的地址。
- en: 7.5.2 Statically Computing the Address of a Symbol
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.2 静态计算符号的地址
- en: Since memory addresses are 64 bits, and the .dword directive allows you to initialize
    a dword object with a 64-bit value, shouldn’t it be possible to initialize such
    an object with the 64-bit address of another symbol in the program? The answer
    depends on the OS you’re running under.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存地址是 64 位的，并且 .dword 指令允许你用 64 位值初始化一个 dword 对象，那么是不是可以用程序中另一个符号的 64 位地址来初始化这样一个对象呢？答案取决于你运行的操作系统。
- en: Under Linux, it is perfectly legal (even when running PIE code) to do the following
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 下，即使运行 PIE 代码，执行以下操作是完全合法的：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'where variable is the name of a symbol appearing in a .data, .bss, .rodata,
    or .text section. When Linux loads the executable program into memory, it will
    automatically patch this dword memory location with the address of that symbol
    in memory (wherever Linux has loaded it). Depending on the section, you might
    be able to directly load the contents of this location in the X0 register by using
    the following instruction, assuming that the symbol is within the PC-relative
    range of the ldr instruction:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其中变量是出现在.data、.bss、.rodata 或 .text 段中的符号名称。当 Linux 将可执行程序加载到内存时，它会自动将此 dword
    内存位置修补为该符号在内存中的地址（无论 Linux 将其加载到哪里）。根据段的不同，你可能可以通过使用以下指令，假设该符号在 ldr 指令的 PC 相对范围内，直接将此位置的内容加载到
    X0 寄存器中：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sadly, this scheme may not work under macOS, where you’re not allowed to use
    absolute addresses in your .text section. If you move varPtr to the .data section,
    macOS will accept the pointer initialization but will reject the ldr instruction
    with the same complaint about an illegal absolute address. Of course, you could
    use the lea macro to load the address of varPtr into X0 and then fetch variable’s
    address by using the [X0] addressing mode; however, at that point, you may as
    well use the lea instruction to load the address of variable directly into X0\.
    In any case, you’re back to the ±4GB limitation of the lea macro.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方案可能在 macOS 上不可行，因为在 macOS 中，你不允许在 .text 段中使用绝对地址。如果你将 varPtr 移到 .data
    段，macOS 会接受指针初始化，但会因非法的绝对地址拒绝 ldr 指令。当然，你可以使用 lea 宏将 varPtr 的地址加载到 X0，然后通过 [X0]
    寻址模式获取变量的地址；然而，在那时，你完全可以直接使用 lea 指令将变量的地址加载到 X0。无论如何，你又回到了 lea 宏的 ±4GB 限制。
- en: 'You can get around the absolute address limitation of macOS by using a relative
    address rather than an absolute address. A *relative address* is just an offset
    from a fixed point in memory (for example, a PC-relative address is an offset
    from the address held in the PC register). You can create a self-relative 64-bit
    pointer by using the following statement:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用相对地址而不是绝对地址来绕过 macOS 的绝对地址限制。*相对地址*只是内存中某个固定点的偏移量（例如，PC 相对地址是相对于存储在 PC
    寄存器中的地址的偏移量）。你可以使用以下语句创建一个自相关的 64 位指针：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This initializes this 64-bit memory location with the distance (in bytes) from
    the varPtr object to the desired memory location (variable). This is known as
    a *self-relative pointer* because the offset is from the pointer variable itself.
    As it turns out, macOS’s assembler is perfectly happy with this address expression
    (even in the .text section) because it is not an absolute address.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将初始化该64位内存位置，存储从varPtr对象到目标内存位置（变量）的距离（以字节为单位）。这被称为*自相对指针*，因为偏移量是相对于指针变量本身的。事实证明，macOS的汇编器对于这个地址表达式（即使在.text段中）也能正常工作，因为它不是一个绝对地址。
- en: 'Of course, you cannot simply load these 64 bits into a register and address
    the memory location at which they point. The value is an offset, not an address.
    However, if you add the address of varPtr to its contents, this will give you
    the address of variable, as demonstrated in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不能简单地将这64位加载到寄存器中并访问它们所指向的内存位置。该值是一个偏移量，而不是一个地址。然而，如果你将varPtr的地址加到它的内容上，你就能得到变量的地址，具体如下代码所示：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This sequence solves the problem with addresses under macOS and happens to work
    just fine under Linux as well. Because this sequence will work under both OSes,
    this book adopts this scheme when fetching addresses from variables in memory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这一序列解决了macOS下地址的问题，并且在Linux下也能很好地工作。因为这一序列在两个操作系统下都能工作，本书在从内存中获取变量地址时采用了这一方案。
- en: Under macOS, this sequence requires varPtr to be in the same .text section as
    the instructions. Otherwise, macOS will complain that varPtr is an absolute address
    and will reject this code. Because I’ve written this book assuming the code will
    generally work under Linux and macOS, I will keep such labels in the .text section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS下，这一序列要求varPtr与指令处于同一.text段中。否则，macOS会抱怨varPtr是一个绝对地址，并拒绝此代码。由于本书假设代码在Linux和macOS下都能正常工作，因此我会将这些标签保留在.text段中。
- en: A single ldr instruction will also work fine under Linux, so if you’re writing
    Linux-only code, the single ldr is more efficient.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux下，单条ldr指令也能正常工作，因此如果你只编写Linux代码，使用单条ldr指令会更高效。
- en: 7.5.3 Dynamically Computing the Address of a Memory Object
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.3 动态计算内存对象的地址
- en: Computing the address of a nonstatic memory object is a bit more involved than
    doing the same for static (.data, .bss, .text, .rodata, and so on) memory objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 计算非静态内存对象的地址比计算静态内存对象（如.data、.bss、.text、.rodata等）的地址稍微复杂一些。
- en: Because every ARM machine instruction is exactly 32 bits in length, you can
    view a .text section containing nothing but machine instructions as an array of
    words, where the value in each word just happens to be the encoding of a machine
    instruction. (This view isn’t 100 percent accurate; if the .text section contains
    data as well as instructions, there are limitations to how far you can go with
    treating the .text section as an array of instructions. However, if you limit
    yourself to those areas that contain only instructions, everything will be fine.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每条ARM机器指令的长度恰好为32位，因此你可以将只包含机器指令的.text段视为一个字数组，其中每个字的值恰好是机器指令的编码。（这个视角并不是100%准确的；如果.text段既包含数据又包含指令，那么将.text段视为指令数组会有一定的局限性。然而，如果你仅限于那些只包含指令的区域，一切都会正常。）
- en: With this in mind, it is possible to manipulate the values in the .text section
    by using the techniques for arrays from section 4.7, “Arrays,” on [page 194](chapter4.xhtml#pg_194).
    This includes techniques such as indexing into arrays and computing the effective
    address of array elements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一点，就可以通过使用第4.7节“数组”（见[第194页](chapter4.xhtml#pg_194)）中有关数组的技巧来操作.text段中的值。这包括索引数组和计算数组元素的有效地址等技巧。
- en: '> NOTE'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '> 注意'
- en: '*Section 5.6.2, “Passing by Reference,” on [page 256](chapter5.xhtml#pg_256)
    describes a procedure for computing the effective address of an object you reference
    via the ARM’s various addressing modes. For data objects, see that discussion.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*第5.6.2节，“按引用传递”，见[第256页](chapter5.xhtml#pg_256)，描述了一种计算你通过ARM的各种寻址模式引用的对象的有效地址的过程。有关数据对象的内容，请参见该讨论。*'
- en: 'Consider the following instruction sequence of arbitrary instructions cut from
    Listing 7-2:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请看下面这段从列表7-2中剪切出来的任意指令序列：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The label goodInput is the base address of an array of five words containing
    the five instructions in this short sequence. You can, of course, take the base
    address of this array by using the adr instruction (or lea if this sequence is
    too far away). Once you have this base address in a register (such as X0), you
    can use the array-indexing calculation to compute the address of a particular
    entry in the array:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 标签goodInput是包含这短序列五条指令的五个字的数组的基地址。当然，你可以通过使用adr指令（或者如果序列距离较远，则使用lea指令）来获取这个数组的基地址。一旦你将这个基地址存入寄存器（例如X0），你就可以使用数组索引计算来计算数组中某个特定条目的地址：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The element_size value is 4, as each instruction is 32 bits. Index 0 specifies
    the mov instruction, index 1 specifies the adr instruction, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: element_size值为4，因为每条指令是32位的。索引0指定mov指令，索引1指定adr指令，依此类推。
- en: 'Given an index value in X1, you can transfer control directly to one of these
    five instructions by using the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 给定X1中的索引值，你可以使用以下代码直接将控制转移到这五条指令中的一条：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The add instruction multiplies the index (X1) by 4 before adding it to the base
    address. This computes the byte address of the specified instruction in the sequence;
    then br transfers control to the instruction.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: add指令在将索引（X1）乘以4后加到基地址上。这计算出指定指令在序列中的字节地址；然后br将控制转移到该指令。
- en: In many respects, this is similar to a switch or case statement, where a unique
    case is associated with each instruction in the sequence. This chapter considers
    such control structures in section 7.6.7, “switch...case Statements,” on [page
    389](chapter7.xhtml#pg_389). In the meantime, just know that you can dynamically
    compute the address of one of the instructions in this sequence by using normal
    effective address calculations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，这类似于一个switch或case语句，每个指令与序列中的一个唯一案例相关联。本章将在7.6.7节“switch...case语句”中讨论此类控制结构，见[第389页](chapter7.xhtml#pg_389)。在此之前，只需知道，你可以通过正常的有效地址计算动态计算这个序列中某条指令的地址。
- en: 7.5.4 Working with Veneers
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.4 使用外壳
- en: In the rare case you need to branch to a location beyond the range of the conditional
    branch instructions, you can use an instruction sequence such as the following
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果你需要跳转到超出条件分支指令范围的位置，你可以使用如下指令序列：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: where bccopposite is the opposite of the branch you want to take. This opposite
    branch skips over the code that transfers control to the target location. This
    provides you with the 4GB range of the lea macro, which should be sufficient if
    you’re branching to code in your program. The opposite conditional branch transfers
    control to the normal *fall-though point* in the code (the code you’d normally
    fall through to if the condition is false). If the condition is true, control
    transfers to a memory-indirect jump that jumps to the original target location
    via a 64-bit pointer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其中bccopposite是你想要采取的分支的对立分支。这个对立分支跳过将控制转移到目标位置的代码。这为你提供了lea宏的4GB范围，如果你是跳转到程序中的代码，这个范围应该足够了。对立的条件分支将控制转移到代码中的正常*顺序执行点*（如果条件为假，你通常会跳转到这个点）。如果条件为真，控制将转移到一个通过64位指针跳转到原始目标位置的内存间接跳转。
- en: This sequence is known as a *veneer* (or a *trampoline*), because a program
    jumps to this point to move even further in the program—much like jumping on a
    trampoline lets you jump higher and higher. Veneers are useful for call and unconditional
    jump instructions that use the PC-relative addressing mode (and thus are limited
    to a ±1MB range around the current instruction). You’ll rarely use veneers to
    transfer to another location within your program, since it’s unlikely you’ll write
    assembly language programs that large.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列被称为*外壳*（或*蹦床*），因为程序跳到这一点以便进一步执行——就像跳到蹦床上让你越跳越高一样。外壳对于使用PC相对寻址模式的调用和无条件跳转指令非常有用（因此其范围限制在当前指令周围的±1MB）。你很少会使用外壳跳转到程序中的另一个位置，因为你不太可能编写如此大的汇编语言程序。
- en: Note the use of the X16 register in this example. The ARM ABI reserves registers
    X16 and X17 for dynamic linking and veneer use. You’re free to use these two as
    volatile registers with the expectation that their contents may be changed upon
    executing a branch instruction (of any kind, though generally a bl instruction).
    Compilers and linkers will typically modify an out-of-range branch instruction
    to transfer code to a nearby veneer, which then transfers control the full distance
    to the actual destination. When creating your own veneers, it makes sense to use
    these registers as temporaries for that purpose.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在此示例中使用了 X16 寄存器。ARM ABI 保留了 X16 和 X17 寄存器用于动态链接和外层使用。您可以自由地将这两个寄存器作为易失性寄存器使用，前提是执行分支指令时，它们的内容可能会发生变化（无论何种类型的分支指令，通常是
    bl 指令）。编译器和链接器通常会修改超出范围的分支指令，将代码转移到一个附近的外层，再由该外层转移控制到实际目的地。在创建您自己的外层时，使用这些寄存器作为临时寄存器是合理的做法。
- en: Branching to code outside this range generally means you’re transferring control
    to a function in a shared (or dynamically linked) library. See the appropriate
    documentation for your OS for details on such libraries.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 分支到此范围外的代码通常意味着您将控制转移到共享（或动态链接）库中的一个函数。有关此类库的详细信息，请参阅操作系统的相关文档。
- en: '[Table 7-1](chapter7.xhtml#tab7-1) lists the opposite conditions; refer to
    [Table 2-11](chapter2.xhtml#tab2-11) on [page 82](chapter2.xhtml#pg_82) for the
    available opposite branch macros in *aoaa.inc*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-1](chapter7.xhtml#tab7-1) 列出了对立条件；有关 *aoaa.inc* 中可用的对立分支宏，请参见 [表 2-11](chapter2.xhtml#tab2-11)
    和 [第 82 页](chapter2.xhtml#pg_82)。'
- en: 'Table 7-1: Opposite Conditions'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1：对立条件
- en: '| Branch condition | Opposite |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 分支条件 | 对立 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| eq | ne |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| eq | ne |'
- en: '| ne | eq |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| ne | eq |'
- en: '| hi | ls |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| hi | ls |'
- en: '| hs | lo |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| hs | lo |'
- en: '| lo | hs |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| lo | hs |'
- en: '| ls | hi |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| ls | hi |'
- en: '| gt | le |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| gt | le |'
- en: '| ge | lt |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| ge | lt |'
- en: '| lt | ge |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| lt | ge |'
- en: '| le | gt |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| le | gt |'
- en: '| cs | cc |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| cs | cc |'
- en: '| cc | cs |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| cc | cs |'
- en: '| vs | vc |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| vs | vc |'
- en: '| vc | vs |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| vc | vs |'
- en: '| mi | pl |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| mi | pl |'
- en: '| pl | mi |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| pl | mi |'
- en: 'If the destination location is beyond the ±4GB range of the lea macro, you’ll
    need to create a 4-byte pointer (offset) to the actual location and use code such
    as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标位置超出了 lea 宏的±4GB范围，则需要创建一个4字节指针（偏移量）指向实际位置，并使用如下代码：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This particular sequence is sufficiently useful that the *aoaa.inc* include
    file provides a macro that expands to it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一特定的序列足够有用，以至于 *aoaa.inc* 包含文件提供了一个宏来扩展它：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you need to call a procedure that’s more than ±4GB away, you could emit
    similar code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要调用一个超过±4GB范围的过程，您可以发出类似的代码：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, it’s easier to do this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，做法更简单的是：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the discussion of veneers out of the way, the next section can discuss
    how to implement HLL-like control structures in assembly language.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过讨论外层代码后，下一节将讨论如何在汇编语言中实现类似于高级语言（HLL）的控制结构。
- en: 7.6 Implementing Common Control Structures in Assembly Language
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6 在汇编语言中实现常见控制结构
- en: This section shows you how to implement HLL-like control structures such as
    decisions, loops, and other control constructs by using pure assembly language.
    It concludes by showing some ARM instructions designed for creating common loops.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何使用纯汇编语言实现类似于高级语言（HLL）的控制结构，如决策、循环和其他控制结构。最后，将展示一些用于创建常见循环的 ARM 指令。
- en: Throughout many of the following examples, this chapter assumes that various
    variables are local variables in the activation record (indexed off of the FP
    register) or static/global variables indexed off the SB (X28) register. We presume
    that appropriate structure declarations have been made for all the variable’s
    identifiers and that the FP/SB registers have been properly initialized to point
    at these structures.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的许多示例中，本章假设各种变量是激活记录中的局部变量（通过 FP 寄存器索引）或通过 SB（X28）寄存器索引的静态/全局变量。我们假定已为所有变量的标识符做出适当的结构声明，并且
    FP/SB 寄存器已正确初始化以指向这些结构。
- en: 7.6.1 Decisions
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.1 决策
- en: 'In its most basic form, a *decision* is a branch within the code that switches
    between two possible execution paths based on a certain condition. Normally (though
    not always), conditional instruction sequences are implemented with the conditional
    jump instructions. Conditional instructions correspond to the following if...then...endif
    statement in an HLL:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的形式中，*决策*是代码中的一个分支，它根据某个条件在两条可能的执行路径之间切换。通常（但并非总是），条件指令序列是通过条件跳转指令实现的。条件指令对应于高级语言（HLL）中的以下
    if...then...endif 语句：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To convert this to assembly language, you must write statements that evaluate
    the expression and then branch around the statements if the result is false. For
    example, if you had the C statements
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其转换为汇编语言，必须编写评估表达式的语句，并在结果为假时绕过这些语句。例如，如果你有如下的 C 语句：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'you could translate this to assembly as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其转换为汇编语言，如下所示：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In general, conditional statements may be broken into three basic categories:
    if statements, switch...case statements, and indirect jumps. Next, you’ll learn
    about these program structures, how to use them, and how to write them in assembly
    language.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，条件语句可以分为三类：if 语句、switch...case 语句和间接跳转。接下来，你将学习这些程序结构，如何使用它们以及如何在汇编语言中编写它们。
- en: 7.6.2 if...then...else Sequences
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.2 if...then...else 序列
- en: The most common conditional statements are the if...then...endif and if...then...else...endif
    statements. These two statements take the form shown in [Figure 7-1](chapter7.xhtml#fig7-1).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的条件语句是 if...then...endif 和 if...then...else...endif 语句。这两个语句的形式如[图 7-1](chapter7.xhtml#fig7-1)所示。
- en: '![](../images/Figure7-1.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-1.jpg)'
- en: 'Figure 7-1: The if...then...else...endif and if...then...endif statements'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：if...then...else...endif 和 if...then...endif 语句
- en: The if...then...endif statement is just a special case of the if...then...else...endif
    statement (with an empty else block). The basic implementation of an if...then...else...endif
    statement in ARM assembly language looks something like this
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: if...then...endif 语句只是 if...then...else...endif 语句的特殊情况（没有 else 块）。在 ARM 汇编语言中，if...then...else...endif
    语句的基本实现看起来像这样：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: where bcc represents a conditional branch instruction (typically the opposite
    branch of the condition being tested).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 bcc 代表条件分支指令（通常是条件测试的相反分支）。
- en: 'For example, suppose you want to convert the C/C++ statement into assembly
    language:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想将 C/C++ 语句转换为汇编语言：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To do so, you could use the following ARM code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你可以使用以下 ARM 代码：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For simple expressions like (aa == bb), generating the proper code for an if...then...else...endif
    statement is easy. Should the expression become more complex, the code complexity
    increases as well. Consider the following C/C++ if statement:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 (aa == bb) 这样的简单表达式，为 if...then...else...endif 语句生成正确的代码是容易的。如果表达式变得更复杂，代码的复杂性也会增加。考虑以下
    C/C++ if 语句：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To convert a complex if statement such as this one, break it into a sequence
    of three if statements as follows (assuming the use of short-circuit evaluation;
    see section 7.6.5, “Short-Circuit vs. Complete Boolean Evaluation,” on [page 382](chapter7.xhtml#pg_382)
    for details):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个复杂的 if 语句转换为如下所示的三条 if 语句序列（假设使用短路求值；详情见第 7.6.5 节，“短路与完整布尔求值”，在[第 382 页](chapter7.xhtml#pg_382)）：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This conversion comes from the following C/C++ equivalences:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换来自以下 C/C++ 等式：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: is equivalent to
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: and
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: is equivalent to
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In assembly language, the former if statement becomes the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，前面的 if 语句变成如下所示：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note the use of opposite branches to suggest that falling through is the main
    condition to consider.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用相反分支，表明掉落是要考虑的主要条件。
- en: 'The biggest problem with complex conditional statements in assembly language
    is trying to figure out what you’ve done after you’ve written the code. HLL expressions
    are much easier to read and comprehend, so well-written comments are essential
    for clear assembly language implementations of if...then...else...endif statements.
    The following code shows an elegant implementation of the preceding example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言中复杂条件语句的最大问题是，在写完代码后很难弄清楚自己做了什么。高级语言表达式更容易阅读和理解，因此，良好的注释对于清晰的汇编语言实现 if...then...else...endif
    语句至关重要。以下代码展示了前面示例的优雅实现：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Whenever you’re working in assembly language, don’t forget to step back for
    a moment and see if you can rethink the solution in assembly language rather than
    playing “human C/C++ compiler.” When working with a complex Boolean expression,
    your first thought should be, “Can I use the conditional compare instruction to
    resolve this?” The following example does just that:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在汇编语言中工作时，不要忘记稍微停下来，看看是否可以用汇编语言重新思考解决方案，而不是扮演“人类 C/C++ 编译器”的角色。在处理复杂的布尔表达式时，你的第一个想法应该是：“我能否使用条件比较指令来解决这个问题？”以下示例正是这么做的：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The cmp instruction sets the flags for (x > y). The first ccmp instruction sets
    the flags to simulate a signed ge (not less than) if (x <= y) or based on the
    comparison of (z < t) if (x > y). After executing the first ccmp instruction,
    N ≠ V if (x > y) && (z < t).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: cmp指令设置（x > y）的标志。第一条ccmp指令设置标志来模拟符号ge（不小于），如果（x <= y），或者基于（z < t）的比较，如果（x >
    y）。在执行第一条ccmp指令后，如果（x > y）&&（z < t），则N ≠ V。
- en: Upon executing the second ccmp instruction, if N ≠ V (meaning signed less than),
    the code just sets NZCV to simulate ne and doesn’t bother comparing aa and bb
    (because the left-hand side of the disjunction operator is already true, there
    is no need to evaluate the third parenthetical expression). Setting Z = 0 means
    the csel instruction will copy d to c (based on the ne condition).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行第二条ccmp指令时，如果N ≠ V（意味着符号小于），代码会设置NZCV来模拟ne，并且不再比较aa和bb（因为析取操作符的左侧已经为真，无需再计算第三个括号表达式）。设置Z
    = 0意味着csel指令会将d复制到c（基于ne条件）。
- en: If N = V when executing the second ccmp instruction, the ge condition is true,
    which means that the conjunction operation yielded false and you must test to
    see if aa does not equal bb. That will set the flags appropriately for the csel
    instruction. Listing 7-3 demonstrates the execution of this conditional comparison
    code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行第二条ccmp指令时N = V，ge条件为真，这意味着与操作结果为假，你必须测试aa是否不等于bb。这将为csel指令设置适当的标志。列表7-3展示了该条件比较代码的执行。
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s the build command and sample output for Listing 7-3:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列表7-3的构建命令和示例输出：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The output shows the truth table for the given expression.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了给定表达式的真值表。
- en: 7.6.3 Complex if Statements Using Complete Boolean Evaluation
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.3 使用完整布尔评估的复杂if语句
- en: 'Many Boolean expressions involve conjunction (AND) or disjunction (OR) operations.
    You can convert such Boolean expressions into assembly language in two ways: using
    *complete Boolean evaluation* or using *short-circuit Boolean evaluation*. This
    section discusses complete Boolean evaluation, and the next discusses short-circuit
    Boolean evaluation.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 许多布尔表达式涉及与（AND）或或（OR）操作。你可以通过两种方式将这样的布尔表达式转换成汇编语言：使用*完整布尔评估*或使用*短路布尔评估*。本节讨论完整布尔评估，下一节讨论短路布尔评估。
- en: 'Conversion via complete Boolean evaluation is almost identical to converting
    arithmetic expressions into assembly language, as covered in section 6.4, “Logical
    Expressions,” on [page 312](chapter6.xhtml#pg_312). However, for Boolean evaluation,
    you do not need to store the result in a variable; once the evaluation of the
    expression is complete, you check whether you have a false (0) or true (1, or
    nonzero) result to take whatever action the Boolean expression dictates. Remember
    that only the ands instruction sets the zero flag; there is no orrs instruction.
    Consider the following if statement and its conversion to assembly language using
    complete Boolean evaluation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完整布尔评估进行转换几乎与将算术表达式转换为汇编语言相同，详见第6.4节“逻辑表达式”，[第312页](chapter6.xhtml#pg_312)。然而，对于布尔评估，你不需要将结果存储在变量中；一旦表达式评估完成，你只需要检查结果是假的（0）还是正确的（1，或非零），然后执行布尔表达式指示的操作。记住，只有ands指令会设置零标志；没有orrs指令。考虑以下if语句及其通过完整布尔评估转换为汇编语言的例子：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code computes a Boolean result in the W0 register and then, at the end
    of the computation, tests this value to see whether it contains true or false.
    If the result is false, this sequence skips over the code associated with Stmt1.
    The important thing is that the program will execute every instruction that computes
    this Boolean result (up to the beq instruction).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码计算一个布尔结果到W0寄存器，然后，在计算结束时，测试该值看它是包含真还是假。如果结果为假，这段序列会跳过与Stmt1相关的代码。重要的是，程序会执行每一条计算布尔结果的指令（直到beq指令）。
- en: 'By now you should recognize that we can improve this code by using the ccmp
    instruction:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在你应该已经认识到，通过使用ccmp指令，我们可以改进这段代码：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The code is still a bit longer than usual, but this is the result of using memory
    variables rather than registers for everything in this example. Even though this
    example uses the ccmp instruction, the code still executes each and every instruction
    in the sequence, even if the condition becomes false early on and could never
    become true.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 代码仍然比平常稍长，但这是因为在这个例子中使用了内存变量而不是寄存器。即使这个例子使用了ccmp指令，代码仍然会执行每一条指令，即使条件在一开始就变为假，且永远不会变为真。
- en: 7.6.4 Short-Circuit Boolean Evaluation
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.4 短路布尔评估
- en: If you are willing to expend a little more effort (and your Boolean expression
    doesn’t depend on side effects), you can often convert a Boolean expression to
    a faster sequence of assembly language instructions by using *short-circuit Boolean
    evaluation*. This approach attempts to determine whether an expression is true
    or false by executing only some of the instructions that would compute the complete
    expression.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意付出更多的努力（并且你的布尔表达式不依赖副作用），你通常可以通过使用*短路布尔评估*将布尔表达式转换为更快速的汇编语言指令序列。这种方法试图通过只执行计算完整表达式的一部分指令，来判断一个表达式是真还是假。
- en: Consider the expression aa && bb. Once you determine that aa is false, there
    is no need to evaluate bb because there is no way the expression can be true.
    If bb represents a complex subexpression rather than a single Boolean variable,
    it should be clear that evaluating only aa is more efficient.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表达式aa && bb。一旦你确定aa为假，就不需要再评估bb，因为无论bb的值是什么，表达式都无法为真。如果bb表示一个复杂的子表达式，而不是一个单一的布尔变量，那么只评估aa会显得更加高效。
- en: 'As a concrete example, consider the subexpression ((x < y) && (z > t)). Once
    you determine that x is not less than y, there is no need to check whether z is
    greater than t because the expression will be false regardless of the values of
    z and t. The following code fragment shows how to implement short-circuit Boolean
    evaluation for this expression:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，考虑子表达式((x < y) && (z > t))。一旦你确定x不小于y，就无需再检查z是否大于t，因为无论z和t的值如何，表达式都会为假。以下代码片段展示了如何为这个表达式实现短路布尔评估：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The code skips any further testing once it determines that x is not less than
    y. Of course, if x is less than y, the program has to test z to see if it is greater
    than t; if not, the program skips over the then clause. Only if the program satisfies
    both conditions does the code fall through to the then clause.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码确定x不小于y，它就跳过任何进一步的测试。当然，如果x小于y，程序必须测试z是否大于t；如果不是，程序会跳过then语句块。只有当程序满足两个条件时，代码才会进入then语句块。
- en: 'For the logical OR operation, the technique is similar. If the first subexpression
    evaluates to true, there is no need to test the second operand. Whatever the second
    operand’s value is at that point, the full expression still evaluates to true.
    The following example demonstrates the use of short-circuit evaluation with disjunction
    (||):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逻辑“或”操作，技巧是类似的。如果第一个子表达式的值为真，就无需再测试第二个操作数。无论第二个操作数的值是什么，整个表达式仍然会为真。以下例子展示了如何在使用析取（||）时应用短路评估：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Because the conjunction and disjunction operators are commutative, you can evaluate
    the left or right operand first if it is more convenient to do so.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于合取和析取运算符是可交换的，如果更方便，你可以先评估左侧或右侧操作数。
- en: Be aware that some expressions depend on the leftmost subexpression evaluating
    one way in order for the rightmost subexpression to be valid; if(x != NULL &&
    x -> y) is a common test in C/C++, for example.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有些表达式依赖于最左侧子表达式的评估方式，以确保最右侧子表达式的有效性；例如，在C/C++中，if(x != NULL && x -> y)就是一个常见的测试。
- en: 'As one last example in this section, consider the full Boolean expression from
    the previous section:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的最后一个例子，考虑上一节中的完整布尔表达式：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The code in this example evaluates aa != bb first, because it is shorter and
    faster, and the remaining subexpression last. This is a common technique assembly
    language programmers use to write better code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的代码首先评估aa != bb，因为它更短且更快，然后最后评估剩余的子表达式。这是汇编语言程序员常用的技巧，用来编写更高效的代码。
- en: This assumes, of course, that all comparisons are equally likely to be true
    or false. If you can predict that the subexpression aa != bb will be false the
    vast majority of the time, it would be best to test that condition last.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这假设所有的比较在真或假之间的概率是相等的。如果你能预测子表达式aa != bb在绝大多数情况下为假，那么最好将该条件最后测试。
- en: '#### 7.6.5 Short-Circuit vs. Complete Boolean Evaluation'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 7.6.5 短路与完全布尔评估'
- en: When using complete Boolean evaluation, every statement in the sequence for
    that expression will execute; short-circuit Boolean evaluation, on the other hand,
    may not require the execution of every statement associated with the Boolean expression.
    As you’ve seen in the previous two sections, code based on short-circuit evaluation
    is often shorter and possibly faster.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全布尔评估时，表达式中每个语句都会执行；而短路布尔评估则可能不需要执行与布尔表达式相关的每个语句。正如你在前两节中看到的，基于短路评估的代码通常更简洁，且可能更快。
- en: 'However, short-circuit Boolean evaluation may not produce the correct result
    in some cases. Given an expression with *side effects* (changes to variables within
    the expression), short-circuit Boolean evaluation will produce a different result
    than complete Boolean evaluation. Consider the following C/C++ example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，短路布尔评估在某些情况下可能无法产生正确的结果。给定一个带有 *副作用*（表达式中变量的变化）的表达式，短路布尔评估会产生与完全布尔评估不同的结果。考虑以下
    C/C++ 示例：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using complete Boolean evaluation, you might generate the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全布尔评估时，你可能会生成如下代码：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The ccmp instruction compares the incremented value of z against 0, but only
    if x is equal to y. If x is not equal to y, the ccmp instruction sets the Z flag
    to 1 so that control transfers to SkipStmt with the following beq instruction.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ccmp 指令将 z 增加后的值与 0 进行比较，但仅在 x 等于 y 时执行。如果 x 不等于 y，ccmp 指令会将 Z 标志设置为 1，从而控制转移到
    SkipStmt，并执行以下 beq 指令。
- en: 'Using short-circuit Boolean evaluation, you might generate the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短路布尔评估时，你可能会生成如下代码：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A subtle but important difference exists between these two conversions: if
    x is equal to y, the first version still *increments* z *and compares it to 0*
    before it executes the code associated with Stmt. The short-circuit version, on
    the other hand, skips the code that increments z if it turns out that x is equal
    to y. Therefore, the behavior of these two code fragments is different if x is
    equal to y.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种转换之间存在一个微妙但重要的差异：如果 x 等于 y，第一种版本仍然会 *递增* z，并 *与 0 进行比较*，然后才执行与 Stmt 相关的代码。另一方面，短路版本在发现
    x 等于 y 时会跳过递增 z 的代码。因此，如果 x 等于 y，这两段代码的行为是不同的。
- en: Neither implementation is wrong; depending on the circumstances, you may or
    may not want the code to increment z if x is equal to y. However, it is important
    to realize that these two schemes produce different results, so you can choose
    an appropriate implementation if the effect of this code on z matters to your
    program.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 两种实现方式都没有错；根据具体情况，你可能希望或不希望当 x 等于 y 时，代码增加 z 的值。然而，重要的是要意识到这两种方案会产生不同的结果，因此如果此代码对
    z 的影响对程序至关重要，你可以选择合适的实现。
- en: 'Many programs take advantage of short-circuit Boolean evaluation and rely on
    the program not evaluating certain components of the expression. The following
    C/C++ code fragment demonstrates perhaps the most common example that requires
    short-circuit Boolean evaluation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序利用短路布尔评估，并依赖程序不评估表达式的某些部分。以下 C/C++ 代码片段演示了可能最常见的需要短路布尔评估的例子：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If it turns out that pntr is NULL, the expression is false, and there is no
    need to evaluate the remainder of the expression. This statement relies on short-circuit
    Boolean evaluation for correct operation. Were C/C++ to use complete Boolean evaluation,
    the second half of the expression would attempt to dereference a NULL pointer,
    when pntr is NULL.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 pntr 结果为 NULL，则该表达式为假，不需要评估表达式的其余部分。此语句依赖于短路布尔评估才能正确操作。如果 C/C++ 使用完全布尔评估，表达式的后半部分将尝试取消引用一个
    NULL 指针，而此时 pntr 为 NULL。
- en: 'Consider the translation of this statement using complete Boolean evaluation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用完全布尔评估翻译该语句：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If pntr contains NULL (0), this program will attempt to access the data at location
    0 in memory via the ldrb w0, [x0] instruction. Under most OSes, this will cause
    a memory access fault (segmentation fault).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 pntr 包含 NULL（0），该程序将尝试通过 ldrb w0, [x0] 指令访问内存中位置为 0 的数据。在大多数操作系统中，这将导致内存访问故障（段错误）。
- en: 'Now consider the short-circuit Boolean conversion:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑短路布尔转换：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, the problem with dereferencing the NULL pointer doesn’t exist.
    If pntr contains NULL, this code skips over the statements that attempt to access
    the memory address that pntr contains.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，取消引用 NULL 指针的问题不存在。如果 pntr 包含 NULL，这段代码会跳过那些尝试访问 pntr 所包含的内存地址的语句。
- en: 7.6.6 Efficient Implementation of if Statements in Assembly Language
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.6 在汇编语言中高效实现 if 语句
- en: Encoding if statements efficiently in assembly language takes a little more
    thought than simply choosing short-circuit evaluation over complete Boolean evaluation.
    To write code that executes as quickly as possible in assembly language, you must
    carefully analyze the situation and generate the code appropriately. The following
    paragraphs provide suggestions you can apply to your programs to improve their
    performance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中高效地编码 if 语句比仅仅选择短路求值而不是完全布尔求值需要更多的思考。为了编写能够尽可能快速执行的汇编语言代码，你必须仔细分析情况并适当生成代码。以下段落提供了一些建议，可以帮助你提升程序的性能。
- en: 7.6.6.1 Knowing Your Data
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.6.1 了解你的数据
- en: 'Programmers often mistakenly assume that data is random. In reality, data is
    rarely random, and if you know the types of values that your program commonly
    uses, you can write better code. To see how, consider the following C/C++ statement:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常错误地假设数据是随机的。实际上，数据很少是随机的，如果你了解程序常用的值的类型，你就可以编写更好的代码。为了理解如何做到这一点，考虑下面的 C/C++
    语句：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Because C/C++ uses short-circuit evaluation, this code will test whether aa
    is equal to bb. If so, it will test whether c is less than d. If you expect aa
    to be equal to bb most of the time but don’t expect c to be less than d most of
    the time, this statement will execute slower than it should. Consider the following
    Gas implementation of this code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 C/C++ 使用短路求值，这段代码将测试 aa 是否等于 bb。如果是，它将测试 c 是否小于 d。如果你期望 aa 大多数时候等于 bb，但不期望
    c 大多数时候小于 d，这段代码的执行速度将比预期的要慢。考虑以下 Gas 实现的代码：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As you can see, if aa is equal to bb most of the time and c is not less than
    d most of the time, you will have to execute the first eight instructions nearly
    every time in order to determine that the expression is false. Now consider the
    following implementation that takes advantage of this knowledge and the fact that
    the && operator is commutative:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果 aa 大多数时候等于 bb，且 c 大多数时候不小于 d，你将几乎每次都执行前八条指令，以确定表达式是假的。现在，考虑以下实现，它利用了这一知识以及
    && 运算符是交换律的事实：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The code first checks whether c is less than d. If most of the time c is not
    less than d, this code determines that it has to skip to the label DontIncI after
    executing only three instructions in the typical case, compared with seven instructions
    in the previous example.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查 c 是否小于 d。如果大多数情况下 c 不小于 d，这段代码将在典型情况下只执行三条指令后跳转到标签 DontIncI，而与之前的例子相比，它需要执行七条指令。
- en: Optimizations like this are much more obvious in assembly language than in an
    HLL, one of the main reasons assembly programs are often faster than their HLL
    counterparts. The key here is to understand the behavior of your data so you can
    make intelligent decisions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的优化在汇编语言中比在高级语言（HLL）中更为明显，这也是汇编程序通常比高级语言程序更快的主要原因之一。关键在于理解数据的行为，以便做出明智的决策。
- en: 7.6.6.2 Rearranging Expressions
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.6.2 重排表达式
- en: 'Even if your data is random, or you can’t determine how the input values will
    affect your decisions, rearranging the terms in your expressions may still be
    beneficial. Some calculations take far longer to compute than others. For example,
    computing the remainder is slower than a simple cmp instruction. Therefore, if
    you have a statement like the following, you may want to rearrange the expression
    so that the cmp comes first:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的数据是随机的，或者你无法确定输入值将如何影响你的决策，重新排列表达式中的项仍然可能是有益的。一些计算的执行时间远比其他的要长。例如，计算余数比简单的
    cmp 指令慢。因此，如果你有像下面这样的语句，你可能想要重新排列表达式，使 cmp 语句排在前面：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Converted directly to assembly code, this if statement becomes the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 直接转换为汇编代码后，这个 if 语句变成了以下形式：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The remainder computation is expensive (about one-third the speed of most of
    the other instructions in this example). Unless it is three times more likely
    that the remainder is 0 rather than x is equal to y, it would be better to do
    the comparison first and the remainder calculation afterward:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 余数计算很耗时（大约是此例中其他指令速度的三分之一）。除非余数为 0 的可能性比 x 等于 y 的可能性大三倍，否则最好先进行比较，然后再进行余数计算：
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The && and || operators are commutative in the mathematical sense that if you
    evaluate that left or right side first, the logical result is the same. In terms
    of execution, they are not commutative because the order of evaluation may cause
    the code to skip the evaluation of the second subexpression; in particular, these
    operators may not be commutative if side effects occur within the expression.
    This example works fine because there are no side effects or possible exceptions
    being shielded by the reordered evaluation of the && operator.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '&& 和 || 运算符在数学意义上是可交换的，即无论先计算左侧还是右侧，逻辑结果是相同的。但在执行时，它们并不是可交换的，因为评估顺序可能导致跳过第二个子表达式的评估；特别是，如果表达式中存在副作用，这些运算符可能不具有可交换性。这个例子没有问题，因为没有副作用或可能被重新排序的
    && 运算符屏蔽的异常。'
- en: 7.6.6.3 Destructuring Code
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.6.3 解构代码
- en: Structured code is sometimes less efficient than unstructured code because it
    introduces code duplication or extra branches that might not be present in unstructured
    code. Most of the time, this is tolerable because unstructured code is difficult
    to read and maintain; sacrificing some performance in exchange for maintainable
    code is often acceptable. In certain instances, however, you may need all the
    performance you can get and might choose to compromise the readability of your
    code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化代码有时比非结构化代码效率低，因为它可能引入代码重复或额外的分支，这些在非结构化代码中可能不存在。大多数时候，这是可以容忍的，因为非结构化代码难以阅读和维护；为了可维护的代码而牺牲一些性能通常是可以接受的。然而，在某些情况下，你可能需要尽可能多的性能，并可能选择牺牲代码的可读性。
- en: In HLLs, you can often get away with writing structured code because the compiler
    will optimize it, producing unstructured machine code. Unfortunately, when writing
    in assembly language, the machine code you get is exactly equivalent to the assembly
    code you write.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级语言中，你通常可以通过编写结构化代码来避免问题，因为编译器会优化它，生成非结构化的机器代码。不幸的是，在汇编语言中，你得到的机器代码与所写的汇编代码完全等效。
- en: Taking previously written structured code and rewriting it in an unstructured
    fashion to improve performance is known is *destructuring code*. The difference
    between unstructured code and destructured code is that unstructured code was
    written that way in the first place; destructured code started out as structured
    code and was purposefully written in an unstructured fashion to make it more efficient.
    Pure unstructured code is usually hard to read and maintain. Destructured code
    isn’t quite as bad because you limit the damage (unstructuring the code) to only
    those sections where it is absolutely necessary.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前编写的结构化代码重新编写为非结构化代码以提高性能被称为*解构代码*。非结构化代码和解构代码的区别在于，非结构化代码一开始就是以这种方式编写的；解构代码最初是结构化代码，并被故意以非结构化的方式编写，以提高其效率。纯粹的非结构化代码通常难以阅读和维护。解构代码则不那么糟糕，因为你将代码的“非结构化”限制在那些绝对需要的部分。
- en: One classic way to destructure code is to use *code movement*, physically moving
    sections of code elsewhere in the program. You move code that your program rarely
    uses out of the way of code that executes most of the time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 解构代码的经典方法之一是使用*代码移动*，将代码的某些部分物理移到程序的其他地方。你将程序中不常用的代码移到不妨碍大多数时候执行的代码的地方。
- en: Code movement can improve the efficiency of a program two ways. First, a branch
    that is taken is more expensive (time-consuming) than a branch that is not taken.
    If you move the rarely used code to another spot in the program and branch to
    it on the rare occasion the branch is taken, most of the time you will fall straight
    through to the code that executes most frequently. Second, sequential machine
    instructions consume cache storage. If you move rarely executed statements out
    of the normal code stream to another section of the program that is rarely loaded
    into cache, this will improve the cache performance of the system.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 代码移动可以通过两种方式提高程序的效率。首先，执行的分支比未执行的分支更昂贵（耗时）。如果你将不常用的代码移到程序的另一个位置，并在分支被执行的少数情况下跳转到它，大多数时候你将直接跳到最常执行的代码。其次，顺序的机器指令会消耗缓存存储。如果你将不常执行的语句移出正常的代码流，放到程序中一个不常加载到缓存中的部分，这将提高系统的缓存性能。
- en: 'For example, consider the following pseudo C/C++ statement:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下伪 C/C++ 语句：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In normal code, you don’t expect errors to be frequent. Therefore, you would
    typically expect the then section of the preceding if to execute far more often
    than the else clause. The preceding code could translate into the following assembly
    code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的代码中，你不期望错误发生得很频繁。因此，你通常期望前面 if 语句中的 then 部分比 else 子句更常执行。前面的代码可能会翻译成以下汇编代码：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If the expression is false, this code falls through to the normal statements
    and then jumps over the error-handling statements. Instructions that transfer
    control from one point in your program to another (for example, b.al instructions)
    tend to be slow. It is much faster to execute a sequential set of instructions
    than to jump all over the place in your program. Unfortunately, the preceding
    code doesn’t allow this.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式为假，这段代码会跳过错误处理语句，直接执行正常的语句。将程序中的控制从一个点转移到另一个点的指令（例如，b.al 指令）通常会很慢。执行一组顺序指令比在程序中到处跳转要快得多。不幸的是，前面的代码并不允许这样做。
- en: 'One way to rectify this problem is to move the else clause of the code somewhere
    else in your program. You could rewrite the code as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是将代码中的 else 子句移动到程序的其他地方。你可以像下面这样重写代码：
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The program isn’t any shorter. The b.al you removed from the original sequence
    winds up at the end of the else clause. However, because the else clause rarely
    executes, moving the b.al instruction from the then clause (which executes frequently)
    to the else clause is a big performance win, because the then clause executes
    using only straight-line code. This technique is surprisingly effective in many
    time-critical code segments.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 程序并没有变得更短。你从原始序列中移除的 b.al 最终会出现在 else 子句的末尾。然而，由于 else 子句很少执行，将 b.al 指令从经常执行的
    then 子句移到 else 子句是一个巨大的性能提升，因为 then 子句仅使用直线代码执行。这种技巧在许多时间关键的代码段中非常有效。
- en: 7.6.6.4 Calculating Rather than Branching
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.6.4 计算而非分支
- en: On the ARM processor, branches are expensive compared to many other instructions.
    For this reason, it is sometimes better to execute more instructions in a sequence
    than fewer instructions that involve branching.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ARM 处理器中，与许多其他指令相比，分支操作是昂贵的。因此，有时执行更多的顺序指令比执行较少的涉及分支的指令要好。
- en: 'For example, consider the simple assignment w0 = abs(w0). Unfortunately, no
    ARM instruction computes the absolute value of an integer. The obvious way to
    handle this is with an instruction sequence that uses a conditional jump to skip
    over the neg instruction (which creates a positive value in W0 if W0 was negative):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑简单的赋值 w0 = abs(w0)。不幸的是，没有 ARM 指令可以计算整数的绝对值。处理此问题的显而易见方法是使用一个指令序列，通过条件跳转跳过
    neg 指令（如果 W0 为负值，neg 指令会使 W0 变为正值）：
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now consider the following sequence that will also do the job:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下序列，它也能完成任务：
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Not only is the instruction set shorter, it also doesn’t involve any branches,
    so it runs faster. This demonstrates why it’s good to know the instruction set!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅指令集更短，而且不涉及任何分支，因此运行速度更快。这展示了为什么了解指令集是很重要的！
- en: Another example of calculation versus branching that you’ve seen is using the
    ccmp instruction to handle conjunction and disjunction in a Boolean expression
    (see section 7.6.5, “Short-Circuit vs. Complete Boolean Evaluation,” on [page
    382](chapter7.xhtml#pg_382)). Though they tend to execute more instructions than
    short-circuit evaluation, no branching is involved, and this often equates to
    faster-running code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你见过的另一个计算与分支的例子是使用 ccmp 指令处理布尔表达式中的合取与析取（见第 7.6.5 节，“短路与完全布尔运算”，在 [第 382 页](chapter7.xhtml#pg_382)）。虽然它们通常比短路求值执行更多的指令，但不涉及任何分支，而且这通常意味着代码运行得更快。
- en: Sometimes calculation without branching isn’t possible. For certain types of
    branches (in particular, multiway branches), you can combine calculations with
    a single branch to handle complex operations, as discussed in the next section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，无法通过不使用分支来计算。对于某些类型的分支（特别是多路分支），你可以将计算与单一的分支结合起来处理复杂的操作，正如下一节所讨论的那样。
- en: 7.6.7 switch...case Statements
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.7 switch...case 语句
- en: 'The C/C++ switch statement takes the following form:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 的 switch 语句采用以下形式：
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When this statement executes, it checks the value of the expression against
    the constants const1 to constn. If it finds a match, the corresponding statements
    execute.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当这条语句执行时，它会检查表达式的值与常量 const1 到 constn 的匹配情况。如果找到匹配项，相应的语句将执行。
- en: C/C++ places a few restrictions on the switch statement. First, it allows only
    an integer expression (or something whose underlying type can be an integer).
    Second, all the constants in the case clauses must be unique. The next few subsections
    describe the semantics of the switch statement and various implementations and
    clarify the reasons for the restrictions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++对switch语句有一些限制。首先，它只允许一个整数表达式（或其底层类型可以是整数的表达式）。其次，所有case子句中的常量必须是唯一的。接下来的几个小节将描述switch语句的语义以及各种实现方式，并澄清这些限制的原因。
- en: 7.6.7.1 switch Statement Semantics
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.7.1 switch语句的语义
- en: 'Most introductory programming texts introduce the switch...case statement by
    explaining it as a sequence of if...then...elseif...else...endif statements. They
    might claim that the following two pieces of C/C++ code are equivalent:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数入门级编程教材通过将switch...case语句解释为一系列if...then...elseif...else...endif语句来介绍它们。它们可能会声称以下两段C/C++代码是等效的：
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: While semantically these two code segments may be the same, their implementation
    is usually different. Whereas the if...then...elseif...else...endif chain does
    a comparison for each conditional statement in the sequence, the switch statement
    normally uses an indirect jump to transfer control to any one of several statements
    with a single computation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然语义上这两段代码是相同的，但它们的实现通常是不同的。if...then...elseif...else...endif链条会对序列中的每个条件语句进行比较，而switch语句通常使用间接跳转，通过单一的计算将控制权转移到多个语句中的任何一个。
- en: 7.6.7.2 if...else Implementation of switch
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.7.2 if...else 实现 switch
- en: 'The switch (and if...else...elseif) statements could be written in assembly
    language with the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: switch（和if...else...elseif）语句可以用以下汇编代码编写：
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This code takes longer to determine that the last case should execute than it
    does to determine whether the first case executes. This is because the if...else...elseif
    version implements a linear search through the case values, checking them one
    at a time from first to last until it finds a match.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码需要更长的时间来确定最后一个case应该执行，而不是判断第一个case是否执行。这是因为if...else...elseif版本会通过case值进行线性查找，一个一个地检查，直到找到匹配项。
- en: 7.6.7.3 Indirect Jump switch Implementation
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.7.3 间接跳转的switch实现
- en: 'A faster implementation of the switch statement is possible by using an *indirect
    jump table* (a table containing target addresses to jump to). This implementation
    uses the switch expression as an index into a table of addresses; each address
    points at the target case’s code to execute. The following example demonstrates
    the use of a jump table:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用*间接跳转表*（包含跳转目标地址的表），可以实现更快的switch语句。这种实现将switch表达式作为索引，查找地址表中的项；每个地址指向相应case的代码进行执行。以下示例演示了如何使用跳转表：
- en: '[PRE65]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: To use the scaled-indexed addressing mode, this code begins by loading the address
    of the jump table (JmpTbl) into X1 ❶. Because JmpTbl is in the .text section (and
    nearby), the code uses the PC-relative addressing mode.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用缩放索引寻址模式，代码首先将跳转表（JmpTbl）的地址加载到X1 ❶中。由于JmpTbl位于.text段（并且离当前位置较近），代码使用PC相对寻址模式。
- en: 'The code fetches the *i*th entry from JmpTbl ❷. Because each entry in the jump
    table is 8 bytes long, the code must multiply the index (i, which is in X0) by
    8, which the lsl #3 argument handles. The base address (in X1) plus index times
    8 gives the address of the appropriate entry in JmpTbl.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '代码从JmpTbl中获取第*i*项 ❷。由于跳转表中的每一项长度为8字节，代码必须将索引（i，存储在X0中）乘以8，这由lsl #3参数处理。基地址（存储在X1中）加上索引乘以8得到JmpTbl中相应项的地址。'
- en: Because the entries in JmpTbl are offsets rather than absolute addresses (remember,
    macOS doesn’t allow absolute addresses in the .text section), you must convert
    the offset to an absolute address by adding in the base address of the jump table
    ❸ (as each entry in the table is an offset from the base address). The following
    br instruction transfers control to the appropriate case in the switch statement.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JmpTbl中的项是偏移量，而不是绝对地址（请记住，macOS不允许在.text段中使用绝对地址），你必须通过加上跳转表的基地址 ❸来将偏移量转换为绝对地址（因为表中的每一项都是相对于基地址的偏移）。以下br指令将控制权转移到switch语句中相应的case。
- en: To begin, a switch statement requires that you create an array of pointers,
    with each element containing the address of a statement label in your code; those
    labels must be attached to the sequence of instructions to execute for each case
    in the switch statement. As noted in the code annotations, macOS does not allow
    absolute addresses here, so the code uses offsets from the base address of the
    jump table, which also works for Linux. In this example, the JmpTbl array, initialized
    with the offsets of the statement labels Stmt0, Stmt1, and Stmt2, serves this
    purpose. You must place the jump-table array in a location that will never be
    executed as code (such as immediately after a br instruction, as in this example).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，switch语句要求你创建一个指针数组，每个元素包含你代码中某个语句标签的地址；这些标签必须附加到要为每个case执行的指令序列上。如代码注释所示，macOS在这里不允许使用绝对地址，因此代码使用跳转表的基地址的偏移量，这对于Linux也适用。在这个例子中，初始化为Stmt0、Stmt1和Stmt2标签的偏移量的JmpTbl数组就起到了这个作用。你必须将跳转表数组放置在一个永远不会被执行为代码的位置（比如紧接着br指令之后，正如这个例子中所示）。
- en: The program loads the W0 register with the value of i (assuming i is a 32-bit
    unsigned integer, the ldr instruction zero-extends W0 into X0). It then uses this
    value as an index into the JmpTbl array (W1 holds the base address of the JmpTbl
    array) and transfers control to the 8-byte address found at the specified location.
    For example, if W0 contains 0, the br x0 instruction will fetch the double word
    at address JmpTbl+0 (W0 × 8 = 0). Because the first double word in the table contains
    the offset of Stmt0, the br instruction transfers control to the first instruction
    following the Stmt0 label. Likewise, if i (and therefore, W0) contains 1, then
    the indirect br instruction fetches the double word at offset 8 from the table
    and transfers control to the first instruction following the Stmt1 label (because
    the offset of Stmt1 appears at offset 8 in the table). Finally, if i (W0) contains
    2, then this code fragment transfers control to the statements following the Stmt2
    label because it appears at offset 16 in the JmpTbl table.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将W0寄存器加载为i的值（假设i是32位无符号整数，ldr指令将W0零扩展到X0）。然后，它将这个值用作JmpTbl数组的索引（W1保存JmpTbl数组的基地址），并将控制转移到指定位置找到的8字节地址。例如，如果W0包含0，br
    x0指令将从地址JmpTbl+0获取双字（W0 × 8 = 0）。由于表中的第一个双字包含Stmt0的偏移量，br指令将控制转移到Stmt0标签后面的第一条指令。同样，如果i（因此W0）包含1，那么间接br指令会从表中的偏移量8获取双字，并将控制转移到Stmt1标签后面的第一条指令（因为Stmt1的偏移量出现在表中的偏移量8处）。最后，如果i（W0）包含2，那么这段代码将控制转移到Stmt2标签后面的语句，因为它出现在JmpTbl表中的偏移量16处。
- en: As you add more (consecutive) cases, the jump-table implementation becomes more
    efficient (in terms of both space and speed) than the if...elseif form. Except
    for simple cases, the switch statement is almost always faster, and usually by
    a large margin. As long as the case values are consecutive, the switch statement
    version is often smaller as well.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加更多（连续的）case时，跳转表的实现比if...elseif形式更高效（在空间和速度方面）。除了简单的情况，switch语句几乎总是更快，通常差距很大。只要case值是连续的，switch语句版本通常也更小。
- en: 7.6.7.4 Noncontiguous Jump-Table Entries and Range Limiting
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.7.4 非连续跳转表项与范围限制
- en: What happens if you need to include nonconsecutive case labels or can’t be sure
    the switch value doesn’t go out of range? With the C/C++ switch statement, such
    an occurrence will transfer control to the first statement after the switch statement
    (or to a default case, if one is present in the switch).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要包含非连续的case标签，或者不能确定switch值是否会超出范围，会发生什么？在C/C++的switch语句中，遇到这种情况时，控制将转移到switch语句后的第一个语句（或者，如果switch中有默认case，则转移到默认case）。
- en: However, this doesn’t happen in the example in the previous section. If variable
    i does not contain 0, 1, or 2, executing the previous code produces undefined
    results. For example, if i contains 5 when you execute the code, the indirect
    br instruction will fetch the dword at offset 40 (5 × 8) in JmpTbl and transfer
    control to that offset. Unfortunately, JmpTbl doesn’t have six entries, so the
    program will fetch the value of the sixth double word following JmpTbl and use
    that as the target offset, which will often crash your program or transfer control
    to an unexpected location.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在前一节的示例中并未发生这种情况。如果变量 i 的值不包含 0、1 或 2，执行之前的代码会产生未定义的结果。例如，如果在执行代码时 i 的值为
    5，间接 br 指令会在 JmpTbl 中获取偏移量 40（5 × 8）处的 dword，并将控制转移到该偏移量。不幸的是，JmpTbl 并没有六个条目，因此程序会获取
    JmpTbl 后面第六个双字的值，并将其作为目标偏移量，这通常会导致程序崩溃或将控制转移到一个意外的位置。
- en: 'The solution is to place a few instructions before the indirect br to verify
    that the switch selection value is within a reasonable range. In the previous
    example, you’d want to verify that the value of i is in the range 0 to 2 before
    executing the br instruction. If the value of i is outside this range, the program
    should simply jump to the endcase label, which corresponds to dropping down to
    the first statement after the entire switch statement. The following code provides
    this modification:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是在间接 br 指令之前放置一些指令，以验证 switch 选择值是否在合理范围内。在之前的例子中，你需要验证 i 的值是否在 0 到 2 的范围内，然后再执行
    br 指令。如果 i 的值超出这个范围，程序应该直接跳转到 endcase 标签，这对应于跳转到整个 switch 语句后的第一条语句。以下代码提供了这个修改：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Although this code handles the problem of selection values being outside the
    range 0 to 2, it still suffers from two severe restrictions:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码处理了选择值超出 0 到 2 范围的问题，但它仍然存在两个严重的限制：
- en: The cases must start with the value 0\. That is, the minimum case constant has
    to be 0.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种情况必须从值 0 开始。也就是说，最小的情况常量必须为 0。
- en: The case values must be contiguous.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况值必须是连续的。
- en: 'Solving the first problem is easy, and you deal with it in two steps. First,
    you compare the case selection value against a lower and upper bound before determining
    whether the case value is legal, as shown in the following example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 解决第一个问题很容易，可以通过两步来处理。首先，你需要将选择值与上下界进行比较，然后确定该值是否有效，如下例所示：
- en: '[PRE67]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This code adds a pair of extra instructions, cmp and blo, to test the selection
    value to ensure it is in the range 5 to 7\. If not, control drops down to the
    EndCase label; otherwise, control transfers via the indirect br instruction. Unfortunately,
    as the comments point out, this code is broken.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码添加了一对额外的指令，cmp 和 blo，用于测试选择值，以确保其在 5 到 7 的范围内。如果不在该范围内，控制将跳转到 EndCase 标签；否则，控制通过间接
    br 指令转移。不幸的是，正如注释所指出的，这段代码是有问题的。
- en: 'Consider what happens if variable i contains the value 5: the code will verify
    that 5 is in the range 5 to 7 and then will fetch the dword at offset 40 (5 ×
    8) and jump to that address. As before, however, this loads 8 bytes outside the
    bounds of the table and does not transfer control to a defined location. One solution
    is to subtract the smallest case selection value from W0 before executing the
    br instruction, as shown in the following example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑当变量 i 的值为 5 时会发生什么：代码将验证 5 是否在 5 到 7 的范围内，然后会获取偏移量 40（5 × 8）处的 dword，并跳转到该地址。然而，和之前一样，这会加载表格边界之外的
    8 字节，并且不会将控制转移到一个定义的位置。一个解决方案是在执行 br 指令之前，从 W0 中减去最小的情况选择值，如下例所示：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: By subtracting 5 from the value in W0, the code forces W0 to take on the value
    0, 1, or 2 prior to the br instruction. Therefore, case-selection value 5 jumps
    to Stmt5, case-selection value 6 transfers control to Stmt6, and case-selection
    value 7 jumps to Stmt7.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 W0 中减去 5，代码强制 W0 在 br 指令之前取值为 0、1 或 2。因此，选择值为 5 会跳转到 Stmt5，选择值为 6 会将控制转移到
    Stmt6，而选择值为 7 会跳转到 Stmt7。
- en: 'This code has one piece of trickery: the subs instruction serves double duty.
    It not only adjusts the lower bound of the switch expression down to 0 but also
    serves as the comparison against 5 for the lower bound. Remember, the cmp instruction
    sets the flags the same way as the subs instruction. Therefore, subtracting 5
    is the same as comparing against 5 as far as the flag settings are concerned.
    When comparing the value in W0 against 7, the code must actually compare against
    2 because we’ve subtracted 5 from the original index value.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个小技巧：subs 指令发挥了双重作用。它不仅将 switch 表达式的下限调整为 0，而且还作为下限与 5 的比较。记住，cmp 指令的作用和
    subs 指令一样，会设置标志。因此，减去 5 等同于与 5 比较，就标志设置而言。当将 W0 中的值与 7 进行比较时，实际上应该与 2 进行比较，因为我们已经从原始索引值中减去了
    5。
- en: 'You can handle cases that don’t start with 0 in another way:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过另一种方式处理不以 0 开头的情况：
- en: '[PRE69]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This example subtracts 40 (5 × 8) from the base address of the jump table when
    loading that base address into X1\. The index is still in the range 5 to 7, yielding
    an offset of 40 to 56 into the table; however, because the base address is now
    specified 40 bytes before the actual table, the array-indexing calculation properly
    indexes into the jump-table entries.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在将跳转表的基地址加载到 X1 时，从跳转表基地址减去 40（5 × 8）。索引仍然在 5 到 7 的范围内，偏移量为 40 到 56；但是，由于基地址现在指定在实际表之前的
    40 字节，因此数组索引计算正确地索引到了跳转表条目。
- en: 'The C/C++ switch statement provides a default clause that executes if the case-selection
    value doesn’t match any of the case values. The following switch statement includes
    a default clause:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 的 switch 语句提供了一个 default 子句，当 case 选择值与任何 case 值不匹配时，该子句会执行。以下的 switch
    语句包含了一个 default 子句：
- en: '[PRE70]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implementing the equivalent of the default clause in pure assembly language
    is easy: just use a different target label in the blo and bhi instructions at
    the beginning of the code. The following example implements a switch statement
    similar to the preceding one:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯汇编语言中实现等效的 default 子句很简单：只需在代码开头的 blo 和 bhi 指令中使用不同的目标标签。以下示例实现了一个类似于前面那个的
    switch 语句：
- en: '[PRE71]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The second restriction noted earlier, that the case values need to be contiguous,
    is easy to handle by inserting extra entries into the jump table. Consider the
    following C/C++ switch statement:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的第二个限制，即 case 值需要是连续的，可以通过在跳转表中插入额外条目来轻松处理。考虑以下 C/C++ 的 switch 语句：
- en: '[PRE72]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The minimum switch value is 1, and the maximum value is 8\. Therefore, the code
    before the indirect br instruction needs to compare the value in i against 1 and
    8\. If the value is from 1 to 8, it’s still possible that i might not contain
    a legal case-selection value. However, because the br instruction indexes into
    a table of double words, the table must have eight double-word entries.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的 switch 值是 1，最大值是 8。因此，在间接 br 指令之前的代码需要将 i 的值与 1 和 8 进行比较。如果值在 1 到 8 之间，仍然有可能
    i 不包含一个合法的 case 选择值。然而，由于 br 指令是通过双字表来索引的，因此该表必须有八个双字条目。
- en: 'To handle the values from 1 to 8 that are not case-selection values, simply
    put the statement label of the default clause (or the label specifying the first
    instruction after the end of the switch if there is no default clause) in each
    of the jump-table entries that don’t have a corresponding case clause. The following
    code demonstrates this technique:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理 1 到 8 之间不作为 case 选择值的情况，只需将 default 子句的语句标签（或在没有 default 子句时，指定 switch
    结束后第一条指令的标签）放入每个没有相应 case 子句的跳转表条目中。以下代码演示了这一技术：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This code uses cmp instructions to ensure that the switch value is in the range
    1 to 8 and transfers control to the DefaultCase label if this is the case.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 cmp 指令确保 switch 值在 1 到 8 的范围内，并在符合条件时将控制转移到 DefaultCase 标签。
- en: 7.6.7.5 Sparse Jump Tables
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.7.5 稀疏跳转表
- en: 'The current implementation of the switch statement has a problem. If the case
    values contain nonconsecutive entries that are widely spaced, the jump table could
    become exceedingly large. The following switch statement would generate an extremely
    large code file:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 switch 语句实现存在一个问题。如果 case 值包含非连续的、间隔很大的条目，跳转表可能变得异常庞大。以下的 switch 语句将生成一个极其庞大的代码文件：
- en: '[PRE74]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this situation, your program will be much smaller if you implement the switch
    statement with a sequence of if statements rather than using an indirect jump
    statement. However, the size of the jump table does not normally affect the execution
    speed of the program. If the jump table contains 2 entries or 2,000, the switch
    statement will execute the multiway branch in a constant amount of time. The if
    statement implementation requires a linearly increasing amount of time for each
    case label appearing in the case statement.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果你使用一系列 if 语句来实现 switch 语句，而不是使用间接跳转语句，那么你的程序会变得更小。然而，跳转表的大小通常不会影响程序的执行速度。无论跳转表包含
    2 个条目还是 2000 个条目，switch 语句都将在恒定的时间内执行多重分支。if 语句的实现则需要随着 case 语句中每个标签的增加而线性增长所需的时间。
- en: 'One of the biggest advantages to using assembly language over an HLL like Swift
    or C/C++ is that you get to choose the actual implementation of statements like
    switch. In some instances, you can implement a switch statement as a sequence
    of if...then...elseif statements, you can implement it as a jump table, or you
    can use a hybrid of the two. The following code examples demonstrate combining
    if...then...elseif and jump-table implementations for the same control structure:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用汇编语言而非像 Swift 或 C/C++ 这样的高级语言的最大优势之一是，你可以选择像 switch 语句这样的语句的实际实现方式。在某些情况下，你可以将
    switch 语句实现为一系列 if...then...elseif 语句，也可以将其实现为跳转表，或者你可以使用两者的混合体。以下代码示例演示了将 if...then...elseif
    和跳转表实现结合在一起，以实现相同的控制结构：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'That code could become the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能会变成以下内容：
- en: '[PRE76]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Some switch statements have sparse cases, but the cases are often grouped into
    contiguous clusters. Consider the following C/C++ switch statement:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有些 switch 语句包含稀疏的 case，但这些 case 通常会被分组成连续的簇。考虑下面这个 C/C++ switch 语句：
- en: '[PRE77]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You can convert a switch statement that consists of widely separated groups
    of (nearly) contiguous cases to assembly language code using one jump-table implementation
    for each contiguous group, then use comparison instructions to determine which
    jump-table instruction sequence to execute. Here’s one possible implementation
    of the previous C/C++ code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将由多个相邻（几乎）连续的 case 组成的 switch 语句转换为汇编语言代码，方法是为每个连续的 group 实现一个跳转表，然后使用比较指令来确定执行哪个跳转表指令序列。下面是前面
    C/C++ 代码的一种可能实现方式：
- en: '[PRE78]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This code sequence combines groups 0 to 2 and 10 to 11 into a single group (requiring
    seven additional jump-table entries) in order to save having to write an additional
    jump-table sequence. For a set of cases this simple, it’s easier to just use compare-and-branch
    sequences, but I’ve simplified this example to demonstrate multiple jump tables.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 0 到 2 组和 10 到 11 组合并为一个单独的组（需要额外的七个跳转表条目），以便节省不必编写额外的跳转表序列。对于这样简单的一组 case，使用比较与分支序列更为方便，但我简化了这个示例以演示多个跳转表。
- en: 7.6.7.6 Other switch Statement Alternatives
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.7.6 其他 switch 语句的替代方案
- en: 'What happens if the cases are too sparse to do anything but compare the expression’s
    value case by case? In this situation, the code is not necessarily doomed to being
    translated into the equivalent of an if...elseif...else...endif sequence. However,
    before considering other alternatives, remember that not all if...elseif...else...endif
    sequences are created equal. Look back at the last example in the previous section
    (the sparse switch statement). A straightforward implementation might have been
    something like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 case 太稀疏，只能逐个比较表达式的值会发生什么情况？在这种情况下，代码不一定注定要被转换为等同于 if...elseif...else...endif
    的语句。然而，在考虑其他替代方案之前，请记住，并非所有的 if...elseif...else...endif 语句都是一样的。回顾前一节中的最后一个示例（稀疏的
    switch 语句）。一种简单的实现可能是这样的：
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Instead, the former implementation first tests against the value 100 and branches
    based on the comparison being less than (cases 0 to 11) or greater than (cases
    1000 to 1001), effectively creating a small *binary search* that reduces the number
    of comparisons. It’s hard to see the savings in the HLL code, but in assembly
    code you can count the number of instructions that would be executed in the best
    and worst cases and see an improvement over the standard *linear search* approach
    of simply comparing the values in the cases in the order they appear in the switch
    statement. (Of course, if you have many groups in a sparse switch statement, a
    binary search will be much faster, on average, than a linear search.)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，前一种实现首先对值100进行测试，并根据比较结果分支到小于（情况0到11）或大于（情况1000到1001），有效地创建了一个小的*二分查找*，减少了比较的次数。虽然在高级语言代码中很难看到节省的地方，但在汇编代码中，你可以计算出在最佳和最差情况下执行的指令数量，并看到相较于标准的*线性搜索*方法（只是按顺序比较switch语句中出现的情况值），有所改进。（当然，如果你在稀疏的switch语句中有许多分组，二分查找平均会比线性查找快得多。）
- en: If your cases are too sparse (no meaningful groups at all), such as the 1, 10,
    100, 1,000, 10,000 example given in section 7.6.7.5, “Sparse Jump Tables,” on
    [page 399](chapter7.xhtml#pg_399), you can’t reasonably implement the switch statement
    by using a jump table. Rather than devolving into a straight linear search, which
    can be slow, a better solution is to sort your cases and test them by using a
    binary search.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的情况过于稀疏（根本没有有意义的分组），比如在第7.6.7.5节《稀疏跳转表》中的1, 10, 100, 1,000, 10,000的示例（见[第399页](chapter7.xhtml#pg_399)），你就无法合理地通过跳转表来实现switch语句。与其转而使用直接的线性搜索（可能很慢），更好的解决方案是对你的情况进行排序，并通过二分查找来测试它们。
- en: 'With a *binary search*, you first compare the expression value against the
    middle case value. If it’s less than the middle value, you repeat the search on
    the first half of the list of values; if it’s greater than the middle value, you
    repeat the test on the second half of the values; if it’s equal, obviously you
    drop into the code to handle that test. The following code shows the binary search
    version of the 1, 10, 100, ... example:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*二分查找*，你首先将表达式值与中间的情况值进行比较。如果小于中间值，你就对值列表的前半部分继续搜索；如果大于中间值，你就对值列表的后半部分继续搜索；如果相等，显然你就进入代码处理该测试。以下代码展示了1,
    10, 100, ... 示例的二分查找版本：
- en: '[PRE80]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The techniques presented in this section have many possible alternatives. For
    example, one common solution is to create a table containing a set of records,
    with each record entry a two-tuple containing a case value and a jump address.
    Rather than having a long sequence of compare instructions, a short loop can sequence
    through all the table elements, searching for the case value and transferring
    control to the corresponding jump address if a match occurs. This scheme is slower
    than the other techniques in this section, but it can be much shorter than the
    traditional if...elseif...else...endif implementation. With a little effort, you
    could use a binary search if the table is sorted.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中介绍的技术有许多可能的替代方案。例如，一个常见的解决方案是创建一个表，表中包含一组记录，每条记录是一个包含情况值和跳转地址的二元组。与其有一长串比较指令，不如使用一个短循环来遍历所有表元素，搜索情况值，并在匹配时将控制转移到相应的跳转地址。这个方案比本节中的其他技术要慢，但比传统的if...elseif...else...endif实现要简洁得多。稍加努力，如果表是有序的，你也可以使用二分查找。
- en: 7.6.7.7 Jump-Table Size Reductions
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.6.7.7 跳转表大小减少
- en: 'All the switch statement examples up to this point have used double-word arrays
    for the jump table. With a 64-bit offset, these jump tables can transfer control
    to any location in the ARM’s address space. In reality, this range is almost never
    necessary. Most offsets will be relatively small numbers (often less than ±128,
    or ±32,767). This means that the HO bits of the jump-table entries will likely
    be all 0s or all 1s (if the offset is negative). With a slight modification to
    the instructions that transfer control through the jump table, cutting the size
    of the table in half is easy:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的switch语句示例都使用了双字数组作为跳转表。使用64位偏移量，这些跳转表可以将控制转移到ARM地址空间中的任何位置。实际上，这个范围几乎从不需要。大多数偏移量将是相对较小的数字（通常小于±128，或±32,767）。这意味着跳转表项的高位可能全是0或全是1（如果偏移量为负）。通过稍微修改通过跳转表传递控制的指令，将表的大小减半是很容易的：
- en: '[PRE81]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This example has three modifications to the other examples in this chapter:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例对本章中的其他示例做了三处修改：
- en: The scaled-indexed addressing mode (ldr instruction) scales the index (in X0)
    by 4 instead of 8 (because we’re accessing elements of a word array rather than
    a dword array).
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '扩展索引寻址模式（ldr 指令）将索引（在 X0 中）按 4 缩放，而不是按 8 缩放（因为我们访问的是字数组而不是双字数组）。  '
- en: The add instruction sign-extends W0 to 64 bits before adding the value with
    X1.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'add 指令在将值与 X1 相加之前，对 W0 进行符号扩展至 64 位。  '
- en: The jump table contains word entries instead of dword entries.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳转表包含字条目而不是双字条目。
- en: This modification limits the range of the case labels to ±2GB around the jump
    table, rather than the full 64-bit address space—hardly a limitation for most
    programs. In exchange for this limit, the jump table is now half its original
    size.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '这个修改将 case 标签的范围限制在跳转表周围的 ±2GB 范围内，而不是完整的 64 位地址空间——对于大多数程序来说，这几乎不算限制。作为交换，跳转表的大小现在只有原来的一半。  '
- en: Before you get the sneaky idea of reducing the size of the table entries to
    16 bits (giving you a ±32K range), be aware that neither macOS’s nor Linux’s object
    code format—Mach-O and the Executable Linkable Format (ELF), respectively—supports
    16-bit relocatable offsets; 32-bit offsets are the best you can do.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '在你产生将表项大小减小为 16 位（从而获得 ±32K 范围）的狡猾想法之前，请注意，macOS 和 Linux 的目标代码格式——分别为 Mach-O
    和可执行链接格式（ELF）——都不支持 16 位可重定位偏移量；32 位偏移量是你能做的最好选择。  '
- en: 7.7 State Machines and Indirect Jumps
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '7.7 状态机和间接跳转  '
- en: Another control structure commonly found in assembly language programs is the
    state machine. In basic terms, a *state machine* is a piece of code that keeps
    track of its execution history by entering and leaving certain states. A state
    machine uses a *state variable* to control program flow. The FORTRAN programming
    language provides this capability with the assigned goto statement. Certain variants
    of C, such as GNU’s GCC from the Free Software Foundation, provide similar features.
    In assembly language, the indirect jump can implement state machines.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '汇编语言程序中常见的另一种控制结构是状态机。简单来说，*状态机* 是一段通过进入和退出某些状态来跟踪其执行历史的代码。状态机使用 *状态变量* 来控制程序流程。FORTRAN
    编程语言通过分配的 goto 语句提供了这种能力。某些 C 的变种，如自由软件基金会的 GNU GCC，也提供了类似的功能。在汇编语言中，间接跳转可以实现状态机。  '
- en: In one sense, all programs are state machines. The CPU registers and values
    in memory constitute the state of that machine. However, this chapter uses a much
    more constrained definition. For most purposes, only a single variable (or the
    value in the PC register) will denote the current state.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '从某种意义上讲，所有程序都是状态机。CPU 寄存器和内存中的值构成了该机器的状态。然而，本章使用了一个更为有限的定义。在大多数情况下，只有一个单一的变量（或
    PC 寄存器中的值）表示当前状态。  '
- en: For a concrete example of a state machine, suppose you have a procedure and
    want to perform one operation the first time you call it, a different operation
    the second time you call it, something else the third time you call it, and then
    something new again on the fourth call. After the fourth call, the code repeats
    these four operations in order. For example, say you want the procedure to add
    W0 and W1 the first time, subtract them on the second call, multiply them on the
    third, and divide them on the fourth. You could implement this procedure as shown
    in Listing 7-4.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '以状态机为具体例子，假设你有一个过程，并且希望在第一次调用时执行一个操作，第二次调用时执行另一个操作，第三次调用时执行第三个操作，然后在第四次调用时执行一个新的操作。第四次调用后，代码将按顺序重复这四个操作。例如，假设你希望该过程第一次调用时将
    W0 和 W1 相加，第二次调用时将它们相减，第三次调用时将它们相乘，第四次调用时将它们相除。你可以按以下列表 7-4 实现此过程。  '
- en: '[PRE82]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This code uses X19 to maintain the state variable ❶. The main program preserves
    X19 (and X20) ❷ and then initializes the state machine to state 0 ❸. The code
    then makes successive calls to the state machine functions and prints the results
    from state 0 ❹, 1 ❺, 2 ❻, and 3 ❼. After executing in state 3, the code returns
    to state 0 and prints the result ❽.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码使用 X19 来维护状态变量 ❶。主程序保存 X19（和 X20）❷，然后将状态机初始化为状态 0 ❸。接着，代码依次调用状态机函数，并打印从状态
    0 ❹、1 ❺、2 ❻ 和 3 ❼ 的结果。执行完状态 3 后，代码返回到状态 0 并打印结果 ❽。  '
- en: 'Here’s the build command and program output:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '这是构建命令和程序输出：  '
- en: '[PRE83]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Technically, the StateMachine procedure is not the state machine. Instead, the
    variable state and the cmp/bne instructions constitute the state machine. The
    procedure is little more than a switch statement implemented via the if...then...elseif
    construct. The only unique thing is that it remembers how many times it has been
    called (or rather, how many times, modulo 4, it has been called) and behaves differently
    depending on the number of calls.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，StateMachine 过程本身并不是状态机。实际上，状态变量和 cmp/bne 指令构成了状态机。这个过程不过是通过 if...then...elseif
    构造实现的一个 switch 语句。唯一独特的是，它记住了它被调用的次数（或者更准确地说，是按 4 的模数计算的调用次数），并根据调用次数的不同而表现得不同。
- en: While this is a *correct* implementation of the desired state machine, it is
    not particularly efficient. The astute reader may recognize that this code could
    be made a little faster by using an actual switch statement rather than the if...then...elseif...endif
    implementation. However, an even better solution exists.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个*正确的*状态机实现，但它并不特别高效。机智的读者可能会意识到，通过使用实际的 switch 语句而不是 if...then...elseif...endif
    实现，可以让这段代码运行得更快。然而，还有一个更好的解决方案。
- en: It’s common to use an indirect jump to implement a state machine in assembly
    language. Rather than having a state variable that contains a value like 0, 1,
    2, or 3, we could load the state variable with the *address* of the code to execute
    upon entry into the procedure. By simply jumping to that address, the state machine
    could save the tests needed to select the proper code fragment. Consider the implementation
    in Listing 7-5 using the indirect jump.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，使用间接跳转来实现状态机是很常见的。我们可以不使用包含 0、1、2 或 3 之类值的状态变量，而是将状态变量加载为进入过程时要执行的代码的*地址*。通过简单地跳转到该地址，状态机可以省去选择合适代码片段所需的测试。考虑一下列表
    7-5 中使用间接跳转的实现。
- en: '[PRE84]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This code has the same structure as Listing 7-4\. The main difference is that
    this code assumes that the target address of the state machine is in X19 rather
    than a state number.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与列表 7-4 的结构相同。主要的不同之处在于，这段代码假设状态机的目标地址在 X19 中，而不是一个状态编号。
- en: The br instruction at the beginning of the StateMachine procedure ❶ transfers
    control to the location pointed at by the state variable (X19). The first time
    you call StateMachine, it points at the state0 label. Thereafter, each subsection
    of code sets the state variable to point at the appropriate successor code. Within
    each state of the state machine ❷, the code sets X19 to the address of the next
    entry point of the state machine (rather than setting a state number). The main
    program initializes the state machine with the address of the State0 label ❸ rather
    than the value 0\. Otherwise, this main program is largely the same as in Listing
    7-4.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在 StateMachine 过程的开始部分，br 指令❶将控制权转移到由状态变量（X19）指向的位置。第一次调用 StateMachine 时，它指向
    state0 标签。之后，每个代码子段都会将状态变量设置为指向相应的后续代码。在每个状态机状态内❷，代码将 X19 设置为状态机下一个入口点的地址（而不是设置状态编号）。主程序使用
    State0 标签的地址❸来初始化状态机，而不是使用值 0。除此之外，这个主程序与列表 7-4 中的基本相同。
- en: 'Here’s the build command and program output:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和程序输出：
- en: '[PRE85]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This output demonstrates that Listing 7-5 behaves in a manner similar to Listing
    7-4.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出展示了列表 7-5 的行为与列表 7-4 类似。
- en: 7.8 Loops
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8 循环
- en: Loops represent the final basic control structure (sequences, decisions, and
    loops) that make up a typical program. Most HLLs have implied loop structures
    hidden away. For example, consider the BASIC statement if A$ = B$ then 100. This
    if statement compares two strings and jumps to statement 100 if they are equal.
    In assembly language, you would need to write a loop to compare each character
    in A$ to the corresponding character in B$ and then jump to statement 100 if and
    only if all the characters matched. (The C stdlib provides the strcmp routine
    that compares the strings for you, effectively hiding the loop. However, if you
    were to write this function yourself, the looping nature of the operation would
    be obvious.)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是构成典型程序的最后一种基本控制结构（顺序、选择和循环）。大多数高级语言（HLL）都将隐式的循环结构隐藏了起来。例如，考虑 BASIC 语句 if
    A$ = B$ then 100。这个 if 语句比较两个字符串，如果它们相等，就跳转到语句 100。在汇编语言中，你需要编写一个循环，逐个比较 A$ 中的每个字符与
    B$ 中对应位置的字符，然后仅当所有字符匹配时才跳转到语句 100。（C 标准库提供了 strcmp 例程来为你比较字符串，实际上隐藏了这个循环。然而，如果你自己编写这个函数，操作的循环性质将变得显而易见。）
- en: 'Program loops consist of three components: an optional initialization component,
    an optional loop-termination test, and the body of the loop. The order in which
    you assemble these components can dramatically affect the loop’s operation. Three
    permutations of these components appear frequently in programs: while loops, repeat...until
    loops (do...while in C/C++), and infinite loops (for example, for(;;) in C/C++).
    This section covers those three loop types along with C-style for loops (definite
    loops), register usage in loops, and breaking out of loops.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 程序循环由三个部分组成：一个可选的初始化部分，一个可选的循环终止测试，和循环体。你将这些部分组装的顺序可以显著影响循环的执行。程序中经常出现三种排列组合：`while`
    循环、`repeat...until` 循环（C/C++ 中的 `do...while`）和无限循环（例如 C/C++ 中的 `for(;;)`）。本节将涵盖这三种循环类型，以及
    C 风格的 `for` 循环（确定性循环）、循环中的寄存器使用和如何跳出循环。
- en: 7.8.1 while
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.8.1 `while`
- en: 'The most generic loop is the while loop. In C/C++, it takes the following form:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最通用的循环是 `while` 循环。在 C/C++ 中，它采用以下形式：
- en: '[PRE86]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the while loop, the termination test appears at the beginning of the loop.
    As a direct consequence of the position of the termination test, the body of the
    loop may never execute if the Boolean expression is always false.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，终止测试出现在循环开始时。由于终止测试的位置，循环体可能永远不会执行，如果布尔表达式始终为假。
- en: 'Consider the following C/C++ while loop:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 C/C++ `while` 循环：
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The i = 0; statement is the initialization code for this loop. i is a loop-control
    variable, because it controls the execution of the body of the loop. i < 100 is
    the loop-termination condition: the loop will not terminate as long as i is less
    than 100\. The single statement ++i; (increment i) is the loop body that executes
    on each loop iteration.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`i = 0;` 语句是此循环的初始化代码。`i` 是一个循环控制变量，因为它控制着循环体的执行。`i < 100` 是循环终止条件：只要 `i` 小于
    100，循环就不会终止。单个语句 `++i;`（递增 `i`）是循环体，在每次循环迭代时执行。'
- en: 'A C/C++ while loop can be easily synthesized using if and goto statements.
    For example, you may replace the previous C while loop with the following C code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ `while` 循环可以通过 `if` 和 `goto` 语句轻松合成。例如，你可以用以下 C 代码替代前面的 C `while` 循环：
- en: '[PRE88]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'More generally, you can construct any while loop as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，你可以按如下方式构造任何`while`循环：
- en: '[PRE89]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Therefore, you can use the techniques from earlier in this chapter to convert
    if statements to assembly language and add a single b.al instruction to produce
    a while loop. The example in this section translates to the following pure ARM
    assembly code:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用本章前面提到的技术，将 `if` 语句转换为汇编语言，并添加一个 `b.al` 指令来生成 `while` 循环。本节中的示例将转换为以下纯
    ARM 汇编代码：
- en: '[PRE90]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: GCC will actually convert most while statements to different ARM code than this
    section presents. The reason for the difference appears in section 7.9.1, “Moving
    the Termination Condition to the End of a Loop,” on [page 428](chapter7.xhtml#pg_428),
    which explores how to write more efficient loop code.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 实际上会将大多数 `while` 语句转换为与本节展示的不同的 ARM 代码。差异的原因出现在第 7.9.1 节，“将终止条件移动到循环末尾”，在[第
    428 页](chapter7.xhtml#pg_428)中，探讨了如何编写更高效的循环代码。
- en: 7.8.2 repeat...until
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.8.2 `repeat...until`
- en: 'The repeat...until loop, also called the do...while loop in C, tests for the
    termination condition at the end of the loop rather than at the beginning. In
    Pascal, the repeat...until loop takes the following form:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat...until` 循环，也称为 C 中的 `do...while` 循环，它在循环的末尾测试终止条件，而不是在循环开始时。在 Pascal
    中，`repeat...until` 循环采用以下形式：'
- en: '[PRE91]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This is comparable to the following C/C++ do...while loop:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下的 C/C++ `do...while` 循环相当：
- en: '[PRE92]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This sequence executes the initialization code, then executes the loop body,
    and finally tests a condition to see whether the loop should repeat. If the Boolean
    expression evaluates to false, the loop repeats; otherwise, the loop terminates.
    In the repeat...until loop, the termination test appears at the end of the loop
    and, as a direct consequence, the loop body always executes at least once.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列执行初始化代码，然后执行循环体，最后测试一个条件以判断循环是否应该重复。如果布尔表达式的结果为假，循环会重复；否则，循环终止。在 `repeat...until`
    循环中，终止测试出现在循环末尾，因此，循环体总是至少执行一次。
- en: 'Like the while loop, the repeat...until loop can be synthesized with an if
    statement and a b.al (branch). The following is an example of just such an implementation:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `while` 循环类似，`repeat...until` 循环可以通过 `if` 语句和 `b.al`（分支）语句合成。以下是这样一种实现的示例：
- en: '[PRE93]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Based on the material presented in the previous sections, you can easily synthesize
    repeat...until loops in assembly language, as shown in the following simple example:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面章节中提供的内容，你可以轻松地在汇编语言中合成`repeat...until`循环，如以下简单示例所示：
- en: '[PRE94]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The repeat...until loop has a slightly more efficient implementation because
    it combines the loop termination test and the branch back to the beginning of
    the loop.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat...until`循环有一个稍微高效的实现，因为它结合了循环终止测试和跳转回循环开始的操作。'
- en: 7.8.3 forever/endfor
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.8.3 forever/endfor
- en: 'If while loops test for termination at the beginning of the loop and repeat...until
    and do...while loops check for termination at the end of the loop, the only place
    left to test for termination is in the middle of the loop. The C/C++ high-level
    for(;;) loop, combined with the break statement, provides this capability. The
    C/C++ infinite loop takes the following form:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`while`循环在循环开始时测试终止条件，而`repeat...until`和`do...while`循环在循环结束时测试终止条件，那么唯一剩下的测试终止条件的位置就是循环中间。C/C++的高级`for(;;)`循环，结合`break`语句，提供了这个功能。C/C++的无限循环采用以下形式：
- en: '[PRE95]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'There is no explicit termination condition. The for(;;) construct forms an
    infinite loop. A break statement usually handles loop termination. Consider the
    following C++ code that employs a for(;;) construct:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 没有显式的终止条件。`for(;;)`结构形成了一个无限循环。`break`语句通常用于处理循环的终止。考虑以下使用`for(;;)`结构的C++代码：
- en: '[PRE96]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Converting a for(;;) loop to pure assembly language is easy: all you need is
    a label and a b.al instruction. The break statement in this example is also nothing
    more than a b.al instruction (or conditional jump). The pure assembly language
    version of the preceding code looks something like the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个`for(;;)`循环转换为纯汇编语言是很简单的：你只需要一个标签和一个`b.al`指令。此示例中的`break`语句也仅仅是一个`b.al`指令（或条件跳转）。上述代码的纯汇编语言版本大致如下：
- en: '[PRE97]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As you can see, the forever loop has a very simple implementation.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`forever`循环有一个非常简单的实现。
- en: 7.8.4 for
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.8.4 for
- en: 'The standard for loop is a special form of the while loop that repeats the
    loop body a specific number of times, which is known as a *definite* loop. In
    C/C++, the for loop takes the following form:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`for`循环是`while`循环的一种特殊形式，它使得循环体重复特定次数，这被称为*确定性*循环。在C/C++中，`for`循环的形式如下：
- en: '[PRE98]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This is equivalent to the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这等价于以下内容：
- en: '[PRE99]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Traditionally, programs use the for loop to process arrays and other objects
    accessed in sequential order. You normally initialize a loop-control variable
    with the initialization statement, then use the loop-control variable as an index
    into the array (or other data type), as shown in the following example:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，程序使用`for`循环来处理数组和其他按顺序访问的对象。你通常用初始化语句初始化一个循环控制变量，然后将该变量作为数组（或其他数据类型）的索引，如以下示例所示：
- en: '[PRE100]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To convert this to pure assembly language, begin by translating the for loop
    into an equivalent while loop:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其转换为纯汇编语言，首先将`for`循环转换为等效的`while`循环：
- en: '[PRE101]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now, using the techniques from section 7.8.1, “while,” on [page 415](chapter7.xhtml#pg_415),
    translate the code into pure assembly language:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用第7.8.1节“while”中的技术（见[第415页](chapter7.xhtml#pg_415)），将代码翻译成纯汇编语言：
- en: '[PRE102]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This is a fairly efficient implementation of a while loop in assembly language,
    though for for loops that execute a fixed number of times, you might consider
    using the cbnz instruction (see section 7.8.6, “ARM Looping Instructions,” on
    [page 425](chapter7.xhtml#pg_425)).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在汇编语言中实现`while`循环的一个相当高效的实现，尽管对于执行固定次数的`for`循环，你可能会考虑使用`cbnz`指令（见第7.8.6节，“ARM循环指令”，[第425页](chapter7.xhtml#pg_425)）。
- en: 7.8.5 break and continue
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.8.5 break和continue
- en: The C/C++ break and continue statements both translate into a single b.al instruction.
    The break statement exits the loop that immediately contains the break statement;
    the continue statement restarts the loop that contains the continue statement.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++的`break`和`continue`语句都转换为单一的`b.al`指令。`break`语句退出直接包含`break`语句的循环；`continue`语句重新启动包含`continue`语句的循环。
- en: 'To convert a break statement to pure assembly language, just emit a goto/b.al
    instruction that transfers control to the first statement following the end of
    the loop to exit. You can do this by placing a label after the loop body and jumping
    to that label. The following code fragments demonstrate this technique for the
    various loops:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`break`语句转换为纯汇编语言，只需发出一个`goto/b.al`指令，将控制转移到循环结束后紧接着的第一条语句以退出循环。你可以通过在循环体后放置一个标签并跳转到该标签来实现这一点。以下代码片段演示了这种技术在不同循环中的应用：
- en: '[PRE103]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In pure assembly language, convert the appropriate control structures to assembly
    and replace the goto with a b.al instruction.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯汇编语言中，将适当的控制结构转换为汇编，并将 goto 替换为 b.al 指令。
- en: The continue statement is slightly more complex than the break statement. The
    implementation is still a single b.al instruction; however, the target label doesn’t
    wind up going in the same spot for each of the loops. [Figures 7-2](chapter7.xhtml#fig7-2)
    through [7-5](chapter7.xhtml#fig7-5) show where the continue statement transfers
    control for each of the loops.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: continue 语句比 break 语句稍微复杂一些。实现仍然是一个 b.al 指令；然而，目标标签在每个循环中不会出现在相同的位置。[图 7-2](chapter7.xhtml#fig7-2)
    至 [图 7-5](chapter7.xhtml#fig7-5) 显示了每个循环中 continue 语句的控制转移位置。
- en: '[Figure 7-2](chapter7.xhtml#fig7-2) shows the for(;;) loop with a continue
    statement.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](chapter7.xhtml#fig7-2) 显示了带有 continue 语句的 for(;;) 循环。'
- en: '![](../images/Figure7-2.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-2.jpg)'
- en: 'Figure 7-2: The continue destination and the for(;;) loop'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：continue 目标和 for(;;) 循环
- en: '[Figure 7-3](chapter7.xhtml#fig7-3) shows the while loop with a continue statement.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-3](chapter7.xhtml#fig7-3) 显示了带有 continue 语句的 while 循环。'
- en: '![](../images/Figure7-3.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-3.jpg)'
- en: 'Figure 7-3: The continue destination and the while loop'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：continue 目标和 while 循环
- en: '[Figure 7-4](chapter7.xhtml#fig7-4) shows a C/C++ for loop with a continue
    statement.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4](chapter7.xhtml#fig7-4) 显示了带有 continue 语句的 C/C++ for 循环。'
- en: '![](../images/Figure7-4.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-4.jpg)'
- en: 'Figure 7-4: The continue destination and the for loop'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：continue 目标和 for 循环
- en: Note in [Figure 7-4](chapter7.xhtml#fig7-4) that the continue statement forces
    the execution of incStmt and then transfers control to the test for loop termination.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 [图 7-4](chapter7.xhtml#fig7-4) 中，continue 语句强制执行 incStmt，然后将控制权转移到测试循环终止条件的位置。
- en: '[Figure 7-5](chapter7.xhtml#fig7-5) shows a repeat...until loop with a continue
    statement.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-5](chapter7.xhtml#fig7-5) 显示了一个带有 continue 语句的 repeat...until 循环。'
- en: '![](../images/Figure7-5.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-5.jpg)'
- en: 'Figure 7-5: The continue destination and the repeat... until loop'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-5：continue 目标和 repeat...until 循环
- en: 'The following code fragments demonstrate how to convert the continue statement
    into an appropriate b.al instruction for each of these loop types:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何将 continue 语句转换为每种循环类型的适当 b.al 指令：
- en: '[PRE104]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In each case, the b.al instruction transfers control to the point in the loop
    where it will test the loop condition and increment the loop control variable
    (for for loops), or to the beginning of the loop’s body.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，b.al 指令将控制权转移到循环中测试循环条件并增加循环控制变量（对于 for 循环），或者转移到循环体的开头。
- en: 7.8.6 ARM Looping Instructions
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.8.6 ARM 循环指令
- en: The ARM CPU provides four machine instructions that are useful for creating
    loops. These instructions violate the RISC principle of “an instruction does only
    one thing,” but they are quite handy even if they are a little “CISCy.”
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU 提供了四条机器指令，适用于创建循环。这些指令违反了 RISC 原则“每条指令只做一件事”，但它们还是非常实用，即使它们有些“CISC”风格。
- en: The first two instructions test a register’s value and branch if that register
    is equal to, or not equal to, 0\. The two instructions are cbz (compare and branch
    if zero) and cbnz (compare and branch if not zero). Their syntax is
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 前两条指令测试寄存器的值，并在该寄存器等于或不等于 0 时进行分支。这两条指令是 cbz（比较并在零时分支）和 cbnz（比较并在非零时分支）。它们的语法是：
- en: '[PRE105]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: where X*n* and W*n* are the register to compare against 0 and label is a statement
    label within ±1MB of the current instruction.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，X*n* 和 W*n* 是要与 0 比较的寄存器，label 是当前指令 ±1MB 范围内的语句标签。
- en: 'These instructions are equivalent to the following:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令等价于以下内容：
- en: '[PRE106]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Another useful pair of instructions are tbz (test bit for 0 and branch) and
    tbnz (test bit for not 0 and branch). These instructions test a bit in a register
    and branch based on that bit’s value (0 or nonzero). The syntax for these instructions
    is
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 另一对有用的指令是 tbz（测试位为 0 并分支）和 tbnz（测试位非 0 并分支）。这些指令会测试寄存器中的某个位，并根据该位的值（0 或非零）进行分支。这些指令的语法是：
- en: '[PRE107]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: where X*n* and W*n* are the register to test, *imm**[6]* is a bit number in
    the range 0–63 for 64-bit registers and 0–31 for 32-bit registers, and label is
    a statement label within ±32KB of the current instruction. The tbz instruction
    branches to the label if the specified bit in the register is 0, while the tbnz
    instruction branches if the bit is not 0.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，X*n* 和 W*n* 是要测试的寄存器，*imm**[6]* 是 64 位寄存器范围内 0–63 位的位数，或 32 位寄存器范围内 0–31
    位的位数，label 是当前指令 ±32KB 范围内的语句标签。tbz 指令会在寄存器中的指定位为 0 时跳转到该标签，而 tbnz 指令则在该位不为 0
    时跳转。
- en: 7.8.7 Register Usage and Loops
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.8.7 寄存器使用与循环
- en: Given that the ARM accesses registers more efficiently than memory locations,
    registers are the ideal spot to place loop-control variables (especially for small
    loops). However, registers are a limited resource, despite the many registers
    available on the ARM. Unlike with memory, you cannot place much data in the registers.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于 ARM 对寄存器的访问效率比内存位置更高，寄存器是放置循环控制变量的理想位置（特别是对于小循环）。然而，寄存器是有限资源，尽管 ARM 提供了许多寄存器。与内存不同，你不能在寄存器中放入大量数据。
- en: 'Loops present a special challenge for registers. Registers are perfect for
    loop-control variables because they’re efficient to manipulate and can serve as
    indexes into arrays and other data structures (a common use for loop-control variables).
    However, the limited availability of registers often creates problems when using
    registers in this fashion. This is especially true if you call other functions/procedures
    within the loops, which limits you to using nonvolatile registers for loop control
    variables. Consider the following code with nested loops that will not work properly
    because it attempts to reuse a register (X19) that is already in use, leading
    to the corruption of the outer loop’s loop-control variable:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 循环对寄存器提出了特殊挑战。寄存器非常适合用作循环控制变量，因为它们操作高效，并且可以作为数组和其他数据结构的索引（这是循环控制变量的常见用途）。然而，由于寄存器的数量有限，当以这种方式使用寄存器时，往往会出现问题。如果在循环内调用其他函数/过程，这会使你只能使用非易失性寄存器来作为循环控制变量。这在以下代码中表现得尤为明显，嵌套循环无法正常工作，因为它尝试重用已经在使用的寄存器（X19），导致外层循环的控制变量被损坏：
- en: '[PRE108]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The intent here was to create a set of nested loops, one loop inside another.
    The inner loop (loop2) should repeat four times for each of the eight executions
    of the outer loop (loop1). Unfortunately, both loops use the same register as
    a loop-control variable. Therefore, this will form an infinite loop. Because W19
    is always 0 upon encountering the second subs instruction, control will always
    transfer to the loop1 label (because decrementing 0 produces a nonzero result).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是创建一组嵌套循环，一个循环嵌套在另一个循环内。内层循环（loop2）应该在外层循环（loop1）执行八次时重复执行四次。不幸的是，这两个循环使用相同的寄存器作为循环控制变量。因此，这会形成一个无限循环。因为
    W19 在遇到第二个 `subs` 指令时总是为 0，所以控制总是会转移到 loop1 标签（因为将 0 减去会产生非零结果）。
- en: 'The solution is to save and restore the W19 register or to use a different
    register in place of W19 for the outer loop; the following code demonstrates preserving
    W19 across the execution of the loop:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是保存并恢复 W19 寄存器，或者使用不同的寄存器代替 W19 作为外层循环的控制变量；以下代码展示了如何在循环执行过程中保存 W19：
- en: '[PRE109]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Register corruption is one of the primary sources of bugs in loops in assembly
    language programs, so always keep an eye out for this problem.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器损坏是汇编语言程序中循环错误的主要来源之一，因此要时刻留意这个问题。
- en: Until this point, this chapter has mainly focused on the correct implementation
    of various types of loops in assembly language. The next section begins discussing
    how to write loops efficiently in assembly language.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章主要集中在汇编语言中各种类型循环的正确实现。下一部分将开始讨论如何在汇编语言中高效编写循环。
- en: '### 7.9 Loop Performance Improvements'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '### 7.9 循环性能改进'
- en: Because loops are the primary source of performance problems within a program,
    they are also the place to look when attempting to speed up your software. A treatise
    on how to write efficient programs is beyond the scope of this chapter, but you
    should be aware of the following concepts when designing loops in your programs.
    They’re all aimed at removing unnecessary instructions from your loops in order
    to reduce the time it takes to execute a single iteration of the loop.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 由于循环是程序中性能问题的主要来源，因此在尝试加速软件时，循环是最需要关注的地方。有关如何编写高效程序的详细讨论超出了本章的范围，但在设计程序中的循环时，你应该了解以下概念。这些概念的目的都是通过去除循环中的不必要指令，减少每次循环迭代的执行时间。
- en: 7.9.1 Moving the Termination Condition to the End of a Loop
  id: totrans-445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.1 将终止条件移至循环末尾
- en: 'As you may have noticed, the repeat...until loop is slightly more efficient
    than a while loop. This is because repeat...until manages to combine the loop’s
    Boolean test along with the branch back to the beginning of the loop. You can
    improve the other loops to be slightly more efficient. Consider the following
    flow graphs for the three types of loops presented earlier:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，`repeat...until` 循环比 `while` 循环稍微高效。这是因为 `repeat...until` 成功地将循环的布尔测试与返回到循环起始点的分支结合在了一起。你可以改进其他循环，使其稍微高效一些。考虑以下三种类型的循环的流程图：
- en: '[PRE110]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The repeat...until loop is the simplest of the bunch. This is reflected in
    the assembly language implementation of these loops. Consider the following semantically
    identical repeat...until and while loops:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat...until` 循环是这些循环中最简单的。这一点在这些循环的汇编语言实现中得到了体现。考虑以下语义完全相同的 `repeat...until`
    和 `while` 循环：'
- en: '[PRE111]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Testing for the termination condition at the end of the loop allows you to remove
    a b.al instruction from the loop, which can be significant if the loop is nested
    inside other loops. Given the definition of the loop, you can easily see that
    the loop will execute exactly 20 times, which suggests that the conversion to
    a repeat...until loop is trivial and always possible. Unfortunately, it’s not
    always quite this easy.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环末尾测试终止条件允许你从循环中移除一个 `b.al` 指令，如果循环嵌套在其他循环中，这可能会非常重要。根据循环的定义，你可以轻松看出该循环将精确执行
    20 次，这表明将其转换为 `repeat...until` 循环是微不足道且始终可行的。不幸的是，这并不总是这么简单。
- en: 'Consider the following C code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 C 代码：
- en: '[PRE112]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'In this example, you don’t know what W0 contains upon entry into the loop.
    Therefore, you cannot assume that the loop body will execute at least once. This
    means you must test for loop termination before executing the body of the loop.
    The test can be placed at the end of the loop with the inclusion of a single b.al
    instruction:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你不知道进入循环时 W0 中包含什么。因此，你不能假设循环体至少会执行一次。这意味着你必须在执行循环体之前测试循环是否终止。这个测试可以放在循环的末尾，并加上一条
    `b.al` 指令：
- en: '[PRE113]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Although the code is as long as the original while loop, the b.al instruction
    executes only once rather than on each repetition of the loop. However, the slight
    gain in efficiency is obtained via a slight loss in readability, so be sure to
    comment it. The second code sequence is also closer to spaghetti code than the
    original implementation. Such is often the price of a small performance gain.
    Carefully analyze your code to ensure that such a performance boost is worth the
    loss of clarity.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码与原始 `while` 循环一样长，但 `b.al` 指令仅执行一次，而不是在每次循环时都执行。然而，效率的轻微提升是通过略微降低可读性来实现的，因此一定要加上注释。第二段代码也比原始实现更接近“意大利面条代码”（spaghetti
    code）。这种微小的性能提升常常需要付出可读性的代价。仔细分析你的代码，确保这种性能提升值得牺牲清晰度。
- en: 7.9.2 Executing the Loop Backward
  id: totrans-456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.2 反向执行循环
- en: 'Because of the nature of the flags on the ARM, loops that repeat from a number
    down to (or up to) 0 are more efficient than loops that execute from 0 to another
    value. Compare the following C/C++ for loop and the comparable assembly language
    code:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ARM 上标志的特性，从某个数递减到（或递增到）0的循环比从 0 执行到另一个值的循环更高效。比较以下的 C/C++ `for` 循环和相应的汇编语言代码：
- en: '[PRE114]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now consider another loop that also has eight iterations but runs its loop-control
    variable from 8 down to 1 rather than from 1 up to 8, thereby saving a comparison
    on each repetition of the loop:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑另一个循环，它也有八次迭代，但它的循环控制变量从 8 递减到 1，而不是从 1 递增到 8，从而在每次循环时节省一次比较操作：
- en: '[PRE115]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Saving the execution time of the cmp instruction on each iteration of the loop
    may result in faster code. Unfortunately, you cannot force all loops to run backward.
    However, with a little effort and some coercion, you should be able to write many
    for loops so that they operate backward.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 节省每次迭代中 `cmp` 指令的执行时间可能会导致更快的代码。不幸的是，你无法强制所有循环都反向执行。然而，通过一点努力和一些强制，你应该能够编写许多
    `for` 循环，使其反向运行。
- en: 'The previous example worked out well because the loop ran from 8 down to 1\.
    The loop terminated when the loop-control variable became 0\. What happens if
    you need to execute the loop when the loop-control variable goes to 0? For example,
    suppose that the preceding loop needed to range from 7 down to 0\. As long as
    the lower bound is nonnegative, you can substitute the bpl instruction in place
    of the bne instruction in the earlier code:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子效果很好，因为循环从 8 递减到 1。循环在循环控制变量变为 0 时终止。如果你需要在循环控制变量变为 0 时执行循环，会发生什么情况？例如，假设前面的循环需要从
    7 递减到 0。如果下界是非负数，你可以用 bpl 指令代替早期代码中的 bne 指令：
- en: '[PRE116]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This loop will repeat eight times, with W0 (j) taking on the values 7 to 0\.
    When W0 decrements 0 to –1, it sets the sign flag and the loop terminates.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将重复八次，W0（j）将取值从 7 到 0。当 W0 从 0 递减到 -1 时，它设置符号标志，循环终止。
- en: Keep in mind that some values may look positive but are actually negative. If
    the loop-control variable is a word, values in the range 2,147,483,648 to 4,294,967,295
    are negative in the two’s complement system. Therefore, initializing the loop-control
    variable with any 32-bit value in this range (or, of course, 0) terminates the
    loop after a single execution. This can get you into trouble if you’re not careful.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，有些值看起来是正数，但实际上是负数。如果循环控制变量是一个字（word），则在二进制补码系统中，范围从 2,147,483,648 到 4,294,967,295
    的值是负数。因此，用此范围内的任何 32 位值（或者当然是 0）初始化循环控制变量，将在执行一次后终止循环。如果不小心，这可能会给你带来麻烦。
- en: 7.9.3 Eliminating Loop-Invariant Calculations
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.3 消除循环不变计算
- en: 'A *loop-invariant computation* is a calculation that appears within a loop
    that always yields the same result. You needn’t do such computations inside the
    loop but can instead compute them outside the loop and reference the value of
    the computations inside the loop. The following C code demonstrates an invariant
    computation:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: A *循环不变计算* 是一种出现在循环中的计算，其结果始终相同。你无需在循环内部进行这样的计算，而可以将它们计算到循环外部，并在循环内部引用计算的值。以下
    C 代码演示了一个不变计算：
- en: '[PRE117]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Because j never changes throughout the execution of this loop, the subexpression
    j - 2 can be computed outside the loop:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 j 在整个循环执行过程中始终不变，子表达式 j - 2 可以在循环外部计算：
- en: '[PRE118]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This translates to the following assembly code, which moves the invariant calculation
    outside the loop:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这转换为以下汇编代码，将不变计算移到循环外部：
- en: '[PRE119]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 7.9.4 Unraveling Loops
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.4 解开循环
- en: 'For small loops—those whose bodies are composed of just a few statements—the
    overhead required to process the loop may constitute a significant percentage
    of the total processing time. For example, consider the following Pascal code
    and its associated ARM assembly language code:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小循环——那些循环体仅由少数语句组成的循环——处理循环所需的开销可能占总处理时间的一个显著比例。例如，考虑以下 Pascal 代码及其对应的 ARM
    汇编语言代码：
- en: '[PRE120]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Three instructions execute on each repetition of the loop. Only one instruction
    is doing the desired operation (moving a 0 into an element of A). The remaining
    two instructions control the loop. Therefore, it takes 12 instructions to do the
    operation logically required by 4.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环执行三条指令。只有一条指令在执行所需的操作（将 0 移动到 A 的一个元素中）。其余两条指令控制循环。因此，执行逻辑上由 4 所需的操作需要 12
    条指令。
- en: 'While we could make many improvements to this loop based on the information
    presented thus far, consider carefully exactly what it is that this loop is doing:
    it’s storing four 0s into A[0] through A[3]. A more efficient approach is to use
    four str instructions to accomplish the same task. For example, if A is an array
    of words, the following code initializes A much faster than the preceding code:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于迄今为止提供的信息我们可以对这个循环做出许多改进，但请仔细考虑这个循环到底在做什么：它将四个 0 存储到 A[0] 到 A[3] 中。一种更高效的方法是使用四条
    str 指令来完成相同的任务。例如，如果 A 是一个字数组，以下代码比前面的代码更快地初始化 A：
- en: '[PRE121]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Although this is a simple example, it shows the benefit of *loop unraveling*
    (also known as *loop unrolling*), which consists of repeating the loop’s body
    as source code for each iteration of the loop. If this simple loop appeared buried
    inside a set of nested loops, the 3:1 instruction reduction could possibly double
    the performance of that section of your program. (It would be criminal not to
    mention at this point that you could cut this down to two instructions by storing
    XZR, a double word, into A + 0 and A + 8, though that is a different optimization.)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的例子，但它展示了*循环解开*（也称为*循环展开*）的好处，该方法通过在源代码中重复循环体来实现每次迭代。如果这个简单的循环出现在一组嵌套循环中，3:1的指令减少可能会将该部分程序的性能提高一倍。（此时不提到你可以通过将双字存储到
    A + 0 和 A + 8 来将其减少为两条指令，尽管那是另一种优化，实在是太不合适了。）
- en: Of course, you cannot unravel all loops. Loops that execute a variable number
    of times are difficult to unravel because there is rarely a way to determine at
    assembly time the number of loop iterations. Therefore, unraveling a loop is a
    process best applied to loops that execute a known number of times, with the number
    of times known at assembly time.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你无法解开所有的循环。执行可变次数的循环很难解开，因为通常没有办法在汇编时确定循环的迭代次数。因此，解开循环是一种最适合应用于已知循环次数的循环的过程，且循环的执行次数在汇编时是已知的。
- en: Even if you repeat a loop a fixed number of iterations, it may not be a good
    candidate for loop unraveling. Loop unraveling produces impressive performance
    improvements when the number of instructions controlling the loop (and handling
    other overhead operations) represents a significant percentage of the total number
    of instructions in the loop. Had the previous loop contained 36 instructions in
    the body (exclusive of the 3 overhead instructions), the performance improvement
    would be, at best, only 10 percent, compared with the 300 to 400 percent it now
    enjoys.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你重复执行一个固定次数的循环，它也可能不是循环解开的好候选。循环解开能带来显著的性能提升，特别是当控制循环的指令数量（以及处理其他开销操作的指令）占循环总指令数的一个重要比例时。如果前面的循环体包含了36条指令（不包括3条开销指令），性能提升最多也只能达到10%，而现在的提升幅度为300%到400%。
- en: Therefore, the costs of unraveling a loop—all the extra code that must be inserted
    into your program—quickly reach a point of diminishing returns as the body of
    the loop grows larger or as the number of iterations increases. Furthermore, entering
    that code into your program can become quite a chore. Therefore, loop unraveling
    is a technique best applied to small loops.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解开循环的成本——所有必须插入到程序中的额外代码——会随着循环体的增大或迭代次数的增加而迅速达到收益递减的临界点。此外，将这些代码输入到程序中也可能变得非常繁琐。因此，循环解开技术最好应用于小型循环。
- en: 7.9.5 Using Induction Variables
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.5 使用归纳变量
- en: 'This section introduces optimizations based on induction variables. An *induction
    variable* is one whose value depends entirely on the value of another variable.
    Consider the following Pascal loop:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了基于归纳变量的优化。*归纳变量*是指其值完全依赖于另一个变量的值。考虑以下 Pascal 循环：
- en: '[PRE122]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Here the program is initializing each element of an array of character sets
    to the empty set. The straightforward code to achieve this is the following:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这里程序正在初始化字符集数组的每个元素为一个空集合。实现这一功能的直接代码如下：
- en: '[PRE123]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Although unraveling this code will still improve performance, it will take 2,304
    instructions to accomplish this task—too many for all but the most time-critical
    applications. However, you can reduce the execution time of the loop’s body by
    using induction variables.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管解开这段代码仍然会提高性能，但实现这一任务将需要2,304条指令——对于大多数应用程序而言，这个数量太多，只有在最为关键的时间敏感型应用中才可能考虑。然而，你可以通过使用归纳变量来减少循环体的执行时间。
- en: 'In the preceding example, the index into the array csetVar tracks the loop-control
    variable; it’s always equal to the value of the loop-control variable times 16\.
    Because i doesn’t appear anywhere else in the loop, there is no sense in performing
    the computations on i. Why not operate directly on the array index value? Furthermore,
    because the scaled-indexed addressing mode doesn’t support an integer offset component,
    the code is constantly adding 8 to or subtracting 8 from X20 to initialize the
    second half of each character set element. This computation can also be worked
    into the induction of the loop control variable. The following code demonstrates
    this technique:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，数组 csetVar 的索引跟踪循环控制变量；它总是等于循环控制变量的值乘以 16。由于 i 在循环中没有出现在其他地方，因此没有必要对
    i 进行计算。为什么不直接对数组索引值进行操作？此外，由于缩放索引寻址模式不支持整数偏移量成分，代码会不断地加 8 或减 8 来初始化每个字符集元素的后半部分。这一计算也可以被融入到循环控制变量的归纳中。以下代码演示了这一技巧：
- en: '[PRE124]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The induction that takes place in this example occurs when the code initializes
    the loop control variable with the address of the array (moved into X20 for efficiency)
    and then increments it by 16 on each iteration of the loop rather than by 1\.
    This allows the code to use the indirect-plus- offset addressing mode (rather
    than the scaled-indexed addressing mode), as no shift is required. Once the code
    can use the indirect-plus-offset mode, it can drop the addition and subtraction
    of the loop control variable in order to access the second half of each character
    set array element.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的归纳发生在代码通过将数组的地址初始化到循环控制变量中（为了提高效率，将其移入 X20）并在每次循环迭代时将其增加 16，而不是增加 1。这使得代码可以使用间接加偏移寻址模式（而不是缩放索引寻址模式），因为不需要移位。一旦代码可以使用间接加偏移模式，它就可以省略对循环控制变量的加法和减法操作，以便访问每个字符集数组元素的后半部分。
- en: 7.10 Moving On
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.10 继续前进
- en: After mastering the material in this chapter and the chapters up to this point,
    you should be capable of translating many HLL programs into assembly code.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握本章及之前各章的内容后，你应该能够将许多高级语言程序转换为汇编代码。
- en: 'This chapter covered several concepts concerning the implementation of loops
    in assembly language. It discussed statement labels, including working with their
    addresses, efficiently representing pointers to labels in your programs, using
    unconditional and indirect branches, working with veneers, and transferring control
    to statements beyond the range of the ARM branches. It then covered decisions:
    how to implement if...then...else...elseif, switch statements, state machines
    in assembly language, Boolean expressions, and complete/short-circuit evaluation.
    It also described how to utilize 32-bit PC-relative addresses to reduce jump-table
    (and pointer) sizes. Finally, this chapter described various kinds of loops, improving
    loop performance, and the special ARM machine instructions that support loop construction.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了有关汇编语言中实现循环的几个概念。讨论了语句标签，包括如何使用它们的地址，如何高效地在程序中表示指向标签的指针，使用无条件和间接分支，操作外壳，以及如何将控制转移到
    ARM 分支范围之外的语句。接着讲解了决策：如何实现 if...then...else...elseif、switch 语句、汇编语言中的状态机、布尔表达式，以及完全/短路求值。还描述了如何利用
    32 位 PC 相对地址来减小跳转表（和指针）的大小。最后，本章描述了各种类型的循环、提高循环性能以及支持循环构造的特殊 ARM 机器指令。
- en: You’re now prepared to start writing some serious assembly language code. Starting
    with the next chapter, you’ll learn some intermediate assembly language programming
    that enables you to write code that is difficult or impossible to write in HLLs.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经准备好开始编写一些真正的汇编语言代码。从下一章开始，你将学习一些中级汇编语言编程，帮助你编写在高级语言中难以或不可能编写的代码。
- en: 7.11 For More Information
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.11 更多信息
- en: My book *Write Great Code,* Volume 2, 2nd edition (No Starch Press, 2020) provides
    a good discussion of the implementation of various HLL control structures in low-level
    assembly language. It also discusses optimizations such as induction, unrolling,
    strength reduction, and so on that apply to optimizing loops.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的书《*编写优秀的代码*》，第二卷，第二版（No Starch Press，2020）提供了关于在低级汇编语言中实现各种高级语言控制结构的良好讨论。它还讨论了诸如归纳、展开、强度减少等优化方法，这些方法适用于优化循环。
