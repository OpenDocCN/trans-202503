- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Template Injection
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模板注入
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Template engines* are a type of software used to determine the appearance
    of a web page. Developers often overlook attacks that target these engines, called
    *server-side* *template injections (**SSTIs)*, yet they can lead to severe consequences,
    like remote code execution. They have become more common in the past few years,
    with instances found in the applications of organizations such as Uber and Shopify.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板引擎* 是一种用于决定网页外观的软件。开发人员常常忽视针对这些引擎的攻击，称为 *服务器端* *模板注入（**SSTI**）*，但这些攻击可能导致严重的后果，如远程代码执行。近年来，这类攻击变得更加普遍，像
    Uber 和 Shopify 等组织的应用程序中也曾发现过这类漏洞。'
- en: In this chapter, we’ll dive into the mechanisms of this vulnerability by focusing
    on web applications using the Jinja2 template engine. After confirming that we
    can submit template injections to the application, we’ll take advantage of Python
    sandbox-escaping tricks to run operating system commands on the server.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨这种漏洞的机制，重点关注使用 Jinja2 模板引擎的 Web 应用程序。在确认我们能够向应用程序提交模板注入后，我们将利用 Python
    沙箱逃逸技巧，在服务器上运行操作系统命令。
- en: Exploiting various template engines will require different syntax and methods,
    but this chapter should give you a good introduction to the principles useful
    for finding and exploiting template injection vulnerabilities on any system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 利用不同的模板引擎需要不同的语法和方法，但本章将为你提供一个很好的介绍，帮助你理解如何在任何系统中寻找和利用模板注入漏洞。
- en: Mechanisms
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: To understand how template injections work, you need to understand the mechanisms
    of the template engines they target. Simply put, template engines combine application
    data with web templates to produce web pages. These web templates, written in
    template languages such as Jinja, provide developers with a way to specify how
    a page should be rendered. Together, web templates and template engines allow
    developers to separate server-side application logic and client-side presentation
    code during web development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解模板注入是如何工作的，你需要了解它们所针对的模板引擎的机制。简单来说，模板引擎将应用程序数据与 Web 模板结合，生成网页。这些 Web 模板使用像
    Jinja 这样的模板语言编写，提供了一个让开发人员指定页面如何渲染的方式。Web 模板和模板引擎结合起来，使开发人员在 Web 开发过程中可以将服务器端应用逻辑和客户端展示代码分离。
- en: Template Engines
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板引擎
- en: 'Let’s take a look at Jinja, a template language for Python. Here is a template
    file written in Jinja. We will store this file with the name *example.jinja*:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 Jinja，这是一个用于 Python 的模板语言。下面是一个用 Jinja 编写的模板文件。我们将把这个文件保存为 *example.jinja*：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, this template file looks like normal HTML. However, it contains
    special syntax to indicate content that the template engine should interpret as
    template code. In Jinja, any code surrounded by double curly brackets `{{ }}`
    is to be interpreted as a Python expression, and code surrounded by bracket and
    percent sign pairings `{% %}` should be interpreted as a Python statement.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个模板文件看起来像普通的 HTML。然而，它包含了特殊的语法，用于指示模板引擎将其解释为模板代码。在 Jinja 中，任何被双大括号 `{{
    }}` 包围的代码都应被解释为 Python 表达式，而任何被大括号和百分号符号 `{% %}` 包围的代码应被解释为 Python 语句。
- en: In programming languages, an *expression* is either a variable or a function
    that returns a value, whereas a *statement* is code that doesn’t return anything.
    Here, you can see that the template first embeds the expressions `list_title`
    and `list_description` in HTML header tags 1. Then it creates a loop to render
    all items in the `item_list` variable in the HTML body 2.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，*表达式* 是一个变量或返回值的函数，而 *语句* 是不返回任何值的代码。这里，你可以看到模板首先将表达式 `list_title` 和
    `list_description` 嵌入到 HTML 头部标签 1 中。然后，它创建一个循环，在 HTML 主体 2 中渲染 `item_list` 变量中的所有项。
- en: 'Now the developer can combine the template with Python code to create the complete
    HTML page. The following piece of Python code reads the template file from *example.jinja*
    and generates an HTML page dynamically by providing the template engine with values
    to insert into the template:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开发人员可以将模板与 Python 代码结合，创建完整的 HTML 页面。以下 Python 代码从 *example.jinja* 中读取模板文件，并通过为模板引擎提供要插入模板的值，动态生成
    HTML 页面：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, the Python code reads the template file named *example.jinja* 1. It then
    generates an HTML page dynamically by providing the template with the values it
    needs 2. You can see that the code is rendering the template with the values `Chapter
    Contents` as the `list_title` 3, and `Here are the contents of chapter 16.` as
    the `list_description` 4, and a list of values—`Mechanisms Of Template Injection`,
    `Preventing Template Injection`, `Hunting For Template Injection`, `Escalating
    Template Injection`, `Automating Template Injection`, and `Find Your First Template
    Injection!`—as the `item_list` 5.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Python代码读取名为*example.jinja*的模板文件1。然后，它通过为模板提供所需的值来动态生成HTML页面2。你可以看到，代码正在渲染模板，将值`Chapter
    Contents`作为`list_title` 3，`Here are the contents of chapter 16.`作为`list_description`
    4，以及一组值——`Mechanisms Of Template Injection`、`Preventing Template Injection`、`Hunting
    For Template Injection`、`Escalating Template Injection`、`Automating Template Injection`和`Find
    Your First Template Injection!`——作为`item_list` 5。
- en: 'The template engine will combine the data provided in the Python script and
    the template file *example.jinja* to create this HTML page:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎将结合Python脚本中提供的数据和模板文件*example.jinja*，生成这个HTML页面：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Template engines make rendering web pages more efficient, as developers can
    present different sets of data in a standardized way by reusing templates. This
    functionality is especially useful when developers need to generate pages of the
    same format with custom content, such as bulk emails, individual item pages on
    an online marketplace, and the profile pages of different users. Separating HTML
    code and application logic also makes it easier for developers to modify and maintain
    parts of the HTML code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎使得渲染网页更加高效，因为开发者可以通过重用模板以标准化的方式呈现不同的数据集。当开发者需要生成具有自定义内容的同一格式的页面时，这一功能尤为有用，例如批量邮件、在线市场中的单个商品页面以及不同用户的个人资料页面。将HTML代码和应用程序逻辑分开，也使得开发者更容易修改和维护HTML代码的部分内容。
- en: Popular template engines on the market include Jinja, Django, and Mako (which
    work with Python), Smarty and Twig (which work with PHP), and Apache FreeMarker
    and Apache Velocity (which work with Java). We’ll talk more about how to identify
    these template engines in applications later in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上流行的模板引擎包括Jinja、Django和Mako（与Python配合使用）、Smarty和Twig（与PHP配合使用）以及Apache FreeMarker和Apache
    Velocity（与Java配合使用）。我们将在本章后面讲解如何在应用程序中识别这些模板引擎。
- en: Injecting Template Code
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入模板代码
- en: 'Template injection vulnerabilities happen when a user is able to inject input
    into templates without proper sanitization. Our previous example isn’t vulnerable
    to template injection vulnerabilities because it does not embed user input into
    templates. It simply passes a list of hardcoded values as the `list_title`, `list_description`,
    and `item_list` into the template. Even if the preceding Python snippet does pass
    user input into the template like this, the code would not be vulnerable to template
    injection because it is safely passing user input into the template as data:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模板注入漏洞发生在用户能够将输入注入到模板中而没有经过适当的清理时。我们之前的例子没有受到模板注入漏洞的影响，因为它没有将用户输入嵌入到模板中。它只是将一组硬编码的值作为`list_title`、`list_description`和`item_list`传递给模板。即使前面的Python代码段确实像这样将用户输入传递到模板中，代码也不会受到模板注入的影响，因为它是安全地将用户输入作为数据传递到模板中的：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the code is clearly defining that the title portion of the `user_input`
    can be used only as the `list_title` 1, the description portion of the `user_input`
    is the `list_description` 2, and the list portion of the `user_input` can be used
    for the `item_list` of the template 3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码明确指出`user_input`的标题部分只能作为`list_title` 1使用，`user_input`的描述部分是`list_description`
    2，`user_input`的列表部分可以作为模板的`item_list` 3。
- en: However, sometimes developers treat templates like strings in programming languages
    and directly concatenate user input into them. This is where things go wrong,
    as the template engine won’t be able to distinguish between user input and the
    developer’s template code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时开发者将模板视为编程语言中的字符串，并直接将用户输入拼接到其中。这时问题就出在这里，因为模板引擎无法区分用户输入和开发者的模板代码。
- en: 'Here’s an example. The following program takes user input and inserts it into
    a Jinja template to display the user’s name on an HTML page:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子。以下程序接受用户输入并将其插入到Jinja模板中，以在HTML页面上显示用户的名字：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code first creates a template by concatenating HTML code and user input
    together 1, then renders the template 2.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过将HTML代码和用户输入拼接在一起创建模板1，然后渲染该模板2。
- en: 'If users submit a GET request to that page, the website will return an HTML
    page that displays their name:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户提交GET请求到该页面，网站将返回一个显示他们名字的HTML页面：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This request will cause the template engine to render the following page:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求将导致模板引擎渲染以下页面：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, what if you submitted a payload like the following instead?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你提交了如下的payload，会怎么样呢？
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead of supplying a name as the `name` parameter, you are submitting an
    expression that has special meaning for the template engine. Jinja2 interprets
    anything within double curly brackets `{{ }}` as Python code. You will notice
    something odd in the resulting HTML page. Instead of displaying the string `The
    user''s name is: {{1+1}}`, the page displays the string `The user''s name is:
    2`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '你没有提交一个名字作为`name`参数，而是提交了一个对模板引擎具有特殊意义的表达式。Jinja2将任何双大括号`{{ }}`中的内容解释为Python代码。你会注意到在生成的HTML页面中有些奇怪的地方。页面没有显示字符串`The
    user''s name is: {{1+1}}`，而是显示了字符串`The user''s name is: 2`：'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What just happened? When you submitted `{{1+1}}` as your name, the template
    engine mistook the content enclosed in `{{ }}` as a Python expression, so it executed
    `1+1` and returned the number `2` in that field.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才发生了什么？当你提交`{{1+1}}`作为你的名字时，模板引擎误将`{{ }}`中包含的内容视为Python表达式，因此执行了`1+1`并返回了数字`2`。
- en: 'This means you can submit any Python code you’d like and get its results returned
    in the HTML page. For instance, `upper()` is a method in Python that converts
    a string to uppercase. Try submitting the code snippet `{{''Vickie''.upper()}}`,
    like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以提交任何你想要的Python代码，并将结果返回到HTML页面中。例如，`upper()`是Python中的一个方法，用于将字符串转换为大写。试着提交以下代码片段`{{'Vickie'.upper()}}`，像这样：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see an HTML page like this returned:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到像这样返回的HTML页面：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You may have noticed that template injections are similar to SQL injections.
    If the template engine can’t determine where a piece of user-supplied data ends
    and where the template logic starts, the template engine will mistake user input
    for template code. In those cases, attackers can submit arbitrary code and get
    the template engine to execute their input as source code!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到模板注入与SQL注入类似。如果模板引擎无法确定用户提供的数据的结束位置以及模板逻辑的起始位置，模板引擎就会将用户输入误认为模板代码。在这种情况下，攻击者可以提交任意代码，并让模板引擎将其输入当作源代码执行！
- en: Depending on the permissions of the compromised application, attackers might
    be able to use the template injection vulnerability to read sensitive files or
    escalate their privileges on the system. We will talk more about escalating template
    injections later in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据被攻击应用程序的权限，攻击者可能通过模板注入漏洞读取敏感文件或提升在系统上的权限。我们将在本章稍后讨论如何提升模板注入攻击。
- en: Prevention
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防范
- en: How can you prevent this dangerous vulnerability? The first way is by regularly
    patching and updating the frameworks and template libraries your application uses.
    Many developers and security professionals are catching on to the danger of template
    injections. As a result, template engines publish various mitigations against
    this attack. Constantly updating your software to the newest version will ensure
    that your applications are protected against new attack vectors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如何防止这个危险的漏洞呢？第一种方法是定期修补和更新应用程序使用的框架和模板库。许多开发者和安全专家已经意识到模板注入的危险。因此，模板引擎发布了各种缓解措施来防御这种攻击。不断更新软件到最新版本将确保您的应用程序免受新攻击向量的威胁。
- en: You should also prevent users from supplying user-submitted templates if possible.
    If that isn’t an option, many template engines provide a hardened sandbox environment
    that you can use to safely handle user input. These sandbox environments remove
    potentially dangerous modules and functions, making user-submitted templates safer
    to evaluate. However, researchers have published numerous sandbox escape exploits,
    so this is by no means a bulletproof method. Sandbox environments are also only
    as safe as their configurations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该尽量防止用户提供自定义模板。如果这不可行，许多模板引擎提供了一个强化的沙盒环境，你可以用来安全地处理用户输入。这些沙盒环境去除了潜在危险的模块和函数，使得用户提交的模板更加安全地进行评估。然而，研究人员已经发布了许多沙盒逃逸漏洞，因此这绝不是万无一失的方法。沙盒环境的安全性也与其配置密切相关。
- en: Implement an allowlist for allowed attributes in templates to prevent the kind
    of RCE exploit that I’ll introduce in this chapter. Also, sometimes template engines
    raise descriptive errors that help attackers develop exploits. You should handle
    these errors properly and return a generic error page to the user. Finally, sanitize
    user input before embedding it into web templates and avoid injecting user-supplied
    data into templates whenever possible.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为模板中允许的属性实现白名单，以防止我将在本章中介绍的那种 RCE 漏洞。此外，有时模板引擎会抛出描述性错误，帮助攻击者开发漏洞利用。你应该妥善处理这些错误，并向用户返回一个通用的错误页面。最后，在将用户输入嵌入网页模板之前进行过滤，并尽量避免将用户提供的数据注入到模板中。
- en: Hunting for Template Injection
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找模板注入
- en: As with hunting for many other vulnerabilities, the first step in finding template
    injections is to identify locations in an application that accept user input.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与寻找许多其他漏洞一样，寻找模板注入的第一步是识别应用程序中接受用户输入的位置。
- en: 'Step 1: Look for User-Input Locations'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步：查找用户输入位置
- en: Look for locations where you can submit user input to the application. These
    include URL paths, parameters, fragments, HTTP request headers and body, file
    uploads, and more.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 查找可以向应用程序提交用户输入的位置。这些位置包括 URL 路径、参数、片段、HTTP 请求头和主体、文件上传等。
- en: Templates are typically used to dynamically generate web pages from stored data
    or user input. For example, applications often use template engines to generate
    customized email or home pages based on the user’s information. So to look for
    template injections, look for endpoints that accept user input that will eventually
    be displayed back to the user. Since these endpoints typically coincide with the
    endpoints for possible XXS attacks, you can use the strategy outlined in Chapter
    6 to identify candidates for template injection. Document these input locations
    for further testing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 模板通常用于根据存储的数据或用户输入动态生成网页。例如，应用程序通常使用模板引擎根据用户的信息生成定制的电子邮件或主页。因此，要寻找模板注入漏洞，应该查找那些接受用户输入并最终会返回给用户的端点。由于这些端点通常与可能发生
    XXS 攻击的端点重合，因此可以使用第六章中概述的策略来识别模板注入的潜在位置。记录这些输入位置以便进一步测试。
- en: 'Step 2: Detect Template Injection by Submitting Test Payloads'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步：通过提交测试有效载荷来检测模板注入
- en: Next, detect template injection vulnerabilities by injecting a test string into
    the input fields you identified in the previous step. This test string should
    contain special characters commonly used in template languages. I like to use
    the string `{{1+abcxx}}${1+abcxx}<%1+abcxx%>[abcxx]` because it’s designed to
    induce errors in popular template engines. `${...}` is the special syntax for
    expressions in the FreeMarker and Thymeleaf Java templates; `{{...}}` is the syntax
    for expressions in PHP templates such as Smarty or Twig, and Python templates
    like Jinja2; and `<%= ... %>` is the syntax for the Embedded Ruby template (ERB).
    And `[``random expression``]` will make the server interpret the random expression
    as a list item if the user input is placed into an expression tag within the template
    (we will discuss an example of this scenario later).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过将测试字符串注入到你在上一阶段识别的输入字段中来检测模板注入漏洞。该测试字符串应包含模板语言中常用的特殊字符。我喜欢使用字符串`{{1+abcxx}}${1+abcxx}<%1+abcxx%>[abcxx]`，因为它旨在引发流行模板引擎中的错误。`${...}`是
    FreeMarker 和 Thymeleaf Java 模板中的表达式语法；`{{...}}`是 PHP 模板（如 Smarty 或 Twig）以及 Python
    模板（如 Jinja2）中的表达式语法；`<%= ... %>`是嵌入式 Ruby 模板（ERB）的语法。而`[``random expression``]`会让服务器将随机表达式解释为列表项，如果用户输入被放置到模板中的表达式标签中（我们稍后会讨论这种场景的一个示例）。
- en: In this payload, I make the template engine resolve the variable with the name
    `abcxx`, which probably has not been defined in the application. If you get an
    application error from this payload, that’s a good indication of template injection,
    because it means that the special characters are being treated as special by the
    template engine. But if error messages are suppressed on the server, you need
    to use another method to detect template injection vulnerabilities.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个有效载荷中，我让模板引擎解析名为`abcxx`的变量，该变量可能在应用程序中未定义。如果你从这个有效载荷中收到应用程序错误，那是模板注入的一个良好迹象，因为这意味着模板引擎将特殊字符视为特殊字符。但是，如果服务器上抑制了错误信息，你需要使用另一种方法来检测模板注入漏洞。
- en: 'Try providing these test payloads to the input fields `${7*7}`, `{{7*7}}`,
    and `<%= 7*7 %>`. These payloads are designed to detect template injection in
    various templating languages. `${7*7}` works for the FreeMarker and Thymeleaf
    Java templates; `{{7*7}}` works for PHP templates such as Smarty or Twig, and
    Python templates like Jinja2; and `<%= 7*7 %>` works for the ERB template. If
    any of the returned responses contain the result of the expression, 49, it means
    that the data is being interpreted as code by the template engine:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将这些测试有效载荷`${7*7}`、`{{7*7}}`和`<%= 7*7 %>`提供给输入字段。这些有效载荷旨在检测各种模板语言中的模板注入。`${7*7}`适用于FreeMarker和Thymeleaf
    Java模板；`{{7*7}}`适用于PHP模板，如Smarty或Twig，以及Python模板，如Jinja2；`<%= 7*7 %>`适用于ERB模板。如果返回的任何响应包含表达式的结果`49`，这意味着数据被模板引擎解释为代码：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While testing these endpoints for template injections, keep in mind that successful
    payloads don’t always cause results to return immediately. Some applications might
    insert your payload into a template somewhere else. The results of your injection
    could show up in future web pages, emails, and files. A time delay also might
    occur between when the payload is submitted and when the user input is rendered
    in a template. If you’re targeting one of these endpoints, you’ll need to look
    out for signs that your payload has succeeded. For example, if an application
    renders an input field unsafely when generating a bulk email, you will need to
    look at the generated email to check whether your attack has succeeded.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这些端点的模板注入时，请记住，成功的有效载荷并不总是立即返回结果。一些应用程序可能会将你的有效载荷插入到其他地方的模板中。你的注入结果可能会出现在未来的网页、电子邮件和文件中。在提交有效载荷和用户输入在模板中呈现之间，也可能会有时间延迟。如果你正在攻击这些端点中的一个，你需要注意寻找有效载荷成功的迹象。例如，如果一个应用程序在生成批量电子邮件时不安全地呈现了输入字段，你需要查看生成的电子邮件，检查你的攻击是否成功。
- en: 'The three test payloads `${7*7}`, `{{7*7}}`, and `<%= 7*7 %>` would work when
    user input is inserted into the template as plaintext, as in this code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 三个测试有效载荷`${7*7}`、`{{7*7}}`和`<%= 7*7 %>`在用户输入作为纯文本插入模板时有效，如以下代码片段所示：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But what if the user input is concatenated into the template as a part of the
    template’s logic, as in this code snippet?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果用户输入作为模板逻辑的一部分拼接到模板中，会发生什么呢？如以下代码片段所示。
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, the user input is placed into the template within expression tags `{{...}}`.
    Therefore, you do not have to provide extra expression tags for the server to
    interpret the input as code. In that case, the best way to detect whether your
    input is being interpreted as code is to submit a random expression and see if
    it gets interpreted as an expression. In this case, you can input `7*7` to the
    field and see if `49` gets returned:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户输入被放置在表达式标签`{{...}}`中的模板内。因此，你不需要为服务器提供额外的表达式标签来将输入解释为代码。在这种情况下，检测输入是否被解释为代码的最佳方式是提交一个随机表达式，看看它是否被解释为表达式。在这种情况下，你可以在字段中输入`7*7`，看看是否返回`49`：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Step 3: Determine the Template Engine in Use'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：确定使用的模板引擎
- en: Once you’ve confirmed the template injection vulnerability, determine the template
    engine in use to figure out how to best exploit that vulnerability. To escalate
    your attack, you’ll have to write your payload with a programming language that
    the particular template engine expects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认了模板注入漏洞，确定使用的模板引擎，以便找出如何最好地利用这个漏洞。为了升级攻击，你必须使用特定模板引擎预期的编程语言来编写有效载荷。
- en: 'If your payload caused an error, the error message itself may contain the name
    of the template engine. For example, submitting my test string `{{1+abcxx}}${1+abcxx}<%1+abcxx%>[abcxx]`
    to our example Python application would cause a descriptive error that tells me
    that the application is using Jinja2:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的有效载荷导致了一个错误，错误信息本身可能包含模板引擎的名称。例如，提交我的测试字符串`{{1+abcxx}}${1+abcxx}<%1+abcxx%>[abcxx]`到我们的示例Python应用程序，会导致一个描述性错误，告诉我该应用程序使用的是Jinja2：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Otherwise, you can figure out the template engine in use by submitting test
    payloads specific to popular template languages. For example, if you submit `<%=
    7*7 %>` as the payload and `49` gets returned, the application probably uses the
    ERB template. If the successful payload is `${7*7}`, the template engine could
    either be Smarty or Mako. If the successful payload is `{{7*7}}`, the application
    is likely using Jinja2 or Twig. At that point, you could submit another payload,
    `{{7*''7''}}`, which would return `7777777` in Jinja2 and `49` in Twig. These
    testing payloads are taken from PortSwigger research: [https://portswigger.net/research/server-side-template-injection/](https://portswigger.net/research/server-side-template-injection/).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以通过提交特定于流行模板语言的测试负载来确定正在使用的模板引擎。例如，如果您提交 `<%= 7*7 %>` 作为负载并返回 `49`，则该应用程序可能使用了
    ERB 模板。如果成功的负载是 `${7*7}`，则模板引擎可能是 Smarty 或 Mako。如果成功的负载是 `{{7*7}}`，则应用程序可能使用的是
    Jinja2 或 Twig。此时，您可以提交另一个负载 `{{7*'7'}}`，在 Jinja2 中返回 `7777777`，在 Twig 中返回 `49`。这些测试负载来自
    PortSwigger 的研究：[https://portswigger.net/research/server-side-template-injection/](https://portswigger.net/research/server-side-template-injection/)。
- en: Many other template engines are used by web applications besides the ones I’ve
    talked about. Many have similar special characters designed not to interfere with
    normal HTML syntax, so you might need to perform multiple test payloads to definitively
    determine the type of template engine you are attacking.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我提到的模板引擎外，Web 应用程序还使用了许多其他模板引擎。许多模板引擎设计了类似的特殊字符，以避免干扰正常的 HTML 语法，因此您可能需要执行多个测试负载，才能明确确定您正在攻击的模板引擎类型。
- en: Escalating the Attack
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级攻击
- en: Once you’ve determined the template engine in use, you can start to escalate
    the vulnerability you’ve found. Most of the time, you can simply use the `7*7`
    payload introduced in the preceding section to prove the template injection to
    the security team. But if you can show that the template injection can be used
    to accomplish more than simple mathematics, you can prove the impact of your bug
    and show the security team its value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确定了正在使用的模板引擎，您就可以开始提升已发现的漏洞了。大多数情况下，您可以仅使用前面章节中介绍的 `7*7` 负载来向安全团队证明模板注入。但是，如果您能够证明模板注入不仅仅能进行简单的数学运算，您可以证明漏洞的影响并展示其价值给安全团队。
- en: Your method of escalating the attack will depend on the template engine you’re
    targeting. To learn more about it, read the official documentation of the template
    engine and the accompanying programming language. Here, I’ll show how you can
    escalate a template injection vulnerability to achieve system command execution
    in an application running Jinja2.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您提升攻击的方法将取决于您正在攻击的模板引擎。要了解更多信息，请阅读该模板引擎及其伴随的编程语言的官方文档。在这里，我将展示如何通过模板注入漏洞在运行
    Jinja2 的应用程序中实现系统命令执行。
- en: Being able to execute system commands is extremely valuable for the attacker
    because it might allow them to read sensitive system files like customer data
    and source code files, update system configurations, escalate their privileges
    on the system, and attack other machines on the network. For example, if an attacker
    can execute arbitrary system commands on a Linux machine, they can read the system’s
    password file by executing the command `cat /etc/shadow`. They can then use a
    password-cracking tool to crack the system admin’s encrypted password and gain
    access to the admin’s account.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 能够执行系统命令对攻击者来说是极其有价值的，因为这可能允许他们读取敏感的系统文件，例如客户数据和源代码文件，更新系统配置，提升他们在系统上的权限，并攻击网络中的其他机器。例如，如果攻击者能够在
    Linux 机器上执行任意系统命令，他们可以通过执行命令 `cat /etc/shadow` 来读取系统的密码文件。然后，他们可以使用密码破解工具破解系统管理员的加密密码，从而获得管理员账户的访问权限。
- en: Searching for System Access via Python Code
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 Python 代码搜索系统访问
- en: Let’s circle back to our example application. We already know that you can execute
    Python code by using this template injection vulnerability. But how do you go
    on to execute system commands by injecting Python code?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前的示例应用程序。我们已经知道，您可以通过这种模板注入漏洞执行 Python 代码。那么，如何通过注入 Python 代码来执行系统命令呢？
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Normally in Python, you can execute system commands via the `os.system()` function
    from the `os` module. For example, this line of Python code would execute the
    Linux system command `ls` to display the contents of the current directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在 Python 中，您可以通过 `os` 模块中的 `os.system()` 函数执行系统命令。例如，这行 Python 代码将执行 Linux
    系统命令 `ls` 来显示当前目录的内容：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, if you submit this payload to our example application, you most likely
    won’t get the results you expect:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将此有效载荷提交到我们的示例应用程序，你很可能不会得到预期的结果：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Instead, you’ll probably run into an application error:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可能会遇到应用程序错误：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is because the `os` module isn’t recognized in the template’s environment.
    By default, it doesn’t contain dangerous modules like `os`. Normally, you can
    import Python modules by using the syntax `import` `MODULE`, or `from` `MODULE`
    `import *`, or finally `__import__(''``MODULE`''`)`. Let’s try to import the `os`
    module:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`os`模块在模板的环境中无法识别。默认情况下，它不包含像`os`这样的危险模块。通常，你可以通过`import` `MODULE`、`from`
    `MODULE` `import *` 或最后使用`__import__('MODULE')`语法来导入 Python 模块。让我们尝试导入`os`模块：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you submit this payload to the application, you will probably see another
    error returned:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此有效载荷提交到应用程序，可能会看到另一个错误返回：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is because you can’t import modules within Jinja templates. Most template
    engines will block the use of dangerous functionality such as `import` or make
    an allowlist that allows users to perform only certain operations within the template.
    To escape these limitations of Jinja2, you need to take advantage of Python sandbox-escape
    techniques.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为你无法在 Jinja 模板中导入模块。大多数模板引擎会阻止使用危险功能，如`import`，或者会设置一个允许列表，只允许用户在模板中执行某些操作。要逃避这些
    Jinja2 的限制，你需要利用 Python 沙盒逃逸技术。
- en: Escaping the Sandbox by Using Python Built-in Functions
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过使用 Python 内置函数逃脱沙盒
- en: 'One of these techniques involves using Python’s built-in functions. When you’re
    barred from importing certain useful modules or importing anything at all, you
    need to investigate functions that are already imported by Python by default.
    Many of these built-in functions are integrated as a part of Python’s `object`
    class, meaning that when we want to call these functions, we can create an object
    and call the function as a method of that object. For example, the following GET
    request contains Python code that lists the Python classes available:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种技术是使用 Python 的内置函数。当你无法导入某些有用的模块或根本无法导入任何模块时，你需要调查 Python 默认已导入的函数。许多这些内置函数作为
    Python 的`object`类的一部分进行集成，这意味着当我们想调用这些函数时，我们可以创建一个对象并将该函数作为对象的方法进行调用。例如，以下 GET
    请求包含列出可用 Python 类的 Python 代码：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you submit this payload into the template injection endpoint, you should
    see a list of classes like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此有效载荷提交到模板注入端点时，应该会看到如下类的列表：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To better understand what’s happening here, let’s break down this payload a
    bit:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这里发生了什么，让我们稍微分析一下这个有效载荷：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It first creates an empty list and calls its `__class__` attribute, which refers
    to the class the instance belongs to, `list`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先创建一个空列表并调用其`__class__`属性，该属性引用该实例所属的类，即`list`：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then you can use the `__bases__` attribute to refer to the base classes of
    the `list` class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以使用`__bases__`属性来引用`list`类的基类：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This attribute will return a tuple (which is just an ordered list in Python)
    of all the base classes of the class `list`. A *base class* is a class that the
    current class is built from; `list` has a base class called `object`. Next, we
    need to access the `object` class by referring to the first item in the tuple:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性将返回一个元组（在 Python 中就是一个有序列表），该元组包含`list`类的所有基类。*基类*是当前类构建自的类；`list`类有一个名为`object`的基类。接下来，我们需要通过引用元组中的第一个项来访问`object`类：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we use `__subclasses__()` to refer to all the subclasses of the class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`__subclasses__()`来引用该类的所有子类：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When we use this method, all the subclasses of the `object` class become accessible
    to us! Now, we simply need to look for a method in one of these classes that we
    can use for command execution. Let’s explore one possible way of executing code.
    Before we go on, keep in mind that not every application’s Python environment
    will have the same classes. Moreover, the payload I’ll talk about next may not
    work on all target applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这种方法时，`object`类的所有子类都能对我们开放！现在，我们只需要在这些类中查找可以用于命令执行的方法。让我们探索一种可能的代码执行方式。在继续之前，请记住，并非每个应用程序的
    Python 环境都会有相同的类。此外，接下来我将讨论的有效载荷可能并不适用于所有目标应用程序。
- en: The `__import__` function, which can be used to import modules, is one of Python’s
    built-in functions. But since Jinja2 is blocking its direct access, you will need
    to access it via the `builtins` module. This module provides direct access to
    all of Python’s built-in classes and functions. Most Python modules have `__builtins__`
    as an attribute that refers to the built-in module, so you can recover the `builtins`
    module by referring to the `__builtins__` attribute.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`__import__`函数是Python的内建函数，可以用来导入模块。但由于Jinja2阻止了对它的直接访问，你需要通过`builtins`模块来访问它。这个模块提供对Python所有内建类和函数的直接访问。大多数Python模块都有一个`__builtins__`属性，指向内建模块，因此你可以通过引用`__builtins__`属性来恢复`builtins`模块。'
- en: 'Within all the subclasses in `[].__class__.__bases__[0].__subclasses__()`,
    there is a class named `catch_warnings`. This is the subclass we’ll use to construct
    our exploit. To find the `catch_warnings` subclass, inject a loop into the template
    code to look for it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[].__class__.__bases__[0].__subclasses__()`的所有子类中，有一个名为`catch_warnings`的类。我们将使用这个子类来构建我们的漏洞利用。为了找到`catch_warnings`子类，可以在模板代码中注入一个循环来查找它：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This loop goes through all the classes in `[].__class__.__bases__[0].__subclasses__()`
    1 and finds the one with the string `catch_warnings` in its name 2. Then it instantiates
    an object of that class 3. Objects of the class `catch_warnings` have an attribute
    called `_module` that refers to the `warnings` module.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环遍历`[].__class__.__bases__[0].__subclasses__()`中的所有类，并找到名字中包含字符串`catch_warnings`的类。然后它实例化该类的对象。`catch_warnings`类的对象具有一个名为`_module`的属性，它指向`warnings`模块。
- en: 'Finally, we use the reference to the module to refer to the `builtins` module:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用对模块的引用来引用`builtins`模块：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should see a list of built-in classes and functions returned, including
    the function `__import__`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到返回的内建类和函数列表，其中包括`__import__`函数：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now have a way to access the import functionality! Since the built-in classes
    and functions are stored in a Python dictionary, you can access the `__import__`
    function by referring to the key of the function’s entry in the dictionary:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一种访问导入功能的方法！由于内建类和函数存储在Python字典中，你可以通过引用该函数条目在字典中的键来访问`__import__`函数：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we can use the `__import__` function to import the `os` module. You can
    import a module with `__import__` by providing the name of that module as an argument.
    Here, let’s import the `os` module so we can access the `system()` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`__import__`函数来导入`os`模块。你可以通过提供模块名称作为参数来用`__import__`导入模块。在这里，我们导入`os`模块，以便能够访问`system()`函数：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, call the `system()` function and put the command we want to execute
    as the `system()` function’s argument:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`system()`函数，并将我们想要执行的命令作为`system()`函数的参数：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You should see the results of the `ls` command returned. Thiscommand lists the
    contents of the current directory. You’ve achieved command execution! Now, you
    should be able to execute arbitrary system commands with this template injection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到返回的`ls`命令的结果。这个命令列出了当前目录的内容。你已经成功执行了命令！现在，你应该能够通过这个模板注入执行任意的系统命令。
- en: Submitting Payloads for Testing
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交有效载荷进行测试
- en: 'For testing purposes, you should execute code that doesn’t harm the system
    you’re targeting. A common way of proving that you’ve achieved command execution
    and gained access to the operating system is to create a file with a distinct
    filename on the system, such as *template_injection_by_YOUR_BUG_BOUNTY_USERNAME.txt*,
    so that the file is clearly a part of your proof of concept. Use the `touch` command
    to create a file with the specified name in the current directory:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 出于测试目的，你应该执行一些不会对目标系统造成伤害的代码。验证你已成功执行命令并获取操作系统访问权限的常见方法是，在系统上创建一个具有独特文件名的文件，比如*template_injection_by_YOUR_BUG_BOUNTY_USERNAME.txt*，这样该文件就明确成为你概念验证的一部分。使用`touch`命令在当前目录下创建一个具有指定名称的文件：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Different template engines require different escalation techniques. If exploring
    this interests you, I encourage you to do more research into the area. Code execution
    and sandbox escapes are truly fascinating topics. We will discuss more about how
    to execute arbitrary code on target systems in Chapter 18\. If you are interested
    in learning more about sandbox escapes, these articles discuss the topic in more
    detail (this chapter’s example was developed from a tip in Programmer Help):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的模板引擎需要不同的升级技巧。如果你对这个领域感兴趣，我鼓励你进行更多的研究。代码执行和沙箱逃逸是非常迷人的话题。我们将在第18章讨论更多关于如何在目标系统上执行任意代码的内容。如果你对沙箱逃逸感兴趣，这些文章更详细地讨论了这一话题（本章的示例来自《程序员帮助》中的一个提示）：
- en: CTF Wiki, https://ctf-wiki.github.io/ctf-wiki/pwn/linux/sandbox/python-sandbox-escape/
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CTF Wiki, https://ctf-wiki.github.io/ctf-wiki/pwn/linux/sandbox/python-sandbox-escape/
- en: HackTricks, [https://book.hacktricks.xyz/misc/basic-python/bypass-python-sandboxes/](https://book.hacktricks.xyz/misc/basic-python/bypass-python-sandboxes/)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HackTricks, [https://book.hacktricks.xyz/misc/basic-python/bypass-python-sandboxes/](https://book.hacktricks.xyz/misc/basic-python/bypass-python-sandboxes/)
- en: Programmer Help, [https://programmer.help/blogs/python-sandbox-escape.html](https://programmer.help/blogs/python-sandbox-escape.html)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Programmer Help, [https://programmer.help/blogs/python-sandbox-escape.html](https://programmer.help/blogs/python-sandbox-escape.html)
- en: Automating Template Injection
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化模板注入
- en: Developing exploits for each system you target can be time-consuming. Luckily,
    templates often contain already known exploits that others have discovered, so
    when you find a template injection vulnerability, it’s a good idea to automate
    the exploitation process to make your work more efficient.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个目标系统开发漏洞利用可能会非常耗时。幸运的是，模板通常包含了其他人已经发现的已知漏洞，因此当你发现模板注入漏洞时，最好自动化漏洞利用过程，以提高工作效率。
- en: One tool built to automate the template injection process, called tplmap ([https://github.com/epinna/tplmap/](https://github.com/epinna/tplmap/)),
    can scan for template injections, determine the template engine in use, and construct
    exploits. While this tool does not support every template engine, it should provide
    you with a good starting point for the most popular ones.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个工具专门用于自动化模板注入过程，叫做 tplmap ([https://github.com/epinna/tplmap/](https://github.com/epinna/tplmap/))，它可以扫描模板注入、确定使用的模板引擎，并构建漏洞利用。虽然该工具不支持所有模板引擎，但它应该能为你提供一个针对最流行引擎的良好起点。
- en: Finding Your First Template Injection!
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现你的第一个模板注入漏洞！
- en: 'It’s time to find your first template injection vulnerability by following
    the steps we discussed in this chapter:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候按照我们在本章讨论的步骤，找到你的第一个模板注入漏洞了：
- en: Identify any opportunity to submit user input to the application. Mark down
    candidates of template injection for further inspection.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别任何可以向应用程序提交用户输入的机会。标记模板注入的候选项以便进一步检查。
- en: Detect template injection by submitting test payloads. You can use either payloads
    that are designed to induce errors, or engine-specific payloads designed to be
    evaluated by the template engine.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提交测试负载来检测模板注入。你可以使用旨在引发错误的负载，或者是专为模板引擎设计的负载，旨在被模板引擎评估。
- en: If you find an endpoint that is vulnerable to template injection, determine
    the template engine in use. This will help you build an exploit specific to the
    template engine.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你发现一个易受模板注入攻击的端点，确定使用的模板引擎。这将帮助你构建特定于模板引擎的漏洞利用。
- en: Research the template engine and programming language that the target is using
    to construct an exploit.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 研究目标使用的模板引擎和编程语言，以便构建漏洞利用。
- en: Try to escalate the vulnerability to arbitrary command execution.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将漏洞升级为任意命令执行漏洞。
- en: Create a proof of concept that does not harm the targeted system. A good way
    to do this is to execute `touch template_injection_by_``YOUR_NAME``.txt` to create
    a specific proof-of-concept file.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个不会损害目标系统的概念验证。一个好的方法是执行 `touch template_injection_by_``YOUR_NAME``.txt`
    来创建一个特定的概念验证文件。
- en: Draft your first template injection report and send it to the organization!
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 起草你的第一个模板注入报告，并将其发送给相关组织！
