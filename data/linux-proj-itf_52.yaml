- en: Chapter 52. POSIX Message Queues
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第52章 POSIX 消息队列
- en: 'This chapter describes POSIX message queues, which allow processes to exchange
    data in the form of messages. POSIX message queues are similar to their System
    V counterparts, in that data is exchanged in units of whole messages. However,
    there are also some notable differences:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了 POSIX 消息队列，它允许进程以消息的形式交换数据。POSIX 消息队列与 System V 消息队列类似，数据以完整的消息单位交换。然而，它们也有一些显著的不同之处：
- en: POSIX message queues are reference counted. A queue that is marked for deletion
    is removed only after it is closed by all processes that are currently using it.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 消息队列是引用计数的。标记为删除的队列仅在所有当前使用该队列的进程关闭后才会被删除。
- en: Each System V message has an integer type, and messages can be selected in a
    variety of ways using *msgrcv()*. By contrast, POSIX messages have an associated
    priority, and messages are always strictly queued (and thus received) in priority
    order.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 System V 消息都有一个整数类型，可以通过 *msgrcv()* 函数以多种方式选择消息。与此不同，POSIX 消息具有相关的优先级，消息总是严格按优先级顺序排队（因此也按优先级顺序接收）。
- en: POSIX message queues provide a feature that allows a process to be asynchronously
    notified when a message is available on a queue.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 消息队列提供了一项功能，允许进程在队列中有消息时异步通知。
- en: POSIX message queues are a relatively recent addition to Linux. The required
    implementation support was added in kernel 2.6.6 (in addition, *glibc* 2.3.4 or
    later is required).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 消息队列是 Linux 中相对较新的功能。所需的实现支持是在内核 2.6.6 中添加的（此外，还要求 *glibc* 2.3.4 或更高版本）。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: POSIX message queue support is an optional kernel component that is configured
    via the `CONFIG_POSIX_MQUEUE` option.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 消息队列支持是一个可选的内核组件，通过 `CONFIG_POSIX_MQUEUE` 选项进行配置。
- en: Overview
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'The main functions in the POSIX message queue API are the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 消息队列 API 中的主要功能如下：
- en: The *mq_open()* function creates a new message queue or opens an existing queue,
    returning a message queue descriptor for use in later calls.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mq_open()* 函数用于创建一个新的消息队列或打开一个现有的队列，并返回一个消息队列描述符，以供后续调用使用。'
- en: The *mq_send()* function writes a message to a queue.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mq_send()* 函数将消息写入队列。'
- en: The *mq_receive()* function reads a message from a queue.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mq_receive()* 函数从队列中读取一条消息。'
- en: The *mq_close()* function closes a message queue that the process previously
    opened.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mq_close()* 函数关闭进程之前打开的消息队列。'
- en: The *mq_unlink()* function removes a message queue name and marks the queue
    for deletion when all processes have closed it.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mq_unlink()* 函数移除消息队列的名称，并在所有进程关闭该队列后标记该队列为删除。'
- en: 'The above functions all serve fairly obvious purposes. In addition, a couple
    of features are peculiar to the POSIX message queue API:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数的目的相当明确。此外，POSIX 消息队列 API 还有一些独特的功能：
- en: 'Each message queue has an associated set of attributes. Some of these attributes
    can be set when the queue is created or opened using *mq_open()*. Two functions
    are provided to retrieve and change queue attributes: *mq_getattr()* and *mq_setattr()*.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个消息队列都有一组相关的属性。部分属性可以在使用 *mq_open()* 创建或打开队列时设置。提供了两个函数来检索和更改队列属性：*mq_getattr()*
    和 *mq_setattr()*。
- en: The *mq_notify()* function allows a process to register for message notification
    from a queue. After registering, the process is notified of the availability of
    a message by delivery of a signal or by the invocation of a function in a separate
    thread.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mq_notify()* 函数允许进程注册以接收来自队列的消息通知。注册后，进程将通过信号传递或在单独线程中调用函数的方式通知消息的可用性。'
- en: Opening, Closing, and Unlinking a Message Queue
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开、关闭和取消链接消息队列
- en: In this section, we look at the functions used to open, close, and remove message
    queues.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看用于打开、关闭和删除消息队列的函数。
- en: Opening a message queue
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打开消息队列
- en: The *mq_open()* function creates a new message queue or opens an existing queue.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_open()* 函数用于创建一个新的消息队列或打开一个现有的队列。'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns a message queue descriptor on success, or *(mqd_t)* -1 on error
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功时返回消息队列描述符，出错时返回 *(mqd_t)* -1。
- en: The *name* argument identifies the message queue, and is specified according
    to the rules given in Section 51.1.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*name* 参数标识消息队列，并根据第51.1节中给定的规则进行指定。'
- en: The *oflag* argument is a bit mask that controls various aspects of the operation
    of *mq_open()*. The values that can be included in this mask are summarized in
    [Table 52-1](ch52.html#bit_values_for_the_mq_underscore_open_op "Table 52-1. Bit
    values for the mq_open() oflag argument").
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*oflag* 参数是一个位掩码，控制着 *mq_open()* 操作的各个方面。可以包含在此掩码中的值已在[表 52-1](ch52.html#bit_values_for_the_mq_underscore_open_op
    "表 52-1. mq_open() oflag 参数的位值")中总结。'
- en: Table 52-1. Bit values for the *mq_open() oflag* argument
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表 52-1. *mq_open() oflag* 参数的位值
- en: '| Flag | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Flag | 描述 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `O_CREAT` | Create queue if it doesn’t already exist |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `O_CREAT` | 如果队列尚不存在，则创建队列 |'
- en: '| `O_EXCL` | With `O_CREAT`, create queue exclusively |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `O_EXCL` | 与 `O_CREAT` 一起，独占地创建队列 |'
- en: '| `O_RDONLY` | Open for reading only |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `O_RDONLY` | 仅用于读取 |'
- en: '| `O_WRONLY` | Open for writing only |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `O_WRONLY` | 仅用于写入 |'
- en: '| `O_RDWR` | Open for reading and writing |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `O_RDWR` | 以读写模式打开 |'
- en: '| `O_NONBLOCK` | Open in nonblocking mode |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `O_NONBLOCK` | 以非阻塞模式打开 |'
- en: One of the purposes of the *oflag* argument is to determine whether we are opening
    an existing queue or creating and opening a new queue. If *oflag* doesn’t include
    `O_CREAT`, we are opening an existing queue. If *oflag* includes `O_CREAT`, a
    new, empty queue is created if one with the given *name* doesn’t already exist.
    If *oflag* specifies both `O_CREAT` and `O_EXCL`, and a queue with the given *name*
    already exists, then *mq_open()* fails.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*oflag* 参数的一个用途是确定我们是打开一个已存在的队列，还是创建并打开一个新的队列。如果 *oflag* 不包含 `O_CREAT`，则表示我们正在打开一个已存在的队列。如果
    *oflag* 包含 `O_CREAT`，则如果给定的 *name* 对应的队列尚不存在，就会创建一个新的空队列。如果 *oflag* 同时指定了 `O_CREAT`
    和 `O_EXCL`，并且给定的 *name* 已经存在队列，那么 *mq_open()* 会失败。'
- en: The *oflag* argument also indicates the kind of access that the calling process
    will make to the message queue, by specifying exactly one of the values `O_RDONLY`,
    `O_WRONLY`, or `O_RDWR`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*oflag* 参数还指示调用进程对消息队列的访问方式，具体通过指定以下三种值之一：`O_RDONLY`、`O_WRONLY` 或 `O_RDWR`。'
- en: The remaining flag value, `O_NONBLOCK`, causes the queue to be opened in nonblocking
    mode. If a subsequent call to *mq_receive()* or *mq_send()* can’t be performed
    without blocking, the call will fail immediately with the error `EAGAIN`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的标志值 `O_NONBLOCK` 会使队列以非阻塞模式打开。如果后续对 *mq_receive()* 或 *mq_send()* 的调用无法在不阻塞的情况下执行，则该调用会立即因错误
    `EAGAIN` 失败。
- en: 'If *mq_open()* is being used to open an existing message queue, the call requires
    only two arguments. However, if `O_CREAT` is specified in *flags*, two further
    arguments are required: *mode* and *attr*. (If the queue specified by *name* already
    exists, these two arguments are ignored.) These arguments are used as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *mq_open()* 用于打开一个已存在的消息队列，则该调用只需要两个参数。然而，如果在 *flags* 中指定了 `O_CREAT`，则需要另外两个参数：*mode*
    和 *attr*。（如果由 *name* 指定的队列已经存在，这两个参数会被忽略。）这两个参数的用途如下：
- en: 'The *mode* argument is a bit mask that specifies the permissions to be placed
    on the new message queue. The bit values that may be specified are the same as
    for files ([Table 15-4](ch15.html#constants_for_file_permission_bits "Table 15-4. Constants
    for file permission bits"), in [Permissions on Regular Files](ch15.html#permissions_on_regular_files
    "Permissions on Regular Files")), and, as with *open()*, the value in *mode* is
    masked against the process umask ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")). To read from a queue (*mq_receive()*),
    read permission must be granted to the corresponding class of user; to write to
    a queue (*mq_send()*), write permission is required.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mode* 参数是一个位掩码，指定新消息队列的权限。可以指定的位值与文件的权限相同（[表 15-4](ch15.html#constants_for_file_permission_bits
    "表 15-4. 文件权限位的常量")，见[常规文件的权限](ch15.html#permissions_on_regular_files "常规文件的权限")），并且与
    *open()* 一样，*mode* 中的值会与进程的 umask 进行掩码处理（[进程文件模式创建掩码：*umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "进程文件模式创建掩码：umask()")）。为了从队列中读取数据（*mq_receive()*），必须授予相应用户类别的读取权限；为了向队列中写入数据（*mq_send()*），则需要写入权限。'
- en: The *attr* argument is an *mq_attr* structure that specifies attributes for
    the new message queue. If *attr* is `NULL`, the queue is created with implementation-defined
    default attributes. We describe the *mq_attr* structure in Section 52.4.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*attr* 参数是一个 *mq_attr* 结构，指定新消息队列的属性。如果 *attr* 为 `NULL`，则队列将使用实现定义的默认属性创建。我们将在第
    52.4 节描述 *mq_attr* 结构。'
- en: Upon successful completion, *mq_open()* returns a *message queue descriptor*,
    a value of type *mqd_t*, which is used in subsequent calls to refer to this open
    message queue. The only stipulation that SUSv3 makes about this data type is that
    it may not be an array; that is, it is guaranteed to be a type that can be used
    in an assignment statement or passed by value as a function argument. (On Linux,
    *mqd_t* is an *int*, but, for example, on Solaris it is defined as *void **.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 成功完成时，*mq_open()* 返回一个 *消息队列描述符*，该值为 *mqd_t* 类型，用于在后续的调用中引用此打开的消息队列。SUSv3 对该数据类型的唯一要求是，它不能是数组；即，它必须是一个可以在赋值语句中使用或作为函数参数按值传递的类型。（在
    Linux 上，*mqd_t* 是 *int*，但例如在 Solaris 上，它被定义为 *void**。）
- en: An example of the use of *mq_open()* is provided in [Example 52-2](ch52.html#creating_a_posix_message_queue
    "Example 52-2. Creating a POSIX message queue").
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 52-2](ch52.html#creating_a_posix_message_queue "示例 52-2：创建 POSIX 消息队列")中提供了使用
    *mq_open()* 的示例。'
- en: Effect of *fork()*, *exec()*, and process termination on message queue descriptors
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*fork()*, *exec()* 和进程终止对消息队列描述符的影响'
- en: During a *fork()*, the child process receives copies of its parent’s message
    queue descriptors, and these descriptors refer to the same open message queue
    descriptions. (We explain message queue descriptions in Section 52.3.) The child
    doesn’t inherit any of its parent’s message notification registrations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *fork()* 过程中，子进程会收到父进程的消息队列描述符的副本，这些描述符指向相同的打开消息队列描述符。（我们在第 52.3 节中解释了消息队列描述符。）子进程不会继承父进程的任何消息通知注册。
- en: When a process performs an *exec()* or terminates, all of its open message queue
    descriptors are closed. As a consequence of closing its message queue descriptors,
    all of the process’s message notification registrations on the corresponding queues
    are deregistered.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程执行 *exec()* 或终止时，它所有打开的消息队列描述符都会被关闭。由于关闭了消息队列描述符，进程在相应队列上的所有消息通知注册都会被取消。
- en: Closing a message queue
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关闭消息队列
- en: The *mq_close()* function closes the message queue descriptor *mqdes*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_close()* 函数关闭消息队列描述符 *mqdes*。'
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: If the calling process has registered via *mqdes* for message notification from
    the queue ([Message Notification](ch52.html#message_notification "Message Notification")),
    then the notification registration is automatically removed, and another process
    can subsequently register for message notification from the queue.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用进程通过 *mqdes* 在队列上注册了消息通知（[消息通知](ch52.html#message_notification "消息通知")），那么通知注册会自动移除，之后其他进程可以注册该队列的消息通知。
- en: A message queue descriptor is automatically closed when a process terminates
    or calls *exec()*. As with file descriptors, we should explicitly close message
    queue descriptors that are no longer required, in order to prevent the process
    from running out of message queue descriptors.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程终止或调用 *exec()* 时，消息队列描述符会被自动关闭。与文件描述符一样，我们应当显式关闭不再需要的消息队列描述符，以防止进程耗尽消息队列描述符。
- en: As *close()* for files, closing a message queue doesn’t delete it. For that
    purpose, we need *mq_unlink()*, which is the message queue analog of *unlink()*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件的 *close()* 类似，关闭消息队列并不会删除它。为了删除消息队列，我们需要使用 *mq_unlink()*，它是 *unlink()* 的消息队列类比。
- en: Removing a message queue
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除消息队列
- en: The *mq_unlink()* function removes the message queue identified by *name*, and
    marks the queue to be destroyed once all processes cease using it (this may mean
    immediately, if all processes that had the queue open have already closed it).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_unlink()* 函数移除由 *name* 标识的消息队列，并将该队列标记为在所有进程停止使用后销毁（如果所有打开队列的进程已经关闭该队列，可能会立即销毁）。'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: '[Example 52-1](ch52.html#using_mq_underscore_unlink_open_parenthe "Example 52-1. Using
    mq_unlink() to unlink a POSIX message queue") demonstrates the use of *mq_unlink()*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 52-1](ch52.html#using_mq_underscore_unlink_open_parenthe "示例 52-1：使用 mq_unlink()
    断开 POSIX 消息队列") 演示了如何使用 *mq_unlink()*。'
- en: Example 52-1. Using *mq_unlink()* to unlink a POSIX message queue
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 52-1：使用 *mq_unlink()* 断开 POSIX 消息队列
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Relationship Between Descriptors and Message Queues
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符与消息队列之间的关系
- en: The relationship between a message queue descriptor and an open message queue
    is analogous to the relationship between a file descriptor and an open file ([Figure 5-2](ch05.html#relationship_between_file_descriptors_co
    "Figure 5-2. Relationship between file descriptors, open file descriptions, and
    i-nodes"), in [Relationship Between File Descriptors and Open Files](ch05.html#relationship_between_file_descriptors_an
    "Relationship Between File Descriptors and Open Files")). A message queue descriptor
    is a per-process handle that refers to an entry in the system-wide table of open
    message queue descriptions, and this entry in turn refers to a message queue object.
    This relationship is illustrated in [Figure 52-1](ch52.html#relationship_between_kernel_data_structu
    "Figure 52-1. Relationship between kernel data structures for POSIX message queues").
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列描述符和打开的消息队列之间的关系类似于文件描述符和打开文件之间的关系（参见[图 5-2](ch05.html#relationship_between_file_descriptors_co
    "图 5-2. 文件描述符、打开文件描述符和 i 节点的关系")，以及[文件描述符与打开文件之间的关系](ch05.html#relationship_between_file_descriptors_an
    "文件描述符与打开文件之间的关系")）。消息队列描述符是每个进程的句柄，指向系统范围内打开消息队列描述符表中的一个条目，而该条目又指向一个消息队列对象。这个关系如[图
    52-1](ch52.html#relationship_between_kernel_data_structu "图 52-1. POSIX 消息队列的内核数据结构关系")所示。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, POSIX message queues are implemented as i-nodes in a virtual file
    system, and message queue descriptors and open message queue descriptions are
    implemented as file descriptors and open file descriptions, respectively. However,
    these are implementation details that are not required by SUSv3 and don’t hold
    true on some other UNIX implementations. Nevertheless, we return to this point
    in [Linux-Specific Features](ch52.html#linux-specific_features "Linux-Specific
    Features"), because Linux provides some nonstandard features that are made possible
    by this implementation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，POSIX 消息队列作为虚拟文件系统中的 i 节点实现，消息队列描述符和打开的消息队列描述符分别作为文件描述符和打开文件描述符实现。然而，这些是实现细节，并非
    SUSv3 的要求，在其他一些 UNIX 实现中并不成立。尽管如此，我们将在[Linux 特定功能](ch52.html#linux-specific_features
    "Linux 特定功能")一节回到这一点，因为 Linux 提供了一些由此实现所支持的非标准功能。
- en: '![Relationship between kernel data structures for POSIX message queues](figs/web/52-1_PMSG-mq-model.png.jpg)Figure 52-1. Relationship
    between kernel data structures for POSIX message queues'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![POSIX 消息队列的内核数据结构关系](figs/web/52-1_PMSG-mq-model.png.jpg)图 52-1. POSIX 消息队列的内核数据结构关系'
- en: '[Figure 52-1](ch52.html#relationship_between_kernel_data_structu "Figure 52-1. Relationship
    between kernel data structures for POSIX message queues") helps clarify a number
    of details of the use of message queue descriptors (all of which are analogous
    to the use to file descriptors):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 52-1](ch52.html#relationship_between_kernel_data_structu "图 52-1. POSIX
    消息队列的内核数据结构关系") 帮助澄清了消息队列描述符使用的一些细节（这些都类似于文件描述符的使用）：'
- en: An open message queue description has an associated set of flags. SUSv3 specifies
    only one such flag, `O_NONBLOCK`, which determines whether I/O is nonblocking.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开的消息队列描述符有一组相关的标志。SUSv3 只指定了一个这样的标志 `O_NONBLOCK`，它决定了 I/O 是否为非阻塞模式。
- en: Two processes can hold message queue descriptors (descriptor *x* in the diagram)
    that refer to the same open message queue description. This can occur because
    a process opens a message queue and then calls *fork()*. These descriptors share
    the state of the `O_NONBLOCK` flag.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个进程可以持有指向同一个打开的消息队列描述符的消息队列描述符（图中描述符 *x*）。这可以发生在一个进程打开消息队列后调用 *fork()*。这些描述符共享
    `O_NONBLOCK` 标志的状态。
- en: Two processes can hold open message queue descriptors that refer to different
    message queue descriptions that refer to the same message queue (e.g., descriptor
    *z* in process A and descriptor *y* in process B both refer to `/mq-r`). This
    occurs because the two processes each used *mq_open()* to open the same queue.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个进程可以持有指向不同消息队列描述符的打开的消息队列描述符，而这些描述符却指向同一个消息队列（例如，进程 A 中的描述符 *z* 和进程 B 中的描述符
    *y* 都指向 `/mq-r`）。这是因为两个进程各自使用 *mq_open()* 打开了同一个队列。
- en: Message Queue Attributes
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息队列属性
- en: 'The *mq_open()*, *mq_getattr()*, and *mq_setattr()* functions all permit an
    argument that is a pointer to an *mq_attr* structure. This structure is defined
    in `<mqueue.h>` as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_open()*、*mq_getattr()* 和 *mq_setattr()* 函数都允许传入一个指向 *mq_attr* 结构的指针。这个结构在
    `<mqueue.h>` 中定义如下：'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before we look at the *mq_attr* structure in detail, it is worth noting the
    following points:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细查看 *mq_attr* 结构之前，值得注意以下几点：
- en: Only some of the fields are used by each of the three functions. The fields
    used by each function are indicated in the comments accompanying the structure
    definition above.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数只使用其中的一部分字段。每个函数使用的字段在上面结构定义的注释中有所指示。
- en: The structure contains information about the open message queue description
    (*mq_flags*) associated with a message descriptor and information about the queue
    referred to by that descriptor (*mq_maxmsg*, *mq_msgsize*, *mq_curmsgs*).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该结构包含有关打开的消息队列描述符（*mq_flags*）的信息，这些描述符与消息描述符相关联，还包含与该描述符关联的队列的信息（*mq_maxmsg*，*mq_msgsize*，*mq_curmsgs*）。
- en: Some of the fields contain information that is fixed at the time the queue is
    created with *mq_open()* (*mq_maxmsg* and *mq_msgsize*); the others return information
    about the current state of the message queue description (*mq_flags*) or message
    queue (*mq_curmsgs*).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些字段包含在使用 *mq_open()* 创建队列时固定的信息（*mq_maxmsg* 和 *mq_msgsize*）；其他字段返回有关当前消息队列描述符（*mq_flags*）或消息队列（*mq_curmsgs*）的状态信息。
- en: Setting message queue attributes during queue creation
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在队列创建期间设置消息队列属性
- en: 'When we create a message queue with *mq_open()*, the following *mq_attr* fields
    determine the attributes of the queue:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 *mq_open()* 创建一个消息队列时，以下 *mq_attr* 字段决定了队列的属性：
- en: The *mq_maxmsg* field defines the limit on the number of messages that can be
    placed on the queue using *mq_send()*. This value must be greater than 0.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mq_maxmsg* 字段定义了使用 *mq_send()* 放置在队列中的消息数量的上限。该值必须大于 0。'
- en: The *mq_msgsize* field defines the upper limit on the size of each message that
    may be placed on the queue. This value must be greater than 0.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mq_msgsize* 字段定义了可以放置在队列中的每条消息的大小上限。该值必须大于 0。'
- en: Together, these two values allow the kernel to determine the maximum amount
    of memory that this message queue may require.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值一起允许内核确定该消息队列可能需要的最大内存量。
- en: The *mq_maxmsg* and *mq_msgsize* attributes are fixed when a message queue is
    created; they can’t subsequently be changed. In [Message Queue Limits](ch52.html#message_queue_limits-id1
    "Message Queue Limits"), we describe two `/proc` files that place system-wide
    limits on the values that can be specified for the *mq_maxmsg* and *mq_msgsize*
    attributes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_maxmsg* 和 *mq_msgsize* 属性在消息队列创建时被固定；它们之后不能更改。在 [消息队列限制](ch52.html#message_queue_limits-id1
    "消息队列限制")一节中，我们描述了两个 `/proc` 文件，它们对可以为 *mq_maxmsg* 和 *mq_msgsize* 属性指定的值设置了系统范围的限制。'
- en: The program in [Example 52-2](ch52.html#creating_a_posix_message_queue "Example 52-2. Creating
    a POSIX message queue") provides a command-line interface to the *mq_open()* function
    and shows how the *mq_attr* structure is used with *mq_open()*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 52-2](ch52.html#creating_a_posix_message_queue "示例 52-2. 创建一个 POSIX 消息队列")
    中的程序提供了一个命令行界面来使用 *mq_open()* 函数，并展示了如何将 *mq_attr* 结构与 *mq_open()* 一起使用。'
- en: 'Two command-line options allow message queue attributes to be specified: *-m*
    for *mq_maxmsg* and *-s* for *mq_msgsize*. If either of these options is supplied,
    a non-`NULL` *attrp* argument is passed to *mq_open()*. Some default values are
    assigned to the fields of the *mq_attr* structure to which *attrp* points, in
    case only one of the *-m* and *-s* options is specified on the command line. If
    neither of these options is supplied, *attrp* is specified as `NULL` when calling
    *mq_open()*, which causes the queue to be created with the implementation-defined
    defaults for the queue attributes.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个命令行选项允许指定消息队列属性：* -m * 用于 *mq_maxmsg*，* -s * 用于 *mq_msgsize*。如果提供了这些选项中的任意一个，将一个非
    `NULL` 的 *attrp* 参数传递给 *mq_open()*。如果只在命令行中指定了 *-m* 或 *-s* 中的一个选项，将为 *attrp* 指向的
    *mq_attr* 结构体字段分配一些默认值。如果两个选项都没有提供，则在调用 *mq_open()* 时，*attrp* 将被指定为 `NULL`，这将导致队列使用实现定义的默认值来创建队列属性。
- en: Example 52-2. Creating a POSIX message queue
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 52-2. 创建一个 POSIX 消息队列
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Retrieving message queue attributes
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检索消息队列属性
- en: The *mq_getattr()* function returns an *mq_attr* structure containing information
    about the message queue description and the message queue associated with the
    descriptor *mqdes*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_getattr()* 函数返回一个 *mq_attr* 结构体，其中包含关于消息队列描述符 *mqdes* 关联的消息队列的信息。'
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: 'In addition to the *mq_maxmsg* and *mq_msgsize* fields, which we have already
    described, the following fields are returned in the structure pointed to by *attr*:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已经描述的 *mq_maxmsg* 和 *mq_msgsize* 字段外，以下字段也会在 *attr* 指向的结构体中返回：
- en: '*mq_flags*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_flags*'
- en: 'These are flags for the open message queue description associated with the
    descriptor *mqdes*. Only one such flag is specified: `O_NONBLOCK`. This flag is
    initialized from the *oflag* argument of *mq_open()*, and can be changed using
    *mq_setattr()*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是与描述符 *mqdes* 关联的打开的消息队列描述符的标志。仅指定了一个标志：`O_NONBLOCK`。这个标志由 *mq_open()* 的 *oflag*
    参数初始化，并且可以通过 *mq_setattr()* 更改。
- en: '*mq_curmsgs*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_curmsgs*'
- en: This is the number of messages that are currently in the queue. This information
    may already have changed by the time *mq_getattr()* returns, if other processes
    are reading messages from the queue or writing messages to it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前队列中的消息数量。如果其他进程正在从队列中读取消息或向其写入消息，则在 *mq_getattr()* 返回时，此信息可能已经发生变化。
- en: The program in [Example 52-3](ch52.html#retrieving_posix_message_queue_attribute
    "Example 52-3. Retrieving POSIX message queue attributes") employs *mq_getattr()*
    to retrieve the attributes for the message queue specified in its command-line
    argument, and then displays those attributes on standard output.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 52-3](ch52.html#retrieving_posix_message_queue_attribute "示例 52-3. 检索 POSIX
    消息队列属性")中的程序使用 *mq_getattr()* 获取命令行参数中指定的消息队列的属性，然后将这些属性显示在标准输出上。'
- en: Example 52-3. Retrieving POSIX message queue attributes
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 52-3. 检索 POSIX 消息队列属性
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the following shell session, we use the program in [Example 52-2](ch52.html#creating_a_posix_message_queue
    "Example 52-2. Creating a POSIX message queue") to create a message queue with
    implementation-defined default attributes (i.e., the final argument to *mq_open()*
    is `NULL`), and then use the program in [Example 52-3](ch52.html#retrieving_posix_message_queue_attribute
    "Example 52-3. Retrieving POSIX message queue attributes") to display the queue
    attributes so that we can see the default settings on Linux.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的 shell 会话中，我们使用[示例 52-2](ch52.html#creating_a_posix_message_queue "示例 52-2.
    创建 POSIX 消息队列")中的程序创建一个具有实现定义默认属性的消息队列（即，*mq_open()*的最后一个参数是`NULL`），然后使用[示例 52-3](ch52.html#retrieving_posix_message_queue_attribute
    "示例 52-3. 检索 POSIX 消息队列属性")中的程序显示队列属性，以便我们能够查看 Linux 上的默认设置。
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the above output, we see that the Linux default values for *mq_maxmsg*
    and *mq_msgsize* are 10 and 8192, respectively.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，我们看到 Linux 上的默认值，*mq_maxmsg* 为 10，*mq_msgsize* 为 8192。
- en: There is a wide variation in the implementation-defined defaults for *mq_maxmsg*
    and *mq_msgsize*. Portable applications generally need to choose explicit values
    for these attributes, rather than relying on the defaults.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *mq_maxmsg* 和 *mq_msgsize* 的实现定义默认值差异很大。便携式应用程序通常需要为这些属性选择明确的值，而不是依赖于默认值。
- en: Modifying message queue attributes
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改消息队列属性
- en: The *mq_setattr()* function sets attributes of the message queue description
    associated with the message queue descriptor *mqdes*, and optionally returns information
    about the message queue.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_setattr()* 函数设置与消息队列描述符 *mqdes* 相关联的消息队列描述符的属性，并可选择性地返回有关消息队列的信息。'
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'The *mq_setattr()* function performs the following tasks:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_setattr()* 函数执行以下任务：'
- en: It uses the *mq_flags* field in the *mq_attr* structure pointed to by *newattr*
    to change the flags of the message queue description associated with the descriptor
    *mqdes*.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 *mq_attr* 结构中由 *newattr* 指向的 *mq_flags* 字段来更改与描述符 *mqdes* 关联的消息队列描述符的标志。
- en: If *oldattr* is non-`NULL`, it returns an *mq_attr* structure containing the
    previous message queue description flags and message queue attributes (i.e., the
    same task as is performed by *mq_getattr()*).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *oldattr* 非 `NULL`，它将返回一个包含先前消息队列描述符标志和消息队列属性的 *mq_attr* 结构（即，与 *mq_getattr()*
    执行的任务相同）。
- en: The only attribute that SUSv3 specifies that can be changed using *mq_setattr()*
    is the state of the `O_NONBLOCK` flag.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定的唯一可以通过 *mq_setattr()* 更改的属性是 `O_NONBLOCK` 标志的状态。
- en: 'Allowing for the possibility that a particular implementation may define other
    modifiable flags, or that SUSv3 may add new flags in the future, a portable application
    should change the state of the `O_NONBLOCK` flag by using *mq_getattr()* to retrieve
    the *mq_flags* value, modifying the `O_NONBLOCK` bit, and calling *mq_setattr()*
    to change the *mq_flags* settings. For example, to enable `O_NONBLOCK`, we would
    do the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到某些实现可能会定义其他可修改的标志，或者 SUSv3 将来可能会添加新的标志，便携式应用程序应该使用 *mq_getattr()* 来检索 *mq_flags*
    值，修改 `O_NONBLOCK` 位，然后调用 *mq_setattr()* 来更改 *mq_flags* 设置。举例来说，若要启用 `O_NONBLOCK`，我们可以这样做：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Exchanging Messages
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换消息
- en: In this section, we look at the functions that are used to send messages to
    and receive messages from a queue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了用于向队列发送消息和接收消息的函数。
- en: Sending Messages
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送消息
- en: The *mq_send()* function adds the message in the buffer pointed to by *msg_ptr*
    to the message queue referred to by the descriptor *mqdes*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_send()* 函数将由 *msg_ptr* 指向的缓冲区中的消息添加到由描述符 *mqdes* 引用的消息队列中。'
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1。
- en: The *msg_len* argument specifies the length of the message pointed to by *msg_ptr*.
    This value must be less than or equal to the *mq_msgsize* attribute of the queue;
    otherwise, *mq_send()* fails with the error `EMSGSIZE`. Zero-length messages are
    permitted.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*msg_len* 参数指定由 *msg_ptr* 指向的消息的长度。该值必须小于或等于队列的 *mq_msgsize* 属性，否则 *mq_send()*
    会因错误 `EMSGSIZE` 而失败。零长度的消息是允许的。'
- en: Each message has a nonnegative integer priority, specified by the *msg_prio*
    argument. Messages are ordered within the queue in descending order of priority
    (i.e., 0 is the lowest priority). When a new message is added to the queue, it
    is placed after any other messages of the same priority. If an application doesn’t
    need to use message priorities, it is sufficient to always specify *msg_prio*
    as 0.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息都有一个非负整数的优先级，由 *msg_prio* 参数指定。消息在队列中按优先级降序排列（即，0 是最低优先级）。当新消息添加到队列时，它会排在任何其他相同优先级的消息之后。如果应用程序不需要使用消息优先级，则始终将
    *msg_prio* 指定为 0 即可。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As noted at the beginning of this chapter, the type attribute of System V messages
    provides different functionality. System V messages are always queued in FIFO
    order, but *msgrcv()* allows us to select messages in various ways: in FIFO order,
    by exact type, or by highest type less than or equal to some value.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所提到的，System V 消息的类型属性提供了不同的功能。System V 消息总是按 FIFO 顺序排队，但 *msgrcv()* 允许我们以各种方式选择消息：按
    FIFO 顺序，按精确类型，或按小于或等于某个值的最大类型。
- en: SUSv3 allows an implementation to advertise its upper limit for message priorities,
    either by defining the constant `MQ_PRIO_MAX` or via the return from *sysconf(_SC_MQ_PRIO_MAX)*.
    SUSv3 requires this limit to be at least 32 `(_POSIX_MQ_PRIO_MAX)`; that is, priorities
    at least in the range 0 to 31 are available. However, the actual range on implementations
    is highly variable. For example, on Linux, this constant has the value 32,768;
    on Solaris, it is 32; and on Tru64, it is 256.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 允许实现广告其消息优先级的上限，方法是定义常量 `MQ_PRIO_MAX` 或通过 *sysconf(_SC_MQ_PRIO_MAX)* 返回。SUSv3
    要求此限制至少为 32 `(_POSIX_MQ_PRIO_MAX)`；即，至少提供从 0 到 31 的优先级。然而，实际实现中的范围差异很大。例如，在 Linux
    上，此常量的值为 32,768；在 Solaris 上为 32；在 Tru64 上为 256。
- en: If the message queue is already full (i.e., the *mq_maxmsg* limit for the queue
    has been reached), then a further *mq_send()* either blocks until space becomes
    available in the queue, or, if the `O_NONBLOCK` flag is in effect, fails immediately
    with the error `EAGAIN`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息队列已经满（即队列的 *mq_maxmsg* 限制已达到），则进一步调用 *mq_send()* 要么会阻塞直到队列中有空间可用，要么如果设置了
    `O_NONBLOCK` 标志，则会立即因错误 `EAGAIN` 而失败。
- en: The program in [Example 52-4](ch52.html#writing_a_message_to_a_posix_message_que
    "Example 52-4. Writing a message to a POSIX message queue") provides a command-line
    interface to the *mq_send()* function. We demonstrate the use of this program
    in the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 52-4](ch52.html#writing_a_message_to_a_posix_message_que "示例 52-4. 向 POSIX
    消息队列写入消息") 中的程序提供了一个命令行接口来调用 *mq_send()* 函数。我们将在下一节演示如何使用此程序。'
- en: Example 52-4. Writing a message to a POSIX message queue
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 52-4. 向 POSIX 消息队列写入消息
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Receiving Messages
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收消息
- en: The *mq_receive()* function removes the oldest message with the highest priority
    from the message queue referred to by *mqdes* and returns that message in the
    buffer pointed to by *msg_ptr*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_receive()* 函数从由 *mqdes* 引用的消息队列中移除优先级最高的最旧消息，并将该消息返回到由 *msg_ptr* 指向的缓冲区中。'
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes in received message on success, or -1 on error
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回接收消息的字节数，出错时返回 -1。
- en: The *msg_len* argument is used by the caller to specify the number of bytes
    of space available in the buffer pointed to by *msg_ptr*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*msg_len* 参数由调用者使用，用于指定由 *msg_ptr* 指向的缓冲区中可用的字节数。'
- en: Regardless of the actual size of the message, *msg_len* (and thus the size of
    the buffer pointed to by *msg_ptr*) must be greater than or equal to the *mq_msgsize*
    attribute of the queue; otherwise, *mq_receive()* fails with the error `EMSGSIZE`.
    If we don’t know the value of the *mq_msgsize* attribute of a queue, we can obtain
    it using *mq_getattr()*. (In an application consisting of cooperating processes,
    the use of *mq_getattr()* can usually be dispensed with, because the application
    can typically decide on a queue’s *mq_msgsize* setting in advance.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论消息的实际大小如何，*msg_len*（因此指向*msg_ptr*的缓冲区大小）必须大于或等于队列的*mq_msgsize*属性；否则，*mq_receive()*会因错误`EMSGSIZE`而失败。如果我们不知道队列的*mq_msgsize*属性值，可以使用*mq_getattr()*来获取。（在由协作进程组成的应用程序中，通常可以省略使用*mq_getattr()*，因为应用程序通常可以预先决定队列的*mq_msgsize*设置。）
- en: If *msg_prio* is not `NULL`, then the priority of the received message is copied
    into the location pointed to by *msg_prio*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*msg_prio*不是`NULL`，那么接收到的消息的优先级将被复制到*msg_prio*指向的位置。
- en: If the message queue is currently empty, then *mq_receive()* either blocks until
    a message becomes available, or, if the `O_NONBLOCK` flag is in effect, fails
    immediately with the error `EAGAIN`. (There is no equivalent of the pipe behavior
    where a reader sees end-of-file if there are no writers.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息队列当前为空，则*mq_receive()*要么阻塞直到有消息可用，要么，如果启用了`O_NONBLOCK`标志，立即失败并返回错误`EAGAIN`。（这与管道行为不同，管道在没有写入者时，读取者会看到文件结束标志。）
- en: The program in [Example 52-5](ch52.html#reading_a_message_from_a_posix_message_q
    "Example 52-5. Reading a message from a POSIX message queue") provides a command-line
    interface to the *mq_receive()* function. The command format for this program
    is shown in the *usageError()* function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例52-5](ch52.html#reading_a_message_from_a_posix_message_q "示例52-5. 从POSIX消息队列读取消息")中的程序提供了一个命令行界面来调用*mq_receive()*函数。该程序的命令格式如*usageError()*函数所示。'
- en: 'The following shell session demonstrates the use of the programs in [Example 52-4](ch52.html#writing_a_message_to_a_posix_message_que
    "Example 52-4. Writing a message to a POSIX message queue") and [Example 52-5](ch52.html#reading_a_message_from_a_posix_message_q
    "Example 52-5. Reading a message from a POSIX message queue"). We begin by creating
    a message queue and sending a few messages with different priorities:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Shell会话演示了在[示例52-4](ch52.html#writing_a_message_to_a_posix_message_que "示例52-4.
    向POSIX消息队列写入消息")和[示例52-5](ch52.html#reading_a_message_from_a_posix_message_q "示例52-5.
    从POSIX消息队列读取消息")中使用程序的示例。我们首先创建一个消息队列，并发送几个不同优先级的消息：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then execute a series of commands to retrieve messages from the queue:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行一系列命令来从队列中检索消息：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see from the above output, the messages were retrieved in order of
    priority.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出可以看到，消息是按优先级顺序检索的。
- en: 'At this point, the queue is now empty. When we perform another blocking receive,
    the operation blocks:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，队列已经为空。当我们执行另一个阻塞接收时，操作会阻塞：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On the other hand, if we perform a nonblocking receive, the call returns immediately
    with a failure status:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们执行非阻塞接收，调用会立即返回并显示失败状态：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 52-5. Reading a message from a POSIX message queue
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 示例52-5. 从POSIX消息队列读取消息
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Sending and Receiving Messages with a Timeout
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有超时的消息发送和接收
- en: The *mq_timedsend()* and *mq_timedreceive()* functions are exactly like *mq_send()*
    and *mq_receive()*, except that if the operation can’t be performed immediately,
    and the `O_NONBLOCK` flag is not in effect for the message queue description,
    then the *abs_timeout* argument specifies a limit on the time for which the call
    will block.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_timedsend()*和*mq_timedreceive()*函数与*mq_send()*和*mq_receive()*完全相同，不同之处在于，如果操作不能立即执行，且消息队列描述符上没有`O_NONBLOCK`标志，那么*abs_timeout*参数会指定调用阻塞的时间限制。'
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes in received message on success, or -1 on error
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回接收到的消息的字节数，出错时返回-1
- en: 'The *abs_timeout* argument is a *timespec* structure ([High-Resolution Sleeping:
    *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep "High-Resolution
    Sleeping: nanosleep()")) that specifies the timeout as an absolute value in seconds
    and nanoseconds since the Epoch. To perform a relative timeout, we can fetch the
    current value of the `CLOCK_REALTIME` clock using *clock_gettime()* and add the
    required amount to that value to produce a suitably initialized *timespec* structure.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*abs_timeout* 参数是一个 *timespec* 结构体（[高精度睡眠：*nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep
    "高精度睡眠：nanosleep()")），它指定了从纪元起的秒和纳秒的绝对超时时间。要执行相对超时，我们可以使用 *clock_gettime()* 获取
    `CLOCK_REALTIME` 时钟的当前值，并将所需的时间量加到该值上，以生成一个适当初始化的 *timespec* 结构体。'
- en: If a call to *mq_timedsend()* or *mq_timedreceive()* times out without being
    able to complete its operation, then the call fails with the error `ETIMEDOUT`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *mq_timedsend()* 或 *mq_timedreceive()* 调用超时，无法完成操作，则该调用失败，并返回错误 `ETIMEDOUT`。
- en: On Linux, specifying *abs_timeout* as `NULL` means an infinite timeout. However,
    this behavior is not specified in SUSv3, and portable applications can’t rely
    on it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，将 *abs_timeout* 设置为 `NULL` 表示无限超时。然而，这种行为并未在 SUSv3 中指定，因此可移植的应用程序不能依赖它。
- en: The *mq_timedsend()* and *mq_timedreceive()* functions originally derive from
    POSIX.1d (1999) and are not available on all UNIX implementations.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_timedsend()* 和 *mq_timedreceive()* 函数最初来自 POSIX.1d (1999)，并非所有 UNIX 实现都支持它们。'
- en: Message Notification
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息通知
- en: A feature that distinguishes POSIX message queues from their System V counterparts
    is the ability to receive asynchronous notification of the availability of a message
    on a previously empty queue (i.e., when the queue transitions from being empty
    to nonempty). This feature means that instead of making a blocking *mq_receive()*
    call or marking the message queue descriptor nonblocking and performing periodic
    *mq_receive()* calls (“polls”) on the queue, a process can request a notification
    of message arrival and then perform other tasks until it is notified. A process
    can choose to be notified either via a signal or via invocation of a function
    in a separate thread.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 消息队列与 System V 消息队列的一个区别是，POSIX 消息队列能够在队列之前为空时收到消息到达的异步通知（即，当队列从空转为非空时）。这一特性意味着，进程无需进行阻塞的
    *mq_receive()* 调用或将消息队列描述符标记为非阻塞并定期执行 *mq_receive()* 调用（即“轮询”），而是可以请求在有消息到达时收到通知，之后继续执行其他任务，直到收到通知。进程可以选择通过信号或通过在单独线程中调用函数来接收通知。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The notification feature of POSIX message queues is similar to the notification
    facility that we described for POSIX timers in Section 23.6\. (Both of these APIs
    originated in POSIX.1b.)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 消息队列的通知功能类似于我们在第 23.6 节中为 POSIX 定时器描述的通知机制。（这两个 API 都源自 POSIX.1b。）
- en: The *mq_notify()* function registers the calling process to receive a notification
    when a message arrives on the empty queue referred to by the descriptor *mqdes*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*mq_notify()* 函数将调用进程注册为在描述符 *mqdes* 所引用的空队列上到达消息时接收通知。'
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'The *notification* argument specifies the mechanism by which the process is
    to be notified. Before going into the details of the *notification* argument,
    we note a few points about message notification:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*notification* 参数指定了进程接收通知的机制。在详细介绍 *notification* 参数之前，我们先注意一些关于消息通知的要点：'
- en: At any time, only one process (“the registered process”) can be registered to
    receive a notification from a particular message queue. If there is already a
    process registered for a message queue, further attempts to register for that
    queue fail (*mq_notify()* fails with the error `EBUSY`).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时候，只有一个进程（“注册进程”）可以被注册以接收特定消息队列的通知。如果该消息队列已经有一个进程注册，则进一步注册该队列的尝试会失败（*mq_notify()*
    会返回错误 `EBUSY`）。
- en: The registered process is notified only when a new message arrives on a queue
    that was previously empty. If a queue already contains messages at the time of
    the registration, a notification will occur only after the queue is emptied and
    a new message arrives.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册的进程仅在先前为空的队列上到达新消息时收到通知。如果队列在注册时已经包含消息，则仅在队列清空并且有新消息到达时才会收到通知。
- en: After one notification is sent to the registered process, the registration is
    removed, and any process can then register itself for notification. In other words,
    as long as a process wishes to keep receiving notifications, it must reregister
    itself after each notification by once again calling *mq_notify()*.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向注册进程发送一次通知后，注册会被移除，任何进程都可以重新注册以接收通知。换句话说，只要一个进程希望继续接收通知，它必须在每次通知后通过再次调用*mq_notify()*重新注册。
- en: The registered process is notified only if some other process is not currently
    blocked in a call to *mq_receive()* for the queue. If some other process is blocked
    in *mq_receive()*, that process will read the message, and the registered process
    will remain registered.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当其他进程没有在调用*mq_receive()*时被阻塞，注册的进程才会被通知。如果其他进程在*mq_receive()*中被阻塞，该进程将读取消息，而注册的进程将保持注册状态。
- en: A process can explicitly deregister itself as the target for message notification
    by calling *mq_notify()* with a *notification* argument of `NULL`.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程可以通过调用*mq_notify()*并将*notification*参数设为`NULL`，显式地取消注册自己作为消息通知的目标。
- en: 'We already showed the *sigevent* structure that is used to type the *notification*
    argument in [Creating a Timer: *timer_create()*](ch23.html#creating_a_timer_colon_timer_underscore
    "Creating a Timer: timer_create()"). Here, we present the structure in simplified
    form, showing just those fields relevant to the discussion of *mq_notify()*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[创建计时器：*timer_create()*](ch23.html#creating_a_timer_colon_timer_underscore
    "创建计时器：timer_create()")中展示了用于指定*notification*参数的*sigevent*结构。这里，我们以简化的形式呈现该结构，仅显示与讨论*mq_notify()*相关的字段：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The *sigev_notify* field of this structure is set to one of the following values:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的*sigev_notify*字段被设置为以下值之一：
- en: '`SIGEV_NONE`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGEV_NONE`'
- en: Register this process for notification, but when a message arrives on the previously
    empty queue, don’t actually notify the process. As usual, the registration is
    removed when a new messages arrives on an empty queue.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注册该进程以接收通知，但当先前空的队列中有消息到达时，不会实际通知进程。像往常一样，当新消息到达空队列时，注册会被移除。
- en: '`SIGEV_SIGNAL`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGEV_SIGNAL`'
- en: 'Notify the process by generating the signal specified in the *sigev_signo*
    field. The *sigev_value* field specifies data to accompany the signal ([Limits
    on the number of queued realtime signals](ch22.html#limits_on_the_number_of_queued_real-id1
    "Limits on the number of queued realtime signals")). This data can be retrieved
    via the *si_value* field of the *siginfo_t* structure that is passed to the signal
    handler or returned by a call to *sigwaitinfo()* or *sigtimedwait()*. The following
    fields in the *siginfo_t* structure are also filled in: *si_code*, with the value
    `SI_MESGQ`; *si_signo*, with the signal number; *si_pid*, with the process ID
    of the process that sent the message; and *si_uid*, with the real user ID of the
    process that sent the message. (The *si_pid* and *si_uid* fields are not set on
    most other implementations.)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过生成在*sigev_signo*字段中指定的信号来通知进程。*sigev_value*字段指定随信号一起传递的数据（[队列中的实时信号数量限制](ch22.html#limits_on_the_number_of_queued_real-id1
    "队列中的实时信号数量限制")）。此数据可以通过传递给信号处理程序的*siginfo_t*结构中的*si_value*字段，或者通过调用*sigwaitinfo()*或*sigtimedwait()*返回的数据进行检索。*siginfo_t*结构中的以下字段也会被填写：*si_code*，值为`SI_MESGQ`；*si_signo*，信号编号；*si_pid*，发送消息的进程的进程ID；*si_uid*，发送消息的进程的真实用户ID。（*si_pid*和*si_uid*字段在大多数其他实现中未设置。）
- en: '`SIGEV_THREAD`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGEV_THREAD`'
- en: Notify the process by calling the function specified in *sigev_notify_function*
    as if it were the start function in a new thread. The *sigev_notify_attributes*
    field can be specified as `NULL` or as a pointer to a *pthread_attr_t* structure
    that defines attributes for the thread ([Thread Attributes](ch29.html#thread_attributes
    "Thread Attributes")). The union *sigval* value specified in *sigev_value* is
    passed as the argument of this function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用在*sigev_notify_function*中指定的函数来通知进程，就像它是新线程中的启动函数一样。*sigev_notify_attributes*字段可以指定为`NULL`，或者作为指向定义线程属性的*pthread_attr_t*结构的指针（[线程属性](ch29.html#thread_attributes
    "线程属性")）。在*sigev_value*中指定的联合*sigval*值将作为此函数的参数传递。
- en: Receiving Notification via a Signal
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过信号接收通知
- en: '[Example 52-6](ch52.html#receiving_message_notification_via_a_sig "Example 52-6. Receiving
    message notification via a signal") provides an example of message notification
    using signals. This program performs the following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例52-6](ch52.html#receiving_message_notification_via_a_sig "示例52-6. 通过信号接收消息通知")提供了使用信号进行消息通知的示例。该程序执行以下步骤：'
- en: Open the message queue named on the command line in nonblocking mode ![](figs/web/U001.png),
    determine the *mq_msgsize* attribute for the queue ![](figs/web/U002.png), and
    allocate a buffer of that size for receiving messages ![](figs/web/U003.png).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以非阻塞模式打开命令行中指定的消息队列 ![](figs/web/U001.png)，确定队列的*mq_msgsize*属性 ![](figs/web/U002.png)，并为接收消息分配该大小的缓冲区
    ![](figs/web/U003.png)。
- en: Block the notification signal (`SIGUSR1`) and establish a handler for it ![](figs/web/U004.png).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阻塞通知信号（`SIGUSR1`）并为其设置处理程序 ![](figs/web/U004.png)。
- en: Make an initial call to *mq_notify()* to register the process to receive message
    notification ![](figs/web/U005.png).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初次调用*mq_notify()*以注册进程接收消息通知 ![](figs/web/U005.png)。
- en: 'Execute an infinite loop that performs the following steps:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个无限循环，执行以下步骤：
- en: Call *sigsuspend()*, which unblocks the notification signal and waits until
    the signal is caught ![](figs/web/U006.png). Return from this system call indicates
    that a message notification has occurred. At this point, the process will have
    been deregistered for message notification.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用*sigsuspend()*，该函数解锁通知信号并等待信号的到来 ![](figs/web/U006.png)。从此系统调用返回表示消息通知已经发生。此时，进程将不再注册消息通知。
- en: Call *mq_notify()* to reregister this process to receive message notification
    ![](figs/web/U007.png).
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用*mq_notify()*重新注册该进程以接收消息通知 ![](figs/web/U007.png)。
- en: Execute a `while` loop that drains the queue by reading as many messages as
    possible ![](figs/web/U008.png).
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`while`循环，读取尽可能多的消息以清空队列 ![](figs/web/U008.png)。
- en: Example 52-6. Receiving message notification via a signal
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 52-6. 通过信号接收消息通知
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Various aspects of the program in [Example 52-6](ch52.html#receiving_message_notification_via_a_sig
    "Example 52-6. Receiving message notification via a signal") merit further comment:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 52-6](ch52.html#receiving_message_notification_via_a_sig "Example
    52-6. Receiving message notification via a signal")中的程序各个方面值得进一步评论：'
- en: We block the notification signal and use *sigsuspend()* to wait for it, rather
    than *pause()*, to prevent the possibility of missing a signal that is delivered
    while the program is executing elsewhere (i.e., is not blocked waiting for signals)
    in the `for` loop. If this occurred, and we were using *pause()* to wait for signals,
    then the next call to *pause()* would block, even though a signal had already
    been delivered.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们阻塞通知信号并使用*sigsuspend()*等待它，而不是使用*pause()*，以防止程序在`for`循环中执行时错过已传递的信号（即，未阻塞等待信号）。如果发生这种情况，并且我们使用*pause()*等待信号，那么下次调用*pause()*时会被阻塞，即使信号已经传递。
- en: We open the queue in nonblocking mode, and, whenever a notification occurs,
    we use a `while` loop to read all messages from the queue. Emptying the queue
    in this way ensures that a further notification is generated when a new message
    arrives. Employing nonblocking mode means that the `while` loop will terminate
    (*mq_receive()* will fail with the error `EAGAIN`) when we have emptied the queue.
    (This approach is analogous to the use of nonblocking I/O with edge-triggered
    I/O notification, which we describe in [Which technique?](ch63.html#which_technique_question-id1
    "Which technique?"), and is employed for similar reasons.)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们以非阻塞模式打开队列，并且每当通知发生时，我们使用`while`循环读取队列中的所有消息。通过这种方式清空队列，确保当新消息到达时会生成进一步的通知。使用非阻塞模式意味着当我们清空队列时，`while`循环将终止（*mq_receive()*会因为错误`EAGAIN`而失败）。这种方法类似于使用带有边缘触发I/O通知的非阻塞I/O，我们在[Which
    technique?](ch63.html#which_technique_question-id1 "Which technique?")中描述了该技术，并且出于类似的原因使用它。
- en: 'Within the `for` loop, it is important that we reregister for message notification
    *before* reading all messages from the queue. If we reversed these steps, the
    following sequence could occur: all messages are read from the queue, and the
    `while` loop terminates; another message is placed on the queue; *mq_notify()*
    is called to reregister for message notification. At this point, no further notification
    signal would be generated, because the queue is already nonempty. Consequently,
    the program would remain permanently blocked in its next call to *sigsuspend()*.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`for`循环中，我们必须在读取队列中的所有消息之前重新注册消息通知，*而不是*在读取后再进行注册。如果我们反转这些步骤，可能会出现以下情况：所有消息都被从队列中读取，`while`循环终止；另一条消息被放入队列；调用*mq_notify()*重新注册消息通知。此时，不会再生成进一步的通知信号，因为队列已经非空。因此，程序会在下一次调用*sigsuspend()*时永久阻塞。
- en: Receiving Notification via a Thread
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过线程接收通知
- en: '[Example 52-7](ch52.html#receiving_message_notification_via_a_thr "Example 52-7. Receiving
    message notification via a thread") provides an example of message notification
    using threads. This program shares a number of design features with the program
    in [Example 52-6](ch52.html#receiving_message_notification_via_a_sig "Example 52-6. Receiving
    message notification via a signal"):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 52-7](ch52.html#receiving_message_notification_via_a_thr "示例 52-7. 通过线程接收消息通知")提供了一个使用线程的消息通知示例。该程序与[示例
    52-6](ch52.html#receiving_message_notification_via_a_sig "示例 52-6. 通过信号接收消息通知")中的程序共享一些设计特点：'
- en: When message notification occurs, the program reenables notification before
    draining the queue ![](figs/web/U002.png).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当消息通知发生时，程序会在清空队列之前重新启用通知 ![](figs/web/U002.png)。
- en: Nonblocking mode is employed so that, after receiving a notification, we can
    completely drain the queue without blocking ![](figs/web/U005.png).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非阻塞模式，以便在接收到通知后，我们能够在不阻塞的情况下完全清空队列 ![](figs/web/U005.png)。
- en: Example 52-7. Receiving message notification via a thread
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 52-7. 通过线程接收消息通知
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note the following further points regarding the design of the program in [Example 52-7](ch52.html#receiving_message_notification_via_a_thr
    "Example 52-7. Receiving message notification via a thread"):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下几点，关于[示例 52-7](ch52.html#receiving_message_notification_via_a_thr "示例 52-7.
    通过线程接收消息通知")中程序的设计：
- en: The program requests notification via a thread, by specifying `SIGEV_THREAD`
    in the *sigev_notify* field of the *sigevent* structure passed to *mq_notify()*.
    The thread’s start function, *threadFunc()*, is specified in the *sigev_notify_function*
    field ![](figs/web/U003.png).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序通过线程请求通知，方法是在传递给*mq_notify()*的*sigevent*结构的*sigev_notify*字段中指定`SIGEV_THREAD`。线程的启动函数*threadFunc()*在*sigev_notify_function*字段中指定
    ![](figs/web/U003.png)。
- en: After enabling message notification, the main program pauses indefinitely ![](figs/web/U006.png);
    timer notifications are delivered by invocations of *threadFunc()* in a separate
    thread ![](figs/web/U001.png).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用消息通知后，主程序会无限期暂停 ![](figs/web/U006.png)；定时器通知通过在单独线程中调用*threadFunc()*进行交付 ![](figs/web/U001.png)。
- en: 'We could have made the message queue descriptor, *mqd*, visible in *threadFunc()*
    by making it a global variable. However, we adopted a different approach to illustrate
    the alternative: we place the address of the message queue descriptor in the *sigev_value.sival_ptr*
    field that is passed to *mq_notify()*![](figs/web/U004.png). When *threadFunc()*
    is later invoked, this address is passed as its argument.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以通过将消息队列描述符*mqd*设为全局变量，使其在*threadFunc()*中可见。然而，我们采用了不同的方式来说明另一种选择：我们将消息队列描述符的地址放入传递给*mq_notify()*的*sigev_value.sival_ptr*字段中！[](figs/web/U004.png)。当稍后调用*threadFunc()*时，这个地址会作为其参数传递。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We must assign a pointer to the message queue descriptor to *sigev_value.sival_ptr*,
    rather than (some cast version of) the descriptor itself because, other than the
    stipulation that it is not an array type, SUSv3 makes no guarantee about the nature
    or size of the type used to represent the *mqd_t* data type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将指针分配给消息队列描述符的*sigev_value.sival_ptr*，而不是（某个类型转换版本的）描述符本身，因为，除了要求它不是数组类型外，SUSv3并未保证用于表示*mqd_t*数据类型的类型的性质或大小。
- en: Linux-Specific Features
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定于Linux的功能
- en: The Linux implementation of POSIX message queues provides a number of features
    that are unstandardized but nevertheless useful.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Linux实现的POSIX消息队列提供了一些未标准化但仍然有用的功能。
- en: Displaying and deleting message queue objects via the command line
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过命令行显示和删除消息队列对象
- en: 'In [Chapter 51](ch51.html "Chapter 51. Introduction to POSIX IPC"), we mentioned
    that POSIX IPC objects are implemented as files in virtual file systems, and that
    these files can be listed and removed with *ls* and *rm*. In order to do this
    with POSIX message queues, we must mount the message queue file system using a
    command of the following form:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第51章](ch51.html "第51章. POSIX IPC简介")中，我们提到POSIX IPC对象作为虚拟文件系统中的文件实现，并且这些文件可以通过*ls*和*rm*列出和删除。为了对POSIX消息队列执行此操作，我们必须使用如下形式的命令来挂载消息队列文件系统：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The *source* can be any name at all (specifying the string *none* is typical).
    Its only significance is that it appears in `/proc/mounts` and is displayed by
    the *mount* and *df* commands. The *target* is the mount point for the message
    queue file system.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*源*可以是任何名称（指定字符串*none*是典型的做法）。它的唯一意义在于，它会出现在`/proc/mounts`中，并且会被*mount*和*df*命令显示出来。*目标*是消息队列文件系统的挂载点。'
- en: 'The following shell session shows how to mount the message queue file system
    and display its contents. We begin by creating a mount point for the file system
    and mounting it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话展示了如何挂载消息队列文件系统并显示其内容。我们首先创建一个挂载点并进行挂载：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we display the record in `/proc/mounts` for the new mount, and then display
    the permissions for the mount directory:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们显示 `/proc/mounts` 中有关新挂载的记录，然后显示挂载目录的权限：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One point to note from the output of the *ls* command is that the message queue
    file system is automatically mounted with the sticky bit set for the mount directory.
    (We see this from the fact that there is a *t* in the other-execute permission
    field displayed by *ls*.) This means that an unprivileged process can unlink only
    message queues that it owns.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *ls* 命令的输出中有一点需要注意，那就是消息队列文件系统会自动挂载，并为挂载目录设置了粘滞位。（我们从 *ls* 显示的其他执行权限字段中的 *t*
    看出这一点。）这意味着，非特权进程只能取消链接它拥有的消息队列。
- en: 'Next, we create a message queue, use *ls* to show that it is visible in the
    file system, and then delete the message queue:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个消息队列，使用*ls*命令查看它在文件系统中的可见性，然后删除该消息队列：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Obtaining information about a message queue
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取有关消息队列的信息
- en: 'We can display the contents of the files in the message queue file system.
    Each of these virtual files contains information about the associated message
    queue:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以显示消息队列文件系统中文件的内容。这些虚拟文件中的每一个都包含与之关联的消息队列信息：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `QSIZE` field is a count of the total number of bytes of data in the queue.
    The remaining fields relate to message notification. If `NOTIFY_PID` is nonzero,
    then the process with the specified process ID has registered for message notification
    from this queue, and the remaining fields provide information about the kind of
    notification:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSIZE` 字段是队列中数据的总字节数。其余字段与消息通知相关。如果 `NOTIFY_PID` 非零，则表示具有指定进程 ID 的进程已经注册了来自该队列的消息通知，其余字段提供有关通知类型的信息：'
- en: '`NOTIFY` is a value corresponding to one of the *sigev_notify* constants: 0
    for `SIGEV_SIGNAL`, 1 for `SIGEV_NONE`, or 2 for `SIGEV_THREAD`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOTIFY` 是一个对应于 *sigev_notify* 常量的值：`SIGEV_SIGNAL` 为 0，`SIGEV_NONE` 为 1，或 `SIGEV_THREAD`
    为 2。'
- en: If the notification method is `SIGEV_SIGNAL`, the `SIGNO` field indicates which
    signal is delivered for message notification.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通知方法是 `SIGEV_SIGNAL`，那么 `SIGNO` 字段表示为消息通知发送的信号。
- en: 'The following shell session illustrates the information that appears in these
    fields:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话展示了这些字段中出现的信息：
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using message queues with alternative I/O models
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用消息队列与替代 I/O 模型
- en: In the Linux implementation, a message queue descriptor is really a file descriptor.
    We can monitor this file descriptor using I/O multiplexing system calls (*select()*
    and *poll()*) or the *epoll* API. (See [Chapter 63](ch63.html "Chapter 63. Alternative
    I/O Models") for further details of these APIs.) This allows us to avoid the difficulty
    that we encounter with System V messages queues when trying to wait for input
    on both a message queue and a file descriptor (refer to [Disadvantages of System
    V Message Queues](ch46.html#disadvantages_of_system_v_message_queues "Disadvantages
    of System V Message Queues")). However, this feature is nonstandard; SUSv3 doesn’t
    require that message queue descriptors are implemented as file descriptors.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 实现中，消息队列描述符实际上是一个文件描述符。我们可以通过 I/O 多路复用系统调用（*select()* 和 *poll()*）或者
    *epoll* API 来监控这个文件描述符。（更多关于这些 API 的细节，请参见[第63章](ch63.html "第63章. 替代 I/O 模型")）这使我们能够避免在尝试等待来自消息队列和文件描述符的输入时，遇到与
    System V 消息队列相关的难题（参见[System V 消息队列的缺点](ch46.html#disadvantages_of_system_v_message_queues
    "System V 消息队列的缺点")）。然而，这个特性是非标准的；SUSv3 并没有要求消息队列描述符必须实现为文件描述符。
- en: Message Queue Limits
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息队列限制
- en: 'SUSv3 defines two limits for POSIX message queues:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 定义了两个 POSIX 消息队列的限制：
- en: '`MQ_PRIO_MAX`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`MQ_PRIO_MAX`'
- en: We described this limit, which defines the maximum priority for a message, in
    [Sending Messages](ch52.html#sending_messages-id1 "Sending Messages").
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[发送消息](ch52.html#sending_messages-id1 "发送消息")中描述了这个限制，它定义了消息的最大优先级。
- en: '`MQ_OPEN_MAX`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`MQ_OPEN_MAX`'
- en: An implementation can define this limit to indicate the maximum number of message
    queues that a process can hold open. SUSv3 requires this limit to be at least
    `_POSIX_MQ_OPEN_MAX` (8). Linux doesn’t define this limit. Instead, because Linux
    implements message queue descriptors as file descriptors ([Linux-Specific Features](ch52.html#linux-specific_features
    "Linux-Specific Features")), the applicable limits are those that apply to file
    descriptors. (In other words, on Linux, the per-process and system-wide limits
    on the number of file descriptors actually apply to the sum of file descriptors
    and message queue descriptors.) For further details on the applicable limits,
    see the discussion of the `RLIMIT_NOFILE` resource limit in Section 36.3.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以定义此限制，以表示进程可以保持打开的消息队列的最大数量。SUSv3要求此限制至少为`_POSIX_MQ_OPEN_MAX`（8）。Linux不定义此限制。相反，因为Linux将消息队列描述符实现为文件描述符（[Linux特定功能](ch52.html#linux-specific_features
    "Linux-Specific Features")），适用的限制是文件描述符的限制。（换句话说，在Linux上，文件描述符和消息队列描述符的数量的每进程和系统范围限制实际上适用于文件描述符和消息队列描述符的总和。）有关适用限制的详细信息，请参见第36.3节中对`RLIMIT_NOFILE`资源限制的讨论。
- en: 'As well as the above SUSv3-specified limits, Linux provides a number of `/proc`
    files for viewing and (with privilege) changing limits that control the use of
    POSIX message queues. The following three files reside in the directory `/proc/sys/fs/mqueue`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述SUSv3指定的限制外，Linux还提供了一些`/proc`文件，用于查看和（在有权限的情况下）更改控制POSIX消息队列使用的限制。以下三个文件位于目录`/proc/sys/fs/mqueue`中：
- en: '`msg_max`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg_max`'
- en: This limit specifies a ceiling for the *mq_maxmsg* attribute of new message
    queues (i.e., a ceiling for *attr.mq_maxmsg* when creating a queue with *mq_open()*).
    The default value for this limit is 10\. The minimum value is 1 (10 in kernels
    before Linux 2.6.28). The maximum value is defined by the kernel constant `HARD_MSGMAX`.
    The value for this constant is calculated as (131,072 / *sizeof(void *)*), which
    evaluates to 32,768 on Linux/x86-32\. When a privileged process (`CAP_SYS_RESOURCE`)
    calls *mq_open()*, the `msg_max` limit is ignored, but `HARD_MSGMAX` still acts
    as a ceiling for *attr.mq_maxmsg*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此限制指定了新消息队列的*mq_maxmsg*属性的上限（即在使用*mq_open()*创建队列时，*attr.mq_maxmsg*的上限）。该限制的默认值为10。最小值为1（在Linux
    2.6.28之前的内核中为10）。最大值由内核常量`HARD_MSGMAX`定义。该常量的值计算为（131,072 / *sizeof(void *)*），在Linux/x86-32上计算为32,768。当特权进程（`CAP_SYS_RESOURCE`）调用*mq_open()*时，`msg_max`限制会被忽略，但`HARD_MSGMAX`仍然作为*attr.mq_maxmsg*的上限。
- en: '`msgsize_max`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`msgsize_max`'
- en: This limit specifies a ceiling for the *mq_msgsize* attribute of new message
    queues created by unprivileged processes (i.e., a ceiling for *attr.mq_msgsize*
    when creating a queue with *mq_open()*). The default value for this limit is 8192\.
    The minimum value is 128 (8192 in kernels before Linux 2.6.28). The maximum value
    is 1,048,576 (`INT_MAX` in kernels before 2.6.28). This limit is ignored when
    a privileged process (`CAP_SYS_RESOURCE`) calls *mq_open()*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此限制指定了未特权进程创建的新消息队列的*mq_msgsize*属性的上限（即在使用*mq_open()*创建队列时，*attr.mq_msgsize*的上限）。该限制的默认值为8192。最小值为128（在Linux
    2.6.28之前的内核中为8192）。最大值为1,048,576（在Linux 2.6.28之前的内核中为`INT_MAX`）。当特权进程（`CAP_SYS_RESOURCE`）调用*mq_open()*时，此限制将被忽略。
- en: '`queues_max`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`queues_max`'
- en: This is a system-wide limit on the number of message queues that may be created.
    Once this limit is reached, only a privileged process (`CAP_SYS_RESOURCE`) can
    create new queues. The default value for this limit is 256\. It can be changed
    to any value in the range 0 to `INT_MAX`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个系统范围的限制，指定可以创建的消息队列的最大数量。一旦达到此限制，只有特权进程（`CAP_SYS_RESOURCE`）可以创建新的队列。该限制的默认值为256。可以将其更改为0到`INT_MAX`范围内的任何值。
- en: Linux also provides the `RLIMIT_MSGQUEUE` resource limit, which can be used
    to place a ceiling on the amount of space that can be consumed by all of the message
    queues belonging to the real user ID of the calling process. See [Details of Specific
    Resource Limits](ch36.html#details_of_specific_resource_limits "Details of Specific
    Resource Limits") for details.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Linux还提供了`RLIMIT_MSGQUEUE`资源限制，可以用于为调用进程的真实用户ID所属的所有消息队列所占用的空间设置上限。有关详细信息，请参见[特定资源限制的详细信息](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")。
- en: Comparison of POSIX and System V Message Queues
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX与System V消息队列的比较
- en: '[Comparison of System V IPC and POSIX IPC](ch51.html#comparison_of_system_v_ipc_and_posix_ipc
    "Comparison of System V IPC and POSIX IPC") listed various advantages of the POSIX
    IPC interface over the System V IPC interface: the POSIX IPC interface is simpler
    and more consistent with the traditional UNIX file model, and POSIX IPC objects
    are reference counted, which simplifies the task of determining when to delete
    an object. These general advantages also apply to POSIX message queues.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[System V IPC 和 POSIX IPC 比较](ch51.html#comparison_of_system_v_ipc_and_posix_ipc
    "System V IPC 和 POSIX IPC 比较") 列出了 POSIX IPC 接口相对于 System V IPC 接口的各种优点：POSIX
    IPC 接口更简洁，并且与传统的 UNIX 文件模型更一致，且 POSIX IPC 对象是引用计数的，这简化了确定何时删除对象的任务。这些一般的优点也适用于
    POSIX 消息队列。'
- en: 'POSIX message queues also have the following specific advantages over System
    V message queues:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 消息队列相比于 System V 消息队列也有以下具体优点：
- en: The message notification feature allows a (single) process to be asynchronously
    notified via a signal or the instantiation of a thread when a message arrives
    on a previously empty queue.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息通知功能允许（单个）进程在消息到达先前为空的队列时，通过信号或线程实例化异步通知。
- en: On Linux (but not other UNIX implementations), POSIX message queues can be monitored
    using *poll()*, *select()*, and *epoll*. System V message queues don’t provide
    this feature.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux（但不是其他 UNIX 实现）上，可以使用 *poll()*、*select()* 和 *epoll()* 来监视 POSIX 消息队列。System
    V 消息队列不提供此功能。
- en: 'However, POSIX message queues also have some disadvantages compared to System
    V message queues:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，POSIX 消息队列相比于 System V 消息队列也有一些缺点：
- en: POSIX message queues are less portable. This problem applies even across Linux
    systems, since message queue support is available only since kernel 2.6.6.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 消息队列的可移植性较差。这个问题甚至在 Linux 系统之间也存在，因为只有自内核 2.6.6 版本开始才提供消息队列支持。
- en: The facility to select System V messages by type provides slightly greater flexibility
    than the strict priority ordering of POSIX messages.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过类型选择 System V 消息的功能，提供了比 POSIX 消息的严格优先级排序更大的灵活性。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a wide variation in the manner in which POSIX message queues are implemented
    on UNIX systems. Some systems provide implementations in user space, and on at
    least one such implementation (Solaris 10), the *mq_open()* manual page explicitly
    notes that the implementation can’t be considered secure. On Linux, one of the
    motives for selecting a kernel implementation of message queues was that it was
    not deemed possible to provide a secure user-space implementation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 消息队列在 UNIX 系统上的实现方式差异较大。有些系统提供用户空间的实现，且在至少一个这样的实现（Solaris 10）中，*mq_open()*
    手册页面明确指出，该实现不能被认为是安全的。在 Linux 上，选择内核实现消息队列的动机之一是因为认为无法提供一个安全的用户空间实现。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: POSIX message queues allow processes to exchange data in the form of messages.
    Each message has an associated integer priority, and messages are queued (and
    thus received) in order of priority.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 消息队列允许进程以消息的形式交换数据。每条消息都有一个关联的整数优先级，消息按优先级顺序排队（因此也按顺序接收）。
- en: POSIX message queues have some advantages over System V message queues, notably
    that they are reference counted and that a process can be asynchronously notified
    of the arrival of a message on an empty queue. However, POSIX message queues are
    less portable than System V message queues.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 消息队列相比于 System V 消息队列有一些优点，尤其是它们是引用计数的，并且进程可以异步通知消息到达空队列。然而，POSIX 消息队列比
    System V 消息队列的可移植性差。
- en: Further information
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: '[Stevens, 1999] provides an alternative presentation of POSIX message queues
    and shows a user-space implementation using memory-mapped files. POSIX message
    queues are also described in some detail in [Gallmeister, 1995].'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[Stevens, 1999] 提供了一个 POSIX 消息队列的替代展示，并展示了使用内存映射文件的用户空间实现。POSIX 消息队列也在 [Gallmeister,
    1995] 中进行了详细描述。'
- en: Exercises
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Modify the program in [Example 52-5](ch52.html#reading_a_message_from_a_posix_message_q
    "Example 52-5. Reading a message from a POSIX message queue") (`pmsg_receive.c`)
    to accept a timeout (a relative number of seconds) on the command line, and use
    *mq_timedreceive()* instead of *mq_receive()*.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 [示例 52-5](ch52.html#reading_a_message_from_a_posix_message_q "示例 52-5. 从
    POSIX 消息队列读取消息") (`pmsg_receive.c`) 程序，使其接受一个超时（相对秒数）作为命令行参数，并使用 *mq_timedreceive()*
    代替 *mq_receive()*。
- en: Recode the sequence-number client-server application of [A Client-Server Application
    Using FIFOs](ch44.html#a_client-server_application_using_fifos "A Client-Server
    Application Using FIFOs") to use POSIX message queues.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将[A Client-Server Application Using FIFOs](ch44.html#a_client-server_application_using_fifos
    "使用FIFOs的客户端-服务器应用程序")中的序列号客户端-服务器应用程序重新编码，改用POSIX消息队列。
- en: Rewrite the file-server application of [A File-Server Application Using Message
    Queues](ch46.html#a_file-server_application_using_message "A File-Server Application
    Using Message Queues") to use POSIX message queues instead of System V message
    queues.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写[A File-Server Application Using Message Queues](ch46.html#a_file-server_application_using_message
    "使用消息队列的文件服务器应用程序")中的文件服务器应用程序，改用POSIX消息队列替代System V消息队列。
- en: Write a simple chat program (similar to *talk(1)*, but without the *curses*
    interface) using POSIX messages queues.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个简单的聊天程序（类似于*talk(1)*，但没有*curses*界面），使用POSIX消息队列。
- en: Modify the program in [Example 52-6](ch52.html#receiving_message_notification_via_a_sig
    "Example 52-6. Receiving message notification via a signal") (`mq_notify_sig.c`)
    to demonstrate that message notification established by *mq_notify()* occurs just
    once. This can be done by removing the *mq_notify()* call inside the `for` loop.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例 52-6](ch52.html#receiving_message_notification_via_a_sig "示例 52-6. 通过信号接收消息通知")中的程序（`mq_notify_sig.c`），以演示由*mq_notify()*建立的消息通知仅发生一次。可以通过删除`for`循环中的*mq_notify()*调用来实现。
- en: Replace the use of a signal handler in [Example 52-6](ch52.html#receiving_message_notification_via_a_sig
    "Example 52-6. Receiving message notification via a signal") (`mq_notify_sig.c`)
    with the use of *sigwaitinfo()*. Upon return from *sigwaitinfo()*, display the
    values in the returned *siginfo_t* structure. How could the program obtain the
    message queue descriptor in the *siginfo_t* structure returned by *sigwaitinfo()*?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换[示例 52-6](ch52.html#receiving_message_notification_via_a_sig "示例 52-6. 通过信号接收消息通知")中的信号处理程序（`mq_notify_sig.c`）为使用*sigwaitinfo()*。从*sigwaitinfo()*返回后，显示返回的*siginfo_t*结构中的值。程序如何在*sigwaitinfo()*返回的*siginfo_t*结构中获取消息队列描述符？
- en: In [Example 52-7](ch52.html#receiving_message_notification_via_a_thr "Example 52-7. Receiving
    message notification via a thread"), could *buffer* be made a global variable
    and its memory allocated just once (in the main program)? Explain your answer.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[示例 52-7](ch52.html#receiving_message_notification_via_a_thr "示例 52-7. 通过线程接收消息通知")中，*buffer*能否作为全局变量，只在主程序中分配一次内存？请解释你的答案。
