- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: NUMERIC REPRESENTATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数字表示**
- en: '![Image](../images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/comm1.jpg)'
- en: High-level languages shield programmers from the pain of dealing with low-level
    numeric representation. Writing great code, however, requires that you understand
    how computers represent numbers, so that is the focus of this chapter. Once you
    understand internal numeric representation, you’ll discover efficient ways to
    implement many algorithms and avoid the pitfalls associated with common programming
    practices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言屏蔽了程序员处理底层数字表示的痛苦。然而，编写优秀的代码需要理解计算机是如何表示数字的，所以本章的重点就是这个。一旦你理解了内部数字表示，你会发现许多算法的高效实现方法，并避免常见编程实践中可能出现的陷阱。
- en: '**2.1 What Is a Number?**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.1 什么是数字？**'
- en: Having taught assembly language programming for many years, I’ve discovered
    that most people don’t understand the fundamental difference between a number
    and the representation of that number. Most of the time, this confusion is harmless.
    However, many algorithms depend on the internal and external representations we
    use for numbers to operate correctly and efficiently. If you don’t understand
    the difference between the abstract concept of a number and the representation
    of that number, you’ll have trouble understanding, using, or creating such algorithms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在教授汇编语言编程多年后，我发现大多数人并不理解数字与数字表示之间的根本区别。大多数情况下，这种混淆是无害的。然而，许多算法依赖于我们用来操作数字的内部和外部表示，以确保其正确高效地运行。如果你不理解数字的抽象概念和该数字的表示之间的区别，你将很难理解、使用或创建这样的算法。
- en: A *[number](gloss01.xhtml#gloss01_176)* is an intangible, abstract concept.
    It is an intellectual device that we use to denote quantity. Let’s say I told
    you that a book has one hundred pages. You could touch the pages—they are tangible.
    You could even count those pages to verify that there are one hundred of them.
    However, “one hundred” is simply an abstraction I’m applying to the book as a
    way of describing its size.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*[数字](gloss01.xhtml#gloss01_176)*是一个无形的、抽象的概念。它是我们用来表示数量的智力工具。假设我告诉你一本书有一百页。你可以触摸这些页面——它们是有形的。你甚至可以数一数这些页面，以验证它们是否有一百页。然而，“一百”只是我应用于这本书的一个抽象概念，用来描述它的大小。
- en: 'The important thing to realize is that the following is *not* one hundred:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 需要认识到的重要一点是，下面的*并不是*一百：
- en: '100'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '100'
- en: 'This is nothing more than ink on paper forming certain lines and curves (called
    *[glyphs](gloss01.xhtml#gloss01_104)*). You might recognize this sequence of symbols
    as a representation of one hundred, but this is not the actual value 100\. It’s
    just three symbols on this page. It isn’t even the only representation for one
    hundred—consider the following, which are all different representations of the
    value 100:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这不过是纸上墨水形成的一些特定线条和曲线（称为*[字形](gloss01.xhtml#gloss01_104)*）。你可能会把这组符号认作一百的表示，但这并不是实际的100值。它只是页面上的三个符号。它甚至不是一百的唯一表示——考虑以下这些，它们都是100值的不同表示：
- en: '| 100 | Decimal representation |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 十进制表示 |'
- en: '| C | Roman numeral representation |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| C | 罗马数字表示 |'
- en: '| 64[16] | Base-16 (hexadecimal) representation |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 64[16] | 十六进制（基16）表示 |'
- en: '| 1100100[2] | Base-2 (binary) representation |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 1100100[2] | 二进制（基2）表示 |'
- en: '| 144[8] | Base-8 (octal) representation |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 144[8] | 八进制（基8）表示 |'
- en: '| one hundred | English representation |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 一百 | 英文表示 |'
- en: 'The representation of a number is (generally) some sequence of symbols. For
    example, the common representation of the value one hundred, “100,” is really
    a sequence of three numeric digits: the digit 1 followed by the digit 0 followed
    by a second 0 digit. Each of these digits has some specific meaning, but we could
    have just as easily used the sequence “64” to represent one hundred. Even the
    individual digits that make up this representation of 100 are not numbers. They
    are numeric digits, tools we use to represent numbers, but they are not numbers
    themselves.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字的表示（通常）是一些符号的序列。例如，数字一百的常见表示“100”，实际上是由三个数字组成的序列：数字1后跟数字0，再后跟第二个数字0。每个数字都有其特定的意义，但我们本可以用“64”这个序列来表示一百。即使是组成这个100表示的单个数字也不是数字。它们是数字符号，是我们用来表示数字的工具，但它们本身不是数字。
- en: Now you might be wondering why you should even care whether a sequence of symbols
    like “100” is the actual value one hundred or just the representation of it. The
    reason is that you’ll encounter several different sequences of symbols in a computer
    program that look like numbers (that is, they look like “100”), and you don’t
    want to confuse them with actual numeric values. Conversely, there are many different
    representations for the value one hundred that a computer could use, and it’s
    important for you to realize that they are equivalent.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会想，为什么你应该关心像“100”这样的符号序列是实际的数字一百，还是仅仅是它的表示。原因是你在计算机程序中会遇到几种看起来像数字（也就是说，它们看起来像“100”）的符号序列，而你不想将它们与实际的数值混淆。相反，计算机可能使用许多不同的表示方式来表示数字一百，重要的是你要意识到它们是等效的。
- en: '**2.2 Numbering Systems**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.2 数字系统**'
- en: A *[numbering system](gloss01.xhtml#gloss01_177)* is a mechanism we use to represent
    numeric values. Today, most people use the *decimal* (or *base-10*) numbering
    system, and most computer systems use the *binary* (or *base-2*) numbering system.
    Confusion between the two can lead to poor coding practices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*[数字系统](gloss01.xhtml#gloss01_177)*是一种我们用来表示数值的机制。今天，大多数人使用*十进制*（或*基数10*）数字系统，大多数计算机系统使用*二进制*（或*基数2*）数字系统。两者之间的混淆可能会导致不良的编码习惯。'
- en: The Arabs developed the decimal numbering system we commonly use today (this
    is why the 10 decimal digits are known as *[Arabic numerals](gloss01.xhtml#gloss01_13)*).
    The decimal system uses *[positional notation](gloss01.xhtml#gloss01_197)* to
    represent values with a small group of different symbols. Positional notation
    gives meaning not only to the symbol itself, but also to the position of the symbol
    in the sequence of symbols—a scheme that is far superior to other, nonpositional,
    representations. To appreciate the difference between a positional system and
    a nonpositional system, consider the *tally-slash* representation of the number
    25 in [Figure 2-1](ch02.xhtml#ch02fig01).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 阿拉伯人发明了我们今天常用的十进制数字系统（这就是为什么10个十进制数字被称为*【阿拉伯数字】(gloss01.xhtml#gloss01_13)*）。十进制系统使用*【位置记数法】(gloss01.xhtml#gloss01_197)*来用一小组不同的符号表示值。位置记数法不仅赋予符号本身意义，还赋予符号在符号序列中的位置意义——这一方案远优于其他非位置表示法。为了理解位置系统和非位置系统之间的区别，可以参考[图
    2-1](ch02.xhtml#ch02fig01)中的*记数划线*表示法，表示数字25。
- en: '![image](../images/02fig01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig01.jpg)'
- en: '*Figure 2-1: Tally-slash representation of 25*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：记数划线表示法的25*'
- en: The tally-slash representation uses a sequence of *n* marks to represent the
    value *n*. To make the values easier to read, most people arrange the tally marks
    in groups of five, as in [Figure 2-1](ch02.xhtml#ch02fig01). The advantage of
    the tally-slash numbering system is that it’s easy to use for counting objects.
    However, the notation is bulky, and arithmetic operations are difficult. The biggest
    problem with the tally-slash representation is the amount of physical space it
    consumes. To represent the value *n* requires an amount of space proportional
    to *n*. Therefore, for large values of *n*, this notation becomes unusable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 记数划线表示法使用一系列*n*个符号来表示值*n*。为了让数值更易于阅读，大多数人将记数符号按五个一组排列，如[图 2-1](ch02.xhtml#ch02fig01)所示。记数划线数字系统的优点在于它对于计数物体非常方便。然而，这种符号表示方法体积庞大，且进行算术运算时很困难。记数划线表示法的最大问题是它占用的物理空间。表示值*n*需要的空间与*n*成正比。因此，对于较大的*n*值，这种表示法就变得不可使用了。
- en: '***2.2.1 The Decimal Positional Numbering System***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.2.1 十进制位置数字系统***'
- en: 'The decimal positional numbering system represents numbers using strings of
    Arabic numerals, optionally including a decimal point to separate whole and fractional
    portions of the number representation. The position of a digit in the string affects
    its meaning: each digit to the left of the decimal point represents a value between
    0 and 9, multiplied by an increasing power of 10 (see [Figure 2-2](ch02.xhtml#ch02fig02)).
    The symbol immediately to the left of the decimal point in the sequence represents
    a value between 0 and 9\. If there are at least two digits, the second symbol
    to the left of the decimal point represents a value between 0 and 9 times 10,
    and so forth. To the right of the decimal point, the values decrease.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制位置数制使用阿拉伯数字的字符串表示数字，通常包括一个小数点，用于分隔数字的整数部分和小数部分。数字在字符串中的位置影响其含义：小数点左边的每个数字表示一个
    0 到 9 之间的值，并乘以递增的 10 的幂（见 [图 2-2](ch02.xhtml#ch02fig02)）。序列中小数点左边紧邻的符号表示 0 到 9
    之间的值。如果有至少两个数字，小数点左边第二个符号表示 0 到 9 乘以 10 的值，依此类推。小数点右边的值则逐渐减小。
- en: '![image](../images/02fig02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig02.jpg)'
- en: '*Figure 2-2: A positional numbering system*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：位置数制*'
- en: 'The numeric sequence 123.45 represents:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数字序列 123.45 表示：
- en: (1 × 10²) + (2 × 10¹) + (3 × 10⁰) + (4 × 10^(–1)) + (5 × 10^(–2))
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: （1 × 10²）+（2 × 10¹）+（3 × 10⁰）+（4 × 10^(–1)）+（5 × 10^(–2)）
- en: 'or:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: 100 + 20 + 3 + 0.4 + 0.05
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 100 + 20 + 3 + 0.4 + 0.05
- en: 'To understand the power of the base-10 positional numbering system, consider
    that, compared to the tally-slash system:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解十进制位置数制的强大功能，可以考虑与记数划线系统相比：
- en: It can represent the value 10 in one-third the space.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在三分之一的空间内表示值 10。
- en: It can represent the value 100 in about 3 percent of the space.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在大约 3% 的空间内表示值 100。
- en: It can represent the value 1,000 in about 0.3 percent of the space.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在大约 0.3% 的空间内表示值 1,000。
- en: As the numbers grow larger, the disparity becomes even greater. Because of their
    compact and easy-to-recognize notation, positional numbering systems are quite
    popular.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数字变大，差距会变得更加显著。由于其紧凑且易于识别的符号，位置数制非常流行。
- en: '***2.2.2 Radix (Base) Values***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.2.2 基数（进制）值***'
- en: Humans developed the decimal numbering system because it corresponds to the
    number of fingers (“digits”) on their hands. However, decimal isn’t the only positional
    numbering system possible; in fact, for most computer-based applications, it isn’t
    even the best numbering system available. So, let’s take a look at how to represent
    values in other numbering systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 人类发展了十进制数制，因为它与他们手上的手指（“数字”）数量相对应。然而，十进制并不是唯一可能的进制数制；事实上，对于大多数基于计算机的应用，十进制甚至不是最佳的数制。所以，让我们来看看如何在其他数制中表示数值。
- en: The decimal positional numbering system uses powers of 10 and 10 unique symbols
    for each digit position. Because decimal numbers use powers of 10, we call them
    “base-10” numbers. By substituting a different set of numeric digits and multiplying
    those digits by powers of some base other than 10, we can devise a different numbering
    system. The base, or *[radix](gloss01.xhtml#gloss01_207)*, is the value that we
    raise to successive powers for each digit to the left of the *[radix point](gloss01.xhtml#gloss01_208)*
    (note that the term *decimal point* applies only to decimal numbers).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制位置数制使用 10 的幂和 10 个独特的符号表示每个数字位置。由于十进制数使用 10 的幂，我们称它们为“十进制”数字。通过替换一组不同的数字符号，并将这些符号乘以某个除
    10 以外的基数的幂，我们可以设计出另一种数制。基数，或 *[基数](gloss01.xhtml#gloss01_207)*，是我们为每个小数点左边的数字位置提高到递增幂的值（注意，*十进制点*仅适用于十进制数字）。
- en: 'As an example, we can create a base-8 (*octal*) numbering system using eight
    symbols (0–7) and successive powers of 8\. Consider the octal number 123[8] (the
    subscript denotes the base using standard mathematical notation), which is equivalent
    to 83[10]:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用八个符号（0-7）和连续的 8 的幂，创建一个基数为 8（*八进制*）的数制。考虑八进制数 123[8]（下标表示进制，采用标准数学符号），其等价于十进制数
    83[10]：
- en: 1 × 8² + 2 × 8¹ + 3 × 8⁰
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 1 × 8² + 2 × 8¹ + 3 × 8⁰
- en: 'or:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: 64 + 16 + 3
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 64 + 16 + 3
- en: To create a base-*n* numbering system, you need *n* unique digits. The smallest
    possible radix is 2 (for this scheme). For bases 2 through 10, the convention
    is to use the Arabic digits 0 through *n* – 1 (for a base-*n* system). For bases
    greater than 10, the convention is to use the alphabetic digits *a* through *z*
    or *A* through *Z* (ignoring case) for digits greater than 9\. This scheme supports
    numbering systems through base 36 (10 numeric digits and 26 alphabetic digits).
    There’s no agreed-upon convention for symbols beyond the 10 Arabic numeric digits
    and the 26 alphabetic digits. Throughout this book, we’ll deal with base-2, base-8,
    and base-16 values because base 2 (binary) is the native representation most computers
    use, base 8 was popular on older computer systems, and base 16 is more compact
    than base 2\. You’ll find that many programs use these three bases, so it’s important
    to be familiar with them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个基数为 *n* 的数字系统，你需要 *n* 个唯一的数字。最小的进制是2（对于这种方案）。对于2到10之间的进制，约定使用阿拉伯数字0到 *n*
    - 1（对于基数为 *n* 的系统）。对于大于10的进制，约定使用字母数字 *a* 到 *z* 或 *A* 到 *Z*（忽略大小写）表示大于9的数字。该方案支持从基数2到36的数字系统（10个数字字符和26个字母字符）。对于大于10的阿拉伯数字和26个字母字符之外的符号，目前没有统一的约定。在本书中，我们将处理基数为2、基数为8和基数为16的值，因为基数2（二进制）是大多数计算机使用的原生表示，基数8曾在旧计算机系统中流行，而基数16比基数2更紧凑。你会发现许多程序使用这三种进制，因此了解它们非常重要。
- en: '***2.2.3 The Binary Numbering System***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.2.3 二进制数字系统***'
- en: Since you’re reading this book, chances are pretty good that you’re already
    familiar with the base-2, or binary, numbering system; nevertheless, a quick review
    is in order. The binary numbering system works just like the decimal numbering
    system, except binary uses only the digits 0 and 1 (rather than 0–9) and uses
    powers of 2 (rather than powers of 10).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你在读这本书，那么很可能你已经熟悉了基数为2的二进制数字系统；不过，快速回顾一下也是有必要的。二进制数字系统的工作原理与十进制数字系统相似，只是二进制只使用0和1（而不是0到9），并且使用2的幂（而不是10的幂）。
- en: Why even worry about binary? After all, almost every computer language available
    allows programmers to use decimal notation (automatically converting decimal representation
    to the internal binary representation). Despite this capability, most modern computer
    systems talk to I/O devices using binary, and their arithmetic circuitry operates
    on binary data. Many algorithms depend upon binary representation for correct
    operation. In order to write great code, then, you’ll need a complete understanding
    of binary representation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要担心二进制呢？毕竟，几乎所有的计算机语言都允许程序员使用十进制表示法（自动将十进制表示转换为内部的二进制表示）。尽管有这个功能，但大多数现代计算机系统在与I/O设备通信时使用二进制，且它们的算术电路处理的是二进制数据。许多算法依赖于二进制表示来确保正确运行。因此，为了编写优秀的代码，你需要完全理解二进制表示法。
- en: '**2.2.3.1 Converting Between Decimal and Binary Representation**'
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**2.2.3.1 十进制与二进制之间的转换**'
- en: To appreciate what the computer does for you, it’s useful to learn how to convert
    between decimal and binary representations manually.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解计算机为你做了什么，学习如何手动将十进制和二进制表示法进行转换是很有用的。
- en: 'To convert a binary value to decimal, add 2^(*i*) for each 1 in the binary
    string, where *i* is the zero-based position of the binary digit. For example,
    the binary value 11001010[2] represents:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要将二进制值转换为十进制，需将2^(*i*)加到每个二进制字符串中为1的位置，其中 *i* 是二进制位的零基位置。例如，二进制值11001010[2]表示：
- en: 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 0 × 2⁴ + 1 × 2³ + 0 × 2² + 1 × 2¹ + 0 × 2⁰
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 0 × 2⁴ + 1 × 2³ + 0 × 2² + 1 × 2¹ + 0 × 2⁰
- en: 'or:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: 128 + 64 + 8 + 2
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 128 + 64 + 8 + 2
- en: 'or:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: 202[10]
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 202[10]
- en: 'Converting decimal to binary is almost as easy. Here’s an algorithm that converts
    decimal representation to the corresponding binary representation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将十进制转换为二进制几乎一样简单。这里有一个算法可以将十进制表示转换为对应的二进制表示：
- en: If the number is even, emit a 0\. If the number is odd, emit a 1.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字是偶数，则输出0。如果数字是奇数，则输出1。
- en: Divide the number by 2 and discard any fractional component or remainder.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字除以2，丢弃任何小数部分或余数。
- en: If the quotient is 0, the algorithm is complete.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果商为0，算法完成。
- en: If the quotient is not 0 and the number is odd, insert a 1 before the current
    string. If the quotient is not 0 and the number is even, prefix your binary string
    with 0.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果商不为0且数字为奇数，则在当前字符串前插入1。如果商不为0且数字为偶数，则在二进制字符串前加上0。
- en: Go back to step 2 and repeat.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回步骤2并重复。
- en: 'This example converts 202 to binary:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将202转换为二进制：
- en: '202 is even, so emit a 0 and divide by 2 (101): 0'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 202是偶数，因此输出0并除以2（101）：0
- en: '101 is odd, so emit a 1 and divide by 2 (50): 10'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 101是奇数，因此输出1并除以2（50）：10
- en: '50 is even, so emit a 0 and divide by 2 (25): 010'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 50是偶数，因此输出0并除以2（25）：010
- en: '25 is odd, so emit a 1 and divide by 2 (12): 1010'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 25是奇数，因此输出1并除以2（12）：1010
- en: '12 is even, so emit a 0 and divide by 2 (6): 01010'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 12是偶数，因此输出0并除以2（6）：01010
- en: '6 is even, so emit a 0 and divide by 2 (3): 001010'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6是偶数，因此输出0并除以2（3）：001010
- en: '3 is odd, so emit a 1 and divide by 2 (1): 1001010'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3是奇数，因此输出1并除以2（1）：1001010
- en: '1 is odd, so emit a 2 and divide by 2 (0): 11001010'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1是奇数，因此输出2并除以2（0）：11001010
- en: The result is 0, so the algorithm is complete, producing 11001010.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果是0，因此算法完成，得出11001010。
- en: '**2.2.3.2 Making Binary Numbers Easier to Read**'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**2.2.3.2 使二进制数字更易读**'
- en: As you can tell by the equivalent representations 202[10] and 11001010[2], binary
    representation is not as compact as decimal representation. We need some way to
    make the digits, or *[bits](gloss01.xhtml#gloss01_31)*, in binary numbers less
    bulky and easier to read.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从等价表示202[10]和11001010[2]中可以看出，二进制表示法不如十进制表示法紧凑。我们需要找到一种方法，让二进制数字中的每一位，或*([位](gloss01.xhtml#gloss01_31))，更加简洁并易于阅读。
- en: In the United States, most people separate every three digits with a comma to
    make larger numbers easier to read. For example, 1,023,435,208 is much easier
    to read and comprehend than 1023435208\. This book will adopt a similar convention
    for binary numbers; each group of 4 binary bits will be separated with an underscore.
    For example, the binary value 1010111110110010[2] will be written as 1010_1111_1011_0010[2].
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国，大多数人会用逗号将每三位数字分开，以便更容易阅读较大的数字。例如，1,023,435,208比1023435208更容易阅读和理解。本书将采用类似的约定来表示二进制数字；每4个位的二进制数会用下划线分开。例如，二进制值1010111110110010[2]将写作1010_1111_1011_0010[2]。
- en: '**2.2.3.3 Representing Binary Values in Programming Languages**'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**2.2.3.3 在编程语言中表示二进制值**'
- en: Thus far, this chapter has used the subscript notation embraced by mathematicians
    to denote binary values (the lack of a subscript indicates the decimal base).
    Subscripts are not generally recognized by program text editors or programming
    language compilers, however, so we need some other way to represent various bases
    within a standard ASCII text file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经使用了数学家采用的下标符号来表示二进制值（缺少下标表示十进制）。然而，下标符号通常不被程序文本编辑器或编程语言编译器识别，因此我们需要一些其他方法来在标准的ASCII文本文件中表示不同的进制。
- en: Generally, only assembly language compilers (“assemblers”) allow the use of
    literal binary constants in a program.^([1](footnotes.xhtml#fn2_1a)) Because assemblers
    vary widely, there are many different ways to represent binary literal constants
    in an assembly language program. This book presents examples using MASM and HLA,
    so it makes sense to adopt their conventions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，只有汇编语言编译器（“汇编器”）允许在程序中使用字面二进制常量。^([1](footnotes.xhtml#fn2_1a)) 由于汇编器的种类繁多，在汇编语言程序中表示字面二进制常量的方式也各不相同。本书使用MASM和HLA作为示例，因此采用它们的表示约定是有意义的。
- en: MASM represents binary values as a sequence of binary digits (`0` and `1`) ending
    with a `b` or `B`. The binary representation for 9 would be `1001b` in a MASM
    source file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: MASM将二进制值表示为一串二进制数字（`0`和`1`），并以`b`或`B`结尾。在MASM源文件中，9的二进制表示为`1001b`。
- en: 'HLA prefixes binary values with the percent symbol (`%`). To make binary numbers
    more readable, HLA also allows you to insert underscores within binary strings
    like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: HLA使用百分号符号（`%`）作为二进制值的前缀。为了使二进制数字更易读，HLA还允许在二进制字符串中插入下划线，像这样：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***2.2.4 The Hexadecimal Numbering System***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.2.4 十六进制数制***'
- en: 'As noted earlier, binary number representation is verbose. Hexadecimal representation
    offers two great features: it’s very compact, and it’s easy to convert between
    binary and hexadecimal. Therefore, software engineers generally use hexadecimal
    representation rather than binary to make their programs more readable.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，二进制数字表示方式较为冗长。十六进制表示法具有两个重要优点：它非常紧凑，并且在二进制和十六进制之间转换很容易。因此，软件工程师通常使用十六进制表示法而不是二进制，以使程序更具可读性。
- en: 'Because hexadecimal representation is base 16, each digit to the left of the
    hexadecimal point represents some value times a successive power of 16\. For example,
    the number 1234[16] is equal to:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于十六进制表示法是以16为基数的，每一位数字左边的十六进制点代表某个值乘以16的连续幂。例如，数字1234[16]等于：
- en: 1 × 16³ + 2 × 16² + 3 × 16¹ + 4 × 16⁰
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 1 × 16³ + 2 × 16² + 3 × 16¹ + 4 × 16⁰
- en: 'or:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: 4096 + 512 + 48 + 4
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 4096 + 512 + 48 + 4
- en: 'or:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: 4660[10]
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 4660[10]
- en: 'Hexadecimal representation uses the letters *A* through *F* for the additional
    six digits it requires (above the 10 standard decimal digits, 0–9). The following
    are all examples of valid hexadecimal numbers:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制表示法使用字母*A*到*F*表示它所需的额外六个数字（超过10个标准十进制数字，0–9）。以下是所有有效十六进制数字的示例：
- en: 234[16]   DEAD[16]   BEEF[16]   0AFB[16]   FEED[16]   DEAF[16]
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 234[16]   DEAD[16]   BEEF[16]   0AFB[16]   FEED[16]   DEAF[16]
- en: '**2.2.4.1 Representing Hexadecimal Values in Programming Languages**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**2.2.4.1 在编程语言中表示十六进制值**'
- en: 'One problem with hexadecimal representation is that it’s difficult to differentiate
    hexadecimal values like “DEAD” from standard program identifiers. Therefore, most
    programming languages use a special prefix or suffix character to denote hexadecimal
    values. Here’s how you specify literal hexadecimal constants in several popular
    languages:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制表示法的一个问题是很难区分像“DEAD”这样的十六进制值与标准程序标识符。因此，大多数编程语言使用特殊的前缀或后缀字符来表示十六进制值。以下是几种流行语言中如何指定字面十六进制常量：
- en: The C, C++, C#, Java, Swift, and other C-derivative programming languages use
    the prefix `0x`. You’d use the character sequence `0xdead` for the hexadecimal
    value DEAD[16].
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C、C++、C#、Java、Swift及其他C派生编程语言使用前缀`0x`。你可以使用字符序列`0xdead`来表示十六进制值DEAD[16]。
- en: The MASM assembler uses an `h` or `H` suffix. Because this doesn’t completely
    resolve the ambiguity between certain identifiers and literal hexadecimal constants
    (for example, “deadh” still looks like an identifier to MASM), it also requires
    that a hexadecimal value begin with a numeric digit. So, you would add `0` to
    the beginning of the value (because a prefix of 0 does not alter the value of
    a numeric representation) to get `0deadh`, which unambiguously represents DEAD[16].
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MASM汇编器使用`h`或`H`后缀。由于这并不能完全消除某些标识符与字面十六进制常量之间的歧义（例如，“deadh”对MASM仍然看起来像一个标识符），它还要求十六进制值以数字字符开头。因此，你需要在值的开头添加`0`（因为数字表示的前缀`0`不会改变值），得到`0deadh`，这就明确表示DEAD[16]。
- en: Visual Basic uses the `&H` or `&h` prefix. Continuing with the current example,
    you’d use `&Hdead` to represent DEAD[16] in Visual Basic.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Basic使用`&H`或`&h`前缀。继续当前的示例，你需要使用`&Hdead`来表示Visual Basic中的DEAD[16]。
- en: Pascal (Delphi) uses the prefix `$`. So, you’d use `$dead` to represent the
    current example in Delphi/Free Pascal.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pascal（Delphi）使用前缀`$`。因此，你可以使用`$dead`来表示Delphi/Free Pascal中的当前示例。
- en: HLA also uses the prefix `$`. As with binary numbers, it also allows you to
    insert underscores into a hexadecimal number to make it easier to read (for example,
    `$FDEC_A012`).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HLA也使用前缀`$`。与二进制数一样，它还允许你在十六进制数字中插入下划线，以便更容易阅读（例如，`$FDEC_A012`）。
- en: In general, this book will use the HLA/Delphi/Free Pascal format except in examples
    specific to other programming languages. Because there are several C/C++ examples
    in this book, you’ll frequently see the C/C++ notation as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，本书将使用HLA/Delphi/Free Pascal格式，除非是在针对其他编程语言的示例中。由于本书中有若干C/C++示例，因此你会经常看到C/C++表示法。
- en: '**2.2.4.2 Converting Between Hexadecimal and Binary Representations**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**2.2.4.2 在十六进制和二进制表示之间转换**'
- en: Another reason hexadecimal notation is popular is because it’s easy to convert
    between the binary and hexadecimal representations. By memorizing the few simple
    rules shown in [Table 2-1](ch02.xhtml#ch02tab01), you can mentally perform this
    conversion.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制表示法流行的另一个原因是它便于在二进制和十六进制表示之间进行转换。通过记住[表2-1](ch02.xhtml#ch02tab01)中展示的几个简单规则，你可以在脑海中进行这种转换。
- en: '**Table 2-1:** Binary/Hexadecimal Conversion Chart'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1:** 二进制/十六进制转换表'
- en: '| **Binary** | **Hexadecimal** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **十六进制** |'
- en: '| `%0000` | `$0` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `%0000` | `$0` |'
- en: '| `%0001` | `$1` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `%0001` | `$1` |'
- en: '| `%0010` | `$2` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `%0010` | `$2` |'
- en: '| `%0011` | `$3` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `%0011` | `$3` |'
- en: '| `%0100` | `$4` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `%0100` | `$4` |'
- en: '| `%0101` | `$5` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `%0101` | `$5` |'
- en: '| `%0110` | `$6` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `%0110` | `$6` |'
- en: '| `%0111` | `$7` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `%0111` | `$7` |'
- en: '| `%1000` | `$8` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `%1000` | `$8` |'
- en: '| `%1001` | `$9` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `%1001` | `$9` |'
- en: '| `%1010` | `$A` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `%1010` | `$A` |'
- en: '| `%1011` | `$B` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `%1011` | `$B` |'
- en: '| `%1100` | `$C` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `%1100` | `$C` |'
- en: '| `%1101` | `$D` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `%1101` | `$D` |'
- en: '| `%1110` | `$E` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `%1110` | `$E` |'
- en: '| `%1111` | `$F` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `%1111` | `$F` |'
- en: 'To convert the hexadecimal representation of a number into binary, substitute
    the corresponding 4 bits for each hexadecimal digit. For example, to convert `$ABCD`
    into the binary form `%1010_1011_1100_1101`, convert each hexadecimal digit according
    to the values in [Table 2-1](ch02.xhtml#ch02tab01):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数字的十六进制表示转换为二进制，需要为每个十六进制数字替换相应的 4 位。例如，要将 `$ABCD` 转换为二进制形式 `%1010_1011_1100_1101`，根据
    [表 2-1](ch02.xhtml#ch02tab01) 中的值转换每个十六进制数字：
- en: '| `A` | `B` | `C` | `D` | Hexadecimal |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `A` | `B` | `C` | `D` | 十六进制 |'
- en: '| `1010` | `1011` | `1100` | `1101` | Binary |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `1010` | `1011` | `1100` | `1101` | 二进制 |'
- en: 'Converting the binary representation of a number into hexadecimal is almost
    as easy. First, pad the binary number with 0s to make sure it is a multiple of
    4 bits long. For example, given the binary number 1011001010, add two 0 bits to
    the left of the number to make it 12 bits without changing its value: 001011001010\.
    Next, separate the binary value into groups of 4 bits: 0010_1100_1010\. Finally,
    look up these binary values in [Table 2-1](ch02.xhtml#ch02tab01) and substitute
    the appropriate hexadecimal digits: `$2CA`. As you can see, this is much simpler
    than converting between decimal and binary or between decimal and hexadecimal.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字的二进制表示转换为十六进制几乎同样简单。首先，将二进制数用 0 补齐，确保它的位数是 4 的倍数。例如，给定二进制数 1011001010，将两个
    0 位加到数字的左侧，使其变为 12 位而不改变其值：001011001010。接下来，将二进制值分成 4 位一组：0010_1100_1010。最后，在
    [表 2-1](ch02.xhtml#ch02tab01) 中查找这些二进制值，并替换为相应的十六进制数字：`$2CA`。正如你所见，这比将十进制与二进制或十进制与十六进制之间的转换要简单得多。
- en: '***2.2.5 The Octal Numbering System***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.2.5 八进制计数系统***'
- en: Octal (base-8) representation was common in early computer systems, so you might
    still see it in use now and then. Octal is great for 12-bit and 36-bit computer
    systems (or any other size that is a multiple of 3), but not particularly for
    computer systems whose bit size is a power of 2 (8-, 16-, 32-, and 64-bit computer
    systems). Nevertheless, some programming languages allow you to specify numeric
    values in octal notation, and you can still find some older Unix applications
    that use it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制（基数 8）表示法在早期计算机系统中很常见，因此你可能会偶尔看到它的使用。八进制对于 12 位和 36 位计算机系统（或任何位数是 3 的倍数的系统）很有用，但对于位数是
    2 的幂（如 8 位、16 位、32 位和 64 位计算机系统）的计算机系统并不特别合适。然而，一些编程语言允许你以八进制表示法指定数字值，你仍然可以找到一些使用它的旧版
    Unix 应用程序。
- en: '**2.2.5.1 Representing Octal Values in Programming Languages**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**2.2.5.1 编程语言中的八进制表示**'
- en: The C programming language (and derivatives like C++ and Java), MASM, Swift,
    and Visual Basic support octal representation. You should be aware of the notation
    they use for octal numbers in case you come across it in programs written in these
    languages.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: C 编程语言（以及 C++ 和 Java 等衍生语言）、MASM、Swift 和 Visual Basic 支持八进制表示。你应该了解它们使用的八进制表示法，以防在这些语言编写的程序中遇到这种情况。
- en: In C, you specify the octal base by prefixing a numeric string with a `0` (zero).
    For example, `0123` is equivalent to the decimal value 83[10] and definitely *not*
    equivalent to the decimal value 123[10].
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C 中，你可以通过在数字字符串前加上 `0`（零）来指定八进制。例如，`0123` 等于十进制值 83[10]，并且绝对*不是*十进制值 123[10]。
- en: MASM uses a `Q` or `q` suffix. (Microsoft/Intel probably chose *Q* because it
    looks like the letter *O* but isn’t likely to be confused with a zero.)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MASM 使用 `Q` 或 `q` 后缀。（微软/英特尔可能选择 *Q*，因为它看起来像字母 *O*，但不容易与零混淆。）
- en: Swift uses a `0o` prefix. For example, `0o14` represents the decimal value 12[10].
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 使用 `0o` 前缀。例如，`0o14` 表示十进制值 12[10]。
- en: Visual Basic uses the prefix `&O` (that’s the letter *O*, not a zero). For example,
    you’d use `&O123` to represent the decimal value 83[10].
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Basic 使用前缀 `&O`（是字母 *O*，不是零）。例如，你会用 `&O123` 来表示十进制值 83[10]。
- en: '**2.2.5.2 Converting Between Octal and Binary Representation**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**2.2.5.2 二进制与八进制表示之间的转换**'
- en: Converting between binary and octal is similar to converting between binary
    and hexadecimal, except that you work in groups of 3 bits rather than 4\. See
    [Table 2-2](ch02.xhtml#ch02tab02) for the list of binary and octal equivalent
    representations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制与八进制之间的转换类似于二进制与十六进制之间的转换，只是这次是按 3 位一组，而不是 4 位一组。查看 [表 2-2](ch02.xhtml#ch02tab02)，它列出了二进制与八进制的等价表示。
- en: '**Table 2-2:** Binary/Octal Conversion Chart'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-2：** 二进制/八进制转换表'
- en: '| **Binary** | **Octal** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **八进制** |'
- en: '| `%000` | `0` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `%000` | `0` |'
- en: '| `%001` | `1` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `%001` | `1` |'
- en: '| `%010` | `2` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `%010` | `2` |'
- en: '| `%011` | `3` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `%011` | `3` |'
- en: '| `%100` | `4` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `%100` | `4` |'
- en: '| `%101` | `5` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `%101` | `5` |'
- en: '| `%110` | `6` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `%110` | `6` |'
- en: '| `%111` | `7` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `%111` | `7` |'
- en: 'To convert octal into binary, replace each octal digit in the number with the
    corresponding 3 bits from [Table 2-2](ch02.xhtml#ch02tab02). For example, when
    you convert `123q` into a binary value, the final result is `%0_0101_0011`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要将八进制转换为二进制，请将数字中的每个八进制数字替换为[表2-2](ch02.xhtml#ch02tab02)中对应的3位二进制位。例如，当你将`123q`转换为二进制值时，最终结果是`%0_0101_0011`：
- en: '| `1` | `2` | `3` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `2` | `3` |'
- en: '| `001` | `010` | `011` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `001` | `010` | `011` |'
- en: To convert a binary number into octal, you break up the binary string into groups
    of 3 bits (padding with 0s, as necessary) and then replace each triad with the
    corresponding octal digit from [Table 2-2](ch02.xhtml#ch02tab02).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要将二进制数字转换为八进制，你需要将二进制字符串分成3位一组（根据需要用0填充），然后将每组三位替换为[表2-2](ch02.xhtml#ch02tab02)中的对应八进制数字。
- en: To convert an octal value to hexadecimal notation, convert the octal number
    to binary and then convert the binary value to hexadecimal.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要将八进制值转换为十六进制表示法，先将八进制数字转换为二进制，然后再将二进制值转换为十六进制。
- en: '**2.3 Numeric/String Conversions**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.3 数字/字符串转换**'
- en: 'In this section, we’ll explore conversions from string to numeric form and
    vice versa. Because most programming languages (or their libraries) perform these
    conversions automatically, beginning programmers are often unaware that they’re
    even taking place. For example, consider how easy it is to convert a string to
    numeric form in various languages:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨从字符串到数字形式的转换以及反向转换。由于大多数编程语言（或其库）会自动执行这些转换，初学者往往不知道这些转换的发生。例如，考虑在各种语言中将字符串转换为数字形式是多么容易：
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In each of these statements, the variable `i` can hold some integer number.
    The input from the user’s console, however, is a string of characters. The programming
    language’s runtime library is responsible for converting that string of characters
    to the internal binary form the CPU requires. Note that Swift only allows you
    to read a string from the standard input; you must explicitly convert that string
    to an integer using the `Int()` constructor/type conversion function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些语句中，变量`i`可以保存一个整数值。然而，用户从控制台输入的是一串字符。编程语言的运行时库负责将这串字符转换为CPU所需的内部二进制形式。请注意，Swift只允许你从标准输入读取一个字符串；你必须显式地使用`Int()`构造函数/类型转换函数将该字符串转换为整数。
- en: Unfortunately, if you have no idea of the cost of these statements, you won’t
    realize how they can impact your program when performance is critical. It’s important
    to understand the underlying work involved in the conversion algorithms so you
    won’t frivolously use statements like these.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果你不了解这些语句的成本，你将无法意识到它们在性能关键时如何影响你的程序。理解转换算法中涉及的底层工作非常重要，这样你就不会轻率地使用这些语句。
- en: '**NOTE**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For simplicity’s sake, we’ll discuss unsigned integer values and ignore the
    possibility of illegal characters and numeric overflow. Therefore, the following
    algorithms slightly understate the actual work involved.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简便起见，我们将讨论无符号整数值，并忽略非法字符和数值溢出的可能性。因此，以下算法稍微低估了实际涉及的工作。*'
- en: 'Use this algorithm to convert a string of decimal digits to an integer value:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此算法将一串十进制数字转换为整数值：
- en: Initialize a variable with `0`; this will hold the final value.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个值为`0`的变量；这个变量将保存最终的值。
- en: If there are no more digits in the string, then the algorithm is complete, and
    the variable holds the numeric value.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果字符串中没有更多的数字，则算法完成，变量保存了数字值。
- en: Fetch the next digit (moving from left to right) from the string and convert
    it from ASCII to an integer.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串中提取下一个数字（从左到右），并将其从ASCII转换为整数。
- en: Multiply the variable by 10, and then add in the digit fetched in step 3.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量乘以10，然后加上步骤3中提取的数字。
- en: Return to step 2 and repeat.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回步骤2并重复。
- en: 'Converting an integer value to a string of characters takes even more effort:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将整数值转换为字符字符串需要更多的努力：
- en: Initialize a string to the empty string.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个空字符串。
- en: If the integer value is 0, output a `0`, and the algorithm is complete.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果整数值为0，输出`0`，并且算法完成。
- en: Divide the current integer value by 10, computing the remainder and quotient.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前的整数值除以10，计算余数和商。
- en: Convert the remainder (always in the range 0..9^([2](footnotes.xhtml#fn2_2a)))
    to a character, and insert the character at the beginning of the string.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数（始终在0..9的范围内^([2](footnotes.xhtml#fn2_2a)))转换为字符，并将该字符插入字符串的开头。
- en: If the quotient is not 0, make it the new value and repeat steps 3–5.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果商不为0，则将其作为新的值，并重复步骤3至步骤5。
- en: Output the characters in the string.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出字符串中的字符。
- en: 'The particulars of these algorithms are not important. What *is* important
    is that these steps execute once for each output character and division is very
    slow. So, a simple statement like one of the following can hide a fair amount
    of work from the programmer:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法的细节并不重要。重要的是，*每个输出字符执行一次这些步骤，且除法运算非常缓慢*。因此，像以下这样的简单语句可以隐藏程序员相当多的工作：
- en: '[PRE2]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To write great code, you don’t need to avoid using numeric/string conversions
    altogether; however, a great programmer will take care to use them only as necessary.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写出色的代码，你不必完全避免使用数字/字符串转换；然而，一名出色的程序员会小心只在必要时使用它们。
- en: Remember that these algorithms are valid only for unsigned integers. Signed
    integers require a little more effort to process (though the extra work is almost
    negligible). Floating-point values, however, are far more difficult to convert
    between string and numeric form, so keep that in mind when writing code that uses
    floating-point arithmetic.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些算法仅适用于无符号整数。带符号整数需要稍微更多的处理（尽管额外的工作几乎可以忽略不计）。然而，浮点值在字符串与数值之间的转换要困难得多，因此在编写涉及浮点运算的代码时，务必记住这一点。
- en: '**2.4 Internal Numeric Representation**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.4 内部数值表示**'
- en: Most modern computer systems use an internal binary format to represent values
    and other objects. However, most systems can only efficiently represent binary
    values of a given size. In order to write great code, you need to make sure that
    your programs use data objects that the machine can represent efficiently. This
    section will describe how computers physically represent values so you can design
    your programs accordingly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机系统使用内部二进制格式来表示值和其他对象。然而，大多数系统只能有效地表示特定大小的二进制值。为了编写出色的代码，你需要确保你的程序使用计算机能够高效表示的数据对象。本节将描述计算机如何物理表示值，以便你能相应地设计程序。
- en: '***2.4.1 Bits***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.4.1 比特***'
- en: 'The smallest unit of data on a binary computer is a single bit. Because a bit
    can represent only two different values (typically `0` or `1`), you might assume
    that you can’t use it for much. But in fact, there’s an infinite number of two-item
    combinations you can represent with a single bit. Here are some examples (with
    arbitrary binary encodings I’ve created):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制计算机中，数据的最小单位是单个比特。因为一个比特只能表示两个不同的值（通常是`0`或`1`），你可能会认为它无法发挥太大作用。但实际上，使用单个比特可以表示无数种两项组合。以下是一些例子（我创建的任意二进制编码）：
- en: Zero (`0`) or one (`1`)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零（`0`）或一（`1`）
- en: False (`0`) or true (`1`)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假（`0`）或真（`1`）
- en: Off (`0`) or on (`1`)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭（`0`）或开启（`1`）
- en: Male (`0`) or female (`1`)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 男性（`0`）或女性（`1`）
- en: Wrong (`0`) or right (`1`)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误（`0`）或正确（`1`）
- en: 'You’re not limited to representing binary data types, either (that is, those
    objects that have only two distinct values). You could also use a single bit to
    represent any two distinct items:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于表示二进制数据类型（即那些只有两种不同值的对象）。你也可以使用单个比特来表示任何两个不同的项：
- en: The numbers 723 (`0`) and 1,245 (`1`)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字723（`0`）和1,245（`1`）
- en: The colors red (`0`) and blue (`1`)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色（`0`）和蓝色（`1`）
- en: You could even represent two unrelated objects with a single bit. For example,
    you could use the bit value `0` to represent the color red and the bit value `1`
    to represent the number 3,256\. You can represent *any* two different values with
    a single bit—but *only* two different values. Therefore, individual bits aren’t
    sufficient for most computational needs. To overcome the limitations of a single
    bit, we create *[bit strings](gloss01.xhtml#gloss01_32)* from a sequence of multiple
    bits.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用单个比特表示两个不相关的对象。例如，你可以使用比特值`0`表示红色，使用比特值`1`表示数字3,256。你可以用单个比特表示*任何*两种不同的值——但*仅仅*两种不同的值。因此，单个比特对于大多数计算需求是不足够的。为了克服单个比特的局限性，我们通过多个比特的序列创建*【比特串】(gloss01.xhtml#gloss01_32)*。
- en: '***2.4.2 Bit Strings***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.4.2 位串***'
- en: By combining bits into a sequence, we can form binary representations that are
    equivalent to other representations of numbers, like hexadecimal and octal. Most
    computer systems don’t let you combine an arbitrary number of bits, so you have
    to work with bit strings of certain fixed lengths.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将比特组合成一个序列，我们可以形成与其他数值表示方式（如十六进制和八进制）等价的二进制表示。大多数计算机系统不允许你组合任意数量的比特，因此你必须使用固定长度的比特串。
- en: A *[nibble](gloss01.xhtml#gloss01_172)* is a collection of 4 bits. Most computer
    systems don’t provide efficient access to nibbles in memory. Notably, it takes
    exactly 1 nibble to represent a single hexadecimal digit.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*[半字节](gloss01.xhtml#gloss01_172)*是由 4 位组成的集合。大多数计算机系统在内存中无法高效访问半字节。特别地，恰好需要
    1 个半字节来表示一个十六进制数字。'
- en: A *[byte](gloss01.xhtml#gloss01_39)* is 8 bits and is the smallest addressable
    data item on many CPUs; that is, the CPU can efficiently retrieve data in groups
    of 8 bits from memory. For this reason, the smallest data type that many languages
    support consumes 1 byte of memory (regardless of the actual number of bits the
    data type requires).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*[字节](gloss01.xhtml#gloss01_39)*是 8 位，是许多 CPU 上最小的可寻址数据项；即 CPU 可以高效地从内存中以 8
    位为一组来检索数据。正因如此，许多语言支持的最小数据类型消耗 1 个字节的内存（无论该数据类型实际需要多少位）。'
- en: Because the byte is the smallest unit of storage on most machines, and many
    languages use bytes to represent objects that require fewer than 8 bits, we need
    some way of denoting individual bits within a byte. To describe the bits within
    a byte, we’ll use *bit numbers*. As [Figure 2-3](ch02.xhtml#ch02fig03) shows,
    bit 0 is the *[low-order (LO)](gloss01.xhtml#gloss01_138)*, or *least significant*,
    bit, and bit 7 is the *high-order (HO)*, or *most significant*, bit of the byte.
    We’ll refer to all other bits by their number.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字节是大多数计算机中最小的存储单位，并且许多语言使用字节表示需要少于 8 位的对象，我们需要某种方式表示字节中的单个位。为了描述字节中的位，我们将使用*位编号*。如[图
    2-3](ch02.xhtml#ch02fig03)所示，位 0 是*低位（LO）*，或*最不重要*的位，位 7 是*高位（HO）*，或*最重要*的位。其余位将通过它们的编号来表示。
- en: '![image](../images/02fig03.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig03.jpg)'
- en: '*Figure 2-3: Bit numbering in a byte*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：字节中的位编号*'
- en: 'A *word* is defined differently depending on the CPU: it may be a 16-bit, 32-bit,
    or 64-bit object. This book adopts the 80x86 terminology and defines a word as
    a collection of 16 bits. As with bytes, we’ll use bit numbers for a word, starting
    with bit number 0 for the LO bit and working our way up to bit 15, the HO bit
    (see [Figure 2-4](ch02.xhtml#ch02fig04)).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*字*的定义因 CPU 而异：它可能是 16 位、32 位或 64 位的对象。本书采用 80x86 术语，并将一个字定义为 16 位的集合。与字节一样，我们将为一个字使用位编号，从位
    0（LO 位）开始，逐步到位 15（HO 位）（参见[图 2-4](ch02.xhtml#ch02fig04)）。'
- en: '![image](../images/02fig04.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig04.jpg)'
- en: '*Figure 2-4: Bit numbers in a word*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：一个字中的位编号*'
- en: Notice that a word contains exactly 2 bytes. Bits 0 through 7 form the LO byte,
    and bits 8 through 15 form the HO byte (see [Figure 2-5](ch02.xhtml#ch02fig05)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个字包含正好 2 个字节。位 0 到 7 组成 LO 字节，位 8 到 15 组成 HO 字节（参见[图 2-5](ch02.xhtml#ch02fig05)）。
- en: '![image](../images/02fig05.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig05.jpg)'
- en: '*Figure 2-5: The 2 bytes in a word*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：一个字中的 2 个字节*'
- en: A *[double word](gloss01.xhtml#gloss01_80)* (or *[dword](gloss01.xhtml#gloss01_83)*)
    is exactly what its name implies—a pair of words. Therefore, a double-word quantity
    is 32 bits long, as shown in [Figure 2-6](ch02.xhtml#ch02fig06).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*[双字](gloss01.xhtml#gloss01_80)*（或*[dword](gloss01.xhtml#gloss01_83)）*的含义正如其名称所示——一对字。因此，双字的长度是
    32 位，如[图 2-6](ch02.xhtml#ch02fig06)所示。'
- en: '![image](../images/02fig06.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig06.jpg)'
- en: '*Figure 2-6: Bit layout in a double word*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：双字中的位布局*'
- en: '[Figure 2-7](ch02.xhtml#ch02fig07) shows that a double word comprises 2 words
    or 4 bytes.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-7](ch02.xhtml#ch02fig07)显示一个双字由 2 个字或 4 个字节组成。'
- en: '![image](../images/02fig07.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig07.jpg)'
- en: '*Figure 2-7: Bytes and words in a double word*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：双字中的字节和字*'
- en: As noted, most CPUs efficiently handle objects up to a certain size (typically
    32 or 64 bits on contemporary systems). That doesn’t mean you can’t work with
    larger objects, only that it’s less efficient to do so. You typically won’t see
    programs handling numeric objects much larger than about 128 or 256 bits. Some
    programming languages make 64-bit integers available, and most languages support
    64-bit floating-point values, so for these data types we’ll use the term *[quad
    word](gloss01.xhtml#gloss01_206)*. Finally, we’ll use *[long word](gloss01.xhtml#gloss01_139)*
    to describe 128-bit values; although few languages today support them,^([3](footnotes.xhtml#fn2_3a))
    this gives us some room to grow.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，大多数 CPU 高效地处理大小不超过某一限制的对象（现代系统上通常为 32 位或 64 位）。这并不意味着你不能处理更大的对象，只是这样做的效率较低。你通常不会看到程序处理超过大约
    128 位或 256 位的数字对象。一些编程语言提供 64 位整数，且大多数语言支持 64 位浮点值，因此对于这些数据类型，我们将使用*四字*（[quad
    word](gloss01.xhtml#gloss01_206)）这个术语。最后，我们将使用*长字*（[long word](gloss01.xhtml#gloss01_139)）来描述
    128 位的值；尽管今天很少有语言支持它们，^([3](footnotes.xhtml#fn2_3a))，但这给了我们一定的扩展空间。
- en: We can break down quad words into 2 double words, 4 words, 8 bytes, or 16 nibbles.
    Likewise, we can break down long words into 2 quad words, 4 double words, 8 words,
    or 16 bytes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将四字长（quad word）分解为 2 个双字（double word），4 个字（word），8 个字节（byte）或 16 个半字节（nibble）。同样，我们也可以将长字（long
    word）分解为 2 个四字长，4 个双字，8 个字或 16 个字节。
- en: Intel 80x86 platforms also support an 80-bit type that Intel calls a *[tbyte](gloss01.xhtml#gloss01_244)*
    (short for “ten byte”) object. The 80x86 CPU family uses tbyte variables to hold
    extended precision floating-point values and certain binary-coded decimal (BCD)
    values.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔 80x86 平台还支持一种 80 位类型，英特尔称之为 *[tbyte](gloss01.xhtml#gloss01_244)*（即“十字节”对象的缩写）。80x86
    CPU 系列使用 tbyte 变量来保存扩展精度的浮点值和某些二进制编码十进制（BCD）值。
- en: In general, with an *n*-bit string you can represent up to 2^(*n*) different
    values. [Table 2-3](ch02.xhtml#ch02tab03) shows the number of possible objects
    you can represent with nibbles, bytes, words, double words, quad words, and long
    words.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用 *n* 位串，您可以表示最多 2^(*n*) 个不同的值。[表 2-3](ch02.xhtml#ch02tab03) 显示了使用半字节、字节、字、双字、四字和长字可以表示的可能对象数量。
- en: '**Table 2-3:** Number of Values Representable with Bit Strings'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-3：** 可由位串表示的值的数量'
- en: '| **Size of bit string (in bits)** | **Number of possible combinations (2^(*n*))**
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **位串大小（以位为单位）** | **可能的组合数量（2^(*n*)）** |'
- en: '| 4 | 16 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 16 |'
- en: '| 8 | 256 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 256 |'
- en: '| 16 | 65,536 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 65,536 |'
- en: '| 32 | 4,294,967,296 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 4,294,967,296 |'
- en: '| 64 | 18,446,744,073,709,551,616 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 18,446,744,073,709,551,616 |'
- en: '| 128 | 340,282,366,920,938,463,463,374,607,431,768,211,456 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 340,282,366,920,938,463,463,374,607,431,768,211,456 |'
- en: '**2.5 Signed and Unsigned Numbers**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.5 有符号与无符号数**'
- en: The binary number 0…00000^([4](footnotes.xhtml#fn2_4a)) represents 0; 0…00001
    represents 1; 0…00010 represents 2; and so on toward infinity. But what about
    negative numbers? To represent signed values, most computer systems use the *two’s
    complement* numbering system. The representation of signed numbers places some
    fundamental restrictions on them, so it’s important that you understand how signed
    and unsigned numbers are represented differently in a computer system in order
    to use them efficiently.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数字 0…00000^([4](footnotes.xhtml#fn2_4a)) 表示 0；0…00001 表示 1；0…00010 表示 2；依此类推直到无穷大。那么负数呢？为了表示有符号的值，大多数计算机系统使用
    *二进制补码* 数字系统。有符号数的表示方式对它们施加了一些基本的限制，因此理解有符号数和无符号数在计算机系统中的不同表示方式非常重要，以便有效地使用它们。
- en: With *n* bits, we can represent only 2^(*n*) different objects. Because negative
    values are objects in their own right, we’ll have to divide these 2^(*n*) combinations
    between negative and non-negative values. So, for example, a byte can represent
    the negative values –128 through –1 and the non-negative values 0 to 127\. With
    a 16-bit word, we can represent signed values in the range –32,768 to +32,767\.
    With a 32-bit double word, we can represent values in the range –2,147,483,648
    to +2,147,483,647\. In general, with *n* bits we can represent the signed values
    in the range –2^(*n–*)¹ to +2^(*n–*)¹ – 1.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *n* 位，我们只能表示 2^(*n*) 个不同的对象。由于负数本身也是一个对象，我们需要将这 2^(*n*) 个组合分配给负值和非负值。例如，一个字节可以表示从
    -128 到 -1 的负值，以及从 0 到 127 的非负值。使用 16 位字，可以表示从 -32,768 到 +32,767 的有符号值。使用 32 位双字，可以表示从
    -2,147,483,648 到 +2,147,483,647 的值。一般来说，使用 *n* 位可以表示从 -2^(*n–*)¹ 到 +2^(*n–*)¹
    – 1 范围内的有符号值。
- en: 'The two’s complement system uses the HO bit as a *sign bit*. If the HO bit
    is `0`, the number is non-negative and has the usual binary encoding; if the HO
    bit is `1`, the number is negative and uses the two’s complement encoding. Here
    are some examples using 16-bit numbers:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制补码系统使用最高位（HO 位）作为 *符号位*。如果最高位为 `0`，则该数字为非负数，并使用通常的二进制编码；如果最高位为 `1`，则该数字为负数，并使用二进制补码编码。以下是一些使用
    16 位数字的例子：
- en: '`$8000` (`%1000_0000_0000_0000`) is negative because the HO bit is `1`.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$8000`（`%1000_0000_0000_0000`）是负数，因为最高位（HO 位）为 `1`。'
- en: '`$100` (`%0000_0001_0000_0000`) is non-negative because the HO bit is `0`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$100`（`%0000_0001_0000_0000`）是非负数，因为最高位（HO 位）为 `0`。'
- en: '`$7FFF` (`%0111_1111_1111_1111`) is non-negative.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$7FFF`（`%0111_1111_1111_1111`）是非负数。'
- en: '`$FFFF` (`%1111_1111_1111_1111`) is negative.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$FFFF`（`%1111_1111_1111_1111`）是负数。'
- en: '`$FFF` (`%0000_1111_1111_1111`) is non-negative.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$FFF`（`%0000_1111_1111_1111`）是非负数。'
- en: 'To negate a number, you can use the two’s complement operation as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要取反一个数字，可以使用二进制补码操作，方法如下：
- en: Invert all the bits in the number; that is, change all the `0`s to `1`s and
    vice versa.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转数字中的所有位；也就是说，将所有 `0` 改为 `1`，将所有 `1` 改为 `0`。
- en: Add `1` to the inverted result (ignoring any overflow).
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`1`加到反转后的结果（忽略任何溢出）。
- en: If the result is negative (has its HO bit set), then this is the two’s complement
    form of the non-negative value.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果是负数（其 HO 位被设置），那么这就是非负值的二进制补码形式。
- en: 'For example, these are the steps to compute the 8-bit equivalent of the decimal
    value –5:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是计算十进制值 –5 的 8 位等价数的步骤：
- en: '`%0000_0101`   5 (in binary).'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%0000_0101`   5（二进制）。'
- en: '`%1111_1010`   Invert all the bits.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%1111_1010`   反转所有位。'
- en: '`%1111_1011`   Add 1 to obtain –5 (in two’s complement form).'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%1111_1011`   加 1 得到 –5（二进制补码形式）。'
- en: 'If we take –5 and negate it, the result is 5 (`%0000_0101`), just as we expect:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取 –5 并取反，结果是 5（`%0000_0101`），正如我们预期的那样：
- en: '`%1111_1011`   Two’s complement for –5.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%1111_1011`   –5 的二进制补码。'
- en: '`%0000_0100`   Invert all the bits.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%0000_0100`   反转所有位。'
- en: '`%0000_0101`   Add 1 to obtain 5 (in binary).'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%0000_0101`   加 1 得到 5（二进制）。'
- en: Let’s look at some 16-bit examples and their negations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些 16 位示例及其反转。
- en: 'First, negate 32,767 (`$7FFF`):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，取反 32,767（`$7FFF`）：
- en: '`%0111_1111_1111_1111`   +32,767, the largest 16-bit positive number.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%0111_1111_1111_1111`   +32,767，最大的 16 位正数。'
- en: '`%1000_0000_0000_0000`   Invert all the bits (`8000h`).'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%1000_0000_0000_0000`   反转所有位（`8000h`）。'
- en: '`%1000_0000_0000_0001`   Add 1 (`8001h`, or –32,767).'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%1000_0000_0000_0001`   加 1（`8001h`，或 –32,767）。'
- en: 'Now negate 16,384 (`$4000`):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在取反 16,384（`$4000`）：
- en: '`%0100_0000_0000_0000`   16,384.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%0100_0000_0000_0000`   16,384。'
- en: '`%1011_1111_1111_1111`   Invert all the bits (`$BFFF`).'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%1011_1111_1111_1111`   反转所有位（`$BFFF`）。'
- en: '`%1100_0000_0000_0000`   Add 1 (`$C000` or –16,384).'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%1100_0000_0000_0000`   加 1（`$C000` 或 –16,384）。'
- en: 'And now negate –32,768 (`$8000`):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在取反 –32,768（`$8000`）：
- en: '`%1000_0000_0000_0000`   –32,768, the smallest 16-bit negative number.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%1000_0000_0000_0000`   –32,768，最小的 16 位负数。'
- en: '`%0111_1111_1111_1111`   Invert all the bits (`$7FFF`).'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%0111_1111_1111_1111`   反转所有位（`$7FFF`）。'
- en: '`%1000_0000_0000_0000`   Add 1 (`$8000` or –32,768).'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%1000_0000_0000_0000`   加 1（`$8000` 或 –32,768）。'
- en: '`$8000` inverted becomes `$7FFF`, and after adding 1 we obtain `$8000`! Wait,
    what’s going on here: –(–32,768) is –32,768? Of course not. However, the 16-bit
    two’s complement numbering system cannot represent the value +32,768\. In general,
    you cannot negate the smallest negative value in the two’s complement numbering
    system.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`$8000` 反转后变为 `$7FFF`，加 1 后我们得到 `$8000`！等等，发生了什么：–(–32,768) 就是 –32,768？当然不是。然而，16
    位二进制补码系统无法表示 +32,768。一般来说，你不能取二进制补码系统中最小负值的反。'
- en: '**2.6 Useful Properties of Binary Numbers**'
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.6 二进制数的有用性质**'
- en: 'Here are some properties of binary values that you might find useful in your
    programs:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可能在程序中用到的二进制值性质：
- en: If bit position 0 of a binary (integer) value contains `1`, the number is an
    odd number; if this bit contains `0`, then the number is even.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果二进制（整数）值的第 0 位包含 `1`，则该数是奇数；如果该位包含 `0`，则该数是偶数。
- en: If the LO *n* bits of a binary number all contain `0`, then the number is evenly
    divisible by 2^(*n*).
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果二进制数的低 *n* 位都包含 `0`，那么该数可以被 2^(*n*) 整除。
- en: If a binary value contains a `1` in bit position *n*, and `0`s everywhere else,
    then that number is equal to 2^(*n*).
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果二进制值的第 *n* 位是 `1`，而其他所有位都是 `0`，那么该数等于 2^(*n*)。
- en: If a binary value contains all `1`s from bit position 0 up to (but not including)
    bit position *n*, and all other bits are `0`, then that value is equal to 2^(*n*)
    – 1.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果二进制值从第 0 位到第 *n*-1 位都包含 `1`，而其他所有位都是 `0`，那么该值等于 2^(*n*) – 1。
- en: Shifting all the bits in a number to the left by one position multiplies the
    binary value by 2.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个数的所有位向左移动一位，会将该二进制值乘以 2。
- en: Shifting all the bits of an unsigned binary number to the right by one position
    effectively divides that number by 2 (this does not apply to signed integer values).
    Odd numbers are rounded down.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将无符号二进制数的所有位右移一位，实际上是将该数除以 2（这不适用于有符号整数值）。奇数会向下舍入。
- en: Multiplying two *n*-bit binary values together may require as many as 2 × *n*
    bits to hold the result.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 *n* 位二进制值相乘可能需要多达 2 × *n* 位来存储结果。
- en: Adding or subtracting two *n*-bit binary values never requires more than *n*
    + 1 bits to hold the result.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法或减法两个 *n* 位二进制值从不需要超过 *n* + 1 位来存储结果。
- en: Inverting all the bits in a binary number (that is, changing all the `0`s to
    `1`s and vice versa) is the same thing as negating (changing the sign) of the
    value and then subtracting 1 from the result.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转二进制数中的所有位（即将所有 `0` 改为 `1`，反之亦然）与取反（改变符号）该值并从结果中减去 1 是相同的。
- en: '*Incrementing* (adding 1 to) the largest unsigned binary value for a given
    number of bits always produces a value of `0`.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*递增*（加 1）给定位数的最大无符号二进制值总是产生 `0`。'
- en: '*Decrementing* (subtracting 1 from) 0 always produces the largest unsigned
    binary value for a given number of bits.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*递减*（减去1）0总是会生成一个给定位数的最大无符号二进制值。'
- en: An *n*-bit value provides 2^(*n*) unique combinations of those bits.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*n*位的值提供2^(*n*)种唯一的位组合。
- en: The value 2^(*n*)–1 contains *n* bits, each containing the value `1`.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2^(*n*)–1的值包含*n*个位，每个位都包含值`1`。
- en: It’s a good idea to memorize all the powers of 2 from 2⁰ through 2^(16) (see
    [Table 2-4](ch02.xhtml#ch02tab04)), as these values come up in programs all the
    time.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 记住从2⁰到2^(16)的所有2的幂是个好主意（见[表2-4](ch02.xhtml#ch02tab04)），因为这些值在程序中经常出现。
- en: '**Table 2-4:** Powers of 2'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-4：** 2的幂'
- en: '| ***n*** | 2***n*** |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| ***n*** | 2***n*** |'
- en: '| 0 | 1 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 |'
- en: '| 1 | 2 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 |'
- en: '| 2 | 4 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 |'
- en: '| 3 | 8 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 8 |'
- en: '| 4 | 16 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 16 |'
- en: '| 5 | 32 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 32 |'
- en: '| 6 | 64 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 64 |'
- en: '| 7 | 128 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 128 |'
- en: '| 8 | 256 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 256 |'
- en: '| 9 | 512 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 512 |'
- en: '| 10 | 1,024 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1,024 |'
- en: '| 11 | 2,048 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 2,048 |'
- en: '| 12 | 4,096 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4,096 |'
- en: '| 13 | 8,192 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 8,192 |'
- en: '| 14 | 16,384 |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 16,384 |'
- en: '| 15 | 32,768 |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 32,768 |'
- en: '| 16 | 65,536 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 65,536 |'
- en: '**2.7 Sign Extension, Zero Extension, and Contraction**'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.7 符号扩展、零扩展与收缩**'
- en: With the two’s complement system, a single negative value is represented differently
    depending on the size of the representation. An 8-bit signed value must be converted
    for use in an expression involving a 16-bit number. This conversion and its converse—converting
    a 16-bit value to 8 bits—are the *[sign extension](gloss01.xhtml#gloss01_230)*
    and *contraction* operations, respectively.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用补码系统时，单一负值的表示方式会根据表示大小的不同而有所不同。8位的符号值必须转换才能用于涉及16位数的表达式。这种转换及其逆操作——将16位数转换为8位数——分别是*[符号扩展](gloss01.xhtml#gloss01_230)*和*收缩*操作。
- en: Consider the value –64\. The 8-bit two’s complement value for this number is
    `$C0`. The 16-bit equivalent is `$FFC0`. Clearly, these are not the same bit pattern.
    Now consider the value +64\. The 8- and 16-bit versions of this value are `$40`
    and `$0040`, respectively. We extend the size of negative values differently than
    we extend the size of non-negative values.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑值-64。这个数的8位补码值是`$C0`，16位等效值是`$FFC0`。显然，这些不是相同的位模式。现在考虑值+64。这个数的8位和16位版本分别是`$40`和`$0040`。我们扩展负值的方式与扩展非负值的方式不同。
- en: To *sign-extend* a value, copy the sign bit into the additional HO bits in the
    new format. For example, to sign-extend an 8-bit number to a 16-bit number, copy
    bit 7 of the 8-bit number into bits 8 through 15 of the 16-bit number. To sign-extend
    a 16-bit number to a double word, copy bit 15 into bits 16 through 31 of the double
    word.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行*符号扩展*，将符号位复制到新格式中的额外高位。例如，将一个8位数扩展到16位时，将8位数的第7位复制到16位数的第8到15位。将一个16位数扩展到双字时，将第15位复制到双字的第16到31位。
- en: When adding a byte quantity to a word quantity, you need to sign-extend the
    byte to 16 bits before adding the two numbers. Other operations may require a
    sign extension to 32 bits.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在将一个字节数量加到一个字数量时，需要先将字节扩展到16位，再加上这两个数。其他操作可能需要扩展到32位。
- en: '[Table 2-5](ch02.xhtml#ch02tab05) provides several examples of sign extension.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2-5](ch02.xhtml#ch02tab05)提供了几个符号扩展的示例。'
- en: '**Table 2-5:** Sign Extension Examples'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-5：** 符号扩展示例'
- en: '| **8 bits** | **16 bits** | **32 bits** | **Binary (two’s complement)** |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **8位** | **16位** | **32位** | **二进制（补码）** |'
- en: '| `$80` | `$FF80` | `$FFFF_FF80` | `%1111_1111_1111_1111_1111_1111_1000_0000`
    |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `$80` | `$FF80` | `$FFFF_FF80` | `%1111_1111_1111_1111_1111_1111_1000_0000`
    |'
- en: '| `$28` | `$0028` | `$0000_0028` | `%0000_0000_0000_0000_0000_0000_0010_1000`
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `$28` | `$0028` | `$0000_0028` | `%0000_0000_0000_0000_0000_0000_0010_1000`
    |'
- en: '| `$9A` | `$FF9A` | `$FFFF_FF9A` | `%1111_1111_1111_1111_1111_1111_1001_1010`
    |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `$9A` | `$FF9A` | `$FFFF_FF9A` | `%1111_1111_1111_1111_1111_1111_1001_1010`
    |'
- en: '| `$7F` | `$007F` | `$0000_007F` | `%0000_0000_0000_0000_0000_0000_0111_1111`
    |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `$7F` | `$007F` | `$0000_007F` | `%0000_0000_0000_0000_0000_0000_0111_1111`
    |'
- en: '| n/a | `$1020` | `$0000_1020` | `%0000_0000_0000_0000_0001_0000_0010_0000`
    |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| n/a | `$1020` | `$0000_1020` | `%0000_0000_0000_0000_0001_0000_0010_0000`
    |'
- en: '| n/a | `$8086` | `$FFFF_8086` | `%1111_1111_1111_1111_1000_0000_1000_0110`
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| n/a | `$8086` | `$FFFF_8086` | `%1111_1111_1111_1111_1000_0000_1000_0110`
    |'
- en: '*[Zero extension](gloss01.xhtml#gloss01_270)* converts small unsigned values
    to larger unsigned values. Zero extension is very easy—just store `0`s in the
    HO byte(s) of the larger operand. For example, to zero-extend the 8-bit value
    `$82` to 16 bits, you insert a `0` for the HO byte, yielding `$0082`.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*[零扩展](gloss01.xhtml#gloss01_270)*将小的无符号值转换为更大的无符号值。零扩展非常简单——只需将`0`存储在更大操作数的高位字节中。例如，将8位值`$82`零扩展到16位时，将高位字节插入`0`，得到`$0082`。'
- en: Further examples are listed in [Table 2-6](ch02.xhtml#ch02tab06).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例请见[表 2-6](ch02.xhtml#ch02tab06)。
- en: '**Table 2-6:** Zero Extension Examples'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-6：** 零扩展示例'
- en: '| **8 bits** | **16 bits** | **32 bits** | **Binary** |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| **8 位** | **16 位** | **32 位** | **二进制** |'
- en: '| `$80` | `$0080` | `$0000_0080` | `%0000_0000_0000_0000_0000_0000_1000_0000`
    |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `$80` | `$0080` | `$0000_0080` | `%0000_0000_0000_0000_0000_0000_1000_0000`
    |'
- en: '| `$28` | `$0028` | `$0000_0028` | `%0000_0000_0000_0000_0000_0000_0010_1000`
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `$28` | `$0028` | `$0000_0028` | `%0000_0000_0000_0000_0000_0000_0010_1000`
    |'
- en: '| `$9A` | `$009A` | `$0000_009A` | `%0000_0000_0000_0000_0000_0000_1001_1010`
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `$9A` | `$009A` | `$0000_009A` | `%0000_0000_0000_0000_0000_0000_1001_1010`
    |'
- en: '| `$7F` | `$007F` | `$0000_007F` | `%0000_0000_0000_0000_0000_0000_0111_1111`
    |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `$7F` | `$007F` | `$0000_007F` | `%0000_0000_0000_0000_0000_0000_0111_1111`
    |'
- en: '| n/a | `$1020` | `$0000_1020` | `%0000_0000_0000_0000_0001_0000_0010_0000`
    |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 不适用 | `$1020` | `$0000_1020` | `%0000_0000_0000_0000_0001_0000_0010_0000`
    |'
- en: '| n/a | `$8086` | `$0000_8086` | `%0000_0000_0000_0000_1000_0000_1000_0110`
    |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 不适用 | `$8086` | `$0000_8086` | `%0000_0000_0000_0000_1000_0000_1000_0110`
    |'
- en: 'Many high-level language compilers automatically handle sign and zero extension.
    The following examples in C demonstrate how this works:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 许多高级语言编译器会自动处理符号扩展和零扩展。下面的 C 语言示例演示了这一过程：
- en: '[PRE3]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Some languages (such as Ada or Swift) require an explicit cast from a smaller
    size to a larger size. Check the reference manual for your particular language
    to see if this is necessary. The advantage of a language that requires you to
    provide an explicit conversion is that the compiler never does anything behind
    your back. If you fail to do the conversion yourself, the compiler emits a diagnostic
    message.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言（如 Ada 或 Swift）要求从较小的大小显式转换为较大的大小。请查阅特定语言的参考手册，查看是否需要这样做。要求显式转换的语言的优点是，编译器永远不会在你不知情的情况下做任何事情。如果你没有进行转换，编译器会发出诊断信息。
- en: The important thing to realize about sign and zero extension is that they aren’t
    always free. Assigning a smaller integer to a larger integer may require more
    machine instructions (taking longer to execute) than moving data between two like-sized
    integer variables. Therefore, you should be careful about mixing variables of
    different sizes within the same arithmetic expression or assignment statement.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 关于符号扩展和零扩展，重要的是要意识到它们并非总是免费的。将较小的整数赋值给较大的整数可能需要更多的机器指令（执行时间更长），而不是在两个相同大小的整数变量之间移动数据。因此，在同一个算术表达式或赋值语句中混合不同大小的变量时，应小心。
- en: Sign contraction—converting a value with some number of bits to the same value
    with a fewer number of bits—is a little more troublesome. For example, consider
    the value –448\. As a 16-bit hexadecimal number, its representation is `$FE40`.
    The magnitude of this number is too large to fit into 8 bits, so you can’t sign-contract
    it to 8 bits.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 符号扩展——将一个具有某些位数的值转换为具有较少位数的相同值——稍微麻烦一些。例如，考虑值 –448。作为一个 16 位的十六进制数，它的表示是 `$FE40`。这个数的大小太大，无法适应
    8 位，因此你无法将其符号扩展到 8 位。
- en: 'To properly sign-contract one value to another, you must look at the HO byte(s)
    that you want to discard. First, the HO bytes must all contain either `0` or `$FF`.
    Second, the HO bit of your resulting value must match *every* bit you’ve removed
    from the number. Here are some examples of converting 16-bit values to 8-bit values
    (including a couple of failures):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地将一个值符号扩展到另一个值，你必须查看你想要丢弃的高位字节。首先，所有高位字节必须包含 `0` 或 `$FF`。其次，结果值的高位字节必须与你从数字中移除的每一位匹配。以下是将
    16 位值转换为 8 位值的一些示例（包括几个失败的例子）：
- en: '`$FF80` (`%1111_1111_1000_0000`) can be sign-contracted to `$80` (`%1000_0000`).'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$FF80`（`%1111_1111_1000_0000`）可以符号扩展为 `$80`（`%1000_0000`）。'
- en: '`$0040` (`%0000_0000_0100_0000`) can be sign-contracted to `$40` (`%0100_0000`).'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$0040`（`%0000_0000_0100_0000`）可以符号扩展为 `$40`（`%0100_0000`）。'
- en: '`$FE40` (`%1111_1110_0100_0000`) cannot be sign-contracted to 8 bits.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$FE40`（`%1111_1110_0100_0000`）不能被符号扩展到 8 位。'
- en: '`$0100` (`%0000_0001_0000_0000`) cannot be sign-contracted to 8 bits.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$0100`（`%0000_0001_0000_0000`）不能符号扩展到 8 位。'
- en: 'Some high-level languages, like C, will simply store the LO portion of the
    expression into a smaller variable and discard the HO component—at best, the C
    compiler may give you a warning about the loss of precision that may occur. You
    can often quiet the compiler, but it still doesn’t check for invalid values. Typically,
    you’d use code like the following to sign-contract a value in C:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级语言，如 C，通常会将表达式的低位部分存储到一个较小的变量中，丢弃高位部分——最多，C 编译器可能会给出有关可能发生精度丢失的警告。你通常可以让编译器静默，但它仍然不会检查无效值。通常，你可以使用类似以下代码来符号扩展
    C 中的值：
- en: '[PRE4]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The only safe solution in C is to compare the result of the expression to an
    upper- and lower-bound value before attempting to store the value into a smaller
    variable. Here’s the preceding code with these checks in place:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中唯一安全的解决方案是在尝试将值存入较小的变量之前，先将表达式的结果与上限和下限值进行比较。以下是加入这些检查后的代码：
- en: '[PRE5]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code gets pretty ugly. In C/C++, you’d probably want to turn this into
    a macro (`#define`) or a function so your code would be a bit more readable.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显得相当复杂。在 C/C++ 中，你可能希望将其转换为宏（`#define`）或函数，这样代码会更加易读。
- en: Some high-level languages (such as Free Pascal and Delphi) automatically sign-contract
    values and then check the value to ensure it fits in the destination operand.^([5](footnotes.xhtml#fn2_5a))
    Such languages raise some sort of exception (or stop the program) if a range violation
    occurs. To take corrective action, you’ll either need to write some exception-handling
    code or use an `if` statement sequence similar to the one in the C example just
    given.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级语言（例如 Free Pascal 和 Delphi）会自动进行符号收缩值转换，然后检查该值以确保它适合目标操作数。^([5](footnotes.xhtml#fn2_5a))
    这样的语言如果发生范围违反，会抛出某种异常（或停止程序）。要采取纠正措施，你需要编写一些异常处理代码，或者使用类似于 C 示例中给出的 `if` 语句序列。
- en: '**2.8 Saturation**'
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.8 饱和**'
- en: You can also reduce the size of an integer value through *[saturation](gloss01.xhtml#gloss01_220)*,
    which is useful when you’re willing to live with a possible loss of precision.
    To convert a value via saturation, you copy the LO bits of the larger object into
    the smaller object. If the larger value is outside the smaller object’s range,
    then you *clip* the larger value by setting the smaller object to the largest
    (or smallest) value within the smaller value’s range.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 *[饱和](gloss01.xhtml#gloss01_220)* 来减小整数值的大小，当你愿意接受可能的精度损失时，这非常有用。要通过饱和转换一个值，你需要将较大对象的低位（LO
    bits）复制到较小的对象中。如果较大的值超出了较小对象的范围，那么你就 *裁剪* 较大的值，将较小对象的值设置为该范围内的最大（或最小）值。
- en: For example, when converting a 16-bit signed integer to an 8-bit signed integer,
    if the 16-bit value is in the range –128 through +127, you simply copy the LO
    byte into the 8-bit object. If the 16-bit signed value is greater than +127, then
    you clip the value to +127 and store +127 into the 8-bit object. Likewise, if
    the value is less than –128, you clip the final 8-bit object to –128\. Saturation
    works the same way when you clip 32-bit values to smaller values.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在将一个 16 位有符号整数转换为 8 位有符号整数时，如果 16 位值的范围在 -128 到 +127 之间，你只需将低字节（LO byte）复制到
    8 位对象中。如果 16 位有符号值大于 +127，那么你就裁剪该值至 +127，并将 +127 存储到 8 位对象中。同样地，如果该值小于 -128，你就将最终的
    8 位对象裁剪至 -128。饱和操作在将 32 位值裁剪为较小值时，效果相同。
- en: If the larger value is outside the range of the smaller value, there will be
    a loss of precision during the conversion. While clipping the value is never desirable,
    sometimes it’s better than raising an exception or otherwise rejecting the calculation.
    For many applications, such as audio or video, the clipped result is still recognizable
    to the end user, so this is a reasonable conversion scheme.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果较大的值超出了较小值的范围，那么在转换过程中会丢失精度。虽然裁剪值并不是最理想的选择，但有时它比抛出异常或拒绝计算更好。对于许多应用程序，比如音频或视频，即使裁剪后的结果，最终用户依然能够识别，因此这是一种合理的转换方案。
- en: 'Many CPUs support saturation arithmetic in their special “multimedia extension”
    instruction sets—for example, the MMX/SSE/AVX instruction extensions on the Intel
    80x86 processor family. Most CPUs’ standard instruction sets, as well as most
    high-level languages, do not provide direct support for saturation, but the technique
    is not difficult. Consider the following Free Pascal/Delphi code, which uses saturation
    to convert a 32-bit integer to a 16-bit integer:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 CPU 支持其特殊的“多媒体扩展”指令集中的饱和运算——例如，英特尔 80x86 处理器系列的 MMX/SSE/AVX 指令扩展。大多数 CPU
    的标准指令集以及大多数高级语言并未直接支持饱和运算，但这种技术并不难实现。请看以下使用饱和技术将 32 位整数转换为 16 位整数的 Free Pascal/Delphi
    代码：
- en: '[PRE6]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**2.9 Binary-Coded Decimal Representation**'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.9 二进制编码十进制表示法**'
- en: The *[binary-coded decimal](gloss01.xhtml#gloss01_28) (BCD)* format, as its
    name suggests, encodes decimal values using a binary representation. Common general-purpose
    high-level languages (like C/C++, Pascal, and Java) rarely support decimal values.
    However, business-oriented programming languages (like COBOL and many database
    languages) do. So, if you’re writing code that interfaces with a database or some
    language that supports decimal arithmetic, you may need to deal with BCD representation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*[二进制编码十进制](gloss01.xhtml#gloss01_28)（BCD）* 格式，顾名思义，使用二进制表示法对十进制值进行编码。常见的通用高级语言（如
    C/C++、Pascal 和 Java）很少支持十进制值。然而，面向业务的编程语言（如 COBOL 和许多数据库语言）是支持的。因此，如果你正在编写与数据库或支持十进制算术的语言接口的代码，你可能需要处理
    BCD 表示。'
- en: BCD values consist of a sequence of nibbles, with each nibble representing a
    value in the range 0 to 9\. (The BCD format uses only 10 of the possible 16 values
    represented by a nibble.) With a byte we can represent values containing two decimal
    digits (0..99), as shown in [Figure 2-8](ch02.xhtml#ch02fig08). With a word, we
    can represent four decimal digits (0..9999). A double word can represent up to
    eight decimal digits.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: BCD 值由一系列 nibble 组成，每个 nibble 表示一个范围在 0 到 9 之间的值。（BCD 格式仅使用 nibble 可表示的 16 个值中的
    10 个。）使用一个字节可以表示包含两位十进制数字的值（0..99），如 [图 2-8](ch02.xhtml#ch02fig08) 所示。使用一个字，可以表示四位十进制数字（0..9999）。一个双字可以表示最多八位十进制数字。
- en: '![image](../images/02fig08.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig08.jpg)'
- en: '*Figure 2-8: BCD data representation in a byte*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：字节中的 BCD 数据表示*'
- en: An 8-bit BCD variable can represent values in the range 0 to 99, while that
    same 8 bits, holding a binary value, could represent values in the range 0 to
    255\. Likewise, a 16-bit binary value can represent values in the range 0 to 65,535,
    while a 16-bit BCD value can represent only about a sixth of those values (0..9999).
    Inefficient storage isn’t the only problem with BCD, though—BCD calculations also
    tend to be slower than binary calculations.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 8 位的 BCD 变量可以表示从 0 到 99 之间的值，而同样的 8 位二进制值则可以表示从 0 到 255 之间的值。同样，一个 16 位的二进制值可以表示从
    0 到 65,535 之间的值，而一个 16 位的 BCD 值只能表示其中约六分之一的值（0..9999）。不过，BCD 的问题不仅仅是存储效率低——BCD
    计算也往往比二进制计算慢。
- en: 'The BCD format does have two saving graces: it’s very easy to convert BCD values
    between the internal numeric representation and their decimal string representations,
    and it’s also very easy to encode multidigit decimal values in hardware when using
    BCD—for example, when using a set of dials, with each dial representing a single
    digit. For these reasons, you’re likely to see people using BCD in embedded systems
    (such as toaster ovens and alarm clocks) but rarely in general-purpose computer
    software.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: BCD 格式确实有两个优点：它非常容易在内部数字表示和十进制字符串表示之间转换 BCD 值，而且在使用 BCD 时，硬件编码多位十进制值也非常简单——例如，使用一组拨盘，每个拨盘表示一个数字。因此，你可能会在嵌入式系统（如烤面包机和闹钟）中看到
    BCD 的应用，但在通用计算机软件中很少见。
- en: A few decades ago, people thought that calculations involving BCD (or just decimal)
    arithmetic were more accurate than binary calculations. Therefore, they would
    often perform important calculations, like those involving monetary units, using
    decimal-based arithmetic. Certain calculations can produce more accurate results
    in BCD, but for most calculations, binary is more accurate. This is why most modern
    computer programs represent all values (including decimal values) in a binary
    form. For example, the Intel 80x86 *floating-point unit (FPU)* supports a pair
    of instructions for loading and storing BCD values. Internally, the FPU converts
    these BCD values to binary. It only uses BCD as an external (to the FPU) data
    format. This approach generally produces more accurate results.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，人们认为涉及 BCD（或仅十进制）算术的计算比二进制计算更为准确。因此，他们通常会使用基于十进制的算术来执行重要的计算，比如涉及货币单位的计算。某些计算在
    BCD 中可能会产生更准确的结果，但对于大多数计算来说，二进制更加准确。这就是为什么大多数现代计算机程序将所有值（包括十进制值）表示为二进制形式的原因。例如，Intel
    80x86 *浮点单元（FPU）* 支持一对指令来加载和存储 BCD 值。在内部，FPU 会将这些 BCD 值转换为二进制。它仅将 BCD 用作外部（FPU
    之外的）数据格式。这种方法通常会产生更准确的结果。
- en: '**2.10 Fixed-Point Representation**'
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.10 定点表示**'
- en: 'There are two ways computer systems commonly represent numbers with fractional
    components: fixed-point representation and floating-point representation.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统常用两种方式来表示带有小数部分的数字：定点表示和浮点表示。
- en: Back in the days when CPUs didn’t support floating-point arithmetic in hardware,
    fixed-point arithmetic was very popular with programmers writing high-performance
    software that dealt with fractional values. There’s less software overhead needed
    to support fractional values in a fixed-point format than in floating-point. However,
    CPU manufacturers added FPUs to their CPUs to support floating-point in hardware,
    and today, it’s fairly rare to see someone attempt fixed-point arithmetic on a
    general-purpose CPU. It’s usually more cost-effective to use the CPU’s native
    floating-point format.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当CPU不支持硬件浮点运算时，定点运算在编写高性能软件、处理小数值的程序员中非常流行。定点格式支持小数值所需的软件开销比浮点格式少。然而，CPU制造商在CPU中添加了FPU来支持硬件浮点运算，如今在通用CPU上很少有人尝试定点运算。通常，使用CPU的本地浮点格式更具成本效益。
- en: Although CPU manufacturers have worked hard at optimizing the floating-point
    arithmetic on their systems, in certain circumstances, carefully written assembly
    language programs that use fixed-point calculations will run faster than the equivalent
    floating-point code. Certain 3D gaming applications, for example, may produce
    faster computations using a 16:16 (16-bit integer, 16-bit fractional) format rather
    than a 32-bit floating-point format. Because there are some very good uses for
    fixed-point arithmetic, this section discusses fixed-point representation and
    fractional values using the fixed-point format.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CPU制造商已经努力优化其系统中的浮点运算，但在某些情况下，精心编写的汇编语言程序使用定点计算比等效的浮点代码运行得更快。例如，某些3D游戏应用可能使用16:16（16位整数，16位小数）格式，而不是32位浮点格式，从而产生更快的计算。由于定点运算有一些非常好的应用场景，本节将讨论定点表示法和使用定点格式的小数值。
- en: '**NOTE**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Chapter 4](ch04.xhtml#ch04) will discuss the floating-point format.*'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*[第4章](ch04.xhtml#ch04)将讨论浮点格式。*'
- en: 'As you’ve seen, positional numbering systems represent fractional values (values
    between 0 and 1) by placing digits to the right of the radix point. In the binary
    numbering system, each bit to the right of the binary point represents the value
    0 or 1 multiplied by some successive negative power of 2\. We represent that fractional
    component of a value using sums of binary fractions. For example, the value 5.25
    is represented by the binary value 101.01\. The conversion to decimal yields:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，位置编号系统通过将数字放置在基点右侧来表示小数值（介于0和1之间的值）。在二进制编号系统中，基点右侧的每一位代表值0或1，乘以2的某个连续负次方。我们使用二进制分数的和来表示值的小数部分。例如，值5.25被二进制表示为101.01。转换为十进制得到：
- en: 1 × 2² + 1 × 2⁰ + 1 × 2^(–2) = 4 + 1 + 0.25 = 5.25
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 1 × 2² + 1 × 2⁰ + 1 × 2^(–2) = 4 + 1 + 0.25 = 5.25
- en: When using a fixed-point binary format, you choose a particular bit in the binary
    representation and implicitly place the binary point before that bit. You choose
    the position of the binary point based on the number of significant bits you require
    in the fractional portion of the number. For example, if your values’ integer
    components can range from 0 to 999, you’ll need at least 10 bits to the left of
    the binary point to represent this range of values. If you require signed values,
    you’ll need an extra bit for the sign. In a 32-bit fixed-point format, this leaves
    either 21 or 22 bits for the fractional part, depending on whether your value
    is signed.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用定点二进制格式时，你选择二进制表示中的特定位，并隐式地将二进制点放在该位之前。你根据小数部分所需的有效位数来选择二进制点的位置。例如，如果你的值的整数部分范围从0到999，你将需要至少10个位在二进制点的左侧来表示这个范围的值。如果需要有符号值，你还需要额外的一个位来表示符号。在32位定点格式中，这将剩下21或22个位用于小数部分，具体取决于你的值是否是有符号的。
- en: 'Fixed-point numbers are a small subset of the real numbers. Because the number
    of values between any two integer values is infinite, fixed-point values cannot
    exactly represent every single one (doing so would require an infinite number
    of bits). With fixed-point representation, we have to approximate most of the
    real numbers. Consider the 8-bit fixed-point format, which uses 6 bits for the
    integer portion and 2 bits for the fractional component. The integer component
    can represent values in the range 0 to 63 (or signed values in the range –32 to
    +31). The fractional component can represent only four different values: 0.0,
    0.25, 0.5, and 0.75\. You cannot exactly represent 1.3 with this format; the best
    you can do is approximate it by choosing the value closest to it (1.25). This
    introduces error. You can reduce this error by adding further bits to the right
    of the binary point in your fixed-point format (at the expense of reducing the
    range of the integer component or adding more bits to your fixed-point format).
    For example, if you move to a 16-bit fixed-point format using an 8-bit integer
    and an 8-bit fractional component, then you can approximate 1.3 using the binary
    value 1.01001101\. The decimal equivalent is as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 定点数是实数的一个小子集。由于任何两个整数之间的值是无限的，定点值无法准确表示每一个值（做到这一点需要无限位数）。使用定点表示法时，我们必须逼近大多数实数。考虑8位定点格式，其中6位用于整数部分，2位用于分数部分。整数部分可以表示范围为0到63的值（或表示范围为–32到+31的带符号值）。分数部分只能表示四个不同的值：0.0、0.25、0.5和0.75。使用这种格式无法精确表示1.3；你能做的最好的就是选择最接近它的值（1.25）。这就引入了误差。你可以通过在定点格式的二进制小数点右侧添加更多位来减少这种误差（但这样会减少整数部分的范围，或者需要为定点格式添加更多位）。例如，如果你使用一个16位的定点格式，整数部分使用8位，分数部分使用8位，那么你可以通过二进制值1.01001101来逼近1.3。其十进制等价值如下：
- en: 1 + 0.25 + 0.03125 + 0.15625 + 0.00390625 = 1.30078125
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 0.25 + 0.03125 + 0.15625 + 0.00390625 = 1.30078125
- en: Adding more bits to the fractional component of your fixed-point number will
    give you a more accurate approximation of this value (the error is only 0.00078125
    using this format, compared to 0.05 in the previous format).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 向定点数的分数部分添加更多位数，将使该值的逼近更加精确（使用这种格式时误差仅为0.00078125，而使用之前的格式时误差为0.05）。
- en: In a fixed-point binary numbering system, there are certain values you can never
    accurately represent regardless of how many bits you add to the fractional part
    of your fixed-point representation (1.3 just happens to be such a value). This
    is probably the main reason why people (mistakenly) feel that decimal arithmetic
    is more accurate than binary arithmetic (particularly when working with decimal
    fractions like 0.1, 0.2, 0.3, and so on).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在定点二进制计数系统中，无论你向定点表示的分数部分添加多少位，总有一些值无法准确表示（1.3恰好是这样一个值）。这可能是人们（错误地）认为十进制运算比二进制运算更精确的主要原因（尤其是在处理像0.1、0.2、0.3等十进制小数时）。
- en: To contrast the comparative accuracy of the two systems, let’s consider a fixed-point
    decimal system (using BCD representation). If we choose a 16-bit format with 8
    bits for the integer portion and 8 bits for the fractional portion, we can represent
    decimal values in the range 0.0 to 99.99 with two decimal digits of precision
    to the right of the decimal point. We can exactly represent values like 1.3 in
    this BCD notation using a hex value like `$0130` (the implicit decimal point appears
    between the second and third digits in this number). As long as you use only the
    fractional values 0.00 to 0.99 in your computations, this BCD representation is
    more accurate than the binary fixed-point representation (using an 8-bit fractional
    component).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对比这两种系统的精度，我们考虑一个定点十进制系统（使用BCD表示法）。如果我们选择一个16位格式，其中8位用于整数部分，8位用于分数部分，那么我们可以表示范围为0.0到99.99的十进制值，小数点右侧有两位十进制精度。我们可以通过像`$0130`这样的十六进制值精确表示1.3（在这个数字中，隐含的小数点出现在第二位和第三位之间）。只要在计算中仅使用分数值0.00到0.99，这种BCD表示法比二进制定点表示法（使用8位分数部分）更精确。
- en: 'In general, however, the binary format is more accurate. The binary format
    lets you exactly represent 256 different fractional values, whereas BCD lets you
    represent only 100\. If you pick an arbitrary fractional value, it’s likely the
    binary fixed-point representation provides a better approximation than the decimal
    format (because there are over two and a half times as many binary versus decimal
    fractional values). (You can extend this comparison to larger formats: for example,
    with a 16-bit fractional component, the decimal/BCD fixed-point format gives you
    exactly four digits of precision; the binary format, on the other hand, offers
    over six times the resolution—65,536 rather than 10,000 fractional values.) Decimal
    fixed-point format has the advantage only when you regularly work with the fractional
    values that it can exactly represent. In the United States, monetary computations
    commonly produce these fractional values, so programmers figured the decimal format
    is better for monetary computations. However, given the accuracy most financial
    computations require (generally four digits to the right of the decimal point
    is the minimum precision), it’s usually better to use a binary format.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，二进制格式更为精确。二进制格式允许你精确表示256个不同的分数值，而BCD格式只能表示100个。如果你选择一个任意的分数值，那么二进制定点表示法通常能比十进制格式提供更好的近似值（因为二进制分数值的数量是十进制的两倍多）。(你可以将这个比较扩展到更大的格式：例如，使用16位分数部分，十进制/BCD定点格式提供精确的四位数字精度；而二进制格式则提供超过六倍的分辨率——65,536个分数值，而不是10,000个。)
    十进制定点格式只有在你经常处理它能精确表示的分数值时才有优势。在美国，货币计算通常会产生这些分数值，因此程序员认为十进制格式在货币计算中更好。然而，考虑到大多数金融计算要求的精度（通常是小数点后四位是最小精度），通常使用二进制格式更好。
- en: If you absolutely, positively need to exactly represent the fractional values
    between 0.00 and 0.99 with at least two digits of precision, the binary fixed-point
    format is not a viable solution. Fortunately, you don’t have to use a decimal
    format; as you’ll soon see, there are other binary formats that will let you exactly
    represent these values.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要精确表示0.00到0.99之间的分数值，并且要求至少有两位数字的精度，那么二进制定点格式就不是一个可行的解决方案。幸运的是，你不必使用十进制格式；正如你将很快看到的，还有其他二进制格式可以让你精确表示这些值。
- en: '**2.11 Scaled Numeric Formats**'
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.11 缩放数字格式**'
- en: Fortunately, there’s a numeric representation that combines the exact representation
    of certain decimal fractions with the precision of the binary format. Known as
    the [*scaled numeric* format](gloss01.xhtml#gloss01_223), this representation
    is also efficient to use and doesn’t require any special hardware.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种数字表示方法，它结合了某些十进制分数的精确表示和二进制格式的精度。这个格式被称为[*缩放数字*格式](gloss01.xhtml#gloss01_223)，它在使用时也很高效，并且不需要任何特殊硬件。
- en: Another advantage of the scaled numeric format is that you can choose any base,
    not just decimal, for your format. For example, if you’re working with ternary
    (base-3) fractions, you can multiply your original input value by 3 (or a power
    of 3) and exactly represent values like ¹/[3], ²/[3], ⁴/[9], ⁷/[27], and so on—something
    you can’t do in either the binary or decimal numbering systems.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放数字格式的另一个优点是，你可以选择任何进制，而不仅仅是十进制。例如，如果你处理的是三进制（基数为3）分数，你可以将原始输入值乘以3（或3的幂），并精确表示像¹/[3]、²/[3]、⁴/[9]、⁷/[27]这样的值——这是在二进制或十进制数字系统中无法做到的。
- en: To represent fractional values, you multiply your original value by some value
    that converts the fractional component to a whole number. For example, if you
    want to maintain two decimal digits of precision to the right of the decimal point,
    multiply your values by 100 upon input. This translates values like 1.3 to 130,
    which we can exactly represent using an integer value. Assuming you do this calculation
    with all your fractional values (and they have the same two digits of precision
    to the right of the decimal point), you can manipulate your values using standard
    integer arithmetic operations. For example, if you have the values 1.5 and 1.3,
    their integer conversion produces 150 and 130\. If you add these two values, you
    get 280 (which corresponds to 2.8). When you need to output these values, you
    divide them by 100 and emit the quotient as the integer portion of the value and
    the remainder (zero-extended to two digits, if necessary) as the fractional component.
    Other than needing to write specialized input and output routines that handle
    the multiplication and division by 100 (as well as dealing with the decimal point),
    you’ll find that this scaled numeric scheme is almost as easy as doing regular
    integer calculations.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示分数值，你将原始值乘以某个数值，将分数部分转换为整数。例如，如果你希望在小数点右边保持两位精度，输入时将数值乘以 100。这将类似于将 1.3
    转换为 130，我们可以精确地使用整数表示。如果你对所有的分数值都进行这样的转换（并且它们都在小数点右边有相同的两位精度），那么你可以使用标准的整数运算操作来处理这些数值。例如，如果你有值
    1.5 和 1.3，它们的整数转换分别为 150 和 130。将这两个值相加，你得到 280（这对应于 2.8）。当你需要输出这些值时，你将它们除以 100，并将商作为整数部分，余数（如果需要，零扩展至两位）作为分数部分。除了需要编写专门的输入和输出例程来处理乘以
    100 和除以 100（以及处理小数点）外，你会发现这种缩放数字方案几乎和普通的整数运算一样简单。
- en: If you scale your values as described here, you’ve limited the maximum range
    of the integer portion of your numbers. For example, if you need two decimal digits
    of precision to the right of your decimal point (meaning you multiply the original
    value by 100), then you may only represent (unsigned) values in the range 0 to
    42,949,672 rather than the normal range of 0 to 4,294,967,296.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照这里描述的方式缩放数值，那么你限制了数字的整数部分的最大范围。例如，如果你需要在小数点右边保留两位精度（即将原始值乘以 100），那么你只能表示（无符号）范围为
    0 到 42,949,672 的值，而不是正常范围 0 到 4,294,967,296。
- en: When you’re doing addition or subtraction with a scaled format, both operands
    must have the same scaling factor. If you’ve multiplied the left operand by 100,
    you must multiply the right operand by 100 as well. For example, if you’ve scaled
    the variable `i10` by 10 and you’ve scaled the variable `j100` by 100, you need
    to either multiply `i10` by 10 (to scale it by 100) or divide `j100` by 10 (to
    scale it down to 10) before attempting to add or subtract these two numbers. This
    ensures that both operands have the radix point in the same position (note that
    this applies to literal constants as well as to variables).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用缩放格式进行加法或减法时，两个操作数必须具有相同的缩放因子。如果你将左边的操作数乘以 100，那么右边的操作数也必须乘以 100。例如，如果你将变量`i10`缩放了
    10，且将变量`j100`缩放了 100，那么你需要将`i10`乘以 10（将其缩放至 100）或将`j100`除以 10（将其缩放至 10），然后才能进行加法或减法运算。这样可以确保两个操作数的小数点位置相同（注意，这适用于文字常量和变量）。
- en: 'In multiplication and division operations, the operands do not require the
    same scaling factor prior to the operation. However, once the operation is complete,
    you may need to adjust the result. Suppose you have two values you’ve scaled by
    100 to produce two digits of precision after the decimal point, `i = 25` (0.25)
    and `j = 1` (0.01). If you compute `k = i * j` using standard integer arithmetic,
    you’ll get 25 (25 × 1 = 25), which is interpreted as 0.25, but the result should
    be 0.0025\. The computation is correct; the problem is understanding how the multiplication
    operator works. We’re actually computing:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在乘法和除法操作中，操作数在运算之前不需要相同的缩放因子。然而，一旦运算完成，你可能需要调整结果。假设你有两个值，分别将它们缩放了 100 来保留小数点后两位精度，`i
    = 25`（0.25）和 `j = 1`（0.01）。如果你使用标准的整数运算计算`k = i * j`，你将得到 25（25 × 1 = 25），这被解释为
    0.25，但结果应该是 0.0025。计算是正确的；问题在于理解乘法运算符的工作原理。实际上，我们在计算的是：
- en: (0.25 × (100)) × (0.01 × (100)) = 0.25 × 0.01 × (100 × 100) (commutative laws
    allow this) = 0.0025 × (10,000) = 25
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: (0.25 × (100)) × (0.01 × (100)) = 0.25 × 0.01 × (100 × 100)（交换律允许这样做）= 0.0025
    × (10,000) = 25
- en: The final result actually gets scaled by 10,000 because both `i` and `j` have
    been multiplied by 100; when you multiply their values, you wind up with a value
    multiplied by 10,000 (100 × 100) rather than 100\. To solve this problem, you
    should divide the result by the scaling factor once the computation is complete.
    For example, `k = (i * j)/100`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果实际上会被放大10000倍，因为`i`和`j`都被乘以了100；当你乘以它们的值时，结果会是乘以10000（100 × 100），而不是100。为了解决这个问题，在计算完成后，你应该将结果除以缩放因子。例如，`k
    = (i * j)/100`。
- en: 'The division operation suffers from a similar problem. Suppose we have the
    values `m = 500` (5.0) and `n = 250` (2.5) and we want to compute `k = m/n`. We
    would normally expect to get the result 200 (2.0, which is 5.0/2.5). However,
    here’s what we’re actually computing:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 除法操作也有类似的问题。假设我们有`m = 500`（5.0）和`n = 250`（2.5），并且我们想计算`k = m/n`。我们通常期望得到200（2.0，5.0/2.5）的结果。然而，实际上我们正在计算的是：
- en: (5 × 100) / (2.5 × 100) = 500/250 = 2
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: (5 × 100) / (2.5 × 100) = 500/250 = 2
- en: At first blush this may look correct, but the result is really 0.02 after you
    factor in the scaling operation. The result we need is 200 (2.0). Division by
    the scaling factor eliminates the scaling factor in the final result. Therefore,
    to properly compute the result, we need to compute `k = 100 * m/n`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始看起来这似乎是正确的，但当你考虑到缩放操作后，结果实际上是0.02。我们需要的结果是200（2.0）。除以缩放因子会在最终结果中消除缩放因子。因此，为了正确计算结果，我们需要计算`k
    = 100 * m/n`。
- en: Multiplication and division place a limit on the precision you have available.
    If you have to premultiply the dividend by 100, then the dividend must be at least
    100 times smaller than the largest possible integer value, or an overflow will
    occur (producing an incorrect result). Likewise, when you’re multiplying two scaled
    values, the final result must be 100 times less than the maximum integer value,
    or an overflow will occur. Because of these issues, you may need to set aside
    additional bits or work with small numbers when using scaled numeric representation.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法和除法对你可用的精度有限制。如果你必须先将被除数乘以100，那么被除数必须至少比最大整数值小100倍，否则将发生溢出（产生错误的结果）。同样，当你乘以两个缩放值时，最终结果必须比最大整数值小100倍，否则也会发生溢出。由于这些问题，在使用缩放数值表示时，你可能需要保留额外的位或使用小数字。
- en: '**2.12 Rational Representation**'
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.12 有理数表示法**'
- en: One big problem with the fractional representations we’ve seen is that they
    provide a close approximation, but not an exact representation, for all rational
    values.^([6](footnotes.xhtml#fn2_6a)) For example, in binary or decimal you cannot
    exactly represent the value ¹/[3]. You could switch to a ternary (base-3) numbering
    system and exactly represent ¹/[3] [, but then you wouldn’t be able to exactly
    represent fractional values like ¹/[2] or ¹/[10]. We need a numbering system that
    can represent *any* rational fractional value.]
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的分数表示法的一个大问题是，它们提供的是一个近似值，而不是一个精确的表示，适用于所有有理数值。^([6](footnotes.xhtml#fn2_6a))
    例如，在二进制或十进制中，无法精确表示值¹/[3]。你可以切换到三进制（基数为3）的编号系统，并精确表示¹/[3]，但这样你就无法精确表示像¹/[2]或¹/[10]这样的分数值。我们需要一个可以表示*任何*有理分数值的编号系统。
- en: Rational representation uses pairs of integers to represent fractional values.
    One integer represents the numerator (*n*) of a fraction, and the other represents
    the denominator (*d*). The actual value is equal to *n*/*d*. As long as *n* and
    *d* are “relatively prime” (that is, not both evenly divisible by the same value),
    this scheme provides a good representation for fractional values within the bounds
    of the integer representation you’re using for *n* and *d*. Arithmetic is quite
    easy; you use the same algorithms to add, subtract, multiply, and divide fractional
    values that you learned in grade school when dealing with fractions. However,
    certain operations may produce really large numerators or denominators (to the
    point where you get integer overflow in these values). Other than this problem,
    you can represent a wide range of fractional values using this scheme.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数表示法使用整数对来表示分数值。一个整数表示分数的分子（*n*），另一个表示分母（*d*）。实际的值等于*n*/*d*。只要*n*和*d*是“互质的”（即，不是都能被同一个数整除），这种方案提供了一个很好的分数值表示，在你为*n*和*d*使用的整数表示范围内。算术运算相当简单；你可以使用在小学学习分数时学到的相同算法来加、减、乘、除分数值。然而，某些运算可能会产生非常大的分子或分母（以至于你会遇到整数溢出）。除了这个问题外，你可以使用这种方案表示广泛的分数值。
- en: '**2.13 For More Information**'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.13 更多信息**'
- en: 'Knuth, Donald E. *The Art of Computer Programming, Volume 2: Seminumerical
    Algorithms*. 3rd ed. Boston: Addison-Wesley, 1998.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth, Donald E. *计算机程序设计艺术，第2卷：半数字算法*。第3版。波士顿：Addison-Wesley，1998年。
