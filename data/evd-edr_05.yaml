- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">IMAGE-LOAD
    AND REGISTRY NOTIFICATIONS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">图像加载和注册表通知</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: The last two kinds of notification callback routines we’ll cover in this book
    are image-load notifications and registry notifications. An *image-load notification*
    occurs whenever an executable, DLL, or driver is loaded into memory on the system.
    A *registry notification* is triggered when specific operations in the registry
    occur, such as key creation or deletion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将介绍的最后两种通知回调例程是图像加载通知和注册表通知。*图像加载通知*会在可执行文件、DLL或驱动程序加载到系统内存时发生。*注册表通知*会在注册表发生特定操作时触发，例如键值创建或删除。
- en: In addition to these notification types, in this chapter we’ll also cover how
    EDRs commonly rely on image-load notifications for a technique called *KAPC injection*,
    which is used to inject their function-hooking DLLs. Lastly, we’ll discuss an
    evasion method that targets an EDR’s driver directly, potentially bypassing all
    the notification types we’ve discussed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些通知类型，本章还将讨论EDR如何常常依赖图像加载通知来进行一种名为*KAPC注入*的技术，该技术用于注入它们的函数钩子DLL。最后，我们将讨论一种针对EDR驱动程序的规避方法，这可能绕过我们讨论过的所有通知类型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Image-Load Notifications Work</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">图像加载通知的工作原理</samp>
- en: By collecting image-load telemetry, we can gain extremely valuable information
    about a process’s dependencies. For example, offensive tools that use in-memory
    .NET assemblies, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp>
    command in Cobalt Strike’s Beacon, routinely load the common language runtime
    *clr.dll* into their processes. By correlating an image load of *clr.dll* with
    certain attributes in the process’s PE header, we can identify non-.NET processes
    that load *clr.dll*, potentially indicating malicious behavior.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过收集图像加载遥测信息，我们可以获得关于进程依赖关系的极为宝贵的信息。例如，使用内存中.NET程序集的攻击工具，如Cobalt Strike Beacon中的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</sup>命令，通常将公共语言运行时*clr.dll*加载到其进程中。通过将*clr.dll*的图像加载与进程的PE头中的某些属性关联，我们可以识别加载*clr.dll*的非.NET进程，这可能表明恶意行为。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a Callback
    Routine</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">注册回调例程</samp>
- en: The kernel facilitates these image-load notifications through the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetLoadImageNotifyRoutine()</samp>
    API. If a driver wants to receive these events, the developers simply pass in
    their callback function as the only parameter to that API, as shown in [Listing
    5-1](#list5-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过<samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetLoadImageNotifyRoutine()</samp>
    API来实现这些图像加载通知。如果驱动程序想要接收这些事件，开发人员只需将他们的回调函数作为唯一参数传递给该API，如[清单 5-1](#list5-1)所示。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: Registering an image-load callback routine'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-1：注册图像加载回调例程
- en: Now the system will invoke the internal callback function <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageLoadNotificationCallback()</samp>
    each time a new image is loaded into a process.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，系统将在每次将新图像加载到进程时，调用内部回调函数<samp class="SANS_TheSansMonoCd_W5Regular_11">ImageLoadNotificationCallback()</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing the Callback
    Routines Registered on a System</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查看系统上注册的回调例程</samp>
- en: The system also adds a pointer to the function to an array, <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspLoadImageNotifyRoutine()</samp>.
    We can traverse this array in the same way as the array used for process-notification
    callbacks discussed in [Chapter 3](chapter3.xhtml). In [Listing 5-2](#list5-2),
    we do this to list the image-load callbacks registered on the system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 系统还将一个指向该函数的指针添加到一个数组中，<samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspLoadImageNotifyRoutine()</samp>。我们可以像遍历[第3章](chapter3.xhtml)中讨论的进程通知回调数组那样，遍历这个数组。在[清单
    5-2](#list5-2)中，我们这样做以列出系统上注册的图像加载回调。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: Enumerating image-load callbacks'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-2：枚举图像加载回调
- en: There are notably fewer callbacks registered here than there were for process-creation
    notifications. Process notifications have more non-security uses than image loads,
    so developers are more interested in implementing them. Conversely, image loads
    are a critical datapoint for EDRs, so we can expect to see any EDRs loaded on
    the system here alongside Defender <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp>
    and the Customer Interaction Tracker <samp class="SANS_TheSansMonoCd_W5Regular_11">[1]</samp>.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里注册的回调函数明显少于进程创建通知时注册的回调函数。进程通知的非安全用途比图像加载更多，因此开发人员更有兴趣实现它们。相反，图像加载是EDR（终端检测与响应）的一项关键数据点，因此我们可以预期在系统中加载的任何EDR工具将与Defender
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp> 和客户交互跟踪器 <samp class="SANS_TheSansMonoCd_W5Regular_11">[1]</samp>
    一起出现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Collecting Information
    from Image Loads</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从图像加载中收集信息</samp>
- en: When an image is loaded, the callback routine receives a pointer to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IMAGE_INFO</samp> structure, defined in
    [Listing 5-3](#list5-3). The EDR can collect telemetry from it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载图像时，回调例程会接收到指向一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">IMAGE_INFO</samp>
    结构的指针，该结构在[清单 5-3](#list5-3)中定义。EDR可以从中收集遥测数据。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 5-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IMAGE_INFO</samp>
    structure definition'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-3：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IMAGE_INFO</samp>
    结构定义
- en: This structure has a few particularly interesting fields. First, <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemModeImage</samp>
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> if the image
    is mapped to user address space, such as in DLLs and EXEs. If this field is set
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the image is a driver
    being loaded into kernel address space. This is useful to an EDR because malicious
    code that loads into kernel mode is generally more dangerous than code that loads
    into user mode.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构有一些特别有趣的字段。首先，<samp class="SANS_TheSansMonoCd_W5Regular_11">SystemModeImage</samp>
    如果图像映射到用户地址空间（如DLL和EXE文件），则设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。如果该字段设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，则表示该图像是加载到内核地址空间中的驱动程序。对于EDR来说，这非常有用，因为加载到内核模式的恶意代码通常比加载到用户模式的代码更危险。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageSignatureLevel</samp>
    field represents the signature level assigned to the image by Code Integrity,
    a Windows feature that validates digital signatures, among other things. This
    information is useful for systems that implement some type of software restriction
    policy. For example, an organization might require that certain systems in the
    enterprise run signed code only. These signature levels are constants defined
    in the *ntddk.h* header and shown in [Listing 5-4](#list5-4).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageSignatureLevel</samp> 字段表示Code
    Integrity分配给图像的签名级别，Code Integrity是Windows的一项功能，除了验证数字签名外，还具有其他功能。这些信息对实现某种类型软件限制策略的系统非常有用。例如，某个组织可能要求企业中的某些系统仅运行签名代码。这些签名级别是定义在*ntddk.h*头文件中的常量，并显示在[清单
    5-4](#list5-4)中。
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-4: Image signature levels'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-4：图像签名级别
- en: The purpose of each value isn’t well documented, but some are self-explanatory.
    For instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_SIGNING_LEVEL_UNSIGNED</samp>
    is for unsigned code, <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_SIGNING_LEVEL_WINDOWS</samp>
    indicates that the image is an operating system component, and <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_SIGNING_LEVEL_ANTIMALWARE</samp>
    has something to do with antimalware protections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值的用途并没有很好的文档说明，但其中一些是显而易见的。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">SE_SIGNING_LEVEL_UNSIGNED</samp>
    用于未签名代码，<samp class="SANS_TheSansMonoCd_W5Regular_11">SE_SIGNING_LEVEL_WINDOWS</samp>
    表示该图像是操作系统组件，<samp class="SANS_TheSansMonoCd_W5Regular_11">SE_SIGNING_LEVEL_ANTIMALWARE</samp>
    与反恶意软件保护有关。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageSignatureType</samp>
    field, a companion to <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageSignatureLevel</samp>,
    defines the signature type with which Code Integrity has labeled the image to
    indicate how the signature was applied. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_IMAGE_SIGNATURE_TYPE</samp>
    enumeration that defines these values is shown in [Listing 5-5](#list5-5).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageSignatureType</samp> 字段是与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageSignatureLevel</samp> 相关的字段，定义了Code
    Integrity标记图像的签名类型，以指示签名的应用方式。定义这些值的 <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_IMAGE_SIGNATURE_TYPE</samp>
    枚举在[清单 5-5](#list5-5)中显示。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 5-5: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SE_IMAGE_SIGNATURE_TYPE</samp>
    enumeration'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-5：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SE_IMAGE_SIGNATURE_TYPE</samp>
    枚举
- en: The Code Integrity internals related to these properties are outside the scope
    of this chapter, but the most commonly encountered are <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImageSignatureNone</samp>
    (meaning the file is unsigned), <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImageSignatureEmbedded</samp>
    (meaning the signature is embedded in the file), and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImageSignatureCache</samp>
    (meaning the signature is cached on the system).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些属性相关的代码完整性内部实现超出了本章的范围，但最常遇到的有 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImageSignatureNone</samp>（表示文件未签名）、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeImageSignatureEmbedded</samp>（表示签名已嵌入文件中）和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImageSignatureCache</samp>（表示签名已缓存在系统中）。
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePartialMap</samp>
    value is nonzero, the image being mapped into the process’s virtual address space
    isn’t complete. This value, added in Windows 10, is set in cases such as when
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!MapViewOfFile()</samp>
    is invoked to map a small portion of a file whose size is larger than that of
    the process’s address space. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageBase</samp>
    field contains the base address into which the image will be mapped, in either
    user or kernel address space, depending on the image type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePartialMap</samp> 的值非零，说明正在映射到进程虚拟地址空间中的映像并不完整。这个值是在
    Windows 10 中加入的，用于表示当调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!MapViewOfFile()</samp>
    映射一个文件的部分内容时的情况，特别是当文件的大小大于进程的地址空间时。<samp class="SANS_TheSansMonoCd_W5Regular_11">ImageBase</samp>
    字段包含映像将被映射到的基地址，取决于映像类型，它可以是在用户空间或内核空间中的地址。
- en: It is worth noting that when the image-load notification reaches the driver,
    the image is already mapped. This means that the code inside the DLL is in the
    host process’s virtual address space and ready to be executed. You can observe
    this behavior with WinDbg, as demonstrated in [Listing 5-6](#list5-6).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当映像加载通知到达驱动程序时，映像已经被映射。这意味着 DLL 内的代码已经在宿主进程的虚拟地址空间中，并准备好执行。你可以通过 WinDbg
    观察这种行为，如[列表 5-6](#list5-6)所示。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-6: Extracting the image name from an image-load notification'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-6：从映像加载通知中提取映像名称
- en: We first set a breakpoint on the function responsible for traversing the array
    of registered callback routines. Then we investigate the RCX register when the
    debugger breaks. Remember that the first parameter passed to the callback routine,
    stored in RCX, is a Unicode string containing the name of the image being loaded
    ❶.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在负责遍历注册回调例程数组的函数上设置一个断点。然后，当调试器中断时，我们调查 RCX 寄存器。记住，传递给回调例程的第一个参数存储在 RCX
    中，它是一个包含正在加载的映像名称的 Unicode 字符串 ❶。
- en: Once we have this image in our sights, we can view the current process’s VADs,
    shown in [Listing 5-7](#list5-7), to see which images have been loaded into the
    current process, where, and how.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们锁定了这个映像，我们可以查看当前进程的 VADs，如[列表 5-7](#list5-7)所示，了解哪些映像已经加载到当前进程中，加载的位置和方式。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 5-7: Checking the VADs to find the image to be loaded'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-7：检查 VADs 以找到要加载的映像
- en: The last line of the output shows that the target of the image-load notification,
    *ntdll.dll* in our example, is labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp>.
    In the case of EDR, this means that we know the DLL is located on disk and copied
    into memory. The loader needs to do a few things, such as resolving the DLL’s
    dependencies, before the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllMain()</samp>
    function inside the DLL is called and its code begins to execute. This is particularly
    relevant only in situations where the EDR is working in prevention mode and might
    take action to stop the DLL from executing in the target process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后一行显示，映像加载通知的目标，即我们的示例中的 *ntdll.dll*，被标记为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp>。在
    EDR 的情况下，这意味着我们知道 DLL 位于磁盘上并已复制到内存中。加载程序需要做一些事情，如解析 DLL 的依赖项，然后才会调用 DLL 内的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DllMain()</samp> 函数，并开始执行其代码。这在 EDR 处于预防模式并可能采取行动阻止
    DLL 在目标进程中执行的情况下尤其重要。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Image-Load Notifications with
    Tunneling Tools</samp>
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用隧道工具规避映像加载通知</samp>
- en: An evasion tactic that has gained popularity over the past few years is to proxy
    one’s tooling rather than run it on the target. When an attacker avoids running
    post-exploitation tooling on the host, they remove many host-based indicators
    from the collection data, making detection extremely difficult for the EDR. Most
    adversary toolkits contain utilities that collect network information or act on
    other hosts in the environment. However, these tools generally require only a
    valid network path and the ability to authenticate to the system with which they
    want to interact. So attackers don’t have to execute them on a host in the target
    environment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，一种日益流行的规避策略是代理工具，而不是在目标上运行它。当攻击者避免在主机上运行后期利用工具时，他们可以从收集的数据中去除许多主机上的指示，从而使
    EDR 的检测变得极为困难。大多数对手工具包包含收集网络信息或作用于环境中其他主机的实用程序。然而，这些工具通常只需要一个有效的网络路径和能够对其想要交互的系统进行身份验证的能力。因此，攻击者不需要在目标环境中的主机上执行这些工具。
- en: One way of staying off the host is by proxying the tools from an outside computer
    and then routing the tool’s traffic through the compromised host. Although this
    strategy has recently become more common for its usefulness in evading EDR solutions,
    the technique isn’t new, and most attackers have performed it for years by using
    the Metasploit Framework’s auxiliary modules, particularly when their complex
    tool sets won’t work on the target for some reason. For example, attackers sometimes
    wish to make use of the tools provided by Impacket, a collection of classes written
    in Python for working with network protocols. If a Python interpreter isn’t available
    on the target machine, the attackers need to hack together an executable file
    to drop and execute on the host. This creates a lot of headaches and limits the
    operational viability of many toolkits, so attackers turn to proxying instead.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一种保持远离目标主机的方法是通过外部计算机代理工具，然后将工具的流量通过被攻破的主机路由。尽管这种策略由于其在规避 EDR 解决方案方面的有效性近年来变得越来越常见，但这一技术并不新鲜，大多数攻击者多年来一直通过使用
    Metasploit Framework 的辅助模块来实施，尤其是当他们的复杂工具集因某种原因无法在目标上正常工作时。例如，攻击者有时希望利用 Impacket
    提供的工具集，这是一个用 Python 编写的类库，用于处理网络协议。如果目标机器上没有 Python 解释器，攻击者就需要构建一个可执行文件来投放并在主机上执行。这会带来很多麻烦，并限制了许多工具包的操作性，因此攻击者转向了代理。
- en: Many command-and-control agents, such as Beacon and its <samp class="SANS_TheSansMonoCd_W5Regular_11">socks</samp>
    command, support some form of proxying. [Figure 5-1](#fig5-1) shows a common proxying
    architecture.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令与控制代理，例如 Beacon 及其 <samp class="SANS_TheSansMonoCd_W5Regular_11">socks</samp>
    命令，支持某种形式的代理。[图 5-1](#fig5-1) 显示了一个常见的代理架构。
- en: '![](../images/Figure5-1.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: A generic proxying
    architecture</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-1：一种通用的代理架构</samp>
- en: After deploying the command-and-control agent in the target environment, operators
    will start a proxy on their server and then associate the agent with the proxy.
    From thereon, all traffic routed through the proxy will pass through a *bastion*,
    a host used to obfuscate the true location of the command-and-control server,
    to the deployed agent, allowing the operator to tunnel their tools into the environment.
    An operator may then use tools such as Proxychains or Proxifier to force their
    post-exploitation tooling, running on some external host, to ship its traffic
    through the proxy and act as if it were running on the internal environment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标环境中部署命令与控制代理后，操作员会在其服务器上启动代理，然后将代理与该代理关联。从此以后，所有通过代理路由的流量将通过一个 *堡垒*，即用于混淆命令与控制服务器真实位置的主机，传递到已部署的代理，从而允许操作员将其工具通过代理隧道进入该环境。操作员可以使用如
    Proxychains 或 Proxifier 等工具，强制将其后期利用工具（运行在外部主机上）的流量通过代理，并表现得像是在内部环境中运行一样。
- en: There is, however, one significant downside to this tactic. Most offensive security
    teams use noninteractive sessions, which introduce a planned delay between the
    command-and-control agent’s check-ins with its server. This allows the beaconing
    behavior to blend into the system’s normal traffic by reducing the total volume
    of interactions and matching the system’s typical communications profile. For
    example, in most environments, you wouldn’t find much traffic between a workstation
    and a banking site. By increasing the interval between check-ins to a server posing
    as a legitimate banking service, attackers can blend into the background. But
    when proxying, this practice becomes a substantial headache, as many tools aren’t
    built to support high-latency channels. Imagine trying to browse a web page but
    only being allowed to make one request per hour (and then having to wait another
    hour for the results).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一策略有一个显著的缺点。大多数进攻安全团队使用非交互式会话，这会在命令与控制代理与其服务器的签到之间引入预定延迟。这允许信标行为融入系统的正常流量，通过减少交互总量并匹配系统的典型通信模式。例如，在大多数环境中，你不会发现工作站与银行网站之间有大量流量。通过将签到间隔增加到与伪装成合法银行服务的服务器之间，攻击者可以将自己融入到背景中。但当进行代理时，这一做法就成了一个难题，因为许多工具并未构建为支持高延迟通道。试想一下，你在浏览网页时每小时只能发出一次请求（然后又得等一个小时才能看到结果）。
- en: To work around this, many operators will reduce the check-in intervals to nearly
    zero, creating an interactive session. This lessens network latency, allowing
    the post-exploitation tooling to run without delay. However, because nearly all
    command-and-control agents use a single communications channel for check-ins,
    tasking, and the sending of output, the volume of traffic over this single channel
    can become significant, tipping off defenders that suspicious beaconing activity
    is taking place. This means attackers must make some trade-offs between host-based
    and network-based indicators with respect to their operating environment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这一点，许多操作者会将签到间隔缩短至接近零，从而创建交互式会话。这减少了网络延迟，使得后期利用工具可以毫无延迟地运行。然而，由于几乎所有的命令与控制代理都使用单一的通信通道进行签到、任务指派和输出发送，因此通过该单一通道的流量量可能会变得很大，导致防御者注意到可疑的信标活动正在发生。这意味着攻击者必须在主机级和网络级指示符之间做出一定的权衡，以适应其操作环境。
- en: As EDR vendors enhance their ability to identify beaconing traffic, offensive
    teams and developers will continue to advance their tradecraft to evade detection.
    One of the next logical steps in accomplishing this is to use multiple channels
    for command-and-control tasking rather than only one, either by employing a secondary
    tool, such as gTunnel, or by building this support into the agent itself. [Figure
    5-2](#fig5-2) shows an example of how this could work.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随着EDR厂商增强识别信标流量的能力，进攻团队和开发者将继续提升其技术手段以躲避检测。实现这一目标的下一个合乎逻辑的步骤之一，是使用多个频道进行命令与控制任务，而不是仅仅使用一个，可能通过使用次级工具，如gTunnel，或者将该支持集成到代理本身。[图5-2](#fig5-2)展示了这一方法的一个示例。
- en: '![](../images/Figure5-2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: The gTunnel proxying
    architecture</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-2：gTunnel代理架构</samp>
- en: In this example, we still use the existing command-and-control channel to control
    the agent deployed on the compromised host, but we also add a gTunnel channel
    that allows us to proxy our tooling. We execute the tooling on our attacker host,
    virtually eliminating the risk of host-based detection, and route the tool’s network
    traffic through gTunnel to the compromised system, where it continues as if it
    originated from the compromised host. This still leaves open the opportunity for
    defenders to detect the attack using network-based detections, but it greatly
    reduces the attacker’s footprint on the host.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们仍然使用现有的命令与控制通道来控制部署在被攻陷主机上的代理，但我们还添加了一个gTunnel通道，允许我们代理我们的工具。我们在攻击者主机上执行这些工具，几乎消除了基于主机的检测风险，并将工具的网络流量通过gTunnel路由到被攻陷的系统，在那里它继续像是来自被攻陷主机一样。这仍然给防御者提供了基于网络的检测攻击的机会，但它大大减少了攻击者在主机上的痕迹。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Triggering KAPC Injection with Image-Load
    Notifications</samp>
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">触发KAPC注入与图像加载通知</samp>
- en: '[Chapter 2](chapter2.xhtml) discussed how EDRs often inject function-hooking
    DLLs into newly created processes to monitor calls to certain functions of interest.
    Unfortunately for vendors, there is no formally supported way of injecting a DLL
    into a process from kernel mode. Ironically, one of their most common methods
    of doing so is a technique often employed by the malware they seek to detect:
    APC injection. Most EDR vendors use KAPC injection, a procedure that instructs
    the process being spawned to load the EDR’s DLL despite it not being explicitly
    linked to the image being executed.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](chapter2.xhtml)讨论了EDR如何经常将功能钩子DLL注入新创建的进程，以监控对某些感兴趣函数的调用。对于厂商而言，不幸的是，从内核模式将DLL注入进程并没有正式支持的方法。具有讽刺意味的是，他们最常用的其中一种方法实际上是恶意软件常用的技术：APC注入。大多数EDR厂商使用KAPC注入，这一过程指示正在生成的进程加载EDR的DLL，尽管它并未显式地链接到正在执行的映像中。'
- en: 'To inject a DLL, EDRs can’t simply write the contents of the image into the
    process’s virtual address space however they wish. The DLL must be mapped in a
    manner that follows the PE format. To achieve this from kernel mode, the driver
    can use a pretty neat trick: relying on an image-load callback notification to
    watch for a newly created process loading *ntdll.dll*. Loading *ntdll.dll* is
    one of the first things a new process does, so if the driver can notice this happening,
    it can act on the process before the main thread begins its execution: a perfect
    time to place its hooks. This section walks you through the steps to inject a
    function-hooking DLL into a newly created 64-bit process.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注入DLL，EDR不能随意将图像的内容写入进程的虚拟地址空间。DLL必须以符合PE格式的方式映射。为了从内核模式实现这一点，驱动程序可以使用一个相当巧妙的技巧：依赖图像加载回调通知来监控新创建的进程加载*ntdll.dll*。加载*ntdll.dll*是新进程做的第一件事之一，因此如果驱动程序能够注意到这一点，它可以在主线程开始执行之前对进程采取行动：这是放置钩子的完美时机。本节将引导您完成将功能钩子DLL注入新创建的64位进程的步骤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding KAPC
    Injection</samp>
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理解KAPC注入</samp>
- en: KAPC injection is relatively straightforward in theory and only gets murky when
    we talk about its actual implementation in a driver. The general gist is that
    we want to tell a newly created process to load the DLL we specify. In the case
    of EDRs, this will almost always be a function-hooking DLL. APCs, one of several
    methods of signaling a process to do something for us, wait until a thread is
    in an *alertable* state, such as when the thread executes <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!SleepEx()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WaitForSingleObjectEx()</samp>,
    to perform the task we requested.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: KAPC注入在理论上相对简单，只有在我们讨论其在驱动程序中的实际实现时才会变得模糊。大致来说，我们希望告诉一个新创建的进程加载我们指定的DLL。对于EDR来说，这几乎总是一个功能钩子DLL。APC作为一种信号进程执行某些操作的方法之一，等待直到线程处于*可警告*状态，例如当线程执行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!SleepEx()</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WaitForSingleObjectEx()</samp>时，来执行我们请求的任务。
- en: KAPC injection queues this task from kernel mode, and unlike plain user-mode
    APC injection, the operating system doesn’t formally support it, making its implementation
    a bit hacky. The process consists of a few steps. First, the driver is notified
    of an image load, whether it be the process image (such as *notepad.exe*) or a
    DLL that the EDR is interested in. Because the notification occurs in the context
    of the target process, the driver then searches the currently loaded modules for
    the address of a function that can load a DLL, specifically <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>.
    Next, the driver initializes a few key structures, providing the name of the DLL
    to be injected into the process; initializes the KAPC; and queues it for execution
    into the process. Whenever a thread in the process enters an alertable state,
    the APC will be executed and the EDR driver’s DLL will be loaded.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: KAPC注入从内核模式排队此任务，不像普通的用户模式APC注入，操作系统并不正式支持它，这使得其实现有些“黑客式”。该过程包括几个步骤。首先，驱动程序会在图像加载时收到通知，无论是进程图像（如*notepad.exe*）还是EDR关注的DLL。因为通知发生在目标进程的上下文中，驱动程序随后会在当前加载的模块中查找一个可以加载DLL的函数的地址，特别是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>。接下来，驱动程序初始化几个关键结构，提供要注入进程的DLL的名称；初始化KAPC；并将其排队执行。每当进程中的一个线程进入可警告状态时，APC就会执行，EDR驱动的DLL将被加载。
- en: To better understand this process, let’s step through each of these stages in
    greater detail.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个过程，让我们更详细地逐步了解这些阶段。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting a Pointer
    to the DLL-Loading Function</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">获取 DLL 加载函数的指针</samp>
- en: Before the driver can inject its DLL, it must get a pointer to the undocumented
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp> function,
    which is responsible for loading a DLL into a process, similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!LoadLibrary()</samp>.
    This is defined in [Listing 5-8](#list5-8).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在驱动程序能够注入其 DLL 之前，它必须获取一个指向未记录的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>
    函数的指针，该函数负责将 DLL 加载到进程中，类似于 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!LoadLibrary()</samp>。该内容在
    [清单 5-8](#list5-8) 中定义。
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 5-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LdrLoadDll()</samp>
    definition'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-8：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LdrLoadDll()</samp>
    函数定义
- en: Note that there is a difference between a DLL being loaded and it being fully
    mapped into the process. For this reason, a post-operation callback may be more
    favorable than a pre-operation callback for some drivers. This is because, when
    a post-operation callback routine is notified, the image is fully mapped, meaning
    that the driver can get a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>
    in the mapped copy of *ntdll.dll*. Because the image is mapped into the current
    process, the driver also doesn’t need to worry about address space layout randomization
    (ASLR).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，DLL 被加载和完全映射到进程中之间存在差异。因此，对于某些驱动程序，后操作回调可能比前操作回调更为有利。因为当后操作回调例程被通知时，映像已经完全映射，意味着驱动程序可以在映射的
    *ntdll.dll* 副本中获取指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>
    的指针。由于映像已经映射到当前进程中，驱动程序也无需担心地址空间布局随机化（ASLR）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preparing to Inject</samp>
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">准备注入</samp>
- en: Once the driver gets a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>,
    it has satisfied the most important requirement for performing KAPC injection
    and can start injecting its DLL into the new process. [Listing 5-9](#list5-9)
    shows how an EDR’s driver might perform the initialization steps necessary to
    do so.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦驱动程序获取了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>
    的指针，它就满足了执行 KAPC 注入的最重要要求，并可以开始将其 DLL 注入到新进程中。[清单 5-9](#list5-9) 显示了 EDR 驱动程序如何执行必要的初始化步骤来实现这一点。
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 5-9: Allocating memory in the target process and initializing the context
    structure'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-9：在目标进程中分配内存并初始化上下文结构
- en: The driver allocates memory inside the target process ❶ for a context structure
    containing the name of the DLL to be injected ❷.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序在目标进程 ❶ 内部分配内存，以容纳一个包含要注入的 DLL 名称的上下文结构 ❷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the KAPC
    Structure</samp>
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建 KAPC 结构</samp>
- en: After this allocation and initialization completes, the driver needs to allocate
    space for a <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> structure,
    as shown in [Listing 5-10](#list5-10). This structure holds the information about
    the routine to be executed in the target thread.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此分配和初始化后，驱动程序需要为 <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp>
    结构分配空间，如 [清单 5-10](#list5-10) 所示。该结构包含有关要在目标线程中执行的例程的信息。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 5-10: Allocating memory for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">KAPC</samp>
    structure'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-10：为 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">KAPC</samp>
    结构分配内存
- en: The driver allocates this memory in <samp class="SANS_TheSansMonoCd_W5Regular_11">NonPagedPool</samp>,
    a memory pool that guarantees the data will stay in physical memory rather than
    being paged out to disk as long as the object is allocated. This is important
    because the thread into which the DLL is being injected may be running at a high
    interrupt request level, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DISPATCH_LEVEL</samp>,
    in which case it shouldn’t access memory in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PagedPool</samp>,
    as this causes a fatal error that usually results in an <samp class="SANS_TheSansMonoCd_W5Regular_11">IRQL_NOT_LESS_OR_EQUAL</samp>
    bug check (also known as the Blue Screen of Death).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序在 <samp class="SANS_TheSansMonoCd_W5Regular_11">NonPagedPool</samp> 中分配此内存，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NonPagedPool</samp> 是一种内存池，保证数据会保留在物理内存中，而不会因为对象仍被分配而被换出到磁盘。这一点非常重要，因为
    DLL 注入的线程可能正在以高中断请求级别运行，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">DISPATCH_LEVEL</samp>，在这种情况下，它不应访问
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PagedPool</samp> 中的内存，因为这会导致一个致命错误，通常会导致
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IRQL_NOT_LESS_OR_EQUAL</samp> 错误检查（也称为蓝屏死机）。
- en: Next, the driver initializes the previously allocated <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp>
    structure using the undocumented <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInitializeApc()</samp>
    API, shown in [Listing 5-11](#list5-11).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，驱动程序使用未公开的 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInitializeApc()</samp>
    API 初始化先前分配的 <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> 结构，如 [列表
    5-11](#list5-11) 所示。
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-11: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!KeInitializeApc()</samp>
    definition'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-11：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!KeInitializeApc()</samp>
    定义
- en: In our driver, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInitializeApc()</samp>
    would look something like what is shown in [Listing 5-12](#list5-12).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的驱动程序中，对 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInitializeApc()</samp>
    的调用大致如 [列表 5-12](#list5-12) 所示。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 5-12: The call to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!KeInitializeApc()</samp>
    with the details for DLL injection'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-12：带有 DLL 注入详细信息的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!KeInitializeApc()</samp>
    调用
- en: This function first takes the pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp>
    structure created previously, along with a pointer to the thread into which the
    APC should be queued, which can be the current thread in our case. Following these
    parameters is a member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC_ENVIRONMENT</samp>
    enumeration, which should be <samp class="SANS_TheSansMonoCd_W5Regular_11">OriginalApcEnvironment</samp>
    (*0*), to indicate that the APC will run in the thread’s process context.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先接受指向之前创建的 <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> 结构的指针，以及指向应该排队到其中的线程的指针，在我们的例子中可以是当前线程。紧随其后的是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC_ENVIRONMENT</samp> 枚举中的一个成员，它应该是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OriginalApcEnvironment</samp> (*0*)，以指示
    APC 将在该线程的进程上下文中运行。
- en: The next three parameters, the routines, are where a bulk of the work happens.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelRoutine</samp>, named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OurKernelRoutine()</samp> in our
    example code, is the function to be executed in kernel mode at <samp class="SANS_TheSansMonoCd_W5Regular_11">APC_LEVEL</samp>
    before the APC is delivered to user mode. Most often, it simply frees the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> object and returns. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RundownRoutine</samp> function is executed
    if the target thread is terminated before the APC was delivered. This should free
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> object, but we’ve
    kept it empty in our example for the sake of simplicity. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NormalRoutine</samp>
    function should execute in user mode at <samp class="SANS_TheSansMonoCd_W5Regular_11">PASSIVE_LEVEL</samp>
    when the APC is delivered. In our case, this should be the function pointer to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>. The last
    two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">ApcMode</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NormalContext</samp>, are set to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp> (*1*) and the parameter
    passed as <samp class="SANS_TheSansMonoCd_W5Regular_11">NormalRoutine</samp>,
    respectively.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个参数，即例程，是主要工作发生的地方。<samp class="SANS_TheSansMonoCd_W5Regular_11">KernelRoutine</samp>，在我们的示例代码中命名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OurKernelRoutine()</samp>，是在内核模式下执行的函数，在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">APC_LEVEL</samp> 层级执行，且在将 APC 传递到用户模式之前执行。通常，它只是释放
    <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> 对象并返回。<samp class="SANS_TheSansMonoCd_W5Regular_11">RundownRoutine</samp>
    函数在目标线程在 APC 被传递之前终止时执行。此函数应释放 <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp>
    对象，但为了简化起见，我们在示例中将其留空。<samp class="SANS_TheSansMonoCd_W5Regular_11">NormalRoutine</samp>
    函数应在 APC 被传递时，在用户模式下的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PASSIVE_LEVEL</samp>
    层级执行。在我们的例子中，它应该是指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>
    的函数指针。最后两个参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">ApcMode</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NormalContext</samp>，分别被设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp>
    (*1*) 和作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">NormalRoutine</samp> 传递的参数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Queueing the APC</samp>
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">队列 APC</samp>
- en: Lastly, the driver needs to queue this APC. The driver calls the undocumented
    function <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInsertQueueApc()</samp>,
    defined in [Listing 5-13](#list5-13).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，驱动程序需要将这个 APC 排队。驱动程序调用未记录的函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInsertQueueApc()</samp>，该函数在
    [列表 5-13](#list5-13) 中定义。
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 5-13: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!KeInsertQueueApc()</samp>
    definition'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-13：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!KeInsertQueueApc()</samp>
    定义
- en: This function is quite a bit simpler than the previous one. The first input
    parameter is the APC, which will be the pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp>
    we created. Next are the arguments to be passed. These should be the path to the
    DLL to be loaded and the length of the string containing the path. Because these
    are the two members of our custom <samp class="SANS_TheSansMonoCd_W5Regular_11">INJECTION_CTX</samp>
    structure, we simply reference the members here. Finally, since we’re not incrementing
    anything, we can set <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数比之前的函数简单得多。第一个输入参数是 APC，它将是指向我们创建的 <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp>
    的指针。接下来是要传递的参数。这些应该是要加载的 DLL 路径和包含路径的字符串的长度。由于这两个成员是我们自定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">INJECTION_CTX</samp>
    结构的一部分，我们在这里直接引用这些成员。最后，由于我们没有递增任何东西，可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。
- en: At this point, the DLL is queued for injection into the new process whenever
    the current thread enters an alertable state, such as if it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WaitForSingleObject()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep()</samp>. After the APC
    completes, the EDR will start to receive events from the DLL containing its hooks,
    allowing it to monitor the execution of key APIs inside the injected function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，DLL 将被排队注入新进程中，每当当前线程进入可警示状态时，例如调用<samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WaitForSingleObject()</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sleep()</samp>时。在 APC 完成后，EDR 将开始接收来自包含其钩子的
    DLL 的事件，从而允许它监控注入函数内部关键 API 的执行。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Preventing KAPC Injection</samp>
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">防止 KAPC 注入</samp>
- en: Beginning in Windows build 10586, processes may prevent DLLs not signed by Microsoft
    from being loaded into them via process and thread mitigation policies. Microsoft
    originally implemented this functionality so that browsers could prevent third-party
    DLLs from injecting into them, which could impact their stability.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Windows 10586 版本开始，进程可以通过进程和线程缓解策略防止未由微软签名的 DLL 加载到它们中。微软最初实现此功能是为了让浏览器能够防止第三方
    DLL 注入到它们中，因为这些 DLL 可能会影响浏览器的稳定性。
- en: The mitigation strategies work as follows. When a process is created via the
    user-mode process-creation API, a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp>
    structure is expected to be passed as a parameter. Inside this structure is a
    pointer to an attribute list, <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_LIST</samp>.
    This attribute list, once initialized, supports the attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY</samp>.
    When this attribute is set, the <samp class="SANS_TheSansMonoCd_W5Regular_11">lpValue</samp>
    member of the attribute may be a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">DWORD</samp>
    containing the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON</samp>
    flag. If this flag is set, only DLLs signed by Microsoft will be permitted to
    load in the process. If a program tries to load a DLL not signed by Microsoft,
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_IMAGE_HASH</samp>
    error will be returned. By leveraging this attribute, processes can prevent EDRs
    from injecting their function-hooking DLL, allowing them to operate without fear
    of function interception.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解策略的工作原理如下。当通过用户模式进程创建 API 创建一个进程时，预计会将指向<samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp>结构的指针作为参数传递。该结构内包含指向属性列表的指针，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_LIST</samp>。一旦初始化，此属性列表支持属性<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY</samp>。当设置此属性时，属性的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpValue</samp>成员可能是指向包含<samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON</samp>标志的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DWORD</samp>的指针。如果设置了此标志，则只允许加载由微软签名的
    DLL。如果程序尝试加载未由微软签名的 DLL，将返回<samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_IMAGE_HASH</samp>错误。通过利用此属性，进程可以防止
    EDR 注入其函数钩子 DLL，从而允许它们在不担心函数拦截的情况下运行。
- en: A caveat to this technique is that the flag is only passed to processes being
    created and does not apply to the current process. Because of this, it is best
    suited for command-and-control agents that rely on the fork&run architecture for
    post-exploitation tasks, as each time the agent queues a task, the sacrificial
    process will be created and have the mitigation policy applied. If a malware author
    would like this attribute to apply to their original process, they could leverage
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!SetProcessMitigationPolicy()</samp>
    API and its associated <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessSignaturePolicy</samp>
    policy. By the time the process would be able to make this API call, however,
    the EDR’s function-hooking DLL would be loaded in the process and its hooks placed,
    rendering this technique nonviable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技术的一个警告是，标志仅传递给正在创建的进程，不适用于当前进程。因此，它最适用于依赖 fork&run 架构进行后期利用任务的命令与控制代理，因为每次代理排队任务时，牺牲进程将被创建并应用缓解策略。如果恶意软件作者希望这个属性适用于其原始进程，他们可以利用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!SetProcessMitigationPolicy()</samp>
    API 及其关联的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessSignaturePolicy</samp>
    策略。然而，在进程能够调用此 API 时，EDR 的函数钩子 DLL 将已经加载到进程中并放置了钩子，使得这种技术变得不可行。
- en: Another challenge with using this technique is that EDR vendors have begun to
    get their DLLs attestation-signed by Microsoft, as shown in [Figure 5-3](#fig5-3),
    allowing them to be injected into processes even if the flag was set.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术的另一个挑战是，EDR 供应商已经开始让他们的 DLL 获得微软的认证签名，如[图 5-3](#fig5-3)所示，这使得它们即使在设置了标志的情况下也能注入到进程中。
- en: '![](../images/Figure5-3.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: CrowdStrike Falcon’s
    DLL countersigned by Microsoft</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-3：CrowdStrike Falcon 的 DLL
    经微软签名</samp>
- en: In his post “Protecting Your Malware with blockdlls and ACG,” Adam Chester describes
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON</samp>
    flag, commonly referred to as Arbitrary Code Guard (ACG), to prevent the modification
    of executable regions of memory, a requirement of placing function hooks. While
    this flag prevented function hooks from being placed, it also prevented many off-the-shelf
    command-and-control agents’ shellcode from executing during testing, as most rely
    on manually setting pages of memory to read-write-execute (RWX).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的文章《使用 blockdlls 和 ACG 保护恶意软件》中，Adam Chester 描述了使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON</samp>
    标志（通常称为任意代码保护（ACG））来防止修改内存中的可执行区域，这是放置函数钩子的要求。虽然这个标志阻止了函数钩子的放置，但它也在测试期间阻止了许多现成的命令与控制代理的
    shellcode 执行，因为大多数依赖于手动将内存页设置为读写执行（RWX）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Registry Notifications Work</samp>
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">注册表通知的工作原理</samp>
- en: Like most software, malicious tools commonly interact with the registry, such
    as by querying values and creating new keys. In order to capture these interactions,
    drivers can register notification callback routines that get alerted any time
    a process interacts with the registry, allowing the driver to prevent, tamper
    with, or simply log the event.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数软件一样，恶意工具通常会与注册表交互，例如查询值和创建新键。为了捕获这些交互，驱动程序可以注册通知回调例程，当进程与注册表交互时，这些回调将被触发，从而允许驱动程序防止、篡改或简单地记录该事件。
- en: Some offensive techniques rely heavily on the registry. We can often detect
    these through registry events, assuming we know what we’re looking for. [Table
    5-1](#tab5-1) shows a handful of different techniques, what registry keys they
    interact with, and their associated <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp>
    class (a value we’ll discuss later in this section).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些攻击技术严重依赖于注册表。我们通常可以通过注册表事件检测到这些技术，前提是我们知道在寻找什么。[表 5-1](#tab5-1)展示了一些不同的技术、它们交互的注册表键以及它们关联的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> 类（这是我们稍后将在本节讨论的一个值）。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 5-1:</samp> <samp class="SANS_Futura_Std_Book_11">Attacker
    Tradecraft in the Registry and the Related</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp>
    <samp class="SANS_Futura_Std_Book_11">Members</samp>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 5-1：</samp> <samp class="SANS_Futura_Std_Book_11">注册表中的攻击者技巧及相关</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> <samp class="SANS_Futura_Std_Book_11">成员</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Technique</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Registry
    location</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">REG_NOTIFY_CLASS
    members</samp> |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">技术</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">注册表位置</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">REG_NOTIFY_CLASS 成员</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Run-key persistence</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\Software\Microsoft\Windows\CurrentVersion\Run</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtCreateKey(Ex)</samp> |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">运行键持久性</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\Software\Microsoft\Windows\CurrentVersion\Run</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtCreateKey(Ex)</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Security Support Provider (SSP) persistence</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security
    Packages</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp>
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">安全支持提供程序(SSP)持久性</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security
    Packages</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Component Object Model (COM) hijack</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SOFTWARE\Classes\CLSID\<CLSID>\</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp> |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">组件对象模型(COM)劫持</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SOFTWARE\Classes\CLSID\<CLSID>\</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Service hijack</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SYSTEM\CurrentControlSet\Services\<ServiceName></samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp> |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">服务劫持</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SYSTEM\CurrentControlSet\Services\<ServiceName></samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Link-Local Multicast Name Resolution
    (LLMNR) poisoning</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\Software\Policies\Microsoft\Windows
    NT\DNSClient</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtQueryValueKey</samp>
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Link-Local多播名称解析(LLMNR)中毒</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\Software\Policies\Microsoft\Windows
    NT\DNSClient</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtQueryValueKey</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Security Account Manager dumping</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SAM</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNt(Pre/Post)SaveKey</samp>
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">安全帐户管理器转储</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SAM</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNt(Pre/Post)SaveKey</samp>
    |'
- en: To explore how adversaries interact with the registry, consider the technique
    of service hijacking. On Windows, services are a way of creating long-running
    processes that can be started manually or on boot, similar to daemons on Linux.
    While the service control manager manages these services, their configurations
    are stored exclusively in the registry, under the *HKEY_LOCAL_MACHINE (HKLM)*
    hive. For the most part, services run as the privileged *NT AUTHORITY/SYSTEM*
    account, which gives them pretty much full control over the system and makes them
    a juicy target for attackers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索攻击者如何与注册表交互，可以考虑服务劫持技术。在Windows系统中，服务是一种创建长时间运行的进程的方式，这些进程可以手动启动或在启动时自动启动，类似于Linux中的守护进程。虽然服务控制管理器管理这些服务，但它们的配置仅存储在注册表中，位于
    *HKEY_LOCAL_MACHINE (HKLM)* 区域。大多数情况下，服务作为特权的 *NT AUTHORITY/SYSTEM* 账户运行，这使得它们几乎可以完全控制系统，并成为攻击者的一个诱人目标。
- en: One of the ways that adversaries abuse services is by modifying the registry
    values that describe the configuration of a service. Inside a service’s configuration,
    there exists a value, <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePath</samp>,
    that contains the path to the service’s executable. If an attacker can change
    this value to the path for a piece of malware they’ve placed on the system, their
    executable will be run in this privileged context when the service is restarted
    (most often on system reboot).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意攻击者滥用服务的一种方式是通过修改描述服务配置的注册表值。在服务的配置中，存在一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePath</samp>
    的值，它包含指向服务可执行文件的路径。如果攻击者能够将这个值更改为他们在系统上放置的恶意软件的路径，那么当服务重新启动时（通常是在系统重启时），他们的可执行文件将在这个特权上下文中运行。
- en: Because this attack procedure relies on registry value modification, an EDR
    driver that is monitoring <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp>-type
    events could detect the adversary’s activity and respond accordingly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此攻击过程依赖于注册表值的修改，因此监视 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp>
    类型事件的EDR驱动程序可能会检测到攻击者的活动并做出相应反应。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a Registry
    Notification</samp>
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">注册注册表通知</samp>
- en: To register a registry callback routine, drivers must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!CmRegisterCallbackEx()</samp>
    function defined in [Listing 5-14](#list5-14). The <samp class="SANS_TheSansMonoCd_W5Regular_11">Cm</samp>
    prefix references the configuration manager, which is the component of the kernel
    that oversees the registry.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册一个注册表回调例程，驱动程序必须使用在[清单 5-14](#list5-14)中定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!CmRegisterCallbackEx()</samp>
    函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">Cm</samp> 前缀表示配置管理器，这是内核中负责管理注册表的组件。
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!CmRegisterCallbackEx()</samp>
    prototype'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-14：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!CmRegisterCallbackEx()</samp>
    原型
- en: Of the callbacks covered in this book, the registry callback type has the most
    complex registration function, and its required parameters are slightly different
    from those for the other functions. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp>
    parameter is the pointer to the driver’s callback. It must be defined as an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EX_CALLBACK_FUNCTION</samp>, according
    to Microsoft’s Code Analysis for Drivers and the Static Driver Verifier, and it
    returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>. Next,
    as in object-notification callbacks, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Altitude</samp>
    parameter defines the callback’s position in the callback stack. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Driver</samp>
    is a pointer to the driver object, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Context</samp>
    is an optional value that can be passed to the callback function but is very rarely
    used. Lastly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Cookie</samp>
    parameter is a <samp class="SANS_TheSansMonoCd_W5Regular_11">LARGE_INTEGER</samp>
    passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!CmUnRegisterCallback()</samp>
    when unloading the driver.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书介绍的所有回调中，注册表回调类型的注册函数最为复杂，其所需的参数与其他函数略有不同。首先，<samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp>
    参数是指向驱动程序回调的指针。根据微软的驱动程序代码分析和静态驱动程序验证器，它必须定义为 <samp class="SANS_TheSansMonoCd_W5Regular_11">EX_CALLBACK_FUNCTION</samp>，并返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>。接下来，与对象通知回调类似，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Altitude</samp> 参数定义回调在回调堆栈中的位置。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Driver</samp> 是指向驱动程序对象的指针，<samp class="SANS_TheSansMonoCd_W5Regular_11">Context</samp>
    是一个可选值，可以传递给回调函数，但很少使用。最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">Cookie</samp>
    参数是一个传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!CmUnRegisterCallback()</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LARGE_INTEGER</samp>，用于卸载驱动程序时。
- en: When a registry event occurs, the system invokes the callback function. Registry
    callback functions use the prototype in [Listing 5-15](#list5-15).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册表事件发生时，系统会调用回调函数。注册表回调函数使用[清单 5-15](#list5-15)中的原型。
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 5-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!ExCallbackFunction()</samp>
    prototype'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-15：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!ExCallbackFunction()</samp>
    原型
- en: The parameters passed to the function may be difficult to make sense of at first
    due to their vague names. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackContext</samp>
    parameter is the value defined in the registration function’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Context</samp>
    parameter, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument1</samp>
    is a value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp>
    enumeration that specifies the type of action that occurred, such as a value being
    read or a new key being created. While Microsoft lists 62 members of this enumeration,
    those with the member prefixes <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNt</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPre</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPost</samp>
    represent the same activity generating notifications at different times, so by
    deduplicating the list, we can identify 24 unique operations. These are shown
    in [Table 5-2](#tab5-2).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给函数的参数可能一开始很难理解，因为它们的名称比较模糊。<samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackContext</samp>
    参数是注册函数中 <samp class="SANS_TheSansMonoCd_W5Regular_11">Context</samp> 参数定义的值，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Argument1</samp> 是来自 <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp>
    枚举中的一个值，表示发生的操作类型，比如读取一个值或创建一个新的键。虽然微软列出了这个枚举的62个成员，但其中带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNt</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RegNtPre</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPost</samp>
    前缀的成员表示相同的活动，在不同的时间生成通知，因此通过去重列表，我们可以识别出24个独特的操作。这些操作列在[表5-2](#tab5-2)中。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 5-2:</samp> <samp class="SANS_Futura_Std_Book_11">Stripped</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> <samp class="SANS_Futura_Std_Book_11">Members
    and Descriptions</samp>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 5-2:</samp> <samp class="SANS_Futura_Std_Book_11">剥离的</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> <samp class="SANS_Futura_Std_Book_11">成员和描述</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Registry operation</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">注册表操作</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    registry key is being deleted.</samp> |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在删除一个注册表键。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SetValueKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">A value is being set for a key.</samp> |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SetValueKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">正在为键设置一个值。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteValueKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">A value is being deleted from a key.</samp> |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteValueKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">正在从一个键中删除一个值。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformationKey</samp> |
    <samp class="SANS_Futura_Std_Book_11">Metadata is being set for a key.</samp>
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformationKey</samp> |
    <samp class="SANS_Futura_Std_Book_11">正在为一个键设置元数据。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RenameKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    key is being renamed.</samp> |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RenameKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在重命名一个键。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumerateKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">Subkeys of a key are being enumerated.</samp>
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumerateKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">正在枚举一个键的子键。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumerateValueKey</samp> |
    <samp class="SANS_Futura_Std_Book_11">Values of a key are being enumerated.</samp>
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumerateValueKey</samp> |
    <samp class="SANS_Futura_Std_Book_11">正在枚举一个键的值。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    key’s metadata is being read.</samp> |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在读取键的元数据。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryValueKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">A value in a key is being read.</samp> |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryValueKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">正在读取一个键中的值。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryMultipleValueKey</samp>
    | <samp class="SANS_Futura_Std_Book_11">Multiple values of a key are being queried.</samp>
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryMultipleValueKey</samp>
    | <samp class="SANS_Futura_Std_Book_11">正在查询一个键的多个值。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    new key is being created.</samp> |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在创建一个新密钥。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    handle to a key is being opened.</samp> |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在打开一个密钥的句柄。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyHandleClose</samp> | <samp
    class="SANS_Futura_Std_Book_11">A handle to a key is being closed.</samp> |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyHandleClose</samp> | <samp
    class="SANS_Futura_Std_Book_11">正在关闭一个密钥的句柄。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateKeyEx</samp> | <samp
    class="SANS_Futura_Std_Book_11">A key is being created.</samp> |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateKeyEx</samp> | <samp
    class="SANS_Futura_Std_Book_11">正在创建一个密钥。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenKeyEx</samp> | <samp class="SANS_Futura_Std_Book_11">A
    thread is trying to open a handle to an existing key.</samp> |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenKeyEx</samp> | <samp class="SANS_Futura_Std_Book_11">线程正在尝试打开一个现有密钥的句柄。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FlushKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    key is being written to disk.</samp> |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FlushKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在将密钥写入磁盘。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    registry hive is being loaded from a file.</samp> |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在从文件加载注册表集群。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UnLoadKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    registry hive is being unloaded.</samp> |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UnLoadKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在卸载一个注册表集群。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryKeySecurity</samp> | <samp
    class="SANS_Futura_Std_Book_11">A key’s security information is being queried.</samp>
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryKeySecurity</samp> | <samp
    class="SANS_Futura_Std_Book_11">正在查询一个密钥的安全信息。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SetKeySecurity</samp> | <samp
    class="SANS_Futura_Std_Book_11">A key’s security information is being set.</samp>
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SetKeySecurity</samp> | <samp
    class="SANS_Futura_Std_Book_11">正在设置一个密钥的安全信息。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RestoreKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    key’s information is being restored.</samp> |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RestoreKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在恢复一个密钥的信息。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SaveKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    key’s information is being saved.</samp> |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SaveKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在保存一个密钥的信息。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ReplaceKey</samp> | <samp class="SANS_Futura_Std_Book_11">A
    key’s information is being replaced.</samp> |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ReplaceKey</samp> | <samp class="SANS_Futura_Std_Book_11">正在替换一个密钥的信息。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryKeyName</samp> | <samp
    class="SANS_Futura_Std_Book_11">The full registry path of a key is being queried.</samp>
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryKeyName</samp> | <samp
    class="SANS_Futura_Std_Book_11">正在查询密钥的完整注册表路径。</samp> |'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument2</samp> parameter
    is a pointer to a structure that contains information relevant to the operation
    specified in <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument1</samp>. Each
    operation has its own associated structure. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreCreateKeyEx</samp>
    operations use the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_CREATE_KEY_INFORMATION</samp>
    structure. This information provides the relevant context for the registry operation
    that occurred on the system, allowing the EDR to extract the data it needs to
    make a decision on how to proceed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument2</samp> 参数是一个指向结构体的指针，该结构体包含与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument1</samp> 中指定的操作相关的信息。每个操作都有其关联的结构体。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreCreateKeyEx</samp> 操作使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">REG_CREATE_KEY_INFORMATION</samp> 结构体。这些信息提供了系统上发生的注册表操作的相关上下文，使得EDR能够提取所需的数据，进而做出后续处理决策。
- en: Every pre-operation member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp>
    enumeration (those that begin with <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPre</samp>
    or simply <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNt</samp>) uses structures
    specific to the type of operation. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreQueryKey</samp>
    operation uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_QUERY_KEY_INFORMATION</samp>
    structure. These pre-operation callbacks allow the driver to modify or prevent
    the request from completing before execution is handed off to the configuration
    manager. An example of this using the previous <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreQueryKey</samp>
    member would be to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyInformation</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_QUERY_KEY_INFORMATION</samp>
    structure to change the type of information returned to the caller.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> 枚举的前操作成员（那些以
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPre</samp> 或简单的 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNt</samp>
    开头的）使用特定于操作类型的结构。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreQueryKey</samp>
    操作使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_QUERY_KEY_INFORMATION</samp>
    结构。这些前操作回调允许驱动程序在将执行交给配置管理器之前修改或阻止请求的完成。以之前的 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreQueryKey</samp>
    成员为例，可以修改 <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_QUERY_KEY_INFORMATION</samp>
    结构的 <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyInformation</samp> 成员，以更改返回给调用者的信息类型。
- en: Post-operation callbacks always use the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPERATION_INFORMATION</samp>
    structure, with the exception of <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostCreateKey</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostOpenKey</samp>, which
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_CREATE_KEY_INFORMATION</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPEN_KEY _INFORMATION</samp>
    structures, respectively. This post-operation structure consists of a few interesting
    members. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> member
    is a pointer to the registry-key object for which the operation was completed.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Status</samp> member is the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> value that the system
    will return to the caller. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ReturnStatus</samp>
    member is an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> value
    that, if the callback routine returns <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS
    _CALLBACK_BYPASS</samp>, will be returned to the caller. Lastly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">PreInformation</samp>
    member contains a pointer to the structure used for the corresponding pre-operation
    callback. For example, if the operation being processed is <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreQueryKey</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">PreInformation</samp> member
    would be a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">REG _QUERY_KEY_INFORMATION</samp>
    structure.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 后操作回调始终使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPERATION_INFORMATION</samp>
    结构，除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostCreateKey</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostOpenKey</samp>，它们分别使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_CREATE_KEY_INFORMATION</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPEN_KEY_INFORMATION</samp>
    结构。这个后操作结构包含几个有趣的成员。<samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp>
    成员是一个指针，指向完成操作的注册表键对象。<samp class="SANS_TheSansMonoCd_W5Regular_11">Status</samp>
    成员是系统将返回给调用者的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> 值。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReturnStatus</samp> 成员是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    值，如果回调例程返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_CALLBACK_BYPASS</samp>，则该值将返回给调用者。最后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PreInformation</samp> 成员包含指向用于相应前操作回调的结构的指针。例如，如果正在处理的操作是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreQueryKey</samp>，则 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PreInformation</samp> 成员将是指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_QUERY_KEY_INFORMATION</samp>
    结构的指针。
- en: While these callbacks don’t allow the same level of control as pre-operation
    callbacks do, they still give the driver some influence over the value returned
    to the caller. For example, the EDR could collect the return value and log that
    data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些回调不像前操作回调那样能提供相同程度的控制，但它们仍然可以让驱动程序在一定程度上影响返回给调用者的值。例如，EDR 可以收集返回值并记录这些数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mitigating Performance
    Challenges</samp>
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">缓解性能挑战</samp>
- en: One of the biggest challenges that EDRs face when receiving registry notifications
    is performance. Because the driver can’t filter the events, it receives every
    registry event that occurs on the system. If one driver in the callback stack
    performs some operation on the data received that takes an excessive amount of
    time, it can cause serious system performance degradation. For example, during
    one test, a Windows virtual machine performed nearly 20,000 registry operations
    per minute at an idle state, as shown in [Figure 5-4](#fig5-4). If a driver took
    some action for each of these events that lasted an additional millisecond, it
    would cause a nearly 30 percent degradation to system performance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: EDR 在接收注册表通知时面临的最大挑战之一就是性能。由于驱动程序无法过滤事件，它会接收到系统上发生的每个注册表事件。如果回调堆栈中的某个驱动程序对接收到的数据执行了一个耗时过长的操作，就可能导致系统性能严重下降。例如，在一次测试中，Windows
    虚拟机在空闲状态下每分钟执行了近 20,000 次注册表操作，如[图 5-4](#fig5-4)所示。如果一个驱动程序对每个事件采取了一些额外的动作，每个动作多耗时一毫秒，这将导致系统性能下降近
    30%。
- en: '![](../images/Figure5-4.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: A total of 19,833
    registry events captured in one minute</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-4：在一分钟内捕获的总计 19,833 个注册表事件</samp>
- en: To reduce the risk of adverse performance impacts, EDR drivers must carefully
    select what they monitor. The most common way that they do this is by monitoring
    only certain registry keys and selectively capturing event types. [Listing 5-16](#list5-16)
    demonstrates how an EDR might implement this behavior.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少对性能的不良影响，EDR 驱动程序必须仔细选择它们要监视的内容。它们最常用的方法是仅监视特定的注册表键，并有选择地捕获事件类型。[列表 5-16](#list5-16)演示了一个
    EDR 如何实现这种行为。
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-16: Scoping a registry callback notification routine to work with
    specific operations only'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-16：限定注册表回调通知例程，仅对特定操作有效
- en: In this example, the driver first casts the <samp class="SANS_TheSansMonoCd_W5Regular_11">pRegNotifyClass</samp>
    input parameter to a <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp>
    structure for comparison ❶ using a switch case. This is to make sure it’s working
    with the correct structure. The driver then checks whether the class matches one
    that it supports (in this case, key creation and the setting of a value). If it
    does match, the <samp class="SANS_TheSansMonoCd_W5Regular_11">pInfo</samp> member
    is cast to the appropriate structure ❷ so that the driver can continue to parse
    the event notification data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，驱动程序首先将输入参数<samp class="SANS_TheSansMonoCd_W5Regular_11">pRegNotifyClass</samp>转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp>结构体进行比较❶，使用的是一个switch
    case。这是为了确保它正在与正确的结构体进行交互。然后，驱动程序检查该类是否与其支持的类匹配（在此情况下，键创建和设置值）。如果匹配，<samp class="SANS_TheSansMonoCd_W5Regular_11">pInfo</samp>成员将被转换为适当的结构体❷，以便驱动程序可以继续解析事件通知数据。
- en: An EDR developer may want to limit its scope even further to lessen the performance
    hit the system will take. For instance, if a driver wants to monitor service creation
    via the registry, it would need to check for registry-key creation events in the
    *HKLM:\SYSTEM\CurrentControlSet\Services\* path only.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: EDR 开发人员可能希望进一步限制其范围，以减少系统的性能损耗。例如，如果驱动程序希望通过注册表监视服务创建，它只需检查*HKLM:\SYSTEM\CurrentControlSet\Services\*路径下的注册表键创建事件。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Registry Callbacks</samp>
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避注册表回调</samp>
- en: Registry callbacks have no shortage of evasion opportunities, most of which
    are due to design decisions aimed at improving system performance. When drivers
    reduce the number of registry events they monitor, they can introduce blind spots
    in their telemetry. For example, if they’re only monitoring events in *HKLM*,
    the hive used for the configuration of items shared across the system, they won’t
    detect any per-user registry keys created in *HKCU* or *HKU*, the hives used to
    configure items specific to a single principal. And if they’re monitoring registry-key
    creation events only, they’ll miss registry-key restoration events. EDRs commonly
    use registry callbacks to help protect unauthorized processes from interacting
    with registry keys associated with its agent, so it’s safe to assume that some
    of the allowable performance overhead is tied up in that logic.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表回调存在大量规避机会，其中大多数是由于旨在提高系统性能的设计决策。当驱动程序减少它们监控的注册表事件数量时，它们可能会在遥测中引入盲点。例如，如果它们仅监控
    *HKLM* 中的事件，该项注册表用于配置系统共享的项目，它们将无法检测到在 *HKCU* 或 *HKU* 中创建的每个用户注册表键，这些注册表是用于配置特定于单一主体的项目。如果它们仅监控注册表键创建事件，它们将错过注册表键恢复事件。EDR（端点检测与响应）常使用注册表回调帮助保护未经授权的进程免于与其代理关联的注册表键交互，因此可以合理推测，允许的性能开销中有一部分与该逻辑相关。
- en: This means that there are likely coverage gaps in the sensor that attackers
    can abuse. For example, [Listing 5-17](#list5-17) contains the decompilation of
    a popular endpoint security product’s driver to show how it handles a number of
    registry operations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着传感器可能存在覆盖漏洞，攻击者可以加以利用。例如，[列表 5-17](#list5-17) 包含了一个流行的端点安全产品的驱动程序反汇编，展示了该驱动程序如何处理多个注册表操作。
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-17: Registry callback routine disassembly'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-17：注册表回调例程反汇编
- en: The driver uses a switch case to handle notifications related to different types
    of registry operations. Specifically, it monitors key-deletion, value-deletion,
    and key-enumeration events. On a matching case, it extracts certain values based
    on the operation type and then processes them. In some cases, it also applies
    a context to the object ❶ to allow for advanced processing. In others, it calls
    an internal function ❷ using the extracted data.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序使用 switch case 来处理与不同类型注册表操作相关的通知。具体来说，它监控键删除、值删除和键枚举事件。在匹配的情况下，它根据操作类型提取某些值并进行处理。在某些情况下，它还会将上下文应用于对象
    ❶，以便进行高级处理。在其他情况下，它会使用提取的数据调用内部函数 ❷。
- en: There are a few notable gaps in coverage here. For instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostSetValueKey</samp>,
    the operation of which the driver is notified whenever the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegSetValue(Ex)</samp>
    API is called, is handled in a case much later in the switch statement. This case
    would detect an attempt to set a value in a registry key, such as to create a
    new service. If the attacker needs to create a new registry subkey and set values
    inside it, they’ll need to find another method that the driver doesn’t cover.
    Thankfully for them, the driver doesn’t process the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreLoadKey</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostLoadKey</samp> operations,
    which would detect a registry hive being loaded from a file as a subkey. So, the
    operator may be able to leverage the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegLoadKey</samp>
    API to create and populate their service registry key, effectively creating a
    service without being detected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些显著的覆盖漏洞。例如，每当调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegSetValue(Ex)</samp>
    API 时，驱动程序会通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostSetValueKey</samp>
    接收通知，而此操作则在 switch 语句中较晚的 case 中处理。该 case 会检测设置注册表键值的尝试，例如创建新服务。如果攻击者需要创建新的注册表子键并在其中设置值，他们将需要找到驱动程序未涵盖的另一种方法。幸运的是，驱动程序并未处理
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreLoadKey</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostLoadKey</samp>
    操作，这些操作会检测从文件加载的注册表 hive 作为子键。因此，操作员可能能够利用 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegLoadKey</samp>
    API 来创建并填充他们的服务注册表键，从而有效地创建服务而不被检测到。
- en: Revisiting the post-notification call <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostSetValueKey</samp>,
    we can see that the driver exhibits some interesting behavior common among most
    products, shown in [Listing 5-18](#list5-18).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 回到通知后调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostSetValueKey</samp>，我们可以看到该驱动程序展示了一些在大多数产品中常见的有趣行为，如
    [列表 5-18](#list5-18) 所示。
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 5-18: Registry-notification processing logic'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-18：注册表通知处理逻辑
- en: This routine extracts the <samp class="SANS_TheSansMonoCd_W5Regular_11">Status</samp>
    ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> ❷ members from
    the associated <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPERATION_INFORMATION</samp>
    structure and stores them as local variables. Then it checks that these values
    aren’t <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>, respectively ❸. If
    the values fail the check, the output buffer used for relaying messages to the
    user-mode client is freed ❹ and the context set for the object is nulled. This
    behavior may seem strange at first, but it relates to the internal function renamed
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InternalGetNameFromRegistryObject()</samp>
    for clarity ❺. [Listing 5-19](#list5-19) contains the decompilation of this function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程提取关联的<samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPERATION_INFORMATION</samp>结构中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Status</samp> ❶ 和<samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp>
    ❷成员，并将它们存储为本地变量。然后，它检查这些值是否为<samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> ❸。如果这些值未通过检查，则用于将消息传递给用户模式客户端的输出缓冲区将被释放
    ❹，并且为对象设置的上下文将被置为无效。这个行为一开始可能看起来很奇怪，但它与为了清晰起见重新命名的内部函数<samp class="SANS_TheSansMonoCd_W5Regular_11">InternalGetNameFromRegistryObject()</samp>有关
    ❺。[清单 5-19](#list5-19)包含该函数的反汇编代码。
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-19: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternalGetNameFromRegistryObject()</samp>
    disassembly'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-19：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternalGetNameFromRegistryObject()</samp>的反汇编
- en: This internal function takes a pointer to a registry object, which is passed
    in as the local variable holding the <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPERATION_INFORMATION</samp>
    structure, and extracts the name of the registry key being acted on using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!ObQueryNameString()</samp> ❷. The problem
    with this flow is that if the operation was unsuccessful (as in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Status</samp>
    member of the post-operation information structure isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp>),
    the registry object pointer is invalidated and the call to the object-name-resolution
    function won’t be able to extract the name of the registry key. This driver contains
    conditional logic to check for this condition ❶.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内部函数接收一个指向注册表对象的指针，该指针通过传递包含<samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp>成员的本地变量（即<
    samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPERATION_INFORMATION</samp>结构）传入，并使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!ObQueryNameString()</samp> ❷提取正在操作的注册表项的名称。这个流程的问题在于，如果操作失败（例如后操作信息结构中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Status</samp>成员不是<samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp>），则注册表对象指针会失效，调用对象名称解析函数时无法提取注册表项的名称。这个驱动程序包含条件逻辑来检查这种情况
    ❶。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*This specific function isn’t the only API affected by this problem. We often
    see similar logic implemented for other functions that extract key-name information
    from registry objects, such as <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!CmCallbackGetKeyObjectIDEx()</samp>.*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个特定的函数并不是唯一受此问题影响的 API。我们经常看到类似的逻辑被实现在其他从注册表对象中提取键名信息的函数中，如<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!CmCallbackGetKeyObjectIDEx()</samp>。*'
- en: 'Operationally, this means that an unsuccessful attempt to interact with the
    registry won’t generate an event, or at least one with all the relevant details,
    from which a detection can be created, all because the name of the registry key
    is missing. Without the name of the object, the event would effectively read “this
    user attempted to perform this registry action at this time and it was unsuccessful”:
    not very actionable for defenders.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作角度来看，这意味着如果与注册表的交互尝试失败，系统不会生成一个事件，或者至少不会生成一个包含所有相关细节的事件，从而无法创建检测。原因是缺少注册表项的名称。没有对象的名称，事件实际上会显示为“该用户尝试在此时间执行此注册表操作，但未成功”：这对于防御者来说并没有太大作用。
- en: But for attackers, this detail is important because it can change the risk calculus
    involved in performing certain activities. If an action targeting the registry
    were to fail (such as an attempt to read a key that doesn’t exist or to create
    a new service with a mistyped registry path), it would likely go unnoticed. By
    checking for this logic when a driver is handling post-operation registry notifications,
    attackers can determine which unsuccessful actions would evade detection.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于攻击者来说，这个细节非常重要，因为它可能改变进行某些活动时的风险计算。如果针对注册表的操作失败（例如尝试读取一个不存在的键，或尝试创建一个路径拼写错误的新服务），通常是不会被发现的。通过检查驱动程序处理操作后注册表通知时的逻辑，攻击者可以确定哪些失败的操作会避开检测。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading EDR Drivers with Callback Entry
    Overwrites</samp>
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">通过回调入口覆盖规避 EDR 驱动程序</samp>
- en: In this chapter as well as [Chapters 3](chapter3.xhtml) and [4](chapter4.xhtml),
    we covered many kinds of callback notifications and discussed various evasions
    geared at bypassing them. Due to the complexity of EDR drivers and their different
    vendor implementations, it isn’t possible to entirely evade detection using these
    means. Rather, by focusing on evading specific components of the driver, operators
    can reduce the likelihood of triggering an alert.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及 [第 3 章](chapter3.xhtml) 和 [第 4 章](chapter4.xhtml) 中，我们讨论了多种回调通知并探讨了旨在绕过它们的各种规避方法。由于
    EDR 驱动程序的复杂性及其不同供应商的实现，无法完全通过这些手段规避检测。相反，通过专注于规避驱动程序的特定组件，操作员可以减少触发警报的可能性。
- en: However, if an attacker either gains administrator access on the host, has the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp> token
    privilege, or encounters a vulnerable driver that allows them to write to arbitrary
    memory, they may choose to target the EDR’s driver directly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果攻击者获得了主机的管理员权限、拥有 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>
    令牌特权，或遇到一个允许他们写入任意内存的易受攻击的驱动程序，他们可能会选择直接攻击 EDR 的驱动程序。
- en: This process most commonly involves finding the internal list of callback routines
    registered on the system, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCallProcessNotifyRoutines</samp>
    in the context of process notifications or <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsCallImageNotifyRoutines</samp>
    for image-load notifications. Researchers have publicly demonstrated this technique
    in many ways. [Listing 5-20](#list5-20) shows the output of Benjamin Delpy’s Mimidrv.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程最常见的做法是查找系统上注册的回调例程的内部列表，例如在进程通知上下文中使用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCallProcessNotifyRoutines</samp>，或图像加载通知使用的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsCallImageNotifyRoutines</samp>。研究人员已经以多种方式公开展示了这种技术。[列表
    5-20](#list5-20)展示了 Benjamin Delpy 的 Mimidrv 输出。
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 5-20: Using Mimidrv to enumerate process-notification callback routines'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-20：使用 Mimidrv 枚举进程通知回调例程
- en: Mimidrv searches for a byte pattern that indicates the start of the array holding
    the registered callback routines. It uses Windows build–specific offsets from
    functions inside *ntoskrnl.exe*. After locating the list of callback routines,
    Mimidrv determines the driver from which the callback originates by correlating
    the address of the callback function to the address space in use by the driver.
    Once it has located the callback routine in the target driver, the attacker can
    choose to overwrite the first byte at the entry point of the function with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RETN</samp> instruction (<samp class="SANS_TheSansMonoCd_W5Regular_11">0xC3</samp>).
    This would cause the function to immediately return when execution is passed to
    the callback, preventing the EDR from collecting any telemetry related to the
    notification event or taking any preventive action.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Mimidrv 搜索指示包含注册回调例程的数组开始位置的字节模式。它使用来自 *ntoskrnl.exe* 内部函数的 Windows 构建特定偏移量。定位回调例程列表后，Mimidrv
    通过将回调函数的地址与驱动程序正在使用的地址空间进行关联，确定回调源自哪个驱动程序。一旦定位到目标驱动程序中的回调例程，攻击者可以选择将函数入口点的第一个字节覆盖为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RETN</samp> 指令（<samp class="SANS_TheSansMonoCd_W5Regular_11">0xC3</samp>）。这样，当执行传递给回调时，函数将立即返回，从而防止
    EDR 收集与通知事件相关的遥测数据或采取任何预防措施。
- en: While this technique is operationally viable, deploying it comes with significant
    technical hurdles. First, unsigned drivers can’t be loaded onto Windows 10 or
    later unless the host is put into test mode. Next, the technique relies on build-specific
    offsets, which introduces complexity and unreliability to the tooling, as newer
    versions of Windows could change these patterns. Lastly, Microsoft has heavily
    invested in making Hypervisor-Protected Code Integrity (HVCI) a default protection
    on Windows 10 and has enabled it by default on secured-core systems. HVCI reduces
    the ability to load malicious or known-vulnerable drivers by protecting the code-integrity
    decision-making logic, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ci!g_CiOptions</samp>,
    which is commonly temporarily overwritten to allow an unsigned driver to be loaded.
    This drives up the complexity of overwriting a callback’s entry point, as only
    HVCI-compatible drivers could be loaded on the system, reducing the potential
    attack surface.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此技术在操作上是可行的，但其部署面临重大技术挑战。首先，未签名的驱动程序不能在Windows 10或更高版本上加载，除非将主机置于测试模式。接下来，该技术依赖于特定版本的偏移量，这为工具的使用带来了复杂性和不可靠性，因为Windows的新版本可能会更改这些模式。最后，微软已大量投入将Hypervisor保护的代码完整性（HVCI）作为Windows
    10的默认保护，并且在受保护核心系统上默认启用。HVCI通过保护代码完整性决策逻辑，包括常常被临时覆盖以允许加载未签名驱动程序的< samp class="SANS_TheSansMonoCd_W5Regular_11">ci!g_CiOptions</samp>，从而减少加载恶意或已知存在漏洞的驱动程序的能力。这增加了覆盖回调入口点的复杂性，因为系统上只能加载与HVCI兼容的驱动程序，从而减少了潜在的攻击面。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: While not as straightforward as the previously discussed callback types, image-load
    and registry-notification callbacks provide just as much information to an EDR.
    Image-load notifications can tell us when images, whether they be DLLs, executables,
    or drivers, are being loaded, and they give the EDR a chance to log, act, or even
    signal to inject its function-hooking DLL. Registry notifications provide an unparalleled
    level of visibility into actions affecting the registry. To date, the strongest
    evasion strategies an adversary can employ when facing these sensors is either
    to abuse a gap in coverage or logical flaw in the sensor itself or to avoid it
    entirely, such as by proxying in their tooling.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不像前面讨论的回调类型那样直观，图像加载和注册表通知回调同样能向EDR提供大量信息。图像加载通知可以告诉我们何时加载图像，无论是DLL、可执行文件还是驱动程序，它们都为EDR提供了记录、行动甚至信号注入其功能钩取DLL的机会。注册表通知则提供了前所未有的透明度，揭示了影响注册表的操作。迄今为止，面对这些传感器，攻击者可以使用的最强规避策略是利用覆盖范围的空白或传感器本身的逻辑缺陷，或者完全避免传感器，例如通过代理化其工具。
