- en: Part III
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分
- en: Implementation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 实现
- en: '8'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Secure Programming
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 安全编程
- en: The first principle is that you must not fool yourself, and you are the easiest
    person to fool.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一个原则是你绝不能欺骗自己，而你是最容易被欺骗的人。
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Richard P. Feynman
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —理查德·P·费曼
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'A completed software design, created and reviewed with security in mind, is
    only the beginning of a product’s journey: next comes the work of implementing,
    testing, deploying, operating, monitoring, maintaining, and, ultimately, retiring
    it at end of life. While the particular details of all this will vary greatly
    in different operating systems and languages, the broad security themes are so
    common as to be nearly universal.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的软件设计，经过考虑安全性后创建和审查，只是产品旅程的开始：接下来是实施、测试、部署、运营、监控、维护，最终在生命周期结束时退役的工作。尽管所有这些的具体细节在不同的操作系统和语言中会有很大的差异，但广泛的安全主题是如此常见，以至于几乎是普遍的。
- en: 'Developers must not only faithfully implement the explicit security provisions
    of a good design, but in doing so they must also take care to avoid inadvertently
    introducing additional vulnerabilities with flawed code. A carpenter building
    a house based on the architect’s plans is a good metaphor: sloppy construction
    with lousy materials leads to all kinds of problems in the finished product. If
    the carpenter misstrikes a nail and bends it, the problem is noticeable and easily
    remedied. By contrast, flawed code is easily overlooked, but may nevertheless
    create a vulnerability that can be exploited with dire consequences. The purpose
    of this chapter is not to teach you how to code—I’ll assume you already know about
    that—but rather how code becomes vulnerable and how to make it more secure. The
    following chapters cover many of the commonplace implementation vulnerabilities
    that continue to plague software projects.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员不仅必须忠实地实现良好设计中的显式安全条款，而且在实现过程中还必须小心避免通过有缺陷的代码无意中引入额外的漏洞。一个基于建筑师设计图纸建造房屋的木匠是一个很好的比喻：用劣质材料和粗糙的施工会导致最终产品出现各种问题。如果木匠打钉子时不小心弯了钉子，问题是显而易见并且容易修复的。相比之下，有缺陷的代码容易被忽视，但它仍然可能会创建一个可以被利用并带来严重后果的漏洞。本章的目的不是教你如何编码——我假设你已经了解这方面的知识——而是教你代码如何变得脆弱，以及如何让代码更加安全。接下来的章节将涵盖许多普遍存在的实施漏洞，这些漏洞继续困扰着软件项目。
- en: The line between design and implementation is not always clear, nor should it
    be. Thoughtful designers can anticipate programming issues, provide advice about
    areas where security will be critical, and much more. The programmers doing the
    implementation must flesh out the design and resolve any ambiguities in order
    to make functional code with precisely defined interfaces. Not only must they
    securely render the design—in itself a daunting task—but they must also avoid
    introducing additional vulnerabilities in the course of supplying the necessary
    code in full detail.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和实现之间的界限并不总是明确的，而且也不应该明确。深思熟虑的设计师可以预见编程问题，提供关于安全至关重要的领域的建议，等等。进行实现的程序员必须完善设计，并解决任何模糊之处，以便编写具有精确定义接口的功能性代码。他们不仅必须安全地呈现设计——这本身就是一项艰巨的任务——还必须避免在提供必要的详细代码过程中引入额外的漏洞。
- en: 'In an ideal world, the design should specify proactive security measures: features
    of the software built for the purpose of protecting the system, its assets, and
    its users. Conversely, security in development is about avoiding pitfalls that
    software is liable to—rough edges on the components and tools, if you will. Where
    new risks emerge during the process of implementation, mitigations specific to
    these are in order, because there is no reason to expect that designers could
    have anticipated them.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，设计应当指定主动的安全措施：为保护系统、资产和用户而构建的软件特性。相反，开发中的安全性是关于避免软件可能遇到的陷阱——如果你愿意，可以把它看作是组件和工具的粗糙边缘。当在实施过程中出现新风险时，应该针对这些风险采取相应的缓解措施，因为没有理由期望设计师能够预见到这些问题。
- en: 'This chapter focuses on how some bugs become vulnerabilities, how they occur,
    and how to avoid the various pitfalls. It approaches these issues in general terms
    as a lead-in to the following chapters, which drill into major areas that, historically,
    have proven to be fraught with security problems. We’ll begin by exploring the
    essence of the challenge of secure coding, including how attackers exploit openings
    and extend their influence deeper into code. We’ll also talk about bugs: how vulnerabilities
    arise from them, how minor bugs can form vulnerability chains that potentially
    create bigger problems, and how code appears through the lens of entropy.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论一些漏洞是如何从错误中产生的，它们是如何发生的，以及如何避免各种陷阱。它以一般性的问题展开，为接下来的章节做铺垫，这些章节将深入探讨历史上被证明充满安全问题的主要领域。我们将从探讨安全编码挑战的本质开始，包括攻击者如何利用漏洞并将其影响扩展到代码中更深层次。我们还将讨论错误：漏洞是如何从错误中产生的，轻微的错误如何形成可能导致更大问题的漏洞链，以及从熵的角度看待代码。
- en: Avoiding vulnerabilities in your code requires vigilance, but that requires
    knowledge of how code undermines security. To make the concept of a coding vulnerability
    concrete, we’ll walk through a simplified version of the code for a devastating
    real vulnerability that shows how a one-line editing slip-up broke security across
    the internet. Then we’ll look at a few classes of common vulnerabilities as examples
    of bugs that are potentially exploitable with serious consequences.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 避免代码中的漏洞需要保持警惕，但这需要了解代码如何破坏安全性。为了将编码漏洞的概念具体化，我们将通过一个简化版本的代码，展示一个致命的真实漏洞，说明如何通过一次简单的编辑失误导致全网的安全崩溃。接下来，我们将以几个常见漏洞的类别为例，展示一些可能被利用且后果严重的错误。
- en: Throughout Part III, most code examples will be in Python and C, widely used
    languages that span the range from high-level to low-level abstraction. This is
    real code using the particulars of the specific language, but the concepts in
    this book apply generally. Even if you are unfamiliar with Python or C, the code
    snippets should be simple enough for readers familiar with any modern programming
    language to follow.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三部分中，大多数代码示例将使用Python和C语言，这两种语言广泛应用，涵盖了从高级到低级的各种抽象层次。这些是真正的代码，使用了特定语言的细节，但书中的概念是通用的。即使你不熟悉Python或C语言，代码片段也应该足够简单，让任何熟悉现代编程语言的读者都能跟得上。
- en: The Challenge
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战
- en: The term “secure programming” was the obvious choice for the title of this chapter,
    though it is potentially misleading. A more accurate expression of the goal (unsuitable
    as a chapter title) would be “avoiding coding insecurely.” What I mean by that
    is that the challenge of secure coding largely amounts to not introducing flaws
    that become exploitable vulnerabilities. Programmers certainly do build protection
    mechanisms that proactively improve security, but these are typically explicit
    in the design or features of APIs. I want to focus primarily on the inadvertent
    pitfalls because they are nonobvious and constitute the root causes of most security
    failings. Think of secure coding as similar to learning where the potholes are
    in a road, diligently paying attention at the wheel, and navigating them consistently.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “安全编程”这个术语是本章标题的显而易见选择，尽管它可能具有误导性。更准确地表达目标（虽然不适合作为章节标题）应该是“避免不安全的编码”。我的意思是，安全编码的挑战主要在于不引入会成为可被利用的漏洞的缺陷。程序员当然会构建主动提高安全性的保护机制，但这些机制通常在设计或API的功能中是明确的。我想主要关注那些无意中陷入的陷阱，因为它们不明显，并构成大多数安全失败的根本原因。可以把安全编码看作是学习如何发现道路上的坑洞，仔细驾驶，并始终如一地避开它们。
- en: 'I believe that many programmers, perhaps quite rightfully, have unfavorable
    attitudes toward software security (and in some cases, more viscerally, about
    “security cops”—or worse names—who they perceive as bothering them) because they
    often hear the message “don’t mess up” when it comes to implementation. “Don’t
    mess up!” is unhelpful advice to a jeweler about to cut a rare diamond for the
    same reasons: they have every intention of doing their best, and the added stress
    only makes it harder to concentrate and do the job right. The well-meaning “cops”
    are providing necessary advice, but often they don’t phrase it in the most kindly
    and constructive way. Having made this mistake plenty of times myself, I am endeavoring
    to walk that fine line here, and ask for the reader’s understanding.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信许多程序员，或许有充分的理由，对软件安全持有不太友好的态度（在某些情况下，更直观地表现为对“安全警察”——或者更糟的称呼——的反感，因为他们认为这些人总是给他们添麻烦），因为他们通常听到的消息是“不要出错”。“不要出错！”对即将切割稀有钻石的珠宝商来说，这也是不太有帮助的建议：他们本打算尽全力做到最好，而额外的压力只会让他们更难集中注意力，做好工作。这些好意的“警察”确实在提供必要的建议，但他们往往没有以最友好、最建设性的方式表达出来。我自己也犯过这个错误很多次，所以在这里我尽力走好这条细线，也希望读者能够理解。
- en: Caution is indeed necessary, because one slip by a programmer (as we shall see
    when we look at the GotoFail vulnerability later in this chapter) can easily result
    in disastrous consequences. The root of the problem is the great fragility and
    complexity of large modern software systems, which are only expected to grow in
    the future. Professional developers know how to test and debug code, but security
    is another matter, because vulnerable code usually works fine absent a diligent
    attack.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确实需要小心，因为程序员的一次失误（正如我们稍后在本章讨论的GotoFail漏洞所示）很容易导致灾难性的后果。问题的根源在于大型现代软件系统的脆弱性和复杂性，而这种问题在未来只会加剧。专业开发人员知道如何测试和调试代码，但安全性则是另一回事，因为易受攻击的代码在没有严密攻击的情况下通常能够正常工作。
- en: Software designers create idealized conceptions that, by virtue of not yet being
    realized, can even be perfectly secure in theory. But making software that actually
    works introduces new levels of complexity and requires fleshing out details beyond
    the design, all of which inevitably carries the risk of security problems. The
    good news is that perfection isn’t the goal, and the coding failure modes that
    account for most of the common vulnerabilities are both well understood and not
    that difficult to get right. The trick is constant vigilance and learning how
    to look out for dangerous flaws in code. This chapter presents a few concepts
    that should help you get a good grasp of what secure versus vulnerable code looks
    like, along with some examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计师创造出理想化的概念，这些概念因为尚未实现，因此理论上可以是完全安全的。但要让软件真正运行起来，就会引入新的复杂性，并且需要填补设计之外的细节，这些都会不可避免地带来安全问题的风险。好消息是，完美并不是目标，导致大多数常见漏洞的编码失败模式已经被很好地理解，并且并不难做到正确。诀窍在于保持持续的警惕，学会识别代码中的危险缺陷。本章将介绍一些概念，帮助你更好地理解什么是安全代码与易受攻击的代码，并举一些例子。
- en: Malicious Influence
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶意影响
- en: 'When thinking about secure coding, a key consideration is understanding how
    attackers potentially *influence* running code. Think of a big, complicated machine
    purring away smoothly, and then a prankster takes a stick and starts poking the
    mechanism. Some parts, such as the cylinders of a gasoline engine, will be completely
    protected within the block, while other parts, such as a fan belt, are exposed,
    making it easy to jam something in, causing a failure. This is analogous to how
    attackers prod systems when attempting to penetrate them: they start from the
    attack surface and use cleverly crafted, unexpected inputs to try and foul the
    mechanism, then attempt to trick code inside the system into doing their bidding.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑安全编码时，一个关键的考虑因素是理解攻击者如何可能*影响*正在运行的代码。想象一个大型复杂的机器平稳运转，然后一个恶作剧者拿起一根棍子开始戳机械部件。有些部分，比如汽油发动机的气缸，会完全被机体保护起来，而另一些部分，比如风扇皮带，则是暴露在外的，容易被插入东西，导致故障。这就像攻击者试图渗透系统时的行为：他们从攻击面开始，利用巧妙设计的、出乎意料的输入来破坏机制，然后试图欺骗系统内部的代码，迫使它们按自己的意图行事。
- en: 'Untrusted inputs potentially influence code in two ways: directly and indirectly.
    Beginning wherever they can inject some untrusted input—say, the string “BOO!”—they
    experiment in hopes that their data will avoid rejection and propagate deeper
    into the system. Working down through layers of I/O and various interfaces, the
    string “BOO!” typically will find its way into a number of code paths, and its
    influence will permeate deeper into the system. Occasionally, the untrusted data
    and code interaction triggers a bug, or a feature that may have an unfortunate
    side effect. A web search for “BOO!” may involve hundreds of computers in a datacenter,
    each contributing a little to the search result. As a result, the string must
    get written to memory in thousands of places. That’s a lot of influence spread,
    and if there is even a minuscule chance of harm, it could be dangerous.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不受信输入可能通过两种方式影响代码：直接和间接。从任何可以注入不受信输入的地方开始——例如字符串“BOO!”——他们进行尝试，希望数据能够避免被拒绝并进一步传播到系统中。通过I/O层和各种接口逐层向下，字符串“BOO!”通常会找到多条代码路径，并且它的影响会渗透到系统中。偶尔，不受信数据和代码的交互会触发一个错误，或者产生一个可能带来不良副作用的功能。一次“BOO!”的网页搜索可能涉及数据中心中的数百台计算机，每台都为搜索结果贡献一部分。因此，这个字符串必须在成千上万的地方写入内存。这是一个广泛的影响，如果存在即使微小的危害机会，也可能是危险的。
- en: The technical term for this kind of influence of data on code is *tainting*,
    and a few languages have implemented features to track it. The Perl interpreter
    can track tainting for the purpose of mitigating injection attacks (covered in
    Chapter 10). Early versions of JavaScript had taint checking for similar reasons,
    though it has long since been removed due to lack of use. Still, the concept of
    influence on code by data from untrusted sources is important to understand to
    prevent vulnerabilities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据对代码影响的技术术语是*污染*，一些语言实现了跟踪污染的功能。Perl解释器可以跟踪污染，旨在缓解注入攻击（在第10章中讨论）。早期版本的JavaScript曾出于类似原因进行污染检查，但由于缺乏使用，这一功能早已被移除。不过，理解数据来自不受信源对代码的影响是很重要的，以便防止漏洞。
- en: 'There are other ways that input data can influence code indirectly without
    the data being stored. Suppose that, given an input of the string “BOO!”, the
    code avoids storing any further copies of it: Does that insulate the system from
    its influence? It certainly does not. For example, consider this given `input
    = "BOO!"`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据还可以以间接的方式影响代码，而不需要存储数据。假设，给定输入字符串“BOO!”，代码避免存储其任何进一步的副本：这是否意味着它使系统免受其影响？显然并非如此。例如，考虑以下`input
    = "BOO!"`：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The presence of the exclamation point in the input has caused the code to now
    pursue `PlanB` instead of `PlanA`, even though the input string itself is neither
    stored nor passed on for subsequent processing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输入中感叹号的存在使得代码现在选择执行`PlanB`而非`PlanA`，即使输入字符串本身既未被存储也未传递到后续处理。
- en: This simple example illustrates how the influence of an untrusted input can
    propagate deep into code, even though the data (here, “BOO!”) may not itself propagate
    far. In a large system, you can appreciate the potential of penetration into lots
    of code when you consider the transitive closure (the aggregate extent of all
    paths), starting from the attack surface. This ability to extend through many
    layers is important, because it means that attackers can reach into more code
    than you might expect, affording them opportunities to control what the code does.
    We’ll talk more about managing untrusted input in Chapter 10.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子说明了不受信输入如何深入传播到代码中，即便数据（此处为“BOO!”）本身并未广泛传播。在大型系统中，当你考虑从攻击面开始的传递闭包（所有路径的汇总扩展）时，可以更好地理解渗透到大量代码中的潜力。这种通过多层延伸的能力至关重要，因为它意味着攻击者可以进入比你预期更多的代码，从而控制代码的执行。我们将在第10章进一步讨论如何管理不受信输入。
- en: Vulnerabilities Are Bugs
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漏洞即错误
- en: If debugging is the process of removing bugs, then programming must be the process
    of putting them in.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果调试是去除错误的过程，那么编程一定是将错误加入的过程。
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Edsger Dijkstra
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —埃兹杰·戴克斯特拉
- en: 'That all software has bugs is so widely accepted that it is hardly necessary
    to substantiate the claim at this point. Of course, exceptions to this generalization
    do exist: trivial code, provably correct code, and highly engineered software
    that runs aviation, medical, or other critical equipment. But for everything else,
    awareness of the ubiquity of bugs is a good starting point from which to approach
    secure coding, because a subset of those bugs are going to be useful to attackers.
    So, bugs are our focus here.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有软件都有漏洞已经是如此广泛接受的事实，以至于现在几乎不需要再证明这一点。当然，这一普遍化也有例外：一些微不足道的代码、经过证明正确的代码以及用于航空、医疗或其他关键设备的高度工程化的软件。但对于其他所有软件，意识到漏洞的普遍性是接触安全编码的一个良好起点，因为其中一部分漏洞对攻击者有用。因此，错误是我们在这里关注的重点。
- en: '*Vulnerabilities* are a subset of software bugs useful to attackers to cause
    harm. It’s nearly impossible to accurately separate vulnerabilities from other
    bugs, so it may be easiest to start by identifying bugs that clearly are not vulnerabilities—that
    is, totally harmless bugs. Let’s consider some examples of bugs in an online shopping
    website. A good example of an innocuous bug might be a problem with the web page
    layout not working as designed: it’s a bit of a mess, but all important content
    is fully visible and functional. While this might be important to fix for reasons
    of brand image or usability, it’s clear that there is no security risk associated
    with this bug. But to emphasize how tricky vulnerability spotting can be, there
    could be similar bugs that mess up layout and are also harmful, such as if they
    obscure important information the user must see to make an accurate security decision.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*漏洞*是软件错误的一个子集，攻击者可以利用这些漏洞造成危害。准确区分漏洞和其他错误几乎是不可能的，因此，最简单的方式可能是先识别出那些显然不是漏洞的错误——也就是说，完全无害的错误。我们来看一下在线购物网站中的一些错误实例。一个无害错误的典型例子可能是网页布局没有按照设计工作：页面有些凌乱，但所有重要内容都完全可见且功能正常。虽然从品牌形象或可用性的角度来看，这个问题可能需要修复，但显然这个错误并不会带来任何安全风险。然而，为了强调漏洞发现的困难性，类似的错误可能既破坏了布局，又可能带来危害，比如它遮掩了用户必须看到的关键信息，而这些信息对做出准确的安全决策至关重要。'
- en: 'At the harmful end of the spectrum, here’s a nightmarish vulnerability to contemplate:
    the administrative interface becomes accidentally exposed, unprotected, on the
    internet. Now, anyone visiting the website can click a button to go into the console
    used by managers to change prices, see confidential business and financial data,
    and more. It doesn’t take a genius to see that this is a complete failure of authorization
    and a clear security threat.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个范围的危害端，这里有一个令人不寒而栗的漏洞值得深思：管理界面意外暴露并未加以保护，出现在互联网中。现在，任何访问该网站的人都可以点击按钮进入由管理员用来更改价格、查看机密业务和财务数据等的控制台。谁都能看出，这完全是授权失败，并且是一个明显的安全威胁。
- en: Of course, there is a continuum between those extremes, with a large murky area
    in the middle that requires subjective judgments about the potential of a bug
    to cause harm. And as we will see in the next section, the often unforeseen cumulative
    effects of multiple bugs make determining their potential for harm particularly
    challenging. In the interests of security, naturally, I would urge you to err
    on the safe side and lean toward remedying more bugs if there is any chance they
    might be vulnerabilities.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些极端情况之间有一个连续体，中间有一个很大的模糊区域，需要根据错误可能造成的危害进行主观判断。正如我们将在下一节中看到的那样，多个错误的常常是不可预见的累积效应，使得判断它们的危害潜力变得特别具有挑战性。出于安全的考虑，自然地，我会建议你采取保守的态度，倾向于修复更多的错误，如果它们有可能是漏洞的话。
- en: Every project I’ve ever worked on had a tracking database filled with tons of
    bugs, but no concerted effort to reduce even the known bug count (which is very
    different from the actual bug count) to zero. So it’s safe to say that, generally,
    all of us program alongside a trove of known bugs, not to mention the unknown
    bugs. If it isn’t already actively done, consider working through the known bugs
    and flagging possible vulnerabilities for fixing. It’s important to mention, too,
    that it’s almost always easier to just fix a bug than to investigate and prove
    that it’s harmless. Chapter 13 offers guidance on assessing and ranking security
    bugs to help you prioritize vulnerabilities.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与过的每个项目都有一个追踪数据库，里面充满了大量的错误，但没有针对减少已知错误数量（这与实际错误数量不同）做出系统的努力。因此，可以说，通常我们都在一堆已知错误中编程，更不用提那些未知的错误。如果尚未主动执行，考虑处理已知错误并标记可能的漏洞以便修复。还需要提到的是，通常修复一个错误比调查并证明它无害要容易得多。第13章提供了关于评估和排名安全漏洞的指导，帮助你优先处理漏洞。
- en: Vulnerability Chains
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漏洞链
- en: 'The idea behind *vulnerability chains* is that seemingly harmless bugs can
    combine to create a serious security bug. It’s bug synergy for the attackers.
    Think of taking a walk and coming upon a stream you would like to cross. It’s
    far too wide to leap across, but you notice a few stones sticking up above the
    surface: by hopping from stone to stone, it’s easy to cross without getting your
    shoes wet. These stones represent minor bugs, not vulnerabilities themselves,
    but together they form a new path right through the stream, allowing the attacker
    to reach deep inside the system. These stepping-stone bugs form, in combination,
    an exploitable vulnerability.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*漏洞链*的背后理念是，看似无害的错误可能会结合在一起，产生一个严重的安全漏洞。这对攻击者而言就是错误的协同效应。想象一下你在散步时碰到一条想要穿越的溪流，溪流宽得无法跳过去，但你注意到有几块石头露出水面：通过从石头跳到石头，你可以轻松地穿越而不弄湿鞋子。这些石头代表的是轻微的错误，而不是漏洞本身，但它们一起形成了一条新的通道，穿过溪流，允许攻击者深入系统内部。这些“垫脚石”错误通过组合形成了一个可利用的漏洞。'
- en: 'Here’s a simple example of how such a vulnerability chain could arise in an
    online shopping web app. After a recent code change, the app’s order form has
    a new field prefilled with a code indicating which warehouse will handle the shipment.
    Previously, business logic in the backend assigned a warehouse after the customer
    placed the order. Now a field that’s editable by the customer determines the warehouse
    that will handle the order. Call this Bug #1\. The developer responsible for this
    change suggests that nobody will notice the addition, and furthermore, even should
    anyone modify the warehouse designation that the system supplies by default, another
    warehouse won’t have the requested items in stock, so it will get flagged and
    corrected: “No harm, no foul.” Based on this analysis, but without any testing,
    the team schedules Bug #1 for the next release cycle. They’re glad to save themselves
    a fire drill and schedule slip, and push the buggy code change into production.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个简单的示例，说明在线购物Web应用中如何产生这样的漏洞链。在最近的一次代码更改后，应用的订单表单新增了一个字段，预填充了一个代码，表示哪个仓库将负责发货。以前，后台的业务逻辑是在客户下单后分配仓库。现在，由客户编辑的一个字段决定了处理订单的仓库。我们称之为Bug
    #1。负责此更改的开发人员认为没有人会注意到这个新增字段，而且即便有人修改了系统默认提供的仓库分配，另一个仓库可能没有所需商品库存，所以系统会标记并修正：
    “没有害处，无所谓”。基于这一分析，但没有进行任何测试，团队决定将Bug #1安排在下一个发布周期进行处理。他们很高兴能够避免紧急处理和延期，将这个有问题的代码更改推入生产环境。'
- en: 'Meanwhile, a certain Bug #2 is languishing in the bug database with a Priority-3
    ranking (meaning “fix someday,” which is to say, probably never), long forgotten.
    Years ago, a tester filed Bug #2 after discovering that if you place an order
    with the wrong warehouse designation, the system immediately issues a refund because
    that warehouse is unable to fulfill it; but then another processing stage reassigns
    the order to the correct warehouse, which fulfills and ships it. The tester saw
    this as a serious problem—the company would be giving away merchandise for free—and
    filed it as Priority-1\. In the triage meeting, the programmers insisted that
    the tester was “cheating” because the backend handled the warehouse assignment
    (before Bug #1 was introduced) after confirming available inventory. In other
    words, at the time of discovery, Bug #2 was purely hypothetical and could never
    have happened in production. Since the interaction of various stages of business
    logic would be difficult to untangle, the team decided to leave it alone and make
    the bug Priority-3, and it was quickly forgotten.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '与此同时，Bug #2正在错误数据库中以Priority-3的排名（意味着“某天修复”，也就是可能永远不会修复）萎靡不振，早已被遗忘。多年前，一位测试人员在发现如果使用错误的仓库指定下订单，系统会立即发放退款，因为该仓库无法履行订单；但随后另一个处理阶段将订单重新分配给正确的仓库，由该仓库履行并发货后，提交了Bug
    #2。测试人员认为这是一个严重的问题——公司将免费赠送商品——并将其列为Priority-1。在评审会议中，程序员坚持认为测试人员是在“作弊”，因为后台处理了仓库分配（在Bug
    #1引入之前）并确认了库存。换句话说，在发现时，Bug #2纯粹是假设性的，在生产环境中根本不会发生。由于不同业务逻辑阶段的相互作用难以解开，团队决定不管它，并将Bug的优先级设为Priority-3，很快就被遗忘了。'
- en: 'If you followed this story of “letting sleeping bugs lie” you probably already
    can see that it has an unhappy ending. With the introduction of Bug #1, in combination
    with Bug #2, a fully fledged vulnerability chain now exists, almost certainly
    unbeknownst to anyone. Now that the warehouse designation field is writable by
    customers, the wrong warehouse case that triggers Bug #2 is easy to produce. All
    it takes is for one devious, or even curious, customer to try editing the warehouse
    field; pleasantly surprised to receive free merchandise with a full refund, they
    might go back for a lot more the next time, or share the secret with others.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你跟随了这个“放任Bug不管”的故事，你可能已经能看出它以一个不太愉快的结局收场。随着Bug #1的引入，加上Bug #2，现在已经存在了一个完全成熟的漏洞链，几乎可以肯定没人察觉到。现在，由于仓库指定字段可以被客户写入，触发Bug
    #2的错误仓库情况变得容易产生。只要有一个狡猾的，甚至是好奇的客户尝试编辑仓库字段；他们会高兴地发现能够免费获得商品并全额退款，下次可能会回来购买更多，或者与他人分享这个秘密。'
- en: 'Let’s look at where the bug triage went wrong. Bug #2 (found earlier) was a
    serious fragility that they should have fixed in the first place. The reasoning
    in favor of leaving it alone hinged on the warehouse trusting other backend logic
    to direct it flawlessly, under the assumption (correct, at the time) that the
    warehouse assignment field in an order was completely isolated from any attack
    surface. Still, it’s clearly a worrisome fragility that clearly has bad consequences,
    and the fact that the business logic would be difficult to fix suggests that a
    rewrite might be a good idea.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看错误的bug评审过程在哪里出错了。Bug #2（较早发现的）是一个严重的脆弱性，他们本应该一开始就修复它。支持放任不管的推理依赖于仓库信任其他后台逻辑能够完美指引它，假设（当时是正确的）订单中的仓库指定字段与任何攻击面完全隔离。尽管如此，它显然是一个令人担忧的脆弱性，显然会带来不好的后果，而业务逻辑难以修复的事实暗示着重写可能是个好主意。'
- en: 'Bug #1, introduced later on, opened up a new attack surface, exposing the warehouse
    designation field to tampering. The unfortunate decision not to fix this depended
    on the incorrect assumption that tampering was harmless. With the benefit of hindsight,
    had anyone done a little testing (in a test environment, of course, never in production),
    they could have easily found the flaw in their reasoning and done the right thing
    before releasing Bug #1\. And, ideally, had the tester who found Bug #2, or anyone
    familiar with it, been present, they might have connected the dots and slated
    both bugs for fixing as Priority-1\.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bug #1，后来的引入，打开了一个新的攻击面，暴露了仓库指定字段的篡改风险。未修复这个问题的不幸决定源于错误的假设，认为篡改是无害的。事后看来，如果有人稍微进行一些测试（当然是在测试环境中进行，绝不能在生产环境中），他们本可以轻松发现他们推理中的漏洞，并在发布Bug
    #1之前做出正确的决定。理想情况下，如果发现Bug #2的测试人员，或任何熟悉该问题的人在场，他们可能会将两者联系起来，并将这两个bug列为Priority-1进行修复。'
- en: Compared to this artificial example, recognizing when bugs form vulnerability
    chains is, in general, very challenging. Once you understand the concept, it’s
    easy to see the wisdom of fixing bugs proactively whenever possible. Furthermore,
    even when you do suspect a vulnerability chain might exist, I should warn you
    that in practice it’s often hard to convince others to spend time implementing
    a fix for what looks like a vague hypothetical, especially when fixing the bug
    in question entails significant work. It’s likely that most large systems are
    full of undetected vulnerability chains, and our systems are weaker for it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 相比这个人为的例子，识别漏洞何时形成漏洞链通常是非常具有挑战性的。一旦你理解了这一概念，你就会明白，尽可能主动修复漏洞的智慧。更重要的是，即使你怀疑可能存在漏洞链，我还是要提醒你，在实际操作中，通常很难说服别人花时间修复看起来像是模糊假设的问题，特别是当修复这个漏洞需要大量工作时。很可能大多数大型系统中都充满了未被发现的漏洞链，而我们的系统因此变得更脆弱。
- en: 'This example illustrates how two bugs can align into a causal chain, much like
    a tricky billiards shot with the cue ball hitting another ball, that in turn knocks
    the target ball into the pocket. Believe it or not, vulnerability chains can be
    a good deal more involved: one team in the Pwn2Own competitive hacking contest
    managed to chain together *six bugs* to achieve a difficult exploit.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了两个漏洞如何形成因果链，就像一杆巧妙的台球击球，母球击中另一颗球，进而将目标球打入球袋。信不信由你，漏洞链可能比这更复杂：在Pwn2Own黑客竞赛中，有一支团队成功地将*六个漏洞*串联起来，达成了一个困难的攻击。
- en: 'When you understand vulnerability chains, you can better appreciate the relationship
    of code quality to security. Bugs introducing fragility, especially around critical
    assets, should be fixed aggressively. Punting a bug because “it will never happen”
    (like our Bug #2) is risky, and you should bear in mind that one person’s opinion
    that it will be fine is just that, an opinion, not a proof. Such thinking is akin
    to the Security by Obscurity anti-pattern and at best a temporary measure rather
    than a good final triage decision.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '当你理解漏洞链时，你能更好地理解代码质量与安全性之间的关系。引入脆弱性的漏洞，尤其是在关键资产周围，应该积极修复。因为“它永远不会发生”（就像我们说的Bug
    #2）而推迟修复是很危险的，你需要记住，一个人认为它没问题的观点，只是观点而已，并不是证据。这种思维类似于“安全即隐藏”的反模式，充其量只是一个临时措施，而不是一个好的最终筛选决策。'
- en: Bugs and Entropy
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漏洞和熵
- en: Having surveyed vulnerabilities and vulnerability chains, next consider that
    software is also liable to less precise sequences of events that can do damage.
    Some bugs tend to break things in unpredictable ways, which makes an analysis
    of their exploitability (as with a vulnerability chain) difficult. As evidence
    of this phenomenon, we commonly reboot our phones and computers to clear out the
    entropy that accumulates over time due to the multitude of bugs. (Here I’m using
    the word *entropy* loosely, to evoke an image of disorder and metaphorical corrosion.)
    Attackers can sometimes leverage these bugs and their aftereffects, so countermeasures
    can help improve security.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解漏洞和漏洞链之后，接下来考虑一下，软件也容易受到不那么精确的事件序列的影响，这些事件可能造成损害。一些漏洞倾向于以不可预测的方式破坏事物，这使得分析它们的可利用性（就像漏洞链一样）变得困难。作为这种现象的证据，我们常常重启手机和计算机，以清除随着时间积累的熵（这里我使用“熵”这个词有点宽泛，旨在唤起混乱和隐喻腐蚀的形象）。攻击者有时可以利用这些漏洞及其后效，因此采取对策可以帮助提升安全性。
- en: Bugs arising from unexpected interactions between threads of execution are one
    class prone to this kind of trouble, because they typically present in a variety
    of ways, seemingly at random. Memory corruption bugs are another such class, because
    the contents of the stack and heap are in constant flux. These sorts of bugs,
    which perturb the system in unpredictable ways, can almost be juicier targets
    for attack because they offer potentially endless possibilities. Attackers can
    be quite adept at exploiting such messy bugs, and automation makes it easy to
    retry low-yield attempts until they get lucky. On the flip side, most programmers
    dislike taking on these elusive bugs that are hard to pin down and frequently
    deemed too flaky to be of concern, and hence they tend to persist unaddressed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于执行线程之间意外的交互而引发的错误是一类容易出现这种问题的错误，因为它们通常以各种方式呈现，似乎是随机的。内存损坏错误是另一类此类错误，因为栈和堆的内容在不断变化。这些以不可预测的方式扰乱系统的错误，几乎是攻击的更有价值的目标，因为它们提供了潜在的无限可能性。攻击者可以非常熟练地利用这些混乱的错误，自动化使得他们可以轻松地反复尝试低效的攻击，直到运气好。另一方面，大多数程序员不喜欢处理这些难以捉摸的错误，因为它们难以定位，而且常常被认为是太不稳定以至于不值得关注，因此这些错误往往未能得到解决。
- en: Even if you cannot nail down a clear causal chain, entropy-inducing bugs can
    be dangerous and are well worth fixing. All bugs introduce amounts of something
    like entropy into systems, in the sense that they are slight departures from the
    correct behavior, and those small amounts of disturbance quickly add up—especially
    if abetted by a wily attacker. By analogy with the Second Law of Thermodynamics,
    entropy inevitably builds up within a closed system, raising the risk of harm
    due to bugs of this type becoming exploitable at some point.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你无法确定一个明确的因果链，引发熵的错误仍然是危险的，值得修复。所有的错误都会向系统引入一定量的熵，因为它们是从正确行为中略微偏离的表现，而这些小的干扰迅速累积——特别是如果被狡猾的攻击者利用的话。类比热力学第二定律，熵不可避免地在封闭系统内积累，随着时间的推移，这类错误可能在某个时刻变得可以被利用，从而增加了伤害的风险。
- en: Vigilance
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警觉性
- en: I love hiking, and the trails in my area are often muddy and slippery, with
    exposed roots and rocks, so slipping and falling is a constant threat. With practice
    and experience, slips have become rare, but what’s uncanny is that in particularly
    treacherous spots, where I focus, I never slip. While occasionally I do still
    fall, rather than due to any obstacle, it’s usually on an easier part of the trail,
    because *I just wasn’t paying attention*. The point here is that with awareness,
    difficult challenges can be mastered; and conversely, inattention easily undermines
    you, even when the going is easy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢徒步旅行，我所在地区的步道常常泥泞湿滑，露出的树根和岩石使得滑倒和摔跤成为一个常见的威胁。随着实践和经验的积累，滑倒的情况变得少见，但奇怪的是，在特别危险的地方，当我集中注意力时，我从未滑倒。尽管偶尔我还是会摔倒，但这通常不是因为有什么障碍，而是因为在步道的较容易部分，*我没有注意到*。这里的重点是，凭借警觉性，困难的挑战可以被克服；相反，漫不经心很容易让你失败，即使在轻松的时候也是如此。
- en: 'Software developers face just such a challenge: without awareness of potential
    security pitfalls and sustained focus, it’s easy to unwittingly fall into them.
    Developers instinctively write code to work for the normal use case, but attackers
    often try the unexpected in hopes of finding a flaw that might lead to an exploit.
    Maintaining vigilance to anticipate the full range of possible inputs and combinations
    of events is critical, as described previously in terms of vulnerability chains
    and entropy, to delivering secure code.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发人员面临的正是这样的挑战：如果没有意识到潜在的安全陷阱并保持持续的专注，很容易不知不觉地掉入其中。开发人员本能地编写代码以适应正常的使用情况，但攻击者往往会尝试出乎意料的情况，希望能找到一个可能导致漏洞的缺陷。正如前面提到的脆弱链和熵一样，保持警觉，预测所有可能的输入和事件组合，是编写安全代码的关键。
- en: The following section and chapters present a broad representative survey of
    the vulnerabilities that plague modern software, with “toy” code examples used
    to show what implementation vulnerabilities look like. As Marvin Minsky, one of
    the artificial intelligence legends at MIT, whom I was fortunate to meet during
    my time there, points out, “In science one can learn the most by studying the
    least.” In this context, that means that simplified code examples aid explanation
    by making it easy to focus on the critical flaw. In practice, vulnerabilities
    are woven into the fabric of a great profusion of code, along with a lot of other
    things that are important to the task but irrelevant to the security implications,
    and are not so easily recognized. If you want to look at real-world code examples,
    browse the bug database of any open source software project—they are all sure
    to have security bugs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节提供了一个广泛的代表性调查，展示了现代软件中常见的漏洞，并通过“玩具”代码示例来展示实现漏洞是什么样的。正如麻省理工学院人工智能传奇人物马文·明斯基（Marvin
    Minsky）指出的那样，“在科学中，人们通过研究最少的东西学到最多的东西。”在这个背景下，这意味着简化的代码示例通过让人们专注于关键缺陷，帮助解释问题。在实际应用中，漏洞往往是被融入大量代码的结构中，代码中还有很多其他对于任务来说很重要，但与安全隐患无关的内容，且这些漏洞并不容易被识别。如果你想查看真实的代码示例，可以浏览任何开源软件项目的错误数据库——这些项目肯定有安全漏洞。
- en: Vigilance requires discipline at first, but with practice it becomes second
    nature when you know what to watch out for. Remember that if your vigilance pays
    off and you do manage to fend off a would-be attacker, you probably will never
    know it—so celebrate each small victory, as you avert hypothetical future attacks
    with every fix.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 警觉性最初需要一定的纪律，但随着实践的积累，知道该注意什么后，它会变成第二天性。记住，如果你的警觉性得到了回报，并且成功阻止了一个潜在的攻击者，你可能永远都不会知道——所以庆祝每一次小小的胜利，因为每次修复都在避免未来可能发生的攻击。
- en: 'Case Study: GotoFail'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：GotoFail
- en: Some vulnerabilities are nasty bugs that don’t follow any pattern, somehow slip
    past testing, and get released. One property of vulnerabilities that makes this
    more likely to happen than you might expect is that the code often works for typical
    usage, and only displays harmful behavior when stressed by an intentional attack.
    In 2014, Apple quietly released a set of critical security patches for most of
    its products, declining to explain the problem for “the protection of our customers.”
    It didn’t take long for the world to learn that the vulnerability was due to an
    apparent editing slip-up that effectively undermined a critical security protection.
    It’s easy to understand what happened by examining a short excerpt of the actual
    code. Let’s take a look.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些漏洞是顽固的错误，它们不遵循任何模式，某种方式悄悄地绕过测试并被发布出去。漏洞的一个特点是它们通常在典型的使用情况下没有问题，只有在遭遇故意攻击时才会表现出有害行为，这使得漏洞比你想象的更容易发生。2014年，苹果悄悄发布了一组关键的安全补丁，涵盖了大部分产品，但却没有解释问题的原因，称是“为了保护客户”。不久，世界就知道这个漏洞是由于一个明显的编辑失误，实际上破坏了一个关键的安全保护。通过检查实际代码的一个简短摘录，很容易理解发生了什么。我们来看看。
- en: One-Line Vulnerability
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单行漏洞
- en: 'To set the stage, the code in question runs during secure connection establishment.
    It checks that everything is working properly in order to secure subsequent communications.
    The security of the Secure Sockets Layer (SSL) protocol rests on checking that
    the server signs the negotiated key, authenticated according to the server’s digital
    certificate. More precisely, the server signs the hash of several pieces of data
    that the ephemeral key derives from. Chapter 11 covers the basics of SSL, but
    you can follow the code behind this vulnerability without knowing any of those
    details. Here is the C++ code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设定场景，相关代码在安全连接建立过程中运行。它检查一切是否正常，以确保后续通信的安全。安全套接字层（SSL）协议的安全性依赖于检查服务器是否签署了经过认证的协商密钥，并且这个认证是根据服务器的数字证书进行的。更准确地说，服务器签署的是一个哈希值，这个哈希值是由临时密钥衍生出来的多个数据块组合而成。第11章涵盖了SSL的基础知识，但即使你不了解这些细节，也可以理解这个漏洞背后的代码。这里是C++代码：
- en: '**vulnerable code**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞代码**'
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The three calls to `SSLHashSHA1.update` feed their respective chunks of data
    into the hash function and check for the nonzero return error case. The details
    of the hash computation are beside the point for our purposes, and not shown;
    just know that this computation is critical to security, since its output must
    match an expected value in order to authenticate the communication.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 三次调用`SSLHashSHA1.update`将各自的数据块输入到哈希函数中，并检查非零返回值的错误情况。哈希计算的细节对于我们而言无关紧要，且没有展示；只需知道，这个计算对安全至关重要，因为其输出必须与预期值匹配，才能验证通信。
- en: 'At the bottom of the function, the code frees up a couple of buffers, and then
    returns the value of `err`: zero for success, or a nonzero error code.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的底部，代码释放了一些缓冲区，然后返回`err`的值：成功时为零，或者为非零的错误代码。
- en: 'The intended pattern in the code is clear: keep checking for nonzero return
    values indicating error, or sail through with zeros if everything is fine, and
    then return that. You probably already see the error—the duplicated `goto fail`
    line. Notwithstanding the suggestive indentation, this unconditionally shunts
    execution down to the `fail` label, skipping the rest of the hash computation
    and skipping the hash check altogether. Since the last assignment to `err` before
    the extra jump was a zero value, this function suddenly unconditionally approves
    of everything. Presumably this bug went undetected because valid secure connections
    still worked: the code didn’t check the hash, but if it had, they all would have
    passed anyway.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的预期模式很清楚：不断检查返回值是否为非零，表示错误；如果一切正常，则通过零值继续执行，然后返回该值。你可能已经看到了错误——重复的`goto fail`行。尽管有提示性的缩进，这条语句无条件地将执行跳转到`fail`标签，跳过了剩余的哈希计算，并完全跳过了哈希检查。由于在额外跳转前最后一次对`err`的赋值是零值，因此该函数突然无条件地批准了所有内容。可以推测，这个bug没有被发现，因为有效的安全连接仍然能正常工作：代码没有检查哈希，但即使检查了，它们也会通过。
- en: Beware of Footguns
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小心脚本陷阱
- en: 'GotoFail is a great argument for the wisdom of structuring code by indentation,
    as languages such as Python do. The C language enables a kind of *footgun* (a
    feature that makes it easy to shoot yourself in the foot) by instead determining
    a program’s structure syntactically. This allows indentation that, by standard
    code style conventions, is potentially misleading because it implies different
    semantics, even though it’s completely ignored by the compiler. When looking at
    this code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GotoFail是构造代码时遵循缩进结构智慧的一个有力论据，就像Python等语言所做的那样。C语言通过语法决定程序结构，提供了一种*脚本陷阱*（容易自伤的功能），这使得编写代码时按标准代码风格惯例缩进，可能会产生误导性的效果，因为它暗示了不同的语义，尽管编译器完全忽略了这些缩进。当你看到这段代码时：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'programmers might easily see the following (unless they are careful and mentally
    compiling the code):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可能很容易看到以下情况（除非他们很小心，并且在脑海中编译代码）：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Meanwhile, the compiler unambiguously sees:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，编译器清楚地看到：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A simple editing error happened to be easily missed, and also dramatically changed
    the code, right at the heart of a critical security check. That’s the epitome
    of a serious vulnerability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的编辑错误恰好容易被忽视，并且在关键的安全检查的核心部分极大地改变了代码。这就是一个严重漏洞的典型体现。
- en: Beware of other such footguns in languages, APIs, and other programming tools
    and data formats. You’ll see many examples in the following chapters, but another
    one from C syntax that I’ll mention here is writing `if (x = 8)` instead of `if
    (x == 8)`. The former assigns `8` to `x`, unconditionally executing the then-clause,
    since that value is nonzero; the latter compares `x` to `8`, executing the then-clause
    only if it’s true—quite different, indeed. While some would argue against it stylistically,
    I like to write such C statements as `if (8 == x)` because if I forget to double
    the equal sign, it is a syntax error and the compiler will catch it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 小心其他类似的脚本陷阱，出现在编程语言、API以及其他编程工具和数据格式中。你将在接下来的章节中看到许多例子，但这里我想提到的另一个来自C语法的例子是写`if
    (x = 8)`而不是`if (x == 8)`。前者将`8`赋值给`x`，无条件执行then-clause，因为该值非零；后者将`x`与`8`进行比较，仅当其为真时才执行then-clause——这两者确实有很大的不同。虽然有些人可能从风格上反对，但我喜欢把这种C语句写成`if
    (8 == x)`，因为如果我忘记写两个等号，它将会是一个语法错误，编译器会捕捉到。
- en: Compiler warnings can help flag this sort of slip-up. The GCC compiler’s `-Wmisleading-indentation`
    warning option is intended for just the sort of problem that caused the GotoFail
    vulnerability. Some warnings indicate potential trouble in subtler ways. An unused
    variable warning seems benign enough, but say there are two variables with similar
    names and you accidentally typed the wrong one in an important access test, resulting
    in the warning and also the use of the wrong data for a crucial test. While warnings
    are by no means reliable indicators of all vulnerabilities, they are easy to check
    and just might save the day.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器警告有助于标记这种疏忽。GCC编译器的`-Wmisleading-indentation`警告选项专门用于解决像GotoFail漏洞所导致的此类问题。有些警告以更微妙的方式指示潜在问题。未使用的变量警告似乎无害，但假设有两个变量名字相似，你不小心在重要的访问测试中输入了错误的变量，结果触发了警告，并且使用了错误的数据进行关键测试。虽然警告并不是所有漏洞的可靠指示器，但它们容易检查，可能会在关键时刻救场。
- en: Lessons from GotoFail
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从GotoFail中的教训
- en: 'There are several important lessons we can learn from GotoFail:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从GotoFail中学到几个重要的教训：
- en: Small slips in critical code can have a devastating impact on security.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键代码中的小失误可能对安全性造成毁灭性影响。
- en: The vulnerable code still works correctly in the expected case.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱的代码在预期情况下仍然能正常工作。
- en: It’s arguably more important for security to test that code like this rejects
    invalid cases than that it passes the normal legit uses.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从安全的角度看，测试此类代码是否能够拒绝无效情况，可能比测试它通过正常合法使用更为重要。
- en: Code reviews are an important check against bugs introduced by oversight. It’s
    hard to imagine how a careful reviewer looking at a code diff could miss this.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查是防止由于疏忽引入的漏洞的重要检查环节。很难想象一个认真审查代码差异的审查员会错过这个问题。
- en: 'This vulnerability suggests a number of countermeasures that could have prevented
    it from occurring. Some of these are specific to this particular bug, but even
    those should suggest the sorts of precautions you could apply elsewhere to save
    yourself the pain of creating flawed code. Useful countermeasures include:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞提出了一些本可以防止其发生的对策。这些对策中有些特定于此特定漏洞，但即便如此，这些对策也应该能够提示你在其他地方应用相似的预防措施，以避免编写出有缺陷的代码。有效的对策包括：
- en: Better testing, of course. At a minimum, there should have been a test case
    for each of those `if`s to ensure that all necessary checks worked.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，更好的测试。至少，应该为每个`if`编写测试用例，以确保所有必要的检查都能正常工作。
- en: Watch out for unreachable code (many compilers have options to flag this). In
    the case of GotoFail, this could have tipped the programmers off to the introduction
    of the vulnerability.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意不可达代码（许多编译器有选项来标记此类代码）。在GotoFail的情况下，这可能已经让程序员意识到漏洞的引入。
- en: Make code as explicit as possible, for example by using parentheses and curly
    braces liberally, even where they could be omitted.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使代码尽可能明确，例如，使用圆括号和大括号，即使在可以省略的地方也要广泛使用。
- en: Use source code analysis tools such as “linters,” which can improve code quality,
    and in the process may flag some potential vulnerabilities for preemptive fixing.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用源代码分析工具，如“代码检查工具”（linters），可以提高代码质量，在这个过程中，可能会标记出一些潜在漏洞，提前进行修复。
- en: Consider ad hoc source code filters to detect suspect patterns such as, in this
    case, duplicated source code lines, or any other recurrent errors.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑使用临时的源代码过滤器来检测可疑的模式，例如在这种情况下，检测重复的源代码行，或任何其他重复的错误。
- en: Measure and require full test coverage, especially for security-critical code.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量并要求对安全关键代码进行全面的测试覆盖。
- en: These are just some of the basic techniques you can use to spot bugs that could
    undermine security. As you encounter new classes of bugs, consider how tools might
    be applied to systemically avoid repeated occurrences in the future—doing so should
    reduce vulnerabilities in the long term.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你可以用来发现可能危害安全的漏洞的一些基本技巧。当你遇到新的漏洞类型时，考虑如何利用工具系统性地避免未来的重复发生——这样做应该能在长期减少漏洞。
- en: Coding Vulnerabilities
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码漏洞
- en: All happy families are alike; each unhappy family is unhappy in its own way.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有幸福的家庭都是相似的；每个不幸的家庭都有自己不幸的方式。
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Leo Tolstoy
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——列夫·托尔斯泰
- en: 'Sadly, the famous opening line from Leo Tolstoy’s novel *Anna Karenina* applies
    all too well to software: the prospects for new kinds of bugs are endless, and
    attempting to compile a complete list of all potential software vulnerabilities
    would be a fool’s errand. Categories are useful, and we will cover many of them,
    but do not confuse them with a complete taxonomy covering the full range of possibilities.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，列夫·托尔斯泰的小说*《安娜·卡列尼娜》*中的著名开头句子在软件领域也同样适用：新的漏洞种类是无穷无尽的，试图列出所有潜在的软件漏洞将是愚蠢的。分类是有用的，我们将讨论许多分类，但不要把它们与涵盖所有可能性的完整分类体系混淆。
- en: This book by no means presents an exhaustive list of all potential flaws, but
    it does cover a representative swath of many of the most common categories. This
    basic survey should provide you with a good start, and with experience you will
    begin to intuit additional issues and learn how to safely steer clear of them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并未呈现所有潜在缺陷的详尽列表，但它确实覆盖了许多最常见类别的代表性内容。这一基本调查应该能为你提供一个良好的起点，随着经验的积累，你将开始直觉性地识别其他问题，并学会如何安全地避免它们。
- en: Atomicity
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原子性
- en: Many of the worst coding “war stories” that I have heard involve multithreading
    or distributed processes sporadically interacting in bizarre ways due to an unexpected
    sequence of events. Vulnerabilities often stem from these same conditions, and
    the only saving grace is that the sensitive timing required may make the exploit
    too unreliable for the perpetrators—though you should not expect this to easily
    dissuade them from trying anyway.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我听到的许多最糟糕的编码“战斗故事”都涉及多线程或分布式进程由于意外事件的序列而在奇怪的方式中偶尔互动。漏洞往往源于这些相同的条件，而唯一的救命稻草是，所需的敏感时序可能使得攻击手段对实施者来说过于不可靠——尽管你不应该指望这轻易能劝阻他们继续尝试。
- en: Even if your code is single threaded and well behaved, it’s almost always running
    in a machine with many other active processes, so when you interact with the filesystem,
    or any common resource, you are potentially dealing with race conditions involving
    code you know nothing about. *Atomicity* in software describes operations that
    are guaranteed to effectively be completed as a single step. This is an important
    defensive weapon in such cases in order to prevent surprises that potentially
    can lead to vulnerabilities.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的代码是单线程且表现良好，它几乎总是在有许多其他活动进程的机器上运行，因此，当你与文件系统或任何公共资源交互时，你可能正在处理涉及你一无所知的代码的竞态条件。软件中的*原子性*描述的是保证能够有效地作为单个步骤完成的操作。这在这种情况下是一个重要的防御武器，用于防止可能导致漏洞的意外情况。
- en: 'To explain what can happen, consider a simple example of copying sensitive
    data to a temporary file. The deprecated Python `tempfile.mktemp` function returns
    the name of a temporary file guaranteed not to exist, intended for use by applications
    as the name of a file they create and then use. Don’t use it: use the new `tempfile.NamedTemporaryFile`
    instead. Here’s why. Between the time that `tempfile.mktemp` returns the temporary
    file path and the time at which your code actually opens the file, another process
    may have had a chance to interfere. If the other process can guess the name generated
    next, it can create the file first and (among many possibilities) inject malicious
    data into the temporary file. The clean solution that the new function provides
    is to use an atomic operation to create and open the temporary file, without the
    possibility of anything intervening in the process.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明可能发生的情况，考虑一个简单的例子：将敏感数据复制到临时文件。已弃用的Python `tempfile.mktemp` 函数返回一个保证不存在的临时文件名，旨在供应用程序使用，作为它们创建并随后使用的文件名。不要使用它：改用新的
    `tempfile.NamedTemporaryFile`。原因如下。在 `tempfile.mktemp` 返回临时文件路径与代码实际打开文件之间的时间间隙中，另一个进程可能有机会干扰。如果另一个进程能猜到下一个生成的文件名，它就能先创建文件，并且（在多种可能性中）将恶意数据注入临时文件。新函数提供的解决方案是使用原子操作来创建并打开临时文件，避免任何干预过程。
- en: Timing Attacks
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间攻击
- en: A *timing attack* is a side-channel attack that infers information from the
    time it takes to do an operation, indirectly learning about some state of the
    system that should be private. Differences in timing can sometimes provide a hint—that
    is, they leak a little bit of protected information—benefiting an attacker. As
    a simple example, consider the task of trying to guess a secret number between
    1 and 100; if it is known that the time to answer “No” is proportional to how
    far off the guess is, this quirk helps the guesser home in on the correct answer
    much more quickly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*时序攻击*是一种侧信道攻击，它通过操作所需的时间推测信息，间接地了解系统中本应保密的某些状态。时序的差异有时可以提供线索——即，它们泄露了一些受保护的信息——对攻击者有利。举一个简单的例子，假设任务是猜测一个介于1到100之间的秘密数字；如果已知回答“否”的时间与猜测的距离成正比，这种特性可以帮助猜测者更快速地锁定正确答案。'
- en: Meltdown and Spectre are timing attacks on modern processors that operate below
    the software level, but the principles are directly applicable. These attacks
    exploit quirks of *s**peculative execution*, where the processor races forward
    to precompute results while tentatively relaxing various checks in the interest
    of speed. When this includes operations that are normally disallowed, the processor
    detects this eventually and cancels the results before they become final. This
    complicated speculation all works according to the processor design and is essential
    to achieve the incredible speeds we enjoy. However, during the speculative, rules-are-suspended
    execution, whenever the computation accesses memory, this has the side effect
    of causing it to be cached. When the speculative execution is canceled, the cache
    is unaffected, and that side effect represents a potential hint, which these attacks
    utilize to infer what happened during the speculative execution. Specifically,
    the attack code can deduce what happened during the canceled speculative execution
    by checking the state of the cache. Memory caching speeds up execution but is
    not directly exposed to software; however, code can tell whether or not the memory
    location contents were in the cache by measuring memory access time, because cached
    memory is way faster. This is a complicated attack on a complex processor architecture,
    but for our purposes the point is that when timing correlates to protected information
    state, it can be exploitable as a leak.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Meltdown和Spectre是对现代处理器的时序攻击，发生在软件层面以下，但其原理是直接适用的。这些攻击利用了*猜测执行*的特点，在这种执行方式下，处理器会提前计算结果，同时暂时放松各种检查以提高速度。当这一过程涉及到通常不允许的操作时，处理器最终会检测到并取消这些结果，防止其最终生效。这种复杂的猜测执行完全依赖于处理器的设计，且对于实现我们享受的惊人速度至关重要。然而，在猜测执行期间，当计算访问内存时，副作用是导致内存被缓存。当猜测执行被取消时，缓存并不受影响，这种副作用就成为了一个潜在的线索，攻击者利用它来推断在猜测执行期间发生了什么。具体而言，攻击代码可以通过检查缓存的状态来推测在被取消的猜测执行期间发生了什么。内存缓存加速了执行，但不直接暴露给软件；然而，代码可以通过测量内存访问时间来判断内存位置内容是否在缓存中，因为缓存的内存速度远快于常规内存。这是对复杂处理器架构的复杂攻击，但就我们的目的而言，关键点是当时序与受保护信息状态相关联时，它可以被用作泄露的漏洞。
- en: For a simpler, purely software-based example of a timing attack, suppose you
    want to determine whether or not your friend (or frenemy?) has an account with
    a particular online service, but you don’t know their account name. The “forgot
    password” option asks users for their account name and phone number in order to
    send a “reminder.” However, suppose that the implementation first looks up the
    phone number in a database, and if found, proceeds to look up the associated account
    name to see if it matches the input. Say that each lookup takes a few seconds,
    so the time delay is noticeable to the user. First, you try a few random account
    names (say, by mashing the keyboard) and phone numbers that likely won’t match
    actual users, and learn that it reliably takes about three seconds to get a “No
    such account” response. Next, you sign up with your own phone number and try the
    “forgot password” feature using your number with one of the random unused account
    names. Now you observe that in this case it takes five seconds, or almost twice
    as long, to get the response.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 举一个更简单的、纯粹基于软件的时间攻击示例，假设你想确定你的朋友（或者“死对头”？）是否在某个特定的在线服务上有账户，但你不知道他们的账户名。“忘记密码”选项会要求用户提供账户名和电话号码，以便发送“提醒”。然而，假设实现首先在数据库中查找电话号码，如果找到了，就会继续查找关联的账户名，看看是否与输入的匹配。假设每次查找需要几秒钟，因此时间延迟对用户是可察觉的。首先，你尝试几个随机的账户名（比如随便按键盘）和电话号码，这些很可能不会与实际用户匹配，并且你会发现，通常需要三秒钟才能得到“没有此账户”的回应。接下来，你用自己的电话号码注册账户，并尝试使用自己的号码与一个随机未使用的账户名进行“忘记密码”操作。现在你观察到，在这种情况下，响应时间为五秒钟，几乎是原来的两倍。
- en: 'Armed with these facts, you can try your friend’s phone number with an unused
    account name: if it takes five seconds to get a reply, then you know that their
    phone number is in the database, and if it takes three seconds, then it isn’t.
    By observing the timing alone, you can infer whether a given phone number is in
    the database. If membership might reveal sensitive private information, such as
    in a forum for patients with a certain medical condition, such timing attacks
    could enable a harmful disclosure.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些事实，你可以尝试使用一个未使用的账户名来测试你朋友的电话号码：如果回复需要五秒钟，那么你就知道他们的电话号码在数据库中；如果只需要三秒钟，那么就说明电话号码不在数据库中。仅通过观察时间，你就可以推断给定的电话号码是否在数据库中。如果会员信息可能会泄露敏感的私人信息，例如在某些患者论坛中，这种时间攻击可能会导致有害的信息泄露。
- en: Timing differences naturally occur due to software when there is a sequence
    of slow operations (think `if...if...if...if...`), and there is valuable information
    to be inferred from knowing how far down the sequence of events the execution
    proceeded. Precisely how much or little timing difference is required to leak
    information depends on many factors. In the online account checking example, it
    takes a few seconds to represent a clear signal, given the normal delays the web
    imposes on access. By contrast, when exploiting Meltdown or Spectre using code
    running on the same machine, sub-millisecond time differences may be measurable
    and also significant.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件的原因，时间差异是自然发生的，尤其是当有一系列缓慢的操作（想想`if...if...if...if...`）时，知道执行进度到达序列的哪个位置可以推断出有价值的信息。确切的时间差异大小取决于许多因素。在在线账户检查的示例中，由于网络访问的正常延迟，几秒钟的时间差足以表示一个清晰的信号。相比之下，当利用Meltdown或Spectre漏洞通过同一台机器上的代码执行时，亚毫秒级的时间差异可能是可测量的，并且同样具有重要意义。
- en: The best mitigation option is to reduce the time differential to an acceptable—that
    is, imperceptible—level. To prevent the presence of a phone number in the database
    from leaking, changing the code to use a single database lookup to handle both
    cases would be sufficient. When there is an inherent timing difference and the
    timing side channel could result in a serious disclosure, about all you can do
    to mitigate the risk is introduce an artificial delay to blur the timing signal.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的缓解选项是将时间差异缩小到一个可以接受的——即，无法察觉的——水平。为了防止电话号码出现在数据库中而泄露信息，只需将代码更改为使用单一数据库查找来处理两种情况即可。当存在固有的时间差异，并且这种时间侧信道可能导致严重的泄露时，最好的缓解措施就是引入人工延迟来模糊时间信号。
- en: Serialization
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化
- en: '*Serialization* refers to the common technique of converting data objects to
    a byte stream, a little like a *Star Trek* transporter does, to then “beam” them
    through time and space. Storing or transmitting the resulting bytes allows you
    to subsequently reconstitute equivalent data objects through *deserialization*.
    This ability to “dehydrate” objects and then “rehydrate” them is handy for object-oriented
    programming, but the technique is inherently a security risk if there is any possibility
    of tampering in between. Not only can an attacker cause critical data values to
    morph, but by constructing invalid byte sequences, they can even cause the deserialization
    code to perform harmful operations. Since deserialization is only safe when used
    with trusted serialized data, this is an example of the untrusted input problem.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列化*是指将数据对象转换为字节流的常见技术，类似于 *星际迷航* 中的传送器，然后通过时间和空间“传送”它们。存储或传输生成的字节流可以让你通过
    *反序列化* 重新构造相应的数据对象。这种“脱水”对象再“复水”的能力对面向对象编程非常有用，但如果在此过程中有任何篡改的可能性，这项技术本质上就是一个安全隐患。攻击者不仅可以使关键数据值发生变化，而且通过构造无效的字节序列，他们甚至可以使反序列化代码执行有害操作。由于反序列化只有在使用受信任的序列化数据时才是安全的，这就是不受信任输入问题的一个例子。'
- en: The problem is not that these libraries are poorly built, but that they require
    trust to be able to perform the operations necessary to construct arbitrary objects
    in order to do their job. Deserialization is, in effect, an interpreter that does
    whatever the serialized bytes of its input tell it to do, so its use with untrusted
    data is never a good idea. For example, Python’s deserialization operation (called
    “unpickling”) is easily tricked into executing arbitrary code by embedding a malicious
    byte sequence in the data to be unpickled. Unless serialized byte data can be
    securely stored and transmitted without the possibility of tampering, such as
    with a MAC or digital signature (as discussed in Chapter 5), it’s best avoided
    completely.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于这些库构建得不好，而在于它们需要信任才能执行构建任意对象所需的操作，从而完成它们的工作。反序列化实际上是一种解释器，它会执行其输入的序列化字节所指示的任何操作，因此，使用不受信任的数据来进行反序列化永远不是一个好主意。例如，Python
    的反序列化操作（称为“反 pickle”）很容易通过在要反序列化的数据中嵌入恶意字节序列来诱使它执行任意代码。除非序列化的字节数据能够安全存储和传输，并且没有被篡改的可能性，比如使用
    MAC 或数字签名（如第 5 章所讨论的），否则最好完全避免使用。
- en: The Usual Suspects
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见嫌疑人
- en: The greatest trick the devil ever pulled was convincing the world he didn’t
    exist.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 魔鬼曾经用过的最伟大的伎俩就是让全世界相信他不存在。
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Charles Baudelaire
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — 查尔斯·波德莱尔
- en: 'The next several chapters cover many of the “usual suspects” that keep cropping
    up in code as vulnerabilities. In this chapter we considered GotoFail and issues
    with atomicity, timing attacks, and serialization. Here is a preview of the topics
    we’ll explore next:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几章将讨论许多在代码中经常出现的“常见嫌疑人”漏洞。在本章中，我们考虑了 GotoFail 和原子性问题、时序攻击以及序列化问题。以下是我们接下来要探讨的主题预览：
- en: Fixed-width integer vulnerabilities
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定宽度整数漏洞
- en: Floating-point precision vulnerabilities
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点精度漏洞
- en: Buffer overflow and other memory management issues
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区溢出和其他内存管理问题
- en: Input validation
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证
- en: Character string mishandling
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串处理不当
- en: Injection attacks
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入攻击
- en: Web security
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 安全
- en: Many of these issues will seem obvious, yet all continue to recur largely unabated
    as root causes of software vulnerabilities, with no end in sight. It’s important
    to learn from past failings, because many of these vulnerability classes have
    existed for decades. Yet, it would be a mistake to take a backward-looking approach
    as if all possible security bugs were cataloged exhaustively. No book can forewarn
    of all possible pitfalls, but you can study these examples to get an idea of the
    deeper patterns and lessons behind them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些问题看起来显而易见，但它们依然是软件漏洞的根本原因，且大多数问题没有得到有效遏制，仍在不断出现。我们需要从过去的失败中吸取教训，因为这些漏洞类别已经存在了几十年。然而，将目光只放在过去，认为所有可能的安全漏洞都已经被详尽列举，是一种错误的思维方式。没有一本书可以预警所有可能的陷阱，但你可以通过研究这些例子，了解它们背后更深层的模式和教训。
- en: '9'
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Low-Level Coding Flaws
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 底层编码缺陷
- en: Low-level programming is good for the programmer’s soul.
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 底层编程有益于程序员的心灵。
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —John Carmack
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — 约翰·卡马克
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The next few chapters will survey a multitude of coding pitfalls programmers
    need to be aware of for security reasons, starting with the classics. This chapter
    covers basic flaws that are common to code that works closer to the machine level.
    The issues discussed here arise when data exceeds the capacity of either fixed-size
    numbers or allocated memory buffers. Modern languages tend to provide higher-level
    abstractions that insulate code from these perils, but programmers working in
    these safer languages will still benefit from understanding these flaws, if only
    to fully appreciate all that’s being done for them, and why it matters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几章将概述程序员需要了解的多种编码陷阱，尤其是出于安全原因的注意事项，从经典问题开始。本章涵盖了与接近机器层的代码相关的基本缺陷。这些问题出现在数据超出固定大小数字或分配内存缓冲区的容量时。现代语言往往提供更高层次的抽象，使代码免受这些危险，但在这些更安全的语言中工作的程序员仍然可以通过理解这些缺陷获益，即便只是为了充分理解为他们所做的一切，以及这些问题为何重要。
- en: Languages such as C and C++ that expose these low-level capabilities remain
    dominant in many software niches, so the potential threats they pose are by no
    means theoretical. Modern languages such as Python usually abstract away the hardware
    enough that the issues described in this chapter don’t occur, but the lure of
    approaching the hardware level for maximum efficiency remains powerful. A few
    popular languages offer programmers their choice of both worlds. In addition to
    type-safe object libraries, the Java and C# base types include fixed-width integers,
    and they have “unsafe” modes that remove many of the safeguards normally provided.
    Python’s `float` type, as explained in “Floating-Point Precision Vulnerabilities”
    on page 149, relies on hardware support and accrues its limitations, which must
    be coped with.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如C和C++这类暴露底层功能的语言，在许多软件领域中仍然占据主导地位，因此它们所带来的潜在威胁绝非理论上的问题。现代语言如Python通常会将硬件抽象得足够高，以至于本章中描述的问题不会出现，但追求最大效率、接近硬件层的诱惑依然强大。几种流行语言为程序员提供了两者兼得的选择。除了类型安全的对象库外，Java和C#的基础类型包括固定宽度的整数，并且它们有“非安全”模式，可以去除通常提供的许多保护措施。Python的`float`类型，如在第149页的《浮点精度漏洞》一节中所解释的，依赖于硬件支持，并带来其局限性，必须加以应对。
- en: Readers who never use languages exposing low-level functionality may be tempted
    to skip this chapter, and can do so without losing the overall narrative of the
    book. However, I recommend reading through it anyway, as it’s best to understand
    what protections the languages and libraries you use do or do not provide, and
    to fully appreciate all that’s being done for you.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从不使用暴露底层功能的语言的读者，可能会倾向于跳过本章，而且这样做不会影响全书的整体叙述。然而，我仍然建议阅读本章，因为最好了解你所使用的语言和库提供了哪些保护措施，或者没有提供哪些保护措施，并充分理解为你所做的一切。
- en: Programming closer to the hardware level, if done well, is extremely powerful,
    but comes at a cost of increased effort and fragility. In this chapter, we focus
    on the most common classes of vulnerability specific to coding with lower-level
    abstractions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果做得好，靠近硬件层编程是非常强大的，但也付出了增加的工作量和脆弱性的代价。在本章中，我们将重点讨论与低级抽象编程相关的最常见的漏洞类型。
- en: Since this chapter is all about bugs that arise from issues where code is near
    or at the hardware level, you must understand that the exact results of many of
    these operations will vary across platforms and languages. I’ve designed the examples
    to be as specific as possible, but implementation differences may cause varying
    results—and it’s exactly because computations can vary unpredictably that these
    issues are easily overlooked and can have an impact on security. The details will
    vary depending on your hardware, compiler, and other factors, but the concepts
    introduced in this chapter do apply generally.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章讨论的是与代码接近或处于硬件层时出现的漏洞，你必须理解，许多操作的确切结果在不同的平台和语言之间会有所不同。我已将示例设计得尽可能具体，但实现上的差异可能会导致结果不同——正是因为计算结果可能不可预测地变化，这些问题才容易被忽视，并可能对安全性产生影响。具体细节会因硬件、编译器和其他因素而异，但本章介绍的概念是普遍适用的。
- en: Arithmetic Vulnerabilities
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术漏洞
- en: Different programming languages variously define their arithmetic operators
    either mathematically or according to the processor’s corresponding instructions,
    which, as we shall see shortly, are not quite the same. By *low-level*, I mean
    features of programming languages that depend on machine instructions, which requires
    dealing with the hardware’s quirks and limitations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言以不同的方式定义它们的算术运算符，或者是按数学方式，或者是按照处理器对应的指令，正如我们稍后将看到的那样，这两者并不完全相同。所谓的*低级*，指的是依赖于机器指令的编程语言特性，这需要处理硬件的怪癖和限制。
- en: Code is full of integer arithmetic. It’s used not only for computing numerical
    values but also for string comparison, indexed access to data structures, and
    more. Because the hardware instructions are so much faster and easier to use than
    software abstractions that handle a larger range of values, they are hard to resist,
    but with that convenience and speed comes the risk of *overflow*. Overflow happens
    when the result of a computation exceeds the capacity of a fixed-width integer,
    leading to unexpected results, which can create a vulnerability.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中充满了整数运算。它不仅用于计算数值，还用于字符串比较、数据结构的索引访问等。由于硬件指令比处理更大范围数值的软件抽象要快速且易于使用，因此很难抗拒它们，但这种便利和速度也带来了*溢出*的风险。当计算结果超出固定宽度整数的容量时，就会发生溢出，导致意外结果，从而可能产生漏洞。
- en: Floating-point arithmetic has more range than integer arithmetic, but its limited
    precision can cause unexpected results, too. Even floating-point numbers have
    limits (for single precision, on the order of 10^(38)), but when the limit is
    exceeded, they have the nice property of resulting in a specific value that denotes
    infinity.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点运算的范围比整数运算更广，但其有限的精度也可能导致意外的结果。即使是浮点数也有其限制（对于单精度，大约为 10^(38)），但是当超出这个限制时，它们具有一个很好的特性，即会得到一个特定的值，表示无限大。
- en: Readers interested in an in-depth treatment of the implementation of arithmetic
    instructions down to the hardware level can learn more from *The Secret Life of
    Programs* by Jonathan E. Steinhart (No Starch Press, 2019).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有兴趣深入了解算术指令在硬件级别实现的读者，可以通过 Jonathan E. Steinhart 的《程序的秘密生活》（No Starch Press，2019）进一步学习。
- en: Fixed-Width Integer Vulnerabilities
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定宽度整数漏洞
- en: At my first full-time job, I wrote device drivers in assembly machine language
    on minicomputers. Though laughably underpowered by modern standards, minicomputers
    provided a great opportunity to learn how hardware works, because you could look
    at the circuit board and see every connection and every chip (which had a limited
    number of logic gates inside). I could *see* the registers connected to the arithmetic
    logic unit (which could perform addition, subtraction, and Boolean operations
    only) and memory, so I knew exactly how the computer worked. By contrast, modern
    processors are fabulously complicated, containing billions of logic gates, well
    beyond human understanding by casual observation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我第一份全职工作中，我在小型计算机上用汇编语言编写设备驱动程序。虽然按照现代标准看，它们的性能可笑地低，但小型计算机提供了一个学习硬件如何工作的好机会，因为你可以查看电路板，看到每个连接和每个芯片（每个芯片内部有有限数量的逻辑门）。我可以*看到*连接到算术逻辑单元（只能执行加法、减法和布尔运算）和内存的寄存器，因此我完全明白计算机是如何工作的。相反，现代处理器极为复杂，包含数十亿个逻辑门，远远超出了人类通过随意观察能够理解的范围。
- en: Today, most programmers learn and use higher-level languages that shield them
    from machine language and the intricacies of CPU architecture. Fixed-width integers
    are the most basic building blocks of many languages, including Java and C/C++,
    and if any computation exceeds their limited range, you get the wrong result *silently*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数程序员学习并使用高级语言，这些语言将他们与机器语言和 CPU 架构的复杂性隔离开。固定宽度整数是许多语言中最基本的构建块，包括 Java 和
    C/C++，如果任何计算超过了它们的有限范围，你将得到错误的结果，*默默地*。
- en: Modern processors often have either a 32- or 64-bit architecture, but we can
    understand how they work by discussing smaller sizes. Let’s look at an example
    of overflow based on unsigned 16-bit integers. A 16-bit integer can represent
    any value from 0 to 65,535 (2^(16) – 1). For example, multiplying 300 by 300 should
    give us 90,000, but that number is beyond the range of the fixed-width integer
    we are using. So, due to overflow, the result we actually get is 24,464 (65,536
    less than the expected result).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现代处理器通常具有 32 位或 64 位架构，但我们可以通过讨论更小的尺寸来理解它们是如何工作的。让我们通过一个基于无符号 16 位整数的溢出示例来看看。一个
    16 位整数可以表示从 0 到 65,535（2^(16) – 1）之间的任何值。例如，300 乘以 300 应该得到 90,000，但这个数字超出了我们使用的定宽整数的范围。因此，由于溢出，我们实际上得到的结果是
    24,464（比预期结果少 65,536）。
- en: Some people think about overflow mathematically as *modular arithmetic*, or
    the remainder of division (for instance, the previous calculation gave us the
    remainder of dividing 90,000 by 65,536). Others think of it in terms of binary
    or hexadecimal truncation, or in terms of the hardware implementation—but if none
    of these make sense to you, just remember that the results for oversized values
    will not be what you expect. Since mitigations for overflow will attempt to avoid
    it in the first place, the precise resulting value is not usually important.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人将溢出从数学上看作是*模运算*，即除法的余数（例如，之前的计算给出了将 90,000 除以 65,536 的余数）。其他人则从二进制或十六进制截断的角度，或者从硬件实现的角度来考虑它——但如果这些都不适合你，只需记住，超大值的结果将不是你预期的。由于溢出的缓解措施通常会试图在第一次发生之前避免它，精确的结果值通常并不重要。
- en: What’s important here is anticipating the foibles of binary arithmetic, rather
    than knowing exactly what value results from a calculation—which, depending on
    the language and compiler, may not be well defined (that is, the language specification
    refuses to guarantee any particular value). Operations technically specified as
    “not defined” in a language may seem predictable, but you are on thin ice if the
    language specification doesn’t offer a guarantee. The bottom line for security
    is that it’s important to know the language specification and avoid computations
    that are potentially undefined. Do not get clever and experiment to find a tricky
    way to detect the undefined result, because with different hardware or a new version
    of the compiler, your code might stop working.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是预见到二进制算术的怪癖，而不是准确知道计算结果是什么——这取决于语言和编译器，可能并不明确定义（也就是说，语言规范不保证任何特定的值）。在语言中，技术上被指定为“未定义”的操作可能看起来可预测，但如果语言规范没有提供保证，你就处于危险之中。安全的底线是，了解语言规范并避免潜在未定义的计算非常重要。不要心血来潮，试图找到一种巧妙的方法来检测未定义的结果，因为在不同的硬件或新的编译器版本下，你的代码可能会停止工作。
- en: If you miscompute an arithmetic result your code may break in many ways, and
    the effects often snowball into a cascade of dysfunction, culminating in a crash
    or blue screen. Common examples of vulnerabilities due to integer overflow include
    buffer overflows (discussed in “Buffer Overflow” on page 157), incorrect comparisons
    of values, situations in which you give a credit instead of charging for a sale,
    and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计算错误，代码可能会以多种方式崩溃，效果往往会像滚雪球一样累积成一系列功能失常，最终导致崩溃或蓝屏。由于整数溢出导致的常见漏洞包括缓冲区溢出（在第
    157 页的“缓冲区溢出”中讨论）、值的错误比较、在销售时给出信用而不是收费等情况。
- en: It’s best to mitigate these issues before any computation that could go out
    of bounds is performed, while all numbers are still within range. The easy way
    to get it right is to use an integer size that is larger than the largest allowable
    value, preceded by checks ensuring that invalid values never sneak in. For example,
    to compute 300 × 300, as mentioned earlier, use 32-bit arithmetic, which is capable
    of handling the product of any 16-bit values. If you must convert the result back
    to 16-bit, protect it with a 32-bit comparison to ensure that it is in range.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在进行任何可能超出范围的计算之前就缓解这些问题，确保所有数字仍然在范围内。正确的简单方法是使用比最大允许值更大的整数大小，并在前面进行检查，确保无效值永远不会潜入。例如，要计算
    300 × 300，如前所述，使用 32 位算术，它能够处理任何 16 位值的乘积。如果你必须将结果转换回 16 位，请用 32 位比较来保护它，以确保它在范围内。
- en: 'Here is what multiplying two 16-bit unsigned integers into a 32-bit result
    looks like in C. I prefer to use an extra set of parentheses around the casts
    for clarity, even though operator precedence binds the casts ahead of the multiplication
    (I’ll provide a more comprehensive example later in this chapter for a more realistic
    look at how these vulnerabilities slip in):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将两个16位无符号整数相乘得到一个32位结果的 C 语言代码。为了清晰起见，我喜欢在类型转换周围加上一对额外的括号，尽管操作符优先级会先绑定类型转换，再进行乘法运算（稍后在本章中，我会提供一个更全面的例子，来更实际地展示这些漏洞是如何潜入的）：
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The fact that fixed-width integers are subject to silent overflow is not difficult
    to understand, yet in practice these flaws continue to plague even experienced
    coders. Part of the problem is the ubiquity of integer math in programming—including
    its implicit usages, such as pointer arithmetic and array indexing, where the
    same mitigations must be applied. Another challenge is the necessary rigor of
    always keeping in mind not just what the reasonable range of values might be for
    every variable, but also what possible ranges of values the code could encounter,
    given the manipulations of a wily attacker.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 定宽整数容易发生静默溢出这一事实并不难理解，但在实际中，这些缺陷仍然困扰着即使是经验丰富的程序员。问题的一部分在于整数运算在编程中的普遍性——包括其隐式用法，如指针运算和数组索引，这些地方也必须应用相同的缓解措施。另一个挑战是必须始终严谨地记住，不仅要了解每个变量的合理值范围，还要了解代码可能遇到的值范围，考虑到狡猾攻击者的操作。
- en: Many times when programming, it feels like all we are doing is manipulating
    numbers, yet we must not lose sight of the fragility of these calculations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 编程时，很多时候我们感觉自己只是在操作数字，但我们必须时刻牢记这些计算的脆弱性。
- en: Floating-Point Precision Vulnerabilities
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮动点精度漏洞
- en: Floating-point numbers are, in many ways, more robust and less quirky than fixed-width
    integers. For our purposes, you can think of a floating-point number as a sign
    bit (for positive or negative numbers), a fraction of a fixed precision, and an
    exponent of two that the fraction is multiplied by. The popular IEEE 754 double-precision
    specification provides 15 decimal digits (53 binary digits) of precision, and
    if you exceed its extremely large bounds, you get a signed infinity—or *NaN (not
    a number)*—for a few operations instead of truncation to wild values, as you do
    with fixed-width integers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动点数在很多方面比定宽整数更稳定、更少异常。对于我们的目的，你可以把浮动点数看作是一个符号位（用于表示正负数）、一个固定精度的分数，以及一个二的指数，分数会乘以这个指数。流行的
    IEEE 754 双精度标准提供了15位十进制数字（53位二进制数字）的精度，如果超出其极大范围，几个操作后会得到一个带符号的无穷大——或 *NaN（非数字）*——而不是像定宽整数那样被截断为不合理的值。
- en: Since 15 digits of precision is enough to tally the federal budget of the United
    States (currently several trillion dollars) in pennies, the risk of loss of precision
    is rarely a problem. Nonetheless, it does happen silently in the low-order digits,
    which can be surprising because the representation of floating-point numbers is
    binary rather than decimal. For example, since decimal fractions do not necessarily
    have exact representations in binary, 0.1 + 0.2 will yield 0.30000000000000004—a
    value that is *not* equal to 0.3\. These kinds of messy results can happen because
    just as a fraction such as 1/7 is a repeating decimal in base 10, 1/10 repeats
    infinitely in base 2 (it’s 0.00011001100\. . . with 1100 continuing forever),
    so there will be error in the lowest bits. Since these errors are introduced in
    the low-order bits, this is called *underflow*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于15位的精度足以用分币计算美国联邦预算（目前数万亿美元），因此精度丧失的风险很少成为问题。然而，它确实会在低位数字中悄无声息地发生，这可能令人惊讶，因为浮动点数的表示是二进制而非十进制。例如，由于十进制分数在二进制中不一定有准确的表示，0.1
    + 0.2 会得到 0.30000000000000004——一个 *不* 等于 0.3 的值。这种混乱的结果可能发生，因为就像1/7在十进制中是一个无限循环小数一样，1/10在二进制中也是无限循环（它是
    0.00011001100...，1100 永远重复），因此最低位会有误差。由于这些误差是在低位数字中引入的，因此这种现象被称为 *下溢*。
- en: 'Even though underflow discrepancies are tiny proportionally, they can still
    produce unintuitive results when values are of different magnitudes. Consider
    the following code written in JavaScript, a language where all numbers are floating
    point:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 即使下溢差异在比例上非常小，它们在值的大小不同的情况下仍然会产生不直观的结果。考虑以下用 JavaScript 编写的代码，在这个语言中，所有的数字都是浮动点数：
- en: '**vulnerable code**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**脆弱的代码**'
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Mathematically, the result of the expression in the final line should equal
    `b-c`, since the value `a` is first added and then subtracted. (The `console.log`
    function is a handy way to output the value of an expression.) But in fact, the
    value of `a` is large enough that adding or subtracting much smaller values has
    no effect, given the limited precision available, so that when the value `a` is
    finally subtracted, the result is zero.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 数学上，最后一行表达式的结果应等于`b-c`，因为值`a`首先被加上，然后被减去。（`console.log`函数是输出表达式值的便捷方法。）但实际上，`a`的值足够大，以至于加减更小的值对结果没有影响，考虑到有限的精度，当值`a`最终被减去时，结果是零。
- en: When calculations such as the one in this example are approximate, the error
    is harmless, but when you need full precision, or when values of differing orders
    of magnitude go into the computation, then a good coder needs to be cautious.
    Vulnerabilities arise when such discrepancies potentially impact a security-critical
    decision in the code. Underflow errors may be a problem for computations such
    as checksums or for double-entry accounting, where exact results are essential.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当像这个例子中的计算是近似值时，误差是无害的，但当你需要完全精确，或者当计算中涉及不同数量级的值时，好的程序员需要谨慎。如果这种误差可能影响代码中安全关键决策，漏洞就会出现。对于像校验和或复式记账这样的计算，溢出错误可能是一个问题，因为精确结果至关重要。
- en: For many floating-point computations, even without dramatic underflow like in
    the example we just showed, small amounts of error accumulate in the lower bits
    when the values do not have an exact representation. It’s almost always unwise
    to compare floating-point values for equality (or inequality), since this operation
    cannot tolerate even tiny differences in computed values. So, instead of `(x ==
    y)`, compare the values within a small range `(x > y - delta && x < y + delta)`
    for a value of `delta` suitable for the application. Python provides the `math.isclose`
    helper function that does a slightly more sophisticated version of this test.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多浮点计算，即使没有像我们刚才展示的那种显著下溢，当值没有精确表示时，小的误差也会在低位逐渐积累。通常不建议直接比较浮点值是否相等（或不相等），因为这个操作不能容忍即使是微小的计算差异。因此，应该改为在一个小范围内比较值`(x
    > y - delta && x < y + delta)`，其中`delta`是适合该应用程序的值。Python提供了`math.isclose`辅助函数，执行一个稍微更复杂的测试版本。
- en: When you must have high precision, consider using the super-high-precision floating-point
    representations (IEEE 754 defines 128- and 256-bit formats). Depending on the
    requirements of the computation, arbitrary-precision decimal or rational number
    representations may be the best choice. Libraries often provide this functionality
    for languages that do not include native support.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要高精度时，可以考虑使用超高精度浮点数表示（IEEE 754定义了128位和256位格式）。根据计算的要求，任意精度的小数或有理数表示可能是最佳选择。许多库为不包含原生支持的语言提供了此功能。
- en: 'Example: Floating-Point Underflow'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：浮点下溢
- en: 'Floating-point underflow is easy to underestimate, but lost precision has the
    potential to be devastating. Here is a simple example in Python of an online ordering
    system’s business logic that uses floating-point values. The following code’s
    job is to check that purchase orders are fully paid, and if so, approve shipment
    of the product:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点下溢很容易被低估，但精度丧失有可能带来灾难性后果。下面是一个简单的Python例子，展示了一个在线订购系统的业务逻辑，其中使用了浮点数值。以下代码的任务是检查采购订单是否已完全支付，如果是，则批准发货：
- en: '**vulnerable code**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**脆弱代码**'
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Purchase orders consist of line items that are either product or payment details.
    The total of payments, minus the total cost of products ordered, should be zero.
    The payments are already validated beforehand, and let me be explicit about one
    detail of that process: if the customer immediately cancels a charge in full,
    both the credit and debit appear as line items without querying the credit card
    processor, which incurs a fee. Let’s also posit that the prices listed for items
    are correct.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 采购订单由产品或付款明细组成。付款总额减去订购的产品总成本应为零。付款已经提前验证，我需要明确说明一个细节：如果客户立即取消全部费用，则信用和借记将作为明细项出现，而无需查询信用卡处理器，这会产生费用。我们还假设所列项目的价格是正确的。
- en: 'Focusing on the floating-point math, see how for payment line items the amount
    is added to `net`, and for products the amount times quantity is subtracted (these
    invocations are written as Python `doctest`s, where the `>>>` lines are code to
    run followed by the expected values returned):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 聚焦于浮动小数点运算，看看在付款项中，金额是如何加到 `net` 上的，而在产品项中，金额乘以数量是如何被减去的（这些调用被写作 Python `doctest`，其中
    `>>>` 行是要运行的代码，后跟预期的返回值）：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code works as expected, approving the first transaction shown for a fully
    paid TV and rejecting the order that doesn’t note a payment.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 代码按预期工作，批准了第一个完全支付电视的交易，并拒绝了未注明付款的订单。
- en: 'Now it’s time to break this code and “steal” some TVs. If you already see the
    vulnerability, it’s a great exercise to try and deceive the function yourself.
    Here is how I got 1,000 TVs for free, with explanation following the code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候破坏这段代码并“偷”一些电视了。如果你已经看到了漏洞，这是一个很好的练习，尝试自己欺骗这个函数。以下是我如何免费获得 1,000 台电视的代码，代码后会有解释：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The trick here is in the fake payment of the outrageous amount `1e30`, or 10^(30),
    followed by the immediate reversal of the charge. These bogus numbers get past
    the accounting check because they sum to zero (10^(30) – 10^(30)). Note that between
    the canceling debit and the credit is a line item that orders 1,000 TVs. Because
    the first number is so huge, when the cost of the TVs is subtracted, it underflows
    completely; then, when the credit (a negative number) is added in, the result
    is zero. Had the credit immediately followed the payment followed by the line
    item for the TVs, the result would be different and an error would be correctly
    flagged.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧在于伪造一个巨额金额 `1e30`，即 10^(30)，然后立即撤销该费用。这些虚假的数字通过了会计检查，因为它们的和为零（10^(30) –
    10^(30)）。注意，在取消借方和贷方之间，有一项订单是 1,000 台电视。由于第一个数字如此庞大，当从中减去电视的成本时，它完全下溢；然后，当添加负数的信用时，结果为零。如果信用立即跟随支付，并紧接着是电视的订单项，那么结果会不同，并且错误会被正确地标记出来。
- en: To give you a more accurate feel for underflow—and more importantly, to show
    how to gauge the range of safe values to make the code secure—we can drill in
    a little deeper. The choice of 10^(30) for this attack was arbitrary, and this
    trick works with numbers as low as about 10^(24), but not 10^(23). The cost of
    1,000 TVs at $10,000 each is $10,000,000, or 10⁷. So with a fake charge of 10^(23),
    the value 10⁷ starts to change the computation a little, corresponding to about
    16 digits of precision (23 – 7). The previously mentioned 15 digits of precision
    was a safe rule-of-thumb approximation (the binary precision corresponds to 15.95
    decimal digits) that’s useful because most of us think naturally in base 10, but
    since the floating-point representation is actually binary, it can differ by a
    few bits.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你更准确地理解下溢——更重要的是，展示如何衡量安全值范围来确保代码安全——我们可以深入探讨一下。选择 10^(30) 进行这次攻击是任意的，这个技巧也适用于大约
    10^(24) 这样的数字，但不适用于 10^(23)。1,000 台电视的成本是每台 $10,000，总共是 $10,000,000，或 10⁷。所以当伪造费用为
    10^(23) 时，数值 10⁷ 开始稍微改变计算结果，约对应 16 位精度（23 – 7）。之前提到的 15 位精度是一个安全的经验法则（由于二进制精度与
    15.95 十进制位对应），这很有用，因为我们大多数人天生以 10 为基数思考，但由于浮动小数点表示实际上是二进制的，它可能会有几位不同。
- en: With that reasoning in mind, let’s fix this vulnerability. If we want to work
    in floating point, then we need to constrain the range of numbers. Assuming a
    minimum product cost of $0.01 (10^(–2)) and 15 digits of precision, we can set
    a maximum payment amount of $10^(13) (15 – 2), or $10 trillion. This upper limit
    avoids underflow, though in practice, a smaller limit corresponding to a realistic
    maximum order amount would be best.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个推理，我们来修复这个漏洞。如果我们想使用浮动小数点，那么我们需要限制数字的范围。假设最小产品成本为 $0.01 (10^(–2)) 且有 15
    位精度，我们可以设定最大支付金额为 $10^(13) (15 – 2)，即 $10 万亿。这个上限可以避免下溢，尽管实际上，设定一个与实际最大订单金额相对应的较小限制会更好。
- en: 'Using an arbitrary-precision number type avoids underflow: in Python, that
    could be the native integer type, or `fractions.Fraction`. Higher-precision floating-point
    computation will prevent this particular attack but would still be susceptible
    to underflow with more extreme values. Since Python is dynamically typed, when
    the code is called with values of these types, the attack fails. But even if we
    had written this code with one of these arbitrary precision types and considered
    it safe, if the attacker managed to sneak in a float somehow, the vulnerability
    would reappear. That’s why doing a range check—or, if the caller cannot be trusted
    to present the expected type, converting incoming values to safe types before
    computing—is important.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任意精度数字类型可以避免下溢：在 Python 中，这可以是原生整数类型，或者是 `fractions.Fraction`。高精度的浮点计算可以防止这种特定的攻击，但在遇到更极端的值时，仍然可能会出现下溢问题。由于
    Python 是动态类型语言，当代码使用这些类型的值时，攻击会失败。但即使我们使用了这些任意精度类型并认为是安全的，如果攻击者设法通过某种方式偷偷注入了一个浮点数，漏洞依然会重新出现。这就是为什么进行范围检查，或者在调用方不能信任提供预期类型的情况下，在计算前将输入值转换为安全类型是很重要的原因。
- en: 'Example: Integer Overflow'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：整数溢出
- en: Fixed-width integer overflow vulnerabilities are often utterly obvious in hindsight,
    and this class of bugs has been well known for many years. Yet experienced coders
    repeatedly fall into the trap, whether because they don’t believe the overflow
    can happen, because they misjudge it as harmless, or because they don’t consider
    it at all. The following example shows the vulnerability in a larger computation
    to give you an idea of how these bugs can easily slip in. In practice, vulnerable
    computations tend to be more involved, and the values of variables harder to anticipate,
    but for explanatory purposes, this simple code will make it easy to see what’s
    going on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 固定宽度整数溢出漏洞在事后往往是显而易见的，这类错误已被广泛认识多年。然而，有经验的程序员反复陷入这个陷阱，无论是因为他们不相信溢出会发生，还是因为他们误判其无害，或根本没有考虑到它。以下示例展示了一个较大计算中的漏洞，帮助你理解这些错误是如何轻易潜入的。实际上，易受攻击的计算往往更为复杂，变量的值也更难预测，但为了说明问题，简单的代码让我们更容易理解发生了什么。
- en: 'Consider this straightforward payroll computation formula: the number of hours
    worked times the rate of pay gives the total dollars of pay. This simple calculation
    will be done in fractional hours and dollars, which gives us full precision. On
    the flip side, with rounding, the details get a little complicated, and as will
    be seen, integer overflow easily happens.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单的工资计算公式：工作小时数乘以工资率得到总工资。这一简单计算将在分数小时和分数美元中进行，从而提供完整的精度。另一方面，使用四舍五入时，细节会变得有些复杂，正如将要看到的，整数溢出很容易发生。
- en: 'Using 32-bit integers for exact precision, we compute dollar values in cents
    (units of $0.01), and hours in thousandths (units of 0.001 hours), so the numbers
    do get big. But as the highest possible 32-bit integer value, `UINT32_MAX`, is
    over 4 billion (2^(32) – 1), we assume we’ll be safe by the following logic: company
    policy limits paid work to 100 hours per week (100,000 in thousandths), so at
    an upper limit of $400/hour (40,000 cents), that makes a maximum paycheck of 4,000,000,000
    (and $40,000 is a nice week’s pay).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 32 位整数进行精确计算，我们以分（$0.01 单位）计算美元值，以千分之一小时（0.001 小时单位）计算工作时间，因此数字会变得很大。但由于最高的
    32 位整数值 `UINT32_MAX` 超过 40 亿（2^(32) – 1），我们假设以下逻辑可以保证安全：公司政策将每周工作时间限制为 100 小时（100,000
    千分之一小时），假设每小时工资上限为 400 美元（40,000 分），那么最大薪水为 4,000,000,000（40,000 美元是一周的不错工资）。
- en: 'Here is the computation of pay in C, with all variables and constants defined
    as `uint32_t` values:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是用 C 语言计算工资的代码，所有变量和常量都定义为 `uint32_t` 类型：
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `if` statement, which returns an error indication for out-of-range parameters,
    is an essential guard for preventing overflow in the computation that follows.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句，返回超出范围参数的错误指示，是防止后续计算中溢出的必要保护。'
- en: 'The computation in the `return` statement deserves explanation. Since we are
    representing hours in thousandths, we must divide the result by 1,000 to get the
    actual pay, so we first add 500 (half of the divisor) for rounding. A trivial
    example confirms this: 10 hours (10,000) times $10.00/hour (1,000) equals 10,000,000;
    add 500 for rounding, giving 10,000,500; and divide by 1,000, giving 10,000 or
    $100.00, the correct value. Even at this point, you should consider this code
    fragile, to the extent that it flirts with the possibility of truncation due to
    fixed-width integer limitations.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 语句中的计算值得解释。由于我们将小时表示为千分之一，我们必须将结果除以1,000才能得到实际的工资，因此我们首先加上500（除数的一半）以便进行四舍五入。一个简单的例子可以验证这一点：10小时（10,000）乘以$10.00/小时（1,000）等于10,000,000；加上500进行四舍五入，得到10,000,500；然后除以1,000，得到10,000或$100.00，这是正确的值。即便在此时，你也应该认为这段代码是脆弱的，因为它可能会由于固定宽度整数限制而面临截断的风险。'
- en: So far the code works fine for all inputs, but suppose management has announced
    a new overtime policy. We need to modify the code to add 50 percent to the pay
    rate for all overtime hours (any hours worked after the first 40 hours). Further,
    the percentage should be a parameter, so management can easily change it later.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这段代码在所有输入下都能正常工作，但假设管理层宣布了一项新的加班政策。我们需要修改代码，将所有加班小时的工资（超过40小时后的工作时间）增加50%。此外，百分比应为一个参数，以便管理层以后可以轻松更改它。
- en: 'To add the extra pay for overtime hours, we introduce `overtime_percentage`.
    The code for this isn’t shown, but its value is 150, meaning 150 percent of normal
    pay for overtime hours. Since the pay will increase, the $400/hour limit won’t
    work anymore, because it won’t be low enough to prevent integer overflow. But
    that pay rate was unrealistic as a practical limit anyhow, so let’s halve it,
    just to be safe, and say $200/hour is the top pay rate:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加加班小时的额外工资，我们引入了`overtime_percentage`。这段代码没有显示，但它的值是150，意味着加班小时按正常工资的150%支付。由于工资会增加，$400/小时的限制将不再适用，因为它不够低，无法防止整数溢出。但这个工资限制本来就不太现实，所以我们将它减半，以确保安全，并设定$200/小时为最高工资率：
- en: '**vulnerable code**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**脆弱的代码**'
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we check if the number of hours exceeds the overtime pay threshold (40
    hours), and if not, the same calculation applies. In the case of overtime, we
    first compute `overage_millihours` as the hours (in thousandths) over 40.000\.
    For those hours, we multiply the computed pay by the `overtime_percentage` (150).
    Since we have a percentage (two digits of decimal fraction) and thousandths of
    hours (three digits of decimals), we must divide by 100,000 (five zeros) after
    adding half of that for rounding. After computing the base pay on the first 40
    hours, without the overtime adjustment, the code sums the two to calculate the
    total pay. For efficiency, we could combine these similar computations, but the
    intention here is for the code to structurally match the computation for clarity.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们检查工作小时数是否超过了加班支付的临界点（40小时），如果没有，应用相同的计算。对于加班情况，我们首先计算`overtime_millihours`，即超过40.000小时的工作时间（以千分之一小时为单位）。对于这些小时，我们将计算出的工资乘以`overtime_percentage`（150）。由于我们有一个百分比（两位小数）和千分之一小时（小数点后三位），因此在加上它的一半用于四舍五入后，我们必须除以100,000（五个零）。在计算了前40小时的基本工资后，没有加班调整，代码将两者相加，得出总工资。为了提高效率，我们可以将这些相似的计算合并，但这里的目的是使代码在结构上与计算匹配，以便清晰明了。
- en: This code works most of the time, but not always. One example of an odd result
    is that 60.000 hours worked at $50.00/hour yields $2,211.51 in pay (it should
    be $3,500.00). The problem is with the multiplication by `overtime_percentage`
    (150), which easily overflows with a number of overtime hours at a good rate of
    pay. In integer arithmetic, we cannot precompute 150/100 as a fraction—as an integer
    that’s just 1—so we have to do the multiplication first.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码大部分时间都能正常工作，但并非每次都如此。一个奇怪的结果是，60.000小时工作，时薪$50.00，计算出的工资为$2,211.51（应该是$3,500.00）。问题出在与`overtime_percentage`（150）的乘法上，随着加班小时数的增加和较高的时薪，它很容易溢出。在整数运算中，我们不能将150/100作为一个分数预先计算——作为整数它的值是1——所以我们必须先进行乘法运算。
- en: 'To fix this code, we could replace `(X*150)/100` with `(X*3)/2`, but that ruins
    the parameterization of the overtime percentage and wouldn’t work if the rate
    changed to a less amenable value. One solution that maintains the parameterization
    would be to break up the computation so that the multiplication and division use
    64-bit arithmetic, downcasting to a 32-bit result:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这段代码的问题，我们可以将 `(X*150)/100` 替换为 `(X*3)/2`，但是这样会破坏加班百分比的参数化，并且如果费率变为一个不太容易处理的值，这种方法就无法使用。一个能够保持参数化的解决方案是将计算过程拆分，使得乘法和除法使用
    64 位算术运算，并将结果转换为 32 位：
- en: '**fixed code**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**固定代码**'
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For illustrative purposes, the 64-bit variables include that designation in
    their names. We could also write these expressions with a lot of explicit casting,
    but it would get long and be less readable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明问题，64 位变量的名称中包含了这一标识。我们也可以通过大量显式转换来编写这些表达式，但这样会显得冗长且不易阅读。
- en: The multiplication of three values was split up to multiply two of them into
    a 64-bit variable before overflow can happen; once upcast, the multiplication
    with the percentage is 64-bit and will work correctly. The resultant code is admittedly
    messier, and comments to explain the reasoning would be helpful. The cleanest
    solution would be to upgrade all variables in sight to 64-bit at a tiny loss of
    efficiency. Such are the trade-offs involved in using fixed-width integers for
    computation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 三个值的乘法被拆分成先将其中两个值乘到一个 64 位变量中，防止溢出发生；一旦进行了上溢，和百分比的乘法就是 64 位的，并且会正确工作。虽然结果代码的确更为复杂，并且需要注释来解释推理过程，但最干净的解决方案是将所有变量升级为
    64 位，牺牲一点效率。这就是使用固定宽度整数进行计算时所涉及的权衡。
- en: Safe Arithmetic
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全算术
- en: Integer overflow is more frequently problematic than floating-point underflow
    because it can generate dramatically different results, but we can by no means
    safely ignore floating-point underflow, either. Since by design compilers do arithmetic
    in ways that potentially diverge from mathematical correctness, developers are
    responsible for dealing with the consequences. Once aware of these problems, you
    can adopt several mitigation strategies to help avoid vulnerabilities.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 整数溢出比浮点下溢更常见问题，因为它可能会导致结果的剧烈变化，但我们同样不能安全地忽视浮点下溢问题。由于编译器在设计时进行的算术运算可能与数学正确性有所偏差，开发者必须负责处理其后果。一旦意识到这些问题，你可以采取几种缓解策略来帮助避免漏洞。
- en: 'Avoid using tricky code to handle potential overflow problems because any mistakes
    will be hard to find by testing and represent potentially exploitable vulnerabilities.
    Additionally, a trick might work on your machine but not be portable to other
    CPU architectures or different compilers. Here is a summary of how to do these
    computations safely:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用复杂的代码来处理潜在的溢出问题，因为任何错误都难以通过测试找到，并且可能代表潜在的可利用漏洞。此外，一种技巧可能在你的机器上有效，但无法移植到其他
    CPU 架构或不同的编译器。以下是如何安全地进行这些计算的总结：
- en: Be careful using type conversions that can potentially truncate or distort results,
    just as calculations can.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用可能截断或扭曲结果的类型转换时要小心，就像计算本身可能会出现的问题一样。
- en: Where possible, constrain inputs to the computation to ensure that all possible
    values are representable.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能限制输入值，以确保所有可能的值都能被表示。
- en: Use a larger fixed-size integer to avoid possible overflow; check that the result
    is within bounds before converting it back to a smaller-sized integer.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更大的固定大小整数来避免可能的溢出；在将结果转换回更小的整数之前，检查其是否在范围内。
- en: Remember that intermediate computed values may overflow, causing a problem,
    even if the final result is always within range.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，尽管最终结果始终在范围内，但中间计算的值可能会发生溢出，从而导致问题。
- en: Use extra care when checking the correctness of arithmetic in and around security-sensitive
    code.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检查与安全相关的代码中的算术正确性时要格外小心。
- en: If the nuances of fixed-width integer and floating-point computations still
    feel arcane, watch them closely and expect surprises in what might seem like elementary
    calculations. Once you know they can be tricky, a little testing with some ad
    hoc code in your language of choice is a great way to get a feel for the limits
    of the basic building blocks of computer math.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果固定宽度整数和浮点计算的细节仍然显得晦涩难懂，请密切关注它们，并且准备好遇到看似简单的计算中可能出现的惊讶。一旦你知道它们可能很棘手，使用你选择的编程语言进行一些临时测试代码是一个很好的方式，可以帮助你了解计算机数学基本构件的极限。
- en: Once you have identified the code at risk of these sort of bugs, make test cases
    that invoke calculations with extreme values for all inputs, then check the results.
    Well-chosen test cases can detect overflow problems, but a limited set of tests
    is not proof that the code is immune to overflow.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了存在这些漏洞风险的代码，就可以创建测试用例，通过所有输入的极限值进行计算，并检查结果。精心设计的测试用例可以检测溢出问题，但有限的测试集并不能证明代码完全不受溢出问题的影响。
- en: Fortunately, more modern languages, such as Python, increasingly use arbitrary-precision
    integers and are not generally subject to these problems. Getting arithmetic computation
    right begins with understanding precisely how the language you use works in complete
    detail. You can find an excellent reference with details for several popular languages
    at the memorable URL [floating-point-gui.de](http://floating-point-gui.de), which
    provides in-depth explanation and best-practice coding examples.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，更现代的编程语言，如Python，越来越多地使用任意精度整数，通常不会受到这些问题的困扰。正确进行算术计算的前提是精确理解你所使用的编程语言的工作原理。你可以通过记住网址[floating-point-gui.de](http://floating-point-gui.de)找到一个很好的参考资料，里面提供了几种流行语言的详细信息，包括深入的解释和最佳实践编码示例。
- en: Memory Access Vulnerabilities
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存访问漏洞
- en: The other vulnerability class we’ll discuss involves improper memory access.
    Direct management of memory is powerful and potentially highly efficient, but
    it comes with the risk of arbitrarily bad consequences if the code gets anything
    wrong.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类我们将讨论的漏洞是与不当内存访问有关的漏洞。直接管理内存既强大又潜在地高效，但如果代码出错，可能会带来任意的严重后果。
- en: Most programming languages offer fully managed memory allocation and constrain
    access to proper bounds, but for reasons of efficiency or flexibility, or sometimes
    because of the inertia of legacy, other languages (predominantly C and C++) make
    the job of memory management the responsibility of the programmer. When programmers
    take on this job—even experienced programmers—they can easily get it wrong, especially
    as the code gets complicated, creating serious vulnerabilities. And as with the
    arithmetic flaws described earlier, the great danger is when a violation of memory
    management protocol goes uncaught and continues to happen silently.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言提供完全托管的内存分配，并限制对适当边界的访问，但出于效率、灵活性，或有时是由于传统的惯性，其他语言（主要是C和C++）将内存管理的工作交给程序员来负责。当程序员承担这项工作时——即使是经验丰富的程序员——也很容易出错，尤其是在代码变得复杂时，这可能会导致严重的漏洞。与之前提到的算术错误类似，最大的危险是当内存管理协议被违反且未被发现时，这种问题会悄无声息地持续发生。
- en: In this section, the focus is on the security aspects of code that directly
    manages and accesses memory, absent built-in safeguards. Code examples will use
    the classic dynamic memory functions of the original C standard library, but these
    lessons apply generally to the many variants that provide similar functionality.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点讨论直接管理和访问内存且没有内置保护机制的代码的安全性问题。代码示例将使用原始C标准库中的经典动态内存函数，但这些教训通常适用于提供类似功能的许多变体。
- en: Memory Management
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存管理
- en: Pointers allow direct access to memory by its address, and they are perhaps
    the most powerful feature of the C language. But just like when wielding any power
    tool, it’s important to use responsible safety precautions to manage the attendant
    risk. Software allocates memory when needed, works within its available bounds,
    and releases it when no longer needed. Any access outside of this agreement of
    space and time will have unintended consequences, and that’s where vulnerabilities
    arise.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 指针允许通过地址直接访问内存，它们可能是C语言中最强大的特性。但就像使用任何强力工具一样，管理附带风险时，采取负责任的安全预防措施非常重要。软件在需要时分配内存，在可用范围内工作，当不再需要时释放内存。任何超出这种空间和时间约定的访问都会导致意外后果，这就是漏洞产生的地方。
- en: The C standard library provides dynamic memory allocation for large data structures,
    or when the size of a data structure cannot be determined at compile time. This
    memory is allocated from the *heap*—a large chunk of address space in the process
    used to provide working memory. C programs use `malloc(3)` to allocation memory,
    and when it’s no longer needed, they release each allocation for reuse by calling
    `free(3)`. There are many variations on these allocation and deallocation functions;
    we will focus on these two for simplicity, but the ideas should apply anytime
    code is managing memory directly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准库提供了动态内存分配，用于处理大型数据结构或当数据结构的大小在编译时无法确定时。这块内存从*堆*中分配——堆是进程中用于提供工作内存的一大块地址空间。C
    程序使用`malloc(3)`来分配内存，当不再需要时，通过调用`free(3)`释放每一块内存以供重用。虽然这些内存分配和释放函数有很多变种，但为了简化起见，我们将重点讨论这两个函数，但这些思路适用于任何直接管理内存的代码。
- en: 'Access after memory release can easily happen when lots of code shares a data
    structure that eventually gets freed, but copies of the pointer remain behind
    and get used in error. After the memory gets recycled, any use of those old pointers
    violates memory access integrity. On the flip side, forgetting to release memory
    after use risks exhausting the heap over time and running out of memory. The following
    code excerpt shows the basic correct usage of heap memory:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 内存释放后仍然访问内存很容易发生，尤其是当许多代码共享一个最终会被释放的数据结构时，但指针的副本仍然存在并被错误使用。内存回收后，任何对这些旧指针的使用都会违反内存访问的完整性。另一方面，如果忘记释放内存，可能会导致堆内存耗尽，最终用尽内存。以下代码片段展示了堆内存的基本正确使用方法：
- en: '[PRE13]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code accesses the memory between the allocation and deallocation calls,
    inside the bounds of allotted memory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在分配和释放内存的调用之间访问内存，且在分配的内存范围内。
- en: In actual use, the allocation, memory access, and deallocation can be scattered
    around the code, making it tricky to always do this just right.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际使用中，内存分配、访问和释放可能分散在代码的不同位置，这使得始终正确地执行这些操作变得复杂。
- en: Buffer Overflow
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区溢出
- en: 'A *buffer overflow* (or, alternatively, *buffer overrun*) occurs when code
    accesses a memory location outside of the intended target buffer. It’s important
    to be very clear about its meaning because the terminology is confusing. *Buffer*
    is a general term for any region in memory: data structures, character strings,
    arrays, objects, or variables of any type. *Access* is a catch-all term for reading
    or writing memory. That means a buffer overflow involves reading or writing outside
    of the intended memory region, even though “overflow” more naturally describes
    the act of writing. While the effects of reading and writing differ fundamentally,
    it’s useful to think of them together to understand the problem.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*缓冲区溢出*（或称*缓冲区溢出错误*）发生在代码访问了目标缓冲区外的内存位置时。理解其含义非常重要，因为相关术语可能会引起混淆。*缓冲区*是内存中任何区域的通用术语：数据结构、字符字符串、数组、对象或任何类型的变量。*访问*是一个涵盖所有读取或写入内存的术语。这意味着缓冲区溢出涉及在意图之外的内存区域进行读取或写入，尽管“溢出”更自然地描述的是写入操作。尽管读取和写入的效果在本质上不同，但将它们放在一起理解问题会更有帮助。'
- en: Buffer overflows are not exclusive to heap memory, but can occur with any kind
    of variable, including static allocations and local variables on the stack. All
    of these potentially modify other data in memory in arbitrary ways. Unintended
    writes out of bounds could change just about anything in memory, and clever attackers
    will refine such an attack to try to cause maximum damage. In addition, buffer
    overflow bugs may read memory unexpectedly, possibly leaking information to attackers
    or otherwise causing the code to misbehave.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出不仅仅限于堆内存，任何类型的变量都有可能发生缓冲区溢出，包括静态分配和栈上的局部变量。这些都可能以任意方式修改内存中的其他数据。意外的越界写入可能会改变内存中的任何内容，聪明的攻击者会不断改进这种攻击方式，力图造成最大损害。此外，缓冲区溢出错误可能会意外地读取内存，可能会泄露信息给攻击者，或导致代码行为异常。
- en: Don’t underestimate the difficulty and importance of getting explicit memory
    allocation, access within bounds, and release of unused storage exactly right.
    Simple patterns of allocation, use, and release are best, including exception
    handling to ensure that the release is never skipped. When allocation by one component
    hands off the reference to other code, it’s critical to define responsibility
    for subsequently releasing the memory to one side of the interface or the other.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不要低估正确获取显式内存分配、确保访问在边界内，并准确释放未使用存储的重要性和难度。最佳做法是采用简单的分配、使用和释放模式，包括异常处理，以确保释放操作从不被跳过。当一个组件进行分配并将引用交给其他代码时，必须明确指定责任，确保最终释放内存的操作由接口的某一方负责。
- en: Finally, be cognizant that even in a fully range-checked, garbage-collected
    language, you can still get in trouble. Any code that directly manipulates data
    structures in memory can make errors equivalent to buffer overflow issues. Consider,
    for example, manipulating a byte string, such as a TCP/IP packet in a Python array
    of bytes. Reading the contents and making modifications involves computing offsets
    into data and can be buggy, even if access outside the array does not occur.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，即使在完全进行了范围检查、并且使用垃圾回收机制的语言中，你仍然可能会遇到问题。任何直接操作内存中数据结构的代码，都可能产生类似缓冲区溢出问题的错误。例如，考虑操作一个字节字符串，如
    Python 数组中的 TCP/IP 数据包。读取内容并进行修改涉及计算数据的偏移量，即使没有发生数组外的访问，也可能会出错。
- en: 'Example: Memory Allocation Vulnerabilities'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：内存分配漏洞
- en: Let’s look at an example showing the dangers of dynamic memory allocation gone
    wrong. I’ll make this example straightforward, but in actual applications the
    key pieces of code are often separated, making these flaws much harder to see.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，展示动态内存分配出现问题的危险。我将这个示例简化，但在实际应用中，关键代码往往是分开的，这使得这些漏洞更加难以察觉。
- en: A Simple Data Structure
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个简单的数据结构
- en: 'This example uses a simple C data structure representing a user account. The
    structure consists of a flag that’s set if the user is an admin, a user ID, a
    username, and a collection of settings. The semantics of these fields don’t matter
    to us, except if the `isAdmin` field is nonzero, as this confers unlimited authorization
    (making this field an attractive target for attack):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用一个简单的 C 数据结构来表示用户账户。该结构包括一个标志，如果用户是管理员则设置该标志、用户 ID、用户名和一组设置。除非`isAdmin`字段非零，因为这个字段赋予无限授权（使其成为攻击的一个诱人目标），否则这些字段的语义对我们并不重要：
- en: '[PRE14]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here’s a function that creates these user account records:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个创建这些用户账户记录的函数：
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first parameter specifies whether the user is an admin or not. The second
    parameter provides a username, which must not exceed the specified maximum length.
    A global counter (`userid_next`, declaration not shown) provides sequential unique
    IDs. The values of all the settings are set to zero initially, and the code returns
    a pointer to the new record unless an error causes it to return `NULL` instead.
    Note that the code checks the length of the `username` string before the allocation,
    so that allocation happens only when the memory will get used.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数指定用户是否为管理员。第二个参数提供一个用户名，用户名长度不得超过指定的最大长度。一个全局计数器（`userid_next`，声明未显示）提供连续的唯一
    ID。所有设置的初始值都为零，除非发生错误导致返回`NULL`，否则代码会返回指向新记录的指针。请注意，代码在分配内存之前会检查`username`字符串的长度，以确保仅在内存将被使用时才进行分配。
- en: Writing an Indexed Field
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 写入索引字段
- en: 'After we’ve created a record, the values of all the settings can be set using
    the following function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 创建记录后，所有设置的值可以通过以下函数进行设置：
- en: '**vulnerable code**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**脆弱的代码**'
- en: '[PRE16]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function takes an index into the settings and a value as decimal number
    strings. After converting these to integers, it stores the value as the indexed
    setting in the record. For example, to assign setting 1 the value 14, we would
    invoke the function `update_setting(ua, "1", "14")`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个设置的索引和一个作为十进制数字字符串的值。将这些值转换为整数后，它将值作为索引设置存储在记录中。例如，要将设置 1 的值设置为 14，我们会调用函数`update_setting(ua,
    "1", "14")`。
- en: The function `strtol` converts the strings to integer values. The pointer that
    `strtol` sets (`endptr`) tells the caller how far it parsed; if that isn’t the
    null terminator, the string wasn’t a valid integer and the code returns an error.
    After ensuring that the index (`i`) does not exceed the number of settings, it
    parses the value (`v`) in the same way and stores the setting’s value in the record.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`strtol`将字符串转换为整数值。`strtol`设置的指针（`endptr`）告诉调用者它解析了多远；如果不是空字符终止符，则说明字符串不是有效的整数，代码会返回错误。在确保索引（`i`）不超过设置数量后，它会以相同的方式解析值（`v`），并将设置的值存储在记录中。
- en: Buffer Overflow Vulnerability
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓冲区溢出漏洞
- en: 'All this setup is simplicity itself, though C tends to be verbose. Now let’s
    cut to the chase. There’s a bug: no check exists for a negative index value. If
    an attacker can manage to get this function called as `update_setting(ua, "-12",
    "1")` they can become an admin. This is because the assignment into settings accesses
    48 bytes backward into the record, since each item is of type `long`, which is
    4 bytes. Therefore, the assignment writes the value `1` into the `isAdmin` field,
    granting excess privileges.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些设置本身很简单，尽管C语言通常显得冗长。现在让我们直接切入正题。存在一个bug：没有检查负索引值。如果攻击者能够将此函数调用为`update_setting(ua,
    "-12", "1")`，他们就能成为管理员。这是因为对设置的赋值会访问记录中的48个字节，向后偏移，因为每个项目的类型是`long`，占用4个字节。因此，赋值将`1`写入`isAdmin`字段，从而授予过多的权限。
- en: In this case, the fact that we allowed negative indexing within a data structure
    caused an unauthorized write to memory that violated a security protection mechanism.
    You need to watch out for many variations on this theme, including indexing errors
    due to missing limit checks or arithmetic errors such as overflow. Sometimes,
    a bad access out of one data structure can modify other data that happens to be
    in the wrong place.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们允许在数据结构中使用负索引，导致未授权的内存写入，违反了安全保护机制。你需要警惕此类问题的多种变体，包括由于缺少边界检查或算术错误（如溢出）而导致的索引错误。有时，一个错误的访问可能会修改其他数据，而这些数据恰好处于错误的位置。
- en: 'The fix is to prevent negative index values from being accepted, which limits
    write accesses to the valid range of settings. The following addition to the `if`
    statement rejects negative values of `i`, closing the loophole:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是防止接受负索引值，从而将写入访问限制在有效的设置范围内。以下对`if`语句的补充会拒绝负值`i`，从而堵住漏洞：
- en: '[PRE17]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The additional `i < 0` condition will now reject any negative index value, blocking
    any unintended modification by this function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的`i < 0`条件现在会拒绝任何负索引值，从而阻止该函数进行任何非预期的修改。
- en: Leaking Memory
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: Even once we’ve fixed the negative index overwrite flaw, there’s still a vulnerability.
    The documentation for `malloc(3)` warns, with underlining, “The memory is not
    initialized.” This means that the memory could contain anything, and a little
    experimentation does show that leftover data appears in there, so recycling the
    uninitialized memory represents a potential leak of private data.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经修复了负索引覆盖的问题，仍然存在漏洞。`malloc(3)`的文档警告并加下划线：“内存未初始化。” 这意味着内存可能包含任何内容，经过一些实验，我们发现其中确实有残留数据，因此回收未初始化的内存会导致私密数据泄露的潜在风险。
- en: 'Our `create_user_account` function does write data to all fields of the structure,
    but it still leaks bytes that are in the data structure as recycled memory. Compilers
    usually align field offsets that allow efficient writing: on my 32-bit computer,
    field offsets are a multiple of 4 (4 bytes of 8 bits is 32), and other architectures
    perform similar alignments. The alignment is needed because writing a field that
    spans a multiple-of-4 address (for example, writing 4 bytes to address 0x1000002)
    requires two memory accesses. So in this example, after the single-byte Boolean
    `isAdmin` field at offset 0, the `userid` field follows at offset 4, leaving the
    three intervening bytes (offsets 1–3) unused. [Figure 9-3](#figure9-3) shows the
    memory layout of the data structure in graphical form.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`create_user_account`函数确实写入了结构体的所有字段，但它仍然泄露了作为回收内存的数据结构中的字节。编译器通常会对字段偏移量进行对齐，以便高效写入：在我的32位计算机上，字段偏移量是4的倍数（4个字节等于32位），而其他架构也执行类似的对齐。之所以需要对齐，是因为写入跨越4的倍数地址的字段（例如，将4个字节写入地址0x1000002）需要两次内存访问。因此，在这个示例中，偏移量为0的单字节布尔值`isAdmin`字段之后，`userid`字段位于偏移量4处，留下了中间的3个字节（偏移量1–3）未使用。[图9-3](#figure9-3)展示了数据结构的内存布局。
- en: '![f09003](image_fi/501928c09/f09003.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](image_fi/501928c09/f09003.png)'
- en: 'Figure 9-3: The memory layout of the user_account record'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：`user_account` 记录的内存布局
- en: Additionally, the use of `strcpy` for the username leaves another chunk of memory
    in its uninitialized state. This string copy function stops copying at the null
    terminator, so, for example, a 5-character string would only modify the first
    6 bytes, leaving 34 bytes of whatever `malloc` happened to grab for us. The point
    of all this is that the newly allocated structure contains residual data which
    may leak unless every byte is overwritten.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`strcpy`在复制用户名时会留下另一块未初始化的内存。这一字符串复制函数会在遇到空字符终止符时停止复制，所以例如一个5个字符的字符串只会修改前6个字节，剩下的34个字节则会保留`malloc`为我们分配的任何内容。所有这一切的要点是，新的分配结构包含残留数据，这些数据可能会泄漏，除非每个字节都被覆盖。
- en: Mitigating the risk of these inadvertent memory leaks isn’t hard, but you must
    diligently overwrite all bytes of data structures that could be exposed. You shouldn’t
    attempt to anticipate precisely how the compiler might allocate field offsets,
    because this could vary over time and across platforms. Instead, the easiest way
    to avoid these issues is to zero out buffers once allocated unless you can otherwise
    ensure they are fully written, or know they won’t be disclosed across a trust
    boundary. Remember that even if your code doesn’t use sensitive data itself, this
    memory leak path could expose other data anywhere in the process.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 减轻这些无意间发生的内存泄漏风险并不困难，但你必须勤奋地覆盖所有可能被暴露的数据结构的字节。你不应该试图精确预测编译器如何分配字段偏移量，因为这可能会随时间和平台的不同而变化。相反，避免这些问题的最简单方法是，在分配缓冲区后将其清零，除非你能确保它们已经完全写入，或者知道它们不会跨信任边界泄露。记住，即使你的代码本身不使用敏感数据，这条内存泄漏路径也可能暴露进程中的其他数据。
- en: Generally speaking, you should avoid using `strcpy` to copy strings because
    there are so many ways to get it wrong. The `strncpy` function both fills unused
    bytes in the target with zeros and protects against overflow with strings that
    exceed the buffer size. However, `strncpy` does *not* guarantee that the resultant
    string will have a null terminator. This is why it’s essential to allocate the
    buffer to be of size `MAX_USERNAME_LEN` `+ 1`, ensuring that there is always room
    for the null terminator. Another option is to use the `strlcpy` function, which
    does ensure null termination; however, for efficiency, it does not zero-fill unused
    bytes. As this example shows, when you handle memory directly there are many factors
    you must deal with carefully.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应该避免使用`strcpy`来复制字符串，因为有太多的方式可能出错。`strncpy`函数不仅将目标中未使用的字节填充为零，还能防止缓冲区溢出。但`strncpy`并不保证结果字符串会有一个空字符终止符。因此，分配缓冲区时必须确保其大小为`MAX_USERNAME_LEN`
    `+ 1`，以保证总有空间留给空字符终止符。另一种选择是使用`strlcpy`函数，它可以确保空字符终止符的存在；然而，为了提高效率，它不会填充未使用的字节。正如这个例子所示，当你直接处理内存时，有许多因素需要小心应对。
- en: Now that we’ve covered the mechanics of memory allocation and seen what vulnerabilities
    look like in a constructed example, let’s consider a more realistic case. The
    following example is based on a remarkable security fiasco from several years
    ago that compromised a fair share of the world’s major web services.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了内存分配的机制，并通过构造的示例看到了漏洞的表现，让我们考虑一个更现实的案例。以下示例基于几年前发生的一场引人注目的安全事件，该事件影响了世界上许多主要的网络服务。
- en: 'Case Study: Heartbleed'
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究：Heartbleed
- en: In early April 2014, headlines warned of a worldwide disaster narrowly averted.
    Major operating system platforms and websites rolled out coordinated fixes, hastily
    arranged in secret, in an attempt to minimize their exposure as details of the
    newly identified security flaw became public. Heartbleed made news not only as
    “the first security bug with a cool logo,” but because it revealed a trivially
    exploitable hole in the armor of any server deploying the popular OpenSSL TLS
    library.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年4月初，头条新闻警告全球灾难险些发生。主要操作系统平台和网站推出了协调的修复措施，这些修复措辞匆忙且秘密安排，试图在新识别出的安全漏洞细节公之于众时，尽量减少其暴露。Heartbleed不仅因为“第一个带有酷炫标志的安全漏洞”而成为新闻，而且它揭示了部署流行OpenSSL
    TLS库的任何服务器都有一个轻易被利用的漏洞。
- en: What follows is an in-depth look at one of the scariest security vulnerabilities
    of the decade, and it should provide you with context for how serious mistakes
    can be. The purpose of this detailed discussion is to illustrate how bugs managing
    dynamically allocated memory can become devastating vulnerabilities. As such,
    I have simplified the code and some details of the complicated TLS communication
    protocol to show the crux of the vulnerability. Conceptually, this corresponds
    directly with what actually occurred, but with fewer moving parts and much simpler
    code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对本十年最可怕的安全漏洞之一的深入分析，它应该能帮助你理解严重错误是如何产生的。这段详细讨论的目的，是为了说明管理动态分配内存的 bug 如何变成灾难性的漏洞。因此，我简化了代码和一些复杂的
    TLS 通信协议细节，以展示漏洞的关键所在。从概念上讲，这与实际发生的情况直接对应，但代码部分更少，结构也更加简化。
- en: Heartbleed is a flaw in the OpenSSL implementation of the TLS Heartbeat Extension,
    proposed in 2012 with RFC 6520\. This extension provides a low-overhead method
    for keeping TLS connections alive, saving clients from having to re-establish
    a new connection after a period of inactivity. The so-called heartbeat itself
    is a round-trip message exchange consisting of a *heartbeat request*, with a payload
    of between 16 and 16,384 (2^(14)) bytes of arbitrary data, echoed back as a *heartbeat
    response* containing the same payload. [Figure 9-4](#figure9-4) shows the basic
    request and response messages of the protocol.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed 是 OpenSSL 实现 TLS 心跳扩展中的一个漏洞，该扩展在 2012 年通过了 RFC 6520 提议。这个扩展提供了一种低开销的方法来保持
    TLS 连接活跃，从而避免客户端在一段时间不活动后重新建立连接。所谓的心跳本身是一种往返消息交换，包括一个 *心跳请求*，其有效负载大小在 16 到 16,384（2^(14)）字节之间的任意数据，回传为一个
    *心跳响应*，其中包含相同的有效负载。[图 9-4](#figure9-4) 展示了该协议的基本请求和响应消息。
- en: '![f09004](image_fi/501928c09/f09004.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![f09004](image_fi/501928c09/f09004.png)'
- en: 'Figure 9-4: The Heartbeat protocol (simplified)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：心跳协议（简化版）
- en: Having downloaded an HTTPS web page, the client may later send a heartbeat request
    on the connection to let the server know that it wants to maintain the connection.
    In an example of normal use, the client might send the 16-byte message “Hello!”
    (padded with zeros) comprising the request, and the server would respond by sending
    the same 16 bytes back. (That’s how it’s supposed to work, at least.) Now let’s
    look at the Heartbleed bug.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端下载了 HTTPS 网页后，可能会在连接上发送心跳请求，以告知服务器它希望保持连接。在正常使用的示例中，客户端可能会发送一个 16 字节的消息“Hello!”（用零填充），作为请求，服务器会通过发送相同的
    16 字节回应。（至少按理说应该是这样。）现在让我们来看看 Heartbleed 漏洞。
- en: 'The critical flaw occurs in malformed heartbeat requests that provide a small
    payload yet claim a larger payload byte count. To see exactly how this works,
    let’s first look at the internal structure of one of the simplified heartbeat
    messages that the peers exchange. All of the code in this example is in C:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的漏洞出现在格式错误的心跳请求中，这些请求提供了一个较小的有效负载，但却声称有一个更大的有效负载字节数。为了准确了解这如何工作，我们首先来看一下简化版心跳消息的内部结构，这些消息是通信双方交换的。这个例子中的所有代码都用
    C 语言编写：
- en: '[PRE18]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The data structure declaration `hbmessage` shows the three parts of one of these
    heartbeat messages. The first field is the message `type`, indicating whether
    it’s a request or response. Next is the length in bytes of the message payload,
    called `payload_length`. The third field, called `bytes`, is declared as zero-length,
    but is intended to be used with a dynamic allocation that adds the appropriate
    size needed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构声明 `hbmessage` 显示了这些心跳消息的三个部分。第一个字段是消息 `type`，表示它是请求还是响应。接下来是消息有效负载的字节长度，称为
    `payload_length`。第三个字段叫做 `bytes`，声明为零长度，但其目的是与动态分配一起使用，增加所需的适当大小。
- en: 'A malicious client might attack a target server by first establishing a TLS
    connection to it, and then sending a 16-byte heartbeat request with a byte count
    of 16,000\. Here’s what that looks like as a C declaration:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一个恶意的客户端可能通过先建立一个 TLS 连接，然后发送一个包含 16,000 字节数的 16 字节心跳请求来攻击目标服务器。以下是该请求在 C 语言中的声明方式：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The client sending this is lying: the message says its payload is 16,000 bytes
    long but the actual payload is only 16 bytes. To understand how this message tricks
    the server, look at the C code that processes the incoming heartbeat request message:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 发送此请求的客户端在撒谎：该消息声明其有效负载为 16,000 字节长，但实际的有效负载只有 16 字节。为了理解这条消息如何欺骗服务器，我们来看一下处理传入心跳请求消息的
    C 代码：
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `hb` function gets called with two parameters: the incoming heartbeat `request`
    message and a pointer named `message_length`, which stores the length of the response
    message that the function returns. The first two lines compute the byte length
    of the response as `response_length`, then a memory block of that size gets allocated
    as `response`. The next two lines fill in the first two values of the response
    message: the message `type` and its `payload_length`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`hb` 函数调用时有两个参数：传入的心跳 `request` 消息和一个名为 `message_length` 的指针，它存储着函数返回的响应消息的长度。前两行计算响应的字节长度为
    `response_length`，然后分配一个该大小的内存块作为 `response`。接下来的两行填充响应消息的前两个值：消息 `type` 和其 `payload_length`。'
- en: Next comes the fateful bug. The server needs to send back the message bytes
    received in the request, so it copies the data from the request into the response.
    Because it trusts the request message to have accurately reported its length,
    the function copies 16,000 bytes—but since there are only 16 bytes in the request
    message, the response includes thousands of bytes of internal memory contents.
    The last two lines store the length of the response message and then return the
    pointer to it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是决定性错误。服务器需要返回请求中接收到的消息字节，因此它将请求中的数据复制到响应中。由于它信任请求消息已经准确地报告了其长度，函数复制了 16,000
    字节，但由于请求消息中只有 16 字节，响应中包含了成千上万字节的内部内存内容。最后两行存储响应消息的长度，然后返回指向它的指针。
- en: '[Figure 9-5](#figure9-5) illustrates this exchange of messages, detailing how
    the preceding code leaks the contents of process memory. To make the harm of the
    exploit concrete, I’ve depicted a couple of additional buffers, containing secret
    data, already sitting in memory in the vicinity of the request buffer. Copying
    16,000 bytes from a buffer that only contained a 16-byte payload—illustrated here
    by the overly large dotted-line region—results in the secret data ending up in
    the response message, which the server sends to the client.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-5](#figure9-5) 展示了这一消息交换过程，详细说明了前述代码如何泄露进程内存的内容。为了具体化这个漏洞的危害，我画了几个额外的缓冲区，这些缓冲区中包含着机密数据，已经位于请求缓冲区附近的内存中。从仅包含
    16 字节有效负载的缓冲区复制 16,000 字节——这里通过过大的虚线区域进行了示意——导致机密数据最终出现在响应消息中，而该响应被服务器发送给客户端。'
- en: '![f09005](image_fi/501928c09/f09005.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![f09005](image_fi/501928c09/f09005.png)'
- en: 'Figure 9-5: Attacking with the Heartbleed bug (simplified)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：利用 Heartbleed 漏洞攻击（简化版）
- en: This flaw is tantamount to configuring your server to provide an anonymous API
    that snapshots and sends out thousands of bytes of working memory to all callers—a
    complete breach of memory isolation, exposed to the internet. It should come as
    no surprise that web servers using HTTPS security have any number of juicy secrets
    in working memory. According to the discoverers of the Heartbleed bug, they were
    able to easily steal from themselves “the secret keys used for our X.509 certificates,
    user names and passwords, instant messages, emails and business critical documents
    and communication.” Since exactly what data leaked depended on the foibles of
    memory allocation, the ability of attackers exploiting this vulnerability to repeatedly
    access server memory eventually yielded all kinds of sensitive data. For a simpler
    view of Heartbleed, see [Figure 9-6](#figure9-6).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞相当于配置服务器，提供一个匿名 API，该 API 会将数千字节的工作内存快照并发送给所有调用者——这完全违背了内存隔离原则，暴露给互联网。毫不奇怪，使用
    HTTPS 安全的 web 服务器的工作内存中会包含大量的机密信息。根据 Heartbleed 漏洞的发现者所说，他们轻易地从自己那儿偷取了“用于 X.509
    证书的密钥、用户名和密码、即时消息、电子邮件以及关键的商业文档和通信”。由于泄漏的数据具体内容取决于内存分配的巧合，攻击者利用这个漏洞反复访问服务器内存，最终获取了各种敏感数据。有关
    Heartbleed 更简明的视图，请参见 [图 9-6](#figure9-6)。
- en: '![f09006](image_fi/501928c09/f09006.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![f09006](image_fi/501928c09/f09006.png)'
- en: 'Figure 9-6: Heartbleed Explanation (courtesy of Randall Munroe, [xkcd.com/1354](http://xkcd.com/1354))'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6：Heartbleed 漏洞解释（由 Randall Munroe 提供，[xkcd.com/1354](http://xkcd.com/1354)）
- en: 'The fix was straightforward in hindsight: anticipate “lying” heartbeat requests
    that ask for more payload than they provide, and, as the RFC explicitly specifies,
    ignore them. Thanks to Heartbleed, the world learned how dependent so many servers
    were on OpenSSL, and how few volunteers were laboring on the critical software
    that so much of the internet’s infrastructure depended on. The bug is typical
    of why many security flaws are difficult to detect, because everything works flawlessly
    in the case of well-formed requests, and only malformed requests that well-intentioned
    code would be unlikely to ever make cause problems. Furthermore, the leaked server
    memory in heartbeat responses causes no direct harm to the server: only by careful
    analysis of the excessive data disclosure does the extent of the potential damage
    become evident.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 回过头来看，修复其实很简单：预判那些“伪造”的心跳请求，它们要求的有效负载超过了它们实际提供的内容，按照 RFC 明确规定，应该忽略它们。多亏了 Heartbleed，世界认识到很多服务器对
    OpenSSL 的依赖程度，以及许多志愿者为这些关键软件所做的工作，这些软件是如此多互联网基础设施的支柱。这个漏洞的特点是，许多安全漏洞之所以难以被发现，是因为在结构良好的请求情况下，系统一切正常，只有结构不良的请求会引发问题，而这些不良请求是善意的代码几乎不可能生成的。此外，心跳响应中泄露的服务器内存并不会直接对服务器造成伤害：只有通过对过量数据泄露的仔细分析，潜在的损害程度才变得明显。
- en: 'As arguably one of the most severe security vulnerabilities discovered in recent
    years, Heartbleed should serve as a valuable example of the nature of security
    bugs, and how small flaws can result in a massive undermining of our systems’
    security. From a functional perspective, one could easily argue that this is a
    minor bug: it’s unlikely to happen, and sending back more payload data than the
    request provided seems, at first glance, utterly harmless.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 作为近年来最严重的安全漏洞之一，Heartbleed 应该作为一个宝贵的例子，展示安全漏洞的性质，以及如何通过小小的缺陷导致系统安全的巨大破坏。从功能角度来看，很多人可能会认为这是一个小错误：它不太可能发生，而且比请求提供的更多的有效负载数据，看起来一开始是无害的。
- en: Heartbleed is an excellent object lesson in the fragility of low-level languages.
    Small errors can have massive impact. A buffer overflow potentially exposes high-value
    secrets if they happen to be lying around in memory at just the wrong location.
    The design (protocol specification) anticipated this very error by directing that
    heartbeat requests with incorrect byte lengths should be ignored, but without
    explicit testing, nobody noticed the vulnerability for over two years.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed 是一个很好的教训，展示了低级语言的脆弱性。小错误可能会带来巨大的影响。如果缓冲区溢出发生，并且内存中恰好存放着重要的秘密数据，它可能会暴露这些高价值的秘密。设计（协议规范）预见到了这个错误，并指示应该忽略具有不正确字节长度的心跳请求，但在没有明确测试的情况下，没人注意到这个漏洞，直到两年多以后。
- en: This is just one bug in one library. How many more like it are still out there
    now?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个库中的一个漏洞。现在还有多少类似的漏洞存在？
- en: '10'
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Untrusted Input
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 不受信任的输入
- en: I like engineering, but I love the creative input.
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我喜欢工程学，但我更热爱创意输入。
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —John Dykstra
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —约翰·戴克斯特拉
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Untrusted inputs* are perhaps the greatest source of concern for developers
    writing secure code. The term itself can be confusing, and may best be understood
    as encompassing all inputs to a system that are not *trusted inputs*, meaning
    inputs from code that you can trust to provide well-formed data. Untrusted inputs
    are those that are out of your control and might be manipulated, and include any
    data entering the system that you do not fully trust. That is, they’re inputs
    you *should not trust*, not inputs you *mistakenly trust*.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*不受信任的输入* 可能是开发人员编写安全代码时最需要担心的来源。这个术语本身可能令人困惑，最好理解为包含所有不是 *受信任输入* 的系统输入，即你可以信任的代码提供的格式良好的数据输入。不受信任的输入是指那些超出你控制范围并可能被篡改的数据，包括任何你不完全信任的数据进入系统。也就是说，它们是你
    *不应信任* 的输入，而不是你 *错误信任* 的输入。'
- en: Any data coming from the outside and entering the system is best considered
    untrusted. The system’s users may be nice, trustworthy people, but when it comes
    to security they are best considered untrusted, because they could do anything—including
    falling victim to the tricks of others. Untrusted inputs are worrisome because
    they represent an *attack vector*, a way to reach into the system and cause trouble.
    Maliciously concocted inputs that cross trust boundaries are of special concern
    because they can penetrate deep into the system, causing exploits in privileged
    code, so it’s essential to have good first lines of defense. The world’s greatest
    source of untrusted inputs has to be the internet, and since it’s so rare for
    software to be fully disconnected, this represents a serious threat for almost
    all systems.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 任何来自外部并进入系统的数据都应视为不可信。系统的用户可能是友好、值得信赖的人，但在安全方面，最好将他们视为不可信，因为他们可能做出任何事情——包括成为他人陷阱的受害者。不可信输入令人担忧，因为它们代表着一个
    *攻击向量*，即进入系统并制造麻烦的途径。恶意构造的跨越信任边界的输入尤其值得关注，因为它们可能深入系统，导致特权代码中的漏洞，因此必须拥有强有力的第一道防线。世界上最大的来源不可信输入的地方无疑是互联网，而且由于软件很少能完全断开连接，这对几乎所有系统而言构成了严重威胁。
- en: '*Input validation* (or *input sanitization*) is defensive coding that imposes
    restrictions on inputs, forcing conformity to prescribed rules. By validating
    that inputs meet specific constraints and ensuring that code works properly for
    all valid inputs, you can successfully defend against these attacks. This chapter
    centers on managing untrusted inputs using input validation, and why doing so
    is important to security. The topic may seem mundane and it isn’t technically
    difficult, but the need is so commonplace that doing a better job at input validation
    is perhaps the most impactful low-hanging fruit available to developers for reducing
    vulnerabilities. As such, it’s covered in depth. Character string inputs present
    specific challenges and the security implications of Unicode are too little known,
    so we’ll also survey the basic issues they present. Then we’ll walk through some
    examples of injection attacks perpetrated using untrusted data with various technologies:
    SQL, path traversal, regular expressions, and XML external entities (XXE). Finally,
    I’ll summarize the available mitigation techniques for this broad set of vulnerabilities.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入验证*（或 *输入清理*）是一种防御性编程技术，它对输入施加限制，强制其符合预定规则。通过验证输入是否满足特定约束，并确保代码对所有有效输入都能正确工作，你可以成功防御这些攻击。本章重点讨论如何通过输入验证管理不可信输入，以及这样做对安全性的重要性。这个话题看似平凡，技术上也不难，但需求非常普遍，做得更好的输入验证可能是开发人员减少漏洞的最具影响力的低成本措施。因此，本章对这一内容进行了深入探讨。字符字符串输入存在特定的挑战，Unicode的安全性隐患知之甚少，因此我们还将概述它们所带来的基本问题。接下来，我们将通过一些使用不可信数据进行的注入攻击示例，介绍各种技术：SQL、路径遍历、正则表达式和XML外部实体（XXE）。最后，我将总结针对这一广泛漏洞集合的可用缓解技术。'
- en: Input Validation
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入验证
- en: Before you look for validation in others, try and find it in yourself.
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在寻求他人验证之前，先试着在自己身上找到验证。
- en: ''
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Greg Behrendt
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Greg Behrendt
- en: Now that you understand what untrusted inputs are, consider their potential
    effects within a system and how to protect against harm. Untrusted inputs routinely
    flow through systems, often reaching down many layers into trusted components—so
    just because your code is directly invoked from trusted code, there is no guarantee
    that those inputs can be trusted. The problem is that components might be passing
    through data from anywhere. The more ways an attacker can potentially manipulate
    the data, the more untrusted it is. Upcoming examples should make this point clear.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了什么是不可信输入，接下来考虑它们在系统中的潜在影响以及如何防止危害。不可信输入经常流经系统，通常会深入许多层次的受信组件——因此，虽然你的代码是由受信代码直接调用的，但并不能保证这些输入是可信的。问题在于，组件可能正在传递来自任何地方的数据。攻击者操控数据的方式越多，这些输入就越不可信。接下来的例子将清楚地说明这一点。
- en: Input validation is a good defense, as it dials untrusted input down to a range
    of values that the application can safely process. The essential job of input
    validation is to ensure that untrusted inputs conform to design specifications
    so that code downstream of the validation only deals with well-formed data. Let’s
    say you are writing a user login authentication service that receives a username
    and password, and issues an authentication token if the credentials are correct.
    By restricting usernames to between 8 and 40 characters and requiring that they
    consist of a well-defined subset of Unicode code points, you can make the handling
    of that input much simpler, because it’s a known quantity. Subsequent code can
    use fixed-size buffers to hold a copy of the username, and it need not worry about
    the ramifications of obscure characters. You could likely simplify processing
    based on that assurance in other ways, too.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证是一种有效的防御手段，它将不可信的输入限制在应用程序可以安全处理的值范围内。输入验证的核心任务是确保不可信的输入符合设计规范，以便验证后的代码只处理格式正确的数据。假设你正在编写一个用户登录认证服务，该服务接收用户名和密码，如果凭证正确则发放认证令牌。通过将用户名限制在8到40个字符之间，并要求它们由Unicode代码点的某个明确定义的子集组成，你可以大大简化该输入的处理，因为它是一个已知的数量。后续代码可以使用固定大小的缓冲区来存储用户名的副本，并且无需担心难以处理的字符。基于这一保障，你可能还能以其他方式简化处理。
- en: 'We have already seen input validation used to fix low-level vulnerabilities
    in the previous chapter. The paycheck integer computation code had input validation
    consisting of one `if` statement to guard against overly large input values:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经看到输入验证用于修复低级别的漏洞。工资单整数计算代码包含了一个`if`语句的输入验证，用来防止过大的输入值：
- en: '[PRE21]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There’s no need to repeat the explanation for this, but it serves as a fine
    example of basic input validation. Almost any code you write will only work correctly
    within certain limitations: it won’t work for extreme values such as massive memory
    sizes, or perhaps text in different languages. Whatever the limitations are, we
    don’t want to expose code to inputs it wasn’t designed for, as this risks unintended
    consequences that could create vulnerabilities. One easy method to mitigate this
    danger is to impose artificial restrictions on inputs that screen out all problematic
    inputs.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点无需重复解释，但它作为基本输入验证的一个很好的示例。几乎任何你编写的代码在某些限制条件下才能正常工作：它不适用于极端值，例如巨大的内存大小，或者不同语言的文本。无论这些限制是什么，我们都不希望将代码暴露于它未设计处理的输入，因为这可能会导致意外后果，从而产生漏洞。缓解这一危险的一个简单方法是对输入施加人为的限制，筛除所有有问题的输入。
- en: There are some nuances worth pointing out, however. Of course, restrictions
    should never reject inputs that should have been rightfully handled; for instance,
    in the paycheck example, we cannot reject 40-hour work weeks as invalid. If the
    code cannot handle all valid inputs, then we need to fix it so it can handle a
    broader scope of inputs. Also, an input validation strategy may need to consider
    the interaction of multiple inputs. In the paycheck example, the product of the
    pay rate and hours worked could exceed the fixed-width integer size, as we saw
    in Chapter 9, so validation could limit the product of these two inputs, or set
    limits on each separately. The former approach is more permissive but may be more
    difficult for callers to accommodate, so the right choice depends on the application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些细节需要注意。当然，限制不应拒绝应该被合理处理的输入；例如，在工资单示例中，我们不能将40小时的工作周视为无效。如果代码不能处理所有有效输入，那么我们需要修复它，使其能够处理更广泛的输入范围。此外，输入验证策略可能需要考虑多个输入之间的相互作用。在工资单示例中，工资率和工作小时数的乘积可能超过固定宽度的整数大小，正如我们在第9章中看到的那样，因此验证可以限制这两个输入的乘积，或者分别为每个输入设置限制。前一种方法更宽松，但可能对调用方的适应性要求更高，因此正确的选择取决于应用程序的需求。
- en: Generally, you should validate untrusted inputs as soon as possible, so as to
    minimize the risk of unconstrained input flowing to downstream code that may not
    handle it properly. Once validated, subsequent code benefits from only being exposed
    to well-behaved data; this helps developers write secure code, because they know
    exactly what the range of inputs will be. Consistency is key, so a good pattern
    is to stage input validation in the first layer of code that handles incoming
    data, then hand the valid input off to business logic in deeper layers that can
    confidently assume that all inputs are valid.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应该尽早验证不可信的输入，以尽量减少不受约束的输入流入下游代码的风险，这些下游代码可能无法妥善处理这些输入。一旦验证通过，后续代码就可以只处理规范的输入数据，这有助于开发人员编写安全代码，因为他们明确知道输入的范围。保持一致性至关重要，所以一个好的模式是，在处理输入数据的代码的第一层就进行输入验证，然后将有效的输入交给更深层次的业务逻辑，这样可以让后续代码更有信心地假设所有输入都是有效的。
- en: We primarily think of input validation as a defense against untrusted inputs—specifically,
    what’s on the attack surface—but this does not mean that all other inputs can
    be blithely ignored. No matter how much you trust the provider of some data, it
    may be possible for a mistake to result in unexpected inputs, or for an attack
    to somehow compromise part of the system and effectively expand the attack surface.
    For all of these reasons, defensive input validation is your friend. It’s safest
    to err on the side of redundant input validation rather than risk creating a subtle
    vulnerability—if you don’t know for certain that incoming data is reliably validated,
    you probably need to do it to be sure.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要将输入验证视为防御不可信输入的手段——特别是攻击面上的内容——但这并不意味着其他所有输入都可以被轻视。无论你多么信任某些数据的提供者，仍然有可能由于错误导致意外的输入，或者攻击可能通过某种方式破坏系统的部分内容，从而有效地扩展攻击面。出于这些原因，防御性输入验证是你的好伙伴。与其冒着创建细微漏洞的风险，不如在输入验证上多加冗余，尤其是在你不能确定输入数据是否经过可靠验证的情况下，你可能需要自行验证以确保安全。
- en: Determining Validity
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定有效性
- en: Input validation begins with deciding what’s valid. This is not as straightforward
    as it sounds, because it amounts to anticipating all future valid input values
    and figuring out how, with good reason, to disallow the rest. This decision is
    usually made by the developer, who must weigh what users may want against the
    extra coding involved in permitting a wider range. Ideally, software requirements
    specify what constitutes valid input, and a good design may provide guidance.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证的开始是决定什么是有效的。这并不像听起来那么简单，因为它实际上意味着要预测所有未来可能的有效输入值，并合理地找出如何拒绝其他值。这个决定通常由开发者做出，开发者必须权衡用户可能需要的输入与允许更广泛输入范围所需的额外编码工作。理想情况下，软件需求应该明确规定什么是有效输入，而良好的设计也会提供指导。
- en: For an integer input, the full range of 32-bit integers may appear to be an
    obvious choice because it’s a standard data type. But thinking ahead, if the code
    will add these values together at some point, that’ll require a bigger integer,
    so the 32-bit restriction becomes arbitrary. Alternatively, if you can reasonably
    set a lower limit for validity, then you can make sure the sum of the values will
    fit into 32 bits. Determining the right answer for what constitutes a valid input
    will require examining the application-specific context—a great example of how
    domain knowledge is important to security. Once the range of values deemed valid
    is specified, it’s easy to determine the appropriate data type to use.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数输入，32位整数的完整范围似乎是一个显而易见的选择，因为它是标准数据类型。但考虑到未来，如果代码会在某个时刻将这些值相加，那么这将需要一个更大的整数，因此32位限制变得任意。或者，如果你能合理地为有效性设定一个下限，那么你可以确保这些值的总和能够适应32位。确定有效输入的正确答案将需要检查特定应用场景——这是领域知识对安全性至关重要的一个典型例子。一旦指定了有效值的范围，就很容易确定使用哪种适当的数据类型。
- en: What usually works well is to establish an explicit limit on inputs and then
    leave plenty of headroom in the implementation to be certain of correctly processing
    all valid inputs. By headroom, I mean if you are copying a text string into a
    4,096-byte buffer, use 4,000 bytes as the maximum valid length so you have a little
    room to spare. (In C, the additional null terminator overflowing a buffer by one
    byte is a classic mistake that’s easy to make.) Some programmers like a good challenge,
    but if you’re too generous (by allowing the widest possible range of input), then
    you are forcing the implementation to take on a bigger and harder job than is
    necessary, leading to greater code complexity and test burden. Even if your online
    shopping application can manage a cart with a billion items, attempting to process
    such an unrealistic transaction would be counterproductive. It would be kindest
    to reject the input (which may well be due to somebody’s cat sitting on their
    keyboard).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通常行之有效的做法是对输入建立一个明确的限制，并在实现中留出足够的冗余空间，以确保能够正确处理所有有效输入。所谓冗余空间，我的意思是如果你正在将一个文本字符串复制到一个4,096字节的缓冲区中，应该使用4,000字节作为最大有效长度，这样你就有一些额外的空间。（在C语言中，额外的空终止符溢出一个字节是一个经典的错误，容易犯。）一些程序员喜欢挑战，但如果你太宽松（允许尽可能广泛的输入范围），那么你就是在迫使实现承担一个比必要的更大更难的任务，从而导致代码复杂性和测试负担的增加。即使你的在线购物应用能够管理一个包含十亿个商品的购物车，处理这样一个不现实的交易也是适得其反的。最好的做法是拒绝输入（这可能是因为某人的猫坐在了键盘上）。
- en: Validation Criteria
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证标准
- en: Most input validation checks consist of several criteria, including ensuring
    the input doesn’t exceed a maximum size, that the data arrives in the proper format,
    and that it’s within a range of acceptable values.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数输入验证检查包括几个标准，确保输入不超过最大大小，数据以正确的格式到达，并且在可接受的值范围内。
- en: 'Checking the value’s size is a quick test primarily intended to avoid DoS threats
    to your code, which would cause your application to lumber or even crash under
    the weight of megabytes of untrusted input. The data format may be a sequence
    of digits for a number, strings consisting of certain allowed characters, or a
    more involved format, such as XML or JSON. Typically, it’s wise to check these
    in this order: limit size first, so you don’t waste time trying to deal with excessively
    massive inputs, then make sure the input is well formed before parsing it, and
    then check that the resulting value is within the acceptable range.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 检查值的大小是一个快速测试，主要用于避免DoS攻击，这种攻击会使你的应用在面对数兆的非信任输入时变得笨重甚至崩溃。数据格式可能是数字的数字序列，包含某些允许字符的字符串，或者是更复杂的格式，比如XML或JSON。通常，明智的做法是按以下顺序进行检查：首先限制大小，以避免浪费时间处理过于庞大的输入，然后确保输入格式正确，再检查结果值是否在可接受范围内。
- en: Deciding on a valid range of values can be the most subjective choice, but it’s
    important to have specific limits. How that range is defined will depend on the
    data type. For integers, the range will be no less than a minimum and no greater
    than a maximum value. For floating-point numbers, there may be limits on precision
    (decimal places) as well. For strings, it’s a maximum length, encoding, and usually
    an allowable format or syntax, as determined by a regular expression or the like.
    I recommend specifying maximum string lengths in characters rather than bytes,
    if only so that non-programmers have some hope of knowing what this constraint
    means.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 决定一个有效的值范围可能是最主观的选择，但设定具体的限制是非常重要的。这个范围的定义将取决于数据类型。对于整数，范围将不小于最小值且不大于最大值。对于浮点数，可能还有精度（小数位数）的限制。对于字符串，则是最大长度、编码，通常还包括通过正则表达式或类似方式确定的允许格式或语法。我建议以字符为单位指定最大字符串长度，而不是字节，这样非程序员至少能理解这个约束的含义。
- en: It’s helpful to think about inputs as valid for a purpose, rather than in the
    abstract. For example, a language translation system might accept input that is
    first validated to conform to the supported character set and maximum length common
    to all supported languages. If the next processing stage analyzes the text to
    determine what language it is, having chosen the language you can then further
    restrict the text to the appropriate character set.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入视为有目的的有效，而不是抽象的有效是非常有帮助的。例如，一个语言翻译系统可能会接受输入，首先验证它是否符合支持的字符集和所有支持语言的最大长度。如果下一阶段的处理分析文本以确定语言，那么一旦选择了语言，你就可以进一步限制文本到相应的字符集。
- en: Or consider validating an integer input that represents the quantity of items
    ordered on a purchase invoice. The maximum quantity any customer might ever actually
    order is not easy to determine, but it’s a good question to consider up front.
    If you have access to past data, a quick SQL query might return an interesting
    example worth knowing for reference. While one could argue that the maximum 32-bit
    integer value is the least limiting and hence best choice, in practice this rarely
    makes much sense. Who wouldn’t consider an order of 4,294,967,295 of any product
    as anything but some sort of mistake? Since non-programmers are never going to
    remember such strange numbers derived from binary, choosing a more user-friendly
    limit, such as 1,000,000, makes more sense. Should anyone ever legitimately run
    up against such a limit, it probably is worth knowing about, and should be easy
    to adjust. What’s more, the developer will learn about a real use case in the
    process that was previously unimagined.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 或者考虑验证一个整数输入，它表示在采购发票上订购的商品数量。任何客户可能订购的最大数量并不容易确定，但这是一个值得事先考虑的问题。如果你可以访问过去的数据，快速的SQL查询可能会返回一个有趣的例子，值得参考。虽然有人可能认为最大32位整数值是最不具限制性、因此是最好的选择，但实际上这通常没有太大意义。谁会认为订购4,294,967,295个产品不是什么错误呢？由于非程序员永远不会记住这种由二进制衍生出来的奇怪数字，选择一个更符合用户习惯的限制，比如1,000,000，显然更有意义。如果某人真的碰到这样的限制，应该容易调整，并且这个情况也值得了解。更重要的是，开发者在这个过程中会了解到一个此前没有预想到的真实使用案例。
- en: The primary purpose of input validation is to ensure that no invalid input gets
    past it. The simplest way to do this is to simply reject invalid inputs, as we
    have been doing implicitly in the discussion so far. A more forgiving alternative
    is to detect any invalid input and modify it into a valid form. Let’s look at
    these different approaches, and when to do which.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证的主要目的是确保无效输入无法通过验证。实现这一点的最简单方法就是直接拒绝无效输入，就像我们至今讨论中所隐含的那样。一个更宽容的替代方法是检测任何无效输入并将其修改为有效的格式。我们来看一下这些不同的方法，并探讨何时使用哪种方法。
- en: Rejecting Invalid Input
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拒绝无效输入
- en: 'Rejection of input that does not conform to specified rules is the simplest
    and arguably safest approach. Complete acceptance or rejection is cleanest and
    clearest, and usually easiest to get right. It’s like the common-sense advice
    for deciding if it’s safe to swim in the ocean: “When in doubt, don’t go out.”
    This can be as simple as refusing to process a web form if any field is improperly
    filled out, or as extreme as rejecting an entire batch of incoming data because
    of a single violation in some record.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝不符合规定规则的输入是最简单且可以说是最安全的方法。完全接受或拒绝是最干净、最清晰的，通常也最容易做对。这就像常识性的建议，决定是否安全游泳时：“如果有疑虑，就不要下水。”这可以简单到如果任何表单字段填写错误就拒绝处理网页表单，或极端一些，因某条记录的单个违规而拒绝整个数据批次。
- en: Whenever people are providing the input directly, such as in the case of a web
    form, it’s kindest to provide informative error messages, making it easy for them
    to correct their mistakes and resubmit. Users presumably submit invalid input
    either as a mistake or due to ignorance of the validation rules, neither of which
    is good. Calling a halt and asking the data source to provide valid input is the
    conservative way to do input validation, and it affords a good chance for regular
    providers to learn and adapt.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户直接提供输入时，比如在网页表单的情况下，最为友善的做法是提供有用的错误信息，方便他们更正错误并重新提交。用户提交无效输入通常是由于疏忽或不了解验证规则，这两种情况都不理想。停止处理并要求数据源提供有效输入是输入验证的保守方法，并且为常规提供者提供了一个学习和适应的机会。
- en: 'When input validation rejects bad input from people, best practices include:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入验证拒绝用户输入的不良内容时，最佳实践包括：
- en: Explain what constitutes a valid entry as part of the user interface, saving
    at least those who read it from having to guess and retry. (How am I supposed
    to know that area codes should be hyphenated rather than parenthesized?)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户界面中解释什么构成有效条目，至少可以避免那些阅读它的人猜测并重试。（我怎么知道区号应该用连字符而不是括号表示？）
- en: Flag multiple errors at once, so they can be corrected and resubmitted in one
    step.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次标记多个错误，以便可以在一步中进行更正并重新提交。
- en: When people are directly providing the input, keep the rules simple and clear.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户直接提供输入时，保持规则简单明了。
- en: Break up complicated forms into parts, with a separate form for each part, so
    people can see that they’re making progress.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将复杂的表单拆分成多个部分，每个部分对应一个单独的表单，这样用户可以看到他们在不断取得进展。
- en: When inputs come from other computers, not directly from people, more rigid
    input validation may be wise. The best way to implement these requirements is
    by writing documentation precisely describing the expected input format and any
    other constraints. In the case of input from professionally run systems, fully
    rejecting an entire batch of inputs, rather than attempting to partially process
    the valid subset of data, may make the most sense, as it indicates something is
    out of spec. This allows the error to be corrected and the full dataset submitted
    again without needing to sort out what was or wasn’t processed.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入来自其他计算机，而不是直接来自用户时，可能需要更加严格的输入验证。实现这些要求的最佳方式是编写文档，精确描述预期的输入格式和其他约束条件。在来自专业系统的输入情况下，完全拒绝整个输入批次，而不是尝试部分处理有效数据，可能更为合理，因为这表明某些数据不符合规范。这样可以在无需处理哪些数据被处理过、哪些没有的情况下，纠正错误并重新提交完整数据集。
- en: Correcting Invalid Input
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修正无效输入
- en: Safe and simple as it may be to insist on receiving completely valid inputs
    and rejecting everything else, by no means is this always the best way to go.
    For online merchants seeking customers at all costs, rejecting inputs during checkout
    could lead to more instances of the dreaded “abandoned cart,” and lost sales.
    For interactive user input, rigid rules can be frustrating, so if the software
    can help the user provide valid input, it should.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然坚持只接收完全有效的输入并拒绝所有其他输入是安全且简单的，但这并不总是最好的方法。对于在线商家来说，为了吸引客户，拒绝结账过程中的输入可能导致更多的“购物车遗弃”现象，从而失去销售机会。对于互动式用户输入来说，严格的规则可能会让用户感到沮丧，因此，如果软件能够帮助用户提供有效输入，那么它应该这么做。
- en: If you don’t want to stop the show for a minor error, then your input validation
    code may attempt to correct the invalid inputs, transforming them into valid values
    instead of rejecting them. Easy examples of this include truncating long strings
    to whatever the maximum length is, or removing extraneous leading or trailing
    spaces. Other examples of correcting invalid inputs are more complicated. Consider
    the common example of entering a mailing address in the exact form allowed by
    the postal service. This is a considerable challenge because of the precise spacing,
    spelling of street names, and form of abbreviation expected. Just about the only
    way to do this is to offer best-guess matches of similar addresses in the official
    format for the respondent to choose from.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想因为一个小错误而中断流程，那么你的输入验证代码可以尝试修正无效的输入，将其转换为有效值，而不是直接拒绝它们。简单的例子包括将过长的字符串截断到最大长度，或者去除多余的前后空格。其他修正无效输入的例子则更复杂。考虑常见的邮寄地址输入问题，要求精确符合邮政服务规定的格式。这是一个相当大的挑战，因为街道名称的拼写、间隔和缩写形式都非常严格。几乎唯一的解决方法是提供类似地址的最佳匹配项，供用户从中选择。
- en: The best cure for tricky validation requirements is to design inputs to be as
    simple as possible. For example, many of us have struggled when providing phone
    numbers that require area codes in parentheses, or dashes in certain positions.
    Instead, let phone numbers be strings of digits and avoid syntax rules in the
    first place.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 处理棘手的验证要求的最佳方法是将输入设计得尽可能简单。例如，许多人在输入电话号码时，会遇到需要括号的区号或某些位置的连字符的麻烦。与其要求这种格式，不如让电话号码仅由数字组成，避免使用语法规则。
- en: While adjustments may save time, any correction introduces the possibility that
    the correction will modify the input in an unintended fashion (from the user’s
    standpoint). Take the example of a telephone number form field where the input
    is expected to be 10 digits long. It should be safe to strip out common characters
    such as hyphens and accept the input if the result produces 10 valid digits, but
    if the input has too many digits, the user might have intended to provide an international
    number, or they might have made a typo. Either way, it probably isn’t safe to
    truncate it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然调整可能节省时间，但任何修正都引入了这样一个可能性：修正会以用户未预期的方式改变输入。以电话号表单字段为例，输入应该是10位数字。去除常见符号（如连字符）并接受结果为10位有效数字的输入似乎是安全的，但如果输入的数字过多，用户可能本来想提供一个国际号码，或者可能是输入错误。无论哪种情况，可能都不应该直接截断它。
- en: Proper input validation requires careful judgment, but it makes software systems
    much more reliable, and hence more secure. It reduces the problem space, eliminates
    needless tricky edge cases, improves testability, and results in the entire system
    being better defined and stable.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的输入验证需要谨慎判断，但它能使软件系统更加可靠，从而更安全。它减少了问题空间，消除了不必要的棘手边缘案例，提高了可测试性，并使整个系统更加明确定义和稳定。
- en: Character String Vulnerabilities
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串漏洞
- en: If you are a programmer working in 2006 and you don’t know the basics of characters,
    character sets, encodings, and Unicode, and I catch you, I’m going to punish you
    by making you peel onions for six months in a submarine.
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你是2006年工作的程序员，且不了解字符、字符集、编码和Unicode的基础知识，一旦我抓到你，我将惩罚你，让你在潜水艇里剥洋葱六个月。
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Joel Spolsky
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Joel Spolsky
- en: Nearly all software components process character strings, at least as command
    line parameters or when displaying output in legible form. Certain applications
    process character strings extensively; these include word processors, compilers,
    web servers and browsers, and many more. String processing is ubiquitous, so it’s
    important to be aware of the common security pitfalls involved. What follows is
    a sampling of the many issues to be aware of to avoid inadvertently creating vulnerabilities.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的软件组件都需要处理字符字符串，至少作为命令行参数或者在以可读形式显示输出时。某些应用程序广泛处理字符字符串；其中包括文字处理软件、编译器、网页服务器和浏览器等。字符串处理无处不在，因此，了解其中常见的安全陷阱至关重要。接下来将介绍一些问题，帮助你避免无意中创建安全漏洞。
- en: Length Issues
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长度问题
- en: Length is the first challenge because character strings are potentially of unbounded
    length. Extremely long strings invite buffer overflow when copied into fixed-length
    storage areas. Even if handled correctly, massive strings can result in performance
    problems if they consume excessive cycles or memory, potentially threatening availability.
    So, the first line of defense is to limit the length of incoming untrusted strings
    to reasonable sizes. At the risk of stating the obvious, don’t confuse character
    count with byte length when allocating buffers.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 长度是第一个挑战，因为字符字符串的长度可能是无限的。极长的字符串在被复制到固定长度的存储区域时可能导致缓冲区溢出。即使处理得当，大量字符串仍可能导致性能问题，因为它们可能消耗过多的周期或内存，潜在地威胁到可用性。因此，第一道防线是将传入的不可信字符串的长度限制在合理范围内。冒昧地提醒一下，在分配缓冲区时，不要将字符数与字节长度混淆。
- en: Unicode Issues
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unicode问题
- en: Modern software usually relies on Unicode, a rich character set that spans the
    world’s written languages, but the cost of this richness is a lot of hidden complexity
    that can be fertile ground for exploits. There are numerous character encodings
    to represent the world’s text as bytes, but most often software uses Unicode as
    a kind of *lingua franca*. The Unicode standard (version 13.0) is just over 1,000
    pages long, specifying over 140,000 characters, canonicalization algorithms, legacy
    character code standard compatibility, and bidirectional language support; it
    covers nearly all the world’s written languages, encoding more than one million
    code points.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件通常依赖Unicode，这是一个涵盖世界上所有书面语言的丰富字符集，但这种丰富性带来了大量的隐藏复杂性，可能成为攻击的温床。世界上有许多字符编码方式来将文本表示为字节，但大多数软件将Unicode作为一种*通用语言*。Unicode标准（13.0版本）长达1000多页，指定了超过14万个字符、规范化算法、与旧版字符编码标准的兼容性以及双向语言支持；它覆盖了几乎所有世界上的书面语言，编码了超过一百万个代码点。
- en: Unicode text has several different encodings that you need to be aware of. UTF-8
    is the most common, but there are also UTF-7, UTF-16, and UTF-32 encodings. Accurately
    translating between bytes and characters is important for security, lest the contents
    of the text inadvertently morph in the process. *Collation* (sorted order) depends
    on the encoding and the language, which can create unintended results if you aren’t
    aware of it. Some operations may work differently in the context of a different
    locale, such as when run on a computer configured for another country or language,
    so it’s important to test for correctness in all these cases. When there is no
    need to support different locales, consider specifying the locale explicitly rather
    than inheriting an arbitrary one from the system configuration.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 文本有几种不同的编码方式，您需要了解它们。UTF-8 是最常见的编码方式，但还有 UTF-7、UTF-16 和 UTF-32 编码。准确地在字节和字符之间进行转换对安全至关重要，以免在过程中不小心改变文本内容。*排序*（排序顺序）取决于编码和语言，如果您没有意识到这一点，可能会产生意外的结果。某些操作在不同的语言环境下可能表现不同，比如在为其他国家或语言配置的计算机上运行时，因此在所有这些情况下测试正确性非常重要。当不需要支持不同语言环境时，考虑明确指定语言环境，而不是从系统配置中继承任意语言环境。
- en: 'Because Unicode has many surprising features, the bottom line for security
    is to use a trustworthy library to handle character strings, rather than attempting
    to work on the bytes directly. You could say that in this regard, Unicode is analogous
    to cryptography in that it’s best to leave the heavy lifting to experts. If you
    don’t know what you are doing, some quirk of an obscure character or language
    you’ve never heard of might introduce a vulnerability. This section details some
    of the major issues that are well worth being aware of, but a comprehensive deep
    dive into the intricacies of Unicode would deserve a whole book. Detailed guidance
    about security considerations for developers who need to understand the finer
    points is available from the Unicode Consortium. *UTR#36: Unicode Security Considerations*
    is a good starting point.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Unicode 具有许多令人惊讶的特性，因此安全的底线是使用可信的库来处理字符字符串，而不是直接操作字节。可以说，在这方面，Unicode 类似于加密，因为最好将繁重的工作交给专家。如果你不知道自己在做什么，某些你从未听说过的字符或语言的怪异特性可能会引入安全漏洞。本节详细介绍了一些重要问题，值得了解，但要全面深入地研究
    Unicode 的复杂性，可能需要一本完整的书。有关开发人员需要了解更细微之处的安全考虑，Unicode 联盟提供了详细的指南。*UTR#36：Unicode
    安全考虑* 是一个很好的起点。
- en: Encodings and Glyphs
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编码与字符形状
- en: Unicode encodes characters, not *glyphs* (rendered visual forms of characters).
    This simple dictum has many repercussions, but perhaps the easiest way to explain
    it is that the capital letter I (U+0049) and the Roman numeral one (U+2160) are
    separate characters that may appear as identical glyphs (called *homomorphs*).
    Web URLs support international languages, and the use of look-alike characters
    is a well-known trick that attackers use to fool users. Famously, someone got
    a legitimate server certificate using a Cyrillic character (U+0420) that looks
    just like the P in PayPal, creating a perfect phishing setup.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 编码的是字符，而不是 *字符形状*（字符的渲染视觉形式）。这一简单的原则有许多影响，但或许最容易解释的是，大写字母 I (U+0049)
    和罗马数字一 (U+2160) 是不同的字符，虽然它们可能显示为相同的字符形状（称为 *同形字*）。网页 URL 支持多种语言，使用相似字符是攻击者用来欺骗用户的常见伎俩。著名的案例是，有人利用一个看起来和
    PayPal 中字母 P 一模一样的西里尔字母（U+0420）成功获得了合法的服务器证书，从而创建了一个完美的钓鱼攻击场景。
- en: Unicode includes combining characters that allow different representations for
    the same character. The Latin letter Ç (U+00C7) also has a two-character representation,
    consisting of a capital C (U+0043) followed by the “Combining Cedilla” character
    (U+0327). Both the one- and two-character forms display as the same glyph, and
    there is no semantic difference, so code should generally treat them as equivalent
    forms. The typical coding strategy would be to first normalize input strings to
    a canonical form, but unfortunately, Unicode has several kinds of normalization,
    so getting the details right requires further study.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 包括了组合字符，允许同一个字符有不同的表示方式。拉丁字母 Ç (U+00C7) 也有两字符表示形式，即大写字母 C (U+0043) 后跟“组合塞迪拉”（U+0327）字符。无论是一字符形式还是两字符形式，它们显示的字符形状相同，没有语义差异，因此代码通常应将它们视为等效形式。典型的编码策略是首先将输入字符串标准化为规范形式，但不幸的是，Unicode
    有多种规范化方式，因此正确处理这些细节需要进一步研究。
- en: Case Change
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大小写转换
- en: Converting strings to upper- or lowercase is a common way of canonicalizing
    text so that code treats `test`, `TEST`, `tEsT`, and so forth as identical. Yet
    it turns out that there are characters beyond the English alphabet that have surprising
    properties under case transformations.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串转换为大写或小写是规范化文本的常见方法，这样代码就能将`test`、`TEST`、`tEsT`等视为相同。然而，事实证明，除了英文字母之外，还有一些字符在大小写转换中表现出令人惊讶的特性。
- en: 'For example, the following strings are different yet nearly identical to casual
    observers: `''This ıs a test.''` and `''This is a test.''` (Note the missing dot
    over the second lowercase `i` in the first sentence.) Converted to uppercase,
    they both turn into the identical `''THIS IS A TEST.''` since the lowercase dotless
    `ı` (U+0131) and the familiar lowercase `i` (U+0069) both become uppercase `I`
    (U+0049). To see how this leads to a vulnerability, consider checking an input
    string for the presence of `<script>`: the code might convert to lowercase, scan
    for that substring, then convert to uppercase for output. The string `<scrıpt>`
    would slip through but appear as `<SCRIPT>` in the output, which could allow script
    injection on a web page—the very thing the code was trying to prevent.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下字符串虽然不同，但对一般观察者几乎是相同的：`'This ıs a test.'` 和 `'This is a test.'`（注意第一句话中第二个小写`i`缺少点）。将其转换为大写后，它们都会变成相同的`'THIS
    IS A TEST.'`，因为没有点的小写`ı`（U+0131）和常见的小写`i`（U+0069）都变成了大写的`I`（U+0049）。为了说明这如何导致漏洞，假设检查输入字符串是否包含`<script>`：代码可能会将其转换为小写，扫描该子字符串，然后再转换为大写进行输出。字符串`<scrıpt>`就会悄悄通过，但在输出中会显示为`<SCRIPT>`，这可能会允许在网页上进行脚本注入——这正是代码原本试图防止的事情。
- en: Injection Vulnerabilities
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入漏洞
- en: If you ever injected truth into politics you would have no politics.
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你把真理注入政治，你就没有政治了。
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Will Rogers
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —威尔·罗杰斯
- en: Unsolicited credit card offers comprise a major chunk of the countless tons
    of junk mail that clog up the postal system, but one clever recipient managed
    to turn the tables on the bank. Instead of tossing out a promotional offer to
    sign up for a card with terms he did not like, Dmitry Agarkov scanned the attached
    contract and carefully modified the text to specify terms extremely favorable
    to him, including 0 percent interest, unlimited credit, and a generous payment
    that he would receive should the bank cancel the card. He signed the modified
    contract and returned it to the bank, and soon received his new credit card. Dmitry
    enjoyed the generous terms of his uniquely advantageous contract for a while,
    but things got ugly when the bank finally caught on. After a protracted legal
    battle that included a favorable judgment upholding the validity of the modified
    contract, he eventually settled out of court.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 不请自来的信用卡广告占据了堆积如山的垃圾邮件的大部分，这些邮件堵塞了邮政系统，但有一个聪明的收件人设法让银行吃了亏。Dmitry Agarkov没有丢弃他不喜欢的条款的促销信用卡申请，而是扫描了附带的合同，并仔细修改了文本，指定了对他极为有利的条款，包括0%的利率、无限制的信用额度，以及如果银行取消信用卡他将收到一笔丰厚的款项。他签署了修改后的合同并将其返回给银行，很快收到了新的信用卡。Dmitry享受了一段时间独特有利合同中的优厚条款，但当银行最终察觉到这一点时，事情变得棘手。经过一场漫长的法律斗争，其中包括一项支持修改合同有效性的有利判决，他最终在庭外达成了和解。
- en: 'This is a real-world example of an *injection attack*: contracts are not the
    same as code, but they do compel the signatories to perform prescribed actions
    in much the same way as a program behaves. By altering the terms of the contract,
    Dmitry was able to force the bank to act against its will, almost as if he had
    modified the software that manages credit card accounts in his favor. Software
    is also susceptible to this sort of attack: untrusted inputs can fool it into
    doing unexpected things, and this is actually a fairly common vulnerability.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个现实世界的*注入攻击*示例：合同不同于代码，但它们确实要求签署人执行规定的动作，就像程序的行为一样。通过修改合同条款，Dmitry能够迫使银行违背其意愿行事，几乎就像他修改了管理信用卡账户的软件来使其有利于自己一样。软件也容易受到这种攻击：不受信任的输入可以诱使它执行意外的操作，而这实际上是一个相当常见的漏洞。
- en: There is a common software technique that works by constructing a string or
    data structure that encodes an operation to be performed, and then executing that
    to accomplish the specified task. (This is analogous to the bank writing a contract
    that defines how its credit card service operates, expecting the terms to be accepted
    unchanged.) When data from an untrusted source is involved, it may be able to
    influence what happens upon execution. If the attacker can change the intended
    effect of the operation, that influence may cross a trust boundary and get executed
    by software at a higher privilege. This is the idea of injection attacks in the
    abstract.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种常见的软件技术，通过构造一个字符串或数据结构，编码一个要执行的操作，然后执行它来完成指定的任务。（这类似于银行写合同定义其信用卡服务的操作方式，期望这些条款不被修改。）当涉及到来自不可信来源的数据时，它可能会影响执行时发生的情况。如果攻击者能改变操作的预期效果，这种影响可能会跨越信任边界，并由更高权限的软件执行。这就是抽象意义上的注入攻击概念。
- en: Before explaining the specifics of some common injection attacks, let’s consider
    a simple example of how the influence of untrusted data can be deceptive. According
    to an apocryphal story, just this kind of confusion was exploited successfully
    by an intramural softball team that craftily chose the name “No Game Scheduled.”
    Several times opposing teams saw this name on the schedule, assumed it meant that
    there was no game that day, and lost by forfeit as no-shows. This is an example
    of an injection attack because the team name is an input to the scheduling system,
    but “No Game Scheduled” was misinterpreted as being a message from the scheduling
    system.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释一些常见注入攻击的具体细节之前，让我们先考虑一个简单的例子，说明不可信数据的影响如何具有欺骗性。根据一个未经证实的故事，正是这种混淆被一支巧妙的校内垒球队成功利用，他们选择了名字“无比赛安排”（No
    Game Scheduled）。几次对方队伍在赛程上看到这个名字，误以为那天没有比赛，因此因未按时到场而被判弃权。这是一个注入攻击的例子，因为队伍名称是赛程系统的输入，但“无比赛安排”被误解为赛程系统的消息。
- en: 'The same injection attack principles apply to many different technologies (that
    is, forms of constructed strings that represent an operation), including but not
    limited to:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的注入攻击原理适用于许多不同的技术（即，表示操作的构造字符串形式），包括但不限于：
- en: SQL statements
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 语句
- en: Filepath names
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件路径名
- en: Regular expressions (as a DoS threat)
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式（作为 DoS 威胁）
- en: XML data (specifically, XXE declarations)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 数据（特别是 XXE 声明）
- en: Shell commands
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell 命令
- en: Interpreting strings as code (for example, JavaScript’s `eval` function)
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串解释为代码（例如，JavaScript 的 `eval` 函数）
- en: HTML and HTTP headers (covered in Chapter 11)
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML 和 HTTP 头（第 11 章介绍）
- en: The following sections explain the first four kinds of injection attacks in
    detail. Shell command and code injection work similarly to SQL injection, where
    sloppy string construction is exploitable by untrusted inputs. We’ll cover web
    injection attacks in the next chapter.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将详细解释前四种注入攻击。Shell 命令和代码注入的工作原理与 SQL 注入相似，都是由于不小心构造的字符串可以被不可信输入所利用。我们将在下一章介绍
    Web 注入攻击。
- en: SQL Injection
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL 注入
- en: 'The classic xkcd comic #327 ([Figure 10-1](#figure10-1)) portrays an audacious
    SQL injection attack, wherein parents give their child an unlikely and unpronounceable
    name that includes special characters. When entered into the local school district’s
    database, this name compromises the school’s records.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '经典的 xkcd 漫画 #327 （[图 10-1](#figure10-1)）描绘了一次大胆的 SQL 注入攻击，其中父母给他们的孩子起了一个不太可能且无法发音的名字，名字中包含特殊字符。当该名字被输入到当地学区的数据库时，这个名字破坏了学校的记录。'
- en: '![f10001](image_fi/501928c10/f10001.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![f10001](image_fi/501928c10/f10001.png)'
- en: 'Figure 10-1: Exploits of a Mom (courtesy of Randall Munroe, [xkcd.com/327](http://xkcd.com/327))'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：妈妈的利用（由 Randall Munroe 提供， [xkcd.com/327](http://xkcd.com/327)）
- en: 'To understand how this works, assume that the school registration system uses
    a SQL database and adds student records with a SQL statement of the form shown
    here:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一如何运作，假设学校注册系统使用 SQL 数据库，并通过如下 SQL 语句添加学生记录：
- en: '[PRE22]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this simplified example, that statement adds the name “Robert” to the database.
    (In practice, more columns than just `name` would appear in the two sets of parenthesized
    lists; those are omitted here for simplicity.)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简化的例子中，该语句将名字“Robert”添加到数据库中。（实际上，除了 `name` 之外，括号中的列表还会出现更多的列；为了简便起见，这里省略了这些列。）
- en: 'Now imagine a student with the ludicrous name of `Robert''); DROP TABLE students;--`.Consider
    the resultant SQL command, with the parts corresponding to the student’s name
    highlighted:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一个学生拥有一个荒谬的名字 `Robert'); DROP TABLE students;--`。考虑一下结果 SQL 命令，其中与学生姓名相关的部分已被高亮：
- en: '[PRE23]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'According to SQL command syntax rules, this string actually contains two statements:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 SQL 命令语法规则，这个字符串实际上包含了两个语句：
- en: '[PRE24]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first of these two SQL commands inserts a “Robert” record as intended. However,
    since the student’s name contains SQL syntax, it also injects a second, unintended
    command, `DROP TABLE`, that deletes the entire table. The double dashes denote
    a comment, so the SQL engine ignores the following text. This trick allows the
    exploit to work by consuming the trailing syntax (single quote and close parenthesis)
    in order to avoid a syntax error that would prevent execution.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 SQL 命令中的第一个按预期插入一个“Robert”记录。然而，由于学生的姓名包含 SQL 语法，它还注入了一个第二个、不希望出现的命令 `DROP
    TABLE`，这个命令会删除整个表格。双破折号表示注释，因此 SQL 引擎会忽略后面的文本。这个技巧通过消耗结尾的语法（单引号和闭括号）来避免语法错误，从而使得执行能够正常进行。
- en: Now let’s look at the code a little more closely to see what a SQL injection
    vulnerability looks like and how to prevent it. The hypothetical school registration
    system code works by forming SQL commands as text strings, such as in the first
    basic example we covered, and then executing them. The input data provides names
    and other information to fill out student records. In theory, we can even suppose
    that staff verified this input against official records to ensure their accuracy
    (assuming, with a large grain of salt, that legal names can include ASCII special
    characters).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们仔细看看代码，了解 SQL 注入漏洞的样子以及如何防止它。假设的学校注册系统代码通过将 SQL 命令作为文本字符串形成，如我们之前讲解的第一个基本示例，然后执行它们。输入数据提供了学生的姓名和其他信息，用于填写学生记录。从理论上讲，我们甚至可以假设工作人员已将这些输入与官方记录进行核对，以确保其准确性（假设，在大多数情况下，法律名字中可以包含
    ASCII 特殊字符）。
- en: 'The programmer’s fatal mistake was in writing a string concatenation statement
    such as the following without considering that an unusual name could “break out”
    of the single quotes:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员的致命错误是在写出类似下面的字符串连接语句时，没有考虑到一个不寻常的名字可能会“跳出”单引号：
- en: '**vulnerable code**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞代码**'
- en: '[PRE25]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Mitigating injection attacks is not hard but requires vigilance, lest you get
    sloppy and write code like this. Mixing untrusted inputs and command strings is
    the root cause of the vulnerability, because those inputs can break out of the
    quotes with unintended harmful consequences.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解注入攻击并不难，但需要保持警惕，以免变得马虎，写出像这样的代码。混合不受信任的输入和命令字符串是漏洞的根本原因，因为这些输入可能会“跳出”引号，带来意外的有害后果。
- en: Determining what strings constitute a valid name is an important requirements
    issue, but let’s just focus on the apostrophe character used in this SQL statement
    as a single quote. Since there are names (such as O’Brien) that contain the apostrophe,
    which is key to cracking open the SQL command syntax, the application cannot forbid
    this character as part of input validation. This name could be correctly written
    as the quoted string `'O''Brien'`, but there could be many other special characters
    requiring special treatment to effectively eliminate the vulnerability in a complete
    solution.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 确定哪些字符串构成有效的姓名是一个重要的需求问题，但让我们先集中关注 SQL 语句中作为单引号使用的撇号字符。由于一些名字（如 O’Brien）包含撇号，而撇号是打开
    SQL 命令语法的关键，应用程序不能在输入验证时禁止这个字符。这个名字可以正确地写作引用字符串 `'O''Brien'`，但可能还有许多其他特殊字符需要特殊处理，以有效消除完整解决方案中的漏洞。
- en: As a further defense, you should configure the SQL database such that the software
    registering students does not have the administrative privileges to delete any
    tables, which it does not need to do its job. (This is an example of the “Least
    Privilege” pattern from Chapter 4.)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的防御措施，您应该配置 SQL 数据库，使得注册学生的软件没有删除任何表格的管理权限，因为它不需要做这项工作。（这是第四章中的“最小权限”模式的一个示例。）
- en: Rather than “reinventing the wheel” with custom SQL sanitization code, the best
    practice is to use a library intended to construct SQL commands to handle these
    problems. If a trustworthy library isn’t available, create test cases to ensure
    that attempted injection attacks are either rejected or safely processed, and
    that everything works for students with names like O’Brien.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 与其“重新发明轮子”编写自定义SQL清理代码，最佳做法是使用专门构造SQL命令的库来处理这些问题。如果没有可靠的库可用，应该创建测试用例以确保尝试的注入攻击要么被拒绝，要么被安全处理，并确保像O’Brien这样的学生名字能够正常工作。
- en: 'Here are a few simple Python code snippets showing the wrong and then the right
    way to do this. First is the wrong way, using a mock-up of the Bobby Tables attack:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是几个简单的Python代码片段，展示错误和正确的处理方式。首先是错误的方式，使用Bobby Tables攻击的模拟：
- en: '**vulnerable code**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**脆弱的代码**'
- en: '[PRE26]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After creating a connection (`con`) to the SQL database, the code assigns the
    student’s name to the variable `student_name`. Next, the code constructs the SQL
    `INSERT` statement by plugging the string `student_name` into the `VALUES` list
    and assigning that to `sql_stmt`. Finally, that string is executed as a SQL script.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建与SQL数据库的连接（`con`）后，代码将学生的名字赋值给变量`student_name`。接下来，代码通过将字符串`student_name`插入`VALUES`列表中来构建SQL
    `INSERT`语句，并将其赋值给`sql_stmt`。最后，执行该字符串作为SQL脚本。
- en: 'The right way to handle this is to let the library insert parameters involving
    untrusted data, as shown in the following code snippet:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的正确方式是让库插入涉及不可信数据的参数，如以下代码片段所示：
- en: '**fixed code**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**修复后的代码**'
- en: '[PRE27]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this implementation, the `?` placeholder is filled in from the following
    tuple parameter consisting of the `student_name` string. Note that there are no
    quotes required within the `INSERT` statement string—that’s all handled for you.
    This syntax avoids the injection and safely enters Bobby’s strange name into the
    database.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，`?`占位符从以下包含`student_name`字符串的元组参数中填充。请注意，在`INSERT`语句字符串中不需要引号——这一切都为您处理了。这种语法避免了注入攻击，并安全地将Bobby的奇怪名字输入到数据库中。
- en: There is a detail in this example that deserves clarification. Making the original
    exploit work requires the `executescript` library function, because `execute`
    only accepts a single statement, which serves as a kind of a defense against this
    particular attack. However, it would be a mistake to think that all injection
    attacks involve additional commands, and that this limitation confers much protection.
    For example, suppose there’s another student with a different unpronounceable
    name at the school, `Robert', 'A+');--`. He and plain old Robert are both failing—but
    when his grades are recorded in another SQL table, his mark gets elevated to an
    A+. How so?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中有一个细节需要澄清。要使原始漏洞生效，需要使用`executescript`库函数，因为`execute`只接受单个语句，这对抗了这种特定攻击。然而，认为所有注入攻击都涉及额外的命令，并且这种限制提供了很大的保护，是一个错误的看法。例如，假设学校里有另一个名字难以发音的学生，`Robert',
    'A+');--`。他和普通的罗伯特都不及格——但是当他的成绩被记录到另一个SQL表中时，他的成绩被提升到了A+。这是怎么回事？
- en: 'When plain old Robert’s grades are submitted using the vulnerable code, the
    command enters the intended grade of an F as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用脆弱的代码提交普通的罗伯特的成绩时，命令会如以下所示输入预定的F成绩：
- en: '[PRE28]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But with the name `Robert'', ''A+'');--` that command becomes:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当名字为`Robert', 'A+');--`时，该命令变成了：
- en: '[PRE29]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: One final remark is in order about xkcd’s “Little Bobby Tables” example that
    attentive readers may have noticed. Setting aside the absurdity of the premise,
    it is a remarkable coincidence that Bobby’s parents were able to foresee the arbitrarily
    chosen specific name of the database table (`Students`). This is best explained
    by artistic license.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对于xkcd的“Little Bobby Tables”例子，有一个最后的备注，细心的读者可能已经注意到。撇开前提的荒谬性不谈，令人惊讶的是，Bobby的父母居然能够预见到数据库表格的特定名称（`Students`）是随意选择的。这最好的解释是艺术许可。
- en: Path Traversal
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径遍历
- en: 'Filepath traversals are a common vulnerability closely related to injection
    attacks. Instead of escaping from quotation marks, as we saw in the previous section’s
    examples, this attack escapes into parent directories to gain unexpected access
    to other parts of the filesystem. For example, to serve a collection of images,
    an implementation might collect image files in a directory named `/server/data/image_store`
    and then process requests for an image named *`X` by fetching image data from
    the path formed from the (untrusted) input name `X`: `/server/data/image_store/X`.*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 文件路径遍历是与注入攻击密切相关的常见漏洞。与我们在前一节例子中看到的从引号中逃逸的攻击不同，这种攻击是通过逃逸到父级目录，从而获得对文件系统其他部分的意外访问。例如，若要提供一组图像，一个实现可能会将图像文件存储在名为`/server/data/image_store`的目录中，然后通过获取由（不受信任的）输入名称`X`形成的路径`/server/data/image_store/X`来处理对名为*`X`的图像的请求。*
- en: '*The obvious attack would be requesting the name `../../secret/key`, which
    would return the file `/server/secret/key` that should have been private. Recall
    that *.* (dot) is a special name for the current directory and *..* (dot-dot)
    is the parent directory that allows traversal toward the filesystem root, as shown
    by this sequence of equivalent pathnames:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*显而易见的攻击方式是请求名称`../../secret/key`，这将返回本应是私有的文件`/server/secret/key`。回想一下，*.*（点）是当前目录的特殊名称，而*..*（点点）是父级目录，它允许穿越至文件系统根目录，正如这个等效路径序列所示：'
- en: '`/server/data/image_store/../../secret/key`'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/server/data/image_store/../../secret/key`'
- en: '`/server/data/../secret/key`'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/server/data/../secret/key`'
- en: '`/server/secret/key`'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/server/secret/key`'
- en: The best way to secure against this kind of attack is to limit the character
    set allowed in the input (`X` in our example). Often, input validation ensuring
    that the input is an alphanumeric string suffices to completely close the door.
    This works well because it excludes the troublesome file separator and parent
    directory forms needed to escape from the intended part of the filesystem.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种攻击的最佳方式是限制输入（例如我们例子中的`X`）中允许的字符集。通常，通过输入验证确保输入是一个字母数字字符串，足以完全关闭此漏洞。这个方法有效，因为它排除了需要突破目标文件系统部分的有问题的文件分隔符和父目录形式。
- en: However, sometimes that approach is too limiting. When it’s necessary to handle
    arbitrary filenames this simple method is too restrictive, so you have more work
    to do (and it can get complicated because filesystems are complicated). Furthermore,
    if your code will run across different platforms, you need to be aware of possible
    filesystem differences (for example, the *nix path separator is a slash, but on
    Microsoft Windows it’s a backslash).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时这种方法过于限制。当需要处理任意文件名时，这种简单方法过于严格，因此你需要做更多工作（而且可能会变得复杂，因为文件系统本身就是复杂的）。此外，如果你的代码需要跨平台运行，你还需要注意可能存在的文件系统差异（例如，*nix
    系统的路径分隔符是斜杠，而在微软 Windows 上是反斜杠）。
- en: 'Here is a simple example of a function that inspects input strings before using
    them as subpaths for accessing files in the directory that this Python code resides
    in (denoted by `__file__`). The idea is to provide access only to files in a certain
    directory or its subdirectories—but absolutely *not* to arbitrary files elsewhere.
    In the version shown here, the guard function `safe_path` checks the input for
    a leading slash (which goes to the filesystem root) or parent directory dot-dot
    and rejects inputs that contain these. To get this right you should work with
    paths using standard libraries, such as Python’s `os.path` suite of functionality,
    rather than ad hoc string manipulation. But this alone isn’t sufficient to ensure
    against breaking out of the intended directory:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，展示了一个函数在将输入字符串用作访问文件目录的子路径之前进行检查的过程，该目录是此 Python 代码所在的目录（由`__file__`表示）。其目的是仅提供对某个目录或其子目录中的文件的访问权限——但绝对*不能*访问其他地方的任意文件。在这里显示的版本中，守卫函数`safe_path`会检查输入是否包含前导斜杠（指向文件系统根目录）或父级目录的点点（`..`），并拒绝包含这些内容的输入。为了正确处理路径，你应该使用标准库中的路径处理功能，例如
    Python 的`os.path`，而不是临时的字符串操作。但仅凭这一点并不足以确保不会突破目标目录：
- en: '**vulnerable code**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**易受攻击的代码**'
- en: '[PRE30]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The remaining hole in this protection is that the path can name a valid directory,
    and then go up to the parent directory, and so on to break out. For example, since
    the current directory this sample code runs in is five levels below the root,
    the path `./../../../../../etc/passwd` (with five dot-dots) resolves to the `/etc/passwd`
    file.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个保护机制的漏洞在于路径可以指定一个有效的目录，然后向上跳转到父目录，一直到可以突破路径。例如，由于该示例代码运行的当前目录距离根目录有五级，路径`./../../../../../etc/passwd`（带有五个点点）会解析为`/etc/passwd`文件。
- en: 'We could improve the string-based tests for invalid paths by rejecting any
    path containing dot-dot, but such an approach can be risky, since it’s hard to
    be certain that we’ve anticipated all possible tricks and completely blocked them.
    Instead, there’s a straightforward solution that relies on the `os.path` library,
    rather than constructing path strings with your own code:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过拒绝包含“点点”路径的路径来改进基于字符串的无效路径测试，但这种方法可能存在风险，因为很难确保我们已经预见到所有可能的技巧并完全阻止它们。相反，有一个简单的解决方案，依赖于`os.path`库，而不是用自己的代码构建路径字符串：
- en: '**fixed code**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**修复后的代码**'
- en: '[PRE31]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This protection you can take to the bank, and here’s why. The base directory
    is a reliable path because there is no involvement of untrusted input: it’s fully
    derived from values completely under the programmer’s control. After joining with
    the input path string, that path gets normalized, which resolves any dot-dot parent
    references to produce an absolute path (`filepath`). Now we can check that the
    longest common subpath of these is the intended directory to which we want to
    restrict access.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这个保护机制是可以依赖的，原因如下。基础目录是一个可靠的路径，因为它没有涉及不受信任的输入：它完全由程序员控制的值构成。在与输入路径字符串连接后，该路径会被规范化，从而解决任何点点父目录引用，生成一个绝对路径（`filepath`）。现在我们可以检查这些路径的最长公共子路径是否为我们希望限制访问的目标目录。
- en: Regular Expressions
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Efficient, flexible, and easy to use, a *regex* (regular expression) offers
    a remarkably wide range of functionality and is perhaps the most versatile tool
    we have for parsing text strings. They’re generally faster (both to code and execute)
    than ad hoc code, and more reliable. Regex libraries compile state tables that
    an interpreter (a finite state machine or similar automaton) executes to match
    against a string.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 高效、灵活且易于使用，*正则表达式*（regex）提供了广泛的功能，可能是我们解析文本字符串时最通用的工具。它们通常比特定代码更快（既能编写又能执行），且更可靠。正则表达式库编译了状态表，解释器（有限状态机或类似自动机）执行这些表来匹配字符串。
- en: Even if your regex is correctly constructed it can cause security issues, as
    some regular expressions are prone to excessive execution times, and if attackers
    can trigger these they can cause a serious DoS. Specifically, execution time can
    balloon if the regex incurs *backtracking*—that is, when it scans forward a long
    way, then needs to go back and rescan over and over to find a match. The security
    danger generally results from allowing untrusted inputs to specify the regex;
    or, if the code already contains a backtracking regex, from an untrusted input
    that supplies a long worst-case string that maximizes the computational effort.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的正则表达式构造正确，它也可能引发安全问题，因为某些正则表达式容易导致执行时间过长，如果攻击者能够触发这些正则表达式，就可能引发严重的DoS攻击。具体来说，如果正则表达式发生*回溯*——即它向前扫描很远，然后需要反向重新扫描多次以找到匹配项——执行时间可能会膨胀。安全隐患通常源于允许不受信任的输入来指定正则表达式；或者，如果代码中已经包含了一个回溯的正则表达式，来自不受信任的输入的长字符串可能会最大化计算工作量，从而导致问题。
- en: 'A backtracking regex can look innocuous, as an example will demonstrate. The
    following Python code takes more than three seconds to run on my modest Raspberry
    Pi Model 4B. Your processor is likely much faster, but since each `D` added to
    the 24 in the example doubles the running time, it isn’t hard to lock up any processor
    with a slightly longer string:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一个回溯的正则表达式看起来可能无害，正如一个示例所展示的那样。以下的Python代码在我的普通Raspberry Pi Model 4B上运行超过三秒钟。你的处理器可能更快，但由于在示例中每增加一个`D`到24中就会使运行时间加倍，因此很容易用稍长的字符串使任何处理器陷入死锁：
- en: '[PRE32]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The danger of excessive runtime exists with any kind of parsing of untrusted
    inputs, in cases where backtracking or other nonlinear computations can blow up.
    In the next section you’ll see an XML entity example along these lines, and there
    are many more.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是哪种解析不受信任输入的方式，只要涉及回溯或其他非线性计算，都会存在过度运行时间的风险。在下一节中，你将看到一个与此相关的XML实体示例，还有更多类似的例子。
- en: The best way to mitigate these issues depends on the specific computation, but
    there are several general approaches to countering these attacks. Avoid letting
    untrusted inputs influence computations that have the potential to blow up. In
    the case of regular expressions, don’t let untrusted inputs define the regex,
    avoid backtracking if possible, and limit the length of the string that the regex
    matches against. Figure out what the worst-case computation could be, and then
    test it to ensure that it’s not excessively slow.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解这些问题的最佳方式取决于具体的计算，但有几种常见的方法可以抵御这些攻击。避免让不受信任的输入影响可能导致爆炸的计算。在正则表达式的情况下，不要让不受信任的输入定义正则表达式，尽量避免回溯，并限制正则表达式匹配的字符串长度。找出最坏的计算情况，然后进行测试，确保它不会过于缓慢。
- en: Dangers of XML
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML 的危险
- en: XML is one of the most popular ways to represent structured data, as it is powerful
    as well as human-readable. However, you should be aware that the power of XML
    can also be weaponized. There are two major ways that untrusted XML can cause
    harm using XML entities.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: XML 是表示结构化数据的最流行方式之一，因为它既强大又易于人类阅读。然而，你应该意识到 XML 的强大功能也可能被武器化。通过 XML 实体，有两种主要方式可以使不受信任的
    XML 造成危害。
- en: '*XML entity declarations* are a relatively obscure feature, and unfortunately,
    attackers have been creative in finding ways of abusing these. In the example
    that follows, a named entity `big1` is defined as a four-character string. Another
    named entity, `big2`, is defined as eight instances of `big1` (a total of 32 characters),
    and `big3` is eight more of those, and so on. By the time you get up to `big7`,
    you’re dealing with a megabyte of data, and it’s easy to go on up from there.
    This example concocts an 8-megabyte chunk of XML. As you can see, you would need
    to add only a few lines to go into the gigabytes:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*XML 实体声明* 是一个相对晦涩的特性，不幸的是，攻击者在利用这些特性方面非常有创意。在下面的示例中，一个命名实体 `big1` 被定义为一个四字符字符串。另一个命名实体
    `big2` 被定义为 `big1` 的八个实例（共计 32 个字符），`big3` 是另外八个，以此类推。等你到 `big7` 时，你正在处理一兆字节的数据，而且从那以后很容易继续增加。这个例子构造了一个
    8 兆字节的 XML。正如你所看到的，只需再添加几行，你就能进入到吉字节级别：'
- en: '[PRE33]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'More tricks are possible with external entity declarations. Consider the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 外部实体声明还可以使用更多技巧。考虑以下情况：
- en: '[PRE34]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This does exactly what you would think: reads the password file and makes its
    contents available wherever `&snoop;` appears in the XML henceforth. If the attacker
    can present this as XML and then see the result of the entity expansion, they
    can disclose the contents of any file they can name.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如你想象的那样：读取密码文件并使其内容在 XML 中出现 `&snoop;` 的位置随处可见。如果攻击者能够将其作为 XML 提供，并看到实体扩展的结果，他们就能公开任何他们可以命名的文件的内容。
- en: Your first line of defense against these sorts of problems will be keeping untrusted
    inputs out of any XML that your code processes. Some modern libraries check for
    just this kind of attack, but you should check to be sure if you need to rely
    on it. If you don’t need XML external entities, then protect against this sort
    of attack by excluding them from inputs, or by disabling the processing of such
    declarations.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这些问题的第一道防线是防止不受信任的输入进入你的代码处理的任何 XML。一些现代库会检查这种类型的攻击，但你应该检查是否需要依赖它。如果你不需要 XML
    外部实体，那么通过将它们从输入中排除或禁用此类声明的处理来防范这种攻击。
- en: Mitigating Injection Attacks
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓解注入攻击
- en: Just as various kinds of injection attacks rely on the common trick of using
    untrusted inputs to influence statements or commands that execute in the context
    of the application, mitigations for these issues also have common threads, though
    the details do vary. Input validation is always a good first line of defense,
    but depending on what allowable inputs may consist of, that alone is not necessarily
    enough.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 就像各种类型的注入攻击依赖于使用不受信任的输入来影响在应用程序上下文中执行的语句或命令一样，这些问题的缓解措施也有共同点，尽管具体细节有所不同。输入验证始终是一个很好的第一道防线，但根据可允许的输入内容，这单独并不一定足够。
- en: Avoid attempting to insert untrusted data into constructed strings for execution,
    for instance as commands. Modern libraries for SQL and other functionality susceptible
    to injection attacks should provide helper functions that allow you to pass in
    data separately from the command. These functions handle quoting, escaping, or
    whatever it takes to safely perform the intended operation for all inputs. I recommend
    checking for a specific note about security in the library’s documentation, as
    there do exist slipshod implementations that just slap strings together and will
    be liable to injection attacks under the facade of the API. When in doubt, a security
    test case (see Chapter 12) is a good way to sanity-check this.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 避免将不可信的数据插入到构造的字符串中执行，例如作为命令。现代的SQL和其他可能遭受注入攻击的功能库应该提供助手函数，允许你将数据与命令分开传递。这些函数会处理引用、转义，或执行其他必要操作，以安全地执行所有输入的预定操作。我建议在库的文档中查找关于安全性的具体说明，因为确实存在一些草率的实现方式，它们只是将字符串拼接在一起，在API的外表下容易受到注入攻击。如果有疑虑，安全测试用例（见第12章）是检查这一点的好方法。
- en: 'If you cannot, or will not, use a secure library—although, again, I caution
    against the slippery slope of “what could possibly go wrong?” thinking—first consider
    finding an alternative way to avoid the risk of injection. Instead of constructing
    a *nix `ls` command to enumerate the contents of a directory, use a system call.
    The reasoning behind this is clear: all that `readdir(3)` can possibly do is return
    directory entry information; by contrast, invoking a shell command could potentially
    do just about anything.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能，或者不愿意，使用安全库——尽管我再次提醒不要陷入“有什么可能出错呢？”的滑坡思维——首先考虑找到一种替代方法，以避免注入的风险。例如，不要构造*nix
    `ls`命令来列出目录内容，而是使用系统调用。这样做的理由很明确：`readdir(3)`唯一可能做的就是返回目录条目信息；相反，调用Shell命令则可能执行任何操作。
- en: Using the filesystem as a homemade datastore may be the quickest solution in
    some cases, but I can hardly recommend it as a secure approach. If you insist
    on doing it the risky way, don’t underestimate the work required to anticipate
    and then block all potential attacks in order to fully secure it. Input validation
    is your friend here; if you can constrain the string to a safe character set (for
    example, names consisting only of ASCII alphanumerics), then you may be all right.
    As an additional layer of defense, study the syntax of the command or statement
    you are forming and be sure to apply all the necessary quoting or escaping to
    ensure nothing goes wrong. It’s worth reading the applicable specifications carefully,
    as there may be obscure forms you are unaware of.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将文件系统用作自制数据存储可能是最快的解决方案，但我几乎不能推荐它作为一个安全的方法。如果你坚持走风险路线，请不要低估预测并阻止所有潜在攻击所需的工作，以确保完全安全。输入验证是你的朋友；如果你能将字符串限制为安全字符集（例如，只包含ASCII字母数字的名称），那么可能就没问题。作为额外的防御层，研究你正在构建的命令或语句的语法，并确保应用所有必要的引用或转义，以确保不会出错。仔细阅读适用的规范是值得的，因为可能会有你未曾注意到的隐晦形式。
- en: The good news is that the dangerous operations where injections become a risk
    are often easy to scan for in source code. Check that SQL commands are safely
    constructed using parameters, rather than as ad hoc strings. For shell command
    injections, watch for uses of `exec(3)` and its variants, and be sure to properly
    quote command arguments (Python provides `shlex.quote` for exactly this purpose).
    In JavaScript, review uses of `eval` and either safely restrict them or consider
    not using it when untrusted inputs could possibly influence the constructed expression.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，危险操作中，注入成为风险的地方通常在源代码中很容易扫描到。检查SQL命令是否使用参数安全地构造，而不是作为临时字符串构造。对于Shell命令注入，留意`exec(3)`及其变体的使用，并确保正确引用命令参数（Python提供了`shlex.quote`来专门处理这个问题）。在JavaScript中，检查`eval`的使用，或者安全地限制它，或者考虑在不受信任的输入可能影响构造的表达式时，根本不使用它。
- en: This chapter covered a number of injection attacks and related common vulnerabilities,
    but injection is a very flexible method that can appear in many guises. In the
    following chapter we will see it again (twice), in the context of web vulnerabilities.*  *#
    11
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了多种注入攻击及相关的常见漏洞，但注入是一种非常灵活的方法，可以以多种方式出现。在接下来的章节中，我们将再次看到它（两次），在网络漏洞的背景下。*  *#
    11
- en: Web Security
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全
- en: When the words appeared, everyone said they were a miracle. But nobody pointed
    out that the web itself is a miracle.
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当这些文字出现时，大家都说它们是一个奇迹。但没有人指出，整个网络本身才是一个奇迹。
- en: ''
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —E. B. White (from *Charlotte’s Web*)
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —E. B. White（摘自*夏洛的网*）
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The enormous success of the World Wide Web is in no small part due to the remarkable
    fact (today, completely taken for granted) that countless millions of people use
    it routinely without having the slightest understanding of how it works. This
    singular achievement for such a complex amalgam of technology is at once a blessing
    and a curse. Undoubtedly, the web’s ease of use has sustained widespread growth.
    On the flip side, securing a global network of independent digital services, used
    by countless millions of oblivious humans at the endpoints, is indeed an extremely
    difficult task. Security is perhaps the hardest part of this big hard problem.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网的巨大成功，很大程度上归功于一个显著的事实（如今，这已被视为理所当然）：无数人每天都在使用它，却对其工作原理一无所知。这个对于如此复杂的技术集合的单一成就，既是祝福也是诅咒。毫无疑问，网络的易用性促进了其广泛的增长。另一方面，保障一个由无数独立数字服务组成的全球网络，且这些服务被无数对其毫无了解的用户使用，确实是一个极其困难的任务。安全性或许是这个复杂问题中最难的一部分。
- en: One complicating factor that makes security especially challenging is that the
    early web was rather naively designed, without much consideration to security.
    As a result, the modern web is the product of a long evolution of standards, muddled
    by the competitive “browser wars” and backward compatibility restrictions. In
    short, the web is the most extreme instance of after-the-fact, “bolt-on security”
    in history—though what we have, well over a quarter of a century after its invention,
    is getting respectable.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 使安全性尤其具有挑战性的一个复杂因素是，早期的网络设计相当天真，几乎没有考虑到安全性。因此，现代网络是标准长期演变的产物，受竞争性的“浏览器大战”和向后兼容性的制约。简而言之，网络是历史上最极端的“事后补充安全性”案例——尽管如今，距其发明已有超过四分之一世纪，我们所拥有的网络安全性已经变得相当可敬。
- en: Yet while the modern web can be made secure, its tangled history means that
    it’s also quite fragile and filled with many “security and privacy infelicities,”
    as the authors of RFC 6265, a spec for web cookies, so colorfully put it. Software
    professionals need to understand all of this so as not to run afoul of these issues
    when building for the web. Tiny missteps easily create vulnerabilities. Given
    the “Wild West” nature of the internet, bad actors have the freedom to easily
    probe how websites work, as well as anonymously muck around looking for openings
    to attack.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管现代网络可以变得安全，但由于其错综复杂的历史，它仍然非常脆弱，并充满了许多“安全和隐私的不完美之处”，正如RFC 6265的作者——该规范为网页Cookies——所形容的那样。软件专业人员需要理解这一切，以免在为网络构建时遇到这些问题。哪怕是微小的失误也能轻易造成漏洞。鉴于互联网的“荒野西部”性质，恶意行为者可以自由地探查网站的工作方式，并匿名寻找攻击的切入点。
- en: This chapter focuses on the fundamentals of how the web security model evolved,
    and the right and wrong ways to use it. Vulnerabilities arise from the details,
    and there are so many things a secure website must get exactly right. We’ll cover
    all of the basics of web security, beginning with a plea to build on top of a
    secure framework that handles the intricacies for you. From there, we will see
    how secure communication (HTTPS), proper use of the HTTP protocol (including cookies),
    and the Same Origin Policy combine to keep websites safe. Finally, we’ll cover
    two of the major vulnerabilities specific to the web (XSS and CSRF) and discuss
    a number of other mitigations that, when combined, go a long way toward securing
    a modern web server. Nonetheless, this chapter is by no means a complete compendium
    of web security, the specifics of which are voluminous and evolve rapidly.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了网络安全模型如何演变的基础知识，以及正确和错误的使用方式。漏洞源于细节，安全网站必须精确处理许多方面。我们将涵盖网络安全的所有基础知识，从呼吁在安全框架上构建开始，框架为你处理复杂细节。接下来，我们将看到如何通过安全通信（HTTPS）、正确使用HTTP协议（包括Cookies）以及同源策略（Same
    Origin Policy）来保护网站安全。最后，我们将讨论两种特定于网页的主要漏洞（XSS和CSRF），并讨论其他一些缓解措施，结合起来将大大提高现代网站服务器的安全性。尽管如此，本章绝不是网络安全的完整汇编，网络安全的具体内容非常庞大，且快速发展。
- en: 'The goal here is to convey a broad-brush sense of the major common pitfalls
    so you will recognize and know how to deal with them. Web applications are also
    subject to the many other vulnerabilities covered elsewhere in this book: the
    focus in this chapter should not be interpreted to suggest that these are the
    only potential security concerns.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是传达对常见陷阱的整体理解，以便你能识别并知道如何应对它们。Web 应用程序也会受到本书其他地方提到的众多漏洞的影响：本章的重点不应被解读为这些是唯一的安全隐患。
- en: Build on a Framework
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于框架构建
- en: Use design as a framework to bring order out of chaos.
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用设计作为框架，将混乱中带出秩序。
- en: ''
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Nita Leland
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Nita Leland
- en: Thanks to modern web development tools, building a website has become nearly
    as easy as using one. My top recommendations for building a secure website are
    to rely on a high-quality framework, never override the safeguards it provides,
    and let competent experts handle all the messy details.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于现代 web 开发工具，构建一个网站已经几乎和使用网站一样容易了。我对构建安全网站的主要建议是：依赖一个高质量的框架，永远不要覆盖它提供的安全措施，让有能力的专家处理所有复杂的细节。
- en: A reliance on a solid framework should insulate you from the kinds of vulnerabilities
    covered in the following sections, but it’s still valuable to understand exactly
    what frameworks do and don’t do so you can use them effectively. It’s also critical
    that you choose a secure framework from the start, because your code will heavily
    depend on it, making it painful to switch later if it lets you down. How do you
    know if a web framework is really secure? It boils down to trust—both in the good
    intentions and the expertise of its makers.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖一个稳固的框架应该能使你免受接下来部分所提到的漏洞影响，但理解框架到底能做什么和不能做什么，依然非常重要，这样你才能有效使用它。选择一个安全的框架从一开始就至关重要，因为你的代码将会严重依赖它，如果它失败了，后期切换会非常痛苦。你如何知道一个
    web 框架是否真的安全？这归结为信任——对其开发者的良好意图和专业知识的信任。
- en: 'Web frameworks rise and fall in popularity and buzz almost as fast as Parisian
    fashion, and your choice will depend on many factors, so I won’t attempt to make
    recommendations. However, I can suggest general guidelines to consider for your
    own evaluation:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Web 框架的流行程度和热度变化几乎和巴黎时尚一样迅速，你的选择将取决于许多因素，因此我不会尝试做推荐。然而，我可以建议一些你在评估时可以考虑的通用指南：
- en: Choose a framework produced by a trustworthy organization or team that actively
    develops and maintains it in order to keep up with constantly changing web technologies
    and practices.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个由值得信赖的组织或团队开发并维护的框架，以便跟上不断变化的 web 技术和实践。
- en: Look for an explicit security declaration in the documentation. If you don’t
    find one, I would disqualify the framework.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文档中查找明确的安全声明。如果没有找到，我会排除该框架。
- en: 'Research past performance: the framework doesn’t need a perfect record, but
    slow responses or ongoing patterns of problems are red flags.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究过去的表现：框架不需要完美的记录，但响应缓慢或持续出现的问题模式是红旗。
- en: Build a small prototype and check the resulting HTML for proper escaping and
    quoting (using inputs like the ones in this chapter’s examples).
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个小型原型，并检查生成的 HTML 是否进行了适当的转义和引用（使用本章示例中的输入）。
- en: Build a simple test bed to experiment with basic XSS and CSRF attacks, as explained
    later in this chapter.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个简单的测试环境，进行基本的 XSS 和 CSRF 攻击实验，如本章后续所述。
- en: The Web Security Model
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 安全模型
- en: I’m kind of glad the web is sort of totally anarchic. That’s fine with me.
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我有点高兴网络在某种程度上是完全无政府状态的。这对我来说没问题。
- en: ''
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Roger Ebert
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Roger Ebert
- en: The web is a client/server technology, and understanding its security model
    requires considering both of those perspectives at once. Doing so gets interesting
    quickly, since the security interests of the two parties are often in contention,
    especially given the threat of potential attackers intruding via the internet.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一个客户端/服务器技术，理解它的安全模型需要同时考虑这两种视角。这样做会很快变得有趣，因为双方的安全利益常常相互冲突，尤其是考虑到潜在攻击者通过互联网入侵的威胁。
- en: Consider the typical online shopping website. The security principles at play
    here apply, more or less, to all kinds of web activity. In order to do business,
    the merchant and customers must trust each other to a certain degree, and in the
    vast majority of cases that does actually happen. Nonetheless, there are inevitably
    a few bad actors out there, so websites cannot fully trust every client, and vice
    versa. The following points highlight some of the nuances of the tentative mutual
    trust between the merchant and customer.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 以典型的在线购物网站为例，这里涉及的安全原则在某种程度上适用于所有种类的网络活动。为了开展业务，商家和客户必须在一定程度上相互信任，而在绝大多数情况下，确实会发生这种信任。然而，不可避免地有一些坏行为者，因此网站不能完全信任每个客户端，反之亦然。以下几点突出了商家和客户之间暂时互信的一些细微差别。
- en: 'Here are some the merchant’s basic requirements:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这是商家的基本要求：
- en: Other websites should be unable to interfere with my customer interactions.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他网站不应该干扰我的客户互动。
- en: I want to minimize my competitors’ ability to scrape my product and inventory
    details while helpfully informing legit customers.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我希望最大程度减少竞争对手抓取我的产品和库存细节的能力，同时能够为合法客户提供有用的信息。
- en: Customers shouldn’t be able to manipulate prices or order products not in stock.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户不应该能够操控价格或订购没有库存的产品。
- en: 'Here are some of the customer’s:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些客户的要求：
- en: I require assurance that the website I’m accessing is authentic.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要确保我访问的网站是可信的。
- en: I demand confidence that online payments are secure.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我要求确认在线支付是安全的。
- en: I expect the merchant to keep my shopping activities private.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我希望商家能够保持我的购物活动私密。
- en: Clearly, both parties must remain vigilant for the web to work well. That said,
    the customer expects many things from the merchant. Solving the hard problem of
    educating confused or gullible customers is out of scope here, if that’s even
    possible. Instead, in web security, we focus on securing a website from the merchant’s
    perspective. The web only works if servers do a good job of providing that security,
    making it possible for the honest end user to even have a chance at a secure web
    experience. Merchants must not only decide how much they can trust customers,
    but also intuit how much customers will likely trust them.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，双方必须保持警惕，才能让网络正常运作。话虽如此，客户对商家有许多期望。解决困惑或轻信客户的难题超出了本章节的范围，如果这件事甚至可能解决的话。相反，在
    web 安全领域，我们侧重于从商家的角度保障网站安全。网络只有在服务器能够提供良好的安全性时才能正常工作，这使得诚实的终端用户有机会获得安全的网络体验。商家不仅要决定他们可以信任客户的程度，还要直觉地判断客户可能会信任他们的程度。
- en: Another odd aspect of the web’s security model is the role of the client browser.
    Designing web services proves challenging because they need to interact with browsers
    that they have absolutely no control over. A malevolent client could easily use
    a modified browser capable of anything. Alternatively, a careless client could
    well be running an ancient browser full of security holes. Even if a web server
    attempts to limit the types of browsers clients use to certain versions, remember
    that the browser could easily misidentify itself to get around such restrictions.
    The saving grace is that honest clients want to use secure browsers and update
    them regularly, because it protects their own interests. Most importantly, so
    long as the server remains secure, one malicious client cannot interfere with
    the service that other clients receive.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全模型的另一个奇怪方面是客户端浏览器的角色。设计 web 服务是一项挑战，因为它们需要与完全无法控制的浏览器互动。一个恶意的客户端可以轻松使用经过修改的浏览器进行任何操作。或者，一个粗心的客户端可能正在运行一个充满安全漏洞的古老浏览器。即使
    web 服务器试图限制客户端使用的浏览器类型为某些版本，请记住，浏览器可以轻松伪装自己以绕过这些限制。值得庆幸的是，诚实的客户端希望使用安全的浏览器并定期更新它们，因为这能保护他们自己的利益。最重要的是，只要服务器保持安全，一个恶意的客户端就无法干扰其他客户端所收到的服务。
- en: Web servers overtrusting potentially untrustworthy client browsers is at the
    root of many web security vulnerabilities. I stress this point, at the risk of
    repetition, because it is so easily and often forgotten (as I will explain throughout
    the chapter).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: web 服务器对潜在不可信的客户端浏览器的过度信任是许多 web 安全漏洞的根源。我强调这一点，冒着重复的风险，因为这个问题是如此容易且常常被忽视（正如我将在本章中解释的那样）。
- en: The HTTP Protocol
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 协议
- en: Anyone who considers protocol unimportant has never dealt with a cat.
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何认为协议不重要的人，显然从未与猫打过交道。
- en: ''
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Robert A. Heinlein
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——罗伯特·A·海因莱因
- en: The HTTP protocol itself is at the heart of the web, so before we dig into web
    security, it’s worth briefly reviewing how it works. This hyper-simplified explanation
    serves as a conceptual framework for the rest of the security discussion, and
    we’ll focus on the parts where security enters the picture. For many, web browsing
    has become so commonplace in daily life that it’s worth stepping back and thinking
    through all the steps of the process—many of which we hardly notice, as modern
    processors and networks routinely provide blazing-fast responses.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议本身是web的核心，所以在我们深入讨论web安全之前，简要回顾一下它是如何工作的非常值得。这个高度简化的解释作为余下安全讨论的概念框架，我们将专注于安全如何介入的部分。对于许多人来说，网页浏览已经成为日常生活中如此普遍的活动，因此值得退后一步，仔细思考整个过程的所有步骤——许多步骤我们几乎没有注意到，因为现代处理器和网络通常能提供快速的响应。
- en: 'Web browsing always begins with a uniform resource locator (URL). The following
    example shows its parts:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 网页浏览总是从统一资源定位符（URL）开始。以下示例展示了它的组成部分：
- en: '[PRE35]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The *scheme* precedes the colon, and specifies the protocol (here, `http`)
    the browser must use to request the desired resource. IP-based protocols begin
    with `//` followed by the *hostname*, which for web pages is the domain name of
    the web server (in this case, `www.example.com`). The rest is all optional: the
    `/` followed by the *path*, the `?` followed by the *query*, and the `#` followed
    by the *fragment*. The path specifies which web page the browser is requesting.
    The query allows the web page content to be parameterized. For example, when searching
    for something on the web, the URL path for results might be `/search?q=something`.
    The fragment names a secondary resource within the page, often an anchor as the
    destination of a link. In summary, the URL specifies how and where to request
    the content, the specific page on the site, query parameters to customize the
    page, and a way to name a particular part of the page.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '*方案*在冒号之前，指定浏览器必须使用的协议（在这里是`http`）来请求所需的资源。基于IP的协议以`//`开始，后面跟着*主机名*，对于网页来说，就是web服务器的域名（在这个例子中是`www.example.com`）。其余部分都是可选的：`/`后跟*路径*，`?`后跟*查询*，以及`#`后跟*片段*。路径指定了浏览器请求的网页。查询允许网页内容参数化。例如，当在网页上搜索某个内容时，搜索结果的URL路径可能是`/search?q=something`。片段标识页面内的二级资源，通常是作为链接目标的锚点。总之，URL指定了如何以及在何处请求内容，网站上的具体页面，定制页面的查询参数，以及命名页面中特定部分的方法。'
- en: Your web browser has a lot of work to do in order to display the web page when
    you give it a URL. First, it queries the Domain Name System (DNS) for the IP address
    of the hostname in order to know where to send the request. The request contains
    the URL path and other parameters encoded as *request headers* (including any
    cookies, the user’s preferred language, and so on) sent to the web server host.
    The server sends back a response containing a status code and *response headers*
    (which may set cookies, and many other things), followed by the content body that
    consists of the HTML for the web page. For all embedded resources, such as scripts,
    images, and so forth, this same request/response process repeats until the content
    is fully loaded and displayed.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给浏览器提供一个URL时，浏览器需要做很多工作来显示网页。首先，它查询域名系统（DNS）以获取主机名的IP地址，从而知道该向何处发送请求。请求包含URL路径和其他作为*请求头*编码的参数（包括任何cookie、用户的首选语言等），这些都被发送到web服务器主机。服务器返回的响应包含一个状态码和*响应头*（这些可能设置cookie，以及其他许多内容），接着是包含网页HTML的内容体。对于所有嵌入的资源，如脚本、图片等，这个请求/响应过程会重复，直到内容完全加载并显示出来。
- en: Now let’s look at what web servers must do correctly in order to remain secure.
    One important detail not yet mentioned is that the request specifies the *HTTP
    verb*. For our purposes here, we will focus on just the two most common verbs.
    *GET* requests content from the server. By contrast, clients use the *POST* verb
    to send form submissions or file uploads. GET requests are explicitly not state-changing,
    whereas POST requests intend to change the state of the server. Respecting this
    semantic distinction is important, as will be seen when we cover CSRF attacks.
    For now, keep in mind that even though the client specifies the request verb to
    use, the server is the one that decides what to do with it. Additionally, by offering
    hyperlinks and forms on its pages, the server in effect guides the client to make
    subsequent GET or POST requests.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看网络服务器必须正确执行的操作，以保持安全。有一个重要的细节尚未提及，那就是请求指定了*HTTP动词*。在这里，我们将专注于两个最常见的动词。*GET*请求从服务器获取内容。相比之下，客户端使用*POST*动词来发送表单提交或文件上传。GET请求显式地不会改变状态，而POST请求则打算改变服务器的状态。尊重这种语义上的区分非常重要，正如我们在讨论CSRF攻击时将看到的那样。现在，记住尽管客户端指定了要使用的请求动词，但服务器才是决定如何处理该请求的主体。此外，通过在页面上提供超链接和表单，服务器实际上引导客户端进行后续的GET或POST请求。
- en: 'Sticklers will point out that one certainly can run a server that changes state
    in response to GET verb requests and, perversely, refuses to change state for
    form POST submissions. But if you strictly follow the standard rules, it is vastly
    easier to make your server secure. Think of it this way: yes, it is possible to
    climb over fences marked “Keep Out!” at a cliff and walk along the edge of the
    precipice without falling, but doing so needlessly puts your security in jeopardy.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 一些挑剔的人会指出，确实可以运行一个响应GET动词请求而改变状态的服务器，并且反常地拒绝通过表单POST提交来改变状态。但如果严格遵守标准规则，确保服务器安全将变得容易得多。可以这样想：是的，的确可以翻越标有“禁止通行！”的围栏，在悬崖边缘走路而不掉下来，但这样做无谓地把你的安全置于危险之中。
- en: A related security no-no is embedding sensitive data in a URL; instead, use
    form POST requests to send the data to the server. Otherwise, the `REFERER` header
    may disclose the URL of the web page that led to the request, exposing the data.
    For example, clicking a link on a web page with the URL `https://example.com?param=SECRET`
    navigates to the link destination using a GET request with a `REFERER` header
    containing the URL which includes `SECRET`, thereby leaking the secret data. In
    addition, logs or diagnostic messages risk disclosing the data contained in URLs.
    While servers can use the `Referrer-Policy` header to block this, they must depend
    on the client honoring it—hardly a perfect solution. (The `REFERER` header is
    indeed misspelled in the spec, so we’re stuck with that, but the policy name is
    correctly spelled.)
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的安全禁忌是将敏感数据嵌入URL中；相反，应该使用表单POST请求将数据发送到服务器。否则，`REFERER`头可能会泄露导致请求的网页URL，从而暴露数据。例如，点击一个网页上的链接，URL为`https://example.com?param=SECRET`，它会使用GET请求导航到目标链接，而`REFERER`头包含包含`SECRET`的URL，从而泄露了秘密数据。此外，日志或诊断信息也可能会泄露URL中包含的数据。虽然服务器可以使用`Referrer-Policy`头来阻止这种情况，但它们必须依赖客户端遵守这一点——这并不是一个完美的解决方案。（`REFERER`头在规范中确实拼写错误，所以我们只能这样接受，但政策名称拼写是正确的。）
- en: One easy mistake to make is including usernames in URLs. Even an opaque identifier,
    such as the hash of a username, leaks information, in that it potentially allows
    an eavesdropper to match two separately observed URLs and infer that they refer
    to the same user.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容易犯的错误是将用户名包含在URL中。即使是像用户名哈希这样的模糊标识符，也会泄露信息，因为它可能允许窃听者匹配两个分别观察到的URL，并推断它们指向同一个用户。
- en: Digital Certificates and HTTPS
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字证书与HTTPS
- en: If what is communicated is false, it can hardly be called communication.
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果传达的内容是错误的，那就很难称之为沟通。
- en: ''
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Benjamin Mays
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —本杰明·梅斯
- en: 'The first challenge for secure web browsing is reliably communicating with
    the correct server. To do this, you must know the correct URL and query a DNS
    service that provides the right IP address. If the network routes and transmits
    the request correctly, it should reach the intended server. That’s a lot of factors
    to get right, and a large attack surface: bad actors could interfere with the
    DNS lookup, the routing, or the data on the wire at any point along the route.
    Should the request be diverted to a malicious server, the user might never realize
    it; it isn’t hard to put up a look-alike website that would easily fool just about
    anyone.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 安全浏览网页的第一个挑战是可靠地与正确的服务器进行通信。为此，你必须知道正确的URL并查询提供正确IP地址的DNS服务。如果网络能够正确路由并传输请求，它应该能够到达目标服务器。要做到这一点，涉及到很多因素，而这些因素都可能成为攻击的切入点：恶意行为者可能会干扰DNS查找、路由过程或任何沿途的数据。假如请求被引导到一个恶意服务器，用户可能根本不会察觉；因为建立一个看似相同的网站并不难，几乎可以轻易欺骗任何人。
- en: The HTTPS protocol (also called *HTTP over TLS/SSL*) is tailor-made to mitigate
    these threats. HTTPS secures the web using many of the techniques covered in Chapter
    5. It provides a secure end-to-end tamper-proof encrypted channel, as well as
    assurance to the client that the intended server is really at the other end of
    that channel. Think of the secure channel as a tamper-evident pipeline for data
    that confirms the server’s identity. An eavesdropping attacker could possibly
    see encrypted data, but without the secret key, it’s indistinguishable from random
    bits. An attacker may be able to tamper with the data on an unprotected network,
    but if HTTPS is used, any tampering will always be detected. Attackers may be
    able to prevent communication, for example by physically cutting a cable, but
    you are assured that bogus data will never get through.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS协议（也称为*HTTP over TLS/SSL*）是专门为减轻这些威胁而量身定制的。HTTPS使用了第5章中介绍的许多技术来保障网络安全。它提供了一个安全的端到端防篡改加密通道，同时也向客户端保证，所请求的服务器确实存在于该通道的另一端。可以将这个安全通道看作是一个防篡改的管道，用于确认服务器的身份。窃听者可能看到加密的数据，但没有密钥，这些数据无法与随机比特区分开。攻击者也许能够在未保护的网络上篡改数据，但如果使用了HTTPS，任何篡改都会被检测到。攻击者可能会通过物理切断电缆来阻止通信，但你可以放心，虚假的数据永远无法传递通过。
- en: Nobody ever disputed the need for HTTPS to secure financial transactions on
    the web, but major sites delayed going fully HTTPS for far too long. (For example,
    Facebook only did so in 2013.) When first implemented, the protocol had subtle
    flaws, and the necessary computations were too heavyweight for the hardware at
    the time to justify widespread adoption. The good news is that, over time, developers
    fixed the bugs and optimized the protocol. Thanks to protocol optimizations, more
    efficient crypto algorithms, and faster processors, HTTPS is fast, robust, and
    rapidly approaching ubiquity today. It’s widely used to protect private data communications,
    but even for a website only serving public information, HTTPS is important to
    ensure authenticity and strong integrity. In other words, it provides assurance
    that the client is communicating with the bona fide server named in the request
    URL, and that data transmitted between them has not been snooped on or tampered
    with. Today, it’s difficult to think of any good reason *not* to configure a website
    to use HTTPS exclusively. That said, there are still plenty of non-secure HTTP
    websites out there. If you use them, keep in mind that the nice security properties
    of HTTPS do not apply, and take appropriate precautions.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人质疑为了确保网页上的金融交易安全，HTTPS是必需的，但许多大型网站推迟了全面启用HTTPS的时间。（例如，Facebook直到2013年才实施。）在最初的实现阶段，协议存在一些微妙的缺陷，而当时硬件的计算能力也不足以支持其广泛应用。好消息是，随着时间的推移，开发者修复了这些漏洞并优化了协议。得益于协议优化、更高效的加密算法和更快的处理器，今天的HTTPS既快速又稳健，正在迅速走向普及。它广泛用于保护私人数据通信，但即使是仅提供公共信息的网站，使用HTTPS也非常重要，以确保真实性和强大的完整性。换句话说，它可以确保客户端正在与请求URL中指定的真实服务器进行通信，并且在它们之间传输的数据没有被窃听或篡改。今天，很难想出任何合理的理由*不*配置网站只使用HTTPS。不过，仍然有许多不安全的HTTP网站。如果你使用这些网站，请记住，HTTPS的优良安全特性并不适用，并且要采取适当的预防措施。
- en: Understanding precisely what HTTPS does (and does not do) to secure the client/server
    interaction is critical in order to grasp its value, how it helps, and what it
    can and cannot change. In addition to assuring server authenticity and the confidentiality
    and integrity of web requests and response content, the secure channel protects
    the URL path (in the first line of the request headers—for example, `GET /path/page.html?query=secret#fragment`),
    preventing anyone who’s snooping from seeing what page of the website the client
    requested. (HTTPS can optionally also authenticate the client to the server.)
    However, the HTTPS traffic itself is still observable over the network, and because
    the IP addresses of the endpoints are unprotected, eavesdroppers can often deduce
    the identity of the server.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 准确理解 HTTPS 在保护客户端/服务器交互中所做的（以及未做的）工作，对于理解它的价值、它如何帮助以及它能做和不能做的事情至关重要。除了确保服务器的真实性和
    web 请求及响应内容的机密性与完整性外，安全通道还保护了 URL 路径（请求头的第一行——例如，`GET /path/page.html?query=secret#fragment`），防止任何窃听者看到客户端请求了网站的哪个页面。（HTTPS
    也可以选择验证客户端身份。）然而，HTTPS 流量本身仍然可以在网络上被观察到，并且由于端点的 IP 地址未被保护，窃听者通常可以推断出服务器的身份。
- en: '[Table 11-1](#table11-1) compares of the security attributes of HTTP and HTTPS,
    in terms of the capabilities of an attacker lurking between the two endpoints
    of a client/server communication.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 11-1](#table11-1) 比较了 HTTP 和 HTTPS 的安全属性，重点在于攻击者在客户端/服务器通信的两个端点之间潜伏时的能力。'
- en: 'Table 11-1: HTTP vs. HTTPS Security Attributes'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 11-1：HTTP 与 HTTPS 安全属性
- en: '| **Can an attacker. . .** | **HTTP** | **HTTPS** |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| **攻击者能否…** | **HTTP** | **HTTPS** |'
- en: '| --- | --- | --- |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| See web traffic between client/server endpoints? | Yes | Yes |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| 查看客户端/服务器端点之间的 web 流量？ | 是 | 是 |'
- en: '| Identify the IP addresses of both client and server? | Yes | Yes |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| 确定客户端和服务器的 IP 地址？ | 是 | 是 |'
- en: '| Deduce the web server’s identity? | Yes | Sometimes (see note below) |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| 推断 web 服务器的身份？ | 是 | 有时（见下文注释） |'
- en: '| See what page within the site is requested? | Yes | No (in encrypted headers)
    |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| 查看请求了网站中的哪一页面？ | 是 | 否（加密头信息中） |'
- en: '| See the web page content and the body of POSTs? | Yes | No (encrypted) |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| 查看网页内容和 POST 请求的主体？ | 是 | 否（加密） |'
- en: '| See the headers (including cookies) and URL (including the query portion)?
    | Yes | No |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| 查看头信息（包括 cookies）和 URL（包括查询部分）？ | 是 | 否 |'
- en: '| Tamper with the URL, headers, or content? | Yes | No |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| 修改 URL、头信息或内容？ | 是 | 否 |'
- en: As HTTPS and the technology environment matured, the last obstacle to broad
    adoption was the overhead of getting server certificates. Whereas larger companies
    could afford the fees that trusted certificate authorities charged and had staff
    to manage the renewal process, the owners of smaller websites balked at the extra
    cost and administrative overhead. By 2015, HTTPS was mature and most internet-connected
    hardware operated fast enough to handle it, and with awareness of the importance
    of web privacy growing quickly, the internet community was approaching a consensus
    that it needed to secure the majority of web traffic. The lack of free and simple
    server certificate availability proved the biggest remaining obstacle.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 HTTPS 和技术环境的成熟，广泛采用的最后障碍是获取服务器证书的开销。大型公司能够承担受信任证书颁发机构收取的费用，并有员工管理续期过程，而小型网站的所有者则对额外的成本和行政开销感到犹豫不决。到
    2015 年，HTTPS 已经成熟，大多数互联网连接硬件的处理速度足以应对 HTTPS，且随着人们对网络隐私重要性认识的迅速增长，互联网社区逐渐达成共识，认为需要保护大部分的
    web 流量。免费且简便的服务器证书的缺乏被证明是剩余的最大障碍。
- en: 'Thanks to strong promotion by the wonderful Electronic Frontier Foundation
    and sponsorship from a wide range of industry companies, Let’s Encrypt, a product
    of the nonprofit Internet Security Research Group, offers the world a free, automated,
    and open certificate authority. It provides Domain Validation (DV) certificates,
    free of charge, to any website owner. Here’s a simplified explanation of how Let’s
    Encrypt works. Keep in mind that the following process is automated in practice:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了电子前沿基金会的强力推广和各行业公司广泛的赞助，Let’s Encrypt——一个非营利性互联网安全研究小组的产品，提供了一个免费的、自动化的、开放的证书颁发机构。它为任何网站所有者提供免费的域名验证（DV）证书。以下是
    Let’s Encrypt 工作原理的简化说明。请记住，以下过程在实践中是自动化的：
- en: Identify yourself to Let’s Encrypt by generating a key pair and sending the
    public key.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过生成密钥对并发送公钥向 Let’s Encrypt 进行身份验证。
- en: Query Let’s Encrypt, asking what you need to do to prove that you control the
    domain.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询 Let’s Encrypt，询问你需要做什么来证明你控制该域名。
- en: Let’s Encrypt issues a challenge, such as provisioning a specified DNS record
    for the domain.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Let’s Encrypt 提供了一个挑战，例如为域名提供指定的 DNS 记录。
- en: You satisfy the challenge by creating the requested DNS record and ask Let’s
    Encrypt to verify what you did.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建请求的 DNS 记录并请求 Let’s Encrypt 验证你所做的操作，你可以完成挑战。
- en: Once verified, the private key belonging to the generated key pair is authorized
    for the domain by Let’s Encrypt.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦验证通过，生成的密钥对所属的私钥将被 Let’s Encrypt 授权用于该域名。
- en: Now you can request a new certificate by sending Let’s Encrypt a request signed
    by the authorized private key.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以通过向 Let’s Encrypt 发送一个由授权私钥签名的请求来申请新的证书。
- en: Let’s Encrypt issues 90-day DV certificates and provides a “certbot” to handle
    automatic renewals. With automatically renewable certificates available as a free
    service, secure web serving today has widely become a turnkey solution at no additional
    cost. HTTPS comprised more than 85 percent of web traffic in 2020, more than double
    the 40 percent level of 2016, when Let’s Encrypt launched.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: Let’s Encrypt 发放 90 天的 DV 证书，并提供一个“certbot”来处理自动续期。通过提供可自动续期的证书作为免费服务，今天的安全
    Web 服务已广泛成为一个即插即用的解决方案，无需额外费用。2020年，HTTPS 占 Web 流量的比例超过 85%，是2016年 Let’s Encrypt
    启动时的40%水平的两倍还多。
- en: A DV certificate is usually all you need to prove the identity of your website.
    DV certificates simply assert the authenticated web server’s domain name, and
    nothing more. That is, the `example.com` certificate is only ever issued to the
    owner of the `example.com` web server. By contrast, certificates offering higher
    levels of trust, such as Organization Validation (OV) and Extended Validation
    (EV) certificates, authenticate not only the identity of the website but also,
    to some extent, the owner’s identity and reputation. However, with the proliferation
    of free DV certificates, it’s increasingly unclear if the other kinds will remain
    viable. Few users care about such distinctions of trust, and the technical as
    well as legal nuances of OV and EV certificates are subtle. Their precise benefits
    are challenging to grasp unless (and even if) you are a lawyer.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: DV 证书通常就足以证明你网站的身份。DV 证书仅验证经过认证的 Web 服务器的域名，仅此而已。也就是说，`example.com` 证书仅会发放给
    `example.com` Web 服务器的所有者。相比之下，提供更高信任级别的证书，如组织验证（OV）和扩展验证（EV）证书，不仅验证网站的身份，还在某种程度上验证所有者的身份和声誉。然而，随着免费的
    DV 证书的普及，其他类型证书是否仍然具有可行性变得越来越不明确。很少有用户关心这些信任区分，而 OV 和 EV 证书的技术和法律细节很微妙。除非你是律师，否则它们的具体好处很难理解。
- en: Once you’ve set up your web server to use the HTTPS protocol with a certificate,
    you must make sure it *always* uses HTTPS. To ensure this, you must reject *downgrade
    attacks*, which attempt to force the communication to occur with weak encryption
    or without encryption. These attacks work in two ways. In the simplest case, the
    attacker tries changing an HTTPS request to HTTP (which can be snooped and tampered
    with), and a poorly configured web server might be tricked into complying. The
    other method exploits the HTTPS protocol options that let the two parties negotiate
    *cipher suites* for the encrypted channel. For example, the server may be able
    to “speak” one set of crypto “dialects,” and the client might “speak” a different
    set, so up front, they need to agree on one that’s in both their repertoires.
    This process opens the door to an attacker, who could trick both parties into
    selecting an insecure choice that compromises security.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了你的 web 服务器使用 HTTPS 协议并配置了证书，你必须确保它*始终*使用 HTTPS。为了确保这一点，你必须拒绝*降级攻击*，这种攻击试图迫使通信使用弱加密或不加密。这些攻击有两种方式。在最简单的情况下，攻击者试图将
    HTTPS 请求更改为 HTTP（这种方式可以被监听和篡改），而配置不当的 web 服务器可能会被欺骗而配合。另一种方法则利用 HTTPS 协议的选项，允许双方为加密通道协商*密码套件*。例如，服务器可能能够“讲”一套加密“方言”，而客户端则可能“讲”另一套，因此，双方需要事先就其中一种都能支持的选项达成一致。这个过程为攻击者提供了机会，攻击者可能会欺骗双方选择一个不安全的选项，从而破坏安全性。
- en: The best defense is to ensure your HTTPS configuration only operates with secure
    modern cryptographic algorithms. Judging exactly which cipher suites are secure
    is highly technical and best left to cryptographers. You must also strike a balance
    to avoid excluding, or degrading the experience of, older and less powerful clients.
    If you don’t have access to reliable expert advice, you can look at what major
    trustworthy websites do and follow that. Simply assuming that the default configuration
    will be secure forever is a recipe for failure.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的防御方法是确保你的HTTPS配置只使用安全的现代加密算法。判断哪些密码套件是安全的非常技术性，最好交给加密专家来做。你还必须在避免排除或降低旧版和性能较弱客户端的体验之间找到平衡。如果你没有可靠的专家建议，可以查看主要信任网站的做法并跟随它们。简单地认为默认配置永远是安全的，是失败的保障。
- en: Mitigate such attacks by always redirecting HTTP to HTTPS, as well as restricting
    web cookies to HTTPS only. Include the `Strict-Transport-Security` directive in
    your response HTTP headers so the browser knows that the website always uses HTTPS.
    For an HTTPS web page to be fully secure, it must be pure HTTPS. This means all
    content on the server should use HTTPS, as should all scripts, images, fonts,
    CSS, and other referenced resources. Failing to take all the necessary precautions
    weakens the security protection.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 通过始终将HTTP重定向到HTTPS，并将Web cookies限制为仅通过HTTPS访问，可以减少此类攻击的发生。同时，在响应的HTTP头部中包括`Strict-Transport-Security`指令，让浏览器知道该网站始终使用HTTPS。为了确保HTTPS网页的安全性，它必须完全使用HTTPS。这意味着服务器上的所有内容都应该使用HTTPS，包括所有的脚本、图片、字体、CSS以及其他引用的资源。如果不采取所有必要的预防措施，安全保护会大打折扣。
- en: The Same Origin Policy
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同源策略
- en: Doubt is the origin of wisdom.
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 疑问是智慧的源泉。
- en: ''
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Rene Descartes
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —勒内·笛卡尔
- en: Browsers isolate resources—typically windows or tabs—from different websites
    so they can’t interfere with each other. Known as the *Same Origin Policy (SOP)*,
    the rule allows interaction between resources only if their host domain names
    and port numbers match. The Same Origin Policy dates back to the early days of
    the web and became necessary with the advent of JavaScript. Web script interacts
    with web pages via the *Document Object Model* *(**DOM)*, a structured tree of
    objects that correspond to browser windows and their contents. It didn’t take
    a security expert to see that if any web page could use script to `window.open`
    any other site, and programmatically do anything it wanted with the content, countless
    problems would ensue. The first restrictions that were implemented—including fixes
    for a number of tricky ways people found of getting around them over the years—evolved
    into today’s Same Origin Policy.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器通过将不同网站的资源（通常是窗口或标签页）进行隔离，防止它们相互干扰。这一规则称为*同源策略（SOP）*，只有当资源的主机域名和端口号匹配时，才允许它们之间进行交互。*同源策略*起源于网络的早期，并且随着JavaScript的出现而变得必要。网页脚本通过*文档对象模型*（**DOM**）与网页进行交互，DOM是一个结构化的对象树，代表浏览器窗口及其内容。如果任何网页都可以通过脚本来`window.open`其他网站，并且能够任意操作内容，显然会带来无数问题。因此，最初实施的限制——包括对人们多年发现的规避方法的修复——最终演变成了今天的同源策略。
- en: The Same Origin Policy applies to script and cookies (with a few extra twists),
    which both can potentially leak data between independent websites. However, web
    pages can include images and other content, such as web ads, from other websites.
    This is safely allowed, since these cannot access the content of the window they
    appear in.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略适用于脚本和cookies（还有一些额外的变化），它们可能会在独立的网站之间泄露数据。然而，网页可以包含来自其他网站的图片和其他内容，比如网页广告。这是安全允许的，因为这些内容无法访问它们所在窗口的内容。
- en: Although the Same Origin Policy prevents script in pages from other websites
    from *reaching in*, web pages can always choose to *reach out* to different websites
    if they wish, pulling their content into the window. It’s quite common for a web
    page to include content from other websites, to display images, to load scripts
    or CSS, and so forth. Including any content from other websites is an important
    trust decision; however, because it makes the web page vulnerable to malicious
    content that may originate there.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管同源策略防止来自其他网站页面的脚本*访问*，但网页总是可以选择*访问*其他网站，如果它们愿意，可以将其内容加载到窗口中。网页包含来自其他网站的内容是很常见的，像是展示图片、加载脚本或CSS等。引入来自其他网站的任何内容都是一个重要的信任决策；然而，这样做使得网页容易受到可能来自这些网站的恶意内容攻击。
- en: Web Cookies
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web Cookies
- en: When the going gets tough, the tough make cookies.
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当事情变得艰难时，艰难的人会做出cookies。
- en: ''
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Erma Bombeck
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —厄尔玛·博姆贝克
- en: '*Cookies* are small data strings that the server asks the client to store on
    its behalf and then provide back to it with subsequent requests. This clever innovation
    allows developers to easily customize web pages for a particular client. The server
    response may set named cookies to some value. Then, until the cookies expire,
    the client browser sends the cookies applicable to a given page in subsequent
    requests. Since the client retains its own cookies, the server doesn’t necessarily
    need to identify the client to bind cookie values to it, so the mechanism is potentially
    privacy-preserving.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cookies* 是服务器要求客户端代表其存储的小数据字符串，并在随后的请求中将其返回给服务器。这一巧妙的创新使得开发人员能够轻松地为特定客户端定制网页。服务器响应可能会将命名的
    cookies 设置为某个值。然后，在 cookies 过期之前，客户端浏览器会在随后的请求中发送适用于给定页面的 cookies。由于客户端保留自己的 cookies，服务器不必识别客户端即可将
    cookie 值与其绑定，因此该机制有可能保护隐私。'
- en: 'Here’s a simple analogy: if I run a store and want to count how many times
    each customer visits, an easy way would be for me to give each customer a slip
    of paper with “1” on it and ask them to bring it back the next time they come.
    Then, each time a customer returns, I take their paper, add one to the number
    on it, and give it back. So long as customers comply, I won’t have to do any bookkeeping
    or even remember their names to keep accurate tallies.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的类比：如果我经营一家商店，并想计算每个顾客访问的次数，一种简单的方法是给每个顾客一张写着“1”的纸条，要求他们下次来时带回这张纸条。然后，每次顾客回来时，我拿到他们的纸条，数字加一，再还给他们。只要顾客遵守规则，我就不需要做任何账务处理，甚至不需要记住他们的名字，就能准确地统计。
- en: We use cookies for all manner of things on the web, tracking users being among
    the most controversial. Cookies often establish secure sessions so the server
    can reliably tell all of its clients apart. Generating a unique *session cookie*
    for each new client allows the server to identify the client from the cookie appearing
    in a request.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在网页上使用 cookies 来做各种事情，其中最具争议的是跟踪用户。Cookies 通常用于建立安全会话，这样服务器就能可靠地区分所有客户端。为每个新客户端生成一个独特的*会话
    cookie*，允许服务器通过请求中出现的 cookie 来识别客户端。
- en: While any client could tamper with its own cookies and pretend to be a different
    session, if the session cookie is properly designed, the client shouldn’t be able
    to forge a valid session cookie. Additionally, clients could send copies of their
    cookies to another party, but in doing so they would only harm their own privacy.
    That behavior doesn’t threaten innocent users and is tantamount to sharing one’s
    password.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管任何客户端都可以篡改自己的 cookies 并伪装成一个不同的会话，但如果会话 cookie 设计得当，客户端不应该能够伪造一个有效的会话 cookie。此外，客户端可能会将其
    cookie 的副本发送给其他方，但这样做只会损害自己的隐私。这种行为不会威胁到无辜的用户，相当于分享自己的密码。
- en: Consider a hypothetical online shopping website that stores the current contents
    of a customer’s shopping cart in cookies as a list of items and the total cost.
    There is nothing to stop a clever and unethical shopper from modifying the local
    cookie store. For instance, they could change the price of a valuable load of
    merchandise to a paltry sum. This does not mean that cookies are useless; cookies
    could be used to remember the customer’s preferences, favorite items, or other
    details, and tampering with these wouldn’t hurt the merchant. It just means that
    you should always use client storage on a “trust but verify” basis. Go ahead and
    store item costs and the cart total as cookies if that’s useful, but before accepting
    the transaction, be certain to validate the cost of each item on the server side,
    and reject any data that’s been tampered with. This example makes the problem
    plain as day. However, other forms of the same trust mistake are more subtle,
    and attackers frequently exploit this sort of vulnerability.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个在线购物网站，将顾客购物车的当前内容以商品列表和总金额的形式存储在 cookies 中。没有任何东西可以阻止一个聪明而不道德的购物者修改本地的
    cookie 存储。例如，他们可能会将一件贵重商品的价格更改为极低的金额。这并不意味着 cookies 是无用的；cookies 可以用来记住顾客的偏好、喜爱的商品或其他细节，篡改这些信息不会对商家造成损害。这只是意味着，你应该始终以“信任但验证”的原则使用客户端存储。如果这有用，可以将商品价格和购物车总额存储为
    cookies，但在接受交易之前，务必在服务器端验证每个商品的价格，拒绝任何被篡改的数据。这个例子使问题一目了然。然而，其他形式的同样信任错误更加微妙，攻击者经常利用这种漏洞。
- en: Now let’s look at this same example from the client’s perspective. When two
    people use an online shopping website and browse to the same `/mycart` URL, they
    each see different shopping carts because they have distinct sessions. Usually,
    unique cookies establish independent anonymous sessions, or, for logged-in users,
    identify specific accounts.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从客户端的角度看这个相同的例子。当两个人使用一个在线购物网站并浏览到相同的`/mycart`网址时，他们会看到不同的购物车，因为他们有不同的会话。通常，唯一的cookies会建立独立的匿名会话，或者对于已登录用户，识别特定账户。
- en: Servers set session cookies with a time of expiration, but since they cannot
    always rely on the client to respect that wish, they must also enforce limits
    on the validity of session cookies that need renewing. (From the user’s perspective,
    this expiration looks like being asked to log in again after a period of inactivity.)
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器设置带有过期时间的会话cookies，但由于它们不能总是依赖客户端来尊重这个愿望，它们还必须强制执行会话cookies的有效期限制，这些cookies需要更新。（从用户的角度来看，这种过期表现为在一段时间不活动后被要求重新登录。）
- en: Cookies are subject to the Same Origin Policy, with explicit provisions for
    sharing between subdomains. This means that cookies set by `example.com` are visible
    to the subdomains `cat.example.com` and `dog.example.com`, but cookies set on
    those respective subdomains are isolated from each other. Also, though subdomains
    can see cookies set by parent domains, they cannot modify them. By analogy, state
    governments rely on national-level credentials such as passports, but may not
    issue them. Within a domain, cookies may be further scoped by path as well (but
    this is not a strong security mechanism). [Table 11-2](#table11-2) illustrates
    these rules in detail. In addition, cookies may specify a `Domain` attribute for
    explicit control.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies受限于同源策略（SOP），并明确规定了在子域名之间共享的条款。这意味着由`example.com`设置的cookies对`cat.example.com`和`dog.example.com`的子域名可见，但在这些子域名上设置的cookies彼此隔离。此外，尽管子域名可以看到父域名设置的cookies，但不能修改它们。类比而言，州政府依赖国家级凭证（如护照），但无法签发这些凭证。在同一个域名内，cookies还可以通过路径进一步限定（但这不是一种强安全机制）。[表11-2](#table11-2)详细说明了这些规则。此外，cookies还可以指定`Domain`属性以便进行明确的控制。
- en: 'Table 11-2: Cookie Sharing Under Same Origin Policy (SOP) with Subdomains'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-2：同源策略（SOP）与子域名下的cookie共享
- en: '| **Can the web pages served by the hosts below. . .** | **. . .see the cookies
    set for these hosts?** |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| **下面的主机所提供的网页是否. . .** | **. . .能看到为这些主机设置的cookies吗？** |'
- en: '| --- | --- |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ***example.com*** | ***dog.example.com*** | ***cat.example.com*** | ***example.org***
    |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| ***example.com*** | ***dog.example.com*** | ***cat.example.com*** | ***example.org***
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ***example.com*** | Yes (same domain) | No (subdomain) | No (subdomain) |
    No (SOP) |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| ***example.com*** | 是（相同域名） | 否（子域名） | 否（子域名） | 否（SOP） |'
- en: '| ***dog.example.com*** | Yes (parent domain) | Yes (same domain) | No (sibling
    domain) | No (SOP) |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| ***dog.example.com*** | 是（父域名） | 是（相同域名） | 否（兄弟域名） | 否（SOP） |'
- en: '| ***cat.example.com*** | Yes (parent domain) | No (sibling domain) | Yes (same
    domain) | No (SOP) |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| ***cat.example.com*** | 是（父域名） | 否（兄弟域名） | 是（相同域名） | 否（SOP） |'
- en: '| ***example.org*** | No (SOP) | No (SOP) | No (SOP) | Yes (same domain) |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| ***example.org*** | 否（SOP） | 否（SOP） | 否（SOP） | 是（相同域名） |'
- en: Script nominally has access to cookies via the DOM, but this convenience would
    give malicious script that manages to run in a web page an opening to steal the
    cookies, so it’s best to block script access by specifying the `httponly` cookie
    attribute. HTTPS websites should also apply the `secure` attribute to direct the
    client to only send cookies over secure channels. Unfortunately, due to legacy
    constraints too involved to cover here, integrity and availability issues remain
    even when you use both of these attributes (see RFC 6265 for the gory details).
    I mention this not only as a caveat, but also as a great example of a repeated
    pattern in web security; the tension between backward compatibility and modern
    secure usage results in compromise solutions that illustrate why, if security
    isn’t baked in from the start, it often proves to be elusive.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本名义上可以通过DOM访问cookies，但这个便利性会给恶意脚本提供一个可趁之机，若它能在网页中运行，则可能窃取cookies，因此最好通过指定`httponly`cookie属性来阻止脚本访问。HTTPS网站还应应用`secure`属性，指示客户端仅通过安全通道发送cookies。不幸的是，由于涉及的遗留限制过多，无法在此详细讨论，即使使用这两个属性，也仍然会出现完整性和可用性问题（有关详细信息，请参见RFC
    6265）。我提到这个不仅仅是作为警告，还作为一个网络安全中反复出现的模式的经典示例；向后兼容性与现代安全使用之间的紧张关系导致了妥协解决方案，这说明了如果从一开始就没有内建安全性，它往往会变得难以实现。
- en: HTML5 has added numerous extensions to the security model. A prime example is
    Cross-Origin Resource Sharing (CORS), which allows selective loosening of Same
    Origin Policy restrictions to enable data access by other trusted websites. Browsers
    additionally provide the Web Storage API, a more modern client-side storage capability
    for web apps that’s also subject to the Same Origin Policy. These newer features
    are much better designed from a security standpoint, but still are not a complete
    substitute for cookies.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5为安全模型添加了许多扩展。一个典型的例子是跨源资源共享（CORS），它允许有选择地放宽同源策略的限制，以便其他受信任的网站可以访问数据。浏览器还提供了Web
    Storage API，这是一种更现代的客户端存储能力，供Web应用使用，同样也受到同源策略的限制。这些新特性在安全方面设计得更好，但仍不能完全替代Cookies。
- en: Common Web Vulnerabilities
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的网页漏洞
- en: Websites should look good from the inside and out.
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网站应该在内外看起来都很好。
- en: ''
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Paul Cookson
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —保罗·库克森
- en: Now that we’ve surveyed the major security highlights of website construction
    and use, it’s time to talk about specific vulnerabilities that commonly arise.
    Web servers are liable to all kinds of security vulnerabilities, including many
    of those covered elsewhere in this book, but in this chapter we’ll focus on security
    issues specific to the web. The preceding sections explained the web security
    model, including a lot of potential ways to avoid weakening security and useful
    features that help better secure your web presence. Even assuming you did all
    of that right, this section covers still more ways web servers can get it wrong
    and be vulnerable.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了网站建设和使用中的主要安全亮点，是时候谈论一些常见的特定漏洞了。Web服务器容易受到各种安全漏洞的威胁，包括本书其他部分讨论的许多漏洞，但在本章中，我们将重点关注与Web相关的安全问题。前面的章节解释了Web安全模型，包括许多潜在的避免削弱安全性的方法以及有助于更好保护你的网站的实用功能。即使假设你做对了所有这些事情，本节将继续介绍Web服务器可能出现的其他错误以及它们的漏洞。
- en: 'The first category of web vulnerability, and likely the most common, is cross-site
    scripting (XSS). The other vulnerability we’ll cover here is probably my favorite
    due to its subtlety: cross-site request forgery (CSRF).'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类别的网页漏洞，也可能是最常见的，就是跨站脚本攻击（XSS）。我们将在这里讨论的另一个漏洞，可能是我最喜欢的，因为它的隐蔽性：跨站请求伪造（CSRF）。
- en: Cross-Site Scripting
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: I don’t let myself “surf” on the Web, or I would probably drown.
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我不允许自己在网上“冲浪”，否则我可能会淹死。
- en: ''
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Aubrey Plaza
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —奥布里·普拉扎
- en: The isolation that the Same Origin Policy provides is fundamental to building
    secure websites, but this protection breaks easily if we don’t take necessary
    precautions. *Cross-site scripting (**XSS)* is a web-specific injection attack
    where malicious input alters the behavior of a website, typically resulting in
    running unauthorized script.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略提供的隔离对于构建安全网站至关重要，但如果我们没有采取必要的预防措施，这种保护很容易被突破。*跨站脚本攻击（**XSS**）*是一种特定于网页的注入攻击，恶意输入会改变网站的行为，通常导致未经授权的脚本被执行。
- en: Let’s consider a simple example to see how this works and why it’s essential
    to protect against. The attack usually begins with the innocent user already logged
    in to a trusted website. The user then opens another window or tab and goes surfing,
    or perhaps unwisely clicks a link in an email, browsing to an attacking site.
    The attacker typically aims to commandeer the user’s authenticated state with
    the target site. They can do so even without a tab open to the victim site, so
    long as the cookies are present (which is why it’s good practice to log out of
    your banking website when you’re done). Let’s look at what an XSS vulnerability
    in a victim site looks like, exactly how to exploit it, and finally, how to fix
    it.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子，看看它是如何工作的，以及为什么必须保护自己免受攻击。攻击通常始于无辜的用户已经登录到一个可信网站。然后用户打开另一个窗口或标签页开始浏览，或者可能不小心点击了一封电子邮件中的链接，浏览到了一个攻击网站。攻击者通常旨在劫持用户在目标网站上的认证状态。他们甚至可以在没有打开受害网站标签页的情况下做到这一点，只要Cookies仍然存在（这就是为什么完成网上银行操作后最好登出）。让我们看看受害网站中的XSS漏洞是什么样子的，如何利用它，最后如何修复它。
- en: 'Suppose that for some reason a certain page of the victim website (`www.example.com`)
    wants to render a line of text in several different colors. Instead of building
    separate pages, all identical except for the color of that line, the developer
    chooses to specify the desired color in the URL query parameter. For example,
    the URL for the version of the web page with a line of green text would be:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 假设出于某种原因，受害网站的某一页面（`www.example.com`）希望以几种不同的颜色渲染一行文本。开发者选择在URL查询参数中指定所需的颜色，而不是构建多个仅在该行颜色上有所不同的相同页面。例如，具有绿色文本一行的网页版本的URL可能是：
- en: '[PRE36]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The server then inserts the highlighted query parameter into the following
    HTML fragment:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 然后服务器将高亮的查询参数插入到以下HTML片段中：
- en: '[PRE37]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This works fine if used properly, which is exactly why these flaws are easily
    overlooked. Seeing the root of the problem requires looking at the server-side
    Python code responsible for handling this task (as well as some devious thinking):'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确使用，这段代码是完全没问题的，这也是这些漏洞容易被忽视的原因。要看到问题的根本，必须查看负责处理此任务的服务器端Python代码（以及一些巧妙的思维）：
- en: '**vulnerable code**'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**脆弱的代码**'
- en: '[PRE38]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first line parses the URL query string (the part after the question mark).
    The next line extracts the `color` parameter, or defaults to black if it’s unspecified.
    The last line constructs the HTML fragment that displays text with the corresponding
    font color, using inline styling for the heading level 1 tag (`<h1>`). The variable
    `h` then forms part of the HTML response that comprises the web page.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行解析URL查询字符串（问号后的部分）。下一行提取`color`参数，若未指定，则默认为黑色。最后一行构建HTML片段，显示带有相应字体颜色的文本，使用内联样式来处理一级标题标签（`<h1>`）。然后，变量`h`构成了HTML响应的一部分，包含在网页中。
- en: You can find the XSS vulnerability in that last line. There, the programmer
    has created a path from the contents of the URL (which, on the internet, anyone
    can send to the server) that leads directly into the HTML content served to the
    client. This is the familiar pattern of injection attacks from Chapter 10, and
    constitutes an unprotected trust boundary crossing, because the parameter input
    string is now inside the web page HTML contents. This condition alone is enough
    to raise red flags, but to see the full dimensions of this XSS vulnerability,
    let’s try exploiting it.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在最后一行找到XSS漏洞。这里，程序员创建了一个路径，从URL的内容（在互联网上，任何人都可以发送到服务器）直接进入客户端的HTML内容。这是第10章中熟悉的注入攻击模式，构成了未受保护的信任边界跨越，因为参数输入字符串现在已被嵌入到网页HTML内容中。单单这一点就足以引起警觉，但要看清楚这个XSS漏洞的全部维度，我们需要尝试利用它。
- en: 'An attack requires a little imagination. Refer back to the `<h1>` HTML tag
    and consider other possible substitutions for the highlighted color name. Think
    outside the box, or in this case, outside the double quoted string `style="color:green"`.
    Or can you break out of the `<h1>` tag entirely? Here’s a URL that illustrates
    what I mean by “break out”:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击需要一点想象力。回顾一下`<h1>` HTML标签，并考虑其他可能的替代高亮的颜色名称。跳出框框思考，或者在这个例子中，跳出双引号字符串`style="color:green"`。或者你能完全突破`<h1>`标签吗？这里有一个网址可以说明我所说的“突破”：
- en: '[PRE39]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All of that highlighted stuff gets dutifully inserted into the `<h1>` HTML tag
    as before, producing a vastly different result.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些高亮的内容都会像之前一样，按要求插入到`<h1>` HTML标签中，产生完全不同的结果。
- en: 'In the actual HTML, this code would appear as a single line, but for legibility
    I’ve indented it here to show how it’s parsed:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的HTML中，这段代码会呈现为一行，但为了可读性，我在这里进行了缩进，显示它是如何解析的：
- en: '[PRE40]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The new `<h1>` tag is syntactic, specifying an orange color. However, note
    that the attacker’s URL parameter value supplied the closing angle bracket. This
    wasn’t done just to be nice: the attacker needed to close the `<h1>` tag in order
    to make a well-formed `<SCRIPT>` tag and inject it into the HTML, ensuring that
    the script would run. In this case, the script opens an alert dialog—a harmless
    but unmistakable proof of the exploit. After the closing `</SCRIPT>` tag, the
    rest of the injection is just filler to obscure that tampering occurred. The new
    `<span>` tag has an `id` attribute merely so the following double quote and closing
    angle bracket will appear as part of the `<span>` tag. Browsers routinely supply
    closing `</span>` tags if missing, so the exploited page is well-formed HTML,
    making the modifications invisible to the user (unless they inspect the HTML source).'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `<h1>` 标签是语法上的，指定了橙色。然而，请注意，攻击者提供的 URL 参数值供应了闭合的尖括号。这并非仅仅是为了好看：攻击者需要关闭 `<h1>`
    标签，以便创建一个格式正确的 `<SCRIPT>` 标签并将其注入到 HTML 中，从而确保脚本能够执行。在这种情况下，脚本会弹出一个警告对话框——这是一个无害但明显的漏洞证明。在闭合的
    `</SCRIPT>` 标签之后，剩余的注入内容仅仅是填充物，用来掩盖篡改行为。新的 `<span>` 标签具有 `id` 属性，仅仅是为了让后续的双引号和闭合尖括号作为
    `<span>` 标签的一部分。浏览器通常会在缺失时自动提供闭合的 `</span>` 标签，因此被利用的页面依然是格式正确的 HTML，这使得修改对用户来说是不可见的（除非他们检查
    HTML 源代码）。
- en: To actually attack victims remotely, the attacker has more work to do in order
    to get people to browse to the malicious URL. Attacks like this generally only
    work when the user is already authenticated to the target website—that is, when
    valid login session cookies exist. Otherwise, the attacker might as well type
    the URL into their own browser. What they’re after is your website session, which
    shows your bank balance or your private documents. A serious attacker-defined
    script would immediately load additional script, and then proceed to exfiltrate
    data, or make unauthorized transactions in the user’s context.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 为了远程攻击受害者，攻击者还需要做更多工作，以便让受害者访问恶意 URL。像这样的攻击通常只有在用户已经登录目标网站时才有效——也就是说，只有在存在有效的登录会话
    cookie 时。否则，攻击者可以直接将 URL 输入自己的浏览器。攻击者真正想要的是你的网站会话，这可能显示你的银行余额或私人文件。一旦攻击者定义了一个恶意脚本，它将立即加载额外的脚本，并继续窃取数据或在用户的上下文中进行未授权的交易。
- en: XSS vulnerabilities aren’t hard for attackers to discover, since they can easily
    view a web page’s content to see the inner workings of the HTML. (To be precise,
    they can’t see code on the server, but by trying URLs and observing the resulting
    web pages, it isn’t hard to make useful inferences about how it works.) Once they
    notice an injection from the URL into a web page, they can then perform a quick
    test, like the example shown here, to check if the server is vulnerable to XSS.
    Moreover, once they have confirmed that HTML metacharacters, such as angle brackets
    and quotes, flow through from the URL query parameter (or perhaps another attack
    surface) into the resultant web page, they can view the page’s source code and
    tweak their attempts until they hit the jackpot.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 漏洞对于攻击者来说并不难发现，因为他们可以轻松查看网页的内容，了解 HTML 的内部工作原理。（准确来说，他们无法看到服务器上的代码，但通过尝试不同的
    URL 并观察结果网页，他们很容易推断出网页的工作方式。）一旦他们注意到 URL 注入到网页中，他们就可以进行快速测试，比如这里展示的例子，检查服务器是否容易受到
    XSS 攻击。此外，一旦他们确认 HTML 元字符，如尖括号和引号，从 URL 查询参数（或可能是其他攻击面）流入结果网页，他们可以查看页面的源代码并调整他们的尝试，直到成功注入恶意代码。
- en: There are several kinds of XSS attacks. This chapter’s example is a *reflected
    XSS* attack, because it is initiated via an HTTP request and expressed in the
    immediate server response. A related form, the *stored XSS* attack, involves two
    requests. First, the attacker somehow manages to store malicious data, either
    on the server or in client-side storage. Once that’s set up, a following request
    tricks the web server into injecting the stored data into a subsequent request,
    completing the attack. Stored XSS attacks can work across different clients. For
    example, on a blog, if the attacker can post a comment that causes XSS in the
    rendering of comments, then subsequent users viewing the web page will get the
    malicious script.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 攻击有几种类型。本章的例子是一种 *反射型 XSS* 攻击，因为它是通过 HTTP 请求发起，并在服务器的即时响应中体现。相关的形式是 *存储型
    XSS* 攻击，涉及两个请求。首先，攻击者以某种方式将恶意数据存储在服务器或客户端存储中。一旦设置完成，随后的请求会欺骗 Web 服务器将存储的数据注入到随后的请求中，从而完成攻击。存储型
    XSS 攻击可以跨不同客户端生效。例如，在博客上，如果攻击者能发布导致评论渲染时触发 XSS 的评论，那么随后的用户查看网页时将会获取到恶意脚本。
- en: A third attack form, called *DOM-based* *XSS*, uses the HTML DOM as the source
    of the malicious injection, but otherwise works much the same. Categories aside,
    the bottom line is that all of these vulnerabilities derive from injecting untrusted
    data that the web server allows to flow into the web page, introducing malicious
    script or other harmful content.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种攻击形式，称为 *基于 DOM 的 XSS*，使用 HTML DOM 作为恶意注入的源，但其工作原理与前两种攻击相似。不论分类如何，关键在于，这些漏洞都来源于将不受信任的数据注入
    Web 服务器，允许它流入网页，进而引入恶意脚本或其他有害内容。
- en: A secure web framework should have XSS protection built in, in which case you
    should be safe so long as you stay within the framework. As with any injection
    vulnerability, the defense involves either avoiding any chance for untrusted input
    to flow into a web page and potentially break out, or performing input validation
    to ensure that inputs will be handled safely. In the colored text example, the
    former technique could be implemented by simply serving named web pages (`/green-page`
    and `/blue-page`, for example) without the tricky query parameter. Alternatively,
    with a color parameter in the URL, you could constrain the query parameter value
    to be in an allowlist.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 一个安全的 Web 框架应该内置 XSS 保护，在这种情况下，只要你待在框架内，就应该是安全的。和任何注入漏洞一样，防御措施要么是避免任何不受信任的输入流入网页并可能突破，或者是进行输入验证，确保输入会被安全处理。在有色文本的例子中，前者的技巧可以通过简单地提供命名网页（例如
    `/green-page` 和 `/blue-page`）而不使用复杂的查询参数来实现。或者，若 URL 中包含颜色参数，可以将查询参数的值限制在允许的白名单内。
- en: Cross-Site Request Forgery
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: One cannot separate the spider web’s form from the way in which it originated.
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们无法将蜘蛛网的形式与它的起源方式分开。
- en: ''
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Neri Oxman
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Neri Oxman
- en: '*Cross-site request forgery* (*CSRF*, or sometimes *XSRF*) is an attack on
    a fundamental limitation in the Same Origin Policy. The vulnerability that these
    attacks exploit is conceptually simple but extremely subtle, so exactly where
    the problem lies, and how to fix it, can be hard to see at first. Web frameworks
    should provide CSRF protection, but a strong understanding of the underlying issue
    is still valuable so you can confirm that it works and be sure not to interfere
    with the mechanism.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '*跨站请求伪造*（*CSRF*，有时也叫 *XSRF*）是一种针对相同来源策略基本限制的攻击。这些攻击所利用的漏洞概念上很简单，但极其微妙，因此问题的具体所在以及如何修复它，刚开始时可能很难发现。Web
    框架应该提供 CSRF 保护，但对底层问题的深入理解仍然很有价值，这样你才能确认它是否有效，并确保不会干扰该机制。'
- en: Websites certainly can and often do include content, such as images from different
    websites, obtained via HTTP GET. The Same Origin Policy allows these requests
    while isolating the content, so the image data doesn’t leak between different
    websites from different domains. For example, site X can include on its page an
    image from site Y; the user sees the embedded image as part of the page, but site
    X itself cannot “see” the image, because the browser blocks script access to image
    data via the DOM.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 网站当然可以并且通常会包含内容，比如通过 HTTP GET 从不同网站获取的图片。相同来源策略允许这些请求，同时隔离内容，确保图像数据不会在不同域名的不同网站之间泄露。例如，站点
    X 可以在其页面中嵌入来自站点 Y 的图片；用户会看到嵌入的图片作为页面的一部分，但站点 X 自身无法“看到”该图片，因为浏览器通过 DOM 阻止了脚本对图像数据的访问。
- en: 'But the Same Origin Policy works the same for POST as it does for GET, and
    POST requests can modify a site’s state. Here’s exactly what happens: the browser
    allows site X to submit a form to site Y, and includes the Y cookies, too. The
    browser ensures that the response from site Y is completely isolated from site
    X. The threat is that a POST can modify data on the Y server, which X shouldn’t
    be able to do, and *by design*, any website can POST to any other. Since browsers
    facilitate these unauthorized requests, web developers must explicitly defend
    against these attempts to modify data on the server.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Same Origin Policy 对 POST 和 GET 请求的工作方式是相同的，而 POST 请求可以修改网站的状态。具体发生的事情是：浏览器允许网站
    X 向网站 Y 提交表单，并且也会包含 Y 的 cookies。浏览器确保来自 Y 网站的响应与 X 网站完全隔离。威胁在于，POST 请求可以修改 Y 服务器上的数据，而
    X 不应该能够做到这一点，*设计上*，任何网站都可以向任何其他网站发起 POST 请求。由于浏览器会促进这些未经授权的请求，网页开发者必须显式地防范这些修改服务器数据的尝试。
- en: A simple attack scenario will illustrate what CSRF vulnerabilities look like,
    how to exploit them, and in turn, how to defend against attack. Consider a social
    website Y, with many users who each have accounts. Site Y is running a poll, and
    each user gets one vote. The site drops a unique cookie for each authenticated
    user on the voting page, and then only accepts one vote per user.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的攻击场景将展示 CSRF 漏洞是什么样的、如何利用这些漏洞，进而如何防御攻击。假设有一个社交网站 Y，许多用户每个人都有账户。网站 Y 正在进行投票，每个用户只能投一票。该网站会在投票页面为每个认证用户设置一个独特的
    cookie，然后只接受每个用户的一次投票。
- en: A comment posted on the voting page says, “Check this out before you vote!”
    and links to a page on another website, X, that offers advice on how to vote.
    Many users click the link and read the page. With the Same Origin Policy protecting
    you, what could go wrong?
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 投票页面上发布的评论写道：“投票前请先查看这个！”并链接到另一个网站 X 的页面，提供关于如何投票的建议。许多用户点击了链接并阅读了页面。由于 Same
    Origin Policy 的保护，可能会出什么问题呢？
- en: 'If you don’t see the problem yet, here’s a big hint: think about what might
    be going on in the site X window. Suppose site X is run by some dastardly and
    guileful cheaters trying to steal votes. Whenever a user browses to X, script
    on that page submits the site owner’s preferred vote to the social website in
    that user’s browser context (using their cookies from Y).'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没看到问题，给你一个大提示：想一想 X 网站窗口里可能发生了什么。假设网站 X 是由一些邪恶且狡猾的作弊者运营，他们试图窃取投票。当用户浏览 X
    网站时，该页面上的脚本会在用户的浏览器上下文中（使用他们来自 Y 的 cookies）提交网站所有者希望的投票给社交网站。
- en: Since site X is allowed to submit forms using each user’s Y cookies, that’s
    enough to steal votes. The attackers just want to effect the state change on the
    server; they don’t need to see the response page confirming the user’s vote, which
    is all the Same Origin Policy blocks.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网站 X 被允许使用每个用户的 Y cookies 提交表单，这足以窃取投票。攻击者只需要在服务器上执行状态更改，他们不需要看到确认用户投票的响应页面，而这正是
    Same Origin Policy 阻止的内容。
- en: To prevent CSRF, ensure that valid state-changing requests are unguessable.
    In other words, treat each valid POST request as a special snowflake that only
    works once in the context of its intended use. An easy way to do this is by including
    a secret token as a hidden field in all forms, then checking that each request
    includes the secret corresponding to the given web session. There is a lot of
    nuanced detail packed into the creation and checking of a secret token for CSRF
    protection, so the details are worth digging into. A decent web framework should
    handle this for you, but let’s take a look at the details.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止 CSRF，确保有效的状态更改请求是不可猜测的。换句话说，将每个有效的 POST 请求视为一个特殊的“雪花”，它仅在其预定用途的上下文中有效。一种简单的方法是在所有表单中包含一个秘密令牌作为隐藏字段，然后检查每个请求是否包含与给定网页会话相对应的秘密。创建和检查
    CSRF 防护的秘密令牌时，涉及很多细节，因此值得深入探讨。一个好的 Web 框架应该会为你处理这些问题，但让我们来看一下这些细节。
- en: 'Here’s an example of the voting form with an anti-CSRF secret token highlighted:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有防 CSRF 秘密令牌的投票表单示例：
- en: '[PRE41]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The hidden `csrf_token` field doesn’t appear on the screen, but is included
    in the POST request. The field’s value is a base-64 encoding of a SHA-256 hash
    of the contents of the session cookie, but any per-client secret works. Here’s
    the Python code creating the anti-CSRF token for the session:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的 `csrf_token` 字段不会出现在页面上，但会包含在 POST 请求中。该字段的值是 session cookie 内容的 SHA-256
    哈希值的 base-64 编码，但任何每个客户端的秘密值都可以使用。以下是生成会话防 CSRF token 的 Python 代码：
- en: '[PRE42]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The code derives the token from the session cookie (the string value `self.session_id`),
    so it’s unique to each client. Since the Same Origin Policy prevents site X from
    knowing the victim’s site Y cookies, it’s impossible for Y’s creators to concoct
    an authentic form that satisfies these conditions to POST and steal the vote.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码从会话 cookie（字符串值 `self.session_id`）中派生令牌，因此它对每个客户端都是唯一的。由于同源策略阻止站点 X 知道受害者站点
    Y 的 cookie，因此 Y 的创建者无法构造一个满足这些条件的真实表单来执行 POST 操作并窃取投票。
- en: 'The validation code on the Y server simply computes the expected token value
    and checks that the corresponding field in the incoming form matches it. The following
    code prevents CSRF attempts by returning an error message if the token doesn’t
    match, before actually processing the form:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: Y 服务器上的验证代码简单地计算预期的令牌值，并检查传入表单中的相应字段是否与其匹配。以下代码通过在实际处理表单之前，如果令牌不匹配，则返回错误信息，从而防止
    CSRF 攻击：
- en: '[PRE43]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There are many ways to mitigate CSRF attacks, but deriving the token from the
    session cookie is a nice solution because all the necessary information to do
    the check arrives in the POST request. Another possible mitigation is to use a
    *nonce*—an unguessable token for one-time use—but to fend off CSRF attacks, you
    still have to tie it to the intended client session. This solution involves generating
    the random nonce for the form’s CSRF token, storing the token in a table indexed
    by session, and then validating the form by looking up the nonce for the session
    and checking that it matches.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以缓解 CSRF 攻击，但从会话 cookie 中派生令牌是一个不错的解决方案，因为所有进行检查所需的信息都会通过 POST 请求到达。另一个可能的缓解方法是使用
    *nonce*——一种不可猜测的、一次性的令牌——但是为了防止 CSRF 攻击，你仍然需要将其与目标客户端会话绑定。这种解决方案包括为表单的 CSRF 令牌生成随机的
    nonce，将令牌存储在按会话索引的表格中，然后通过查找该会话的 nonce 并检查是否匹配来验证表单。
- en: Modern browsers support the `SameSite` attribute on cookies to mitigate CSRF
    attacks. `SameSite=Strict` blocks sending cookies for any third-party requests
    (to other domains) on a page, which would stop CSRF but can break some useful
    behavior when navigating to another site that expects its cookies. There are other
    settings available, but support may be inconsistent across browser brands and
    older versions. Since this is a client-side CSRF defense it may be risky for the
    server to completely depend on it, so it should be considered at additional mitigation
    rather than the sole defense.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器支持 cookie 的 `SameSite` 属性来缓解 CSRF 攻击。`SameSite=Strict` 会阻止向页面上的任何第三方请求（到其他域）发送
    cookie，这可以阻止 CSRF 攻击，但当导航到另一个期待其 cookie 的站点时，可能会破坏一些有用的行为。还有其他可用的设置，但不同浏览器品牌和旧版本的支持可能不一致。由于这是客户端的
    CSRF 防御，完全依赖它对服务器来说可能有风险，因此应该将其作为额外的缓解措施，而非唯一防御。
- en: More Vulnerabilities and Mitigations
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多漏洞与缓解措施
- en: The only way you can know where the line is, is if you cross it.
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你只能通过越过界限才能知道界限在哪里。
- en: ''
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Dave Chappelle
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Dave Chappelle
- en: 'To recap: to be secure you should build websites in pure HTTPS, using a quality
    framework. Don’t override protection features provided by the framework unless
    you really know what you are doing, which means understanding how vulnerabilities
    such as XSS and CSRF arise. Modern websites often incorporate external scripts,
    images, styling, and the like, and you should only depend on resources from sources
    that you can trust since you are letting them inject content into your web page.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：为了安全，你应该使用纯 HTTPS 构建网站，并使用高质量的框架。在你真正知道自己在做什么之前，不要覆盖框架提供的保护功能，这意味着要理解像 XSS
    和 CSRF 这样的漏洞是如何产生的。现代网站通常会整合外部脚本、图像、样式等，你应该仅依赖你信任的资源，因为你让它们将内容注入到你的网页中。
- en: Naturally, that isn’t the end of the story, as there are still plenty of ways
    to get in trouble when exposing a server to the web. Websites present a large
    attack surface to the public internet, and those untrusted inputs can easily trigger
    all manner of vulnerabilities in server code, such as SQL injection (web servers
    frequently use databases for storage) and all the rest.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，这并不是故事的结束，因为在将服务器暴露于 Web 时仍有很多方式会陷入麻烦。网站为公共互联网提供了一个巨大的攻击面，这些不可信的输入很容易触发服务器代码中的各种漏洞，例如
    SQL 注入（Web 服务器通常使用数据库进行存储）以及其他所有漏洞。
- en: 'There are a number of other web-specific pitfalls worth mentioning. Here are
    some of the more common additional issues to watch out for (though this list is
    hardly exhaustive):'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他值得注意的特定于 Web 的陷阱。以下是一些常见的附加问题（尽管这个列表并不详尽）：
- en: Don’t let attackers inject untrusted inputs into HTTP headers (similar to XSS).
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要让攻击者将不受信任的输入注入到 HTTP 头部（类似 XSS 攻击）。
- en: Specify accurate MIME content types to ensure that browsers process responses
    correctly.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定准确的 MIME 内容类型，以确保浏览器正确处理响应。
- en: 'Open redirects can be problematic: don’t allow redirects to arbitrary URLs.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开重定向可能是一个问题：不要允许重定向到任意 URL。
- en: Only embed websites you can trust with `<IFRAME>`. (Many browsers support the
    `X-Frame-Options` header mitigation.)
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只嵌入你信任的网站使用 `<IFRAME>`。 （许多浏览器支持 `X-Frame-Options` 响应头的缓解措施。）
- en: When working with untrusted XML data, beware of XML external entity (XXE) attacks.
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理不受信任的 XML 数据时，要小心 XML 外部实体（XXE）攻击。
- en: The CSS `:visited` selector potentially discloses whether a given URL is in
    the browser history.
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS `:visited` 选择器可能会泄露某个 URL 是否在浏览器历史记录中。
- en: In addition, websites should use a great new feature, the HTTP `Content-Security-Policy`
    response header, to reduce exposure to XSS. It works by specifying authorized
    sources for script or images (and many other such features), allowing the browser
    to block attempts to inject inline script or other malicious content from other
    domains. There are a lot of browsers out there, and browser compatibility for
    this feature is still inconsistent, so using this header isn’t sufficient to consider
    the vulnerability completely fixed. Think of this as an additional line of defense,
    but since it is client-side and out of your control, don’t consider it a free
    pass granting perfect immunity to XSS.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，网站应使用一个全新的功能——HTTP `Content-Security-Policy` 响应头，以减少暴露于 XSS 攻击的风险。它通过指定脚本或图像的授权来源（以及许多其他类似功能）来工作，从而允许浏览器阻止尝试注入内联脚本或其他来自其他域的恶意内容。现有许多浏览器，而浏览器对这一功能的兼容性仍然不一致，因此仅使用该响应头并不足以认为漏洞已完全修复。可以将其视为一道额外的防线，但由于它是客户端功能并且超出你的控制范围，因此不要将其视为对
    XSS 完美免疫的“通行证”。
- en: Links to untrusted third-party websites can be risky because the browser may
    send a `REFERER` header, as mentioned earlier in this chapter, and provide a `window.opener`
    object in the DOM to the target page. The `rel="noreferrer"` and `rel="noopener"`
    attributes, respectively, should be used to block these unless they are useful
    and the target can be trusted.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 链接到不受信任的第三方网站可能会存在风险，因为浏览器可能会发送一个 `REFERER` 响应头，正如本章前面提到的，并将 `window.opener`
    对象提供给目标页面。除非目标页面有用且可以信任，否则应该分别使用 `rel="noreferrer"` 和 `rel="noopener"` 属性来阻止这些行为。
- en: Adding new security features after the fact may be daunting for large existing
    websites, but there is a relatively easy way of moving in the right direction.
    In a test environment, add restrictive security policies in all web pages, and
    then test the website and track down what gets blocked issue by issue. If you
    prohibit script loading from a site that you know is safe and you intended to
    use, then by incrementally loosening the script policy, you’ll quickly arrive
    at the correct policy exceptions. With automated in-browser testing just to make
    sure the entire site gets tested, you should be able to make great strides for
    security with a modest investment of effort.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型现有网站，事后添加新的安全功能可能会让人望而却步，但有一种相对简单的方式可以朝着正确的方向前进。在测试环境中，在所有网页中添加限制性安全策略，然后测试网站并逐一跟踪被阻止的问题。如果你禁止从一个你知道是安全并且打算使用的站点加载脚本，通过逐步放宽脚本策略，你将很快找到正确的政策例外。通过自动化浏览器内测试，确保整个网站都经过测试，你应该能够以适度的努力取得显著的安全进展。
- en: There are a number of HTTP response headers that help you specify what the browser
    should or should not allow, including the `Content-Security-Policy`, `Referrer-Policy`,
    `Strict-Transport-Security`, `X-Content-Type-Options`, and `X-Frame-Options` headers.
    The specifications are still evolving, and support may vary from browser to browser,
    so this is a tricky, changing landscape. Ideally, make your website secure on
    the server side, and then use these security features as a second layer of defense,
    bearing in mind that reliance *only* on client side mechanisms would be risky.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 HTTP 响应头可以帮助你指定浏览器应该或不应该允许的内容，包括 `Content-Security-Policy`、`Referrer-Policy`、`Strict-Transport-Security`、`X-Content-Type-Options`
    和 `X-Frame-Options` 响应头。相关规范仍在不断发展，且各浏览器的支持情况可能不同，因此这是一个复杂且不断变化的领域。理想情况下，首先在服务器端确保网站的安全，然后使用这些安全功能作为第二层防御，并且要记住，*仅*依赖客户端机制是有风险的。
- en: It’s amazing how secure the web actually is, considering all the ways that things
    can go wrong, what it evolved from, and the volume of critical data it carries.
    Perhaps, in hindsight, it’s best that security technologies have matured slowly
    over time as the web has seen widespread global adoption. Had the early innovators
    attempted to design a completely secure system back in the day, the task would
    have been extremely daunting, and had they failed, the entire endeavor might never
    have come to anything.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到网页可能出错的各种方式、它的发展历程以及它承载的关键数据量，实际上网络的安全性令人惊叹。或许，回顾过去，随着网页在全球范围内的广泛采用，安全技术随着时间的推移逐渐成熟是最合适的。如果早期的创新者曾试图设计一个完全安全的系统，那将是一项极其艰巨的任务，如果他们失败了，整个努力可能永远无法取得成果。
- en: '12'
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Security Testing
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试
- en: Testing leads to failure, and failure leads to understanding.
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 测试会导致失败，而失败会带来理解。
- en: ''
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Burt Rutan
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —伯特·鲁坦
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-618
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter introduces security testing as an essential part of developing
    reliable, secure code. Testing proactively to detect security vulnerabilities
    is both well understood and not difficult to do, but it’s vastly underutilized
    in practice and so represents a major opportunity to raise security assurance.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了安全测试作为开发可靠、安全代码的重要组成部分。主动测试以发现安全漏洞是容易理解且不难实施的，但在实践中却极为不足，因此这代表了提高安全保障的一个重要机会。
- en: This chapter opens with a quick overview of the uses of security testing, followed
    by a walkthrough of how security testing could have saved the world from a major
    vulnerability. Next, we look at the basics of writing security test cases to detect
    and catch vulnerabilities or their precursors. Fuzz testing is a powerful supplementary
    technique that can help you ferret out deeper problems. We’ll also cover security
    regressiontests, created in response to existing vulnerabilities to ensure that
    the same mistakes are never made twice. The chapter concludes with a discussion
    of how testing helps to prevent denial-of-service (DoS) and related attacks, followed
    by a summary of security testing best practices (which covers a wide range of
    ideas for security testing, but is by no means comprehensive).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以安全测试应用的简要概述开始，接着介绍了安全测试如何挽救世界免于一个重大漏洞。接下来，我们将学习如何编写安全测试用例，以检测和捕捉漏洞或其前兆。模糊测试是一种强有力的补充技术，有助于发现更深层次的问题。我们还将涵盖安全回归测试，针对现有漏洞创建，以确保同样的错误不会再次发生。本章最后讨论了如何通过测试预防拒绝服务（DoS）和相关攻击，并总结了安全测试的最佳实践（涵盖了广泛的安全测试思路，但并非全面）。
- en: What Is Security Testing?
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是安全测试？
- en: To begin, it’s important to define what I mean by *security testing*. Most testing
    consists of exercising code to check that functionality works as intended. Security
    testing simply flips this around, ensuring that operations that should *not* be
    allowed aren’t (an example with code will shortly make this distinction clear).
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要定义*安全测试*的含义。大多数测试通过运行代码来检查功能是否按预期工作。安全测试则完全相反，确保那些*不应该*允许的操作确实没有发生（稍后的代码示例将清晰地说明这一点）。
- en: 'Security testing is indispensable because it ensures that mitigations are working.
    Given that coders reasonably focus on getting the intended functionality to work
    with normal use, attacks that do the unexpected can be difficult to fully anticipate.
    The material covered in the preceding chapters should immediately suggest numerous
    security testing possibilities. Here are some basic kinds of security test cases
    corresponding to the major classes of vulnerabilities covered previously:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试不可或缺，因为它确保缓解措施有效。考虑到开发人员通常专注于确保功能在正常使用下按预期工作，针对不期而至的攻击，完全预测是十分困难的。前几章所涉及的内容应该立刻提示出众多安全测试的可能性。以下是一些与之前提到的主要漏洞类别相对应的基础安全测试用例：
- en: '**Integer overflows**'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**整数溢出**'
- en: Establish permitted ranges of values and ensure that detection and rejection
    of out-of-range values work.
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定允许的值范围，并确保能够检测并拒绝超出范围的值。
- en: '**Memory management problems**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存管理问题**'
- en: Test that the code handles extremely large data values correctly, and rejects
    them when they’re too big.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试代码是否能正确处理极大的数据值，并在数据过大时将其拒绝。
- en: '**Untrusted inputs**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可信输入**'
- en: Test various invalid inputs to ensure they are either rejected or converted
    to a valid form that is safely processed.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试各种无效输入，确保它们要么被拒绝，要么被转换为有效的形式并安全地处理。
- en: '**Web security**'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 安全**'
- en: Ensure that HTTP downgrade attacks, invalid authentication and CSRF tokens,
    and XSS attacks fail (see the previous chapter for details on these).
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 HTTP 降级攻击、无效身份验证和 CSRF 令牌、以及 XSS 攻击失败（有关这些的详细信息，请参阅前一章）。
- en: '**Exception handling flaws**'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常处理缺陷**'
- en: Force the code through its various exception handling paths (using dependency
    injection for rare ones) to check that it recovers reasonably.
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制代码通过其各种异常处理路径（使用依赖注入处理少见的路径），检查它是否能够合理地恢复。
- en: What all of these tests have in common is that they are off the beaten path
    of normal usage, which is why they are easily forgotten. And since all these areas
    are ripe for attack, thorough testing makes a big difference. Security testing
    makes code more secure by anticipating such cases and confirming that the necessary
    protection mechanisms always work. In addition, for security-critical code, I
    recommend thorough code coverage to ensure the highest possible quality, since
    bugs in those areas tend to be devastating.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的共同点是它们偏离了正常使用的常规路径，这也是它们容易被遗忘的原因。由于这些领域都是攻击的高风险区域，彻底的测试能起到很大的作用。安全测试通过预测这些情况并确认必要的保护机制始终有效，从而使代码更加安全。此外，对于安全关键的代码，我建议进行彻底的代码覆盖率测试，以确保尽可能高的质量，因为这些区域的漏洞往往会带来灾难性的后果。
- en: Security testing is likely the best way you can start making real improvements
    to application security, and it isn’t difficult to do. There are no public statistics
    for how much or how little security testing is done in the software industry,
    but the preponderance of recurrent vulnerabilities strongly suggests that it’s
    an enormous missed opportunity.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试可能是你开始提升应用程序安全性的最佳方式，而且并不难做到。关于软件行业中安全测试的公开统计数据并不存在，但反复出现的漏洞强烈表明，这是一个巨大的错失机会。
- en: Security Testing the GotoFail Vulnerability
  id: totrans-636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全测试 GotoFail 漏洞
- en: What a testing of character adversity is.
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么是字符逆境的测试？
- en: ''
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Harry Emerson Fosdick
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——哈里·爱默生·福斯迪克
- en: Recall the GotoFail vulnerability we examined in Chapter 8, which caused secure
    connection checks to be bypassed. Extending the simplified example presented there,
    let’s look at how security testing would have easily detected problems like that.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在第八章中讨论的 GotoFail 漏洞，它导致了安全连接检查被绕过。扩展我们在那里的简化示例，让我们看看安全测试是如何轻松发现类似问题的。
- en: 'The GotoFail vulnerability was caused by a single line of code accidentally
    being doubled up, as shown by the highlighted line in the following code snippet.
    Since that line was a `goto` statement, it short-circuited a series of important
    checks and caused the verification function to unconditionally produce a passing
    return code. Earlier we looked only at the critical lines of code (in my simplified
    version), but to security test it, we need to examine the entire function:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: GotoFail 漏洞是由一行代码意外重复导致的，如以下代码片段中高亮的行所示。由于那一行是 `goto` 语句，它跳过了一系列重要的检查，导致验证函数无条件地返回通过的代码。我们之前只看了关键的代码行（在我的简化版本中），但为了进行安全测试，我们需要检查整个函数：
- en: '**vulnerable code**'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '**易受攻击的代码**'
- en: '[PRE44]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `VerifyServerKeyExchange` function takes a `params` argument consisting
    of three fields, computes the message digest hash over its contents, and compares
    the result to the `expected_hash` value that authenticates the data. A zero return
    value indicates that the hashes match, which is required for a valid request.
    A nonzero return value means there was a problem: the hash *values* did not match
    (`-100`), the hash *lengths* did not match (`-106`), or some nonzero error code
    was returned from the hash computation library due to an unspecified error. Security
    depends on this: any tampering with the hash value or the data causes the hashes
    to mismatch, signaling that something is amiss.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`VerifyServerKeyExchange` 函数接受一个由三个字段组成的 `params` 参数，计算其内容的消息摘要哈希，并将结果与验证数据的
    `expected_hash` 值进行比较。返回值为零表示哈希匹配，这是有效请求的必要条件。非零返回值表示存在问题：哈希 *值* 不匹配（`-100`），哈希
    *长度* 不匹配（`-106`），或者由于未指定的错误，从哈希计算库返回了某个非零错误代码。安全性依赖于此：任何篡改哈希值或数据的行为都会导致哈希不匹配，从而标志着出现了问题。'
- en: Let’s first walk through the correct version of the code, before the duplicated
    `goto` statement was introduced. After setting up a `HashCtx ctx` context variable,
    it hashes the three data fields of `params` in turn (at 1, 2, and 3). If any error
    occurs, it jumps to the `fail` label to return the error code in the variable
    `err`. Otherwise, it continues, copying the hash result into a buffer and comparing
    that (at 4) to the expected hash value. The comparison function `memcmp` returns
    `0` for equal, or if the hashes are different, the code assigns an error code
    of `-100` to `err` and falls through to return that result.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先走一遍正确版本的代码，在引入重复的`goto`语句之前。设置一个`HashCtx ctx`上下文变量后，它依次对`params`的三个数据字段进行哈希（分别在
    1、2 和 3 处）。如果发生任何错误，它会跳转到`fail`标签并返回变量`err`中的错误代码。否则，代码继续执行，将哈希结果复制到缓冲区并在第 4 步与预期的哈希值进行比较。比较函数`memcmp`返回`0`表示相等，如果哈希不同，代码会将错误代码`-100`赋值给`err`并继续返回该结果。
- en: Functional Testing
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能测试
- en: 'Before considering security testing, let’s start with a functional test for
    the `VerifyServerKeyExchange` function. Functional testing checks that the code
    performs as expected, and this simple example is by no means complete. This example
    uses the MinUnit test framework for C. To follow along, all you need to know is
    that `mu_assert(``condition``,` `message``)` checks that the expression `condition`
    is true; if not, the assertion fails, printing the `message` provided:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑安全测试之前，让我们先从`VerifyServerKeyExchange`函数的功能测试开始。功能测试检查代码是否按预期执行，这个简单的示例并不完整。这个示例使用了
    C 语言的 MinUnit 测试框架。为了跟随示例，你只需要知道`mu_assert(``condition``,` `message``)`用来检查表达式`condition`是否为真；如果不为真，断言失败，并打印提供的`message`：
- en: '[PRE45]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This calls the function with known-good parameters, so we expect a return value
    of `0` to pass the test. In the function itself, the three fields will be hashed
    (at 1, 2, and 3). The hashes compare equal at 4. Not shown are the test values
    for the three fields of data (in the `ExchangeParams` struct named `test0`) with
    the precomputed correct hash (`expected_hash`) that the server would sign.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用使用已知良好的参数，因此我们期望返回值为`0`，测试通过。在函数内部，这三个字段会被哈希（分别在 1、2 和 3 处）。哈希在 4 处比较相等。未显示的是三字段数据（`ExchangeParams`结构体中的`test0`）的测试值，以及服务器会签署的预计算正确哈希（`expected_hash`）。
- en: Functional Testing with the Vulnerability
  id: totrans-650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 含漏洞的功能测试
- en: Now let’s introduce the GotoFail vulnerability (that highlighted line of code)
    and see what impact it has. When we rerun the functional test with the extra `goto`,
    the test still passes. The code works fine up to the duplicated `goto`, but then
    jumps over the hashing of the third data field (at 3) and the comparison of hashes
    (at 4). The function will continue to verify correct inputs, but now it will also
    verify some bad inputs that it should reject. However, we don’t know that yet.
    This is precisely why security testing is so important—and why it’s so easily
    overlooked.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们引入 GotoFail 漏洞（即突出显示的那行代码），并看看它带来了什么影响。当我们在额外的`goto`语句后重新运行功能测试时，测试仍然通过。代码在重复的`goto`之前工作正常，但跳过了第三个数据字段的哈希（在
    3 处）和哈希比较（在 4 处）。函数仍然会继续验证正确的输入，但现在它也会验证一些应该被拒绝的错误输入。然而，我们现在还不知道这一点。这正是安全测试如此重要的原因——也是为何它如此容易被忽视的原因。
- en: More thorough functional testing might well include additional test cases, such
    as to check for verification failure (a nonzero return value). However, functional
    testing often stops short of thoroughly covering all the cases where we need the
    verify function to reject inputs in the name of security. This is where security
    testing comes in, as we shall see next.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 更全面的功能测试可能包括额外的测试用例，例如检查验证失败（非零返回值）。然而，功能测试通常并不会彻底涵盖所有我们需要验证的用例，而这些用例需要验证函数拒绝输入的安全性。正是在这一点上，安全测试变得尤为重要，接下来我们将看到这一点。
- en: Security Test Cases
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全测试用例
- en: Now let’s write some security test cases. Since there are three chunks of data
    to hash, that suggests writing three corresponding tests; each of these will change
    the data values in some way, resulting in a hash that won’t match the expected
    value. The target verify function should reject these inputs because the changed
    values potentially represent data tampering, which the hash comparison is supposed
    to prevent. The actual values (`test1`, `test2`, ``test3) are copies of the correct
    `test0` with slight variations in one of the three data fields; the values themselves
    are unimportant and not shown. Here are the three test cases:``
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一些安全性测试用例。由于需要对三块数据进行哈希处理，这意味着我们需要编写三个相应的测试用例；每个测试用例都会以某种方式改变数据值，导致哈希值与预期值不匹配。目标验证函数应该拒绝这些输入，因为改变的数据值可能代表数据篡改，而哈希比较正是用来防止这种情况的。这些实际的值（`test1`，`test2`，`test3`）是正确的`test0`的副本，只有其中一个数据字段稍作变化；这些值本身并不重要，且未显示。以下是三个测试用例：
- en: '[PRE46]  ``# 13 Secure Development Best Practices    > They say that nobody
    is perfect. Then they tell you practice makes perfect. I wish they''d make up
    their minds. >  > —Winston Churchill  ![](image_fi/book_art/chapterart.png)  So
    far in Part III, we have surveyed a collection of security vulnerabilities that
    arise in the development phase. In this chapter, we’ll focus on how aspects of
    the development process itself relate to security and can go wrong. We’ll begin
    by discussing code quality: the value of good code hygiene, thorough error and
    exception handling, documenting security properties, and the role of code reviews
    in promoting security. Second, we’ll look at dealing with dependencies: specifically,
    how they introduce vulnerabilities into systems. The third area we’ll cover is
    bug triage—a critical skill for balancing security against other exigencies. Finally,
    secure development depends on maintaining a secure working environment, so I provide
    some basic tips on what you need to do to avoid being compromised.    For practical
    reasons, the guidance that follows is generic. Readers should be able to apply
    it to their own development practices. Many other effective techniques are specific
    to programming languages, operating systems, and other particulars of a given
    system. For this reason, it’s important that you recognize the big patterns in
    the following discussion, but also be alert to additional security-related issues
    and opportunities that arise in your own work.    ## Code Quality    > Quality
    is always in style. >  > —Robert Genn    The earlier chapters in Part III explained
    many of the ways that vulnerabilities slip into code, but here I want to focus
    on the relationship of bugs in general to security. If you can raise the quality
    of your code, you’ll make it more secure in the long run, whether you recognize
    this or not. All vulnerabilities are bugs, so fewer bugs means fewer vulnerabilities
    and vulnerability chains. But of course, diminishing returns kick in long before
    you eliminate all bugs, so it’s best to take a balanced approach.    The following
    discussion covers some of the key areas to focus on in the name of security.    ###
    Code Hygiene    Programmers usually have a good sense of the quality of the code
    they’re working with, but for various reasons, they often choose to accept known
    flaws instead of making needed improvements. Code smells, spaghetti code, and
    postponed “TODO” comments that mark further work needed all tend to be fertile
    ground for vulnerabilities. At least in areas where security is of special concern,
    identifying and smoothing out these rough edges can be one of the best ways to
    avoid vulnerabilities without needing to do any security analysis in order to
    see how bugs may be exploitable.    In addition to your native sense of the condition
    of the code, use tools to flag these issues. Compile your code with full warnings
    and then fix the code to resolve significant issues. Some of these automated warnings,
    such as misleading indentation or unused code for which there is no execution
    path, would have identified the GotoFail vulnerability we talked about in Chapter
    8, and security tested in Chapter 12. Lint and other static code analysis tools
    offer even richer scrutiny of the code, providing tips that sometimes reveal bugs
    and vulnerabilities.    Code analysis doesn’t always identify security bugs as
    such, so you’ll have to cast a broader net. Use these tools frequently during
    development to lower the overall number of potential bugs. This way, if a tool’s
    output changes significantly you’ll have a better chance of noticing it, because
    the new content won’t get lost in a torrent of older messages.    Fix all warnings
    if it’s easy to do so, or when you see that an issue could be serious. For example,
    unreachable code suggests that although somebody wrote the code for a reason,
    it’s now out of the picture, and that can’t be right. On the other hand, warnings
    about variable naming conventions, while being good suggestions, probably won’t
    relate to any security vulnerability.    Finding time to do this kind of cleanup
    is always challenging. Take an incremental approach; even an hour or two a week
    will make a big difference over time, and the process is a good way to become
    familiar with a big codebase. If all the warnings are too much to deal with, start
    with the most promising ones (for example, GCC’s `-Wmisleading-indentation`),
    then fix what gets flagged.    ### Exception and Error Handling    The 1996 Ariane
    5 Flight 501 Failure Report painfully details the consequences of poor exception
    handling. While the calamitous bug was purely self-inflicted, involving no malicious
    actor, it stands as an example of how an attacker might exploit the resulting
    behavior to compromise a system.    Soon after the Ariane 5 spacecraft’s launch,
    a floating point to integer conversion in a calculation caused an exception. An
    exception-handling mechanism triggered, but as the conversion error was unanticipated,
    the exception handler code had no contingency for the situation. The code shut
    down the engine, resulting in catastrophic failure after 36.7 seconds of flight.    Defending
    against such problems begins with recognizing the risks of slapdash exception
    handling and then thinking through the right response for even the most unlikely
    exceptions. Generally speaking, it’s best to handle exceptions as close to the
    source as possible, where there is the most context for it and the shortest window
    of time for further complications to arise.    That said, large systems may need
    a top-level handler to field any unhandled exceptions that bubble up. One good
    way to do this is to identify a unit of action and fail that in its entirety.
    For example, a web server might catch exceptions during an HTTP request and return
    a generic 500 (server error) response. Typically, web applications should handle
    state-changing requests as transactions so that any error always results in no
    state change. This avoids partial changes that may leave the system in a fragile
    state.    Much of the reasoning that connects sloppy exception handling to potential
    vulnerabilities also applies to error handling in general. Like exceptions, error
    cases may occur infrequently, so it’s easy for developers to forget them, leaving
    them incomplete or untested. A common trick attackers use to discover exploits
    is to try causing some kind of error and then observe what the code does in hopes
    of discovering weaknesses. Therefore, the best defense is to implement solid error
    handling from the start. This is a classic example of one way that security vulnerabilities
    are different from other bugs: in normal use, some error might be exceedingly
    rare, but in the context of a concerted attack, invoking an error might be an
    explicit goal.    Solid testing is important in order to get error and exception
    handling right. Ensure that there is test coverage on all code paths, especially
    the less common ones. Monitor logs of exceptions in production and track down
    their causes to make sure that exception recovery works correctly. Aggressively
    investigate and fix intermittent exceptions, because if a smart attacker learns
    how to trigger one, they may be able to fine-tune it into a malicious exploit
    from there.    ### Documenting Security    When you’re writing code with important
    security consequences, how much do you need to explain your decisions in comments,
    so others (or your own forgetful self, months or years later) don’t accidentally
    break it?    For critical code, or wherever the security implications deserve
    explanation, commenting is important, as it allows anyone who is contemplating
    changing the code to understand the stakes. When you write comments about security,
    explain the security implications and be specific: simply writing `// Beware:
    security consequences` isn’t an explanation. Be clear and stick to the point:
    include too much verbiage and people will either tune it out or give up. Recalling
    the Heartbleed bug we discussed in Chapter 9, and security tested in Chapter 12,
    a good comment would explain that rejecting invalid requests with byte counts
    exceeding the actual data provided is crucial because it could result in disclosing
    private data beyond the extent of the buffer. If the security analysis becomes
    too complex to explain in the comments, write up the details in a separate document,
    then provide a reference to that document.    This does not mean that you should
    attempt to flag all code that security depends on. Instead, aim to warn readers
    about the less-than-obvious issues that might be easily overlooked in the future.
    Ultimately, comments cannot fully substitute for knowledgeable coders who are
    constantly vigilant of security implications, which is why this stuff is not easy.    Writing
    a good security test case (as discussed in Chapter 12) is an ideal way to back
    up the documentation with a mechanism to prevent others from unwittingly breaking
    security with future changes. As a working mock-up of what an attack looks like,
    such a test not only guards against accidental adverse changes, but also serves
    to show exactly how the code might go wrong.    ### Security Code Reviews    The
    professional software development process includes peer code reviews as standard
    practice, and I want to make the case for explicitly including security in those
    reviews. Usually this is best done as one step within the code review workflow,
    along with the checklist of potential issues that reviewers should be on the lookout
    for, including code correctness, readability, style, and so forth.    I recommend
    that the same code reviewer add an explicit step to consider security, typically
    after a first pass reading the code, going through it again with their “security
    hat” on. If the reviewer doesn’t feel up to covering security, they should delegate
    that part to someone capable. Of course, you can skip this step for code changes
    that are clearly without security implications.    Reviewing code changes for
    security differs from an SDR (the topic of Chapter 7) in that you are looking
    at a narrow subset of the system without the big-picture view you get when reviewing
    a whole design. Be sure you consider how the code handles a range of untrusted
    inputs, check that any input validation is robust, and avoid potential Confused
    Deputy problems. Naturally, code that is crucial to security should get extra
    attention, and usually merits a higher threshold of quality. The opportunity to
    focus an extra pair of eyes on the security of the code has great potential for
    improving the system as a whole.    Code reviews are also an excellent opportunity
    to ensure that the security test cases that have been created (as described in
    Chapter 12) are sufficient. As a reviewer, if you hypothesize that certain inputs
    might be problematic, write a security test case and see what happens, rather
    than guessing. Should your exploratory test case reveal a vulnerability, raise
    the issue and also contribute the test case to ensure it gets fixed.    ## Dependencies    >
    Dependence leads to subservience. >  > —Thomas Jefferson    Modern systems tend
    to build on large stacks of external components. These dependencies are problematic
    in more ways than one. Many platforms, such as `npm`, automatically pull in numerous
    dependencies that are difficult to track. And using old versions of external code
    with known vulnerabilities is one of the biggest ongoing threats the industry
    has yet to systematically eliminate. In addition, there is risk of picking up
    malicious components in your software supply chain. This can happen in several
    ways; for example, packages created with similar names to well-known ones may
    get selected by mistake, and you can get malware indirectly via other components
    through their dependencies.    Adding components to a system can potentially harm
    security even if those components are intended to strengthen it. You must trust
    not only the component’s source, but everything the source trusts as well. In
    addition to the inevitable risks of extra code that adds bugs and overall complexity,
    components can expand the attack surface in unexpected new ways. Binary distributions
    are virtually opaque, but even with source code and documentation, it’s often
    infeasible to carefully review and understand everything you get inside the package,
    so it often boils down to blind trust. Antivirus software can detect and block
    malware, but it also uses pervasive hooks that go deep into the system, needs
    superuser access, and potentially increases the attack surface, such as when it
    phones home to get the latest database of malware and report findings. The ill-advised
    choice of a vulnerable component can end up degrading security, even if your intention
    was to add an extra layer of defense.    ### Choosing Secure Components    For
    the system as a whole to be secure, each of its components must be secure. In
    addition, the interfaces between them must be secure. Here are some basic factors
    to consider when choosing secure components:    *   What is the security track
    record of the component in question, and of its maker? *   Is the component’s
    interface proprietary, or are there compatible alternatives? (More choices may
    provide more secure alternatives.) *   When (not if) security vulnerabilities
    are found in the component, are you confident its developers will respond quickly
    and release a fix? *   What are the operational costs (in other words, effort,
    downtime, and expenses) of keeping the component up to date?    It’s important
    to select components with a security perspective in mind. A component used to
    process private data should provide guarantees against information disclosure.
    If, as a side effect of processing data, it will be logging the content or storing
    it in unsecured storage, that constitutes a potential leak. Don’t repurpose software
    written to handle, say, ocean temperatures, which have no privacy concerns at
    all, for use with sensitive medical data. Also avoid prototype components, or
    anything other than high-quality production releases.    ### Securing Interfaces    A
    well-documented interface should explicitly specify its security and privacy properties,
    but in practice this often doesn’t happen. In the interest of efficiency, it’s
    easy for programmers to omit input validation, especially when they assume that
    validation will have already been handled. On the other hand, making every interface
    perform redundant input validation is indeed wasteful. When unsure, test to find
    out how the interface behaves if you can, and if still in doubt, add a layer of
    input validation in front of the interface for good measure.    Avoid using deprecated
    APIs, because they often mask potential security issues. API makers commonly deprecate,
    rather than entirely remove, APIs that include insecure features. This discourages
    others from using the vulnerable code while maintaining backward compatibility
    for existing API consumers. Of course, deprecation happens for other reasons as
    well, but as an API consumer, it’s important to investigate whether the reason
    for the deprecation has security implications. Remember that attackers may be
    tracking API deprecations as well, and may be readying an attack.    Beyond these
    basic examples, take extra care whenever an interface exposes its internals, because
    these often get used in unintended ways that can easily create vulnerabilities.
    Consider “The Most Dangerous Code in the World” (Georgiev et al., 2012), a great
    case study of a widely used SSL library that researchers found was repeatedly
    used unsafely, completely undermining the security properties it was meant to
    provide. The authors found that “the root cause of most of these vulnerabilities
    is the terrible design of the APIs to the underlying SSL libraries.”    Also be
    wary of APIs with complicated configuration options, particularly if security
    depends on them. When designing your own APIs, honor the Secure by Default pattern,
    document how to securely configure your system, and where appropriate provide
    a helper method that ensures proper configuration. When you must expose potentially
    insecure functionality, do everything possible to ensure that nobody can plausibly
    use it without knowing exactly what they are doing.    ### Don’t Reinvent Security
    Wheels    Use a standard, high-quality library for your basic security functionality
    when possible. Every time someone attempts to mitigate, say, an XSS attack in
    query parameters from scratch, they risk missing an obscure form of attack, even
    if they know HTML syntax inside out.    If a good solution isn’t available, consider
    creating a library for use throughout your codebase to address a particular potential
    flaw, and be sure to test it thoroughly. In some cases, automated tools can help
    find specific flaws in code that often become vulnerabilities. For example, scan
    C code for the older “unsafe” string functions (such as `strcpy`) and replace
    them with the newer “safe” versions (`strlcpy`) of the same functionality.    If
    you are writing a library or framework, look carefully for security foibles so
    they get handled properly, once and for all. Then follow through and explicitly
    document what protections are and aren’t provided. It isn’t helpful to just advertise:
    “Use this library and your security worries will all be solved.” If I am relying
    on your code, how do I know what exactly is or is not being handled? For example,
    a web framework should describe how it uses cookies to manage sessions, prevents
    XSS, provides nonces for CSRF, uses HTTPS exclusively, and so forth.    While
    it may feel like putting all your eggs in one basket, solving a potential security
    problem once with a library or framework is usually best. The consistent use of
    such a layer provides a natural bottleneck, addressing all instances of the potential
    problem. When you find a new vulnerability later, you can make a single change
    to the common code, which is easy to fix and test and should catch all usages.    Security-aware
    libraries must sometimes provide raw access to underlying features that cannot
    be fully protected. For example, an HTML framework template might let applications
    inject arbitrary HTML. When this is necessary, thoroughly document wherever the
    usual protections cease to apply, and explain the responsibilities of the API
    users. Ideally, name the API in a way that provides an unmistakable hint about
    the risk, such as `unsafe_raw_html`.    The bottom line is that security vulnerabilities
    can be subtle, possible attacks are many, and it only takes one to succeed—so
    it’s wise to avoid tackling such challenges on your own. For the same reasons,
    once someone has successfully solved a problem, it’s smart to reuse that as a
    general solution. Human error is the attacker’s friend, so using solutions that
    make it easy to do things the secure way is best.    ### Contending with Legacy
    Security    Digital technology evolves quickly, but security tools tend to lag
    behind for a number of reasons. This represents an important ongoing challenge.
    Like the proverbial frog in hot water, legacy security methods often remain in
    use for far too long unless someone takes a hard look at them, explicitly points
    out the risk, and proposes a more secure solution and a transition plan.    To
    be clear, I’m not saying that existing security methods are necessarily weak,
    just that almost everything has a “best before” date. Plus, we need to periodically
    re-evaluate existing systems in the context of the evolving threat landscape.
    Password-based authentication may need shoring up with a second factor if it becomes
    susceptible to phishing attacks. Crypto implementations are based on modern hardware
    cost and capability assessments, and as Moore’s law tells us, this is a moving
    target; as quantum computing matures, high-security systems are already moving
    on to post-quantum algorithms thought to be resistant to the new technology.    Weak
    security often persists well past its expiration date for a few reasons. First,
    inertia is a powerful force. Since systems typically evolve by increments, nobody
    questions the way authentication or authorization is currently done. Second, enterprise
    security architecture typically requires all subsystems to be compatible, so any
    changes will mean modifying every component to interoperate in a new way. That
    often feels like a huge job and thus raises powerful resistance.    Also, older
    subcomponents can be problematic, as legacy hardware or software may not support
    more modern security technologies. In addition, there is the easy counterargument
    that the current security has worked so far, so there’s no need to fix what isn’t
    broken. On top of all this, whoever designed the legacy security may no longer
    be around, and nobody else may fully understand it. Or, if the original designer
    is around, they may be defensive of their work.    No simple answer can address
    all of these concerns, but threat modeling may identify specific issues with weak
    legacy security that should make the risk it represents evident.    Once you’ve
    identified the need to phase out the legacy code, you need to plan the change.
    Integrating a new component with a compatible interface into the codebase makes
    the job easier, but sometimes this isn’t possible. In some cases, a good approach
    is to implement better security incrementally: parts of the system can convert
    to the new implementation piecewise, until you can remove legacy code when it
    is no longer needed.    ## Vulnerability Triage    > The term “triage” normally
    means deciding who gets attention first. >  > —Bill Dedman    Most security issues,
    once identified, are straightforward to fix, and your team will easily reach consensus
    on how to do so. Occasionally, however, differences of opinion about security
    issues do happen, particularly in the middle ground where the exploitability of
    a bug is unclear or the fix is difficult. Unless there are significant constraints
    that compel expediency, it’s generally wise to fix any bug if there is any chance
    that it might be vulnerable to exploit. Bear in mind how vulnerability chains
    can arise when several minor bugs combine to create major vulnerabilities, as
    we saw in Chapter 8. And always remember that just because you can’t see how to
    exploit a bug, that by no means proves that a determined attacker won’t.    ###
    DREAD Assessments    In the rare case that your team does not quickly reach consensus
    on fixing a bug, make a structured assessment of the risk it represents. The *DREAD
    model*, originally conceived by Jason Taylor and evangelized by both of us at
    Microsoft, is a simple tool for evaluating the risk of a specific threat. DREAD
    enumerates five aspects of the risk that a vulnerability exposes:    **Damage
    potential**    1.  If exploited, how harmful could it be?    **Reproducibility**    1.  Will
    attacks succeed every time, some of the time, or only rarely?    **Exploitability**    1.  How
    hard, in terms of technical difficulty, effort, and cost, is the vulnerability
    to exploit? How long is the attack path?    **Affected users**    1.  Will all,
    some, or only a few users be impacted? Can specific targets be easily attacked,
    or are the victims arbitrary?    **Discoverability**    1.  How likely is it that
    attackers will find the vulnerability?    In my experience, it works best to think
    of DREAD ratings in terms of five independent dimensions. Personally, I do not
    recommend assigning a numerical score to each, because severity is not very linear.
    My preferred method is to use T-shirt sizes (S, M, L, XL) to represent subjective
    magnitudes, as the following example illustrates. If you do use numerical scores,
    I would specifically discourage adding up the five scores to get a total to use
    for ranking one threat against another, as this is essentially comparing apples
    to oranges. Unless several of the factors have fairly low DREAD scores, consider
    the threat a significant one likely worth mitigating.    If the issue requires
    a triage meeting to resolve, use DREAD to present your case. Discuss the individual
    factors as needed to get a clear view of the consequences of the vulnerability.
    Often, when one component scores low, the debate will focus on what that means
    to the overall impact.    Let’s see how DREAD works in practice. Pretend we’ve
    just discovered the Heartbleed bug and want to make a DREAD rating for it. Recall
    that this vulnerability lets anonymous attackers send malicious Heartbeat requests
    and receive back large chunks of the web server’s memory.    Here is a quick DREAD
    scoring of the information leakage threat:    **Damage potential: XL**    1.  Internal
    memory of the server potentially discloses secret keys.    **Reproducibility:
    M**    1.  Leaked memory contents will vary due to many factors and will be innocuous
    in some cases, but unpredictable.    **Exploitability: L**    1.  An anonymous
    attacker needs only send a simple request packet; extracting useful secrets takes
    a little expertise and then some luck.    **Affected users: XL**    1.  The server
    and all users are at risk.    **Discoverability: L**    1.  It depends on whether
    the idea occurs to an attacker (obvious once publicly announced); it’s easily
    tried and confirmed.    This DREAD rating is subjective because in our scenario,
    there has not been time to investigate the vulnerability much beyond a quick confirmation
    of the bug. Suppose that we have seen a server key disclosed (hence, Damage potential
    is XL), but that in repeated tests the memory contents varied greatly, suggesting
    the M Reproducibility rating. Discoverability is particularly tricky: How do you
    measure the likelihood of someone thinking to even try this? I would argue that
    if you’ve thought of this, then it’s best to assume others will too before long.    Discussions
    of DREAD scores are a great way to tease out the nuances of these judgments. When
    you get into a discussion, listen carefully and give due consideration to other
    opinions. Heartbleed is among the worst vulnerabilities in history, yet we didn’t
    rate all of its DREAD factors at the maximum, serving as a good demonstration
    of why ratings must be carefully interpreted. Since this flaw occurred in code
    running on millions of web servers and undermined the security of HTTPS, you could
    say that the Damage potential and Affected users scores were actually off the
    charts (say, XXXXXXXL), more than making up for the few moderate ratings. The
    value of DREAD ratings is in revealing the relative importance of different aspects
    of a vulnerability, providing a clear view of the risk it represents.    ### Crafting
    Working Exploits    Constructing a working proof-of-concept attack is the strongest
    way to make the case to fix a vulnerability. For some bugs the attack is obvious,
    and when it’s easy to code up the exploit, that seals the deal. However, in my
    opinion this is rarely necessary, for a couple of reasons. For starters, crafting
    a demonstration exploit usually involves a lot of work. Actual working exploits
    often require a lot of refinement after you’ve identified the underlying vulnerability.
    More importantly, even if you are an experienced penetration tester, just because
    you fail to create a functional exploit, that is by no means proof that the vulnerability
    is not exploitable.    This is a controversial topic, but my take is that for
    all these reasons it’s difficult to justify the effort of creating a working exploit
    for the purpose of addressing a security vulnerability. That said, by all means
    write a regression test (as discussed in Chapter 12) that will trigger the bug
    directly, even if it isn’t a full-fledged working attack.    ### Making Triage
    Decisions    When using DREAD, or doing any vulnerability assessment for that
    matter, bear in mind that it’s far easier to underestimate, rather than overestimate,
    actual threats. Noticing a potential vulnerability and taking no action can be
    a tragic mistake, and one that’s obviously best avoided. I’ve lost a few of those
    battles and can assure you that there is no satisfaction in saying “I told you
    so” after the fact. Failing to fix significant flaws is a Russian roulette game
    not worth playing: “just fix it” is a great standing policy.    Here are some
    general rules of thumb for making better security triage decisions:    *   Bugs
    in privileged code, or code that accesses valuable assets, should be fixed and
    then carefully tested to guard against the introduction of new bugs. *   Bugs
    that are well isolated from any attack surface and seem harmless are usually safe
    to defer. *   Carefully confirm claims that a bug is harmless: it may be easier
    to fix the bug than to accurately assess its full potential impact. *   Aggressively
    fix bugs that could be part of vulnerability chains (discussed in Chapter 8).
    *   Finally, when it’s a toss-up, I always advise fixing the issue: better safe
    than sorry.    When more research is needed, assign someone to investigate the
    issue and report back with a proposal; don’t waste time debating hypotheticals.
    In discussions, focus on understanding other perspectives rather than trying to
    change minds. Trust your intuition. With practice, when you know what to focus
    on, this will quickly become easier.    ## Maintaining a Secure Development Environment    >
    The secret of landscapes isn’t creation. . . .It’s maintenance. >  > —Michael
    Dolan    Good hygiene is a useful analogy: to produce a safe food product, manufacturers
    need fresh ingredients from trustworthy suppliers, a sanitary working environment,
    sterilized tools, and so forth. Similarly, good security practices must be observed
    throughout the entire development process for the resulting product to be secure.    Malicious
    code can slip into the product due to even a one-time lapse during development,
    a fact which should give you pause. The last thing that developers want is for
    their software to become a vector for malware.    ### Separating Development from
    Production    Strictly separate your development and production environments,
    if you aren’t doing this already. The core idea is to provide a “wall” between
    the two, typically consisting of separate subnetworks, or at least mutually exclusive
    access permission regimes. That is, when developing software, the programmer should
    not have access to production data. Nor should production machines and operations
    staff have access to the development environment and source code (write access).
    In smaller shops, where one person handles both production and development, you
    can switch between user accounts. The inconvenience of switching is more than
    compensated for by saving the product from even a single mistake. Plus, it provides
    peace of mind.    ### Securing Development Tools    Carefully vet development
    tools and library code before installing and using them. Some minor utility downloaded
    from “somewhere,” even for a one-time use, could bring more trouble than it’s
    worth. Consider setting up a safely isolated sandbox for experiments or odd jobs
    not part of the core development process. This is easily done with a virtual machine.    All
    computers involved in development must be secure if the result is to be secure.
    So must all source code repositories and other services, as these are all potential
    openings for vulnerabilities to creep into the final product. In fact, it goes
    deeper: all operating systems, compilers, and libraries involved in the process
    of development must also be secure. It’s a daunting challenge, and it may sound
    almost impossible, but fortunately perfection is not the goal. You must recognize
    these risks first, then find opportunities to make incremental improvements.    The
    best way to mitigate these risks is by threat modeling the development environment
    and processes. Analyze the attack surface for a range of threats, treating the
    source code as your primary asset. Basic mitigations for typical development work
    include:    *   Securely configure and regularly update development computers.
    *   Restrict personal use of computers used for development. *   Systematically
    review new components and dependencies. *   Securely administer computers used
    for the build and release processes. *   Securely manage secrets (such as code
    signing keys). *   Secure login credential management with strong authentication.
    *   Regularly audit source change commits for anomalous activity. *   Keep secure
    backup copies of source code and the build environment.    ### Releasing the Product    Use
    a formal release process to bridge development and production. This can happen
    through a shared repository that only development staff can modify, and that operations
    staff can only read. This Separation of Duty ensures that the responsibilities
    of the respective parties are not only clear but enforced, essentially rendering
    impossible solo “cowboy” efforts to make quick code changes and then push the
    new version into production, where security flaws are easily introduced, without
    going through approved channels.``*'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE46]  ``# 13 安全开发最佳实践    > 他们说没有人是完美的。然后他们告诉你练习使人完美。我希望他们能明确自己的想法。 >  >
    —温斯顿·丘吉尔  ![](image_fi/book_art/chapterart.png)  到目前为止，在第三部分，我们已经调查了在开发阶段出现的一系列安全漏洞。在本章中，我们将重点讨论开发过程本身与安全相关的方面以及可能出现的问题。我们将首先讨论代码质量：良好的代码卫生、彻底的错误和异常处理、记录安全属性以及代码审查在促进安全方面的作用。其次，我们将看看处理依赖关系：特别是它们如何将漏洞引入系统。我们将涵盖的第三个领域是错误分类——这是一项平衡安全与其他急需之间的关键技能。最后，安全开发取决于维护一个安全的工作环境，因此我提供了一些基本提示，告诉你需要做些什么来避免被入侵。    由于实际原因，接下来的指导是通用的。读者应该能够将其应用于自己的开发实践中。许多其他有效的技术是特定于编程语言、操作系统和给定系统的其他细节的。因此，重要的是你认识到以下讨论中的大模式，但也要警惕在自己的工作中出现的其他与安全相关的问题和机会。    ##
    代码质量    > 质量永远是时尚。 >  > —罗伯特·根    第三部分的前几章解释了漏洞如何潜入代码，但在这里我想重点讨论一般错误与安全之间的关系。如果你能提高代码质量，无论你是否意识到这一点，你都会使其更加安全。所有的漏洞都是错误，因此更少的错误意味着更少的漏洞和漏洞链。但当然，在消除所有错误之前，收益递减会在很早之前出现，因此最好采取一种平衡的方法。    以下讨论涵盖了一些关注安全的关键领域。    ###
    代码卫生    程序员通常对他们正在处理的代码的质量有很好的感觉，但出于各种原因，他们经常选择接受已知缺陷而不是进行必要的改进。代码异味、意大利面代码和推迟的“TODO”注释标记的进一步工作都往往是漏洞的肥沃土壤。至少在安全特别关注的领域，识别和消除这些粗糙的边缘可能是避免漏洞的最佳方法之一，而无需进行任何安全分析即可看到漏洞可能如何被利用。    除了你对代码状况的本能感知之外，使用工具来标记这些问题也很重要。使用完整警告编译代码，然后修复代码以解决重要问题。一些自动警告，例如误导的缩进或没有执行路径的未使用代码，将识别我们在第8章和第12章中讨论的GotoFail漏洞，并进行了安全测试。Lint和其他静态代码分析工具提供了更丰富的代码审查，提供有时会揭示错误和漏洞的提示。    代码分析并不总是将安全漏洞识别为这样，因此你必须扩大范围。在开发过程中经常使用这些工具，以降低潜在漏洞的总数。这样，如果工具的输出发生显著变化，你就有更好的机会注意到它，因为新内容不会在大量旧消息中丢失。    如果容易做到的话，修复所有警告，或者当你发现问题可能严重时。例如，无法访问的代码表明尽管有人出于某种原因编写了代码，但现在已经不在画面中了，这是不对的。另一方面，关于变量命名约定的警告，虽然是好建议，但可能与任何安全漏洞无关。    找时间进行这种清理总是具有挑战性的。采取逐步的方法；即使每周只有一两个小时，随着时间的推移会产生很大的差异，这个过程是熟悉大型代码库的好方法。如果所有警告太多而无法处理，请从最有希望的警告开始（例如，GCC的`-Wmisleading-indentation`），然后修复被标记的问题。    ###
    异常和错误处理    1996年阿丽亚娜5号501航班失败报告痛苦地详细描述了异常处理不当的后果。虽然灾难性的错误纯粹是自我造成的，没有涉及恶意行为，但它作为一个例子展示了攻击者如何利用结果行为来危害系统。    阿丽亚娜5号飞船发射后不久，一个计算中的浮点到整数转换引发了异常。异常处理机制触发了，但由于转换错误是意外的，异常处理程序代码没有为这种情况做好准备。代码关闭了发动机，导致飞行36.7秒后发生灾难性故障。    防范这类问题的方法始于认识到草率的异常处理的风险，然后仔细考虑即使是最不可能的异常的正确响应。一般来说，最好在可能的情况下尽早处理异常，因为在源头处理异常时有最多的上下文和最短的时间窗口来避免进一步的复杂情况。    也就是说，大型系统可能需要一个顶层处理程序来处理任何未处理的异常。一个很好的方法是识别一个行动单元并完全失败。例如，Web服务器可能会在HTTP请求期间捕获异常并返回一个通用的500（服务器错误）响应。通常，Web应用程序应该将改变状态的请求作为事务处理，以便任何错误总是导致没有状态更改。这避免了可能导致系统处于脆弱状态的部分更改。    将与潜在漏洞相关的许多推理也适用于一般的错误处理。与异常一样，错误情况可能很少发生，因此开发人员很容易忘记它们，使它们不完整或未经测试。攻击者发现漏洞的常见技巧是尝试引发某种错误，然后观察代码在希望发现弱点的情况下的行为。因此，最好的防御措施是从一开始就实施可靠的错误处理。这是安全漏洞与其他错误不同的一个经典例子：在正常使用中，某些错误可能极为罕见，但在有组织的攻击的背景下，调用错误可能是一个明确的目标。    要正确处理错误和异常处理，测试非常重要。确保所有代码路径都有测试覆盖，特别是不常见的路径。监视生产中的异常日志并追踪其原因，以确保异常恢复正常。积极调查和修复间歇性异常，因为如果一个聪明的攻击者学会如何触发一个异常，他们可能能够从那里将其微调为恶意利用。    ###
    记录安全    当你编写具有重要安全后果的代码时，你需要在注释中解释你的决定有多少，以便其他人（或者你自己忘记了几个月或几年后）不会意外破坏它。    对于关键代码，或者安全影响值得解释的地方，注释是重要的，因为它允许任何考虑更改代码的人了解风险。当你写有关安全的注释时，解释安全影响并具体说明：简单地写`//
    小心：安全后果`并不是一个解释。要清晰并且切中要点：包含太多废话，人们要么会忽略它，要么放弃。回想我们在第9章和第12章讨论的Heartbleed漏洞，一个好的注释会解释拒绝使用超出实际提供数据的字节计数的无效请求是至关重要的，因为这可能导致泄露超出缓冲区范围的私人数据。如果安全分析变得太复杂而无法在注释中解释，请将详细信息写在单独的文档中，然后提供对该文档的引用。    这并不意味着你应该尝试标记所有安全依赖的代码。相反，目标是警告读者关于未来可能被轻视的不明显问题。最终，注释不能完全替代对安全影响不断保持警惕的有经验的编码人员，这就是为什么这些工作并不容易。    编写一个好的安全测试用例（如第12章所述）是支持文档的理想方式，以防止其他人在未来更改中无意中破坏安全。作为攻击看起来像的工作原型，这样的测试不仅可以防止意外的不利变化，还可以准确显示代码可能出错的地方。    ###
    安全代码审查    专业软件开发过程包括同行代码审查作为标准实践，我想要为明确包括安全在这些审查中做出论据。通常最好在代码审查工作流程中的一个步骤中进行，与审查人员应该注意的潜在问题清单一起，包括代码正确性、可读性、风格等。    我建议同一个代码审查员在第一次阅读代码后添加一个明确的步骤来考虑安全性，然后再次审查代码时戴上他们的“安全帽”。如果审查人员觉得无法涵盖安全性，他们应该将这部分委托给有能力的人。当然，对于明显没有安全影响的代码更改，你可以跳过这一步。    为了安全审查代码更改，与SDR（第7章的主题）不同，你正在查看一个系统的一个狭窄子集，而不是审查整个设计时获得的整体视图。确保考虑代码如何处理一系列不受信任的输入，检查任何输入验证是否健壮，并避免潜在的混淆副手问题。当然，对于安全至关重要的代码应该得到额外关注，并且通常值得更高的质量门槛。将额外的一双眼睛聚焦在代码的安全性上有很大潜力来改善整个系统。    代码审查也是确保已创建的安全测试用例（如第12章所述）足够的绝佳机会。作为审查人员，如果你假设某些输入可能有问题，编写一个安全测试用例并查看结果，而不是猜测。如果你的探索性测试用例揭示了一个漏洞，提出问题并贡献测试用例以确保它得到修复。    ##
    依赖关系    > 依赖导致服从。 >  > —托马斯·杰斐逊    现代系统往往建立在大量外部组件的基础上。这些依赖关系在多方面都存在问题。许多平台，如`npm`，自动拉取许多难以跟踪的依赖关系。使用已知漏洞的旧版本外部代码是业界尚未系统消除的最大持续威胁之一。此外，存在在软件供应链中拾取恶意组件的风险。这可以通过几种方式发生；例如，使用与知名组件类似名称的软件包可能会被错误选择，你可以通过其他组件间接地通过它们的依赖关系获得恶意软件。    向系统添加组件可能会损害安全，即使这些组件旨在加强安全性。你必须信任不仅组件的来源，还要信任源代码信任的一切。除了额外代码带来的增加错误和整体复杂性的不可避免的风险外，组件还可能以意想不到的新方式扩展攻击面。二进制分发几乎是不透明的，但即使有源代码和文档，仔细审查和理解包中的所有内容通常是不可行的，因此通常归结为盲目信任。防病毒软件可以检测和阻止恶意软件，但它也使用深入系统的普遍钩子，需要超级用户访问权限，并且可能增加攻击面，例如当它打电话回家获取最新的恶意软件数据库并报告发现时。选择一个易受攻击的组件可能最终降低安全性，即使你的意图是增加额外的防御层。    ###
    选择安全组件    为了整个系统安全，每个组件都必须是安全的。此外，它们之间的接口必须是安全的。在选择安全组件时，考虑以下一些基本因素：    *   组件本身和其制造商的安全记录如何？
    *   组件的接口是专有的，还是有兼容的替代品？（更多选择可能提供更安全的替代品。） *   当（而不是如果）在组件中发现安全漏洞时，你有信心其开发人员会迅速做出反应并发布修复吗？
    *   保持组件最新的操作成本（换句话说，努力、停机'
