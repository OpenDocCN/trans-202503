- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Advanced Arithmetic
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高级算术
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter covers extended-precision arithmetic, arithmetic on operands whose
    sizes are different, and decimal arithmetic. By the conclusion of this chapter,
    you will know how to apply arithmetic and logical operations to integer operands
    of any size, including those larger than 64 bits, and how to convert operands
    of different sizes into a compatible format. Finally, you’ll learn to perform
    decimal arithmetic by using the x86-64 BCD instructions on the x87 FPU, which
    lets you use decimal arithmetic in those few applications that absolutely require
    base-10 operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了扩展精度算术、不同大小操作数的算术运算以及十进制算术。通过本章的学习，你将知道如何对任何大小的整数操作数进行算术和逻辑运算，包括那些大于64位的操作数，并且如何将不同大小的操作数转换为兼容格式。最后，你将学习如何使用x86-64
    BCD指令在x87 FPU上执行十进制算术，这使你能够在那些确实需要基数为10的操作的应用中使用十进制算术。
- en: 8.1 Extended-Precision Operations
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 扩展精度运算
- en: 'One big advantage of assembly language over high-level languages is that assembly
    language does not limit the size of integer operations. For example, the standard
    C programming language defines three integer sizes: `short int`, `int`, and `long
    int`.^([1](#c08-footnote-1)) On the PC, these are often 16- and 32-bit integers.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言相对于高级语言的一个大优势是，汇编语言不限制整数运算的大小。例如，标准的C编程语言定义了三种整数大小：`short int`、`int`和`long
    int`。^([1](#c08-footnote-1)) 在PC上，这些通常是16位和32位整数。
- en: Although the x86-64 machine instructions limit you to processing 8-, 16-, 32-,
    or 64-bit integers with a single instruction, you can use multiple instructions
    to process integers of any size. If you want to add 256-bit integer values together,
    it’s no problem. This section describes how to extend various arithmetic and logical
    operations from 16, 32, or 64 bits to as many bits as you please.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管x86-64的机器指令限制你只能使用单条指令处理8位、16位、32位或64位整数，但你可以使用多条指令处理任何大小的整数。如果你想将256位整数相加，也不成问题。本节将介绍如何将各种算术和逻辑操作从16位、32位或64位扩展到任意位数。
- en: 8.1.1 Extended-Precision Addition
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 扩展精度加法
- en: The x86-64 `add` instruction adds two 8-, 16-, 32-, or 64-bit numbers. After
    the execution of `add`, the x86-64 carry flag is set if you have an overflow out
    of the HO bit of the sum. You can use this information to do extended-precision
    addition operations.^([2](#c08-footnote-2)) Consider the way you manually perform
    a multiple-digit addition operation (as shown in [Figure 8-1](#figure8-1)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64的`add`指令将两个8位、16位、32位或64位的数字相加。执行`add`后，如果和的最高位（HO位）溢出，x86-64的进位标志将被设置。你可以利用这一信息执行扩展精度加法操作。^([2](#c08-footnote-2))
    请考虑你手动执行多位数加法操作的方式（如图8-1所示）。
- en: '![f08001](image_fi/501089c08/f08001.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![f08001](image_fi/501089c08/f08001.png)'
- en: 'Figure 8-1: Multi-digit addition'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1：多位数相加
- en: The x86-64 handles extended-precision arithmetic the same way, except instead
    of adding the numbers a digit at a time, it adds them together a byte, word, double
    word, or quad word at a time. Consider the three-quad-word (192-bit) addition
    operation in [Figure 8-2](#figure8-2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64处理扩展精度算术的方式与此相同，不同的是它不是每次添加一个数字，而是每次添加一个字节、字、双字或四字。考虑图8-2中的三个四字（192位）加法操作。
- en: '![f08002](image_fi/501089c08/f08002.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![f08002](image_fi/501089c08/f08002.png)'
- en: 'Figure 8-2: Adding two 192-bit objects together'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-2：将两个192位对象相加
- en: 'As you can see, the idea is to break a larger operation into a sequence of
    smaller ones. Since the x86 processor family is capable of adding together at
    most 64 bits at a time (using general-purpose registers), the operation must proceed
    in blocks of 64 bits or fewer. Here are the steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，基本思路是将一个较大的操作分解为一系列较小的操作。由于x86处理器系列每次最多能相加64位（使用通用寄存器），因此该操作必须以64位或更少的块进行。以下是步骤：
- en: Add the two LO quad words together just as you would add the two LO digits of
    a decimal number together in the manual algorithm, using the `add` instruction.
    If there is a carry out of the LO addition, `add` sets the carry flag to `1`;
    otherwise, it clears the carry flag.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个低位四字相加，就像在手动算法中将两个低位数字相加一样，使用`add`指令。如果低位加法溢出，`add`会将进位标志设置为`1`；否则，它会清除进位标志。
- en: 'Add together the second pair of quad words in the two 192-bit values, plus
    the carry out of the previous addition (if any), using the `adc` (*add with carry*)
    instruction. The `adc` instruction uses the same syntax as `add` and performs
    almost the same operation:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`adc`（*带进位加法*）指令，将两个192位值中的第二对四字相加，并加上之前加法的进位（如果有的话）。`adc`指令与`add`指令的语法相同，几乎执行相同的操作：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The only difference is that `adc` adds in the value of the carry flag along
    with the source and destination operands. It sets the flags the same way `add`
    does (including setting the carry flag if there is an unsigned overflow). This
    is exactly what we need to add together the middle two double words of our 192-bit
    sum.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 唯一的区别是，`adc`会将进位标志的值与源操作数和目标操作数一起加进去。它设置标志与`add`相同（包括如果发生无符号溢出则设置进位标志）。这正是我们需要的，用来加在192位和的中间两个双字上。
- en: Add the HO double words of the 192-bit value with the carry out of the sum of
    the middle two quad words, once again using `adc`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`adc`再次将192位值的高位双字与中间两个四字之和的进位相加。
- en: To summarize, the `add` instruction adds the LO quad words together, and `adc`
    adds all other quad word pairs together. At the end of the extended-precision
    addition sequence, the carry flag indicates unsigned overflow (if set), a set
    overflow flag indicates signed overflow, and the sign flag indicates the sign
    of the result. The zero flag doesn’t have any real meaning at the end of the extended-precision
    addition (it simply means that the sum of the two HO quad words is 0 and does
    not indicate that the whole result is 0).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`add`指令将低位四字加在一起，而`adc`将所有其他四字对加在一起。在扩展精度加法序列结束时，进位标志指示无符号溢出（如果设置），溢出标志指示符号溢出，符号标志表示结果的符号。零标志在扩展精度加法结束时没有任何实际意义（它只是表示两个高位四字的和为0，并不表示整个结果为0）。
- en: 'For example, suppose that you have two 128-bit values you wish to add together,
    defined as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有两个128位的值需要相加，定义如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Suppose also that you want to store the sum in a third variable, `Z`, which
    is also an `oword`. The following x86-64 code will accomplish this task:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你还想将结果存储到第三个变量`Z`中，它也是一个`oword`。以下x86-64代码将完成此任务：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first three instructions add the LO quad words of `X` and `Y` together and
    store the result into the LO quad word of `Z`. The last three instructions add
    the HO quad words of `X` and `Y` together, along with the carry from the LO word,
    and store the result in the HO quad word of `Z`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前三条指令将`X`和`Y`的低位四字加在一起，并将结果存储到`Z`的低位四字中。最后三条指令将`X`和`Y`的高位四字加在一起，连同低位字的进位，并将结果存储到`Z`的高位四字中。
- en: Remember, `X`, `Y`, and `Z` are `oword` objects (128 bits), and an instruction
    of the form `mov rax, X` would attempt to load a 128-bit value into a 64-bit register.
    To load a 64-bit value, specifically the LO 64 bits, the `qword ptr` operator
    coerces symbols `X`, `Y`, and `Z` to 64 bits. To load the HO qwords, you use address
    expressions of the form `X[8]`, along with the `qword ptr` operator, because the
    x86 memory space addresses bytes, and it takes 8 consecutive bytes to form a quad
    word.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`X`、`Y`和`Z`是`oword`对象（128位），像`mov rax, X`这样的指令会尝试将128位值加载到64位寄存器中。要加载64位值，特别是低64位，`qword
    ptr`操作符会将符号`X`、`Y`和`Z`强制转换为64位。要加载高64位四字，你需要使用类似`X[8]`的地址表达式，并配合`qword ptr`操作符，因为x86内存空间按字节寻址，八个连续字节构成一个四字。
- en: 'You can extend this algorithm to any number of bits by using `adc` to add in
    the higher-order values. For example, to add together two 256-bit values declared
    as arrays of four quad words, you could use code like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`adc`将更高位的值加到一起，将这个算法扩展到任何位数。例如，要将声明为四个四字数组的两个256位值相加，你可以使用如下代码：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 8.1.2 Extended-Precision Subtraction
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 扩展精度减法
- en: Just as it does addition, the x86-64 performs multi-byte subtraction the same
    way you would manually, except it subtracts whole bytes, words, double words,
    or quad words at a time rather than decimal digits. You use the `sub` instruction
    on the LO byte, word, double word, or quad word and the `sbb` (*subtract with
    borrow*) instruction on the high-order values.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就像它进行加法一样，x86-64也以相同的方式进行多字节减法，除非它一次减去的是完整的字节、字、双字或四字，而不是十进制数字。你对低位字节、字、双字或四字使用`sub`指令，并对高位值使用`sub`与借位指令`sbb`（*带借位减法*）。
- en: 'The following example demonstrates a 128-bit subtraction using the 64-bit registers
    on the x86-64:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了一个使用x86-64上的64位寄存器的128位减法：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example demonstrates a 256-bit subtraction:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了一个256位减法：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 8.1.3 Extended-Precision Comparisons
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 扩展精度比较
- en: Unfortunately, there isn’t a “compare with borrow” instruction that you can
    use to perform extended-precision comparisons. Fortunately, you can compare extended-precision
    values by using just a `cmp` instruction, as you’ll soon see.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有“与借位比较”指令可以用来执行扩展精度比较。幸运的是，你可以通过仅使用`cmp`指令来比较扩展精度值，正如你将很快看到的那样。
- en: Consider the two unsigned values 2157h and 1293h. The LO bytes of these two
    values do not affect the outcome of the comparison. Simply comparing the HO bytes,
    21h with 12h, tells us that the first value is greater than the second.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个无符号值2157h和1293h。这两个值的低字节不会影响比较结果。只需比较高字节，即21h和12h，我们就可以知道第一个值大于第二个值。
- en: 'You need to look at both bytes of a pair of values only if the HO bytes are
    equal. In all other cases, comparing the HO bytes tells you everything you need
    to know about the values. This is true for any number of bytes, not just two.
    The following code compares two signed 128-bit integers by comparing their HO
    quad words first and comparing their LO quad words only if the HO quad words are
    equal:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要在一对值的高字节相等时，查看这对值的两个字节。在所有其他情况下，比较高字节就足以告诉你这些值的一切。对于任意数量的字节，情况都是如此，而不仅仅是两个字节。以下代码通过首先比较它们的高四字（quad
    word）来比较两个有符号的128位整数，只有在高四字相等的情况下，才会比较它们的低四字：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To compare unsigned values, use the `ja` and `jb` instructions in place of `jg`
    and `jl`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较无符号值，可以使用`ja`和`jb`指令来代替`jg`和`jl`。
- en: 'You can synthesize any comparison from the preceding sequence, as shown in
    the following examples that demonstrate signed comparisons; just substitute `ja`,
    `jae`, `jb`, and `jbe` for `jg`, `jge`, `jl`, and `jle` (respectively) if you
    want unsigned comparisons. Each of the following examples assumes these declarations:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过前述序列合成任何比较，如下所示，演示了有符号比较；如果你想进行无符号比较，只需将`jg`、`jge`、`jl`和`jle`分别替换为`ja`、`jae`、`jb`和`jbe`。以下每个示例假设有这些声明：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code implements a 128-bit test to see if `OW1 < OW2` (signed).
    Control transfers to the `IsLess` label if `OW1 < OW2`. Control falls through
    to the next statement if this is not true:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了一个128位测试，检查`OW1 < OW2`（有符号）。如果`OW1 < OW2`，控制会转移到`IsLess`标签。如果不成立，控制会继续执行下一条语句：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is a 128-bit test to see if `OW1 <= OW2` (signed). This code jumps to
    `IsLessEq` if the condition is true:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个128位测试，检查`OW1 <= OW2`（有符号）。如果条件成立，程序会跳转到`IsLessEq`：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a 128-bit test to see if `OW1 > OW2` (signed). It jumps to `IsGtr`
    if this condition is true:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个128位测试，检查`OW1 > OW2`（有符号）。如果此条件成立，程序会跳转到`IsGtr`：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is a 128-bit test to see if `OW1 >= OW2` (signed). This code
    jumps to label `IsGtrEQ` if this is the case:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个128位测试，检查`OW1 >= OW2`（有符号）。如果成立，代码会跳转到标签`IsGtrEQ`：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is a 128-bit test to see if `OW1 == OW2` (signed or unsigned). This code
    branches to the label `IsEqual` if `OW1 == OW2`. It falls through to the next
    instruction if they are not equal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个128位测试，检查`OW1 == OW2`（有符号或无符号）。如果`OW1 == OW2`，代码会跳转到标签`IsEqual`。如果它们不相等，程序会继续执行下一条指令：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is a 128-bit test to see if `OW1 != OW2` (signed or unsigned).
    This code branches to the label `IsNotEqual` if `OW1 != OW2`. It falls through
    to the next instruction if they are equal:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个128位测试，检查`OW1 != OW2`（有符号或无符号）。如果`OW1 != OW2`，该代码会跳转到标签`IsNotEqual`。如果它们相等，则继续执行下一条指令：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To generalize the preceding code for objects larger than 128 bits, start the
    comparison with the objects’ HO quad words and work your way down to their LO
    quad words, as long as the corresponding double words are equal. The following
    example compares two 256-bit values to see if the first is less than or equal
    (unsigned) to the second:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将前述代码推广到大于128位的对象，首先从对象的高四字开始比较，然后逐步比较它们的低四字，只要相应的双字（double word）相等。以下示例比较了两个256位值，检查第一个值是否小于或等于（无符号）第二个值：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 8.1.4 Extended-Precision Multiplication
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.4 扩展精度乘法
- en: Although an 8×8-, 16×16-, 32×32-, or 64×64-bit multiplication is usually sufficient,
    sometimes you may want to multiply larger values. You use the x86-64 single-operand
    `mul` and `imul` instructions for extended-precision multiplication operations,
    using the same techniques that you employ when manually multiplying two values.
    Consider the way you perform multi-digit multiplication by hand ([Figure 8-3](#figure8-3)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 8×8、16×16、32×32 或 64×64 位乘法通常已经足够，但有时你可能需要将更大的值相乘。你可以使用 x86-64 单操作数的 `mul`
    和 `imul` 指令进行扩展精度乘法操作，使用你在手动乘法时采用的相同技术。考虑一下你手动执行多位数乘法的方式（[图 8-3](#figure8-3)）。
- en: '![f08003](image_fi/501089c08/f08003.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![f08003](image_fi/501089c08/f08003.png)'
- en: 'Figure 8-3: Multi-digit multiplication'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：多位数乘法
- en: The x86-64 does extended-precision multiplication in the same manner except
    that it works with bytes, words, double words, and quad words rather than digits,
    as shown in [Figure 8-4](#figure8-4).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 在执行扩展精度乘法时使用相同的方法，唯一的区别是它处理的是字节、字、双字和四字，而不是数字，如 [图 8-4](#figure8-4) 所示。
- en: Probably the most important thing to remember when performing an extended-precision
    multiplication is that you must also perform an extended-precision addition at
    the same time. Adding up all the partial products requires several additions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 执行扩展精度乘法时，最重要的一点是你还必须同时执行扩展精度加法。将所有部分积相加需要多次加法。
- en: '![f08004](image_fi/501089c08/f08004.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![f08004](image_fi/501089c08/f08004.png)'
- en: 'Figure 8-4: Extended-precision multiplication'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4：扩展精度乘法
- en: '[Listing 8-1](#listing8-1) demonstrates how to multiply two 64-bit values (producing
    a 128-bit result) by using 32-bit instructions. Technically, you can do a 64-bit
    multiplication with a single instruction, but this example demonstrates a method
    you can easily extend to 128 bits by using the x86-64 64-bit registers rather
    than the 32-bit registers.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](#listing8-1) 演示了如何使用 32 位指令将两个 64 位值相乘（得到一个 128 位结果）。从技术上讲，你可以使用单条指令执行
    64 位乘法，但这个例子展示了一种方法，你可以通过使用 x86-64 的 64 位寄存器，而不是 32 位寄存器，轻松地将其扩展到 128 位。'
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 8-1: Extended-precision multiplication'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-1：扩展精度乘法
- en: The code works only for unsigned operands. To multiply two signed values, you
    must note the signs of the operands before the multiplication, take the absolute
    value of the two operands, do an unsigned multiplication, and then adjust the
    sign of the resulting product based on the signs of the original operands. Multiplication
    of signed operands is left as an exercise for you.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码仅适用于无符号操作数。要将两个带符号值相乘，你必须在乘法前注意操作数的符号，取两个操作数的绝对值，进行无符号乘法，然后根据原始操作数的符号调整结果积的符号。带符号操作数的乘法留给你自己完成。
- en: The example in [Listing 8-1](#listing8-1) was fairly straightforward because
    it was possible to keep the partial products in various registers. If you need
    to multiply larger values together, you will need to maintain the partial products
    in temporary (memory) variables. Other than that, the algorithm that [Listing
    8-1](#listing8-1) uses generalizes to any number of double words.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](#listing8-1) 中的示例相当直接，因为可以将部分积保存在不同的寄存器中。如果你需要将更大的值相乘，你将需要在临时（内存）变量中保存部分积。除此之外，[清单
    8-1](#listing8-1) 使用的算法可以推广到任意数量的双字。'
- en: 8.1.5 Extended-Precision Division
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.5 扩展精度除法
- en: You cannot synthesize a general *n*-bit / *m*-bit division operation by using
    the `div` and `idiv` instructions—though a less general operation, dividing an
    *n*-bit quantity by a 64-bit quantity can be done using the `div` instruction.
    A generic extended-precision division requires a sequence of shift and subtract
    instructions (which takes quite a few instructions and runs much slower). This
    section presents both methods (using `div` and shift and subtract) for extended-precision
    division.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能通过使用 `div` 和 `idiv` 指令合成一个通用的 *n*-位 / *m*-位除法操作——尽管一个较不通用的操作，将一个 *n*-位数除以一个
    64 位数，可以通过使用 `div` 指令完成。一个通用的扩展精度除法需要一系列的移位和减法指令（这需要相当多的指令，运行速度较慢）。本节介绍了两种方法（使用
    `div` 和移位减法）来进行扩展精度除法。
- en: 8.1.5.1 Special Case Form Using div Instruction
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.5.1 使用 div 指令的特殊情况形式
- en: Dividing a 128-bit quantity by a 64-bit quantity is handled directly by the
    `div` and `idiv` instructions, as long as the resulting quotient fits into 64
    bits. However, if the quotient does not fit into 64 bits, then you have to perform
    extended-precision division.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将128位数除以64位数是由`div`和`idiv`指令直接处理的，只要结果商能够适应64位寄存器。然而，如果商无法适应64位，则必须执行扩展精度除法。
- en: 'For example, suppose you want to divide 0004_0000_0000_1234h by 2\. The naive
    approach would look something like the following (assuming the value is held in
    a pair of qword variables named `dividend`, and `divisor` is a quad word containing
    2):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你要将0004_0000_0000_1234h除以2。天真直接的方法可能如下所示（假设值保存在名为`dividend`的一对四字变量中，`divisor`是一个包含2的四字变量）：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Although this code is syntactically correct and will compile, it will raise
    a divide error exception when run. The quotient must fit into the RAX register
    when using `div`, and 2_0000_091Ah will not fit, being a 66-bit quantity (try
    dividing by 8 if you want to see it produce a result that will fit).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码在语法上是正确的，并且可以编译，但在运行时会引发除法错误异常。使用`div`时，商必须适应RAX寄存器，而2_0000_091Ah无法适应，因为它是一个66位的数值（如果你想查看它产生适合的结果，可以尝试除以8）。
- en: 'Instead, the trick is to divide the (zero- or sign-extended) HO double word
    of the dividend by the divisor and then repeat the process with the remainder
    and the LO dword of the dividend, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，诀窍是将被除数的（零扩展或符号扩展的）高双字除以除数，然后使用余数和被除数的低双字重复此过程，如下所示：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `quotient` variable is 128 bits because it’s possible for the result to
    require as many bits as the dividend (for example, if you divide by 1). Regardless
    of the size of the `dividend` and `divisor` operands, the remainder is never larger
    than 64 bits (in this case). Hence, the `remainder` variable in this example is
    just a quad word.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`quotient`变量是128位，因为结果可能需要与被除数一样多的位数（例如，如果除以1）。无论`dividend`和`divisor`操作数的大小如何，余数最多只有64位（在这种情况下）。因此，本示例中的`remainder`变量只是一个四字。'
- en: To correctly compute the 128 / 64 quotient, begin by computing the 64 / 64 quotient
    of `dividend[8]` / `divisor`. The quotient from this first division becomes the
    HO double word of the final quotient. The remainder from this division becomes
    the extension in RDX for the second half of the division operation. The second
    half of the code divides `rdx:dividend[0]` by `divisor` to produce the LO quad
    word of the quotient and the remainder from the division. The code does not zero-extend
    RAX into RDX prior to the second `div` instruction, because RDX already contains
    valid bits that must not be disturbed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正确计算128 / 64的商，首先计算`dividend[8]` / `divisor`的64 / 64商。第一次除法得到的商成为最终商的高双字（HO
    double word）。此除法的余数成为RDX中的扩展，用于第二次除法操作的下半部分。代码的第二部分将`rdx:dividend[0]`除以`divisor`，以生成商的低四字（LO
    quad word）以及除法的余数。代码不会在第二个`div`指令之前将RAX零扩展到RDX，因为RDX已经包含了不能被干扰的有效位。
- en: 'The preceding 128 / 64 division operation is a special case of the general
    division algorithm to divide an arbitrary-size value by a 64-bit divisor. The
    general algorithm is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述128 / 64除法操作是通用除法算法的一个特例，用于将任意大小的值除以64位除数。通用算法如下：
- en: Move the HO quad word of the dividend into RAX and zero-extend it into RDX.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将被除数的高四字移动到RAX并将其零扩展到RDX。
- en: Divide by the divisor.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行除法操作。
- en: Store the value in RAX into the corresponding qword position of the quotient
    result variable (position of the dividend qword loaded into RAX prior to the division).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RAX中的值存储到商结果变量的相应四字位置（在除法之前加载到RAX中的被除数四字位置）。
- en: Load RAX with the next-lower quad word in the dividend, without modifying RDX.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RAX加载为被除数中的下一个低四字，不修改RDX。
- en: Repeat steps 2 to 4 until you’ve processed all the quad words in the dividend.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2到4，直到处理完被除数中的所有四字。
- en: At the end, the RDX register will contain the remainder, and the quotient will
    appear in the destination variable, where step 3 was storing the results. [Listing
    8-2](#listing8-2) demonstrates how to divide a 256-bit quantity by a 64-bit divisor,
    producing a 256-bit quotient and a 64-bit remainder.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，RDX寄存器将包含余数，商将出现在目标变量中，即步骤3存储结果的地方。[Listing 8-2](#listing8-2)展示了如何用64位除数除以256位数，从而得到一个256位商和一个64位余数。
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 8-2: Unsigned 128 / 32-bit extended-precision division'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-2：无符号128 / 32位扩展精度除法
- en: 'Here’s the build command and program output (note that you can verify that
    the division was correct by simply looking at the result, noting that each digit
    is one-half the original value):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和程序输出（请注意，你可以通过简单地查看结果来验证除法是否正确，注意每个数字是原始值的一半）：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can extend this code to any number of bits by adding additional `mov`-`div`-`mov`
    instructions to the sequence. Like the extended-precision multiplication in the
    previous section, this extended-precision division algorithm works only for unsigned
    operands. To divide two signed quantities, you must note their signs, take their
    absolute values, do the unsigned division, and then set the sign of the result
    based on the signs of the operands.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向序列中添加更多的 `mov`-`div`-`mov` 指令来扩展此代码以支持任意位数。像上一节的扩展精度乘法一样，这个扩展精度除法算法只适用于无符号操作数。要除以两个带符号的数，必须注意它们的符号，取它们的绝对值，进行无符号除法，然后根据操作数的符号设置结果的符号。
- en: 8.1.5.2 Generic N-bit by M-bit Division
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.5.2 通用 N 位除以 M 位
- en: To use a divisor larger than 64 bits, you have to implement the division by
    using a shift-and-subtract strategy, which works but is very slow. As with multiplication,
    the best way to understand how the computer performs division is to study how
    you were taught to do long division by hand. Consider the operation 3456 / 12
    and the steps you would take to manually perform this operation, as shown in [Figure
    8-5](#figure8-5).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用大于 64 位的除数，必须通过使用移位和减法策略来实现除法，这种方法有效，但非常慢。与乘法一样，理解计算机如何执行除法的最佳方式是研究你是如何学习手工做长除法的。考虑操作
    3456 / 12 以及你手动执行此操作时的步骤，如 [图 8-5](#figure8-5) 所示。
- en: '![f08005](image_fi/501089c08/f08005.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![f08005](image_fi/501089c08/f08005.png)'
- en: 'Figure 8-5: Manual digit-by-digit division operation'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5：手动逐位除法操作
- en: This algorithm is actually easier in binary because at each step you do not
    have to guess how many times 12 goes into the remainder, nor do you have to multiply
    12 by your guess to obtain the amount to subtract. At each step in the binary
    algorithm, the divisor goes into the remainder exactly 0 or 1 time. As an example,
    consider the division of 27 (11011) by 3 (11) that is shown in [Figure 8-6](#figure8-6).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法在二进制中实际上更容易，因为在每一步中，你不需要猜测 12 能被余数除几次，也不需要将 12 乘以你的猜测来得到要减去的数。在二进制算法的每一步中，除数要么正好除尽余数一次，要么不除尽。举个例子，考虑
    27（11011）除以 3（11）的除法，如 [图 8-6](#figure8-6) 所示。
- en: '![f08006](image_fi/501089c08/f08006.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![f08006](image_fi/501089c08/f08006.png)'
- en: 'Figure 8-6: Longhand division in binary'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-6：二进制长除法
- en: 'The following algorithm implements this binary division operation in a way
    that computes the quotient and the remainder at the same time:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法以同时计算商和余数的方式实现了这个二进制除法操作：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`NumberBits` is the number of bits in the `Remainder`, `Quotient`, `Divisor`,
    and `Dividend` variables. `SHL` is the left-shift operator. The `Quotient := Quotient
    + 1;` statement sets the LO bit of `Quotient` to `1` because this algorithm previously
    shifts `Quotient` 1 bit to the left. [Listing 8-3](#listing8-3) implements this
    algorithm.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberBits` 是 `Remainder`（余数）、`Quotient`（商）、`Divisor`（除数）和 `Dividend`（被除数）变量中的位数。`SHL`
    是左移操作符。`Quotient := Quotient + 1;` 语句将 `Quotient` 的最低有效位设置为 `1`，因为该算法之前将 `Quotient`
    左移了 1 位。[清单 8-3](#listing8-3) 实现了这个算法。'
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 8-3: Extended-precision division'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-3：扩展精度除法
- en: 'Here’s the build command and program output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和程序输出：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code does not check for division by 0 (it will produce the value 0FFFF_FFFF_FFFF_FFFFh
    if you attempt to divide by 0); it handles only unsigned values and is very slow
    (an order of magnitude or two worse than the `div` and `idiv` instructions). To
    handle division by 0, check the divisor against 0 prior to running this code and
    return an appropriate error code if the divisor is 0\. Dealing with signed values
    is the same as the earlier division algorithm: note the signs, take the operands’
    absolute values, do the unsigned division, and then fix the sign afterward.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有检查除数是否为 0（如果尝试除以 0，它会产生值 0FFFF_FFFF_FFFF_FFFFh）；它只处理无符号值，且非常慢（比 `div`
    和 `idiv` 指令慢一个或两个数量级）。要处理除以 0 的情况，在运行此代码之前检查除数是否为 0，如果除数为 0，则返回适当的错误代码。处理带符号值的方式与前面的除法算法相同：注意符号，取操作数的绝对值，进行无符号除法，然后在结果中修正符号。
- en: You can use the following technique to boost the performance of this division
    by a fair amount. Check to see if the divisor variable uses only 32 bits. Often,
    even though the divisor is a 128-bit variable, the value itself fits into 32 bits
    (that is, the HO double words of `Divisor` are 0) and you can use the `div` instruction,
    which is much faster. The improved algorithm is a bit more complex because you
    have to first compare the HO quad words for 0, but on average, it runs much faster
    while remaining capable of dividing any two pairs of values.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下技巧大幅提高这个除法的性能。检查除数变量是否仅使用32位。通常，尽管除数是一个128位变量，但它的值本身适合32位（即 `Divisor`
    的高双字为0），你可以使用 `div` 指令，它要快得多。改进后的算法稍微复杂一些，因为你首先需要比较高四字是否为0，但总体来说，它运行得更快，同时仍然能够除以任何两个值对。
- en: 8.1.6 Extended-Precision Negation Operations
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.6 扩展精度取反运算
- en: 'The `neg` instruction doesn’t provide a generic extended-precision form. However,
    a negation is equivalent to subtracting a value from 0, so we can easily simulate
    an extended-precision negation by using the `sub` and `sbb` instructions. The
    following code provides a simple way to negate a (320-bit) value by subtracting
    that value from 0, using an extended-precision subtraction:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`neg` 指令没有提供通用的扩展精度形式。然而，取反等同于从0中减去一个值，因此我们可以通过使用 `sub` 和 `sbb` 指令轻松地模拟扩展精度取反。以下代码提供了一种简单的方法，通过使用扩展精度减法将一个（320位）值从0中减去来实现取反：'
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A slightly more efficient way to negate smaller values (128 bits) uses a combination
    of `neg` and `sbb` instructions. This technique uses the fact that `neg` subtracts
    its operand from 0\. In particular, it sets the flags the same way the `sub` instruction
    would if you subtracted the destination value from 0\. This code takes the following
    form (assuming you want to negate the 128-bit value in RDX:RAX):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微更高效的方法来取反较小的值（128位）是使用 `neg` 和 `sbb` 指令的组合。这个技巧利用了 `neg` 将操作数从0中减去的事实。特别地，它设置标志位的方式与
    `sub` 指令将目标值从0中减去时相同。此代码的形式如下（假设你想要取反RDX:RAX中的128位值）：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first two instructions negate the HO and LO qwords of the 128-bit result.
    However, if there is a borrow out of the LO negation (think of `neg rax` as subtracting
    0 from RAX, possibly producing a carry/borrow), that borrow is not subtracted
    from the HO qword. The `sbb` instruction at the end of this sequence subtracts
    nothing from RDX if no borrow occurs when negating RAX; it subtracts 1 from RDX
    if a borrow was needed when subtracting 0 from RAX.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前两条指令对128位结果的高四字和低四字进行取反。然而，如果低四字取反时有借位（可以将 `neg rax` 看作是从RAX中减去0，可能会产生进位/借位），这个借位不会从高四字中减去。序列末尾的
    `sbb` 指令如果在取反RAX时没有发生借位，它不会从RDX中减去任何东西；如果取反时需要借位，它将从RDX中减去1。
- en: With a lot of work, it is possible to extend this scheme to more than 128 bits.
    However, around 256 bits (and certainly, once you get beyond 256 bits), it actually
    takes fewer instructions to use the general subtract-from-zero scheme.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 经过大量的工作，实际上可以将此方案扩展到超过128位。然而，在256位左右（当然，一旦超过256位），实际上使用从零减去的通用方案所需的指令更少。
- en: 8.1.7 Extended-Precision AND Operations
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.7 扩展精度与运算
- en: 'Performing an *n*-byte AND operation is easy: simply AND the corresponding
    bytes between the two operands, saving the result. For example, to perform the
    AND operation with all operands 128 bits long, you could use the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 *n* 字节与运算很简单：只需对两个操作数的相应字节进行与运算，并保存结果。例如，要对所有128位长的操作数执行与运算，你可以使用以下代码：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To extend this technique to any number of qwords, logically AND the corresponding
    bytes, words, double words, or quad words together in the operands.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此技巧扩展到任意数量的四字，你可以在操作数中逻辑地将相应的字节、字、双字或四字进行与运算。
- en: This sequence sets the flags according to the value of the last `and` operation.
    If you AND the HO quad words last, this sets all but the zero flag correctly.
    If you need to test the zero flag after this sequence, logically OR the two resulting
    double words together (or otherwise compare them both against 0).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列根据最后一次 `and` 运算的结果设置标志位。如果你最后对高四字进行与运算，这将正确地设置除了零标志之外的所有标志。如果你需要在这个序列之后测试零标志，可以对两个结果的双字进行逻辑或操作（或者将它们与0进行比较）。
- en: 8.1.8 Extended-Precision OR Operations
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.8 扩展精度或运算
- en: 'Multi-byte logical OR operations are performed in the same way as multi-byte
    AND operations. You OR the corresponding bytes in the two operands together. For
    example, to logically OR two 192-bit values, use the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 多字节的逻辑或（OR）操作与多字节与（AND）操作的执行方式相同。你将两个操作数中对应的字节进行按位或运算。例如，要对两个 192 位的值进行逻辑或运算，可以使用以下代码：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As in the previous example, this does not set the zero flag properly for the
    entire operation. If you need to test the zero flag after an extended-precision
    OR, you must logically OR all the resulting double words together.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，这样做不会为整个操作正确设置零标志。如果您需要在执行扩展精度的 OR 操作后测试零标志，必须将所有结果的双字进行逻辑 OR 运算。
- en: 8.1.9 Extended-Precision XOR Operations
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.9 扩展精度异或操作
- en: 'As with other logical operations, extended-precision XOR operations exclusive-ORs
    the corresponding bytes in the two operands to obtain the extended-precision result.
    The following code sequence operates on two 64-bit operands, computes their exclusive-or,
    and stores the result into a 64-bit variable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他逻辑操作一样，扩展精度的异或（XOR）操作会对两个操作数中的对应字节进行排他或运算，从而得到扩展精度的结果。以下代码序列对两个64位操作数进行运算，计算它们的异或结果，并将结果存储到一个64位变量中：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The comment about the zero flag in the previous two sections, as well as the
    comment about the XMM and YMM registers, apply here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个部分关于零标志的评论，以及关于 XMM 和 YMM 寄存器的评论，在此处同样适用。
- en: 8.1.10 Extended-Precision NOT Operations
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.10 扩展精度 NOT 操作
- en: 'The `not` instruction inverts all the bits in the specified operand. An extended-precision
    NOT is performed by executing the `not` instruction on all the affected operands.
    For example, to perform a 128-bit NOT operation on the value in RDX:RAX, execute
    the following instructions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`not` 指令会反转指定操作数中的所有位。通过在所有受影响的操作数上执行 `not` 指令来执行扩展精度的 NOT 操作。例如，要对 RDX:RAX
    中的值执行 128 位的 NOT 操作，请执行以下指令：'
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Keep in mind that if you execute the NOT instruction twice, you wind up with
    the original value. Also, exclusive-ORing a value with all 1s (0FFh, 0FFFFh, 0FFFF_FFFFh,
    or 0FFFF_FFFF_FFFF_FFFFh) performs the same operation as the `not` instruction.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果执行两次 NOT 指令，结果将返回原始值。此外，使用全 1（0FFh、0FFFFh、0FFFF_FFFFh 或 0FFFF_FFFF_FFFF_FFFFh）对一个值进行异或操作，所执行的操作与
    `not` 指令相同。
- en: 8.1.11 Extended-Precision Shift Operations
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.11 扩展精度移位操作
- en: Extended-precision shift operations require a shift and a rotate instruction.
    This section describes how to construct these operations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度移位操作需要移位和旋转指令。本节描述了如何构造这些操作。
- en: 8.1.11.1 Extended-Precision Shift Left
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.11.1 扩展精度左移
- en: A 128-bit `shl` (*shift left*) takes the form shown in [Figure 8-7](#figure8-7).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位的 `shl`（*左移*）操作的形式如[图 8-7](#figure8-7)所示。
- en: '![f08007](image_fi/501089c08/f08007.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![f08007](image_fi/501089c08/f08007.png)'
- en: 'Figure 8-7: 128-bit shift-left operation'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7：128 位左移操作
- en: To accomplish this with machine instructions, we must first shift the LO qword
    to the left (for example, using the `shl` instruction) and capture the output
    from bit 63 (conveniently, the carry flag does this for us). We must then shift
    this bit into the LO bit of the HO qword while simultaneously shifting all the
    other bits to the left (and capturing the output by using the carry flag).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过机器指令完成此操作，首先需要将低位四字（LO qword）左移（例如，使用 `shl` 指令），并将来自第 63 位的输出捕获（方便的是，进位标志会为我们完成此操作）。然后，我们必须将此位移入高位四字（HO
    qword）的低位，同时将其他所有位向左移（并通过进位标志捕获输出）。
- en: 'You can use the `shl` and `rcl` instructions to implement this 128-bit shift.
    For example, to shift the 128-bit quantity in RDX:RAX one position to the left,
    you’d use the following instructions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `shl` 和 `rcl` 指令来实现这种 128 位移位操作。例如，要将 RDX:RAX 中的 128 位数据左移一位，可以使用以下指令：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `shl` instruction shifts a 0 into bit 0 of the 128-bit operand and shifts
    bit 63 into the carry flag. The `rcl` instruction then shifts the carry flag into
    bit 64 and shifts bit 127 into the carry flag. The result is exactly what we want.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`shl` 指令会将一个 0 移入 128 位操作数的第 0 位，并将第 63 位移入进位标志。然后，`rcl` 指令将进位标志移入第 64 位，并将第
    127 位移入进位标志。最终结果正是我们所需要的。'
- en: Using this technique, you can shift an extended-precision value only 1 bit at
    a time. You cannot shift an extended-precision operand several bits by using the
    CL register, nor can you specify a constant value greater than 1 when using this
    technique.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此技术，您每次只能将扩展精度的值移动 1 位。您不能使用 CL 寄存器将扩展精度操作数移动多个位，也不能在使用此技术时指定大于 1 的常数值。
- en: 'To perform a shift left on an operand larger than 128 bits, use additional
    `rcl` instructions. An extended-precision shift-left operation always starts with
    the least-significant quad word, and each succeeding `rcl` instruction operates
    on the next-most-significant double word. For example, to perform a 192-bit shift-left
    operation on a memory location, you could use the following instructions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要对大于128位的操作数执行左移操作，请使用额外的`rcl`指令。扩展精度左移操作始终从最低有效的四字（quad word）开始，每个随后的`rcl`指令作用于下一个更高有效位的双字（double
    word）。例如，要对一个内存位置执行192位的左移操作，可以使用以下指令：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you need to shift your data by 2 or more bits, you can either repeat the
    preceding sequence the desired number of times (for a constant number of shifts)
    or place the instructions in a loop to repeat them a certain number of times.
    For example, the following code shifts the 192-bit value `Operand` to the left
    by the number of bits specified in CL:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将数据移位2位或更多位，可以选择重复前述的指令序列所需的次数（对于常数移位次数）或将这些指令放入循环中，以一定次数重复执行它们。例如，以下代码将192位的值`Operand`左移CL指定的位数：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 8.1.11.2 Extended-Precision Shift Right and Shift Arithmetic Right
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.11.2 扩展精度右移和算术右移
- en: 'You implement `shr` (*shift right*) and `sar` (*shift arithmetic right*) in
    a similar way, except you must start at the HO word of the operand and work your
    way down to the LO word:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`shr`（*右移*）和`sar`（*算术右移*）的方式类似，唯一的不同是你必须从操作数的最高有效字（HO word）开始，并逐步移至最低有效字（LO
    word）：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The extended-precision shifts set the flags differently than their 8-, 16-,
    32-, and 64-bit counterparts, because the rotate instructions affect the flags
    differently than the shift instructions. Fortunately, the carry flag is the one
    you’ll test most often after a shift operation, and the extended-precision shift
    operations (that is, rotate instructions) properly set this flag.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度移位会以不同于8位、16位、32位和64位对应指令的方式设置标志，因为旋转指令与移位指令对标志的影响不同。幸运的是，进位标志是你在移位操作后最常检查的标志，而扩展精度移位操作（即旋转指令）会正确设置此标志。
- en: 8.1.11.3 Efficient Multi-bit Extended-Precision Shifts
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.11.3 高效的多比特扩展精度移位
- en: 'The `shld` and `shrd` instructions let you efficiently implement extended-precision
    shifts of several bits. These instructions have the following syntax:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`shld`和`shrd`指令让你能够高效地实现多位扩展精度移位。这些指令具有以下语法：'
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `shld` instruction works as shown in [Figure 8-8](#figure8-8).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`shld`指令的工作原理如[图8-8](#figure8-8)所示。'
- en: '![f08008](image_fi/501089c08/f08008.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![f08008](image_fi/501089c08/f08008.png)'
- en: 'Figure 8-8: `shld` operation'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '图8-8: `shld`操作'
- en: '`Operand`2 must be a 16-, 32-, or 64-bit register. `Operand`1 can be a register
    or a memory location. Both operands must be the same size. The third operand,
    `constant` or `cl`, specifies the number of bits to shift, and may be a value
    in the range 0 through *n* – 1, where *n* is the size of the first two operands.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Operand`2必须是16位、32位或64位寄存器。`Operand`1可以是寄存器或内存位置。两个操作数的大小必须相同。第三个操作数`constant`或`cl`指定要移位的位数，其值范围可以是0到*n*
    – 1，其中*n*是前两个操作数的大小。'
- en: 'The `shld` instruction shifts a copy of the bits in `Operand`2 to the left
    by the number of bits specified by the third operand, storing the result into
    the location specified by the first operand. The HO bits shift into the carry
    flag, and the HO bits of `Operand`2 shift into the LO bits of `Operand`1. The
    third operand specifies the number of bits to shift. If the count is *n*, then
    `shld` shifts bit *n* – 1 into the carry flag (obviously, this instruction maintains
    only the last bit shifted into the carry). The `shld` instruction sets the flag
    bits as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`shld`指令将`Operand`2中位的副本左移由第三个操作数指定的位数，将结果存储到由第一个操作数指定的位置。最高有效位（HO bits）移入进位标志，`Operand`2的最高有效位移入`Operand`1的最低有效位（LO
    bits）。第三个操作数指定移位的位数。如果位数是*n*，则`shld`将位*n* – 1移入进位标志（显然，这条指令只保留最后一位移入进位标志）。`shld`指令按如下方式设置标志位：'
- en: If the shift count is 0, `shld` doesn’t affect any flags.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果移位计数为0，`shld`不会影响任何标志。
- en: The carry flag contains the last bit shifted out of the HO bit of `Operand`1.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进位标志包含从`Operand`1的最高有效位（HO bit）移出的最后一位。
- en: If the shift count is 1, the overflow flag will contain 1 if the sign bit of
    `Operand`1 changes during the shift. If the count is not 1, the overflow flag
    is undefined.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果移位计数为1，则如果`Operand`1的符号位在移位过程中发生变化，溢出标志将为1。如果移位计数不是1，溢出标志是未定义的。
- en: The zero flag will be 1 if the shift produces a 0 result.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果移位结果为0，零标志将为1。
- en: The sign flag will contain the HO bit of the result.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号标志将包含结果的高位（HO bit）。
- en: The `shrd` instruction is similar to `shld` except, of course, it shifts its
    bits right rather than left. To get a clear picture of the `shrd` instruction,
    consider [Figure 8-9](#figure8-9).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`shrd` 指令类似于 `shld`，只不过它是将位向右移位，而不是向左移位。为了更清楚地理解 `shrd` 指令，请参考 [图 8-9](#figure8-9)。'
- en: '![f08009](image_fi/501089c08/f08009.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![f08009](image_fi/501089c08/f08009.png)'
- en: 'Figure 8-9: `shrd` operation'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9：`shrd` 操作
- en: 'The `shrd` instruction sets the flag bits as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`shrd` 指令会设置标志位，具体如下：'
- en: If the shift count is 0, `shrd` doesn’t affect any flags.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果移位计数为 0，`shrd` 不会影响任何标志。
- en: The carry flag contains the last bit shifted out of the LO bit of `Operand`1.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进位标志包含从 `Operand`1 的低位（LO bit）移出的最后一位。
- en: If the shift count is 1, the overflow flag will contain 1 if the HO bit of `Operand`1
    changes. If the count is not 1, the overflow flag is undefined.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果移位计数为 1，当 `Operand`1 的高位（HO bit）发生变化时，溢出标志将为 1。如果计数不是 1，溢出标志则未定义。
- en: The zero flag will be 1 if the shift produces a 0 result.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果移位结果为 0，零标志位将为 1。
- en: The sign flag will contain the HO bit of the result.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号标志将包含结果的高位（HO）位。
- en: 'Consider the following code sequence:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码序列：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first `shld` instruction shifts the bits from `ShiftMe[8]` into `ShiftMe[16]`
    without affecting the value in `ShiftMe[8]`. The second `shld` instruction shifts
    the bits from `ShiftMe` into `ShiftMe[8]`. Finally, the `shl` instruction shifts
    the LO double word the appropriate amount.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条 `shld` 指令将 `ShiftMe[8]` 的位移入 `ShiftMe[16]`，而不会影响 `ShiftMe[8]` 的值。第二条 `shld`
    指令将 `ShiftMe` 的位移入 `ShiftMe[8]`。最后，`shl` 指令会将低双字（LO double word）适当的位数移位。
- en: There are two important things to note about this code. First, unlike the other
    extended-precision shift-left operations, this sequence works from the HO quad
    word down to the LO quad word. Second, the carry flag does not contain the carry
    from the HO shift operation. If you need to preserve the carry flag at that point,
    you will need to push the flags after the first `shld` instruction and pop the
    flags after the `shl` instruction.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码有两点需要注意。首先，与其他扩展精度左移操作不同，这个序列是从高四字（HO quad word）向低四字（LO quad word）移位。其次，进位标志不会包含来自高位移位操作的进位。如果需要在那时保留进位标志，必须在第一次
    `shld` 指令后保存标志，并在 `shl` 指令后恢复标志。
- en: You can do an extended-precision shift-right operation by using the `shrd` instruction.
    It works almost the same way as the preceding code sequence, except you work from
    the LO quad word to the HO quad word. The solution is left as an exercise for
    you.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `shrd` 指令执行扩展精度的右移操作。它的工作方式几乎与前面的代码序列相同，只是你从低四字（LO quad word）开始，最后处理高四字（HO
    quad word）。解决方案留给你作为练习。
- en: 8.1.12 Extended-Precision Rotate Operations
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.12 扩展精度旋转操作
- en: 'The `rcl` and `rcr` operations extend in a manner similar to `shl` and `shr`.
    For example, to perform 192-bit `rcl` and `rcr` operations, use the following
    instructions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcl` 和 `rcr` 操作的扩展方式类似于 `shl` 和 `shr`。例如，要执行 192 位的 `rcl` 和 `rcr` 操作，使用以下指令：'
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The only difference between this code and the code for the extended-precision
    shift operations is that the first instruction is a `rcl` or `rcr` rather than
    a `shl` or `shr`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与扩展精度移位操作的代码唯一不同之处是，第一条指令是 `rcl` 或 `rcr`，而不是 `shl` 或 `shr`。
- en: 'Performing an extended-precision `rol` or `ror` operation isn’t quite as simple
    because of the way the incoming bit is processed. You can use the `bt`, `shld`,
    and `shrd` instructions to implement an extended-precision `rol` or `ror` instruction.^([3](#c08-footnote-3))
    The following code shows how to use the `shld` and `bt` instructions to do a 128-bit
    extended-precision `rol`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 执行扩展精度的 `rol` 或 `ror` 操作并不像简单的左移或右移那样，因为输入位的处理方式不同。你可以使用 `bt`、`shld` 和 `shrd`
    指令来实现扩展精度的 `rol` 或 `ror` 指令。^[3](#c08-footnote-3) 以下代码展示了如何使用 `shld` 和 `bt` 指令执行
    128 位扩展精度的 `rol` 操作：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: An extended-precision `ror` instruction is similar; just keep in mind that you
    work on the LO end of the object first, and the HO end last.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度的 `ror` 指令类似；只需记住，你首先在对象的低端（LO）进行操作，最后在高端（HO）进行操作。
- en: 8.2 Operating on Different-Size Operands
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 操作不同大小的操作数
- en: Occasionally, you may need to do a computation on a pair of operands that are
    not the same size. For example, you may need to add a word and a double word together
    or subtract a byte value from a word value. To do so, extend the smaller operand
    to the size of the larger operand and then operate on two same-size operands.
    For signed operands, you sign-extend the smaller operand to the same size as the
    larger operand; for unsigned values, you zero-extend the smaller operand. This
    works for any operation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要对一对大小不同的操作数进行计算。例如，您可能需要将一个字（word）和一个双字（double word）相加，或者从一个字值中减去一个字节（byte）值。为此，需要将较小的操作数扩展到较大操作数的大小，然后对两个相同大小的操作数进行运算。对于带符号的操作数，您需要将较小的操作数符号扩展到与较大操作数相同的大小；对于无符号值，您则需要将较小的操作数零扩展。这适用于任何操作。
- en: 'The following examples demonstrate adding a byte variable and a word variable:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何将一个字节变量与一个字变量相加：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In both cases, the byte variable was loaded into the AL register, extended to
    16 bits, and then added to the word operand. This code works out really well if
    you can choose the order of the operations (for example, adding the 8-bit value
    to the 16-bit value).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，字节变量被加载到 AL 寄存器中，扩展为 16 位，然后与字操作数相加。如果您可以选择操作的顺序（例如，将 8 位值加到 16 位值），这段代码效果非常好。
- en: 'Sometimes you cannot specify the order of the operations. Perhaps the 16-bit
    value is already in the AX register, and you want to add an 8-bit value to it.
    For unsigned addition, you could use the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您无法指定操作的顺序。也许 16 位值已经在 AX 寄存器中，您想要加上一个 8 位值。对于无符号加法，您可以使用以下代码：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first `add` instruction adds the byte at `var1` to the LO byte of the value
    in the accumulator. The `adc` instruction adds the carry from the addition of
    the LO bytes into the HO byte of the accumulator. If you leave out `adc`, you
    may not get the correct result.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `add` 指令将 `var1` 中的字节加到累加器中的 LO 字节。`adc` 指令将加法中的进位加到累加器的 HO 字节中。如果省略了 `adc`，可能无法获得正确的结果。
- en: 'Adding an 8-bit signed operand to a 16-bit signed value is a little more difficult.
    Unfortunately, you cannot add an immediate value (as in the preceding example)
    to the HO word of AX, because the HO extension byte can be either 0 or 0FFh. If
    a register is available, the best thing to do is the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个 8 位带符号操作数加到一个 16 位带符号值中会稍微复杂一些。不幸的是，您不能将一个立即数值（如前面的例子中）加到 AX 的 HO 字中，因为
    HO 扩展字节可能是 0 或 0FFh。如果有可用的寄存器，最好的做法是：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If an extra register is not available, you might try the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有额外的寄存器，您可以尝试以下代码：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This works because the x86-64 can push 16-bit registers. One word of advice:
    don’t leave the RSP register misaligned (not on an 8-byte boundary) for very long.
    If you’re working with 32- or 64-bit registers, you’ll have to push the full 64-bit
    register and add 8 to RSP when you’re done with the stack.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式之所以有效，是因为 x86-64 可以推送 16 位寄存器。给出一点建议：不要让 RSP 寄存器错位（即不在 8 字节边界上）时间过长。如果您正在使用
    32 位或 64 位寄存器，完成堆栈操作后，您必须推送整个 64 位寄存器并将 RSP 加 8。
- en: 'Another alternative is to store the 16-bit value in the accumulator into a
    memory location and then proceed as before:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将 16 位值存储到累加器中的内存位置，然后像以前一样继续操作：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: All these examples add a byte value to a word value. By zero- or sign-extending
    the smaller operand to the size of the larger operand, you can easily add any
    two different-size variables together.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都将一个字节值加到一个字值中。通过将较小的操作数零扩展或符号扩展到较大操作数的大小，您可以轻松地将两个不同大小的变量相加。
- en: 'As a last example, consider adding an 8-bit signed value to an oword (128-bit)
    value:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个示例，考虑将一个 8 位带符号值与一个 oword（128 位）值相加：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 8.3 Decimal Arithmetic
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 十进制运算
- en: The x86-64 CPUs use the binary numbering system for their native internal representation.
    In the early days of computing, designers thought that decimal (base-10) arithmetic
    was more accurate for business calculations. Mathematicians have shown that this
    is not the case; nevertheless, some algorithms depend on decimal calculations
    to produce correct results. Therefore, although decimal arithmetic is generally
    less efficient and less accurate than using binary arithmetic, the need for decimal
    arithmetic persists.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 CPU 使用二进制编号系统来表示其本地的内部表示。在计算机早期，设计者认为十进制（基数为 10）运算对商业计算更为精确。数学家们已经证明，这并非如此；然而，某些算法依赖于十进制运算来生成正确的结果。因此，尽管十进制运算通常比二进制运算效率低且准确性差，但十进制运算的需求仍然存在。
- en: To represent decimal numbers in the native binary format, the most common technique
    is to use the *binary-coded decimal (**BCD)* representation. This uses 4 bits
    to represent the 10 possible decimal digits (see [Table 8-1](#table8-1)). The
    binary value of those 4 bits is equal to the corresponding decimal value in the
    range 0 to 9\. Of course, with 4 bits we can actually represent 16 different values;
    the BCD format ignores the remaining six bit combinations. Because each BCD digit
    requires 4 bits, we can represent a two-digit BCD value with a single byte. This
    means that we can represent the decimal values in the range 0 to 99 by using a
    single byte (as opposed to 0 to 255 with a byte in binary format).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地二进制格式中表示十进制数字，最常见的技术是使用*二进制编码十进制（**BCD**）*表示法。这使用4位来表示10个可能的十进制数字（见[表8-1](#table8-1)）。这4位的二进制值等于对应的十进制值，范围是0到9。当然，4位可以表示16个不同的值；BCD格式忽略剩余的六个位组合。因为每个BCD数字需要4位，我们可以使用一个字节表示一个两位数的BCD值。这意味着我们可以通过一个字节表示范围在0到99之间的十进制值（而不是在二进制格式下一个字节表示的0到255的范围）。
- en: 'Table 8-1: Binary-Coded Decimal Representation'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1：二进制编码十进制表示法
- en: '| **BCD representation** | **Decimal equivalent** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **BCD表示法** | **十进制等效值** |'
- en: '| --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0000 | 0 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 |'
- en: '| 0001 | 1 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 |'
- en: '| 0010 | 2 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 |'
- en: '| 0011 | 3 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 |'
- en: '| 0100 | 4 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 |'
- en: '| 0101 | 5 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 |'
- en: '| 0110 | 6 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 |'
- en: '| 0111 | 7 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 |'
- en: '| 1000 | 8 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 8 |'
- en: '| 1001 | 9 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | 9 |'
- en: '| 1010 | Illegal |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | 非法 |'
- en: '| 1011 | Illegal |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | 非法 |'
- en: '| 1100 | Illegal |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 1100 | 非法 |'
- en: '| 1101 | Illegal |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | 非法 |'
- en: '| 1110 | Illegal |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | 非法 |'
- en: '| 1111 | Illegal |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | 非法 |'
- en: 8.3.1 Literal BCD Constants
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 字面BCD常量
- en: 'MASM does not provide, nor do you need, a literal BCD constant. Because BCD
    is just a form of hexadecimal notation that does not allow the values 0Ah to 0Fh,
    you can easily create BCD constants by using MASM’s hexadecimal notation. For
    example, the following `mov` instruction copies the BCD value 99 into the AL register:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: MASM不提供字面BCD常量，也不需要字面BCD常量。因为BCD仅仅是十六进制表示法的一种形式，不允许使用0Ah到0Fh的值，你可以通过使用MASM的十六进制表示法轻松创建BCD常量。例如，下面的`mov`指令将BCD值99复制到AL寄存器中：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The important thing to keep in mind is that you must not use MASM literal decimal
    constants for BCD values. That is, `mov al, 95` does not load the BCD representation
    for 95 into the AL register. Instead, it loads 5Fh into AL, and that’s an illegal
    BCD value.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的重要一点是，你不能使用MASM字面十进制常量表示BCD值。也就是说，`mov al, 95`不会将95的BCD表示加载到AL寄存器中。相反，它会将5Fh加载到AL寄存器中，这是一个非法的BCD值。
- en: 8.3.2 Packed Decimal Arithmetic Using the FPU
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 使用FPU进行打包十进制运算
- en: To improve the performance of applications that rely on decimal arithmetic,
    Intel incorporated support for decimal arithmetic directly into the FPU. The FPU
    supports values with up to 18 decimal digits of precision, with computations using
    all the arithmetic capabilities of the FPU, from addition to transcendental operations.
    Assuming you can live with only 18 digits of precision and a few other restrictions,
    decimal arithmetic on the FPU is the right way to go.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高依赖于十进制运算的应用程序的性能，英特尔将十进制运算的支持直接集成到FPU中。FPU支持精度高达18位十进制数字的值，并且在所有FPU算术能力下进行计算，从加法到超越操作。如果你能接受只有18位精度以及一些其他限制，那么在FPU上进行十进制运算是正确的选择。
- en: 'The FPU supports only one BCD data type: a 10-byte 18-digit packed decimal
    value. The packed decimal format uses the first 9 bytes to hold the BCD value
    in a standard packed decimal format. The first byte contains the two LO digits,
    and the ninth byte holds the two HO digits. The HO bit of the tenth byte holds
    the sign bit, and the FPU ignores the remaining bits in the tenth byte (as using
    those bits would create possible BCD values that the FPU could not exactly represent
    in the native floating-point format).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: FPU仅支持一种BCD数据类型：一个10字节18位的打包十进制值。打包十进制格式使用前9个字节以标准的打包十进制格式存储BCD值。第一个字节包含两个低位数字（LO），第九个字节包含两个高位数字（HO）。第十个字节的高位（HO）位用于存储符号位，FPU忽略第十个字节中剩余的位（因为使用这些位会产生FPU无法在本地浮点格式中精确表示的BCD值）。
- en: The FPU uses a one’s complement notation for negative BCD values. The sign bit
    contains a 1 if the number is negative, and it contains a 0 if the number is positive.
    If the number is 0, the sign bit may be either 0 or 1, because, like the binary
    one’s complement format, there are two distinct representations for 0.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: FPU对负BCD值使用补码表示。符号位如果数字为负则包含1，如果数字为正则包含0。如果数字为0，符号位可以是0或1，因为像二进制补码格式一样，0有两种不同的表示。
- en: MASM’s `tbyte` type is the standard data type used to define packed BCD variables.
    The `fbld` and `fbstp` instructions require a `tbyte` operand (which you can initialize
    with a hexadecimal/BCD value).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: MASM的` tbyte `类型是用于定义打包BCD变量的标准数据类型。` fbld `和` fbstp `指令需要一个` tbyte `操作数（你可以用十六进制/BCD值初始化它）。
- en: Instead of fully supporting decimal arithmetic, the FPU provides two instructions,
    `fbld` and `fbstp`, that convert between packed decimal and binary floating-point
    formats when moving data to and from the FPU. The `fbld` (*float/BCD load*) instruction
    loads an 80-bit packed BCD value onto the top of the FPU stack after converting
    that BCD value to the binary floating-point format. Likewise, the `fbstp` (*float/BCD
    store and pop*) instruction pops the floating-point value off the top of stack,
    converts it to a packed BCD value, and stores the BCD value into the destination
    memory location. This means calculations are done using binary arithmetic. If
    you have an algorithm that absolutely, positively depends on the use of decimal
    arithmetic, it may fail if you use the FPU to implement it.^([4](#c08-footnote-4))
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: FPU并不完全支持十进制算术，而是提供了两条指令，` fbld `和` fbstp `，用于在将数据传入和传出FPU时，在打包十进制和二进制浮点格式之间进行转换。`
    fbld `（*浮动/BCD加载*）指令在将BCD值转换为二进制浮点格式后，将一个80位的打包BCD值加载到FPU栈顶。同样，` fbstp `（*浮动/BCD存储并弹出*）指令将浮点值从栈顶弹出，将其转换为打包BCD值，并将BCD值存储到目标内存位置。这意味着计算是使用二进制算术进行的。如果你有一个完全依赖十进制算术的算法，在使用FPU实现时，可能会失败。^([4](#c08-footnote-4))
- en: The conversion between packed BCD and the floating-point format is not a cheap
    operation. The `fbld` and `fbstp` instructions can be quite slow (more than two
    orders of magnitude slower than `fld` and `fstp`, for example). Therefore, these
    instructions can be costly if you’re doing simple additions or subtractions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 打包BCD与浮点格式之间的转换并不是一个廉价的操作。` fbld `和` fbstp `指令可能会非常慢（例如，比` fld `和` fstp `慢两个数量级以上）。因此，如果你只进行简单的加减法，这些指令可能会很昂贵。
- en: 'Because the FPU converts packed decimal values to the internal floating-point
    format, you can mix packed decimal, floating point, and (binary) integer formats
    in the same calculation. The following code fragment demonstrates how you might
    achieve this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于FPU将打包的十进制值转换为内部浮点格式，因此你可以在同一个计算中混合使用打包十进制、浮点和（二进制）整数格式。以下代码片段演示了如何实现这一点：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The FPU treats packed decimal values as integer values. Therefore, if your calculations
    produce fractional results, the `fbstp` instruction will round the result according
    to the current FPU rounding mode. If you need to work with fractional values,
    you need to stick with floating-point results.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: FPU将打包十进制值视为整数值。因此，如果你的计算产生了小数结果，` fbstp `指令将根据当前的FPU舍入模式对结果进行舍入。如果你需要处理小数值，你需要坚持使用浮点结果。
- en: 8.4 For More Information
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 更多信息
- en: 'Donald Knuth’s *The Art of Computer Programming*, Volume 2: *Seminumerical
    Algorithms* (Addison-Wesley Professional, 1997) contains a lot of useful information
    about decimal arithmetic and extended-precision arithmetic, though that text is
    generic and doesn’t describe how to do this in x86-64 assembly language. Additional
    information on BCD arithmetic can also be found at the following websites:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 唐纳德·克努斯（Donald Knuth）的*《计算机程序设计的艺术》*，第二卷：*半数值算法*（Addison-Wesley Professional，1997）包含了许多关于十进制算术和扩展精度算术的有用信息，尽管该书内容是通用的，并未描述如何在x86-64汇编语言中实现此操作。关于BCD算术的更多信息也可以在以下网站找到：
- en: '*BCD Arithmetic, a Tutorial, [http://homepage.divms.uiowa.edu/~jones/bcd/bcd.html](http://homepage.divms.uiowa.edu/~jones/bcd/bcd.html)*'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*BCD算术教程，[http://homepage.divms.uiowa.edu/~jones/bcd/bcd.html](http://homepage.divms.uiowa.edu/~jones/bcd/bcd.html)*'
- en: '**   *General Decimal Arithmetic, [http://speleotrove.com/decimal/](http://speleotrove.com/decimal/)***   *Intel
    Decimal Floating-Point Math Library, [https://software.intel.com/en-us/articles/intel-decimal-floating-point-math-library/](https://software.intel.com/en-us/articles/intel-decimal-floating-point-math-library/)***'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**   *通用十进制算术，[http://speleotrove.com/decimal/](http://speleotrove.com/decimal/)*
    **   *英特尔十进制浮点数学库，[https://software.intel.com/en-us/articles/intel-decimal-floating-point-math-library/](https://software.intel.com/en-us/articles/intel-decimal-floating-point-math-library/)***'
- en: '***## 8.5 Test Yourself'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '***## 8.5 自测'
- en: 'Provide the code to compute *x* = *y* + *z*, assuming the following:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供计算 *x* = *y* + *z* 的代码，假设以下条件：
- en: '*x*, *y*, and *z* are 128-bit integers'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x*、*y* 和 *z* 是 128 位整数'
- en: '*x* and *y* are 96-bit integers, and *z* is a 64-bit integer'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* 和 *y* 是 96 位整数，*z* 是 64 位整数'
- en: '*x*, *y*, and *z* are 48-bit integers'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x*、*y* 和 *z* 是 48 位整数'
- en: 'Provide the code to compute *x* = *y* − *z*, assuming the following:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供计算 *x* = *y* − *z* 的代码，假设以下条件：
- en: '*x*, *y*, and *z* are 192-bit integers'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x*、*y* 和 *z* 是 192 位整数'
- en: '*x*, *y*, and *z* are 96-bit integers'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x*、*y* 和 *z* 是 96 位整数'
- en: Provide the code to compute *x* = *y* × *z*, assuming *x*, *y*, and *z* are
    128-bit unsigned integers.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供计算 *x* = *y* × *z* 的代码，假设 *x*、*y* 和 *z* 是 128 位无符号整数。
- en: Provide the code to compute *x* = *y* / *z*, assuming *x* and *y* are 128-bit
    signed integers, and *z* is a 64-bit signed integer.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供计算 *x* = *y* / *z* 的代码，假设 *x* 和 *y* 是 128 位带符号整数，*z* 是 64 位带符号整数。
- en: 'Assuming *x* and *y* are unsigned 128-bit integers, convert the following to
    assembly language:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 *x* 和 *y* 是无符号的 128 位整数，将以下内容转换为汇编语言：
- en: if(*x* == *y*) `then code`
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 (*x* == *y*) `则执行代码`
- en: if(*x* < *y*) `then code`
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 (*x* < *y*) `则执行代码`
- en: if(*x* > *y*) `then code`
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 (*x* > *y*) `则执行代码`
- en: if(*x* ≠ *y*) `then code`
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 (*x* ≠ *y*) `则执行代码`
- en: 'Assuming *x* and *y* are signed 96-bit integers, convert the following to assembly
    language:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 *x* 和 *y* 是带符号的 96 位整数，将以下内容转换为汇编语言：
- en: if(*x* == *y*) `then code`
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 (*x* == *y*) `则执行代码`
- en: if(*x* < *y*) `then code`
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 (*x* < *y*) `则执行代码`
- en: if(*x* > *y*) `then code`
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 (*x* > *y*) `则执行代码`
- en: 'Assuming *x* and *y* are signed 128-bit integers, provide two distinct ways
    to convert the following to assembly language:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 *x* 和 *y* 是带符号的 128 位整数，提供两种不同的方法将以下内容转换为汇编语言：
- en: '*x* = –*x*'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* = –*x*'
- en: '*x* = –*y*'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* = –*y*'
- en: 'Assuming *x*, *y*, and *z* are all 128-bit integer values, convert the following
    to assembly language:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 *x*、*y* 和 *z* 都是 128 位整数，转换以下内容为汇编语言：
- en: '*x* = *y* & *z* (bitwise logical AND)'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* = *y* & *z* （按位逻辑与）'
- en: '*x* = *y* | *z* (bitwise logical OR)'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* = *y* | *z* （按位逻辑或）'
- en: '*x* = *y* ^ *z* (bitwise logical XOR)'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* = *y* ^ *z* （按位逻辑异或）'
- en: '*x* = ~*y* (bitwise logical NOT)'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* = ~*y* （按位逻辑非）'
- en: '*x* = *y* << 1 (bitwise shift left)'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* = *y* << 1 （按位左移）'
- en: '*x* = *y* >> 1 (bitwise shift right)'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* = *y* >> 1 （按位右移）'
- en: Assuming *x* and *y* are signed 128-bit values, convert *x* = *y* >> 1 to assembly
    language (bitwise arithmetic shift right).
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 *x* 和 *y* 是带符号的 128 位值，将 *x* = *y* >> 1 转换为汇编语言（按位算术右移）。
- en: Provide the assembly code to rotate the 128-bit value in *x* through the carry
    flag (left by 1 bit).
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供汇编代码，通过进位标志（左移 1 位）旋转 *x* 的 128 位值。
- en: Provide the assembly code to rotate the 128-bit value in *x* through the carry
    flag (right by 1 bit).***
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供汇编代码，通过进位标志（右移 1 位）旋转 *x* 的 128 位值。***
