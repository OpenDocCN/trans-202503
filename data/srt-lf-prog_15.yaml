- en: '**15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15**'
- en: REAL-WORLD CONSIDERATIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**现实世界的考量**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Since this book is intended as a companion for someone learning to code, you
    hopefully know something about software at this point and about the hardware on
    which it runs as well. You might think that you’re ready to be a programmer. But
    programming involves more than knowing about hardware and writing code. How do
    you know what code to write, and how do you go about writing it? How do you know
    that it works?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书旨在作为学习编程者的伴侣，你此时应该对软件有所了解，也对其运行所需的硬件有所认识。你可能认为自己已经准备好成为一名程序员。但编程不仅仅是了解硬件和编写代码。你如何知道该写什么代码，又如何编写它？你如何知道它是否有效？
- en: Those aren’t the only important questions you face. Can others figure out how
    to use your code? How easy is it for others to add features or find and fix bugs?
    How hard is it to make your code run on hardware other than that for which it
    was originally written?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是你面临的唯一重要问题。别人能理解如何使用你的代码吗？别人能多容易地添加功能或发现并修复错误？让你的代码在其他硬件上运行有多难，而这些硬件并不是最初编写代码时所用的硬件？
- en: This chapter covers various topics related to the creation of software. While
    you can do small projects yourself sitting in a dark room with a sufficient quantity
    of junk food, most projects are a team sport that involves dealing with people.
    That’s harder than you might think—the hardware/software systems that we call
    people are way buggier than even the most terrifying internet-of-things abomination.
    And forget about documentation; even if you could find any, it would be out-of-date.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了与软件创建相关的各种主题。虽然你可以一个人完成小项目，坐在昏暗的房间里，吃着足够的垃圾食品，但大多数项目是团队合作，涉及与人打交道。这比你想象的要难——我们所称之为人的硬件/软件系统，比起最可怕的物联网怪物更容易出问题。而且，文档别指望了；即使你能找到，它也会是过时的。
- en: That’s why this chapter also covers some of the philosophical and practical
    issues around being a programmer. Yup, this is where the old curmudgeon tries
    to pass on some hard-earned wisdom.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么本章还涵盖了作为程序员的一些哲学和实践问题。没错，这就是那个老顽固试图传递一些辛苦得来的智慧的地方。
- en: '**The Value Proposition**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**价值主张**'
- en: 'There’s an overarching question that you should keep in mind when working on
    a project: “Am I adding value?” I’m not talking about the intrinsic value of accomplishing
    some task here; I’m talking about increasing productivity.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行项目时，有一个总体性的问题你应该时刻牢记：“我在增加价值吗？”我这里说的不是完成某项任务的内在价值；而是说提升生产力的价值。
- en: If you’re programming for a living, you need to meet whatever goals your employer
    has set. But, of course, there’s more than one way to meet those goals. You could
    just do what you need to do to get by. Or, you could put a little thought into
    things that might not have occurred to management. For example, you might realize
    that your code would be useful in another project and structure it so it’s easily
    reusable. Or, you might sense that you were tasked to implement a special case
    of a more general problem and solve that general problem instead, paving the way
    for future enhancements. Of course, you should talk about this with management
    so that they’re not surprised.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是为了谋生而编程，你需要达成雇主设定的目标。当然，达成这些目标的方式不止一种。你可以只是做你需要做的事情以应付过去。或者，你可以多花点心思考虑一些管理层可能没想到的事情。例如，你可能意识到你的代码在另一个项目中也能派上用场，于是你会将其结构化，便于重用。或者，你可能会察觉到你被要求实现某个更一般问题的一个特例，而你选择解决那个更一般的问题，为未来的增强奠定基础。当然，你应该和管理层讨论这些，以免他们感到意外。
- en: You can add value to yourself by making sure that you’re proficient in a variety
    of technologies. Side projects are a common way to get experience; it’s equivalent
    to doing homework but more fun.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过确保自己精通多种技术来为自己增值。副项目是获得经验的常见方式；它等同于做作业，但更有趣。
- en: One classic way in which people attempt to add value is by creating tools. This
    is trickier than it seems because sometimes adding value for yourself reduces
    value for others. People often create new tools because some feature that they
    think they need is missing from existing ones. A good example is the `make` utility
    (invented by Stuart Feldman at Bell Labs in 1976), which is used to build large
    software packages. As time went on, new features were needed. Some of these were
    added to `make`, but in many other cases, people created well-intentioned but
    incompatible new utilities that performed similar functions. (For example, I consulted
    for a company once that wrote their own solely because they didn’t bother to completely
    read the `make` documentation and were unaware that it would do exactly what they
    needed.) Now there’s `make`, `cmake`, `dmake`, `imake`, pick-a-letter-`make`,
    and other programs that all do similar things in incompatible ways. The result
    is that practitioners like you need to learn multiple tools in each category.
    It makes everyone’s life harder, not easier. It doesn’t add value—it detracts.
    [Figure 15-1](ch15.xhtml#ch15fig01) sums up the situation nicely.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 人们尝试增加价值的经典方式之一是创建工具。这比看起来更棘手，因为有时候，为自己增加的价值可能会减少他人的价值。人们常常创造新工具，是因为他们认为现有工具缺少某些他们需要的功能。一个很好的例子是`make`工具（由Stuart
    Feldman于1976年在贝尔实验室发明），它用于构建大型软件包。随着时间的推移，需要新功能。有些功能被添加到了`make`中，但在许多其他情况下，人们创造了出于好意但不兼容的新工具，执行类似的功能。（例如，我曾为一家公司提供咨询服务，他们自己写了一个工具，仅仅因为他们没有完全阅读`make`的文档，没意识到`make`已经能完成他们需要的工作。）现在有了`make`、`cmake`、`dmake`、`imake`、pick-a-letter-`make`等多个程序，它们都以不兼容的方式做着类似的事情。结果是，像你这样的从业者需要学习每个类别中的多个工具。这让每个人的工作变得更难，而不是更容易。它没有增加价值，反而减少了。[图
    15-1](ch15.xhtml#ch15fig01)很好地总结了这一情况。
- en: '![Image](../images/15fig01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig01.jpg)'
- en: '*Figure 15-1: Not adding value (courtesy of Randall Munroe,* xkcd.com*)*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：没有增加价值（图源：Randall Munroe，* xkcd.com*)*'
- en: Creating burdens for others doesn’t add value. Experienced programmers know
    that doing something that’s already been done in a way that they personally prefer
    rarely adds value. Instead, it shows off one’s immaturity as a programmer. Improve
    existing tools wherever possible because more people will be able to use the result.
    Save making new tools for new things. Make sure that you fully understand existing
    tools because they might be more capable than you realized at first glance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 给别人制造负担并不会增加价值。经验丰富的程序员知道，以他们个人偏好的方式去做已经有人做过的事情，通常不会增加价值。相反，这往往显示出程序员的成熟度不足。在可能的情况下，改进现有工具，因为更多的人将能够使用这一成果。把创造新工具留给真正需要的地方。确保你完全理解现有工具，因为它们可能比你最初认为的更强大。
- en: Mucking up the ecosystem into which you release code does not add value. Many
    developers behave as if they’re stereotypical Americans vacationing in another
    country, or for that matter my father-in-law visiting—the “I just came to your
    place, so do things my way” attitude.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏你发布代码的生态系统并不会增加价值。许多开发者表现得就像是刻板印象中的美国人到另一个国家度假，或者更确切地说，像我岳父来访一样——“我刚到你们这里，所以按照我的方式做”的态度。
- en: For example, UNIX systems have a command that displays manual pages for programs.
    You can type `man foo` and it’ll show you the page for the `foo` command. There’s
    also a convention that really complex commands, such as `yacc`, have both a manual
    page and a longer, more in-depth document that describes the program in more detail.
    When the GNU project (which I’ll discuss shortly) added commands to UNIX, it used
    its own `texinfo` system for manuals, which wasn’t compatible with the `man` system.
    The result was that users would have to try both the `man` and `info` commands
    to find documentation. Even if, as some believe, the GNU approach was superior,
    any possible benefits were outweighed by the UNIX community’s huge loss of productivity
    that resulted from the fragmented ecosystem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，UNIX系统有一个命令，用于显示程序的手册页。你可以输入`man foo`，它会显示`foo`命令的页面。还有一个约定，真正复杂的命令，比如`yacc`，不仅有手册页，还有一份更长、更深入的文档，详细描述该程序。当GNU项目（我稍后会讨论）向UNIX添加命令时，使用了自己的`texinfo`手册系统，这与`man`系统不兼容。结果是，用户需要同时尝试`man`和`info`命令来查找文档。即使某些人认为GNU的方法更优，但任何可能的好处都被UNIX社区由于生态系统碎片化所带来的巨大生产力损失所抵消。
- en: There are many other examples, such as the replacement of the `init` system
    with `systemd`. A big part of the UNIX philosophy, as discussed later in this
    chapter, is modular design, but `systemd` replaced the modular `init` system with
    a huge monolithic beast. There was no attempt to retrofit new features into the
    existing system. The entire user base lost productivity because they had to learn
    a new system that mostly did just what the old one did. It would have added more
    value to add multithreading and other new features to the existing system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的例子，比如将`init`系统替换为`systemd`。正如本章后面讨论的，UNIX哲学的一个重要部分是模块化设计，但`systemd`用一个庞大的单体系统替代了模块化的`init`系统。没有尝试将新功能加到现有系统中。整个用户群体的生产力下降，因为他们不得不学习一个新的系统，而这个新系统大部分功能和旧系统一样。如果将多线程和其他新功能添加到现有系统中，可能会带来更多的价值。
- en: Yet another example is the `jar` utility, which is part of the Java programming
    environment. The `tar` utility was created in the 1970s to pack multiple files
    into a single one. This solved a problem caused by using magnetic tape for storage.
    Mag tape is a block device, and packing files together allowed full blocks to
    be used thereby increasing efficiency. ZIP files, which first made their appearance
    on Windows, are similar. Rather than using either of these existing formats, though,
    Java made its own. The result was that users now needed to learn yet another command
    for no particularly good reason.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是`jar`工具，它是Java编程环境的一部分。`tar`工具是在1970年代创建的，用于将多个文件打包成一个文件。这解决了使用磁带存储时产生的问题。磁带是一个块设备，将文件打包在一起可以充分利用整个块，从而提高效率。ZIP文件首次出现在Windows系统中，类似于这个思路。然而，Java并没有使用这两种现有格式，而是创造了自己的格式。结果是，用户现在需要学习另一个命令，但并没有什么特别好的理由。
- en: So don’t be the programmer equivalent of an “ugly American.” Work with the ecosystem,
    not against it. Use the rule of “least astonishment” as a guide. You’ve added
    value if your work seems a natural extension of the existing environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不要成为程序员版的“丑陋的美国人”。要与生态系统合作，而不是与之对立。以“最小惊讶原则”为指导。如果你的工作看起来是现有环境的自然延伸，那么你就创造了价值。
- en: '**How We Got Here**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我们是如何走到今天的**'
- en: Before we get going on more practical issues, let’s look at how we got here.
    Much more has happened in the field than we can cover here, so we’ll just touch
    on some important historical highlights and a few more recent developments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论更多实际问题之前，先看看我们是如何走到今天的。这个领域发生了很多事情，我们在这里无法完全覆盖，所以我们将简单地提及一些重要的历史节点和一些较新的发展。
- en: '***A Short History***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***简短的历史***'
- en: A long time ago, people made money selling computers, which were really expensive.
    Software was written and given away in order to help sell computers. There was
    a culture of sharing and working together to improve software. More and more people
    wrote and shared software as computers became more accessible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，人们通过出售计算机来赚钱，而计算机的价格非常昂贵。软件是为了帮助销售计算机而编写并免费提供的。当时有一种分享和合作改进软件的文化。随着计算机变得越来越普及，越来越多的人开始编写和分享软件。
- en: The *Multics* operating system, which ran on the huge GE645 mainframe computer,
    was collaboratively developed in the 1960s by Bell Telephone Laboratories, General
    Electric, and the Massachusetts Institute of Technology. Bell pulled out of the
    project, and some of the people there who had worked on it—most notably, Ken Thompson
    and Dennis Ritchie—went off to experiment with some filesystem ideas they’d had
    when working on Multics using the smaller computers produced by the Digital Equipment
    Corporation (DEC). Their work resulted in an innovative new operating system called
    UNIX, which embodied a new minimalist and modular philosophy for software. While
    not planned at the outset, it became the first *portable* operating system, meaning
    it could run on more than one type of computer. The term *UNIX* in this book refers
    to all similar systems including Linux, FreeBSD, NetBSD, OpenBSD, and the modern
    macOS. Microsoft Windows is the only major outlier, but even it is incorporating
    more and more UNIX features—for example, the socket model for networking.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*Multics*操作系统运行在庞大的GE645大型主机上，1960年代由贝尔电话实验室、通用电气和麻省理工学院共同开发。贝尔从该项目中退出，一些曾在项目中工作的人员——最著名的包括肯·汤普森和丹尼斯·里奇——离开后开始尝试在开发Multics时想到的一些文件系统想法，并使用数字设备公司（DEC）生产的小型计算机进行实验。他们的工作最终导致了一个创新性的操作系统UNIX的诞生，UNIX体现了一种新的极简和模块化的软件哲学。尽管这一点最初并未计划，但它成为了第一个*可移植*的操作系统，意味着它可以在多种类型的计算机上运行。本书中的*UNIX*一词指的是所有类似的系统，包括Linux、FreeBSD、NetBSD、OpenBSD和现代的macOS。微软Windows是唯一的主要例外，但即便如此，它也在逐步纳入越来越多的UNIX特性——例如，网络套接字模型。'
- en: Bell wasn’t the only Multics participant to go their own way. The Incompatible
    Timesharing System (ITS) was developed over at MIT. While ITS included a number
    of groundbreaking features, its most influential contribution is arguably the
    Emacs (Editor MACroS) text editor, which began as a set of macros for the DEC
    TECO (Text Editor and Corrector) text editor. The user interface for ITS and Emacs
    influenced the GNU project, also started at MIT.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 贝尔实验室并不是唯一一个走自己道路的Multics参与者。不可兼容的分时系统（ITS）是在麻省理工学院（MIT）开发的。尽管ITS包含了许多开创性的特性，但其最具影响力的贡献无疑是Emacs（Editor
    MACroS）文本编辑器，它最初是DEC TECO（文本编辑器和校正器）文本编辑器的一组宏命令。ITS和Emacs的用户界面影响了GNU项目，后者也是在MIT启动的。
- en: Ken Thompson brought a copy of UNIX with him in 1975 when he took a sabbatical
    year to teach at the University of California, Berkeley. This had a huge effect
    that still reverberates today. Students had access to a real working system. They
    could examine the code to see how things worked, and they could make changes.
    Not only that, but they were exposed to the philosophy as well. Berkeley produced
    its own version of UNIX, called *BSD* for Berkeley Software Distribution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 肯·汤普森（Ken Thompson）于1975年带着一份UNIX副本，在休假一年期间前往加利福尼亚大学伯克利分校教学。这一举措产生了巨大影响，至今仍在回响。学生们可以接触到一个真正的工作系统，查看代码了解系统如何运作，并且可以进行修改。不仅如此，他们也接触到了UNIX的哲学思想。伯克利开发了自己的UNIX版本，称为*BSD*（伯克利软件分发版）。
- en: Students added many new important features to the system. BBN’s networking stack,
    which is the foundation of the internet, was integrated into UNIX at Berkeley,
    where the now-ubiquitous socket interface was born. University graduates started
    to use the BSD version of UNIX and formed companies such as Sun Microsystems,
    which made commercial UNIX-based systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 学生们为系统增加了许多重要的新功能。BBN的网络堆栈——互联网的基础——被集成到了伯克利的UNIX系统中，诞生了如今无处不在的套接字接口。大学毕业生开始使用BSD版本的UNIX并创办了像Sun
    Microsystems这样的公司，开发商业化的UNIX基础系统。
- en: Personal computers changed this. All of a sudden the people writing software
    weren’t the people selling computers, so they needed to charge for it. But there
    was still an attitude of “it’s great that we make a living doing this cool stuff.”
    This changed dramatically when Bill Gates (one of the founders of Microsoft) came
    on the scene. As is evident from numerous court depositions, his focus was on
    making money. If he had to do something cool to make money, he would, but his
    priorities were opposite those of others in the industry. How did this change
    things?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 个人计算机改变了这一切。突然间，编写软件的人不再是卖电脑的人，因此他们需要对软件收费。但当时仍然存在一种“我们通过做这些酷事谋生真是太棒了”的心态。直到比尔·盖茨（Bill
    Gates）登场，这种情况才发生了剧变。正如许多法庭证词中所显示的，他的关注点在于赚钱。如果为了赚钱需要做一些酷的事情，他会去做，但他的优先级与行业中其他人的完全相反。这一变化如何影响了整个行业呢？
- en: Software development began to be driven more by politics, lawyers, and sometimes-underhanded
    behavior than by superior engineering. This approach frequently focused on suppressing
    innovation that competed with existing products. For example, Microsoft started
    with MS-DOS, a program that they bought from its developer, American computer
    programmer Tim Paterson. Microsoft let the program languish, as they were making
    plenty of money from it. A company called Digital Research came out with an improved
    version called DR-DOS. When Microsoft released Windows, the original version of
    which ran on top of DOS, they included a hidden, encrypted piece of code that
    checked to see whether the system was running MS-DOS or DR-DOS and generated phony
    errors if it found DR-DOS. This made DR-DOS unsuccessful in the marketplace even
    though it was arguably a better product for the money.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发开始更多地受到政治、律师和有时不正当行为的驱动，而非卓越的工程技术。这种方法经常集中在压制与现有产品竞争的创新。例如，微软从其开发者——美国计算机程序员蒂姆·帕特森手中购买了MS-DOS程序，并让该程序处于停滞状态，因为他们从中赚取了大量的利润。名为Digital
    Research的公司推出了一个改进版本，称为DR-DOS。当微软发布Windows时，最初版本是运行在DOS之上的，他们在其中加入了一段隐藏的加密代码，用以检查系统是否在运行MS-DOS或DR-DOS，如果发现DR-DOS，就会产生虚假的错误信息。尽管DR-DOS在性能上可能更为优秀，但由于这个做法，它在市场上并未成功。
- en: It wasn’t just Microsoft, however. Apple also sued Digital Research for “copying”
    their user interface in a product called GEM. Digital Research would probably
    have prevailed eventually, but would have gone bankrupt in the process because
    Apple had much deeper pockets. It’s somewhat ironic when you realize that the
    Apple user interface was substantially copied from the Xerox Alto.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不仅仅是微软的行为。苹果也因其在一款名为GEM的产品中“抄袭”了他们的用户界面，起诉了Digital Research。Digital Research可能最终会胜诉，但过程中会因为苹果有更深的财力而破产。想想看，苹果的用户界面实际上在很大程度上是抄袭了施乐公司的Xerox
    Alto，这其中有些讽刺意味。
- en: Unfortunately, this mindset continues today with threatened big players resorting
    to the courts instead of innovating their way out of their difficulties. Examples
    abound, such as SCO versus IBM, Oracle versus Google, Apple versus Samsung, Samsung
    versus Apple, Intellectual Ventures shell companies versus the world, and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种思维模式至今依然存在，受到威胁的大公司继续诉诸法院，而不是通过创新来解决自己的困境。类似的例子屡见不鲜，比如SCO诉IBM、甲骨文诉谷歌、苹果诉三星、三星诉苹果、Intellectual
    Ventures壳公司与全世界等。
- en: Personal computers started becoming popular in the mid-1980s. It wasn’t practical
    to run UNIX on them because the hardware lacked a memory management unit (see
    [Chapter 5](ch05.xhtml#ch05)), although there was a variant called Xenix that
    did run on the original IBM PC hardware.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 个人计算机在1980年代中期开始流行。当时在这些计算机上运行UNIX并不实际，因为硬件缺乏内存管理单元（见[第5章](ch05.xhtml#ch05)），尽管有一个叫Xenix的变种能在最初的IBM
    PC硬件上运行。
- en: Colleges started using personal computers running Microsoft Windows to teach
    computer science because they were cheaper. However, unlike the UNIX-era graduates
    from UC Berkeley and other schools, these students weren’t able to look at the
    source code of the system they were using. And the system with which they became
    familiar was considerably less advanced than UNIX. As a result, graduates from
    this era are often not of the same quality as their earlier counterparts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大学开始使用运行微软Windows的个人计算机来教授计算机科学，因为它们更便宜。然而，与UC伯克利和其他学校的UNIX时代毕业生不同，这些学生无法查看他们所使用的系统的源代码。而且，他们熟悉的系统远不如UNIX先进。因此，这一代毕业生的素质往往不如前辈。
- en: In part as a reaction to the closed nature of the source code, Richard Stallman
    started the GNU (Gnu’s Not Unix) project in 1983\. Among other things, the goal
    was to create a freely available and legally unencumbered version of UNIX. Today
    we call this “free and open source software,” or *FOSS*. *Open source* means that
    the source code is available for others to see, and more importantly, modify and
    improve. Stallman, working with his lawyer, created the *copyleft*, a variant
    of the copyright used by others to protect their software. The copyleft essentially
    said that others were free to use and modify the code as long as they made their
    modifications available under the same terms. In other words, “we’ll share our
    code with you if you share yours with everyone else.” The GNU project did a great
    job of re-creating the UNIX utilities such as `cp` and, possibly most important,
    the `gcc` C compiler. But the project team was slow to create an operating system
    itself.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对源代码封闭性质的回应，理查德·斯托曼于1983年启动了GNU（Gnu's Not Unix）项目。除了其他目标外，这个项目的目标是创建一个自由可用且没有法律限制的UNIX版本。今天我们称之为“自由和开源软件”，或*FOSS*。*开源*意味着源代码可以供他人查看，更重要的是可以修改和改进。斯托曼与他的律师合作，创建了*copyleft*，这是一种版权变体，用于保护他人的软件。copyleft基本上意味着，只要他人按照相同条款提供修改版代码，便可以自由使用和修改这些代码。换句话说，“我们会与你分享我们的代码，只要你也与他人分享你的代码。”GNU项目成功地重新创造了许多UNIX工具，如`cp`，以及可能最重要的`gcc`
    C编译器。但该项目团队在创建操作系统方面的进展较慢。
- en: Linus Torvalds began work on what is now known as the *Linux* operating system
    in 1991, partly because there was no GNU operating system. To a large degree,
    this work was made possible by both the existence of the GNU tools such as the
    C compiler and the nascent internet, which enabled collaboration. Linux has become
    extremely popular. It’s used heavily in data centers (the cloud), it’s the underlying
    software in Android devices, and it’s used in many appliances. This book was written
    on a Linux system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 林纳斯·托瓦兹（Linus Torvalds）于1991年开始着手开发如今被称为*Linux*的操作系统，部分原因是当时没有GNU操作系统。在很大程度上，这项工作得以实现，是因为GNU工具（如C编译器）和新兴的互联网存在，后者促进了合作。Linux已经变得非常流行。它被广泛用于数据中心（云计算），是Android设备的底层软件，并且被许多家电所使用。这本书就是在Linux系统上编写的。
- en: Large companies were originally skeptical about using open source software.
    Who would fix the bugs? This is somewhat ludicrous; if you’ve ever reported a
    bug to Microsoft, Apple, or any other large company, you know how much attention
    it gets. In 1989, John Gilmore, DV Henkel-Wallace (a.k.a. Gumby), and Michael
    Tiemann founded *Cygnus Support* to provide commercial support for open source
    software. Its existence greatly increased the willingness of companies to use
    open source software.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大公司最初对使用开源软件持怀疑态度。谁来修复漏洞呢？这有些荒谬；如果你曾向微软、苹果或任何其他大公司报告过漏洞，你就会知道它们会得到多少关注。1989年，John
    Gilmore、DV Henkel-Wallace（也就是Gumby）和Michael Tiemann成立了*Cygnus Support*，为开源软件提供商业支持。它的存在大大增加了公司使用开源软件的意愿。
- en: In many ways, Linux and GNU have brought us a new golden era similar to the
    Berkeley UNIX days. It’s not *quite* as shiny, though, because some of the people
    from the PC era are making changes without really understanding the philosophy.
    In particular, some programmers who didn’t grow up with UNIX are reducing the
    value of the ecosystem by replacing small modular components with huge monolithic
    programs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，Linux 和 GNU 为我们带来了类似于 Berkeley UNIX 时代的一个新的黄金时代。不过，它并不像当时那样*光辉灿烂*，因为一些来自个人电脑时代的人们在没有真正理解其哲学的情况下做出了改变。尤其是一些没有在
    UNIX 环境中成长起来的程序员，通过用巨大的单体程序替代小而模块化的组件，降低了生态系统的价值。
- en: '***Open Source Software***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***开源软件***'
- en: Open source software is widely successful despite alarmist propaganda by some
    established closed source companies. For example, senior Microsoft personnel claimed,
    “Open source is an intellectual property destroyer. I can’t imagine something
    that could be worse than this for the software business and the intellectual property
    business,” despite the fact that they were secretly using open source tools in-house.
    A main advantage of open source software is that many more eyeballs are available
    to look at the code, which translates into benefits such as greater security and
    reliability. Another is that it allows programmers to build on work that others
    have done instead of having to reinvent everything. Even if you use a closed source
    computer system, there’s a pretty good chance that you’re still using some open
    source components. Even Microsoft recently appears to have seen the light and
    makes many UNIX tools available on their systems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些传统的闭源公司进行危言耸听的宣传，开源软件仍然取得了广泛的成功。例如，微软高级人员曾声称：“开源是知识产权的毁灭者。我无法想象有什么比这更糟糕的事情会发生在软件行业和知识产权行业。”然而，实际上他们在内部却在秘密使用开源工具。开源软件的一个主要优势是有更多的眼睛能够审视代码，这转化为更高的安全性和可靠性等好处。另一个优势是，它允许程序员在他人完成的工作基础上进行开发，而无需重新发明所有内容。即便你使用的是闭源计算机系统，仍然有很大的可能性你正在使用一些开源组件。甚至微软最近似乎也意识到了这一点，并且在他们的系统上提供了许多UNIX工具。
- en: The development of open source software was greatly enhanced by the internet
    and cloud services. It’s trivial to find open source projects or to start your
    own. But—and this is a big but—the majority of open source projects out there
    are garbage just like their closed source counterparts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件的发展得到了互联网和云服务的极大推动。现在找开源项目或启动自己的项目是非常简单的。但——这是一个大但——大多数开源项目和它们的闭源对等物一样，都是垃圾。
- en: A lot of open source software comes from student projects. Since they’re often
    first projects, the authors haven’t yet mastered the art of writing good code.
    And much of this software is unfinished, as the student programmers completed
    their class, graduated, or just moved on. It’s often easier to rewrite something
    than it is to decipher someone else’s poorly written and documented code. This
    is a vicious cycle because the rewrite often doesn’t get done, so there are multiple
    versions that don’t work in different ways. For example, I recently needed to
    extract tags from MP3 files and tried six different open source programs, each
    of which failed in a different way. It’s often difficult to determine whether
    or not there is a good working version of something because there is so much litter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 很多开源软件来自学生项目。由于这些通常是学生的第一项目，作者还未掌握编写优秀代码的艺术。而且许多这类软件都未完成，因为学生程序员完成了课程、毕业了或仅仅是离开了。通常，重写某个东西比解读别人写得差且没有文档的代码更容易。这是一个恶性循环，因为重写工作往往没有完成，所以会有多个版本以不同的方式无法工作。例如，我最近需要从MP3文件中提取标签，尝试了六个不同的开源程序，每个都以不同的方式失败了。很难确定某个东西是否有一个好的可用版本，因为到处都是垃圾。
- en: When Richard Stallman started the GNU project, he assumed that the world was
    filled with programmers of similar quality to him and his peers. That assumption
    didn’t turn out to be valid. There is still a belief that one of the advantages
    of open source software is that you can add features and fix bugs that you find.
    Unfortunately, much of this software is poorly written and completely undocumented,
    making the amount of effort too great for a casual user or even an experienced
    programmer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当理查德·斯托曼开始GNU项目时，他认为世界上充满了像他和他的同行一样质量的程序员。但这个假设并没有成立。现在依然有人认为开源软件的一个优势是你可以添加功能并修复你发现的漏洞。不幸的是，很多这类软件编写得很糟糕，且完全没有文档，这使得对于普通用户甚至经验丰富的程序员来说，投入的努力过于巨大。
- en: Just because something is open source doesn’t mean that it’s a great example
    of the craft. But you can learn what not to do just as well as you can learn what
    to do from looking at other people’s code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为某样东西是开源的，并不意味着它是工艺的典范。但你可以通过查看别人写的代码，学到什么不该做的事，就像学到该做什么一样。
- en: Here are two indicators, one positive and one negative, that you can use to
    help determine the quality of a piece of code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个指标，一个是正面的，一个是负面的，你可以用它们来帮助判断一段代码的质量。
- en: The positive indicator is whether or not a project is under active development
    with more than one contributor. This doesn’t apply to projects that have been
    around for a long time and are actually “done.” It often helps if a project is
    supported by some organization. Many of the major open source projects originated
    at companies that still support their development. However, you must be wary of
    open source projects created at companies that are later acquired by other companies
    with different philosophies. For example, Sun Microsystems was a prodigious developer
    of open source software, including OpenOffice, Java, and VirtualBox. However,
    Sun was acquired by Oracle, which ended support for some of these projects and
    tried to find ways to control and monetize others; see the Oracle versus Google
    lawsuit for details. Other projects have been donated by companies to foundations
    that support their development. This often yields a consistent vision that keeps
    the project on track. This indicator is not completely reliable, so take it with
    a grain of salt. For example, the code base for the Firefox web browser is a poorly
    documented mess.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正面指标是项目是否在积极开发中，并且有超过一个贡献者。这不适用于那些已经存在了很长时间并且实际上“完成”的项目。如果一个项目得到了某个组织的支持，通常会有帮助。许多主要的开源项目最初来自那些仍然支持其开发的公司。然而，你必须警惕那些由公司创建的开源项目，这些公司后来被其他具有不同理念的公司收购。例如，Sun
    Microsystems曾是开源软件的主要开发者，包括OpenOffice、Java和VirtualBox。然而，Sun被Oracle收购，后者结束了对这些项目的支持，并尝试找办法控制和变现其他项目；有关详情请参见Oracle诉谷歌的诉讼。还有一些项目是由公司捐赠给支持其开发的基金会，这通常会带来一个一致的愿景，使项目保持在正轨上。这个指标并非完全可靠，所以要谨慎看待。例如，Firefox浏览器的代码库就是一团糟，且文档不完善。
- en: The negative indicator is the type and quantity of dialog that you’ll see at
    various programmer “self-help” websites. If you see lots of “I can’t figure out
    how to make this work” and “Where do I start to make this change?” questions,
    then it’s probably not a great piece of code. Furthermore, if the responses are
    mostly useless nonanswers or are snarky and unhelpful, then the project probably
    lacks good developers. Developers who blame the questioner for their own lack
    of quality work are not good role models. Of course, it’s also a bad sign if there
    are no comments or questions at all, as it means that the code is probably not
    used.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 负面指标是你在各种程序员“自助”网站上看到的对话类型和数量。如果你看到很多“我不知道怎么让这个工作”以及“我该从哪里开始进行这个修改？”之类的问题，那么这段代码可能就不怎么样。此外，如果回答大多是无用的空洞回答，或者带有讽刺性和不友好的态度，那么这个项目很可能缺乏优秀的开发者。那些将责任归咎于提问者、却未能提供高质量工作的开发者并不是好的榜样。当然，如果根本没有评论或问题，那也是一个不好的信号，这意味着代码可能没有被使用。
- en: Cautionary tales aside, open source is a great thing. Make your code open source
    when it makes sense to do so. But first, learn how to do a good job so that your
    code becomes a good example to others.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 警示故事撇开不谈，开源是一件好事。只有在合适的时候才将代码开源。但首先，要学会如何做好工作，这样你的代码才能成为他人的好榜样。
- en: '***Creative Commons***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创意共享***'
- en: The copyleft worked well for software, but software isn’t the only area in which
    society benefits from the ability to build on the past. When the copyleft was
    first created, most computer applications were text based; graphics, images, audio,
    and video were too expensive for the average consumer. Today, the sounds and visuals
    that are part of programs are arguably as important as the programs themselves.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 版权反向保护对软件来说非常有效，但软件并不是唯一一个从能够在过去的基础上构建的能力中受益的领域。当版权反向保护首次创建时，大多数计算机应用程序都是基于文本的；图形、图像、音频和视频对于普通消费者来说过于昂贵。今天，程序中的声音和视觉效果可以说和程序本身一样重要。
- en: American lawyer and academic Lawrence Lessig recognized the importance of artistic
    works and created a set of licenses for them similar to the copyleft called *Creative
    Commons*. There are many variants of these licenses, just like there are a variety
    of open source licenses for software. These range from “you can do anything you
    want” to “you have to give the creator credit” to “you have to share all of your
    changes” to “noncommercial use only” to “no derivative works allowed.”
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 美国律师和学者劳伦斯·莱西格认识到艺术作品的重要性，并为这些作品创建了一套类似于“版权反向保护”的许可证，称为*创意共享*。这些许可证有很多变体，就像软件有各种开源许可证一样。它们的范围从“你可以做任何你想做的事”到“你必须给创作者署名”再到“你必须分享所有的修改”以及“仅限非商业使用”到“禁止衍生作品”。
- en: The Creative Commons legal framework has greatly enhanced our ability to build
    on the work of others.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创意共享（Creative Commons）法律框架极大地增强了我们在他人工作基础上进行创新的能力。
- en: '***The Rise of Portability***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可移植性的崛起***'
- en: The term *portability* has a specific meaning for software. Code that is portable
    can run in a different environment than the one for which it was developed. That
    may be a different software environment, different hardware, or both. Portability
    wasn’t an issue in the early days of computing when there were just a handful
    of computer vendors, although standard languages like COBOL and FORTRAN allowed
    programs to be run on different machines. It became more important in the 1980s
    when the EDA industry (see “[Hardware vs. Software](ch03.xhtml#ch03lev1sec6)”
    on [page 90](ch03.xhtml#page_90)) and the availability of UNIX enabled the formation
    of a much larger number of computer companies.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*可移植性*在软件领域有着特定的含义。可移植的代码可以在不同于其开发环境的环境中运行。这个环境可能是不同的软件环境、不同的硬件，或者两者都有。早期计算机时代，计算机厂商不多，因此可移植性不是问题，尽管像
    COBOL 和 FORTRAN 这样的标准语言允许程序在不同的机器上运行。但在 1980 年代，随着 EDA 行业的崛起（参见 “[硬件与软件](ch03.xhtml#ch03lev1sec6)”
    第 90 页）和 UNIX 的普及，计算机公司数量大增，才使得可移植性变得更加重要。'
- en: These new computer vendors ported UNIX to their products; their customers didn’t
    have to worry about it. But another change happened at about the same time, which
    is that these less-expensive UNIX systems made inroads into the commercial market
    instead of being limited to academia. Source code was not shipped with many of
    these systems since the end users would never be building programs themselves.
    And, in an effort to increase profits, some companies started charging extra for
    certain UNIX tools, such as the C compiler. People who needed these tools started
    turning to the GNU tools since they were free, and often at least as good—and
    in many cases better than—the original UNIX tools.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的计算机厂商将 UNIX 移植到他们的产品上；他们的客户不需要担心这个问题。但大约在同一时期，另一个变化发生了，即这些低成本的 UNIX 系统开始进入商业市场，而不再仅限于学术界。这些系统没有随附源代码，因为最终用户通常不会自己编写程序。而且，为了增加利润，一些公司开始对某些
    UNIX 工具收费，比如 C 编译器。需要这些工具的人们开始转向 GNU 工具，因为它们是免费的，而且通常至少与原版 UNIX 工具一样好——在许多情况下甚至更好。
- en: But now, users had to port these tools to different systems themselves, which
    quickly became a huge pain point. Different systems had header files and libraries
    in different places, and many of the library functions had subtle differences
    in their behavior. This was addressed in two different ways. First, standards
    such as POSIX (portable operating system interface) were created to bring some
    consistency to the APIs and user environments. Second, the GNU project created
    a set of *build tools*, such as `automake`, `autoconf`, and `libtool`, to automate
    some of the system dependency checking. Unfortunately, these tools are incredibly
    cryptic and hard to use. Plus, they have their own dependencies, so code built
    with a particular version often can’t be built with another.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，用户必须自己将这些工具移植到不同的系统上，这很快成为了一个巨大的痛点。不同的系统在不同位置有头文件和库，许多库函数在行为上有细微差异。这个问题通过两种不同的方法得到了解决。首先，创建了像
    POSIX（可移植操作系统接口）这样的标准，以便为 API 和用户环境带来一些一致性。其次，GNU 项目创建了一套*构建工具*，如 `automake`、`autoconf`
    和 `libtool`，用于自动化一些系统依赖项的检查。不幸的是，这些工具极其晦涩，难以使用。而且，它们有自己的依赖项，因此用某个特定版本构建的代码往往不能用另一个版本构建。
- en: This is the state of the world today. Modern systems are more similar than they
    used to be because the world is pretty much UNIX based. And, while they’re clunky,
    the GNU build tools get the job done most of the time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当今世界的现状。现代系统比以前更为相似，因为这个世界基本上都是基于 UNIX 的。而且，尽管这些工具笨拙，GNU 构建工具大多数时候还是能完成任务。
- en: '***Package Management***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包管理***'
- en: Open source software, especially Linux, exacerbated the problem of distributing
    software. While people refer to Linux as if it’s a single system, there are many
    different configurations—from what’s used in data centers to desktops to the base
    for Android phones and tablets. Even if all systems had the same configuration,
    there are many different versions of each system. While source code is available,
    a lot of code is now distributed in precompiled, ready-to-run form.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件，尤其是 Linux，恶化了软件分发的问题。虽然人们通常把 Linux 看作是一个单一的系统，但实际上它有许多不同的配置——从数据中心使用的系统到桌面系统，再到
    Android 手机和平板的基础系统。即便所有系统配置相同，每个系统也有很多不同的版本。虽然源代码是开放的，但如今许多代码都以预编译、即开即用的形式进行分发。
- en: We talked about shared libraries back in “[Running Programs](ch05.xhtml#ch05lev1sec12)”
    on [page 137](ch05.xhtml#page_137). A precompiled program won’t work unless the
    system includes the right versions of the libraries on which it depends. Some
    large programs use huge numbers of libraries, and all of them need to be present
    and of the versions that the programs expect.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 “[运行程序](ch05.xhtml#ch05lev1sec12)” 章节中讨论过共享库，见 [第137页](ch05.xhtml#page_137)。如果系统中没有包含程序所依赖的正确版本的库，预编译的程序将无法运行。有些大型程序使用大量的库，而且所有这些库都需要存在，并且是程序所期待的版本。
- en: While there were some earlier attempts, *package management* really took off
    with Linux. Package management tools allow programs to be bundled into *packages*
    that include a list of dependencies. Package management tools such as `apt`, `yum`,
    and `dnf` not only download and install software but also check the target system
    for dependencies, downloading and installing them as necessary.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管早期曾尝试过一些方法，*软件包管理* 真正开始流行是在 Linux 上。软件包管理工具可以将程序打包成包含依赖关系列表的 *包*。像 `apt`、`yum`
    和 `dnf` 这样的包管理工具，不仅可以下载并安装软件，还能检查目标系统的依赖关系，必要时下载并安装它们。
- en: These tools work a good part of the time. But they tend to run into problems
    when different programs need different versions of the same dependencies. And,
    since package managers aren’t compatible, it’s a lot of work to get software ready
    to be installed on different systems.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具在很多时候能够正常工作。但当不同的程序需要同一个依赖的不同版本时，它们往往会遇到问题。而且，由于包管理工具之间不兼容，要将软件准备好安装到不同的系统上需要付出大量的工作。
- en: '***Containers***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***容器***'
- en: '*Containers* are a more recent, different approach to the package management
    problems. The idea is that an application and all of its dependencies are bundled
    up into a container. The container is then run in an environment where all of
    its pieces, such as data files, are kept isolated from the rest of the system.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器* 是一种更新且不同的解决包管理问题的方法。其理念是将一个应用程序及其所有依赖项打包成一个容器。然后，在一个环境中运行这个容器，确保它的所有部分，如数据文件，都与系统的其他部分隔离开来。'
- en: Containers simplify software deployment because they bundle up all of the dependencies
    (libraries and other programs) required by an application into a single package.
    This means that, provided your type of container is supported, you can just install
    a containerized application without having to worry about other things that it
    needs. A downside of this approach is that it effectively eliminates shared libraries
    (see “[Running Programs](ch05.xhtml#ch05lev1sec12)” on [page 137](ch05.xhtml#page_137)),
    resulting in less efficient memory utilization. Containers are also larger than
    applications by themselves.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 容器简化了软件部署，因为它们将应用程序所需的所有依赖项（库和其他程序）打包成一个单独的包。这意味着，只要你的容器类型被支持，你就可以安装一个容器化的应用程序，而不必担心它需要其他的东西。此方法的一个缺点是，它实际上消除了共享库（见
    “[运行程序](ch05.xhtml#ch05lev1sec12)” 章节，第 [137 页](ch05.xhtml#page_137)），导致内存利用效率较低。容器的体积也通常大于单独的应用程序。
- en: Security is touted as a benefit of containers. The idea is that running multiple
    applications on the same operating system allows applications to interfere with
    each other by leveraging OS bugs. While that may be true, it just means that a
    different class of bugs needs to be exploited.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的安全性被宣传为一种优势。其理念是，在同一个操作系统上运行多个应用程序可能会通过利用操作系统漏洞相互干扰。虽然这可能是事实，但这意味着需要利用不同类别的漏洞。
- en: Containerized applications called *snaps* are an option on many Linux systems.
    *CoreOS*, now *Container Linux*, is one of the major Linux container efforts.
    One of the developers was among the first people to suffer through the course
    notes that were the foundation of this book, so you’re in good company.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多 Linux 系统中，容器化应用程序被称为 *snaps*。*CoreOS*，现在的 *Container Linux*，是主要的 Linux 容器项目之一。其开发者之一曾是第一批经历本书基础课程笔记的人员，因此你在这里并不孤单。
- en: '***Java***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Java***'
- en: The Java programming language was created by a team at Sun Microsystems led
    by James Gosling starting in 1991\. Gosling has a track record of recognizing
    when technology has changed to the point where a different approach becomes practical.
    In this case, he realized that machines were fast enough that interpreters were
    a practical alternative to compiled code in many circumstances. The Java language
    looks a lot like C and C++.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Java 编程语言由 Sun Microsystems 的一个团队创建，团队由 James Gosling 领导，始于 1991 年。Gosling 一直以在技术发生变化到可以采用不同方法时做出正确判断而闻名。在这个案例中，他意识到机器足够快，以至于在许多情况下，解释型语言是编译代码的一个实用替代方案。Java
    语言与 C 和 C++ 非常相似。
- en: One of the ideas behind Java was that rather than recompiling your code for
    every target machine, someone would do that for the Java interpreter and then
    your code would just run. You would only have to write your code once and run
    it anywhere. This wasn’t a completely original concept, as Java wasn’t the first
    interpreted language.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Java 背后的一个理念是，与其为每个目标机器重新编译代码，不如让某个人为 Java 解释器做这件事，这样你的代码就可以直接运行。你只需编写一次代码并在任何地方运行。这并不是一个完全原创的概念，因为
    Java 并不是第一个解释型语言。
- en: Java was originally designed for television set–top boxes (back when it was
    called Oak). It was repurposed as a way to run code in browsers that was independent
    of the machine on which the browser was running. It has been somewhat eclipsed
    by JavaScript in that environment, although it’s still used. JavaScript is unrelated
    to Java, and is not quite as nice a language, but it’s much easier to write since
    it doesn’t require any special tools.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Java 最初是为电视机顶盒设计的（当时它被称为 Oak）。它被重新设计为一种可以在浏览器中运行的代码方式，且与浏览器运行的机器无关。在这个环境中，Java
    在一定程度上被 JavaScript 取代，尽管它仍然被使用。JavaScript 与 Java 无关，且并不像 Java 那样是一种优雅的语言，但它更容易编写，因为它不需要任何特殊工具。
- en: Java is important because it has become a popular teaching language. This is
    partly due to the fact that it uses garbage collection, which frees beginners
    from the complexity of explicit memory management. It’s a great place to start
    as long as you don’t stop there.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Java 很重要，因为它已成为一种流行的教学语言。这部分归因于它使用垃圾回收机制，解除了初学者对于显式内存管理的复杂性困扰。它是一个很好的起点，只要你不要止步于此。
- en: Java has become much more than a language; there is a whole ecosystem of software
    that surrounds it. That ecosystem includes a lot of custom tools and file formats,
    making life more difficult for programmers. The ecosystem is so complicated and
    fragmented that it’s not uncommon to hear programmers grumble that while they
    only have to write code once, getting the ecosystem installed and functional so
    that they can actually run that code is often pretty difficult.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Java 已不再只是一个语言；它已经发展成了一个围绕它的庞大软件生态系统。这个生态系统包括了许多自定义工具和文件格式，这使得程序员的生活更加困难。生态系统的复杂性和碎片化如此严重，以至于常常能听到程序员抱怨，虽然他们只需要编写一次代码，但让整个生态系统安装并正常运行，进而使代码能够真正执行，往往是非常困难的。
- en: Another downside to Java is the programming culture that has grown up around
    it. Java programmers tend to use hundreds of lines of code where one would suffice.
    When looking at someone else’s Java code, you often wonder where to find the line
    that actually does something. Some of this stems from Java being a good object-oriented
    language. Fanatics obsess over having a beautiful class hierarchy and often prioritize
    that over getting a job done.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的另一个缺点是围绕它形成的编程文化。Java 程序员往往会用数百行代码来实现一个本可以用一行代码完成的任务。在查看别人写的 Java 代码时，你常常会想，究竟哪里才是那行真正做事的代码。这其中部分原因是
    Java 是一门优秀的面向对象语言。狂热者们过于执着于拥有一个漂亮的类层次结构，往往把这个优先于完成任务。
- en: A good example is a Java database tool called *Hibernate*, which, as far as
    I can tell, tries to solve two “problems.” The first is that Java classes and
    subclasses do a great job of *data hiding*, or limiting the visibility of internal
    variables. But, despite the data hiding, code at the bottom of the class hierarchy
    accesses a global database, which causes some people to freak out philosophically.
    Hibernate uses special comments in Java to provide database manipulation, hiding
    reality from the programmer. Of course, this is all well and good until something
    breaks, at which time reality must be faced.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的例子是一个名为 *Hibernate* 的 Java 数据库工具，按照我所了解，它试图解决两个“问题”。第一个问题是，Java 类和子类非常擅长
    *数据隐藏*，或者限制内部变量的可见性。但尽管有数据隐藏，类层次结构底部的代码还是会访问一个全局数据库，这让一些人在哲学上产生了恐慌。Hibernate 使用
    Java 中的特殊注释提供数据库操作，将现实隐藏在程序员面前。当然，所有这些都很好，直到某些东西坏了，这时就不得不面对现实。
- en: The second thing that Hibernate does is to provide an abstraction called HQL
    (Hibernate Query Language) on top of the underlying database API, which is usually
    SQL (Structured Query Language). In theory, this allows programmers to perform
    database operations without having to worry about the differences between database
    systems.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 做的第二件事是提供一个叫做 HQL（Hibernate 查询语言）的抽象，位于底层数据库 API（通常是 SQL）之上。从理论上讲，这允许程序员执行数据库操作，而无需担心数据库系统之间的差异。
- en: Back before the C programming language was formally standardized, there were
    a number of incompatibilities between compilers. Rather than invent a “meta-C,”
    people came up with programming guidelines like “don’t use this feature.” By following
    these guidelines, code would work on any compiler.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 编程语言正式标准化之前，编译器之间存在许多不兼容问题。人们并没有发明一种“元 C”，而是提出了像“不要使用这个特性”这样的编程指南。通过遵循这些指南，代码就可以在任何编译器上运行。
- en: The differences between SQL implementations can be handled in a similar way
    without introducing yet another mechanism. It’s also worth noting that most serious
    SQL projects include something called *stored procedures* for which there is no
    compatibility among implementations. And HQL doesn’t provide support for them,
    so it missed out on the one place where it could have been really useful.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 实现之间的差异可以通过类似的方式处理，而不必引入新的机制。值得注意的是，大多数严肃的 SQL 项目都包含一种叫做 *存储过程* 的东西，而在不同的实现之间没有兼容性。而
    HQL 并不提供对存储过程的支持，因此错过了它本可以非常有用的一个地方。
- en: The feel-good value of hiding the underlying database system is not balanced
    out by having to learn a new language that doesn’t do everything you need.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏底层数据库系统的让人感觉良好的价值，并不能抵消学习一种无法满足所有需求的新语言所带来的负担。
- en: '***Node.js***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Node.js***'
- en: As you’ve seen in this book, JavaScript began life as a scripting language for
    browsers. *Node.js* is the latest environment that allows JavaScript to be run
    outside of a browser. One of its primary attractions is that it allows both the
    client and server sides of an application to be written in the same programming
    language.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书中所看到的，JavaScript 最初是作为浏览器脚本语言诞生的。*Node.js* 是最新的环境，它允许 JavaScript 在浏览器外运行。它的主要吸引力之一是，它允许客户端和服务器端的应用程序都用相同的编程语言编写。
- en: While the idea is good, the results vary. I avoid Node.js for a couple of reasons.
    First, Node.js invented its own package manager. Just what everyone needed—another
    incompatible method making it harder to maintain systems. As a contrast, even
    though Perl has its own package manager, it avoids decreasing value by making
    its packages available via system package managers such as `apt` and `dnf`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个想法很好，但结果却有所不同。我避免使用 Node.js 有几个原因。首先，Node.js 发明了自己的包管理器。真是每个人都需要的东西——又一个不兼容的方法，使得维护系统变得更加困难。与此对比，尽管
    Perl 有自己的包管理器，但它通过让其包可以通过系统包管理器（如 `apt` 和 `dnf`）来获取，避免了降低价值。
- en: Second, there are hundreds of thousands of Node.js packages with twisty interdependencies.
    The vast majority are not suitable for serious work. For some reason, Node.js
    attracts bad code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，Node.js 有成千上万的包，它们之间有复杂的相互依赖关系。绝大多数并不适合用于严肃的工作。出于某种原因，Node.js 吸引了许多糟糕的代码。
- en: '***Cloud Computing***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***云计算***'
- en: 'Cloud computing means using someone else’s computers over a network. It’s not
    really a new concept; it’s an updated version of the 1960s invention of time sharing.
    Two factors make cloud computing interesting:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算意味着通过网络使用他人的计算机。这并不是什么新概念；它是 1960 年代时间共享发明的更新版。使得云计算有趣的有两个因素：
- en: Networks have become more ubiquitous and speeds have increased dramatically.
    This makes functionality like streaming audio and video possible, not to mention
    offloading storage for things like email.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络变得更加普及，速度也显著提高。这使得流媒体音视频等功能成为可能，更不用说将存储卸载到如电子邮件等应用上了。
- en: Hardware prices have come down to the point where an incredible amount of computing
    power and storage is available. This has led to new algorithms and ways to solve
    problems that were previously not practical. Of course, the same can be said for
    desktop computers. My current machine has eight processor cores, 64GB of RAM,
    and 28TiB of disk. This was neither practical nor economical when I started programming.
    Another way of looking at it is that the machine on which I’m writing this book
    has more RAM than the total amount of disk storage on the machine that I used
    20 years ago.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件价格已经降低到足以提供惊人的计算能力和存储空间的程度。这促使了新的算法和解决问题的方式，这些方式在之前是不切实际的。当然，台式计算机也有类似的变化。我现在的机器有八个处理器核心，64GB的RAM和28TiB的硬盘。当我开始编程时，这样的配置既不实用也不经济。从另一个角度看，我现在写这本书的机器，其RAM比我20年前使用的计算机的硬盘总容量还要大。
- en: There’s nothing really magical about cloud computing; it’s just hardware and
    software. It has created new business models for renting computing resources.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算并没有什么神奇之处；它只是硬件和软件的结合。它为租赁计算资源创造了新的商业模式。
- en: Cloud computing has sparked a lot of innovation in hardware packaging. Data
    centers have completely different economies of scale, and reliability is important.
    Cramming huge numbers of machines into a space means paying a lot of attention
    to power and cooling. One creative scheme pioneered by Sun Microsystems involves
    building data centers in shipping containers instead of buildings.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算激发了硬件包装方面的许多创新。数据中心有着完全不同的规模经济，可靠性也至关重要。将大量机器压缩进一个空间意味着必须非常注意电力和散热问题。Sun
    Microsystems公司开创了一种富有创意的方案，即将数据中心建在集装箱中，而不是建造传统的建筑物。
- en: '***Virtual Machines***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***虚拟机***'
- en: It used to be that one program would run on one computer at a time. Operating
    systems made it possible to run multiple programs via time sharing. But not all
    application programs that users wanted were available on all operating systems,
    especially when closed source systems became the norm. Many users had to resort
    to using multiple computers running different operating systems, or having to
    reboot their machine to run different operating systems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，一个程序通常只能在一台计算机上运行。操作系统使得通过时间共享可以运行多个程序。但并非所有用户想要的应用程序都能在所有操作系统上运行，尤其是在封闭源代码系统成为常态时。许多用户不得不使用多台运行不同操作系统的计算机，或者重启机器来运行不同的操作系统。
- en: Hardware is now fast enough that entire operating systems can be considered
    applications, making time sharing between multiple operating systems practical.
    Keep in mind that this might require interpreting an instruction set that is different
    than that of the underlying physical machine. Also, it’s not enough just to be
    able to run the instruction set—the expected hardware environment must be present
    as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件现在足够快速，以至于整个操作系统可以被视为应用程序，使得多个操作系统之间的时间共享变得实用。需要注意的是，这可能需要解释与底层物理机器不同的指令集。另外，仅仅能够运行指令集还不够——预期的硬件环境也必须到位。
- en: Since these operating systems aren’t necessarily running directly on the physical
    machine hardware, they’re called *virtual machines*. Virtual machines provide
    many advantages other than eliminating the proprietary operating system lockout.
    They’re really useful for development, especially for operating system development.
    That’s because when the system under development crashes, it doesn’t also crash
    your development system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些操作系统不一定直接运行在物理机器硬件上，因此它们被称为*虚拟机*。虚拟机除了消除专有操作系统的锁定之外，还提供了许多其他优势。它们对于开发非常有用，尤其是操作系统开发。这是因为当开发中的系统崩溃时，它不会同时崩溃你的开发系统。
- en: Virtual machines are a mainstay of the cloud-computing world. You can rent space
    in the cloud and run whatever mix of operating systems you desire.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机是云计算世界中的主要支柱。你可以在云中租用空间，并运行你所需要的任何操作系统组合。
- en: The operating system that supports the virtual machines is often called a *hypervisor*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 支持虚拟机的操作系统通常被称为*虚拟机监控器（Hypervisor）*。
- en: '***Portable Devices***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***便携设备***'
- en: Just as with cloud computing, improvements in communication technology and hardware
    price/performance have made it possible to build portable devices with great power
    and functionality. A single modern cell phone has more computing power and storage
    than all of the computers in the world combined a few decades ago. Other than
    the portability, there’s nothing new or magical about these devices. Each has
    its own ecosystem and tools.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就像云计算一样，通信技术和硬件的性价比提高使得构建具备强大功率和功能的便携设备成为可能。如今一部现代手机的计算能力和存储量超过了几十年前全世界所有计算机的总和。除了便携性外，这些设备没有什么新奇或神奇之处。每个设备都有自己的生态系统和工具。
- en: The big challenge with portable device programming is power management. Because
    portable devices are battery powered, great care must be taken to minimize operations
    such as memory accesses, as they consume power and run down the battery.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植设备编程的一个巨大挑战是电源管理。由于可移植设备是电池供电的，因此必须非常小心，以最小化诸如内存访问等操作，因为它们消耗电力并且会耗尽电池。
- en: '**The Programming Environment**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程环境**'
- en: Programming for a living is not the same thing as working on personal or school
    projects. Working as a programmer means taking direction from, giving direction
    to, and working with others. Little if anything is taught about this aspect of
    the field in school. It’s often learned through a series of weird on-the-job experiences.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以编程为生与从事个人或学校项目是两回事。作为程序员工作意味着要从别人那里接受指导、向别人提供指导，并与他人协作。在学校里，几乎没有教授关于这一领域的这一方面的知识。这通常是通过一系列奇怪的工作经验学到的。
- en: '***Are You Experienced?***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***你有经验吗？***'
- en: So here you are, a new programmer with little or no experience. What is experience
    and how do you acquire it?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你现在是一名经验很少或没有经验的新程序员。什么是经验，如何获得经验？
- en: Employers are always looking for “experienced professionals.” What does that
    mean? The simplest definition is that a candidate has exactly the sought-after
    skills. But that’s not really a very good definition, and it’s often impractical.
    For example, I received a call in 1995 from a recruiter looking for someone with
    five years of Java programming experience. I had to explain that even the authors
    of Java didn’t have that level of experience because it hadn’t been around that
    long.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 雇主总是寻找“有经验的专业人士”。这是什么意思？最简单的定义是，候选人具备了所需的技能。但这并不是真正很好的定义，而且往往不切实际。例如，我在1995年接到一位招聘人员的电话，他在找一位拥有五年Java编程经验的人。我不得不解释说，即使是Java的作者也没有那么多经验，因为它还没有出现那么长时间。
- en: One of the satisfying things about programming is that you get to do things
    that have never been done before. So how can you start with the skills that you
    won’t have until you’re done? What’s a good definition of experience?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一大满足感在于，你可以做一些前所未做过的事情。那么，如何从那些直到你完成之前都不会具备的技能开始呢？什么是经验的好定义？
- en: First of all, you need to be grounded in the fundamentals. If all you know is
    how to build a website, you’re unlikely to be able to successfully contribute
    to a surgical robot project. But more importantly, experience is knowing what
    you can do and what you can’t do. How do you know what you can do when you haven’t
    done it yet? You need to learn to estimate. It’s not just guesswork; it’s heuristics.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要扎实的基础。如果你只知道如何构建一个网站，你很可能无法成功地为外科手术机器人项目做出贡献。但更重要的是，经验就是知道自己能做什么，不能做什么。当你还没做过某件事时，如何知道自己能做什么呢？你需要学会估算。这不仅仅是猜测，而是启发式的方法。
- en: '***Learning to Estimate***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***学习估算***'
- en: One of the most damaging things you can do as a member of a project team is
    to fail to deliver your work on time without warning. The key here is *without
    warning*; nobody delivers everything on time, but when being late is a surprise,
    it’s difficult for other team members to work around.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为项目团队的一员，最有害的事情之一就是未能按时交付工作且没有提前警告。关键在于*没有提前警告*；没人能够百分之百按时交付所有任务，但如果迟交让人感到意外，那么其他团队成员就很难做好调整。
- en: 'How do you learn to estimate? With practice. Start with this: before you do
    a task, such as a homework assignment, jot down your estimate of how long it will
    take. Then keep track of how long the task actually took. After a while, you might
    discover that you’re getting better at estimating. This is good practice because
    with homework, just like with programming, you’re always doing something that
    you haven’t done before.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何学习估算？通过实践。首先可以从这个开始：在你做某项任务之前，比如作业，先记录下你估计它将花费的时间。然后跟踪这项任务实际花费的时间。过一段时间后，你可能会发现自己在估算上变得更加准确了。这是一个好的练习，因为作业就像编程一样，你总是在做一些之前没做过的事情。
- en: 'An oft-abused but worthwhile management technique is status reporting: you
    regularly generate a short list of what you accomplished since the last report,
    what problems arose, and what your plans are for the next reporting period. This
    is just a more formal method of tracking your homework predictions. When a status
    report shows that the plans were not achieved but no problems were encountered,
    that’s a red flag. Status reporting gives you a way to adjust your estimates by
    comparing them to actual results.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常被滥用但却值得采用的管理技巧是状态报告：你定期生成一份简短的清单，列出自上次报告以来你完成了什么，出现了什么问题，以及你对下一个报告期的计划。这只是一种更正式的跟踪你作业预测的方法。当一份状态报告显示计划未达成，但没有遇到问题时，这就是一个警示信号。状态报告为你提供了一种通过将估算与实际结果进行比较来调整估算的方法。
- en: '***Scheduling Projects***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***项目排期***'
- en: Programming projects are generally more complex than your homework (with the
    possible exception of your programming class homework). How do you estimate a
    more complex project?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编程项目通常比你的作业更复杂（可能唯一的例外是你的编程课作业）。你如何估算一个更复杂的项目？
- en: A fairly simple method is to make a list of all of the pieces in the project.
    Put them into three appropriately sized bins, such as 1 hour, 1 day, and 1 week.
    Add up the results. You will probably be wrong about most of your guesses, but
    on average the total estimate will be pretty close. Status reporting is key here,
    because it shows that some things take more time than expected while others take
    less time, making it possible to track the original estimate.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当简单的方法是列出项目中的所有组成部分。将它们分成三个适当大小的类别，比如1小时、1天和1周。然后将结果加起来。你可能会在大多数猜测上出错，但总体估算会非常接近。状态报告在这里至关重要，因为它展示了某些事情花费的时间比预期的更多，而其他事情则花费的时间更少，这使得追踪最初的估算成为可能。
- en: Approaches like this are an important trade-off, because generating a complete
    and accurate schedule for a complex project often takes longer than just doing
    the project. And it still wouldn’t account for things like snow days.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的做法是一个重要的权衡，因为为一个复杂项目生成一个完整且准确的时间表通常比直接做项目还要花时间。而且它仍然无法考虑到像雪天这样的因素。
- en: Related to this is how projects actually get planned in the industry, which
    I explained when answering a question from the audience at an ACM lecture in 2004
    at Oregon State University. It’s not really possible to convey the slack-jawed
    silence that followed. Goes to show, you don’t learn everything you need to know
    in class. What happens is that you’ll distinguish yourself by doing a great job
    on some project. Your manager will take you aside and say, “Hey, nice job. We’re
    thinking about doing this new thing. Can you tell me how long it will take and
    how much it’ll cost?” You’ll feel so honored that you’ll give up your social life
    for a while to figure it all out in detail. You’ll do this without knowing (except
    you will, because you’ve read this) that before your manager talked to you, they
    already had some numbers in mind, possibly given to them by their manager. You’ll
    show your results to your manager, who will respond with, “Oh. Well, you know,
    if it’s going to take this long and cost this much, we just won’t do it.” A light
    will go on in your head and you’ll ask yourself, “Do I want to have a job next
    week?” You’ll say, “Well, this was conservative, I can pull it in here and there.”
    Now, a very interesting thing is taking place. You’re lying to your manager, who
    knows that you’re lying. Your manager also knows that your original numbers are
    correct, and that the project would come in on time and on budget if you were
    allowed to use them. Furthermore, they know that forcing you to use the more aggressive
    numbers will make the project late and over budget. But sadly, that’s the way
    it’s often done.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相关的是，项目在行业中实际上是如何规划的，这一点我在2004年在俄勒冈州立大学的ACM讲座中回答观众提问时做了解释。很难传达那时随之而来的目瞪口呆的沉默。证明了你并不能在课堂上学到所有需要知道的东西。实际上，发生的情况是，你会通过在某个项目上做出出色的工作来脱颖而出。你的经理会把你拉到一边说：“嘿，做得不错。我们在考虑做一个新项目。你能告诉我需要多长时间，以及它会花费多少吗？”你会感到非常荣幸，以至于你会暂时放弃社交生活，仔细研究所有细节。你会这么做，而并不知道（除非你看过这篇文章，你会知道）在你的经理和你交谈之前，他们已经有了一些数字，可能是他们的经理给的。你会把结果展示给经理，经理会回应说：“哦。如果它需要这么长时间并且花费这么多，我们就不做了。”你脑袋里会突然亮起一盏灯，你会问自己：“下周我还想有工作吗？”你会说：“嗯，这个估算很保守，我可以在某些地方收紧一下。”现在，发生了一件非常有趣的事情。你在对经理撒谎，而经理知道你在撒谎。经理也知道你最初的数字是正确的，并且如果允许使用这些数字，项目将按时完成并且不会超预算。此外，他们知道，强迫你使用更激进的数字将导致项目延迟并超出预算。但遗憾的是，这通常就是常见的做法。
- en: While this scenario may be hard to believe, keep in mind the popularity of *Dilbert*
    comics.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个场景可能难以置信，但请记住*迪尔伯特*漫画的受欢迎程度。
- en: As this example indicates, a common challenge in scheduling is management that
    refuses to accept schedules and true costs. Nonengineers often view schedules
    as something that can be negotiated; managers often feel that engineers are too
    conservative in scheduling and try to negotiate down the estimated time. This
    almost always leads to bigger problems down the road. The only legitimate way
    in which to decrease the time is to remove features.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，一个常见的调度挑战是管理层拒绝接受计划和真实成本。非工程师通常将计划视为可以协商的东西；经理们往往觉得工程师在调度时过于保守，并试图将估计时间压低。这几乎总是会导致后续更大的问题。唯一合法的减少时间的方式是去掉某些功能。
- en: '***Decision Making***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***决策制定***'
- en: There are many possible ways to do most projects. There are choices of programming
    languages, data structures, and more. Engineers are famous for having heated debates
    over the “right” way to do something. Sometimes projects don’t happen and people
    lose their jobs because they can never stop arguing and get down to work. Heated
    discussions often make management uncomfortable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目有许多可能的实施方式。可以选择的编程语言、数据结构等等。工程师以激烈争论“正确”做法而著称。有时项目因无法停止争论而无法进行，最终导致人们失业。激烈的讨论常常让管理层感到不安。
- en: An otherwise unexceptional manager taught me something very useful about resolving
    these sorts of problems. At the beginning of a project, he took all of us into
    a conference room and told us how he worked. He said that decisions were going
    to be made first and foremost on technical grounds. But, he said, many times there
    is no technical reason for doing things one way or another. He said that in those
    cases, it was perfectly okay to say, “I want to do it this way because I like
    it.” He explained that as long as nobody else preferred a different way, then
    he’d go along. He didn’t want to hear complicated pseudotechnical arguments that
    in reality were just someone justifying their particular preference but not saying
    so. In that case, not only would that person not get their way, but they’d probably
    also lose their job. The moral of this story is to keep technical necessities
    separate from personal preferences.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一位原本并不特别出色的经理教会了我一些关于解决这类问题的非常有用的东西。在一个项目开始时，他把我们所有人带进会议室，告诉我们他是如何工作的。他说，决定将首先基于技术原因来做出。但他说，很多时候，没有技术上的理由去做事的某种方式。他说，在这种情况下，说“我想这么做，因为我喜欢”是完全可以的。他解释说，只要没有人偏好另一种方式，那么他就会同意。他不想听到复杂的伪技术性论证，因为那些实际上只是某人在为自己的偏好辩解，却不直接说出来。若是那样的话，不仅那个人不会如愿，可能还会丢掉工作。这个故事的道德是：将技术需求与个人偏好分开。
- en: You’ve already gotten a taste of this sort of behavior in [Chapter 12](ch12.xhtml#ch12),
    where you learned that the actual rationale for and benefits of JavaScript promises
    are obfuscated by a fear of pyramid-of-doom rationalization.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在[第12章](ch12.xhtml#ch12)中初步了解过这种行为，在那里你学到了 JavaScript promises 的实际原理和好处常常被“末日金字塔”式的合理化所掩盖。
- en: '***Working with Different Personalities***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与不同性格的人合作***'
- en: I mentioned earlier in this chapter that programming usually involves working
    with other people.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章前面提到过，编程通常涉及与他人合作。
- en: Numerous “learn to code” boosters emphasize that “programming is fun.” I don’t
    agree; my sympathies are more in line with those expressed by Italian researcher
    Walter Vannini in his article “Coding Is Not ‘Fun’, It’s Technically and Ethically
    Complex.” Recall the two-step programming process from the book’s introduction.
    The second step, explain it to a three-year-old (that is, doing the actual programming),
    requires meticulous attention to detail. You’re probably at a stage where you
    have trouble keeping your room clean; that doesn’t translate to programming. I
    would say that programming is *satisfying*. The fun comes in the first step, understanding
    the problem. But even that’s not a barrel of laughs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 许多“学习编程”的倡导者强调“编程是有趣的”。我不同意；我的观点更倾向于意大利研究员沃尔特·瓦尼尼在其文章《编程不是‘有趣’的，它在技术和伦理上都很复杂》中表达的看法。回想一下本书介绍中的两步编程过程。第二步，向三岁小孩解释（也就是进行实际的编程），需要对细节进行细致的关注。你可能正处于一个很难保持房间整洁的阶段；但这并不等同于编程。我会说编程是*令人满足的*。乐趣出现在第一步，即理解问题。但即使如此，也并不是件轻松的事。
- en: People in any profession have a wide range of personalities, not all of which
    would be described as “well adjusted.” Programmers are no exception. While many
    programmers have balanced personalities, some favor technical prowess over social
    skills. There is a wide spectrum between Richard Stallman and Dennis Ritchie,
    with Linus Torvalds somewhere in between. This can be a source of problems, especially
    in this age where people are highly sensitive to word choices.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 各行各业的人有着各种各样的性格，其中并非所有都可以用“心理调适良好”来形容。程序员也不例外。虽然许多程序员的性格比较平衡，但也有一些人更注重技术能力，而忽视社交技能。从理查德·斯托尔曼到丹尼斯·里奇之间，有着一个广泛的跨度，而林纳斯·托瓦兹则介于其中。这可能成为问题的根源，尤其是在如今人们对措辞非常敏感的时代。
- en: 'There’s a lot of discussion in the media these days about abusive behavior
    in the workplace. Let me be clear: workplace abuse is never acceptable, so don’t
    be an abuser and don’t allow yourself to be abused. But it can often be difficult
    to determine what is abuse and what isn’t. That’s because people don’t have the
    same worldviews, and something that might be fine for one person might not be
    for another. The classic example is Apple founder Steve Jobs.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，媒体中关于职场暴力行为的讨论非常多。让我明确一点：职场暴力是绝对不可接受的，所以不要成为施暴者，也不要让自己成为被虐待者。但有时候，确定什么算是暴力行为，什么又不是，可能会很困难。这是因为人们的世界观不同，一些对某个人来说没问题的事情，可能对另一个人来说就不行。经典的例子是苹果创始人史蒂夫·乔布斯。
- en: You might think that this issue could be addressed with some simple rules. And
    it can, but there are trade-offs. Many years ago, I worked with a manager who
    expressed it pretty well. He said that while he could force the people in his
    group into “good behavior,” such as being less argumentative, the result would
    be losing much of the creative manic energy for which he hired those people. He
    felt that a large part of his job was to smooth over personality differences so
    that people would be productive.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这个问题可以通过一些简单的规则来解决。的确是可以，但也有权衡。许多年前，我曾和一个经理一起工作，他对这一点表达得非常好。他说，虽然他可以强迫团队成员“表现得更好”，比如减少争论，但这样做的结果是会失去他当初聘用这些人时所希望看到的那种创造性、狂热的能量。他认为自己工作的一大部分就是缓和性格上的差异，以便让团队更具生产力。
- en: A big source of problems is that programmers who are passionate about their
    work may be intensely critical of someone else’s. A hard lesson to learn is that
    it’s not personal. I once had an employee who—as I eventually learned—if I pointed
    out a bug in his code, he would interpret that as me telling him he was a bad
    person. As a contrast, when that same employee took delight at pointing out bugs
    in my code, my reaction was, “Let’s fix it because we want this to succeed.” At
    the core, this is about people having confidence in themselves. Try to build the
    confidence of your team members, as confident people are less likely to take things
    personally.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大问题来源是，热爱自己工作的人可能会对别人工作的表现产生强烈的批评。一个艰难的教训是，这并不是针对个人。我曾经有一个员工——我后来才知道——如果我指出他代码中的一个bug，他会认为我在告诉他他是一个糟糕的人。相反，当这个员工高兴地指出我代码中的bug时，我的反应是：“我们来修复它，因为我们希望这个项目成功。”从根本上讲，这与人们是否对自己有信心有关。尽量培养你团队成员的信心，因为有信心的人不太可能把事情看得太个人化。
- en: 'Related to this, I once worked for someone who regularly told me that what
    I was doing was stupid. Eventually, I figured out what was happening and said
    the following: “You know, I finally realized that when you tell me that what I’m
    doing is stupid, you’re really saying that you don’t understand what I’m doing.
    Now that I know that, I’ll ignore you as best I can. But I’m human, so every time
    you say ‘stupid,’ I get less work done for the next few days. So if you want to
    get your money’s worth, you might try to just tell me that you don’t understand
    things.”'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相关的是，我曾经为一个人工作，这个人经常告诉我我做的事情很愚蠢。最终，我弄明白了发生了什么，并说了以下的话：“你知道吗，我终于意识到，当你告诉我我做的事情很愚蠢时，实际上是在说你不理解我在做什么。现在我知道了，我会尽量忽视你。但我也是人，每次你说‘愚蠢’时，接下来的几天我都会做得更少。所以，如果你想让自己得到物有所值的回报，你可能可以直接告诉我你不理解这些事情。”
- en: Communication is important. A characteristic of insecure people is that they
    try to make others feel inferior either by talking way above their level or by
    being condescending. The job of a secure person is to figure out how to speak
    to others at their level of understanding. As an example, I was at a party at
    the 1989 SIGGRAPH (Special Interest Group on Computer Graphics) conference and
    overheard someone there ask another person for help in understanding a paper written
    by Loren Carpenter, the first geek to win an Academy Award. This other person
    patiently explained the paper. Afterward, the first person said, “Hey, thanks.
    That really helped. My name is Joe, what’s yours?” to which the other person replied,
    “I’m Loren.” Be like Loren.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 沟通非常重要。不安全感强的人往往试图通过说一些超出他人理解范围的话或表现出居高临下的态度来让别人感到自卑。一个有安全感的人应该学会如何与别人以他们能理解的方式进行沟通。举个例子，我曾在1989年SIGGRAPH（计算机图形学特别兴趣小组）会议的一个聚会上，听到有人请求另一个人帮助理解洛伦·卡彭特（Loren
    Carpenter）写的论文——他是第一个获得奥斯卡奖的极客。那个人耐心地解释了论文内容。之后，那个请求帮助的人说：“嘿，谢谢。真的很有帮助。我叫乔，你叫什么名字？”那人回答：“我是洛伦。”要像洛伦一样。
- en: 'One more thing to keep in mind if you do end up in a difficult situation at
    work: Human Resources is not your friend. Their job is not to protect you; it’s
    to protect the company from liability.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你最终陷入了职场的困境，还需要记住一件事：人力资源部不是你的朋友。他们的工作不是保护你，而是保护公司免于承担责任。
- en: '***Navigating Workplace Culture***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***职场文化导航***'
- en: Each workplace has its own unique culture. Finding one that matches your personality
    is key to having a successful and enjoyable career. Results-based and personality-based
    cultures are opposite ends of the spectrum.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个职场都有其独特的文化。找到一个与你个性匹配的文化是拥有成功且愉快职业生涯的关键。以结果为导向的文化和以个性为导向的文化是两种截然不同的极端。
- en: 'Amy Wrzesniewski, Clark McCauley, Paul Rozin, and Barry Schwartz’s 1997 article
    “Jobs, Careers, and Callings: People’s Relations to Their Work” partitions people’s
    work into the three categories in the article’s title. In short, people get financial
    rewards from jobs, advancement from careers, and enjoyment from callings. Matching
    your category and personality to your workplace is a key component of success.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Amy Wrzesniewski、Clark McCauley、Paul Rozin 和 Barry Schwartz 于 1997 年发表的文章《工作、职业与使命：人们与工作关系》将人们的工作分为文章标题中的三类。简而言之，人们从工作中获得经济回报，从职业中获得晋升，从使命中获得享受。将你的类别和个性与工作环境匹配是成功的关键因素。
- en: Jobs and careers work better in personality-based cultures. These cultures reward
    drama-free personal interactions. People treat each other well, at least face-to-face.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 工作和职业在基于个性化的文化中运作得更好。这些文化奖励无戏剧性的个人互动。人们彼此对待得很好，至少在面对面的情况下是如此。
- en: Callings and results-based cultures go together. Getting the best job done is
    the reward even if doing so involves heated arguments and intense discussions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使命感和基于结果的文化是相辅相成的。即使完成工作时涉及激烈的争论和深入的讨论，得到最佳的工作成果仍然是奖励。
- en: As an example, this book’s technical editor and I spent a month having an intense
    argument about a paragraph in [Chapter 7](ch07.xhtml#ch07). We were both happy
    that we reached a great solution, and that happiness made up for all of the arguing.
    We were both annoyed that it took so long to find a solution, but that’s the way
    it is; sometimes solutions are not obvious. If that sort of process and outcome
    makes you happy, you want to find a workplace that values such behavior.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，本书的技术编辑和我花了一个月的时间就 [第七章](ch07.xhtml#ch07)中的一个段落进行激烈的争论。我们都很高兴达成了一个很好的解决方案，而这种高兴弥补了所有的争吵。我们都感到烦恼的是找到解决方案花了这么长时间，但事实就是如此；有时解决方案并不显而易见。如果这种过程和结果让你感到高兴，那么你就应该找到一个重视这种行为的工作场所。
- en: It’s worth taking a step back to reframe the problem when a solution is elusive.
    However, it’s difficult to remember to do this in the middle of a passionate discussion.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个解决方案难以找到时，退后一步重新审视问题是值得的。然而，在热烈的讨论中很难记得去做这件事。
- en: '***Making Informed Choices***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***做出明智的选择***'
- en: You may have noticed that I haven’t exactly had glowing things to say about
    certain parts of the technology spectrum, such as the web. This may have you wondering
    why you’d want to work in this field. A lot depends on what you want to get out
    of your work, as per the previous section. Keep in mind that all endeavors have
    their good and bad aspects. Choose your work situations with your eyes open.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，我并没有对技术领域中的某些部分（例如互联网）有过多的赞美。这可能让你疑惑，为什么你会想在这个领域工作。很多事情取决于你想从工作中获得什么，正如前一部分所提到的。请记住，所有的事业都有其好与坏。睁开眼睛选择你的工作环境。
- en: There’s often a trade-off between interesting work and making lots of money.
    People with callings prefer interesting work and would do it for free if necessary.
    People with jobs or careers often get paid handsomely for working with cumbersome
    or broken technology. A good example is the large number of people who remembered
    how to program in COBOL, who found and fixed Y2K bugs. These were bugs in antiquated
    code that involved dates and kept only the last two digits of the year. The transition
    from 1999 to 2000 would have broken this code, which was in use for lots of critical
    infrastructure.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，做有趣的工作和赚很多钱之间存在权衡。拥有使命感的人倾向于选择有趣的工作，并且如果有必要，会愿意免费做这份工作。拥有工作或职业的人则常常因使用笨重或损坏的技术而获得丰厚的报酬。一个典型的例子是许多人记得如何用
    COBOL 编程，他们发现并修复了 Y2K 错误。这些错误出现在过时的代码中，涉及日期并只保留年份的最后两位数字。1999 年到 2000 年的过渡将会破坏这些代码，而这些代码在许多关键基础设施中使用。
- en: '**Development Methodologies**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**开发方法论**'
- en: 'It seems like every field of endeavor spawns “methodology experts.” Programming
    is no different, except possibly that there is such zeal that *ideology* is a
    more appropriate term than *methodology*. And every methodology seems to come
    with its own uniform, hairstyle, terminology, and secret handshakes. To a large
    degree, this just makes it easier for adherents to exclude the nonbelievers, the
    opposite of the Loren Carpenter example earlier. And it can become ridiculous:
    I was discussing methodology with a client who finally blurted out, “As long as
    we have a completely Agile pivoting scrum, things should be okay.”'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来每个领域的努力都会催生出“方法论专家”。编程也不例外，甚至可能有着更强烈的热情，以至于*理念*这个词比*方法论*更为合适。每一种方法论似乎都有自己的制服、发型、术语和秘密握手。很大程度上，这让信徒更容易将非信徒排除在外，这正好与之前提到的
    Loren Carpenter 的例子相反。而且这可能变得荒谬：我曾与一个客户讨论方法论，最终他脱口而出：“只要我们有一个完全敏捷的 pivot scrum，一切就应该没问题。”
- en: My expert advice is to not take any ideology too seriously. None of them work
    in pure form; you need to cherry-pick the ideas and use those that make sense
    for your project. How do you decide what works for your project? Let’s look at
    the various stages of development ([Figure 15-2](ch15.xhtml#ch15fig02)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我的专家建议是不要把任何理念当作绝对真理。没有哪个理念是完美适用的；你需要挑选出那些对你项目有意义的思想。如何决定哪些理念适用于你的项目呢？我们来看看开发的各个阶段（[图
    15-2](ch15.xhtml#ch15fig02)）。
- en: '![Image](../images/15fig02.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/15fig02.jpg)'
- en: '*Figure 15-2: Project development cycle*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：项目开发周期*'
- en: We have the three questions with which we began this chapter. A big distinction
    between ideologies is the role of the user.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这一章开始时提出的三个问题仍然有效。各种理念的一个重要区别在于用户的角色。
- en: Contrary to what you might believe from observing the world around you, software
    is written for things other than entertainment. An ideology that works for a website
    or video game is probably not appropriate for a satellite, power plant, pacemaker,
    or car.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与你通过观察周围的世界可能会相信的不同，软件的编写不仅仅是为了娱乐。适用于网站或视频游戏的理念，可能不适用于卫星、电厂、起搏器或汽车。
- en: It’s important to know exactly what you’re doing for projects in which the cost
    of failure is high, so the users (#1) are involved early on in order to come up
    with a clear definition. Once you have a definition, you can begin coding, which
    is usually—and should be—reviewed by peers. The result is tested against the definition.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些失败代价高的项目，确切知道自己在做什么非常重要，因此需要尽早让用户（#1）参与进来，形成明确的定义。一旦有了定义，就可以开始编写代码，这通常——也应该——经过同侪的审查。最终的结果会根据定义进行测试。
- en: When the cost of failure is low, there’s less incentive to come up with a clear
    definition in advance. It’s common to take more of a “We’ll know it when we see
    it” attitude. Users (#2) play a more important role in looking at results and
    deciding whether or not the right thing has been done. Testing to determine whether
    or not the code actually works is often confused with testing to determine whether
    or not users like the current definition.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当失败的代价较低时，提前明确地定义并没有太大的动力。通常会采取一种“看到时我们就知道”的态度。用户（#2）在查看结果并决定是否做对了方面扮演更重要的角色。测试是否代码能正常工作，往往会和测试用户是否喜欢当前定义混淆。
- en: Laziness and incompetence are not good development methodologies. Many people
    don’t write specifications because they don’t know how. Choose a methodology that’s
    right for the project first and the people second.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰和无能不是好的开发方法。很多人不编写规范，因为他们不知道怎么做。首先为项目选择合适的开发方法，其次再考虑团队成员的适应性。
- en: '**Project Design**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目设计**'
- en: A project starts with an idea. It might be your idea, or it might come from
    someone else. How does that turn into code?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目从一个想法开始。它可能是你的想法，也可能来自别人。那么这个想法是如何转化为代码的呢？
- en: You can, of course, just start coding. And that’s just fine for small personal
    projects. But for anything significant, there are some processes that you can
    follow that lead to better results.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以直接开始编写代码。这对于小型个人项目是完全可以的。但对于任何较为重要的项目，存在一些流程可以遵循，从而带来更好的结果。
- en: '***Writing It Down***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***写下它***'
- en: Start by writing the idea down. You’ll be surprised by how that gets you to
    fill in a lot of missing details.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时先把想法写下来。你会惊讶于它能让你填补许多遗漏的细节。
- en: It’s important for your documentation to be at the correct level. Talk about
    what you’re going to do, not how you’re going to do it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文档必须处于正确的层级。谈论你打算做什么，而不是你将如何做。
- en: As an example of how not to go about it, I was once asked to help out on a project
    to design a new blood pressure monitor. The client sent me about 5,000 pages of
    documentation and asked me to estimate the cost, which I was unable to do. It
    turns out that, due to prior problems, company management had issued an edict
    that no code would be written without documentation. Sounds good, but they ignored
    the fact that none of their people knew how to write documentation, and they didn’t
    provide any training. So the engineers wrote code without telling management and
    then described their code in longhand English. Nowhere did their documents even
    mention that the product was a blood pressure monitor.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为如何避免做法的一个例子，我曾经被要求参与一个设计新的血压监测仪的项目。客户寄给我大约5000页的文档，并要求我估算成本，但我无法做到。原来，由于先前的问题，公司管理层发布了一项命令，要求在没有文档的情况下不能编写任何代码。听起来不错，但他们忽略了一个事实，那就是他们的员工根本不知道如何编写文档，也没有提供任何培训。于是，工程师们在没有通知管理层的情况下编写代码，然后用长篇的英语描述他们的代码。在他们的文档中，甚至没有提到该产品是血压监测仪。
- en: Another example is the Apache web server. Good piece of software. Tons of documentation
    on how to set this or that configuration parameter. Never says that it’s a web
    server or describes how the pieces relate.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是Apache Web服务器。是个不错的软件，有大量关于如何设置这个或那个配置参数的文档。却从未说明它是一个Web服务器，或者描述各部分之间的关系。
- en: '***Fast Prototyping***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***快速原型设计***'
- en: One development methodology that deserves a mention is *fast prototyping*. This
    involves whipping out a partially working version of your project. Just like writing
    things down, prototyping helps you to understand your idea in more depth. A prototype
    can also be a useful tool to help explain your idea to others.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一种值得提及的开发方法论是*快速原型设计*。这涉及到快速制作一个部分可用的项目版本。就像写东西一样，原型设计有助于你更深入地理解你的想法。原型也可以作为一个有用的工具，帮助你向别人解释你的想法。
- en: 'Watch out for these pitfalls:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 小心这些陷阱：
- en: Don’t mistake your prototype for production code. Throw it out and write new
    code using what you learned from doing the prototype.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要把你的原型当作生产代码。扔掉它，并基于你从原型中学到的知识编写新代码。
- en: Don’t allow yourself to be forced into coming up with a hard schedule for the
    prototype. After all, a big reason for prototyping is that you don’t know enough
    to be able to generate a realistic schedule.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要让自己被迫为原型制定一个严格的时间表。毕竟，进行原型设计的一个重要原因是你对项目的了解还不够，无法生成一个现实的时间表。
- en: Most difficult, don’t let your management mistake your prototype for a shippable
    product.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最困难的一点是，别让你的管理层把你的原型当作可以交付的产品。
- en: One of the hallmarks of prototype code that got shipped is a lack of coherency.
    In his book *The Stuff of Thought* (Penguin), Steven Pinker discusses the difference
    between working with blocks and working with the principles that govern the behavior
    of those blocks. You’re mainly working with blocks during prototyping. It’s important
    to take a step back after the prototype is functional to observe those governing
    principles and then reimplement the code to use those principles consistently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 已经交付的原型代码的一个标志性特征就是缺乏连贯性。在他的书《思想的本质》（Penguin）中，史蒂文·平克讨论了与操作模块块和操作控制这些模块行为的原则之间的区别。在原型设计中，你主要是在操作模块块。原型功能实现后，重要的是退后一步，观察这些控制原则，然后重新实现代码，以一致地运用这些原则。
- en: '***Interface Design***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***接口设计***'
- en: Your project will occupy some place in a *software stack*; you saw an overview
    of this in [Figure 1](intro.xhtml#ifig01) on [page xxxiii](intro.xhtml#page_xxxiii).
    Software is the filling in a sandwich that communicates with things above and
    below it. The interfaces that your application uses make up the bottom piece of
    bread. You need to define the top piece.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目将在*软件堆栈*中占据某个位置；你在[图 1](intro.xhtml#ifig01)中看到了这个概览，位于[第xxxiii页](intro.xhtml#page_xxxiii)。软件就像三明治中的馅料，和上下层的内容进行通信。你的应用程序使用的接口构成了底层的那片面包。你需要定义顶部的那片面包。
- en: System programming occupies the space between the hardware and the applications.
    System programs communicate with hardware using whatever combination of registers
    and bits are detailed in the device manufacturer’s datasheets. But system programs
    also have to communicate with applications. The line between them is called the
    *application program interface (API)*. An API is called a *user interface (UI)*
    if it’s used by people instead of by other programs. There are numerous APIs since
    programs are built in layers; there may be an operating system at the bottom with
    an API that is used by libraries, which in turn are used by applications. How
    is an API designed? What makes a good one?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 系统编程位于硬件和应用程序之间。系统程序通过使用设备厂商数据表中详细说明的寄存器和位的任意组合与硬件进行通信。但系统程序也需要与应用程序进行通信。它们之间的界线被称为
    *应用程序接口（API）*。如果 API 被人使用而不是其他程序使用，它就被称为 *用户界面（UI）*。由于程序是分层构建的，所以有许多 API；底层可能有一个操作系统，操作系统提供的
    API 被库使用，而库又被应用程序使用。那么，如何设计 API 呢？一个好的 API 是怎样的？
- en: A good way to start is to document the *use cases*, situations in which the
    API is used to accomplish some task or set of tasks. You can collect use cases
    by querying the eventual users of a program. But keep in mind that users often
    give shortsighted answers because they’re already using something. A lot of their
    feedback tends to be of the “make it like this with that change” variety. And
    a pile of discrete requirements doesn’t make for a clean result.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的起点是记录 *用例*，即使用 API 来完成某项任务或一组任务的情境。你可以通过询问程序的最终用户来收集用例。但要记住，用户往往会给出目光短浅的回答，因为他们已经在使用某些东西。他们的反馈很多都是“像这样做，换成那个”这种类型。而一堆离散的需求并不会得到一个干净的结果。
- en: Now, you could just do what the users request, and it might work out for a while.
    But for an API to have legs, you need to abstract the user requirements and synthesize
    an elegant solution. Let’s look at a few examples.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以只按照用户的要求去做，这可能暂时有效。但要让一个 API 具有生命力，你需要抽象用户需求，并合成一个优雅的解决方案。我们来看几个例子。
- en: The original Apple Macintosh API was published in 1985 in a three-volume set
    of books called *Inside Macintosh* (Addison-Wesley). The set was over 1,200 pages
    long. It’s completely obsolete; modern (UNIX-based) Macs don’t use any of it.
    Why didn’t this API design last?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 Apple Macintosh API 于 1985 年发布，包含一本名为 *Inside Macintosh* 的三卷本书（Addison-Wesley）。这套书超过了
    1200 页，已经完全过时；现代的（基于 UNIX 的）Mac 不再使用其中的任何内容。为什么这个 API 设计没有持续下来？
- en: The Mac API could be described as very wide and shallow. It had a huge number
    of functions, each of which did one particular thing. An argument could be made
    that this interface didn’t last because it was too specific; the lack of abstractions,
    or generalizations, made it impossible to extend as new use cases arose. Of course,
    more functions could have been added, making it even wider, but that’s not a very
    practical approach.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Mac API 可以被描述为非常广泛且浅薄。它有大量的功能，每个功能都只做一件事。可以说，这个接口没有持续下来是因为它过于具体；缺乏抽象或概括，使得在出现新用例时无法扩展。当然，可以添加更多的功能，让它变得更加广泛，但这并不是一个很实用的方法。
- en: By contrast, version 6 of the UNIX operating system was released 10 years earlier
    in 1975, with a 321-page manual. It embodied a completely different approach that
    sported a narrow and deep API. The narrowness and depth were made possible by
    a good set of abstractions. What’s an abstraction? It’s a broad category of things;
    for example, rather than talking individually about cats, dogs, horses, cows,
    and so on, you could use the abstraction “animals.” These abstractions were evident
    not just in the system calls (see “[System and User Space](ch05.xhtml#ch05lev1sec8)”
    on [page 133](ch05.xhtml#page_133)) but also in the applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，UNIX 操作系统的第 6 版在 1975 年发布，距离现在已经有 10 年，它有一本 321 页的手册。它体现了一种完全不同的方法，拥有一个狭窄而深刻的
    API。狭窄和深刻得以实现，得益于良好的抽象集合。什么是抽象？它是一个广泛的类别；例如，与其分别谈论猫、狗、马、牛等，不如使用抽象的“动物”来统一表达。这些抽象不仅体现在系统调用中（参见
    [“系统与用户空间”](ch05.xhtml#ch05lev1sec8) 在 [第 133 页](ch05.xhtml#page_133)），还体现在应用程序中。
- en: For example, you’re probably familiar with the concept of a file as a place
    to store data. Many operating systems had different system calls for each type
    of file. UNIX had a single type of file with a handful of system calls. For example,
    the `creat` system call could create any type of file. (When asked if he would
    do anything different if he were redesigning the UNIX system, Ken Thompson replied,
    “I’d spell `creat` with an `e`.”) As part of the file abstraction, even I/O devices
    were treated as files, as you saw in [Chapter 10](ch10.xhtml#ch10).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能熟悉将文件作为存储数据的地方的概念。许多操作系统为每种类型的文件提供不同的系统调用。UNIX 则只有一种类型的文件，并提供少数几个系统调用。例如，`creat`
    系统调用可以创建任何类型的文件。（当被问到如果重新设计 UNIX 系统会做什么不同的事情时，Ken Thompson 回答：“我会把 `creat` 拼写成
    `create`。”）作为文件抽象的一部分，即使是 I/O 设备也被当作文件来处理，正如你在[第10章](ch10.xhtml#ch10)中看到的那样。
- en: Compare this abstraction to the `pip` (Peripheral Interchange Program) utility
    on contemporary DEC systems. It was a hugely complicated and ungainly tool that
    had special commands that allowed users to copy files. There were specific commands
    to copy files to tapes, printers, and more. By contrast, UNIX had a single `cp`
    (copy) command that users could use to copy files independent of their type and
    where they lived. You could copy a file to an I/O port connected to a printer
    as easily as you could copy a file from one place to another.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种抽象与当代 DEC 系统上的 `pip`（外围交换程序）工具进行对比。它是一个非常复杂且笨拙的工具，具有特殊的命令，允许用户复制文件。它有专门的命令将文件复制到磁带、打印机等地方。相比之下，UNIX
    只有一个 `cp`（复制）命令，用户可以使用它独立于文件类型和存储位置复制文件。你可以像从一个地方复制文件到另一个地方一样轻松地将文件复制到连接到打印机的
    I/O 端口。
- en: 'The UNIX abstractions supported a novel programming philosophy:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 的抽象支持了一种新颖的编程哲学：
- en: Each program should do one thing and do it well. Make another program to do
    something new instead of adding complication to old ones.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个程序应该做一件事，并且做得好。如果需要做新事情，就制作另一个程序，而不是在旧程序中增加复杂性。
- en: Build programs to work together; the output of programs should be usable as
    input to other programs. Do complicated things by hooking simple programs together
    instead of writing huge monolithic programs.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建程序使其能够协同工作；程序的输出应该能作为其他程序的输入。通过将简单程序连接在一起做复杂的事情，而不是编写庞大的整体程序。
- en: Both the UNIX API and a large number of the original applications are still
    in widespread use today, more than 40 years later, which is a testament to the
    quality of the design. Not only that, but a large number of the libraries are
    still in use and essentially unchanged, though their functionality has been copied
    into many other systems. And the book *The UNIX Programming Environment* (Prentice
    Hall) by Brian Kernighan and Rob Pike is still worth a read even though it’s decades
    old.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到今天，UNIX API 和大量最初的应用程序仍然被广泛使用，距今已经超过 40 年，这证明了其设计的质量。不仅如此，大量的库仍然在使用，且基本没有变化，尽管它们的功能已经被复制到许多其他系统中。而
    Brian Kernighan 和 Rob Pike 合著的《The UNIX Programming Environment》（Prentice Hall）一书，即使已经出版了几十年，仍然值得一读。
- en: A more subtle advantage of this modular approach is that new programs not only
    have intrinsic value but also add to the value of the ecosystem as a whole.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块化方法的一个更微妙的优势是，新程序不仅有内在的价值，还能为整个生态系统增添价值。
- en: Switching gears slightly, I mentioned earlier that a UI is an API for users
    instead of other programs. In his 2004 book *The Art of Unix Usability*, Eric
    Raymond supplies an interesting case study of the Common Unix Printing System
    (CUPS), which gives numerous insights on how not to design user interfaces.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微转个话题，我之前提到过，UI 是一个供用户使用的 API，而不是供其他程序使用。在他 2004 年的书籍《The Art of Unix Usability》中，Eric
    Raymond 提供了一个有趣的案例研究，讲述了通用 UNIX 打印系统（CUPS），其中包含了如何不设计用户界面的诸多见解。
- en: 'Designing a great interface is hard. Here are a few points to keep in mind:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个优秀的接口是困难的。以下是一些要记住的要点：
- en: An API should not expose implementation internals. It should not depend on a
    particular implementation.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 API 不应该暴露实现的内部细节。它不应依赖于特定的实现。
- en: APIs should exhibit *conceptual heaviness*, which is another way of saying that
    there should be good abstractions.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 应该表现出*概念的重量感*，这可以理解为应该有良好的抽象。
- en: APIs should be *extensible*, or adaptable to future needs. Good abstractions
    help here.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 应该是*可扩展的*，或适应未来的需求。良好的抽象有助于此。
- en: APIs should be *minimal*, meaning that they shouldn’t be larded with multiple
    ways to do the same thing.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 应该是*简洁的*，意味着它们不应该有多种方式做同一件事。
- en: '*Modularity* is good; if an API provides related sets of functionality, make
    them as independent as possible. This also makes it easier to break a project
    into pieces so that multiple people can work on it simultaneously.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块化*是好的；如果一个API提供相关的功能集，应该尽可能使它们独立。这也使得将项目拆分成多个部分以便多个人同时工作变得更容易。'
- en: Functionality should be *composable*; that is, it should be easy to combine
    the pieces in useful ways. (Don’t misread this as *compostable*. The world already
    has too many poorly designed interfaces rotting away.) For example, if you had
    an interface that returned sorted search results, it might make sense to separate
    out the searching and sorting so that they could be used both independently and
    in combination.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能应该是*可组合*的；也就是说，应该能够轻松地将各个部分组合成有用的方式。（不要误读为*可堆肥*。世界上已经有太多设计不良的接口在腐烂。）例如，如果你有一个返回排序搜索结果的接口，可能会有意义将搜索和排序分开，以便它们既可以独立使用，也可以组合使用。
- en: Unless you’ve been asleep, you’ve noticed that I’m a fan of the UNIX philosophy.
    This is because it works, not because it’s flashy and trendy. And it illuminates
    the previous points.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你一直在睡觉，否则你应该已经注意到，我是UNIX哲学的拥趸。这是因为它有效，而不是因为它华丽和时髦。而且它也阐明了之前的观点。
- en: As we discussed earlier, one UNIX feature that is now also available on many
    other systems is the file abstraction. Most operations on files are not performed
    using the filename; instead, the filename is converted into a handle called a
    *file descriptor*, which is used instead. This abstraction allows users to perform
    file operations on things that are not technically files, such as connecting to
    something over a network.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，一个UNIX特性现在也可以在许多其他系统上找到，那就是文件抽象。对文件的绝大多数操作并不是通过文件名来执行的；相反，文件名会被转换成一个叫做*文件描述符*的句柄，并用它来代替。这个抽象使得用户能够对那些技术上不是文件的东西执行文件操作，比如通过网络连接到某个东西。
- en: As we saw in [Chapter 10](ch10.xhtml#ch10), when a program is started on UNIX,
    it is passed a pair of file handles called *standard input* and *standard output*.
    You can think of a program as a water filter in a pipe; unfiltered water flows
    into standard input, and filtered water pours from standard output. One of the
    clever things about UNIX is that the standard output of one program can be hooked
    to the standard input of another via something called a *pipe*. For example, if
    you had a water filter program and a water heater program, you could hook them
    together to get heated, filtered water without having to write a special program
    to do that. You can think of UNIX as a crate full of random tools and parts from
    which things can be built.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第10章](ch10.xhtml#ch10)中看到的，当一个程序在UNIX上启动时，它会被传递一对称为*标准输入*和*标准输出*的文件句柄。你可以将程序想象成管道中的水过滤器；未过滤的水流入标准输入，过滤后的水从标准输出流出。UNIX的一个巧妙之处在于，一个程序的标准输出可以通过一个叫做*管道*的东西连接到另一个程序的标准输入。例如，如果你有一个水过滤程序和一个水加热程序，你可以将它们连接起来，得到加热的过滤水，而不需要编写一个专门的程序来实现这一点。你可以把UNIX想象成一个装满随机工具和零件的箱子，里面的东西可以用来构建各种各样的东西。
- en: An amusing illustration of this philosophy occurred in 1986, when Don Knuth
    (professor emeritus of computer science at Stanford University and author of *The
    Art of Computer Programming* series, which you should own a copy of) wrote an
    article for *Communications of the ACM* that included more than 10 pages of code
    to cleverly solve a particular problem. This was followed by a critique from Doug
    McIlroy (Ken Thompson and Dennis Ritchie’s boss at Bell Laboratories) showing
    how the entire solution could be written as a single line of six pipelined UNIX
    commands. The moral of the story is that good general-purpose tools that can be
    interconnected beat one-off special solutions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这一哲学的一个有趣插曲发生在1986年，当时唐·克努斯（斯坦福大学计算机科学名誉教授，《计算机程序设计的艺术》系列的作者，建议你拥有一册）为《ACM通讯》写了一篇文章，包含了超过10页的代码，巧妙地解决了一个特定问题。随后，道格·麦克伊罗伊（肯·汤普森和丹尼斯·里奇在贝尔实验室的老板）对该文进行了批评，展示了如何用六个管道化的UNIX命令将整个解决方案写成一行。这个故事的寓意是，好的通用工具可以互相连接，胜过一次性解决方案。
- en: One of the things that made pipelining work was that programs mostly worked
    on text and thus had a common format. Programs didn’t rely on much structure in
    the data other than a line of text or fields separated by some character. Some
    claim that this approach only worked because in “simpler times,” text could be
    a common format. But again, the API has legs. Program suites such as ImageMagick
    provide complex image-processing pipelines. Programs also exist to handle data
    with a more complex structure, such as XML and JSON.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 管道化工作的一大原因是程序主要处理文本，因此它们有一个共同的格式。程序并不依赖数据中的太多结构，除了文本行或由某个字符分隔的字段。一些人声称这种方法只在“更简单的时代”才有效，因为文本可以作为一种通用格式。但再说一次，API
    是有生命力的。像 ImageMagick 这样的程序套件提供了复杂的图像处理管道。也有程序可以处理具有更复杂结构的数据，如 XML 和 JSON。
- en: '***Reusing Code or Writing Your Own***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重用代码或编写自己的代码***'
- en: While defining the top-slice-of-bread interface is critical to a project, you’ll
    also face difficult decisions in selecting the bottom slice of bread. On what
    code that you didn’t write are you going to rely?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然定义面包的顶层切片接口对项目至关重要，但你在选择面包的底层切片时也会面临艰难的决策。你将依赖哪些你没有编写的代码？
- en: Your program will likely use libraries (see “[Running Programs](ch05.xhtml#ch05lev1sec12)”
    on [page 137](ch05.xhtml#page_137)) other people have written that include functions
    you can use instead of writing your own. How do you know when to use a library
    function and when to write something yourself?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序可能会使用别人编写的库（见《[运行程序](ch05.xhtml#ch05lev1sec12)》[第 137 页](ch05.xhtml#page_137)），这些库包含了你可以使用的功能，替代自己编写。你怎么知道何时使用库函数，何时自己编写代码？
- en: At one level, this is the same problem as finding good open source software,
    as we discussed earlier in “[Open Source Software](ch15.xhtml#ch15lev2sec2)” on
    [page 419](ch15.xhtml#page_419). If a library doesn’t have a stable API, then
    it’s likely that future releases will break your code. Multiply this by the number
    of libraries, and it’s clear that all of your time will go into fixing things
    instead of writing your own code. Too many libraries can make your code fragile.
    For example, a package on which many other packages depended was broken in Node.js
    recently, affecting a large number of programs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，这与我们之前在《[开源软件](ch15.xhtml#ch15lev2sec2)》中讨论的找到优秀的开源软件是同一个问题（见 [第 419
    页](ch15.xhtml#page_419)）。如果一个库没有稳定的 API，那么未来的版本很可能会破坏你的代码。将这一点与库的数量相乘，很明显你所有的时间都会用来修复问题，而不是编写自己的代码。库太多会让你的代码变得脆弱。例如，最近
    Node.js 中有一个包破裂，导致许多其他依赖该包的程序受到影响。
- en: Sometimes you need to use libraries because they implement something that takes
    really specialized knowledge that you don’t have. A good example of this is the
    OpenSSL cryptography libraries.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要使用库，因为它们实现了你没有的真正专业知识。一个很好的例子就是 OpenSSL 加密库。
- en: Some argue that using libraries is better than writing your own code because
    libraries in wide use have been debugged. Unfortunately, that’s not always true;
    the OpenSSL library is a notable example.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有人认为使用库比自己编写代码更好，因为广泛使用的库经过了调试。不幸的是，这并不总是正确的；OpenSSL 库就是一个显著的例子。
- en: Normally I would say that you shouldn’t use a library when the number of lines
    of code to include the library exceeds the number of lines of code needed to write
    it yourself—for example, using `glibc` to implement singly linked lists. However,
    you also need to think about the environment in which the library is used; `glibc`
    is used by so many programs that it likely resides in memory as a shared library,
    so it effectively gets you code without using any memory space.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我会说，当包含库的代码行数超过自己编写库所需的代码行数时，就不应该使用库——例如，使用 `glibc` 来实现单向链表。然而，你还需要考虑库使用的环境；`glibc`
    被如此多的程序使用，它很可能作为共享库驻留在内存中，因此实际上它为你提供了代码，而不占用任何内存空间。
- en: It’s often very difficult to find useful libraries. A recent article mentioned
    that there are over 350,000 Node.js packages. It’s probably faster to write your
    own code than it is to find the right needle in such a gargantuan haystack.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 找到有用的库通常非常困难。最近的一篇文章提到，Node.js 包有超过 350,000 个。与其在如此庞大的数据堆中找到合适的针，可能还不如自己编写代码来得更快。
- en: '**Project Development**'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目开发**'
- en: At this point, you can hopefully create a specification for a project and a
    schedule for implementation. How do you turn this into reality?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点时，你应该能够为项目创建规范并制定实施计划。你如何将这些变为现实？
- en: Consider using Linux or some other UNIX derivative for your programming. There
    are many ways to do this. If you have a Mac, you’re all set because there’s a
    variant of UNIX underneath. You can install Linux on your PC. If that’s not practical,
    you can run a *live image*, which means running from a DVD and not changing anything
    on your PC’s hard drive. A better option is to run Linux in a *virtual machine*,
    which is a piece of software that lets you run a different operating system within
    a window on your computer. For example, you can install *VirtualBox* on a Windows
    machine and then run Linux there.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用 Linux 或其他 UNIX 衍生系统进行编程。实现这一目标的方法有很多。如果你有一台 Mac，那就万事俱备，因为它底层是 UNIX 的一个变种。你也可以在你的
    PC 上安装 Linux。如果这不现实，你可以运行一个*实时镜像*，这意味着从 DVD 运行而不改变你 PC 上的硬盘内容。一个更好的选择是通过*虚拟机*运行
    Linux，虚拟机是一款软件，允许你在电脑的窗口内运行不同的操作系统。例如，你可以在 Windows 机器上安装*VirtualBox*，然后在里面运行 Linux。
- en: '***The Talk***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***那一谈***'
- en: Okay, it’s time for the talk. Maybe your parents were too embarrassed; maybe
    they thought that you’d hear about it at school. Or maybe they think that you’ll
    find out what you need on the internet. That’s all pretty lame. If you’re going
    to be a serious code slinger, you need to have an adult relationship with computers.
    You need to put down the mouse and learn to use a text editor.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是谈话时间了。也许你的父母太尴尬了，或者他们认为你会在学校听到，或者他们觉得你会在网上找到你需要的资料。无论如何，这些都太敷衍了。如果你打算成为一个认真的程序员，你需要和计算机建立一种成年人的关系。你需要放下鼠标，学会使用文本编辑器。
- en: '**Adult Relationships with Computers**'
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**与计算机的成年关系**'
- en: Your relationship with computers has been pretty childlike so far. You’ve been
    pointing, clicking, poking, and otherwise tickling the computer and watching it
    giggle in response. That doesn’t cut it for programming.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你与计算机的关系一直以来都是比较幼稚的。你一直在点击、点击、戳戳，或者以其他方式逗弄计算机，看着它作出反应。这些做法对于编程来说是远远不够的。
- en: Programming involves a pretty intense relationship with a computer. You’ll be
    doing a lot more than just typing up a paper or watching a video—so much more
    that you’re going to need to be much more productive. That means that it’s time
    to learn how to use power tools.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 编程涉及与计算机的紧密互动。你将做的不仅仅是敲打论文或者观看视频——而是做更多的事情，以至于你需要提高效率。这意味着是时候学习如何使用强大的工具了。
- en: Many of these tools are cryptic and a bit difficult to learn. Too bad. Once
    you get the hang of them, you’ll never go back because you can get so much more
    accomplished with much less effort. So, grit your teeth and put in the up-front
    work; it’ll pay off big-time later!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些工具都很难理解，有些学习起来有点困难。没办法。一旦你掌握了它们，你就再也不会回头了，因为你能以更少的努力完成更多的事情。所以，咬紧牙关，做好前期的努力，后续会有很大的回报！
- en: '**Terminals and Shells**'
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**终端与 Shell**'
- en: Remember all that stuff about terminals in [Chapter 6](ch06.xhtml#ch06)? Well,
    guess what? Real programmers still use ’em. Terminals don’t make a racket or do
    the green flash anymore. And they’re not a separate machine; they’re a piece of
    software that runs on the computer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 记得[第 6 章](ch06.xhtml#ch06)中讲的关于终端的那些内容吗？好吧，猜猜怎么着？真正的程序员现在仍然在使用它们。终端不再发出喧闹的声音，也不再出现绿色闪光了。而且它们不再是独立的机器；它们只是运行在计算机上的一款软件。
- en: All desktop computer systems have terminals, even if they make them hard to
    find. By default, terminals run *command interpreters*. You’ll be presented with
    a command *prompt*. As you might expect, you enter commands at a command prompt.
    Systems rooted in UNIX—such as Apple products, Linux, and FreeBSD—have a command
    interpreter or *shell* named *bash*. Of course, Windows does its own thing, but
    it’s possible to install bash on Windows systems.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有桌面计算机系统都有终端，即使它们让终端变得难以找到。默认情况下，终端运行*命令解释器*。你会看到一个命令*提示符*。正如你可能预料的那样，你需要在命令提示符下输入命令。基于
    UNIX 的系统——如苹果产品、Linux 和 FreeBSD——都有一个命令解释器或*Shell*，它叫做*bash*。当然，Windows 自行运行另一套系统，但也可以在
    Windows 系统上安装 bash。
- en: THE BASH SHELL
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: THE BASH SHELL
- en: One of the original UNIX shells, named `sh`, was written by Stephen Bourne.
    Over the years, other shells were created that had more features. Unfortunately,
    these new features came with personalities that were completely incompatible with
    `sh`. Eventually, a new version of `sh` was written that incorporated these additional
    features in a compatible way. This version was named `bash` for “Bourne-again
    shell.” Retaining the legacy Bourne identity was a huge value-add that resulted
    in supremacy among shells.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的UNIX shell之一，名为`sh`，由Stephen Bourne编写。随着时间的推移，创建了更多功能的shell。不幸的是，这些新功能带来了与`sh`完全不兼容的特性。最终，编写了一个新的`sh`版本，它以兼容的方式整合了这些额外功能。这个版本被命名为`bash`，即“Bourne-again
    shell”（重生的Bourne shell）。保留Bourne的遗产是一个巨大的附加值，导致了它在各个shell中的主导地位。
- en: 'Many of the commands have cryptic names, such as `grep` (global regular expression
    printer). It’s a lot like anatomy, where many body parts are named after something
    else they resemble or after the person who first discovered them. For example,
    the `awk` command was named after its authors: Alfred Aho, Peter Weinberger, and
    Brian Kernigan. It all makes a compelling case for evolution. It’s hard to distinguish
    people talking about these commands from grunting cavemen.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令都有晦涩的名字，比如`grep`（全局正则表达式打印工具）。这有点像解剖学，许多身体部位是根据它们所类似的东西或最先发现它们的人来命名的。例如，`awk`命令是以其作者Alfred
    Aho、Peter Weinberger和Brian Kernigan的名字命名的。这为进化提供了有力的论据。很难从说这些命令的人中分辨出他们是不是像洞穴人一样在咕哝。
- en: A big reason to learn these cryptic commands is automation. A powerful shell
    feature is that you can put commands into a file, creating a program that runs
    those commands. If you find yourself doing something a lot, you can just make
    a command to do it for you. This is way more productive than sitting at a fancy
    graphical program clicking buttons and waiting for results.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 学习这些晦涩命令的一个重要原因是自动化。一个强大的shell功能是你可以将命令写入文件，创建一个运行这些命令的程序。如果你发现自己经常做某件事，可以为它创建一个命令来自动完成。这样比坐在一个花哨的图形化程序里点击按钮，等待结果要高效得多。
- en: '**Text Editors**'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**文本编辑器**'
- en: Text editors are programs that let you create and modify vanilla ASCII data,
    which is the stuff of which programs are made (I am completely unqualified to
    comment on programming languages that use non-ASCII characters such as Chinese).
    A main advantage of text editors is that they operate using commands, which is
    way more efficient than cutting and pasting stuff with a mouse—at least, once
    you learn them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑器是让你创建和修改纯ASCII数据的程序，而程序就是由这些数据构成的（我完全没有资格评论使用非ASCII字符的编程语言，比如中文）。文本编辑器的一个主要优势是它们通过命令操作，这比用鼠标剪切和粘贴要高效得多——至少，在你学会这些命令之后。
- en: 'There are two popular text editors: *vi* and *Emacs*. Learn to use one (or
    both). Each has its fanatical following ([Figure 15-3](ch15.xhtml#ch15fig03)).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有两款流行的文本编辑器：*vi* 和 *Emacs*。学习使用其中一个（或两个）。每个都有它的狂热粉丝（[图15-3](ch15.xhtml#ch15fig03)）。
- en: '![Image](../images/15fig03.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig03.jpg)'
- en: '*Figure 15-3: vi vs. Emacs*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-3：vi与Emacs的对比*'
- en: 'Eclipse and Visual Studio are examples of fancy programming tools known as
    *integrated development environments*, or *IDEs*. (Check their release date: beware
    the IDEs of March.) While IDEs are great for untangling someone else’s poorly
    written code, you’re already lost if you need them. Going way back to the book’s
    introduction, learn the fundamentals before losing sight of them in fancy tools.
    Also, you’ll find that such tools are pretty slow and you can be much more effective
    with simple but powerful alternatives. For example, you can edit a program with
    a text editor and rebuild it faster than you can start one of these tools.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse和Visual Studio是一些花哨的编程工具，统称为*集成开发环境*（*IDE*）。（查看它们的发布日期：小心三月的IDE。）虽然IDE在解开别人写得糟糕的代码时非常有用，但如果你需要它们，你已经迷失了。从本书的介绍开始，先学习基本知识，避免在花哨的工具中失去它们。此外，你会发现这些工具非常慢，使用简单而强大的替代工具会更高效。例如，你可以用文本编辑器编辑程序，然后比启动这些工具更快地重新编译它。
- en: '***Portable Code***'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***便携代码***'
- en: While you may never intend to use a piece of software elsewhere, it’s surprising
    how often it happens. And if your code is open source, others may want to use
    it (or pieces of it) elsewhere. How do we write code so that it’s not overly difficult
    to port? The short answer is to avoid hardwiring where possible.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能从不打算在其他地方使用某个软件，但你会惊讶于它发生的频率。而且，如果你的代码是开源的，其他人可能会希望在其他地方使用它（或其中的一部分）。我们如何编写代码，使其不会过于难以移植？简短的答案是尽量避免硬编码。
- en: As you learned earlier in this book, there’s a wide variety of ways in which
    hardware can differ, such as the bit and byte ordering and word size. Separate
    from the hardware, there are differences in how programming languages present
    the hardware to the programmer. For example, a trouble spot in C and C++ is that
    the language standards don’t define whether or not a `char` is signed or unsigned.
    The workaround is to be explicit in your code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在本书中前面学到的，硬件差异有很多种，例如位序和字节序、字长等。除了硬件本身，编程语言如何向程序员展示硬件也存在差异。例如，C和C++中的一个难点是，语言标准没有定义`char`是否是有符号的或无符号的。解决方法是，在代码中明确说明。
- en: You can use the `sizeof` operator in C to determine the number of bytes in a
    data type. Unfortunately, you need to write small programs to determine the bit
    and byte order. Many languages include ways to find out, for example, the largest
    and smallest numbers that can be stored in a particular data type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，你可以使用`sizeof`运算符来确定数据类型的字节数。不幸的是，你需要编写小程序来确定位和字节顺序。许多语言都提供了查找特定数据类型能够存储的最大和最小数字的方法。
- en: Character sets are another troublesome area. Using UTF-8 avoids many problems.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 字符集是另一个棘手的领域。使用UTF-8可以避免许多问题。
- en: Many programs use external libraries and other facilities. How do you insulate
    something like string comparison from system differences? One way is to stick
    to standard functionality. For example, standards such as POSIX define the behavior
    of library functions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序使用外部库和其他工具。如何将诸如字符串比较之类的操作与系统差异隔离开来呢？一种方法是坚持使用标准功能。例如，像POSIX这样的标准定义了库函数的行为。
- en: There will be differences between target environments that can’t be dealt with
    easily. Put as many of these dependencies as possible in a single place instead
    of scattering them throughout your code. That makes it easy for someone else to
    make the needed changes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 目标环境之间会存在一些无法轻易解决的差异。将尽可能多的这些依赖项集中在一个地方，而不是分散在代码的各个部分，这样可以让其他人更容易做出必要的更改。
- en: Just because code can be built for another system doesn’t mean that it’s a good
    idea. A classic example is the X Window System. In the early 1980s, Stanford graduate
    student Andy Bechtolsheim designed a special workstation-like personal terminal
    to run on the Stanford University Network. Stanford licensed the hardware design,
    which became the foundation of SUN Microsystems’ line of Sun Workstation products.
    Stanford professors David Cheriton and Keith Lantz developed the V operating system,
    which ran on the SUN. It featured a very fast synchronous interprocess communication
    mechanism, which meant that programs could communicate with each other very quickly.
    Paul Asente and Brian Reed developed the W window system, which ran on the V system.
    This code eventually made it to MIT, where it was ported to UNIX and renamed X.
    But UNIX didn’t have the fast synchronous IPC; it had a slower asynchronous IPC
    designed for the embryonic internet. X’s performance was worse than awful, and
    it took a major redesign to get it up to terrible.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为代码可以为另一个系统构建，并不意味着这是一个好主意。一个经典的例子是X窗口系统。在1980年代初期，斯坦福大学研究生安迪·贝赫托尔斯海姆设计了一款特殊的工作站型个人终端，用于在斯坦福大学网络上运行。斯坦福大学授权了这一硬件设计，这也成为了SUN
    Microsystems公司Sun工作站系列产品的基础。斯坦福大学的教授大卫·切里顿和基思·兰茨开发了V操作系统，该系统运行在SUN上。它具有非常快速的同步进程间通信机制，这意味着程序之间可以非常快速地进行通信。保罗·阿森特和布莱恩·里德开发了W窗口系统，该系统运行在V系统上。这段代码最终传到了MIT，并被移植到UNIX上，并重新命名为X。但UNIX没有快速的同步IPC；它有一个较慢的异步IPC，设计用于初期的互联网。X的性能差得令人难以忍受，经过大规模的重构后，它的表现才勉强变得不那么糟糕。
- en: '***Source Control***'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***源代码管理***'
- en: 'Programs change: you add to them, you modify them to fix bugs, and so on. How
    do you keep track of all of your old versions? It’s important to be able to go
    back in time, because you may introduce a bug in a new version and need to see
    what changed.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是不断变化的：你添加新功能，修改代码以修复错误，等等。如何追踪所有旧版本呢？能够回溯历史非常重要，因为你可能在新版本中引入了bug，需要查看发生了哪些变化。
- en: Time to flog more UNIXisms. Doug McIlroy created a program called *diff* in
    the early 1970s that compared two files and generated a list of differences. This
    program could optionally produce output in a form that could be piped into a text
    editor so that users could take a file and a list of differences and produce a
    changed file, leveraging composability. Mark Rochkind built on this idea to create
    the *Source Code Control System (SCCS)*. Rather than storing a complete copy of
    every changed file, SCCS stored the original and a list of changes for each version.
    This allowed users to request any version of the file, which would get constructed
    on the fly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该是多说一些UNIX文化的时刻了。道格·麦克伊罗伊（Doug McIlroy）在1970年代初期创建了一个名为*diff*的程序，用来比较两个文件并生成差异列表。该程序可以选择性地输出一个可以通过管道传递到文本编辑器中的格式，以便用户可以拿着文件和差异列表生成修改后的文件，从而利用可组合性。马克·罗奇金德（Mark
    Rochkind）在此基础上开发了*源代码控制系统（SCCS）*。与其存储每个已更改文件的完整副本，SCCS存储原始文件和每个版本的更改列表。这使得用户可以请求任何版本的文件，而该版本会即时构建。
- en: SCCS had an awkward user interface, and it was slow because as revisions piled
    up, more sets of changes had to be applied to reconstruct a version. Walter Tichy
    released *Revision Control System (RCS)* in 1982\. RCS had a better user interface
    and used backward differencing instead of SCCS’s forward differencing, meaning
    that RCS kept the most recent version and the changes needed to generate older
    versions. Since the current version was mostly what users wanted, it was much
    faster.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: SCCS具有尴尬的用户界面，并且由于修订版本积累，重建一个版本时需要应用更多的更改集，因此运行速度较慢。沃尔特·蒂奇（Walter Tichy）于1982年发布了*修订控制系统（RCS）*。RCS拥有更好的用户界面，并且采用了向后差异（backward
    differencing），而不是SCCS的向前差异，这意味着RCS保留了最新版本以及生成旧版本所需的更改。由于当前版本通常是用户最需要的，因此它的速度更快。
- en: SCCS and RCS only worked well on a single computer. Dick Grune developed the
    *Concurrent Versioning System (CVS)*, which essentially provided network access
    to RCS-like functionality in addition to being the first system to use merges
    instead of locks.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: SCCS和RCS只在单台计算机上有效。迪克·格鲁内（Dick Grune）开发了*并发版本控制系统（CVS）*，它本质上为RCS提供了网络访问功能，并且是第一个使用合并而不是锁定的系统。
- en: The original SCCS and RCS tools didn’t scale well because they relied on file
    locking; users would “check out” a file, edit it, and then “check in.” A checked-out
    file couldn’t be edited by others. This was especially problematic if someone
    locked a file and went on vacation. In response to this limitation, *distributed*
    systems such as Subversion, Bitkeeper, and Git were created. These tools replace
    the lock problem with the merge problem. Anyone can edit files, but they must
    reconcile their changes with changes made by others when checking back in.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的SCCS和RCS工具扩展性较差，因为它们依赖于文件锁定；用户会“签出”一个文件，编辑它，然后“签入”。被签出的文件不能被其他人编辑。如果有人锁定了文件并去度假，这就特别成问题。为了应对这一限制，*分布式*系统如Subversion、Bitkeeper和Git应运而生。这些工具将锁定问题替换为合并问题。任何人都可以编辑文件，但他们在重新签入时必须将自己的更改与他人的更改进行合并。
- en: Use one of these programs to track your code. RCS is very simple and easy to
    use if you’re just working on a project by yourself on your own system. Right
    now, Git is the most popular for distributed projects. Learn it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些程序之一来跟踪你的代码。如果你只是自己在个人系统上做一个项目，RCS非常简单且易于使用。目前，Git是分布式项目中最受欢迎的工具。学会使用它。
- en: '***Testing***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试***'
- en: You can’t really know if a program is working unless you test it. Develop a
    set of tests along with your program. (Some methodologies espouse starting with
    the tests.) Keep the tests under source control. Again, one of the great things
    about UNIX automation is that you can craft a single command that fires off a
    complete batch of tests. It’s often useful to do a nightly build, where the program
    build is started at a particular time every day and tests are run. *Regression
    testing* is a term used to describe the process of verifying that code changes
    didn’t break anything that used to work. *Regress* in this context means “to go
    backward”; regression testing helps to make sure that fixed bugs aren’t reintroduced.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能真正知道一个程序是否正常工作，除非你进行测试。与程序一起开发一组测试。（一些方法论主张从测试开始。）将测试保存在源代码控制中。同样，UNIX自动化的一大优势是，你可以编写一个单一命令，触发一整套测试。做一个每晚构建（nightly
    build）通常非常有用，程序的构建会在每天的某个特定时间启动，并运行测试。*回归测试*是一个术语，用来描述验证代码更改没有破坏曾经正常工作的过程。*回归*在此语境中指的是“倒退”；回归测试有助于确保修复的bug没有重新引入。
- en: Several programs are available to help you do testing. While it’s complicated,
    there are frameworks that allow you to test user interfaces by programmatically
    typing and clicking.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种程序可以帮助你进行测试。虽然这很复杂，但有一些框架可以让你通过编程输入和点击来测试用户界面。
- en: Where possible, have someone else also generate tests for your code. It’s natural
    for the person writing the code to be subconsciously blind to known problems and
    to avoid writing tests for them.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，让别人也为你的代码生成测试。编写代码的人很自然会对已知的问题产生潜意识的盲点，并避免为这些问题编写测试。
- en: '***Bug Reporting and Tracking***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***错误报告与跟踪***'
- en: Users will find bugs in your code independent from your own testing. You need
    some way for them to report bugs and some way to track how and whether those bugs
    were fixed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 用户会在你的测试之外发现代码中的错误。你需要某种方式让他们报告这些错误，并且能够跟踪这些错误是否已被修复。
- en: Again, there are many tools available to support this.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有许多工具可以支持这一点。
- en: '***Refactoring***'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重构***'
- en: '*Refactoring* is the process of rewriting code without changing the behavior
    or interfaces. It’s sort of like fast prototyping slowly. Why would you do this?
    Primarily because when the code was fully fleshed out, it became a mess and you
    think you know how to do it better. Refactoring can reduce maintenance costs.
    However, you need a good set of tests to make sure that the refactored code works
    like it’s supposed to. Also, any time things are being rewritten, there’s a temptation
    to add new features—don’t give in to it. Refactoring is a good time to reexamine
    the principles behind what’s already been done as mentioned earlier in “[Fast
    Prototyping](ch15.xhtml#ch15lev2sec20)” on [page 432](ch15.xhtml#page_432).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*重构*是指在不改变行为或接口的情况下重写代码。这有点像是慢速的快速原型制作。为什么要这么做呢？主要是因为当代码完全写出来时，它变得很乱，而你觉得自己能做得更好。重构可以减少维护成本。然而，你需要一套良好的测试，以确保重构后的代码如预期般正常工作。而且，每当进行重写时，总会有一种诱惑想要加入新特性——不要屈服于它。重构是重新审视之前所做工作背后原则的好时机，正如在[《快速原型制作》](ch15.xhtml#ch15lev2sec20)中[432页](ch15.xhtml#page_432)提到的那样。'
- en: '***Maintenance***'
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***维护***'
- en: One programming fact that’s not obvious is that for any serious piece of code,
    the cost of maintenance greatly exceeds the cost of development. Keep this in
    mind. Avoid doing cute twisty things that might impress your peers. Remember that
    if people doing maintenance were as smart as you, they’d be doing design, not
    maintenance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不太明显的编程事实是，对于任何严肃的代码来说，维护的成本远远超过开发的成本。记住这一点。避免做那些可能让你的同行印象深刻的花里胡哨的事。记住，如果做维护工作的人和你一样聪明，他们应该在做设计，而不是做维护。
- en: In [Chapter 12](ch12.xhtml#ch12), you saw several different ways to write asynchronous
    JavaScript code. Some of these ways keep everything in one place, while others
    separate setup from execution. It takes longer for maintainers to find and fix
    bugs when they have to track down all of the pieces.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](ch12.xhtml#ch12)中，你看到几种不同的编写异步 JavaScript 代码的方法。其中一些方法将所有内容集中在一个地方，而另一些则将设置与执行分开。当维护者需要追踪所有部分时，找到并修复错误的时间会更长。
- en: Some programmers believe that a program is a work of art that must be understood
    in its fullness before being touched. This is a great-sounding philosophy. But
    in reality, it’s more important that someone be able to look at any part of the
    code and quickly understand what it does. Writing beautiful code that can’t be
    maintained often leads to failure. Find the beauty in making code that’s easy
    to understand.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员认为程序是必须在完全理解之后才能接触的艺术品。这听起来很有哲理。但实际上，更重要的是，任何人都能快速看懂代码的任何部分，并理解其功能。编写美观但无法维护的代码往往会导致失败。找到编写易于理解的代码中的美。
- en: Something that really helps maintainers if your code talks to hardware is to
    include references to the hardware datasheets in your code. If you’re poking at
    some register, include the datasheet page number(s) where that register is described.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码与硬件交互，有一件事对维护者非常有帮助，那就是在代码中包含硬件数据表的引用。如果你在操作某个寄存器，请包括该寄存器描述的 datasheet
    页码。
- en: '**Be Stylish**'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**保持时尚**'
- en: People often learn about programming without understanding the environment in
    which it exists. There are a few things to keep in mind here.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常在不理解其存在环境的情况下学习编程。这里有几个需要记住的事项。
- en: You may not have thought too much about the educational system. Right now it’s
    spewing knowledge at you, some of which you’ll actually absorb. Where did this
    knowledge come from? Other people discovered it. At some point, especially if
    you pursue an advanced degree, it’ll be your turn to discover things that other
    people will learn. One of the great things about open source software projects
    is that you can contribute to them. Even if you’re not ready to code, many of
    these projects need help with documentation, so if there’s some program that you
    use or that interests you, get involved. It’s a great way to meet people, and
    it also looks good on college and job applications. Be cautious, as many programmers
    are not particularly adept socially. Have a thick skin.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有太多考虑过教育体系。目前它正向你灌输知识，其中一些你会真正吸收。这些知识从哪里来？是别人发现的。在某个时刻，尤其是当你追求高级学位时，将轮到你去发现别人将要学习的东西。开源软件项目的一个伟大之处是你可以参与其中。即使你还没有准备好编写代码，许多项目也需要文档帮助，所以如果有你使用或感兴趣的程序，参与进来。这是结识人的好方法，而且也在大学和工作申请中很有分量。要小心，因为许多程序员在社交方面并不擅长。要有厚脸皮。
- en: When you write software, write it clearly and document it well. Make sure that
    others can understand what’s going on, or nobody will be able to help you. Get
    your “job security” by garnering a reputation for doing good work instead of by
    making sure that nobody but you can work on your code. Again, bear in mind that,
    as I said before, the cost of maintaining software greatly exceeds the cost of
    development.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写软件时，要写得清晰，并且文档化做得好。确保别人能够理解代码的运作，否则就没人能帮助你。通过建立良好的工作声誉来获得“工作安全感”，而不是确保只有你能处理你的代码。再次提醒，正如我之前所说，维护软件的成本远远超过开发成本。
- en: Where possible, make your software open source. Give back to the body of work
    on which you rely.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，让你的软件开源。回馈你所依赖的工作成果。
- en: Learn to write coherent, correctly spelled English (or the human language of
    your choice). Write real documentation for your code. Avoid documentation-generating
    tools such as Doxygen. You may have noticed that those are wonderful tools for
    generating large volumes of worthless documentation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 学会写连贯且拼写正确的英语（或你选择的任何人类语言）。为你的代码编写真实的文档。避免使用类似 Doxygen 这样的文档生成工具。你可能已经注意到，这些工具在生成大量无用的文档方面非常出色。
- en: 'Documentation needs to describe what the code is doing. It should illuminate
    the structure of the data and how it is manipulated by the code. My first job
    writing code was at Bell Telephone Laboratories when I was in high school. Lucky
    me! My boss told me that every line of code should be commented. Not being very
    smart at the time, I did things like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 文档需要描述代码的作用。它应当阐明数据的结构以及代码如何操作这些数据。我第一次写代码的工作是在我高中时的贝尔电话实验室。运气真好！我的老板告诉我，每一行代码都应该有注释。那时我并不聪明，我做了这样的事：
- en: '[PRE0]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can probably see, these comments were completely worthless. It would
    have been better to say something like:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经看到的，这些评论完全没有价值。说些像下面这样的内容会更好：
- en: '[PRE1]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Way back in 1985, I had the idea that it would be cool to be able to extract
    documentation from source code files, especially because you could change the
    documentation in the same place where you were changing the code. I wrote a tool
    called *xman* (extract manual) that generated `troff`-format typeset manuals from
    the source code. It used a special C comment that began with `/**` to introduce
    documentation. On a different world-track, my proposal to teach a course at the
    1986 SIGGRAPH conference was accepted. I needed some additional speakers and contacted
    James Gosling, later an inventor of Java. I demonstrated xman for him. A short
    time later, we abandoned xman because it became clear that, while it could produce
    lots of pretty documentation, it was the wrong type of documentation. While correlation
    does not demonstrate causation (and Gosling doesn’t remember), Java included *Javadoc*,
    a way to include documentation in source files, and documentation was introduced
    by `/**` comments. This technique was copied by many other tools. So maybe I’m
    responsible for this mess.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在1985年，我有一个想法，那就是从源代码文件中提取文档会很酷，尤其是因为你可以在更改代码的地方同时更改文档。我写了一个叫做*xman*（extract
    manual）的工具，它能够从源代码中生成`troff`格式的排版手册。它使用了一种以`/**`开头的特殊C语言注释来引入文档内容。在另一个平行的轨迹中，我的提案被接受，在1986年SIGGRAPH大会上教授课程。我需要一些额外的扬声器，并联系了詹姆斯·高斯林，后来他成为了Java的发明人。我向他演示了xman。不久之后，我们放弃了xman，因为显然，虽然它能够生成大量漂亮的文档，但它属于错误类型的文档。虽然相关性并不等于因果关系（高斯林也不记得了），但Java中包括了*Javadoc*，一种在源代码文件中加入文档的方法，文档是通过`/**`注释引入的。这一技巧被许多其他工具所效仿。所以，也许我得为这堆乱七八糟的东西负责。
- en: When you look at automatically generated documentation, it tends to be of the
    “add 1” variety. There are volumes of documentation that contain only function
    names, plus the names and types of the arguments. If you can’t figure this out
    just by glancing at the code, you shouldn’t be programming! Little of this documentation
    says what the function does, how it does it, and how it relates to the rest of
    the system. The moral is, don’t be fooled into thinking that fancy tools are the
    same thing as good documentation. Write good documentation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到自动生成的文档时，它往往是“加1”式的。那里面有大量文档，只包含函数名，以及参数的名称和类型。如果你仅通过瞥一眼代码就不能搞明白这些，那你就不该编程！这些文档几乎没有说明函数做了什么，它是怎么做的，以及它与系统其他部分的关系。教训是，不要被花哨的工具所迷惑，以为它们就是好的文档。写出好的文档。
- en: 'One last comment on documentation: include things that are obvious to you,
    the things that you don’t think about at all. People reading your documentation
    don’t know the things that are obvious to you. There is a famous comment in UNIX
    version 6—which had few comments—that said, “You are not expected to understand
    this.” Not the most helpful!'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关于文档的最后一个评论：包括那些对你来说显而易见的内容，那些你根本不曾思考过的内容。阅读你文档的人并不知道对你来说显而易见的事物。UNIX第六版中有一个著名的注释——它几乎没有注释——上面写着：“你不需要理解这个。”这可不是最有帮助的！
- en: '**Fix, Don’t Re-create**'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**修复，而不是重建**'
- en: The software universe, especially the open source part, is littered with partially
    working programs and programs that do many but not all of the same things. Avoid
    this type of behavior.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 软件世界，尤其是开源部分，充满了部分工作的程序和做很多事情但并非全部相同的程序。避免这种行为。
- en: Try to finish both your own projects and those started by others. If you don’t
    finish yours, at least leave them in good enough shape that someone else can easily
    take over the development. Remember, it’s about adding value.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量完成你自己的项目和他人开始的项目。如果你不能完成自己的项目，至少让它们保持在一个别人可以轻松接手开发的良好状态。记住，这是关于增加价值的。
- en: '**Summary**'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Now you’ve learned that programming involves more than just knowing about hardware
    and software. It’s a complex and rewarding endeavor that requires a lot of disparate
    knowledge. We’ve covered a lot of ground together. You’ve seen how to represent
    and operate on complex information using bits. You’ve learned why we use bits
    and how we build them in hardware. We’ve explored fundamental hardware building
    blocks and how to assemble those blocks into computers. We looked at the additional
    functionality needed to make computers more usable and various technologies for
    connecting computers to the outside world. This was followed by a discussion of
    how to organize data to take advantage of memory architectures. We looked at the
    process for converting computer languages into instructions that the hardware
    can understand. You learned about web browsers and how they organize data and
    process languages. High-level applications were compared to lower-level system
    programs. A number of interesting tricks for solving problems were examined, along
    with a lot of cat pictures. Some of the issues resulting from multitasking were
    discussed. We looked at the advanced topics of security and machine intelligence,
    which involved even more cats. Hopefully you noticed that the fundamental building
    blocks and tricks are used again and again in different combinations. Finally,
    you learned that the task of programming involves people in addition to hardware
    and software.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经明白了，编程不仅仅是了解硬件和软件的知识。它是一个复杂且有意义的过程，需要掌握大量不同的知识。我们一起走过了很多的内容。你已经看到了如何使用比特来表示和操作复杂的信息。你学会了为什么我们使用比特，以及如何在硬件中构建它们。我们探讨了基本的硬件构建块，以及如何将这些构建块组装成计算机。我们还了解了让计算机更加易用所需的附加功能，以及将计算机与外界连接的各种技术。接下来，我们讨论了如何组织数据，以便充分利用内存架构。我们研究了将计算机语言转化为硬件可以理解的指令的过程。你了解了网页浏览器及其如何组织数据并处理语言。我们将高级应用程序与低级系统程序进行了比较。还探讨了一些有趣的技巧来解决问题，并伴随着很多猫咪的图片。我们讨论了多任务处理带来的一些问题。我们探讨了安全性和机器智能等高级话题，过程中还涉及了更多的猫咪。希望你注意到，这些基本的构建块和技巧在不同的组合中被反复使用。最后，你了解到，编程的任务不仅仅涉及硬件和软件，还包括人与人之间的协作。
- en: This is all just the beginning. It puts what you’ve learned or are learning
    about programming into perspective and gives you a foundation. Don’t stop here;
    there is much, much more to learn.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个开始。它让你对编程的理解更加深入，并为你提供了一个基础。不要停在这里，接下来还有更多的知识等待你去学习。
- en: You might recall that way back in the book’s introduction I mentioned the need
    to understand the universe. It’s not possible for any one person to understand
    everything about the universe. One of the parts that I’ve never been able to figure
    out is how to nicely end a book. So that’s it. We’re done. The end.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在书的介绍中，我提到过理解宇宙的必要性。没有任何一个人能够了解宇宙的所有事物。对于我来说，我一直无法弄明白的一件事就是如何优雅地结束一本书。所以就这样吧，我们完成了，结束。
