- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**OTHER AZURE SERVICES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他 Azure 服务**'
- en: '![image](../images/00015.jpeg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00015.jpeg)'
- en: There was a time when software release schedules were roughly aligned with the
    Olympics—a new version of your favorite operating system, productivity suite,
    or game would be released once every couple of years. Although there may have
    been some interim updates and service packs to fix bugs, users eager for new features
    had to count the months until they could stand in line to buy a cardboard box
    filled with disks or a CD. But the world has moved on from this paradigm, with
    radically shortened release schedules, new distribution methods, and even different
    ways for companies to monetize their products.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，软件发布的时间表大致与奥运会相吻合——你最喜欢的操作系统、生产力套件或游戏的新版本大约每两年发布一次。尽管可能会有一些临时更新和服务包来修复漏洞，但急切渴望新功能的用户必须等待几个月，直到他们可以排队购买一个装满磁盘或
    CD 的纸箱。然而，世界已经脱离了这种范式，发布周期大幅缩短，分发方式发生了变化，甚至公司盈利产品的方式也变了。
- en: This new model is very apparent in Azure, with new service offerings coming
    online all the time. In the earlier chapters, I focused on the core services any
    enterprise that adopts Azure is likely to use. In this chapter, we explore some
    of the newer, lesser-used, or more unique Azure services, and examine the ones
    that are interesting from a security perspective.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这一新模式在 Azure 中尤为明显，新的服务不断上线。在前面的章节中，我专注于任何采用 Azure 的企业可能会使用的核心服务。在这一章中，我们将探讨一些较新的、较少使用的或更具特色的
    Azure 服务，并从安全角度审视一些有趣的服务。
- en: We start by looking at Key Vault, a mechanism for the secure storage and retrieval
    of credentials such as passwords and certificates in the cloud. Then, we discuss
    some notable aspects of Web Apps, the feature of Azure App Services for publishing
    websites. Finally, we close with Azure Automation, a service to automate management
    tasks both in the cloud and on the corporate network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看看 Key Vault，这是一个用于在云中安全存储和检索凭证（如密码和证书）的机制。然后，我们讨论 Azure 应用服务中的 Web 应用功能，这是发布网站的一个特性。最后，我们将介绍
    Azure 自动化服务，这是一个用于在云端和企业网络上自动化管理任务的服务。
- en: '**Best Practices: Key Vault**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最佳实践：密钥库**'
- en: When storing secrets in Key Vault, you can do several things to add an extra
    layer of security, such as tightly controlling access, pre-encrypting secrets,
    and using logging. Each of these makes an already-strong service considerably
    harder to attack.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Key Vault 中存储秘密时，你可以采取几种措施来增加额外的安全层次，例如严格控制访问、预加密秘密和使用日志记录。这些措施使得一个本已强大的服务更加难以攻击。
- en: First, any secret vaulting solution is only as secure as the user with the weakest
    security practices. For this reason, it is crucial to limit the number of people
    who can access the Key Vault. With role-based access control (RBAC), very specific,
    granular permissions can be granted to the Key Vault and its contents. However,
    even a very tight set of permissions to the Key Vault doesn’t help much if the
    vault resides in a subscription with dozens of users with owner permissions who
    don’t need access to the vault. After all, any of these users could leverage their
    subscription permissions to grant themselves access to the Key Vault. To prevent
    this, I encourage you to consider creating a separate subscription just for your
    Key Vault if it is going to hold particularly sensitive secrets. More details
    about Key Vault hardening are available at *[https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault/](https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault/)*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，任何秘密存储解决方案的安全性都取决于拥有最弱安全实践的用户。因此，限制能够访问密钥库的人员数量至关重要。通过基于角色的访问控制（RBAC），可以为密钥库及其内容授予非常具体、细粒度的权限。然而，即使对密钥库的权限设置非常严格，如果密钥库位于一个有几十个拥有所有者权限且不需要访问密钥库的用户的订阅中，这也帮助不大。毕竟，这些用户中的任何人都可以利用他们的订阅权限授予自己访问密钥库的权限。为了防止这种情况，我建议你考虑为你的密钥库创建一个单独的订阅，特别是当它存储特别敏感的秘密时。有关密钥库强化的更多细节，请访问
    *[https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault/](https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault/)*。
- en: If you are using Key Vault to store secrets that won’t be used directly by another
    cloud service, it might be worth considering pre-encrypting secrets before putting
    them in Key Vault. Key Vault, of course, stores all of its data in an encrypted
    format; however, if an attacker compromises an account that is used to retrieve
    the secrets, they can retrieve the decrypted secrets. If you encrypt the secrets
    locally before uploading them (and store the decryption keys somewhere offline),
    an attacker who obtains an account with access to your vault will only be able
    to pull the encrypted values and won’t have the cleartext secret.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Key Vault 存储不会被其他云服务直接使用的机密，可能值得考虑在将机密放入 Key Vault 之前先进行本地加密。当然，Key Vault
    会将所有数据以加密格式存储；然而，如果攻击者破坏了用于检索机密的帐户，他们可以获取解密后的机密。如果你在上传之前对机密进行本地加密（并将解密密钥存储在离线位置），即使攻击者获得了有访问权限的帐户，他们也只能拉取加密后的值，而无法获得明文机密。
- en: As with other services, logging is important for Key Vault too. When enabled,
    the logs contain information such as key enumeration, creation, reads, writes,
    and deletions. This includes details useful for identifying illegitimate access,
    such as the caller’s IP address and the account making the request. More details
    about Key Vault’s audit logs can be found at *[https://docs.microsoft.com/en-us/azure/key-vault/key-vault-logging/](https://docs.microsoft.com/en-us/azure/key-vault/key-vault-logging/)*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他服务一样，Key Vault 的日志记录也非常重要。启用后，日志包含诸如密钥枚举、创建、读取、写入和删除等信息。这些日志包含有助于识别非法访问的详细信息，如调用者的
    IP 地址和发起请求的帐户。有关 Key Vault 审计日志的更多细节可以在 *[https://docs.microsoft.com/en-us/azure/key-vault/key-vault-logging/](https://docs.microsoft.com/en-us/azure/key-vault/key-vault-logging/)*
    中找到。
- en: '**Examining Azure Key Vault**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**审查 Azure Key Vault**'
- en: Azure Key Vault is a service that allows a developer to securely store passwords,
    connection strings, storage keys, certificates, and so on, for use in other Azure
    services. As a penetration tester, I love Key Vault because I can use it as a
    recommendation to resolve many common pentest findings. And, if a user misconfigures
    a Key Vault instance, it can be another source of credentials to further my access
    into the target environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Key Vault 是一项服务，允许开发者将密码、连接字符串、存储密钥、证书等安全地存储起来，以便在其他 Azure 服务中使用。作为渗透测试人员，我喜欢
    Key Vault，因为我可以将其作为解决许多常见渗透测试问题的建议。而且，如果用户错误配置了 Key Vault 实例，它还可以成为进一步访问目标环境的凭证来源。
- en: It’s no exaggeration to say that I include Key Vault as a potential solution
    to findings in most of my reports. In “[Obtaining Credentials](part0011.html#lev20)”
    on [page 15](part0011.html#page_15), I demonstrated how easy it can be to discover
    passwords and other secrets in source code repositories, errant configuration
    files, and even on developer workstations. Key Vault provides an API—with libraries
    and sample code for most major programming languages—that makes it easy for a
    developer to keep this sensitive information in a secured, access-controlled,
    auditable location. Although Key Vault doesn’t prevent every developer mistake,
    it’s excellent for cleaning up secret hygiene issues.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 说我在大多数报告中将 Key Vault 作为潜在解决方案是毫不夸张的。在“[获取凭证](part0011.html#lev20)”的[第15页](part0011.html#page_15)，我演示了如何轻松地在源代码库、错误的配置文件甚至开发者工作站上发现密码和其他机密信息。Key
    Vault 提供了一个 API——大多数主要编程语言都有库和示例代码——使开发者能够轻松地将这些敏感信息存储在一个安全、受控访问、可审计的位置。尽管 Key
    Vault 并不能防止所有开发者的错误，但它在解决机密信息清理问题上表现优秀。
- en: 'Three different types of storage are available in Key Vault: secrets, keys,
    and certificates. Each of these presents a different opportunity for a pentester,
    as detailed in the following sections.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Key Vault 中提供了三种不同类型的存储：机密、密钥和证书。每种存储为渗透测试人员提供了不同的机会，详细内容将在以下各节中说明。
- en: '***Displaying Secrets***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***显示机密***'
- en: A secret is a key-value pair consisting of a name and a text value; the text
    value can be up to 25KB in size and supports version history. You can view the
    secret’s text value within the portal, using APIs, or in PowerShell—assuming your
    account has the correct permissions. Because secrets can be retrieved, Microsoft’s
    documentation recommends pre-encrypting secrets with a public key before saving
    them in Azure if they are particularly sensitive. The private key to decrypt the
    secret would be placed in Key Vault’s HSM storage, protecting the private key,
    and therefore the secret, from unauthorized access.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 机密是由名称和文本值组成的键值对；文本值可以大到 25KB，并支持版本历史。你可以在门户中、使用 API 或 PowerShell 查看机密的文本值——前提是你的账户具有正确的权限。因为机密可以被检索，微软的文档建议在保存机密到
    Azure 之前，特别敏感的机密应先用公钥加密。解密机密的私钥将存储在 Key Vault 的 HSM 存储中，从而保护私钥和机密不被未经授权访问。
- en: If you obtain an account you suspect might have access to Key Vault instances
    and their secrets, use PowerShell to enumerate them all at once. To do this, run
    the script shown in [Listing 7-1](part0016.html#ch07list1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑某个账户可能有权限访问 Key Vault 实例及其机密，使用 PowerShell 一次性列出所有这些信息。为此，请运行[清单 7-1](part0016.html#ch07list1)中显示的脚本。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: Displaying Key Vault secrets*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：显示 Key Vault 机密*'
- en: The script begins by getting a list of Key Vault instances in the subscription
    ➊. Then, in each instance it retrieves a list of all secrets ➋. Finally, for each
    secret, it outputs the secret in the format Vault Name`:` Secret Name `=` Secret
    Value ➌.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先获取订阅中 Key Vault 实例的列表 ➊。然后，在每个实例中检索所有机密的列表 ➋。最后，对于每个机密，它以 Vault 名称`:` 机密名称
    `=` 机密值的格式输出该机密 ➌。
- en: '***Displaying Keys***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***显示密钥***'
- en: Key storage allows users to generate or upload RSA asymmetric keys to Key Vault.
    Within the vault, the keys can be used to perform cryptographic operations, such
    as sign, verify, encrypt, and decrypt using Azure’s APIs. Once the keys are uploaded,
    Azure doesn’t allow users to export them, except in an encrypted backup form that
    can only be used to restore the keys back into Azure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥存储允许用户将 RSA 非对称密钥生成或上传到 Key Vault。在 Vault 内部，这些密钥可以用于执行加密操作，如签名、验证、加密和解密，使用
    Azure 的 API。密钥上传后，Azure 不允许用户导出它们，除非以加密备份的形式，这种备份仅能用于将密钥恢复到 Azure 中。
- en: Because no one can export keys, the key storage section of Key Vault is somewhat
    less exciting to a pentester than the secret storage. However, if you have access
    to an account that has permission to call cryptographic APIs for keys, you might
    still be able to leverage them. But before you can leverage these keys, you’ll
    need to know how each one is used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有人可以导出密钥，Key Vault 的密钥存储部分对渗透测试者来说相较于机密存储稍显乏味。然而，如果你可以访问一个有权限调用加密 API 的账户，你仍然可能能够利用这些密钥。但在你能利用这些密钥之前，你需要知道每个密钥的使用方式。
- en: Azure requires each key to have a name, which may hint at its purpose. It also
    allows users to associate up to 15 *tags* (or 256-character name-value pairs)
    with each key. An organization chooses how to use these tags, and the tags may
    give you additional information about a key’s purpose. [Listing 7-2](part0016.html#ch07list2)
    shows how to display details about every key in every vault within a subscription
    using PowerShell.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 要求每个密钥必须有一个名称，这个名称可能暗示其用途。它还允许用户为每个密钥关联最多 15 个*标签*（或 256 字符的名称-值对）。组织可以选择如何使用这些标签，这些标签可能会提供有关密钥用途的额外信息。[清单
    7-2](part0016.html#ch07list2)展示了如何使用 PowerShell 显示订阅中每个 Vault 的每个密钥的详细信息。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-2: Displaying Key Vault key information*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-2：显示 Key Vault 密钥信息*'
- en: Like the secrets retrieval script, the key script starts by iterating over Key
    Vault instances. Within each instance, a list of keys is retrieved ➊ and then
    the details of each key are printed ➋. The output includes the name of the vault
    instance ➌, the key name ➍, the key validity period ➎, the tags ➏, and what operations
    the key can be used to perform ➐.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与机密检索脚本类似，密钥脚本从遍历 Key Vault 实例开始。在每个实例中，首先检索到密钥列表 ➊，然后打印每个密钥的详细信息 ➋。输出包括 Vault
    实例名称 ➌、密钥名称 ➍、密钥有效期 ➎、标签 ➏ 以及密钥可执行的操作 ➐。
- en: Once you’ve determined the key’s purpose, you could potentially use it for the
    same purpose. For example, if a key is used to sign documents for proof of authenticity,
    you could generate a forgery. Or, if it’s used for encrypting files, you could
    decrypt those files. There isn’t an easy way to do this in PowerShell, but Microsoft
    does offer the `KeyVaultClient` class in the `KeyVault` library, which supports
    these operations and is available for .NET and Java. You can find sample code
    at *[https://www.microsoft.com/en-us/download/details.aspx?id=45343](https://www.microsoft.com/en-us/download/details.aspx?id=45343)*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了密钥的用途，你可能会将其用于相同的目的。例如，如果密钥用于签署文件以证明真实性，你可能会生成伪造文件。或者，如果它用于加密文件，你可以解密这些文件。在
    PowerShell 中没有简单的方法来做到这一点，但 Microsoft 确实提供了`KeyVaultClient`类，它在`KeyVault`库中支持这些操作，并且可以在
    .NET 和 Java 中使用。你可以在* [https://www.microsoft.com/en-us/download/details.aspx?id=45343](https://www.microsoft.com/en-us/download/details.aspx?id=45343)*找到示例代码。
- en: '***Displaying Certificates***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***显示证书***'
- en: Certificate storage is a special category under the “secrets” category of Key
    Vault. Users can upload PFX files or have Key Vault generate self-signed certificates
    or certificate requests. They can then use these certificates, for example, to
    secure the communications between users and a custom Azure application. The key
    and certificate features of Key Vault both deal with asymmetric cryptography,
    but their intended purpose is slightly different. Keys are used to submit cryptographic
    operations and have the operations performed using a private key within secure
    storage. Certificates can be used within different applications, such as website
    certificates that are used not only for encryption but also to confirm the name
    of the site (and other attributes and intended usage), and thus are usable even
    outside of Azure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 证书存储是 Key Vault 中“秘密”类别下的一个特殊类别。用户可以上传 PFX 文件，或者让 Key Vault 生成自签名证书或证书请求。然后，他们可以使用这些证书，例如，用于保护用户与自定义
    Azure 应用程序之间的通信。Key Vault 的密钥和证书功能都涉及非对称加密，但它们的预期用途略有不同。密钥用于提交加密操作，并通过安全存储中的私钥执行操作。证书可以在不同的应用程序中使用，例如，用于加密的同时确认站点名称（以及其他属性和预期用途）的站点证书，因此即使在
    Azure 外部也能使用。
- en: Key Vault will respect the export flags of certificates added to it. Therefore,
    if a user imports a certificate marked non-exportable, an attacker won’t be able
    to recover it. But if a key is marked exportable, it can be retrieved just like
    other Key Vault secrets. In fact, if a user doesn’t specify an export policy when
    creating a certificate in Key Vault, it defaults to exportable. [Listing 7-3](part0016.html#ch07list3)
    walks through listing certificates in Key Vault, viewing their details, and obtaining
    public keys, and, if accessible, private keys.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Key Vault 会遵循添加到其中的证书的导出标志。因此，如果用户导入一个标记为不可导出的证书，攻击者将无法恢复它。但如果密钥标记为可导出，它就可以像其他
    Key Vault 秘密一样被检索。事实上，如果用户在创建 Key Vault 证书时没有指定导出策略，它默认为可导出。[列表 7-3](part0016.html#ch07list3)
    演示了如何列出 Key Vault 中的证书、查看其详细信息并获取公钥，以及（如果可访问）私钥。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-3: Displaying Key Vault certificates*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-3：显示 Key Vault 证书*'
- en: This final Key Vault enumeration script begins as the others do—by iterating
    over Key Vault instances and then certificates. For each certificate, you need
    two calls to Azure in order to obtain the details. A call to `Get-AzureKeyVaultCertificate`
    retrieves public information about the certificate, including the subject, thumbprint,
    validity period, and public key ➊. Then, a call to `Get-AzureKeyVaultSecret` obtains
    the private key part of the certificate, if it’s available ➋. Next, the script
    exports the public key value to a certificate file (*Certificate Name.cer*) in
    the current working directory ➌. Finally, a PFX file is created which contains
    the public key data, and the private key information if it was exportable ➍.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的 Key Vault 枚举脚本与其他脚本一样开始——通过遍历 Key Vault 实例，然后是证书。对于每个证书，你需要两次调用 Azure
    才能获取其详细信息。第一次调用`Get-AzureKeyVaultCertificate`会检索关于证书的公共信息，包括主题、指纹、有效期和公钥 ➊。然后，调用`Get-AzureKeyVaultSecret`获取证书的私钥部分（如果可用）
    ➋。接下来，脚本将公钥值导出到当前工作目录中的证书文件（*证书名称.cer*） ➌。最后，创建一个包含公钥数据和私钥信息（如果可导出的）的 PFX 文件 ➍。
- en: '**DEFENDER’S TIP**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**DEFENDER’S TIP**'
- en: If you don’t intend to use a certificate outside of Key Vault, be sure to mark
    it as non-exportable. To do this, pass the -KeyNotExportable switch to the New-AzureKeyVaultCertificatePolicy
    cmdlet when creating the certificate. If you have a very sensitive certificate
    or key, take a look at Key Vault’s physical Hardware Security Module (HSM) option.
    Although this option is a bit more expensive than the software-based HSM version
    of Key Vault, the certificates are placed in an industry-standard cryptography
    device that’s designed to prevent private keys from being extracted once added
    to the device.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不打算将证书用于 Key Vault 之外的地方，务必将其标记为不可导出。为此，在创建证书时，将 -KeyNotExportable 选项传递给
    New-AzureKeyVaultCertificatePolicy cmdlet。如果你有非常敏感的证书或密钥，可以考虑 Key Vault 的物理硬件安全模块（HSM）选项。虽然这个选项比基于软件的
    HSM 版本更昂贵，但证书被存放在行业标准的加密设备中，这些设备旨在防止私钥在添加到设备后被提取。
- en: '***Accessing Key Vault from Other Azure Services***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过其他 Azure 服务访问 Key Vault***'
- en: Users can configure Key Vault instances to allow access from virtual machines,
    Azure Resource Manager, and Azure Disk Encryption in the Advanced access policy
    settings in Azure portal, as shown in [Figure 7-1](part0016.html#ch07fig1).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在 Azure 门户的高级访问策略设置中配置 Key Vault 实例，允许虚拟机、Azure 资源管理器和 Azure 磁盘加密访问，如 [图
    7-1](part0016.html#ch07fig1) 所示。
- en: '![image](../images/00051.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00051.jpeg)'
- en: '*Figure 7-1: Advanced access policy for Azure Key Vault—enabling access from
    other services*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：Azure Key Vault 的高级访问策略——允许其他服务访问*'
- en: 'Each of these settings has a purpose: virtual machines can store and access
    SSL certificates in Key Vault, Azure Resource Manager can create and deploy templates
    that need secrets (such as a local administrator password for a VM template),
    and Azure Disk Encryption uses Key Vault’s secret storage to keep its encryption
    keys for virtual hard disks (VHDs). These are all perfectly good uses for Key
    Vault, and are much better than checking these secrets into source control. However,
    it also means that a user who has permissions to administer a virtual machine
    or to modify and deploy templates may be able to gain access to Key Vault data
    they wouldn’t otherwise have rights to see.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置各有其用途：虚拟机可以在 Key Vault 中存储和访问 SSL 证书，Azure 资源管理器可以创建和部署需要机密的模板（例如虚拟机模板的本地管理员密码），Azure
    磁盘加密使用 Key Vault 的机密存储来保存虚拟硬盘（VHD）的加密密钥。这些都是 Key Vault 的非常好的使用场景，比将这些机密提交到源代码管理系统要安全得多。然而，这也意味着具有管理虚拟机或修改和部署模板权限的用户，可能能够访问他们本不应查看的
    Key Vault 数据。
- en: '**DEFENDER’S TIP**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**DEFENDER’S TIP**'
- en: Because advanced access policies are set at the Key Vault instance level, all
    secrets within an instance are subject to the same policies. Therefore, it is
    a good idea to create multiple vaults and restrict access to each store to specific
    services. Each store should contain only those secrets that are intended to be
    used by *all* of the services that have access to the store.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为高级访问策略是在 Key Vault 实例级别设置的，所以实例中的所有机密都遵循相同的策略。因此，最好创建多个密钥库，并限制每个库的访问权限，仅允许特定的服务访问。每个密钥库应仅包含那些所有拥有访问权限的服务所需要的机密。
- en: '**Targeting Web Apps**'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**针对 Web 应用的攻击**'
- en: A subset of Azure App Services, Web Apps are websites designed to run on Azure
    PaaS (Platform as a Service). Developers can write Web Apps in a variety of languages—such
    as ASP.NET, PHP, JavaScript, Node.js, and Python—and run them within a Windows
    or Linux container. Identifying these sites is often easy because they have the
    URL *<Site Name>.azurewebsites.net* by default, but developers can give a Web
    App a custom domain name, if it’s deployed in a non-free service tier.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 应用服务中的一部分子集，Web 应用是设计用于在 Azure PaaS（平台即服务）上运行的网站。开发人员可以使用多种语言编写 Web 应用——例如
    ASP.NET、PHP、JavaScript、Node.js 和 Python——并在 Windows 或 Linux 容器中运行它们。识别这些网站通常很容易，因为它们默认的
    URL 为 *<网站名称>.azurewebsites.net*，但如果在非免费服务层中部署，开发人员可以为 Web 应用设置自定义域名。
- en: 'Web Apps are interesting targets for several reasons:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用是一个有趣的攻击目标，原因有几个：
- en: They are public (internet) facing, so a defacement could cause reputational
    harm to a client.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是面向公众（互联网）的，因此篡改可能会对客户造成声誉损害。
- en: They use deployment accounts that an attacker may find on developer workstations.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使用的部署帐户可能会在开发人员工作站上被攻击者发现。
- en: They are a popular Azure feature and used by many businesses.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是 Azure 的热门功能，并被许多企业使用。
- en: Sites in the free tier are often developer test sites with minimal security
    planning, yet they may contain secrets for production sites.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费套餐中的站点通常是开发者测试站点，安全规划较少，但它们可能包含生产站点的机密信息。
- en: Their code sometimes contains credentials to access other services, such as
    Azure SQL.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的代码有时包含访问其他服务的凭证，例如 Azure SQL。
- en: For these reasons, a pentester should always include Web Apps in an Azure assessment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些原因，渗透测试人员在 Azure 评估中应始终包括 Web 应用。
- en: '***Deployment Methods***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***部署方法***'
- en: 'When a developer wants to publish their latest revision of a site to Azure,
    they must make two choices: what deployment method to use and what credentials
    they should use to authenticate. Web Apps support several different ways to load
    code into a site:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员想将他们最新的站点版本发布到 Azure 时，他们必须做出两个选择：使用什么部署方法以及使用什么凭证进行身份验证。Web 应用支持几种不同的方式将代码加载到站点中：
- en: FTP/FTPS
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP/FTPS
- en: WebDeploy
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebDeploy
- en: Git Repository (local or on GitHub)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 仓库（本地或在 GitHub 上）
- en: Deployment from an external service such as OneDrive, Dropbox, or Bitbucket
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自外部服务的部署，例如 OneDrive、Dropbox 或 Bitbucket
- en: It is good to be familiar with these methods; when you gain access to a developer
    workstation, it will help you identify which tools may have cached credentials
    or saved copies of source code available.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉这些方法是很有好处的；当你获得开发者工作站的访问权限时，这将帮助你识别哪些工具可能缓存了凭证或保存了源代码副本。
- en: Web developers have traditionally used *File Transfer Protocol* (*FTP*) to push
    websites to servers, although it is not a good option because the user’s credentials
    and file contents are sent unencrypted. If you discover a developer using FTP,
    this should be a finding in and of itself!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Web 开发者传统上使用 *文件传输协议*（*FTP*）将网站推送到服务器，尽管这不是一个好的选择，因为用户的凭证和文件内容是未加密发送的。如果你发现开发者使用
    FTP，这本身就是一个问题！
- en: Fortunately, Azure also supports *FTP Secure* (*FTPS*), which is encrypted and
    an acceptable choice. Anywhere you find a saved connection, look at the protocol
    before the server’s address to determine which type of connection is being used.
    Users connecting to FTP will have connections that begin with *ftp://* whereas
    secured connections will use *ftps://*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Azure 也支持 *FTP Secure*（*FTPS*），它是加密的，也是一个可接受的选择。在任何找到已保存连接的地方，查看协议部分（位于服务器地址之前）以确定正在使用的连接类型。连接到
    FTP 的用户会看到以 *ftp://* 开头的连接，而安全连接则会使用 *ftps://*。
- en: Another common deployment method is WebDeploy, also called MSDeploy, which Visual
    Studio or the *msbuild.exe*/*msdeploy.exe* compiler tool pipeline can use to publish
    compiled projects. WebDeploy was first used not for publishing to Azure, but by
    developers deploying sites to Microsoft IIS web servers. Therefore, I’m not surprised
    that it seems to be commonly used for sites written in Microsoft’s ASP.NET language.
    WebDeploy is only available on Windows clients. You may also encounter users of
    a tool called *WAWSDeploy.exe*, which is a wrapper for WebDeploy that makes it
    easier to use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的部署方法是 WebDeploy，也叫做 MSDeploy，它可以通过 Visual Studio 或 *msbuild.exe*/*msdeploy.exe*
    编译工具管道来发布编译后的项目。WebDeploy 最初不是用来发布到 Azure，而是开发者将站点部署到 Microsoft IIS Web 服务器时使用的。因此，我并不惊讶它似乎在使用
    Microsoft ASP.NET 语言编写的站点中被广泛使用。WebDeploy 仅在 Windows 客户端上可用。你也可能遇到一个名为 *WAWSDeploy.exe*
    的工具，它是 WebDeploy 的一个封装工具，简化了其使用。
- en: For developers who use git to manage their source code, the ability to deploy
    straight from their git client is quite convenient. Given the growth in git’s
    popularity, I expect to see the number of developers using this method increase
    significantly. To use this method, the developer simply retrieves deployment credentials
    and a git repository URL from the Azure portal, and then uses git to push their
    site to the remote master branch. Developers don’t need any special utilities
    or libraries on their workstations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 git 管理源代码的开发者而言，直接从 git 客户端进行部署是非常方便的。鉴于 git 的流行程度不断增长，我预计使用这种方法的开发者数量将显著增加。使用这种方法时，开发者只需从
    Azure 门户获取部署凭证和 git 仓库 URL，然后使用 git 将站点推送到远程主分支。开发者不需要在工作站上安装任何特殊的工具或库。
- en: Azure also supports an ever-growing list of external services that developers
    can use to stage content for Web Apps, such as Visual Studio Team Server, OneDrive,
    Bitbucket, and Dropbox. This feature is generically known as *cloud sync*, and
    it differs from the previous methods discussed. All the other deployment methods
    are run on a developer’s system, use credentials obtained from Azure, and push
    the content into Azure; but cloud sync is a pull model. The developer authorizes
    Azure to access their online storage provider, and then Azure pulls the content
    into the Web App from a designated folder in the external service.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 还支持越来越多的外部服务，开发人员可以利用这些服务为 Web 应用阶段性地准备内容，例如 Visual Studio Team Server、OneDrive、Bitbucket
    和 Dropbox。此功能通常被称为*云同步*，与前面讨论的其他方法不同。所有其他部署方法都在开发人员的系统上运行，使用从 Azure 获得的凭证，将内容推送到
    Azure；但云同步则采用拉取模型。开发人员授权 Azure 访问他们的在线存储提供商，然后 Azure 从外部服务的指定文件夹中拉取内容到 Web 应用。
- en: '***Obtaining Deployment Credentials***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取部署凭证***'
- en: For every deployment method besides cloud sync, the Web App developer must provide
    a username and password when uploading files for their site. These deployment
    credentials are different from the user’s Azure portal login information—that
    account won’t work to deploy a site. Instead, the developer can choose to use
    either a user-specific deployment account or a site-specific account. Either account
    type will work for FTP, WebDeploy, and git deployments; the differences between
    the two credentials is who shares them and where they can be found.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了云同步以外的每种部署方法，Web 应用开发人员在上传文件到他们的网站时必须提供用户名和密码。这些部署凭证不同于用户的 Azure 门户登录信息——该账户无法用于部署网站。相反，开发人员可以选择使用用户特定的部署账户或站点特定的账户。无论哪种账户类型，都可以用于
    FTP、WebDeploy 和 git 部署；两种凭证的区别在于它们的共享对象以及可以在哪里找到。
- en: '**User Deployment Credentials**'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用户部署凭证**'
- en: 'Each Azure user can create one deployment account to add, remove, or change
    files in any and every site they have permission to modify, across all subscriptions
    they can access. To create this account, or to reset its password, the user must
    do the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Azure 用户可以创建一个部署账户，用于添加、删除或更改他们有权限修改的任何网站上的文件，适用于他们可以访问的所有订阅。要创建此账户或重置其密码，用户必须执行以下操作：
- en: Log in to the Azure portal and navigate to **App Services**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Azure 门户并导航到 **应用服务**。
- en: Select any Web App in their subscription (or create a new one if none exists).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择他们订阅中的任何 Web 应用（如果没有现有的，可以创建一个新的）。
- en: Click **Deployment Credentials**.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **部署凭证**。
- en: Specify a username and password.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定用户名和密码。
- en: Once the account is created, the account holder can use it across any of their
    Web Apps, with only a slight variation between sites. To connect to each site,
    the user must enter the username in the format *<Website Name>\<Username>* and
    specify their password. For example, suppose the developer chose the username
    *webadmin* and specified *Awe5omeDev#* as their (relatively weak) password. To
    manage the website *[http://azweb8426.azurewebsites.net/](http://azweb8426.azurewebsites.net/)*,
    the developer would enter `azweb8426\``webadmin` as the username in their chosen
    deployment tool and enter `Awe5omeDev#` as the password. If the developer later
    wanted to work on *[http://bkunaenk.azurewebsites.net/](http://bkunaenk.azurewebsites.net/)*,
    they would enter `bkunaenk\webadmin` as the username and `Awe5omeDev#` as the
    password.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 账户创建后，账户持有者可以在他们的任何 Web 应用中使用该账户，站点之间只有轻微的差异。要连接到每个网站，用户必须以 *<网站名称>\<用户名>* 格式输入用户名，并指定他们的密码。例如，假设开发人员选择了用户名
    *webadmin*，并指定 *Awe5omeDev#* 作为他们（相对较弱的）密码。要管理网站 *[http://azweb8426.azurewebsites.net/](http://azweb8426.azurewebsites.net/)*，开发人员将在他们选择的部署工具中输入
    `azweb8426\`webadmin` 作为用户名，并输入 `Awe5omeDev#` 作为密码。如果开发人员之后想要在 *[http://bkunaenk.azurewebsites.net/](http://bkunaenk.azurewebsites.net/)*
    上工作，他们将输入 `bkunaenk\webadmin` 作为用户名，并输入 `Awe5omeDev#` 作为密码。
- en: Because the same credentials are used broadly across all sites, an attacker
    who compromises it can modify any site this developer has access to—even unrelated
    sites that happen to be in the same subscription and have overly broad permissions.
    Consider a subscription with 50 administrators, where each administrator owns
    and manages one site, but none of them has changed their site’s owner or contributor
    access permissions—so anyone with subscription access has permission to modify
    the site. A developer with just a personal blog might not put much effort into
    protecting their credentials, whereas another developer who runs the company’s
    home page may closely guard their password. In this scenario, the first developer’s
    credentials would be able to make changes to the latter’s site! This also applies
    to cases where a single developer owns multiple Web Apps, only some of which are
    important.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于相同的凭证被广泛用于所有站点，攻击者如果破坏了它，就可以修改任何该开发人员有权限访问的站点——甚至是一些与该开发人员无关的站点，只要它们位于同一个订阅中，并且权限设置过于宽泛。假设有一个拥有
    50 名管理员的订阅，每个管理员都拥有并管理一个站点，但他们都没有更改自己站点的所有者或贡献者权限——因此，任何拥有订阅访问权限的人都可以修改该站点。一个仅有个人博客的开发人员可能不会特别关注保护自己的凭证，而另一个负责公司主页的开发人员则可能会非常小心地保护自己的密码。在这种情况下，第一个开发人员的凭证就可以对第二个开发人员的站点进行修改！这同样适用于一个开发人员拥有多个
    Web 应用的情况，其中只有部分应用是重要的。
- en: So, where can you find a user’s deployment credentials? This depends on the
    user, but in general, you might find them saved in FTP clients, password managers,
    or a git credential store file such as *.git-credentials* within the user’s home
    directory. But if the user is leveraging WebDeploy or FTP through Visual Studio,
    you’re probably out of luck. Visual Studio saves the user’s password in an encrypted
    blob within an XML file named *<Website>-<Method>.pubxml.user*, such as *bkunaenk-FTP.pubxml.user*.
    Additionally, this blob contains details about the workstation and user it’s associated
    with, so you won’t be able to use it in a different user’s session or on a different
    PC.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在哪里可以找到用户的部署凭证呢？这取决于用户，但通常你可以在 FTP 客户端、密码管理器或用户主目录中的 git 凭证存储文件（如 *.git-credentials*）中找到它们。但如果用户通过
    Visual Studio 使用 WebDeploy 或 FTP，你可能就没戏了。Visual Studio 会将用户的密码保存在一个加密的 Blob 中，存储在名为
    *<Website>-<Method>.pubxml.user* 的 XML 文件里，例如 *bkunaenk-FTP.pubxml.user*。此外，这个
    Blob 还包含与之关联的工作站和用户的详细信息，因此你无法在其他用户的会话或不同的电脑上使用它。
- en: '**NOTE**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can reset the deployment account in the Azure portal without knowing the
    current password, so if you have portal access, you can always change the password
    to a different value. However, the user is likely to notice if their account suddenly
    stops working with the expected password. It should also be noted that the deployment
    account itself doesn’t grant access to the portal, only the ability to change
    Web App files.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在 Azure 门户中重置部署账户，而无需知道当前密码，因此，如果你有门户访问权限，你可以随时将密码更改为不同的值。然而，如果账户突然无法使用预期密码，用户可能会注意到。还需要注意的是，部署账户本身并不授予门户访问权限，只是能够更改
    Web 应用文件的权限。*'
- en: '**App Deployment Credentials**'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**应用部署凭证**'
- en: 'The other type of credentials for deployments is app specific. Each Web App
    gets a single deployment credential that is shared between all developers of that
    site, and they can use it in all the same places as a user deployment account:
    FTP, WebDeploy, and git.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种部署凭证是应用特定的。每个 Web 应用都有一个单独的部署凭证，该凭证在该站点的所有开发人员之间共享，并且可以在与用户部署账户相同的地方使用：FTP、WebDeploy
    和 git。
- en: This type of account presents a slightly lower risk than user deployment credentials,
    because if the credential is leaked, it can only be used to modify a single site.
    However, the credential is only as secure as the developer in possession of it
    with the worst security hygiene. Additionally, if an attacker compromises a credential
    that is accessible by multiple users, it may be hard to determine where the breach
    occurred. Finally, shared accounts are often not reset when an employee leaves,
    is fired, or changes roles, so a user’s access may persist longer than it should.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的账户比用户部署凭证具有稍低的风险，因为如果凭证泄露，攻击者只能修改单一站点。然而，凭证的安全性取决于持有它的开发人员的安全意识最差的情况。此外，如果攻击者破坏了多个用户可以访问的凭证，那么可能很难确定漏洞发生的具体位置。最后，共享账户在员工离职、被解雇或角色变动时往往不会重置，因此用户的访问权限可能会比预期的持续更长时间。
- en: The Azure portal doesn’t display app deployment credentials. Instead, developers
    can obtain them by navigating to the Web App in the Azure portal and then clicking
    the **Get publish profile** button on the Overview tab, as shown in [Figure 7-2](part0016.html#ch07fig2).
    If an administrator is concerned that an account is compromised, they can reset
    the credential using the **Reset publish profile** button on the same toolbar.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 门户不会显示应用部署凭证。相反，开发人员可以通过在 Azure 门户中导航到 Web 应用，然后点击概览标签上的 **获取发布配置文件**
    按钮，如 [图 7-2](part0016.html#ch07fig2) 所示，来获取凭证。如果管理员担心账户已被泄露，他们可以使用相同工具栏上的 **重置发布配置文件**
    按钮重置凭证。
- en: '![image](../images/00052.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00052.jpeg)'
- en: '*Figure 7-2: Obtaining a publish profile for a Web App*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：获取 Web 应用的发布配置文件*'
- en: 'The **Get publish profile** button initiates a download of a file named *<App
    Name>.publishsettings*. You may recall Publish Settings files from [Chapter 2](part0011.html#ch02)
    ([page 23](part0011.html#page_23)), which are XML files that contain a management
    certificate for a subscription. These Publish Settings files are also XML documents,
    but in this case, they contain details about a Web App instead of a subscription.
    Each Web App’s Publish Settings file contains the following items:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取发布配置文件** 按钮会启动一个下载，下载的文件名为 *<App Name>.publishsettings*。你可能记得发布设置文件来自 [第
    2 章](part0011.html#ch02)（[第 23 页](part0011.html#page_23)），它们是包含订阅管理证书的 XML 文件。这些发布设置文件也是
    XML 文档，但在这种情况下，它们包含有关 Web 应用的详细信息，而不是订阅信息。每个 Web 应用的发布设置文件包含以下内容：'
- en: The Web App target URL
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 应用目标 URL
- en: URLs to use for WebDeploy and FTP deployments
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 WebDeploy 和 FTP 部署的 URL
- en: The app deployment username, which is always *<App Name>\<App Name>$*
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用部署用户名，始终为 *<App Name>\<App Name>$*
- en: The app deployment password, which is a plaintext, 60-character, alphanumeric
    string
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用部署密码，它是一个明文的、60 字符的字母数字字符串
- en: The file may also have some optional data, such as connection strings for databases
    the app relies upon and the URL of the Azure portal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中还可能包含一些可选数据，例如应用所依赖的数据库的连接字符串以及 Azure 门户的 URL。
- en: Because the password for this account isn’t encrypted, another user can copy
    a Web App’s Publish Settings file and use it from a different computer. So, if
    you obtain access to a developer workstation or a code repository, search for
    these files because they’ll contain all the information needed to connect to the
    Web App server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为此账户的密码没有加密，其他用户可以复制 Web 应用的发布设置文件，并从另一台计算机使用它。所以，如果你能够访问开发工作站或代码仓库，请查找这些文件，因为它们将包含连接到
    Web 应用服务器所需的所有信息。
- en: '***Creating and Searching for Artifacts on Web App Servers***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在 Web 应用服务器上创建和搜索工件***'
- en: Once you have access to an app server, there are a few things you might want
    to do. First, if you need to prove to your client that you gained access to the
    server, consider dropping a small text file with a *.config* extension stating
    you were there. This kind of flag is far better than making a publicly visible
    change, and because app servers don’t expose *.config* files to web browsers,
    users of the site won’t be able to see it; only administrators who log in to the
    server can.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你访问了应用服务器，你可能需要做一些事情。首先，如果你需要向客户证明你已访问服务器，可以考虑放置一个小的文本文件，文件扩展名为 *.config*，声明你曾经在那里。这种标记比公开可见的更改要好得多，而且因为应用服务器不会将
    *.config* 文件暴露给网页浏览器，网站的用户无法看到它；只有登录到服务器的管理员才能看到。
- en: You can also use the server to try to capture credentials by modifying the Web
    App to covertly store logon information for you in a secure way. Alternatively,
    you could add a page to the site to use for phishing, which users would likely
    trust since it’s hosted on a legitimate site.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用服务器尝试捕获凭证，通过修改 Web 应用隐秘地将登录信息以安全的方式存储下来。或者，你可以向网站添加一个页面，用于网络钓鱼，因为用户可能会信任这个页面，因为它托管在一个合法的网站上。
- en: '**WARNING**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Always be sure that your rules of engagement allow for this kind of activity
    before modifying or adding pages on a public-facing site—especially if you’re
    adding code to exfiltrate user information or credentials. This is often off limits
    in penetration tests! If there’s even a little doubt, check with your client and
    attorney. As always, you should also make sure to record and account for any changes
    you make, in order to completely undo all changes at the end of your engagement.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*在修改或添加公共网站页面之前，一定要确保你的参与规则允许进行此类活动——特别是当你添加代码以外泄用户信息或凭证时。这通常在渗透测试中是禁止的！如果有任何疑虑，请与客户和律师确认。像往常一样，你还应该确保记录并跟踪你所做的任何更改，以便在参与结束时完全撤销所有更改。*'
- en: My favorite thing to do when I compromise web servers is to look for secrets
    that aren’t exposed to the site’s users. For example, *.config*, *.asp*, *.aspx*,
    and *.php* files are usually not directly served to users if requested. Because
    .*config* files often contain secrets, they aren’t returned at all, whereas ASP
    and PHP files are rendered on the server first, with just the client-ready result
    returned. By accessing these files through FTP, you can view the original code
    with any embedded secrets intact. You can often then pivot further into database
    servers or other backend systems.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我在入侵 Web 服务器时最喜欢做的事情之一是寻找不向站点用户暴露的机密。例如，*.config*、*.asp*、*.aspx* 和 *.php* 文件通常不会直接返回给用户请求的内容。因为
    *config* 文件通常包含机密信息，所以它们根本不会返回，而 ASP 和 PHP 文件会首先在服务器上呈现，然后只返回客户端准备好的结果。通过 FTP
    访问这些文件，你可以查看原始代码，保留任何嵌入的机密信息。然后，你通常可以进一步访问数据库服务器或其他后端系统。
- en: Aside from non-served files, app servers may contain files that are simply hard
    to find. For example, a developer may upload pages to the server but delay linking
    to them on other pages in the site until a specific time, such as when a new product
    is announced. And some developers might create pages intended for only those people
    who know how to find them, such as administrator logon forms. Discovering files
    like these might warrant a finding, if the information would harm the client when
    revealed or if the information is relying on “security through obscurity” for
    protection. Confidential data simply shouldn’t be accessible on a public-facing
    website, even if it isn’t easily discoverable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了未提供服务的文件，应用服务器可能还包含一些难以找到的文件。例如，开发人员可能会将页面上传到服务器，但延迟在站点的其他页面上链接它们，直到某个特定的时间，比如新产品发布时。有些开发人员可能会创建仅供那些知道如何找到它们的人访问的页面，例如管理员登录表单。发现这些文件可能会被视为一个发现点，如果这些信息在公开时会对客户造成伤害，或者如果该信息依赖于“通过模糊性实现安全”来保护。机密数据不应在面向公众的网站上可以访问，即使它不容易被发现。
- en: '**Best Practices: Automation**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最佳实践：Automation**'
- en: Azure Automation is a powerful tool for automating repetitive tasks both in
    the cloud and on-premises. However, its ability to perform a wide variety of tasks
    also makes it a security concern if used by a malicious actor. Here are some steps
    to help keep your Azure Automation jobs secure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Automation 是一个强大的工具，用于自动化云端和本地的重复任务。然而，它能够执行多种任务，也使其在被恶意行为者使用时成为一个安全隐患。以下是一些帮助保持
    Azure Automation 作业安全的步骤。
- en: Begin by being cautious about what values, or *assets*, you place in Azure Automation’s
    variable storage. Automation gives users the ability to store things like credentials,
    which can then be used by jobs to access resources they need to do their work.
    Assets are stored encrypted, but since the running job needs to be able to use
    them, the decryption key is stored in a Key Vault that is accessible to Automation.
    This means that anyone who can create and run a job is able to retrieve the cleartext
    value of any asset, as described in “[Obtaining Automation Assets](part0016.html#lev175)”
    on [page 152](part0016.html#page_152). If you’re storing credentials as assets,
    be sure these credentials have the fewest rights possible to accomplish their
    task.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时要小心你在 Azure Automation 的变量存储中放置了哪些值或 *资产*。Automation 允许用户存储像凭证这样的东西，凭证可以被作业用来访问它们执行工作所需的资源。资产是加密存储的，但由于运行中的作业需要使用它们，因此解密密钥存储在可以访问
    Automation 的 Key Vault 中。这意味着任何可以创建并运行作业的人，都能够获取任何资产的明文值，正如在[“获取 Automation 资产”](part0016.html#lev175)一节中，位于[第
    152 页](part0016.html#page_152)所描述的那样。如果你存储凭证作为资产，请确保这些凭证拥有完成任务所需的最少权限。
- en: Next, if you plan to have Automation kick off tasks in your corporate environment,
    you’ll need to set up Hybrid Workers, which involves installing an agent onto
    on-premises systems, described in depth on [page 157](part0016.html#page_157).
    By default, these agents will run jobs using the local system account on these
    servers, meaning the jobs will have full administrative access to the server where
    they’re run. Therefore, you should never configure a sensitive system as a Hybrid
    Worker. Although Hybrid Workers and the jobs they run will certainly need some
    level of access to resources to complete their tasks, make sure to create a good
    threat model and consider any risks that may come with this type of cloud-to-corporate
    access.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果你计划让自动化在你的企业环境中启动任务，你需要设置混合工作者，这涉及到在本地系统上安装一个代理，详细内容见[第 157 页](part0016.html#page_157)。默认情况下，这些代理将在这些服务器上使用本地系统帐户运行作业，这意味着作业将具有对运行它们的服务器的完全管理员访问权限。因此，你绝不应该将敏感系统配置为混合工作者。尽管混合工作者及其运行的作业肯定需要某种程度的资源访问权限才能完成任务，但请确保创建一个良好的威胁模型，并考虑到这种云到企业访问可能带来的任何风险。
- en: '**Leveraging Azure Automation**'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**利用 Azure 自动化**'
- en: One final service worth discussing is Azure Automation, which is essentially
    a sophisticated task scheduler for the cloud. Administrators create *runbooks*,
    or workflows of tasks, using PowerShell or a graphical editor in the Azure portal.
    A runbook can perform a wide variety of actions. For example, it might parse a
    log file every five minutes and then send an alert to an administrator if a critical
    error occurred. If a task is repetitive, uses cloud resources, and can be scripted
    in PowerShell, it’s a good candidate for automation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得讨论的最终服务是 Azure 自动化，它本质上是云中的一个复杂任务调度程序。管理员使用 PowerShell 或 Azure 门户中的图形编辑器创建
    *运行簿*，即任务的工作流。运行簿可以执行多种多样的操作。例如，它可以每五分钟解析一次日志文件，然后在发生严重错误时向管理员发送警报。如果某个任务是重复性的，使用云资源，并且可以用
    PowerShell 脚本化，那么它是自动化的一个良好候选项。
- en: 'Although Azure Automation is a complex service with many features, two components
    are of particular interest to a security professional: assets and Hybrid Workers.
    Automation assets are another location in Azure where users can keep secrets,
    similar to a Key Vault instance. Hybrid Workers allow a runbook to perform tasks
    using on-premises resources, not unlike some of the network bridging technologies
    in [Chapter 6](part0015.html#ch06).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Azure 自动化是一个功能复杂的服务，具有许多功能，但有两个组件对安全专业人员尤为重要：资产和混合工作者。自动化资产是 Azure 中的另一个位置，用户可以在其中存储机密，类似于一个
    Key Vault 实例。混合工作者允许运行簿使用本地资源执行任务，这与[第 6 章](part0015.html#ch06)中某些网络桥接技术类似。
- en: '***Obtaining Automation Assets***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取自动化资产***'
- en: Anyone who has spent time working in system administration has likely written
    dozens, if not hundreds, of scripts to make their work more efficient and less
    tedious. Although such scripts vary considerably between authors, organizations,
    and target platforms, almost every script has variables and input data. Often,
    this includes the account that the script should use to perform its actions, a
    list of systems to target, and a location to log any output.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 任何曾在系统管理中工作过的人，可能都写过数十个，甚至数百个脚本，以提高工作效率并减少繁琐的工作。尽管这些脚本在作者、组织和目标平台之间差异很大，但几乎每个脚本都有变量和输入数据。通常，这包括脚本应该使用的帐户、目标系统的列表以及记录任何输出的位置。
- en: Azure Automation needs to allow such input so its runbooks can offer more than
    the most basic functionality. But unlike traditional scripts, runbooks are executed
    by Azure, not by a user from a command line. To address this gap, Azure Automation
    allows users to declare and save variables, credentials, connections, and certificates—generically
    referred to as *assets*—within the Automation service. Runbooks can then reference
    those assets, but they aren’t runbook specific; they are shared between all runbooks
    within an Automation account. Although a subscription may have multiple Automation
    accounts, assets aren’t sharable across those accounts.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 自动化需要允许这种输入，以便其运行簿能够提供比最基本功能更多的功能。但与传统脚本不同，运行簿是由 Azure 执行的，而不是由用户从命令行执行。为了弥补这一差距，Azure
    自动化允许用户在自动化服务中声明并保存变量、凭据、连接和证书——统称为 *资产*。运行簿可以引用这些资产，但它们不是特定于运行簿的；它们在一个自动化帐户内的所有运行簿之间共享。尽管一个订阅可能有多个自动化帐户，但资产在这些帐户之间是不可共享的。
- en: 'Let’s discuss each of the four asset classes, which are similar but have subtle
    differences:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论四类资产，它们相似但有微妙的区别：
- en: '**Variables**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**'
- en: 'When defining a variable, the developer provides a name, a data type, a value,
    and an optional description, and specifies if Automation should store the value
    encrypted. Variables can be any of the following types: Strings, Booleans, DateTimes,
    Integers, or Other (“Not Specified”). If the encrypted flag is set, the Azure
    portal won’t display the data type for that variable, and the value field will
    be displayed as asterisks. However, because runbooks need to be able to use the
    value, users can display variables, regardless of their encryption status, using
    the `Get-AutomationVariable` cmdlet within a runbook.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义变量时，开发人员提供名称、数据类型、值和可选描述，并指定是否应加密存储值。如果设置了加密标志，Azure 门户将不会显示该变量的数据类型，并且值字段将显示为星号。然而，由于运行簿需要能够使用该值，用户可以通过在运行簿中使用
    `Get-AutomationVariable` cmdlet 来显示变量，无论它们的加密状态如何。
- en: '**Connections**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接**'
- en: 'Connections are used to log in to Azure subscriptions within a runbook. Users
    can retrieve connections with the `Get-AutomationConnection` cmdlet, which returns
    a hash table with the values from the following keys inside: `SubscriptionId`,
    `ApplicationId`, `TenantId`, and `CertificateThumbprint`. Typically, these values
    are used in a subsequent call to `Add-AzureRMAccount` to connect to the desired
    subscription. Connection objects themselves don’t contain any secret data.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 连接用于在运行簿中登录到 Azure 订阅。用户可以使用 `Get-AutomationConnection` cmdlet 检索连接，它返回一个哈希表，其中包含以下键的值：`SubscriptionId`、`ApplicationId`、`TenantId`
    和 `CertificateThumbprint`。通常，这些值会在随后的调用中用于 `Add-AzureRMAccount` 以连接到所需的订阅。连接对象本身不包含任何机密数据。
- en: '**Credentials**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**凭据**'
- en: In Azure Automation, credentials are stored in `PSCredential` objects and consist
    of an object name, a username, a password, and an optional description. Like encrypted
    variables, credentials are encrypted in Azure portal to protect their passwords.
    Even after using the `Get-AutomationPSCredential` cmdlet to retrieve the credential,
    Azure won’t display the value, because it expects developers to pass the entire
    returned `PSCredential` object to any system needing the account. However, users
    can display the password and username by calling the `GetNetworkCredential` function
    on the `PSCredential` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 自动化中，凭据存储在 `PSCredential` 对象中，包含对象名称、用户名、密码和可选描述。与加密变量类似，凭据在 Azure 门户中被加密，以保护其密码。即使使用
    `Get-AutomationPSCredential` cmdlet 来检索凭据，Azure 也不会显示值，因为它期望开发人员将返回的整个 `PSCredential`
    对象传递给任何需要该账户的系统。然而，用户可以通过调用 `PSCredential` 对象上的 `GetNetworkCredential` 函数来显示密码和用户名。
- en: '**Certificates**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**证书**'
- en: 'Users can upload X.509 certificates in either *.cer* (public key only) or *.pfx*
    (public and private key) form to Azure Automation. When an Automation account
    is created, Azure provides an option to automatically populate the certificate
    store with two certificates that can be used to manage ASM and ARM resources:
    `AzureClassicRunAsCertificate` and `AzureRunAsCertificate`, respectively. If the
    user declines this option, Azure prompts them a second time to confirm, because
    these certificates are helpful for completing tasks in Azure. So, you should expect
    to see these certificates in almost every Automation account you encounter. Although
    a user could upload certificates for any purpose, certificates in Automation are
    usually used in conjunction with connections to manage other Azure resources.
    You can retrieve certificates using the `Get-AutomationCertificate` cmdlet, which
    retrieves the certificate’s details, public key, and the private key, if present.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以以 *.cer*（仅公钥）或 *.pfx*（公钥和私钥）形式将 X.509 证书上传到 Azure 自动化。当创建自动化帐户时，Azure 提供了一个选项，可以自动填充证书存储，其中包含两个可以用于管理
    ASM 和 ARM 资源的证书：`AzureClassicRunAsCertificate` 和 `AzureRunAsCertificate`。如果用户拒绝此选项，Azure
    会第二次提示用户确认，因为这些证书对于完成 Azure 中的任务非常有用。因此，您应该期望在几乎所有遇到的自动化帐户中看到这些证书。尽管用户可以上传用于任何目的的证书，但自动化中的证书通常与连接一起使用，以管理其他
    Azure 资源。您可以使用 `Get-AutomationCertificate` cmdlet 检索证书，它将检索证书的详细信息、公钥和私钥（如果存在）。
- en: Using the cmdlets and functions just discussed, you can create a runbook to
    collect asset values that may help further your infiltration into the client’s
    environment. Start by opening the Azure portal and selecting Azure Automation
    from the service list. In the Automation Accounts window, check for any existing
    Automation accounts, as shown in [Figure 7-3](part0016.html#ch07fig3).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用刚才讨论过的 cmdlet 和函数，您可以创建一个 runbook 来收集可能有助于进一步渗透客户端环境的资产值。首先打开 Azure 门户，从服务列表中选择
    Azure 自动化。在**自动化帐户**窗口中，检查是否有现有的自动化帐户，如[图 7-3](part0016.html#ch07fig3)所示。
- en: '![image](../images/00053.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00053.jpeg)'
- en: '*Figure 7-3: List of Azure Automation accounts*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Azure 自动化帐户列表*'
- en: If none are listed, the target subscription isn’t using Automation and you can
    skip this section. If multiple accounts are listed, you’ll want to perform the
    steps in this section for each account. Click the name of an Automation account
    to open it. You should then see a view similar to [Figure 7-4](part0016.html#ch07fig4).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有列出任何项，则目标订阅没有使用自动化，您可以跳过此部分。如果列出了多个帐户，您需要对每个帐户执行本节中的步骤。点击某个自动化帐户的名称以打开它。接下来，您应该看到类似于[图
    7-4](part0016.html#ch07fig4)的视图。
- en: Once a specific account is displayed, you can browse around to get an idea of
    how Automation is being used. Click **Runbooks** and review the names of the scripts.
    If any sound interesting, click them and then click **Edit** to view their source
    code—just be sure not to save any changes to them. You can also quickly browse
    the available assets by clicking the various tabs under the Shared Resources section
    in the menu on the left in [Figure 7-4](part0016.html#ch07fig4), but Azure won’t
    display any secret values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦显示出特定帐户，您可以浏览查看自动化的使用情况。点击**Runbooks**并查看脚本的名称。如果有任何看起来有趣的，点击它们，然后点击**编辑**查看其源代码——只是确保不要保存任何更改。您还可以通过点击左侧菜单中**共享资源**部分下的各种标签，快速浏览可用的资产，如[图
    7-4](part0016.html#ch07fig4)所示，但 Azure 不会显示任何机密值。
- en: To display all of the assets, including passwords, encrypted variables, and
    certificate private keys, click **Runbooks** and then click **Add a runbook**
    at the top of the page. In the menu that appears, click **Create a new runbook**
    and then provide a name for the runbook and select **PowerShell** as the runbook
    type. Finally, click **Create**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示所有资产，包括密码、加密变量和证书私钥，点击**Runbooks**，然后点击页面顶部的**添加 runbook**。在出现的菜单中，点击**创建新的
    runbook**，然后为 runbook 提供一个名称，并选择**PowerShell**作为 runbook 类型。最后，点击**创建**。
- en: '![image](../images/00054.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00054.jpeg)'
- en: '*Figure 7-4: Main view of an Automation account*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：自动化帐户的主视图*'
- en: A blank runbook will appear. On the left side, a tree view provides a helpful
    list of available PowerShell cmdlets, other runbooks, and, most importantly, assets
    you can use. Expand the Assets object as well as each nested item, as shown in
    [Figure 7-5](part0016.html#ch07fig5).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空白的 runbook 将出现。在左侧，树状视图提供了可用的 PowerShell cmdlet、其他 runbook，以及最重要的，可以使用的资产列表。展开**资产**对象以及每个嵌套项，如[图
    7-5](part0016.html#ch07fig5)所示。
- en: For every asset that sounds interesting, you can click the ellipsis menu next
    to the asset name and click **Add to canvas**. This will add a new line of code
    to the runbook that retrieves that asset. For variables and connections, this
    is sufficient to display the interesting parts of those elements. However, for
    credentials and certificates, you’ll need to add a few extra lines of code to
    get the passwords and private keys.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个听起来有趣的资产，您可以点击资产名称旁边的省略号菜单，然后点击**添加到画布**。这将向 runbook 中添加一行新代码，用于检索该资产。对于变量和连接，这足以显示这些元素中有趣的部分。然而，对于凭证和证书，您需要添加几行额外的代码来获取密码和私钥。
- en: '![image](../images/00055.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00055.jpeg)'
- en: '*Figure 7-5: List of assets available for the runbook*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：runbook 可用资产列表*'
- en: 'For passwords, store the output of the `Get-AutomationPSCredential` credential
    in a variable and then use `GetNetworkCredential()` to get the username and password
    values, like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于密码，将`Get-AutomationPSCredential`凭证的输出存储在一个变量中，然后使用`GetNetworkCredential()`获取用户名和密码值，如下所示：
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When looking at a certificate, I like to display the certificate’s name and
    thumbprint, as well as its public and private keys as XML. This should be sufficient
    to import the certificate into a different system for use outside of Azure. To
    do this, put the following in the runbook:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 查看证书时，我喜欢显示证书的名称和指纹，以及其公钥和私钥的 XML 格式。这应该足以将证书导入到不同的系统中，以便在 Azure 外部使用。要做到这一点，请在
    runbook 中输入以下内容：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will save the certificate object into a variable ➊, display its thumbprint
    and subject ➋, and output its private key ➌ and public key ➍. [Figure 7-6](part0016.html#ch07fig6)
    shows the completed runbook ready to execute.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把证书对象保存到变量 ➊ 中，显示其指纹和主题 ➋，并输出其私钥 ➌ 和公钥 ➍。[图 7-6](part0016.html#ch07fig6) 显示了准备执行的完整
    Runbook。
- en: '![image](../images/00056.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00056.jpeg)'
- en: '*Figure 7-6: Completed runbook to retrieve assets*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：完成的 Runbook 用于检索资产*'
- en: Once you are satisfied with your runbook, click **Save** and then click **Test
    pane**. This will open a new view where you can click **Start** to execute the
    runbook. Once the runbook is finished, any output will be displayed in white,
    as shown in [Figure 7-7](part0016.html#ch07fig7). If your runbook had any exceptions,
    error messages will be displayed in the output area in red.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对您的 Runbook 感到满意，点击**保存**，然后点击**测试窗格**。这将打开一个新视图，在该视图中您可以点击**开始**来执行 Runbook。运行结束后，任何输出将以白色显示，如[图
    7-7](part0016.html#ch07fig7)所示。如果您的 Runbook 出现异常，错误信息将以红色显示在输出区域。
- en: '![image](../images/00057.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00057.jpeg)'
- en: '*Figure 7-7: Runbook Test pane with output*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：带有输出的 Runbook 测试窗格*'
- en: From the Test pane, you can see the completed runbook execution as well as the
    variable values, connection details, credential username and password, certificate
    details, and the public and private keys you requested. You can then use this
    information to pivot into subscriptions, services, or systems that may have been
    previously inaccessible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试窗格中，您可以看到完成的 Runbook 执行情况，以及变量值、连接详情、凭据用户名和密码、证书详情，以及您请求的公钥和私钥。然后，您可以利用这些信息进入之前可能无法访问的订阅、服务或系统。
- en: '***Hybrid Workers***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***混合工作节点***'
- en: In addition to being able to automate tasks in the cloud, Azure Automation also
    has the ability to perform tasks on a corporate network. Azure provides a package
    that an administrator can install on several on-premises systems. These machines
    then become *Hybrid Workers* that receive commands from Azure Automation and execute
    them on the corporate network. This is similar to the network bridging technologies
    discussed in [Chapter 6](part0015.html#ch06); however, those services were designed
    for moving data between a company and the cloud, whereas Hybrid Workers are meant
    for sending management commands to corporate systems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够在云中自动化任务外，Azure 自动化还能够在公司网络上执行任务。Azure 提供了一个软件包，管理员可以将其安装在多个本地系统上。这些机器随后成为*混合工作节点*，接收来自
    Azure 自动化的命令并在公司网络上执行。这类似于[第 6 章](part0015.html#ch06)中讨论的网络桥接技术；不过，那些服务是为在公司与云之间传输数据而设计的，而混合工作节点则用于向公司系统发送管理命令。
- en: '**Hybrid Worker Mechanics**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**混合工作节点机制**'
- en: Setting up a Hybrid Worker isn’t trivial. Administrators have to create an Operations
    Management Suite (OMS) account at *[https://mms.microsoft.com/](https://mms.microsoft.com/)*,
    enable the Automation solution in the OMS portal, download and install a program
    called Microsoft Management Agent on the machines they want to be Hybrid Workers,
    and then run the *New-OnPremiseHybridWorker**.ps1* script on those systems—specifying
    which subscription and Automation account the worker should use. So, you aren’t
    likely to find a Hybrid Worker in every automation account—but those that do have
    one are likely making use of it. This is good news for a pentester because it
    means Hybrid Worker systems are often online and have access to interesting accounts
    and systems on their corporate networks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 设置混合工作节点并不简单。管理员需要在*[https://mms.microsoft.com/](https://mms.microsoft.com/)*创建一个操作管理套件（OMS）账户，在
    OMS 门户中启用自动化解决方案，在他们希望作为混合工作节点的机器上下载并安装一个名为 Microsoft 管理代理的程序，然后在这些系统上运行*New-OnPremiseHybridWorker**.ps1*脚本，指定工作节点应使用的订阅和自动化账户。因此，您不太可能在每个自动化账户中找到一个混合工作节点，但那些有混合工作节点的账户很可能正在使用它。对于渗透测试人员来说，这是个好消息，因为这意味着混合工作节点系统通常是在线的，并且可以访问公司网络上的有趣账户和系统。
- en: Once installed, the Hybrid Worker operates by running the System Center Management
    Service host process, called *MonitoringHost.exe*, which polls an *azure-automation.net*
    server over HTTPS, looking for work. Once it finds a job, it spawns an instance
    of *Orchestrator.Sandbox.exe*, which then runs the runbook script. If needed,
    *Orchestrator.Sandbox.exe* may launch *conhost.exe* processes to run non-PowerShell
    commands. By default, all of these processes run as the *NT AUTHORITY\SYSTEM*
    account, which means that runbooks have administrative access to the system acting
    as a Hybrid Worker, but they don’t automatically have access to other systems
    on the domain. This is where *credential assets*—credentials stored within Azure
    automation for use within runbooks—come in; if a runbook needs to access a different
    system on the corporate domain—to copy files from a network share, for example—it
    needs to use an account with those privileges. Either the runbook developer can
    use the credential directly in the script with the `Get-AutomationPSCredential`
    cmdlet or they can set the Hybrid Worker to run all scripts in the context of
    a credential asset. Either way, the developer must store the credential in the
    Automation account.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，混合工作者通过运行名为*MonitoringHost.exe*的系统中心管理服务主机进程来操作，该进程通过 HTTPS 与*azure-automation.net*服务器进行通信，查找任务。一旦找到任务，它会生成一个*Orchestrator.Sandbox.exe*实例，该实例随后运行运行簿脚本。如果需要，*Orchestrator.Sandbox.exe*可以启动*conhost.exe*进程来执行非
    PowerShell 命令。默认情况下，所有这些进程都以*NT AUTHORITY\SYSTEM*账户运行，这意味着运行簿具有对充当混合工作者的系统的管理权限，但它们不会自动访问域上的其他系统。此时，*凭证资产*—即存储在
    Azure 自动化中的凭证供运行簿使用—就派上用场了；如果运行簿需要访问公司域上的其他系统（例如，从网络共享复制文件），则需要使用具有这些权限的账户。运行簿开发人员可以通过`Get-AutomationPSCredential`
    cmdlet直接在脚本中使用凭证，或者可以设置混合工作者以凭证资产的身份运行所有脚本。无论哪种方式，开发人员都必须将凭证存储在自动化账户中。
- en: '**Identifying Hybrid Workers**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**识别混合工作者**'
- en: 'Determining if an Automation account contains Hybrid Workers is easy: in the
    Azure portal, navigate to an Automation account instance and then click **Hybrid
    worker groups** in the account’s menu. There may be one or more worker groups
    listed; each group is a pool of one or more Hybrid Workers that can be assigned
    work. To see what machines are in a given group, click the group name. This will
    open the group, as shown in [Figure 7-8](part0016.html#ch07fig8).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 判断一个自动化账户是否包含混合工作者很简单：在 Azure 门户中，导航到一个自动化账户实例，然后点击账户菜单中的**混合工作者组**。可能会列出一个或多个工作者组；每个组是一个可以分配工作的一个或多个混合工作者的池。要查看某个组中有哪些机器，请点击组名。这将打开该组，如[图
    7-8](part0016.html#ch07fig8)所示。
- en: '![image](../images/00058.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00058.jpeg)'
- en: '*Figure 7-8: A Hybrid Worker group blade*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：混合工作者组面板*'
- en: From this pane, you can see the list of individual servers’ names in this group
    by clicking the **Hybrid Workers** tile. You can also see if the workers in this
    group are running as the default Local System account or using a credential asset
    by clicking **Hybrid worker group settings**, as shown in [Figure 7-9](part0016.html#ch07fig9).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在此面板中，您可以通过点击**混合工作者**图标来查看此组中各个服务器的名称。您还可以通过点击**混合工作者组设置**来查看该组中的工作者是否以默认的本地系统账户运行，或是否使用凭证资产，如[图
    7-9](part0016.html#ch07fig9)所示。
- en: '![image](../images/00059.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00059.jpeg)'
- en: '*Figure 7-9: Hybrid worker group settings showing a custom credential being
    used*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：展示使用自定义凭证的混合工作者组设置*'
- en: All Hybrid Workers in a given group run using the same credential.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 给定组中的所有混合工作者都使用相同的凭证运行。
- en: '**Using Hybrid Workers**'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用混合工作者**'
- en: When I find an Automation account with Hybrid Workers, I’m immediately curious
    what I can do with it. If you’re an outsider using Automation as your entry point
    into the network, you may not have any idea what the Hybrid Worker servers or
    the credential assets can access. A good way to get started is by reviewing any
    existing runbooks in the account. This way, you’ll learn how the subscription
    is using Automation, as well as at least a few systems that can be used with the
    credential assets. To do this, select the **Runbooks** tab in the Automation account
    in Azure portal; then click any runbook and click the **Edit** button. This will
    show the source code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我找到一个带有Hybrid Workers的自动化账户时，我立刻好奇我能用它做什么。如果你是一个外部人员，通过自动化作为进入网络的入口点，你可能完全不知道Hybrid
    Worker服务器或凭据资产可以访问哪些内容。一个好的入门方法是查看账户中现有的任何运行手册。通过这种方式，你将了解订阅是如何使用自动化的，并且至少了解一些可以使用凭据资产的系统。为此，选择Azure门户中自动化账户的**运行手册**标签；然后点击任意运行手册并点击**编辑**按钮。这将显示源代码。
- en: In the Automation Account pane, you may also want to review the Activity Log
    and Schedules tabs. The Activity Log tab lets you review any jobs that have run
    recently, as well as see whether anyone has made any changes to runbooks, Hybrid
    Worker groups, or assets. The Schedules tab shows any upcoming runbook executions,
    which can be useful if you plan to modify an existing runbook and need to know
    which one will run next.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化账户面板中，你可能还想查看活动日志和调度标签。活动日志标签让你查看最近运行的任何任务，以及是否有人对运行手册、Hybrid Worker组或资产进行了更改。调度标签显示任何即将执行的运行手册，这在你计划修改现有运行手册并需要知道下一个将执行的是哪个时非常有用。
- en: 'Once you have some knowledge of the Automation account, you might create or
    modify a runbook to get code running on a Hybrid Worker. To do this, follow the
    same steps for creating a runbook as we did in “[Obtaining Automation Assets](part0016.html#lev175)”
    on [page 152](part0016.html#page_152). A good initial test runbook might look
    like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对自动化账户有了一些了解，你可能会创建或修改一个运行手册，以便在Hybrid Worker上运行代码。为此，按照我们在“[获取自动化资产](part0016.html#lev175)”中所做的相同步骤来创建一个运行手册，详见[第152页](part0016.html#page_152)。一个好的初始测试运行手册可能是这样的：
- en: '[PRE5]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This runbook displays the assigned worker’s name, the account the script is
    running as, and some information about the host process.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运行手册显示了分配的工作者的名称，脚本以哪个账户运行，以及一些关于主机进程的信息。
- en: Once the runbook is complete and you open the Test pane, you will see an option
    labeled *Run on*. Instead of Azure, select the **Hybrid Worker** button, and then
    from the **Choose Hybrid Worker group** drop-down list, select the group you want
    to execute the code. You can’t choose a specific worker for the runbook; Automation
    will assign the job based on its scheduler. Once you click **Start**, the job
    will be sent to a worker, and the results will be displayed in the Test pane—just
    as they were when the runbook ran on Azure, as shown in [Figure 7-10](part0016.html#ch07fig10).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行手册完成并且你打开测试面板，你将看到一个标有*运行在*的选项。选择**Hybrid Worker**按钮，而不是Azure，然后从**选择Hybrid
    Worker组**下拉列表中，选择你想执行代码的组。你不能为运行手册选择特定的工作者；自动化将根据其调度器分配任务。一旦点击**开始**，任务将被发送到一个工作者，结果将在测试面板中显示——就像运行手册在Azure上运行时一样，如[图7-10](part0016.html#ch07fig10)所示。
- en: '![image](../images/00060.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00060.jpeg)'
- en: '*Figure 7-10: Completed runbook execution on a Hybrid Worker*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-10：在Hybrid Worker上完成的运行手册执行*'
- en: At this point, you have a pretty ideal penetration testing setup. You have an
    externally accessible entry point into a private network, credentials for that
    network, and existing scripts to provide a starting point. From here, you can
    use your favorite PowerShell commands for post-exploitation to explore the network,
    pivot to other systems, collect loot, and more.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你已经有了一个相当理想的渗透测试设置。你有一个可以访问私有网络的外部入口点，拥有该网络的凭据，并且有现有的脚本作为起点。从这里，你可以使用你最喜欢的PowerShell命令进行后期利用，探索网络，切换到其他系统，收集战利品，等等。
- en: '**Summary**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this chapter, we looked at three services that are unique to Azure: Key
    Vault, Web Apps, and Azure Automation. Each service offers both a challenge and
    an opportunity for information security professionals. Key Vault can solve many
    of the issues pentesters identify, but it can also have its own problems if misconfigured.
    Web Apps make development and deployment of new sites very easy, but with some
    risk of credential management problems. And while Azure Automation is a complicated
    service to learn, the most interesting components from a security perspective
    are similar to concepts you’ve seen used in other parts of Azure, such as Key
    Vault and Service Bus, with similar risks and threat models.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了三个 Azure 独有的服务：Key Vault、Web Apps 和 Azure Automation。每个服务都对信息安全专业人员提出了挑战，同时也带来了机会。Key
    Vault 可以解决渗透测试人员发现的许多问题，但如果配置错误，也可能会有自身的问题。Web Apps 使得新网站的开发和部署变得非常简单，但也存在一些凭证管理的问题风险。而
    Azure Automation 尽管是一个学习起来较为复杂的服务，从安全角度来看，最有趣的组件与 Azure 中其他部分使用的概念相似，如 Key Vault
    和 Service Bus，具有类似的风险和威胁模型。
- en: In the next chapter, we’ll switch gears and look at ways that Azure’s security
    monitoring features can detect and alert on illicit activities.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将转换话题，探讨 Azure 的安全监控功能如何检测并警告非法活动。
