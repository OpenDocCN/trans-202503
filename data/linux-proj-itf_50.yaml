- en: Chapter 50. Virtual Memory Operations
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第50章 虚拟内存操作
- en: 'This chapter looks at various system calls that perform operations on a process’s
    virtual address space:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了执行操作的各种系统调用，这些操作作用于进程的虚拟地址空间：
- en: The *mprotect()* system call changes the protection on a region of virtual memory.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mprotect()* 系统调用更改虚拟内存区域的保护。'
- en: The *mlock()* and *mlockall()* system calls lock a region of virtual memory
    into physical memory, thus preventing it from being swapped out.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mlock()* 和 *mlockall()* 系统调用将虚拟内存区域锁定到物理内存中，从而防止其被交换出去。'
- en: The *mincore()* system call allows a process to determine whether the pages
    in a region of virtual memory are resident in physical memory.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mincore()* 系统调用允许进程确定虚拟内存区域中的页面是否驻留在物理内存中。'
- en: The *madvise()* system call allows a process to advise the kernel about its
    future patterns of usage of a virtual memory region.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*madvise()* 系统调用允许进程向内核建议其未来使用虚拟内存区域的模式。'
- en: Some of these system calls find particular use in conjunction with shared memory
    regions ([Chapter 48](ch48.html "Chapter 48. System V Shared Memory"), [Chapter 49](ch49.html
    "Chapter 49. Memory Mappings"), and [Chapter 54](ch54.html "Chapter 54. POSIX
    Shared Memory")), but they can be applied to any region of a process’s virtual
    memory.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些系统调用特别用于与共享内存区域结合使用（[第48章](ch48.html "第48章 系统V共享内存")、[第49章](ch49.html "第49章
    内存映射") 和 [第54章](ch54.html "第54章 POSIX共享内存")），但它们也可以应用于任何进程的虚拟内存区域。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The techniques described in this chapter are not in fact about IPC at all, but
    we include them in this part of the book because they are sometimes used with
    shared memory.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所描述的技术实际上与进程间通信（IPC）无关，但我们将它们包括在本书的这一部分，因为它们有时与共享内存一起使用。
- en: 'Changing Memory Protection: *mprotect()*'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改内存保护：*mprotect()*
- en: The *mprotect()* system call changes the protection on the virtual memory pages
    in the range starting at *addr* and continuing for *length* bytes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*mprotect()* 系统调用更改从 *addr* 开始、持续 *length* 字节的虚拟内存页的保护。'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1。
- en: The value given in *addr* must be a multiple of the system page size (as returned
    by *sysconf(_SC_PAGESIZE)*). (SUSv3 specified that *addr must* be page-aligned.
    SUSv4 says that an implementation *may* require this argument to be page-aligned.)
    Because protections are set on whole pages, *length* is, in effect, rounded up
    to the next multiple of the system page size.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*addr* 中给定的值必须是系统页面大小的倍数（由 *sysconf(_SC_PAGESIZE)* 返回）。(SUSv3 指定 *addr* 必须按页面对齐。SUSv4
    表示实现 *可以* 要求此参数按页面对齐。) 因为保护是针对整个页面设置的，所以 *length* 实际上会四舍五入到系统页面大小的下一个倍数。'
- en: 'The *prot* argument is a bit mask specifying the new protection for this region
    of memory. It must be specified as either `PROT_NONE` or a combination created
    by ORing together one or more of `PROT_READ`, `PROT_WRITE`, and `PROT_EXEC`. All
    of these values have the same meaning as for *mmap()* ([Table 49-2](ch49.html#memory_protection_values
    "Table 49-2. Memory protection values"), in [Creating a Mapping: *mmap()*](ch49.html#creating_a_mapping_colon_mmap_open_paren
    "Creating a Mapping: mmap()")).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*prot* 参数是一个位掩码，指定该内存区域的新保护。它必须指定为 `PROT_NONE` 或通过对 `PROT_READ`、`PROT_WRITE`
    和 `PROT_EXEC` 之一或多个进行 OR 运算得到的组合。这些值的含义与 *mmap()* 中相同（见[表49-2](ch49.html#memory_protection_values
    "表49-2. 内存保护值")，以及[创建映射：*mmap()*](ch49.html#creating_a_mapping_colon_mmap_open_paren
    "创建映射：mmap()")）。'
- en: If a process attempts to access a region of memory in a manner that violates
    the memory protection, the kernel generates a `SIGSEGV` signal for the process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程尝试以违反内存保护的方式访问内存区域，内核会为该进程生成一个 `SIGSEGV` 信号。
- en: 'One use of *mprotect()* is to change the protection of a region of mapped memory
    originally set in a call to *mmap()*, as shown in [Example 50-1](ch50.html#changing_memory_protection_with_mprotect
    "Example 50-1. Changing memory protection with mprotect()"). This program creates
    an anonymous mapping that initially has all access denied (`PROT_NONE`). The program
    then changes the protection on the region to read plus write. Before and after
    making the change, the program uses the *system()* function to execute a shell
    command that displays the line from the `/proc/`*PID*`/maps` file corresponding
    to the mapped region, so that we can see the change in memory protection. (We
    could have obtained the mapping information by directly parsing `/proc/self/maps`,
    but we used the call to *system()* because it results in a shorter program.) When
    we run this program, we see the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*mprotect()* 的一个用途是改变通过 *mmap()* 调用时设置的映射内存区域的保护，如 [示例 50-1](ch50.html#changing_memory_protection_with_mprotect
    "示例 50-1. 使用 mprotect() 修改内存保护") 中所示。该程序创建了一个匿名映射，初始时所有访问都被拒绝（`PROT_NONE`）。然后程序将该区域的保护更改为可读加可写。在更改前后，程序使用
    *system()* 函数执行一个 shell 命令，显示来自 `/proc/`*PID*`/maps` 文件中与映射区域对应的行，从而可以看到内存保护的变化。（我们本可以直接解析
    `/proc/self/maps` 来获取映射信息，但我们使用 *system()* 调用是因为它能使程序更简短。）当我们运行这个程序时，输出如下：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the last line of output, we can see that *mprotect()* has changed the permissions
    of the memory region to `PROT_READ | PROT_WRITE`. (For an explanation of the `(deleted)`
    string that appears after `/dev/zero` in the shell output, refer to Section 48.5.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从最后一行输出中，我们可以看到 *mprotect()* 已经将内存区域的权限更改为 `PROT_READ | PROT_WRITE`。（关于 shell
    输出中 `/dev/zero` 后出现的 `(deleted)` 字符串的解释，请参见第 48.5 节。）
- en: Example 50-1. Changing memory protection with *mprotect()*
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 50-1. 使用 *mprotect()* 修改内存保护
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Memory Locking: *mlock()* and *mlockall()*'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存锁定：*mlock()* 和 *mlockall()*
- en: In some applications, it is useful to lock part or all of a process’s virtual
    memory so that it is guaranteed to always be in physical memory. One reason for
    doing this is to improve performance. Accesses to locked pages are guaranteed
    never to be delayed by a page fault. This is useful for applications that must
    ensure rapid response times.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用程序中，锁定进程虚拟内存的部分或全部内容是很有用的，这样可以保证它始终驻留在物理内存中。这样做的一个原因是为了提高性能。对锁定页面的访问可以保证不会因为页面错误而被延迟。这对于必须确保快速响应时间的应用程序非常有用。
- en: Another reason for locking memory is security. If a virtual memory page containing
    sensitive data is never swapped out, then no copy of the page is ever written
    to the disk. If the page was written to the disk, it could, in theory, be read
    directly from the disk device at some later time. (An attacker could deliberately
    engineer this situation by running a program that consumes a large amount of memory,
    thus forcing the memory of other processes to be swapped out to disk.) Reading
    information from the swap space could even be done after the process has terminated,
    since the kernel makes no guarantees about zeroing out the data held in swap space.
    (Normally, only privileged processes would be able to read from the swap device.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定内存的另一个原因是安全性。如果包含敏感数据的虚拟内存页从未被交换出去，那么该页的副本将永远不会写入磁盘。如果该页被写入磁盘，理论上它可以在以后直接从磁盘设备读取。（攻击者可以故意制造这种情况，通过运行一个消耗大量内存的程序，从而迫使其他进程的内存被交换到磁盘。）即使在进程终止后，也可以从交换空间中读取信息，因为内核并不保证将交换空间中的数据清零。（通常，只有具有特权的进程才有权从交换设备读取数据。）
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The suspend mode on laptop computers, as well some desktop systems, saves a
    copy of a system’s RAM to disk, regardless of memory locks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本电脑的挂起模式，以及一些桌面系统，会将系统的 RAM 内容保存到磁盘中，无论是否有内存锁定。
- en: In this section, we look at the system calls used for locking and unlocking
    part or all of a process’s virtual memory. However, before doing this, we first
    look at a resource limit that governs memory locking.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将讨论用于锁定和解锁进程虚拟内存部分或全部内容的系统调用。然而，在这之前，我们首先看看一个控制内存锁定的资源限制。
- en: The `RLIMIT_MEMLOCK` resource limit
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`RLIMIT_MEMLOCK` 资源限制'
- en: In [Details of Specific Resource Limits](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits"), we briefly described the `RLIMIT_MEMLOCK`
    limit, which defines a limit on the number of bytes that a process can lock into
    memory. We now consider this limit in more detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[具体资源限制的详细信息](ch36.html#details_of_specific_resource_limits "Details of Specific
    Resource Limits")中，我们简要介绍了 `RLIMIT_MEMLOCK` 限制，它定义了进程可以锁定到内存中的字节数。现在我们更详细地讨论这个限制。
- en: In Linux kernels before 2.6.9, only privileged processes (`CAP_IPC_LOCK`) can
    lock memory, and the `RLIMIT_MEMLOCK` soft resource limit places an upper limit
    on the number of bytes that a privileged process can lock.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.6.9 之前的 Linux 内核中，只有具有特权的进程（`CAP_IPC_LOCK`）可以锁定内存，而 `RLIMIT_MEMLOCK` 软资源限制对特权进程可以锁定的字节数设置了上限。
- en: 'Starting with Linux 2.6.9, changes to the memory locking model allow unprivileged
    processes to lock small amounts of memory. This is useful for an application that
    needs to place a small piece of sensitive information in locked memory in order
    to ensure that it is never written to the swap space on disk; for example, *gpg*
    does this with pass phrases. As a result of these changes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Linux 2.6.9 开始，内存锁定模型的变化允许非特权进程锁定少量内存。这对需要将少量敏感信息放入锁定内存中的应用程序非常有用，以确保这些信息永远不会写入磁盘的交换空间；例如，*gpg*
    就是这样处理密码短语的。由于这些变化：
- en: no limits are placed on the amount of memory that a privileged process can lock
    (i.e., `RLIMIT_MEMLOCK` is ignored); and
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于特权进程，可以锁定的内存量没有限制（即，`RLIMIT_MEMLOCK` 被忽略）；以及
- en: an unprivileged process is now able to lock memory up to the soft limit defined
    by `RLIMIT_MEMLOCK`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，普通进程也能锁定内存，直到由`RLIMIT_MEMLOCK`定义的软限制为止。
- en: The default value for both the soft and hard `RLIMIT_MEMLOCK` limits is 8 pages
    (i.e., 32,768 bytes on x86-32).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_MEMLOCK` 的软限制和硬限制的默认值都是 8 页（即 x86-32 上的 32,768 字节）。'
- en: 'The `RLIMIT_MEMLOCK` limit affects:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_MEMLOCK` 限制影响：'
- en: '*mlock()* and *mlockall()*;'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mlock()* 和 *mlockall()*；'
- en: the *mmap()* `MAP_LOCKED` flag, which is used to lock a memory mapping when
    it is created, as described in [Additional *mmap()* Flags](ch49.html#additional_mmap_open_parenthesis_close_p
    "Additional mmap() Flags"); and
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap()`函数的`MAP_LOCKED`标志用于在创建内存映射时锁定内存映射，如[附加的*mmap()*标志](ch49.html#additional_mmap_open_parenthesis_close_p
    "Additional mmap() Flags")中所述；'
- en: the *shmctl()* `SHM_LOCK` operation, which is used to lock System V shared memory
    segments, as described in Section 48.7.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*shmctl()* `SHM_LOCK` 操作，用于锁定 System V 共享内存段，如第 48.7 节所述。'
- en: Since virtual memory is managed in units of pages, memory locks apply to complete
    pages. When performing limit checks, the `RLIMIT_MEMLOCK` limit is rounded *down*
    to the nearest multiple of the system page size.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚拟内存是以页为单位进行管理的，因此内存锁定作用于整个页。在执行限制检查时，`RLIMIT_MEMLOCK` 限制会向下舍入到系统页大小的最接近倍数。
- en: 'Although this resource limit has a single (soft) value, in effect, it defines
    two separate limits:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个资源限制只有一个（软）值，但实际上它定义了两个独立的限制：
- en: For *mlock()*, *mlockall()*, and the *mmap()* `MAP_LOCKED` operation, `RLIMIT_MEMLOCK`
    defines a per-process limit on the number of bytes of its virtual address space
    that a process may lock.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *mlock()*、*mlockall()* 和 *mmap()* `MAP_LOCKED` 操作，`RLIMIT_MEMLOCK` 定义了每个进程的限制，限制了进程可以锁定的虚拟地址空间的字节数。
- en: For the *shmctl()* `SHM_LOCK` operation, `RLIMIT_MEMLOCK` defines a per-user
    limit on the number of bytes in shared memory segments that may be locked by the
    real user ID of this process. When a process performs a *shmctl()* `SHM_LOCK`
    operation, the kernel checks the total number of bytes of System V shared memory
    that are already recorded as being locked by the real user ID of the calling process.
    If the size of the to-be-locked segment would not push that total over the process’s
    `RLIMIT_MEMLOCK` limit, the operation succeeds.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *shmctl()* `SHM_LOCK` 操作，`RLIMIT_MEMLOCK` 定义了一个每用户限制，限制了该进程的实际用户 ID 可以锁定的共享内存段的字节数。当进程执行
    *shmctl()* `SHM_LOCK` 操作时，内核会检查该进程的实际用户 ID 已经锁定的 System V 共享内存的总字节数。如果要锁定的内存段大小不会使总量超过该进程的
    `RLIMIT_MEMLOCK` 限制，操作就会成功。
- en: The reason `RLIMIT_MEMLOCK` has different semantics for System V shared memory
    is that a shared memory segment can continue to exist even when it is not attached
    by any process. (It is removed only after an explicit *shmctl()* `IPC_RMID` operation,
    and then only after all processes have detached it from their address space.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_MEMLOCK` 对于 System V 共享内存具有不同语义的原因是，尽管没有任何进程附加到共享内存段，它仍然可以继续存在。（只有在执行显式的
    *shmctl()* `IPC_RMID` 操作后，且所有进程都已将其从地址空间中分离时，才会被移除。）'
- en: Locking and unlocking memory regions
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 锁定和解锁内存区域
- en: A process can use *mlock()* and *munlock()* to lock and unlock regions of memory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以使用 *mlock()* 和 *munlock()* 来锁定和解锁内存区域。
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时两者返回 0，错误时返回 -1
- en: 'The *mlock()* system call locks all of the pages of the calling process’s virtual
    address range starting at *addr* and continuing for *length* bytes. Unlike the
    corresponding argument passed to several other memory-related system calls, *addr*
    does not need to be page-aligned: the kernel locks pages starting at the next
    page boundary below *addr*. However, SUSv3 optionally allows an implementation
    to require that *addr* be a multiple of the system page size, and portable applications
    should ensure that this is so when calling *mlock()* and *munlock()*.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*mlock()* 系统调用会锁定从 *addr* 开始，长度为 *length* 字节的调用进程的虚拟地址范围的所有页面。与传递给其他几个内存相关系统调用的相应参数不同，*addr*
    不需要按页面对齐：内核从 *addr* 以下的下一个页面边界开始锁定页面。然而，SUSv3 允许实现选择性地要求 *addr* 是系统页面大小的倍数，因此便携式应用程序应确保在调用
    *mlock()* 和 *munlock()* 时满足此条件。'
- en: Because locking is done in units of whole pages, the end of the locked region
    is the next page boundary greater than *length* plus *addr*. For example, on a
    system where the page size is 4096 bytes, the call *mlock(2000, 4000)* will lock
    bytes 0 through to 8191.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于锁定是按整个页面单位进行的，因此被锁定区域的结束位置是大于 *length* 加 *addr* 的下一个页面边界。例如，在页面大小为 4096 字节的系统上，调用
    *mlock(2000, 4000)* 将锁定从字节 0 到 8191。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can find out how much memory a process currently has locked by inspecting
    the `VmLck` entry of the Linux-specific `/proc/`*PID*`/status` file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查 Linux 特定的 `/proc/`*PID*`/status` 文件中的 `VmLck` 条目来找出进程当前锁定了多少内存。
- en: After a successful *mlock()* call, all of the pages in the specified range are
    guaranteed to be locked and resident in physical memory. The *mlock()* system
    call fails if there is insufficient physical memory to lock all of the requested
    pages or if the request violates the `RLIMIT_MEMLOCK` soft resource limit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功调用 *mlock()* 后，指定范围内的所有页面保证被锁定并驻留在物理内存中。如果没有足够的物理内存来锁定所有请求的页面，或者请求违反了 `RLIMIT_MEMLOCK`
    软资源限制，*mlock()* 系统调用将失败。
- en: We show an example of the use of *mlock()* in [Example 50-2](ch50.html#using_mlock_open_parenthesis_close_paren
    "Example 50-2. Using mlock() and mincore()").
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [示例 50-2](ch50.html#using_mlock_open_parenthesis_close_paren "示例 50-2：使用
    mlock() 和 mincore()") 中展示了如何使用 *mlock()*。
- en: 'The *munlock()* system call performs the converse of *mlock()*, removing a
    memory lock previously established by the calling process. The *addr* and *length*
    arguments are interpreted in the same way as for *munlock()*. Unlocking a set
    of pages doesn’t guarantee that they cease to be memory-resident: pages are removed
    from RAM only in response to memory demands by other processes.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*munlock()* 系统调用执行 *mlock()* 的相反操作，移除调用进程先前建立的内存锁。*addr* 和 *length* 参数的解释方式与
    *mlock()* 相同。解锁一组页面并不能保证它们停止驻留在内存中：只有在其他进程的内存需求下，页面才会从 RAM 中移除。'
- en: 'Aside from the explicit use of *munlock()*, memory locks are automatically
    removed in the following circumstances:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显式使用 *munlock()*，在以下情况下内存锁定会自动移除：
- en: on process termination;
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进程终止时；
- en: if the locked pages are unmapped via *munmap()*; or
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果锁定的页面通过 *munmap()* 被解除映射；
- en: if the locked pages are overlaid using the *mmap()* `MAP_FIXED` flag.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被锁定的页面通过 *mmap()* 的 `MAP_FIXED` 标志被覆盖。
- en: Details of the semantics of memory locking
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内存锁定的语义细节
- en: In the following paragraphs, we note some details of the semantics of memory
    locks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，我们会说明一些内存锁定语义的细节。
- en: Memory locks are not inherited by a child created via *fork()*, and are not
    preserved across an *exec()*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 内存锁定不会被 *fork()* 创建的子进程继承，并且不会跨 *exec()* 保留。
- en: Where multiple processes share a set of pages (e.g., a `MAP_SHARED` mapping),
    these pages remain locked in memory as long as at least one of the processes holds
    a memory lock on the pages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个进程共享一组页面（例如，`MAP_SHARED` 映射）时，只要至少有一个进程对这些页面保持内存锁定，这些页面就会保持在内存中。
- en: Memory locks don’t nest for a single process. If a process repeatedly calls
    *mlock()* on a certain virtual address range, only one lock is established, and
    this lock will be removed by a single call to *munlock()*. On the other hand,
    if we use *mmap()* to map the same set of pages (i.e., the same file) at several
    different locations within a single process, and then lock each of these mappings,
    the pages remain locked in RAM until all of the mappings have been unlocked.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 内存锁定对于单个进程来说是不可嵌套的。如果一个进程在某个虚拟地址范围上重复调用 *mlock()*，则只会建立一个锁，并且这个锁会通过一次调用 *munlock()*
    被移除。另一方面，如果我们使用 *mmap()* 在同一个进程中将相同的一组页面（即相同的文件）映射到多个不同的位置，并且锁定每个映射，那么这些页面将在所有映射被解锁之前一直保持在内存中。
- en: 'The fact that memory locks are performed in units of pages and can’t be nested
    means that it isn’t logically correct to independently apply *mlock()* and *munlock()*
    calls to different data structures on the same virtual page. For example, suppose
    we have two data structures within the same virtual memory page pointed to by
    pointers *p1* and *p2*, and we make the following calls:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 内存锁定是按页面单位执行的，并且不能嵌套，这意味着独立地对同一虚拟页面上的不同数据结构应用 *mlock()* 和 *munlock()* 调用在逻辑上是不正确的。例如，假设我们在同一个虚拟内存页面中有两个数据结构，分别由指针
    *p1* 和 *p2* 指向，并且我们执行以下调用：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All of the above calls will succeed, but at the end of this sequence, the entire
    page is unlocked; that is, the data structure pointed to by *p2* is not locked
    into memory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述调用都会成功，但在这个序列的末尾，整个页面会被解锁；即，指向 *p2* 的数据结构不会被锁定在内存中。
- en: 'Note that the semantics of the *shmctl()* `SHM_LOCK` operation ([Shared Memory
    Control Operations](ch48.html#shared_memory_control_operations "Shared Memory
    Control Operations")) differ from those of *mlock()* and *mlockall()*, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*shmctl()* `SHM_LOCK` 操作（[共享内存控制操作](ch48.html#shared_memory_control_operations
    "共享内存控制操作")）的语义与 *mlock()* 和 *mlockall()* 不同，具体如下：
- en: After a `SHM_LOCK` operation, pages are locked into memory only as they are
    faulted in by subsequent references. By contrast, *mlock()* and *mlockall()* fault
    all of the locked pages into memory before the call returns.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行 `SHM_LOCK` 操作后，页面只有在被后续访问调入内存时才会被锁定。相比之下，*mlock()* 和 *mlockall()* 会在调用返回之前将所有锁定的页面调入内存。
- en: The `SHM_LOCK` operation sets a property of the shared memory segment, rather
    than the process. (For this reason, the value in the `/proc/`*PID*`/status VmLck`
    field doesn’t include the size of any attached System V shared memory segments
    that have been locked using `SHM_LOCK`.) This means that, once faulted into memory,
    the pages remain resident even if all processes detach the shared memory segment.
    By contrast, a region locked into memory using *mlock()* (or *mlockall()*) remains
    locked only as long as at least one process holds a lock on the region.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHM_LOCK` 操作设置的是共享内存段的属性，而不是进程的属性。（因此，`/proc/`*PID*`/status VmLck` 字段中的值不包括通过
    `SHM_LOCK` 锁定的任何附加的 System V 共享内存段的大小。）这意味着，一旦页面被调入内存，即使所有进程都分离了共享内存段，这些页面仍然会保持在内存中。相比之下，使用
    *mlock()*（或 *mlockall()*）将内存区域锁定后，只有在至少一个进程保持该区域的锁定时，该区域才会继续保持锁定状态。'
- en: Locking and unlocking all of a process’s memory
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 锁定和解锁一个进程的所有内存
- en: A process can use *mlockall()* and *munlockall()* to lock and unlock all of
    its memory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以使用 *mlockall()* 和 *munlockall()* 来锁定和解锁其所有内存。
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 两者在成功时返回 0，在出错时返回 -1
- en: 'The *mlockall()* system call locks all of the currently mapped pages in a process’s
    virtual address space, all of the pages mapped in the future, or both, according
    to the *flags* bit mask, which is specified by ORing together one or both of the
    following constants:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*mlockall()* 系统调用会根据通过按位“或”操作组合的以下常量之一或两者，锁定进程虚拟地址空间中当前映射的所有页面、未来映射的所有页面，或者两者：'
- en: '`MCL_CURRENT`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`MCL_CURRENT`'
- en: Lock all pages that are currently mapped into the calling process’s virtual
    address space. This includes all pages currently allocated for the program text,
    data segments, memory mappings, and the stack. After a successful call specifying
    the `MCL_CURRENT` flag, all of the pages of the calling process are guaranteed
    to be memory-resident. This flag doesn’t affect pages that are subsequently allocated
    in the process’s virtual address space; for this, we must use `MCL_FUTURE`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定当前映射到调用进程虚拟地址空间中的所有页面。这包括程序文本、数据段、内存映射和栈所分配的所有页面。在成功调用并指定 `MCL_CURRENT` 标志后，调用进程的所有页面都可以保证驻留在内存中。此标志不会影响后续分配的页面；对于此类页面，我们必须使用
    `MCL_FUTURE`。
- en: '`MCL_FUTURE`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`MCL_FUTURE`'
- en: Lock all pages subsequently mapped into the calling process’s virtual address
    space. Such pages may, for example, be part of a shared memory region mapped via
    *mmap()* or *shmat()*, or part of the upwardly growing heap or downwardly growing
    stack. As a consequence of specifying the `MCL_FUTURE` flag, a later memory allocation
    operation (e.g., *mmap()*, *sbrk()*, or *malloc()*) may fail, or stack growth
    may yield a `SIGSEGV` signal, if the system runs out of RAM to allocate to the
    process or the `RLIMIT_MEMLOCK` soft resource limit is encountered.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定所有随后映射到调用进程虚拟地址空间的页面。这些页面可以是通过 *mmap()* 或 *shmat()* 映射的共享内存区域的一部分，或者是向上增长的堆或向下增长的栈的一部分。由于指定了
    `MCL_FUTURE` 标志，后续的内存分配操作（例如 *mmap()*、*sbrk()* 或 *malloc()*) 可能会失败，或者栈增长可能会导致
    `SIGSEGV` 信号，如果系统内存不足以分配给进程，或者遇到 `RLIMIT_MEMLOCK` 的软资源限制。
- en: The same rules regarding the constraints, lifetime, and inheritance of memory
    locks created with *mlock()* also apply for memory locks created via *mlockall()*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *mlock()* 创建的内存锁的约束、生命周期和继承规则，同样适用于通过 *mlockall()* 创建的内存锁。
- en: The *munlockall()* system call unlocks all of the pages of the calling process
    and undoes the effect of any previous *mlockall(MCL_FUTURE)* call. As with *munlock()*,
    unlocked pages are not guaranteed to be removed from RAM by this call.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*munlockall()* 系统调用解锁调用进程的所有页面，并撤销任何先前的 *mlockall(MCL_FUTURE)* 调用的效果。与 *munlock()*
    一样，解锁的页面不能保证会被此调用从 RAM 中移除。'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before Linux 2.6.9, privilege (`CAP_IPC_LOCK`) was required to call *munlockall()*
    (inconsistently, privilege was not required for *munlock()*). Since Linux 2.6.9,
    privilege is no longer required.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.6.9 之前，调用 *munlockall()* 需要特权 (`CAP_IPC_LOCK`)，但 *munlock()* 在某些情况下不需要特权。自
    Linux 2.6.9 起，已不再需要特权。
- en: 'Determining Memory Residence: *mincore()*'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定内存驻留：*mincore()*
- en: The *mincore()* system call is the complement of the memory locking system calls.
    It reports which pages in a virtual address range are currently resident in RAM,
    and thus won’t cause a page fault if accessed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*mincore()* 系统调用是内存锁定系统调用的补充。它报告虚拟地址范围内哪些页面当前驻留在 RAM 中，因此如果访问这些页面不会导致页面错误。'
- en: SUSv3 doesn’t specify *mincore()*. It is available on many, but not all, UNIX
    implementations. On Linux, *mincore()* has been available since kernel 2.4.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 没有规范 *mincore()*。它在许多 UNIX 实现中可用，但并不是所有实现都支持。在 Linux 上，*mincore()* 从 2.4
    内核开始可用。
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: The *mincore()* system call returns memory-residence information about pages
    in the virtual address range starting at *addr* and running for *length* bytes.
    The address supplied in *addr* must be page-aligned, and, since information is
    returned about whole pages, *length* is effectively rounded up to the next multiple
    of the system page size.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*mincore()* 系统调用返回关于从 *addr* 开始、长度为 *length* 字节的虚拟地址范围内页面的内存驻留信息。提供的 *addr*
    地址必须是页面对齐的，并且由于返回的是整页信息，*length* 实际上会向上舍入到系统页面大小的下一个倍数。'
- en: Information about memory residency is returned in *vec*, which must be an array
    of *(length + PAGE_SIZE – 1) / PAGE_SIZE* bytes. (On Linux, *vec* has the type
    *unsigned char **; on some other UNIX implementations, *vec* has the type *char
    **.) The least significant bit of each byte is set if the corresponding page is
    memory-resident. The setting of the other bits is undefined on some UNIX implementations,
    so portable applications should test only this bit.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 内存驻留信息通过 *vec* 返回，*vec* 必须是一个大小为 *(length + PAGE_SIZE – 1) / PAGE_SIZE* 字节的数组。（在
    Linux 上，*vec* 的类型是 *unsigned char **；在其他一些 UNIX 实现中，*vec* 的类型是 *char **。）如果相应的页面驻留在内存中，则每个字节的最低有效位被设置。其他位的设置在某些
    UNIX 实现中是未定义的，因此可移植的应用程序应该只测试这一位。
- en: The information returned by *mincore()* can change between the time the call
    is made and the time the elements of *vec* are checked. The only pages guaranteed
    to remain memory-resident are those locked with *mlock()* or *mlockall()*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*mincore()*返回的信息可能在调用发生时与检查*vec*元素时之间有所变化。唯一保证始终驻留在内存中的页面是那些通过*mlock()*或*mlockall()*锁定的页面。'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Prior to Linux 2.6.21, various implementation problems meant that *mincore()*
    did not correctly report memory-residence information for `MAP_PRIVATE` mappings
    or for nonlinear mappings (established using *remap_file_pages()*).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux 2.6.21之前，存在一些实现问题，导致*mincore()*未能正确报告`MAP_PRIVATE`映射或非线性映射（通过*remap_file_pages()*建立）的内存驻留信息。
- en: '[Example 50-2](ch50.html#using_mlock_open_parenthesis_close_paren "Example 50-2. Using
    mlock() and mincore()") demonstrates the use of *mlock()* and *mincore()*. After
    allocating and mapping a region of memory using *mmap()*, this program uses *mlock()*
    to lock either the entire region or otherwise groups of pages at regular intervals.
    (Each of the command-line arguments to the program is expressed in terms of pages;
    the program converts these to bytes, as required for the calls to *mmap()*, *mlock()*,
    and *mincore()*.) Before and after the *mlock()* call, the program uses *mincore()*
    to retrieve information about the memory residency of pages in the region and
    displays this information graphically.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 50-2](ch50.html#using_mlock_open_parenthesis_close_paren "示例 50-2. 使用 mlock()
    和 mincore()")演示了*mlock()*和*mincore()*的使用。在使用*mmap()*分配和映射内存区域之后，该程序使用*mlock()*来锁定整个区域或定期锁定页面组。（程序的每个命令行参数以页面为单位表达；程序将这些参数转换为字节，以便用于调用*mmap()*、*mlock()*和*mincore()*。）在调用*mlock()*之前和之后，程序使用*mincore()*来获取关于该区域页面内存驻留状态的信息，并将这些信息以图形方式显示。'
- en: Example 50-2. Using *mlock()* and *mincore()*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 50-2. 使用*mlock()*和*mincore()*
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following shell session shows a sample run of the program in [Example 50-2](ch50.html#using_mlock_open_parenthesis_close_paren
    "Example 50-2. Using mlock() and mincore()"). In this example, we allocate 32
    pages, and in each group of 8 pages, we lock 3 consecutive pages:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell会话展示了[示例 50-2](ch50.html#using_mlock_open_parenthesis_close_paren "示例
    50-2. 使用 mlock() 和 mincore()")程序的示例运行。在这个示例中，我们分配了32个页面，并在每组8个页面中锁定3个连续的页面：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the program output, dots represent pages that are not resident in memory,
    and asterisks represent pages that are resident in memory. As we can see from
    the final line of output, 3 out of each group of 8 pages are memory-resident.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序输出中，点表示未驻留在内存中的页面，星号表示驻留在内存中的页面。从最后一行输出中可以看到，在每组8个页面中，有3个页面驻留在内存中。
- en: In this example, we assumed superuser privilege so that the program can use
    *mlock()*. This is not necessary in Linux 2.6.9 and later if the amount of memory
    to be locked falls within the `RLIMIT_MEMLOCK` soft resource limit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们假设拥有超级用户权限，以便程序可以使用*mlock()*。但在Linux 2.6.9及以后的版本中，如果要锁定的内存量在`RLIMIT_MEMLOCK`软资源限制范围内，则不需要此权限。
- en: 'Advising Future Memory Usage Patterns: *madvise()*'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建议未来的内存使用模式：*madvise()*
- en: The *madvise()* system call is used is to improve the performance of an application
    by informing the kernel about the calling process’s likely usage of the pages
    in the range starting at *addr* and continuing for *length* bytes. The kernel
    may use this information to improve the efficiency of I/O performed on the file
    mapping that underlies the pages. (See [File Mappings](ch49.html#file_mappings
    "File Mappings") for a discussion of file mappings.) On Linux, *madvise()* has
    been available since kernel 2.4.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*madvise()*系统调用的作用是通过告知内核调用进程在以*addr*为起始位置、持续*length*字节范围内的页面可能使用情况，从而提高应用程序的性能。内核可以利用这些信息来提高在文件映射上的I/O效率，该文件映射支撑着这些页面。（关于文件映射的讨论，请参见[文件映射](ch49.html#file_mappings
    "文件映射")。）在Linux中，*madvise()*自2.4版本内核起可用。'
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'The value specified in *addr* must be page-aligned, and *length* is effectively
    rounded up to the next multiple of the system page size. The *advice* argument
    is one of the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在*addr*中指定的值必须是页面对齐的，并且*length*实际上会向上舍入到系统页面大小的下一个倍数。*advice*参数是以下选项之一：
- en: '`MADV_NORMAL`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`MADV_NORMAL`'
- en: This is the default behavior. Pages are transferred in clusters (a small multiple
    of the system page size). This results in some read-ahead and read-behind.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认行为。页面以集群的形式传输（系统页面大小的小倍数）。这会导致一些预读和延迟读取。
- en: '`MADV_RANDOM`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`MADV_RANDOM`'
- en: Pages in this region will be accessed randomly, so read-ahead will yield no
    benefit. Thus, the kernel should fetch the minimum amount of data on each read.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该区域内的页面将被随机访问，因此预读取没有任何好处。因此，内核应在每次读取时获取最小量的数据。
- en: '`MADV_SEQUENTIAL`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`MADV_SEQUENTIAL`'
- en: Pages in this range will be accessed once, sequentially. Thus, the kernel can
    aggressively read ahead, and pages can be quickly freed after they have been accessed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该范围内的页面将按顺序访问一次。因此，内核可以积极地预读取，并且页面在访问后可以迅速被释放。
- en: '`MADV_WILLNEED`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`MADV_WILLNEED`'
- en: Read pages in this region ahead, in preparation for future access. The `MADV_WILLNEED`
    operation has an effect similar to the Linux-specific *readahead()* system call
    and the *posix_fadvise()* `POSIX_FADV_WILLNEED` operation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在该区域内预读取页面，为未来访问做准备。`MADV_WILLNEED` 操作的效果类似于 Linux 特有的 *readahead()* 系统调用和 *posix_fadvise()*
    中的 `POSIX_FADV_WILLNEED` 操作。
- en: '`MADV_DONTNEED`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`MADV_DONTNEED`'
- en: The calling process no longer requires the pages in this region to be memory-resident.
    The precise effect of this flag varies across UNIX implementations. We first note
    the behavior on Linux. For a `MAP_PRIVATE` region, the mapped pages are explicitly
    discarded, which means that modifications to the pages are lost. The virtual memory
    address range remains accessible, but the next access of each page will result
    in a page fault reinitializing the page, either with the contents of the file
    from which it is mapped or with zeros in the case of an anonymous mapping. This
    can be used as a means of explicitly reinitializing the contents of a `MAP_PRIVATE`
    region. For a `MAP_SHARED` region, the kernel *may* discard modified pages in
    some circumstances, depending on the architecture (this behavior doesn’t occur
    on x86). Some other UNIX implementations also behave in the same way as Linux.
    However, on some UNIX implementations, `MADV_DONTNEED` simply informs the kernel
    that the specified pages can be swapped out if necessary. Portable applications
    should not rely on the Linux’s destructive semantics for `MADV_DONTNEED`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 调用进程不再需要该区域中的页面驻留在内存中。此标志的具体效果在不同的 UNIX 实现中有所不同。我们首先注意到 Linux 上的行为。对于 `MAP_PRIVATE`
    区域，映射的页面会被显式丢弃，这意味着对页面的修改会丢失。虚拟内存地址范围仍然可以访问，但每次访问页面时都会触发页面错误，重新初始化页面，要么用其映射的文件内容，要么在匿名映射的情况下用零填充。这可以作为显式重新初始化
    `MAP_PRIVATE` 区域内容的一种方式。对于 `MAP_SHARED` 区域，内核在某些情况下*可能*会丢弃已修改的页面，具体取决于架构（在 x86
    上不会发生这种行为）。其他一些 UNIX 实现也表现得与 Linux 相同。然而，在某些 UNIX 实现中，`MADV_DONTNEED` 只是通知内核，如果有必要，指定的页面可以被换出。可移植的应用程序不应依赖于
    Linux 对 `MADV_DONTNEED` 的破坏性语义。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Linux 2.6.16 added three new nonstandard *advice* values: `MADV_DONTFORK`,
    `MADV_DOFORK`, and `MADV_REMOVE`. Linux 2.6.32 and 2.6.33 added another four nonstandard
    *advice* values: `MADV_HWPOISON`, `MADV_SOFT_OFFLINE`, `MADV_MERGEABLE`, and `MADV_UNMERGEABLE`.
    These values are used in special circumstances and are described in the *madvise(2)*
    manual page.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6.16 增加了三个新的非标准*建议*值：`MADV_DONTFORK`、`MADV_DOFORK` 和 `MADV_REMOVE`。Linux
    2.6.32 和 2.6.33 增加了另外四个非标准*建议*值：`MADV_HWPOISON`、`MADV_SOFT_OFFLINE`、`MADV_MERGEABLE`
    和 `MADV_UNMERGEABLE`。这些值在特殊情况下使用，并在 *madvise(2)* 手册页中进行了描述。
- en: Most UNIX implementations provide a version of *madvise()*, typically allowing
    at least the *advice* constants described above. However, SUSv3 standardizes this
    API under a different name, *posix_madvise()*, and prefixes the corresponding
    *advice* constants with the string `POSIX_`. Thus, the constants are `POSIX_MADV_NORMAL`,
    `POSIX_MADV_RANDOM`, `POSIX_MADV_SEQUENTIAL`, `POSIX_MADV_WILLNEED`, and `POSIX_MADV_DONTNEED`.
    This alternative interface is implemented in *glibc* (version 2.2 and later) by
    calls to *madvise()*, but it is not available on all UNIX implementations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 UNIX 实现提供了一个 *madvise()* 的版本，通常至少允许上述描述的 *建议* 常量。然而，SUSv3 将这个 API 标准化为一个不同的名称
    *posix_madvise()*，并将相应的 *建议* 常量的前缀加上 `POSIX_` 字符串。因此，这些常量为 `POSIX_MADV_NORMAL`、`POSIX_MADV_RANDOM`、`POSIX_MADV_SEQUENTIAL`、`POSIX_MADV_WILLNEED`
    和 `POSIX_MADV_DONTNEED`。这个替代接口在 *glibc*（版本 2.2 及更高版本）中通过调用 *madvise()* 实现，但并非所有
    UNIX 实现都支持。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 says that *posix_madvise()* should not affect the semantics of a program.
    However, in *glibc* versions before 2.7, the `POSIX_MADV_DONTNEED` operation is
    implemented using *madvise()* `MADV_DONTNEED`, which does affect the semantics
    of a program, as described earlier. Since *glibc* 2.7, the *posix_madvise()* wrapper
    implements `POSIX_MADV_DONTNEED` to do nothing, so that it does not affect the
    semantics of a program.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定 *posix_madvise()* 不应影响程序的语义。然而，在 *glibc* 2.7 之前的版本中，`POSIX_MADV_DONTNEED`
    操作是通过 *madvise()* `MADV_DONTNEED` 实现的，这会影响程序的语义，正如前文所述。从 *glibc* 2.7 开始，*posix_madvise()*
    封装函数实现 `POSIX_MADV_DONTNEED` 为不做任何操作，因此不会影响程序的语义。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we considered various operations that can be performed on
    a process’s virtual memory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了可以在进程的虚拟内存上执行的各种操作：
- en: The *mprotect()* system call changes the protection on a region of virtual memory.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mprotect()* 系统调用用于更改虚拟内存区域的保护状态。'
- en: The *mlock()* and *mlockall()* system calls lock part or all of a process’s
    virtual address space, respectively, into physical memory.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mlock()* 和 *mlockall()* 系统调用分别将进程的部分或全部虚拟地址空间锁定到物理内存中。'
- en: The *mincore()* system call reports which pages in a virtual memory region are
    currently resident in physical memory.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mincore()* 系统调用报告虚拟内存区域中哪些页面当前驻留在物理内存中。'
- en: The *madvise()* system call and the *posix_madvise()* function allow a process
    to advise the kernel about the process’s expected patterns of memory use.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*madvise()* 系统调用和 *posix_madvise()* 函数允许一个进程向内核建议该进程预计的内存使用模式。'
- en: Exercises
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Verify the effect of the `RLIMIT_MEMLOCK` resource limit by writing a program
    that sets a value for this limit and then attempts to lock more memory than the
    limit.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写一个程序来验证 `RLIMIT_MEMLOCK` 资源限制的效果，该程序设置此限制的值并尝试锁定超出限制的更多内存。
- en: Write a program to verify the operation of the *madvise()* `MADV_DONTNEED` operation
    for a writable `MAP_PRIVATE` mapping.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，验证 *madvise()* `MADV_DONTNEED` 操作在可写的 `MAP_PRIVATE` 映射中的运行效果。
