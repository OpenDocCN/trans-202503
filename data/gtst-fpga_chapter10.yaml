- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NUMBERS
    AND MATH</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">数字与数学</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Throughout this book, I’ve been saying that FPGAs are good at performing mathematical
    computations quickly. I’ve also been saying that FPGAs are good at doing tasks
    in parallel, and that the combination of these two assets—fast math done in parallel—is
    one of their killer features. In low-level Verilog or VHDL code, however, working
    with numbers and math is full of pitfalls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我一直在说 FPGAs 擅长快速执行数学运算。我还说过，FPGAs 擅长并行执行任务，而这两项优势——快速数学运算和并行处理——是它们的杀手级特性。然而，在低级
    Verilog 或 VHDL 代码中，处理数字和数学是充满陷阱的。
- en: In this chapter, we’ll explore exactly how FPGAs manage mathematical calculations
    so you can avoid those pitfalls. To understand the details of how operations like
    addition, subtraction, multiplication, and division work, we also need to understand
    how to represent numbers, both positive and negative, with or without decimals,
    inside your FPGA. It’s time for a journey in the wonderful world of computer arithmetic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 FPGAs 如何管理数学运算，以便你可以避免那些陷阱。要了解加法、减法、乘法和除法等运算的细节，我们还需要了解如何在 FPGA 内部表示数字，不论是正数还是负数，是否带小数。现在是时候进入计算机算术的奇妙世界了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Numerical Data Types</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">数值数据类型</samp>
- en: There are many ways to represent numbers in Verilog or VHDL, as is true with
    all programming languages. For example, if you want to store only whole numbers,
    you can use an integer data type, but if you need to store fractional numbers,
    you’ll need a data type that can represent decimals. Choosing the right type for
    the data you’re trying to represent is critical in any programming language. If
    you assign data to the wrong type, you’ll either get compiler errors or, worse,
    a design that behaves strangely. For example, trying to assign a decimal number
    to an integer data type could truncate the fractional component, causing an unintended
    rounding operation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Verilog 或 VHDL 中表示数字有许多方法，这一点与所有编程语言一样。例如，如果你只需要存储整数，可以使用整数数据类型，但如果需要存储小数，则需要使用可以表示小数的数据类型。在任何编程语言中，为数据选择正确的类型至关重要。如果将数据分配给错误的数据类型，你可能会遇到编译错误，或者更糟糕的是，设计出现奇怪的行为。例如，试图将小数赋值给整数数据类型，可能会截断小数部分，导致意外的四舍五入操作。
- en: Additionally, you don’t want to use more resources than necessary. For example,
    you could create every signal with a 64-bit-wide data type, but that’s clearly
    overkill if all you need is a counter that goes from 0 to 7\. FPGAs provide even
    more granular control over data types than you get with most other programming
    languages. For example, C has the <samp class="SANS_TheSansMonoCd_W5Regular_11">uint8_t</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">uint16_t</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>
    data types, which create data widths of 8, 16, and 32 bits, respectively, but
    there’s nothing in between. In Verilog and VHDL, by contrast, you can create a
    signal that’s 9 bits wide, 15 bits wide, 23 bits wide, or any other number. We’ll
    explore recommendations for sizing signals later in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还不想使用超过必要的资源。例如，你可以使用 64 位宽的数据类型来创建每个信号，但如果你只需要一个从 0 到 7 的计数器，显然这是一种过度设计。与大多数其他编程语言相比，FPGAs
    对数据类型的控制更加精细。例如，C 语言有 <samp class="SANS_TheSansMonoCd_W5Regular_11">uint8_t</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">uint16_t</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>
    数据类型，它们分别创建 8 位、16 位和 32 位的数据宽度，但没有中间值。相比之下，在 Verilog 和 VHDL 中，你可以创建 9 位、15 位、23
    位宽的信号，或者任何其他位宽。本章后面我们将探讨信号尺寸的建议。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Representing Signed
    vs. Unsigned Values</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">表示有符号与无符号值</samp>
- en: 'When you’re working with numbers, you need to know if they’re positive or negative.
    Sometimes, such as if you’re counting clock cycles to keep track of time, you’ll
    know the values will all be positive. In this case, you can store the numbers
    using an *unsigned* data type; the sign (positive or negative) isn’t specified
    and is assumed to be positive. Other times, you’ll need to work with negative
    numbers: for example, when you’re reading temperature values, where the sign of
    the numbers might vary. In these cases you’ll need to use a *signed* data type,
    where the positive or negative sign is specified.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理数字时，需要知道它们是正数还是负数。有时候，比如当你计数时钟周期以跟踪时间，你会知道这些值都是正数。在这种情况下，你可以使用 *无符号* 数据类型来存储数字；符号（正数或负数）没有指定，默认假设为正数。其他时候，你需要处理负数：例如，当你读取温度值时，数字的符号可能会变化。在这些情况下，你需要使用
    *有符号* 数据类型，其中符号（正数或负数）是明确指定的。
- en: 'By default, signals in Verilog and VHDL are unsigned. For example, if we need
    a counter that counts from 0 to 7, we can declare a signal like <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    [2:0] counter;</samp> in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    counter : std_logic_vector(2 downto 0);</samp> in VHDL. We’ve used code like this
    throughout the book. It will create a 3-bit register, and since it’s unsigned
    by default, the values on the register will all be interpreted as positive. If
    we want <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> to represent
    negative numbers as well as positive ones, we’d have to explicitly declare it
    to be signed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    keyword. In Verilog we would write <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    signed [2:0] counter;</samp>, and in VHDL we would use <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    counter : signed(2 downto 0);</samp>.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，Verilog 和 VHDL 中的信号是无符号的。例如，如果我们需要一个从 0 到 7 的计数器，我们可以在 Verilog 中声明一个信号，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reg [2:0] counter;</samp>，或者在 VHDL
    中声明为 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal counter : std_logic_vector(2
    downto 0);</samp>。我们在整本书中都使用了这样的代码。它会创建一个 3 位寄存器，且由于默认是无符号的，寄存器中的值将全部解释为正数。如果我们希望
    <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> 能表示负数和正数，我们必须显式声明它为有符号，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> 关键字。在 Verilog 中，我们会写成
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reg signed [2:0] counter;</samp>，在
    VHDL 中，我们会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal counter : signed(2
    downto 0);</samp>。'
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*To access the signed keyword in VHDL, you need to use the numeric_std package,
    which you can do by adding the line use ieee.numeric_std.all; at the top of your
    file. You may see some code that uses the std_logic_arith package instead, but
    this isn’t an official IEEE-supported library and I don’t recommend using it.
    It’s easier to make mistakes with this package than with numeric_std.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*要在 VHDL 中访问 signed 关键字，你需要使用 numeric_std 包，可以通过在文件顶部添加一行 use ieee.numeric_std.all;
    来实现。你可能会看到一些代码使用了 std_logic_arith 包，但这不是一个官方的 IEEE 支持库，我不推荐使用它。使用这个包比使用 numeric_std
    容易出错。*'
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> keyword
    explicitly tells the tools that this 3-bit-wide register can represent negative
    and positive values. But which values can we actually represent with it? [Table
    10-1](#tab10-1) compares the values represented by a 3-bit unsigned register and
    a 3-bit signed register. (We’ll discuss how to determine the signed values in
    the next section.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> 关键字明确告诉工具，这个
    3 位宽的寄存器可以表示负数和正数。但是我们实际能用它表示哪些值呢？[表 10-1](#tab10-1) 比较了 3 位无符号寄存器和 3 位有符号寄存器表示的值。（我们将在下一节讨论如何确定有符号值。）
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp> <samp class="SANS_Futura_Std_Book_11">3-Bit
    Unsigned vs. Signed Decimal Values</samp>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-1：</samp> <samp class="SANS_Futura_Std_Book_11">3
    位无符号与有符号十进制值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned
    decimal value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signed decimal
    value</samp> |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">位</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">无符号十进制值</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">有符号十进制值</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">–4</samp> |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">–4</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">–3</samp> |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">–3</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2</samp> |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1</samp> |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1</samp> |'
- en: Notice that when a register is declared as signed, we lose some numbers on the
    positive end of the range (4, 5, 6, and 7 in this case) but gain some numbers
    on the negative end (–1, –2, –3, and –4). The range of numbers that can be represented
    by an unsigned register is 0 to 2*^N* − 1, where *N* is the number of bits available.
    For this 3-bit register, we can represent from 0 to 2³ − 1 = 7 if the register
    is unsigned. On the other hand, the range of numbers that can be represented by
    a signed register is –2^(*^N*^(–1)) to 2^(*^N*^(–1)) − 1\. In this case, that
    gives us –2^((3–1)) to 2^((3–1)) − 1, or = –4 to 3\. The data is still 3 bits
    of binary data, but *what that binary data represents* is different.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当一个寄存器被声明为带符号时，我们会失去一些正数范围内的数字（在这个例子中是4, 5, 6和7），但会在负数范围内获得一些数字（–1, –2,
    –3和–4）。无符号寄存器能够表示的数字范围是0到2*^N* − 1，其中*N*是可用的位数。对于这个3位寄存器，如果寄存器是无符号的，我们可以表示从0到2³
    − 1 = 7。另一方面，带符号寄存器能够表示的数字范围是 –2^(*^N*^(–1)) 到 2^(*^N*^(–1)) − 1。在这种情况下，它给我们的范围是
    –2^((3–1)) 到 2^((3–1)) − 1，即 –4 到 3。数据仍然是3位的二进制数据，但*这些二进制数据表示的内容*是不同的。
- en: Another feature to notice in [Table 10-1](#tab10-1) is that the values that
    are negative all have a 1 in the most significant bit position. In fact, the most
    significant bit in a signed number is the *sign bit*, which indicates whether
    the number being represented is positive or negative. For signed binary numbers,
    a 0 in the sign bit tells you that the number is positive, while a 1 in the sign
    bit tells you that the number is negative.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的特点是在[表10-1](#tab10-1)中，所有负值的最高有效位都为1。实际上，在带符号的数值中，最高有效位是*符号位*，它表示所表示的数字是正数还是负数。对于带符号的二进制数，符号位为0表示数字是正数，而符号位为1表示数字是负数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Taking the Two’s
    Complement</samp>
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">求二的补码</samp>
- en: How do you know what decimal value a negatively signed binary number is supposed
    to represent? You take its *two’s complement*, a mathematical operation where
    you invert the number’s bits and then add 1\. For example, take the binary number
    <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>. If this were an unsigned
    number, we’d interpret it as 5 in decimal, but if it’s a signed number, the 1
    in the sign bit tells us that the represented value should be negative, so we
    have to take the two’s complement. First, we invert <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>,
    which gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>. Then
    we add 1, giving us <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>,
    which is 3 in decimal. Finally, we apply the negative sign to get –3\. Look back
    at [Table 10-1](#tab10-1) and you’ll see that’s what we have in the row for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">101</samp>.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如何知道一个带负号的二进制数应该表示什么十进制值呢？你需要进行*二补数*运算，这是一种数学操作，其中你将数值的位反转，然后加 1。例如，考虑二进制数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">101</samp>。如果它是无符号数，我们会将其解释为十进制的 5，但如果它是有符号数，那么符号位上的
    1 告诉我们，表示的值应该是负数，因此我们必须进行二补数运算。首先，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>的位反转，得到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">010</samp>。然后加 1，得到<samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>，它在十进制中是
    3。最后，我们加上负号得到 –3。回到[表 10-1](#tab10-1)，你会看到在<samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>这一行就是这个结果。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*An alternative to the invert-and-add-one method is to start at the right-most
    (least significant) bit, move left until you get to the first 1, then invert all
    the remaining bits to the left of that 1\. For example, 100010 100 becomes 011101
    100\. The three bolded bits, up to and including the first 1 from the right, remain
    the same, while the others are inverted. In decimal, 011101100 is 236; applying
    the negative sign, we know that 100010100 represents –236\. This method avoids
    the need for addition and can be simpler for long numbers.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*反转加一法的替代方法是，从最右边（最低有效）位开始，向左移动，直到遇到第一个 1，然后将这个 1 左边的所有位反转。例如，100010 100 变成
    011101 100。三个加粗的位，直到并包括右边第一个 1，保持不变，而其他位则反转。十进制中，011101100 是 236；加上负号后，我们知道 100010100
    表示 –236。这个方法避免了加法操作，对于长数字可能更简单。*'
- en: We can also take a two’s complement to go in the other direction, converting
    a negative decimal number into its signed binary representation. For example,
    how would we represent –1 in binary using 3 bits? First, strip away the negative
    sign to get 1, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    in binary. Then invert the bits to get <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp>,
    and add 1 to get <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>. Again,
    check [Table 10-1](#tab10-1) and you’ll see that this is the correct result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以反向进行二补数运算，将一个负的十进制数转换为其带符号的二进制表示。例如，如何用 3 位二进制表示 –1 呢？首先，去掉负号得到 1，它的二进制表示是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">001</samp>。然后反转位，得到<samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp>，再加
    1，得到<samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>。同样，查看[表 10-1](#tab10-1)，你会发现这是正确的结果。
- en: Taking the two’s complement is a useful trick us humans can use to better understand
    how to interpret signed numbers, but this invert-and-add-one logic *isn’t something
    an FPGA actually does* when working with negative values. The data is binary 1s
    and 0s whether a number is signed or unsigned. It’s just the *representation*
    of those 1s and 0s that makes a difference. When you have a 3-bit unsigned signal
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>, that represents
    the decimal value 5\. When you have a 3-bit signed signal set to <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>,
    that represents the decimal value –3\. The FPGA doesn’t have to invert and add
    bits anywhere to know that. It just needs to know that the signal is of a signed
    data type. This is an important point and will become clearer as we explore mathematical
    operations in binary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 取二进制补码是我们人类用来更好理解如何解释有符号数字的一个有用技巧，但这种“反转并加一”的逻辑*并不是FPGA在处理负值时实际执行的操作*。无论一个数字是有符号还是无符号，数据都是二进制的1和0。不同之处在于这些1和0的*表示方式*。当你有一个3位无符号信号，设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">101</samp>时，它表示十进制值5。当你有一个3位有符号信号，设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">101</samp>时，它表示十进制值-3。FPGA并不需要反转并加上位来知道这一点。它只需要知道该信号是有符号数据类型。这是一个重要的点，随着我们在二进制中探索数学运算，这一点会更加清晰。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sizing Signals Appropriately</samp>
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">正确地调整信号大小</samp>
- en: When you write Verilog or VHDL code working with signed and unsigned data types,
    you must ensure that you properly size the signals you’re creating. If you try
    to store too large of a number in too small of a signal, you’ll get data loss.
    As we just discussed, for example, the value of a 3-bit unsigned counter maxes
    out at 7\. If you try to increment it again from 7, it won’t go to 8; it’ll actually
    go back to 0\. This is sometimes called *wraparound*, and if you’re not expecting
    it, you’ll end up losing count. As you’ll see later in the chapter, ensuring your
    signals are large enough to handle your data is particularly important when the
    signals are for holding the results of mathematical operations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写处理有符号和无符号数据类型的Verilog或VHDL代码时，必须确保你创建的信号大小正确。如果你试图将一个过大的数字存储到一个过小的信号中，你将会丢失数据。如我们刚才讨论的那样，例如，一个3位无符号计数器的最大值是7。如果你尝试从7开始递增，它不会变成8；实际上，它会回到0。这有时被称为*回绕*，如果你没有预料到这一点，你可能会丢失计数。如本章后面所述，确保信号足够大以容纳你的数据，在信号用来保存数学运算结果时尤其重要。
- en: 'To avoid data loss you might be tempted to make all your signals larger than
    they need to be, but there’s a downside to this, too: you’ll end up using more
    of your FPGA’s precious resources than are needed. This may be less of a problem
    than you think, though. If the synthesis tools are smart enough, they might detect
    that your possible range of values is smaller than the signal you’ve created and
    remove the upper bits that are unused to conserve resources. If the tools did
    this to our <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> register,
    for example, we’d see a warning saying something like <samp class="SANS_TheSansMonoCd_W5Regular_11">Pruning
    register counter</samp> in the synthesis report. Getting a warning like this isn’t
    usually a problem, but it might indicate code you could revisit and size differently.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免数据丢失，你可能会倾向于将所有信号做得比实际需要的更大，但这样做也有一个弊端：你将使用更多FPGA宝贵的资源，这比实际需要的要多。然而，这个问题可能没有你想象的那么严重。如果综合工具足够智能，它们可能会检测到你的值的可能范围小于你创建的信号，并去除未使用的高位，以节省资源。例如，如果工具对我们的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>寄存器进行优化，我们会在综合报告中看到类似<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pruning register counter</samp>的警告。通常，收到这样的警告不是问题，但它可能表明你可以重新检查代码，并调整信号的大小。
- en: As a rule of thumb, you should aim to size your signals to the values you expect
    them to store, but know that making them too large is a much better solution than
    making them too small. Of course, you have to remember that the maximum value
    you can represent with a given number of bits varies depending on whether the
    values are signed or unsigned. For comparison, [Table 10-2](#tab10-2) summarizes
    the ranges of possible unsigned and signed values you can represent using between
    2 and 8 bits.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，你应该根据信号预期存储的值来选择大小，但要知道，设置信号大小过大比设置过小要更好。当然，你还需要记住，使用给定的位数表示的最大值会根据是否为有符号或无符号值而有所不同。为了进行对比，[表
    10-2](#tab10-2)总结了你可以使用 2 到 8 位表示的无符号和有符号值的范围。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-2:</samp> <samp class="SANS_Futura_Std_Book_11">N-bit
    Sizing for Unsigned and Signed Data Types</samp>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-2:</samp> <samp class="SANS_Futura_Std_Book_11">无符号和有符号数据类型的
    N 位大小</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Width</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Min integer</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Min
    binary</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Max integer</samp> |
    <samp class="SANS_Futura_Std_Heavy_B_11">Max binary</samp> |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">宽度</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">类型</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">最小整数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">最小二进制</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">最大整数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">最大二进制</samp>
    |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00000</samp>
    | <samp class="SANS_Futura_Std_Book_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00000</samp>
    | <samp class="SANS_Futura_Std_Book_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–16</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10000</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01111</samp>
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–16</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10000</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">111111</samp>
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">111111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–32</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100000</samp>
    | <samp class="SANS_Futura_Std_Book_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011111</samp>
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–32</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100000</samp>
    | <samp class="SANS_Futura_Std_Book_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">127</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1111111</samp>
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">127</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1111111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–64</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0111111</samp>
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–64</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0111111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">255</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11111111</samp>
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">255</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11111111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–128</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">127</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01111111</samp>
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–128</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">127</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01111111</samp>
    |'
- en: Starting at a width of 2 bits, we can represent the numbers 0 to 3 unsigned,
    or –2 to 1 signed. At a width of 8 bits, we can represent 0 to 255 unsigned, or
    –128 to 127 signed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2 位宽开始，我们可以表示 0 到 3 的无符号数，或者 –2 到 1 的有符号数。在 8 位宽时，我们可以表示 0 到 255 的无符号数，或者
    –128 到 127 的有符号数。
- en: 'One way to bypass the sizing dilemma is to size your signals dynamically, instead
    of setting them to a fixed width. We’ve seen some examples of this throughout
    the book. For instance, if you need to index into something 32 words deep but
    that depth could change in the future, you could write something like <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    [$clog2(DEPTH)-1:0] index;</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    [4:0] index;</samp> in Verilog, or <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    index : integer range 0 to DEPTH-1;</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    index : std_logic_vector(4 downto 0);</samp> in VHDL. Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>
    is a parameter/generic that can be changed on the fly. Using it will generate
    a signal of the exact bit width you need, wide enough to index into all possible
    values from <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH-1</samp>,
    with no extra headroom. In this case, you would set <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>, but if your indexing
    requirement were to grow to some larger value (say 1,024), the code won’t break;
    all you’ll have to do is change <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>.
    By contrast, if you arbitrarily say that <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    will be fixed to 8 bits wide (which has a maximum value of 255, as you can see
    in [Table 10-2](#tab10-2)), then your code might break in the future if your requirements
    grow beyond that range.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '绕过大小问题的一种方法是动态地调整信号的大小，而不是将其设置为固定宽度。我们在本书中已经看过一些这样的示例。例如，如果你需要索引到深度为 32 的某个东西，但该深度可能会在未来发生变化，你可以在
    Verilog 中编写类似 <samp class="SANS_TheSansMonoCd_W5Regular_11">reg [$clog2(DEPTH)-1:0]
    index;</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">reg [4:0] index;</samp>，或者在
    VHDL 中编写 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal index : integer
    range 0 to DEPTH-1;</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    index : std_logic_vector(4 downto 0);</samp>。这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>
    是一个可以动态更改的参数/泛型。使用它将生成一个精确的比特宽度信号，足以索引从 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH-1</samp> 的所有可能值，不会有多余的空余空间。在这种情况下，你可以将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>，但如果你的索引需求增长到更大的值（例如
    1,024），代码也不会崩溃；你只需要更改 <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>。相比之下，如果你随意地说
    <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> 会被固定为 8 位宽（最大值为 255，如你在
    [表 10-2](#tab10-2) 中看到的那样），那么如果你的需求超出该范围，代码可能会在未来崩溃。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between
    Types in VHDL</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">VHDL 中类型转换</samp>
- en: VHDL has many numeric data types, including <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>, where binary
    values are interpreted as positive or negative decimal numbers; <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>,
    where you can type numbers directly into the code; and <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>,
    where by default binary values aren’t interpreted as anything other than binary
    values. Because VHDL is strongly typed, you’ll often need to convert between these
    different data types when you’re working with numbers. Before we do any math,
    let’s look at some examples of how to implement common VHDL type conversions using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp> package (not
    the unofficial <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_arith</samp>).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: VHDL 有许多数字数据类型，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>，其中二进制值被解释为正数或负数的十进制数；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>，可以直接在代码中输入数字；以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>，其中默认情况下二进制值不会被解释为除二进制值以外的任何内容。由于
    VHDL 是强类型语言，在处理数字时，通常需要在这些不同的数据类型之间进行转换。在进行任何数学运算之前，我们先看一些如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp>
    包（而不是非官方的 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_arith</samp>）实现常见
    VHDL 类型转换的示例。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Verilog users don’t need to worry about performing these conversions, since
    Verilog is loosely typed. VHDL users should consult this section as needed for
    reference.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*Verilog 用户无需担心执行这些转换，因为 Verilog 是弱类型语言。VHDL 用户应根据需要参考本节内容。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">From Unsigned or Signed to
    Integer</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">从无符号或有符号到整数</samp>
- en: 'This example illustrates how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> type to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> type. For simplicity, we’re
    assuming the signals are all 4 bits wide, but the conversion will work for any
    bit width:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例说明了如何将无符号或有符号类型转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    类型。为了简化起见，我们假设所有信号都是 4 位宽，但这种转换适用于任何位宽：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For these conversions, all we need to do is call the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp>
    function from the <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp>
    package. We already know the width and the sign of the input, so the output will
    be sized automatically. This works whether the input is unsigned (as with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in1</samp>) or signed (as with <samp class="SANS_TheSansMonoCd_W5Regular_11">in2</samp>).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些转换，我们只需要调用来自 <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp>
    包的 <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp> 函数。我们已经知道输入的宽度和符号，因此输出会自动调整大小。无论输入是无符号（如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in1</samp>）还是有符号（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">in2</samp>），该方法都适用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">From Integer to Unsigned,
    Signed, or std_logic_vector</samp>
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">从整数到无符号、有符号或 std_logic_vector</samp>
- en: 'This example shows how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    type to one of the other types. Again, we’re assuming 4-bit signals:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何将 <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> 类型转换为其他类型。再次说明，我们假设信号为
    4 位：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_unsigned()</samp>
    ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">to_signed()</samp> ❷ functions
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp> to convert
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    type. In addition to the value to be converted, these functions require the width
    of the output signal as an argument. Rather than entering the width manually,
    we get it by applying <samp class="SANS_TheSansMonoCd_W5Regular_11">'length</samp>,
    a VHDL attribute, to the output signal. This keeps the code flexible; if the width
    changes, the conversion code doesn’t have to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">to_unsigned()</samp>
    ❶ 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">to_signed()</samp> ❷ 函数，来自 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp>，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    类型。除了要转换的值外，这些函数还需要输出信号的宽度作为参数。我们通过应用 VHDL 属性 <samp class="SANS_TheSansMonoCd_W5Regular_11">'length</samp>
    获取宽度，而不是手动输入。这样可以保持代码的灵活性；如果宽度发生变化，转换代码不需要做任何更改。
- en: To get to <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>,
    we have to convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> if the integer
    is positive ❸, or to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    if the integer is negative ❹. Then, once we have an unsigned or signed value of
    the proper width, we cast it using <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector()</samp>.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>，我们必须将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>（如果整数是正数
    ❸），或者转为 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>（如果整数是负数 ❹）。然后，一旦我们获得了具有适当宽度的无符号或有符号值，我们就可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector()</samp> 进行类型转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">From std_logic_vector to Unsigned,
    Signed, or Integer</samp>
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">从 std_logic_vector 到无符号、有符号或整数</samp>
- en: 'Finally, here’s how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>
    type to one of the other numeric types:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是如何将 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>
    类型转换为其他数字类型的示例：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To get to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> ❶ or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> ❷, we use a simple
    cast. However, VHDL needs to know if the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>
    is unsigned or signed before converting to the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    type. We perform the appropriate cast using <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned()</samp>
    ❸ or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp> ❹, then call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp> function
    to do the final conversion.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> ❶ 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> ❷，我们使用一个简单的类型转换。然而，VHDL
    需要知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp> 是无符号的还是有符号的，才能转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> 类型。我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned()</samp>
    ❸ 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp> ❹ 来执行适当的转换，然后调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp> 函数进行最终转换。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Performing Mathematical Operations</samp>
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">执行数学运算</samp>
- en: Now we’ll consider how basic addition, subtraction, multiplication, and division
    operations are performed within an FPGA, and how to implement them in Verilog
    and VHDL. I’ll suggest some rules that, if followed, will help you avoid many
    of the commit pitfalls when working with binary math. The best way to explore
    these concepts is through examples. To that end, we’ll create a large testbench
    that you can run in a simulator tool like EDA Playground. The testbench will execute
    dozens of different math equations, illustrating how binary math operations should
    be carried out and how they can go awry.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将考虑在 FPGA 中如何执行基本的加法、减法、乘法和除法操作，以及如何在 Verilog 和 VHDL 中实现它们。我将建议一些规则，如果遵循这些规则，将帮助你避免在进行二进制数学运算时出现许多常见的陷阱。探索这些概念的最佳方法是通过示例。为此，我们将创建一个大型测试平台，你可以在像
    EDA Playground 这样的仿真工具中运行它。该测试平台将执行数十个不同的数学方程，展示二进制数学运算应该如何进行，以及它们如何出错。
- en: In general, when working with numbers and manipulating them with algebraic operations,
    testbenches are a very powerful tool. Hidden math issues in your code can manifest
    themselves in strange ways. Testbenches allow you to stress your design by running
    through a large range of possible inputs, to see how the code works. I find it
    valuable to inject data into my testbenches that stress the math operations over
    a wide range of values, including minimum and maximum inputs. This helps ensure
    a design is robust.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在处理数字并进行代数运算时，测试平台是一个非常强大的工具。代码中隐藏的数学问题可能以奇怪的方式表现出来。测试平台通过运行大量不同的输入来加大设计的压力，从而查看代码的工作情况。我发现，在我的测试平台中注入数据，尤其是那些对数学运算施加压力的值，包括最小和最大输入，是非常有价值的。这有助于确保设计的稳健性。
- en: 'Before we do any math, let’s set up our testbench, called <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>,
    by declaring all the necessary inputs and outputs, as well as some helper functions
    in the VHDL version. This setup code provides the skeleton for the examples that
    follow throughout the rest of the chapter. The code for each example will go where
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">--</samp> is shown in the setup code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何数学运算之前，让我们通过在 VHDL 版本中声明所有必要的输入和输出，以及一些辅助函数，来设置我们的测试平台，名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>。这段设置代码为接下来整个章节中的示例提供了框架。每个示例的代码将放置在设置代码中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">--</samp> 位置：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The skeleton for this testbench sets up a single <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> (in
    VHDL) block that runs once through. We’ll fill in this block with examples later
    in the chapter. Notice that we’ve declared a number of signals using <samp class="SANS_TheSansMonoCd_W5Regular_11">reg</samp>
    (in Verilog) and <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp>
    (in VHDL). This is the first time we’ve seen the <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp>
    keyword in VHDL: we need it so we can write blocking assignment statements in
    the testbench. See “Blocking vs. Non-Blocking Assignments” on page 214 for more
    information.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试平台的骨架设置了一个单独的 <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>（在
    Verilog 中）或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>（在 VHDL
    中）块，该块只运行一次。我们将在本章后面用示例填充这个块。请注意，我们已经使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">reg</samp>（在
    Verilog 中）和 <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp>（在 VHDL
    中）声明了一些信号。这是我们第一次在 VHDL 中看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp>
    关键字：我们需要它以便在测试平台中编写阻塞赋值语句。有关更多信息，请参见第 214 页的“阻塞与非阻塞赋值”。
- en: The examples in this chapter use a common naming scheme to quickly identify
    the data types and widths of the signals so you don’t have to keep looking back
    at the signal definitions. The prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    indicates an input to a math equation, while <samp class="SANS_TheSansMonoCd_W5Regular_11">o</samp>
    indicates an output, the result of the math equation. In addition, we have the
    suffixes <samp class="SANS_TheSansMonoCd_W5Regular_11">_u</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">_s</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> represents unsigned,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> represents signed, and
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> represents the
    bit width of the signal. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_s4</samp>
    is a 4-bit-wide signed output. Establishing a scheme like this that makes it easier
    to remember data types and widths can be very helpful in your code, especially
    if there are many values in a single file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例使用了一种通用的命名规则，以便快速识别信号的数据类型和宽度，这样你就不必不断回头查看信号定义。前缀 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    表示数学方程的输入，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">o</samp> 表示输出，即数学方程的结果。此外，我们有后缀
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_u</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">_s</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>，其中
    <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> 代表无符号，<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    代表有符号，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> 代表信号的位宽。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_s4</samp> 是一个 4 位宽的有符号输出。建立像这样的命名方案，可以帮助你更容易地记住数据类型和宽度，尤其是当一个文件中有很多值时，这对你的代码非常有帮助。
- en: Notice in the VHDL that we declare a custom function, <samp class="SANS_TheSansMonoCd_W5Regular_11">str()</samp>,
    to help convert the outputs of our equations to strings for printing. This will
    save us a lot of typing in the examples later on. We actually define the function
    in three different ways, depending on the data type involved—because VHDL is strongly
    typed, we need to define all the supported function inputs so that the compiler
    knows which one to use. The first definition ❶ converts an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    value, the second ❷ converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    value, and the third ❸ converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">real</samp>
    value. This is an example of function *overloading*, a programming technique where
    a single function can have multiple implementations. Overloading is a somewhat
    advanced VHDL concept, but it’s very useful. You can even overload normal VHDL
    operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp> with any implementation that
    you need, though I don’t recommend doing so.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 VHDL 中，我们声明了一个自定义函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">str()</samp>，用于将我们方程的输出转换为字符串以便打印。这将大大减少我们在后续示例中输入的工作量。我们实际上根据数据类型定义了三种不同的函数，因为
    VHDL 是强类型语言，我们需要定义所有支持的函数输入，以便编译器知道使用哪个版本。第一个定义 ❶ 转换一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    值，第二个 ❷ 转换一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> 值，第三个
    ❸ 转换一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">real</samp> 值。这是函数 *重载* 的一个例子，重载是一个编程技巧，允许一个函数有多个实现。重载是一个相对高级的
    VHDL 概念，但它非常有用。你甚至可以重载普通的 VHDL 运算符，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>，使用任何你需要的实现，尽管我并不建议这样做。
- en: Now that we have our testbench set up, we’re ready to start exploring math operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了测试平台，准备开始探索数学运算。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Addition</samp>
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加法</samp>
- en: 'Adding binary data works the same way you were taught to add numbers in elementary
    school: you add them one digit at a time, working from right to left. For example,
    here’s how to add the binary numbers <samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 加法二进制数据的方式与小学时教你加法的方式相同：逐位相加，从右向左。例如，以下是如何加法两个二进制数<samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To arrive at the result, you simply go digit by digit, starting with the least
    significant bit, adding the digits in that column together. If you get 1 + 1 =
    10 in a column, then you write 0 at the bottom of the column and carry the 1 to
    the next digit to the left.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要得出结果，你只需要逐位相加，从最低有效位开始，将该列的数字相加。如果在某一列中得到 1 + 1 = 10，那么你在该列的底部写下 0，并将 1 进位到左边的下一位。
- en: 'Notice that the result of adding two 4-bit numbers together is 5 bits wide.
    This is our first rule of FPGA math:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将两个 4 位数相加后的结果是 5 位宽。这是 FPGA 数学的第一个规则：
- en: '**Rule #1** When adding, the result should be at least 1 bit bigger than the
    biggest input.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #1** 在加法时，结果的位数应至少比最大输入大 1 位。'
- en: 'The extra bit is needed in the case where adding the most significant bit requires
    a carry operation. Without the extra bit, we’d be truncating the result, which
    could produce an incorrect answer. In our first example, dropping the most significant
    bit wouldn’t make a difference, but consider this example where having that extra
    bit is critical:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当加法的最高有效位需要进位操作时，额外的位是必要的。如果没有这个额外的位，我们就会截断结果，可能会得到错误的答案。在第一个例子中，丢弃最高有效位并不会产生问题，但考虑这个例子，拥有额外的位是至关重要的：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the most significant bit of the result is a 1\. Had we just assumed that
    the output width would be the same as the input widths, then we would have dropped
    this bit and gotten the wrong answer. Our result would have been <samp class="SANS_TheSansMonoCd_W5Regular_11">0100</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">10100</samp>.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结果的最高有效位是 1。如果我们假设输出宽度与输入宽度相同，那么我们就会丢掉这个位，得到错误的答案。我们的结果将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0100</samp>
    而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">10100</samp>。
- en: 'Perhaps you’ve noticed that I haven’t explicitly said what these binary numbers
    represent yet, and whether they’re positive or negative. For example, is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1001</samp> unsigned and equal to 9, or
    is it signed and equal to the two’s complement of 9, which is –7 (invert the bits
    to get <samp class="SANS_TheSansMonoCd_W5Regular_11">0110</samp>, then add 1 to
    get <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>)? The reason I haven’t
    specified this is because the representation of the binary data ultimately doesn’t
    affect how the math is performed, as long as the inputs and outputs are sized
    appropriately. Whether <samp class="SANS_TheSansMonoCd_W5Regular_11">1001</samp>
    represents +9 or –7, the addition operation will be performed the same way. Of
    course, we care if the result is positive or negative, but the implementation
    of the addition doesn’t change depending on whether the data types are signed
    or unsigned. Let’s revisit our first example and consider what happens when we
    assign it various signed and unsigned combinations. Here’s the example again:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你注意到，我还没有明确说明这些二进制数字代表什么，也没有说明它们是正数还是负数。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">1001</samp>
    是无符号并等于 9，还是有符号并等于 9 的二进制补码，即 –7（反转位得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0110</samp>，然后加
    1 得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>）？我之所以没有明确说明这一点，是因为二进制数据的表示方式最终不会影响数学运算的执行方式，只要输入和输出的位数合适。无论
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1001</samp> 代表 +9 还是 –7，加法操作都会以相同的方式进行。当然，我们关心结果是正数还是负数，但加法的实现不会因为数据类型是有符号还是无符号而有所不同。让我们重新回到第一个例子，考虑一下当我们为其分配不同的有符号和无符号组合时会发生什么。以下是这个例子：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If both addition inputs are declared as unsigned types, then we have 2 + 8 =
    10\. Pretty simple. If both addition inputs are declared as signed, then the first
    input is still 2, but the second input is –8\. (Invert the bits to get <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>,
    add 1 to get <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>, and apply
    the negative sign to get –8.) So now we have 2 + –8, which should equal –6, but
    the result, <samp class="SANS_TheSansMonoCd_W5Regular_11">01010</samp>, is still
    10\. Something isn’t right here!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个加法输入都声明为无符号类型，那么我们有 2 + 8 = 10。相当简单。如果两个加法输入都声明为有符号类型，那么第一个输入仍然是 2，但第二个输入是
    –8。 （反转位得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>，加 1 得到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>，然后应用负号得到 –8。）所以现在我们有 2 + –8，结果应该是
    –6，但结果 <samp class="SANS_TheSansMonoCd_W5Regular_11">01010</samp> 仍然是 10。这里出了点问题！
- en: 'The problem is that we’re not performing sign extension on the inputs. *Sign
    extension* is the operation of increasing the number of bits of a binary number
    while preserving the number’s sign and value. This operation is required when
    the inputs are signed. Without it, we’ll get an incorrect answer, as you’ve just
    seen. To perform sign extension on a signed value, simply replicate the most significant
    bit. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp> becomes
    <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">00010</samp>. Let’s try
    that math again, this time first applying sign extension to our inputs:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们没有对输入进行符号扩展。*符号扩展*是将二进制数的位数增加，同时保持该数的符号和值的操作。输入为有符号时，需要进行此操作。如果没有，它会导致不正确的答案，就像你刚才看到的那样。要对有符号值执行符号扩展，只需复制最重要的位。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1000</samp> 变成 <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp> 变成 <samp class="SANS_TheSansMonoCd_W5Regular_11">00010</samp>。让我们再次尝试这个运算，这次先对输入应用符号扩展：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our inputs are still 2 and –8\. (For the latter, invert the bits of <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>
    to get <samp class="SANS_TheSansMonoCd_W5Regular_11">00111</samp>, add 1 to get
    <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>, and apply the negative
    sign to get –8.) The answer, <samp class="SANS_TheSansMonoCd_W5Regular_11">11010</samp>,
    is the signed equivalent of –6, which is exactly what we want. Sign extension
    was the critical step to ensure we got the expected answer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入仍然是 2 和 –8。 （对于后者，反转 <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>
    的位得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">00111</samp>，加 1 得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>，然后应用负号得到
    –8。）答案 <samp class="SANS_TheSansMonoCd_W5Regular_11">11010</samp> 是 –6 的有符号等效值，这正是我们想要的。符号扩展是确保我们得到预期答案的关键步骤。
- en: 'Sign extension is useful for unsigned values, too. In fact, since VHDL is strongly
    typed, the inputs and outputs to an addition operation must all have exactly the
    same width. You can’t, for example, add two 4-bit inputs to produce a 5-bit output;
    everything must be 5 bits. That means we should revisit Rule #1 and add a small
    modification:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '符号扩展对于无符号值也非常有用。事实上，由于 VHDL 是强类型的，所有参与加法运算的输入和输出必须具有完全相同的宽度。例如，你不能将两个 4 位输入相加得到一个
    5 位输出；所有的信号都必须是 5 位。这意味着我们应该重新审视规则 #1，并进行一个小的修改：'
- en: '**Rule #1 (modification #1)** When adding, the result should be at least 1
    bit bigger than the biggest input, *before sign extension*. Once sign extension
    is applied, the input and output widths should match exactly.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #1（修改 #1）** 在加法时，结果应至少比最大输入大 1 位，*在符号扩展之前*。一旦符号扩展应用，输入和输出的宽度应完全匹配。'
- en: For unsigned values, sign extension simply means adding a 0 as the new most
    significant bit. For example, unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>. The good news
    for those of you using Verilog is that the code performs sign extension automatically
    when you’re adding numbers. If you’re using VHDL, however, you’ll need to sign-extend
    your inputs manually using the <samp class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp>
    function, as you’ll see in the coming examples. Both approaches have their pros
    and cons. Verilog is easier if you know what you’re doing, as there’s less to
    worry about, but it also leaves more room for mistakes (for example, trying to
    store data in too small a signal). VHDL’s extra steps can be more confusing for
    beginners, and it generates cryptic errors when the rules aren’t followed. On
    the other hand, VHDL ensures that you’ve matched widths and types every step along
    the way, so there’s less room for error in the end.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无符号值，符号扩展意味着将0作为新的最高有效位。例如，无符号的 <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    变成 <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>。对于使用 Verilog 的用户来说，好消息是，当你加法运算时，代码会自动执行符号扩展。然而，如果你使用的是
    VHDL，你将需要通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp> 函数手动进行符号扩展，正如接下来的示例中所展示的那样。这两种方法各有优缺点。如果你知道自己在做什么，Verilog
    更容易，因为你需要担心的东西较少，但也更容易出错（例如，试图将数据存储在一个过小的信号中）。VHDL 的额外步骤可能让初学者感到困惑，而且当规则没有遵循时，它会生成难以理解的错误。另一方面，VHDL
    确保每一步都匹配宽度和类型，因此最终出错的可能性较小。
- en: 'Let’s summarize what we’ve learned with a few code examples. Add this code
    to your testbench where you saw the <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    earlier:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些代码示例来总结我们所学的内容。将以下代码添加到你的测试平台中，在你之前看到过的 <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    位置：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s the output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'First, we have two situations (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp>) where Rule #1 isn’t
    followed. We’re using 4-bit inputs and storing the result in a 4-bit output, and
    we’re not performing any sign extension. In both of these examples, we get the
    wrong answer. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp>, we
    add two unsigned numbers, 9 and 11, but get 4 as a result. The problem here is
    that we’re dropping the most significant bit, which would be worth 16\. (Indeed,
    4 + 16 = 20, which is the answer we should be getting.) In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp>,
    we add two signed numbers representing negative values, and again we get the wrong
    answer.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们有两个情况（<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp>），这两个例子没有遵循规则 #1。我们使用 4 位输入，并将结果存储在
    4 位输出中，而且没有执行符号扩展。在这两个例子中，我们得到了错误的结果。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp>
    中，我们加了两个无符号数，9 和 11，但得到了 4 作为结果。问题在于我们丢失了最高有效位，而这个位的值应该是 16。（事实上，4 + 16 = 20，这才是我们应该得到的答案。）在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp> 中，我们加了两个表示负值的有符号数，结果依然是错误的。'
- en: 'The fix is to store the result in a 5-bit output, which we do in both <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex03</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex04</samp>.
    We’ve satisfied Rule #1, so the math works correctly. Notice that in the Verilog
    version, the sign extension happens automatically: we can simply assign 4-bit
    inputs to a 5-bit output, for example by writing <samp class="SANS_TheSansMonoCd_W5Regular_11">o_u5</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i2_u4;</samp>.
    In VHDL, however, we must explicitly match input and output widths, while preserving
    the sign and value of each input. To do this, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp>
    function ❶. We use the VHDL tick attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">''length</samp>
    to reference the length of the output signal, as we did when we were performing
    type conversions. Again, this is more flexible than hardcoding the desired width
    by writing something like <samp class="SANS_TheSansMonoCd_W5Regular_11">resize(i1_u4,
    5)</samp>.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是将结果存储在一个5位的输出中，我们在<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex03</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex04</samp>中都这样做了。我们已经满足了规则#1，所以数学运算是正确的。注意，在Verilog版本中，符号扩展是自动进行的：我们可以简单地将4位输入赋值给5位输出，例如通过写<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_u5</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i2_u4;</samp>。然而，在VHDL中，我们必须显式地匹配输入和输出的位宽，同时保留每个输入的符号和值。为此，我们调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp>函数❶。我们使用VHDL的tick属性<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'length</samp>来引用输出信号的长度，正如我们在进行类型转换时所做的那样。再说一次，这比通过写类似<samp
    class="SANS_TheSansMonoCd_W5Regular_11">resize(i1_u4, 5)</samp>这样的硬编码宽度更灵活。
- en: 'Another tip for performing successful addition operations is to never mix signed
    and unsigned values. Your inputs and outputs should be of the same type; otherwise
    you might get an incorrect answer. This brings us to our second rule of FPGA math:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 进行成功的加法运算的另一个技巧是不要混合带符号和不带符号的值。输入和输出应该是相同类型的；否则，你可能会得到错误的结果。这引出了我们的第二条FPGA数学规则：
- en: '**Rule #2** Match types among inputs and outputs.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则#2** 输入和输出类型要匹配。'
- en: 'With VHDL, it’s easy to follow Rule #2 because it will throw an error if you
    try to do a math operation where one input is signed and the other is unsigned.
    For example, say you write this in your testbench to try to add a 4-bit unsigned
    value (<samp class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp>) to a 4-bit
    signed value (<samp class="SANS_TheSansMonoCd_W5Regular_11">i2_s4</samp>):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于VHDL来说，遵循规则#2很容易，因为如果你尝试进行一个输入为带符号、另一个输入为不带符号的数学运算，它会抛出错误。例如，假设你在测试平台中写下以下代码，尝试将一个4位的不带符号值（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp>）与一个4位的带符号值（<samp class="SANS_TheSansMonoCd_W5Regular_11">i2_s4</samp>）相加：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You’ll end up with an error message indicating the tool doesn’t know how to
    interpret the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator
    given those inputs:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个错误消息，指出工具无法理解给定输入下的<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>运算符：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Verilog is much more lenient. It will happily let you perform that math operation,
    and it won’t tell you that it’s actually treating your signed input as unsigned.
    This can very possibly result in the wrong answer, so be careful to always match
    your data types in Verilog.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Verilog的容错性更强。它会很高兴地让你执行该数学运算，而且不会告诉你它实际上是把带符号输入当作不带符号处理的。这很可能导致错误的结果，因此在Verilog中务必小心始终匹配数据类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Subtraction</samp>
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">减法</samp>
- en: Subtraction isn’t that different from addition. After all, subtraction is just
    an addition operation where one of the inputs is negative. In this sense, we’ve
    been doing subtraction all along; 2 + –8 is the same as 2 – 8\. Likewise, you
    can think of something like 5 – 3 as 5 + –3 and approach it like an addition operation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 减法与加法没什么不同。毕竟，减法只是将其中一个输入变为负数的加法运算。从这个角度看，我们一直在做减法；2 + –8 就等同于 2 – 8。同样，你可以把类似
    5 – 3 的运算看作 5 + –3，并以加法运算的方式进行处理。
- en: 'There’s one thing to be careful with when subtracting two numbers, though:
    while you *could* use subtraction with unsigned inputs and outputs, I wouldn’t
    recommend it. What happens if the result should be negative? For example, 3 –
    5 = –2, but if you try to store –2 into an unsigned data type, you won’t get the
    correct result. This brings us to our next rule:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在进行两个数的减法时，有一件事需要特别注意：虽然你*可以*使用无符号输入和输出进行减法，但我不推荐这样做。如果结果应该是负数会怎样呢？例如，3 –
    5 = -2，但如果你尝试将 -2 存入无符号数据类型中，你将无法获得正确的结果。这引出了我们的下一个规则：
- en: '**Rule #3** When subtracting, use signed inputs and outputs.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #3** 在进行减法时，使用有符号的输入和输出。'
- en: Even if you don’t think the result of a subtraction will produce a negative
    number, you should use signed data types to be safe.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你认为减法的结果不会产生负数，你也应该使用有符号数据类型，以确保安全。
- en: 'Because subtraction is really just negative addition, subtraction carries the
    same risk that you could truncate the result if the output isn’t sized appropriately.
    Again, it’s better to size up the output by 1 bit and to sign-extend your inputs
    before performing the math operation. This gives us a further modified Rule #1:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '因为减法实际上就是负数加法，所以减法存在相同的风险，即如果输出的大小不合适，可能会导致结果被截断。再次强调，最好在执行数学运算之前将输出大小增加1位，并对输入进行符号扩展。这给我们带来了进一步修改的规则
    #1：'
- en: '**Rule #1 (modification #2)** When adding *or subtracting*, the result should
    be at least 1 bit bigger than the biggest input, before sign extension. Once sign
    extension is applied, the input and output widths should match exactly.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #1（修改版 #2）** 在加法*或减法*时，结果应比最大输入大至少 1 位，符号扩展前如此。符号扩展应用后，输入和输出的位宽应该完全匹配。'
- en: 'With those two rules in place, let’s extend our <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>
    testbench to take a look at some subtraction operations in Verilog and VHDL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两条规则，我们扩展了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>
    测试平台，来观察 Verilog 和 VHDL 中的一些减法操作：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s the output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex05</samp>, we’re trying
    to calculate 9 – 11 but we get a result of 30, clearly the wrong answer. The problem
    here is that we’re using unsigned types for subtraction, which is a violation
    of Rule #3\. We fix this in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex06</samp>
    by converting the input values from unsigned to signed data types. We also perform
    sign extension in the process, going from 4-bit inputs to 5-bit inputs. In the
    Verilog code, we handle the conversion by simply assigning the 4-bit unsigned
    signals to 5-bit signed signals ❶. Verilog takes care of the details automatically.
    VHDL makes us jump through a few more hoops. We first resize the input, which
    will sign-extend it, but the result of the resize operation is still an unsigned
    type, so we then explicitly cast it to a signed data type using <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp>
    ❷. This is safe to do because we’ve already resized the signal, so the most significant
    bit will be 0\. Therefore, the value after converting to a signed type won’t be
    changed.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex05</samp> 中，我们尝试计算 9 – 11，但结果却是
    30，显然是错误的答案。问题在于我们使用了无符号类型进行减法，这违反了规则 #3。我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex06</samp>
    中通过将输入值从无符号转换为有符号数据类型来修复这一问题。在此过程中，我们还进行了符号扩展，将 4 位输入转换为 5 位输入。在 Verilog 代码中，我们通过将
    4 位无符号信号直接赋值给 5 位有符号信号来处理转换 ❶。Verilog 会自动处理细节。而 VHDL 需要我们多做一些工作。我们首先调整输入大小，这将进行符号扩展，但调整大小后的结果仍然是无符号类型，因此我们需要显式地使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp> 将其转换为有符号数据类型 ❷。这样做是安全的，因为我们已经调整了信号大小，所以最高位将是
    0。因此，转换为有符号类型后的值不会改变。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplication</samp>
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">乘法</samp>
- en: 'Multiplication also works similarly to addition; after all, a multiplication
    operation is just a series of repeated addition operations (4 × 3 = 4 + 4 + 4).
    The first thing to consider when multiplying two inputs together is how to properly
    size the output bit width. This brings us to our next rule:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算与加法运算类似；毕竟，乘法运算只是重复加法的一个过程（4 × 3 = 4 + 4 + 4）。在将两个输入相乘时，首先要考虑的是如何正确设置输出的位宽。这引出了我们的下一个规则：
- en: '**Rule #4** When multiplying, the output bit width must be at least the sum
    of the input bit widths (before sign extension).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #4** 在乘法运算时，输出位宽必须至少等于输入位宽的总和（在符号扩展之前）。'
- en: 'This rule holds true for both signed and unsigned numbers. For example, say
    we’re trying to multiply the unsigned inputs <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp> (equivalent to 7 ×
    3). According to Rule #4, the output should be 3 + 2 = 5 bits wide. You can try
    out the multiplication yourself to confirm this, using the same technique you
    learned in school for multiplying multidigit numbers—multiply each digit individually
    and add the results together:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '这个规则对有符号数和无符号数都适用。例如，假设我们正在尝试乘法运算无符号输入 <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>（等于 7 × 3）。根据规则 #4，输出应该是
    3 + 2 = 5 位宽。你可以自己试一下这个乘法运算，使用你在学校学过的多位数相乘的技巧——逐位相乘并将结果相加：'
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The output, <samp class="SANS_TheSansMonoCd_W5Regular_11">10101</samp> (equivalent
    to 21), is indeed 5 bits wide, which is what we expected. But what happens to
    this same multiplication if we treat our inputs and outputs as signed, rather
    than unsigned? In this case, we would have the equivalent of –1 × –1 in decimal,
    which should produce a result of +1, but signed <samp class="SANS_TheSansMonoCd_W5Regular_11">10101</samp>
    in binary is equal to –11 in decimal. What’s wrong here?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出 <samp class="SANS_TheSansMonoCd_W5Regular_11">10101</samp>（等于 21），确实是 5 位宽，符合预期。但如果我们将输入和输出视为有符号数而非无符号数，这个乘法运算会怎样呢？在这种情况下，相当于十进制的
    –1 × –1，结果应该是 +1，但二进制的有符号 <samp class="SANS_TheSansMonoCd_W5Regular_11">10101</samp>
    等于十进制的 –11。那么这里到底出了什么问题呢？
- en: 'The problem is that we didn’t sign-extend our inputs to match the width of
    our output (5 bits) before multiplying. If we do that, our inputs both become
    <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>, and the multiplication
    looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，我们在进行乘法运算之前，没有将输入的位宽扩展到与输出位宽（5 位）相匹配。如果我们这样做，输入会变成 <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>，乘法运算结果如下所示：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we’re getting <samp class="SANS_TheSansMonoCd_W5Regular_11">00000001</samp>,
    or really <samp class="SANS_TheSansMonoCd_W5Regular_11">00001</samp> once we truncate
    the result to be 5 bits wide, which is +1 in decimal. Sign extension gives us
    the result we expect. Unlike with addition and subtraction, however, you don’t
    actually need to perform this sign extension manually when multiplying numbers
    using Verilog or VHDL. The tools will handle this automatically; you simply need
    to size the output signal correctly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">00000001</samp>，或者实际上在将结果截断为
    5 位宽后，得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">00001</samp>，即十进制的 +1。符号扩展给出了我们预期的结果。然而，与加法和减法不同，在使用
    Verilog 或 VHDL 进行乘法运算时，你实际上不需要手动进行符号扩展。工具会自动处理这一过程；你只需要正确设置输出信号的位宽。
- en: 'VHDL helps with this too: it won’t even let you compile the code if you disobey
    Rule #4 and fail to size the output of a multiplication correctly. With Verilog,
    you’ll need to be more careful. It won’t warn you if the output is the wrong size,
    and you could get an unexpected result. Let’s add some examples of this to our
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp> testbench:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'VHDL 也能帮助处理这个问题：如果你违反规则 #4，未正确设置乘法运算的输出大小，VHDL 根本无法编译代码。而在 Verilog 中，你需要更加小心。如果输出的位宽不正确，它不会发出警告，可能会得到意外的结果。让我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp> 测试平台中添加一些例子：'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s the output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Verilog allows us to perform the math operation despite the fact that we’re
    disobeying Rule #4 by multiplying 4 bits by 4 bits and storing the result in a
    4-bit output. This produces incorrect results for both unsigned (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex07</samp>)
    and signed (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex08</samp>) input values.
    VHDL, on the other hand, won’t even build this code; we get a nice descriptive
    error telling us that the tool is trying to assign an 8-bit-wide result to a 4-bit-wide
    variable, which isn’t permitted. Let’s add a few more examples to our testbench
    that fix these issues:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'Verilog 允许我们执行数学运算，尽管我们违反了规则 #4，即将 4 位数与 4 位数相乘，并将结果存储在一个 4 位输出中。这对于无符号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex07</samp>）和有符号（<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex08</samp>）输入值都会产生错误结果。另一方面，VHDL
    甚至无法构建此代码；我们会得到一个详细的错误信息，告诉我们工具正在尝试将一个 8 位宽的结果赋值给一个 4 位宽的变量，这是不允许的。让我们在测试平台中添加几个例子来修复这些问题：'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s the output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex09</samp>, we correct the
    problem in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex07</samp> by storing
    the output of multiplying two unsigned 4-bit values into an 8-bit signal. Similarly,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex10</samp> corrects the issue from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex08</samp> with signed values.
    Notice that we never have to sign-extend the inputs, in either Verilog or VHDL.
    The tools handle this automatically.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex09</samp> 中，我们通过将两个无符号 4 位值相乘的结果存储到一个
    8 位信号中，解决了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex07</samp> 中的问题。类似地，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex10</samp> 修复了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex08</samp>
    中有符号值的问题。请注意，我们在 Verilog 或 VHDL 中都不需要扩展输入的符号。工具会自动处理这一点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplication by
    Powers of 2</samp>
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">乘以 2 的幂</samp>
- en: 'There’s a trick that we can use when multiplying numbers by a power of 2 (for
    example, 2, 4, 8, 16, 32, …). Rather than instantiating a bunch of multiplication
    logic, we can simply instantiate a shift register and perform a shift left operation.
    Shifting left by *N* bits is equivalent to multiplying by 2*^N*. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0011</samp> (3 in binary) shifted
    left 2 bits gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">1100</samp>
    (12 in binary). It’s the same as calculating 3 × 4, or 3 × 2². This trick works
    for both signed and unsigned numbers. Let’s try it out in our testbench:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在乘以 2 的幂（例如 2、4、8、16、32 等）时，我们可以使用一个技巧。与其实例化一堆乘法逻辑，我们可以简单地实例化一个移位寄存器并执行左移操作。左移
    *N* 位等同于乘以 2*^N*。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">0011</samp>（十进制
    3）左移 2 位，得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">1100</samp>（十进制 12）。这等同于计算
    3 × 4，或 3 × 2²。这个技巧适用于有符号和无符号数。让我们在测试平台中试试：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here’s the output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We start with the decimal value 3 and shift left by 1, 2, and 4 bits to multiply
    it by 2, 4, and 16, respectively. In Verilog we perform the shift using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><<</samp> operator, and in VHDL we use
    the function <samp class="SANS_TheSansMonoCd_W5Regular_11">shift_left()</samp>.
    Both take as an argument the number of bit positions to shift.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从十进制值 3 开始，左移 1、2 和 4 位，分别将其乘以 2、4 和 16。在 Verilog 中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>
    运算符进行移位，而在 VHDL 中，我们使用函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">shift_left()</samp>。这两个方法的参数都是要移位的位数。
- en: Shifting left is a simple and quick trick to save FPGA resources, but you don’t
    necessarily need to write it out explicitly. It’s likely that if you hardcode
    a multiplication by a power of 2, the synthesis tools will be smart enough to
    figure out that a left shift would take fewer resources.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 左移是节省FPGA资源的一个简单快捷的技巧，但你不一定需要显式地写出来。如果你硬编码了一个2的幂乘法，综合工具可能会足够聪明，自动识别出左移操作会占用更少的资源。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Division</samp>
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Division</samp>
- en: Unfortunately, division isn’t nearly as simple an operation as addition, subtraction,
    or multiplication. Division comes with all sorts of messy complications, like
    remainders and fractions. In general, it’s a good idea to avoid division inside
    your FPGA if you can. It’s a resource-intensive operation, especially if you need
    that operation to run at high clock rates.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，除法不像加法、减法或乘法那样简单。除法会带来各种复杂问题，比如余数和分数。一般来说，如果可以的话，最好避免在FPGA内部进行除法。除法是一个资源密集型的操作，尤其是在你需要让这个操作在高时钟频率下运行时。
- en: I once worked on a project that needed to add a division operation to an FPGA
    in the field. The FPGA was a very old part, and it simply couldn’t fit it within
    the available resources. To accommodate the division operation we ended up having
    to upgrade to a higher-resource FPGA of the same family, which increased the cost
    of the hardware by over $1 million. I always think of that one extra operation
    as the million-dollar divide!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经参与一个项目，需要在现场为FPGA添加一个除法操作。那个FPGA是一个非常老旧的型号，根本无法在现有资源下完成这项操作。为了支持除法操作，我们最终不得不升级到同一家族的高资源FPGA，这使得硬件成本增加了超过100万美元。我一直把那一次额外的操作当作百万美元除法！
- en: If you *must* divide numbers, there are a few ways to make the operation less
    resource-intensive. These include restricting yourself to dividing by powers of
    2, using a precalculated table of answers, or breaking up the operation across
    multiple clock cycles.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你*必须*进行除法操作，有几种方法可以使这个操作更节省资源。这些方法包括限制自己只进行2的幂除法，使用预先计算好的答案表，或者将操作分解到多个时钟周期中进行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Powers of 2</samp>
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用2的幂</samp>
- en: 'My best suggestion for reducing the overhead of dividing numbers inside an
    FPGA is to make the divisor a power of 2\. Similar to how multiplication by a
    power of 2 can be efficiently performed with a shift left operation, division
    by a power of 2 can be performed efficiently with a shift right operation. Shifting
    right by *N* bits is equivalent to dividing by 2*^N*. Let’s look at a few examples
    of this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我对减少在FPGA内部进行除法操作开销的最佳建议是将除数设为2的幂。类似于如何使用左移操作高效地进行2的幂乘法，2的幂除法也可以通过右移操作高效地完成。右移*N*位相当于除以2*^N*。让我们来看看几个例子：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here’s the output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex14</samp> performs a shift right
    by 1, which in Verilog uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">>></samp>
    operator and in VHDL uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">shift_right()</samp>
    function. This accomplishes a single divide by 2\. To divide by 4, shift right
    by 2 bit positions, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex15</samp>.
    Likewise, a right shift by 4 divides by 16, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex16</samp>.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex14</samp>执行了右移1位，在Verilog中使用的是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>></samp> 运算符，而在VHDL中使用的是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">shift_right()</samp> 函数。这完成了一个除以2的操作。要除以4，可以右移2个位位置，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex15</samp> 所示。同样，右移4位相当于除以16，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex16</samp> 所示。
- en: 'What happens when we don’t have a number that’s cleanly divisible by the power
    of 2 serving as the divisor? In this case, shifting right effectively accomplishes
    a division that’s rounded down to the nearest integer. The next few examples illustrate
    how this works:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有一个能被2的幂整除的数字作为除数时会发生什么呢？在这种情况下，右移操作有效地完成了一个向下取整到最接近整数的除法。接下来的几个例子将说明这是如何工作的：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s the output:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex17</samp>, we try to perform
    15 / 2\. This should give us 7.5, but we have no way to represent the .5 part,
    so we end up rounding down to 7 instead. Thinking of this as a shift right, we
    went from <samp class="SANS_TheSansMonoCd_W5Regular_11">00001111</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">00000111</samp>. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex18</samp>,
    we try to take 15 / 4, which should be 3.75, but we drop the decimal places and
    just get 3\. Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex19</samp>
    we get 15 / 8 = 1\. This rounding might cause a problem if you’re not expecting
    it, so be aware that this can happen when performing shift right operations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex17</samp> 中，我们尝试执行 15 / 2\。这应该得到
    7.5，但我们无法表示 .5 部分，因此最终会向下取整为 7。将其视为右移操作，我们从 <samp class="SANS_TheSansMonoCd_W5Regular_11">00001111</samp>
    变为 <samp class="SANS_TheSansMonoCd_W5Regular_11">00000111</samp>。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex18</samp>
    中，我们尝试计算 15 / 4，这应该得到 3.75，但我们会去掉小数部分，只得到 3\。最后，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex19</samp>
    中，我们得到 15 / 8 = 1\。如果你没有预料到这种情况，这种舍入可能会引发问题，因此请注意在执行右移操作时可能会发生这种情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using a Precalculated Table</samp>
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用预计算表</samp>
- en: Another option for dividing two numbers is to precalculate the result for all
    possible input combinations. For example, if we’re trying to divide any number
    1 through 7 by any other number 1 through 7, we could create something like [Table
    10-3](#tab10-3) inside the FPGA.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种除法操作的选项是为所有可能的输入组合预先计算结果。例如，如果我们尝试将数字 1 到 7 中的任何数字除以 1 到 7 中的任何其他数字，我们可以在
    FPGA 中创建类似[表 10-3](#tab10-3)的内容。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-3:</samp> <samp class="SANS_Futura_Std_Book_11">Precalculated
    Table for Full Range of Division Inputs</samp>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-3：</samp> <samp class="SANS_Futura_Std_Book_11">全范围除法输入的预计算表</samp>
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">4</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">5</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">6</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">7</samp> |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">4</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">5</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">6</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">7</samp> |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.25</samp> | <samp class="SANS_Futura_Std_Book_11">0.20</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.17</samp> | <samp class="SANS_Futura_Std_Book_11">0.14</samp>
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.25</samp> | <samp class="SANS_Futura_Std_Book_11">0.20</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.17</samp> | <samp class="SANS_Futura_Std_Book_11">0.14</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">2.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.67</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.40</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.33</samp> | <samp class="SANS_Futura_Std_Book_11">0.29</samp>
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">2.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.67</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.40</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.33</samp> | <samp class="SANS_Futura_Std_Book_11">0.29</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">3.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.75</samp> | <samp class="SANS_Futura_Std_Book_11">0.60</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.43</samp>
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">3.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.75</samp> | <samp class="SANS_Futura_Std_Book_11">0.60</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.43</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">4.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.00</samp> | <samp class="SANS_Futura_Std_Book_11">1.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.80</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.67</samp> | <samp class="SANS_Futura_Std_Book_11">0.57</samp>
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">4.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.00</samp> | <samp class="SANS_Futura_Std_Book_11">1.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.80</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.67</samp> | <samp class="SANS_Futura_Std_Book_11">0.57</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">5.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.67</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.25</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.83</samp> | <samp class="SANS_Futura_Std_Book_11">0.71</samp>
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">5.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.67</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.25</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.83</samp> | <samp class="SANS_Futura_Std_Book_11">0.71</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">6.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.00</samp> | <samp class="SANS_Futura_Std_Book_11">2.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.20</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.86</samp>
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">6.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.00</samp> | <samp class="SANS_Futura_Std_Book_11">2.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.20</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.86</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">7.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.50</samp> | <samp class="SANS_Futura_Std_Book_11">2.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.75</samp> | <samp class="SANS_Futura_Std_Book_11">1.40</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.17</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">7.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.50</samp> | <samp class="SANS_Futura_Std_Book_11">2.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.75</samp> | <samp class="SANS_Futura_Std_Book_11">1.40</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.17</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    |'
- en: For this example, let’s assume that each row represents a possible dividend,
    and each column represents a possible divisor. The value at the intersection of
    a given dividend and divisor is the corresponding quotient. As an example, to
    find the value in decimal for the fraction 5/6, go to row 5, then over to column
    6 to get the value 0.83\. To implement this in Verilog or VHDL, we could store
    this two-dimensional table in a 2D array. (You saw how 2D arrays work in the state
    machine project in [Chapter 8](chapter8.xhtml).) The row input values provide
    one index, the column input values provide the second index, and the quotient
    is the value at those two indices. We’re not actually performing any math here;
    we’re just indexing into the correct result, which has been precalculated and
    stored in memory.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，假设每一行代表一个可能的被除数，每一列代表一个可能的除数。给定的被除数和除数交汇处的值就是相应的商。例如，要找到分数5/6的十进制值，可以去第5行，再移动到第6列，得到值0.83。为了在Verilog或VHDL中实现这一点，我们可以将这个二维表格存储在一个二维数组中。（你可以在[第8章](chapter8.xhtml)的状态机项目中看到二维数组是如何工作的。）行输入值提供了一个索引，列输入值提供了第二个索引，商则是这两个索引处的值。我们实际上并没有进行任何数学运算；我们只是索引到正确的结果，这个结果已经预先计算并存储在内存中。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If you’re wondering how to represent decimal values like 0.50 and 0.33 inside
    an FPGA, good question! We’ll explore this topic shortly.*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在想如何在 FPGA 中表示像 0.50 和 0.33 这样的十进制值，问得好！我们很快会探讨这个话题。*'
- en: As the range of possible inputs grows, of course, we’ll need a larger and larger
    table to store the possible outputs. Eventually, a single table could take up
    an entire block RAM, which are often 16Kb in size. Using a precalculated table
    in a block RAM guarantees that a single division calculation will take a single
    clock cycle, since we only need one clock cycle to read from the memory (as you
    learned when we discussed RAM back in [Chapter 6](chapter6.xhtml)). However, we
    can’t read from multiple locations in the memory on the same clock cycle, so if
    we needed to do two divisions simultaneously, on the exact same clock cycle, we
    would need to instantiate a second copy of the precalculated table in another
    block RAM.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 随着可能输入范围的增大，当然，我们将需要一个更大更大的表来存储可能的输出。最终，一个单独的表可能会占用整个块 RAM，通常块 RAM 的大小为 16Kb。使用块
    RAM 中的预计算表可以确保单次除法计算只需要一个时钟周期，因为我们只需一个时钟周期来读取内存（就像我们在[第六章](chapter6.xhtml)中讨论
    RAM 时所学的那样）。然而，我们不能在同一个时钟周期内从多个位置读取内存，因此如果我们需要在完全相同的时钟周期内同时进行两次除法运算，我们就需要在另一个块
    RAM 中实例化预计算表的第二个副本。
- en: Block RAMs are usually valuable resources, so taking up a bunch of them for
    concurrent divisions doesn’t scale very well. If the design will allow us to run
    the different divisions in consecutive clock cycles, rather than simultaneously,
    we could instead use a single table and time-share it. Time sharing a single resource
    would require arbitration of that resource, as we discussed in [Chapter 7](chapter7.xhtml).
    We would have to create some arbiter that would only allow access to the block
    RAM table by one module at a time.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 块 RAM 通常是宝贵的资源，因此将其用于并行除法运算并不具有良好的可扩展性。如果设计允许我们在连续的时钟周期中运行不同的除法操作，而不是同时进行，我们可以改为使用一个表格并进行时间共享。对单一资源进行时间共享需要对该资源进行仲裁，正如我们在[第七章](chapter7.xhtml)中讨论的那样。我们需要创建一个仲裁器，只允许一个模块在每次时钟周期访问该块
    RAM 表。
- en: The solutions discussed up to this point assume we have just one clock cycle
    to get the result of a division operation. However, if we can wait multiple clock
    cycles for the result of a division operation, that allows us to use another option.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的解决方案假设我们只有一个时钟周期来获得除法运算的结果。然而，如果我们可以等待多个时钟周期来得到除法结果，那么我们就可以使用另一个选项。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Multiple Clock Cycles</samp>
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用多个时钟周期</samp>
- en: Another way to ease the burden of the synthesis tools when it comes to division
    is to create an algorithm that performs division in more than a single clock cycle,
    using simpler math operations such as addition and subtraction. At its heart,
    division is about calculating how many times one number fits into another number.
    You can accomplish this, for example, by adding the divisor to itself over and
    over until you’ve passed the value of the dividend, while counting the number
    of times you had to run that loop. Then you subtract the dividend to get the remainder.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解合成工具在执行除法时的负担的另一种方法是创建一个算法，该算法通过使用更简单的数学运算（如加法和减法）在不止一个时钟周期内执行除法。除法的本质是计算一个数能在另一个数中被包含多少次。例如，你可以通过将除数反复加到自身，直到超出被除数的值，同时计数你执行了多少次循环。然后，减去被除数以得到余数。
- en: There are various other techniques for performing division using simpler math
    operations. (Specific implementations are beyond the scope of this book; search
    the web for *division algorithms on FPGAs* if you want to learn more.) But of
    course, these methods only work if you’re able to wait multiple clock cycles for
    the result. Using multiple clock cycles to produce a result is a bit different
    in this context than the pipelining example we discussed in [Chapter 7](chapter7.xhtml),
    where we broke up a complex math operation across multiple clock cycles to meet
    timing. In that case, we were still able to get a result every clock cycle, but
    the outputs were delayed a few clock cycles from the inputs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 还有各种其他方法可以通过更简单的数学运算执行除法。（具体实现超出了本书的范围；如果你想了解更多，可以在网上搜索*FPGA上的除法算法*。）但当然，这些方法只有在你能够等待多个时钟周期得到结果的情况下才有效。在这个背景下，使用多个时钟周期得到结果与我们在[第七章](chapter7.xhtml)中讨论的流水线示例有所不同，在那个例子中，我们将一个复杂的数学运算分解到多个时钟周期以满足时序要求。在那个例子中，我们仍然能够在每个时钟周期获得一个结果，但输出相对于输入延迟了几个时钟周期。
- en: In this case, we don’t know how many clock cycles the division algorithm will
    take to provide a result, so we can’t rely on a result each clock cycle. Ultimately,
    it’s a question of trading lower resource utilization for more clock cycles. If
    you really need to get the result of a division operation on every single clock
    cycle, you’ll have to use one of the previously discussed division techniques.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不知道除法算法需要多少时钟周期才能提供结果，因此我们不能依赖每个时钟周期的结果。最终，这是一个在更低资源利用和更多时钟周期之间进行权衡的问题。如果你真的需要在每个时钟周期都获得除法操作的结果，你将不得不使用之前讨论过的除法技术之一。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How FPGAs Implement Math Operations</samp>
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">FPGA 如何实现数学运算</samp>
- en: With all the operations we’ve discussed so far, we’ve only looked at how the
    math works, without really considering how the operations are implemented inside
    an FPGA. There are various FPGA components that may be involved, depending on
    the specific operation performed. If you take an introductory digital electronics
    course, you might learn about *half adders* and *full adders*, digital circuits
    that combine various logic gates (like XOR and AND) to perform addition operations.
    It’s a fascinating subject, but in the end you might be frustrated to find that
    you don’t need to know how these circuits work to be able to do math with modern
    FPGA code. You’ll never need to instantiate a full adder component by manually
    typing out all the necessary logic operations if you’re just adding two numbers
    together. Instead, you just use the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator in Verilog or VHDL, like you would in any other programming language,
    and trust the synthesis tools to handle the implementation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的所有操作只是看到了数学如何运作，并没有真正考虑这些操作是如何在 FPGA 内部实现的。根据执行的具体操作，可能会涉及不同的 FPGA
    组件。如果你参加了入门级的数字电子学课程，你可能会学习到*半加法器*和*全加法器*，这些是结合了各种逻辑门（如 XOR 和 AND）来执行加法操作的数字电路。这是一个很有趣的主题，但最终你可能会感到沮丧，因为你不需要知道这些电路是如何工作的，就能在现代
    FPGA 代码中进行数学运算。如果你只是在做加法，你永远不需要通过手动编写所有必要的逻辑操作来实例化一个全加法器组件。相反，你只需在 Verilog 或 VHDL
    中使用<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>运算符，就像在任何其他编程语言中一样，并且相信综合工具会处理实现过程。
- en: The tools will likely place addition and subtraction operations into basic LUTs.
    For multiplication, the tools will use flip-flops for the shift left approach,
    or LUTs or DSP blocks (if available) for more complicated calculations. As discussed
    in [Chapter 9](chapter9.xhtml), DSP blocks are useful for accelerating large multiply–accumulate
    operations without utilizing a lot of LUT logic. Finally, division will require
    registers for the shift right approach, block RAMs for the precalculated table
    approach, or LUTs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 工具可能会将加法和减法操作放入基本的 LUT 中。对于乘法，工具会使用触发器来实现左移方法，或者使用 LUT 或 DSP 块（如果可用）进行更复杂的计算。如[第
    9 章](chapter9.xhtml)所讨论，DSP 块在加速大规模乘法-累加运算时非常有用，而且不会占用大量 LUT 逻辑。最后，除法操作需要寄存器来实现右移方法，或者使用预计算表的块
    RAM，或者是 LUT。
- en: 'There’s more to math than just addition, subtraction, multiplication, and division,
    however. Look at your calculator and consider all the operations we haven’t discussed:
    sine, cosine, square root, and more. It’s certainly possible to run these operations
    on an FPGA, but it gets complicated and is beyond the scope of this book. If you’re
    interested in learning more, there are dedicated algorithms that you can instantiate
    for these, such as a Coordinate Rotation Digital Computer (CORDIC). Search GitHub
    for *FPGA CORDIC* and you’ll find many examples.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数学不仅仅是加法、减法、乘法和除法。看看你的计算器，考虑一下我们没有讨论的所有其他操作：正弦、余弦、平方根等等。在 FPGA 上运行这些操作当然是可能的，但它会变得复杂，并超出了本书的范围。如果你有兴趣了解更多，实际上有专门的算法可以实例化来执行这些操作，例如坐标旋转数字计算机（CORDIC）。你可以在
    GitHub 上搜索*FPGA CORDIC*，会找到许多例子。
- en: In addition to actually implementing more complicated math operations on your
    FPGA, if you have the option it might be worth sending the inputs to a dedicated
    processor to perform the calculations, and then returning the result back to the
    FPGA logic. We’ll discuss floating- versus fixed-point arithmetic in the next
    section, but processors are much more capable of performing floating-point arithmetic
    than FPGAs. This processor can be a dedicated component external to the FPGA,
    or it can be internal to the FPGA itself. If it’s internal, it’s referred to as
    either a hard-core processor or a soft-core processor, depending on if it’s a
    dedicated piece of silicon or not.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在FPGA上实际实现更复杂的数学运算外，如果有选择，可能值得将输入发送到专用处理器进行计算，然后将结果返回到FPGA逻辑中。我们将在下一节讨论浮点运算与定点运算，但处理器执行浮点运算的能力远超FPGA。这个处理器可以是外部的专用组件，也可以是FPGA内部的。如果是内部的，它被称为硬核处理器或软核处理器，具体取决于它是否是专用硅片。
- en: Many modern FPGAs have internal hard ARM cores. This type of component with
    FPGA logic and a dedicated processor is often referred to as a *system on a chip
    (SoC)*. You can send the operations from the FPGA LUT/flip-flop logic into the
    ARM core for processing, and it will perform whatever operation is required and
    return the result. This solution is more about handling data than performing math,
    since you’ll likely need to set up FIFOs for each of the inputs and outputs. Working
    with a separate processor is an advanced topic, but it can be very valuable in
    higher-end applications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代FPGA都具有内部硬件ARM核心。这种将FPGA逻辑与专用处理器结合的组件通常被称为*系统级芯片（SoC）*。你可以将来自FPGA查找表（LUT）/触发器逻辑的操作发送到ARM核心进行处理，ARM核心会执行所需的操作并返回结果。这种解决方案更多是处理数据而不是进行数学运算，因为你可能需要为每个输入和输出设置FIFO。使用单独的处理器是一个高级话题，但在高端应用中它非常有价值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with Decimals</samp>
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">与小数一起工作</samp>
- en: 'So far we’ve been working with integers, but there are many applications where
    you’ll need your FPGA to operate on numbers with a decimal component. In this
    section, we’ll examine how to do math using non-integers. To begin with, we need
    to consider how fractional numbers are actually represented using binary digits.
    There are two possible systems to choose from: floating point and fixed point.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理整数，但在许多应用中，你需要让FPGA处理带有小数部分的数字。在本节中，我们将探讨如何使用非整数进行数学运算。首先，我们需要考虑如何使用二进制数字表示分数数字。有两种可能的系统可以选择：浮点数和定点数。
- en: The vast majority of mathematical operations within electronic devices use *floating-point*
    arithmetic, since most CPUs are designed to handle floating-point numbers. The
    key to floating point is that the *radix* (the decimal separator) “floats,” depending
    on how much precision is needed. We won’t go into detail about how exactly this
    works, but the bottom line is that with 32 bits you can represent an enormous
    range of values, with varying precision; you can represent very small numbers
    with high precision, or very large numbers with less precision. *Fixed-point*
    arithmetic, on the other hand, has a fixed radix, meaning there are a fixed number
    of integer places and a fixed number of decimal places.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 绝大多数电子设备中的数学运算使用*浮点*运算，因为大多数CPU设计用来处理浮点数。浮点的关键在于*基数*（小数点）是“浮动”的，取决于需要多少精度。我们不会详细讨论这如何运作，但关键是，使用32位可以表示一个巨大的数值范围，且具有不同的精度；你可以用高精度表示非常小的数字，或者用较低精度表示非常大的数字。另一方面，*定点*运算有一个固定的基数，这意味着有固定数量的整数位和固定数量的小数位。
- en: FPGAs *can* perform floating-point operations, but they often require more resources
    than fixed-point operations. Most FPGA math is therefore done with fixed-point
    arithmetic, so that will be our focus for the rest of the chapter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA*可以*执行浮点运算，但通常比定点运算需要更多的资源。因此，大多数FPGA数学运算使用定点运算，因此本章剩余部分将聚焦于定点运算。
- en: To illustrate how fixed-point representation works, let’s take an example. Say
    we have 3 bits allotted for representing a number inside our FPGA. We’ve been
    assuming up to this point that each bit change will be worth one integer value.
    For example, going from <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> means that we go from
    1 to 2\. But we’ve just arbitrarily decided that each bit is worth one integer.
    We could just as easily decide that a single bit is worth something else, for
    example 0.5\. In that case, <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    would be equivalent to 0.5, <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>
    would be 1.0, <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> would be
    1.5, and so on. We now have a fixed-point system where the rightmost bit represents
    the decimal component of the number and the other two bits represent the integer
    component. We can also interpret the bits in other ways to give us different fixed-point
    representations. [Table 10-4](#tab10-4) shows the most common decimal interpretations
    of 3 unsigned bits.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明定点表示法是如何工作的，我们来看一个例子。假设我们在 FPGA 中为表示一个数字分配了 3 位。到目前为止，我们一直假设每个比特的变化都代表一个整数值。例如，从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>，表示从
    1 到 2。但我们只是随便决定每个比特代表一个整数值。我们也可以决定每个位的值是别的东西，比如 0.5。这样，<samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    就等于 0.5，<samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> 就是 1.0，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">011</samp> 就是 1.5，以此类推。现在我们有了一个定点系统，其中最右边的比特表示数字的小数部分，另外两位则表示整数部分。我们还可以以其他方式解读这些比特，从而获得不同的定点表示。[表
    10-4](#tab10-4) 显示了 3 位无符号数的最常见小数表示方法。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-4:</samp> <samp class="SANS_Futura_Std_Book_11">3-Bit
    Unsigned Fixed-Point Possibilities</samp>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-4：</samp> <samp class="SANS_Futura_Std_Book_11">3
    位无符号定点表示的可能性</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">U3.0</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">U2.1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">U1.2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">U0.3</samp> |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">比特</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">U3.0</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">U2.1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">U1.2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">U0.3</samp> |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.125</samp> |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.125</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.0</samp> | <samp class="SANS_Futura_Std_Book_11">0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.250</samp> |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.0</samp> | <samp class="SANS_Futura_Std_Book_11">0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.250</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.375</samp> |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.375</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.0</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.500</samp> |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.0</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.500</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.5</samp> | <samp class="SANS_Futura_Std_Book_11">1.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.625</samp> |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.5</samp> | <samp class="SANS_Futura_Std_Book_11">1.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.625</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.0</samp> | <samp class="SANS_Futura_Std_Book_11">1.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.750</samp> |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.0</samp> | <samp class="SANS_Futura_Std_Book_11">1.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.750</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.5</samp> | <samp class="SANS_Futura_Std_Book_11">1.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.875</samp> |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.5</samp> | <samp class="SANS_Futura_Std_Book_11">1.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.875</samp> |'
- en: The headings in [Table 10-4](#tab10-4) use a modified version of *Q notation*,
    which is a way to specify the parameters of a binary fixed-point number format.
    In Q notation, for example, Q1.2 indicates that 1 bit is being used for the integer
    portion of a number and 2 bits are being used for the fractional portion. Standard
    Q notation assumes the values are signed; however, in FPGAs it’s very common to
    have unsigned and signed values. That’s why I prefer a notation that specifies
    if the values are signed (S) or unsigned (U) using the leading character. Thus,
    S3.1 indicates a signed value with 3 integer bits and 1 fractional bit, and U4.8
    indicates an unsigned value with 4 integer bits and 8 fractional bits.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-4](#tab10-4)中的标题使用了修改版的 *Q 表示法*，这是一种指定二进制定点数格式参数的方法。例如，在 Q 表示法中，Q1.2
    表示 1 位用于数字的整数部分，2 位用于小数部分。标准 Q 表示法假设值是带符号的；然而，在 FPGA 中，使用无符号和带符号值是非常常见的。这就是为什么我更喜欢使用带有前导字符的表示法来指定值是否为带符号（S）或无符号（U）。因此，S3.1
    表示一个带符号值，其中 3 个比特用于整数部分，1 个比特用于小数部分，U4.8 表示一个无符号值，其中 4 个比特用于整数部分，8 个比特用于小数部分。'
- en: In [Table 10-4](#tab10-4), the U3.0 column is what we’re used to; all 3 bits
    are allotted to the integer portion of the number, so we only have whole numbers.
    Let’s consider the next column, U2.1\. It’s unsigned, with 2 bits for the integer
    component and 1 bit for the decimal component. This means the integer part can
    be in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>, and the decimal part
    can be in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. To figure out what possible
    values that represents, simply take the original U3.0 value and divide it by 2\.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> is 7 in
    U3.0, but in U2.1 it’s 3.5 (7 / 2 = 3.5). In general, when there are *N* bits
    allotted to the fractional portion of the number, you divide the integer representation
    by 2*^N* to determine the fixed-point value. Thus, <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    in U0.3 is 7 / 2³ = 7 / 8 = 0.875.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 10-4](#tab10-4)中，U3.0列是我们熟悉的；所有 3 个比特分配给数字的整数部分，因此我们只有整数。接下来考虑下一列 U2.1\。它是无符号的，其中
    2 个比特用于整数部分，1 个比特用于小数部分。这意味着整数部分的取值范围可以是 <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">11</samp>，小数部分的取值范围可以是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。为了找出这些值的可能性，只需将原始的 U3.0
    值除以 2。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> 在 U3.0 中是 7，但在
    U2.1 中是 3.5（7 / 2 = 3.5）。一般来说，当有 *N* 个比特分配给数字的小数部分时，你将整数表示除以 2*^N* 来确定定点值。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">111</samp> 在 U0.3 中是 7 / 2³ = 7 / 8 =
    0.875。
- en: In [Table 10-4](#tab10-4) we treated all the values as unsigned. [Table 10-5](#tab10-5)
    shows the most common possibilities for interpreting the same 3 bits when we use
    signed data types.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 10-4](#tab10-4)中，我们将所有值都视为无符号的。[表 10-5](#tab10-5)显示了在使用带符号数据类型时解释相同 3 个比特的最常见方式。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-5:</samp> <samp class="SANS_Futura_Std_Book_11">3-Bit
    Signed Fixed-Point Possibilities</samp>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-5：</samp> <samp class="SANS_Futura_Std_Book_11">3
    位符号定点数可能性</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">S3.0</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">S2.1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">S1.2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">S0.3</samp> |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">位</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">S3.0</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">S2.1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">S1.2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">S0.3</samp> |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.125</samp> |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.125</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.0</samp> | <samp class="SANS_Futura_Std_Book_11">0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.250</samp> |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.0</samp> | <samp class="SANS_Futura_Std_Book_11">0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.250</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.375</samp> |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.375</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">–4</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2.0</samp> | <samp class="SANS_Futura_Std_Book_11">–1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.500</samp> |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">–4</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2.0</samp> | <samp class="SANS_Futura_Std_Book_11">–1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.500</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1.5</samp> | <samp class="SANS_Futura_Std_Book_11">–0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.375</samp> |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1.5</samp> | <samp class="SANS_Futura_Std_Book_11">–0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.375</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">–2</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1.0</samp> | <samp class="SANS_Futura_Std_Book_11">–0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.250</samp> |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">–2</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1.0</samp> | <samp class="SANS_Futura_Std_Book_11">–0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.250</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">–</samp><samp
    class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">–0.5</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.25</samp> | <samp class="SANS_Futura_Std_Book_11">–0.125</samp>
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">–</samp><samp
    class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">–0.5</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.25</samp> | <samp class="SANS_Futura_Std_Book_11">–0.125</samp>
    |'
- en: The S3.0 column shows the same signed whole number values we saw earlier in
    the chapter, in [Table 10-1](#tab10-1). We can generate the remaining columns
    by dividing the values in the S3.0 column by 2 for S2.1, by 4 for S1.2, and by
    8 for S0.3.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: S3.0 列显示了我们在本章早些时候看到的相同符号的整数值，参见[表 10-1](#tab10-1)。我们可以通过将 S3.0 列中的值分别除以 2 得到
    S2.1，除以 4 得到 S1.2，除以 8 得到 S0.3。
- en: 'Here’s the critical thing about working with fixed-point numbers: when you’re
    performing operations on binary data, the behavior of the binary operation doesn’t
    change based on its representation. Addition, subtraction, multiplication, and
    division all work exactly the same way as before, when we were treating the numbers
    as integers. However, there are a few more rules that need to be established to
    get the correct answer with fixed-point values.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关于处理定点数的关键点是：当你对二进制数据进行操作时，二进制操作的行为不会因其表示形式而改变。加法、减法、乘法和除法的工作方式与之前将数字视为整数时完全相同。然而，要获得定点值的正确答案，仍然需要建立一些额外的规则。
- en: You’ll notice for the remainder of this chapter that I make an effort to keep
    track of the decimals in the code examples. I find it very helpful to add comments
    recording the width of the math operations in my Verilog or VHDL code. For example,
    when adding two 3-bit numbers together to get a 4-bit result, I’ll include a comment
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">// U2.1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U2.1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U3.1</samp> so I know the decimal
    and integer widths. This is particularly useful when there are several math operations
    chained one after another, where the widths along the way might be changing.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在本章剩余部分，我尽量跟踪代码示例中的小数位。我发现，在我的 Verilog 或 VHDL 代码中添加注释记录数学操作的小数位宽非常有帮助。例如，当将两个
    3 位数相加得到一个 4 位结果时，我会加上类似 <samp class="SANS_TheSansMonoCd_W5Regular_11">// U2.1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">U2.1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">U3.1</samp>
    的注释，这样我就知道小数位和整数位的宽度。这在进行多个数学操作并且操作过程中宽度可能发生变化时特别有用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding and Subtracting
    with Fixed Point</samp>
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定点加法和减法</samp>
- en: 'When performing addition or subtraction with fixed-point decimals, the actual
    process doesn’t change. The data is still just binary. There’s another rule that
    we must apply when we have decimals involved, however:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行带有定点小数的加法或减法时，实际过程并不会改变。数据仍然是二进制的。然而，在涉及小数时，我们必须应用另一条规则：
- en: '**Rule #5** When adding or subtracting, the decimal widths must match.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #5** 在进行加法或减法时，小数位数必须匹配。'
- en: 'The number of places to the right of the decimal point determines the value,
    or *weight*, of each bit, so if you try to add or subtract two inputs with different
    decimal bit widths—for example, a U3.1 input and a U4.0 input—you’ll get a wrong
    answer. We can see that in the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 小数点右侧的位数决定了每个位的值或*权重*，所以如果你尝试将两个具有不同小数位宽的输入相加或相减——例如，一个是 U3.1 输入，一个是 U4.0 输入——你会得到错误的答案。我们可以在下面的代码中看到这一点：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE41]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE42]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here’s the output:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE43]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex20</samp> shows the effect
    of not obeying Rule #5\. Here we’re attempting to add a U3.1 to a U4.0\. This
    is going to cause a problem because the weight of the bits being added together
    isn’t matched. Indeed, the printout tells us that 1.5 + 3 = 3, so something has
    clearly gone wrong.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex20</samp> 显示了不遵守规则 #5 的效果。在这里，我们试图将一个
    U3.1 加到一个 U4.0 上。这将导致问题，因为被加在一起的位的权重没有匹配。事实上，打印输出告诉我们 1.5 + 3 = 3，所以显然出了问题。'
- en: Notice that we’ve divided the input U3.1 and the output U5.1 by 2.0 to print
    out these fixed-point values correctly ❶. For Verilog, we can simply do the division
    on the unsigned input and use <samp class="SANS_TheSansMonoCd_W5Regular_11">%f</samp>
    to format the result like a float. In VHDL, the conversion is a bit more complicated.
    First we need to switch to the <samp class="SANS_TheSansMonoCd_W5Regular_11">real</samp>
    data type, which is used for numbers with decimals, and then we can divide by
    2.0 for printing.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经将输入U3.1和输出U5.1除以2.0，以正确打印这些定点值❶。对于Verilog，我们可以简单地对无符号输入进行除法，并使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">%f</samp>格式化结果为浮点数。在VHDL中，转换要复杂一些。首先，我们需要切换到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">real</samp>数据类型，它用于带小数的数字，然后我们就可以除以2.0来进行打印。
- en: 'To fix this example, we need to adjust one of the inputs so it has the same
    number of decimal bits as the other input. We can either change the first input
    from U3.1 to U4.0 to match the second input, or change the second input from U4.0
    to U4.1\. In the following code, we try both options:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这个例子，我们需要调整其中一个输入，使其与另一个输入具有相同的小数位数。我们可以将第一个输入从U3.1改为U4.0，以匹配第二个输入，或者将第二个输入从U4.0改为U4.1。以下代码尝试了这两种选项：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here’s the output:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE47]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE48]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex21</samp>, we convert the
    U3.1 to a U4.0, effectively dropping the decimal point. We do this using a 1-bit
    shift to the right ❶. But consider the effect of this: we’re eliminating the least
    significant bit, and if that bit has a 1 in it, then we’re dropping that data.
    Essentially, we’re performing a rounding operation to the next lowest integer.
    We can see that our first input was originally 1.5, but after dropping the decimal
    point it’s 1.0\. The math is correct, 1.0 + 3.0 = 4.0, but we’ve truncated our
    input.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex21</samp>中，我们将U3.1转换为U4.0，实质上丢弃了小数点。我们通过将位移1位到右来实现这一点❶。但是考虑这个操作的影响：我们正在去掉最不重要的位，如果该位是1，那么我们就丢失了这部分数据。实际上，我们正在执行向下取整的舍入操作。我们可以看到，输入最初是1.5，但去掉小数点后变为1.0。数学上是正确的，1.0
    + 3.0 = 4.0，但我们已经截断了输入。
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex22</samp> shows a better solution
    that retains the precision of all inputs. Rather than shifting the first input
    to the right, we shift the second input to the left ❷. This pads the least significant
    bit with a 0, converting our second input from U4.0 to U4.1\. Notice that this
    means the second input now occupies a total of 5 bits. We need to be sure to resize
    it, or we could end up losing the data in the most significant bit during the
    shift left. Additionally, our output now has to be 6 bits so we don’t violate
    Rule #1.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex22</samp>展示了一个更好的解决方案，它保持了所有输入的精度。我们不是将第一个输入向右移，而是将第二个输入向左移❷。这样填充了最不重要的位为0，将第二个输入从U4.0转换为U4.1。注意，这意味着第二个输入现在占用了总共5个位。我们需要确保对其进行调整，否则在向左移位的过程中可能会丢失最重要位的数据。此外，我们的输出现在必须是6个位，以确保不违反规则#1。
- en: Now that the decimal widths of the two inputs are matched with no loss of precision,
    we’re able to successfully calculate that 1.5 + 3.0 = 4.5\. Expanding your inputs
    to match is the best solution if you don’t want to round any of the decimal values.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于两个输入的小数宽度已经匹配且没有丢失精度，我们可以成功地计算出1.5 + 3.0 = 4.5。如果你不想舍去任何小数值，扩展输入使其匹配是最好的解决方案。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Subtracting fixed-point numbers works with all the same rules as addition,
    so we won’t consider an example here. Follow the rules introduced in this chapter,
    and your subtraction operations will work as expected.*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*减法操作的定点数遵循与加法相同的规则，因此我们在这里不考虑具体示例。遵循本章介绍的规则，你的减法操作将按预期工作。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplying with
    Fixed Point</samp>
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定点数乘法</samp>
- en: 'Multiplication with fixed-point numbers doesn’t require any shifting to match
    the decimal widths. Instead, we can simply multiply the two inputs together as
    they are, provided we keep track of the input widths and size the output appropriately.
    We already have a rule for multiplication:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定点数进行乘法运算不需要进行移位以匹配小数位宽。相反，只要我们跟踪输入宽度并适当调整输出宽度，就可以直接将两个输入相乘。我们已经有了一个关于乘法的规则：
- en: '**Rule #4** When multiplying, the output bit width must be at least the sum
    of the input bit widths (before sign extension).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #4** 进行乘法运算时，输出位宽必须至少是输入位宽的总和（符号扩展前）。'
- en: 'Now we need to add another rule to account for fixed-point numbers:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加另一个规则来处理定点数：
- en: '**Rule #6** When multiplying fixed-point numbers, add the integer component
    bit widths and the decimal component bit widths of your inputs separately to get
    the output format.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #6** 进行定点数乘法时，分别将输入的整数部分位宽和小数部分位宽相加，以确定输出格式。'
- en: 'For example, if you’re trying to multiply a U3.5 by a U1.7, the result is formatted
    as a U4.12\. We determine this by adding the integer components (3 + 1 = 4) and
    the decimal components (5 + 7 = 12), and putting them together to get the output
    width format. It works the same way for signed values, so S3.0 × S2.4 = S5.4\.
    Notice that we’re still obeying Rule #4 as well, since the output width will be
    the sum of the input widths. It’s just that the integer and decimal components
    are treated separately.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，如果你试图将一个 U3.5 乘以一个 U1.7，结果格式为 U4.12。我们通过将整数部分（3 + 1 = 4）和小数部分（5 + 7 = 12）相加来确定输出宽度格式。对于带符号值，处理方法相同，所以
    S3.0 × S2.4 = S5.4。请注意，我们仍然遵循规则 #4，因为输出宽度将是输入宽度的总和。只是整数部分和小数部分会分别处理。'
- en: 'Let’s take a look at some examples in Verilog and VHDL:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些 Verilog 和 VHDL 的示例：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE49]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE50]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here’s the output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex23</samp>, we’re multiplying
    a U2.2 by a U3.1 to get a result that’s a U5.3\. We can see in the printout that
    the answer is correct: 1.25 × 5.5 = 6.875\. As with the addition examples, notice
    that we have to divide the values to print them out correctly. We divide the U2.2
    by 4, the U3.1 by 2, and the U5.3 by 8\. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex24</samp>,
    we use the same technique to multiply signed values. We’re multiplying 1.5 by
    –6.0 to get –9.0, which is represented with S2.2 × S4.0 = S6.2.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex23</samp> 中，我们将一个 U2.2 乘以一个
    U3.1，得到一个结果为 U5.3。我们可以从打印输出中看到，答案是正确的：1.25 × 5.5 = 6.875。与加法示例一样，请注意，我们必须先将值进行除法运算才能正确打印它们。我们将
    U2.2 除以 4，U3.1 除以 2，U5.3 除以 8。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex24</samp>
    中，我们使用相同的技术来进行带符号数的乘法运算。我们将 1.5 乘以 -6.0，得到 -9.0，表示为 S2.2 × S4.0 = S6.2。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: Since FPGAs are known for being able to perform many calculations at fast clock
    rates and in parallel, many common FPGA applications call for using addition,
    subtraction, multiplication, and division. Inside your FPGA, these operations
    may involve LUTs, shift registers, or DSP blocks. More important than knowing
    exactly how the operations are implemented, however, is understanding how the
    inputs and outputs are stored and what those binary digits represent when you’re
    writing your Verilog or VHDL code. Are they signed or unsigned? Integers or fixed
    point?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 FPGA 以其能够在快速时钟频率和并行处理下执行大量计算而闻名，许多常见的 FPGA 应用都需要进行加法、减法、乘法和除法运算。在你的 FPGA
    中，这些操作可能涉及查找表（LUT）、移位寄存器或 DSP 模块。然而，比知道操作是如何实现的更重要的是理解输入和输出是如何存储的，以及在编写 Verilog
    或 VHDL 代码时，这些二进制数字代表的含义。它们是带符号的还是无符号的？整数还是定点数？
- en: 'Over the course of this chapter, we’ve developed a set of rules for successfully
    performing FPGA math operations and interpreting the results. They are:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经制定了一套规则，用于成功执行 FPGA 数学运算并解释结果。它们是：
- en: '**Rule #1** When adding or subtracting, the result should be at least 1 bit
    bigger than the biggest input, before sign extension. Once sign extension is applied,
    the input and output widths should match exactly.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #1** 在进行加法或减法时，结果的位宽应该比最大的输入宽度大至少 1 位，且在进行符号扩展之前。符号扩展应用后，输入和输出的位宽应该完全匹配。'
- en: '**Rule #2** Match types among inputs and outputs.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #2** 输入和输出之间的类型必须匹配。'
- en: '**Rule #3** When subtracting, use signed inputs and outputs.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #3** 在进行减法时，使用带符号的输入和输出。'
- en: '**Rule #4** When multiplying, the output bit width must be at least the sum
    of the input bit widths (before sign extension).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #4** 在进行乘法运算时，输出的位宽必须至少是输入位宽的总和（在符号扩展之前）。'
- en: '**Rule #5** When adding or subtracting, the decimal widths must match.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #5** 在进行加法或减法时，小数位宽必须匹配。'
- en: '**Rule #6** When multiplying fixed-point numbers, add the integer component
    bit widths and the decimal component bit widths of your inputs separately to get
    the output format.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #6** 在进行定点数乘法时，分别将输入的整数部分位宽和小数部分位宽相加，得到输出格式。'
- en: These rules don’t capture every nuance of performing math in FPGAs, but they
    cover the major details that you need to get right. If you follow these six rules,
    it’s much more likely that you’ll get the correct answer from your calculations.
    Whenever you’re working with math, adding tests will help to ensure things are
    working as you expect.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则并没有涵盖 FPGA 中数学运算的所有细节，但它们涵盖了你需要正确处理的主要细节。如果你遵循这六条规则，你的计算结果更有可能是正确的。每当你进行数学运算时，添加测试将帮助确保一切按预期工作。
