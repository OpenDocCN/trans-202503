- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: CREATING A SERVER INVENTORY SCRIPT
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务器清单脚本
- en: '![Images](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/common.jpg)'
- en: So far in this book, you’ve focused on learning PowerShell as a language, getting
    familiar with its syntax and commands. But more than a language, PowerShell is
    a tool. Now that you have a grip on the ins and outs of PowerShell, it’s time
    for the fun stuff!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，你已经专注于学习 PowerShell 作为一种语言，熟悉其语法和命令。但 PowerShell 不仅仅是一个语言，它还是一个工具。既然你已经掌握了
    PowerShell 的基本知识，现在是时候进行更有趣的部分了！
- en: The real power of PowerShell lies in its tool-making abilities. In this context,
    a *tool* refers to a PowerShell script, a module, a function, or something that
    helps you perform a management task. Whether that task is creating a report, gathering
    information about a computer, creating a company user account, or something more
    complex, you’ll learn how to automate it with PowerShell.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的真正力量在于它的工具制作能力。在这个上下文中，*工具*指的是一个 PowerShell 脚本、一个模块、一个函数或任何有助于你执行管理任务的东西。无论任务是创建报告、收集计算机信息、创建公司用户账户，还是更复杂的任务，你都将学习如何使用
    PowerShell 自动化这些任务。
- en: 'In this chapter, I’ll show you how to collect data with PowerShell so you can
    make more-informed decisions. Specifically, you’ll build a server inventory project.
    You’ll learn to create a script with parameters, feed it server names, and discover
    a wealth of information to peruse: operating system specs as well as hardware
    information including storage size, free storage, memory, and more.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向你展示如何使用 PowerShell 收集数据，以便做出更明智的决策。具体来说，你将构建一个服务器清单项目。你将学习如何创建一个带有参数的脚本，输入服务器名称，并发现大量的信息供你浏览：操作系统规格以及硬件信息，包括存储大小、空闲存储、内存等。
- en: Prerequisites
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 先决条件
- en: Before you begin this chapter, you need to have a domain-joined Windows computer,
    read permission to Active Directory computer objects, an Active Directory organizational
    unit (OU) of computer accounts, and the Remote Server Administration Toolkit (RSAT)
    software package, which you can download from [*https://www.microsoft.com/en-us/download/details.aspx?id=45520*](https://www.microsoft.com/en-us/download/details.aspx?id=45520).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，你需要一台已加入域的 Windows 计算机、对 Active Directory 计算机对象的读取权限、一个包含计算机账户的 Active
    Directory 组织单位（OU），以及可以从 [*https://www.microsoft.com/en-us/download/details.aspx?id=45520*](https://www.microsoft.com/en-us/download/details.aspx?id=45520)
    下载的远程服务器管理工具包（RSAT）。
- en: Creating the Project Script(s)
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建项目脚本
- en: Since you’ll be building scripts in this chapter and not just executing code
    at the console, you first need to create a new PowerShell script. Create a script
    called *Get-ServerInformation.ps1*. I’ve put mine in *C:\*. You’ll be adding code
    to this script throughout the chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将在本章中构建脚本，而不仅仅是在控制台中执行代码，首先你需要创建一个新的 PowerShell 脚本。创建一个名为 *Get-ServerInformation.ps1*
    的脚本。我把我的脚本放在 *C:\* 目录下。你将在本章中不断地往这个脚本中添加代码。
- en: Defining the Final Output
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义最终输出
- en: Before you start coding, it’s good practice to make a “back of the napkin” plan
    of what you want the output to look like when you’re done. This simple sketch
    is a great way to measure progress, especially when building large scripts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写代码之前，制定一个“草图”计划，确定完成后输出应该是什么样子，这是一个良好的实践。这个简单的草图是衡量进度的一个好方法，尤其是在构建大型脚本时。
- en: 'For this server inventory script, we’ll say that when the script ends, you’d
    like output to the PowerShell console that looks like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个服务器清单脚本，我们假设在脚本结束时，你希望在 PowerShell 控制台中看到如下输出：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that you know what you want to see, let’s make it happen.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道你想看到的内容，让我们开始实现它。
- en: Discovery and Script Input
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现与脚本输入
- en: The first step is deciding how to tell your script what to query. You’ll be
    collecting information from multiple servers. As stated in the “Prerequisites”
    section, you’ll use Active Directory to find your server names.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是决定如何告诉你的脚本查询内容。你将从多个服务器收集信息。如在“先决条件”部分所述，你将使用 Active Directory 来查找服务器名称。
- en: Of course, you could query server names from text files, from an array of server
    names stored in a PowerShell script, from the Registry, from a Windows Management
    Instrumentation (WMI) repository, from databases—it doesn’t matter. As long as
    somehow, some way, your script ends up with an array of strings representing server
    names, you’re good to go. For this project, however, you’ll use servers from Active
    Directory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以从文本文件中查询服务器名称，从存储在 PowerShell 脚本中的服务器名称数组中查询，从注册表中查询，从 Windows 管理工具 (WMI)
    库中查询，或者从数据库中查询——这都没关系。只要你的脚本最终获得一个表示服务器名称的字符串数组，你就可以继续进行。不过，在这个项目中，你将使用来自 Active
    Directory 的服务器。
- en: In this example, all the servers are in a single OU. If you try this on your
    own and you find that they’re not, that’s okay; you’ll just have to loop through
    your OUs and read the computer objects in each. But here, your first task is reading
    all the computer objects in the OU. In this environment, all the servers are in
    the `Servers` OU. Your domain is called `powerlab.local`. To retrieve computer
    objects from AD, use the `Get-ADComputer` command, as shown in [Listing 14-1](ch14.xhtml#ch14list1).
    This command should return all the AD computer objects for the servers you’re
    interested in.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，所有的服务器都位于同一个OU。如果你自己尝试时发现它们不在同一个OU中，也没关系；你只需要遍历你的OU，并读取每个OU中的计算机对象即可。但在这里，你的第一个任务是读取OU中的所有计算机对象。在这个环境中，所有的服务器都位于`Servers`
    OU。你的域名是`powerlab.local`。要从AD中检索计算机对象，使用`Get-ADComputer`命令，如[Listing 14-1](ch14.xhtml#ch14list1)所示。这个命令应该会返回你感兴趣的所有AD计算机对象。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 14-1: Using `Get-AdComputer` to return server data*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-1：使用`Get-AdComputer`返回服务器数据*'
- en: Notice that instead of directly setting the `SearchBase` parameter argument,
    you define a variable. You should get used to doing this. In fact, every time
    you have a specific configuration like this, it’s always a good idea to put it
    into a variable, because you never know when you’ll need to use that value again.
    You also return the output of `Get-ADComputer` to a variable. Since you’ll be
    working with these servers later, you want to have the names to reference.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里你不是直接设置`SearchBase`参数的值，而是定义了一个变量。你应该习惯这样做。事实上，每当你遇到类似的具体配置时，把它放到一个变量中总是一个好主意，因为你永远不知道什么时候你还需要再次使用这个值。你还将`Get-ADComputer`的输出返回到一个变量中。由于你稍后还会处理这些服务器，因此你希望能够引用它们的名称。
- en: 'The `Get-ADComputer` command returns the whole AD objects, but you’re looking
    for just the server names. You can narrow this down by using `Select-Object` to
    return only the `Name` property:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-ADComputer`命令返回的是整个AD对象，但你只需要服务器名称。你可以通过使用`Select-Object`来缩小范围，仅返回`Name`属性：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that you have a basic idea of how to query an individual server, let’s look
    at how to query all of them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了查询单个服务器的基本思路，让我们来看一下如何查询所有服务器。
- en: Querying Each Server
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询每台服务器
- en: To query each server, you need to make a loop that’ll make it possible to query
    every server in your array exactly once.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询每台服务器，你需要创建一个循环，这样可以确保每台服务器在你的数组中只被查询一次。
- en: 'It’s never a good idea to assume that your code will work immediately (it usually
    doesn’t). Instead, I like to start slow and test each piece as I’m building it.
    In this case, instead of trying to do everything in one go, use `Write-Host` to
    ensure that the script is returning the server names you expect:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的代码会立即工作通常并不是一个好主意（它通常不会）。相反，我喜欢在构建过程中慢慢进行，并在每个步骤中进行测试。在这种情况下，不要尝试一次性完成所有任务，而是使用`Write-Host`确保脚本返回你预期的服务器名称：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By now, you should have a script called *Get-ServerInformation.ps1* that looks
    like [Listing 14-2](ch14.xhtml#ch14list2).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经有了一个名为*Get-ServerInformation.ps1*的脚本，内容如[Listing 14-2](ch14.xhtml#ch14list2)所示。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 14-2: Your script so far*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-2：到目前为止你的脚本*'
- en: 'Once you run the script, you get a few server names. Your output may look different,
    depending on which servers you used:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行脚本，你将获得一些服务器名称。根据你使用的服务器不同，输出可能会有所不同：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great! You have a loop setup that iterates over each server name in your array.
    Your first task is complete.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！你已经设置了一个循环，它会遍历你数组中的每个服务器名称。你的第一个任务已经完成。
- en: 'Thinking Ahead: Combining Different Types of Information'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提前思考：结合不同类型的信息
- en: 'One of the keys to success with PowerShell is good planning and organization.
    Part of this is knowing what to expect. For many beginners, who don’t have much
    experience with the kinds of results PowerShell will give, this is a problem:
    they know what they want to happen (hopefully), but they don’t know what *could*
    happen. As a result, they create scripts that zigzag among data sources, getting
    data from one, and then the other, and then the first, and then the third, linking
    them all together, and doing it all again. There are easier ways to do things,
    and I would be doing you a disservice if I didn’t pause to explain them.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell成功的关键之一是良好的规划和组织。部分内容就是了解预期结果。对于许多初学者来说，他们没有太多关于PowerShell可能返回的结果的经验，这是一个问题：他们知道自己希望发生什么（希望如此），但他们不知道*可能*发生什么。因此，他们编写的脚本会在数据源之间“之”字形地穿梭，从一个获取数据，再到另一个，接着是第一个，然后是第三个，将它们连接起来，再做一遍。其实有更简单的方式，我如果不暂停来解释这些，反而会对你造成不利影响。
- en: Looking at the output in [Listing 14-1](ch14.xhtml#ch14list1), you can see that
    you’ll need a few commands to pull information from various sources (WMI, the
    filesystem, Windows services). Each source will return a different kind of object,
    and you’ll have an absolute mess if you try to combine them thoughtlessly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[Listing 14-1](ch14.xhtml#ch14list1)中的输出，你可以看到，你将需要一些命令来从不同的来源提取信息（WMI、文件系统、Windows服务）。每个来源将返回不同类型的对象，如果你不加思考地将它们合并，你会得到一团糟。
- en: 'Jumping ahead a little, let’s get a glimpse of what the output would look like
    if you tried to pull the service name and memory without any formatting or output
    attention. You might get something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微提前一点，让我们看一下，如果你尝试在没有任何格式化或输出关注的情况下提取服务名称和内存，输出会是什么样子。你可能会看到类似这样的内容：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you’re querying a service and trying to get memory from a server at the
    same time. The objects are different, the properties on those objects are different,
    and if you merge all the output and dump it, it looks terrible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在查询一个服务，并同时尝试从服务器获取内存。这些对象不同，这些对象上的属性也不同，如果你将所有输出合并并直接输出，看起来会很糟糕。
- en: Let’s see how to avoid this kind of output. Since you’ll be combining different
    kinds of output, and you need something that fits our exact specifications, you
    have to create your own type of output. Don’t worry, this isn’t as complicated
    as you might think. In [Chapter 2](ch02.xhtml#ch2), you learned how to create
    `PSCustomObject` types. These generic objects in PowerShell allow you to add your
    own properties—perfect for what you’re doing here.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何避免这种输出。由于你将组合不同类型的输出，并且你需要符合我们确切规范的内容，因此你必须创建自己类型的输出。别担心，这不像你想象的那么复杂。在[第2章](ch02.xhtml#ch2)中，你学会了如何创建`PSCustomObject`类型。PowerShell中的这些通用对象允许你添加自己的属性—非常适合你在这里做的事情。
- en: 'You know the headers of the output you need (and, as I’m sure you know by now,
    these “headers” will always be object properties). Let’s create a custom object
    with the properties you’d like to see in the output. For obvious reasons, I’ve
    called this object `$output`; you’ll return it after you populate its properties:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道所需输出的标题（并且，正如我相信你现在已经知道的，这些“标题”将始终是对象属性）。让我们创建一个自定义对象，并将你希望在输出中看到的属性放进去。出于明显的原因，我将这个对象命名为`$output`；你在填充它的属性后将返回它：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll notice that the hashtable keys are surrounded by single quotes. This
    isn’t mandatory if there’s no space in the key. However, because I am using spaces
    in some key names, I decided to standardize on single quotes across all of the
    keys. It’s generally not recommended to use spaces in object property names in
    lieu of using custom formatting, but that is outside the scope of this book. For
    more information on custom formatting, refer to the *about_Format.ps1xml* help
    topic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到哈希表的键被单引号包围。如果键中没有空格，这是不强制的。然而，由于我在一些键名中使用了空格，我决定在所有键上统一使用单引号。通常不推荐在对象属性名称中使用空格，除非使用自定义格式化，但这超出了本书的范围。有关自定义格式化的更多信息，请参阅*about_Format.ps1xml*帮助主题。
- en: 'If you copy this to the console, and return it with the formatting cmdlet,
    `Format-Table`, you can see the headers you’re looking for:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其复制到控制台，并通过格式化命令`Format-Table`返回它，你将看到你所需要的标题：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Format-Table` command is one of a few format commands in PowerShell that
    are meant to be used as the last command in the pipeline. They transform current
    output and display it differently. In this instance, you’re telling PowerShell
    to transform your object output into a table format and autosize the rows based
    on the width of the console.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Format-Table`命令是PowerShell中少数几个格式化命令之一，旨在作为管道中的最后一个命令使用。它们会转换当前的输出并以不同的方式显示它。在这种情况下，你正在告诉PowerShell将对象输出转换为表格格式，并根据控制台的宽度自动调整行的大小。'
- en: Once you define your custom output object, you can go back to your loop and
    make sure each server is returned in this format. Since you already know the server
    name, you can set that property right away, as in [Listing 14-3](ch14.xhtml#ch14list3).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了自定义输出对象，你可以返回到循环中，确保每个服务器都以这种格式返回。由于你已经知道服务器名称，可以立即设置该属性，如[Listing 14-3](ch14.xhtml#ch14list3)所示。
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 14-3: Putting your `output` object in your loop and setting the server
    name*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-3: 将你的`output`对象放入循环中并设置服务器名称*'
- en: Notice that you created `output` as a hashtable and cast it as a `PSCustomObject`
    only after you filled it with data. You do this because it’s simpler to keep the
    property values in a hashtable than in a `PSCustomObject`; you care about `output`
    being an object of that type only when it’s being output so that when you bring
    in other sources of information, they will all be the same object type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你在填充数据后才将 `output` 创建为哈希表并将其转换为 `PSCustomObject`。之所以这样做，是因为将属性值保存在哈希表中比保存在
    `PSCustomObject` 中更简单；你只有在输出时才关心 `output` 是该类型的对象，以便当你引入其他信息源时，它们都将是相同的对象类型。
- en: 'You can see all the property names that your `PSCustomObject` has, along with
    the names of the servers you’re querying, with this code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下代码查看你的 `PSCustomObject` 所有属性的名称，以及你正在查询的服务器名称：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, you have data. It may not seem like much, but you’re well on
    your way!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你已经有了数据。它可能看起来不多，但你已经走在了正确的道路上！
- en: Querying Remote Files
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询远程文件
- en: Now that you know how you’re going to store your data, you just need to get
    it. This means pulling the information you need from each server and returning
    only the properties you care about. Let’s start with the value for `UserProfileSize`
    (MB). To do this, let’s figure out a way to find out how much space is being consumed
    by all these profiles located in the *C:\Users* folder on each server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何存储数据，接下来只需要获取数据。这意味着需要从每个服务器中提取所需的信息，并仅返回你关心的属性。让我们从 `UserProfileSize`（MB）的值开始。为此，让我们想办法找出每个服务器的
    *C:\Users* 文件夹中所有这些配置文件占用了多少空间。
- en: Because of the way you set up the loop, you need to figure out how to do this
    for only one server. Since you know the folder path is *C:\Users*, let’s first
    see if you can query all the files under all the server’s user profile folders.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你设置了循环的方式，你需要弄清楚如何仅为一个服务器执行此操作。既然你知道文件夹路径是 *C:\Users*，那么让我们先看看你是否能查询到所有服务器的用户配置文件夹下的所有文件。
- en: 'When you run `Get-ChildItem -Path \\WEBSRV1\c$\Users -Recurse -File` and have
    access to that file share, you can immediately see it’s returning all the files
    and folders in all user profiles, but you don’t see anything related to size.
    Let’s pipe the output to `Select-Object` to return all properties:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `Get-ChildItem -Path \\WEBSRV1\c$\Users -Recurse -File` 并且有权限访问该文件共享时，你会看到它返回了所有用户配置文件中的所有文件和文件夹，但没有看到任何与大小相关的信息。让我们将输出通过管道传递给
    `Select-Object`，以返回所有属性：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Length` property shows how large the file is in bytes. Knowing this, you’ll
    have to figure out how to add up the `Length` values of each file in the server’s
    *C:\Users* folder. Luckily, PowerShell makes this easy with one of its cmdlets:
    `Measure-Object`. This cmdlet accepts input from the pipeline and automatically
    adds up the values of a specific property:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Length` 属性显示文件的大小（以字节为单位）。知道这一点后，你需要计算服务器 *C:\Users* 文件夹中每个文件的 `Length` 值的总和。幸运的是，PowerShell
    通过其中一个 cmdlet `Measure-Object` 使这一过程变得简单。这个 cmdlet 接受来自管道的输入，并自动将特定属性的值加总起来：'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You now have a property (`Sum`) that you can use to represent the total user
    profile size in your output. At this point, it’s just a matter of incorporating
    the code into your loop and setting the appropriate property in your `$output`
    hashtable. Since you need only the `Sum` property from the object returned by
    `Measure-Object`, you’ll enclose the command in parentheses and reference the
    `Sum` property as in [Listing 14-4](ch14.xhtml#ch14list4).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个属性（`Sum`），可以用来表示输出中总的用户配置文件大小。此时，只需将代码整合到循环中，并在 `$output` 哈希表中设置适当的属性。由于你只需要从
    `Measure-Object` 返回的对象中获取 `Sum` 属性，因此你会将命令括在括号中，并像 [清单 14-4](ch14.xhtml#ch14list4)
    中那样引用 `Sum` 属性。
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 14-4: Updating your script to store `UserProfilesSize`*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-4：更新脚本以存储 `UserProfilesSize`*'
- en: 'If you run the script, you get the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行该脚本，结果如下：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, you now have the total size of the user profiles—but it’s not
    in megabytes. You calculated the sum of `Length`, and `Length` is in bytes. PowerShell
    makes conversions like this easy: if you simply divide the number by `1MB`, you’ll
    have your number. You might see the resulting values represented with decimal
    points. You can take a final step and ensure that you have a whole number by casting
    the output to an integer, which will “round” the number to a whole megabyte value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你现在得到了用户配置文件的总大小——但它还不是以兆字节为单位。你计算了 `Length` 的总和，而 `Length` 是以字节为单位的。PowerShell
    使得这种转换变得简单：只需将数字除以 `1MB`，就可以得到结果。你可能会看到结果以小数点形式表示。你可以采取最后一步，将输出转换为整数，以确保你得到的是一个整数，这样就可以将数字“四舍五入”到一个完整的兆字节值：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Querying Windows Management Instrumentation
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询Windows管理工具
- en: You have five more values to fill. For four of them, you’ll use a built-in Microsoft
    feature called *Windows Management Instrumentation (WMI)*. Based on the industry
    standard Common Information Model (CIM), WMI is a repository containing real-time
    information about thousands of attributes relating to the operating system and
    the hardware it’s running on. The information is separated into various namespaces,
    classes, and properties. If you’re looking for information about a computer, chances
    are, you’ll be using WMI a lot.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有五个值需要填充。对于其中四个，你将使用一个名为*Windows管理工具（WMI）*的微软内置功能。WMI基于行业标准的通用信息模型（CIM），是一个包含与操作系统及其运行硬件相关的数千个属性的实时信息库。这些信息被分隔成不同的命名空间、类和属性。如果你正在寻找有关计算机的信息，你很可能会经常使用WMI。
- en: For this particular script, you’ll pull information about hard drive space,
    the operating system version, the server’s IP address, and the amount of memory
    the server contains.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的脚本，你将提取硬盘空间、操作系统版本、服务器的IP地址，以及服务器包含的内存量的信息。
- en: 'PowerShell has two commands to query WMI: `Get-WmiObject` and `Get-CimInstance`.
    The `Get-WmiObject` command is older and not as flexible as `Get-CimInstance`
    (if you want the technical details: this is mainly because `Get-WmiObject` uses
    only DCOM to connect to remote computers, while `Get-CimInstance`, by default,
    uses WSMAN and can optionally use DCOM as well). As of right now, Microsoft appears
    to be putting all its effort into `Get-CimInstance`, so that’s the command you’ll
    use. For a detailed breakdown of CIM versus WMI, check out this blog post: [*https://blogs.technet.microsoft.com**/heyscriptingguy/2016/02/08/should-i-use-cim-or-wmi-with-windows-powershell/*](https://blogs.technet.microsoft.com/heyscriptingguy/2016/02/08/should-i-use-cim-or-wmi-with-windows-powershell/).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell有两个命令用于查询WMI：`Get-WmiObject`和`Get-CimInstance`。`Get-WmiObject`是较旧的命令，灵活性不如`Get-CimInstance`（如果你想了解技术细节：这主要是因为`Get-WmiObject`只使用DCOM来连接远程计算机，而`Get-CimInstance`默认使用WSMAN，也可以选择使用DCOM）。目前，微软似乎将所有精力都投入到`Get-CimInstance`中，所以你将使用这个命令。关于CIM与WMI的详细对比，可以参考这篇博客：[*https://blogs.technet.microsoft.com/heyscriptingguy/2016/02/08/should-i-use-cim-or-wmi-with-windows-powershell/*](https://blogs.technet.microsoft.com/heyscriptingguy/2016/02/08/should-i-use-cim-or-wmi-with-windows-powershell/)。
- en: 'The hardest part of querying WMI is figuring out where the information you’re
    looking for is hidden. Normally, you’d do this research on your own (and I encourage
    you to try it here), but for time’s sake, let me offer you the answer sheet to
    this script: all storage resource usage is in `Win32_LogicalDisk`, information
    about the operating system is in `Win32_OperatingSystem`, Windows services are
    all represented in `Win32_Service`, any network adapter information is in `Win32_NetworkAdapterConfiguration`,
    and memory information is in `Win32_PhysicalMemory`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 查询WMI的最难部分是弄清楚你想要的信息藏在哪里。通常，你需要自己做这个研究（我鼓励你在这里尝试），但为了节省时间，让我为你提供这个脚本的答案：所有存储资源使用情况都在`Win32_LogicalDisk`中，操作系统的信息在`Win32_OperatingSystem`中，Windows服务都在`Win32_Service`中，任何网络适配器的信息都在`Win32_NetworkAdapterConfiguration`中，内存信息则在`Win32_PhysicalMemory`中。
- en: Now let’s see how to use `Get-CimInstance` to query these WMI classes for the
    properties you’re looking for.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用`Get-CimInstance`查询这些WMI类，获取你需要的属性。
- en: Disk Free Space
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 磁盘剩余空间
- en: 'Let’s start with the available hard drive space, found in `Win32_LogicalDisk`.
    As with `UserProfilesSize`, you’ll start with one server and then generalize in
    your loop. Here, you can see that you lucked out; you don’t even need to use `Select-Object`
    to dig into all the properties—`FreeSpace` is right there:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从可用的硬盘空间开始，这些信息存储在`Win32_LogicalDisk`中。像处理`UserProfilesSize`一样，你将从一台服务器开始，然后在循环中进行泛化。在这里，你很幸运；你甚至不需要使用`Select-Object`来挖掘所有的属性——`FreeSpace`就在这里：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Knowing that `Get-CimInstance` returns an object, you can simply access the
    property that you need to get only the amount of free space:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 了解到`Get-CimInstance`返回的是一个对象后，你只需访问所需的属性，就能获取到剩余空间的数值：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You have the value but, like last time, it’s in bytes (this is a common thing
    in WMI). You can do the same conversion trick as before, except now you want gigabytes
    so you’ll divide by `1GB`. When you update the script by dividing the `FreeSpace`
    property by `1GB`, you get output that looks something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经获得了数值，但是像上次一样，它是以字节为单位的（这是WMI中的常见情况）。你可以像之前一样进行转换，只不过这次你需要的是千兆字节，所以你要将其除以`1GB`。当你更新脚本，通过将`FreeSpace`属性除以`1GB`时，输出结果大概是这样：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You don’t need to see the free space out to 12 digits, so you can do a little
    rounding by using the `Round()` method on the `[Math]` class, making the output
    look much better:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要看到12位数字的空闲空间，因此可以通过使用`[Math]`类的`Round()`方法进行四舍五入，使输出看起来更好：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now the values are much easier to read. Three down, four to go.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些值更容易阅读了。三个已经完成，剩下四个。
- en: Operating System Information
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作系统信息
- en: 'By now you should see the general pattern: query a single server, find the
    appropriate property, and add the query to your `foreach` loop.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在你应该能看到一般的模式：查询单台服务器，找到合适的属性，然后将查询添加到你的`foreach`循环中。
- en: 'From now on, you’ll simply add lines to your `foreach` loop. The process of
    narrowing down the class, class property, and the property value is the same for
    any value you’ll be querying from WMI. Just follow this same general pattern:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，你只需在`foreach`循环中添加行。缩小类、类属性和属性值的过程对于你从WMI查询的任何值都是一样的。只需遵循相同的一般模式：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Adding the next value gives you a script that looks like [Listing 14-5](ch14.xhtml#ch14list5).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下一个值后，你的脚本看起来像[示例 14-5](ch14.xhtml#ch14list5)。
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 14-5: Your script updated to include a query for `OperatingSystem`*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-5：更新后的脚本，包含`OperatingSystem`查询*'
- en: 'Now run your script:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行你的脚本：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You’ve gotten some useful OS information. Let’s take the next step and figure
    out how to query some information on memory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经获得了一些有用的操作系统信息。让我们迈出下一步，看看如何查询内存信息。
- en: Memory
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内存
- en: 'Moving onto the next piece of information to gather (`Memory`), you’ll use
    the `Win32_PhysicalMemory` class. Testing your query on a single server again
    gives the information you’re looking for. In this case, the memory information
    you need is stored in `Capacity`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是收集下一条信息（`Memory`），你将使用`Win32_PhysicalMemory`类。再次在单台服务器上测试你的查询，能够获得你需要的信息。在这种情况下，你需要的内存信息存储在`Capacity`中：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each instance under `Win32_PhysicalMemory` represents a *bank* of RAM. You can
    think of a bank as a physical stick of RAM in a server. It just so happens that
    my SQLSRV1 server has only one bank of memory. However, you will undoubtedly find
    servers with many more.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Win32_PhysicalMemory`下的每个实例代表一个*内存条*。你可以把内存条看作服务器中的一根物理内存条。恰好我的SQLSRV1服务器只有一根内存条。然而，你肯定会找到有更多内存条的服务器。'
- en: Since you’re looking for total memory in a server, you’ll have to follow the
    same routine you used to get profile size. You’ll have to add up the value of
    `Capacity` across all the instances. Lucky for us, the `Measure-Object` cmdlet
    works across any number of object types. As long as the property is a number,
    it can add them all up.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你需要查询服务器的总内存，你必须按照获取配置文件大小时使用的相同步骤进行操作。你需要将所有实例中的`Capacity`值加起来。幸运的是，`Measure-Object`
    cmdlet可以跨任何数量的对象类型工作。只要属性是数字，它就能将它们加起来。
- en: 'Again, since `Capacity` was represented in bytes, you’ll convert it to the
    appropriate label:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于`Capacity`是以字节表示的，你需要将其转换为适当的标签：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see in [Listing 14-6](ch14.xhtml#ch14list6), your script grows and
    grows!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[示例 14-6](ch14.xhtml#ch14list6)中看到的，你的脚本越来越长！
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 14-6: Your script with the query for `Memory`*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-6：包含`Memory`查询的脚本*'
- en: 'Let’s look at the output so far:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看到目前为止的输出：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With that, you have only two fields left to fill!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你只剩下两个字段需要填写！
- en: Network Information
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络信息
- en: The final piece of WMI information is the IP address, which you’ll grab from
    `Win32_NetworkAdapterConfiguration`. I saved the task of finding the IP address
    for last because, unlike the other data entries, finding the IP address of the
    server isn’t as cut and dried as finding a value and then adding it to your `$output`
    hashtable. You’ll have to do some filtering to narrow it down.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项WMI信息是IP地址，它来自`Win32_NetworkAdapterConfiguration`。我把找IP地址的任务放到最后，因为与其他数据条目不同，找到服务器的IP地址不像找到一个值然后将其添加到`$output`哈希表那样简单。你需要做一些筛选操作来缩小范围。
- en: 'Let’s first see what the output looks like using the same method you’ve used
    so far:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看使用到目前为止的方法输出是什么样的：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You’ll see right away that the default output doesn’t show the IP address, not
    that that has stopped you before. But, somewhat trickier, here the command doesn’t
    return a single instance. This server has three network adapters on it. How do
    you select the one that has the IP address you’re looking for?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立刻发现默认输出不显示IP地址，不过这并没有阻止你。但是，更棘手的是，这个命令并没有返回一个实例。这个服务器上有三个网络适配器。你如何选择包含你要查找的IP地址的那个呢？
- en: 'First, you have to see all the properties by using `Select-Object`. Using `Get-CimInstance
    -ComputerName SQLSRV1 -ClassName Win32_NetworkAdapterConfiguration | Select-Object
    -Property *`, you can scroll through the (substantial) output. Depending on the
    network adapters installed on the server, you may notice fields that don’t have
    anything for the `IPAddress` property. This is common because network adapters
    do not have an IP address. However, when you do find one with an IP address bound
    to it, it should look similar to the following code, where you can see the `IPAddress`
    property ❶ has (in this instance) an IPv4 address of 192.168.0.40 and a couple
    of IPv6 addresses:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要通过使用 `Select-Object` 查看所有属性。使用 `Get-CimInstance -ComputerName SQLSRV1
    -ClassName Win32_NetworkAdapterConfiguration | Select-Object -Property *`，你可以浏览（大量的）输出。根据服务器上安装的网络适配器，你可能会注意到某些字段在
    `IPAddress` 属性上没有任何内容。这是很常见的，因为某些网络适配器没有 IP 地址。然而，当你找到绑定有 IP 地址的适配器时，它应该类似于以下代码，你可以看到
    `IPAddress` 属性 ❶ 在这个例子中有一个 IPv4 地址 192.168.0.40 和几个 IPv6 地址：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The script needs to be dynamic and support lots of network adapter configurations.
    It’s important that the script is able to handle other types of network adapters
    other than the `Microsoft Hyper-V Network Adapter` you’re working with here. You’ll
    need to find a standard criterion to filter on so that it can apply to all servers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本需要动态并支持多种网络适配器配置。确保脚本能够处理除你正在使用的 `Microsoft Hyper-V Network Adapter` 之外的其他类型的网络适配器非常重要。你需要找到一个标准的过滤标准，这样它就能适用于所有服务器。
- en: The `IPEnabled` property is the key. When this property is set to `True`, the
    TCP/IP protocol is bound to this network adapter, which is a prerequisite to having
    an IP address. If you can narrow down the NIC that has the `IPEnabled` property
    set to `True`, you’ll have the adapter you’re looking for.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPEnabled` 属性是关键。当这个属性设置为 `True` 时，TCP/IP 协议已绑定到这个网络适配器，这是拥有 IP 地址的前提。如果你能缩小到那个
    `IPEnabled` 属性设置为 `True` 的网卡，那么你就找到了你需要的适配器。'
- en: 'When filtering WMI instances, it’s always best to use the `Filter` parameter
    on `Get-CimInstance`. There’s a saying in the PowerShell community: *filter left*.
    Basically, it means that if you can, always filter output as far to the left as
    possible—meaning filter as early as possible so that you’re not sending unnecessary
    objects through the pipeline. Don’t use `Where-Object` unless you have to. The
    performance will be much faster instead if the pipeline isn’t clogged with unneeded
    objects.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在过滤 WMI 实例时，最好使用 `Get-CimInstance` 上的 `Filter` 参数。PowerShell 社区有句名言：*filter
    left*。基本意思是，如果可以的话，总是尽可能早地过滤输出——也就是说，尽早过滤，这样你就不会把不必要的对象送入管道。除非必须，否则不要使用 `Where-Object`。如果管道中没有不需要的对象，性能会更快。
- en: 'The `Filter` parameter on `Get-CimInstance` uses *Windows Query Language (WQL)*,
    which is a small subset of *Structured Query Language (SQL)*. The `Filter` parameter
    accepts the same `WHERE` clause syntax that WQL does. Take this example: if, in
    WQL, you want all the `Win32_NetworkAdapterConfiguration` class instances with
    the `IPEnabled` property set to `True`, you could use `SELECT *` `FROM Win32_NetworkAdapterConfiguration
    WHERE IPEnabled = ''True''`. Since you’re already specifying the class name for
    the `ClassName` parameter argument in `Get-CimInstance`, you need to specify `IPEnabled
    = ''True''` for `Filter`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-CimInstance` 上的 `Filter` 参数使用的是 *Windows 查询语言（WQL）*，这是 *结构化查询语言（SQL）*
    的一个子集。`Filter` 参数接受与 WQL 相同的 `WHERE` 子句语法。举个例子：如果在 WQL 中，你希望所有 `Win32_NetworkAdapterConfiguration`
    类实例的 `IPEnabled` 属性设置为 `True`，你可以使用 `SELECT *` `FROM Win32_NetworkAdapterConfiguration
    WHERE IPEnabled = ''True''`。由于你已经在 `Get-CimInstance` 中为 `ClassName` 参数指定了类名，你需要为
    `Filter` 指定 `IPEnabled = ''True''`：'
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This should return only network adapters that are `IPEnabled` (meaning they
    have an IP address).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该只返回那些 `IPEnabled`（意味着它们有 IP 地址）的网络适配器。
- en: 'Now that you have a single WMI instance, and now that you know the property
    you’re looking for (`IPAddress`), let’s see what it looks like when querying a
    single server. You’ll use the same object.property syntax you’ve been using:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个单一的 WMI 实例，并且知道你要找的属性是 `IPAddress`，我们来看看在查询单个服务器时它是什么样子的。你将使用你一直在使用的
    object.property 语法：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ouch! Looks like it has IPv4 and IPv6 references in there. You’ll have to filter
    out more elements. Because WQL can’t filter deeper than the property value, you’ll
    need to parse out the IPv4 address.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！看起来里面有 IPv4 和 IPv6 的引用。你需要过滤更多的元素。由于 WQL 无法对属性值进行更深层次的过滤，你需要解析出 IPv4 地址。
- en: 'Doing some investigation, you can see that all the addresses are enclosed with
    curly brackets separated by a comma:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些调查，你可以看到所有地址都被花括号包围，并且由逗号分隔：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is a good indication that this property isn’t stored as one big string
    but rather as an array. To confirm that this is an array, you can try using an
    index to see whether you can get only the IPv4 address:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明该属性不是作为一个大字符串存储，而是作为一个数组。为了确认它是一个数组，你可以尝试使用索引来查看是否能只获取IPv4地址：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You’re in luck! The `IPAddress` property *is* an array. At this point, you have
    your value, and you can add your full command to your script, as shown in [Listing
    14-7](ch14.xhtml#ch14list7).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你真幸运！`IPAddress`属性*确实*是一个数组。此时，你已经得到了值，可以将完整的命令添加到脚本中，如[列表14-7](ch14.xhtml#ch14list7)所示。
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 14-7: Updated code that now handles `IPAddress`*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-7：更新后的代码，现在可以处理`IPAddress`*'
- en: 'Now you run this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你运行这个：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that you have all the WMI information you need, there’s only one thing left
    to do.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经收集到所有所需的WMI信息，只剩下最后一件事了。
- en: Windows Services
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows 服务
- en: 'The last piece of data to gather is a list of the services on the server that
    are stopped. You’ll follow our basic algorithm, testing on a single server first.
    To do that, you’ll use the `Get-Service` command on the server, which will return
    all of the services being used. You’ll then pipe that output to a `Where-Object`
    command that will filter only for services that have a status of `Stopped`. All
    in all, the command will look like this: `Get-Service -ComputerName sqlsrv1 |
    Where-Object { $_.Status -eq ''Stopped'' }`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 收集的最后一项数据是服务器上已停止的服务列表。你将按照我们的基本算法，首先在单台服务器上进行测试。为此，你将使用`Get-Service`命令在服务器上运行，这将返回所有正在使用的服务。然后，你将把输出通过管道传递给`Where-Object`命令，仅筛选出状态为`Stopped`的服务。总的来说，命令将如下所示：`Get-Service
    -ComputerName sqlsrv1 | Where-Object { $_.Status -eq 'Stopped' }`。
- en: This command is returning whole objects with all their properties. But you’re
    just looking for service names, so you’ll use the same technique you’ve been using—referencing
    the property name—and return a list of only service names.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令返回的是包含所有属性的完整对象。但你只是想要服务名称，所以你将使用你一直在使用的技巧——引用属性名称——并只返回服务名称的列表。
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Adding this to your script, you get [Listing 14-8](ch14.xhtml#ch14list8).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一部分添加到你的脚本中，你将得到[列表14-8](ch14.xhtml#ch14list8)。
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 14-8: Updating and using your script to print the stopped services*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-8：更新并使用你的脚本打印已停止的服务*'
- en: 'Run the following code to test your script:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码来测试你的脚本：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As far as stopped services go, everything looks okay—but where did the other
    properties go? At this point, the console window has no room left. Removing the
    `Format-Table` reference allows you to see all the values:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关于已停止的服务，一切看起来都正常——但是其他的属性去哪儿了？此时，控制台窗口已经没有空间了。移除`Format-Table`引用可以让你看到所有的值：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Looks good!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！
- en: Script Cleanup and Optimization
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本清理与优化
- en: Rather than declare victory and move on, let’s reflect a little. Writing code
    is an iterative process. It’s entirely possible that you start out with a goal,
    accomplish that goal, and still end up with bad code—there’s more to a good program
    than simply doing what needs to be done. The script does exactly what you want
    it to do now, but you could do it in a better way. How?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在宣布胜利并继续之前，让我们稍微反思一下。编写代码是一个迭代过程。你完全有可能一开始设定了目标，达成了目标，但最终还是写出了糟糕的代码——优秀的程序不仅仅是完成需要做的事。脚本现在确实完成了你想要的功能，但你可以用更好的方式来实现。如何做呢？
- en: 'Recall the DRY method: *don’t repeat yourself*. You can see a lot of repetition
    in this script. You have lots of `Get-CimInstance` references where you’re using
    the same parameters over and over again. You’re also making a lot of calls to
    WMI for the same server. These look like good places to make the code more efficient.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下DRY原则：*不要重复自己*。你可以看到这个脚本中有很多重复的地方。你有许多`Get-CimInstance`的引用，里面使用了相同的参数。你还在为同一个服务器多次调用WMI。这些地方看起来是让代码更高效的好机会。
- en: First of all, the CIM cmdlets have a `CimSession` parameter. This parameter
    allows you to create a single CIM session once and then reuse it. Rather than
    creating a temporary session, using it, and tearing it down again, you can create
    a single session, use it all you want, and then tear it down, as shown in [Listing
    14-9](ch14.xhtml#ch14list9). The concept is similar to the `Invoke-Command` command’s
    `Session` parameter that we covered in [Chapter 8](ch08.xhtml#ch8).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，CIM cmdlets有一个`CimSession`参数。这个参数允许你创建一个CIM会话并在之后重用它。与其创建一个临时会话，使用它，然后销毁它，不如创建一个会话，随时使用，然后销毁它，正如[Listing
    14-9](ch14.xhtml#ch14list9)中所示。这个概念类似于我们在[第8章](ch08.xhtml#ch8)中介绍的`Invoke-Command`命令的`Session`参数。
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 14-9: Updating your code to create, and reuse, a single session*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-9: 更新你的代码以创建并重用单个会话*'
- en: Now you’re reusing a single CIM session rather than multiple ones. But you’re
    still referencing it a lot in different commands’ parameters. To make this even
    better, you can create a hashtable and assign it a key called `CIMSession` and
    a value of the CIM session you just created. Once you have a common set of parameters
    saved in a hashtable, you can reuse it across all `Get-CimInstance` references.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在重用单个CIM会话，而不是多个会话。但你仍然在不同命令的参数中多次引用它。为了更好地优化，你可以创建一个哈希表，并为其分配一个名为`CIMSession`的键，将你刚创建的CIM会话作为值。一旦你在哈希表中保存了一个通用的参数集，就可以在所有`Get-CimInstance`引用中重用它。
- en: This technique is known as *splatting*, and you can do it by specifying the
    hashtable you just created while calling each of the `Get-CimInstance` references
    via the `@` symbol followed by the hashtable name, as shown in [Listing 14-10](ch14.xhtml#ch14list10).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技巧被称为*splatting*，你可以通过在调用每个`Get-CimInstance`引用时，使用`@`符号后跟哈希表名称来实现，如[Listing
    14-10](ch14.xhtml#ch14list10)所示。
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 14-10: Creating the `CIMSession` parameter to reuse*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-10: 创建`CIMSession`参数以供重用*'
- en: At this point, you’re probably used to passing parameters to commands in the
    `dash<`parameter name`>` `<`parameter value`>` format. This works but it becomes
    inefficient, especially if you’re passing the same parameters to commands over
    and over again. Instead, you can use splatting as you’ve done here, by creating
    a hashtable and then simply passing that single hashtable to each command that
    requires the same parameter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你可能已经习惯于以`dash<`参数名称`>` `<`参数值`>`的格式将参数传递给命令。这种方式有效，但如果你反复将相同的参数传递给命令，它会变得低效。相反，你可以像这里一样使用splatting，通过创建一个哈希表，然后将该哈希表传递给每个需要相同参数的命令。
- en: Now you’ve eliminated the `$cimSession` variable altogether.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完全删除了`$cimSession`变量。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you’ve taken essential information from all the previous chapters
    and applied it to a situation you might find in the real world. A script that
    queries information is one of the first types of scripts I usually recommend creating.
    It teaches you a lot about PowerShell, and there’s little chance of screwing anything
    up!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你从所有前面的章节中提取了关键信息，并将其应用到你在现实世界中可能遇到的情境中。我通常推荐创建的一种脚本类型是查询信息的脚本。它教会你很多PowerShell的知识，而且出错的几率很小！
- en: You moved iteratively through this chapter, going from a goal to a solution
    to an even better solution. This is a process you’ll follow over and over again
    as you work with PowerShell. Define your goal, start small, get your framework
    laid out (a `foreach` loop, in this case), and start adding code piece by piece,
    overcoming one obstacle at a time until it all comes together.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中进行了逐步迭代，从目标到解决方案，再到更好的解决方案。这是你在使用PowerShell时将反复遵循的过程。定义目标，从小处着手，搭建框架（在本例中是`foreach`循环），然后逐步添加代码，一步步克服障碍，直到一切都达成。
- en: 'Once you finish your script, keep in mind that you haven’t really finished
    until you review your code: see how to make it more efficient, use fewer resources,
    and get faster. Experience will make optimizing easier. You’ll build the perspective
    you need until optimizing becomes second nature. When you’re finished optimizing,
    sit back, bask in your success, and get ready to start your next project!'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了脚本，记住，你实际上并未完全完成，直到你回顾你的代码：看看如何使它更高效、使用更少的资源并提升速度。经验会让优化变得更容易。你将建立起必要的视角，直到优化成为一种自然而然的行为。当你完成优化后，坐下来，享受成功的喜悦，准备好开始下一个项目吧！
