- en: '**15**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15**'
- en: '**FUNCTIONS AND PROCEDURES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数和过程**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'Since the beginning of the structured programming revolution in the 1970s,
    subroutines (procedures and functions) have been one of the primary tools software
    engineers use to organize, modularize, and otherwise structure their programs.
    Because procedure and function calls are used so frequently in code, CPU manufacturers
    have attempted to make them as efficient as possible. Nevertheless, these calls—and
    their associated returns—have costs that many programmers don’t consider when
    creating functions, and using them inappropriately can greatly increase a program’s
    size and execution time. This chapter discusses those costs and how to avoid them,
    covering the following subjects:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自从1970年代结构化编程革命开始以来，子程序（过程和函数）一直是软件工程师用来组织、模块化和构建程序的主要工具之一。由于过程和函数调用在代码中使用频繁，CPU制造商尝试使它们尽可能高效。然而，这些调用及其相关的返回操作存在成本，许多程序员在创建函数时未考虑到这些成本，不恰当地使用它们可能会大幅增加程序的大小和执行时间。本章将讨论这些成本及如何避免它们，涵盖以下主题：
- en: Function and procedure calls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和过程调用
- en: Macros and inline functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏和内联函数
- en: Parameter passing and calling conventions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数传递和调用约定
- en: Activation records and local variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活记录和局部变量
- en: Parameter-passing mechanisms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数传递机制
- en: Function return results
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数返回结果
- en: By understanding these topics, you can avoid the efficiency pitfalls that are
    common in modern programs that make heavy use of procedures and functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解这些主题，你可以避免现代程序中常见的效率陷阱，这些程序大量使用过程和函数。
- en: '**15.1 Simple Function and Procedure Calls**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**15.1 简单的函数和过程调用**'
- en: Let’s begin with some definitions. A *function* is a section of code that computes
    and returns some value—the function result. A *procedure* (or *void function*,
    in C/C++/Java/Swift terminology) simply accomplishes some action. Function calls
    generally appear within an arithmetic or logical expression, while procedure calls
    look like statements in the programming language. For the purpose of this discussion,
    you can generally assume that a procedure call and a function call are the same,
    and use the terms *function* and *procedure* interchangeably. For the most part,
    a compiler implements procedure and function calls identically.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些定义开始。*函数*是一个计算并返回某个值的代码块——即函数结果。*过程*（或在C/C++/Java/Swift术语中称为*无返回函数*）仅仅执行某些操作。函数调用通常出现在算术或逻辑表达式中，而过程调用则像编程语言中的语句。为了讨论的目的，你可以假设过程调用和函数调用是相同的，可以互换使用*函数*和*过程*这两个术语。大多数情况下，编译器对过程和函数调用的实现是一样的。
- en: '**NOTE**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Functions and procedures do have some differences, however. Namely, there
    are some efficiency issues related to function results, which we’ll consider in
    “Function Return Values” on [page 590](ch15.xhtml#page_590).*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数和过程确实存在一些差异。然而，函数结果相关的效率问题是其中之一，我们将在“函数返回值”一节中讨论，详见[第590页](ch15.xhtml#page_590)。*'
- en: 'With most CPUs, you invoke procedures via an instruction similar to the 80x86
    `call` (`branch` and `link` on the ARM and PowerPC) and return to the caller using
    the `ret` (return) instruction. The `call` instruction performs three discrete
    operations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数CPU上，你通过类似于80x86的`call`指令（ARM和PowerPC上的`branch`和`link`）调用过程，并使用`ret`（返回）指令返回调用者。`call`指令执行三项离散操作：
- en: It determines the address of the instruction to execute upon returning from
    the procedure (this is usually the instruction immediately following `call`).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它决定了从过程返回时要执行的指令地址（通常是紧随`call`指令后的那条指令）。
- en: It saves this address (commonly known as the *return address* or *link address*)
    into a known location.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将此地址（通常称为*返回地址*或*链接地址*）保存到一个已知位置。
- en: It transfers control (via a jump mechanism) to the first instruction of the
    procedure.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过跳转机制将控制权转移到过程的第一条指令。
- en: 'Execution starts with the first instruction of the procedure and continues
    until the CPU encounters a `ret` instruction, which fetches the return address
    and transfers control to the machine instruction at that address. Consider the
    following C function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 执行从过程的第一条指令开始，直到CPU遇到`ret`指令，这时会获取返回地址并将控制权转移到该地址处的机器指令。考虑以下C语言函数：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the conversion to PowerPC code by GCC:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是GCC将其转换为PowerPC代码后的结果：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s the 32-bit ARM version of this source code compiled by GCC:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由GCC编译的32位ARM版本源代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And here’s the conversion of the same source code to 80x86 code by GCC:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是GCC将相同源代码转换为80x86代码的结果：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the 80x86, ARM, and PowerPC devote considerable effort to building
    and managing activation records (see “The Stack Section” on [page 179](ch07.xhtml#page_179)).
    The important things to see in these two assembly language sequences are the `bl
    _func` and `blr` instructions in the PowerPC code; `bl func` and `bx lr` instructions
    in the ARM code; and the `call func` and `ret` instructions in the 80x86 code.
    These are the instructions that call the function and return from it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，80x86、ARM和PowerPC都花费了相当大的努力来构建和管理激活记录（请参阅[第179页](ch07.xhtml#page_179)的“栈部分”）。在这两段汇编语言序列中，重要的是要注意PowerPC代码中的`bl
    _func`和`blr`指令；ARM代码中的`bl func`和`bx lr`指令；以及80x86代码中的`call func`和`ret`指令。这些是调用函数和从函数返回的指令。
- en: '**15.1.1 Return Address Storage**'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**15.1.1 返回地址存储**'
- en: But where, exactly, does the CPU store the return address? In the absence of
    recursion and certain other program control constructs, the CPU could store the
    return address in any location that is large enough to hold the address and that
    will still contain that address when the procedure returns to its caller. For
    example, the program could choose to store the return address in a machine register
    (in which case the return operation would consist of an indirect jump to the address
    contained in that register). One problem with using registers, however, is that
    CPUs generally have a limited number of them. This means every register that holds
    a return address is unavailable for other purposes. For this reason, on CPUs that
    save the return address in a register, the applications usually move the return
    address to memory so they can reuse that register.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，CPU到底将返回地址存储在哪里呢？在没有递归和某些其他程序控制结构的情况下，CPU可以将返回地址存储在任何足够大的位置，只要这个位置在过程返回调用者时仍然包含该地址。例如，程序可以选择将返回地址存储在机器寄存器中（在这种情况下，返回操作将是间接跳转到寄存器中包含的地址）。然而，使用寄存器有一个问题，那就是CPU通常只有有限数量的寄存器。这意味着每个保存返回地址的寄存器都不能用于其他目的。因此，在那些将返回地址保存在寄存器中的CPU上，应用程序通常会将返回地址移动到内存中，以便可以重用该寄存器。
- en: Consider the PowerPC and ARM `bl` (branch and link) instruction. This instruction
    transfers control to the target address specified by its operand and copies the
    address of the instruction following `bl` into the LINK register. Inside a procedure,
    if no code modifies the value of the LINK register, the procedure can return to
    its caller by executing a PowerPC `blr` (branch to LINK register) or ARM `bx`
    (branch and exchange) instruction. In our trivial example, the `func()` function
    does not execute any code that modifies the value of the LINK register, so this
    is exactly how `func()` returns to its caller. However, if this function had used
    the LINK register for some other purpose, it would have been the procedure’s responsibility
    to save the return address so that it could restore the value prior to returning
    via a `blr` instruction at the end of the function call.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑PowerPC和ARM的`bl`（分支和链接）指令。该指令将控制转移到其操作数指定的目标地址，并将`bl`后面的指令地址复制到LINK寄存器中。在一个过程内部，如果没有代码修改LINK寄存器的值，则该过程可以通过执行PowerPC的`blr`（分支到LINK寄存器）或ARM的`bx`（分支和交换）指令来返回到调用者。在我们简单的示例中，`func()`函数没有执行任何修改LINK寄存器值的代码，因此这正是`func()`返回到其调用者的方式。然而，如果该函数将LINK寄存器用于其他目的，那么过程就需要负责保存返回地址，以便在函数调用结束时通过`blr`指令恢复返回地址。
- en: 'A more common place to keep return addresses is in memory. Although accessing
    memory on most modern processors is much slower than accessing a CPU register,
    keeping return addresses in memory allows a program to have a large number of
    nested procedure calls. Most CPUs actually use a *stack* to hold return addresses.
    For example, the 80x86 `call` instruction *pushes* the return address onto a stack
    data structure in memory, and the `ret` instruction *pops* this return address
    off the stack. Using a stack of memory locations to hold return addresses offers
    several advantages:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更常见的保存返回地址的地方是内存。尽管在大多数现代处理器上，访问内存的速度比访问CPU寄存器慢得多，但将返回地址保存在内存中允许程序有大量的嵌套过程调用。大多数CPU实际上使用*栈*来保存返回地址。例如，80x86的`call`指令*将*返回地址压入内存中的栈数据结构，而`ret`指令*将*这个返回地址从栈中弹出。使用内存位置的栈来保存返回地址有几个优点：
- en: Stacks, because of their *last-in, first-out (LIFO)* organization, fully support
    nested procedure calls and returns as well as recursive procedure calls and returns.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈由于其*后进先出 (LIFO)* 的组织方式，完全支持嵌套过程调用和返回以及递归过程调用和返回。
- en: Stacks are memory efficient because they reuse the same memory locations for
    different procedure return addresses (rather than requiring a separate memory
    location to hold each procedure’s return address).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈具有内存效率，因为它们重用相同的内存位置来存储不同过程的返回地址（而不是需要单独的内存位置来存储每个过程的返回地址）。
- en: Even though stack access is slower than register access, the CPU can generally
    access memory locations on the stack faster than separate return addresses elsewhere,
    because the CPU frequently accesses the stack and the stack contents tend to remain
    in the cache.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使栈访问比寄存器访问慢，CPU通常也能比访问其他地方的返回地址更快地访问栈上的内存位置，因为CPU频繁访问栈，并且栈内容通常会保存在缓存中。
- en: As discussed in [Chapter 7](ch07.xhtml#ch07), stacks are also great places to
    store activation records (such as parameters, local variables, and other procedure
    state information).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如[第7章](ch07.xhtml#ch07)所述，栈也是存储激活记录（如参数、局部变量和其他过程状态信息）的好地方。
- en: Using a stack also incurs a few penalties, though. Most importantly, maintaining
    a stack generally requires dedicating a CPU register to keep track of it in memory.
    This could be a register that the CPU explicitly dedicates for this purpose (for
    example, the RSP register on the x86-64 or R14/SP on the ARM) or a general-purpose
    register on a CPU that doesn’t provide explicit hardware stack support (for example,
    applications running on the PowerPC processor family typically use R1 for this
    purpose).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用栈也会带来一些惩罚。最重要的是，维护栈通常需要分配一个CPU寄存器来跟踪栈在内存中的位置。这可能是CPU专门为此目的分配的寄存器（例如，x86-64的RSP寄存器或ARM的R14/SP寄存器），或者是没有提供显式硬件栈支持的CPU上的通用寄存器（例如，运行在PowerPC处理器系列上的应用通常使用R1寄存器来完成此任务）。
- en: On CPUs that provide a hardware stack implementation and a `call`/`ret` instruction
    pair, making a procedure call is easy. As shown earlier in the 80x86 GCC example
    output, the program simply executes a `call` instruction to transfer control to
    the beginning of the procedure and then executes a `ret` instruction to return
    from the procedure.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供硬件栈实现和`call`/`ret`指令对的CPU上，进行过程调用非常简单。如前面80x86 GCC示例输出所示，程序只需执行`call`指令将控制转移到过程的开始，然后执行`ret`指令从过程返回。
- en: The PowerPC/ARM approach, using a “branch and link” instruction might seem less
    efficient than the `call`/`ret` mechanism. While it’s certainly true that the
    “branch and link” approach requires a little more code, it isn’t so clear that
    it’s slower than the `call`/`ret` approach. A `call` instruction is a complex
    instruction (accomplishing several independent tasks with a single instruction)
    and, as a result, typically requires several CPU clock cycles to execute. The
    execution of the `ret` instruction is similar. Whether the extra overhead is costlier
    than maintaining a software stack varies by CPU and compiler. However, a “branch
    and link” instruction and an indirect jump through the link address, without the
    overhead of maintaining the software stack, is usually faster than the corresponding
    `call`/`ret` instruction pair. If a procedure doesn’t call any other procedures
    and can maintain parameters and local variables in machine registers, it’s possible
    to skip the software stack maintenance instructions altogether. For example, the
    call to `func()` in the previous example is probably more efficient on the PowerPC
    and ARM than on the 80x86, because `func()` doesn’t need to save the LINK register’s
    value into memory—it simply leaves that value in LINK throughout the execution
    of the function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: PowerPC/ARM的方式，使用“分支和链接”指令，可能看起来比`call`/`ret`机制效率低。虽然“分支和链接”方法确实需要稍微多一些代码，但并不明显比`call`/`ret`方法慢。`call`指令是一条复杂指令（通过一条指令完成多个独立任务），因此通常需要几个CPU时钟周期来执行。`ret`指令的执行类似。额外的开销是否比维护软件栈更昂贵，取决于CPU和编译器。然而，“分支和链接”指令以及通过链接地址的间接跳转，通常比相应的`call`/`ret`指令对更快，因为没有维护软件栈的开销。如果一个过程不调用其他过程，并且能够在机器寄存器中维护参数和局部变量，那么完全可以跳过软件栈维护指令。例如，前面示例中的`func()`调用在PowerPC和ARM上可能比在80x86上更高效，因为`func()`不需要将LINK寄存器的值保存到内存中——它只是将该值保持在LINK寄存器中，直到函数执行完成。
- en: 'Because many procedures are short and have few parameters and local variables,
    a good RISC compiler can often dispense with the software stack maintenance entirely.
    Therefore, for many common procedures, this RISC approach is faster than the CISC
    (`call`/`ret`) approach; however, that’s not to imply that it’s always better.
    The brief example in this section is a very special case. In our simple demonstration
    program, the function that this code calls—via the `bl` instruction—is near the
    `bl` instruction. In a complete application, `func()` might be *very* far away,
    and the compiler wouldn’t be able to encode the target address as part of the
    instruction. That’s because RISC processors (like the PowerPC and ARM) must encode
    their entire instruction within a single 32-bit value (which must include both
    the opcode and the displacement to the function). If `func()` is farther away
    than can be encoded in the remaining displacement bits (24, in the case of the
    PowerPC and ARM `bl` instructions), the compiler has to emit a sequence of instructions
    that will compute the address of the target routine and indirectly transfer control
    through that address. Most of the time, this shouldn’t be a problem. After all,
    few programs are so large that the functions would be outside this range (64MB,
    in the case of the PowerPC, ±32MB for the ARM). However, there’s a very common
    case where GCC (and other compilers, presumably) must generate this type of code:
    when the compiler doesn’t know the target address of the function, because it’s
    an external symbol that the linker must merge in after compilation is complete.
    Because the compiler doesn’t know where the routine will be sitting in memory
    (and also because most linkers work only with 32-bit addresses, not 24-bit displacement
    fields), the compiler must assume that the function’s address is out of range
    and emit the long version of the function call. Consider the following slight
    modification to the earlier example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多过程较短，且参数和局部变量较少，一个好的RISC编译器通常能够完全省去软件栈的维护。因此，对于许多常见的过程，这种RISC方法比CISC（`call`/`ret`）方法更快；然而，这并不意味着它总是更好。本节中的简短示例是一个非常特殊的情况。在我们的简单演示程序中，这段代码调用的函数——通过`bl`指令——离`bl`指令很近。在一个完整的应用程序中，`func()`可能会*非常*远，而编译器将无法将目标地址编码为指令的一部分。这是因为RISC处理器（如PowerPC和ARM）必须将整个指令编码在一个32位值内（该值必须同时包括操作码和到函数的偏移量）。如果`func()`的距离超出了剩余偏移位（在PowerPC和ARM的`bl`指令中为24位）所能编码的范围，编译器必须发出一系列指令来计算目标例程的地址，并通过该地址间接转移控制权。大多数时候，这不应该是个问题。毕竟，很少有程序的函数会超出这个范围（在PowerPC中为64MB，ARM为±32MB）。然而，有一个非常常见的情况是GCC（以及其他编译器，可能也一样）必须生成这种类型的代码：当编译器不知道函数的目标地址时，因为它是一个外部符号，链接器必须在编译完成后将其合并进来。因为编译器不知道该例程将在内存中的哪个位置（而且大多数链接器仅处理32位地址，而不是24位的偏移量字段），编译器必须假设该函数的地址超出了范围，并生成长版本的函数调用。考虑一下对之前示例的轻微修改：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code declares `func()` as an external function. Now look at the PowerPC
    code that GCC produces and compare it with the earlier code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`func()`声明为外部函数。现在看看GCC生成的PowerPC代码，并与之前的代码进行比较：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code effectively winds up calling two functions in order to call `func()`.
    First, it calls a *stub* function (`L_func$stub`), which then transfers control
    to the actual `func()` routine. Clearly there is considerable overhead here. Without
    actually benchmarking the PowerPC code against the 80x86 code, it’s probably a
    safe bet that the 80x86 solution is a bit more efficient. (The 80x86 version of
    the GCC compiler emits the same code for the main program as in the earlier example,
    even when compiling in the external reference.) You’ll soon see that the PowerPC
    also generates stub functions for things other than external functions. Therefore,
    the CISC solution often is more efficient than the RISC solution (presumably,
    RISC CPUs make up the difference in performance in other areas).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上调用了两个函数来调用`func()`。首先，它调用一个*存根*函数（`L_func$stub`），然后将控制权转交给实际的`func()`函数。显然，这里有相当大的开销。如果不对PowerPC代码与80x86代码进行实际的基准测试，推测80x86解决方案可能会更高效一些。（即使在编译外部引用时，80x86版本的GCC编译器也会生成与之前示例中相同的主程序代码。）很快你会发现，PowerPC也会为除外部函数之外的其他情况生成存根函数。因此，CISC解决方案通常比RISC解决方案更高效（大概RISC处理器在其他方面弥补了性能差距）。
- en: 'The Microsoft CLR also provides generic call and return functionality. Consider
    the following C# program with a static function `f()`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft CLR 还提供了通用的调用和返回功能。考虑以下带有静态函数`f()`的 C# 程序：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the CIL code that the Microsoft C# compiler emits for functions `f()`
    and `Main()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Microsoft C# 编译器为函数`f()`和`Main()`生成的 CIL 代码：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As one last example, here’s a comparable Java program:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个例子，这是一个类似的 Java 程序：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s the Java bytecode (JBC) output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Java 字节码（JBC）输出：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the Microsoft CLR and Java VM both have several variants of call and
    invoke instructions. These simple examples demonstrate calls to static methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Microsoft CLR 和 Java VM 都有多种调用和调用指令变体。这些简单的例子展示了对静态方法的调用。
- en: '**15.1.2 Other Sources of Overhead**'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**15.1.2 其他开销来源**'
- en: Of course, a typical procedure call and return involve overhead beyond the execution
    of the actual procedure `call` and `return` instructions. Prior to calling the
    procedure, the calling code must compute and pass any parameters to it. Upon entry
    into the procedure, the calling code may also need to complete the construction
    of the *activation record* (that is, allocate space for local variables). The
    costs of these operations vary by CPU and compiler. For example, if the calling
    code can pass parameters in registers rather than on the stack (or some other
    memory location), this is usually more efficient. Similarly, if the procedure
    can keep all its local variables in registers rather than in the activation record
    on the stack, accessing those local variables is much more efficient. This is
    one area where RISC processors have a considerable advantage over CISC processors.
    A typical RISC compiler can reserve several registers for passing parameters and
    local variables. (RISC processors typically have 16, 32, or more general-purpose
    registers, so setting aside several registers for this purpose is not outrageous.)
    For procedures that don’t call any other procedures (discussed in the next section),
    there’s no need to preserve these register values, so parameter and local variable
    access is very efficient. Even on CPUs with a limited number of registers (such
    as the 32-bit 80x86), it’s still possible to pass a small number of parameters,
    or maintain a few local variables, in registers. Many 80x86 compilers, for example,
    will keep up to three values (parameters or local variables) in the registers.
    Clearly, though, the RISC processors have an advantage here.^([1](footnotes.xhtml#ch15fn1))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个典型的过程调用和返回涉及的开销不仅仅是执行实际的过程`call`和`return`指令。在调用过程之前，调用代码必须计算并传递任何参数给它。进入过程后，调用代码还可能需要完成*激活记录*的构建（即为局部变量分配空间）。这些操作的开销因
    CPU 和编译器而异。例如，如果调用代码能够通过寄存器而非栈（或其他内存位置）传递参数，通常会更高效。同样，如果过程能够将所有局部变量保存在寄存器中，而不是在栈上的激活记录中，那么访问这些局部变量会更高效。这是
    RISC 处理器相较于 CISC 处理器的一个重要优势。典型的 RISC 编译器可以为传递参数和局部变量保留多个寄存器。（RISC 处理器通常具有 16、32
    个或更多通用寄存器，因此为此目的保留几个寄存器并不算过分。）对于那些不调用其他过程的过程（将在下一节讨论），无需保存这些寄存器的值，因此参数和局部变量的访问非常高效。即使在寄存器数量有限的
    CPU（如 32 位 80x86）上，仍然可以在寄存器中传递少量参数，或者保持少量局部变量。例如，许多 80x86 编译器会将最多三个值（参数或局部变量）保存在寄存器中。显然，RISC
    处理器在这方面具有优势。^([1](footnotes.xhtml#ch15fn1))
- en: Armed with this knowledge, along with the background on activation records and
    stack frames from earlier in this book (see “The Stack Section” on [page 179](ch07.xhtml#page_179)),
    we can now discuss how to write procedures and functions that operate as efficiently
    as possible. The exact rules are highly dependent upon your CPU and the compiler
    you’re using, but some of the concepts are generic enough to apply to all programs.
    The following sections assume that you’re writing for an 80x86 or ARM CPU (as
    most of the world’s software runs on one of these two CPUs).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识，并结合本书前面关于激活记录和栈帧的背景（参见 [第 179 页](ch07.xhtml#page_179)中的《栈部分》），我们现在可以讨论如何编写高效的过程和函数。具体的规则高度依赖于您的
    CPU 和使用的编译器，但一些概念足够通用，可以应用于所有程序。以下各节假设您是在为 80x86 或 ARM CPU 编写程序（因为世界上大多数软件运行在这两种
    CPU 上之一）。
- en: '**15.2 Leaf Functions and Procedures**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**15.2 叶函数和过程**'
- en: Compilers can often generate better code for *leaf* procedures and functions—that
    is, those that don’t call other procedures or functions. The metaphor comes from
    a graphical representation of procedure/function invocations known as a *call
    tree*. A call tree consists of a set of circles (*nodes*) that represent the functions
    and procedures in a program. An arrow from one node to another implies that the
    first node contains a call to the second. [Figure 15-1](ch15.xhtml#ch15fig1) illustrates
    a typical call tree.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常能够为*叶子*过程和函数生成更好的代码——也就是那些不调用其他过程或函数的过程和函数。这个隐喻来源于一种叫做*调用树*的过程/函数调用图形表示。调用树由一组圆圈（*节点*）组成，这些圆圈表示程序中的函数和过程。从一个节点到另一个节点的箭头表示第一个节点包含对第二个节点的调用。[图
    15-1](ch15.xhtml#ch15fig1)展示了一个典型的调用树。
- en: In this example, the main program directly calls procedure `prc1()` and functions
    `fnc1()` and `fnc2()`. Function `fnc1()` directly calls procedure `prc2()`. Function
    `fnc2()` directly calls procedures `prc2()` and `prc3()` as well as function `fnc3()`.
    The leaf procedures and functions in this call tree are `prc1()`, `prc2()`, `fnc3()`,
    and `prc3()`, which do not call any other procedures or functions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，主程序直接调用过程`prc1()`和函数`fnc1()`以及`fnc2()`。函数`fnc1()`直接调用过程`prc2()`。函数`fnc2()`直接调用过程`prc2()`和`prc3()`，以及函数`fnc3()`。在这个调用树中，叶子过程和函数是`prc1()`、`prc2()`、`fnc3()`和`prc3()`，它们没有调用任何其他过程或函数。
- en: '![Image](../images/15fig01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/15fig01.jpg)'
- en: '*Figure 15-1: A call tree*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：调用树*'
- en: 'Working with leaf procedures and functions has an advantage: they do not need
    to save parameters passed to them in registers or preserve the values of local
    variables they maintain in registers. For example, if `main()` passes two parameters
    to `fnc1()` in the EAX and EDX registers, and `fnc1()` passes a different pair
    of parameters to `prc2()` in EAX and EDX, then `fnc1()` must first save the values
    it found in EAX and EDX before calling `prc2()`. The `prc2()` procedure, on the
    other hand, doesn’t have to save the values in EAX and EDX prior to some procedure
    or function call, because it doesn’t make such calls. In a similar vein, if `fnc1()`
    allocates any local variables in registers, then it will need to preserve those
    registers across a call to `prc2()`, because `prc2()` can use the registers for
    its own purposes. By contrast, if `prc2()` uses a register for a local variable,
    it never has to preserve the variable’s value, because it never calls any subroutines.
    Therefore, good compilers tend to generate better code for leaf procedures and
    functions because they don’t have to preserve the register values.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 处理叶子过程和函数有一个优势：它们不需要将传递给它们的参数保存在寄存器中，也不需要保持它们在寄存器中维护的局部变量的值。例如，如果`main()`将两个参数通过EAX和EDX寄存器传递给`fnc1()`，而`fnc1()`将一对不同的参数通过EAX和EDX传递给`prc2()`，那么`fnc1()`必须在调用`prc2()`之前先保存EAX和EDX中的值。另一方面，`prc2()`过程则不需要在调用某个过程或函数之前保存EAX和EDX中的值，因为它不会进行这样的调用。同样，如果`fnc1()`在寄存器中分配了任何局部变量，那么它在调用`prc2()`时需要保留这些寄存器的值，因为`prc2()`可以将这些寄存器用于它自己的目的。相反，如果`prc2()`使用寄存器来存储局部变量，它就不需要保留该变量的值，因为它从不调用任何子程序。因此，优秀的编译器通常会为叶子过程和函数生成更好的代码，因为它们不需要保存寄存器的值。
- en: One way to *flatten* the call tree is to take the code associated with procedures
    and functions in interior nodes and inline it into functions higher in the call
    tree. In [Figure 15-1](ch15.xhtml#ch15fig1), for example, if it is practical to
    move the code for `fnc1()` into `main()`, you don’t need to save and restore registers
    (among other operations). However, be sure you’re not sacrificing readability
    and maintainability when flattening the call tree. You want to avoid writing procedures
    and functions that simply call other procedures and functions without doing any
    work on their own, but you don’t want to destroy the modularity of your application’s
    design by expanding function and procedure calls throughout your code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将调用树*扁平化*的一种方式是将内部节点中与过程和函数相关的代码内联到调用树中更高的函数中。例如，在[图 15-1](ch15.xhtml#ch15fig1)中，如果将`fnc1()`的代码移到`main()`中是可行的，那么就不需要保存和恢复寄存器（以及其他操作）。然而，在扁平化调用树时，要确保你没有牺牲可读性和可维护性。你希望避免编写那些仅仅调用其他过程和函数而自己不做任何工作的过程和函数，但你也不希望通过在代码中扩展函数和过程调用来破坏应用程序设计的模块化。
- en: 'You’ve already seen that having a leaf function is handy when you’re using
    a RISC processor, like the PowerPC or ARM, that uses a “branch and link” instruction
    to make a subroutine call. The PowerPC and ARM LINK registers are good examples
    of registers that you have to preserve across procedure calls. Because a leaf
    procedure does not (normally) modify the value in the LINK register, no extra
    code is necessary in a leaf procedure to preserve that register’s value. To see
    the benefits of calling leaf functions on a RISC CPU, consider the following C
    code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，当使用RISC处理器（如PowerPC或ARM）时，具有叶子函数是很方便的，因为它们使用“分支和链接”指令来进行子程序调用。PowerPC和ARM的LINK寄存器就是必须在过程调用中保留的寄存器的良好示例。因为叶子过程通常不修改LINK寄存器的值，所以在叶子过程中不需要额外的代码来保留该寄存器的值。要了解在RISC
    CPU上调用叶子函数的好处，可以参考以下C代码：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'GCC emits the following PowerPC assembly code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: GCC生成以下PowerPC汇编代码：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There’s an important difference between the implementations of the `f()` and
    `g()` functions in this PowerPC code—`f()` has to preserve the value of the LINK
    register, whereas `g()` does not. Not only does this involve extra instructions,
    but it also involves accessing memory, which can be slow.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段PowerPC代码中，`f()`和`g()`函数的实现有一个重要区别——`f()`必须保留LINK寄存器的值，而`g()`则不需要。这样不仅涉及额外的指令，而且还涉及访问内存，这可能会比较慢。
- en: Another advantage to using leaf procedures, which isn’t obvious from the call
    tree, is that constructing their activation record requires less work. On the
    80x86, for example, a good compiler doesn’t have to preserve the value of the
    EBP register, load EBP with the activation record address, and then restore the
    original value by accessing local objects via the stack pointer register (ESP).
    On RISC processors, which maintain the stack manually, the savings can be significant.
    For such procedures, the overhead of the procedure call and return and activation
    record maintenance is greater than the actual work done by the procedure. Therefore,
    eliminating the activation record maintenance code could nearly double the speed
    of the procedure. For these and other reasons, you should try to keep your call
    trees as shallow as possible. The more leaf procedures your program uses, the
    more efficient it may become when you compile it with a decent compiler.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用叶子过程的另一个优点是，从调用树上看不出来的，就是构建它们的激活记录需要更少的工作。例如，在80x86架构上，一个优秀的编译器不需要保留EBP寄存器的值，不需要将EBP加载为激活记录的地址，然后通过栈指针寄存器（ESP）访问局部对象来恢复原始值。而在手动管理栈的RISC处理器上，这种节省可能是显著的。对于这些过程，过程调用和返回以及激活记录维护的开销大于过程实际执行的工作。因此，消除激活记录维护代码几乎可以使过程的速度加倍。基于这些原因，你应该尽量保持调用树尽可能浅。程序中使用的叶子过程越多，使用合适编译器编译时程序的效率可能越高。
- en: '**15.3 Macros and Inline Functions**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**15.3 宏和内联函数**'
- en: 'One offshoot of the structured programming revolution was that computer programmers
    were taught to write small, modular, and logically coherent functions.^([2](footnotes.xhtml#ch15fn2))
    A function that is logically coherent does one thing well. All of the statements
    in such a procedure or function are dedicated to doing the task at hand without
    producing any side computations or doing any extraneous operations. Years of software
    engineering research indicate that decomposing a problem into small components,
    and then implementing those, produces programs that are easier to read, maintain,
    and modify. Unfortunately, it’s easy to get carried away with this process and
    produce functions like the following Pascal example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化编程革命的一个结果是，计算机程序员被教导编写小型、模块化且逻辑连贯的函数^([2](footnotes.xhtml#ch15fn2))。一个逻辑连贯的函数能做好一件事。该过程或函数中的所有语句都专注于完成手头的任务，不进行任何副计算或无关操作。多年的软件工程研究表明，将问题分解为小组件，然后实现这些组件，能生成更容易阅读、维护和修改的程序。不幸的是，很容易在这个过程中过度设计，产生像下面这个Pascal示例这样的函数：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the 80x86, it would probably take about three instructions to compute the
    sum of two values and store that sum into a memory variable. For example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在80x86上，计算两个值的和并将其存储到内存变量中大约需要三条指令。例如：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Contrast this with the code necessary to simply *call* the function `sum()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与简单*调用*函数`sum()`所需的代码进行对比：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Within the procedure `sum` (assuming a mediocre compiler), you might expect
    to find code like the following HLA sequence:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sum`过程内（假设使用一个普通编译器），你可能会看到如下HLA代码：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, using a function takes three times as many instructions to compute
    the sum of these two objects as the straight-line (no function call) code. Worse
    still, these nine instructions are generally slower than the three that make up
    the inline code. The inline code could run 5 to 10 times faster than the code
    with the function call.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用一个函数来计算这两个对象的和，比直接的（没有函数调用的）代码需要更多三倍的指令。更糟糕的是，这九条指令通常比构成内联代码的三条指令要慢。内联代码的运行速度可能比带有函数调用的代码快
    5 到 10 倍。
- en: The one redeeming quality about the overhead associated with a function or procedure
    call is that it’s fixed. It takes the same number of instructions to set up the
    parameters and the activation record whether the procedure or function body contains
    1 or 1,000 machine instructions. Although the overhead of a procedure call is
    huge when the procedure’s body is small, it’s inconsequential when the procedure’s
    body is large. Therefore, to reduce the impact of procedure/function call overhead
    in your programs, try to place larger procedures and functions and write shorter
    sequences as inline code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数或过程调用的开销，唯一值得肯定的优点是它是固定的。不管过程或函数体包含 1 条还是 1,000 条机器指令，设置参数和激活记录所需的指令数是相同的。尽管当过程体较小时，过程调用的开销很大，但当过程体较大时，这种开销几乎可以忽略不计。因此，为了减少程序中过程/函数调用的开销影响，尽量将较大的过程和函数放置为内联代码，并编写较短的序列。
- en: Finding the optimum balance between the benefits of modular structure and the
    cost of too-frequent procedure calls can be difficult. Unfortunately, good program
    design often prevents us from increasing the size of our procedures and functions
    enough that the overhead of the call and return becomes insignificant. Sure, we
    could combine several functions and procedure calls into a single procedure or
    function, but this would violate several rules of programming style, and great
    code usually avoids such tactics. (One problem with the resulting programs is
    that few people can figure out how they work in order to optimize them.) However,
    if you can’t sufficiently lower the overhead of a procedure’s body by increasing
    the procedure’s size, you can still improve overall performance by reducing the
    overhead in other ways. As you’ve seen, one option is to use leaf procedures and
    functions. Good compilers emit fewer instructions for leaf nodes in the call tree,
    thereby reducing the call/return overhead. However, if the procedure’s body is
    short, you need a way to completely eliminate the procedure call/return overhead.
    Some languages accomplish this with *macros*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块化结构的好处与过于频繁的过程调用成本之间找到最佳平衡可能很困难。不幸的是，良好的程序设计通常会阻止我们将过程和函数的大小增加到足以使调用和返回的开销变得微不足道的程度。确实，我们可以将多个函数和过程调用合并为一个过程或函数，但这会违反几个编程风格的规则，而且优秀的代码通常避免使用这种策略。（这样产生的程序的一个问题是，很少有人能够弄清楚它们是如何工作的，从而优化它们。）然而，如果通过增加过程的大小不能足够降低过程体的开销，你仍然可以通过其他方式减少开销，从而提高整体性能。正如你所看到的，一个选项是使用叶子过程和函数。优秀的编译器对调用树中的叶节点生成更少的指令，从而减少调用/返回的开销。然而，如果过程体很短，你需要一种方法来完全消除过程调用/返回的开销。有些语言通过*宏*实现这一点。
- en: 'A *pure* macro expands the body of a procedure or function in place of its
    invocation. Because there’s no call/return to code elsewhere in the program, a
    macro expansion avoids the overhead associated with those instructions. Furthermore,
    macros also save considerable expense by using textual substitution for parameters
    rather than pushing the parameter data onto the stack or moving it into registers.
    The drawback to a macro is that the compiler expands the macro’s body for each
    invocation of the macro. If the macro body is large and you invoke it in many
    different places, the executable program can grow by a fair amount. Macros represent
    the classic time/space tradeoff: faster code at the expense of greater size. For
    this reason, you should use macros only to replace procedures and functions that
    have a small number of statements (say, between one and five), except in some
    rare cases where speed is paramount.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯*宏会将过程或函数的主体直接扩展为调用位置。由于没有程序中其他地方的调用/返回，宏扩展避免了与这些指令相关的开销。此外，宏还通过使用文本替换参数而不是将参数数据推入栈或将其移动到寄存器中，节省了相当大的开销。宏的缺点是编译器会为每次调用宏时扩展宏的主体。如果宏的主体很大，并且你在多个地方调用它，那么可执行程序的体积可能会增加相当多。宏代表了经典的时间/空间权衡：通过增加大小来换取更快的代码。因此，除非在某些对速度要求极高的罕见情况下，否则应只使用宏来替代语句较少的过程和函数（比如说，一到五个语句）。'
- en: A few languages (like C/C++) provide *inline* functions and procedures, which
    are a cross between a true function (or procedure) and a pure macro. Most languages
    that support inline functions and procedures do not guarantee that the compiler
    will expand the code inline. *Inline expansion*, or a call to an actual function
    in memory, is done at the compiler’s discretion. Most compilers won’t expand an
    inline function if its body is too large or if it has an excessive number of parameters.
    Furthermore, unlike pure macros, which don’t have any associated procedure call
    overhead, inline functions may still need to build an activation record in order
    to handle local variables, temporaries, and other requirements. Thus, even if
    the compiler does expand such a function inline, there may still be some overhead
    that you wouldn’t get with a pure macro.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言（如 C/C++）提供了 *内联* 函数和过程，它们是函数（或过程）和纯宏之间的结合体。大多数支持内联函数和过程的语言并不保证编译器会进行内联扩展。*内联扩展*，或调用内存中的实际函数，是由编译器决定的。如果函数体太大，或者有过多的参数，大多数编译器不会将内联函数扩展出来。此外，与纯宏不同，纯宏没有任何关联的过程调用开销，而内联函数可能仍然需要构建一个激活记录，以处理局部变量、临时变量以及其他需求。因此，即使编译器确实进行了内联扩展，可能仍然会有一些额外开销，这些是使用纯宏时不会遇到的。
- en: 'To see the result of function inlining, consider the following C source file
    prepared for compilation by Microsoft Visual C++:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看函数内联的结果，请考虑以下由 Microsoft Visual C++ 准备进行编译的 C 源文件：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s the MASM-compatible assembly language code that MSVC emits when you
    specify a C compilation (versus a C++ compilation, which produces messier output):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 MSVC 在指定 C 编译时（与 C++ 编译时不同，后者会产生更为混乱的输出）生成的与 MASM 兼容的汇编语言代码：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see in this assembly output, there are no function calls to the `inlineFunc()`
    function. Instead, the compiler expanded this function in place in the `main()`
    function, at the point where the main program calls it. Although the `ilf2()`
    function was also declared inline, the compiler refused to expand it inline and
    treated it like a normal function (probably because of its size).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个汇编输出中看到的那样，`inlineFunc()` 函数没有被调用。相反，编译器在 `main()` 函数中扩展了这个函数，扩展的位置正是主程序调用它的地方。虽然
    `ilf2()` 函数也被声明为内联，编译器拒绝将其内联扩展，并将其视为普通函数（可能是因为它的大小）。
- en: '**15.4 Passing Parameters to a Function or Procedure**'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**15.4 将参数传递给函数或过程**'
- en: The number and type of parameters can also have a big impact on the efficiency
    of the code a compiler generates for your procedures and functions. Simply put,
    the more parameter data you pass, the more expensive the procedure or function
    call becomes. Often, programmers call generic functions (or design generic functions)
    that require you to pass several optional parameters whose values the function
    won’t use. This scheme can make functions more generally applicable to different
    applications, but—as you’ll see in this section—there’s a cost associated with
    that generality, so you might want to consider using a version of the function
    specific to your application if space or speed is an issue.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的数量和类型也会对编译器为你的过程和函数生成的代码效率产生重大影响。简而言之，传递的参数数据越多，过程或函数调用的开销就越大。通常，程序员会调用（或设计）需要传递多个可选参数的通用函数，而这些参数的值函数可能并不会使用。这种方案可以让函数在不同的应用程序中更具通用性，但正如你将在本节中看到的那样，这种通用性是有代价的，因此，如果空间或速度是问题，你可能需要考虑使用针对特定应用程序的函数版本。
- en: 'The parameter-passing mechanism (for example, pass-by-reference or pass-by-value)
    also has an impact on the overhead associated with a procedure call and return.
    Some languages allow you to pass large data objects by value. (Pascal lets you
    pass strings, arrays, and records by value, and C/C++ allows you to pass structures
    by value; other languages vary depending on their design.) Whenever you pass a
    large data object by value, the compiler must emit machine code that makes a copy
    of that data into the procedure’s activation record. This can be time-consuming
    (especially when copying large arrays or structures). Furthermore, large objects
    probably won’t fit in the CPU’s register set, so accessing such data within a
    procedure or function is expensive. It’s usually more efficient to pass large
    data objects such as arrays and structures by reference than by value. The extra
    cost of accessing the data indirectly is usually saved many times over by not
    having to copy the data into the activation record. Consider the following C code,
    which passes a large structure by value to a C function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 参数传递机制（例如，传值或传引用）也会影响过程调用和返回时的开销。一些语言允许你通过值传递大数据对象。（例如，Pascal 允许传递字符串、数组和记录作为值，C/C++
    允许传递结构体作为值；其他语言的设计有所不同。）每当你通过值传递大数据对象时，编译器必须生成机器代码来将该数据复制到过程的激活记录中。这可能是一个耗时的过程（特别是当复制大型数组或结构时）。此外，大对象可能无法适应
    CPU 的寄存器集，因此在过程或函数内访问这些数据会变得很昂贵。通常，通过引用传递像数组和结构体这样的大型数据对象比通过值传递更高效。间接访问数据的额外开销通常通过避免将数据复制到激活记录中得以节省，通常是几倍地节省。考虑以下
    C 代码，其中将一个大型结构体通过值传递给 C 函数：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the PowerPC code that GCC emits:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 GCC 发出的 PowerPC 代码：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, the call to function `f()` calls `memcpy` to transfer a copy
    of the data from the `main()` function’s local array to the `f()` function’s activation
    record. Again, copying memory is a slow process, and this code amply demonstrates
    that you should avoid passing large objects by value. Consider the same code when
    you pass the structure by reference:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对函数 `f()` 的调用通过 `memcpy` 将数据从 `main()` 函数的局部数组复制到 `f()` 函数的激活记录中。再次强调，复制内存是一个慢过程，这段代码充分展示了你应该避免通过值传递大型对象。考虑在通过引用传递结构体时的相同代码：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s the conversion of this C source code to 32-bit ARM assembly by GCC:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 GCC 将该 C 源代码转换为 32 位 ARM 汇编的代码：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Depending on your CPU and compiler, it may be slightly more efficient to pass
    small (scalar) data objects by value rather than by reference. For example, if
    you’re using an 80x86 compiler that passes parameters on the stack, you’ll need
    two instructions to pass a memory object by reference, but only a single instruction
    to pass that same object by value. So, although trying to pass large objects by
    reference is a good idea, the reverse is generally true for small objects. However,
    this is not a hard and fast rule; its validity varies based on the CPU and compiler
    you’re using.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的 CPU 和编译器，将小（标量）数据对象通过值传递可能比通过引用传递更高效。例如，如果你使用的是 80x86 编译器并且参数通过栈传递，那么传递一个内存对象时通过引用需要两条指令，而通过值传递只需要一条指令。因此，尽管尝试通过引用传递大对象是一个好主意，但对于小对象而言，通常相反。不过，这并不是一条死板的规则；它的有效性取决于你使用的
    CPU 和编译器。
- en: 'Some programmers may feel that it’s more efficient to pass data to a procedure
    or function via global variables. After all, if the data is already sitting in
    a global variable that’s accessible to the procedure or function, a call to that
    procedure or function won’t require any extra instructions to pass the data to
    the subroutine, therefore reducing the call overhead. While this seems like a
    big win, keep in mind that compilers have a difficult time optimizing programs
    that make excessive use of global variables. Although using globals may reduce
    the function/procedure call overhead, it may also prevent the compiler from handling
    other optimizations that would have been otherwise possible. Here’s a simple example
    using Microsoft Visual C++ that demonstrates this problem:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员可能会认为通过全局变量将数据传递给过程或函数更加高效。毕竟，如果数据已经存储在一个全局变量中，且该全局变量对过程或函数是可访问的，那么调用该过程或函数时就不需要额外的指令来传递数据给子程序，从而减少了调用开销。尽管这看起来是一个巨大的优势，但要记住，编译器在优化大量使用全局变量的程序时会遇到困难。虽然使用全局变量可能减少函数/过程调用的开销，但也可能会妨碍编译器处理其他本可以实现的优化。下面是一个简单的Microsoft
    Visual C++示例，展示了这个问题：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s the 32-bit MASM source code (with manual annotations) that the MSVC++
    compiler generates for this code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是32位MASM源代码（带手动注释），这是MSVC++编译器为此代码生成的：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the compiler’s ability to optimize around global variables can
    be easily thwarted by the presence of some seemingly unrelated code. In this example,
    the compiler cannot determine that the call to the external `geti()` function
    doesn’t modify the value of the `globalValue` variable. Therefore, the compiler
    can’t assume that `globalValue` still has the value `1` when it computes the inline
    function result for `usesGlobal()`. Exercise extreme caution when using global
    variables to communicate information between a procedure or function and its caller.
    Code that’s unrelated to the task at hand (such as the call to `geti()`, which
    probably doesn’t affect `globalValue`’s value) can prevent the compiler from optimizing
    code that uses global variables.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，编译器在优化全局变量时的能力很容易被一些看似无关的代码所破坏。在这个例子中，编译器无法确定对外部`geti()`函数的调用不会修改`globalValue`变量的值。因此，编译器不能假设在计算`usesGlobal()`的内联函数结果时，`globalValue`仍然保持值`1`。在使用全局变量在过程或函数与调用者之间传递信息时，要格外小心。与当前任务无关的代码（如对`geti()`的调用，可能并不影响`globalValue`的值）会阻止编译器优化使用全局变量的代码。
- en: '**15.5 Activation Records and the Stack**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**15.5 激活记录与堆栈**'
- en: 'Because of how a stack works, the last procedure activation record the software
    creates will be the first activation record that the system deallocates. Since
    activation records hold procedure parameters and local variables, a *last-in,
    first-out (LIFO)* organization is a very intuitive way of implementing activation
    records. To see how it works, consider the following (trivial) Pascal program:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆栈的工作方式，软件创建的最后一个过程激活记录将是系统首先回收的激活记录。由于激活记录保存过程参数和局部变量，因此*后进先出（LIFO）*的组织方式是实现激活记录的非常直观的方法。为了理解它是如何工作的，考虑下面这个（简单的）Pascal程序：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Figure 15-2](ch15.xhtml#ch15fig2) shows the stack layout as this program executes.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-2](ch15.xhtml#ch15fig2) 显示了程序执行时堆栈的布局。'
- en: When the program begins execution, it first creates an activation record for
    the main program. The main program calls the `A` procedure (①). Upon entry into
    the `A` procedure, the code completes the construction of the activation record
    for `A`, effectively pushing it onto the stack. Once inside procedure `A`, the
    code calls procedure `B` (②). Note that `A` is still active while the code calls
    `B`, so `A`’s activation record remains on the stack. Upon entry into `B`, the
    system builds `B`’s activation record and pushes it onto the top of the stack
    (③). Once inside `B`, the code calls procedure `C`, and `C` builds its activation
    record on the stack and arrives at the comment `(* Stack snapshot here *)` (④).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序开始执行时，首先为主程序创建一个激活记录。主程序调用`A`过程（①）。进入`A`过程时，代码完成`A`的激活记录的构建，并有效地将其压入堆栈中。一旦进入`A`过程，代码调用`B`过程（②）。注意，`A`在代码调用`B`时仍然处于活动状态，因此`A`的激活记录仍然保留在堆栈上。进入`B`后，系统为`B`构建激活记录，并将其压入堆栈的顶部（③）。一旦进入`B`过程，代码调用`C`过程，`C`在堆栈上构建其激活记录，并到达注释`(*
    Stack snapshot here *)`（④）。
- en: '![Image](../images/15fig02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig02.jpg)'
- en: '*Figure 15-2: Stack layout after three nested procedure calls*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：三层嵌套过程调用后的堆栈布局*'
- en: Because procedures keep their local variables and parameter values in their
    activation record, the lifetime of these variables extends from the point the
    system first creates the activation record until the system deallocates it when
    the procedure returns to its caller. In [Figure 15-2](ch15.xhtml#ch15fig2), notice
    that `A`’s activation record remains on the stack during the execution of the
    `B` and `C` procedures. Therefore, the lifetime of `A`’s parameters and local
    variables completely brackets the lifetimes of `B`’s and `C`’s activation records.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序会将它们的局部变量和参数值保存在激活记录中，因此这些变量的生命周期从系统首次创建激活记录时开始，直到程序返回调用者时系统释放激活记录为止。在[图15-2](ch15.xhtml#ch15fig2)中，注意到`A`的激活记录在执行`B`和`C`过程时仍然保留在栈上。因此，`A`的参数和局部变量的生命周期完全覆盖了`B`和`C`激活记录的生命周期。
- en: 'Now consider the following C/C++ code with a recursive function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下带有递归函数的C/C++代码：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This program calls the `recursive()` function three times before it begins returning
    (the main program calls `recursive()` once with the parameter value `2`, and `recursive()`
    calls itself twice with the parameter values `1` and `0`). Because each recursive
    call to `recursive()` pushes another activation record before the current call
    returns, when this program finally hits the `if` statement in this code with `cnt`
    equal to `0`, the stack looks something like [Figure 15-3](ch15.xhtml#ch15fig3).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序在开始返回之前调用了`recursive()`函数三次（主程序调用`recursive()`一次，参数值为`2`，而`recursive()`自身调用了两次，参数值分别为`1`和`0`）。由于每次递归调用`recursive()`时都会在当前调用返回之前再压入一个激活记录，因此，当程序最终在代码中的`if`语句处，`cnt`等于`0`时，栈的情况大致如下图[15-3](ch15.xhtml#ch15fig3)所示。
- en: '![Image](../images/15fig03.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/15fig03.jpg)'
- en: '*Figure 15-3: Stack layout after three recursive procedure calls*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-3：三次递归过程调用后的栈布局*'
- en: Because each procedure invocation has a separate activation record, each activation
    of the procedure will have its own copy of the parameters and local variables.
    While the code for a procedure or function is executing, it will access only those
    local variables and parameters in the activation record it has most recently created,^([3](footnotes.xhtml#ch15fn3))
    thereby preserving the values from previous calls.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个过程调用都有一个单独的激活记录，每次激活该过程时都会有其自身的参数和局部变量副本。程序或函数代码执行时，仅会访问它最新创建的激活记录中的局部变量和参数^([3](footnotes.xhtml#ch15fn3))，从而保留了先前调用的值。
- en: '**15.5.1 Breaking Down the Activation Record**'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**15.5.1 激活记录的分解**'
- en: Now that you’ve seen how procedures manipulate activation records on the stack,
    it’s time to take a look at the internal composition of a typical activation record.
    In this section we’ll use a typical activation record layout that you’ll see when
    executing code on an 80x86\. Although different languages, different compilers,
    and different CPUs lay out the activation record differently, these differences,
    if they exist at all, will be minor.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了程序如何在栈上操作激活记录，接下来我们来看看典型的激活记录的内部组成。在这一节中，我们将使用一个典型的激活记录布局，这是你在执行80x86代码时会看到的布局。虽然不同的编程语言、不同的编译器和不同的CPU对激活记录的布局有所不同，但这些差异（如果有的话）通常是微小的。
- en: 'The 80x86 maintains the stack and activation records using two registers: ESP/RSP
    (the stack pointer) and EBP/RBP (the frame pointer, which Intel calls the *base
    pointer*). The ESP/RSP register points at the current top of stack, and the EBP
    register points at the base address of an activation record.^([4](footnotes.xhtml#ch15fn4))
    A procedure can access objects within its activation record by using the indexed
    addressing mode (see “Indexed Addressing Mode” on [page 34](ch03.xhtml#page_34))
    and supplying a positive or negative offset from the value in the EBP/RBP register.
    Generally, a procedure allocates memory storage for local variables at negative
    offsets from EBP/RBP’s value, and for parameters at positive offsets from EBP/RBP.
    Consider the following Pascal procedure, which has both parameters and local variables:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86使用两个寄存器来管理栈和激活记录：ESP/RSP（栈指针）和EBP/RBP（帧指针，Intel称其为*基址指针*）。ESP/RSP寄存器指向当前栈顶，EBP寄存器指向激活记录的基地址^([4](footnotes.xhtml#ch15fn4))。过程可以通过使用索引寻址模式（见[第34页](ch03.xhtml#page_34)的“索引寻址模式”）并提供从EBP/RBP寄存器值偏移的正负偏移量来访问激活记录中的对象。通常，过程为局部变量分配的内存存储会位于EBP/RBP值的负偏移量处，而为参数分配的内存存储则位于EBP/RBP的正偏移量处。考虑以下的Pascal过程，它同时包含了参数和局部变量：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Figure 15-4](ch15.xhtml#ch15fig4) shows a typical activation record for this
    Pascal procedure (remember that the stack grows toward lower memory on the 32-bit
    80x86).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-4](ch15.xhtml#ch15fig4) 显示了该 Pascal 过程的典型激活记录（请记住，在 32 位 80x86 上，栈是向低地址生长的）。'
- en: '![Image](../images/15fig04.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig04.jpg)'
- en: '*Figure 15-4: A typical activation record*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：典型的激活记录*'
- en: When you see the term *base* associated with a memory object, you might think
    that the base address is the lowest address of that object in memory. However,
    there’s no such requirement. The base address is simply the address in memory
    on which you base the offsets to particular fields of that object. As this activation
    record demonstrates, 80x86 activation record base addresses are actually in the
    middle of the record.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到与内存对象相关的术语 *base* 时，你可能会认为基地址是该对象在内存中最低的地址。然而，实际上并没有这样的要求。基地址只是内存中你用来基准偏移量以访问该对象特定字段的地址。如这个激活记录所示，80x86
    激活记录的基地址实际上位于记录的中间。
- en: 'The activation record is constructed in two phases. The first phase begins
    when the code calling the procedure pushes the parameters for the call onto the
    stack. For example, consider the following call to `HasBoth()` in the previous
    example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 激活记录的构建分为两个阶段。第一阶段始于调用过程的代码将调用的参数压入栈中。例如，考虑下面在之前示例中对 `HasBoth()` 的调用：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s the HLA/x86 assembly code that might correspond to this call:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是可能对应于此调用的 HLA/x86 汇编代码：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The three `push` instructions in this code sequence build the first three double
    words of the activation record, and the `call` instruction pushes a *return address*
    onto the stack, creating the fourth double word in the activation record. After
    the call, execution continues in the `HasBoth()` procedure itself, where the program
    continues to build the activation record.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的三个 `push` 指令构建了激活记录的前三个双字，而 `call` 指令将 *返回地址* 压入栈中，创建了激活记录的第四个双字。调用后，执行继续进入
    `HasBoth()` 过程本身，程序在该过程中继续构建激活记录。
- en: The first few instructions of the `HasBoth()` procedure are responsible for
    finishing the construction of the activation record. Immediately upon entry into
    `HasBoth()`, the stack takes the form shown in [Figure 15-5](ch15.xhtml#ch15fig5).^([5](footnotes.xhtml#ch15fn5))
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasBoth()` 过程的前几条指令负责完成激活记录的构建。进入 `HasBoth()` 后，栈呈现出 [图 15-5](ch15.xhtml#ch15fig5)
    中所示的形式。^([5](footnotes.xhtml#ch15fn5))'
- en: '![Image](../images/15fig05.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig05.jpg)'
- en: '*Figure 15-5: Activation record upon entry to HasBoth()*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-5：进入 HasBoth() 时的激活记录*'
- en: 'The first thing the procedure’s code should do is to preserve the value in
    the 80x86 EBP register. On entry, EBP probably points at the base address of the
    caller’s activation record. On exit from `HasBoth()`, EBP needs to contain its
    original value. Therefore, upon entry, `HasBoth()` needs to push the current value
    of EBP on the stack in order to preserve EBP’s value. Next, the `HasBoth()` procedure
    needs to change EBP so that it points at the base address of the `HasBoth()` activation
    record. The following HLA/x86 code takes care of these two operations:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程代码的第一件事应该是保留 80x86 EBP 寄存器中的值。进入时，EBP 可能指向调用者激活记录的基址。退出 `HasBoth()` 时，EBP
    需要包含其原始值。因此，在进入时，`HasBoth()` 需要将当前的 EBP 值压入栈中，以保留 EBP 的值。接下来，`HasBoth()` 过程需要更改
    EBP，使其指向 `HasBoth()` 激活记录的基址。以下 HLA/x86 代码处理了这两个操作：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, the code at the beginning of `HasBoth()` needs to allocate storage
    for its local (automatic) variables. As you saw in [Figure 15-4](ch15.xhtml#ch15fig4),
    those variables sit below the frame pointer in the activation record. To prevent
    future pushes from wiping out the values in those local variables, the code has
    to set ESP to the address of the last double word of local variables in the activation
    record. To accomplish this, it simply subtracts the number of bytes of local variables
    from ESP via the following machine instruction:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`HasBoth()` 开头的代码需要为其局部（自动）变量分配存储空间。如 [图 15-4](ch15.xhtml#ch15fig4) 所示，这些变量位于激活记录中的帧指针下方。为了防止未来的压栈操作覆盖这些局部变量的值，代码必须将
    ESP 设置为激活记录中最后一个局部变量双字的地址。为了实现这一点，它通过以下机器指令将局部变量的字节数从 ESP 中减去：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The *standard entry sequence* for a procedure like `HasBoth()` consists of
    the three machine instructions just considered—`push(ebp);`, `mov(esp, ebp);`,
    and `sub(12, esp);`—which complete the construction of the activation record inside
    the procedure. Just before returning, the Pascal procedure is responsible for
    deallocating the storage associated with the activation record. The *standard
    exit sequence* usually takes the following form (in HLA) for a Pascal procedure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`HasBoth()`这样的过程，*标准入口序列*包括刚才提到的三条机器指令——`push(ebp);`、`mov(esp, ebp);`和`sub(12,
    esp);`——它们完成了过程内激活记录的构建。在返回之前，Pascal过程负责释放与激活记录相关的存储空间。*标准退出序列*通常在Pascal过程中以以下形式出现（在HLA中）：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first instruction deallocates storage for the local variables shown in
    [Figure 15-4](ch15.xhtml#ch15fig4). Note that EBP is pointing at the old value
    of EBP; this value is stored at the memory address just above all the local variables.
    By copying the value in EBP to ESP, we move the stack pointer past all the local
    variables, effectively deallocating them. Now, the stack pointer points at the
    old value of EBP on the stack; therefore, the `pop` instruction in this sequence
    restores EBP’s original value and leaves ESP pointing at the return address on
    the stack. The `ret` instruction in the standard exit sequence does two things:
    it pops the return address from the stack (and, of course, transfers control to
    this address), and it removes 12 bytes of parameters from the stack. Because `HasBoth()`
    has three double-word parameters, popping 12 bytes from the stack removes those
    parameters.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令为[图 15-4](ch15.xhtml#ch15fig4)中显示的局部变量释放存储空间。请注意，EBP指向EBP的旧值；该值存储在所有局部变量上方的内存地址中。通过将EBP中的值复制到ESP，我们将堆栈指针移动过所有局部变量，从而有效地释放它们。现在，堆栈指针指向堆栈上EBP的旧值；因此，该序列中的`pop`指令恢复EBP的原始值，并将ESP指向堆栈上的返回地址。标准退出序列中的`ret`指令执行两项操作：它从堆栈中弹出返回地址（并将控制权转移到该地址），并从堆栈中移除12个字节的参数。因为`HasBoth()`有三个双字参数，从堆栈中弹出12个字节会移除这些参数。
- en: '**15.5.2 Assigning Offsets to Local Variables**'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**15.5.2 分配局部变量的偏移量**'
- en: This `HasBoth()` example allocates local (automatic) variables in the order
    the compiler encounters them. A typical compiler maintains a *current offset*
    (the initial value of which will be 0) into the activation record for local variables.
    Whenever the compiler encounters a local variable, it subtracts the variable’s
    size from the current offset and then uses the result as the offset of the local
    variable (from EBP/RBP) in the activation record. For example, upon encountering
    the declaration for variable `a`, the compiler subtracts the size of `a` (4 bytes,
    assuming `a` is a 32-bit integer) from the current offset (0) and uses the result
    (–4) as the offset for `a`. Next, the compiler encounters variable `r` (which
    is also 4 bytes), sets the current offset to –8, and assigns this offset to `r`.
    This process repeats for each of the local variables in the procedure.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`HasBoth()`示例按照编译器遇到局部变量的顺序分配局部（自动）变量。典型的编译器维护一个*当前偏移量*（初始值为0），该偏移量用于局部变量的激活记录。每当编译器遇到一个局部变量时，它会从当前偏移量中减去该变量的大小，然后使用结果作为局部变量在激活记录中的偏移量（相对于EBP/RBP）。例如，遇到变量`a`的声明时，编译器将`a`的大小（假设`a`是32位整数，占用4字节）从当前偏移量（0）中减去，并将结果（–4）作为`a`的偏移量。接下来，编译器遇到变量`r`（同样占用4字节），将当前偏移量设置为–8，并将此偏移量分配给`r`。这个过程对程序中的每个局部变量都会重复进行。
- en: Although this is a typical way that compilers assign offsets to local variables,
    most languages give compiler implementers free rein to allocate local objects
    as they see fit. A compiler can rearrange the objects in the activation record
    if doing so is more convenient. This means you should avoid designing algorithms
    that depend on the previously mentioned allocation scheme, because some compilers
    do it differently.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是编译器分配局部变量偏移量的典型方式，但大多数语言允许编译器实现者根据需要自由分配局部对象。如果这样做更为方便，编译器可以重新排列激活记录中的对象。这意味着你应该避免设计依赖于上述分配方案的算法，因为某些编译器的做法可能不同。
- en: 'Many compilers try to ensure that all local variables you declare have an offset
    that is a multiple of the object’s size. For example, suppose you have the following
    two declarations in a C function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编译器尝试确保你声明的所有局部变量的偏移量都是对象大小的倍数。例如，假设你在C函数中有以下两个声明：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Normally, you’d expect that the compiler would attach an offset like –1 to the
    `c` variable and –5 to the (4-byte) `int` variable `i`. However, some CPUs (such
    as RISC CPUs) require the compiler to allocate double-word objects on a double-word
    boundary. Even on CPUs that don’t require this (for example, the 80x86), it may
    be faster to access a double-word variable if the compiler aligns it on a double-word
    boundary. For this reason (and as previous chapters have described), many compilers
    automatically add padding bytes between local variables so that each variable
    resides at a *natural* offset in the activation record. In general, bytes may
    appear at any offset, words are happiest on even address boundaries, and double
    words should have a memory address that is a multiple of 4.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会期望编译器为`c`变量分配偏移量–1，为（4字节）`int`变量`i`分配偏移量–5。然而，一些CPU（例如RISC CPU）要求编译器将双字对象分配在双字边界上。即使是在不要求这样做的CPU上（例如80x86），如果编译器将双字变量对齐到双字边界上，访问该变量可能会更快。正因为如此（如前面章节所述），许多编译器会自动在局部变量之间添加填充字节，使得每个变量位于激活记录中的*自然*偏移量。一般来说，字节可以出现在任何偏移量上，字最好位于偶数地址边界上，而双字则应该位于地址是4的倍数的内存地址上。
- en: 'Although an optimizing compiler might automatically handle this alignment for
    you, that comes with a cost—those extra padding bytes. As explained earlier, compilers
    are usually free to rearrange the variables in an activation record, but they
    don’t always do so. Therefore, if you intertwine the definitions for several byte,
    word, double-word, and other-sized objects in your local variable declarations,
    the compiler may wind up inserting several bytes of padding into the activation
    record. You can minimize this problem by attempting to group as many like-sized
    objects together as is reasonable in your procedures and functions. Consider the
    following C/C++ code on a 32-bit machine:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一个优化编译器可能会自动为你处理这种对齐，但这样做是有代价的——那些额外的填充字节。如前所述，编译器通常可以自由地重新排列激活记录中的变量，但它们并不总是这样做。因此，如果你在局部变量声明中交织了多个字节、字、双字和其他大小的对象，编译器最终可能会在激活记录中插入几字节的填充字节。你可以通过尽可能合理地将相同大小的对象分组在你的过程和函数中，从而最小化这个问题。考虑以下在32位机器上的C/C++代码：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An optimizing compiler may elect to insert 3 bytes of padding between each
    of these character variables and the (4-byte) integer variable that immediately
    follows. This means that the preceding code will have about 12 bytes of wasted
    space (3 bytes for each of the character variables). Now consider the following
    declarations in the same C code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优化编译器可能会选择在每个字符变量和紧随其后的（4字节）整数变量之间插入3字节的填充字节。这意味着前述代码将浪费大约12字节的空间（每个字符变量占3字节）。现在考虑以下相同C代码中的声明：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, the compiler won’t emit any extra padding bytes to the code.
    Why? Because characters (being 1 byte each) may begin at any address in memory.^([6](footnotes.xhtml#ch15fn6))
    Therefore, the compiler can place these character variables at offsets –1, –2,
    –3, and –4 within the activation record. Because the last character variable appears
    at an address that is a multiple of 4, the compiler doesn’t need to insert any
    padding bytes between `c3` and `i0` (`i0` will naturally appear at offset –8 in
    the preceding declarations).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，编译器不会为代码插入任何额外的填充字节。为什么？因为字符（每个字符为1字节）可以在内存中的任何地址开始。^([6](footnotes.xhtml#ch15fn6))
    因此，编译器可以将这些字符变量放置在激活记录中的偏移量–1、–2、–3和–4处。由于最后一个字符变量出现在一个是4的倍数的地址上，编译器不需要在`c3`和`i0`之间插入任何填充字节（`i0`会自然地出现在前述声明中的偏移量–8处）。
- en: As you can see, arranging your declarations so that all like-sized objects are
    next to one another can help your compiler produce better code. Don’t take this
    suggestion to an extreme, though. If a rearrangement would make your program more
    difficult to read or maintain, you should carefully consider whether it’s worthwhile
    in your program.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，将你的声明安排得使得所有相同大小的对象彼此相邻，可以帮助编译器生成更好的代码。然而，不要把这个建议极端化。如果重新排列会使你的程序更难以阅读或维护，那么你应该仔细考虑在程序中是否值得这样做。
- en: '**15.5.3 Associating Offsets with Parameters**'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**15.5.3 将偏移量与参数关联**'
- en: As noted, compilers are given considerable leeway with respect to how they assign
    offsets to local (automatic) variables within a procedure. As long as the compiler
    uses these offsets consistently, the exact allocation algorithm it applies is
    almost irrelevant; in fact, it could use a different allocation scheme in different
    procedures of the same program. However, a compiler *doesn’t* have free rein when
    assigning offsets to parameters. It has to live with certain restrictions, because
    other code outside the procedure accesses those parameters. Specifically, the
    procedure and the calling code must agree on the layout of the parameters in the
    activation record so the calling code can build the parameter list. Note that
    the calling code might not be in the same source file, or even in the same programming
    language, as the procedure. To ensure interoperability between a procedure and
    whatever code calls that procedure, then, compilers must adhere to certain *calling
    conventions*. This section will explore the three common calling conventions for
    Pascal/Delphi and C/C++.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编译器在为过程中的局部（自动）变量分配偏移量时，拥有相当大的自由度。只要编译器一致地使用这些偏移量，它所采用的具体分配算法几乎是无关紧要的；实际上，它可以在同一程序的不同过程使用不同的分配方案。然而，编译器*不能*在为参数分配偏移量时完全自由。因为过程外部的其他代码也会访问这些参数。具体来说，过程和调用代码必须就激活记录中参数的布局达成一致，以便调用代码可以构建参数列表。请注意，调用代码可能不在同一个源文件中，甚至可能不在同一种编程语言中。为了确保过程和调用该过程的任何代码之间的互操作性，编译器必须遵循某些*调用约定*。本节将探讨
    Pascal/Delphi 和 C/C++ 的三种常见调用约定。
- en: '**15.5.3.1 The Pascal Calling Convention**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**15.5.3.1 Pascal 调用约定**'
- en: 'In Pascal (including Delphi) the standard parameter-passing convention is to
    push the parameters on the stack in the order of their appearance in the parameter
    list. Consider the following call to the `HasBoth()` procedure from the earlier
    example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pascal（包括 Delphi）中，标准的参数传递约定是将参数按照在参数列表中的出现顺序推送到堆栈中。考虑以下对早期示例中 `HasBoth()`
    过程的调用：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following assembly code implements this call:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下汇编代码实现了这一调用：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When assigning offsets to a procedure’s formal parameters, the compiler assigns
    the highest offset to the first parameter and the lowest offset to the last parameter.
    Because the old value of EBP is at offset 0 in the activation record and the return
    address is at offset 4, the last parameter in the activation record (when using
    the Pascal calling convention on the 80x86 CPU) will reside at offset 8 from EBP.
    Looking back at [Figure 15-4](ch15.xhtml#ch15fig4), you can see that parameter
    `k` is at offset +8, parameter `j` is at offset +12, and parameter `i` (the first
    parameter) is at offset +16 in the activation record.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在为过程的正式参数分配偏移量时，编译器将第一个参数分配给最高的偏移量，而将最后一个参数分配给最低的偏移量。由于 EBP 的旧值在激活记录中的偏移量为 0，返回地址的偏移量为
    4，因此在激活记录中（当使用 Pascal 调用约定并且在 80x86 CPU 上时）最后一个参数将位于 EBP 偏移量 +8 处。回顾 [图 15-4](ch15.xhtml#ch15fig4)，你可以看到参数
    `k` 位于偏移量 +8，参数 `j` 位于偏移量 +12，而参数 `i`（第一个参数）位于偏移量 +16。
- en: The Pascal calling convention also stipulates that it is the procedure’s responsibility
    to remove the parameters the caller pushes when the procedure returns to its caller.
    As you saw earlier, the 80x86 CPU provides a variant of the `ret` instruction
    that lets you specify how many bytes of parameters to remove from the stack upon
    return. Therefore, a procedure that uses the Pascal calling convention will typically
    supply the number of parameter bytes as an operand to the `ret` instruction when
    returning to its caller.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 调用约定还规定，当过程返回到其调用者时，程序必须负责清除调用者推送的参数。如前所述，80x86 CPU 提供了一种 `ret` 指令的变种，允许你指定在返回时从堆栈中移除多少字节的参数。因此，使用
    Pascal 调用约定的过程通常会在返回到其调用者时，将参数字节数作为操作数传递给 `ret` 指令。
- en: '**15.5.3.2 The C Calling Convention**'
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**15.5.3.2 C 调用约定**'
- en: The C/C++/Java languages employ another very popular calling convention, generally
    known as the *cdecl calling convention* (or, simply, the *C calling convention*).
    There are two major differences between the C and Pascal calling conventions.
    First, calls to functions in C must push their parameters on the stack in the
    reverse order. That is, the first parameter must appear at the lowest address
    on the stack (assuming the stack grows downward), and the last parameter must
    appear at the highest address in memory. The second difference is that C requires
    the caller, rather than the function, to remove all parameters from the stack.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++/Java语言采用了另一种非常流行的调用约定，通常称为*cdecl调用约定*（或简称*C调用约定*）。C调用约定与Pascal调用约定有两个主要区别。首先，C语言中的函数调用必须按反向顺序将参数压入栈中。也就是说，第一个参数必须位于栈上的最低地址（假设栈向下增长），最后一个参数必须位于内存中的最高地址。第二个区别是C语言要求调用者而非函数来从栈中移除所有参数。
- en: 'Consider the following version of `HasBoth()` written in C instead of Pascal:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下使用C语言编写的`HasBoth()`版本，而不是Pascal：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Figure 15-6](ch15.xhtml#ch15fig6) provides the layout for a typical `HasBoth`
    activation record (written in C on a 32-bit 80x86 processor).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-6](ch15.xhtml#ch15fig6)展示了典型的`HasBoth`激活记录的布局（在32位80x86处理器上使用C语言编写）。'
- en: '![Image](../images/15fig06.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig06.jpg)'
- en: '*Figure 15-6: HasBoth() activation record in C*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-6：C语言中的HasBoth()激活记录*'
- en: Looking closely, you’ll see the difference between this figure and [Figure 15-4](ch15.xhtml#ch15fig4).
    The positions of the `i` and `k` variables are reversed in this activation record
    (it’s only a coincidence that `j` appears at the same offset in both).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你会看到这个图与[图15-4](ch15.xhtml#ch15fig4)之间的区别。`i`和`k`变量的位置在这个激活记录中被颠倒了（巧合的是，`j`在两个图中的偏移量相同）。
- en: 'Because the C calling convention reverses the order of the parameters and it’s
    the caller’s responsibility to remove all parameter values from the stack, the
    calling sequence for `HasBoth()` is a little different in C than in Pascal. Consider
    the following call to `HasBoth()`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C调用约定会颠倒参数顺序，并且由调用者负责从栈中移除所有参数值，因此`HasBoth()`在C中的调用顺序与Pascal有所不同。请考虑以下对`HasBoth()`的调用：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s the HLA assembly code for this call:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这次调用的HLA汇编代码：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As a result of using the C calling convention, this code differs in two ways
    from the assembly code for the Pascal implementation. First, this example pushes
    the values of the actual parameters in the opposite order of the Pascal code;
    that is, it first computes `y+2` and pushes that value, then it pushes `x`, and
    finally it pushes the value `5`. The second difference is the inclusion of the
    `add(12,esp);` instruction immediately after the call. This instruction removes
    12 bytes of parameters from the stack upon return. The return from `HasBoth()`
    will use only the `ret` instruction, not the `ret n` instruction.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了C调用约定，这段代码与Pascal实现的汇编代码有两个不同之处。首先，这个例子以与Pascal代码相反的顺序压入实际参数的值；也就是说，它先计算`y+2`并将该值压入栈中，然后再压入`x`，最后压入值`5`。第二个不同之处是在调用之后立即包含了`add(12,esp);`指令。这条指令在返回时从栈中移除12个字节的参数。`HasBoth()`的返回只会使用`ret`指令，而不是`ret
    n`指令。
- en: '**15.5.3.3 Conventions for Passing Parameters in Registers**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**15.5.3.3 在寄存器中传递参数的约定**'
- en: As you’ve seen in these examples, passing parameters on the stack between two
    procedures or functions requires a fair amount of code. Good assembly language
    programmers have long known that it’s better to pass parameters in registers.
    Therefore, several 80x86 compilers following Intel’s ABI (application binary interface)
    rules may attempt to pass as many as three parameters in the EAX, EDX, and ECX
    registers.^([7](footnotes.xhtml#ch15fn7)) Most RISC processors specifically set
    aside a set of registers for passing parameters between functions and procedures.
    See “Registers to the Rescue” on [page 585](ch15.xhtml#page_585) for more information.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这些例子中看到的那样，在两个过程或函数之间通过栈传递参数需要相当多的代码。优秀的汇编语言程序员早就知道，最好通过寄存器传递参数。因此，遵循Intel
    ABI（应用二进制接口）规则的多个80x86编译器可能尝试将最多三个参数通过EAX、EDX和ECX寄存器传递。^([7](footnotes.xhtml#ch15fn7))
    大多数RISC处理器专门为函数和过程之间传递参数预留了一组寄存器。有关更多信息，请参见[第585页](ch15.xhtml#page_585)的“寄存器的拯救”。
- en: 'Most CPUs require that the stack pointer remain aligned on some reasonable
    boundary (for example, a double-word boundary), and CPUs that don’t absolutely
    require this may still benefit from it. Furthermore, many CPUs (the 80x86 included)
    can’t easily push certain small-sized objects, like bytes, onto the stack. Therefore,
    most compilers reserve a minimum number of bytes for a parameter (typically 4),
    regardless of its actual size. As an example, consider the following HLA procedure
    fragment:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 CPU 要求堆栈指针保持在某个合理的边界上（例如，双字边界），即使是那些不绝对要求这一点的 CPU，仍然可能从中受益。此外，许多 CPU（包括
    80x86）无法轻松地将某些小尺寸的对象（如字节）推入堆栈。因此，大多数编译器为一个参数保留最少的字节数（通常是 4 字节），无论其实际大小如何。作为一个例子，考虑下面的
    HLA 过程片段：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The activation record for this procedure appears in [Figure 15-7](ch15.xhtml#ch15fig7).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的激活记录显示在[图 15-7](ch15.xhtml#ch15fig7)中。
- en: '![Image](../images/15fig07.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig07.jpg)'
- en: '*Figure 15-7: OneByteParm() activation record*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-7：OneByteParm() 激活记录*'
- en: As you can see, the HLA compiler reserves 4 bytes for the `b` parameter even
    though `b` is only a single-byte variable. This extra padding ensures that the
    ESP register will remain aligned on a double-word boundary.^([8](footnotes.xhtml#ch15fn8))
    We can easily push the value of `b` onto the stack in the code that calls `OneByteParm()`
    using a 4-byte `push` instruction.^([9](footnotes.xhtml#ch15fn9))
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，HLA 编译器为 `b` 参数保留了 4 字节，尽管 `b` 只是一个单字节变量。这个额外的填充确保了 ESP 寄存器将保持在双字边界对齐。^([8](footnotes.xhtml#ch15fn8))
    我们可以通过 4 字节的 `push` 指令轻松地将 `b` 的值推入调用 `OneByteParm()` 的堆栈中。^([9](footnotes.xhtml#ch15fn9))
- en: Even if your program could access the extra bytes of padding associated with
    the `b` parameter, doing so is never a good idea. Unless you’ve explicitly pushed
    the parameter onto the stack (for example, using assembly language code), there’s
    no guarantee about the data values that appear in the padding bytes. In particular,
    they may not contain 0\. Nor should your code assume that the padding is present
    or that the compiler pads such variables out to 4 bytes. Some 16-bit processors
    may require only a single byte of padding. Some 64-bit processors may require
    7 bytes of padding. Some compilers on the 80x86 may use 1 byte of padding, while
    others use 3 bytes. Unless you’re willing to live with code that only one compiler
    can compile (and code that could break when the next version of the compiler comes
    along), it’s best to ignore these padding bytes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的程序可以访问与`b`参数相关的额外填充字节，这样做也从来不是一个好主意。除非你明确地将参数推入堆栈（例如，使用汇编语言代码），否则不能保证填充字节中的数据值。特别地，它们可能不包含
    0。你的代码也不应假设填充字节存在，或者编译器将这些变量填充到 4 字节。一些 16 位处理器可能只需要 1 字节的填充。一些 64 位处理器可能需要 7
    字节的填充。一些 80x86 上的编译器可能使用 1 字节的填充，而其他编译器使用 3 字节的填充。除非你愿意接受只有一个编译器能够编译的代码（并且代码可能在下一个编译器版本发布时无法工作），否则最好忽略这些填充字节。
- en: '**15.5.4 Accessing Parameters and Local Variables**'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**15.5.4 访问参数和局部变量**'
- en: Once a subroutine sets up the activation record, accessing local (automatic)
    variables and parameters is easy. The machine code simply uses the indexed addressing
    mode to access such objects. Consider again the activation record in [Figure 15-4](ch15.xhtml#ch15fig4).
    The variables in the `HasBoth()` procedure have the offsets found in [Table 15-1](ch15.xhtml#ch15tab1).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦子程序设置了激活记录，访问局部（自动）变量和参数就变得非常容易。机器代码只需要使用索引寻址模式来访问这些对象。再考虑一下[图 15-4](ch15.xhtml#ch15fig4)中的激活记录。`HasBoth()`过程中的变量在[表
    15-1](ch15.xhtml#ch15tab1)中列出了其偏移量。
- en: '**Table 15-1:** Offsets to Local Variables and Parameters in `HasBoth()` (Pascal
    Version)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-1：** `HasBoth()` 中局部变量和参数的偏移量（Pascal 版本）'
- en: '| **Variable** | **Offset** | **Addressing mode example** |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **偏移量** | **寻址模式示例** |'
- en: '| `i` | +16 | `mov( [ebp+16], eax );` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `i` | +16 | `mov( [ebp+16], eax );` |'
- en: '| `j` | +12 | `mov( [ebp+12], eax );` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `j` | +12 | `mov( [ebp+12], eax );` |'
- en: '| `k` | +8 | `mov( [ebp+8], eax );` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `k` | +8 | `mov( [ebp+8], eax );` |'
- en: '| `a` | –4 | `mov( [ebp-4], eax );` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `a` | –4 | `mov( [ebp-4], eax );` |'
- en: '| `r` | –8 | `mov( [ebp-8], eax );` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `r` | –8 | `mov( [ebp-8], eax );` |'
- en: '| `c` | –9 | `mov( [ebp-9], al );` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `c` | –9 | `mov( [ebp-9], al );` |'
- en: '| `b` | –10 | `mov( [ebp-10], al );` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `b` | –10 | `mov( [ebp-10], al );` |'
- en: '| `w` | –12 | `mov( [ebp-12], ax );` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `w` | –12 | `mov( [ebp-12], ax );` |'
- en: The compiler allocates static local variables in a procedure at a fixed address
    in memory. Static variables do not appear in the activation record, so the CPU
    accesses static objects using the direct addressing mode.^([10](footnotes.xhtml#ch15fn10))
    As [Chapter 3](ch03.xhtml#ch03) discussed, in 80x86 assembly language instructions
    that use the direct addressing mode need to encode the full 32-bit address as
    part of the machine instruction. Therefore, instructions that use the direct addressing
    mode are usually at least 5 bytes long (and often longer). On the 80x86, if the
    offset from EBP is –128 through +127, then a compiler can encode an instruction
    of the form `[ebp + constant`] in as few as 2 or 3 bytes. Such instructions will
    be more efficient than those that encode a full 32-bit address. The same principle
    applies on other processors, even if those CPUs provide different addressing modes,
    address sizes, and so on. Specifically, accessing local variables whose offset
    is relatively small is generally more efficient than accessing static variables
    or variables with larger offsets.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将静态局部变量分配在函数的固定内存地址。静态变量不会出现在激活记录中，因此 CPU 使用直接寻址模式访问静态对象。^([10](footnotes.xhtml#ch15fn10))
    如[第 3 章](ch03.xhtml#ch03)所讨论，在 80x86 汇编语言中，使用直接寻址模式的指令需要将完整的 32 位地址编码为机器指令的一部分。因此，使用直接寻址模式的指令通常至少为
    5 个字节长（而且通常更长）。在 80x86 上，如果 EBP 的偏移量在 –128 到 +127 之间，那么编译器可以将形式为 `[ebp + constant]`
    的指令编码为 2 或 3 个字节。这样的指令比编码完整 32 位地址的指令更高效。这个原则适用于其他处理器，即使这些 CPU 提供不同的寻址模式、地址大小等。具体来说，访问偏移量较小的局部变量通常比访问静态变量或偏移量较大的变量更高效。
- en: Because most compilers allocate offsets for local (automatic) variables as the
    compiler encounters them, the first 128 bytes of local variables will be the ones
    with the shortest offsets (at least, on the 80x86; this value may be different
    for other processors).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数编译器在遇到局部（自动）变量时会为其分配偏移量，局部变量的前 128 个字节将具有最短的偏移量（至少在 80x86 上是这样；对于其他处理器，这个值可能不同）。
- en: 'Consider the following two sets of local variable declarations (presumably
    appearing with some C function):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两组局部变量声明（假设它们出现在某个 C 函数中）：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here’s a second version of these declarations:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个版本的声明：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Although these two declaration sections are semantically identical, there is
    a big difference in the code a compiler for the 32-bit 80x86 generates to access
    these variables. In the first declaration, the variable `string` appears at offset
    –256 within the activation record, `i` appears at offset –260, `j` appears at
    offset –264, and `c` appears at offset –265\. Because these offsets are outside
    the range –128 through +127, the compiler will have to emit machine instructions
    that encode a 4-byte offset constant rather than a 1-byte constant. Accordingly,
    the code associated with these declarations will be larger and may run slower.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个声明部分在语义上是相同的，但编译器为 32 位 80x86 生成的访问这些变量的代码有很大差异。在第一个声明中，变量 `string` 在激活记录中的偏移量为
    –256，`i` 在 –260，`j` 在 –264，`c` 在 –265。由于这些偏移量超出了 –128 到 +127 的范围，编译器将不得不生成编码 4
    字节偏移常量的机器指令，而不是 1 字节常量。因此，关联的代码会更大，并且可能运行得更慢。
- en: 'Now consider the second declaration. In this example the programmer declares
    the scalar (non-array) objects first. Therefore, the variables have the following
    offsets: `i` at –4, `j` at –8, `c` at –9, and `string` at –265\. This turns out
    to be the optimal configuration for these variables (`i`, `j`, and `c` will use
    1-byte offsets; `string` will require a 4-byte offset).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑第二个声明。在这个例子中，程序员首先声明标量（非数组）对象。因此，变量的偏移量如下：`i` 为 –4，`j` 为 –8，`c` 为 –9，`string`
    为 –265。这被证明是这些变量的最优配置（`i`、`j` 和 `c` 将使用 1 字节偏移量；`string` 将需要 4 字节偏移量）。
- en: 'This example demonstrates another rule you should try to follow when declaring
    local (automatic) variables: declare smaller, scalar objects first within a procedure,
    followed by all the arrays, structures/records, and other large objects.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了你在声明局部（自动）变量时应该遵循的另一条规则：在一个过程内，首先声明较小的标量对象，然后声明所有数组、结构体/记录和其他大对象。
- en: As explained in “Associating Offsets with Parameters” on [page 570](ch15.xhtml#page_570),
    if you declare several local objects with differing sizes adjacent to one another,
    the compiler may need to insert padding bytes to keep the larger objects aligned
    at an appropriate memory address. While worrying about a few wasted bytes here
    and there may seem ridiculous on machines with a gigabyte (or more) of RAM, those
    few padding bytes could be just enough to push the offsets of certain local variables
    beyond –128, causing the compiler to emit 4-byte offsets rather than 1-byte offsets
    for those variables. This is one more reason you should try to declare like-sized
    local variables adjacent to one another.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在《将偏移量与参数关联》一节中所解释的，参见[第570页](ch15.xhtml#page_570)，如果你声明了几个不同大小的局部对象并将它们相邻放置，编译器可能需要插入填充字节，以确保较大的对象在合适的内存地址处对齐。虽然在拥有千兆字节（或更多）内存的机器上为几字节的浪费而烦恼看起来很荒谬，但这些填充字节可能恰好足以将某些局部变量的偏移量推得超过–128，从而导致编译器为这些变量发出4字节的偏移量，而不是1字节的偏移量。这也是你应该尽量将大小相似的局部变量放在一起声明的另一个原因。
- en: 'On RISC processors, such as the PowerPC or ARM, the range of possible offsets
    is usually much greater than ±128\. This is a good thing, because once you exceed
    the range of the activation record offset that a RISC CPU can encode directly
    into an instruction, parameter and local variable access gets very expensive.
    Consider the following C program:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在RISC处理器（如PowerPC或ARM）上，可能的偏移量范围通常比±128大得多。这是件好事，因为一旦你超出了RISC CPU可以直接在指令中编码的激活记录偏移量范围，参数和局部变量的访问将变得非常昂贵。考虑以下的C程序：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here’s the PowerPC assembly output from GCC:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自GCC的PowerPC汇编输出：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This compilation was done under GCC without optimization to show what happens
    when your activation record grows to the point you can no longer encode activation
    record offsets into the instruction.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编译是在没有优化的情况下通过GCC完成的，目的是展示当激活记录增长到你无法再将激活记录偏移量编码到指令中时会发生什么。
- en: 'To encode the address of `e`, whose offset is too large, we need these three
    instructions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要编码偏移量过大的`e`的地址，我们需要这三条指令：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'instead of a single instruction that stores `R0` into the `a` variable, such
    as:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是一条将`R0`存储到`a`变量中的指令，如：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: While two extra instructions in a program of this size might seem insignificant,
    keep in mind that the compiler will generate these extra instructions for each
    such access. If you frequently access a local variable with a huge offset, the
    compiler may generate a significant number of extra instructions throughout your
    function or procedure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个大小的程序中，增加两条额外指令看起来似乎微不足道，但请记住，编译器会为每次这样的访问生成这些额外的指令。如果你频繁访问一个偏移量巨大的局部变量，编译器可能会在你的函数或过程内生成大量的额外指令。
- en: 'Of course, in a standard application running on a RISC, this problem seldom
    occurs because we rarely allocate local storage beyond the range that a single
    instruction can encode. Also, RISC compilers generally allocate scalar (non-array/non-structure)
    objects in registers rather than blindly allocating them at the next memory address
    in the activation record. For example, if you turn on GCC’s optimization with
    the `-O2` command-line switch, you’ll get the following PowerPC output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在标准的RISC应用程序中，这个问题很少出现，因为我们很少会分配超出单条指令能够编码的激活记录偏移量的局部存储。此外，RISC编译器通常将标量（非数组/非结构）对象分配到寄存器中，而不是盲目地将它们分配到激活记录中的下一个内存地址。例如，如果你在命令行中使用`-O2`开关开启GCC优化，你会得到以下PowerPC输出：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: One thing that you’ll notice in this version with optimization enabled is that
    GCC did not allocate variables in the activation record as they were encountered.
    Instead, it placed most of the objects in registers (even array elements). Keep
    in mind that an optimizing compiler may very well rearrange all the local variables
    you declare.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个启用了优化的版本中，你会注意到一个现象，那就是GCC没有按照遇到变量的顺序分配变量到激活记录中。而是将大部分对象放入了寄存器中（即使是数组元素）。请记住，一个优化的编译器很可能会重新排列你声明的所有局部变量。
- en: 'The ARM processor has similar limitations based on the size of the instruction
    opcode (32 bits). Here’s the (unoptimized) ARM output from GCC:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ARM处理器有类似的限制，这些限制基于指令操作码的大小（32位）。这是来自GCC的（未优化的）ARM输出：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: While this is arguably better than the PowerPC code, there’s still considerable
    ugliness in the address computations because the ARM CPU cannot encode 32-bit
    constants as part of the instruction opcode. To understand why GCC emits such
    bizarre constants to compute offsets into the activation record, see the discussion
    of the ARM immediate operands in the section “The Immediate Addressing Mode” in
    Appendix C online.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这比PowerPC代码要好，但由于ARM CPU不能将32位常量编码为指令操作码的一部分，地址计算中仍然存在相当大的不美观。要理解为什么GCC会发出如此奇怪的常量来计算激活记录中的偏移量，请参阅在线附录C中“立即寻址模式”一节中对ARM立即数操作数的讨论。
- en: 'If you find the optimized PowerPC or ARM code a bit hard to follow, consider
    the following 80x86 GCC output for the same C program:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现优化后的PowerPC或ARM代码有些难以理解，可以考虑以下同一C程序的80x86 GCC输出：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Of course, the 80x86 doesn’t have as many registers to use for passing parameters
    and holding local variables, so the 80x86 code has to allocate more locals in
    the activation record. Also, the 80x86 provides an offset range of –128 to +127
    bytes only around the EBP register, so a larger number of instructions have to
    use the 4-byte offset rather than the 1-byte offset. Fortunately, the 80x86 does
    allow you to encode a full 32-bit address as part of the instructions that access
    memory, so you don’t have to execute multiple instructions in order to access
    a variable stored a long distance away from where EBP points in the stack frame.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，80x86没有足够多的寄存器用于传递参数和存储局部变量，因此80x86代码必须在激活记录中分配更多的局部变量。此外，80x86在EBP寄存器周围只提供–128到+127字节的偏移范围，因此更多的指令必须使用4字节的偏移而不是1字节的偏移。幸运的是，80x86确实允许你将一个完整的32位地址编码为访问内存的指令的一部分，因此你不必执行多条指令来访问存储在EBP指向的堆栈帧远距离位置的变量。
- en: '**15.5.5 Registers to the Rescue**'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**15.5.5 寄存器的救援**'
- en: As the examples in the previous section demonstrate, RISC code suffers greatly
    when it has to deal with parameters and local variables whose offsets are not
    easy to represent within the confines of the instruction opcode. In real code,
    however, the situation is not so dire. Compilers are smart enough to use machine
    registers to pass parameters and hold local variables providing immediate access
    to those values. This dramatically reduces the number of instructions in typical
    functions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上一节中的示例所示，当RISC代码需要处理那些偏移量不容易在指令操作码的范围内表示的参数和局部变量时，它会遭遇很大的困难。然而，在实际代码中，情况并没有那么糟糕。编译器足够聪明，能够使用机器寄存器传递参数并存储局部变量，从而实现对这些值的即时访问。这大大减少了典型函数中的指令数量。
- en: Consider the (register-starved) 32-bit 80x86 CPU. As there are only eight general-purpose
    registers, two of which (ESP and EBP) have special purposes that limit their use,
    there aren’t a lot of registers available for passing parameters or holding local
    variables. Typical C compilers use EAX, ECX, and EDX to pass up to three parameters
    to a function. Functions return their result in the EAX register. The function
    must preserve the values of any other registers (EBX, ESI, EDI, and EBP) it uses.
    It’s fortunate that memory access to local variables and parameters inside the
    function is very efficient—given the limited register set, the 32-bit 80x86 will
    need to use memory often for this purpose.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下（寄存器匮乏的）32位80x86 CPU。由于只有八个通用寄存器，其中两个（ESP和EBP）有特殊用途，限制了它们的使用，因此可用来传递参数或存储局部变量的寄存器并不多。典型的C编译器使用EAX、ECX和EDX将最多三个参数传递给函数。函数通过EAX寄存器返回结果。函数必须保存它使用的任何其他寄存器（EBX、ESI、EDI和EBP）的值。幸运的是，访问函数内的局部变量和参数非常高效——鉴于寄存器集的限制，32位80x86通常需要频繁使用内存来实现这一目的。
- en: For most applications, the largest architectural improvement to the 64-bit x86-64
    over the 32-bit 80x86 was not 64-bit registers (or even addresses), but that the
    x86-64 added eight new general-purpose registers and eight new XMM registers that
    compilers could use for passing parameters and holding local variables. The Intel/AMD
    ABI for the x86-64 allows a compiler to pass up to six different arguments in
    registers to a function (without the caller explicitly saving those register values
    before using them). [Table 15-2](ch15.xhtml#ch15tab2) lists the available registers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序，64位x86-64相对于32位80x86的最大架构改进并不是64位寄存器（甚至不是地址），而是x86-64新增了八个通用寄存器和八个新的XMM寄存器，编译器可以使用它们来传递参数和存储局部变量。Intel/AMD的x86-64
    ABI允许编译器通过寄存器将最多六个不同的参数传递给函数（无需调用者在使用之前显式保存这些寄存器的值）。[表15-2](ch15.xhtml#ch15tab2)列出了可用的寄存器。
- en: '**Table 15-2:** Ix86-64 Argument Passing via Registers'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-2：** Ix86-64 通过寄存器传递参数'
- en: '| **Register** | **Usage** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器** | **用途** |'
- en: '| RDI | 1st argument |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| RDI | 第一个参数 |'
- en: '| RSI | 2nd argument |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| RSI | 第二个参数 |'
- en: '| RDX | 3rd argument |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| RDX | 第三个参数 |'
- en: '| RCX | 4th argument |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| RCX | 第四个参数 |'
- en: '| R8 | 5th argument |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| R8 | 第五个参数 |'
- en: '| R9 | 6th argument |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| R9 | 第六个参数 |'
- en: '| XMM0–XMM7 | Used to pass floating-point arguments |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| XMM0–XMM7 | 用于传递浮点参数 |'
- en: '| R10 | Can be used to pass static chain pointer |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| R10 | 可用于传递静态链指针 |'
- en: '| RAX | Used to pass argument count if there are a variable number of parameters
    |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| RAX | 如果参数数量可变，则用于传递参数个数 |'
- en: The 32-bit ARM (A32) ABI specifies up to four arguments appearing in registers
    R0 through R3\. As the A64 architecture has twice as many registers (32), the
    A64 ABI is a bit more generous, passing up to eight 64-bit integer/pointer arguments
    in R0 through R7 and up to eight additional floating-point parameters in V0 through
    V7.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 32 位 ARM (A32) ABI 定义最多四个参数出现在 R0 到 R3 寄存器中。由于 A64 架构有两倍数量的寄存器（32 个），因此 A64
    ABI 比较宽松，允许最多将八个 64 位整数/指针参数传递给 R0 到 R7 寄存器，并且允许最多将八个额外的浮点参数传递给 V0 到 V7 寄存器。
- en: The PowerPC ABI, which has 32 general-purpose registers, sets aside R3 through
    R10 to pass up to eight arguments to a function. It also sets aside the F1 through
    F8 floating-point registers to pass floating-point arguments to a function.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: PowerPC ABI 拥有 32 个通用寄存器，将 R3 到 R10 寄存器留给传递最多八个函数参数。它还将 F1 到 F8 浮点寄存器留给传递浮点函数参数。
- en: In addition to setting aside registers to hold function arguments, the various
    ABIs typically define various registers that a function can use to hold local
    variables or temporary values (without explicitly preserving the values held in
    those registers upon entry to the function). For example, the Windows ABI sets
    aside R11, XMM8 through XMM15, MMX0 through MMX7, the FPU registers, and RAX for
    temporary/local use. The ARM A32 ABI sets aside R4 through R8 and R10 through
    R11 for use as locals. The A64 ABI sets aside R9 through R15 for locals and temporaries.
    The PowerPC sets aside R14 through R30 and F14 through F31 for local variables.
    Once a compiler exhausts the registers the ABI defines for argument passing, most
    ABIs expect the calling code to pass additional parameters on the stack. Similarly,
    once a function uses all the registers set aside for local variables, additional
    local variable allocation occurs on the stack.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分配寄存器用于保存函数参数外，各种 ABI 通常还定义了各种寄存器，供函数用于存储局部变量或临时值（在进入函数时，不必显式保存这些寄存器中的值）。例如，Windows
    ABI 为临时/局部使用预留了 R11、XMM8 到 XMM15、MMX0 到 MMX7、FPU 寄存器和 RAX。ARM A32 ABI 为局部变量预留了
    R4 到 R8 和 R10 到 R11 寄存器。A64 ABI 为局部变量和临时值预留了 R9 到 R15 寄存器。PowerPC 为局部变量预留了 R14
    到 R30 和 F14 到 F31 寄存器。一旦编译器用尽了 ABI 定义的用于传递参数的寄存器，大多数 ABI 期望调用代码通过栈传递额外的参数。类似地，一旦函数用完了为局部变量保留的所有寄存器，额外的局部变量分配将发生在栈上。
- en: Of course, a compiler can use other registers for local and temporary values
    as well as those set aside by the CPU’s or OS’s ABI. However, it’s the compiler’s
    responsibility to preserve those register values across the function call.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，编译器可以使用其他寄存器来存储局部和临时值，包括那些由 CPU 或操作系统的 ABI 预留的寄存器。然而，编译器有责任在函数调用之间保持这些寄存器的值。
- en: '**NOTE**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An ABI is a* convention, *not a requirement by the underlying OS or hardware.
    Compiler writers (and assembly language programmers) who stick to a given ABI
    can expect that their object code modules will be able to interact with code written
    in other languages that adhere to that ABI. However, nothing stops a compiler
    writer from using whatever mechanism they choose.*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*ABI 是一种* 约定，*并非底层操作系统或硬件的要求。遵循某一 ABI 的编译器作者（以及汇编语言程序员）可以期待他们的目标代码模块能够与遵循该
    ABI 的其他语言编写的代码进行交互。但是，没有什么可以阻止编译器作者使用他们选择的任何机制。*'
- en: '**15.5.6 Java VM and Microsoft CLR Parameters and Locals**'
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**15.5.6 Java VM 和 Microsoft CLR 参数与局部变量**'
- en: Because the Java VM and Microsoft CLR are both virtual stack machines, programs
    compiled to those two architectures always push function arguments onto the stack.
    Beyond that, the two virtual machine architectures diverge. The reason for the
    divergence is that the Java VM’s design supports efficient interpretation of Java
    bytecodes with JIT compilation improving performance as needed. The Microsoft
    CLR, on the other hand, does not support interpretation; instead, the CLR code
    (CIL) design supports efficient JIT compilation to optimized machine code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java 虚拟机和 Microsoft CLR 都是虚拟栈机器，编译为这两种架构的程序总是将函数参数推入栈中。除此之外，这两种虚拟机架构存在差异。差异的原因在于，Java
    虚拟机的设计支持通过 JIT 编译高效地解释 Java 字节码，从而在需要时提高性能。而 Microsoft CLR 则不支持解释执行；相反，CLR 代码（CIL）的设计支持将其高效地
    JIT 编译为优化后的机器码。
- en: The Java VM is a traditional stack architecture, with parameters, locals, and
    temporaries sitting on the stack. Other than the fact that there are no registers
    to use for such objects, Java’s memory organization is very similar to that of
    the 80x86/x86-64, PowerPC, and ARM CPUs. During JIT compilation, it can be difficult
    to figure out which values on the stack can be moved into registers and which
    local variables the Java compiler allocates on the stack can be allocated in registers.
    Optimizing such stack allocations to use registers can be very time-consuming,
    so it’s doubtful that the Java JIT compiler does this while the application is
    running (as doing so would greatly diminish the application’s runtime performance).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Java 虚拟机是传统的栈架构，参数、局部变量和临时变量都位于栈上。除了没有可供此类对象使用的寄存器外，Java 的内存组织与 80x86/x86-64、PowerPC
    和 ARM CPU 非常相似。在 JIT 编译期间，可能很难弄清楚栈上的哪些值可以移到寄存器中，Java 编译器分配到栈上的哪些局部变量可以分配到寄存器中。优化这种栈分配以使用寄存器可能非常耗时，因此怀疑
    Java JIT 编译器会在应用程序运行时执行此操作（因为这样做会大大降低应用程序的运行时性能）。
- en: Microsoft’s CLR operates under a different philosophy. CIL is always JIT-compiled
    into native machine code. Furthermore, Microsoft’s intent is to have the JIT compiler
    produce *optimized* native machine code. While the JIT compiler rarely does as
    good a job as a traditional C/C++ compiler, it generally does a much better job
    than the Java JIT compiler. This is because the Microsoft CLR definition explicitly
    singles out parameter argument and local variable memory accesses. When the JIT
    compiler sees these special instructions, it can allocate those variables to registers
    rather than memory locations. As a result, CLR JIT-compiled code is often shorter
    and faster than Java VM JIT-compiled code (especially on RISC architectures).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 的 CLR 采用不同的哲学。CIL 总是 JIT 编译成本地机器码。此外，Microsoft 的目标是让 JIT 编译器生成*优化过*的本地机器码。尽管
    JIT 编译器的表现通常不如传统的 C/C++ 编译器，但它通常比 Java JIT 编译器做得更好。这是因为 Microsoft CLR 的定义明确区分了参数传递和局部变量内存访问。当
    JIT 编译器遇到这些特殊指令时，它可以将这些变量分配到寄存器而不是内存位置。因此，CLR JIT 编译的代码通常比 Java 虚拟机 JIT 编译的代码更短且更快（尤其在
    RISC 架构上）。
- en: '**15.6 Parameter-Passing Mechanisms**'
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**15.6 参数传递机制**'
- en: 'Most high-level languages provide at least two mechanisms for passing actual
    parameter data to a subroutine: pass-by-value and pass-by-reference.^([11](footnotes.xhtml#ch15fn11))
    In languages like Visual Basic, Pascal, and C++, declaring and using both types
    of parameters is so easy that a programmer may conclude that there’s little difference
    in efficiency between the two mechanisms. That’s a myth this section intends to
    dispel.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言提供至少两种机制来将实际参数数据传递给子例程：按值传递和按引用传递。^([11](footnotes.xhtml#ch15fn11)) 在像
    Visual Basic、Pascal 和 C++ 这样的语言中，声明和使用这两种类型的参数非常简单，以至于程序员可能会得出结论，认为这两种机制在效率上几乎没有区别。这是一个误区，本节旨在澄清这一点。
- en: '**NOTE**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are other parameter-passing mechanisms besides pass-by-value and pass-by-reference.
    FORTRAN and HLA, for example, support a mechanism known as pass-by-value/result
    (or pass-by-value/returned). Ada and HLA support pass-by-result. HLA and Algol
    support pass-by-name. This book won’t discuss these alternative parameter-passing
    mechanisms further, because you probably won’t see them very often. If you’d like
    more information, consult a good book on programming language design or the HLA
    documentation.*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*除了按值传递（pass-by-value）和按引用传递（pass-by-reference）之外，还有其他的参数传递机制。例如，FORTRAN 和
    HLA 支持一种被称为按值/结果传递（pass-by-value/result，或称按值/返回传递）的机制。Ada 和 HLA 支持按结果传递（pass-by-result）。HLA
    和 Algol 支持按名称传递（pass-by-name）。本书不会进一步讨论这些替代的参数传递机制，因为你可能很少遇到它们。如果你想了解更多信息，可以查阅一本关于编程语言设计的好书或
    HLA 文档。*'
- en: '**15.6.1 Pass-by-Value**'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**15.6.1 按值传递**'
- en: Pass-by-value is the easiest parameter-passing mechanism to understand. The
    code that calls a procedure makes a copy of the parameter’s data and passes this
    copy to the procedure. For small values, passing a parameter by value generally
    requires little more than a `push` instruction (or, when passing parameters in
    the registers, an instruction that moves the value into a register). Therefore,
    this mechanism is often very efficient.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 按值传递是最容易理解的参数传递机制。调用过程的代码会复制参数的数据，并将这个副本传递给过程。对于小型值，按值传递通常只需要一个 `push` 指令（或者，在寄存器中传递参数时，需要一个将值移动到寄存器的指令）。因此，这种机制通常非常高效。
- en: One big advantage of pass-by-value parameters is that the CPU treats them just
    like a local variable within the activation record. Because you’ll rarely have
    more than 120 bytes of parameter data that you pass to a procedure, CPUs that
    provide a shortened displacement with the indexed addressing mode will be able
    to access most parameter values using a shorter (and, therefore, more efficient)
    instruction.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 按值传递参数的一个大优点是，CPU 将它们视为激活记录中的局部变量。因为你通常不会传递超过 120 字节的参数数据，所以支持索引寻址模式的 CPU 将能够使用更短（因此更高效）的指令访问大多数参数值。
- en: The one case where passing a parameter by value can be inefficient is when you
    need to pass a large data structure, such as an array or record. The calling code
    needs to make a byte-for-byte copy of the actual parameter into the procedure’s
    activation record, as you saw in an earlier example. This can be a very slow process,
    say, if you decide to pass a million-element array to a subroutine by value. Therefore,
    you should avoid passing large objects by value unless absolutely necessary.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 按值传递在某些情况下可能效率较低，尤其是当你需要传递一个大型数据结构时，如数组或记录。调用代码需要将实际参数逐字节复制到过程的激活记录中，正如你在之前的示例中所看到的那样。这可能是一个非常慢的过程，例如，如果你决定通过值传递一个包含百万个元素的数组给子程序。因此，除非绝对必要，否则你应该避免按值传递大型对象。
- en: '**15.6.2 Pass-by-Reference**'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**15.6.2 按引用传递**'
- en: The pass-by-reference mechanism passes the address of an object rather than
    its value. This has a couple of distinct advantages over pass-by-value. First,
    regardless of the parameter’s size, pass-by-reference parameters always consume
    the same amount of memory—the size of a pointer (which typically fits in a machine
    register). Second, pass-by-reference parameters allow you to modify the value
    of the actual parameter—which is impossible with pass-by-value parameters.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 按引用传递机制传递的是对象的地址，而不是它的值。这相比于按值传递有几个明显的优点。首先，无论参数的大小如何，按引用传递的参数始终消耗相同的内存——指针的大小（通常可以适配到机器寄存器中）。其次，按引用传递的参数允许你修改实际参数的值——这是按值传递无法做到的。
- en: Pass-by-reference parameters are not without their drawbacks, though. Usually,
    accessing a reference parameter within a procedure is more expensive than accessing
    a value parameter, because the subroutine needs to dereference that address on
    each access of the object. This generally involves loading a register with the
    pointer in order to dereference the pointer using a register indirect addressing
    mode.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，按引用传递的参数也并非没有缺点。通常，访问过程中的引用参数比访问值参数更昂贵，因为子程序在每次访问对象时都需要解引用该地址。这通常涉及将指针加载到寄存器中，以便使用寄存器间接寻址模式解引用该指针。
- en: 'For example, consider the following Pascal code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下 Pascal 代码：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here’s the equivalent HLA/x86 assembly code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是等效的 HLA/x86 汇编代码：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice that this code requires two more instructions than a version that uses
    pass-by-value—specifically, the two instructions that load the addresses of `dest`
    and `passedByRef` into the EDX register. In general, only a single instruction
    is needed to access the value of a pass-by-value parameter. However, two instructions
    are needed to manipulate the value of a parameter when you pass it by reference
    (one instruction to fetch the address, and one to manipulate the data at that
    address). So, unless you need the semantics of pass-by-reference, try to use pass-by-value
    instead.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码比使用值传递的版本多了两条指令——特别是，将`dest`和`passedByRef`的地址加载到EDX寄存器中的两条指令。通常，访问值传递参数的值只需要一条指令。然而，在通过引用传递参数时，需要两条指令来操作参数的值（第一条指令用于获取地址，第二条指令用于操作该地址中的数据）。因此，除非你需要引用传递的语义，否则尽量使用值传递。
- en: The issues with pass-by-reference tend to diminish when your CPU has lots of
    available registers that it can use to maintain the pointer values. In that situation,
    the CPU can use a single instruction to fetch or store a value via a pointer maintained
    in the register.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的CPU有大量可用寄存器来存储指针值时，引用传递的问题往往会减少。在这种情况下，CPU可以使用一条指令通过寄存器中的指针来获取或存储一个值。
- en: '**15.7 Function Return Values**'
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**15.7 函数返回值**'
- en: Most HLLs return function results in one or more CPU registers. Exactly which
    register the compiler uses depends on the data type, CPU, and compiler. For the
    most part, however, functions return their results in registers (assuming the
    return data fits in a machine register).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言（HLL）会通过一个或多个CPU寄存器返回函数结果。具体使用哪个寄存器取决于数据类型、CPU和编译器。然而，大多数情况下，函数会将结果返回到寄存器中（假设返回的数据适合存放在机器寄存器中）。
- en: On the 32-bit 80x86, most functions that return ordinal (integer) values return
    their function results in the AL, AX, or EAX register. Functions that return 64-bit
    values (`long long int`) generally return the function result in the EDX:EAX register
    pair (with EDX containing the HO double word of the 64-bit value). On 64-bit variants
    of the 80x86 family, 64-bit compilers return 64-bit results in the RAX register.
    On the PowerPC, most compilers follow the IBM ABI and return 8-, 16-, and 32-bit
    values in the R3 register. Compilers for the 32-bit versions of the PowerPC return
    64-bit ordinal values in the R4:R3 register pair (with R4 containing the HO word
    of the function result). Presumably, compilers running on 64-bit variants of the
    PowerPC can return 64-bit ordinal results directly in R3.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位的80x86中，大多数返回整数值的函数会将其结果返回到AL、AX或EAX寄存器。返回64位值（`long long int`）的函数通常会将结果返回到EDX:EAX寄存器对中（其中EDX包含64位值的高双字）。在80x86家族的64位版本中，64位编译器会将64位结果返回到RAX寄存器。在PowerPC上，大多数编译器遵循IBM
    ABI，并将8位、16位和32位值返回到R3寄存器中。32位版本的PowerPC编译器将64位整数值返回到R4:R3寄存器对中（其中R4包含函数结果的高字）。可以推测，运行在64位PowerPC上的编译器可以直接在R3寄存器中返回64位整数结果。
- en: Generally, compilers return floating-point results in one of the CPU’s (or FPU’s)
    floating-point registers. On 32-bit variants of the 80x86 CPU family, most compilers
    return a floating-point result in the 80-bit ST0 floating-point register. Although
    the 64-bit versions of the 80x86 family also provide the same FPU registers as
    the 32-bit members, some operating systems, such as Windows64, typically use one
    of the SSE registers (XMM0) to return floating-point values. PowerPC systems generally
    return floating-point function results in the F1 floating-point register. Other
    CPUs return floating-point results in comparable locations.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器会将浮点数结果返回到CPU（或FPU）的浮点寄存器中。在32位的80x86 CPU家族中，大多数编译器将浮点结果返回到80位的ST0浮点寄存器中。虽然80x86家族的64位版本也提供与32位版本相同的FPU寄存器，但一些操作系统，如Windows64，通常使用SSE寄存器中的一个（XMM0）来返回浮点值。PowerPC系统通常将浮点函数结果返回到F1浮点寄存器中。其他CPU则将浮点结果返回到相应的位置。
- en: 'Some languages allow a function to return a nonscalar (aggregate) value. The
    exact mechanism that compilers use to return large function return results varies
    from compiler to compiler. However, a typical solution is to pass a function the
    address of some storage where the function can place the return result. As an
    example, consider the following short C++ program whose `func()` function returns
    a structure object:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言允许函数返回非标量（聚合）值。编译器用于返回大函数结果的具体机制因编译器而异。然而，一种典型的解决方案是传递函数一个存储地址，函数可以将返回结果放在该存储区域。例如，考虑以下短小的
    C++ 程序，其中 `func()` 函数返回一个结构体对象：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here’s the PowerPC code that GCC emits for this C++ program:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 GCC 为这个 C++ 程序生成的 PowerPC 代码：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here’s the 32-bit 80x86 code that GCC emits for this same function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 GCC 为相同函数生成的 32 位 80x86 代码：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The takeaway from these 80x86 and PowerPC examples is that functions returning
    large objects often copy the function result data just prior to returning. This
    extra copying can take considerable time, especially if the return result is large.
    Instead of returning a large structure as a function result, as shown here, it’s
    usually better to explicitly pass a pointer to some destination storage to a function
    that returns a large result and then let the function do whatever copying is necessary.
    This often saves some time and code. Consider the following C code, which implements
    this policy:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些 80x86 和 PowerPC 示例中可以得出结论：返回大对象的函数通常会在返回之前复制函数结果数据。这种额外的复制可能会花费相当多的时间，尤其是在返回结果很大的时候。与其像这里展示的那样返回一个大的结构体作为函数结果，通常更好的做法是明确地将指向某个目标存储区的指针传递给一个返回大结果的函数，然后让该函数进行必要的复制操作。这通常可以节省一些时间和代码。考虑以下实现此策略的
    C 代码：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here’s the conversion to 80x86 code by GCC:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 GCC 转换成 80x86 代码的结果：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, this approach is more efficient because the code doesn’t have
    to copy the data twice, once to a local copy of the data and once to the final
    destination variable.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种方法更高效，因为代码不必复制数据两次，一次是复制到数据的本地副本，再一次复制到最终的目标变量。
- en: '**15.8 For More Information**'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**15.8 更多信息**'
- en: 'Aho, Alfred V., Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. *Compilers:
    Principles, Techniques, and Tools*. 2nd ed. Essex, UK: Pearson Education Limited,
    1986.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Aho, Alfred V., Monica S. Lam, Ravi Sethi 和 Jeffrey D. Ullman。*《编译原理：技术与工具》*。第2版。英国埃塞克斯：Pearson
    Education Limited，1986。
- en: 'Barrett, William, and John Couch. *Compiler Construction: Theory and Practice*.
    Chicago: SRA, 1986.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Barrett, William 和 John Couch。*《编译器构建：理论与实践》*。芝加哥：SRA，1986。
- en: 'Dershem, Herbert, and Michael Jipping. *Programming Languages, Structures and
    Models*. Belmont, CA: Wadsworth, 1990.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Dershem, Herbert 和 Michael Jipping。*《编程语言、结构与模型》*。加利福尼亚州贝尔蒙特：Wadsworth，1990。
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Duntemann, Jeff. *《汇编语言逐步解析》*。第3版。印第安纳波利斯：Wiley，2009。
- en: 'Fraser, Christopher, and David Hansen. *A Retargetable C Compiler: Design and
    Implementation*. Boston: Addison-Wesley Professional, 1995.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Fraser, Christopher 和 David Hansen。*《可重定向的 C 编译器：设计与实现》*。波士顿：Addison-Wesley
    Professional，1995。
- en: 'Ghezzi, Carlo, and Jehdi Jazayeri. *Programming Language Concepts*. 3rd ed.
    New York: Wiley, 2008.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Ghezzi, Carlo 和 Jehdi Jazayeri。*《编程语言概念》*。第3版。纽约：Wiley，2008。
- en: 'Hoxey, Steve, Faraydon Karim, Bill Hay, and Hank Warren, eds. *The PowerPC
    Compiler Writer’s Guide*. Palo Alto, CA: Warthman Associates for IBM, 1996.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Hoxey, Steve, Faraydon Karim, Bill Hay, 和 Hank Warren, 主编。*《PowerPC 编译器编写指南》*。加利福尼亚州帕洛阿尔托：Warthman
    Associates for IBM，1996。
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Hyde, Randall. *《汇编语言的艺术》*。第2版。旧金山：No Starch Press，2010。
- en: '———. “Webster: The Place on the Internet to Learn Assembly.” *[http://plantation-productions.com/Webster/index.html](http://plantation-productions.com/Webster/index.html)*.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ———. “Webster：互联网上学习汇编语言的地方。” *[http://plantation-productions.com/Webster/index.html](http://plantation-productions.com/Webster/index.html)*。
- en: Intel. “Intel 64 and IA-32 Architectures Software Developer Manuals.” Updated
    November 11, 2019\. *[https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm)*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔。“英特尔 64 和 IA-32 架构软件开发者手册。” 更新于 2019 年 11 月 11 日。 *[https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm)*。
- en: 'Ledgard, Henry, and Michael Marcotty. *The Programming Language Landscape*.
    Chicago: SRA, 1986.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Ledgard, Henry 和 Michael Marcotty。*《编程语言景观》*。芝加哥：SRA，1986。
- en: 'Louden, Kenneth C. *Compiler Construction: Principles and Practice*. Boston:
    Cengage, 1997.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Louden, Kenneth C. *《编译器构建：原理与实践》*。波士顿：Cengage，1997。
- en: 'Louden, Kenneth C., and Kenneth A. Lambert. *Programming Languages: Principles
    and Practice*. 3rd ed. Boston: Course Technology, 2012.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'Louden, Kenneth C. 和 Kenneth A. Lambert. *编程语言：原理与实践*. 第3版. 波士顿: 课程技术出版社, 2012年。'
- en: 'Parsons, Thomas W. *Introduction to Compiler Construction*. New York: W. H.
    Freeman, 1992.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 'Parsons, Thomas W. *编译原理导论*. 纽约: W. H. Freeman出版社, 1992年。'
- en: 'Pratt, Terrence W., and Marvin V. Zelkowitz. *Programming Languages, Design
    and Implementation*. 4th ed. Upper Saddle River, NJ: Prentice Hall, 2001.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pratt, Terrence W. 和 Marvin V. Zelkowitz. *编程语言：设计与实现*. 第4版. 新泽西州上萨德尔河: 普伦蒂斯霍尔出版社,
    2001年。'
- en: 'Sebesta, Robert. *Concepts of Programming Languages*. 11th ed. Boston: Pearson,
    2016.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 'Sebesta, Robert. *编程语言概念*. 第11版. 波士顿: Pearson出版社, 2016年。'
