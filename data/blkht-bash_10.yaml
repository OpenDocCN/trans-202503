- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 10 PERSISTENCE
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 持久性
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: By gaining *persistence* on compromised networks and machines, we can make our
    access immune to environmental changes such as system reboots, a loss of network
    connectivity, or even credential rotation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在被攻破的网络和机器上获得*持久性*，我们可以使得我们的访问免受系统重启、网络连接丧失，甚至凭据轮换等环境变化的影响。
- en: There are many ways to gain persistence. For example, you could plant code on
    a compromised server that reestablishes your access. Or you could discover virtual
    private network credentials in a configuration file on GitHub that someone accidentally
    pushed to a public repository to connect remotely to a network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 获取持久性的方式有很多种。例如，你可以在一个被攻破的服务器上植入代码，以重新建立你的访问。或者，你可以在GitHub上的配置文件中发现虚拟私人网络凭证，某人不小心将其推送到公共仓库中，从而远程连接到网络。
- en: 'Bash is a useful tool for gaining persistence, and in this chapter, we’ll use
    it in several persistence techniques: modifying the scripts used to start system
    services and interact with authentication modules, harvesting credentials by hooking
    executed commands, packaging and distributing malicious scripts, hijacking system
    utilities, and more.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 是一种有用的工具，可以帮助获得持久性，在本章中，我们将用它实现几种持久性技巧：修改启动系统服务并与认证模块交互的脚本，挂钩执行的命令来收集凭据，打包和分发恶意脚本，劫持系统实用工具等。
- en: The Enemies of Persistent Access
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久访问的敌人
- en: 'Many factors could interfere with an attacker’s ability to establish persistent
    access, some of which may not necessarily be under their direct control. Here
    are a few environment types and security practices that could become a hurdle
    and hamper persistence of access:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多因素可能会干扰攻击者建立持久访问的能力，其中一些因素可能并不完全在其直接控制之内。以下是一些可能成为障碍并妨碍访问持久性的环境类型和安全实践：
- en: '**Ephemeral environments**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**短暂环境**'
- en: Short-lived environments, such as those running containers, may make persistence
    challenging. Container orchestration platforms and system administrators might
    spin containers up and down frequently. For example, a system experiencing a decreased
    system load on a slow weekend may automatically scale down the number of running
    containers. If we had access to one of those containers, we’d be at risk of losing
    access.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 短生命周期的环境，如运行容器的环境，可能使得持久性变得具有挑战性。容器编排平台和系统管理员可能会频繁地启动和关闭容器。例如，一个系统在一个慢节奏的周末可能会自动缩减运行中的容器数量，从而减少系统负载。如果我们曾访问过其中一个容器，就有可能丧失访问权限。
- en: '**Mature security practices**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**成熟的安全实践**'
- en: An organization that implements mature security practices can be a harder target
    both to compromise and maintain one’s access to. Some organizations review their
    systems every day for anomalies, harden their infrastructure, scan their environment
    for possible intrusion attempts, and perform threat hunting. In addition, many
    organizations have dedicated red teams to test the effectiveness of the controls.
    These security measures can make it harder to maintain long-term access.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实施成熟安全实践的组织，在被攻破和保持访问控制方面，通常会是一个更难的目标。一些组织每天都会检查其系统是否有异常，强化基础设施，扫描环境中的潜在入侵尝试，并进行威胁狩猎。此外，许多组织还设有专门的红队来测试安全控制的有效性。这些安全措施使得长期保持访问变得更加困难。
- en: '**Network and endpoint security controls**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络和终端安全控制**'
- en: Fine-tuned network and endpoint security controls implemented across an organization
    can make persisting access more difficult. A mature blue team will plan a defense-in-depth
    network strategy to compensate for any control failures.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个组织中实施精细化的网络和终端安全控制措施，会使得持久化访问变得更加困难。一个成熟的蓝队会制定深度防御的网络策略，以应对任何控制失败的情况。
- en: '**Asset life-cycle management and inventory hygiene**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**资产生命周期管理和库存卫生**'
- en: While it doesn’t happen often, asset decommissioning can trigger the loss of
    persistent access. Similarly, solid patch management could introduce fixes to
    the vulnerable software used as part of an exploitation kit. Ideally, you should
    find *grip points*, additional assets to persist your access to, so you don’t
    rely on a single vector for your remote access.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种情况不常见，但资产退役可能会触发持久访问的丧失。同样，健全的补丁管理可能会修复作为攻击工具的一部分所使用的漏洞软件。理想情况下，你应该找到*控制点*，额外的资产来保持访问，而不是仅仅依赖一个远程访问通道。
- en: Modifying Service Configurations
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改服务配置
- en: One way to maintain access to a system is to create or modify the script used
    to start a system service. To achieve this, you could exploit System V and systemd,
    system mechanisms that manage services and control the start sequence of processes.
    System V is the older of the two mechanisms, but you may encounter either tool
    in a penetration test. Let’s learn about both mechanisms in the context of persistence.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 维持系统访问的一种方式是创建或修改用于启动系统服务的脚本。为了实现这一点，你可以利用System V和systemd，它们是管理服务并控制进程启动顺序的系统机制。System
    V是这两种机制中较老的，但你可能会在渗透测试中遇到这两种工具。让我们在持久性上下文中学习这两种机制。
- en: System V
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: System V
- en: System V’s */etc/init.d* directory contains shell scripts, called *init scripts*,
    responsible for starting services, whether they’re network services such as SSH,
    scheduling services such as Cron, or services responsible for setting up a server’s
    hardware clock. But we can also write custom malicious logic by using init scripts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: System V的*/etc/init.d*目录包含名为*init脚本*的shell脚本，负责启动服务，无论是网络服务如SSH，调度服务如Cron，还是负责设置服务器硬件时钟的服务。但我们也可以通过使用init脚本编写自定义恶意逻辑。
- en: NOTE
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Introducing custom code into shell scripts under the* /etc *directory usually
    requires elevated privileges. This technique assumes you have write permissions
    to the target directory.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*向/etc目录下的shell脚本中引入自定义代码通常需要提升权限。此技巧假设你有目标目录的写权限。*'
- en: 'Run the ls command to list the files in */etc/init.d* on any of the machines
    in the lab. Here is the output on *p-jumpbox-01* (172.16.10.13):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行ls命令列出实验室中任意一台机器上*/etc/init.d*目录中的文件。以下是*p-jumpbox-01*（172.16.10.13）上的输出：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each file in the directory affects the configuration of a particular service.
    For example, take a look at the *ssh* script ([Listing 10-1](chapter10.xhtml#Lis10-1)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目录中的每个文件都影响特定服务的配置。例如，查看*ssh*脚本（[清单10-1](chapter10.xhtml#Lis10-1)）。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 10-1: The init script for the SSH service'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-1：SSH服务的init脚本
- en: 'As you can see, the core of this script uses a case statement to determine
    which set of commands to run, given some input. For example, to start, stop, and
    reload the SSH service, we could call the script in each of the following ways:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该脚本的核心使用case语句根据一些输入来决定执行哪一组命令。例如，启动、停止和重新加载SSH服务时，我们可以通过以下方式调用该脚本：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The system is configured to start SSH on boot, and if we can place custom bash
    logic in the script, our code will run whenever the script is called. So, if we’re
    able to create a reverse shell from the init script, we can reconnect the server
    to our listener in the case of a full reboot, as long as the network is available.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 系统配置为在启动时启动SSH，如果我们能将自定义bash逻辑插入脚本中，我们的代码将在每次调用该脚本时执行。因此，如果我们能够从init脚本创建反向shell，我们可以在完整重启后将服务器重新连接到我们的监听器，只要网络可用。
- en: Let’s give this a try. Modify the */etc/init.d/ssh* file by inserting a reverse
    shell payload into it, as shown in [Listing 10-2](chapter10.xhtml#Lis10-2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个。通过将反向shell有效载荷插入*/etc/init.d/ssh*文件，如[清单10-2](chapter10.xhtml#Lis10-2)所示。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 10-2: A reverse shell payload injected into /etc/init.d/ssh'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-2：注入到/etc/init.d/ssh中的反向shell有效载荷
- en: Next, start a listener to receive the reverse shell on Kali. You can use pwncat,
    Ncat, Netcat, or any other listener you prefer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动监听器以在Kali上接收反向shell。你可以使用pwncat、Ncat、Netcat或任何你偏好的监听器。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, switch back to the target system and run the service command to start
    the SSH server daemon:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，切换回目标系统并运行服务命令以启动SSH服务器守护进程：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should see the reverse shell connecting to the listener.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到反向shell连接到监听器。
- en: Note that when you introduce obviously malicious commands such as reverse shell
    payloads, you should make these as invisible as possible. For example, try splitting
    the listener’s remote IP address into a bunch of variables so it blends with the
    rest of the script and doesn’t stand out to anyone who happens to be reading it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你引入明显的恶意命令，如反向shell有效载荷时，应尽量让这些命令不可见。例如，尝试将监听器的远程IP地址拆分成多个变量，使其与脚本的其余部分融合，以免引起任何正在查看该脚本的人的注意。
- en: systemd
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: systemd
- en: systemd manages *units*, which can represent services, devices, and other types
    of components. To achieve persistence, we could try to use systemd as a way to
    register a new service unit on the system. [Listing 10-3](chapter10.xhtml#Lis10-3)
    shows an example of a systemd service with a reverse shell payload.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: systemd管理*units*，它们可以表示服务、设备和其他类型的组件。为了实现持久性，我们可以尝试使用systemd来注册系统上的一个新服务单元。[列表10-3](chapter10.xhtml#Lis10-3)展示了一个带有反向shell负载的systemd服务示例。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 10-3: An example malicious systemd service definition file'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-3：一个恶意systemd服务定义文件示例
- en: 'This service defines the following properties: a new unit ❶, a requirement
    for networking to be available ❷, an instruction to execute the reverse shell
    to the attacker’s machine on service start ❸, and a requirement to restart the
    process if it dies ❹.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务定义了以下属性：一个新单位❶，网络可用的要求❷，在服务启动时执行反向shell到攻击者机器的指令❸，以及如果进程死掉则重新启动的要求❹。
- en: The containers in the lab don’t run systemd, but if you’d like to experiment
    with this technique, you could use these commands on your Kali machine. To use
    the script, create a new service file at */etc/system/service/revshell.service*.
    (The name of the file is also the name of the service. In a real attack, you should
    probably use a sneakier name so it blends nicely with the environment.) Then enable
    the service by executing systemctl enable revshell.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室中的容器不运行systemd，但如果您想尝试此技术，可以在您的Kali机器上使用这些命令。要使用该脚本，请在*/etc/system/service*目录下创建一个新的服务文件*revshell.service*。（文件名也是服务名。在真正的攻击中，您可能应该使用更隐秘的名称，以便与环境融合得更好。）然后通过执行systemctl
    enable revshell来启用该服务。
- en: Run the malicious service by using systemctl start revshell. Now, if the machine
    ever reboots, this service file should reestablish a connection on boot.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过systemctl start revshell来运行恶意服务。现在，如果机器重新启动，此服务文件应在启动时重新建立连接。
- en: Hooking into Pluggable Authentication Modules
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩入可插拔认证模块
- en: '*Pluggable authentication modules (PAMs)* provide high-level APIs for low-level
    authentication schemes, and applications can use them to authenticate users. For
    example, you could adopt an external multifactor authentication provider to prompt
    users to enter a code or insert a hardware security token during login, in addition
    to using a traditional password. PAM configuration files live in the */etc/pam.d*
    directory.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*可插拔认证模块（PAMs）* 提供了用于低级认证方案的高级API，并且应用程序可以使用它们来认证用户。例如，您可以采用外部多因素认证提供者，在登录时提示用户输入代码或插入硬件安全令牌，除了使用传统密码。PAM配置文件存放在*/etc/pam.d*目录中。'
- en: 'In terms of establishing persistence, PAM has an interesting capability: it
    can call external scripts at certain points during an authentication flow by using
    the *pam_exec.so* library. By modifying specific configurations, we could make
    PAM call our own script whenever a user logs in to a system, then take any action
    we’d like.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立持久性方面，PAM具有一个有趣的功能：它可以使用*pam_exec.so*库在认证流程的某些点上调用外部脚本。通过修改特定的配置，我们可以使PAM在用户登录系统时调用我们自己的脚本，然后执行任何我们想要的操作。
- en: 'For example, under */etc/pam.d*, you will find a file named *common-session*.
    This file includes session-related modules that are common to all services. Modify
    this file by appending the following line to it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在*/etc/pam.d*下，您会找到一个名为*common-session*的文件。此文件包含所有服务共有的与会话相关的模块。通过向其追加以下行来修改此文件：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The format of this line is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此行的格式如下：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The type is session, the control is optional, the module path is *pam_exec.so*,
    and the module arguments are seteuid and /usr/local/bin/pam-helper.sh. The session
    type refers to the actions taken before or after a user is given access to a service,
    commonly used for actions such as logging. The optional control means that no
    matter whether this module succeeds or not, it won’t impact the authentication
    or login flow. The module path *pam_exec.so* is the library we will use to call
    external programs, followed by the module arguments seteuid (set effective UID)
    and the full path to the script.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是session，控制是可选的，模块路径是*pam_exec.so*，模块参数设置为seteuid和/usr/local/bin/pam-helper.sh。会话类型指的是在用户被允许访问服务之前或之后执行的操作，通常用于诸如日志记录等操作。可选的控制意味着无论此模块成功与否，都不会影响认证或登录流程。模块路径*pam_exec.so*是我们将用于调用外部程序的库，后跟模块参数seteuid（设置有效用户ID）和脚本的完整路径。
- en: Once you’ve saved the PAM configuration file, *pam_exec.so* will call your script
    whenever someone logs in to or out of the system (for example, by running su -
    backup and providing the password). We’ll provide guidance on writing a suitable
    persistence script in Exercise 19.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦保存了 PAM 配置文件，*pam_exec.so* 将会在有人登录或退出系统时调用您的脚本（例如，通过运行 su - backup 并提供密码）。我们将为练习
    19 提供编写适当持久性脚本的指导。
- en: 'Exercise 19: Coding a Malicious pam_exec Bash Script'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 19：编写恶意 pam_exec Bash 脚本
- en: The previous section explained how to modify a system’s PAM configuration to
    call an external script, *pam-helper.sh*. This script will run whenever a user
    logs in to or out of the system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节讲解了如何修改系统的 PAM 配置以调用外部脚本 *pam-helper.sh*。每当用户登录或退出系统时，此脚本将会运行。
- en: Build the script’s logic to take malicious actions of your choice. For example,
    you could use Cron to schedule a persistent task or use At to schedule a one-time
    task that establishes a reverse shell to a remote machine.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 构建脚本逻辑以执行您选择的恶意操作。例如，您可以使用 Cron 安排一个持久任务，或者使用 At 安排一个一次性任务，建立与远程机器的反向 shell
    连接。
- en: Make sure to save your script into */usr/local/pam-helper.sh* with executable
    permissions. You can test this exercise on *p-jumpbox-01* (172.16.10.13) since
    you already have root access to it. Don’t forget to set up the reverse shell listener
    as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将您的脚本保存到 */usr/local/pam-helper.sh* 并赋予可执行权限。您可以在 *p-jumpbox-01* (172.16.10.13)
    上测试此练习，因为您已经有其 root 访问权限。不要忘记设置反向 shell 监听器。
- en: Generating Rogue SSH Keys
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 Rogue SSH 密钥
- en: Users with SSH access to a server can use their cryptographic keys instead of
    their passwords to log in. When we generate an SSH key pair, we must append the
    public key to a file named *authorized_keys* under the user’s home directory.
    Any public key in this file is authorized to authenticate to the system but only
    when using the account for which the key exists.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有 SSH 访问权限的用户可以使用其加密密钥而不是密码登录服务器。当我们生成 SSH 密钥对时，必须将公钥追加到名为 *authorized_keys*
    的文件中，该文件位于用户的主目录下。此文件中的任何公钥都被授权对系统进行身份验证，但仅当使用该账户时才有效。
- en: 'Because more than one key could be authorized to authenticate, using a rogue
    SSH key to create a backdoor to an account is as easy as adding another public
    key to this file. For example, an *authorized_keys* file for a *nostarch* user
    might look like the following, assuming their home directory is */home/nostarch*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为可以授权多个密钥进行身份验证，所以使用恶意 SSH 密钥创建账户后门就像向此文件添加另一个公钥那么简单。例如，*nostarch* 用户的 *authorized_keys*
    文件可能如下所示，假设他们的主目录是 */home/nostarch*：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To generate a new SSH key, run this command on your Kali machine:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成新的 SSH 密钥，请在您的 Kali 机器上运行以下命令：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use -t (type) to define the type of key (in this case, RSA) and -C (comment)
    with an empty value. If you don’t supply the -C flag with an empty value, ssh-keygen
    will append the computer’s hostname to the end of the key as a comment, which
    is a way to identify the machine that the key belongs to. Follow the wizard, making
    sure not to set a passphrase for the purposes of this example. Two files should
    be created: *id_rsa* (the private key) and *id_rsa.pub* (the public key).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 -t（类型）来定义密钥的类型（在本例中为 RSA），并使用 -C（注释）并附空值。如果不使用 -C 标志并提供空值，ssh-keygen 将在密钥的末尾附加计算机的主机名作为注释，这是标识该密钥所属机器的一种方式。按照向导操作，确保在此示例中不设置密码。应该会创建两个文件：*id_rsa*（私钥）和
    *id_rsa.pub*（公钥）。
- en: You can add the public key to *authorized_keys* in multiple ways. Try performing
    these steps on the *p-jumpbox-01* machine (172.16.10.13) while logged in as the
    backup user.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以多种方式将公钥添加到 *authorized_keys*。尝试在已作为 backup 用户登录到 *p-jumpbox-01* 机器（172.16.10.13）上执行这些步骤。
- en: 'First, you can simply create or modify *~/.ssh/authorized_keys* by using a
    text editor and pasting the public key’s content:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以简单地使用文本编辑器创建或修改 *~/.ssh/authorized_keys* 并粘贴公钥内容：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To add the key remotely, you could use an SSH client to authenticate and run
    a command. Note that this will require you to provide the password of the account
    you’ve managed to compromise.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要远程添加密钥，您可以使用 SSH 客户端进行身份验证并运行命令。请注意，这将需要您提供已经成功攻破的账户的密码。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The ssh-copy-id command makes it slightly easier to copy the public key to
    the server. It should automatically write it to the correct location:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ssh-copy-id 命令使将公钥复制到服务器变得更加简单。它应该会自动将其写入正确的位置：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When prompted, enter the password for the backup user.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时，为 backup 用户输入密码。
- en: 'After adding the key, try using the private RSA key to log in to the server:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 添加密钥后，请尝试使用私有 RSA 密钥登录服务器：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should notice that you’re not prompted to enter the user’s account password.
    If you had provided a passphrase during key creation, you’d be required to provide
    this passphrase when using the key for authentication.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，系统没有提示你输入用户账户密码。如果在创建密钥时提供了密码短语，使用该密钥进行身份验证时将需要提供此密码短语。
- en: Repurposing Default System Accounts
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改用默认系统账户
- en: By default, systems come with built-in accounts other than root, such as nobody,
    sys, sync, bin, games, and man. We call these accounts *service accounts*, as
    they’re used for running specific tasks. Separating these tasks into different
    accounts enforces a least-privilege model, as it enables the system to run applications
    under particular user contexts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，系统带有除 root 之外的内置账户，如 nobody、sys、sync、bin、games 和 man。我们称这些账户为 *服务账户*，因为它们用于运行特定任务。将这些任务分配到不同账户中实施最小特权模型，使系统能够在特定用户上下文中运行应用程序。
- en: These accounts aren’t meant for users to log in to, and if you look closely
    at */etc/passwd* on any of the lab machines (or even on Kali), you’ll see they
    usually have no shell or password set. These common hardening practices ensure
    that they can’t perform system tasks such as job scheduling if compromised.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些账户不是用于用户登录的，如果你仔细查看任何实验机器（甚至是 Kali）上的 */etc/passwd*，你会发现它们通常没有设置 shell 或密码。这些常见的加固措施确保在受到攻击时不能执行系统任务，如作业调度。
- en: 'But if you’ve compromised a machine and gained access to a root account (or
    a sudo user with the ability to create or modify users), you could take measures
    such as the following to craft a backdoor mechanism that blends into the environment:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你已经入侵了一台机器并获得了 root 账户访问权限（或者具有创建或修改用户权限的 sudo 用户），你可以采取以下措施之一来制作一个能够融入环境的后门机制：
- en: Creating a new account that looks similar to a service account
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个看起来类似服务账户的新账户
- en: Modifying an existing service account by adding a shell and password to it
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向现有服务账户添加 shell 和密码进行修改
- en: Let’s convert a service account into a backdoor account that grants us ongoing
    access to the system. We’ll target the *p-jumpbox-01* machine (172.16.10.13),
    where we have root access.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一个服务账户转换为一个后门账户，以便我们持续访问系统。我们将瞄准 *p-jumpbox-01* 机器（172.16.10.13），在那里我们拥有
    root 访问权限。
- en: 'We’ll backdoor the lp account, which is usually used for managing spooling
    services. You can see this account and its default shell in */etc/passwd*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给 lp 账户加入后门，通常用于管理进纸服务。您可以在 */etc/passwd* 中看到此账户及其默认 shell：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, the account has the */usr/sbin/nologin* shell; this won’t allow
    us to log in. Let’s modify the default shell by using usermod and passing it the
    -s (shell) argument:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个账户的 */usr/sbin/nologin* shell ；这不允许我们登录。让我们使用 usermod 并传递 -s（shell）参数来修改默认
    shell：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We recommend learning more about the usermod command by running man usermod.
    Next, set a password with the passwd command and enter a password when prompted:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议通过运行 man usermod 了解更多关于 usermod 命令的信息。接下来，使用 passwd 命令设置密码，并在提示时输入密码：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, check that you can SSH into the server by using the lp account:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过 lp 账户尝试 SSH 登录服务器：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You should be able to remotely connect to the machine by using this service
    account, which should now have a valid shell. You can use this as a backdoor account
    if you lose root access in the future, or if the root account is disabled for
    remote logins.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够通过这个服务账户远程连接到机器上，并且该账户现在应该有一个有效的 shell。如果将来丢失 root 访问权限或者 root 账户被禁用远程登录，您可以将其用作后门账户。
- en: Poisoning Bash Environment Files
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 污染 Bash 环境文件
- en: In [Chapter 2](chapter2.xhtml), we discussed files such as *~/.bashrc*, which
    let us define variables, aliases, and scripts to customize the environment. In
    addition to these files, which live in a user’s home directory, there are system-wide
    *.bashrc* and *.profile* files, located at */etc/bash.bashrc* or */etc/bashrc*
    and */etc/profile*, respectively.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第二章](chapter2.xhtml) 中，我们讨论了像 *~/.bashrc* 这样的文件，它们允许我们定义变量、别名和脚本来自定义环境。除了用户家目录中的这些文件之外，还有系统范围的
    *.bashrc* 和 *.profile* 文件，分别位于 */etc/bash.bashrc* 或 */etc/bashrc* 和 */etc/profile*。
- en: When bash is invoked as an interactive login shell, it will read from */etc/profile*
    (if it exists) before reading user-level environment files such as *~/.bash_profile*,
    *~/bash_login*, and *~/.profile*. Similarly, when bash is invoked as a nonlogin
    interactive shell, it reads the global *bashrc* file before the local one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当 bash 作为交互式登录 shell 被调用时，它会在读取用户级环境文件（如 *~/.bash_profile*、*~/bash_login* 和
    *~/.profile*）之前读取 */etc/profile*（如果该文件存在）。类似地，当 bash 作为非登录交互式 shell 被调用时，它会在本地文件之前读取全局的
    *bashrc* 文件。
- en: 'Also, */etc/profile* will look for files under the */etc/profile.d* directory.
    If files exist, it will use the . command to source (or import) them. You can
    see this behavior by running cat /etc/profile:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，*/etc/profile* 会查找 */etc/profile.d* 目录下的文件。如果存在文件，它将使用 . 命令来加载（或导入）它们。你可以通过运行
    `cat /etc/profile` 来查看这一行为：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, an if condition ❶ checks whether */etc/profile.d* is a directory.
    Next, a for loop iterates on all files with a *.sh* extension under */etc/profile.d*
    ❷ and checks each file for read access by using -r ❸. Finally, the script imports
    the file by using the . command ❹.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一个 if 条件 ❶ 检查 */etc/profile.d* 是否是一个目录。接着，一个 for 循环迭代 */etc/profile.d*
    下所有扩展名为 *.sh* 的文件 ❷，并使用 -r 检查每个文件是否具有读取权限 ❸。最后，脚本使用 . 命令 ❹ 导入该文件。
- en: If we can write malicious code to files such as */etc/profile* or into a directory
    such as */etc/profile.d*, we could invoke shells running custom code under our
    control. If you’ve compromised a specific user account, you might also try planting
    malicious code in that user’s shell environment file, which may lead to interesting
    results and doesn’t require root access. However, the impact will be user specific.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将恶意代码写入 */etc/profile* 等文件或 */etc/profile.d* 等目录中，我们就可以调用在我们控制下运行的自定义代码的
    shell。如果你已经侵入了特定的用户帐户，你也可以尝试将恶意代码植入该用户的 shell 环境文件，这可能会导致有趣的结果，并且不需要 root 权限。然而，影响将仅限于该用户。
- en: 'Let’s try tampering with a user’s profile by introducing custom code that will
    run immediately after a user executes a command. Log in to *p-jumpbox-01* (172.16.10.13)
    as the backup user and create a *.profile* file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过引入自定义代码篡改用户的配置文件，使得用户执行命令后立即运行该代码。以备份用户身份登录 *p-jumpbox-01*（172.16.10.13），并创建一个
    *.profile* 文件：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, write the script in [Listing 10-4](chapter10.xhtml#Lis10-4) into the file
    and save it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 [示例 10-4](chapter10.xhtml#Lis10-4) 中的脚本写入文件并保存。
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 10-4: Hooking an operating system command'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-4：操作系统命令钩子
- en: First, we create a function called hook ❶. This function does only one thing,
    which is print You executed ${BASH_COMMAND} to standard output, where ${BASH_COMMAND}
    is an environment variable that holds the name of the command about to be executed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 hook 的函数 ❶。这个函数只做一件事，即打印 You executed ${BASH_COMMAND} 到标准输出，其中 ${BASH_COMMAND}
    是一个环境变量，保存着即将执行的命令的名称。
- en: 'At ❷, we use the trap command followed by the function name (hook()) and the
    word DEBUG, which is a type of *signal spec (sigspec)* that the trap accepts.
    A sigspec can be any of these values: EXIT, DEBUG, RETURN, or ERR; DEBUG ensures
    that we trap every command executed. (In Exercise 20, we’ll put this sigspec to
    use to steal sensitive data.)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❷ 处，我们使用 trap 命令，后面跟着函数名（hook()）和 DEBUG 关键字，这是一种 trap 接受的 *信号规范（sigspec）*。信号规范可以是以下值之一：EXIT、DEBUG、RETURN
    或 ERR；DEBUG 确保我们捕获每个执行的命令。（在练习 20 中，我们将使用这个信号规范来窃取敏感数据。）
- en: 'Finally, here’s the source file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是源文件：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now run a few commands and observe the output. In the following example, we
    run id and ps -ef:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行一些命令并观察输出。在以下示例中，我们运行了 `id` 和 `ps -ef`：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, our active hook prints the command we executed just before the
    output of that command.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的主动钩子打印了在该命令输出之前执行的命令。
- en: 'Exercise 20: Intercepting Data via Profile Tampering'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 20：通过篡改配置文件拦截数据
- en: 'In this exercise, you have a clear malicious goal: write a script that captures
    any command executed on the compromised system that might contain sensitive information,
    then transmit it to a remote server. If you’re unsure of which commands could
    be interesting to intercept, we have a few examples in our back pocket:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你有一个明确的恶意目标：编写一个脚本，捕捉任何在被攻破的系统上执行的可能包含敏感信息的命令，然后将其传输到远程服务器。如果你不确定哪些命令可能值得拦截，我们有几个例子可以参考：
- en: Web requests that contain an API key parameter
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 API 密钥参数的网页请求
- en: Passwords passed on the command line to common utilities, such as database administration
    tools like MySQL or Redis
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给常用工具的命令行密码，例如数据库管理工具（如 MySQL 或 Redis）
- en: PII such as emails or credit card numbers passed on the command line
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如电子邮件或信用卡号等 PII 通过命令行传递
- en: 'In addition, here are a few high-level tips to get you going:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是一些高级提示，帮助你开始：
- en: Run a web search for string patterns that match the sensitive data you’re interested
    in. For example, look for commands that can accept passwords or even credit card
    numbers.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行网络搜索以查找与你感兴趣的敏感数据匹配的字符串模式。例如，寻找可以接受密码甚至信用卡号的命令。
- en: Identify specific commands you want to intercept; avoid intercepting every command,
    to make your data collection precise.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定你要拦截的特定命令；避免拦截每个命令，以使你的数据收集更精确。
- en: Design your script such that it fails safely. If something goes wrong while
    sending the data over the network, catch the error so the information doesn’t
    leak to the unsuspecting user.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计你的脚本，以便在发送数据到网络时安全失败。如果在传输过程中发生错误，请捕获错误以防信息泄露给不知情的用户。
- en: '[Listing 10-5](chapter10.xhtml#Lis10-5) provides one solution, which targets
    curl or mysql commands used to transmit credentials.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10-5节](chapter10.xhtml#Lis10-5) 提供了一个解决方案，针对使用 curl 或 mysql 命令传输凭证的情况。'
- en: profile_hook.sh
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: profile_hook.sh
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 10-5: Hooking commands and stealing credentials'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第10-5节：截取命令和窃取凭证
- en: 'We create a function named hook() that uses a case statement ❶. The statement
    will try to match the BASH_COMMAND variable against two patterns: mysql* ❷ and
    curl* ❹. These patterns will match anything that starts with either of these strings.
    This should identify uses of the mysql command to connect to a database and the
    curl command to make HTTP requests.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为 hook() 的函数，其中使用一个 case 语句 ❶。该语句将尝试将 BASH_COMMAND 变量与两个模式进行匹配：mysql*
    ❷ 和 curl* ❹。这些模式将匹配任何以这些字符串开头的内容。这应该能够识别使用 mysql 命令连接数据库和使用 curl 命令进行 HTTP 请求的情况。
- en: Next, if the command involved calling the mysql client, we check whether the
    command included a password on the command line by using the -p or --password
    arguments ❸. In this case, the password would belong to the database. If we have
    a match, we send an HTTP POST request to *https://attacker.com* containing a JSON
    payload with the raw command in the request’s POST body.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果命令涉及调用 mysql 客户端，我们将检查命令行是否包含密码，使用 -p 或 --password 参数 ❸。在这种情况下，密码将属于数据库。如果找到匹配项，我们将向
    *https://attacker.com* 发送一个 HTTP POST 请求，其中包含原始命令的 JSON 负载。
- en: At ❺, we do a similar thing with curl. We search for strings such as token,
    apikey, api_token, bearer, or authorization to catch any API keys being passed
    on the command line. These credentials might belong to an internal web panel or
    to an administration interface of some sort. The search is case insensitive (-i).
    If we find such a pattern, we send a request containing the command and the credentials
    to the attacker’s website over HTTP POST.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❺ 处，我们使用 curl 进行类似的操作。我们搜索诸如 token、apikey、api_token、bearer 或 authorization
    等字符串，以捕获命令行传递的任何 API 密钥。这些凭证可能属于内部 Web 面板或某种管理界面。搜索时不区分大小写（-i）。如果找到这样的模式，我们将发送一个请求，其中包含命令和凭证，到攻击者的网站上，通过
    HTTP POST 方法。
- en: Finally, we use trap to trap the hook() function with the DEBUG sigspec type
    ❻.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 trap 来使用 DEBUG sigspec 类型 ❻ 捕获 hook() 函数。
- en: NOTE
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can download this chapter’s scripts from* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以从* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10)
    *下载本章的脚本*。'
- en: Credential Theft
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凭证窃取
- en: If you can maintain access to a user’s credential data, or perhaps even to the
    keyboard actions taken by users, you could keep your access to the system as a
    whole. For example, if a user reset their password and we happened to intercept
    the commands used to do so, we could maintain access even if the credentials were
    rotated (at least until someone discovered and disarmed our mechanism or completely
    wiped the infected system).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够保持对用户凭证数据或甚至用户键盘操作的访问，你可以保持对整个系统的访问。例如，如果用户重置他们的密码，并且我们恰好拦截到执行此操作的命令，即使凭证已经被更改，我们也可以保持访问（至少直到有人发现并停用我们的机制或完全清除受感染的系统）。
- en: We can capture credential information in a variety of ways. One way is by trojanizing
    commands, such as by replacing them with malicious binaries or otherwise tampering
    with their execution flow by injecting malicious logic into them. In this section,
    we’ll implement malicious logic in a few common system administrator utilities.
    We’ll also extract credentials from the bash history file and send these over
    the network.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式捕获凭证信息。一种方法是通过特洛伊木马化命令，例如用恶意二进制文件替换它们，或者通过向其中注入恶意逻辑来破坏它们的执行流程。在本节中，我们将实现一些常见系统管理员工具中的恶意逻辑。我们还将从
    bash 历史文件中提取凭证并通过网络发送这些信息。
- en: Hooking a Text Editor
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂钩文本编辑器
- en: '*Vim* is a common text editor application often found on servers. It’s also
    many developers’ and system administrators’ go-to text-editing application, so
    it warrants its own section.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*Vim* 是一种常见的文本编辑器应用程序，通常可以在服务器上找到。它也是许多开发人员和系统管理员首选的文本编辑应用程序，因此值得单独介绍。'
- en: NOTE
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you’ve never used Vim before, we highly recommend you familiarize yourself
    with it. It’s a powerful editor with many additional capabilities, such as macros,
    scripts, and a plug-in system.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你从未使用过 Vim，我们强烈建议你熟悉它。它是一个功能强大的编辑器，拥有许多附加功能，例如宏、脚本和插件系统。*'
- en: If you have access to one or more users on the system and can modify configurations
    in their home directories, you can exploit Vim’s *autocmd* feature, an automation
    system able to run certain shell commands when special editor events occur. We
    define autocmd actions by using the *~/.vimrc* file, which Vim usually searches
    for in the user’s home directory. When the text editor is opened, it reads from
    this file and looks for any special configurations and instructions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以访问系统上的一个或多个用户，并且可以修改他们主目录中的配置文件，你可以利用 Vim 的 *autocmd* 功能，这是一个在特定编辑器事件发生时能够执行某些
    shell 命令的自动化系统。我们通过使用 *~/.vimrc* 文件来定义 autocmd 操作，Vim 通常会在用户的主目录中搜索该文件。当文本编辑器打开时，它会读取该文件并查找任何特殊的配置和指令。
- en: autocmd events could occur whenever a file is written or read, whenever a file
    is open or closed, and whenever the editor itself is opened or closed, among other
    cases. [Table 10-1](chapter10.xhtml#tab10-1) highlights a few key autocmd events
    of interest.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: autocmd 事件可能在文件写入或读取时、文件打开或关闭时，以及编辑器本身打开或关闭时等情况下发生。[表 10-1](chapter10.xhtml#tab10-1)
    列出了几个关键的 autocmd 事件。
- en: 'Table 10-1: Interesting autocmd Events'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1：有趣的 autocmd 事件
- en: '| Event name | Description |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 事件名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ShellCmdPost | After executing a shell command |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| ShellCmdPost | 执行完 shell 命令后 |'
- en: '| BufWritePost | After writing the entire buffer |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| BufWritePost | 写入整个缓冲区后 |'
- en: '| BufWipeout | Before deleting the buffer |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| BufWipeout | 在删除缓冲区之前 |'
- en: '| StdinReadPost | After reading from stdin into the buffer |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| StdinReadPost | 从 stdin 读取到缓冲区后 |'
- en: The BufWritePost event allows us to take an action after the editor writes whatever
    was present in the buffer. This means that if a user opened a file and performed
    a write action, autocmd would execute our commands.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: BufWritePost 事件允许我们在编辑器写入缓冲区中的内容后执行某些操作。这意味着如果用户打开了一个文件并进行了写入操作，autocmd 将执行我们的命令。
- en: 'Let’s exploit this behavior. First, write the following content into the *~/.vimrc*
    file under a user’s home directory. You can use any of the lab’s compromised machines,
    such as *p-jumpbox-01* (172.16.10.13), using the backup or *root* user:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这种行为。首先，将以下内容写入某个用户主目录下的 *~/.vimrc* 文件中。你可以使用实验室中的任何一台被攻破的机器，例如 *p-jumpbox-01*（172.16.10.13），使用备份或
    *root* 用户：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s dissect what’s happening. First, we define an autocmd instruction by using
    the autocmd keyword. Next, we specify the event name BufWritePost, followed by
    two file extensions, **.conf* and **.config*. This will ensure that the command
    triggers whenever a file with the either of these extensions is written.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下发生了什么。首先，我们使用 autocmd 关键字定义一个 autocmd 指令。接下来，我们指定事件名称 BufWritePost，然后跟随两个文件扩展名，**.conf**
    和 **.config**。这将确保无论何时写入带有这两个扩展名的文件，命令都会触发。
- en: We use :silent to suppress any command messages or errors. Finally, we define
    a command with !, followed by the syntax of the shell command of interest. In
    this example, we’re making an HTTP POST request to 172.16.10.1:8080 by using curl,
    which will run a listener in our Kali machine. We pass -m (max time) with a value
    of 5 to ensure that the entire operation doesn’t take more than five seconds.
    We then pass the -s (silent) argument to stop text from being printed out, and
    redirect the standard output to */dev/null* by using -o /dev/null. We also pass
    --data-binary @<afile> to upload a file. The autocmd <afile> variable represents
    the actual file that Vim is editing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`:silent`来抑制任何命令消息或错误。最后，我们定义一个以`!`开头的命令，后跟感兴趣的shell命令的语法。在这个例子中，我们使用curl向172.16.10.1:8080发出HTTP
    POST请求，这将运行我们Kali机器上的监听器。我们传递`-m`（最大时间）并设定为5，以确保整个操作不超过五秒。然后我们传递`-s`（静默）参数以防止文本输出，并通过使用`-o
    /dev/null`将标准输出重定向到*/dev/null*。我们还传递`--data-binary @<afile>`来上传文件。autocmd <afile>变量表示Vim正在编辑的实际文件。
- en: 'To summarize, when a user writes a file with a name such as *credentials.conf*,
    Vim will execute a curl command to secretly send the file to the remote listener.
    Save this file as *~/.vimrc*. Next, open a remote listener on the Kali machine
    by using any TCP listener of choice:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当用户写入一个名为*credentials.conf*的文件时，Vim将执行一个curl命令，秘密地将该文件发送到远程监听器。将此文件保存为*~/.vimrc*。接着，通过使用任何TCP监听器在Kali机器上打开一个远程监听器：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, using either vi or vim.tiny commands (as vi is a symbolic link to
    vim.tiny in the lab), open a file and write content to it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用vi或vim.tiny命令（因为vi在实验室中是vim.tiny的符号链接），打开一个文件并写入内容：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When you use Vim to save the file to disk, you should notice that the content
    of the file was sent to the listener:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Vim将文件保存到磁盘时，你应该注意到文件内容已被发送到监听器：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you wanted to leak all files, no matter their extension, this autocmd command
    should do the job:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想泄露所有文件，无论其扩展名如何，这个autocmd命令应该能完成任务：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, if a file is particularly large, the upload could take a long time.
    This could reveal to the user that something nefarious is happening, as writing
    to the file would cause a noticeable delay. Let’s make our hook a little cleverer
    ([Listing 10-6](chapter10.xhtml#Lis10-6)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果文件特别大，上传可能需要很长时间。这可能会让用户察觉到某些不正当行为，因为写入文件时会导致明显的延迟。让我们让我们的钩子更聪明一点（[列表 10-6](chapter10.xhtml#Lis10-6)）。
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 10-6: Conditional command execution with autocmd'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-6: 使用autocmd条件执行命令'
- en: Now the command will look only for files containing credentials such as passwords
    or API keys.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，命令将只查找包含凭证的文件，比如密码或API密钥。
- en: Streaming Executed Commands
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流式传输已执行的命令
- en: In [Chapter 8](chapter8.xhtml), we discussed history files, such as *~/.bash_history*.
    History files keep a record of commands executed by users and allow for an access,
    audit, and replay of previously executed commands.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](chapter8.xhtml)中，我们讨论了历史文件，比如*~/.bash_history*。历史文件记录了用户执行的命令，并允许访问、审计和重放之前执行的命令。
- en: History files update whenever new commands are executed, so it could be interesting
    to stream the history files over the network to a listener providing a live record
    of command-execution events to a server we control. These commands could reveal
    what users are executing on a server and capture any credentials they enter via
    the command line. (Note that *~/.bash_history* is just an example; you may find
    it useful to stream other files in your future engagements by using the method
    shown here.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每当新命令被执行时，历史文件就会更新，因此将历史文件流式传输到网络上的监听器，以提供命令执行事件的实时记录，这可能会很有趣，从而将其传输到我们控制的服务器。这些命令可能揭示用户在服务器上执行了什么操作，并捕获他们通过命令行输入的任何凭据。（注意，*~/.bash_history*只是一个示例；你可能会发现通过此方法流式传输其他文件在将来会更有用。）
- en: Let’s set up a few bash commands to send the last written command over the network
    to a remote listener. This technique assumes you have access to a user’s home
    directory and can modify the *~/.profile* file or have the ability to write into
    the system-wide */etc/profile* file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置几个bash命令，将最后写入的命令通过网络发送到远程监听器。此技术假设你有权限访问用户的主目录，并能修改*~/.profile*文件，或者有能力写入系统范围的*/etc/profile*文件。
- en: On *p-jumpbox-01* (172.16.10.13), using the *root* user, create a file under
    the */etc/profile.d* directory named *99-stream.sh* with the contents in [Listing
    10-7](chapter10.xhtml#Lis10-7).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在*p-jumpbox-01*（172.16.10.13）上，使用*root*用户，在*/etc/profile.d*目录下创建一个名为*99-stream.sh*的文件，内容参考[列表
    10-7](chapter10.xhtml#Lis10-7)。
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 10-7: Streaming history files over the network'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-7：通过网络流式传输历史文件
- en: 'At ❶, we export the PROMPT_COMMAND variable to make it available to subsequent
    commands during execution. We’ll set this variable to a bash command that will
    execute just before the shell displays the prompt in the terminal. You’ll notice
    that we pass the history command twice as its value: once with the -a (append)
    parameter and a second time with the -r (read) parameter. The PROMPT_COMMAND value
    will execute just before the prompt is shown, allowing us to append to and read
    from the history file whenever a command is executed.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 处，我们导出 PROMPT_COMMAND 变量，以便在执行期间使其对后续命令可用。我们将此变量设置为一个 bash 命令，该命令将在终端显示提示之前执行。您会注意到我们将
    history 命令传递两次作为其值：一次使用 -a（追加）参数，第二次使用 -r（读取）参数。PROMPT_COMMAND 的值将在显示提示之前执行，允许我们在执行命令时追加到历史文件并从中读取。
- en: We check whether the Netcat (nc) process is running by using pgrep ❷. We use
    -u (user) with whoami to narrow the process list to only those run by the current
    user, followed by the process name of nc. If pgrep returns an exit code of 1 (process
    not found), no reverse shell has connected from this user, so we can establish
    one. This helps us avoid opening multiple connections from the same user.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 pgrep ❷ 检查 Netcat（nc）进程是否在运行。我们使用 -u（用户）与 whoami 结合，将进程列表限制为仅列出当前用户运行的
    nc 进程。如果 pgrep 返回退出码 1（未找到进程），则没有反向 shell 从此用户连接，因此我们可以建立一个新的连接。这有助于我们避免从同一用户打开多个连接。
- en: We use the tail command to read the end of the history file and pipe it to nc
    ❸. The -F (follow) argument tracks the end of the file so any new content gets
    sent across the wire.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 tail 命令读取历史文件的末尾，并将其管道传输到 nc ❸。-F（跟随）参数跟踪文件的末尾，因此任何新内容都会被发送到网络。
- en: 'Finally, we’ll use socat on Kali so we can receive multiple connections without
    closing the server’s end of the connection if multiple users connect and execute
    commands simultaneously:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在 Kali 上使用 socat，以便在多个用户同时连接并执行命令时，能够接收多个连接而不关闭服务器端的连接：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open another terminal and log in to *p-jumpbox-01* (172.16.10.13) as the user
    *backup* (with the previously compromised password *backup*). Then enter a few
    commands:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端并作为用户 backup（先前被入侵密码为 backup）登录到 *p-jumpbox-01*（172.16.10.13）。然后输入几个命令：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Observe the output from socat:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 socat 输出的结果：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You could adapt this technique to stream any file of value during a penetration
    test, such as application or system logfiles.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调整此技术来流式传输任何有价值的文件，如应用程序或系统日志文件，在渗透测试期间。
- en: Forging a Not-So-Innocent sudo
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锻造一个不那么无辜的 sudo
- en: 'In [Chapter 9](chapter9.xhtml), we used misconfigurations of the sudo command
    to elevate our privileges. But we can compromise sudo in another way: by replacing
    it with our own malicious version, then harvesting the user’s password when they
    enter it to run the command.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](chapter9.xhtml)中，我们利用 sudo 命令的配置错误来提升我们的权限。但我们还可以通过另一种方式来损害 sudo：通过替换为我们自己的恶意版本，然后在用户输入密码运行命令时收集其密码。
- en: The main downside to this approach is that when a user provides a correct password
    to sudo, it caches the credentials for a period (such as 15 minutes), and subsequent
    commands won’t require reentering the password. The setting responsible for the
    caching duration is called timestamp_timeout.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的主要缺点在于，当用户向 sudo 提供正确的密码时，它会缓存凭据一段时间（例如 15 分钟），后续命令将无需重新输入密码。负责缓存持续时间的设置称为
    timestamp_timeout。
- en: Despite the caching, if we’re able to intercept the execution when the user
    enters their password the first time, we may be able to leak their password. Let’s
    walk through such an example. In this scenario, we assume we have access to alter
    a user’s environment and can modify files such as *~/.bashrc*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有缓存，如果我们能拦截用户第一次输入密码时的执行，我们可能能够泄漏他们的密码。让我们通过这样一个例子来详细说明。在这种情况下，我们假设我们可以访问并修改用户的环境，以及修改像
    *~/.bashrc* 这样的文件。
- en: We’ll create a fake sudo script. Then we’ll modify a compromised user’s environment
    so that calling sudo will execute the fake version through the use of an alias,
    send their password over the network by using curl, and continue the normal sudo
    execution flow, to avoid raising suspicion.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个伪造的 sudo 脚本。然后，我们将修改被入侵用户的环境，通过别名执行伪造版本调用 sudo，使用 curl 发送他们的密码到网络，并继续正常的
    sudo 执行流程，以避免引起怀疑。
- en: 'Let’s begin! You can perform this scenario on *p-jumpbox-01* (172.16.10.13)
    by implanting the fake sudo script in the backup user account. Create this fake
    sudo file somewhere writable:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！您可以在 *p-jumpbox-01* (172.16.10.13) 上的备份用户帐户中植入虚假 sudo 脚本来执行此场景。在某个可写位置创建此虚假
    sudo 文件：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, create an alias by adding a line to the compromised user’s *~/.bashrc*
    environment file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过向受损用户的 *~/.bashrc* 环境文件添加一行来创建别名：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finally, populate the script with the code in [Listing 10-8](chapter10.xhtml#Lis10-8).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将脚本填充到 [列表 10-8](chapter10.xhtml#Lis10-8) 中的代码中。
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 10-8: A fake sudo script'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-8：一个虚假 sudo 脚本
- en: At ❷, we turn off input echoing by using stty -echo. We then read input from
    the user and present a sudo-like prompt ❸. As the input is the user’s password,
    it shouldn’t be presented in cleartext to the user while they’re typing it. This
    is because, by default, sudo hides the input while it’s being typed, and we need
    to emulate the look and feel of the original command. So, we disable input echoing
    before accepting input from the user.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❷ 处，我们通过使用 stty -echo 关闭输入回显。然后，我们从用户那里读取输入，并呈现类似 sudo 的提示符 ❸。由于输入是用户的密码，在用户输入密码时不应该明文显示。这是因为，默认情况下，sudo
    在用户输入时隐藏输入，我们需要模拟原始命令的外观和感觉。因此，我们在接受用户输入之前禁用输入回显。
- en: Next, we leak the provided password by using the leak_over_http() function.
    This function will use base64 to encode the password and use curl to make an HTTP
    GET request to a path on the web server, using the captured password as the path
    ❶.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用 leak_over_http() 函数泄漏提供的密码。该函数将使用 base64 对密码进行编码，并使用 curl 发起 HTTP
    GET 请求到 web 服务器的路径，使用捕获的密码作为路径 ❶。
- en: At ❹, we turn on input echoing and pass the password, along with the command
    the user executed, to the real sudo binary (*/usr/bin/sudo*) so that the sudo
    execution resumes normally. [Figure 10-1](chapter10.xhtml#fig10-1) highlights
    this flow from end to end.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❹ 处，我们打开输入回显并传递密码，以及用户执行的命令到真正的 sudo 二进制文件 (*/usr/bin/sudo*)，以便 sudo 执行正常恢复。[图
    10-1](chapter10.xhtml#fig10-1) 从头到尾展示了这个流程。
- en: '![](../images/pg250.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg250.jpg)'
- en: 'Figure 10-1: A password interception flow using a fake sudo script'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：使用虚假 sudo 脚本进行密码拦截流程
- en: 'Finally, on your Kali machine, use Python to run a simple HTTP server:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在您的 Kali 机器上，使用 Python 运行一个简单的 HTTP 服务器：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then open another terminal to *p-jumpbox-01* (172.16.10.13) and run a sudo
    command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开另一个终端到 *p-jumpbox-01* (172.16.10.13) 并运行一个 sudo 命令：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should receive the leaked password:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到泄露的密码：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The bolded base64-encoded string is *backup*, which is the password of the backup
    user.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体的 base64 编码字符串是 *backup*，即备份用户的密码。
- en: You can find this script at *[https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10/fake_sudo.sh](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10/fake_sudo.sh)*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *[https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10/fake_sudo.sh](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10/fake_sudo.sh)*
    找到此脚本。
- en: 'Exercise 21: Hijacking Password Utilities'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 21：劫持密码实用程序
- en: 'You could use an approach similar to the sudo attack we just performed to hijack
    other utilities. Any tool that interacts with credentials can help you gain persistence,
    including the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似于我们刚刚执行的 sudo 攻击的方法来劫持其他实用程序。任何与凭据交互的工具都可以帮助您获得持久性，包括以下内容：
- en: passwd For changing local user passwords
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: passwd 用于更改本地用户密码
- en: chpasswd For updating passwords in bulk
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: chpasswd 用于批量更新密码
- en: htpasswd For setting up or changing Apache basic authentication
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: htpasswd 用于设置或更改Apache基本认证
- en: smbpasswd For changing Samba user passwords (such as Active Directory user passwords)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: smbpasswd 用于更改 Samba 用户密码（例如 Active Directory 用户密码）
- en: ldappasswd For changing Lightweight Directory Access Protocol user passwords
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ldappasswd 用于更改轻量级目录访问协议用户密码
- en: 'Try programming a fake command that accepts passwords as input. Here is guidance
    on how to go about this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个接受密码作为输入的虚假命令。以下是如何操作的指南：
- en: 1.  Use man to learn about the target utility.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  使用 man 来了解目标实用程序。
- en: 2.  Attempt to use the tool, taking notes on how it prompts users for passwords,
    what type of output it produces, and how it handles errors.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  尝试使用该工具，记录它如何提示用户输入密码，产生什么类型的输出以及如何处理错误。
- en: 3.  Create a fake utility that can produce the same outputs and accept the same
    inputs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  创建一个可以生成相同输出并接受相同输入的虚假实用程序。
- en: 4.  Retrofit the sudo script from the previous section to fit your new fake
    utility, or create a new script from scratch.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  根据前一节的 sudo 脚本进行修改，以适应新的虚假实用程序，或者从头开始创建一个新脚本。
- en: Distributing Malicious Packages
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发恶意包
- en: Linux systems use package installers such as Debian (DEB) and RPM, depending
    on the distribution. These installers are interesting because they let you package
    your own files, and you may be able to backdoor a system if you can get someone
    to install a malicious package you’ve developed. In the next sections, we’ll explore
    the DEB packaging system. Then we’ll create packages that contain malicious code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统根据发行版使用不同的包管理器，如 Debian（DEB）和 RPM。这些安装程序很有趣，因为它们允许你将自己的文件打包，并且如果你能让别人安装你开发的恶意包，你可能会通过后门攻击系统。在接下来的章节中，我们将探讨
    DEB 包管理系统。然后我们将创建包含恶意代码的包。
- en: Note that software installation on Linux requires root privileges by default;
    a regular user cannot use commands such as dpkg -i package or rpm -i package unless
    they were specifically granted privileged access to these utilities.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Linux 上的软件安装默认需要 root 权限；普通用户不能使用诸如 dpkg -i package 或 rpm -i package 之类的命令，除非他们特别被授予对这些工具的特权访问权限。
- en: Understanding DEB Packages
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 DEB 包
- en: 'You’ll find DEB packages used by the Debian Linux distribution and its derivatives,
    such as Ubuntu. DEB packages are *ar* (archive) files and contain three files:
    *debian-binary*, the control archive, and the data archive.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现 DEB 包被 Debian Linux 发行版及其衍生版（如 Ubuntu）使用。DEB 包是 *ar*（归档）文件，包含三个文件：*debian-binary*，控制归档文件和数据归档文件。
- en: The *debian-binary* file is a text file containing the package’s version number,
    such as 2.0. The *control archive* is a compressed file containing scripts and
    metadata information. The *data archive* contains the files the package should
    install (for example, the software’s manual pages or additional binaries).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*debian-binary* 文件是一个文本文件，包含包的版本号，例如 2.0。*control archive* 是一个压缩文件，包含脚本和元数据。*data
    archive* 包含包应安装的文件（例如，软件的手册页或额外的二进制文件）。'
- en: 'Let’s explore an example package before building our own. Download the example
    DEB package, *example_amd64.deb*. Then run dpkg --info on the package to see information
    about it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自己构建包之前，让我们先看一个示例包。下载示例 DEB 包，*example_amd64.deb*。然后运行 dpkg --info 命令查看包的信息：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, run strings on the package to see its contents. You should see the three
    files we discussed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行 strings 命令查看包的内容。你应该会看到我们讨论过的三个文件：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, install the package to see what it does. You can do this on any machine
    in the lab or on Kali:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安装该包以查看它的作用。你可以在实验室的任何机器上或 Kali 上执行此操作：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, the package doesn’t do anything special other than printing
    a message to the screen. Consider this the “Hello, world!” of DEB packages.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，除了在屏幕上打印一条消息外，包没有做任何特殊的事情。可以将其视为 DEB 包的 “Hello, world!”。
- en: 'To extract the contents of a *.deb* file, use the ar command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取 *.deb* 文件的内容，可以使用 ar 命令：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The v flag is for verbose mode; the x flag, for extraction, accepts the filename.
    To further extract the *control.tar.xz* and *data.tar.xz* files, you can use the
    tar command with -x (extract), -v (verbose), and -f (file):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: v 标志用于详细模式；x 标志用于提取，接受文件名。为了进一步提取 *control.tar.xz* 和 *data.tar.xz* 文件，你可以使用
    tar 命令，带上 -x（提取），-v（详细）和 -f（文件）：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: DEB packages can contain several types of scripts. The most interesting to us
    are *inst* (installation) and *rm* (remove) scripts. *Installation scripts* are
    responsible for the bootstrapping of the package. They include preinstallation
    scripts (*preinst*), called before the package is installed, and post-installation
    scripts (*postinst*), called afterward. These scripts can perform any task, but
    some common tasks are creating directories, setting permissions, and copying files.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: DEB 包可以包含几种类型的脚本。对我们来说最有趣的是 *inst*（安装）和 *rm*（删除）脚本。*安装脚本* 负责包的引导过程。它们包括预安装脚本
    (*preinst*)，在包安装之前执行，和后安装脚本 (*postinst*)，在包安装之后执行。这些脚本可以执行任何任务，但一些常见的任务包括创建目录、设置权限和复制文件。
- en: The *rm scripts* perform some form of cleanup, such as removing files or stopping
    services. These include *prerm* scripts, which take actions such as the removal
    of symbolic links or files associated with the package before it’s finally removed,
    and *postrm* scripts, which clean up files after the package is removed. Can you
    think of ways to include malicious code in these scripts?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*rm 脚本* 执行某种清理操作，例如删除文件或停止服务。这些包括 *prerm* 脚本，它们在包最终被删除之前执行诸如删除符号链接或与包相关的文件的操作，以及
    *postrm* 脚本，它们在包被删除后清理文件。你能想到在这些脚本中包含恶意代码的方式吗？'
- en: Packaging Innocent Software
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打包无害软件
- en: 'Let’s practice creating packages by making our own innocent package. On your
    Kali machine, create a directory named *example*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过制作自己的无害包来练习创建包。在你的 Kali 机器上，创建一个名为 *example* 的目录：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, create a directory named *DEBIAN* inside the *example* directory:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 *example* 目录中创建一个名为 *DEBIAN* 的目录：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a file named *control* inside the *DEBIAN* directory, with the following
    package metadata, and save the file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *DEBIAN* 目录中创建一个名为 *control* 的文件，包含以下包元数据，并保存文件：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then use dpkg -b (build) to build the package. The first argument to -b is
    the name of the directory where the files to package are located, followed by
    the name of the artifact to generate:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 dpkg -b（构建）来构建包。-b 的第一个参数是包含要打包文件的目录名称，接着是生成的工件名称：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can install this package by using sudo dpkg -i package and remove it by using
    sudo dpkg -r package.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 sudo dpkg -i package 安装此包，并使用 sudo dpkg -r package 卸载它。
- en: Converting Package Formats with alien
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 alien 转换包格式
- en: Other Linux distributions use different package formats. Luckily, we can convert
    packages from one format to another (for example, from RPM to DEB or from DEB
    to RPM) by using a tool called alien. Kali should come with alien installed, but
    if not, install it using sudo apt install alien.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 Linux 发行版使用不同的包格式。幸运的是，我们可以通过使用一个名为 alien 的工具将包从一种格式转换为另一种格式（例如，从 RPM 转换为
    DEB 或从 DEB 转换为 RPM）。Kali 系统应该预装了 alien，如果没有，可以使用 sudo apt install alien 命令安装它。
- en: 'The following example converts a DEB package to an RPM package:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将 DEB 包转换为 RPM 包：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We use the arguments -v (verbose), -r package (where the *r* stands for *rpm
    conversion*), and --scripts to tell alien to use verbose output, convert the package
    to RPM, and include the post- and pre-scripts we created earlier.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用参数-v（详细模式）、-r 包（其中 *r* 代表 *rpm 转换*）和 --scripts 来告诉 alien 使用详细输出，将包转换为 RPM
    格式，并包含我们之前创建的前后脚本。
- en: Converting a package from RPM back to the DEB format is as easy as changing
    the -r flag to -d.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将 RPM 包转换回 DEB 格式只需要将 -r 参数改为 -d 即可。
- en: 'Exercise 22: Writing a Malicious Package Installer'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 22：编写恶意包安装程序
- en: 'We could create a malicious package installer to gain persistence on a system
    in a few ways:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式创建一个恶意包安装程序，以便在系统上保持持久性：
- en: By compromising a central software repository, such as a local APT repository
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过入侵一个中央软件仓库，比如本地的 APT 仓库
- en: By compromising an account that has permissions to install packages
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过入侵一个具有安装包权限的帐户
- en: By sending a malicious package as part of a phishing campaign against system
    administrators
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将恶意包作为钓鱼活动的一部分发送给系统管理员
- en: The APT repository mentioned in the first scenario is a web server that contains
    a database of DEB packages. Consumers on the network, such as servers or end users,
    can use the APT repository to download packages onto their operating system and
    install them. You’ll find such setups in networks that aren’t directly connected
    to the internet or that are designed to install software from trusted sources
    only.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种场景中提到的 APT 仓库是一个包含 DEB 包数据库的 Web 服务器。网络中的消费者，如服务器或终端用户，可以使用 APT 仓库将包下载到他们的操作系统并进行安装。你会在那些未直接连接互联网或专为只从受信任源安装软件的网络中看到这种设置。
- en: 'Let’s create a DEB package containing malicious scripts for use in one of these
    scenarios. Specifically, we’ll use the *postinst* and *postrm* scripts to deploy
    and persist a reverse shell. Call your package *bksh*, for *backdoor shell*, and
    create a *control* file, as discussed in “Packaging Innocent Software” on [page
    253](#pg_253). Next, create *postinst* and *postrm* files in the *DEBIAN* directory
    and set their permissions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含恶意脚本的 DEB 包，供上述某些场景使用。具体来说，我们将使用 *postinst* 和 *postrm* 脚本来部署并保持一个反向
    shell。将你的包命名为 *bksh*，即 *后门 shell*，并创建一个 *control* 文件，如《包装无害软件》一节中所讨论的 [第253页](#pg_253)。接下来，在
    *DEBIAN* 目录中创建 *postinst* 和 *postrm* 文件，并设置它们的权限：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Your directory structure should look like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目录结构应该如下所示：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Populate the *postinst* script with a bash script that calls the reverse shell.
    For example, the script in [Listing 10-9](chapter10.xhtml#Lis10-9) will reach
    out to the Kali machine by using the system-wide crontab file */etc/crontab*:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *postinst* 脚本填充为一个调用反向 shell 的 bash 脚本。例如，[列表 10-9](chapter10.xhtml#Lis10-9)
    中的脚本将通过使用系统范围的 crontab 文件 */etc/crontab* 来连接 Kali 机器：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 10-9: A reverse shell callback using /etc/crontab'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-9：使用 /etc/crontab 进行反向 shell 回调
- en: When a user first installs the package, an entry will be written into */etc/crontab*.
    That user could be the root user, or any other user that can install packages
    by using a tool such as dpkg. To ensure that we write this entry only once, we
    use grep to check whether the string 4444 exists in the file before proceeding
    with the actual modification.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户第一次安装软件包时，一条记录将写入到 */etc/crontab*。这个用户可以是 root 用户，也可以是任何可以使用 dpkg 等工具安装软件包的用户。为了确保我们只写入一次此记录，我们使用
    grep 来检查文件中是否存在字符串 4444，然后再进行实际修改。
- en: 'Next, populate the *postrm* script with another reverse shell. This time, the
    cron job will belong to the user that executes the package removal and won’t be
    system-wide:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 *postrm* 脚本填充为另一个反向 Shell。这次，cron 作业将属于执行软件包移除的用户，而不会是系统级的：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This second script provides a fallback mechanism in cases when this package
    is removed from the system.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个脚本提供了一个回退机制，用于在此软件包从系统中移除时。
- en: You can develop additional fallback persistence mechanisms as an extension to
    the exercise. For example, try writing a small web shell to a file on the system
    if the system shows signs of running web server processes to common web directories,
    such as */var/www/html*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以作为练习的扩展，开发额外的回退持久化机制。例如，如果系统显示有运行 Web 服务器进程并指向常见的 Web 目录，如 */var/www/html*，可以尝试写一个小的
    Web Shell 文件到系统中。
- en: 'To test the package, build it, then start a Netcat reverse shell on your Kali
    machine. Copy the package to one of the lab machines, such as *p-jumpbox-01* (172.16.10.13),
    and install it by using the *root* user:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个软件包，先构建它，然后在你的 Kali 机器上启动一个 Netcat 反向 Shell。将软件包复制到其中一台实验室机器上，例如 *p-jumpbox-01*（172.16.10.13），并使用
    *root* 用户安装它：
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then verify that you can see the reverse shell cron job in */etc/crontab*:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后验证是否可以在 */etc/crontab* 中看到反向 Shell 的 cron 作业：
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: After about a minute, you should see the reverse shell connection to your Kali
    Netcat listener. To test *postrm*, remove the package from *p-jumpbox-01*, then
    check the *root* user’s crontab.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 大约一分钟后，你应该能看到反向 Shell 连接到你的 Kali Netcat 监听器。要测试 *postrm*，从 *p-jumpbox-01* 移除软件包，然后检查
    *root* 用户的 crontab。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned many ways of using bash to persist your access
    in the post-compromise stage. We introduced malicious logic to PAM modules, system
    profiles, text editors, and fake utilities. We also enabled dormant accounts and
    added rogue SSH keys, then packaged malicious software using the DEB format.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了许多使用 bash 在入侵后的阶段保持访问的方法。我们将恶意逻辑引入了 PAM 模块、系统配置文件、文本编辑器和伪造的工具。我们还启用了休眠账户并添加了恶意的
    SSH 密钥，然后使用 DEB 格式打包了恶意软件。
