- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Virtualization
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The word *virtual* can be vague in computing systems. It’s used primarily to
    indicate an intermediary that translates a complex or fragmented underlying layer
    to a simplified interface that can be used by multiple consumers. Consider an
    example that we’ve already seen, virtual memory, which allows multiple processes
    to access a large bank of memory as if each had its own insulated bank of memory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机系统中，*虚拟*这个词可能比较模糊。它主要用来表示一个中介，翻译复杂或碎片化的底层层次，提供一个可以被多个消费者使用的简化接口。考虑我们已经见过的一个例子——虚拟内存，它允许多个进程像拥有自己隔离的内存块一样访问一个大的内存池。
- en: 'That definition is still a bit daunting, so it might be better to explain the
    typical purpose of virtualization: creating isolated environments so that you
    can get multiple systems to run without clashing.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义还是有点吓人，所以更好的方法可能是解释虚拟化的典型用途：创建隔离的环境，以便你可以让多个系统运行而不会发生冲突。
- en: Because virtual machines are relatively easy to understand at a higher level,
    that’s where we’ll start our tour of virtualization. However, the discussion will
    remain on that higher level, aiming to explain some of the many terms you may
    encounter when working with virtual machines, without getting into the vast sea
    of implementation specifics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚拟机在更高层次上相对容易理解，我们将在虚拟化之旅中从这里开始。然而，讨论将仍然停留在更高的层次，旨在解释你在使用虚拟机时可能遇到的众多术语，而不深入实现的细节。
- en: We’ll go into a bit more technical detail on containers. They’re built with
    the technology you’ve already seen in this book, so you can see how these components
    can be combined. In addition, it’s relatively easy to interactively explore containers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更深入地讨论容器的技术细节。它们是使用本书中已经介绍的技术构建的，因此你可以看到这些组件是如何组合在一起的。此外，交互式探索容器相对容易。
- en: 17.1 Virtual Machines
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1 虚拟机
- en: Virtual machines are based on the same concept as virtual memory, except with
    *all* of the machine’s hardware instead of just memory. In this model, you create
    an entirely new machine (processor, memory, I/O interfaces, and so on) with the
    help of software, and run a whole operating system in it—including a kernel. This
    type of virtual machine is more specifically called a *system virtual machine*,
    and it’s been around for decades. For example, IBM mainframes traditionally use
    system virtual machines to create a multiuser environment; in turn, users get
    their own virtual machine running CMS, a simple single-user operating system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机基于与虚拟内存相同的概念，只不过是以*整个*机器的硬件为基础，而不仅仅是内存。在这种模型中，你可以借助软件创建一台全新的机器（处理器、内存、I/O接口等），并在其中运行一个完整的操作系统——包括内核。这样的虚拟机更具体地被称为*系统虚拟机*，它已经存在了几十年。例如，IBM的大型机通常使用系统虚拟机来创建多用户环境；反过来，用户会得到自己运行CMS的虚拟机，CMS是一个简单的单用户操作系统。
- en: You can construct a virtual machine entirely in software (usually called an
    *emulator*) or by utilizing the underlying hardware as much as possible, as is
    done in virtual memory. For our purposes in Linux, we’ll look at the latter kind
    due to its superior performance, but note that a number of popular emulators support
    old computer and gaming systems, such as the Commodore 64 and Atari 2600.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以完全通过软件构建一个虚拟机（通常称为*模拟器*），或者尽可能多地利用底层硬件，就像虚拟内存中所做的那样。就我们在Linux中的用途而言，我们将重点关注后一种方式，因为它具有更好的性能，但需要注意的是，许多流行的模拟器支持旧的计算机和游戏系统，如Commodore
    64和Atari 2600。
- en: The world of virtual machines is diverse, with a tremendous amount of terminology
    to wade through. Our exploration of virtual machines will focus primarily on how
    that terminology relates to what you might experience as a typical Linux user.
    We’ll also discuss some of the differences you might encounter in virtual hardware.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机的世界非常广泛，充满了大量的术语需要了解。我们对虚拟机的探索将主要集中在这些术语与典型的Linux用户可能遇到的情况之间的关系。我们还会讨论在虚拟硬件中你可能会遇到的一些差异。
- en: 17.1.1  Hypervisors
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.1  虚拟机监控程序
- en: Overseeing one or more virtual machines on a computer is a piece of software
    called a *hypervisor* or *virtual machine monitor (VMM)*, which works similarly
    to how an operating system manages processes. There are two types of hypervisors,
    and the way you use a virtual machine depends on the type. To most users, the
    *type 2 hypervisor* is the most familiar, because it runs on a normal operating
    system such as Linux. For example, VirtualBox is a type 2 hypervisor, and you
    can run it on your system without extensive modifications. You might have already
    used it while reading this book to test and explore different kinds of Linux systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上管理一个或多个虚拟机的软件叫做*虚拟机监控器*（*hypervisor*）或*虚拟机监视器 (VMM)*，它的工作方式类似于操作系统管理进程的方式。虚拟机监控器有两种类型，虚拟机的使用方式取决于类型。对于大多数用户来说，*第二类型虚拟机监控器*是最熟悉的，因为它运行在像Linux这样的普通操作系统上。例如，VirtualBox就是第二类型虚拟机监控器，你可以在系统上运行它而无需进行大量修改。在阅读本书时，你可能已经使用它来测试和探索不同的Linux系统。
- en: On the other hand, a *type 1 hypervisor* is more like its own operating system
    (especially the kernel), built specifically to run virtual machines quickly and
    efficiently. This kind of hypervisor might occasionally employ a conventional
    companion system such as Linux to help with management tasks. Even though you
    might never run one on your own hardware, you interact with type 1 hypervisors
    all the time. All cloud computing services run as virtual machines under type
    1 hypervisors such as Xen. When you access a website, you’re almost certainly
    hitting software running on such a virtual machine. Creating an instance of an
    operating system on a cloud service such as AWS is creating a virtual machine
    on a type 1 hypervisor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*第一类型虚拟机监控器*更像是一个操作系统（尤其是内核），专门构建来快速高效地运行虚拟机。这种虚拟机监控器可能偶尔会使用像Linux这样的传统伴随系统来帮助管理任务。即使你可能永远不会在自己的硬件上运行一个，你每天都会与第一类型虚拟机监控器交互。所有云计算服务都是在第一类型虚拟机监控器下运行虚拟机，比如Xen。当你访问一个网站时，几乎可以肯定你在访问一个运行在虚拟机上的软件。在AWS等云服务上创建操作系统实例就是在第一类型虚拟机监控器上创建虚拟机。
- en: In general, a virtual machine with its operating system is called a *guest*.
    The *host* is whatever runs the hypervisor. For type 2 hypervisors, the host is
    just your native system. For type 1 hypervisors, the host is the hypervisor itself,
    possibly combined with a specialized companion system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，带有操作系统的虚拟机称为*来宾*。*主机*是运行虚拟机监控器的任何设备。对于第二类型虚拟机监控器，主机就是你的本地系统。对于第一类型虚拟机监控器，主机就是虚拟机监控器本身，可能与一个专门的伴随系统结合使用。
- en: 17.1.2  Hardware in a Virtual Machine
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.2  虚拟机中的硬件
- en: In theory, it should be straightforward for the hypervisor to provide hardware
    interfaces for a guest system. For example, to provide a virtual disk device,
    you could create a big file somewhere on the host and provide access as a disk
    with standard device I/O emulation. This approach is a strict hardware virtual
    machine; however, it is inefficient. Making virtual machines practical for a variety
    of needs requires some changes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，虚拟机监控器为来宾系统提供硬件接口应该是直接的。例如，为了提供一个虚拟磁盘设备，你可以在主机的某个位置创建一个大文件，并通过标准的设备I/O仿真将其作为磁盘提供访问。这个方法是严格的硬件虚拟机，但效率较低。为了使虚拟机适用于各种需求，需要做一些改动。
- en: Most of the differences you might encounter between real and virtual hardware
    are a result of a bridging that allows guests to access host resources more directly.
    Bypassing virtual hardware between the host and guest is known as *paravirtualization*.
    Network interfaces and block devices are among the most likely to receive this
    treatment; for example, a */dev/xvd* device on a cloud computing instance is a
    Xen virtual disk, using a Linux kernel driver to talk directly to the hypervisor.
    Sometimes paravirtualization is used for the sake of convenience; for example,
    on a desktop-capable system such as VirtualBox, drivers are available to coordinate
    the mouse movement between the virtual machine window and the host environment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到的一些虚拟硬件与真实硬件之间的差异，是因为一种桥接技术使得来宾系统能够更直接地访问主机资源。绕过主机与来宾之间的虚拟硬件的方式被称为*准虚拟化*。网络接口和块设备是最有可能接受这种处理的；例如，在云计算实例上，*
    /dev/xvd *设备是一个Xen虚拟磁盘，使用Linux内核驱动程序直接与虚拟机监控器进行通信。有时候，为了方便，准虚拟化被使用；例如，在像VirtualBox这样的桌面系统上，驱动程序可以协调虚拟机窗口和主机环境之间的鼠标移动。
- en: Whatever the mechanism, the goal of virtualization is always to reduce the problem
    just enough so that the guest operating system can treat the virtual hardware
    as it would any other device. This ensures that all of the layers on top of the
    device function properly. For example, on a Linux guest system, you want a kernel
    to be able to access virtual disks as block devices so that you can partition
    and create filesystems on them with the usual tools.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 无论机制如何，虚拟化的目标始终是将问题简化到足够的程度，使得来宾操作系统可以像对待其他设备一样处理虚拟硬件。这确保了设备上方的所有层都能正常运行。例如，在
    Linux 来宾系统上，你希望内核能够将虚拟磁盘视为块设备，以便你可以使用常规工具对其进行分区并创建文件系统。
- en: Virtual Machine CPU Modes
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 虚拟机 CPU 模式
- en: Most of the details about how virtual machines work are beyond the scope of
    this book, but the CPU deserves a mention because we’ve already talked about the
    difference between kernel mode and user mode. The specific names of these modes
    vary depending on the processor (for example, the x86 processors use a system
    called *privilege rings*), but the idea is always the same. In kernel mode, the
    processor can do almost anything; in user mode, some instructions are not allowed,
    and memory access is limited.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机如何工作的大部分细节超出了本书的范围，但 CPU 需要提及，因为我们已经讨论过内核模式和用户模式的区别。这些模式的具体名称因处理器而异（例如，x86
    处理器使用一种叫做*特权环*的系统），但其核心思想始终相同。在内核模式下，处理器几乎可以执行任何操作；而在用户模式下，一些指令是不允许的，且内存访问受到限制。
- en: The first virtual machines for the x86 architecture ran in user mode. This presented
    a problem, because the kernel running inside the virtual machine wants to be in
    kernel mode. To counter this, the hypervisor can detect and react to (“trap”)
    any restricted instructions coming from a virtual machine. With a little work,
    the hypervisor emulates the restricted instructions, enabling virtual machines
    to run in kernel mode on an architecture not designed for it. Because most of
    the instructions a kernel executes aren’t restricted, those run normally, and
    the performance impact is fairly minimal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个运行在 x86 架构上的虚拟机是在用户模式下运行的。这就出现了一个问题，因为虚拟机中的内核希望处于内核模式。为了解决这个问题，虚拟机管理程序可以检测并响应（“陷阱”）来自虚拟机的任何受限指令。经过一些工作，虚拟机管理程序能够模拟这些受限指令，从而使虚拟机能够在不支持该模式的架构上以内核模式运行。因为大多数内核执行的指令并不受限，所以这些指令能正常运行，并且性能影响非常小。
- en: Soon after the introduction of this kind of hypervisor, processor manufacturers
    realized that there was a market for processors that could assist the hypervisor
    by eliminating the need for the instruction trap and emulation. Intel and AMD
    released these feature sets as VT-x and AMD-V, respectively, and most hypervisors
    now support them. In some cases, they are required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的虚拟机管理程序（hypervisor）引入后不久，处理器制造商意识到市场上存在可以通过消除指令陷阱和仿真需求来辅助虚拟机管理程序的处理器需求。英特尔和
    AMD 分别发布了这些功能集，称为 VT-x 和 AMD-V，大多数虚拟机管理程序现在都支持这些功能。在某些情况下，它们是必需的。
- en: 'If you want to learn more about virtual machines, start with Jim Smith and
    Ravi Nair’s *Virtual Machines: Versatile Platforms for Systems and Processes*
    (Elsevier, 2005). This also includes coverage of *process virtual machines*, such
    as the Java virtual machine (JVM), which we won’t discuss here.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解虚拟机，可以从 Jim Smith 和 Ravi Nair 的《*虚拟机：系统与进程的多功能平台*》（Elsevier，2005年）开始阅读。书中还涉及了*进程虚拟机*，例如
    Java 虚拟机（JVM），但我们在此不做讨论。
- en: 17.1.3  Common Uses of Virtual Machines
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.3  虚拟机的常见用途
- en: 'In the Linux world, virtual machine use often falls into one of a few categories:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 环境中，虚拟机的使用通常可以分为几种类型：
- en: Testing and trials There are many use cases for virtual machines when you need
    to try something outside of a normal or production operating environment. For
    example, when you’re developing production software, it’s essential to test software
    in a machine separate from the developer’s. Another use is to experiment with
    new software, such as a new distribution, in a safe and “disposable” environment.
    Virtual machines allow you to do this without having to purchase new hardware.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试和试验 当你需要在不同于正常或生产操作环境的情况下尝试某些东西时，虚拟机有很多用途。例如，在开发生产软件时，必须在与开发者的机器分开的虚拟机上测试软件。另一个用途是尝试新的软件，比如新的发行版，在一个安全且“可丢弃”的环境中。虚拟机让你可以做到这一点，而无需购买新的硬件。
- en: Application compatibility When you need to run something under an operating
    system that differs from your normal one, virtual machines are essential.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用兼容性 当你需要在与常规操作系统不同的操作系统下运行某些软件时，虚拟机是必不可少的。
- en: Servers and cloud services As mentioned earlier, all cloud services are built
    on virtual machine technology. If you need to run an internet server, such as
    a web server, the quickest way to do so is to pay a cloud provider for a virtual
    machine instance. Cloud providers also offer specialized servers, such as databases,
    which are just preconfigured software sets running on virtual machines.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器和云服务 如前所述，所有云服务都是建立在虚拟机技术之上的。如果你需要运行一个互联网服务器，比如Web服务器，最快的方式就是付费给云提供商租用一个虚拟机实例。云提供商还提供专用服务器，比如数据库，这些实际上就是运行在虚拟机上的预配置软件集。
- en: 17.1.4  Drawbacks of Virtual Machines
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.4  虚拟机的缺点
- en: 'For many years, virtual machines have been the go-to method of isolating and
    scaling services. Because you can create virtual machines through a few clicks
    or an API, it’s very convenient to create servers without having to install and
    maintain hardware. That said, some aspects remain troublesome in day-to-day operation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，虚拟机一直是隔离和扩展服务的首选方法。因为你可以通过几次点击或API创建虚拟机，所以无需安装和维护硬件，就能方便地创建服务器。尽管如此，日常操作中仍然有一些方面令人头疼：
- en: '*It can be cumbersome and time-consuming to install and/or configure the system
    and application*. Tools such as Ansible can automate this process, but it still
    takes a significant amount of time to bring up a system from scratch. If you’re
    using virtual machines to test software, you can expect this time to accumulate
    quickly.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装和/或配置系统和应用可能既繁琐又耗时*。像Ansible这样的工具可以自动化这个过程，但从零开始搭建一个系统仍然需要相当多的时间。如果你正在使用虚拟机来测试软件，你可以预见到这些时间会迅速积累。'
- en: '*Even when configured properly, virtual machines start and reboot relatively
    slowly*. There are a few ways around this, but you’re still booting a full Linux
    system.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*即使配置正确，虚拟机的启动和重启速度相对较慢*。虽然有一些方法可以解决这个问题，但你仍然需要启动一个完整的Linux系统。'
- en: '*You have to maintain a full Linux system, keeping current with updates and
    security on each virtual machine*. These systems have systemd and sshd, as well
    as any tools on which your application depends.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你需要维护一个完整的Linux系统，确保每台虚拟机上的更新和安全性*。这些系统有systemd和sshd，以及任何你的应用所依赖的工具。'
- en: '*Your application might have some conflicts with the standard software set
    on a virtual machine*. Some applications have strange dependencies, and they don’t
    always get along well with the software found on a production machine. In addition,
    dependencies like libraries can change with an upgrade in the machine, breaking
    things that once worked.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你的应用可能与虚拟机上的标准软件集存在一些冲突*。有些应用有奇怪的依赖关系，它们并不总是与生产环境中的软件兼容。此外，像库这样的依赖项在机器升级时可能会发生变化，导致以前能正常运行的功能出问题。'
- en: '*Isolating your services on separate virtual machines can be wasteful and costly*.
    The standard industry practice is to run no more than one application service
    on a system, which is robust and easier to maintain. In addition, some services
    can be further segmented; if you run multiple websites, it’s preferable to keep
    them on different servers. However, this is at odds with keeping costs down, especially
    when you’re using cloud services, which charge per virtual machine instance.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将你的服务隔离在单独的虚拟机上可能是浪费资源且成本高昂的*。行业的标准做法是每台系统上只运行一个应用服务，这样更健壮且更易于维护。此外，一些服务可以进一步细分；如果你运行多个网站，最好将它们放在不同的服务器上。然而，这与降低成本的目标相冲突，尤其是当你使用按虚拟机实例收费的云服务时。'
- en: These problems are really no different from the ones you’d encounter running
    services on real hardware, and they aren’t necessarily impediments in small operations.
    However, once you start running more services, they’ll become more noticeable,
    costing time and money. This is when you might consider containers for your services.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题实际上和你在真实硬件上运行服务时遇到的问题没有什么不同，对于小型操作来说，它们不一定是阻碍因素。然而，一旦你开始运行更多的服务，它们就会变得更加明显，消耗时间和金钱。这时候，你可能会考虑为你的服务使用容器。
- en: 17.2 Containers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2 容器
- en: Virtual machines are great for insulating an entire operating system and its
    set of running applications, but sometimes you need a lighter-weight alternative.
    Container technology is now a popular way to fulfill this need. Before we go into
    the details, let’s take a step back to see its evolution.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机非常适合隔离整个操作系统及其运行的应用程序，但有时你需要一个更轻量级的替代方案。容器技术现在是满足这一需求的流行方式。在我们深入细节之前，让我们回顾一下它的演变。
- en: The traditional way of operating computer networks was to run multiple services
    on the same physical machine; for example, a name server could also act as an
    email server and perform other tasks. However, you shouldn’t really trust any
    software, including servers, to be secure or stable. To enhance the security of
    the system and to keep services from interfering with one another, there are some
    basic ways to put up barriers around server daemons, especially when you don’t
    trust one of them very much.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的计算机网络操作方式是将多个服务运行在同一台物理机器上；例如，一个名称服务器也可以充当邮件服务器并执行其他任务。然而，你不应该完全信任任何软件，包括服务器，认为它们是安全或稳定的。为了增强系统的安全性并避免服务之间相互干扰，通常有一些基本的方法来为服务器守护进程设置隔离，特别是当你不太信任其中某些服务时。
- en: One method of service isolation is using the `chroot()` system call to change
    the root directory to something other than the actual system root. A program can
    change its root to something like */var/spool/my_service* and no longer be able
    to access anything outside that directory. In fact, there is a `chroot` program
    that allows you to run a program with a new root directory. This type of isolation
    is sometimes called a *chroot jail* because processes can’t (normally) escape
    it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一种服务隔离的方法是使用 `chroot()` 系统调用将根目录更改为实际系统根目录以外的路径。一个程序可以将根目录更改为类似 */var/spool/my_service*
    的路径，从而无法访问该目录外的任何内容。事实上，存在一个 `chroot` 程序，可以让你在新的根目录下运行程序。这种隔离方式有时被称为 *chroot 监狱*，因为进程通常无法逃脱。
- en: Another type of restriction is the resource limit (rlimit) feature of the kernel,
    which restricts how much CPU time a process can consume or how big its files can
    be.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种限制是内核的资源限制（rlimit）功能，它限制了一个进程可以消耗的 CPU 时间或文件的最大大小。
- en: 'These are the ideas that containers are built on: you’re altering the environment
    and restricting the resources with which processes run. Although there’s no single
    defining feature, a *container* can be loosely defined as a restricted runtime
    environment for a set of processes, the implication being that those processes
    can’t touch anything on the system outside that environment. In general, this
    is called *operating system–level virtualization*.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是容器构建的基本思想：你正在改变环境并限制进程运行时可用的资源。尽管没有单一的定义特征，*容器*可以宽泛地定义为一组进程的受限运行时环境，意味着这些进程无法接触到该环境外的系统资源。一般来说，这被称为*操作系统级虚拟化*。
- en: It’s important to keep in mind that a machine running one or more containers
    still has only one underlying Linux kernel. However, the processes inside a container
    can use the user-space environment from a Linux distribution different than the
    underlying system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，运行一个或多个容器的机器仍然只有一个底层的 Linux 内核。然而，容器内部的进程可以使用与底层系统不同的 Linux 发行版的用户空间环境。
- en: 'The restrictions in containers are built with a number of kernel features.
    Some of the important aspects of processes running in a container are:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的限制是通过许多内核功能构建的。运行在容器中的进程的一些重要方面包括：
- en: They have their own cgroups.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有自己的 cgroups。
- en: They have their own devices and filesystem.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有自己的设备和文件系统。
- en: They cannot see or interact with any other processes on the system.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能看到或与系统中的任何其他进程交互。
- en: They have their own network interfaces.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有自己的网络接口。
- en: Pulling all of those things together is a complicated task. It’s possible to
    alter everything manually, but it can be challenging; just getting a handle on
    the cgroups for a process is tricky. To help you along, many tools can perform
    the necessary subtasks of creating and managing effective containers. Two of the
    most popular are Docker and LXC. This chapter focuses on Docker, but we’ll also
    touch on LXC to see how it differs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些因素整合在一起是一项复杂的任务。虽然可以手动更改一切，但这可能会很具挑战性；仅仅掌握进程的 cgroups 就很棘手。为了帮助你，许多工具可以执行创建和管理有效容器所需的子任务。最受欢迎的两个工具是
    Docker 和 LXC。本章将重点介绍 Docker，但我们也会简要介绍 LXC，看看它与 Docker 的不同之处。
- en: 17.2.1  Docker, Podman, and Privileges
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.1  Docker、Podman 与权限
- en: To run the examples in this book, you need a container tool. The examples here
    are built with Docker, which you can normally install with a distribution package
    without any trouble.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本书中的示例，你需要一个容器工具。这里的示例是使用 Docker 构建的，通常你可以通过发行版的包管理器轻松安装 Docker。
- en: There is an alternative to Docker called Podman. The primary difference between
    the two tools is that Docker requires a server to be running when using containers,
    while Podman does not. This affects the way the two systems set up containers.
    Most Docker configurations require superuser privileges to access the kernel features
    used by its containers, and the dockerd daemon does the relevant work. In contrast,
    you can run Podman as a normal user, called *rootless* operation. When run this
    way, it uses different techniques to achieve isolation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种替代 Docker 的工具叫做 Podman。两者之间的主要区别是 Docker 在使用容器时需要运行一个服务器，而 Podman 不需要。这影响了两者设置容器的方式。大多数
    Docker 配置需要超级用户权限来访问容器所使用的内核功能，dockerd 守护进程负责执行相关工作。相比之下，你可以以普通用户身份运行 Podman，称为
    *无根* 操作。以这种方式运行时，它使用不同的技术来实现隔离。
- en: You can also run Podman as the superuser, causing it to switch over to some
    of the isolation techniques that Docker uses. Conversely, newer versions of dockerd
    support a rootless mode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以以超级用户身份运行 Podman，这样它会切换到 Docker 使用的一些隔离技术。相反，较新的 dockerd 版本支持无根模式。
- en: Fortunately, Podman is command line–compatible with Docker. This means you can
    substitute `podman` for `docker` in the examples here, and they’ll still work.
    However, there are differences in the implementations, especially when you’re
    running Podman in rootless mode, so those will be noted where applicable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Podman 与 Docker 在命令行上是兼容的。这意味着你可以在这里的示例中将 `podman` 替换为 `docker`，它们仍然会正常工作。然而，它们在实现上有所不同，特别是在你以无根模式运行
    Podman 时，所以在适用的地方会特别说明。
- en: 17.2.2  A Docker Example
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.2  Docker 示例
- en: The easiest way to familiarize yourself with containers is to get hands-on.
    The Docker example here illustrates the principal features that make containers
    work, but providing an in-depth user manual is beyond the scope of this book.
    You should have no trouble understanding the online documentation after reading
    this, and if you’re looking for an extensive guide, try Nigel Poulton’s *Docker
    Deep Dive* (author, 2016).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉容器的最简单方法是亲自操作。这里的 Docker 示例展示了容器工作的主要特性，但提供一本深入的用户手册超出了本书的范围。阅读完本书后，你应该能轻松理解在线文档，如果你在寻找一份详细的指南，可以尝试
    Nigel Poulton 的 *Docker Deep Dive*（作者，2016年）。
- en: First you need to create an *image*, which comprises the filesystem and a few
    other defining features for a container to run with. Your images will nearly always
    be based on prebuilt ones downloaded from a repository on the internet.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个 *镜像*，它包含文件系统以及一些其他定义容器运行所需特征。你的镜像几乎总是基于从互联网仓库下载的预构建镜像。
- en: 'Install Docker on your system (your distribution’s add-on package is probably
    fine), make a new directory somewhere, change to that directory, and create a
    file called *Dockerfile* containing these lines:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的系统上安装 Docker（你发行版的附加包应该没问题），然后在某个地方创建一个新目录，进入该目录，创建一个名为 *Dockerfile* 的文件，并将以下内容添加到文件中：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This configuration uses the lightweight Alpine distribution. The only change
    we’re making is adding the bash shell, which we’re doing not just for an added
    measure of interactive usability but also to create a unique image and see how
    that procedure works. It’s possible (and common) to use public images and make
    no changes to them whatsoever. In that case, you don’t need a Dockerfile.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置使用了轻量级的 Alpine 发行版。我们唯一的更改是添加 bash shell，这不仅是为了提高交互性，还为了创建一个独特的镜像并查看该过程是如何工作的。实际上，使用公共镜像并不做任何更改是可能的（也是常见的），在这种情况下，你不需要
    Dockerfile。
- en: 'Build the image with the following command, which reads the Dockerfile in the
    current directory and applies the identifier `hlw_test` to the image:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建镜像，它会读取当前目录中的 Dockerfile，并将标识符 `hlw_test` 应用到镜像上：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Be prepared for a lot of output. Don’t ignore it; reading through it this first
    time will help you understand how Docker works. Let’s break it up into the steps
    that correspond to the lines of the Dockerfile. The first task is to retrieve
    the latest version of the Alpine distribution container from the Docker registry:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好大量的输出信息。不要忽视它；第一次阅读这些输出将帮助你理解 Docker 的工作原理。让我们将其分解为与 Dockerfile 中的行对应的步骤。第一步是从
    Docker 注册表中获取最新版本的 Alpine 发行版容器：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice the heavy use of SHA256 digests and shorter identifiers. Get used to
    them; Docker needs to track many little pieces. In this step, Docker has created
    a new image with the identifier `f70734b6a266` for the basic Alpine distribution
    image. You can refer to that specific image later, but you probably won’t need
    to, because it’s not the final image. Docker will build more on top of it later.
    An image that isn’t intended to be a final product is called an *intermediate
    image*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到大量使用 SHA256 摘要和更短的标识符。习惯它们吧；Docker 需要跟踪许多小部分。在这一步中，Docker 创建了一个 ID 为`f70734b6a266`的新镜像，用于基本的
    Alpine 发行版镜像。你以后可以引用这个特定的镜像，但你可能不需要这么做，因为它不是最终镜像。Docker 会在其上继续构建。一个不是最终产品的镜像被称为*中间镜像*。
- en: 'The next part of our configuration is the bash shell package installation in
    Alpine. As you read the following, you’ll probably recognize output that results
    from the `apk add bash` command (shown in bold):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置的下一部分是在 Alpine 中安装 bash shell 包。阅读以下内容时，你可能会识别出由`apk add bash`命令生成的输出（以粗体显示）：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What’s not so obvious is *how* that’s happening. When you think about it, you
    probably aren’t running Alpine on your own machine here. So how can you run the
    `apk` command that belongs to Alpine already?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不太明显的是*它是如何发生的*。想一想，你可能并不是在自己的机器上运行 Alpine。那么你怎么能运行已经属于 Alpine 的`apk`命令呢？
- en: The key is the line that says `Running in 4f0fb4632b31`. You haven’t asked for
    a container yet, but Docker has set up a new container with the intermediate Alpine
    image from the previous step. Containers have identifiers as well; unfortunately,
    they look no different from image identifiers. To add to the confusion, Docker
    calls the temporary container an *intermediate container*, which differs from
    an intermediate image. Intermediate images stay around after a build; intermediate
    containers do not.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是那行显示 `Running in 4f0fb4632b31`。你还没有请求容器，但 Docker 已经用上一步的中间 Alpine 镜像设置了一个新的容器。容器也有标识符；不幸的是，它们看起来与镜像标识符没有区别。更混淆的是，Docker
    将临时容器称为*中间容器*，这与中间镜像不同。中间镜像在构建后会保留；中间容器则不会。
- en: After setting up the (temporary) container with ID `4f0fb4632b31`, Docker ran
    the `apk` command inside that container to install bash, and then saved the resulting
    changes to the filesystem into a new intermediate image with the ID `12ef4043c80a`.
    Notice that Docker also removes the container after completion.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了 ID 为`4f0fb4632b31`的（临时）容器后，Docker 在该容器内运行了`apk`命令以安装 bash，然后将生成的文件系统更改保存到
    ID 为`12ef4043c80a`的新中间镜像中。注意，Docker 完成后也会删除该容器。
- en: 'Finally, Docker makes the final changes required to run a bash shell when starting
    a container from the new image:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Docker 在从新镜像启动容器时做出了运行 bash shell 所需的最终更改：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, you now have a final image with the ID `1b64f94e5a54`, but
    because you tagged it (in two separate steps), you can also refer to it as `hlw_test`
    or `hlw_test:latest`. Run `docker images` to verify that your image and the Alpine
    image are present:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你现在有了一个 ID 为`1b64f94e5a54`的最终镜像，但因为你标记了它（分两步进行），你也可以称它为`hlw_test`或`hlw_test:latest`。运行`docker
    images`来验证你的镜像和 Alpine 镜像是否存在：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Running Docker Containers
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行 Docker 容器
- en: 'You’re now ready to start a container. There are two basic ways to run something
    in a container with Docker: you can either create the container and then run something
    inside it (in two separate steps), or you can simply create and run in one step.
    Let’s jump right into it and start one with the image that you just built:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你准备好启动一个容器了。使用 Docker 在容器中运行某些东西有两种基本方法：你可以先创建容器，然后在其中运行某些东西（分两步进行），或者你可以直接一步创建并运行。让我们直接开始，使用你刚刚构建的镜像启动一个容器：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should get a bash shell prompt where you can run commands in the container.
    That shell will run as the root user.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到一个 bash shell 提示符，在那里你可以在容器中运行命令。该 shell 将以 root 用户身份运行。
- en: 'If you’re the curious type, you’ll probably want to take a look around the
    container. Run some commands, such as `mount` and `ps`, and explore the filesystem
    in general. You’ll quickly notice that although most things look like a typical
    Linux system, others do not. For example, if you run a complete process listing,
    you’ll get just two entries:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是好奇型的人，可能会想看看容器内部。运行一些命令，如`mount`和`ps`，并大致探索一下文件系统。你会很快注意到，虽然大部分内容看起来像典型的
    Linux 系统，但也有一些不同。例如，如果你运行完整的进程列表，你只会看到两个条目：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Somehow, in the container, the shell is process ID 1 (remember, on a normal
    system, this is init), and nothing else is running except for the process listing
    that you’re executing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中，shell 是进程 ID 1（记住，在普通系统中，这是 init），而除了你正在执行的进程列表，其他任何东西都没有运行。
- en: 'At this point, it’s important to remember that these processes are simply ones
    that you can see on your normal (host) system. If you open another shell window
    on your host system, you can find a container process in a listing, though it
    will require a little searching. It should look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很重要，需要记住这些进程仅仅是你在正常（主机）系统上能看到的进程。如果你在主机系统上打开另一个 shell 窗口，你可以在进程列表中找到一个容器进程，尽管这需要稍微查找一下。它应该看起来像这样：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is our first encounter with one of the kernel features used for containers:
    Linux kernel *namespaces* specifically for process IDs. A process can create a
    whole new set of process IDs for itself and its children, starting at PID 1, and
    then they are able to see only those.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次遇到容器使用的内核特性之一：专门为进程 ID 提供的 Linux 内核*命名空间*。一个进程可以为它自己及其子进程创建一整套新的进程 ID，从
    PID 1 开始，然后它们只能看到这些进程 ID。
- en: Overlay Filesystems
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 覆盖文件系统
- en: 'Next, explore the filesystem in your container. You’ll find it’s somewhat minimal;
    this is because it’s based on the Alpine distribution. We’re using Alpine not
    just because it’s small, but also because it’s likely to be different from what
    you’re used to. However, when you take a look at the way the root filesystem is
    mounted, you’ll see it’s very different from a normal device-based mount:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，探索容器中的文件系统。你会发现它相当简约；这是因为它基于 Alpine 发行版。我们使用 Alpine 不仅是因为它小，还因为它可能与你习惯的系统不同。然而，当你查看根文件系统的挂载方式时，你会发现它与普通的基于设备的挂载方式非常不同：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is an *overlay filesystem*, a kernel feature that allows you to create
    a filesystem by combining existing directories as layers, with changes stored
    in a single spot. If you look on your host system, you’ll see it (and have access
    to the component directories), and you’ll also find where Docker attached the
    original mount.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*覆盖文件系统*，一个内核特性，允许通过将现有目录作为层结合起来创建一个文件系统，同时将更改存储在一个位置。如果你查看你的主机系统，你将看到它（并且可以访问组件目录），你还会发现
    Docker 在哪里附加了原始挂载。
- en: In the mount output, you’ll see the `lowerdir`, `upperdir`, and `workdir` directory
    parameters. The lower directory is actually a colon-separated series of directories,
    and if you look them up on your host system, you’ll find that the last one 1 is
    the base Alpine distribution that was set up in the first step of the image build
    (just look inside; you’ll see the distribution root directory). If you follow
    the two preceding directories, you’ll see they correspond to the other two build
    steps. Therefore, these directories “stack” on top of each other in order from
    right to left.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载输出中，你会看到 `lowerdir`、`upperdir` 和 `workdir` 目录参数。下级目录实际上是一个由冒号分隔的目录序列，如果你在主机系统上查找它们，你会发现最后一个是第一次构建镜像时设置的基本
    Alpine 发行版（只需查看其中，你会看到发行版的根目录）。如果你跟随前两个目录，你会看到它们对应的是另外两个构建步骤。因此，这些目录从右到左依次“堆叠”在一起。
- en: The upper directory goes on top of those, and it’s also where any changes to
    the mounted filesystem appear. It doesn’t have to be empty when you mount it,
    but for containers, it doesn’t make much sense to put anything there to start.
    The work directory is a place for the filesystem driver to do its work before
    writing changes to the upper directory, and it must be empty upon mount.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上级目录位于这些目录之上，且任何对挂载文件系统的更改都会出现在这里。挂载时，它不必为空，但对于容器来说，一开始把任何东西放在那里没有太大意义。工作目录是文件系统驱动程序在将更改写入上级目录之前进行操作的地方，且挂载时必须为空。
- en: As you can imagine, container images with many build steps have quite a few
    layers. This is sometimes a problem, and there are various strategies to minimize
    the number of layers, such as combining `RUN` commands and multistage builds.
    We won’t go into details about those here.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想，拥有许多构建步骤的容器镜像会有相当多的层。这有时会成为一个问题，针对这一点，有多种策略可以最小化层数，比如合并`RUN`命令和多阶段构建。我们在这里不深入讨论这些细节。
- en: Networking
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络
- en: Although you can choose to have a container run in the same network as the host
    machine, you normally want some kind of isolation in the network stack for safety.
    There are several ways to achieve this in Docker, but the default (and most common)
    is called a bridge network, using another kind of namespace—the network namespace
    (netns). Before running anything, Docker creates a new network interface (usually
    *docker0*) on the host system, typically assigned to a private network such as
    172.17.0.0/16, so the interface in this case would be assigned to 172.17.0.1\.
    This network is for communication between the host machine and its containers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以选择让容器在与主机相同的网络中运行，但通常你希望在网络堆栈中实现某种隔离以确保安全。Docker 有几种方式可以实现这一点，但默认（也是最常见的）是桥接网络，使用另一种命名空间——网络命名空间（netns）。在运行任何内容之前，Docker
    会在主机系统上创建一个新的网络接口（通常是 *docker0*），通常分配给一个私有网络，如 172.17.0.0/16，因此在这种情况下，接口将被分配给
    172.17.0.1。这个网络用于主机和其容器之间的通信。
- en: Then, when creating a container, Docker creates a new network namespace, which
    is almost completely empty. At first, the new namespace (which will be the one
    in the container) contains only a new, private loopback (*lo*) interface. To prepare
    the namespace for actual use, Docker creates a *virtual interface* on the host,
    which simulates a link between two actual network interfaces (each with its own
    device) and places one of those devices in the new namespace. With a network configuration
    using an address on the Docker network (172.17.0.0/16 in our case) on the device
    in the new namespace, processes can send packets on that network and be received
    on the host. This can be confusing, because different interfaces in different
    namespaces can have the same name (for example, the container’s can be *eth0*,
    as well as the host machine).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在创建容器时，Docker 会创建一个新的网络命名空间，该命名空间几乎是完全空的。最初，新的命名空间（即容器中的命名空间）仅包含一个新的私有回环
    (*lo*) 接口。为了使命名空间准备好实际使用，Docker 会在主机上创建一个 *虚拟接口*，它模拟了两个实际网络接口之间的连接（每个接口都有自己的设备），并将其中一个设备放置到新的命名空间中。在该命名空间中的设备上配置使用
    Docker 网络（在我们的例子中是 172.17.0.0/16）上的地址，进程就可以在该网络上发送数据包，并在主机上接收。这可能会让人困惑，因为不同命名空间中的不同接口可以有相同的名称（例如，容器的接口可以是
    *eth0*，主机机器的接口也是如此）。
- en: Because this uses a private network (and a network administrator probably wouldn’t
    want to route anything to and from these containers blindly), if left this way,
    the container processes using that namespace couldn’t reach the outside world.
    To make it possible to reach outside hosts, the Docker network on the host configures
    NAT.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这使用的是私有网络（而且网络管理员可能不希望盲目地将数据路由到这些容器中或从容器中路由），如果保持这种方式，使用该命名空间的容器进程将无法访问外部世界。为了能够访问外部主机，主机上的
    Docker 网络配置了 NAT。
- en: '[Figure 17-1](#figure17-1) shows a typical setup. It includes the physical
    layer with the interfaces, as well as the internet layer of the Docker subnet
    and the NAT linking this subnet to the rest of the host machine and its outside
    connections.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-1](#figure17-1) 显示了一个典型的设置。它包括带有接口的物理层，以及 Docker 子网的互联网层和将该子网与主机的其余部分及其外部连接相连的
    NAT。'
- en: '![f17001](image_fi/500402c17/f17001.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![f17001](image_fi/500402c17/f17001.png)'
- en: 'Figure 17-1: Bridge network in Docker. The thick link represents the virtual
    interface pair bond.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-1：Docker 中的桥接网络。粗线表示虚拟接口对的绑定。
- en: Rootless operation networking in Podman is different because setting up virtual
    interfaces requires superuser access. Podman still uses a new network namespace,
    but it needs an interface that can be set up to operate in user space. This is
    a TAP interface (usually at *tap0*), and in conjunction with a forwarding daemon
    called slirp4netns, container processes can reach the outside world. This is less
    capable; for example, containers cannot connect to one another.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Podman 中，rootless 操作的网络不同，因为设置虚拟接口需要超级用户权限。Podman 仍然使用新的网络命名空间，但它需要一个可以在用户空间操作的接口。这是一个
    TAP 接口（通常是 *tap0*），并配合一个名为 slirp4netns 的转发守护进程，容器进程可以访问外部世界。这种方式能力较弱；例如，容器之间无法相互连接。
- en: There’s a lot more to networking, including how to expose ports in the container’s
    network stack for external services to use, but the network topology is the most
    important thing to understand.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 网络还有很多内容，包括如何暴露容器网络堆栈中的端口供外部服务使用，但网络拓扑是最重要的理解内容。
- en: Docker Operation
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker 操作
- en: At this point, we could continue with a discussion of the various other kinds
    of isolation and restrictions that Docker enables, but it would take a long time
    and you probably get the point by now. Containers don’t come from one particular
    feature, but rather a collection of them. A consequence is that Docker must keep
    track of all of the things we do when creating a container and must also be able
    to clean them up.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以继续讨论 Docker 启用的各种隔离和限制，但这会花费很长时间，你大概现在已经明白了。容器并不是由单一功能产生的，而是由多个功能的集合。其结果是，Docker
    必须追踪我们创建容器时所做的一切，并且还必须能够清理它们。
- en: 'Docker defines a container as “running” as long as it has a process running.
    You can show the currently running containers with `docker ps`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 将容器定义为“运行中”，只要它有一个进程在运行。你可以使用 `docker ps` 显示当前运行的容器：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As soon as all of its processes terminate, Docker puts them in an exit state,
    but it still keeps the containers (unless you start with the `--rm` option). This
    includes the changes made to the filesystem. You can easily access the filesystem
    with `docker export`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有进程终止，Docker 会将容器置于退出状态，但它仍然保留容器（除非你使用 `--rm` 选项启动）。这包括对文件系统所做的更改。你可以使用 `docker
    export` 容易地访问文件系统。
- en: You need to be aware of this, because `docker ps` doesn’t show exited containers
    by default; you have to use the `-a` option to see everything. It’s really easy
    to accumulate a large pile of exited containers, and if the application running
    in the container creates a lot of data, you can run out of disk space and not
    know why. Use `docker rm` to remove a terminated container.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要注意这一点，因为默认情况下，`docker ps` 不会显示已退出的容器；你必须使用 `-a` 选项来查看所有容器。很容易积累大量已退出的容器，如果容器中运行的应用创建了大量数据，你可能会耗尽磁盘空间而不知道原因。使用
    `docker rm` 删除已终止的容器。
- en: 'This also applies to old images. Developing an image tends to be a repetitive
    process, and when you tag an image with the same tag as an existing image, Docker
    doesn’t remove the original image. The old image simply loses that tag. If you
    run `docker images` to show all the images on your system, you can see all of
    the images. Here’s an example showing a previous version of an image without a
    tag:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于旧镜像。开发镜像通常是一个重复的过程，当你用与现有镜像相同的标签来标记镜像时，Docker 不会删除原始镜像。旧镜像只是失去了那个标签。如果你运行
    `docker images` 来显示系统上的所有镜像，你可以看到所有镜像。下面是一个例子，显示了没有标签的镜像的先前版本：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Use `docker rmi` to remove an image. This also removes any unnecessary intermediate
    images that the image builds on. If you don’t remove images, they can add up over
    time. Depending on what’s in the images and how they are built, this can consume
    a significant amount of storage space on your system.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker rmi` 来删除一个镜像。这也会删除该镜像所依赖的任何不必要的中间镜像。如果你不删除镜像，它们会随着时间的推移逐渐堆积。根据镜像中的内容以及它们的构建方式，这可能会占用系统大量的存储空间。
- en: In general, Docker does a lot of meticulous versioning and checkpointing. This
    layer of management reflects a particular philosophy compared to tools like LXC,
    which you’ll see soon.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Docker 做了大量细致的版本控制和检查点管理。这种管理方式与像 LXC 这样的工具相比，反映了一种独特的哲学，你很快就会见到。
- en: Docker Service Process Models
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker 服务进程模型
- en: One potentially confusing aspect of Docker containers is the lifecycle of the
    processes inside them. Before a process can completely terminate, its parent is
    supposed to collect (“reap”) its exit code with the `wait()` system call. However,
    in a container, there are some situations in which dead processes can remain because
    their parents don’t know how to react. Along with the way that many images are
    configured, this might lead you to conclude that you’re not supposed to run multiple
    processes or services inside a Docker container. This is not correct.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器的一个可能让人困惑的方面是容器内进程的生命周期。在一个进程完全终止之前，它的父进程应该通过 `wait()` 系统调用来收集（“回收”）它的退出码。然而，在容器中，存在一些情况下死掉的进程仍然存在，因为它们的父进程不知道如何处理。结合许多镜像的配置方式，这可能会让你得出结论：你不应该在
    Docker 容器内运行多个进程或服务。这个结论是错误的。
- en: You can have many processes in a container. The shell we ran in our example
    starts a new child process when you run a command. The only thing that really
    matters is that when you have child processes, the parent cleans up upon their
    exit. Most parents do this, but in certain circumstances, you might run into a
    situation where one does not, especially if it doesn’t know that it has children.
    This can happen when there are multiple levels of process spawning, and the PID
    1 inside the container ends up being the parent of a child that it doesn’t know
    about.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个容器内运行多个进程。我们在示例中运行的shell在你执行命令时会启动一个新的子进程。真正重要的是，当你有子进程时，父进程会在它们退出时进行清理。大多数父进程都会做到这一点，但在某些情况下，你可能会遇到某些父进程做不到这一点，尤其是当它不知道自己有子进程时。这种情况可能发生在多级进程生成的情况下，容器内的PID
    1最终会成为一个它不知道的子进程的父进程。
- en: To remedy this, if you have a simple single-minded service that just spawns
    some processes and seems to leave lingering processes even when a container is
    supposed to terminate, you can add the `--init` option to `docker run`. This creates
    a very simple init process to run as PID 1 in the container and act as a parent
    that knows what to do when a child process terminates.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，如果你有一个简单的单一服务，它仅仅是启动一些进程，并且即使容器应该终止时，仍然会留下残留的进程，你可以在`docker run`命令中添加`--init`选项。这会创建一个非常简单的初始化进程，在容器内作为PID
    1运行，并作为父进程，知道在子进程终止时该做什么。
- en: However, if you’re running multiple services or tasks inside a container (such
    as multiple workers for some job server), instead of starting them with a script,
    you might consider using a process management daemon such as Supervisor (supervisord)
    to start and monitor them. This not only provides the necessary system functionality,
    but also gives you more control over service processes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在一个容器内运行多个服务或任务（例如某个工作服务器的多个工作进程），你可能会考虑使用像Supervisor（supervisord）这样的进程管理守护进程来启动和监控它们，而不是通过脚本启动它们。这样不仅提供了必要的系统功能，还能让你对服务进程有更多的控制。
- en: On that note, if you’re thinking about this kind of model for a container, there’s
    a different option that you might consider, and it doesn’t involve Docker.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点，如果你正在考虑这种模型的容器，有一个不同的选项你可以考虑，它不涉及Docker。
- en: 17.2.3  LXC
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.3  LXC
- en: Our discussion has revolved around Docker not only because it’s the most popular
    system for building container images, but also because it makes it very easy to
    get started and jump into the layers of isolation that containers normally provide.
    However, there are other packages for creating containers, and they take different
    approaches. Of these, LXC is one of the oldest. In fact, the first versions of
    Docker were built on LXC. If you understood the discussion of how Docker does
    its work, you won’t have trouble with LXC technical concepts, so we won’t go over
    any examples. Instead, we’ll just explore some of the practical differences.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的讨论围绕着Docker展开，不仅因为它是构建容器镜像最流行的系统，还因为它让你非常容易开始并跳入容器通常提供的隔离层次。然而，还有其他创建容器的软件包，它们采取了不同的方式。其中，LXC是最古老的之一。实际上，Docker的第一个版本就是基于LXC构建的。如果你理解了Docker是如何工作的，那么理解LXC的技术概念就不成问题了，因此我们不会讲解具体的例子，而是会探索一些实际的差异。
- en: The term *LXC* is sometimes used to refer to the set of kernel features that
    make containers possible, but most people use it to refer specifically to a library
    and package containing a number of utilities for creating and manipulating Linux
    containers. Unlike Docker, LXC involves a fair amount of manual setup. For example,
    you have to create your own container network interface, and you need to provide
    user ID mappings.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*LXC*这个术语有时用于指代使容器成为可能的一组内核功能，但大多数人用它来特指一个包含用于创建和操作Linux容器的多个工具的库和软件包。与Docker不同，LXC涉及相当多的手动设置。例如，你必须创建自己的容器网络接口，并且需要提供用户ID映射。'
- en: Originally, LXC was intended to be as much of an entire Linux system as possible
    inside the container—init and all. After installing a special version of a distribution,
    you could install everything you needed for whatever you were running inside the
    container. That part isn’t too different from what you’ve seen with Docker, but
    there is more setup to do; with Docker, you just download a bunch of files and
    you’re ready to go.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，LXC的目的是尽可能在容器内实现一个完整的Linux系统——包括初始化（init）。在安装了一个特殊版本的发行版后，你可以安装运行容器内部所需的一切。这部分和你在Docker中看到的没有太大区别，但需要做更多的设置；而在Docker中，你只需要下载一堆文件就能开始使用。
- en: Therefore, you might find LXC more flexible in adapting to different needs.
    For example, by default, LXC doesn’t use the overlay filesystem that you saw with
    Docker, although you can add one. Because LXC is built on a C API, you can use
    this granularity in your own software application if necessary.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能会发现LXC在适应不同需求时更加灵活。例如，默认情况下，LXC不会使用你在Docker中看到的覆盖文件系统，尽管你可以添加一个。因为LXC是基于C
    API构建的，所以如果需要，你可以在自己的软件应用程序中使用这种粒度。
- en: An accompanying management package called LXD can help you work through some
    of LXC’s finer, manual points (such as network creation and image management)
    and offers a REST API that you can use to access LXC instead of the C API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为LXD的管理工具包可以帮助你处理LXC的一些更细致的手动操作（例如网络创建和镜像管理），并提供一个REST API，您可以使用它来访问LXC，而不是使用C
    API。
- en: 17.2.4  Kubernetes
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.4  Kubernetes
- en: 'Speaking of management, containers have become popular for many kinds of web
    servers, because you can start a bunch of containers from a single image across
    multiple machines, providing excellent redundancy. Unfortunately, this can be
    difficult to manage. You need to perform tasks such as the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 说到管理，容器已成为许多类型的Web服务器的流行选择，因为你可以从单个镜像在多台机器上启动一堆容器，从而提供出色的冗余。不幸的是，这可能很难管理。你需要执行如下任务：
- en: Track which machines are able to run containers.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪哪些机器能够运行容器。
- en: Start, monitor, and restart containers on those machines.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动、监控并重启这些机器上的容器。
- en: Configure container startup.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置容器启动。
- en: Configure the container networking as required.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要配置容器网络。
- en: Load new versions of container images and update all running containers gracefully.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载新的容器镜像版本，并优雅地更新所有正在运行的容器。
- en: That isn’t a complete list, nor does it properly convey the complexity of each
    task. Software was begging to be developed for it, and among the solutions that
    appeared, Google’s Kubernetes has become dominant. Perhaps one of the largest
    contributing factors for this is its ability to run Docker container images.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完整的列表，也没有准确传达每个任务的复杂性。软件早已开始为此开发，而在出现的解决方案中，Google的Kubernetes已经成为主流。或许其中一个最大的推动因素是它能够运行Docker容器镜像。
- en: Kubernetes has two basic sides, much like any client-server application. The
    server involves the machine(s) available to run containers, and the client is
    primarily a set of command-line utilities that launch and manipulate sets of containers.
    The configuration files for containers (and the groups they form) can be extensive,
    and you’ll quickly find that most of the work involved on the client side is creating
    the appropriate configuration.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes有两个基本方面，就像任何客户端-服务器应用程序一样。服务器涉及可用于运行容器的机器，客户端主要是一组命令行工具，用于启动和操作容器集合。容器（以及它们组成的组）的配置文件可能非常庞大，你很快会发现大部分客户端工作是创建适当的配置。
- en: You can explore the configuration on your own. If you don’t want to deal with
    setting up the servers yourself, use the Minikube tool to install a virtual machine
    running a Kubernetes cluster on your own machine.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自行探索配置。如果你不想自己设置服务器，可以使用Minikube工具在你的机器上安装一个运行Kubernetes集群的虚拟机。
- en: 17.2.5  Pitfalls of Containers
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.5  容器的陷阱
- en: If you think about how a service like Kubernetes works, you’ll also realize
    that a system utilizing containers is not without its costs. At minimum, you still
    need one or more machines on which to run your containers, and this has to be
    a full-fledged Linux machine, whether it’s on real hardware or a virtual machine.
    There’s still a maintenance cost here, although it might be simpler to maintain
    this core infrastructure than a configuration that requires many custom software
    installations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一下像Kubernetes这样的服务是如何工作的，你也会意识到，利用容器的系统并非没有其成本。至少，你仍然需要一台或多台机器来运行容器，这些机器必须是完整的Linux机器，无论是在真实硬件上还是虚拟机上。尽管维持这一核心基础设施可能比需要许多自定义软件安装的配置更简单，但仍然存在维护成本。
- en: That cost can take several forms. If you choose to administer your own infrastructure,
    that’s a significant investment of time, and still has hardware, hosting, and
    maintenance costs. If you instead opt to use a container service like a Kubernetes
    cluster, you’ll be paying the monetary cost of having someone else do the work
    for you.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成本可以有多种形式。如果你选择自己管理基础设施，那是一项巨大的时间投资，仍然涉及硬件、托管和维护成本。如果你选择使用像Kubernetes集群这样的容器服务，你将支付将工作交给别人做的货币成本。
- en: 'When thinking of the containers themselves, keep in mind the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑容器本身时，请记住以下几点：
- en: '*Containers can be wasteful in terms of storage*. In order for any application
    to function inside a container, the container must include all the necessary support
    of a Linux operating system, such as shared libraries. This can become quite large,
    especially if you don’t pay particular attention to the base distribution that
    you choose for your containers. Then, consider your application itself: how big
    is it? This situation is mitigated somewhat when you’re using an overlay filesystem
    with several copies of the same container, because they share the same base files.
    However, if your application creates a lot of runtime data, the upper layers of
    all of those overlays can grow large.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器在存储方面可能是浪费的*。为了使应用程序能够在容器内运行，容器必须包含 Linux 操作系统所需的所有支持，如共享库。如果你没有特别注意你为容器选择的基础发行版，这可能会变得非常庞大。然后，考虑你的应用程序本身：它有多大？当你使用叠加文件系统并且多个容器共享同一个基础文件时，这种情况会有所缓解，因为它们共享相同的基础文件。然而，如果你的应用程序生成大量运行时数据，那么这些叠加层的上层可能会变得很大。'
- en: '*You still have to think about other system resources, such as CPU time*. You
    can configure limits on how much containers can consume, but you’re still constrained
    by how much the underlying system can handle. There’s still a kernel and block
    devices. If you overload stuff, then your containers, the system underneath, or
    both will suffer.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你仍然需要考虑其他系统资源，如 CPU 时间*。你可以配置容器的资源限制，但你仍然受到底层系统能承载多少的限制。系统仍然有内核和块设备。如果你超载了系统，那么你的容器、底层系统或两者都会受到影响。'
- en: '*You might need to think differently about where you store your data*. In container
    systems such as Docker that use overlay filesystems, the changes made to the filesystem
    during runtime are thrown away after the processes terminate. In many applications,
    all of the user data goes into a database, and then that problem is reduced to
    database administration. But what about your logs? Those are necessary for a well-functioning
    server application, and you still need a way to store them. A separate log service
    is a must for any substantial scale of production.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你可能需要重新思考数据存储的位置*。在像 Docker 这样的容器系统中，使用的是叠加文件系统，运行时对文件系统的更改在进程终止后会被丢弃。在许多应用程序中，所有用户数据都会存储在数据库中，然后这个问题就变成了数据库管理。但是，日志怎么办呢？这些对于良好运作的服务器应用程序是必不可少的，你仍然需要一种方法来存储它们。对于任何大规模的生产环境，必须有一个独立的日志服务。'
- en: '*Most container tools and operation models are geared toward web servers*.
    If you’re running a typical web server, you’ll find a great deal of support and
    information about running web servers in containers. Kubernetes, in particular,
    has a lot of safety features for preventing runaway server code. This can be an
    advantage, because it compensates for how (frankly) poorly written most web applications
    are. However, when you’re trying to run another kind of service, it can sometimes
    feel like you’re trying to drive a square peg into a round hole.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大多数容器工具和操作模型都是针对 Web 服务器设计的*。如果你正在运行一个典型的 Web 服务器，你会发现关于在容器中运行 Web 服务器的大量支持和信息。特别是
    Kubernetes，它有许多安全功能可以防止服务器代码失控。这可能是一个优势，因为它弥补了大多数 Web 应用程序（坦率地说）写得很糟糕的问题。然而，当你尝试运行其他类型的服务时，有时会感觉像是在试图将方钉插入圆孔。'
- en: '*Careless container builds can lead to bloat, configuration problems, and malfunction*.
    The fact that you’re creating an isolated environment doesn’t shield you from
    making mistakes in that environment. You might not have to worry so much about
    the intricacies of systemd, but plenty of other things still can go wrong. When
    problems arise in any kind of system, inexperienced users tend to add things in
    an attempt to make the problem go away, often haphazardly. This can continue (often
    blindly) until at last there’s a somewhat functional system—with many additional
    issues. You need to understand the changes you make.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*粗心的容器构建可能导致膨胀、配置问题和故障*。你创建了一个隔离的环境，但这并不能避免你在该环境中犯错。你可能不必太担心 systemd 的复杂性，但其他许多问题仍然可能发生。当任何系统出现问题时，缺乏经验的用户往往会加入一些东西，试图让问题消失，往往是草率地进行。这种情况可能会持续（常常是盲目地）直到最终有一个相对正常运行的系统——但问题变得更多了。你需要理解你所做的更改。'
- en: '*Versioning can be problematic*. We used the `latest` tag for the examples
    in this book. This is supposed to be the latest (stable) release of a container,
    but it also means that when you build a container based on the latest release
    of a distribution or package, something underneath can change and break your application.
    One standard practice is to use a specific version tag of a base container.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*版本控制可能会出现问题*。我们在本书中的示例使用了 `latest` 标签。这应该是容器的最新（稳定）版本，但这也意味着，当你基于最新版本的发行版或软件包构建容器时，下面的某些东西可能会发生变化，从而破坏你的应用程序。一种标准做法是使用基础容器的特定版本标签。'
- en: '*Trust can be an issue*. This applies particularly to images built with Docker.
    When you base your containers on those in the Docker image repository, you’re
    placing trust in an additional layer of management that they haven’t been altered
    to introduce even more security problems than usual, and that they’ll be there
    when you need them. This contrasts with LXC, where you’re encouraged to build
    your own to a certain degree.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信任可能是一个问题*。这尤其适用于使用 Docker 构建的镜像。当你将容器基于 Docker 镜像库中的容器时，你就是在将信任交给一个额外的管理层，这些容器没有被修改成引入比通常更多的安全问题，并且当你需要时，它们会在那里。这与
    LXC 相对立，后者鼓励你在一定程度上自己构建容器。'
- en: When considering these issues, you might think that containers have a lot of
    disadvantages compared to other ways of managing system environments. However,
    that’s not the case. No matter what approach you choose, these problems are present
    in some degree and form—and some of them are easier to manage in containers. Just
    remember that containers won’t solve every problem. For example, if your application
    takes a long time to start on a normal system (after booting), it will also start
    slowly in a container.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这些问题时，你可能会认为与管理系统环境的其他方式相比，容器有很多缺点。然而，事实并非如此。无论你选择哪种方式，这些问题都会以某种程度和形式存在——而且其中一些问题在容器中更容易管理。只需记住，容器并不能解决所有问题。例如，如果你的应用程序在正常系统上启动缓慢（启动后），它在容器中也会启动得很慢。
- en: 17.3 Runtime-Based Virtualization
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.3 基于运行时的虚拟化
- en: A final kind of virtualization to mention is based on the type of environment
    used to develop an application. This differs from the system virtual machines
    and containers that we’ve seen so far, because it doesn’t use the idea of placing
    applications onto different machines. Instead, it’s a separation that applies
    only to a particular application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种虚拟化类型是基于开发应用程序时使用的环境类型。这与我们之前看到的系统虚拟机和容器不同，因为它不使用将应用程序放到不同机器上的概念。相反，它是一种仅适用于特定应用程序的隔离。
- en: The reason for these kinds of environments is that multiple applications on
    the same system can use the same programming language, causing potential conflicts.
    For example, Python is used in several places on a typical distribution and can
    include many add-on packages. If you want to use the system’s version of Python
    in your own package, you can run into trouble if you want a different version
    of one of the add-ons.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些环境存在的原因是，在同一系统上运行的多个应用程序可能会使用相同的编程语言，导致潜在的冲突。例如，Python 在典型的发行版中使用得很广泛，并且可能包含许多附加包。如果你想在自己的包中使用系统版本的
    Python，当你需要不同版本的某个附加包时，可能会遇到麻烦。
- en: 'Let’s look at how Python’s virtual environment feature creates a version of
    Python with only the packages that you want. The way to start is by creating a
    new directory for the environment like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Python 的虚拟环境功能如何创建一个仅包含你想要的包的 Python 版本。开始的方式是像这样创建一个新的目录来存放环境：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, look inside the new *test-venv* directory. You’ll see a number of system-like
    directories such as *bin*, *include*, and *lib*. To activate the virtual environment,
    you need to source (not execute) the `test-venv/bin/activate` script:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查看新创建的 *test-venv* 目录。你会看到一些类似系统的目录，如 *bin*、*include* 和 *lib*。要激活虚拟环境，你需要源（而不是执行）`test-venv/bin/activate`
    脚本：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The reason for sourcing the execution is that activation is essentially setting
    an environment variable, which you can’t do by running an executable. At this
    point, when you run Python, you get the version in *test-venv/bin* directory (which
    is itself only a symbolic link), and the `VIRTUAL_ENV` environment variable is
    set to the environment base directory. You can run `deactivate` to exit to the
    virtual environment.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码执行的原因是激活本质上是设置环境变量，而你无法通过运行可执行文件来完成此操作。在此时，当你运行 Python 时，你会得到位于*test-venv/bin*目录中的版本（该目录本身只是一个符号链接），并且`VIRTUAL_ENV`环境变量会被设置为环境的基础目录。你可以运行`deactivate`来退出虚拟环境。
- en: It isn’t any more complicated than that. With this environment variable set,
    you get a new, empty packages library in *test-venv/lib*, and anything new you
    install when in the environment goes there instead of in the main system’s library.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。设置了这个环境变量后，你会在*test-venv/lib*中得到一个新的空的包库，并且你在虚拟环境中安装的任何新内容都会安装到那里，而不是安装到主系统的库中。
- en: Not all programming languages allow virtual environments in the way Python does,
    but it’s worth knowing about it, if for no other reason than to clear up some
    confusion about the word *virtual*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有编程语言都像 Python 那样支持虚拟环境，但了解它还是值得的，即使仅仅是为了澄清一些关于*虚拟*一词的误解。
- en: Bibliography
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考书目
- en: 'Abrahams, Paul W., and Bruce Larson, *UNIX for the Impatient*, 2nd ed. Boston:
    Addison-Wesley Professional, 1995.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Abrahams, Paul W., 和 Bruce Larson, *急于上手的UNIX*，第2版。波士顿：Addison-Wesley Professional，1995年。
- en: 'Aho, Alfred V., Brian W. Kernighan, and Peter J. Weinberger, *The AWK Programming
    Language*. Boston: Addison-Wesley, 1988.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Aho, Alfred V., Brian W. Kernighan 和 Peter J. Weinberger, *AWK编程语言*。波士顿：Addison-Wesley，1988年。
- en: 'Aho, Alfred V., Monica S. Lam, Ravi Sethi, and Jeffery D. Ullman, *Compilers:
    Principles, Techniques, and Tools*, 2nd ed. Boston: Addison-Wesley, 2006.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Aho, Alfred V., Monica S. Lam, Ravi Sethi 和 Jeffery D. Ullman, *编译器：原理、技术与工具*，第2版。波士顿：Addison-Wesley，2006年。
- en: 'Aumasson, Jean-Philippe, *Serious Cryptography: A Practical Introduction to
    Modern Encryption*. San Francisco: No Starch Press, 2017.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Aumasson, Jean-Philippe, *严肃的加密学：现代加密的实用入门*。旧金山：No Starch Press，2017年。
- en: 'Barrett, Daniel J., Richard E. Silverman, and Robert G. Byrnes, *SSH, The Secure
    Shell: The Definitive Guide*, 2nd ed. Sebastopol, CA: O’Reilly, 2005.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Barrett, Daniel J., Richard E. Silverman 和 Robert G. Byrnes, *SSH，安全外壳：权威指南*，第2版。塞巴斯托波尔，加利福尼亚州：O'Reilly，2005年。
- en: Beazley, David M., *Python Distilled*. Addison-Wesley, 2021.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Beazley, David M., *Python精粹*。Addison-Wesley，2021年。
- en: 'Beazley, David M., Brian D. Ward, and Ian R. Cooke, “The Inside Story on Shared
    Libraries and Dynamic Loading.” *Computing in Science & Engineering* 3, no. 5
    (September/October 2001): 90–97.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Beazley, David M., Brian D. Ward 和 Ian R. Cooke，“共享库和动态加载的内幕故事。” *计算机科学与工程*
    3，第5期（2001年9月/10月）：90–97。
- en: 'Calcote, John, *Autotools: A Practitioner’s Guide to GNU Autoconf, Automake,
    and Libtool*, 2nd ed. San Francisco: No Starch Press, 2019.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Calcote, John, *Autotools：GNU Autoconf，Automake 和 Libtool 实践指南*，第2版。旧金山：No Starch
    Press，2019年。
- en: 'Carter, Gerald, Jay Ts, and Robert Eckstein, *Using Samba: A File and Print
    Server for Linux, Unix, and Mac OS X*, 3rd ed. Sebastopol, CA: O’Reilly, 2007.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Carter, Gerald, Jay Ts 和 Robert Eckstein, *使用Samba：Linux、Unix 和 Mac OS X 的文件和打印服务器*，第3版。塞巴斯托波尔，加利福尼亚州：O'Reilly，2007年。
- en: 'Christiansen, Tom, brian d foy, Larry Wall, and Jon Orwant, *Programming Perl:
    Unmatched Power for Processing and Scripting*, 4th ed. Sebastopol, CA: O’Reilly,
    2012.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Christiansen, Tom, brian d foy, Larry Wall 和 Jon Orwant, *编程Perl：无与伦比的处理和脚本能力*，第4版。塞巴斯托波尔，加利福尼亚州：O'Reilly，2012年。
- en: 'chromatic, *Modern Perl*, 4th ed. Hillsboro, OR: Onyx Neon Press, 2016.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: chromatic, *现代Perl*，第4版。希尔斯伯勒，俄勒冈州：Onyx Neon Press，2016年。
- en: 'Davies, Joshua. *Implementing SSL/TLS Using Cryptography and PKI*. Hoboken,
    NJ: Wiley, 2011.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Davies, Joshua. *使用加密学和PKI实现SSL/TLS*。霍博肯，新泽西州：Wiley，2011年。
- en: 'Friedl, Jeffrey E. F., *Mastering Regular Expressions*, 3rd ed. Sebastopol,
    CA: O’Reilly, 2006.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Friedl, Jeffrey E. F., *精通正则表达式*，第3版。塞巴斯托波尔，加利福尼亚州：O'Reilly，2006年。
- en: 'Gregg, Brendan, *Systems Performance: Enterprise and the Cloud*, 2nd ed. Boston:
    Addison-Wesley, 2020.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Gregg, Brendan, *系统性能：企业与云计算*，第2版。波士顿：Addison-Wesley，2020年。
- en: 'Grune, Dick, Kees van Reeuwijk, Henri E. Bal, Ceriel J. H. Jacobs, and Koen
    Langendoen, *Modern Compiler Design*, 2nd ed. New York: Springer, 2012.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Grune, Dick, Kees van Reeuwijk, Henri E. Bal, Ceriel J. H. Jacobs 和 Koen Langendoen,
    *现代编译器设计*，第2版。纽约：Springer，2012年。
- en: 'Hopcroft, John E., Rajeev Motwani, and Jeffrey D. Ullman, *Introduction to
    Automata Theory, Languages, and Computation*, 3rd ed. Upper Saddle River, NJ:
    Prentice Hall, 2006.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Hopcroft, John E., Rajeev Motwani 和 Jeffrey D. Ullman, *自动机理论、语言与计算导论*，第3版。上萨德尔河，新泽西州：Prentice
    Hall，2006年。
- en: 'Kernighan, Brian W., and Rob Pike, *The UNIX Programming Environment*. Upper
    Saddle River, NJ: Prentice Hall, 1984.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Kernighan, Brian W. 和 Rob Pike, *UNIX 编程环境*。新泽西州上萨德尔河：普伦蒂斯·霍尔出版社，1984年。
- en: 'Kernighan, Brian W., and Dennis M. Ritchie, *The C Programming Language*, 2nd
    ed. Upper Saddle River, NJ: Prentice Hall, 1988.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Kernighan, Brian W. 和 Dennis M. Ritchie, *C 程序设计语言*，第2版。新泽西州上萨德尔河：普伦蒂斯·霍尔出版社，1988年。
- en: 'Kochan, Stephen G., and Patrick Wood, *Unix Shell Programming*, 3rd ed. Indianapolis:
    SAMS Publishing, 2003.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Kochan, Stephen G. 和 Patrick Wood, *Unix Shell 编程*，第3版。印第安纳波利斯：SAMS 出版社，2003年。
- en: 'Levine, John R., *Linkers and Loaders*. San Francisco: Morgan Kaufmann, 1999.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Levine, John R., *连接器与加载程序*。旧金山：Morgan Kaufmann出版社，1999年。
- en: 'Lucas, Michael W., *SSH Mastery: OpenSSH, PuTTY, Tunnels, and Keys*, 2nd ed.
    Detroit: Tilted Windmill Press, 2018.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Lucas, Michael W., *SSH 掌握：OpenSSH、PuTTY、隧道与密钥*，第2版。底特律：Tilted Windmill Press出版社，2018年。
- en: 'Matloff, Norman, *The Art of R Programming: A Tour of Statistical Software
    Design*. San Francisco: No Starch Press, 2011.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Matloff, Norman, *R 编程艺术：统计软件设计导览*。旧金山：No Starch Press出版社，2011年。
- en: 'Mecklenburg, Robert, *Managing Projects with GNU Make*, 3rd ed. Sebastopol,
    CA: O’Reilly, 2005.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Mecklenburg, Robert, *使用 GNU Make 管理项目*，第3版。加利福尼亚州塞巴斯托波尔：O'Reilly出版社，2005年。
- en: 'Peek, Jerry, Grace Todino-Gonguet, and John Strang, *Learning the UNIX Operating
    System: A Concise Guide for the New User*, 5th ed. Sebastopol, CA: O’Reilly, 2001.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Peek, Jerry, Grace Todino-Gonguet 和 John Strang, *学习 UNIX 操作系统：新用户简明指南*，第5版。加利福尼亚州塞巴斯托波尔：O'Reilly出版社，2001年。
- en: Pike, Rob, Dave Presotto, Sean Dorward, Bob Flandrena, Ken Thompson, Howard
    Trickey, and Phil Winterbottom, “Plan 9 from Bell Labs.” Accessed February 1,
    2020, [https://9p.io/sys/doc/.](https://9p.io/sys/doc/)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Pike, Rob, Dave Presotto, Sean Dorward, Bob Flandrena, Ken Thompson, Howard
    Trickey 和 Phil Winterbottom, “Plan 9 来自贝尔实验室。” 访问于2020年2月1日，[https://9p.io/sys/doc/.](https://9p.io/sys/doc/)
- en: Poulton, Nigel, *Docker Deep Dive*. Author, 2016.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Poulton, Nigel, *Docker 深度探索*。作者，2016年。
- en: Quinlan, Daniel, Rusty Russell, and Christopher Yeoh, eds., “Filesystem Hierarchy
    Standard, Version 3.0.” Linux Foundation, 2015, [https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Quinlan, Daniel, Rusty Russell 和 Christopher Yeoh, 编,“文件系统层次结构标准，版本 3.0。”Linux
    基金会，2015年，[https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml)。
- en: 'Raymond, Eric S., ed., *The New Hacker’s Dictionary*. 3rd ed. Cambridge, MA:
    MIT Press, 1996.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Raymond, Eric S., 编, *新黑客字典*。第3版。马萨诸塞州剑桥：麻省理工学院出版社，1996年。
- en: 'Robbins, Arnold, *sed & awk Pocket Reference*, 2nd ed. Sebastopol, CA: O’Reilly,
    2002.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Robbins, Arnold, *sed & awk 口袋参考*，第2版。加利福尼亚州塞巴斯托波尔：O'Reilly出版社，2002年。
- en: 'Robbins, Arnold, Elbert Hannah, and Linda Lamb, *Learning the vi and Vim Editors:
    Unix Text Processing*, 7th ed. Sebastopol, CA: O’Reilly, 2008.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Robbins, Arnold, Elbert Hannah 和 Linda Lamb, *学习 vi 和 Vim 编辑器：Unix 文本处理*，第7版。加利福尼亚州塞巴斯托波尔：O'Reilly出版社，2008年。
- en: 'Salus, Peter H., *The Daemon, the Gnu, and the Penguin*. Tacoma, WA: Reed Media
    Services, 2008.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Salus, Peter H., *守护进程、Gnu 和企鹅*。华盛顿州塔科马：Reed Media Services出版社，2008年。
- en: Samar, Vipin, and Roland J. Schemers III. “Unified Login with Pluggable Authentication
    Modules (PAM),” October 1995, Open Software Foundation (RFC 86.0), [http://www.opengroup.org/rfc/rfc86.0.html](http://www.opengroup.org/rfc/rfc86.0.html).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Samar, Vipin 和 Roland J. Schemers III. “使用可插拔认证模块（PAM）的统一登录，”1995年10月，开放软件基金会（RFC
    86.0），[http://www.opengroup.org/rfc/rfc86.0.html](http://www.opengroup.org/rfc/rfc86.0.html)。
- en: 'Schwartz, Randal L., brian d foy, and Tom Phoenix, *Learning Perl: Making Easy
    Things Easy and Hard Things Possible*, 7th ed. Sebastopol, CA: O’Reilly, 2016.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Schwartz, Randal L., brian d foy 和 Tom Phoenix, *学习 Perl：让简单的事情更简单，让难的事情成为可能*，第7版。加利福尼亚州塞巴斯托波尔：O'Reilly出版社，2016年。
- en: 'Shotts, William, *The Linux Command Line*, 2nd ed. San Francisco: No Starch
    Press, 2019.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Shotts, William, *Linux 命令行*，第2版。旧金山：No Starch Press出版社，2019年。
- en: 'Silberschatz, Abraham, Peter B. Galvin, and Greg Gagne, *Operating System Concepts*,
    10th ed. Hoboken, NJ: Wiley, 2018.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Silberschatz, Abraham, Peter B. Galvin 和 Greg Gagne, *操作系统概念*，第10版。新泽西州霍博肯：Wiley出版社，2018年。
- en: 'Smith, Jim, and Ravi Nair, *Virtual Machines: Versatile Platforms for Systems
    and Processes*. Cambridge, MA: Elsevier, 2005.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Smith, Jim 和 Ravi Nair, *虚拟机：适用于系统和进程的多功能平台*。马萨诸塞州剑桥：Elsevier出版社，2005年。
- en: 'Stallman, Richard M., *GNU Emacs Manual*, 18th ed. Boston: Free Software Foundation,
    2018.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Stallman, Richard M., *GNU Emacs 手册*，第18版。波士顿：自由软件基金会出版社，2018年。
- en: 'Stevens, W. Richard, Bill Fenner, and Andrew M. Rudoff, *Unix Network Programming,
    Volume 1: The Sockets Networking API*, 3rd ed. Boston: Addison-Wesley Professional,
    2003.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Stevens, W. Richard, Bill Fenner 和 Andrew M. Rudoff, *Unix 网络编程，第1卷：套接字网络 API*，第3版。波士顿：Addison-Wesley
    Professional 出版社，2003年。
- en: 'Tanenbaum, Andrew S., and Herbert Bos, *Modern Operating Systems*, 4th ed.
    Upper Saddle River, NJ: Prentice Hall, 2014.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Tanenbaum, Andrew S. 和 Herbert Bos, *现代操作系统*，第4版。新泽西州上萨德尔河：普伦蒂斯·霍尔出版社，2014年。
- en: 'Tanenbaum, Andrew S., and David J. Wetherall, *Computer Networks*, 5th ed.
    Upper Saddle River, NJ: Prentice Hall, 2010.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'Tanenbaum, Andrew S., 和 David J. Wetherall, *计算机网络*, 第5版. 上萨德尔河, 新泽西州: 普伦蒂斯·霍尔出版社,
    2010.'
