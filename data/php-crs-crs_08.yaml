- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 6 LOOPS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6 循环
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter introduces the *loop*, a control structure that allows you to repeat
    a sequence of statements over and over again. Once you understand how to use loops,
    you’ll be able to easily create scripts to process large volumes of data and perform
    repetitive tasks with efficiently written code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*循环*，一种控制结构，它允许你反复执行一系列语句。一旦你理解了如何使用循环，你将能够轻松创建脚本，处理大量数据，并用高效编写的代码执行重复性任务。
- en: 'We’ll cover two main types of PHP loops: the while loop and the for loop. A
    while loop is used for repeating a series of actions until a specific condition
    is met, while a for loop is used for repeating a series of actions a fixed number
    of times. We’ll also look at do...while loops, a variation on while loops. A fourth
    type of PHP loop, the foreach loop, is specifically designed for looping through
    collections of data, such as arrays. We’ll look at foreach loops when we introduce
    arrays in [Chapter 7](chapter7.xhtml).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍两种主要的 PHP 循环：`while` 循环和 `for` 循环。`while` 循环用于在满足特定条件之前重复一系列操作，而 `for`
    循环用于重复固定次数的操作。我们还将了解 `do...while` 循环，它是 `while` 循环的一种变体。第四种类型的 PHP 循环是 `foreach`
    循环，专门用于遍历数据集合，如数组。我们将在[第 7 章](chapter7.xhtml)介绍 `foreach` 循环时讲解数组。
- en: '### while Loops'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### while 循环'
- en: 'One kind of PHP loop is the while loop: a sequence of statements is repeatedly
    executed *while* a certain condition is true. [Figure 6-1](#fig6-1) illustrates
    how this works.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中的一种循环是 `while` 循环：一系列语句会在某个条件为真时*反复*执行。[图 6-1](#fig6-1) 展示了这一过程是如何运作的。
- en: '![](../images/figure6-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure6-1.jpg)'
- en: 'Figure 6-1: The flow of logic for a while loop'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：`while` 循环的逻辑流程
- en: When a script features a while loop, some statements are typically executed
    before the loop begins. Then the PHP engine checks the condition controlling the
    loop. If the condition is false, the statements in the loop will never be executed,
    and the program skips ahead to the statements after the loop. If the condition
    is true, the statements in the loop are executed once, then the condition is checked
    a second time. If it’s still true, the statements in the loop are executed again.
    This cycle continues, with the PHP engine checking the condition before each new
    repetition until it’s found to be false, and the loop ends.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本包含 `while` 循环时，通常会有一些语句在循环开始之前执行。然后，PHP 引擎检查控制循环的条件。如果条件为假，则循环中的语句将永远不会执行，程序会跳过循环后面的语句。如果条件为真，循环中的语句会执行一次，然后再次检查条件。如果条件仍然为真，循环中的语句将再次执行。这个过程会继续进行，PHP
    引擎会在每次新一轮重复前检查条件，直到条件为假，循环结束。
- en: To write a while loop, start with the while keyword, followed in parentheses
    by the Boolean condition that will control the loop. Then enclose the statement
    that should be repeated in curly brackets. If the loop contains only a single
    statement, the curly brackets are optional, but most programmers include them
    anyway to emphasize that the statement is part of the loop.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 `while` 循环时，从 `while` 关键字开始，后跟括号中的布尔条件，控制循环的执行。然后，将需要重复执行的语句放入大括号中。如果循环只包含一条语句，大括号是可选的，但大多数程序员仍然会使用大括号，以强调该语句是循环的一部分。
- en: '[Listing 6-1](#lis6-1) shows a script that uses a while loop to test the length
    of a password. The loop keeps prompting the user to enter a new password until
    the result is long enough.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-1](#lis6-1) 显示了一个使用 `while` 循环来测试密码长度的脚本。该循环会不断提示用户输入新密码，直到密码足够长。'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: A while loop requesting a password of six characters or more'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-1：一个要求密码长度为六个字符或更多的 `while` 循环
- en: Before the loop, we set the $password variable to an initial value of "cat".
    Then we declare the while loop, using strlen($password) < 6 as the condition.
    Before each repetition of the loop, PHP will check the length of $password. If
    it’s shorter than six characters, the condition is true, so the statement in the
    loop will execute. If it’s six or more characters, the condition is false, so
    the loop will end. Since $password starts out being three characters long, we
    know the loop will execute at least once.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环之前，我们将 `$password` 变量设置为初始值 "cat"。然后我们声明 `while` 循环，使用 `strlen($password)
    < 6` 作为条件。在每次循环之前，PHP 会检查 `$password` 的长度。如果密码长度小于六个字符，条件为真，循环中的语句将执行。如果密码长度为六个字符或更多，条件为假，循环将结束。由于
    `$password` 最初是三个字符，所以我们知道循环至少会执行一次。
- en: Inside the loop, we use the built-in readline() function to take in a password
    from the user. The function displays the string passed as an argument as a command
    line prompt, then reads whatever the user types at the command line before pressing
    ENTER. We store the result back into the $password variable, so now we’ll have
    a new value to check before the next repetition of the loop. Once the password
    is long enough and the loop ends, we confirm the new value of $password back to
    the user.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内，我们使用内置的 `readline()` 函数从用户那里获取密码。该函数将传递的字符串作为命令行提示符显示，然后读取用户在命令行输入的内容，直到按下
    ENTER 键。我们将结果存储回 `$password` 变量中，因此在下一次循环重复之前，我们会检查新的值。当密码长度足够并且循环结束时，我们会将新值的
    `$password` 返回给用户确认。
- en: NOTE
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*This program is* not *a good example of secure password protocols since the
    password is being shown onscreen, where anyone could read it. But it’s a handy
    illustration of a* while *loop.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个程序* 不是 *一个良好的安全密码协议示例，因为密码会显示在屏幕上，任何人都可以看到。但它是一个演示 `while` *循环* 的便捷示例。*'
- en: 'The following is a sample run of this script. I’ve entered a few passwords
    that are too short before providing an acceptable one:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该脚本的一个示例运行。我在输入一个可接受的密码之前，先输入了几个过短的密码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s what happens each time the PHP engine checks the strlen($password) <
    6 condition during this run of the script:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每次 PHP 引擎检查 `strlen($password) < 6` 条件时的情况，发生在此脚本的运行过程中：
- en: 1.   $password contains "cat", so the condition is true. The loop executes once.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   $password 包含 "cat"，因此条件为真。循环执行一次。
- en: 2.   $password contains "dog", so the condition is still true. The loop executes
    a second time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   $password 包含 "dog"，所以条件依然为真。循环第二次执行。
- en: 3.   $password contains "whale", so the condition is still true. The loop executes
    a third time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   $password 包含 "whale"，所以条件依然为真。循环第三次执行。
- en: 4.   $password contains "catdog123", so the condition is false. The loop ends,
    and the final print statement executes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   $password 包含 "catdog123"，所以条件为假。循环结束，最后的打印语句执行。
- en: In all, the PHP engine checks the loop’s condition four times and repeats the
    loop’s contents three times. There will always be one more check of the condition
    than there are repetitions of a while loop, since the condition check happens
    *before* the loop’s contents are executed. Try changing the initial value of $password
    to text at least six characters long and running the script again. You’ll find
    that the script skips straight to the final print statement, since the first check
    of the loop condition evaluates to false.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，PHP 引擎检查循环条件四次，并且循环内容重复执行三次。每次 `while` 循环的条件检查次数总比循环的重复次数多一次，因为条件检查发生在循环内容执行*之前*。试着将$password的初始值改为至少六个字符的文本，然后再次运行脚本。你会发现脚本直接跳到最后的打印语句，因为第一次检查循环条件时条件值为假。
- en: do...while Loops
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`do...while` 循环'
- en: 'A do...while loop is an alternate form of a while loop: the condition check
    happens *after* each repetition of the loop, rather than before. This way, the
    statement(s) in the loop are guaranteed to be executed at least once, and the
    number of loop repetitions will match the number of times the condition is checked.
    [Figure 6-2](#fig6-2) shows how this works.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`do...while` 循环是 `while` 循环的另一种形式：条件检查发生在每次循环重复*之后*，而不是之前。这样，循环中的语句保证至少执行一次，且循环的重复次数将与条件检查的次数相匹配。[图
    6-2](#fig6-2)展示了这一过程是如何工作的。'
- en: '![](../images/figure6-2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure6-2.jpg)'
- en: 'Figure 6-2: The flow of logic for a do...while loop'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：`do...while` 循环的逻辑流程
- en: With a do...while loop, first we go once through the statements in the loop.
    Then we test the loop condition. If the condition is false, we move on to the
    statements after the loop, so the loop will have executed only the one time. If
    the condition is true, the loop statements are executed again, and so on until
    the condition is false.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `do...while` 循环时，我们首先执行一次循环中的语句。然后测试循环条件。如果条件为假，程序会跳到循环后的语句，因此循环只执行一次。如果条件为真，循环语句会再次执行，依此类推，直到条件为假。
- en: To write a do...while loop, start with the do keyword, followed in curly brackets
    by the statements that should be repeated. After the closing curly bracket, write
    the while keyword, then the loop condition in parentheses. For example, [Listing
    6-2](#lis6-2) shows how to rewrite the password-checking script from [Listing
    6-1](#lis6-1) by using a do...while loop instead of a while loop. The changes
    are shown in black text.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写 do...while 循环，首先使用 do 关键字，然后用大括号括起应重复执行的语句。闭括号之后，写上 while 关键字，然后在括号内写上循环条件。例如，[示例
    6-2](#lis6-2)展示了如何通过使用 do...while 循环来重写 [示例 6-1](#lis6-1) 中的密码检查脚本，而不是使用 while
    循环。更改部分用黑色文字显示。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-2: A modified version of [Listing 6-1](#lis6-1) using a do...while
    loop'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-2：[示例 6-1](#lis6-1)的修改版本，使用了 do...while 循环
- en: We begin the loop with the do keyword. Then, after our statement with the readline()
    function, on the same line as the closing curly bracket, we write the while keyword
    and then, inside parentheses, the same strlen ($password) < 6 loop condition we
    had before. Notice that we need to include a semicolon after the condition to
    end the statement.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 do 关键字开始循环。然后，在 readline() 函数的语句之后，在闭括号所在的同一行，我们写上 while 关键字，然后在括号内写上与之前相同的
    strlen ($password) < 6 循环条件。请注意，我们需要在条件后加上分号，以结束语句。
- en: The key difference between this and the previous version of the script is that
    we no longer need to set an initial value for the $password variable before entering
    the loop. Instead, we read in an initial password from the user during the first
    run of the loop before testing its value and deciding whether a repetition is
    necessary. In general, if you know you’ll want the statements in a loop to be
    executed at least once, a do...while loop may be a better choice than a while
    loop.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前版本脚本的关键区别在于，我们不再需要在进入循环前为 $password 变量设置初始值。相反，在第一次运行循环时，我们从用户那里读取一个初始密码，然后测试其值并决定是否需要重复。一般来说，如果你知道希望循环中的语句至少执行一次，那么
    do...while 循环可能比 while 循环更适合。
- en: Boolean Flags
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 布尔标志
- en: If the logic governing whether to continue looping is more complex than a single
    condition, it’s often clearer to control the loop by using a Boolean variable
    known as a *flag*. Typically, you set the flag to true, then enter the loop, using
    the flag as the condition. The loop itself features logic (perhaps a series of
    if statements) to set the value of the flag to false when the loop is ready to
    end.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果决定是否继续循环的逻辑比单一条件更复杂，通常通过使用一个布尔变量（称为*标志*）来控制循环会更加清晰。通常，你会将标志设置为 true，然后进入循环，使用该标志作为条件。循环本身会包含逻辑（可能是一个
    if 语句系列），在循环准备结束时，将标志的值设置为 false。
- en: 'For example, say we want to repeatedly prompt the user for input until they
    type either *quit* or *q*. We could accomplish that with a while loop that starts
    this way:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要反复提示用户输入，直到他们输入 *quit* 或 *q*。我们可以通过以下方式使用 while 循环来实现：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The condition for this loop is borderline hard to read, and it would become
    even more convoluted if we wanted to watch for a third input. Controlling the
    loop with a Boolean flag clarifies the code, as shown in [Listing 6-3](#lis6-3).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环的条件几乎难以阅读，如果我们想要监控第三个输入，它会变得更加复杂。通过布尔标志控制循环可以使代码更清晰，正如在[示例 6-3](#lis6-3)中所示。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-3: Using a Boolean flag variable as the loop condition'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-3：使用布尔标志变量作为循环条件
- en: We first create the Boolean flag variable $continueLooping and set it to true.
    Then we declare a while loop with this flag as the loop condition. Notice that
    this is much clearer than the compound condition shown earlier. Since the condition
    is initially true, we’ll enter the loop and execute the loop statement group at
    least once. After prompting the user for text and storing it in the $userInput
    variable, we use two if statements to check whether the variable contains 'quit'
    or 'q'. These if statements take the place of the original compound loop condition;
    both set the flag to false to end the loop when the user asks to quit. After the
    if statements, we print the user’s input. Then, outside the loop, we print a message
    confirming that the loop is over.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建布尔标志变量 $continueLooping 并将其设置为 true。然后，我们声明一个 while 循环，以该标志作为循环条件。请注意，这比之前的复合条件更清晰。由于条件最初为
    true，我们将进入循环并至少执行一次循环语句组。在提示用户输入文本并将其存储在 $userInput 变量中之后，我们使用两个 if 语句来检查该变量是否包含
    'quit' 或 'q'。这两个 if 语句代替了原来的复合循环条件；当用户要求退出时，它们将标志设置为 false，从而结束循环。在 if 语句之后，我们打印用户的输入。然后，在循环外部，我们打印一条消息，确认循环已经结束。
- en: 'Here’s a sample run of the script:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是脚本的一个示例运行：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the script prints out whatever text the user enters. In this
    case, the loop ended after I typed *quit*, but it’ll also end if you type the
    letter *q*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，脚本会打印出用户输入的任何文本。在这个例子中，循环在我输入*quit*后结束，但如果你输入字母*q*，它也会结束。
- en: break Statements
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`break`语句'
- en: The break keyword immediately exits a loop, without allowing any remaining statements
    in the loop to execute. In the previous script’s output, you may have noticed
    that when I typed *quit*, that word was repeated by the loop’s final print statement
    (you typed 'quit') before the loop terminated. With a break statement, we could
    immediately halt the loop as soon as the user enters *quit* or *q*, before that
    print statement runs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`关键字会立即退出循环，不允许任何剩余的语句在循环中执行。在前一个脚本的输出中，你可能注意到当我输入*quit*时，这个词会在循环的最后一个打印语句（你输入了''quit''）中重复显示，然后才会终止循环。使用`break`语句后，当用户输入*quit*或*q*时，我们可以立即停止循环，而不会执行打印语句。'
- en: Using break also eliminates the need for a Boolean flag. Instead, we can simply
    use the literal Boolean value true as the looping condition by writing while (true).
    Since true is always true, this loop will theoretically repeat forever, or at
    least until some conditional logic triggers a break statement. [Listing 6-4](#lis6-4)
    shows how to update our user input script with while (true) and break.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`break`还消除了布尔标志的需求。相反，我们可以通过写`while (true)`来直接使用布尔值`true`作为循环条件。由于`true`始终为真，这个循环理论上会永远重复，或者至少直到某个条件逻辑触发`break`语句为止。[列表6-4](#lis6-4)展示了如何更新我们的用户输入脚本，使用`while
    (true)`和`break`。
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-4: An updated version of [Listing 6-3](#lis6-3), using break to exit
    a while (true) loop'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-4：[列表6-3](#lis6-3)的更新版本，使用`break`语句退出`while (true)`循环
- en: We’ve deleted our $continueLooping Boolean flag and replaced the while loop’s
    condition with the literal true ❶. Inside the loop, we still have our two if statements
    testing whether $userInput contains the string 'quit' or 'q', but this time each
    if statement simply contains the break keyword to immediately exit the loop. This
    way, if either if statement passes, we’ll jump straight to the final print statement
    ❸, without executing the print statement inside the loop ❷.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除了$continueLooping布尔标志，并用字面量`true`替换了`while`循环的条件❶。在循环内部，我们仍然有两个`if`语句来测试`$userInput`是否包含字符串'quit'或'q'，但这次每个`if`语句中都简单地包含了`break`关键字，以立即退出循环。这样，如果任何一个`if`语句通过，我们将直接跳到最终的打印语句❸，而不会执行循环内部的打印语句❷。
- en: 'Here’s a sample run of this updated version of the script:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新后的脚本版本的一个示例运行：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, when I enter the word *quit*, no you typed 'quit' message appears.
    Instead, the loop ends immediately, so the next message is --- I have left the
    loop! ---.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我输入*quit*时，循环不再打印“你输入了'quit'”这样的消息。相反，循环会立即结束，所以下一条消息是——我已经离开循环！——。
- en: In many cases, it’s a matter of personal preference whether you use break statements
    or a Boolean flag in the loop condition to terminate a loop. If you’re coming
    from a language that doesn’t support break statements, Boolean flags might feel
    more natural. On the other hand, if lots of conditions are being tested to decide
    whether the loop should end, break statements can be more practical. When writing
    a code compiler or programming language tool, for example, tens or hundreds of
    tests might be included. Using break statements can save you from having to scroll
    through pages of code to see what might be happening in the later loop statements,
    after all the tests have been conducted.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，是否使用`break`语句或布尔标志来终止循环，取决于个人偏好。如果你来自于不支持`break`语句的语言，布尔标志可能会感觉更自然。另一方面，如果需要测试多个条件来决定循环是否结束，`break`语句则更为实用。例如，在编写代码编译器或编程语言工具时，可能需要包含几十个甚至上百个测试。使用`break`语句可以避免你在执行完所有测试后，需要滚动浏览代码页面以查看后续循环语句中可能发生的情况。
- en: for Loops
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'A for loop is a style of loop that repeats a set number of times. If you know
    exactly how many times you want to repeat a task (for example, giving a user three
    chances to enter the correct password, or testing students with exactly 10 questions
    selected randomly from a test bank), a for loop may be a better choice than a
    while loop. A for loop hinges around a *counter variable*, customarily called
    $i (short for *iterator*), that governs the number of repetitions. Declaring a
    for loop requires three expressions, all featuring this counter variable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环是一种重复固定次数的循环。如果你确切知道你想要重复任务的次数（例如，给用户三次机会输入正确的密码，或者从试题库中随机选择 10 道题目测试学生），那么
    for 循环可能比 while 循环更合适。for 循环围绕一个 *计数器变量*，通常称为 $i（即 *迭代器* 的缩写），它控制循环的重复次数。声明一个
    for 循环需要三个表达式，所有表达式都涉及到这个计数器变量：
- en: 1.   An expression initializing the counter to a starting value
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   一个表达式，用于将计数器初始化为起始值
- en: 2.   An expression testing the counter’s value to determine when the loop should
    stop
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   一个表达式，用于测试计数器的值，以决定何时停止循环
- en: 3.   An expression to increment (or decrement) the counter after each repetition
    of the loop
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   一个表达式，用于在每次循环后递增（或递减）计数器
- en: 'To declare a for loop, all three of these expressions are written in this sequence
    on a single line, immediately after the for keyword, enclosed in a set of parentheses.
    Here’s an example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个 for 循环，这三个表达式会在 for 关键字后面依次写在一行内，并且被一对括号括起来。下面是一个示例：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here $i = 1 initializes the counter variable to 1. Then $i <= 5 sets the looping
    condition; as long as $i is less than or equal to 5, the loop will continue repeating.
    PHP will check this condition *before* each new repetition of the loop. Finally,
    $i++ uses the increment operator (++) to tell PHP to add 1 to $i *after* each
    pass through the loop. This way, $i gets a new value for each cycle of the loop
    that can be tested against the looping condition. In this case, $i will have a
    value of 1 the first time through, then 2 the second time through, and so on.
    The fifth time through the loop, when $i has a value of 5, the $i <= 5 condition
    still passes, but at the end of the fifth repetition, $i will be incremented to
    6. At this point, $i is no longer less than or equal to 5, so the loop ends after
    five repetitions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 $i = 1 将计数器变量初始化为 1。然后 $i <= 5 设置循环条件；只要 $i 小于或等于 5，循环将继续执行。PHP 会在每次新一轮循环前检查这个条件。最后，$i++
    使用增量运算符（++）告诉 PHP 在每次循环后将 1 加到 $i 上。这样，$i 就会在每个循环周期中获取一个新的值，并且这个值可以与循环条件进行比较。在这种情况下，第一次执行时，$i
    的值为 1，第二次执行时为 2，以此类推。当第五次执行时，$i 的值为 5，$i <= 5 的条件仍然成立，但在第五次循环结束时，$i 会被递增到 6。此时，$i
    不再小于或等于 5，因此循环在执行完五次后结束。
- en: To verify that the for loop works as we expect, let’s fill in the loop’s body
    with a simple print statement, as shown in [Listing 6-5](#lis6-5). This script
    should print the same message five times.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 for 循环是否按预期工作，让我们在循环体内填入一个简单的 print 语句，如[示例 6-5](#lis6-5)所示。这个脚本应该会打印相同的消息五次。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-5: An example of a for loop'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-5：一个 for 循环的示例
- en: 'We declare a for loop, using the same set of expressions with the looping variable
    $i we just discussed. Inside the curly brackets delineating the loop’s statement
    group, we write a print statement. Here’s the output of running the script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个 for 循环，使用我们刚刚讨论过的循环变量 $i 的相同表达式集。在大括号内，定义了循环语句组，我们写入一个 print 语句。下面是运行该脚本的输出：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the message indeed prints five times, thanks to the way the
    for loop’s counter variable increments from 1 until it’s no longer less than or
    equal to 5.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于 for 循环的计数器变量从 1 开始递增，直到不再小于或等于 5，消息确实打印了五次。
- en: Using the Counter in the Loop
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在循环中使用计数器
- en: Part of the power of for loops is that the counter variable $i is available
    for use within the body of the loop. This can facilitate working with mathematical
    tasks, or with organized sets of data indexed or identified by a sequence of integers.
    For example, we might want to work with all the items in a database table whose
    IDs are a sequence of integers starting at 1 (see [Part VI](part6.xhtml) for more
    on databases). Or we might want to loop sequentially through all the elements
    of an integer-indexed array (see [Chapter 7](chapter7.xhtml)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环的一个优势是计数器变量 $i 可以在循环体内使用。这有助于处理数学任务或使用通过一系列整数索引或标识的有序数据集。例如，我们可能希望处理数据库表中所有
    ID 为从 1 开始的整数序列的项（有关数据库的更多信息，请参见 [第六部分](part6.xhtml)）。或者我们可能希望顺序遍历一个整数索引数组中的所有元素（有关数组的更多信息，请参见
    [第七章](chapter7.xhtml)）。
- en: To demonstrate, [Listing 6-6](#lis6-6) shows an updated version of our original
    for loop that incorporates the value of $i into the printed message. Since $i
    has a different value during each repetition of the loop, each message will now
    be unique.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，[列表 6-6](#lis6-6) 显示了我们原始 for 循环的更新版本，该版本将 $i 的值包含到打印的消息中。由于 $i 在每次循环重复时都有不同的值，现在每条消息都将是唯一的。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-6: Using the counter variable $i within a for loop'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-6：在 for 循环中使用计数器变量 $i
- en: 'We’ve updated the loop’s print statement to include the value of $i. Here’s
    the result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了循环的打印语句，以包括 $i 的值。以下是结果：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that the number in each output line changes based on the value of $i.
    The output helps illustrate how the counter variable is working: it starts at
    1 and increases by 1 with each repetition of the loop. Once $i gets to 6, the
    $i <=5 condition no longer passes, so the loop ends without printing I am repetition
    6 of a for loop.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每一行输出中的数字会根据 $i 的值变化。输出有助于说明计数器变量是如何工作的：它从 1 开始，并随着每次循环重复增加 1。一旦 $i 达到 6，$i
    <= 5 条件不再成立，因此循环结束，而没有打印 "I am repetition 6 of a for loop"。
- en: So far we’ve been initializing $i to 1, but you can initialize it to any value
    you want. In fact, you’ll find many examples of for loops using a counter variable
    that starts at 0. This is because for loops are often used in conjunction with
    arrays, collections of items that are numbered starting from 0\. We’ll discuss
    arrays, and how to loop through them, in [Chapter 7](chapter7.xhtml).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将 $i 初始化为 1，但你可以将其初始化为任何你想要的值。实际上，你会发现很多 for 循环的例子使用了从 0 开始的计数器变量。这是因为
    for 循环通常与数组一起使用，数组是从 0 开始编号的项目集合。我们将在 [第七章](chapter7.xhtml) 中讨论数组，以及如何遍历它们。
- en: 'When you initialize the counter variable to 0, it’s also common to set the
    looping condition with the less-than operator (<) instead of with less-than-or-equal-to
    (<=), like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将计数器变量初始化为 0 时，通常也会使用小于运算符 (<) 设置循环条件，而不是小于或等于运算符 (<=)，如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This loop will run as long as $i is less than 3\. Since $i starts at 0, the
    loop will repeat three times, when $i equals 0, 1, and 2.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 $i 小于 3，循环就会继续执行。由于 $i 从 0 开始，循环将执行三次，$i 分别为 0、1 和 2。
- en: Skipping Loop Statements
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跳过循环语句
- en: The continue keyword stops the current repetition of a loop, but unlike the
    break keyword, it doesn’t end the loop entirely. Instead, the loop immediately
    jumps ahead to the next repetition. This is useful if you want to skip certain
    passes through a loop. For example, maybe you’re retrieving entries from a database
    and want to ignore certain values, or you want to use only certain numbers in
    a sequence, such as a random sample of every third item in a randomized collection
    of data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: continue 关键字停止当前循环的重复，但与 break 关键字不同，它不会完全结束循环。相反，循环会立即跳到下一个重复。这在你想跳过某些循环次数时非常有用。例如，也许你正在从数据库中检索条目，并希望忽略某些值，或者你只想使用某些序列中的数字，例如从一个随机排列的数据集中每三个项目的随机样本。
- en: '[Listing 6-7](#lis6-7) shows an example of a for loop with a continue statement.
    Here we’re using continue to skip odd values of counter variable $i, so we end
    up printing only the even values. The listing also illustrates how a for loop
    can decrement the counter variable instead of incrementing it.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-7](#lis6-7) 显示了一个包含 continue 语句的 for 循环示例。在这里，我们使用 continue 跳过计数器变量 $i
    的奇数值，因此我们最终只打印偶数值。该列表还展示了如何让 for 循环递减计数器变量，而不是递增它。'
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-7: Skipping parts of a for loop with continue'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-7：使用 continue 跳过 for 循环的部分
- en: We declare a for loop with the $i counter variable starting at 8 and decreasing
    by 1 after each repetition, thanks to the $i-- decrementing expression. The loop
    will count down to 1, then stop when $i equals 0. Inside the loop, we use the
    modulo operator (%) to test whether the current value of $i is even or odd ❶.
    If even, $i % 2 will be 0, or if odd, $i % 2 will be 1. Either way, we store the
    result in the $odd variable, then use that variable as the condition of an if
    statement.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个 for 循环，其中 $i 计数器变量从 8 开始，并在每次重复后通过 $i-- 表达式递减。循环将倒计时到 1，然后当 $i 等于 0
    时停止。在循环内部，我们使用取模运算符 (%) 测试当前 $i 的值是偶数还是奇数 ❶。如果是偶数，$i % 2 的结果为 0；如果是奇数，$i % 2 的结果为
    1。不论哪种情况，我们将结果存储在 $odd 变量中，然后将该变量作为 if 语句的条件。
- en: 'Since an if statement requires a Boolean condition, $odd will be type-juggled
    to a Boolean: true for 1 or false for 0. This way, when the value of $i is odd,
    we’ll execute the if statement, which contains just the continue keyword to interrupt
    the current repetition of the loop and skip to the next one. When $i is even,
    we don’t execute the if statement body, allowing us to complete the current repetition
    of the loop by executing the print statement ❷. The net effect is that we print
    out only even values of $i, as the output shows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 if 语句需要一个布尔条件，$odd 将被强制转换为布尔值：当为 1 时为 true，0 时为 false。这样，当 $i 为奇数时，我们会执行
    if 语句，该语句只包含 continue 关键字，用于中断当前循环的重复并跳到下一个。当 $i 为偶数时，我们不执行 if 语句的主体，从而通过执行 print
    语句 ❷ 完成当前循环的重复。最终效果是我们只打印出 $i 的偶数值，输出如下所示：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’ve successfully skipped the odd numbers thanks to our conditional logic triggering
    the continue statement in our loop.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的条件逻辑触发了循环中的 continue 语句，我们成功跳过了奇数。
- en: NOTE
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* continue *keyword works in* while *loops just as it does in* for *loops.
    Likewise, the* break *keyword also works to completely stop a* for *loop.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*continue* 关键字在 *while* 循环中的作用与在 *for* 循环中一样。同样，*break* 关键字也用于完全停止一个 *for*
    循环。'
- en: Handling the Last Iteration Differently
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理最后一次重复
- en: Sometimes you might want to do something different during the final repetition
    of a loop. With a while or do...while loop, you can’t know if it’s the final repetition
    until the loop has already ended, but with a for loop, you can anticipate the
    last repetition with conditional logic and write code that treats that last repetition
    differently.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望在循环的最后一次重复时做一些不同的事情。对于 while 或 do...while 循环，直到循环结束时你才知道是否是最后一次重复，但对于
    for 循环，你可以通过条件逻辑预见到最后一次重复，并编写代码以不同的方式处理这一重复。
- en: For example, say we’re using a for loop to build up a string containing a list
    of items entered by the user, and we want to separate each item with a comma.
    We might be tempted to write something like [Listing 6-8](#lis6-8).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，我们使用一个 for 循环来构建一个字符串，其中包含用户输入的项列表，并且我们希望用逗号分隔每一项。我们可能会想写类似 [Listing 6-8](#lis6-8)
    这样的代码。
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 6-8: A for loop creating a list of items, separated by commas'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-8: 一个使用 for 循环创建的项列表，并用逗号分隔'
- en: 'We initialize a $message variable with the string "go to the market and buy:
    ". Then we assign $numItems the value 3. This will be the number of repetitions
    of our for loop. Next, we declare the for loop, where $i counts up from 1 to $numItems
    (3). Each time through the loop, we prompt the user to enter an item to buy, storing
    the input in the $item variable. We then append the value of $item to the $message
    string, followed by a comma and a space. When the loop ends, we print out the
    $message string that we’ve constructed.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '我们初始化一个 $message 变量，值为 "go to the market and buy: "。然后我们将 $numItems 的值设为 3。这将是我们
    for 循环的重复次数。接着，我们声明 for 循环，在该循环中，$i 从 1 数到 $numItems（3）。每次循环时，我们提示用户输入一个要购买的商品，并将输入值存储在
    $item 变量中。然后我们将 $item 的值附加到 $message 字符串后面，后面跟一个逗号和一个空格。当循环结束时，我们打印出构建好的 $message
    字符串。'
- en: 'The problem is that we’re treating each repetition of the loop the same, so
    every item in the final message will have a comma after it, including the last
    one. You can see this in the following sample run of the script:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们将循环的每次重复都视为相同，因此最终消息中的每一项后面都会跟一个逗号，包括最后一项。你可以在以下脚本的示例运行中看到这一点：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our script has built up a message including the three items entered at the command
    line, and unfortunately, a comma appears after the last item, apples. We can fix
    this by adding a test to determine whether we’re on the last repetition of the
    loop. Then we’ll add a comma only if it isn’t the last repetition. [Listing 6-9](#lis6-9)
    shows how to update the script.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本已经构建了一个包含在命令行输入的三项内容的消息，但不幸的是，最后一项“apples”后面出现了逗号。我们可以通过添加一个测试来确定是否是最后一次循环迭代，然后只有在不是最后一次迭代时才添加逗号。[清单
    6-9](#lis6-9)展示了如何更新脚本。
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 6-9: Updating the script from [Listing 6-8](#lis6-8) to leave off the
    final comma'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-9：更新[清单 6-8](#lis6-8)的脚本以去掉最后的逗号
- en: This time we first append just the value of $item to the $message string, without
    a comma and space after it. Then we create the Boolean variable $lastIteration,
    giving it the value of the expression $i == $numItems. This expression will be
    true only the last time through the loop. Next, we have an if statement with !$lastIteration
    as the condition. Thanks to the NOT operator (!), this condition will be true
    for all repetitions except the final one. Inside the if statement, we append a
    comma and space to $message. This way, all but the last item in the list will
    have a comma after it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们首先仅将 $item 的值附加到 $message 字符串中，不加逗号和空格。然后，我们创建了一个布尔变量 $lastIteration，并赋予它表达式
    $i == $numItems 的值。这个表达式只有在循环的最后一次迭代时才为 true。接下来，我们使用 if 语句，并将 !$lastIteration
    作为条件。感谢 NOT 操作符（!），这个条件在所有循环迭代中都为 true，除了最后一次。在 if 语句内部，我们将逗号和空格附加到 $message。这样，除了最后一项，列表中的每一项后面都会有逗号。
- en: 'Here’s a sample run of the updated script:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是更新后的脚本运行示例：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We no longer have a comma after apples, the last item in the list, since we’re
    treating the final repetition of the for loop differently from the others.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再在列表的最后一项“apples”后面加逗号，因为我们将 for 循环的最后一次迭代与其他迭代区分开来处理。
- en: NOTE
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Once we start working with arrays, we’ll be able to avoid this kind of last-repetition-is-special
    loop logic by using the built-in* implode() *function. It intelligently adds a
    separator between each item in a list, but not after the last item. We’ll discuss
    this in [Chapter 7](chapter7.xhtml).*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦我们开始使用数组，就可以通过使用内置的* implode() *函数来避免这种特殊的最后一次迭代循环逻辑。它智能地在列表中的每一项之间添加分隔符，但不会在最后一项后添加。我们将在[第
    7 章](chapter7.xhtml)中讨论这个问题。*'
- en: Alternative Loop Syntax
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一种循环语法
- en: PHP provides an alternative syntax for writing while and for loops, setting
    off the contents of the loop with a colon (:) rather than enclosed in curly brackets.
    Just like the alternative syntax for if statements we discussed in [Chapter 4](chapter4.xhtml),
    this other way of writing loops is often useful when combing PHP statements in
    a script with templating text such as HTML for web applications. To demonstrate,
    [Listing 6-10](#lis6-10) uses the alternative syntax to rewrite the password-setting
    while loop from [Listing 6-1](#lis6-1).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了另一种语法来编写 while 和 for 循环，用冒号（:）而不是用大括号将循环内容括起来。就像我们在[第 4 章](chapter4.xhtml)中讨论的
    if 语句的替代语法一样，这种编写循环的方式在将 PHP 语句与模板文本（如用于 web 应用程序的 HTML）结合使用时非常有用。为了演示，[清单 6-10](#lis6-10)
    使用替代语法重写了[清单 6-1](#lis6-1)中的密码设置 while 循环。
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 6-10: An alternative syntax for the while loop from [Listing 6-1](#lis6-1)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-10：来自[清单 6-1](#lis6-1)的 while 循环的另一种语法
- en: Notice that the line declaring the while loop ends with a colon rather than
    an opening curly bracket. In lieu of a closing curly bracket, we signal the end
    of the loop with the endwhile keyword.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，声明 while 循环的那一行以冒号结尾，而不是以大括号开头。我们使用 endwhile 关键字来表示循环的结束，而不是闭合大括号。
- en: '[Listing 6-11](#lis6-11) likewise shows the alternative syntax for the for
    loop from [Listing 6-6](#lis6-6).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-11](#lis6-11) 同样展示了来自[清单 6-6](#lis6-6)的 for 循环的另一种语法。'
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 6-11: An alternative syntax for the for loop from [Listing 6-6](#lis6-6)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-11：来自[清单 6-6](#lis6-6)的 for 循环的另一种语法
- en: Again, notice the colon at the end of the line declaring the loop, and the endfor
    keyword to indicate the end of the loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意声明循环的那一行以冒号结尾，并且使用 endfor 关键字来表示循环的结束。
- en: NOTE
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*PHP has no alternative syntax for a* do...while *loop.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP 没有 do...while 循环的另一种语法*。'
- en: Avoiding Infinite Loops
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免无限循环
- en: 'It’s all too easy to accidentally get trapped in an infinite loop that keeps
    repeating forever because the stopping condition is never met. To avoid this,
    it’s important to make sure the condition controlling the loop can and will be
    false when appropriate. One way to mistakenly write an infinite for loop is to
    set the increment expression to move in the wrong direction relative to the looping
    condition. For example, consider this code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易不小心陷入一个无限循环，导致循环不断重复，因为停止条件永远无法满足。为了避免这种情况，确保控制循环的条件能够在适当的时候变为假是非常重要的。一种常见的错误写法是在循环条件相对的方向上设置递增表达式。例如，考虑以下代码：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This increment expression adds 1 to $i after each repetition. Meanwhile, the
    looping condition tests whether $i is greater than 0. Since $i is growing with
    each repetition, it will always be greater than 0, so the loop will never end.
    The solution is to make $i decrement rather than increment, or to change the looping
    condition to some kind of less-than comparison.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递增表达式在每次重复后给$i加1。同时，循环条件会测试$i是否大于0。由于$i在每次重复时都在增加，它将始终大于0，因此循环永远不会结束。解决方法是让$i递减，而不是递增，或者将循环条件改为某种小于比较。
- en: With while and do...while loops, you can get stuck repeating forever if the
    variables in the loop condition don’t have a chance to be changed correctly in
    the loop statements. For example, say we want to write a script that totals up
    prices entered by the user until the total exceeds $100, then print out the result.
    We might accidentally create an infinite loop by writing something like [Listing
    6-12](#lis6-12).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用while和do...while循环时，如果循环条件中的变量在循环语句中没有机会被正确改变，就容易陷入无限重复。例如，假设我们想编写一个脚本，将用户输入的价格累加，直到总和超过100美元，然后打印出结果。我们可能会不小心写出像[列表6-12](#lis6-12)这样的代码，导致无限循环。
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 6-12: An unintentionally infinite do...while loop'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-12：一个无意中的无限 do...while 循环
- en: We set $total to 0, then enter a do...while loop that keeps repeating while
    $total is less than 100\. Inside the loop, we take in a line of input from the
    user and verify it’s numeric. If it is, we convert the input to a float and store
    the value in $total ❶.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将$total设置为0，然后进入一个do...while循环，只要$total小于100就一直重复。在循环内部，我们从用户那里获取一行输入，并验证其是否为数字。如果是数字，我们将输入转换为浮动类型，并将该值存储在$total中❶。
- en: Do you see the problem? We should have used something like $total += floatval($costString);
    to add the latest input to the value already in $total, but we’ve used a regular
    assignment operator (=) rather than an addition assignment operator (+=). As a
    result, the value of $total will always be the last value entered. If the user
    ever enters a value greater than 100, the loop will end, and the print statement
    will echo back that last value. Otherwise, we’ll be stuck in an infinite loop,
    without really calculating a running total.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到问题了吗？我们本应该使用类似`$total += floatval($costString);`这样的代码来将最新输入的值加到已有的$total值中，但我们使用了常规的赋值操作符（=），而不是加法赋值操作符（+=）。因此，$total的值将始终是最后输入的值。如果用户输入的值大于100，循环会结束，打印语句会回显该最后的值。否则，我们就会陷入无限循环，而无法真正计算累计总和。
- en: An infinite while loop also occurs when the variable tested in the loop condition
    never changes, so once the loop is entered, it’s never exited. Returning to [Listing
    6-12](#lis6-12), for example, we might use a $grandTotal variable to set the looping
    condition, as in while ($grandTotal < 100), but then increment the $total variable
    inside the loop instead of $grandTotal. This way, $grandTotal would never change,
    so the loop would run forever.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 无限while循环还会发生在循环条件中测试的变量永远不会变化的情况下，一旦进入循环，就无法退出。回到[列表6-12](#lis6-12)，例如，我们可能会使用一个$grandTotal变量来设置循环条件，如`while($grandTotal
    < 100)`，但在循环内部递增的是$total变量，而不是$grandTotal。这样，$grandTotal将永远不变，循环将永远执行下去。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined while loops, do...while loops, and for loops, which
    all offer different methods of repeating a sequence of statements. The key to
    these looping control structures is determining how long the loop should keep
    repeating, either by setting a condition for when the loop should stop, as in
    a while or do...while loop, or by specifying a fixed number of repetitions, as
    in a for loop. In addition to the basic structure of these loops, we discussed
    break and continue statements, which provide a mechanism for abruptly ending an
    entire loop or the current repetition of a loop, respectively. Armed with control
    structures like loops and choice statements, you’ll be able to write sophisticated
    programs that perform repetitive tasks and make decisions in response to the current
    conditions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了 `while` 循环、`do...while` 循环和 `for` 循环，这些循环提供了不同的方式来重复执行一系列语句。关键在于如何决定循环的重复次数：可以设置循环停止的条件，如
    `while` 或 `do...while` 循环，或者指定固定的重复次数，如 `for` 循环。除了这些基本的循环结构外，我们还讨论了 `break` 和
    `continue` 语句，分别提供了强制结束整个循环或当前循环重复的机制。掌握了像循环和选择语句这样的控制结构后，你将能够编写出执行重复任务并根据当前条件作出决策的复杂程序。
- en: Exercises
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 1.   Use a do...while loop to keep taking in words input by the user until they
    enter one that begins with a capital letter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   使用 `do...while` 循环持续接受用户输入的单词，直到输入的单词以大写字母开头。
- en: 'Hint: Compare the string entered with the value returned by the ucfirst() function.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：将输入的字符串与 `ucfirst()` 函数返回的值进行比较。
- en: 2.   Use a break statement with a while (true) loop to keep taking in strings
    input by the user until one is numeric.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   使用 `while (true)` 循环配合 `break` 语句，持续接受用户输入的字符串，直到输入的字符串是数字。
- en: 'Hint: Use the is_numeric() function.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：使用 `is_numeric()` 函数。
- en: 3.   Use a continue statement in a for loop to print out all the multiples of
    3 up to 21 (3, 6, 9, and so on).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   在 `for` 循环中使用 `continue` 语句，打印出所有小于等于 21 的 3 的倍数（3、6、9，依此类推）。
