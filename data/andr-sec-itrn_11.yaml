- en: Chapter 11. NFC and Secure Elements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 NFC与安全元素
- en: This chapter gives a brief overview of near field communication (NFC) and secure
    elements (SEs), and explains how they’re integrated into mobile devices. While
    NFC has many uses, we focus on its card emulation mode, which is used to provide
    an interface to an SE integrated into a mobile device. Secure elements offer protected
    storage for private data, such as authentication keys, and provide a secure execution
    environment that can protect security-critical code. We’ll describe which types
    of SEs Android supports and introduce the APIs that Android applications can use
    to communicate with SEs. Finally, we’ll discuss host-based card emulation (HCE)
    and its Android implementations, and demonstrate how to implement an HCE application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要概述了近场通信（NFC）和安全元素（SE），并解释了它们如何集成到移动设备中。虽然NFC有许多用途，但我们将重点介绍其卡片仿真模式，该模式用于提供与集成在移动设备中的SE的接口。安全元素为私密数据提供受保护的存储，例如身份验证密钥，并提供一个安全执行环境，以保护安全关键代码。我们将描述Android支持的SE类型，并介绍Android应用程序可以使用的与SE通信的API。最后，我们将讨论基于主机的卡片仿真（HCE）及其在Android中的实现，并演示如何实现HCE应用程序。
- en: NFC Overview
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NFC概述
- en: '*NFC* is a technology that allows devices that are in close proximity (usually
    10 centimeters or less) to establish radio communication with each other and exchange
    data. NFC is not a single standard, but is based on a set of standards that define
    radio frequencies, communication protocols, and data exchange formats. NFC builds
    upon radio-frequency identification (RFID) technology and operates at the 13.56
    MHz frequency, allowing various data transmission rates such as 106kbps, 212kbps,
    and 424kbps.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*NFC*是一种允许处于近距离（通常为10厘米或更短）的设备之间建立无线通信并交换数据的技术。NFC不是单一的标准，而是基于一组标准，这些标准定义了射频、通信协议和数据交换格式。NFC基于射频识别（RFID）技术，并在13.56
    MHz频率下工作，支持106kbps、212kbps和424kbps等不同的数据传输速率。'
- en: 'NFC communication involves two devices: an initiator and a target. In *active
    mode*, both the initiator and the target have their own power supplies and each
    can transmit a radio signal in order to communicate with the other party. In *passive
    mode*, the target device does not have its own power source and is activated and
    powered by the electromagnetic field emitted by the initiator.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: NFC通信涉及两个设备：发起者和目标。在*主动模式*下，发起者和目标都有各自的电源，并且每个设备都可以发射无线信号以便与对方进行通信。在*被动模式*下，目标设备没有自己的电源，而是通过发起者发射的电磁场来激活并供电。
- en: When communicating in passive mode, the initiator is often called a *reader*,
    and the target a *tag*. The reader can be a dedicated device or be embedded in
    a general purpose device, such as a personal computer or a mobile phone. Tags
    come in various shapes and sizes and range from simple stickers with very limited
    amount of memory to contactless smart cards, which have an embedded CPU.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在被动模式下进行通信时，发起者通常被称为*读卡器*，而目标则被称为*标签*。读卡器可以是专用设备，也可以嵌入到通用设备中，例如个人电脑或手机。标签有各种形状和大小，从简单的、内存非常有限的贴纸到内嵌CPU的非接触智能卡。
- en: 'NFC devices can operate in three different modes: reader/writer (R/W), peer-to-peer
    (P2P), and card emulation (CE). In R/W mode, a device acts as an active initiator
    and can read and write data to external tags. In P2P mode, two NFC devices can
    actively exchange data using a bidirectional communication protocol. The CE mode
    allows an NFC device to emulate a tag or a contactless smart card. Android supports
    all three modes with some limitations. We give an overview of Android’s NFC architecture
    and show how to use each mode in the next section.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: NFC设备可以在三种不同模式下工作：读写（R/W）、点对点（P2P）和卡片仿真（CE）。在R/W模式下，设备作为主动发起者，可以读取和写入外部标签的数据。在P2P模式下，两台NFC设备可以使用双向通信协议进行主动的数据交换。CE模式允许NFC设备仿真标签或非接触式智能卡。Android支持这三种模式，但存在一些限制。我们将在下一节概述Android的NFC架构，并展示如何使用每种模式。
- en: Android NFC Support
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android NFC支持
- en: NFC support in Android was introduced in version 2.3 and the related architecture
    and features remained largely unchanged until version 4.4, which introduced HCE
    support.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Android在2.3版本中引入了NFC支持，相关架构和功能在版本4.4之前基本保持不变，而版本4.4引入了HCE支持。
- en: Android’s NFC implementation resides in the `NfcService` system service, part
    of the `Nfc` system application (package `com.android.nfc`). It wraps the native
    libraries required to drive each supported NFC controller; implements access control,
    tag discovery, and dispatch; and controls card emulation. Android doesn’t expose
    a low-level API to the functionality of `NfcService`, but instead offers an event-driven
    framework that allows interested applications to register for NFC events. This
    event-driven approach is used in all three NFC operating modes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Android的NFC实现位于`NfcService`系统服务中，属于`Nfc`系统应用（包名为`com.android.nfc`）。它封装了驱动每个支持的NFC控制器所需的本地库；实现了访问控制、标签发现和分发；并控制卡模拟。Android并未向外部暴露`NfcService`的低级API，而是提供了一个事件驱动框架，允许感兴趣的应用程序注册NFC事件。这种事件驱动的方法在所有三种NFC操作模式中均有使用。
- en: Reader/Writer Mode
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读/写模式
- en: NFC-enabled Android applications can’t directly set the device in R/W mode.
    Instead, they declare the type of tags they’re interested in, and Android’s tag
    dispatch system selects and starts the matching application when it discovers
    a tag.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 启用NFC的Android应用程序不能直接将设备设置为读/写模式。相反，它们声明自己感兴趣的标签类型，当Android的标签分发系统发现标签时，选择并启动匹配的应用程序。
- en: 'The tag dispatch system both uses the tag technology (discussed shortly) and
    parses tag contents in order to decide which application to dispatch the tag to.
    The tag dispatch system uses three intent actions to notify applications about
    the discovered tag: `ACTION_NDEF_DISCOVERED`, `ACTION_TECH_DISCOVERED`, and `ACTION_TAG_DISCOVERED`.
    The `ACTION_NDEF_DISCOVERED` intent has the highest priority and is sent when
    Android discovers a tag that is formatted using the standard NFC Data Exchange
    Format (NDEF)^([[111](#ftn.ch11fn01)]) and that contains a recognized data type.
    The `ACTION_TECH_DISCOVERED` intent is sent when the scanned tag does not contain
    NDEF data or the data format is not recognized by applications that can handle
    the discovered tag technology. If no applications can handle `ACTION_NDEF_DISCOVERED`
    or `ACTION_TECH_DISCOVERED`, the `NfcService` sends the generic `ACTION_TAG_DISCOVERED`
    intent. Tag dispatch events are delivered only to activities, and therefore cannot
    be processed in the background without user interaction.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 标签分发系统既使用标签技术（稍后讨论），又解析标签内容，以决定将标签分发到哪个应用程序。标签分发系统使用三个意图动作来通知应用程序发现的标签：`ACTION_NDEF_DISCOVERED`、`ACTION_TECH_DISCOVERED`和`ACTION_TAG_DISCOVERED`。`ACTION_NDEF_DISCOVERED`意图具有最高优先级，当Android发现一个使用标准NFC数据交换格式（NDEF）格式化的标签，并且该标签包含已识别的数据类型时，便会发送该意图。`ACTION_TECH_DISCOVERED`意图则在扫描的标签不包含NDEF数据或数据格式不被能够处理已发现标签技术的应用程序所识别时发送。如果没有应用程序可以处理`ACTION_NDEF_DISCOVERED`或`ACTION_TECH_DISCOVERED`，`NfcService`会发送通用的`ACTION_TAG_DISCOVERED`意图。标签分发事件仅传递给活动，因此无法在没有用户交互的情况下在后台处理。
- en: Registering for Tag Dispatch
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册标签分发
- en: Applications register for NFC events using the standard intent filter system
    by declaring the intents that an NFC-enabled activity supports in *AndroidManifest.xml*,
    as shown in [Example 11-1](ch11.html#manifest_file_of_an_nfc-enabled_applicat
    "Example 11-1. Manifest file of an NFC-enabled application").
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通过声明NFC启用的活动所支持的意图，在*AndroidManifest.xml*中使用标准的意图过滤器系统注册NFC事件，如[示例11-1](ch11.html#manifest_file_of_an_nfc-enabled_applicat
    "示例11-1. NFC启用应用程序的清单文件")所示。
- en: Example 11-1. Manifest file of an NFC-enabled application
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例11-1. NFC启用应用程序的清单文件
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in this listing, the application first requests the `android.permission.NFC`
    permission ➊, which is required to access the NFC controller, and then declares
    an activity that handles NFC events, `NfcActivity` ➋. The activity registers three
    intent filters; one for each tag discovery event. The application declares that
    it can handle NDEF data with the *text/plain* MIME type by specifying the `mimeType`
    attribute of the `<data>` tag in the `NDEF_DISCOVERED` intent filter ➌. `NfcActivity`
    also declares that it can handle the `TECH_DISCOVERED` intent ➍, which is sent
    if the scanned tag uses one of the technologies specified in the associated metadata
    XML resource file ➏. Finally, the application requests that it be notified about
    all discovered NFC tags by adding the catch-all `TAG_DISCOVERED` intent filter
    ➎.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如该清单所示，应用程序首先请求`android.permission.NFC`权限 ➊，该权限用于访问NFC控制器，然后声明一个处理NFC事件的活动`NfcActivity`
    ➋。该活动注册了三个意图过滤器，每个过滤器对应一个标签发现事件。应用程序声明它可以通过在`NDEF_DISCOVERED`意图过滤器的`<data>`标签中指定`mimeType`属性，来处理具有*text/plain*
    MIME类型的NDEF数据 ➌。`NfcActivity`还声明它可以处理`TECH_DISCOVERED`意图 ➍，如果扫描的标签使用关联的元数据XML资源文件中指定的某种技术，则会发送此意图
    ➏。最后，应用程序通过添加通配符`TAG_DISCOVERED`意图过滤器 ➎，请求在发现所有NFC标签时得到通知。
- en: If more than one activity that supports the scanned tag is found, Android shows
    a selection dialog, allowing the user to select which activity should handle the
    tag. Applications already in the foreground can short-circuit this selection by
    calling the `NfcAdapter.enableForegroundDispatch()` method. Such an application
    will be given priority over all other matching applications and will automatically
    receive the NFC intent when it’s in the foreground.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到多个支持扫描标签的活动，Android会显示一个选择对话框，允许用户选择哪个活动处理该标签。已经在前台的应用程序可以通过调用`NfcAdapter.enableForegroundDispatch()`方法来绕过此选择。这样的应用程序将在所有其他匹配的应用程序中优先处理，并且当应用程序处于前台时，会自动接收NFC意图。
- en: Tag Technologies
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签技术
- en: A *tag technology* is an abstract term that describes a concrete NFC tag. The
    tag technology is determined by the communication protocol the tag uses, its internal
    structure, or the features it offers. For example, a tag that uses the NFC-A protocol
    (based on ISO 14443-3A)^([[112](#ftn.ch11fn02)]) for communication matches the
    *NfcA* technology, and a tag that contains NDEF-formatted data matches the *Ndef*
    technology, regardless of the underlying communication protocol. (See the `TagTechnology`
    class reference documentation^([[113](#ftn.ch11fn03)]) for a full list of tag
    technologies supported by Android.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*标签技术*是一个抽象术语，用于描述具体的NFC标签。标签技术由标签使用的通信协议、其内部结构或其提供的功能决定。例如，使用NFC-A协议（基于ISO
    14443-3A）进行通信的标签与*NfcA*技术匹配，而包含NDEF格式数据的标签则与*Ndef*技术匹配，无论其底层通信协议如何。（有关Android支持的所有标签技术的完整列表，请参见`TagTechnology`类参考文档。）'
- en: An activity that specifies the `TECH_DISCOVERED` intent filter must provide
    an XML resource file that in turn specifies the concrete technologies it supports
    with a `<tech-list>` element. An activity is considered a match for a tag if one
    of the tech lists it declares is a subset of the technologies supported by the
    tag. Multiple tech lists can be declared in order to match different tags, as
    shown in [Example 11-2](ch11.html#declaring_technologies_to_match_using_te "Example 11-2. Declaring
    technologies to match using tech lists").
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指定了`TECH_DISCOVERED`意图过滤器的活动必须提供一个XML资源文件，该文件进一步指定它支持的具体技术，并使用`<tech-list>`元素。
    如果一个活动声明的技术列表是标签所支持的技术的子集，则认为该活动与标签匹配。 可以声明多个技术列表，以匹配不同的标签，如[示例 11-2](ch11.html#declaring_technologies_to_match_using_te
    "示例 11-2. 使用技术列表声明匹配的技术")所示。
- en: Example 11-2. Declaring technologies to match using tech lists
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-2. 使用技术列表声明匹配的技术
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the first tech list ➊ will match tags that provide a communication interface
    compatible with ISO 14443-4 (ISO-DEP), and which are implemented using the NFC-A
    technology (usually used by NXP contactless smart cards); the second tech list
    ➋ matches tags that use the NFC-F technology (typically Felica cards). Because
    both tech lists are defined independently, our example `NfcActivity` (see [Example 11-1](ch11.html#manifest_file_of_an_nfc-enabled_applicat
    "Example 11-1. Manifest file of an NFC-enabled application")) will be notified
    when either a contactless NXP smart card or a Felica card or tag is scanned.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个技术列表 ➊ 将匹配提供与ISO 14443-4（ISO-DEP）兼容的通信接口的标签，这些标签使用NFC-A技术实现（通常用于NXP非接触智能卡）；第二个技术列表
    ➋ 匹配使用NFC-F技术的标签（通常是Felica卡）。由于这两个技术列表是独立定义的，我们的示例`NfcActivity`（参见[示例 11-1](ch11.html#manifest_file_of_an_nfc-enabled_applicat
    "示例 11-1. 启用NFC应用程序的清单文件")）将在扫描到NXP非接触智能卡或Felica卡或标签时收到通知。
- en: Reading a Tag
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取标签
- en: After the tag dispatch system selects an activity to handle the scanned tag,
    it creates an NFC intent object and passes it to the selected activity. The activity
    can then use the `EXTRA_TAG` extra to obtain a `Tag` object representing the scanned
    tag and call its methods in order to read or write to the tag. (Tags that contain
    NDEF data also provide the `EXTRA_NDEF_MESSAGES` extra, which contains an array
    of NDEF messages parsed from the tag.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签调度系统选择一个活动来处理扫描到的标签后，它会创建一个NFC意图对象，并将其传递给选中的活动。活动可以通过`EXTRA_TAG`额外数据来获取一个表示扫描到标签的`Tag`对象，并调用其方法以读取或写入标签。（包含NDEF数据的标签还会提供`EXTRA_NDEF_MESSAGES`额外数据，其中包含从标签解析出来的NDEF消息数组。）
- en: A concrete `Tag` object representing the underlying tag technology can be obtained
    using the static `get()` method of the corresponding technology class, as shown
    in [Example 11-3](ch11.html#obtaining_a_concrete_tag_instance_from_t "Example 11-3. Obtaining
    a concrete Tag instance from the NFC intent"). If the `Tag` object does not support
    the requested technology, the `get()` method returns `null.`
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用相应技术类的静态`get()`方法获取表示底层标签技术的具体`Tag`对象，如[示例 11-3](ch11.html#obtaining_a_concrete_tag_instance_from_t
    "示例 11-3. 从NFC意图中获取具体的Tag实例")所示。如果`Tag`对象不支持请求的技术，`get()`方法将返回`null`。
- en: Example 11-3. Obtaining a concrete `Tag` instance from the NFC intent
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-3. 从NFC意图中获取具体的`Tag`实例
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using Reader Mode
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用阅读器模式
- en: In addition to the intent-based tag dispatch system, Android 4.4 adds a new
    method that activities can use to obtain a live `Tag` object, called reader mode.
    Reader mode guarantees that while the target activity is in the foreground, all
    other operation modes supported by the NFC controller (such as peer-to-peer and
    card emulation) are disabled. This mode is helpful when scanning an active NFC
    device, such as another Android device in host-based emulation mode, which could
    trigger point-to-point communication and thus take control away from the current
    foreground activity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于意图的标签调度系统，Android 4.4还添加了一种新的方法，活动可以用来获取一个实时的`Tag`对象，称为阅读器模式。阅读器模式确保在目标活动处于前景时，NFC控制器支持的所有其他操作模式（如点对点模式和卡片模拟模式）都会被禁用。当扫描一个活跃的NFC设备时，这种模式非常有用，比如另一台处于主机模拟模式的Android设备，它可能会触发点对点通信，从而将控制权转移给当前的前景活动。
- en: Activities can enable reader mode by calling the `enableReaderMode()` method
    of the `NfcAdapter` class,^([[114](#ftn.ch11fn04)]) as shown in [Example 11-4](ch11.html#enabling_reader_mode_and_obtaining_a_tag
    "Example 11-4. Enabling reader mode and obtaining a Tag object using ReaderCallback").
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 活动可以通过调用`NfcAdapter`类的`enableReaderMode()`方法来启用阅读器模式，如[示例 11-4](ch11.html#enabling_reader_mode_and_obtaining_a_tag
    "示例 11-4. 启用阅读器模式并使用ReaderCallback获取Tag对象")所示。
- en: Example 11-4. Enabling reader mode and obtaining a `Tag` object using `ReaderCallback`
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-4. 启用阅读器模式并使用`ReaderCallback`获取`Tag`对象
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the activity enables reader mode when it comes to the foreground
    by calling the `enableReaderMode()` method ➊ (the activity should disable reader
    mode using the matching `disableReaderMode()` method when it leaves the foreground),
    and obtains a `Tag` instance directly (without an intermediate intent) via the
    `onTagDiscovered()` callback ➋. The `Tag` object is then used in the same way
    as in intent-based dispatch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，活动通过调用`enableReaderMode()`方法 ➊ 来启用前景模式中的阅读器模式（当活动离开前景时，应该使用相应的`disableReaderMode()`方法禁用阅读器模式），并通过`onTagDiscovered()`回调
    ➋ 直接获取一个`Tag`实例（无需中间的意图）。然后，`Tag`对象的使用方式与基于意图的调度方式相同。
- en: Peer-to-Peer Mode
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点对点模式
- en: Android implements a limited NFC P2P mode data exchange between devices using
    the proprietary NDEF push and the standard Simple NDEF Exchange Protocol (SNEP)
    protocols.^([[115](#ftn.ch11fn05)]) Android devices can exchange a single NDEF
    message with any device that supports either of these protocols, but the P2P mode
    is typically used with another Android device in order to implement the so-called
    Android Beam feature.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Android 实现了一种有限的 NFC P2P 模式数据交换，通过专有的 NDEF 推送和标准的简单 NDEF 交换协议（SNEP）协议进行交换。^([[115](#ftn.ch11fn05)])
    Android 设备可以与支持这两种协议的任何设备交换单个 NDEF 消息，但 P2P 模式通常与其他 Android 设备一起使用，以实现所谓的 Android
    Beam 功能。
- en: In addition to NDEF messages, Android Beam allows for the transfer of larger
    data objects, such as photos and videos, which cannot fit in a single NDEF message
    by creating a temporary Bluetooth connection between devices. This process is
    called *NFC handover* and was added in Android 4.1.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 NDEF 消息，Android Beam 还允许传输更大的数据对象，如照片和视频，这些数据无法通过单个 NDEF 消息传输。通过在设备之间创建一个临时的蓝牙连接，可以实现这一过程。这一过程称为*NFC
    交接*，并在 Android 4.1 中加入了此功能。
- en: NDEF message exchange in P2P mode is enabled by calling the `setNdefPushMessage()`
    or `setNdefPushMessageCallback()` methods of the `NfcAdapter` class. (See the
    official NFC API guide^([[116](#ftn.ch11fn06)]) for more details and sample code.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 P2P 模式下的 NDEF 消息交换是通过调用 `NfcAdapter` 类的 `setNdefPushMessage()` 或 `setNdefPushMessageCallback()`
    方法来启用的。（有关更多详情和示例代码，请参见官方的 NFC API 指南^([[116](#ftn.ch11fn06)])。）
- en: Card Emulation Mode
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卡模拟模式
- en: As mentioned in “[NFC Overview](ch11.html#nfc_overview "NFC Overview")”, CE
    mode allows an Android device to emulate a contactless smart card or an NFC tag.
    In CE mode, the device receives commands over NFC, processes them, and sends replies,
    again over NFC. The component responsible for processing commands can be either
    a hardware secure element (as discussed in the next section) connected to the
    device’s NFC controller, or an Android application running on the device (when
    in host-based card emulation, HCE).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 “[NFC 概述](ch11.html#nfc_overview "NFC Overview")” 中所述，CE 模式允许 Android 设备模拟一张非接触式智能卡或
    NFC 标签。在 CE 模式下，设备通过 NFC 接收命令，处理这些命令，并通过 NFC 返回响应。负责处理命令的组件可以是一个硬件安全元件（如下一节所讨论）连接到设备的
    NFC 控制器，或者是一个运行在设备上的 Android 应用程序（当处于基于主机的卡模拟模式，HCE 时）。
- en: In the following sections, we’ll discuss secure elements in mobile devices,
    and the Android APIs that applications can use to communicate with SEs. We’ll
    also describe how Android implements HCE and demonstrate how to create an application
    that enables card emulation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论移动设备中的安全元件，以及应用程序可以用来与安全元件通信的 Android API。我们还将描述 Android 如何实现
    HCE，并展示如何创建一个使能卡模拟的应用程序。
- en: Secure Elements
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全元件
- en: A *secure element (SE)* is a tamper-resistant smart card chip capable of running
    smart card applications (called *applets* or *cardlets*) with a certain level
    of security and isolation. A smart card is essentially a minimal computing environment
    on a single chip, complete with a CPU, ROM, EEPROM, RAM, and I/O port. Recent
    cards also include cryptographic co-processors that implement common algorithms
    such as AES and RSA.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *安全元件 (SE)* 是一个防篡改的智能卡芯片，能够以一定的安全性和隔离性运行智能卡应用（称为 *小程序* 或 *卡片*）。智能卡本质上是一个包含
    CPU、ROM、EEPROM、RAM 和 I/O 端口的最小计算环境。现代智能卡还包括加密协处理器，能够实现常见的算法，如 AES 和 RSA。
- en: Smart cards use various techniques to implement tamper resistance, making it
    quite hard to extract data by disassembling or analyzing the chip. Modern smart
    cards come pre-programmed with a multi-application OS that takes advantage of
    the hardware’s memory protection features to ensure that each application’s data
    is only available to itself. Application installation and (optionally) access
    is controlled by requiring the use of cryptographic keys for each operation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 智能卡采用各种技术来实现防篡改，使得通过拆解或分析芯片来提取数据变得非常困难。现代智能卡预装了多应用操作系统，利用硬件的内存保护功能确保每个应用程序的数据仅对其自身可用。应用程序的安装和（可选的）访问通过要求每次操作使用加密密钥来控制。
- en: The SE can be integrated in mobile devices as a Universal Integrated Circuit
    Card (UICC, commonly known as a *SIM card*) embedded in the handset or connected
    to a SD card slot. If the device supports NFC, the SE is usually connected to
    (or embedded into) the NFC controller, making it possible to communicate with
    the SE wirelessly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SE可以集成在移动设备中，作为通用集成电路卡（UICC，通常称为*SIM卡*），嵌入在手机中或连接到SD卡槽。如果设备支持NFC，SE通常与NFC控制器连接（或嵌入其中），使得可以无线与SE通信。
- en: Smart cards have been around since the 1970s and are now used in applications
    ranging from pre-paid phone calls and transit ticketing to credit cards and VPN
    credential storage. Because an SE installed in a mobile device has equivalent
    or superior capabilities to that of a smart card, it can theoretically be used
    for any application that physical smart cards are currently used for. Additionally,
    because an SE can host multiple applications, it has the potential to replace
    the bunch of cards people use daily with a single device. Furthermore, because
    the SE can be controlled by the device’s OS, access to it can be restricted by
    requiring additional authentication (PIN, passphrase, or code signature) to enable
    it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 智能卡自1970年代以来就已经出现，并且现在被广泛用于从预付费电话和交通票务到信用卡和VPN凭证存储等各种应用中。由于安装在移动设备中的SE具有与智能卡等效或更强的功能，因此理论上可以用于目前智能卡所使用的任何应用程序。此外，由于SE可以托管多个应用程序，它有潜力用一个设备替代人们日常使用的多张卡片。此外，由于SE可以由设备的操作系统控制，可以通过要求额外的身份验证（如PIN码、密码短语或代码签名）来限制对其的访问。
- en: One of the main applications of SEs in mobile devices is that of emulating contactless
    payment cards, and the goal of enabling mobile payments has indeed been the driving
    force behind SE deployment. Aside from financial applications, mobile SEs could
    be used to emulate other contactless cards that are in wide use, such as access
    cards, loyalty cards, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SE在移动设备中的一个主要应用是模拟非接触支付卡，而启用移动支付的目标确实是推动SE部署的动力。除了金融应用外，移动SE还可以用于模拟其他广泛使用的非接触卡，如门禁卡、忠诚卡等。
- en: 'Mobile SEs could also be used to enhance the security of apps that deal with
    sensitive information or algorithms: The security-critical part of the app, such
    as credential storage or license verification, can be implemented inside the SE
    in order to guarantee that it’s impervious to reverse engineering and information
    extraction. Other apps that can benefit from being implemented in the SE are One
    Time Password (OTP) generators and, of course, credential storage (for shared
    secret keys, or private keys in a PKI).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 移动SE也可以用来增强处理敏感信息或算法的应用程序的安全性：应用程序的安全关键部分，如凭证存储或许可证验证，可以在SE内部实现，从而确保其不易受到逆向工程和信息提取的攻击。其他可以从SE实现中受益的应用程序包括一次性密码（OTP）生成器，当然还有凭证存储（用于共享密钥或PKI中的私钥）。
- en: While it’s possible to implement SE-enabled apps today with standard tools and
    technologies, using them in practice on current commercial Android devices isn’t
    straightforward. We’ll discuss this in detail in “[Android SE Execution Environment](ch11.html#android_se_execution_environment
    "Android SE Execution Environment")”, but let’s first explore the types of SEs
    available on mobile devices, and the level of support they have in Android.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管今天可以使用标准工具和技术实现支持SE的应用程序，但在当前的商业Android设备上实际使用它们并不简单。我们将在“[Android SE执行环境](ch11.html#android_se_execution_environment
    "Android SE执行环境")”中详细讨论这一点，但首先让我们探索一下移动设备上可用的SE类型，以及它们在Android中的支持级别。
- en: SE Form Factors in Mobile Devices
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动设备中的SE形态
- en: '[Figure 11-1](ch11.html#android_nfc_and_se_components "Figure 11-1. Android
    NFC and SE components") shows a simplified block diagram of the components of
    an Android device as they relate to NFC and SE support, including the embedded
    SE (eSE) and the UICC. We’ll refer to the components in this diagram in our discussion
    of secure elements and host-based card emulation in the rest of this chapter.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-1](ch11.html#android_nfc_and_se_components "图11-1. Android NFC和SE组件")展示了一个简化的块图，描述了与NFC和SE支持相关的Android设备组件，包括嵌入式SE（eSE）和UICC。在我们讨论本章其余部分的安全元件和基于主机的卡模拟时，将引用此图中的组件。'
- en: In the following subsections, we briefly review the types of SEs available on
    Android devices, how they’re connected to other device components, and the methods
    the OS uses to communicate with each type of SE.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们简要回顾了Android设备上可用的SE类型、它们与其他设备组件的连接方式，以及操作系统如何与每种SE进行通信。
- en: '![Android NFC and SE components](figs/web/11fig01.png.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Android NFC和SE组件](figs/web/11fig01.png.jpg)'
- en: Figure 11-1. Android NFC and SE components
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1. Android NFC和SE组件
- en: UICC
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UICC
- en: Most mobile devices today have some kind of UICC. Although UICCs are smart cards
    that can host applications, because the UICC has traditionally only been connected
    to the baseband processor (not the application processor that runs the main device
    OS), they can’t be accessed directly from Android. All communication goes through
    the Radio Interface Layer (RIL), which is essentially a proprietary IPC interface
    to the baseband.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前大多数移动设备都配备了某种类型的UICC。虽然UICC是可以托管应用的智能卡，但由于UICC传统上只与基带处理器连接（而不是运行主设备操作系统的应用处理器），因此无法直接从Android进行访问。所有通信都通过无线接口层（RIL）进行，RIL本质上是一个专有的IPC接口，用于与基带进行通信。
- en: Communication with the UICC SE is carried out using extended AT commands (`AT+CCHO`,
    `AT+CCHC`, `AT+CGLA` as defined by 3GPP TS 27.007),^([[117](#ftn.ch11fn07)]) which
    the current Android telephony manager does not support. The SEEK for Android project^([[118](#ftn.ch11fn08)])
    provides patches to implement the needed commands, allowing for communication
    with the UICC via the SmartCard API, which is a reference implementation of the
    SIMalliance Open Mobile API specification^([[119](#ftn.ch11fn09)]) (discussed
    in “[Using the OpenMobile API](ch11.html#using_the_openmobile_api "Using the OpenMobile
    API")”). However, as with most components that talk directly to the hardware in
    Android, the RIL consists of an open source part (*rild*), and a proprietary library
    (*libXXX-ril.so*). In order to support communication with the UICC secure element,
    support must be added both to the *rild* and to the underlying proprietary library.
    The choice of whether to add that support is left to hardware vendors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与UICC SE的通信通过扩展的AT命令（`AT+CCHO`、`AT+CCHC`、`AT+CGLA`，如3GPP TS 27.007定义）进行，^([[117](#ftn.ch11fn07)])，当前的Android电话管理器不支持这些命令。Android的SEEK项目^([[118](#ftn.ch11fn08)])提供了补丁来实现所需的命令，从而通过SmartCard
    API与UICC进行通信，SmartCard API是SIMalliance开放移动API规范的参考实现^([[119](#ftn.ch11fn09)])（详见“[使用OpenMobile
    API](ch11.html#using_the_openmobile_api "Using the OpenMobile API")”）。然而，正如与Android中的大多数硬件直接通信的组件一样，RIL由一个开源部分（*rild*）和一个专有库（*libXXX-ril.so*）组成。为了支持与UICC安全元件的通信，必须同时在*rild*和底层专有库中添加支持。是否添加该支持的决定权由硬件厂商来决定。
- en: As of this writing, the SmartCard API has not been integrated into mainline
    Android (although the AOSP source tree includes an empty *packages/ apps/SmartCardService/*
    directory). However, Android devices from major vendors ship with an implementation
    of the SmartCard API, which allows communication from the UICC to third-party
    applications (subject to various access restrictions).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，SmartCard API尚未集成到主线Android中（尽管AOSP源码树中包含一个空的*packages/apps/SmartCardService/*目录）。然而，来自主要厂商的Android设备配备了SmartCard
    API的实现，允许UICC与第三方应用进行通信（受各种访问限制的约束）。
- en: The Single Wire Protocol (SWP) offers an alternative way to use the UICC as
    an SE. SWP is used to connect the UICC to a NFC controller, allowing the NFC controller
    to expose the UICC to external readers when in card emulation mode. The NFC controllers
    built into recent Nexus devices (such as the Broadcom BCM20793M in the Nexus 5)
    support SWP, but this functionality is disabled by default. (It can be enabled
    by changing the configuration file of the *libnfc-brcm* library on the Nexus 5.)
    A standard API to switch between the UICC, the embedded SE (if available), and
    HCE when in card emulation mode is currently not exposed, but the “off-host” routing
    functionality available in Android 4.4 can theoretically route commands to the
    UICC (see “[APDU Routing](ch11.html#apdu_routing "APDU Routing")” for details).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 单线协议（SWP）提供了一种将UICC用作SE的替代方式。SWP用于将UICC连接到NFC控制器，允许NFC控制器在卡模拟模式下将UICC暴露给外部读卡器。近期的Nexus设备（如Nexus
    5中的Broadcom BCM20793M）内置的NFC控制器支持SWP，但此功能默认是禁用的。（通过修改Nexus 5上*libnfc-brcm*库的配置文件，可以启用此功能。）目前没有公开的标准API来在卡模拟模式下切换UICC、嵌入式SE（如果有的话）和HCE，但Android
    4.4中可用的“离线”路由功能理论上可以将命令路由到UICC（详情请参见“[APDU路由](ch11.html#apdu_routing "APDU Routing")”）。
- en: microSD-Based SE
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于microSD的SE
- en: Another form factor for an SE is an *Advanced Security SD card (ASSD)*,^([[120](#ftn.ch11fn10)])
    which is basically an SD card with an embedded SE chip. When connected to an Android
    device with an SD card slot, running a SEEK-patched Android version, the SE can
    be accessed via the SmartCard API. However, Android devices with an SD card slot
    are becoming the exceptions rather than the norm, so it’s unlikely that ASSD Android
    support will make it to the mainstream. Additionally, even when available, recent
    Android versions treat SD cards as secondary storage devices and allow access
    to them only via a very high-level, restrictive API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SE的另一种形式因子是*高级安全SD卡（ASSD）*，^([[120](#ftn.ch11fn10)])，它基本上是一张带有嵌入式SE芯片的SD卡。当连接到带有SD卡插槽的Android设备时，并且运行SEEK修改版的Android系统时，可以通过智能卡API访问SE。然而，带有SD卡插槽的Android设备已经成为例外而非常态，因此ASSD在Android上的支持不太可能成为主流。此外，即使在可用的情况下，最近的Android版本将SD卡视为次级存储设备，只能通过非常高层次、有限制的API进行访问。
- en: Embedded SE
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌入式SE
- en: An *embedded SE (eSE)* is not a distinct device but is usually integrated with
    the NFC controller and housed in the same enclosure. An example of an eSE is NXP’s
    PN65N chip, which combines the PN544 NFC radio controller with the P5CN072 SE
    (part of the SmartMX series).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*嵌入式SE（eSE）*并不是一个独立的设备，而通常与NFC控制器集成在一起，并被封装在同一个外壳中。eSE的一个例子是NXP的PN65N芯片，它将PN544
    NFC无线电控制器与P5CN072 SE（智能MX系列的一部分）结合在一起。'
- en: The first mainstream Android device to feature an embedded SE was the Nexus
    S, which also introduced NFC support to Android and was built using the PN65N
    controller. Its successors, the Galaxy Nexus and the Nexus 4, also came equipped
    with an eSE. However, recent Google-branded devices, such as the Nexus 5 and Nexus
    7 (2013), have deprecated the eSE in favor of host-based card emulation and do
    not include an eSE.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一款搭载嵌入式SE的主流Android设备是Nexus S，它也首次为Android引入了NFC支持，并且采用了PN65N控制器。其后继产品，Galaxy
    Nexus和Nexus 4，也都配备了eSE。然而，最近的Google品牌设备，如Nexus 5和Nexus 7（2013款），已不再使用eSE，而是采用主机卡模拟，并且不再包括eSE。
- en: 'The embedded SE is connected to the NFC controller through a SignalIn/SignalOut
    connection (S2C), standardized as NFC Wired Interface (NFC-WI),^([[121](#ftn.ch11fn11)])
    and has three modes of operation: off, wired, and virtual. In off mode, there’s
    no communication with the SE. In wired mode, the SE is visible to the Android
    OS as if it were a contactless smart card connected to the NFC reader. In virtual
    mode, the SE is visible to external readers as if the phone were a contactless
    smart card. These modes are mutually exclusive, so we can communicate with the
    SE either via the contactless interface (that is, from an external reader), or
    through the wired interface (that is, from an Android app). The next section shows
    how to use the wired mode to communicate with the eSE from an Android app.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式SE通过SignalIn/SignalOut连接（S2C）与NFC控制器连接，并标准化为NFC无线接口（NFC-WI），^([[121](#ftn.ch11fn11)])，具有三种操作模式：关闭模式、无线模式和虚拟模式。在关闭模式下，与SE没有通信。在无线模式下，SE对Android操作系统可见，就像它是一个连接到NFC读卡器的非接触式智能卡一样。在虚拟模式下，SE对外部读卡器可见，就像手机是一个非接触式智能卡。这些模式是互斥的，因此我们可以通过非接触式接口（即，从外部读卡器）或通过有线接口（即，从Android应用程序）与SE进行通信。下一节将展示如何使用有线模式从Android应用程序与eSE通信。
- en: Accessing the Embedded SE
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问嵌入式SE
- en: As of this writing, no public Android SDK API allows communication with the
    embedded SE, but recent Android versions include an optional library called *nfc_extras*,
    which offers a stable interface to the eSE. This section demonstrates how to configure
    Android to allow eSE access to certain Android applications, as well as how to
    use the *nfc_extras* library.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文写作时，没有公开的Android SDK API允许与嵌入式SE进行通信，但最近的Android版本包括一个名为*nfc_extras*的可选库，提供了与eSE的稳定接口。本节将演示如何配置Android，以允许某些Android应用程序访问eSE，并展示如何使用*nfc_extras*库。
- en: Card emulation, and consequently, internal APIs for accessing the embedded SE
    were introduced in Android 2.3.4 (the version that introduced Google Wallet).
    Those APIs are hidden from SDK applications and using them required system signature
    permissions (`WRITE_SECURE_SETTINGS` or `NFCEE_ADMIN`) in Android 2.3.4 and subsequent
    2.3.x releases, as well as in the initial Android 4.0 release (API Level 14).
    A signature permission is quite restrictive because it allows only parties that
    control the platform signature keys to distribute apps that can use the eSE.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 卡模拟和随之而来的用于访问嵌入式 SE 的内部 API 在 Android 2.3.4（引入了 Google Wallet 的版本）中引入。这些 API
    对 SDK 应用程序是隐藏的，使用它们需要在 Android 2.3.4 及其后续版本 2.3.x，以及初始的 Android 4.0 发布（API 级别
    14）中使用系统签名权限（`WRITE_SECURE_SETTINGS` 或 `NFCEE_ADMIN`）。签名权限非常限制，因为它仅允许控制平台签名密钥的方分发能够使用
    eSE 的应用程序。
- en: Android 4.0.4 (API Level 15) lifted this restriction by replacing the signature
    permission with signing certificate whitelisting at the OS level. While this still
    requires modifying core OS files, and thus vendor cooperation, there is no need
    to sign SE applications with the vendor key, which greatly simplifies distribution.
    Additionally, since the whitelist is maintained in a file, it can easily be updated
    using an OTA to add support for more SE applications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.0.4（API 级别 15）通过在操作系统级别将签名权限替换为签名证书白名单，从而取消了此限制。虽然这仍然需要修改核心操作系统文件，因此需要厂商合作，但无需使用厂商密钥对
    SE 应用程序进行签名，这大大简化了分发。此外，由于白名单存储在文件中，可以通过 OTA 轻松更新，以便为更多的 SE 应用程序添加支持。
- en: Granting Access to the eSE
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授予 eSE 访问权限
- en: 'The new whitelisting access control approach is implemented by the `NfceeAccessControl`
    class and enforced by the system `NfcService`. The `NfceeAccessControl` class
    reads the whitelist from */etc/nfcee_access.xml*, which is an XML file that stores
    a list of signing certificates and package names that are allowed to access the
    eSE. Access can be granted both to all apps signed by a particular certificate’s
    private key (if no package name is specified), or to a single package (app) only.
    [Example 11-5](ch11.html#contents_of_the_nfceeunderscoreaccessdot "Example 11-5. Contents
    of the nfcee_access.xml file") shows how the contents of the *nfcee_access.xml*
    file might appear:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 新的白名单访问控制方法通过 `NfceeAccessControl` 类实现，并由系统 `NfcService` 强制执行。`NfceeAccessControl`
    类从 */etc/nfcee_access.xml* 读取白名单，该 XML 文件存储了允许访问 eSE 的签名证书和包名列表。可以授予所有由特定证书的私钥签名的应用程序访问权限（如果未指定包名），也可以仅授予单个包（应用）的访问权限。[示例
    11-5](ch11.html#contents_of_the_nfceeunderscoreaccessdot "示例 11-5. nfcee_access.xml
    文件的内容")展示了 *nfcee_access.xml* 文件的内容可能如下所示：
- en: Example 11-5. Contents of the nfcee_access.xml file
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-5. nfcee_access.xml 文件的内容
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This configuration allows SE access to the `com.example.nfc` package ➋ if it
    is signed by the specified signing certificate ➊. On production devices, this
    file usually contains only the Google Wallet app signing certificate, thus restricting
    eSE access to Google Wallet.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置允许 `com.example.nfc` 包访问 SE ➋，前提是该包由指定的签名证书 ➊ 签名。在生产设备上，该文件通常仅包含 Google Wallet
    应用的签名证书，从而将 eSE 访问权限限制为 Google Wallet。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As of April 2014, Google Wallet is supported only on Android 4.4 and later,
    and uses HCE rather than the eSE.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至 2014年4月，Google Wallet 仅支持 Android 4.4 及更高版本，并使用 HCE 而非 eSE。*'
- en: After an application’s signing certificate has been added to *nfcee_access.xml*,
    no permissions other than the standard NFC permission are required to access the
    eSE. In addition to whitelisting the app’s signing certificate, the *nfc_extras*
    library must be explicitly added to the app’s manifest and marked as required
    with the `<uses-library>` tag in order to enable eSE access (because the library
    is optional, it’s not loaded by default), as shown in [Example 11-6](ch11.html#adding_the_nfcunderscoreextras_library_t
    "Example 11-6. Adding the nfc_extras library to AndroidManifest.xml") at ➊.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的签名证书已添加到 *nfcee_access.xml* 后，除了标准的 NFC 权限外，不需要其他权限来访问 eSE。除了将应用程序的签名证书列入白名单外，还必须显式将
    *nfc_extras* 库添加到应用的清单文件中，并使用 `<uses-library>` 标签将其标记为必需，以启用 eSE 访问（因为该库是可选的，默认情况下不会加载），如[示例
    11-6](ch11.html#adding_the_nfcunderscoreextras_library_t "示例 11-6. 添加 nfc_extras
    库到 AndroidManifest.xml")所示 ➊。
- en: Example 11-6. Adding the nfc_extras library to AndroidManifest.xml
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-6. 将 nfc_extras 库添加到 AndroidManifest.xml
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the NfcExecutionEnvironment API
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 NfcExecutionEnvironment API
- en: Android’s eSE access API isn’t based on a standard smart card communication
    API, such as JSR 177^([[122](#ftn.ch11fn12)]) or the Open Mobile API, but instead
    offers a very basic communication interface, implemented in the `NfcExecutionEnvironment`
    class. The class has only three public methods, as shown in [Example 11-7](ch11.html#nfcexecutionenvironment_api
    "Example 11-7. NfcExecutionEnvironment API").
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Android的eSE访问API并非基于标准智能卡通信API，如JSR 177^([[122](#ftn.ch11fn12)])或Open Mobile
    API，而是提供了一个非常基础的通信接口，实现在`NfcExecutionEnvironment`类中。该类只有三个公共方法，具体方法参见[示例 11-7](ch11.html#nfcexecutionenvironment_api
    "示例 11-7. NfcExecutionEnvironment API")。
- en: Example 11-7. `NfcExecutionEnvironment` API
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-7. `NfcExecutionEnvironment` API
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This simple interface is sufficient to communicate with the SE, but in order
    to use it you first need to obtain an instance of the `NfcExecutionEnvironment`
    class. An instance can be obtained from the `NfcAdapterExtras` class, which is
    in turn accessed via its static `get()` method, as shown in [Example 11-8](ch11.html#using_the_nfcexecutionenvironmen-id00025
    "Example 11-8. Using the NfcExecutionEnvironment API").
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的接口足以与SE进行通信，但要使用它，首先需要获取`NfcExecutionEnvironment`类的一个实例。可以通过`NfcAdapterExtras`类获取一个实例，而该类可以通过其静态方法`get()`进行访问，具体方法参见[示例
    11-8](ch11.html#using_the_nfcexecutionenvironmen-id00025 "示例 11-8. 使用 NfcExecutionEnvironment
    API")。
- en: Example 11-8. Using the `NfcExecutionEnvironment` API
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-8. 使用 `NfcExecutionEnvironment` API
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we first obtain an `NfcAdapterExtras` instance ➊, and then call its `getEmbeddedExecutionEnvironment()`
    method in order to obtain an interface to the eSE ➋. To be able to communicate
    with the eSE, we first open a connection ➌, and then use the `transceive()` method
    to send a command and get a response ➍. Finally, we close the connection using
    the `close()` method ➎.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先获取一个`NfcAdapterExtras`实例 ➊，然后调用它的`getEmbeddedExecutionEnvironment()`方法以获取eSE接口
    ➋。为了与eSE进行通信，我们首先打开一个连接 ➌，然后使用`transceive()`方法发送命令并获取响应 ➍。最后，使用`close()`方法关闭连接
    ➎。
- en: eSE-Related Broadcasts
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: eSE相关广播
- en: An SE-enabled app needs to be notified of NFC events such as RF field detection,
    as well as of events pertaining to the eSE and the applets installed on it, such
    as applet selection via the NFC interface, in order to be able to change state
    accordingly. Because disclosure of such events to malicious applications can lead
    to leaking of sensitive information and denial of service attacks, access to eSE-related
    events must be limited to trusted applications only.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 启用SE的应用需要接收NFC事件通知，如射频场检测以及与eSE和安装在其上的小程序相关的事件，例如通过NFC接口选择小程序，以便能够相应地改变状态。由于将这些事件泄露给恶意应用可能导致敏感信息泄露和拒绝服务攻击，因此对eSE相关事件的访问必须限制为仅信任的应用。
- en: In Android, global events are implemented by using broadcasts, and applications
    can create and register broadcast receivers that receive the broadcasts the app
    is interested in. Access to eSE-related broadcasts can be controlled with standard
    Android signature-based permissions, but this approach has the disadvantage that
    only apps signed with the platform certificate can receive eSE events, thus limiting
    SE-enabled apps to those created by the device manufacturer or mobile network
    operator (MNO). To avoid this limitation, Android uses the same mechanism employed
    to control eSE access; namely, whitelisting application certificates, in order
    to control the scope of applications that can receive eSE-related broadcasts.
    Any application whose signing certificate (and optionally package name) is registered
    in *nfcee_access.xml* can receive eSE-related broadcasts by registering a receiver
    like the one shown in [Example 11-9](ch11.html#declaring_a_broadcast_receiver_for_ese-r
    "Example 11-9. Declaring a broadcast receiver for eSE-related events in AndroidManifest.xml").
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，全局事件是通过广播实现的，应用可以创建并注册广播接收器，接收应用感兴趣的广播。对eSE相关广播的访问可以通过标准的Android基于签名的权限来控制，但这种方法的缺点是只有使用平台证书签名的应用才能接收eSE事件，从而将启用SE的应用限制为设备制造商或移动网络运营商（MNO）创建的应用。为避免这种限制，Android使用了与控制eSE访问相同的机制；即，通过白名单应用程序证书，控制可以接收eSE相关广播的应用范围。任何在*nfcee_access.xml*中注册了签名证书（以及可选的包名）的应用，都可以通过注册接收器接收eSE相关广播，接收器的声明方式如[示例
    11-9](ch11.html#declaring_a_broadcast_receiver_for_ese-r "示例 11-9. 在 AndroidManifest.xml
    中声明用于 eSE 相关事件的广播接收器")所示。
- en: Example 11-9. Declaring a broadcast receiver for eSE-related events in AndroidManifest.xml
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-9. 在AndroidManifest.xml中声明用于eSE相关事件的广播接收器
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, Android offers notifications for lower-level communication events,
    such as RF field detection ➊➋, APDU reception ➌, and applet selection ➍, as well
    as for higher-level events, such as MIFARE sector access ➎ and EMV card removal
    ➏. (APDUs are *Application Protocol Data Units*, the basic building block of smart
    card protocols; see “[SE Communication Protocols](ch11.html#se_communication_protocols
    "SE Communication Protocols")”. The `APDU_RECIEVED` broadcast is not implemented,
    because in practice the NFC controller routes incoming APDUs directly to the eSE,
    which makes them invisible to the OS.) SE-enabled apps register for these broadcasts
    in order to be able to change their internal state or start a related activity
    when each event occurs (for example, to start a PIN entry activity when an EMV
    applet is selected). The `INTERNAL_TARGET_DESELECTED` broadcast ➐ is sent when
    card emulation is deactivated, and the `MASTER_CLEAR_NOTIFICATION` broadcast ➑
    is sent when the contents of the eSE are cleared. (Pre-HCE versions of Google
    Wallet offered users the option to clear the eSE remotely if their device was
    lost or stolen.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Android 提供了用于低级别通信事件的通知，如射频场检测 ➊➋、APDU 接收 ➌ 和应用程序小程序选择 ➍，以及用于高级别事件的通知，如
    MIFARE 扇区访问 ➎ 和 EMV 卡移除 ➏。（APDU 是 *应用协议数据单元*，智能卡协议的基本构建块；请参见 “[SE 通信协议](ch11.html#se_communication_protocols
    "SE Communication Protocols")”。`APDU_RECIEVED` 广播未实现，因为实际上 NFC 控制器会将传入的 APDU 直接路由到
    eSE，这使得它们对操作系统不可见。）支持 SE 的应用程序会注册这些广播，以便在每个事件发生时能够更改其内部状态或启动相关活动（例如，当选择 EMV 小程序时启动
    PIN 输入活动）。`INTERNAL_TARGET_DESELECTED` 广播 ➐ 在卡模拟被停用时发送，`MASTER_CLEAR_NOTIFICATION`
    广播 ➑ 在 eSE 内容被清除时发送。（Google Wallet 的 HCE 之前版本允许用户在设备丢失或被盗时远程清除 eSE 内容。）
- en: Android SE Execution Environment
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android SE 执行环境
- en: The Android SE is essentially a smart card in a different package, so most standards
    and protocols originally developed for smart cards apply. Let’s briefly review
    the most important ones.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Android SE 本质上是一个不同包装的智能卡，因此最初为智能卡开发的大多数标准和协议依然适用。我们来简要回顾一下最重要的几个。
- en: Smart cards have traditionally been filesystem-oriented and the main role of
    their OS has been to handle file access and enforce access permissions. Newer
    cards support a virtual machine running on top of the native OS that allows for
    the execution of “platform independent” applications called applets, which use
    a well-defined runtime library to implement their functionality. While different
    implementations of this paradigm exist, by far the most popular one is the Java
    Card runtime environment (JCRE). Applets are implemented in a restricted version
    of the Java language and use a limited runtime library, which offers basic classes
    for I/O, message parsing, and cryptographic operations. While the JCRE specification^([[123](#ftn.ch11fn13)])
    fully defines the applet runtime environment, it does not specify how to load,
    initialize, and delete applets on actual physical cards (tools are only provided
    for the JCRE emulator).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 智能卡传统上是面向文件系统的，其操作系统的主要作用是处理文件访问和强制执行访问权限。更新的卡片支持在原生操作系统上运行的虚拟机，允许执行名为小程序的“平台无关”应用程序，这些小程序使用一个定义良好的运行时库来实现其功能。尽管存在不同的实现方式，但迄今为止最流行的实现是
    Java Card 运行时环境（JCRE）。小程序是在受限版的 Java 语言中实现的，并使用一个有限的运行时库，该库提供了基本的 I/O 类、消息解析类和加密操作类。虽然
    JCRE 规范^([[123](#ftn.ch11fn13)]) 完全定义了小程序的运行时环境，但并未指定如何在实际的物理卡上加载、初始化和删除小程序（只提供了用于
    JCRE 模拟器的工具）。
- en: Because one of the main applications of smart cards are various payment services,
    the application loading and initialization process (often referred to as *card
    personalization*) needs to be controlled, and only authorized entities should
    be able to alter the state of the card and installed applications. Visa originally
    developed a specification for securely managing applets, called Open Platform,
    which is now maintained and developed by the GlobalPlatform (GP) organization
    under the name GlobalPlatform Card Specification.^([[124](#ftn.ch11fn14)]) The
    gist of this specification is that each GP-compliant card has a mandatory *Issuer
    Security Domain (ISD)* component (informally referred to as the *Card Manager*)
    that offers a well-defined interface for card and application life cycle management.
    Executing ISD operations requires authentication using cryptographic keys saved
    on the card, and thus only an entity that knows those keys can change the state
    of the card (one of `OP_READY`, `INITIALIZED`, `SECURED`, `CARD_LOCKED`, or `TERMINATED`)
    or manage applets. Additionally, the GP card specification defines various secure
    communication protocols (called Secure Channels) that offer authentication, confidentiality,
    and message integrity when communicating with the card.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于智能卡的主要应用之一是各种支付服务，因此应用加载和初始化过程（通常称为*卡片个性化*）需要受到控制，并且只有授权实体能够更改卡片及其已安装应用程序的状态。Visa最初开发了一种用于安全管理小程序的规范，称为开放平台（Open
    Platform），该规范现在由GlobalPlatform（GP）组织以GlobalPlatform Card Specification的名义进行维护和开发。该规范的核心内容是，每个符合GP标准的卡片都有一个强制性的*发行者安全域（ISD）*组件（非正式地称为*卡片管理器*），该组件为卡片和应用生命周期管理提供了一个明确定义的接口。执行ISD操作需要使用存储在卡片上的加密密钥进行身份验证，因此，只有知道这些密钥的实体才能更改卡片的状态（如`OP_READY`、`INITIALIZED`、`SECURED`、`CARD_LOCKED`或`TERMINATED`）或管理小程序。此外，GP卡片规范定义了多种安全通信协议（称为安全通道），在与卡片通信时，提供身份验证、保密性和消息完整性。
- en: SE Communication Protocols
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SE通信协议
- en: 'As discussed in “[Using the NfcExecutionEnvironment API](ch11.html#using_the_nfcexecutionenvironment_api
    "Using the NfcExecutionEnvironment API")”, Android’s interface for communicating
    with the SE is the `byte[] transceive(byte[] command)` method of the `NfcExecutionEnvironment`
    class. The messages exchanged using this API are in practice APDUs, and their
    structure is defined in the *ISO/IEC 7816-4: Organization, security and commands
    for interchange* standard.^([[125](#ftn.ch11fn15)]) The reader (also known as
    a *Card Acceptance Device*, or *CAD*) sends command APDUs (sometimes referred
    to as *C-APDUs*) to the card, composed of a mandatory four-byte header with a
    command class (*CLA*), instruction (*INS*), and two parameters (*P1* and *P2*).
    This is followed by the optional command data length (*Lc*), the actual data,
    and finally the maximum number of response bytes expected, if any (*Le*). The
    card returns a response APDU (*R-APDU*) with a mandatory status word (*SW*, consisting
    of two bytes: *SW1* and *SW2*) and optional response data.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '如在《[使用NfcExecutionEnvironment API](ch11.html#using_the_nfcexecutionenvironment_api
    "Using the NfcExecutionEnvironment API")》中所讨论，Android与SE通信的接口是`byte[] transceive(byte[]
    command)`方法，该方法属于`NfcExecutionEnvironment`类。通过此API交换的信息实际上是APDU，它们的结构在*ISO/IEC
    7816-4: 交换的组织、安全性和命令*标准中有定义。读卡器（也称为*卡片接受设备*，或*CAD*）发送命令APDU（有时称为*C-APDU*）到卡片，命令包括一个强制性的四字节头部，其中包含命令类（*CLA*）、指令（*INS*）和两个参数（*P1*和*P2*）。接着是可选的命令数据长度（*Lc*）、实际数据，最后是最大期望响应字节数（如果有的话，*Le*）。卡片返回一个响应APDU（*R-APDU*），其包含一个强制性的状态字（*SW*，由两字节组成：*SW1*和*SW2*），以及可选的响应数据。'
- en: 'Historically, command APDU data has been limited to 255 bytes (total APDU length
    261 bytes) and response APDU data to 256 bytes (total APDU length 258 bytes).
    Recent cards and readers support extended APDUs with data length up to 65536 bytes,
    but extended APDUs are not always usable, mostly for reasons of compatibility.
    The lower-level communication between the reader and the card is carried out by
    one of several transmission protocols, the most widely used of which are T=0 (byte-oriented)
    and T=1 (block-oriented). Both are defined in *ISO 7816-3: Cards with contacts
    — Electrical interface and transmission protocols*. The APDU exchange is not completely
    protocol-agnostic, because T=0 cannot directly send response data, but only notify
    the reader of the number of available bytes. Additional command APDUs (`GET RESPONSE`)
    need to be sent in order to retrieve the response data.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '历史上，命令 APDU 数据的长度限制为 255 字节（总 APDU 长度为 261 字节），响应 APDU 数据的长度限制为 256 字节（总 APDU
    长度为 258 字节）。近年来的卡片和读卡器支持数据长度可达 65536 字节的扩展 APDU，但扩展 APDU 并不总是可用，主要是出于兼容性原因。读卡器与卡片之间的低层通信是通过多种传输协议之一来进行的，其中最常用的是
    T=0（字节导向）和 T=1（块导向）。这两者都在 *ISO 7816-3: 带接触的卡片 — 电气接口和传输协议* 中有所定义。APDU 交换并非完全与协议无关，因为
    T=0 无法直接发送响应数据，而只能通知读卡器可用字节数。需要发送额外的命令 APDU（`GET RESPONSE`）以检索响应数据。'
- en: The original ISO 7816 standards were developed for contact cards, but the same
    APDU-based communication model is used for contactless cards as well. It’s layered
    on top of the wireless transmission protocol defined by ISO/IEC 14443-4, which
    behaves much like T=1 for contact cards.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 ISO 7816 标准是为接触式卡片制定的，但相同的基于 APDU 的通信模型也被用于非接触式卡片。它是建立在 ISO/IEC 14443-4
    定义的无线传输协议之上的，其行为类似于接触式卡片的 T=1。
- en: Querying the eSE Execution Environment
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询 eSE 执行环境
- en: As discussed in “[Embedded SE](ch11.html#embedded_se "Embedded SE")”, the eSE
    in the Galaxy Nexus is a chip from NXP’s SmartMX series. It runs a Java Card–compatible
    operating system and comes with a GlobalPlatform-compliant ISD. The ISD is configured
    to require authentication for most card management operations, and the authentication
    keys are, naturally, not publicly available. Additionally, a number of subsequent
    failed authentication attempts (usually 10) will lock the ISD and make it impossible
    to install or remove applets, so trying to brute-force the authentication keys
    is not an option. However, the ISD does provide some information about itself
    and the runtime environment on the card without requiring authentication in order
    to make it possible for clients to adjust their behavior dynamically and be compatible
    with different cards.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“[嵌入式 SE](ch11.html#embedded_se "Embedded SE")”中讨论的那样，Galaxy Nexus 中的 eSE
    是 NXP SmartMX 系列的芯片。它运行一个兼容 Java Card 的操作系统，并配备一个符合 GlobalPlatform 标准的 ISD。该 ISD
    被配置为需要进行身份验证才能执行大多数卡片管理操作，而身份验证密钥自然是无法公开的。此外，若发生多次身份验证失败（通常为 10 次），ISD 将被锁定，无法安装或移除小应用程序，因此暴力破解身份验证密钥不可行。然而，ISD
    确实提供了一些关于其自身及卡片运行环境的信息，无需身份验证，目的是使客户端能够动态调整其行为，并兼容不同的卡片。
- en: Because both Java Card and GlobalPlatform define a multi-application environment,
    each application needs a unique identifier called the *Application Identifier
    (AID)*. The AID consists of a 5-byte Registered Application Provider Identifier
    (RID, also called a Resource Identifier) and a Proprietary Identifier eXtension
    (PIX), which can be up to 11 bytes long. Thus, the length of an AID can be 5 to
    16 bytes long. Before being able to send commands to a particular applet, it needs
    to be made active, or selected, by issuing the `SELECT` (`CLA`=00, `INS`=A4) command
    with its AID. As all applications, the ISD is also identified by an AID, which
    varies between card manufacturers and GP implementations. We can find out the
    AID of the ISD by sending an empty `SELECT` command, which both selects the ISD
    and returns information about the card and the ISD configuration. An empty `SELECT`
    is simply a select without an AID specified, so the `SELECT` command APDU becomes
    `00 A4 04 00 00`. If we send this command using the `transcieve()` method of the
    `NfcExecutionEnvironment` class ([Example 11-8](ch11.html#using_the_nfcexecutionenvironmen-id00025
    "Example 11-8. Using the NfcExecutionEnvironment API") at ➍), the returned response
    might look like [Example 11-10](ch11.html#galaxy_nexus_eseapostrophes_response_to
    "Example 11-10. Galaxy Nexus eSE’s response to empty SELECT") at ➋ (➊ is the `SELECT`
    command).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Java Card 和 GlobalPlatform 都定义了多应用环境，所以每个应用都需要一个唯一标识符，称为 *应用标识符（AID）*。AID
    由一个 5 字节的注册应用提供商标识符（RID，也称为资源标识符）和一个最多可长达 11 字节的专有标识符扩展（PIX）组成。因此，AID 的长度可以从 5
    字节到 16 字节不等。在能够向特定小应用发送命令之前，必须通过发出 `SELECT`（`CLA`=00，`INS`=A4）命令并带上其 AID，使其激活或选中。像所有应用一样，ISD
    也有一个 AID，该 AID 在不同的卡片制造商和 GP 实现中可能不同。我们可以通过发送一个空的 `SELECT` 命令来查找 ISD 的 AID，该命令不仅选中
    ISD，还返回有关卡片和 ISD 配置的信息。空的 `SELECT` 命令就是没有指定 AID 的选择命令，因此 `SELECT` 命令的 APDU 格式为
    `00 A4 04 00 00`。如果我们使用 `NfcExecutionEnvironment` 类的 `transcieve()` 方法发送这个命令（[示例
    11-8](ch11.html#using_the_nfcexecutionenvironmen-id00025 "示例 11-8. 使用 NfcExecutionEnvironment
    API") 在 ➍），返回的响应可能类似于 [示例 11-10](ch11.html#galaxy_nexus_eseapostrophes_response_to
    "示例 11-10. Galaxy Nexus eSE 对空 SELECT 的响应") ➋（➊ 是 `SELECT` 命令）。
- en: Example 11-10. Galaxy Nexus eSE’s response to empty `SELECT`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-10。Galaxy Nexus eSE 对空 `SELECT` 的响应
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The response includes a successful status (0x9000) and a long string of bytes.
    The format of this data is defined in “APDU Command Reference,” [Chapter 9](ch09.html
    "Chapter 9. Enterprise Security") of the GlobalPlatform Card Specification and,
    as with most things in the smart card world, is in tag-length-value (TLV) format.
    In TLV, each unit of data is described by a unique tag, followed by its length
    in bytes, and finally the actual data. Most structures are recursive, so the data
    can host another TLV structure, which in turns wraps another, and so on. The structure
    shown in [Example 11-10](ch11.html#galaxy_nexus_eseapostrophes_response_to "Example 11-10. Galaxy
    Nexus eSE’s response to empty SELECT") is called *File Control Information (FCI)*
    and in this case it wraps a Security Domain Management Data structure, which describes
    the ISD. When parsed, the FCI might look like [Example 11-11](ch11.html#parsed_fci_of_the_isd_on_the_ese_in_gala
    "Example 11-11. Parsed FCI of the ISD on the eSE in Galaxy Nexus").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包括一个成功的状态（0x9000）和一串长字节。该数据的格式在“APDU 命令参考”中定义，见 GlobalPlatform 卡片规范的 [第 9
    章](ch09.html "第 9 章. 企业安全")，并且与智能卡世界中的大多数内容一样，采用标签-长度-值（TLV）格式。在 TLV 格式中，每个数据单元由一个唯一的标签描述，后面跟着数据的字节长度，最后是实际数据。大多数结构都是递归的，因此数据可以包含另一个
    TLV 结构，后者又封装了另一个，以此类推。[示例 11-10](ch11.html#galaxy_nexus_eseapostrophes_response_to
    "示例 11-10. Galaxy Nexus eSE 对空 SELECT 的响应") 中显示的结构被称为 *文件控制信息（FCI）*，在这种情况下，它封装了一个安全域管理数据结构，该结构描述了
    ISD。当解析时，FCI 可能看起来像 [示例 11-11](ch11.html#parsed_fci_of_the_isd_on_the_ese_in_gala
    "示例 11-11. Galaxy Nexus 上 eSE 中 ISD 的解析 FCI")。
- en: Example 11-11. Parsed FCI of the ISD on the eSE in Galaxy Nexus
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-11。Galaxy Nexus 上 eSE 的 ISD 解析后的 FCI
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the AID of the ISD is A0 00 00 00 03 00 00 00 ➊, the version of the GlobalPlatform
    implementation is 2.1.1 ➋, the supported Secure Channel protocol is SC02 ➌, and
    the last two fields of the structure contain some proprietary data about the card
    configuration (➍ and ➎). The only other GP command that doesn’t require authentication
    is `GET DATA`, which can be used to return additional data about the ISD configuration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，ISD 的 AID 是 A0 00 00 00 03 00 00 00 ➊，GlobalPlatform 实现的版本是 2.1.1 ➋，支持的安全通道协议是
    SC02 ➌，结构的最后两个字段包含一些关于卡片配置的专有数据（➍ 和 ➎）。唯一一个不需要认证的 GP 命令是 `GET DATA`，可以用于返回有关 ISD
    配置的附加数据。
- en: UICC as a Secure Element
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UICC 作为安全元件
- en: As discussed in “[SE Form Factors in Mobile Devices](ch11.html#se_form_factors_in_mobile_devices
    "SE Form Factors in Mobile Devices")”, the UICC in a mobile device can be used
    as a general-purpose SE when accessed using the Open Mobile API or a similar programming
    interface. This section gives a brief overview of UICCs and the applications they
    typically host, and then shows how to access the UICC via the Open Mobile API.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“[移动设备中的 SE 形态](ch11.html#se_form_factors_in_mobile_devices "SE Form Factors
    in Mobile Devices")”中讨论的那样，移动设备中的 UICC 可以作为通用的 SE 使用，当通过 Open Mobile API 或类似的编程接口访问时。本节简要概述了
    UICC 及其通常托管的应用程序，并展示了如何通过 Open Mobile API 访问 UICC。
- en: SIM Cards and UICCs
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SIM 卡和 UICC
- en: The predecessor of the UICC is the SIM card, and UICCs are still colloquially
    referred to as “SIM cards.” *SIM* stands for *Subscriber Identity Module* and
    refers to a smart card that securely stores the subscriber identifier and the
    associated key used to identify and authenticate a device to a mobile network.
    SIMs were initially used on GSM networks and the original GSM standards were later
    extended to support 3G and LTE. Because SIMs are smart cards, they conform to
    ISO-7816 standards regarding physical characteristics and electrical interface.
    The first SIM cards were the same size as “regular” smart cards (Full-size, FF),
    but by far the most popular sizes today are Mini-SIM (2FF) and Micro-SIM (3FF),
    with Nano-SIM (4FF), which was introduced in 2012, also gaining market share.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: UICC 的前身是 SIM 卡，UICC 仍然被俗称为“SIM 卡”。*SIM* 代表 *Subscriber Identity Module*（用户身份模块），指的是一种智能卡，用于安全地存储用户标识符和用于识别和验证设备与移动网络连接的相关密钥。SIM
    卡最初用于 GSM 网络，原始的 GSM 标准后来扩展以支持 3G 和 LTE。由于 SIM 卡是智能卡，它们符合 ISO-7816 标准的物理特性和电气接口要求。最初的
    SIM 卡与“常规”智能卡（全尺寸，FF）大小相同，但如今最流行的尺寸是 Mini-SIM（2FF）和 Micro-SIM（3FF），而 Nano-SIM（4FF）则于
    2012 年推出，市场份额也在逐步增加。
- en: 'Of course, not every smart card that fits in the SIM slot can be used in a
    mobile device, so the next question is: What makes a smart card a SIM card? Technically,
    it’s conformance to mobile communication standards such as 3GPP TS 11.11 and certification
    by the SIMalliance. In practice, it is the ability to run an application that
    allows it to communicate with the phone (referred to as *Mobile Equipment* or
    *Mobile Station* in related standards) and connect to a mobile network. While
    the original GSM standard did not distinguish between the physical smart card
    and the software required to connect to the mobile network, with the introduction
    of 3G standards, a clear distinction has been made. The physical smart card is
    referred to as a *Universal Integrated Circuit Card (UICC),* and different mobile
    network applications that run on it have been defined: GSM, CSIM, USIM, ISIM,
    and so on. A UICC can host and run more than one network application (hence the
    name *universal*), and thus can be used to connect to different networks. While
    network application functionality depends on the specific mobile network, their
    core features are quite similar: store network parameters securely and identify
    to the network, as well as authenticate the user (optionally) and store user data.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非每一张适合插入 SIM 卡槽的智能卡都可以在移动设备中使用，那么下一个问题是：什么使得一张智能卡成为 SIM 卡？从技术上讲，它需要符合如 3GPP
    TS 11.11 等移动通信标准，并经过 SIMalliance 的认证。在实践中，它需要能够运行一个允许其与手机（在相关标准中称为 *Mobile Equipment*
    或 *Mobile Station*）进行通信并连接到移动网络的应用程序。虽然最初的 GSM 标准并未区分物理智能卡和用于连接移动网络所需的软件，但随着 3G
    标准的引入，二者之间做出了明确区分。物理智能卡被称为 *Universal Integrated Circuit Card (UICC)*，并定义了在其上运行的不同移动网络应用程序：GSM、CSIM、USIM、ISIM
    等。UICC 可以托管并运行多个网络应用程序（因此得名 *universal*），因此可以用于连接不同的网络。虽然网络应用功能依赖于具体的移动网络，但它们的核心特性是相似的：安全存储网络参数并向网络提供身份认证，以及（可选）进行用户认证并存储用户数据。
- en: UICC Applications
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UICC 应用程序
- en: 'Let’s take GSM as an example and briefly review how a network application works.
    For GSM, the main network parameters are network identity (International Mobile
    Subscriber Identity, IMSI; tied to the SIM), phone number (MSISDN, used for routing
    calls and changeable), and a shared network authentication key *Ki*. To connect
    to the network, the phone needs to authenticate and negotiate a session key. Both
    authentication and session keys are derived using *Ki*, which is also known to
    the network and looked up by IMSI. The phone sends a connection request that includes
    its IMSI, which the network uses to find the corresponding *Ki*. The network then
    uses the *Ki* to generate a challenge (*RAND*), expected challenge response (*SRES*),
    and session key *Kc*. When those parameters have been generated, the network sends
    *RAND* to the phone and the GSM application running on the SIM card comes into
    play: the mobile passes the *RAND* to the SIM card, which generates its own *SRES*
    and *Kc*. The *SRES* is sent to the network and if it matches the expected value,
    encrypted communication is established using the session key *Kc*.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以GSM为例，我们简要回顾一下网络应用是如何工作的。对于GSM，主要的网络参数有网络身份（国际移动用户身份，IMSI；与SIM卡绑定）、电话号码（MSISDN，用于路由呼叫并且可以更改）和共享网络认证密钥*Ki*。为了连接到网络，手机需要进行认证并协商会话密钥。认证密钥和会话密钥都是通过*Ki*生成的，而*Ki*也为网络所知，并通过IMSI查找。手机发送一个连接请求，其中包含其IMSI，网络使用IMSI来查找相应的*Ki*。网络然后利用*Ki*生成一个挑战（*RAND*）、预期的挑战响应（*SRES*）和会话密钥*Kc*。当这些参数生成后，网络将*RAND*发送给手机，SIM卡上的GSM应用程序开始起作用：手机将*RAND*传递给SIM卡，SIM卡生成自己的*SRES*和*Kc*。*SRES*被发送到网络，如果与预期值匹配，则通过会话密钥*Kc*建立加密通信。
- en: As you can see, the security of this protocol hinges solely on the secrecy of
    the *Ki*. Because all operations involving the *Ki* are implemented inside the
    SIM card, and it never comes in direct contact with the phone or the network,
    the scheme is kept reasonably secure. Of course, security depends on the encryption
    algorithms used as well, and major weaknesses that allow intercepted GSM calls
    to be decrypted using off-the-shelf hardware were found in the original versions
    of the A5/1 stream cipher (which was initially secret).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该协议的安全性完全依赖于*Ki*的保密性。由于所有涉及*Ki*的操作都在SIM卡内部实现，并且*Ki*从不与手机或网络直接接触，因此该方案保持了合理的安全性。当然，安全性也取决于使用的加密算法，且在A5/1流密码的早期版本中发现了主要的漏洞，这些漏洞使得可以使用现成的硬件解密被拦截的GSM通话（A5/1流密码最初是保密的）。
- en: In Android, network authentication is implemented by the baseband processor
    (more on this in “[Accessing the UICC](ch11.html#accessing_the_uicc "Accessing
    the UICC")” below) and is never directly visible to the main OS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，网络认证是由基带处理器实现的（更多内容见下面的“[访问UICC](ch11.html#accessing_the_uicc "Accessing
    the UICC")”），并且从未直接暴露给主操作系统。
- en: UICC Application Implementation and Installation
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UICC应用程序的实现与安装
- en: We’ve seen that UICCs need to run applications; now let’s see how those applications
    are implemented and installed. Initial smart cards were based on a filesystem
    model, where files (called *elementary files*, or *EF*) and directories (called
    *dedicated files*, or *DF*) were named with a two-byte identifier. Thus, developing
    “an application” involved selecting an ID for the DF that hosts the application’s
    files (called *ADF*), and specifying the formats and names of the EFs that store
    data. For example, the GSM application is under the *7F20* ADF, and the USIM ADF
    hosts the *EF_imsi*, *EF_keys*, *EF_sms*, and other required files.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到UICCs需要运行应用程序；现在让我们来看看这些应用程序是如何实现和安装的。最初的智能卡是基于文件系统模型的，其中文件（称为*基本文件*，或*EF*）和目录（称为*专用文件*，或*DF*）用一个两字节的标识符命名。因此，开发“一个应用程序”就涉及选择一个ID，用于承载应用程序文件的DF（称为*ADF*），并指定存储数据的EF的格式和名称。例如，GSM应用程序位于*7F20*
    ADF下，而USIM ADF承载着*EF_imsi*、*EF_keys*、*EF_sms*等必要文件。
- en: Because practically all UICCs in use today are based on Java Card technology
    and implement GlobalPlatform card specifications, all network applications are
    implemented as Java Card applets and emulate the legacy file-based structure for
    backward compatibility. Applets are installed according to GlobalPlatform specifications
    by authenticating to the ISD and issuing `LOAD` and `INSTALL` commands.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为目前使用的几乎所有UICCs都是基于Java Card技术并实现了GlobalPlatform卡规范，所以所有网络应用程序都作为Java Card小程序来实现，并为了向后兼容而模拟传统的基于文件的结构。小程序根据GlobalPlatform规范通过认证到ISD并发出`LOAD`和`INSTALL`命令进行安装。
- en: One application management feature specific to SIM cards is support for OTA
    updates via binary SMS. This functionality is not used by all carriers, but it
    allows carriers to remotely install applets on SIM cards they’ve issued. OTA is
    implemented by wrapping card commands (APDUs) in SMS T-PDUs (transport protocol
    data units), which the phone forwards to the UICC. In most UICCs, this is the
    only way to load applets on the card, even during initial personalization.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定于 SIM 卡的应用管理功能是支持通过二进制 SMS 进行 OTA 更新。并非所有运营商都使用此功能，但它允许运营商远程在其发放的 SIM 卡上安装小程序。OTA
    通过将卡命令（APDU）封装在 SMS T-PDU（传输协议数据单元）中实现，手机将其转发到 UICC。在大多数 UICC 中，这也是加载小程序到卡上的唯一方式，即使是在初始个性化过程中。
- en: The major use case for this OTA functionality is to install and maintain SIM
    Toolkit (STK) applications that can interact with the handset via standard “proactive”
    commands (which in reality are implemented via polling), and to display menus
    or even open web pages and send SMS. Android supports STK with a dedicated STK
    system app, which is automatically disabled if the UICC card has no STK applets
    installed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此 OTA 功能的主要用途是安装和维护 SIM 工具包（STK）应用程序，这些应用程序可以通过标准的“主动”命令与手机交互（这些命令实际上是通过轮询实现的），并显示菜单，甚至打开网页和发送短信。Android
    支持 STK，并配有专用的 STK 系统应用，如果 UICC 卡上没有安装 STK 小程序，该应用会自动禁用。
- en: Accessing the UICC
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问 UICC
- en: As we discussed in “[UICC Applications](ch11.html#uicc_applications "UICC Applications")”,
    mobile network–related functionality in Android, including UICC access, is implemented
    by the baseband software. The main OS (Android) is limited in what it can do with
    the UICC by the features the baseband exposes. Android supports STK applications
    and can look up and store contacts on the SIM, so it’s clear that it has internal
    support for communicating to the SIM. However, the Android security overview explicitly
    states that “low-level access to the SIM card is not available to third-party
    apps.”^([[126](#ftn.ch11fn16)]) How can we use the SIM card (UICC) as an SE then?
    Some Android builds from major vendors, most notably Samsung, provide an implementation
    of the SIMalliance Open Mobile API, and an open source implementation (for compatible
    devices) of the API is available from the SEEK for Android project. The Open Mobile
    API aims to provide a unified interface for accessing SEs on Android, including
    the UICC.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在“[UICC 应用](ch11.html#uicc_applications "UICC Applications")”中讨论的，Android
    中与移动网络相关的功能，包括 UICC 访问，是通过基带软件实现的。主操作系统（Android）对 UICC 的操作受限于基带所暴露的功能。Android
    支持 STK 应用程序，并可以查找和存储 SIM 卡上的联系人，因此可以明确看出，它内部支持与 SIM 卡的通信。然而，Android 安全概述明确指出，“第三方应用无法访问
    SIM 卡的低级功能。”^([[126](#ftn.ch11fn16)]) 那么我们如何将 SIM 卡（UICC）作为 SE 使用呢？来自主要厂商的某些 Android
    版本，尤其是三星，提供了 SIMalliance 开放移动 API 的实现，且 SEEK for Android 项目提供了该 API 的开源实现（适用于兼容设备）。开放移动
    API 旨在提供统一的接口，用于访问 Android 上的 SE，包括 UICC。
- en: To understand how the Open Mobile API works and the cause of its limitations,
    let’s review how access to the SIM card is implemented in Android. On Android
    devices, all mobile network functionality (dialing, sending SMS, and so on) is
    provided by the baseband processor (also referred to as *modem* or *radio*). Android
    applications and system services communicate with the baseband only indirectly
    via the Radio Interface Layer (RIL) daemon (*rild*). The *rild* in turn talks
    to the actual hardware by using a manufacturer-provided RIL HAL library, which
    wraps the proprietary interface that the baseband provides. The UICC card is typically
    connected only to the baseband processor (though sometimes also to the NFC controller
    via SWP), and thus all communication needs to go through the RIL.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解开放移动 API 的工作原理以及其限制的原因，让我们回顾一下 Android 中如何实现对 SIM 卡的访问。在 Android 设备上，所有与移动网络相关的功能（拨打电话、发送短信等）都是由基带处理器（也称为
    *调制解调器* 或 *无线电*）提供的。Android 应用程序和系统服务仅通过无线电接口层（RIL）守护进程（*rild*）间接与基带进行通信。*rild*
    又通过使用制造商提供的 RIL HAL 库与实际硬件进行通信，该库封装了基带所提供的专有接口。UICC 卡通常仅与基带处理器连接（有时也通过 SWP 连接到
    NFC 控制器），因此所有通信都必须通过 RIL 进行。
- en: While the proprietary RIL implementation can always access the UICC in order
    to perform network identification and authentication, as well as read and write
    contacts and access STK applications, support for transparent APDU exchange is
    not always available. As we mentioned in [UICC](ch11.html#uicc "UICC"), the standard
    way to provide this feature is to use extended AT commands such `AT+CSIM` (Generic
    SIM access) and `AT+CGLA` (Generic UICC Logical Channel Access), but some vendors
    implement APDU exchange using proprietary extensions, so support for the necessary
    AT commands doesn’t automatically provide UICC access.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然专有的 RIL 实现总是能够访问 UICC，以进行网络识别和身份验证，并读取和写入联系人以及访问 STK 应用程序，但透明的 APDU 交换支持并不总是可用。如我们在[UICC](ch11.html#uicc
    "UICC")中提到的，提供此功能的标准方法是使用扩展的 AT 命令，如 `AT+CSIM`（通用 SIM 访问）和 `AT+CGLA`（通用 UICC 逻辑通道访问），但某些厂商使用专有扩展实现
    APDU 交换，因此支持必要的 AT 命令并不自动提供对 UICC 的访问。
- en: SEEK for Android implements a resource manager service (`SmartCardService`)
    that can connect to any supported SE (eSE, ASSD, or UICC) and extensions to the
    Android telephony framework that allow for transparent APDU exchange with the
    UICC. Because access through the RIL is hardware- and HAL-dependent, you need
    both a compatible device and a build that includes the `SmartCardService` and
    related framework extensions, such as those found in most recent Samsung Galaxy
    devices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: SEEK for Android 实现了一个资源管理服务（`SmartCardService`），该服务可以连接任何支持的 SE（eSE、ASSD 或
    UICC）并扩展 Android 电话框架，允许与 UICC 进行透明的 APDU 交换。由于通过 RIL 的访问依赖于硬件和 HAL，你需要一个兼容的设备以及包含
    `SmartCardService` 和相关框架扩展的构建版本，例如大多数最新的三星 Galaxy 设备中包含的那些。
- en: Using the OpenMobile API
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OpenMobile API
- en: The OpenMobile API is relatively small and defines classes that represent the
    card reader that an SE is connected to (`Reader`), a communication session with
    an SE (`Session`), and a basic (channel 0, as per ISO 7816-4) or logical channel
    with the SE (`Channel`). The `Channel` class allows applications to exchange APDUs
    with the SE using the `transmit()` method. The entry point to the API is the `SEService`
    class, which connects to the remote resource manager service (`SmartcardService`)
    and provides a method that returns a list of `Reader` objects available on the
    device. (For more information about the OpenMobile API and the architecture of
    the `SmartcardService`, refer to the SEEK for Android Wiki.^([[127](#ftn.ch11fn17)]))
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMobile API 相对较小，定义了表示与 SE 连接的读卡器（`Reader`）、与 SE 的通信会话（`Session`）以及与 SE 的基本（通道
    0，按 ISO 7816-4 规范）或逻辑通道（`Channel`）的类。`Channel` 类允许应用程序使用 `transmit()` 方法与 SE 交换
    APDU。API 的入口点是 `SEService` 类，该类连接到远程资源管理服务（`SmartcardService`）并提供一个方法，返回设备上可用的
    `Reader` 对象列表。（有关 OpenMobile API 和 `SmartcardService` 架构的更多信息，请参见 SEEK for Android
    Wiki。^([[127](#ftn.ch11fn17)]))
- en: In order to be able to use the OpenMobile API, applications need to request
    the `org.simalliance.openmobileapi.SMARTCARD` permission and add the *org.simalliance.openmobileapi*
    extension library to their manifest as shown in [Example 11-12](ch11.html#androidmanifestdotxml_configuration_requ
    "Example 11-12. AndroidManifest.xml configuration required to use the OpenMobile
    API").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用 OpenMobile API，应用程序需要请求 `org.simalliance.openmobileapi.SMARTCARD` 权限，并将
    *org.simalliance.openmobileapi* 扩展库添加到其清单中，如[示例 11-12](ch11.html#androidmanifestdotxml_configuration_requ
    "示例 11-12. 配置 AndroidManifest.xml 以使用 OpenMobile API")所示。
- en: Example 11-12. AndroidManifest.xml configuration required to use the OpenMobile
    API
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-12. 配置 AndroidManifest.xml 以使用 OpenMobile API
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 11-13](ch11.html#sending_a_command_to_the_first_se_using "Example 11-13. Sending
    a command to the first SE using the OpenMobile API") demonstrates how an application
    can use the OpenMobile API to connect and send a command to the first SE on the
    device.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-13](ch11.html#sending_a_command_to_the_first_se_using "示例 11-13. 使用
    OpenMobile API 向第一个 SE 发送命令") 演示了应用程序如何使用 OpenMobile API 连接并向设备上的第一个 SE 发送命令。'
- en: Example 11-13. Sending a command to the first SE using the OpenMobile API
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-13. 使用 OpenMobile API 向第一个 SE 发送命令
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the application first creates an `SEService` ➊ instance, which connects
    to the `SmartCardService` asynchronously and notifies the application via the
    `serviceConnected()` method (not shown) of the `SEService.CallBack` interface
    when the connection is established. The app can then get a list of the available
    SE readers using the `getReaders()` method ➋, and then open a session to the selected
    reader using the `openSession()` method ➌. If the device does not contain an eSE
    (or another form of SE besides the UICC), or the `SmartCardService` hasn’t been
    configured to use it, the list of readers contains a single `Reader` instance
    that represents the built-in UICC reader in the device. When the app has an open
    `Session` with the target SE, it calls the `openLogicalChannel()` method ➍ in
    order to obtain a `Channel`, which it then uses to send APDUs and receive responses
    using its `transmit()` method ➎.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，应用程序首先创建一个 `SEService` ➊ 实例，该实例异步连接到 `SmartCardService`，并通过 `SEService.CallBack`
    接口中的 `serviceConnected()` 方法（未显示）在连接建立时通知应用程序。然后，应用程序可以使用 `getReaders()` 方法 ➋
    获取可用的 SE 读卡器列表，接着使用 `openSession()` 方法 ➌ 打开与所选读卡器的会话。如果设备不包含 eSE（或除 UICC 外的其他
    SE 形式），或者 `SmartCardService` 没有配置以使用它，则读卡器列表只包含一个 `Reader` 实例，代表设备中的内置 UICC 读卡器。当应用程序与目标
    SE 建立了开放的 `Session` 之后，它调用 `openLogicalChannel()` 方法 ➍ 以获得一个 `Channel`，然后利用该通道发送
    APDU 并通过其 `transmit()` 方法 ➎ 接收响应。
- en: Software Card Emulation
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件卡仿真
- en: '*Software card emulation* (also referred to as *host-based card emulation*
    or *HCE*) allows commands received by the NFC controller to be delivered to the
    application processor (main OS), and to be processed by regular Android applications,
    instead of by applets installed on a hardware SE. Responses are then sent back
    to the reader via NFC, allowing an app to act as a virtual contactless smart card.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件卡仿真*（也称为 *基于主机的卡仿真* 或 *HCE*）允许 NFC 控制器接收到的命令被传送到应用处理器（主操作系统），并由常规 Android
    应用程序处理，而不是由安装在硬件 SE 上的小程序处理。然后，响应通过 NFC 发送回读卡器，使应用程序能够充当虚拟的非接触式智能卡。'
- en: Before being officially added to the Android API, HCE was first available as
    an experimental feature of the CyanogenMod Android distribution.^([[128](#ftn.ch11fn18)])
    Beginning with version 9.1, CyanogenMod integrated a set of patches (developed
    by Doug Yeager) that unlock the HCE functionality of the popular PN544 NFC controller
    and provide a framework interface to HCE. In order to support HCE, two new tag
    technologies (`IsoPcdA` and `IsoPcdB`, representing external contactless readers
    based on NFC Type A and Type B technology, respectively) were added to the NFC
    framework. (The letters *Pcd* stand for *Proximity Coupling Device*, which is
    just another technical term for contactless reader.)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在正式加入 Android API 之前，HCE 最初作为 CyanogenMod Android 发行版的实验性功能提供。^([[128](#ftn.ch11fn18)])
    从版本 9.1 开始，CyanogenMod 集成了一组补丁（由 Doug Yeager 开发），解锁了流行的 PN544 NFC 控制器的 HCE 功能，并提供了一个框架接口来支持
    HCE。为了支持 HCE，NFC 框架中增加了两种新的标签技术（`IsoPcdA` 和 `IsoPcdB`，分别代表基于 NFC A 型和 B 型技术的外部非接触式读卡器）。(*Pcd*
    代表 *Proximity Coupling Device*，即非接触式读卡器的另一技术术语。)
- en: 'The `IsoPcdA` and `IsoPcdB` classes reversed the role of `Tag` objects in the
    Android NFC API: because the external contactless reader is presented as a “tag,”
    “commands” you send from the phone are actually replies to the reader-initiated
    communication. Unlike the rest of Android’s NFC stack, this architecture was not
    event driven and required applications to handle blocking I/O while waiting for
    the reader to send its next command. Android 4.4 introduced a standard, event-driven
    framework for developing HCE applications, which we discuss next.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsoPcdA` 和 `IsoPcdB` 类反转了 Android NFC API 中 `Tag` 对象的角色：由于外部非接触式读卡器作为“标签”呈现，从手机发送的“命令”实际上是对读卡器发起通信的回应。与
    Android NFC 堆栈的其他部分不同，这种架构不是事件驱动的，需要应用程序在等待读卡器发送下一条命令时处理阻塞 I/O。Android 4.4 引入了一个标准的事件驱动框架，用于开发
    HCE 应用程序，我们接下来将讨论这一点。'
- en: Android 4.4 HCE Architecture
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 4.4 HCE 架构
- en: Unlike the R/W and P2P mode, which are only available to activities, HCE applications
    can work in the background and are implemented by defining a service that processes
    commands received from the external reader and returns responses. Such HCE services
    extend the `HostApduService` abstract framework class and implement its `onDeactivated()`
    and `processCommand()` methods. `HostApduService` itself is a very thin mediator
    class that enables twoway communication with the system `NfcService` by using
    `Messenger` objects.^([[129](#ftn.ch11fn19)]) For example, when the `NfcService`
    receives an APDU that needs to be routed (APDU routing is discussed in the next
    section) to a HCE service, it sends a `MSG_COMMAND_APDU` to `HostApduService`,
    which then extracts the APDU from the message and passes it to its concrete implementation
    by calling the `processCommand()` method. If `processCommand()` returns an APDU,
    `HostApduService` encapsulates it in a `MSG_RESPONSE_APDU` message and sends it
    to the `NfcService`, which in turn forwards it to the NFC controller. If the concrete
    HCE service cannot return a response APDU immediately, it returns `null` and sends
    the response later (when it is available) by calling the `sendResponseApdu()`,
    which sends the response to the `NfcService` wrapped in a `MSG_RESPONSE_APDU`
    message.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与仅对活动可用的 R/W 和 P2P 模式不同，HCE 应用可以在后台工作，并通过定义一个服务来处理来自外部读卡器的命令并返回响应。此类 HCE 服务扩展了
    `HostApduService` 抽象框架类，并实现了其 `onDeactivated()` 和 `processCommand()` 方法。`HostApduService`
    本身是一个非常轻量的中介类，通过使用 `Messenger` 对象与系统 `NfcService` 进行双向通信。^([[129](#ftn.ch11fn19)])
    例如，当 `NfcService` 收到一个需要被路由（APDU 路由将在下一节讨论）到 HCE 服务的 APDU 时，它会向 `HostApduService`
    发送一个 `MSG_COMMAND_APDU`，后者从消息中提取 APDU 并通过调用 `processCommand()` 方法将其传递给具体实现。如果
    `processCommand()` 返回一个 APDU，`HostApduService` 会将其封装在 `MSG_RESPONSE_APDU` 消息中并发送回
    `NfcService`，后者再将其转发到 NFC 控制器。如果具体的 HCE 服务无法立即返回响应 APDU，它会返回 `null` 并稍后通过调用 `sendResponseApdu()`
    发送响应（当响应可用时），该方法将响应包装在 `MSG_RESPONSE_APDU` 消息中并发送回 `NfcService`。
- en: APDU Routing
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: APDU 路由
- en: When the device is in card emulation mode, the NFC controller receives all APDUs
    coming from external readers and decides whether to send them to a physical SE
    (if any), or to an HCE service based on its internal APDU routing table. The routing
    table is AID-based and is populated using the metadata SE-enabled applications
    and HCE services declared in their application manifests. When the external reader
    sends a `SELECT` command that is not directly routed to the SE, the NFC controller
    forwards it to the `NfcService`, which extracts the target AID from the command
    and searches the routing table for a matching HCE service by calling the `resolveAidPrefix()`
    method of the `RegisteredAidCache` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备处于卡模拟模式时，NFC 控制器会接收所有来自外部读卡器的 APDU，并根据其内部的 APDU 路由表决定是将它们发送到物理 SE（如果有的话），还是发送到
    HCE 服务。路由表是基于 AID 的，并且通过其应用清单中声明的支持 SE 的应用和 HCE 服务的元数据进行填充。当外部读卡器发送一个 `SELECT`
    命令，该命令未直接路由到 SE 时，NFC 控制器会将其转发给 `NfcService`，后者从命令中提取目标 AID，并通过调用 `RegisteredAidCache`
    类的 `resolveAidPrefix()` 方法在路由表中查找匹配的 HCE 服务。
- en: If a matching service is found, `NfcService` binds to it and obtains a `Messenger`
    instance, which it then uses to send subsequent APDUs (wrapped in `MSG_COMMAND_APDU`
    messages, as discussed in the previous section). For this to work, the app’s HCE
    service needs to be declared in *AndroidManifest.xml* as shown in [Example 11-14](ch11.html#declaring_a_hce_service_in_androidmanife
    "Example 11-14. Declaring a HCE service in AndroidManifest.xml").
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到匹配的服务，`NfcService` 将绑定该服务并获取一个 `Messenger` 实例，然后它将使用该实例发送后续的 APDU（如上一节所讨论的，封装在
    `MSG_COMMAND_APDU` 消息中）。为了使其正常工作，应用的 HCE 服务需要在 *AndroidManifest.xml* 中声明，具体如 [示例
    11-14](ch11.html#declaring_a_hce_service_in_androidmanife "示例 11-14. 在 AndroidManifest.xml
    中声明 HCE 服务") 所示。
- en: Example 11-14. Declaring a HCE service in AndroidManifest.xml
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-14. 在 AndroidManifest.xml 中声明 HCE 服务
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The application declares its HCE service ➊ as usual, using the `<service>` tag,
    but there are a few additional requirements. First, the service must be protected
    with the `BIND_NFC_SERVICE` system signature permission ➋, to guarantee that only
    system apps (in practice, only the `NfcService`) can bind to it. Next, the service
    needs to declare an intent filter that matches the `android.nfc.cardemulation.action.HOST_APDU_SERVICE`
    action ➌ so that it can be identified as a HCE service when scanning installed
    packages, and be bound to when a matching APDU is received. Finally, the service
    must have an XML resource metadata entry under the name *android.nfc.cardemulation.host_apdu_
    service* ➍, which points to an XML resource file listing the AIDs that the service
    can handle. The contents of this file is used to build the AID routing table,
    which the NFC stack consults when it receives a `SELECT` command.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序按惯例声明其 HCE 服务 ➊，使用 `<service>` 标签，但有一些额外的要求。首先，服务必须使用 `BIND_NFC_SERVICE`
    系统签名权限 ➋ 进行保护，以保证只有系统应用程序（实际上是 `NfcService`）可以绑定到该服务。接下来，服务需要声明一个意图过滤器，该过滤器匹配
    `android.nfc.cardemulation.action.HOST_APDU_SERVICE` 动作 ➌，以便在扫描已安装的程序包时能够识别为 HCE
    服务，并在接收到匹配的 APDU 时绑定该服务。最后，服务必须在名为 *android.nfc.cardemulation.host_apdu_service*
    ➍ 的 XML 资源元数据条目下声明，指向一个列出该服务可以处理的 AID 的 XML 资源文件。该文件的内容用于构建 AID 路由表，NFC 堆栈在接收到
    `SELECT` 命令时会参考该表。
- en: Specifying Routing for HCE Services
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 HCE 服务指定路由
- en: For HCE applications, the XML file must include a `<host-apdu-service>` root
    element as shown in [Example 11-15](ch11.html#hce_service_aid_metadata_file "Example 11-15. HCE
    service AID metadata file").
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HCE 应用程序，XML 文件必须包含如[示例 11-15](ch11.html#hce_service_aid_metadata_file "示例
    11-15. HCE 服务 AID 元数据文件")所示的 `<host-apdu-service>` 根元素。
- en: Example 11-15. HCE service AID metadata file
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-15. HCE 服务 AID 元数据文件
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `<host-apdu-service>` tag has a `description` attribute and a `requireDeviceUnlock`
    attribute ➊, which specifies whether the corresponding HCE service should be activated
    when the device is locked. (The device’s screen must be on for NFC to work.) The
    root element contains one or more `<aid-group>` entries ➋, which each have a `category`
    attribute ➌ and contain one or more `<aid-filter>` ➍ tags that specify an AID
    in their `name` attribute (*A0000000010101* in this example).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`<host-apdu-service>` 标签具有一个 `description` 属性和一个 `requireDeviceUnlock` 属性 ➊，它指定在设备锁定时是否应该激活相应的
    HCE 服务。（设备屏幕必须开启才能使 NFC 工作。）根元素包含一个或多个 `<aid-group>` 条目 ➋，每个条目都有一个 `category`
    属性 ➌，并包含一个或多个 `<aid-filter>` ➍ 标签，它们在 `name` 属性中指定一个 AID（例如本示例中的 *A0000000010101*）。'
- en: An AID group defines a set of AIDs that is always handled by a particular HCE
    service. The NFC framework guarantees that if a single AID is handled by an HCE
    service, then all other AIDs in the group are also handled by the same service.
    If two or more HCE services define the same AID, the system shows a selection
    dialog letting the user choose which application should handle the incoming `SELECT`
    command. When an app is chosen, all subsequent commands are routed to it after
    the user confirms the selection by tapping on the dialog shown in [Figure 11-2](ch11.html#hce_application_selection_confirmation_d
    "Figure 11-2. HCE application selection confirmation dialog").
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 AID 组定义了一组始终由特定 HCE 服务处理的 AID。NFC 框架保证，如果一个 AID 被一个 HCE 服务处理，那么该组中的所有其他 AID
    也会由同一个服务处理。如果两个或多个 HCE 服务定义了相同的 AID，系统会显示一个选择对话框，允许用户选择哪个应用程序应处理传入的 `SELECT` 命令。当用户选择一个应用程序后，所有后续命令将路由到该应用程序，用户通过点击在[图
    11-2](ch11.html#hce_application_selection_confirmation_d "图 11-2. HCE 应用选择确认对话框")中显示的对话框来确认选择。
- en: 'Each AID group is associated with a category (specified with the `category`
    attribute), which allows the system to set a default handler per category, rather
    than per AID. An application can check if a particular service is the default
    handler for a category by calling the `isDefaultServiceForCategory()` method of
    the `CardEmulation` class, and get the selection mode for a category by calling
    the `getSelectionModeForCategory()` method. As of this writing, only two categories
    are defined: `CATEGORY_PAYMENT` and `CATEGORY_OTHER`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 AID 组都与一个类别相关联（通过 `category` 属性指定），这使得系统可以按类别设置默认处理程序，而不是按 AID 设置。应用程序可以通过调用
    `CardEmulation` 类的 `isDefaultServiceForCategory()` 方法来检查特定服务是否为某个类别的默认处理程序，并通过调用
    `getSelectionModeForCategory()` 方法来获取类别的选择模式。截至本文写作时，已定义了两个类别：`CATEGORY_PAYMENT`
    和 `CATEGORY_OTHER`。
- en: Android enforces a single active payment category in order to ensure that the
    user has explicitly selected which app should handle payment transactions. The
    default app for the payment category is selected in the Tap & pay screen of the
    system Settings app, as shown in [Figure 11-3](ch11.html#selecting_the_default_payment_applicatio
    "Figure 11-3. Selecting the default payment application in the Tap & pay screen").
    (See the official HCE documentation^([[130](#ftn.ch11fn20)]) for more on payment
    applications.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Android 强制执行单一活动的支付类别，以确保用户明确选择了应该处理支付事务的应用程序。支付类别的默认应用程序是在系统设置应用的 Tap & pay
    屏幕中选择的，如 [图 11-3](ch11.html#selecting_the_default_payment_applicatio "图 11-3.
    在 Tap & pay 屏幕中选择默认支付应用程序") 所示。 (有关支付应用程序的更多信息，请参阅官方 HCE 文档^([[130](#ftn.ch11fn20)])。)
- en: '![HCE application selection confirmation dialog](figs/web/11fig02.png.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![HCE 应用程序选择确认对话框](figs/web/11fig02.png.jpg)'
- en: Figure 11-2. HCE application selection confirmation dialog
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2. HCE 应用程序选择确认对话框
- en: '![Selecting the default payment application in the Tap & pay screen](figs/web/11fig03.png.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![在 Tap & pay 屏幕中选择默认支付应用程序](figs/web/11fig03.png.jpg)'
- en: Figure 11-3. Selecting the default payment application in the Tap & pay screen
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3. 在 Tap & pay 屏幕中选择默认支付应用程序
- en: Specifying Routing for SE Applets
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 SE 应用程序指定路由
- en: 'If a device supports HCE and also has a physical SE, a `SELECT` command sent
    by an external reader can target either an HCE service, or an applet installed
    on the SE. Because Android 4.4 directs all AIDs not listed in the AID routing
    table to the host, the AIDs of applets installed on the SE must be explicitly
    added to the NFC controller’s routing table. This is accomplished with the same
    mechanism used for registering HCE services: by adding a service entry to the
    application’s manifest, and linking it to a meta-data XML file that specifies
    a list of AIDs that should be routed to the SE. When the route is established,
    command APDUs are sent directly to the SE (which processes them and returns a
    response via the NFC controller), so the service is used only as a marker and
    provides no functionality.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备支持 HCE 并且具有物理 SE，外部读卡器发送的 `SELECT` 命令可以指向 HCE 服务或安装在 SE 上的应用程序。因为 Android
    4.4 会将 AID 路由表中未列出的所有 AID 路由到主机，所以安装在 SE 上的应用程序的 AID 必须显式地添加到 NFC 控制器的路由表中。通过与注册
    HCE 服务时相同的机制完成这一操作：通过在应用程序的清单中添加服务条目，并将其链接到一个指定了应该路由到 SE 的 AID 列表的元数据 XML 文件。当路由建立时，命令
    APDU 将直接发送到 SE（SE 处理它们并通过 NFC 控制器返回响应），因此该服务仅作为标记使用，不提供任何功能。
- en: The Android SDK includes a helper service (`OffHostApduService`) that can be
    used to list AIDs that should be routed directly to the SE. This `OffHostApduService`
    class defines some useful constants, but is otherwise empty. An application can
    extend it and declare the resulting service component in its manifest as shown
    in [Example 11-16](ch11.html#declaring_an_off-host_apdu_service_in_an "Example 11-16. Declaring
    an off-host APDU service in AndroidManifest.xml").
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK 包含一个辅助服务（`OffHostApduService`），可以用来列出应该直接路由到 SE 的 AID。这个 `OffHostApduService`
    类定义了一些有用的常量，但除此之外是空的。应用程序可以扩展它，并在其清单中声明生成的服务组件，如 [示例 11-16](ch11.html#declaring_an_off-host_apdu_service_in_an
    "示例 11-16. 在 AndroidManifest.xml 中声明一个 off-host APDU 服务") 所示。
- en: Example 11-16. Declaring an off-host APDU service in AndroidManifest.xml
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-16. 在 AndroidManifest.xml 中声明一个 off-host APDU 服务
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The service declaration is similar to that of [Example 11-14](ch11.html#declaring_a_hce_service_in_androidmanife
    "Example 11-14. Declaring a HCE service in AndroidManifest.xml"), except that
    the declared intent action is *android.nfc.cardemulation.action.OFF_HOST_ APDU_SERVICE*
    ➊ and the XML metadata name is *android.nfc.cardemulation.off_host_apdu_service*
    ➋. The metadata file is also slightly different, as shown in [Example 11-17](ch11.html#off-host_apdu_service_metadata_file
    "Example 11-17. Off-host APDU service metadata file").
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 服务声明与 [示例 11-14](ch11.html#declaring_a_hce_service_in_androidmanife "示例 11-14.
    在 AndroidManifest.xml 中声明一个 HCE 服务") 类似，区别在于声明的意图动作是 *android.nfc.cardemulation.action.OFF_HOST_
    APDU_SERVICE* ➊，而 XML 元数据名称是 *android.nfc.cardemulation.off_host_apdu_service*
    ➋。元数据文件也略有不同，如 [示例 11-17](ch11.html#off-host_apdu_service_metadata_file "示例 11-17.
    Off-host APDU 服务元数据文件") 所示。
- en: Example 11-17. Off-host APDU service metadata file
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-17. Off-host APDU 服务元数据文件
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the format is the same as that of an HCE service, but the root
    element of the file is `<offhost-apdu-service>` ➊ instead of `<host-apdu-service>`.
    Another subtle difference is that `<offhost-apdu-service>` does not support the
    `requireDeviceUnlock` attribute, because transactions are sent directly to the
    SE and therefore the host cannot intervene regardless of the state of the lockscreen.
    The AIDs of the applets residing on the SE (➌ and ➍) are included in a `<aid-group>`
    ➋. Those AIDs are sent directly to the NFC controller, which saves them in its
    internal routing table in order to be able to send matching APDUs directly to
    the SE, without interacting with the Android OS. If the received APDU is not in
    the NFC controller’s routing table, it forwards it to the `NfcService`, which
    sends it to the matching HCE service, or returns an error if no matches are found.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该格式与HCE服务相同，但文件的根元素是`<offhost-apdu-service>` ➊，而不是`<host-apdu-service>`。另一个细微的区别是，`<offhost-apdu-service>`不支持`requireDeviceUnlock`属性，因为事务是直接发送到SE的，因此无论锁屏状态如何，主机都无法干预。驻留在SE上的Applet的AID（➌和➍）包含在`<aid-group>`
    ➋中。这些AID直接发送到NFC控制器，NFC控制器将其保存在内部路由表中，以便能够直接向SE发送匹配的APDU，而无需与Android操作系统交互。如果接收到的APDU不在NFC控制器的路由表中，它会将其转发到`NfcService`，后者会将其发送到匹配的HCE服务，或者如果没有匹配项，则返回错误。
- en: Writing an HCE Service
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写HCE服务
- en: When the HCE service of an application has been declared in its manifest as
    shown in [Example 11-14](ch11.html#declaring_a_hce_service_in_androidmanife "Example 11-14. Declaring
    a HCE service in AndroidManifest.xml"), HCE functionality can be added by extending
    the `HostApduService` base class and implementing its abstract methods as shown
    in [Example 11-18](ch11.html#implementing_a_hostapduservice "Example 11-18. Implementing
    a HostApduService").
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序的HCE服务在其清单中声明时，如[示例11-14](ch11.html#declaring_a_hce_service_in_androidmanife
    "示例11-14：在AndroidManifest.xml中声明HCE服务")所示，可以通过扩展`HostApduService`基类并实现其抽象方法来添加HCE功能，如[示例11-18](ch11.html#implementing_a_hostapduservice
    "示例11-18：实现HostApduService")所示。
- en: Example 11-18. Implementing a `HostApduService`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 示例11-18：实现`HostApduService`
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the example HCE service first declares a few constants that will be helpful
    when accessing APDU data ➊ and returning a standard status result ➋. The service
    defines the `SELECT` command that is used to activate it, including the AID ➌.
    The next few constants ➍ declare the instruction class (*CLA*) and instructions
    that the service can handle.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，示例HCE服务首先声明了一些常量，这些常量在访问APDU数据➊和返回标准状态结果➋时会很有帮助。该服务定义了用于激活它的`SELECT`命令，包括AID
    ➌。接下来的几个常量➍声明了服务可以处理的指令类(*CLA*)和指令。
- en: When the HCE service receives an APDU, it passes it to the `processCommandApdu()`
    method as a byte array, which the service analyzes. If the service hasn’t been
    selected yet, the `processCommandApdu()` method checks if the APDU contains a
    `SELECT` command ➎, and sets the `selected` flag if it does. If the APDU contains
    some other command, the code checks to see if it has a class byte (*CLA*) the
    services supports ➏, and then extracts the instruction byte (*INS*) included in
    the command ➐. If the command APDU contains the `INS_CMD1` instruction ➑, the
    service extracts the *P1* and *P2* parameters, possibly parses the data included
    in the APDU (not shown), sets some internal state, and returns a success status.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当HCE服务接收到APDU时，它将其作为字节数组传递给`processCommandApdu()`方法，该方法分析该数组。如果服务尚未被选择，`processCommandApdu()`方法会检查APDU是否包含`SELECT`命令➎，如果包含，则设置`selected`标志。如果APDU包含其他命令，代码会检查它是否包含服务支持的类字节(*CLA*)➏，然后提取命令中包含的指令字节(*INS*)➐。若命令APDU包含`INS_CMD1`指令➑，服务会提取*P1*和*P2*参数，可能会解析APDU中包含的数据（未显示），设置一些内部状态，并返回成功状态。
- en: If the command includes `INS_CMD2`, which in our example maps to a hypothetical
    operation that requires some time to process (for example, asymmetric key generation),
    the service starts a worker thread (not shown), and returns `null` ➒ in order
    not to block the main thread of the application. When the worker thread completes
    execution, it can return its result using the inherited `sendResponseApdu()` (defined
    in the parent `HostApduService` class). When another service or SE applet is selected,
    the system calls the `onDeactivated()` method, which should release any used resources
    before returning, but in our example simply sets the `selected` flag to `false`
    ➓.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令包括 `INS_CMD2`，在我们的示例中，这映射到一个假设的需要一定时间来处理的操作（例如，非对称密钥生成），服务将启动一个工作线程（未显示），并返回
    `null` ➒ 以避免阻塞应用的主线程。当工作线程完成执行时，它可以使用继承自 `HostApduService` 类的 `sendResponseApdu()`
    方法返回结果。当选择另一个服务或 SE 小程序时，系统会调用 `onDeactivated()` 方法，该方法应在返回之前释放任何已使用的资源，但在我们的示例中，它只是将
    `selected` 标志设置为 `false` ➓。
- en: Because an HCE service essentially parses command APDUs and returns responses,
    the programming model is very similar to that of Java Card applets. However, because
    a HCE service lives inside a regular Android application, it does not execute
    in a constrained environment and can take advantage of all available Android features.
    This makes it easy to implement complex functionality, but also impacts the security
    of HCE apps, as discussed next.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 HCE 服务本质上是解析命令 APDU 并返回响应，因此编程模型与 Java Card 小程序非常相似。然而，由于 HCE 服务存在于常规的 Android
    应用程序内，它并不运行在受限的环境中，可以利用所有可用的 Android 功能。这使得实现复杂功能变得容易，但也影响了 HCE 应用的安全性，接下来将讨论这一点。
- en: Security of HCE Applications
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HCE 应用的安全性
- en: Because any Android application can declare an HCE service and receive and process
    APDUs, the system guarantees that a malicious application cannot inject rogue
    APDU commands into an HCE service by requiring the `BIND_NFC_SERVICE` system signature
    permission in order to bind to HCE services. Additionally, Android’s sandboxing
    model ensures that other applications cannot access sensitive data stored by the
    HCE application by reading its files or calling any data access APIs it might
    expose without permission (assuming such APIs have been properly secured, of course).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何 Android 应用都可以声明 HCE 服务并接收和处理 APDU，因此系统通过要求 `BIND_NFC_SERVICE` 系统签名权限才能绑定到
    HCE 服务，保证恶意应用无法向 HCE 服务注入伪造的 APDU 命令。此外，Android 的沙箱模型确保其他应用无法通过读取 HCE 应用的文件或调用其可能公开的数据访问
    API 来访问 HCE 应用存储的敏感数据，前提是这些 API 已正确加固（当然，假设这些 API 已得到了妥善保护）。
- en: Nevertheless, a malicious application that manages to obtain root privileges
    on a device (for example, by exploiting a privilege escalation vulnerability)
    can both inspect and inject APDUs targeted at an HCE service, and read its private
    data. The HCE application can take some measures to detect this situation, for
    example by inspecting the identity and signing certificate of the caller of its
    `processCommandApdu()` method, but such measures can ultimately be defeated given
    unconstrained access to the OS. Like all applications that store sensitive data,
    HCE applications should also take steps to protect stored data, such as by encrypting
    it on disk or by storing it in the system credential store in the case of cryptographic
    keys. Another way to protect both the code and data of HCE applications is to
    forward all received commands to a remote server, over an encrypted channel, and
    relay only its replies. However, because most of these measures are implemented
    in software, they can ultimately be disabled or bypassed by a sufficiently sophisticated
    malicious application with root access.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，能够获取设备 root 权限的恶意应用（例如，通过利用权限提升漏洞）既可以检查也可以注入针对 HCE 服务的 APDU，还可以读取其私有数据。HCE
    应用可以采取一些措施来检测这种情况，例如检查调用其 `processCommandApdu()` 方法的调用者的身份和签名证书，但考虑到对操作系统的无限制访问，这些措施最终可能会被绕过。像所有存储敏感数据的应用一样，HCE
    应用也应该采取措施保护存储的数据，例如通过加密存储在磁盘上的数据，或在加密密钥的情况下将其存储在系统凭证存储中。另一种保护 HCE 应用代码和数据的方法是将所有接收到的命令通过加密通道转发到远程服务器，并仅转发其回复。然而，由于大多数这些措施是通过软件实现的，它们最终可能会被一个足够复杂的具有
    root 权限的恶意应用禁用或绕过。
- en: In contrast, hardware security elements offer physical tamper resistance, reduced
    attack surface due to their constrained functionality, and tight control over
    installed applets. Therefore, physical SEs are much harder to attack and provide
    much stronger protection of sensitive data used in typical card emulation scenarios
    like contactless payments, even when the default security guarantees of the host
    OS have been bypassed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，硬件安全元件提供物理篡改防护、由于功能受限而减少的攻击面以及对已安装小程序的严格控制。因此，物理SE更难以受到攻击，并且在典型的卡片仿真场景（如非接触支付）中提供更强的敏感数据保护，即使默认的主机操作系统安全保证已被绕过。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*For a detailed discussion of the difference in security level of card emulation
    applications when implemented in secure elements as opposed to in software using
    HCE, see the “HCE vs embedded secure element” blog post series by Cem Paya (who
    worked on the original eSE-backed Google Wallet implementation).*^([[131](#ftn.ch11fn21)])'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关卡片仿真应用程序在安全元件中实现与通过HCE在软件中实现时安全级别差异的详细讨论，请参见Cem Paya（曾参与原始eSE支持的Google Wallet实现）的“HCE与嵌入式安全元件”博客系列。*^([[131](#ftn.ch11fn21)])'
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Android supports the three NFC modes: reader/writer, point-to-point, and card
    emulation. In reader/writer mode, Android devices can access NFC tags, contactless
    cards, and NFC emulation devices, while the point-to-point mode provides simple
    data exchange functionality. The card emulation mode can be backed either by a
    physical secure element (SE) such as a UICC, one that is integrated with the NFC
    controller (embedded SE), or by regular Android applications since Android 4.4\.
    Hardware security elements provide the highest security by offering physical tamper
    resistance and stringent control over SE application (typically implemented as
    Java Card applets) management. However, because the authentication keys required
    to install an application on an SE are typically controlled by a single entity
    (such as the device manufacturer or MNO), distributing SE applications can be
    problematic. Host-based card emulation (HCE), introduced in Android 4.4, makes
    it easy to develop and distribute applications that work in card emulation mode,
    but it relies solely on the OS to enforce security and therefore offers weaker
    protection of sensitive application code and data.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持三种NFC模式：读写模式、点对点模式和卡片仿真模式。在读写模式下，Android设备可以访问NFC标签、非接触式卡片和NFC仿真设备，而点对点模式提供简单的数据交换功能。卡片仿真模式可以通过物理安全元件（SE）如UICC、与NFC控制器集成的安全元件（嵌入式SE）或从Android
    4.4开始的常规Android应用程序来支持。硬件安全元件提供最高的安全性，通过提供物理篡改防护和对SE应用程序（通常以Java Card小程序实现）管理的严格控制，确保安全。然而，由于安装应用程序所需的认证密钥通常由单一实体（如设备制造商或移动网络运营商）控制，因此分发SE应用程序可能会遇到问题。Android
    4.4引入的基于主机的卡片仿真（HCE）简化了开发和分发卡片仿真模式应用程序的过程，但它仅依赖操作系统来执行安全性，因此对敏感应用程序代码和数据的保护较弱。
- en: '* * *'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[111](#ch11fn01)]) The NDEF format and its implementation using various
    tag technologies are described in the NFC Forum specification, available on its
    website: *[http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/](http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/)*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[111](#ch11fn01)]) NDEF格式及其使用各种标签技术的实现已在NFC论坛规范中描述，规范可在其官网获取：* [http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/](http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/)
    *
- en: ^([[112](#ch11fn02)]) Official versions of all ISO standards can be purchased
    on its website, *[http://www.iso.org/iso/home/store/catalogue_ics.htm](http://www.iso.org/iso/home/store/catalogue_ics.htm)*.
    Draft versions of standards can usually be obtained from the website of the standard
    working group.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[112](#ch11fn02)]) 所有ISO标准的正式版本可以在其官方网站上购买，* [http://www.iso.org/iso/home/store/catalogue_ics.htm](http://www.iso.org/iso/home/store/catalogue_ics.htm)
    *。标准草案版本通常可以从标准工作组的官网获得。
- en: ^([[113](#ch11fn03)]) Google, *Android API Reference*, “TagTechnology,” *[https://developer.android.com/reference/android/nfc/tech/TagTechnology.html](https://developer.android.com/reference/android/nfc/tech/TagTechnology.html)*
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[113](#ch11fn03)]) Google, *Android API参考*, “TagTechnology,” *[https://developer.android.com/reference/android/nfc/tech/TagTechnology.html](https://developer.android.com/reference/android/nfc/tech/TagTechnology.html)*
- en: ^([[114](#ch11fn04)]) Google, *Android API Reference*, “NfcAdapter,” *[https://developer.android.com/reference/android/nfc/NfcAdapter.html](https://developer.android.com/reference/android/nfc/NfcAdapter.html)*
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[114](#ch11fn04)]) 谷歌，*Android API 参考*，“NfcAdapter”，*[https://developer.android.com/reference/android/nfc/NfcAdapter.html](https://developer.android.com/reference/android/nfc/NfcAdapter.html)*
- en: ^([[115](#ch11fn05)]) NFC Forum, “NFC Forum Technical Specifications,” *[http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/](http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/)*
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[115](#ch11fn05)]) NFC 联盟，“NFC 联盟技术规范”，*[http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/](http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/)*
- en: ^([[116](#ch11fn06)]) Google, *Android API Guides*, “NFC Basics,” *[https://developer.android.com/guide/topics/connectivity/nfc/nfc.html#p2p](https://developer.android.com/guide/topics/connectivity/nfc/nfc.html#p2p)*
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[116](#ch11fn06)]) 谷歌，*Android API 指南*，“NFC 基础”，*[https://developer.android.com/guide/topics/connectivity/nfc/nfc.html#p2p](https://developer.android.com/guide/topics/connectivity/nfc/nfc.html#p2p)*
- en: ^([[117](#ch11fn07)]) 3GPP, *AT command set for User Equipment (UE)*, *[http://www.3gpp.org/ftp/Specs/html-info/27007.htm](http://www.3gpp.org/ftp/Specs/html-info/27007.htm)*
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[117](#ch11fn07)]) 3GPP，*用户设备（UE）AT 命令集*，*[http://www.3gpp.org/ftp/Specs/html-info/27007.htm](http://www.3gpp.org/ftp/Specs/html-info/27007.htm)*
- en: ^([[118](#ch11fn08)]) “Secure Element Evaluation Kit for the Android platform,”
    *[https://code.google.com/p/seek-for-android/](https://code.google.com/p/seek-for-android/)*
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[118](#ch11fn08)]) “Android 平台的安全元件评估工具包”，*[https://code.google.com/p/seek-for-android/](https://code.google.com/p/seek-for-android/)*
- en: ^([[119](#ch11fn09)]) SIMalliance Limited, *Open Mobile API Specification v2.05*,
    *[http://www.simalliance.org/en?t=/documentManager/sfdoc.file.supply&fileID=1392314878580](http://www.simalliance.org/en?t=/documentManager/sfdoc.file.supply&fileID=1392314878580)*
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[119](#ch11fn09)]) SIMalliance 有限公司，*Open Mobile API 规范 v2.05*，*[http://www.simalliance.org/en?t=/documentManager/sfdoc.file.supply&fileID=1392314878580](http://www.simalliance.org/en?t=/documentManager/sfdoc.file.supply&fileID=1392314878580)*
- en: '^([[120](#ch11fn10)]) SD Association, “Advanced Security SD Card: ASSD,” *[https://www.sdcard.org/developers/overview/ASSD/](https://www.sdcard.org/developers/overview/ASSD/)*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[120](#ch11fn10)]) SD 协会，“高级安全 SD 卡：ASSD”，*[https://www.sdcard.org/developers/overview/ASSD/](https://www.sdcard.org/developers/overview/ASSD/)*
- en: '^([[121](#ch11fn11)]) ECMA International, *ECMA-373: Near Field Communication
    Wired Interface (NFC-WI)*, *[http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-373.pdf](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-373.pdf)*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[121](#ch11fn11)]) ECMA 国际，*ECMA-373：近场通信有线接口 (NFC-WI)*，*[http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-373.pdf](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-373.pdf)*
- en: '^([[122](#ch11fn12)]) Oracle, “JSR 177: Security and Trust Services API for
    J2METM,” *[https://jcp.org/en/jsr/detail?id=177](https://jcp.org/en/jsr/detail?id=177)*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[122](#ch11fn12)]) 甲骨文公司，“JSR 177：J2METM的安全性和信任服务 API”，*[https://jcp.org/en/jsr/detail?id=177](https://jcp.org/en/jsr/detail?id=177)*
- en: ^([[123](#ch11fn13)]) Oracle, “Java Card Classic Platform Specification 3.0.4,”
    *[http://www.oracle.com/technetwork/java/javacard/specs-jsp-136430.html](http://www.oracle.com/technetwork/java/javacard/specs-jsp-136430.html)*
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[123](#ch11fn13)]) 甲骨文公司，“Java Card 经典平台规范 3.0.4”，*[http://www.oracle.com/technetwork/java/javacard/specs-jsp-136430.html](http://www.oracle.com/technetwork/java/javacard/specs-jsp-136430.html)*
- en: ^([[124](#ch11fn14)]) GlobalPlatform, “Card Specifications,” *[http://www.globalplatform.org/specificationscard.asp](http://www.globalplatform.org/specificationscard.asp)*
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[124](#ch11fn14)]) GlobalPlatform，“卡片规范”，*[http://www.globalplatform.org/specificationscard.asp](http://www.globalplatform.org/specificationscard.asp)*
- en: '^([[125](#ch11fn15)]) A summary of ISO 7816 and other smart card-related standards
    is available on CardWerk’s website: *[http://www.cardwerk.com/smartcards/smartcard_standards.aspx](http://www.cardwerk.com/smartcards/smartcard_standards.aspx)*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[125](#ch11fn15)]) ISO 7816 和其他智能卡相关标准的总结可以在 CardWerk 网站找到：*[http://www.cardwerk.com/smartcards/smartcard_standards.aspx](http://www.cardwerk.com/smartcards/smartcard_standards.aspx)*
- en: ^([[126](#ch11fn16)]) Google, *Android Security Overview*, “SIM Card Access,”
    *[https://source.android.com/devices/tech/security/#sim-card-access](https://source.android.com/devices/tech/security/#sim-card-access)*
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[126](#ch11fn16)]) 谷歌，*Android 安全概述*，“SIM 卡访问”，*[https://source.android.com/devices/tech/security/#sim-card-access](https://source.android.com/devices/tech/security/#sim-card-access)*
- en: ^([[127](#ch11fn17)]) *SEEK for Android*, “SmartCardAPI*,” [https://code.google.com/p/seek-for-android/wiki/SmartcardAPI](https://code.google.com/p/seek-for-android/wiki/SmartcardAPI)*
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[127](#ch11fn17)]) *SEEK for Android*，“SmartCardAPI*”，[https://code.google.com/p/seek-for-android/wiki/SmartcardAPI](https://code.google.com/p/seek-for-android/wiki/SmartcardAPI)
- en: ^([[128](#ch11fn18)]) CyanogenMod*, [http://www.cyanogenmod.org/](http://www.cyanogenmod.org/)*
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[128](#ch11fn18)]) CyanogenMod*， [http://www.cyanogenmod.org/](http://www.cyanogenmod.org/)*
- en: ^([[129](#ch11fn19)]) Google, *Android API Reference*, “Messenger,” *[https://developer.android.com/reference/android/os/Messenger.html](https://developer.android.com/reference/android/os/Messenger.html)*
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[129](#ch11fn19)]) Google，*Android API参考*，“Messenger，” *[https://developer.android.com/reference/android/os/Messenger.html](https://developer.android.com/reference/android/os/Messenger.html)*
- en: ^([[130](#ch11fn20)]) Google*, Host-based Card Emulation*, “Payment Applications,”
    *[https://developer.android.com/guide/topics/connectivity/nfc/hce.html#PaymentApps](https://developer.android.com/guide/topics/connectivity/nfc/hce.html#PaymentApps)*
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[130](#ch11fn20)]) Google*，基于主机的卡片模拟*，“支付应用程序，” *[https://developer.android.com/guide/topics/connectivity/nfc/hce.html#PaymentApps](https://developer.android.com/guide/topics/connectivity/nfc/hce.html#PaymentApps)*
- en: ^([[131](#ch11fn21)]) Cem Paya*, Random Oracle*, “HCE vs embedded secure element,”
    parts I to VI, *[http://randomoracle.wordpress.com/2014/03/08/hce-vs-embedded-secure-element-comparing-risks-part-i/](http://randomoracle.wordpress.com/2014/03/08/hce-vs-embedded-secure-element-comparing-risks-part-i/)*
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[131](#ch11fn21)]) Cem Paya*，随机Oracle*，“HCE与嵌入式安全元件，”第一至第六部分，* [http://randomoracle.wordpress.com/2014/03/08/hce-vs-embedded-secure-element-comparing-risks-part-i/](http://randomoracle.wordpress.com/2014/03/08/hce-vs-embedded-secure-element-comparing-risks-part-i/)*
