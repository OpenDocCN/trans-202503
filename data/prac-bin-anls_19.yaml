- en: B
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B
- en: IMPLEMENTING PT_NOTE OVERWRITING USING LIBELF
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`libelf`实现`PT_NOTE`覆盖
- en: In [Chapter 7](ch07.xhtml#ch07), you learned how to inject a code section by
    overwriting the `PT_NOTE` segment at a high level. Here, you’ll see how the `elfinject`
    tool you’ll find on the virtual machine implements this technique. In the process
    of describing the `elfinject` source, you’ll also learn about `libelf`, a popular
    open source library for manipulating the contents of ELF binaries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.xhtml#ch07)中，你学会了如何通过覆盖`PT_NOTE`段以高层次方式注入代码段。在这里，你将看到虚拟机中的`elfinject`工具如何实现这一技术。在描述`elfinject`源代码的过程中，你还将了解`libelf`，这是一个流行的开源库，用于操作ELF二进制文件的内容。
- en: I’ll focus on the parts of the code that implement the steps from [Figure 7-2](ch07.xhtml#ch07fig2)
    ([page 170](ch07.xhtml#page_170)) using `libelf`, leaving out some parts of the
    code that are straightforward and don’t involve `libelf`. To learn more, you can
    find the rest of the `elfinject` source on the virtual machine located in the
    code directory for [Chapter 7](ch07.xhtml#ch07).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将重点介绍实现[图7-2](ch07.xhtml#ch07fig2)（[第170页](ch07.xhtml#page_170)）中的步骤的代码部分，这些步骤使用了`libelf`，并省略一些直观且不涉及`libelf`的代码部分。如需了解更多，可以在虚拟机上的代码目录中找到`elfinject`的其余源代码，位于[第7章](ch07.xhtml#ch07)。
- en: Be sure to read [Section 7.3.2](ch07.xhtml#ch07_3_2) before reading this appendix,
    as knowing the inputs and outputs that `elfinject` expects will make the code
    easier to follow.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本附录之前，请务必阅读[第7.3.2节](ch07.xhtml#ch07_3_2)，因为了解`elfinject`期望的输入和输出将使代码更易于理解。
- en: In this discussion, I’ll use only the parts of the `libelf` API that `elfinject`
    uses to give you a good working understanding of the essentials of `libelf`. For
    more details, refer to the excellent `libelf` documentation or to “`libelf` by
    Example” by Joseph Koshy.^([1](footnote.xhtml#appbfn_1))
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本讨论中，我只会使用`elfinject`所使用的`libelf`API部分，以帮助你理解`libelf`的基本要点。欲了解更多细节，请参考优秀的`libelf`文档，或参考Joseph
    Koshy的《`libelf`实例》一书。^([1](footnote.xhtml#appbfn_1))
- en: B.1 Required Headers
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1 必需的头文件
- en: To parse ELF files, `elfinject` uses the popular open source library `libelf`,
    which is preinstalled on the virtual machine and is available as a package for
    most Linux distributions. To use `libelf`, you need to include a few header files,
    as shown in [Listing B-1](appb.xhtml#appblist1). You also need to link against
    `libelf` by providing the `-lelf` option to the linker.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析ELF文件，`elfinject`使用了流行的开源库`libelf`，该库已经预装在虚拟机中，并且大多数Linux发行版都有这个包。要使用`libelf`，你需要包含一些头文件，如[清单B-1](appb.xhtml#appblist1)所示。你还需要通过向链接器提供`-lelf`选项来链接`libelf`。
- en: '*Listing B-1:* elfinject.c*:* libelf *headers*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单B-1:* elfinject.c*:* libelf *头文件*'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For brevity, [Listing B-1](appb.xhtml#appblist1) doesn’t show all the standard
    C/C++ headers `elfinject` uses, but only two related to `libelf`. The main one
    is *libelf.h* ➊, which provides access to all of `libelf`’s data structures and
    API functions. The other is *gelf.h* ➋, which provides access to `GElf`, a supporting
    API that provides easier access to some of `libelf`’s functionality. `GElf` allows
    you to access ELF files in a way that’s transparent to the ELF class and bit width
    (32-bit versus 64-bit) of the file. The benefit of this will become clear as you
    see more of the `elfinject` code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，[清单B-1](appb.xhtml#appblist1)未显示`elfinject`使用的所有标准C/C++头文件，而仅显示了两个与`libelf`相关的头文件。主要的头文件是*libelf.h*
    ➊，它提供了对`libelf`所有数据结构和API函数的访问。另一个是*gelf.h* ➋，它提供了对`GElf`的访问，`GElf`是一个辅助API，简化了对`libelf`某些功能的访问。`GElf`使你能够透明地访问ELF文件，而无需关心文件的ELF类和位宽（32位与64位）。这种方式的好处将在你看到更多`elfinject`代码时变得更为明显。
- en: B.2 Data Structures Used in elfinject
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2 `elfinject`中使用的数据结构
- en: '[Listing B-2](appb.xhtml#appblist2) shows two data structures that are central
    to `elfinject`. The rest of the code uses these data structures to manipulate
    the ELF file and the code to inject.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单B-2](appb.xhtml#appblist2)展示了两个在`elfinject`中核心使用的数据结构。其余代码使用这些数据结构来操作ELF文件及注入的代码。'
- en: '*Listing B-2:* elfinject.c*:* elfinject *data structures*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单B-2:* elfinject.c*:* elfinject *数据结构*'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first data structure `elf_data_t` ➊ keeps track of data needed to manipulate
    the ELF binary in which the new code section is to be injected. It contains a
    file descriptor for the ELF file (`fd`), a `libelf` handle to the file, an integer
    denoting the binary’s bit width (`bits`), and a `GElf` handle to the binary’s
    executable header. I’ll omit the standard C code that opens `fd`, so from this
    point on, consider `fd` to be opened for reading and writing. I will show the
    code that opens the `libelf` and `GElf` handles shortly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据结构`elf_data_t`➊跟踪在注入新代码段的ELF二进制文件中需要操作的数据。它包含一个指向ELF文件的文件描述符（`fd`）、一个指向文件的`libelf`句柄、一个表示二进制文件位宽的整数（`bits`），以及指向二进制文件可执行头的`GElf`句柄。我将省略打开`fd`的标准C代码，因此从这一点开始，假设`fd`已经被打开用于读写。我稍后会展示打开`libelf`和`GElf`句柄的代码。
- en: The `inject_data_t` structure ➋ tracks information about the code to inject
    and where and how to inject it in the binary. First, it contains data on which
    parts of the binary need to be modified to inject the new code. This data includes
    the index (`pidx`) and `GElf` handle (`phdr`) of the `PT_NOTE` program header
    to overwrite with the injected header. It also includes the index (`sidx`) and
    `libelf` and `GElf` handles (`scn` and `shdr`, respectively) of the section to
    overwrite as well as the file offset to the section name in the string table (`shstroff`)
    to change to a new name, like `.injected`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`inject_data_t`结构体➋跟踪有关要注入的代码以及如何在二进制文件中注入这些代码的信息。首先，它包含有关需要修改二进制文件哪些部分来注入新代码的数据。这些数据包括要覆盖的`PT_NOTE`程序头的索引（`pidx`）和`GElf`句柄（`phdr`）。它还包括要覆盖的段的索引（`sidx`）以及`libelf`和`GElf`句柄（分别是`scn`和`shdr`），以及指向该段名称在字符串表中的文件偏移量（`shstroff`），以便将其更改为一个新名称，比如`.injected`。'
- en: Then comes the actual code to inject in the form of a buffer (`code`) and an
    integer describing the length of that buffer (`len`). This code is given by the
    `elfinject` user, so let’s consider `code` and `len` to be set from this point
    on. The `entry` field is an offset within the `code` buffer, pointing to the code
    location that should become the new entry point for the binary. If there’s no
    new entry point, then `entry` is set to `-1` to indicate this.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是实际注入的代码，以缓冲区（`code`）和描述该缓冲区长度的整数（`len`）的形式给出。这段代码由`elfinject`用户提供，因此从这一点开始，假设`code`和`len`已经被设置。`entry`字段是`code`缓冲区内的一个偏移量，指向应该成为二进制文件新入口点的代码位置。如果没有新的入口点，那么`entry`被设置为`-1`来表示这一点。
- en: The `off` field is the file offset in the binary where the new code should be
    injected. This will point to the end of the binary because that’s where `elfinject`
    places the new code, as shown in [Figure 7-2](ch07.xhtml#ch07fig2). Finally, `secaddr`
    is the load address for the new code section, and `secname` is the name of the
    injected section. You can consider all the fields from `entry` to `secname` to
    be set as well, as they’re all user specified except for `off`, which `elfinject`
    computes when it loads the binary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`off`字段是二进制文件中应注入新代码的文件偏移量。这个偏移量将指向二进制文件的末尾，因为`elfinject`会将新代码放置在此位置，如[图7-2](ch07.xhtml#ch07fig2)所示。最后，`secaddr`是新代码段的加载地址，`secname`是被注入段的名称。你可以认为从`entry`到`secname`的所有字段都已经被设置，因为这些都是用户指定的，除了`off`，它是`elfinject`在加载二进制文件时计算的。'
- en: B.3 Initializing libelf
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3 初始化libelf
- en: 'At this point, let’s skip past the `elfinject` initialization code and assume
    that all initialization succeeded: the user arguments are parsed, a file descriptor
    to the host binary is opened, and the inject file is loaded into the code buffer
    in a `struct inject_data_t`. All of this initialization stuff takes place in the
    `main` function of `elfinject`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们跳过`elfinject`的初始化代码，假设所有初始化都已成功：用户参数已经解析，主机二进制文件的文件描述符已打开，注入文件已加载到`struct
    inject_data_t`中的代码缓冲区。所有这些初始化工作都在`elfinject`的`main`函数中进行。
- en: After that, `main` passes control to a function called `inject_code`, which
    is the starting point for the actual code injection. Let’s take a look at [Listing
    B-3](appb.xhtml#appblist3), which shows the part of `inject_code` that opens the
    given ELF binary in `libelf`. Keep in mind that function names starting with `elf_`
    are `libelf` functions and names starting with `gelf_` are `GElf` functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`main`将控制权传递给一个名为`inject_code`的函数，这是实际代码注入的起点。让我们来看一下[清单B-3](appb.xhtml#appblist3)，其中展示了`inject_code`的一部分，负责在`libelf`中打开给定的ELF二进制文件。请记住，函数名称以`elf_`开头的是`libelf`函数，而以`gelf_`开头的是`GElf`函数。
- en: '*Listing B-3:* elfinject.c*:* inject_code *function*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单B-3:* elfinject.c*:* inject_code *函数*'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: An important local variable in the `inject_code` function, `elf` ➊ is an instance
    of the `elf_data_t` struct type defined previously, and it’s used to store all
    the important information about the loaded ELF binary to pass to other functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`inject_code` 函数中的一个重要局部变量，`elf` ➊ 是先前定义的 `elf_data_t` 结构类型的一个实例，用于存储加载的 ELF
    二进制文件的所有重要信息，并将其传递给其他函数。'
- en: Before using any other `libelf` API functions, you must call `elf_version` ➋,
    which takes the version number of the ELF specification you want to use as its
    only parameter. If the version is not supported, `libelf` will complain by returning
    the constant `EV_NONE`, in which case `inject_code` gives up and reports an error
    initializing `libelf`. If `libelf` doesn’t complain, it means the ELF version
    requested is supported, and it’s safe to make other `libelf` calls to load and
    parse the binary.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用任何其他 `libelf` API 函数之前，必须调用 `elf_version` ➋，该函数接受一个 ELF 规范的版本号作为唯一参数。如果版本不受支持，`libelf`
    会通过返回常量 `EV_NONE` 来报告问题，在这种情况下，`inject_code` 会放弃并报告初始化 `libelf` 时出错。如果 `libelf`
    没有报告问题，说明请求的 ELF 版本是受支持的，接下来可以安全地进行其他 `libelf` 调用，以加载和解析二进制文件。
- en: At the moment, all standard ELF binaries are formatted according to major version
    1 of the specification, so this is the only legal value you can pass to `elf_version`.
    By convention, instead of passing a literal “1” to `elf_version`, you pass the
    constant value `EV_CURRENT`. Both `EV_NONE` and `EV_CURRENT` are specified in
    *elf.h*, which is the header that contains all the constants and data structures
    related to the ELF format, not *libelf.h*. If there’s a major revision of the
    ELF format, `EV_CURRENT` will be incremented to the next version on systems that
    use the new ELF version.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有标准 ELF 二进制文件都是根据规范的主版本 1 格式进行格式化的，因此这是你可以传递给 `elf_version` 的唯一合法值。按照约定，除了直接传递字面量的“1”给
    `elf_version`，你还可以传递常量值 `EV_CURRENT`。`EV_NONE` 和 `EV_CURRENT` 都在 *elf.h* 中进行了定义，而不是在
    *libelf.h* 中。若 ELF 格式有重大修订，`EV_CURRENT` 将在使用新 ELF 版本的系统上递增为下一个版本。
- en: After `elf_version` returns successfully, it’s safe to start loading and parsing
    the binary to inject the new code into. The first step is to call `elf_begin`
    ➌, which opens the ELF file and returns a handle to it of type `Elf*`. You can
    pass this handle to other `libelf` functions to perform operations on the ELF
    file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `elf_version` 成功返回后，可以开始加载并解析二进制文件，以便将新代码注入其中。第一步是调用 `elf_begin` ➌，该函数打开 ELF
    文件并返回一个类型为 `Elf*` 的句柄。你可以将该句柄传递给其他 `libelf` 函数，执行对 ELF 文件的操作。
- en: 'The `elf_begin` function takes three parameters: an open file descriptor for
    the ELF file, a constant that indicates whether to open the file for reading or
    writing, and a pointer to an `Elf` handle. In this case, the file descriptor is
    `fd`, and `inject_code` passes the constant `ELF_C_READ` to indicate that it’s
    interested only in using `libelf` to read the ELF binary. For the final parameter
    (the `Elf` handle), `inject_code` passes `NULL` so that `libelf` automatically
    allocates and returns a handle.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`elf_begin` 函数接受三个参数：用于打开 ELF 文件的文件描述符，一个常量，表示是否以读或写模式打开文件，以及指向 `Elf` 句柄的指针。在这种情况下，文件描述符为
    `fd`，而 `inject_code` 传递常量 `ELF_C_READ`，表示它仅仅对使用 `libelf` 读取 ELF 二进制文件感兴趣。对于最后一个参数（`Elf`
    句柄），`inject_code` 传递 `NULL`，以便 `libelf` 自动分配并返回一个句柄。'
- en: Instead of `ELF_C_READ`, you can also pass `ELF_C_WRITE` or `ELF_C_RDWR` to
    indicate that you want to use `libelf` to write modifications to an ELF binary,
    or for a combination of read and write operations. For simplicity, `elfinject`
    only uses `libelf` to parse the ELF file. To write back any modifications, it
    circumvents `libelf` and simply uses the file descriptor `fd` directly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以传递 `ELF_C_WRITE` 或 `ELF_C_RDWR`，以表示希望使用 `libelf` 向 ELF 二进制文件写入修改，或者进行读写操作的组合。为了简化，`elfinject`
    仅使用 `libelf` 来解析 ELF 文件。为了将任何修改写回，它绕过 `libelf`，直接使用文件描述符 `fd`。
- en: After opening an ELF with `libelf`, you’ll typically pass the opened `Elf` handle
    to `elf_kind` to figure out what kind of ELF you’re dealing with ➍. In this case,
    `inject_code` compares `elf_kind`’s return value to the constant `ELF_K_ELF` to
    verify that the ELF file is an executable. The other possible return values are
    `ELF_K_AR` for ELF archives or `ELF_K_NULL` if an error occurred. In both cases,
    `inject_code` cannot perform the code injection, so it returns with an error.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `libelf` 打开 ELF 文件后，通常会将打开的 `Elf` 句柄传递给 `elf_kind`，以确定所处理的 ELF 类型 ➍。在这种情况下，`inject_code`
    将 `elf_kind` 的返回值与常量 `ELF_K_ELF` 进行比较，验证 ELF 文件是否为可执行文件。其他可能的返回值为 `ELF_K_AR`（表示
    ELF 存档文件）或 `ELF_K_NULL`（表示发生错误）。在这两种情况下，`inject_code` 无法执行代码注入，因此会返回错误。
- en: Next, `inject_code` uses a `GElf` function called `gelf_getclass` to find out
    the “class” of the ELF binary ➎. This indicates whether the ELF is 32-bit (`ELFCLASS32`)
    or 64-bit (`ELFCLASS64`). In case of error, `gelf_getclass` returns `ELFCLASSNONE`.
    The `ELFCLASS*` constants are defined in *elf.h*. For now, `inject_code` just
    stores the bit width of the binary (32 or 64) in the `bits` field of the `elf`
    structure. Knowing the bit width is necessary when parsing the ELF binary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`inject_code` 使用一个名为 `gelf_getclass` 的 `GElf` 函数来获取 ELF 二进制文件的“类” ➎。这表示
    ELF 文件是 32 位（`ELFCLASS32`）还是 64 位（`ELFCLASS64`）。如果发生错误，`gelf_getclass` 会返回 `ELFCLASSNONE`。`ELFCLASS*`
    常量在 *elf.h* 中定义。目前，`inject_code` 只将二进制文件的位宽（32 位或 64 位）存储在 `elf` 结构的 `bits` 字段中。了解位宽在解析
    ELF 二进制文件时是必要的。
- en: That covers initializing `libelf` and retrieving basic information about the
    binary. Now let’s consider the rest of the `inject_code` function, shown in [Listing
    B-4](appb.xhtml#appblist4).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以上就是初始化 `libelf` 并获取二进制文件基本信息的过程。接下来我们来看 `inject_code` 函数的其他部分，参见[清单 B-4](appb.xhtml#appblist4)。
- en: '*Listing B-4:* elfinject.c*:* inject_code *function (continued)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 B-4:* elfinject.c*:* inject_code *函数（续）*'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, the remainder of the `inject_code` function consists of several
    major steps, which correspond to the steps outlined in [Figure 7-2](ch07.xhtml#ch07fig2)
    as well as some extra low-level steps not shown in the figure:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`inject_code` 函数的其余部分包括几个主要步骤，这些步骤对应于[图 7-2](ch07.xhtml#ch07fig2)中列出的步骤，以及一些图中未显示的额外低级步骤：
- en: • Retrieve the binary’s executable header ➊, needed for adjusting the entry
    point later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: • 获取二进制可执行文件的头部 ➊，后续需要用来调整入口点。
- en: • Find the `PT_NOTE` segment ➋ to overwrite and fail if there is no suitable
    segment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: • 查找 `PT_NOTE` 段 ➋ 进行覆盖，如果没有合适的段则失败。
- en: • Write the injected code to the end of the binary ➌.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: • 将注入的代码写入二进制文件的末尾 ➌。
- en: • Adjust the injected section’s load address to meet alignment requirements
    ➍.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: • 调整注入部分的加载地址，以满足对齐要求 ➍。
- en: • Overwrite the `.note.ABI-tag` section header ➎ with a header for the new injected
    section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: • 用新注入部分的头部覆盖 `.note.ABI-tag` 节头 ➎。
- en: • Update the name of the section whose header was overwritten ➏.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: • 更新被覆盖的部分头部的节名称 ➏。
- en: • Overwrite the `PT_NOTE` program header ➐.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: • 覆盖 `PT_NOTE` 程序头 ➐。
- en: • Adjust the binary entry point if requested by the user ➑.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果用户要求，调整二进制文件的入口点 ➑。
- en: • Clean up the `Elf` handle by calling `elf_end` ➒.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过调用 `elf_end` 清理 `Elf` 句柄 ➒。
- en: I’ll go over these steps in more detail next.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我将更详细地讲解这些步骤。
- en: B.4 Getting the Executable Header
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4 获取可执行文件头
- en: In step ➊ in [Listing B-4](appb.xhtml#appblist4), `elfinject` gets the binary’s
    executable header. Recall from [Chapter 2](ch02.xhtml#ch02) that the executable
    header contains the file offsets and sizes of these tables. The executable header
    also contains the binary’s entry point address, which `elfinject` modifies if
    requested by the user.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 B-4](appb.xhtml#appblist4)的步骤 ➊ 中，`elfinject` 获取了二进制可执行文件的头部。回想一下[第2章](ch02.xhtml#ch02)，可执行文件头包含了这些表格的文件偏移量和大小。可执行文件头还包含了二进制文件的入口点地址，`elfinject`
    会根据用户的需求修改这个入口点地址。
- en: To get the ELF executable header, `elfinject` uses the `gelf_getehdr` function.
    This is a `GElf` function that returns an ELF class-agnostic representation of
    the executable header. The format of the executable header differs slightly between
    32-bit and 64-bit binaries, but `GElf` hides these differences so that you don’t
    have to worry about them. It’s also possible to get the executable header using
    only pure `libelf`, without `GElf`. However, in that case, you have to manually
    call `elf32_getehdr` or `elf64_getehdr` depending on the ELF class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 ELF 可执行文件头，`elfinject` 使用 `gelf_getehdr` 函数。这是一个 `GElf` 函数，它返回一个与 ELF 类无关的可执行文件头表示。32
    位和 64 位二进制文件的可执行文件头格式略有不同，但 `GElf` 隐藏了这些差异，因此你无需担心这些问题。也可以仅使用纯 `libelf` 获取可执行文件头，而不使用
    `GElf`。但是，在这种情况下，你必须根据 ELF 类手动调用 `elf32_getehdr` 或 `elf64_getehdr`。
- en: 'The `gelf_getehdr` function takes two parameters: the `Elf` handle and a pointer
    to a `GElf_Ehdr` structure where `GElf` can store the executable header. If all
    is well, `gelf_getehdr` returns a nonzero value. If there’s an error, it returns
    0 and sets `elf_errno`, an error code that you can read by calling `libelf`’s
    `elf_errno` function. This behavior is standard for all `GElf` functions.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`gelf_getehdr` 函数接受两个参数：`Elf` 句柄和一个指向 `GElf_Ehdr` 结构的指针，`GElf` 可以在其中存储可执行文件头。如果一切正常，`gelf_getehdr`
    返回非零值。如果发生错误，它返回 0 并设置 `elf_errno`，这是一个错误代码，你可以通过调用 `libelf` 的 `elf_errno` 函数来读取该错误代码。此行为是所有
    `GElf` 函数的标准行为。'
- en: To convert `elf_errno` to a human-readable error message, you can use the `elf_errmsg`
    function, but `elfinject` doesn’t do this. The `elf_errmsg` function takes the
    return value of `elf_errno` as input and returns a `const char*` pointing to the
    appropriate error string.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `elf_errno` 转换为人类可读的错误消息，你可以使用 `elf_errmsg` 函数，但 `elfinject` 并没有这么做。`elf_errmsg`
    函数接受 `elf_errno` 的返回值作为输入，并返回一个指向适当错误字符串的 `const char*`。
- en: B.5 Finding the PT_NOTE Segment
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5 查找 PT_NOTE 段
- en: After getting the executable header, `elfinject` loops over all the program
    headers in the binary to check whether the binary has a `PT_NOTE` segment that’s
    safe to overwrite (step ➋ in [Listing B-4](appb.xhtml#appblist4)). All of this
    functionality is implemented in a separate function called `find_rewritable_segment`,
    shown in [Listing B-5](appb.xhtml#appblist5).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取可执行文件头后，`elfinject` 会遍历二进制文件中的所有程序头，检查是否存在一个可以安全覆盖的 `PT_NOTE` 段（[清单 B-4](appb.xhtml#appblist4)
    中的步骤 ➋）。所有这些功能都在一个名为 `find_rewritable_segment` 的单独函数中实现，见[清单 B-5](appb.xhtml#appblist5)。
- en: '*Listing B-5:* elfinject.c*: finding the* PT_NOTE *program header*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 B-5:* elfinject.c*: 查找* PT_NOTE *程序头*'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As [Listing B-5](appb.xhtml#appblist5) shows, `find_rewritable_segment` takes
    two arguments: an `elf_data_t*` called `elf` and an `inject_data_t*` called `inject`.
    Recall that these are custom data types, defined in [Listing B-2](appb.xhtml#appblist2),
    which contain all the relevant information about the ELF binary and the inject.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 B-5](appb.xhtml#appblist5)所示，`find_rewritable_segment` 接受两个参数：一个名为 `elf`
    的 `elf_data_t*` 和一个名为 `inject` 的 `inject_data_t*`。回忆一下，这些是自定义数据类型，在[清单 B-2](appb.xhtml#appblist2)中定义，包含有关
    ELF 二进制文件和注入的所有相关信息。
- en: 'To find the `PT_NOTE` segment, `elfinject` first looks up the number of program
    headers that the binary contains ➊. This is done using a `libelf` function called
    `elf_getphdrnum`, which takes two arguments: the `Elf` handle and a pointer to
    a `size_t` integer where the number of program headers will be stored. If the
    return value is nonzero, it means an error occurred, and `elfinject` gives up
    because it cannot access the program header table. If there were no errors, `elf_getphdrnum`
    will have stored the number of program headers in the `size_t` called `n` in [Listing
    B-5](appb.xhtml#appblist5).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到 `PT_NOTE` 段，`elfinject` 首先查找二进制文件中包含的程序头数量 ➊。通过使用一个名为 `elf_getphdrnum`
    的 `libelf` 函数来实现，它接受两个参数：`Elf` 句柄和一个指向 `size_t` 类型整数的指针，用于存储程序头的数量。如果返回值非零，则表示发生了错误，`elfinject`
    会放弃，因为它无法访问程序头表。如果没有错误，`elf_getphdrnum` 会将程序头的数量存储在[清单 B-5](appb.xhtml#appblist5)中的
    `size_t` 类型变量 `n` 中。
- en: Now that `elfinject` knows the number of program headers `n`, it loops over
    each program header to find one of type `PT_NOTE` ➋. To access each program header,
    `elfinject` uses the `gelf_getphdr` function ➌, which allows you to access program
    headers in an ELF class-agnostic way. Its arguments are the `Elf` handle, the
    index number `i` of the program header to get, and a pointer to a `GElf_Phdr`
    struct (`inject->phdr` in this case) to store the program header in. As is usual
    for `GElf`, a nonzero return value indicates success, while return value 0 indicates
    failure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`elfinject`知道程序头的数量`n`，它遍历每个程序头以查找类型为`PT_NOTE`的头部➋。为了访问每个程序头，`elfinject`使用`gelf_getphdr`函数➌，该函数允许以与ELF类无关的方式访问程序头。它的参数是`Elf`句柄、要获取的程序头的索引号`i`以及一个指向`GElf_Phdr`结构体的指针（在本例中为`inject->phdr`），用于存储程序头。像`GElf`函数一样，非零返回值表示成功，而返回值0表示失败。
- en: After this step completes, `inject->phdr` contains the `i`-th program header.
    All that remains is to inspect the program header’s `p_type` field ➍ and check
    whether the type is `PT_NOTE` ➎. If it is, `elfinject` stores the program header
    index in the `inject->pidx` field ➏, and the `find_rewritable_segment` function
    returns successfully.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤完成后，`inject->phdr`包含第`i`个程序头。剩下的就是检查程序头的`p_type`字段➍，并检查其类型是否为`PT_NOTE`➎。如果是，`elfinject`将程序头索引存储在`inject->pidx`字段中➏，并且`find_rewritable_segment`函数成功返回。
- en: If, after looping over all program headers, `elfinject` failed to find a header
    of type `PT_NOTE`, it reports an error ➐ and exits without modifying the binary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在遍历所有程序头后，`elfinject`未能找到类型为`PT_NOTE`的头部，它会报告错误➐并退出，而不修改二进制文件。
- en: B.6 Injecting the Code Bytes
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.6 注入代码字节
- en: After locating the overwritable `PT_NOTE` segment, it’s time to append the injected
    code to the binary (step ➌ in [Listing B-4](appb.xhtml#appblist4)). Let’s look
    at the function that performs the actual inject, which is called `write_code`,
    as shown in [Listing B-6](appb.xhtml#appblist6).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在定位到可覆盖的`PT_NOTE`段后，就可以将注入的代码追加到二进制文件中（[列表 B-4](appb.xhtml#appblist4)中的步骤➌）。让我们来看一下执行实际注入操作的函数，它叫做`write_code`，如[列表
    B-6](appb.xhtml#appblist6)所示。
- en: '*Listing B-6:* elfinject.c*: appending the injected code to the binary*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 B-6:* elfinject.c*: 将注入的代码追加到二进制文件中*'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Like the `find_rewritable_segment` function you saw in the previous section,
    `write_code` takes the `elf_data_t*` called `elf` and the `inject_data_t*` called
    `inject` as its arguments. The `write_code` function doesn’t involve `libelf`;
    it only uses standard C file operations on `elf->fd`, the file descriptor of the
    opened ELF binary.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在前一节中看到的`find_rewritable_segment`函数一样，`write_code`函数将`elf_data_t*`类型的`elf`和`inject_data_t*`类型的`inject`作为参数。`write_code`函数不涉及`libelf`，它仅在打开的ELF二进制文件的文件描述符`elf->fd`上使用标准的C文件操作。
- en: First, `write_code` seeks to the end of the binary ➊. It then appends the injected
    code bytes there ➋ and saves the byte offset where the code bytes were written
    into the `inject->off` field of the `inject` data structure ➌.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`write_code`将光标定位到二进制文件的末尾➊。然后，它在那里追加注入的代码字节➋，并将代码字节写入的字节偏移量保存到`inject->off`字段中➌。
- en: Now that the code injection is done, all that remains is to update a section
    and program header (and optionally the binary entry point) to describe the new
    injected code section and ensure it gets loaded when the binary executes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码注入已经完成，剩下的就是更新一个段头和程序头（可选地更新二进制的入口点），以描述新注入的代码段，并确保在二进制执行时加载它。
- en: B.7 Aligning the Load Address for the Injected Section
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.7 对注入段的加载地址进行对齐
- en: 'With the injected code bytes appended to the end of the binary, it’s almost
    time to overwrite a section header to point to those injected bytes. The ELF specification
    places certain requirements on the addresses of loadable segments and, by extension,
    the sections they contain. Specifically, the ELF standard requires that for each
    loadable segment, `p_vaddr` is congruent to `p_offset` modulo the page size, which
    is 4,096 bytes. The following equation summarizes this requirement:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着注入的代码字节被追加到二进制文件的末尾，现在几乎可以覆盖一个段头以指向这些注入的字节。ELF规范对可加载段的地址以及它们包含的段提出了一些要求。具体来说，ELF标准要求对于每个可加载段，`p_vaddr`与`p_offset`在页大小（4,096字节）上的模运算结果必须相等。以下公式总结了这一要求：
- en: (*p*_*vaddr* mod 4096) =  (*p*_*offset* mod 4096)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: (*p*_*vaddr* mod 4096) =  (*p*_*offset* mod 4096)
- en: Similarly, the ELF standard requires that `p_vaddr` be congruent to `p_offset`
    modulo `p_align`. Therefore, before overwriting the section header, `elfinject`
    adjusts the user-specified memory address for the injected section so that it
    meets these requirements. [Listing B-7](appb.xhtml#appblist7) shows the code that
    aligns the address, which is the same code shown in step ➍ in [Listing B-4](appb.xhtml#appblist4).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，ELF 标准要求 `p_vaddr` 与 `p_offset` 在 `p_align` 模数下是同余的。因此，在覆盖节头之前，`elfinject`
    会调整用户指定的注入部分内存地址，使其满足这些要求。[清单 B-7](appb.xhtml#appblist7) 显示了对齐地址的代码，这与[清单 B-4](appb.xhtml#appblist4)中步骤
    ➍ 所示的代码相同。
- en: '*Listing B-7:* elfinject.c*: aligning the load address for the injected section*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 B-7:* elfinject.c*: 对注入部分的加载地址进行对齐*'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The alignment code in [Listing B-7](appb.xhtml#appblist7) consists of two steps.
    First, it computes the difference `n` between the injected code’s file offset
    modulo 4096 and the section address modulo 4096 ➊. The ELF specification requires
    that the offset and address are congruent modulo 4096 in which case `n` will be
    zero. To ensure correct alignment, `elfinject` adds `n` to the section address
    so that the difference with the file offset becomes zero modulo 4096 if it wasn’t
    already ➋.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 B-7](appb.xhtml#appblist7) 中的对齐代码包括两个步骤。首先，它计算注入代码的文件偏移量模 4096 与节地址模 4096
    之间的差值 `n` ➊。ELF 规范要求偏移量和地址在模 4096 下是同余的，此时 `n` 将为零。为了确保正确的对齐，`elfinject` 将 `n`
    加到节地址中，以便文件偏移量与节地址之间的差值在模 4096 下变为零（如果还没有的话）➋。'
- en: B.8 Overwriting the .note.ABI-tag Section Header
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.8 覆盖 `.note.ABI-tag` 节头
- en: Now that the address for the injected section is known, `elfinject` moves on
    to overwriting the section header. Recall that it overwrites the `.note.ABI-tag`
    section header that’s part of the `PT_NOTE` segment. [Listing B-8](appb.xhtml#appblist8)
    shows the function that handles the overwrite, called `rewrite_code_section`.
    It’s called in step ➎ in [Listing B-4](appb.xhtml#appblist4).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经知道了注入部分的地址，`elfinject` 继续覆盖节头。回想一下，它覆盖了 `.note.ABI-tag` 节头，该节头是 `PT_NOTE`
    段的一部分。[清单 B-8](appb.xhtml#appblist8) 显示了处理覆盖的函数，名为 `rewrite_code_section`。它在[清单
    B-4](appb.xhtml#appblist4)的步骤 ➎ 中被调用。
- en: '*Listing B-8:* elfinject.c*: overwriting the* .note.ABI-tag *section header*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 B-8:* elfinject.c*: 覆盖 * .note.ABI-tag * 节头*'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To find the `.note.ABI-tag` section header to overwrite, `rewrite_code _section`
    loops over all section headers and inspects the section names. Recall from [Chapter
    2](ch02.xhtml#ch02) that section names are stored in a special section called
    `.shstrtab`. To read the section names, `rewrite_code_section` first needs the
    index number of the section header describing the `.shstrtab` section. To get
    this index, you can read the `e_shstrndx` field of the executable header, or you
    can use the the function `elf_getshdrstrndx` provided by `libelf`. [Listing B-8](appb.xhtml#appblist8)
    uses the latter option ➊.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到需要覆盖的 `.note.ABI-tag` 节头，`rewrite_code_section` 会循环遍历所有节头并检查节名称。回想一下，在[第二章](ch02.xhtml#ch02)中提到过，节名称存储在一个名为
    `.shstrtab` 的特殊节中。为了读取节名称，`rewrite_code_section` 首先需要获取描述 `.shstrtab` 节的节头的索引号。要获取这个索引，可以读取可执行文件头的
    `e_shstrndx` 字段，或者可以使用 `libelf` 提供的 `elf_getshdrstrndx` 函数。[清单 B-8](appb.xhtml#appblist8)
    使用了后一种选项 ➊。
- en: 'The `elf_getshdrstrndx` function takes two parameters: an `Elf` handle and
    a pointer to a `size_t` integer to store the section index in. The function returns
    0 on success or sets `elf_errno` and returns −1 on failure.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`elf_getshdrstrndx` 函数接受两个参数：一个 `Elf` 句柄和一个指向 `size_t` 类型整数的指针，用于存储节索引。该函数在成功时返回
    0，失败时设置 `elf_errno` 并返回 -1。'
- en: After getting the index of `.shstrtab`, `rewrite_code_section` loops over all
    section headers, inspecting each one as it goes along. To loop over the section
    headers, it uses the `elf_nextscn` function ➋, which takes an `Elf` handle (`elf->e`)
    and `Elf_Scn*` (`scn`) as input. `Elf_Scn` is a struct defined by `libelf` that
    describes an ELF section. Initially, `scn` is `NULL`, causing `elf_nextscn` to
    return a pointer to the first section header at index 1 in the section header
    table.^([2](footnote.xhtml#appbfn_2)) This pointer becomes the new value of `scn`
    and is handled in the loop body. In the next loop iteration, `elf_nextscn` takes
    the existing `scn` and returns a pointer to the section at index 2, and so on.
    In this way, you can use `elf_nextscn` to iterate over all sections until it returns
    `NULL`, indicating that there is no next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`.shstrtab`的索引后，`rewrite_code_section`会循环遍历所有节头，逐一检查。在循环遍历节头时，它使用`elf_nextscn`函数
    ➋，该函数接受`Elf`句柄（`elf->e`）和`Elf_Scn*`（`scn`）作为输入。`Elf_Scn`是由`libelf`定义的结构，描述了一个ELF节。最初，`scn`为`NULL`，这导致`elf_nextscn`返回指向节头表中索引1的第一个节头的指针。^([2](footnote.xhtml#appbfn_2))
    这个指针成为`scn`的新值，并在循环体中处理。在下一次循环迭代中，`elf_nextscn`接受现有的`scn`并返回指向索引2的节的指针，依此类推。通过这种方式，你可以使用`elf_nextscn`遍历所有节，直到它返回`NULL`，表示没有下一个节。
- en: The loop body handles each section `scn` returned by `elf_nextscn`. The first
    thing that’s done for each section is to get an ELF class-agnostic representation
    of the section’s header, using the `gelf_getshdr` function ➌. It works just like
    `gelf_getphdr`, which you learned about in Section B.5, except that `gelf_getshdr`
    takes an `Elf_Scn*` and a `GElf_Shdr*` as input. If all goes well, `gelf_getshdr`
    populates the given `GElf_Shdr` with the section header of the given `Elf_Scn`
    and returns a pointer to the header. If something goes wrong, it will return `NULL`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 循环体处理由`elf_nextscn`返回的每个节`scn`。对每个节执行的第一件事是使用`gelf_getshdr`函数 ➌获取该节的与ELF类无关的表示。它的工作方式与第B.5节中学习的`gelf_getphdr`类似，只是`gelf_getshdr`接受`Elf_Scn*`和`GElf_Shdr*`作为输入。如果一切顺利，`gelf_getshdr`将用给定`Elf_Scn`的节头填充给定的`GElf_Shdr`并返回指向该头的指针。如果出现问题，它将返回`NULL`。
- en: Using the `Elf` handle stored in `elf->e`, the index `shstrndx` of the `.shstrtab`
    section, and the index `shdr.sh_name` of the current section’s name in the string
    table, `elfinject` now gets a pointer to the string describing the name of the
    current section. To that end, it passes all the required information to the `elf_strptr`
    function ➍, which returns the pointer, or `NULL` in case of error.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储在`elf->e`中的`Elf`句柄、`.shstrtab`节的索引`shstrndx`以及当前节名称在字符串表中的索引`shdr.sh_name`，`elfinject`现在获取指向描述当前节名称的字符串的指针。为此，它将所有必需的信息传递给`elf_strptr`函数
    ➍，该函数返回指针，如果发生错误，则返回`NULL`。
- en: Next, `elfinject` compares the just-obtained section name to the string `".note.ABI-tag"`
    ➎. If it matches, it means the current section is the `.note.ABI-tag` section,
    and `elfinject` overwrites it as described next and then breaks out of the loop
    and returns successfully from `rewrite_code_section`. If the section name doesn’t
    match, the loop moves on to its next iteration to see whether the next section
    matches.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`elfinject`将刚获得的节名称与字符串`".note.ABI-tag"` ➎进行比较。如果匹配，则表示当前节是`.note.ABI-tag`节，`elfinject`会按照接下来的描述覆盖该节，然后跳出循环并从`rewrite_code_section`成功返回。如果节名称不匹配，循环将进入下一次迭代，检查下一个节是否匹配。
- en: If the name of the current section is `.note.ABI-tag`, `rewrite_code_section`
    overwrites the fields in the section header to turn it into a header describing
    the injected section ➏. As mentioned previously in the high-level overview in
    [Figure 7-2](ch07.xhtml#ch07fig2), this involves setting the section type to `SHT_PROGBITS`;
    marking the section as executable; and filling in the appropriate section address,
    file offset, size, and alignment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前节的名称是`.note.ABI-tag`，`rewrite_code_section`将覆盖节头中的字段，将其转变为描述注入节的头 ➏。正如在[图7-2](ch07.xhtml#ch07fig2)中的高级概述所提到的，这涉及将节类型设置为`SHT_PROGBITS`；将节标记为可执行；并填写适当的节地址、文件偏移、大小和对齐方式。
- en: Next, `rewrite_code_section` saves the index of the overwritten section header,
    the pointer to the `Elf_Scn` structure, and a copy of the `GElf_Shdr` in the `inject`
    structure ➐. To get the section’s index, it uses the `elf_ndxscn` function, which
    takes an `Elf_Scn*` as input and returns the index of that section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`rewrite_code_section`将覆盖的节头的索引、指向`Elf_Scn`结构的指针以及`GElf_Shdr`的副本保存在`inject`结构中
    ➐。为了获取节的索引，它使用`elf_ndxscn`函数，该函数以`Elf_Scn*`为输入，并返回该节的索引。
- en: Once the header modifications are complete, `rewrite_code_section` writes the
    modified section header back into the ELF binary file using another `elfinject`
    function called `write_shdr` ➑ and then reorders the section headers by section
    address ➒. I’ll discuss the `write_shdr` function next, skipping the description
    of `reorder_shdrs`, the function that orders the sections, since it’s not central
    to understanding the `PT_NOTE` overwriting technique.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦头部修改完成，`rewrite_code_section`使用另一个名为`write_shdr` ➑的`elfinject`函数将修改后的节头写回ELF二进制文件，然后按节地址重新排序节头
    ➒。接下来我将讨论`write_shdr`函数，跳过对`reorder_shdrs`函数的描述，后者负责排序节，因为它对于理解`PT_NOTE`覆盖技术并不是核心内容。
- en: As mentioned previously, if `elfinject` succeeds in finding and overwriting
    the `.note.ABI-tag` section header, it breaks from the main loop iterating over
    all the section headers and returns successfully. If, on the other hand, the loop
    completes without finding a header to overwrite, then the inject cannot continue,
    and `rewrite_code_section` returns with an error ➓.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果`elfinject`成功找到并覆盖了`.note.ABI-tag`节头，它会从遍历所有节头的主循环中跳出，并成功返回。另一方面，如果循环完成而没有找到可以覆盖的节头，则注入过程无法继续，`rewrite_code_section`会以错误
    ➓ 返回。
- en: '[Listing B-9](appb.xhtml#appblist9) shows the code for `write_shdr`, the function
    responsible for writing the modified section header back to the ELF file.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 B-9](appb.xhtml#appblist9)展示了`write_shdr`的代码，这是负责将修改后的节头写回ELF文件的函数。'
- en: '*Listing B-9:* elfinject.c*: writing the modified section header back to the
    binary*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 B-9：* elfinject.c*：将修改后的节头写回二进制文件*'
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `write_shdr` function takes three parameters: the `elf_data_t` structure
    called `elf` that stores all the important information needed to read and write
    the ELF binary, an `Elf_Scn*` (`scn`) and a `GElf_Shdr*` (`shdr`) corresponding
    to the section to overwrite, and the index (`sidx`) of that section in the section
    header table.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_shdr`函数接受三个参数：存储读取和写入ELF二进制所需所有重要信息的`elf_data_t`结构，名为`elf`；一个`Elf_Scn*`（`scn`）和一个`GElf_Shdr*`（`shdr`），它们对应于需要覆盖的节；以及该节在节头表中的索引（`sidx`）。'
- en: First, `write_shdr` calls `gelf_update_shdr` ➊. Recall that `shdr` contains
    new, overwritten values in all the header fields. Because `shdr` is an ELF class-agnostic
    `GElf_Shdr` structure, which is part of the `GElf` API, writing to it doesn’t
    automatically update the underlying ELF data structures, `Elf32_Shdr` or `Elf64_Shdr`,
    depending on the ELF class. Yet those underlying data structures are the ones
    `elfinject` writes to the ELF binary, so it’s important that they’re updated.
    The `gelf_update_shdr` function takes an `Elf_Scn*` and a `GElf_Shdr*` as input
    and writes any changes made to the `GElf_Shdr` back to the underlying data structures,
    which are part of the `Elf_Scn` structure. The reason `elfinject` writes the underlying
    data structures to file, and not the `GElf` ones, is that the `GElf` data structures
    internally use a memory layout that doesn’t match the layout of the data structures
    in the file, so writing the `GElf` data structures would corrupt the ELF.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`write_shdr`调用`gelf_update_shdr` ➊。回顾一下，`shdr`包含所有头字段中的新覆盖值。由于`shdr`是一个与ELF类无关的`GElf_Shdr`结构，它是`GElf`
    API的一部分，写入它并不会自动更新底层的ELF数据结构（`Elf32_Shdr`或`Elf64_Shdr`，具体取决于ELF类）。然而，正是这些底层数据结构是`elfinject`写入ELF二进制文件的目标，因此必须确保它们被更新。`gelf_update_shdr`函数接受一个`Elf_Scn*`和一个`GElf_Shdr*`作为输入，并将对`GElf_Shdr`所做的任何更改写回到底层的数据结构，这些数据结构是`Elf_Scn`结构的一部分。`elfinject`写入底层数据结构而不是`GElf`数据结构的原因在于，`GElf`数据结构内部使用的内存布局与文件中数据结构的布局不匹配，因此写入`GElf`数据结构会破坏ELF文件。
- en: Now that `GElf` has written all pending updates back to the underlying native
    ELF data structures, `write_shdr` gets the native representation of the updated
    section header and writes it to the ELF file, overwriting the old `.note.ABI-tag`
    section header. First, `write_shdr` checks the bit width of the binary ➋. If it’s
    32 bits, then `write_shdr` calls `libelf`’s `elf32_getshdr` function (passing
    `scn` to it) to get a pointer to the `Elf32_Shdr` representation of the modified
    header ➌. For 64-bit binaries, it uses `elf64_getshdr` ➍ instead of `elf32_getshdr`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`GElf` 已将所有待处理的更新写回到底层的本机 ELF 数据结构中，`write_shdr` 获取更新后的节头的本机表示，并将其写入 ELF
    文件，覆盖旧的 `.note.ABI-tag` 节头。首先，`write_shdr` 检查二进制文件的位宽 ➋。如果是 32 位，那么 `write_shdr`
    调用 `libelf` 的 `elf32_getshdr` 函数（并传递 `scn`）来获取指向修改后的头部的 `Elf32_Shdr` 表示的指针 ➌。对于
    64 位二进制文件，则使用 `elf64_getshdr` ➍，而不是 `elf32_getshdr`。
- en: 'Next, `write_shdr` seeks the ELF file descriptor (`elf->fd`) to the offset
    in the ELF file where the updated header is to be written ➎. Keep in mind that
    the `e_shoff` field in the executable header contains the file offset where the
    section header table starts, `sidx` is the index of the header to overwrite, and
    the `e_shentsize` field contains the size in bytes of each entry in the section
    header table. Thus, the following formula computes the file offset at which to
    write the updated section header:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`write_shdr` 将 ELF 文件描述符（`elf->fd`）定位到 ELF 文件中要写入更新后头部的偏移量 ➎。请记住，执行文件头中的
    `e_shoff` 字段包含节头表开始的文件偏移量，`sidx` 是要覆盖的头部的索引，`e_shentsize` 字段包含节头表中每个条目的字节大小。因此，以下公式计算出写入更新后的节头的文件偏移量：
- en: '*e*_*shoff* + *sidx* × *e*_*shentsize*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*_*shoff* + *sidx* × *e*_*shentsize*'
- en: After seeking to this file offset, `write_shdr` writes the updated section header
    to the ELF file ➏, overwriting the old `.note.ABI-tag` header with the new one
    describing the injected section. By this point, the new code bytes have been injected
    at the end of the ELF binary and there’s a new code section that contains those
    bytes, but this section doesn’t yet have a meaningful name in the string table.
    The next section explains how `elfinject` updates the section name.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在定位到此文件偏移量后，`write_shdr` 将更新后的节头写入 ELF 文件 ➏，用描述注入节的新节头覆盖旧的 `.note.ABI-tag` 节头。此时，新的代码字节已经被注入到
    ELF 二进制文件的末尾，并且有一个新的代码节包含这些字节，但该节在字符串表中还没有一个有意义的名称。下一节将解释 `elfinject` 如何更新节名称。
- en: B.9 Setting the Name of the Injected Section
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.9 设置注入节的名称
- en: '[Listing B-10](appb.xhtml#appblist10) shows the function that changes the name
    of the overwritten section, `.note.ABI-tag`, to something more meaningful, such
    as `.injected`. This is step ➏ in [Listing B-4](appb.xhtml#appblist4).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 B-10](appb.xhtml#appblist10) 显示了将被覆盖的节 `.note.ABI-tag` 的名称更改为更有意义的名称，例如
    `.injected` 的函数。这是 [列表 B-4](appb.xhtml#appblist4) 中的步骤 ➏。'
- en: '*Listing B-10:* elfinject.c*: setting the name of the injected section*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 B-10:* elfinject.c*: 设置注入节的名称*'
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function that overwrites the section name is called `rewrite_section _name`.
    The new name for this injected section cannot be longer than the old name, `.note.ABI-tag`,
    because all the strings in the string table are packed tightly together with no
    room for extra added characters. Therefore, the first thing `rewrite_section_name`
    does is check that the new section name, stored in the `inject->secname` field,
    will fit ➊. If not, `rewrite_section_name` returns with an error.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 用于覆盖节名称的函数名为 `rewrite_section_name`。这个注入节的新名称不能比旧名称 `.note.ABI-tag` 更长，因为字符串表中的所有字符串紧密打包在一起，没有多余的空间来容纳额外的字符。因此，`rewrite_section_name`
    首先会检查存储在 `inject->secname` 字段中的新节名称是否适合 ➊。如果不适合，`rewrite_section_name` 会返回错误。
- en: 'The next steps are identical to the corresponding steps in the `rewrite _code_section`
    function I discussed previously, in [Listing B-8](appb.xhtml#appblist8): get the
    index of the string table section ➋ and then loop over all sections ➌ and inspect
    each section’s header ➍, using the `sh_name` field in the header to obtain a string
    pointer to the section’s name ➎. For details of these steps, refer to Section
    B.8.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤与我之前讨论的 `rewrite_code_section` 函数中的相应步骤相同，见 [列表 B-8](appb.xhtml#appblist8)：获取字符串表节的索引
    ➋，然后遍历所有节 ➌ 并检查每个节的节头 ➍，使用节头中的 `sh_name` 字段来获取指向节名称的字符串指针 ➎。有关这些步骤的详细信息，请参阅 B.8
    节。
- en: 'Overwriting the old `.note.ABI-tag` section name requires two pieces of information:
    the file offset to the start of the `.shstrtab` section (the string table) and
    the offset to the `.note.ABI-tag` section’s name within the string table. Given
    these two offsets, `rewrite_section_name` knows where in the file to write the
    new section name string. The offset within the string table to the `.note.ABI-tag`
    section name is stored in the `sh_name` field of the `.note.ABI-tag` section header
    ➏. Similarly, the `sh_offset` field in the section header contains the start of
    the `.shstrtab` section ➐.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖旧的 `.note.ABI-tag` 段名需要两个信息：`.shstrtab` 段（字符串表）开始的文件偏移量，以及 `.note.ABI-tag`
    段名在字符串表中的偏移量。给定这两个偏移量，`rewrite_section_name` 就知道在哪里在文件中写入新的段名字符串。`.note.ABI-tag`
    段名在字符串表中的偏移量保存在 `.note.ABI-tag` 段头的 `sh_name` 字段中 ➏。类似地，段头中的 `sh_offset` 字段包含
    `.shstrtab` 段的起始位置 ➐。
- en: If all goes well, the loop locates both required offsets ➑. If not, `rewrite
    _section_name` reports the error and gives up.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，循环会定位到两个所需的偏移量 ➑。如果没有，`rewrite_section_name` 会报告错误并放弃。
- en: Finally, `rewrite_section_name` computes the file offset at which to write the
    new section name, saving it in the `inject->shstroff` field ➒. It then calls another
    function, called `write_secname`, to write the new section name to the ELF binary
    at the just-computed offset ➓. Writing the section name to file is straightforward
    and requires only standard C file I/O functions, so I omit a description of the
    `write_secname` function here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`rewrite_section_name` 计算写入新段名的文件偏移量，并将其保存在 `inject->shstroff` 字段中 ➒。然后，它调用另一个名为
    `write_secname` 的函数，将新段名写入 ELF 二进制文件中，写入位置是刚刚计算出的偏移量 ➓。写入段名到文件是直接的，只需要标准的 C 文件
    I/O 函数，因此我在这里省略了对 `write_secname` 函数的描述。
- en: To recap, the ELF binary now contains the injected code, an overwritten section
    header, and a proper name for the injected section. The next step is to overwrite
    a `PT_NOTE` program header, creating a loadable segment that contains the injected
    section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，ELF 二进制文件现在包含了注入的代码、被覆盖的段头，以及为注入段设置的正确名称。下一步是覆盖 `PT_NOTE` 程序头，创建一个包含注入段的可加载段。
- en: B.10 Overwriting the PT_NOTE Program Header
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.10 覆盖 PT_NOTE 程序头
- en: As you may remember, [Listing B-5](appb.xhtml#appblist5) showed the code that
    locates and saves the `PT_NOTE` program header to overwrite. All that’s left to
    do is to overwrite the relevant program header fields and save the updated program
    header to file. [Listing B-11](appb.xhtml#appblist11) shows `rewrite_code_segment`,
    the function that updates and saves the program header. This was called in step
    ➐ from [Listing B-4](appb.xhtml#appblist4).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，[列表 B-5](appb.xhtml#appblist5) 展示了定位并保存 `PT_NOTE` 程序头以进行覆盖的代码。剩下的工作就是覆盖相关的程序头字段，并将更新后的程序头保存到文件中。[列表
    B-11](appb.xhtml#appblist11) 展示了更新并保存程序头的函数 `rewrite_code_segment`。这个函数在 [列表 B-4](appb.xhtml#appblist4)
    中的步骤 ➐ 被调用。
- en: '*Listing B-11:* elfinject.c*: overwriting the* PT_NOTE *program header*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 B-11:* elfinject.c*：覆盖* PT_NOTE *程序头*'
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Recall that the previously located `PT_NOTE` program header is stored in the
    `inject->phdr` field. Thus, `rewrite_code_segment` starts by updating the necessary
    fields in this program header: making it loadable by setting `p_type` to `PT_LOAD`
    ➊; setting the file offset, memory addresses, and size of the injected code segment
    ➋; making the segment readable and executable ➌; and setting the proper alignment
    ➍. These are the same modifications shown in the high-level overview in [Figure
    7-2](ch07.xhtml#ch07fig2).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，之前定位的 `PT_NOTE` 程序头保存在 `inject->phdr` 字段中。因此，`rewrite_code_segment` 首先更新此程序头中的必要字段：通过将
    `p_type` 设置为 `PT_LOAD` ➊ 使其可加载；设置注入代码段的文件偏移量、内存地址和大小 ➋；使段可读并可执行 ➌；并设置正确的对齐方式 ➍。这些修改与在
    [图 7-2](ch07.xhtml#ch07fig2) 中展示的高级概述相同。
- en: After making the necessary modifications, `rewrite_code_segment` calls another
    function called `write_phdr` to write the modified program header back to the
    ELF binary ➎. [Listing B-12](appb.xhtml#appblist12) shows the code of `write_phdr`.
    The code is similar to the `write_shdr` function that writes a modified section
    header to file, which you already saw in [Listing B-9](appb.xhtml#appblist9),
    so I’ll focus on the important differences between `write_phdr` and `write_shdr`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行必要的修改后，`rewrite_code_segment` 调用另一个名为 `write_phdr` 的函数，将修改后的程序头写回 ELF 二进制文件
    ➎。[列表 B-12](appb.xhtml#appblist12) 展示了 `write_phdr` 的代码。该代码与 `write_shdr` 函数类似，后者是将修改后的段头写入文件的函数，你已经在
    [列表 B-9](appb.xhtml#appblist9) 中看过，因此我将重点介绍 `write_phdr` 和 `write_shdr` 之间的重要区别。
- en: '*Listing B-12:* elfinject.c*: writing the overwritten program header back to
    the ELF file*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 B-12:* elfinject.c*：将覆盖的程序头写回 ELF 文件*'
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As in the `write_shdr` function, `write_phdr` begins by making sure all modifications
    to the `GElf` representation of the program header are written back to the underlying
    native `Elf32_Phdr` or `Elf64_Phdr` data structure ➊. To this end, `write_phdr`
    calls the `gelf_update_phdr` function to flush the changes to the underlying data
    structures. This function takes an ELF handle, the index of the modified program
    header, and a pointer to the updated `GElf_Phdr` representation of the program
    header. As usual for `GElf` functions, it returns nonzero on success and 0 on
    failure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `write_shdr` 函数类似，`write_phdr` 首先确保将对程序头的 `GElf` 表示所做的所有修改写回到底层的本地 `Elf32_Phdr`
    或 `Elf64_Phdr` 数据结构 ➊。为此，`write_phdr` 调用 `gelf_update_phdr` 函数，以便将更改刷新到底层数据结构中。此函数接受一个
    ELF 句柄、修改的程序头的索引和指向更新后的 `GElf_Phdr` 程序头表示的指针。像往常一样，对于 `GElf` 函数，成功时返回非零值，失败时返回
    0。
- en: Next, `write_phdr` gets a reference to the native representation of the program
    header in question (an `Elf32_Phdr` or `Elf64_Phdr` structure depending on the
    ELF class) to write it to file ➋. Again, this is similar to what you saw in the
    `write_shdr` function, except that `libelf` doesn’t allow you to directly get
    a pointer to a particular program header. Instead, you must first get a pointer
    to the start of the program header table ➌ and then index it to get a pointer
    to the updated program header itself ➍. To get a pointer to the program header
    table, you use the `elf32_getphdr` or `elf64_getphdr` function, depending on the
    ELF class. They both return the pointer on success or `NULL` on failure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`write_phdr` 获取对相关程序头本地表示的引用（根据 ELF 类，可能是 `Elf32_Phdr` 或 `Elf64_Phdr` 结构），并将其写入文件
    ➋。这个过程类似于你在 `write_shdr` 函数中看到的，唯一不同的是 `libelf` 不允许你直接获取特定程序头的指针。相反，你必须先获取指向程序头表开始位置的指针
    ➌，然后通过索引获取指向更新后的程序头的指针 ➍。要获取指向程序头表的指针，可以根据 ELF 类使用 `elf32_getphdr` 或 `elf64_getphdr`
    函数。它们在成功时返回指针，在失败时返回 `NULL`。
- en: 'Given the native representation of the overwritten ELF program header, all
    that remains now is to seek to the correct file offset ➎ and write the updated
    program header there ➏. That completes all the mandatory steps for injecting a
    new code section into an ELF binary! The only remaining step is optional: modifying
    the ELF entry point to point into the injected code.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于被覆盖的 ELF 程序头的本地表示，现在所需要做的就是寻找到正确的文件偏移量 ➎ 并将更新后的程序头写入该位置 ➏。这完成了将新代码段注入 ELF
    二进制文件中的所有强制步骤！剩下的唯一步骤是可选的：修改 ELF 入口点，使其指向注入的代码。
- en: B.11 Modifying the Entry Point
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.11 修改入口点
- en: '[Listing B-13](appb.xhtml#appblist13) shows the `rewrite_entry_point` function,
    which takes care of modifying the ELF entry point. It’s called only if requested
    by the user in step ➑ in [Listing B-4](appb.xhtml#appblist4).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 B-13](appb.xhtml#appblist13) 显示了 `rewrite_entry_point` 函数，该函数负责修改 ELF 入口点。只有在
    [列表 B-4](appb.xhtml#appblist4) 的第 ➑ 步用户请求时，才会调用此函数。'
- en: '*Listing B-13:* elfinject.c*: modifying the ELF entry point*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 B-13:* elfinject.c*：修改 ELF 入口点*'
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Recall that `elfinject` allows the user to optionally specify a new entry point
    for the binary by giving a command line argument that contains an offset into
    the injected code. The offset specified by the user is saved in the `inject->entry`
    field. If the offset is negative, it means that the entry point should remain
    unchanged, in which case `rewrite_entry_point` is never called. Thus, if `rewrite_entry_point`
    *is* called, `inject->entry` is guaranteed to be nonnegative.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`elfinject` 允许用户通过命令行参数指定一个新的二进制文件入口点，该参数包含指向注入代码的偏移量。用户指定的偏移量保存在 `inject->entry`
    字段中。如果偏移量为负，则表示入口点不应改变，在这种情况下，`rewrite_entry_point` 永远不会被调用。因此，如果调用了 `rewrite_entry_point`，则可以保证
    `inject->entry` 为非负值。
- en: The first thing `rewrite_entry_point` does is update the `e_entry` field in
    the ELF executable header ➊, previously loaded into the `elf->ehdr` field. Next,
    it computes the new entry point address by adding the relative offset into the
    injected code (`inject->entry`) to the base address of the loadable segment that
    contains the injected code (`inject->phdr.p_vaddr`). Then, `rewrite_entry_point`
    calls the dedicated function `write_ehdr` ➋, which writes the modified executable
    header back to the ELF file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`rewrite_entry_point` 做的第一件事是更新 ELF 可执行文件头中的 `e_entry` 字段 ➊，该字段之前已加载到 `elf->ehdr`
    字段中。接下来，它通过将注入代码的相对偏移量（`inject->entry`）加到包含注入代码的可加载段的基地址（`inject->phdr.p_vaddr`）来计算新的入口点地址。然后，`rewrite_entry_point`
    调用专用函数 `write_ehdr` ➋，该函数将修改后的可执行文件头写回 ELF 文件。'
- en: The code of `write_ehdr` is analogous to the `write_shdr` function shown in
    [Listing B-9](appb.xhtml#appblist9). The only difference is that it uses `gelf_update_ehdr`
    instead of `gelf_update_shdr` and `elf32_getehdr`/`elf64_getehdr` instead of `elf32_getshdr`/`elf64_getshdr`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_ehdr` 的代码与 [清单 B-9](appb.xhtml#appblist9) 中展示的 `write_shdr` 函数类似。唯一的区别是，它使用
    `gelf_update_ehdr` 代替了 `gelf_update_shdr`，并且使用 `elf32_getehdr`/`elf64_getehdr`
    代替了 `elf32_getshdr`/`elf64_getshdr`。'
- en: You now know how to use `libelf` to inject code into a binary, overwrite a section
    and program header to accommodate the new code, and modify the ELF entry point
    to jump to the injected code when the binary is loaded! Modifying the entry point
    is optional, and you may not always want to use the injected code immediately
    when the binary starts. Sometimes, you’ll want to use the injected code for different
    reasons, such as substituting a replacement for an existing function. [Section
    7.4](ch07.xhtml#ch07_4) discusses some techniques for transferring control to
    the injected code, other than modifying the ELF entry point.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用 `libelf` 将代码注入二进制文件、覆盖一个节区和程序头以容纳新代码，并修改 ELF 入口点，以便在加载二进制时跳转到注入的代码！修改入口点是可选的，你可能并不总是希望在二进制启动时立即使用注入的代码。有时候，你会希望因不同的原因使用注入的代码，例如替代现有函数的实现。[第7.4节](ch07.xhtml#ch07_4)讨论了除了修改
    ELF 入口点之外，一些将控制权转移到注入代码的技巧。
