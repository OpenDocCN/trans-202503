- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: THE NATURE OF RANDOMNESS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性的本质**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Random processes power the systems we’ll develop later in this book. This chapter
    introduces specific random processes, from those that are truly random to those
    that are deterministic but still random enough to use—that is, pseudorandom and
    quasirandom processes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随机过程驱动着我们在本书后面将要开发的系统。本章介绍了特定的随机过程，包括那些真正的随机过程，以及那些是确定性的但仍然足够随机以供使用的过程——即伪随机和拟随机过程。
- en: We’ll begin with a brief discussion of the relationship between probability
    and randomness. After learning how to determine whether a process is random, we’ll
    explore truly random processes, meaning processes strongly influenced by true
    randomness. We’ll also learn the difference between pseudorandom and quasirandom
    processes. Finally, we’ll use Python to create the `RE` class, the randomness
    engine we’ll use in all of our experiments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简要讨论概率与随机性之间的关系开始。在学习如何判断一个过程是否是随机的之后，我们将探索真正的随机过程，即那些受到真实随机性强烈影响的过程。我们还将学习伪随机和拟随机过程之间的区别。最后，我们将使用
    Python 创建 `RE` 类，这是我们将在所有实验中使用的随机性引擎。
- en: '**Probability and Randomness**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**概率与随机性**'
- en: '*Probability distributions* represent the possible values a *random variable*
    can take and how likely each value is to occur. For us, a random variable is the
    output of a random process.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*概率分布*表示一个*随机变量*可以取的所有可能值，以及每个值出现的可能性。对我们来说，随机变量是一个随机过程的输出。'
- en: Probability distributions come in two varieties. *Continuous* probability distributions
    return values from an infinite set, meaning any real number in the allowed range.
    Here, the word *real* means elements of the set of real numbers, denoted ℝ, which
    are all the numbers on the number line. *Discrete* probability distributions are
    restricted to returning values from a finite set of values, like the heads or
    tails of a coin or the numbers on a die.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 概率分布有两种类型。*连续型*概率分布返回来自无限集合的值，这意味着在允许范围内的任何实数。在这里，*实数*指的是实数集合ℝ中的元素，所有数字都在数轴上。*离散型*概率分布则限制返回来自有限集合的值，比如硬币的正反面或骰子上的数字。
- en: Random processes generate values, known as *samples*, that come from some kind
    of probability distribution, be it continuous or discrete. For example, a coin
    flip delivers samples that are either heads or tails, while a die delivers samples
    from the set {1, 2, 3, 4, 5, 6} (assuming a standard six-sided die).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随机过程生成的值被称为*样本*，这些值来自某种概率分布，无论是连续型的还是离散型的。例如，掷硬币会产生正面或反面的样本，而掷骰子会从集合 {1, 2,
    3, 4, 5, 6} 中返回样本（假设是标准六面骰）。
- en: If a random process returns a single number, how do we know what distribution
    it’s sampling from? In some cases, we have theoretical knowledge, but in other
    cases, all we can do is generate many samples. Over time, the relative frequency
    with which each possible outcome appears will become evident and serve as a stand-in
    for the true probability distribution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个随机过程返回一个单一的数字，我们如何知道它是从哪个分布中采样的呢？在某些情况下，我们有理论知识，但在其他情况下，我们只能生成大量样本。随着时间的推移，每种可能结果出现的相对频率将变得显而易见，并充当真实概率分布的替代品。
- en: '***Discrete Distributions***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***离散分布***'
- en: As an example of a discrete probability distribution, suppose that, thanks to
    the generosity of a local wizard, I have in my possession a one-of-a-kind die
    with only three sides. The numbers 0, 1, or 2 appear on the faces of my three-sided
    die. Therefore, each roll of the die results in one of the three sides face up.
    When I roll my die 50,000 times, keeping a tally of the number of times each side
    appears face up, I get the results in [Table 1-1](ch01.xhtml#ch01tab01).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为离散概率分布的一个例子，假设由于一位当地巫师的慷慨，我拥有一颗独一无二的三面骰。我的三面骰上显示的是数字 0、1 或 2。因此，每次掷骰时，都会有一面朝上。当我掷骰子
    50,000 次，并记录每一面朝上的次数时，我得到了 [表 1-1](ch01.xhtml#ch01tab01) 中的结果。
- en: '**Table 1-1:** Rolling a Three-Sided Die 50,000 Times'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-1：** 掷三面骰 50,000 次'
- en: '| **Face** | **Count** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **面** | **次数** |'
- en: '| --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 33,492 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 33,492 |'
- en: '| 1 | 8,242 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 8,242 |'
- en: '| 2 | 8,266 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 8,266 |'
- en: 'The results indicate that the probability of getting a 0, 1, or 2 is not equal:
    0 appeared 33,492/50,000 = 66.984 percent of the time, 1 appeared 16.484 percent
    of the time, and 2 appeared 16.532 percent of the time. If I were to repeat the
    experiment, the exact count for each outcome would be slightly different, but
    it’s clear that many such experiments would lead to outcomes in which 0 appears
    approximately 67 percent of the time and 1 and 2 each appears 16.5 percent of
    the time. Notice that 67 percent + 16.5 percent + 16.5 percent = 100 percent,
    as it should if the only possible outcomes from rolling my magic die are 0, 1,
    and 2 in the proportion 67 : 16.5 : 16.5.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，出现0、1或2的概率是不相等的：0出现了33,492/50,000 = 66.984%的时间，1出现了16.484%的时间，2出现了16.532%的时间。如果我重复实验，每个结果的精确次数会略有不同，但显然，很多这样的实验会导致结果，其中0大约67%的时间出现，1和2各自大约16.5%的时间出现。注意，67%
    + 16.5% + 16.5% = 100%，如果我的魔法骰子只有0、1、2三种结果，且比例为67:16.5:16.5，那么这就是应该出现的情况。
- en: Rolling the three-sided die is a random process that samples from a probability
    distribution, one where the likelihood of a 0 is 67 percent and the likelihood
    of a 1 or a 2 is 16.5 percent each. There are a finite number of possible outputs,
    so the probability distribution is discrete.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 掷三面骰子是一个随机过程，从一个概率分布中抽样，其中0的概率是67%，1或2的概率各是16.5%。结果是有限的，所以概率分布是离散的。
- en: Let’s try two more experiments that sample from discrete probability distributions.
    The first flips a fair coin 50,000 times. The second rolls a standard six-sided
    die 50,000 times. As before, let’s tally the different outcomes, using 0 for tails
    and 1 for heads. [Table 1-2](ch01.xhtml#ch01tab02) shows the results for the coin
    flips.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做两个实验，它们从离散概率分布中抽样。第一个实验掷50,000次公平的硬币。第二个实验掷50,000次标准的六面骰子。如之前所做，我们将不同的结果统计出来，用0表示反面，用1表示正面。[表
    1-2](ch01.xhtml#ch01tab02) 显示了硬币翻转的结果。
- en: '**Table 1-2:** Flipping a Fair Coin 50,000 Times'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-2：** 公平硬币掷 50,000 次'
- en: '| **Side** | **Count** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **面** | **次数** |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 25,040 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 25,040 |'
- en: '| 1 | 24,960 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 24,960 |'
- en: '[Table 1-3](ch01.xhtml#ch01tab03) shows the results for the die rolls.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-3](ch01.xhtml#ch01tab03) 显示了掷骰子的结果。'
- en: '**Table 1-3:** Rolling a Standard Die 50,000 Times'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-3：** 掷标准骰子 50,000 次'
- en: '| **Face** | **Count** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **面** | **次数** |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 8,438 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 8,438 |'
- en: '| 2 | 8,252 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 8,252 |'
- en: '| 3 | 8,292 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 8,292 |'
- en: '| 4 | 8,367 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 8,367 |'
- en: '| 5 | 8,336 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 8,336 |'
- en: '| 6 | 8,315 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 8,315 |'
- en: Just as my magic three-sided die’s outcomes are not equally likely, the coin
    flips and standard die rolls deliver each outcome with equal probability. The
    counts are nearly uniform. Such *uniform distributions*, those that produce each
    possible outcome with equal probability, are far and away the most common type
    of distribution we’ll harness in this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我的魔法三面骰子的结果并不等概率一样，掷硬币和标准六面骰子的结果则是每个结果具有相等的概率。其计数几乎是均匀的。这种*均匀分布*，即每个可能的结果都具有相等的概率，是本书中我们将使用的最常见的分布类型。
- en: '**NOTE**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To run this experiment, I didn’t actually flip a coin and roll a die 50,000
    times. Instead, I used a pseudorandom generator, discussed later in this chapter.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了进行这个实验，我并没有真的掷50,000次硬币和骰子。相反，我使用了伪随机生成器，稍后将在本章中讨论。*'
- en: '***Continuous Distributions***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连续分布***'
- en: Think of continuous probability distributions as the limit of discrete distributions.
    For example, a six-sided die selects from six possible outcomes. A 20-sided die,
    sometimes called a D20, selects from 20 possible outcomes. If we could somehow
    let the number of sides extend to infinity, then such a die would choose, on each
    roll, from an infinite number of outcomes. This is what a continuous probability
    distribution does.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将连续概率分布视为离散分布的极限。例如，一个六面骰子从六个可能的结果中选择。一个20面骰子，有时被称为D20，从20个可能的结果中选择。如果我们能让骰子的面数延伸到无穷大，那么这种骰子每次掷出时，将从无限多个结果中选择。这就是连续概率分布所做的事情。
- en: Suppose a random process generates real numbers in the range 0 to 1 such that
    all real numbers are equally likely. In that case, the random process is sampling
    from a continuous uniform distribution, just as a die samples from a discrete
    uniform distribution. We’ll make heavy use of the continuous uniform distribution
    as we proceed through the book. Likewise, we’ll occasionally use the *normal*
    (sometimes called *Gaussian*) distribution.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个随机过程生成范围为0到1的实数，并且所有实数出现的概率相等，那么该随机过程就是从连续均匀分布中抽样，就像骰子从离散均匀分布中抽样一样。在本书中，我们将广泛使用连续均匀分布。同样，我们偶尔也会使用*正态*（有时称为*高斯*）分布。
- en: Introducing some math notation at this point will make it easier to understand
    what comes later. The uniform distribution we’ll use most often draws samples
    from [0, 1), meaning the sample is greater than or equal to 0 and strictly less
    than 1, that is, 0 ≤ *x* < 1\. When writing a range like [0, 1), note whether
    a square bracket or a parenthesis is used. The square bracket means the limit
    is included in the range, but a parenthesis excludes the limit. Therefore, (0,
    1) specifies a range where all possible real numbers except 0 and 1 are allowed.
    Similarly, [0, 1] includes both 0 and 1, while [0, 1) includes 0 but excludes
    1\. The pseudorandom and quasirandom processes described later in the chapter
    usually produce outputs in the range [0, 1).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点引入一些数学符号将使后续内容更容易理解。我们最常用的均匀分布从[0, 1)区间中抽取样本，意味着样本大于或等于0，并且严格小于1，即0 ≤ *x*
    < 1。当写出像[0, 1)这样的区间时，请注意是使用方括号还是圆括号。方括号表示包含该限制，而圆括号则不包含该限制。因此，(0, 1)表示一个区间，其中所有可能的实数除了0和1之外都允许。同样，[0,
    1]包括0和1，而[0, 1)包括0但不包括1。后面章节中描述的伪随机和准随机过程通常会生成[0, 1)区间的输出。
- en: 'A uniform distribution is straightforward, whether continuous or discrete:
    each possible outcome is equally likely to appear. However, in a normal distribution,
    some values are more likely to be produced than others.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀分布是直观的，无论是连续的还是离散的：每个可能的结果都有相同的出现概率。然而，在正态分布中，一些值比其他值更可能被生成。
- en: The best way to appreciate a normal distribution is to examine its histogram.
    For example, [Figure 1-1](ch01.xhtml#ch01fig01) shows the distribution of 60 million
    samples from a normal distribution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 欣赏正态分布的最佳方式是检查其直方图。例如，[图1-1](ch01.xhtml#ch01fig01)展示了来自正态分布的6000万个样本的分布。
- en: '![Image](../images/01fig01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig01.jpg)'
- en: '*Figure 1-1: A histogram showing normal (curve) and uniform (line) distributions*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-1：显示正态（曲线）和均匀（线）分布的直方图*'
- en: The values in [Figure 1-1](ch01.xhtml#ch01fig01) range from approximately −6
    to 6\. Values around 0 are most likely, with those at the extremes least likely.
    The normal distribution is widespread; many physical phenomena follow this distribution.
    Crucially, when we take a large set of samples from *any* distribution, the mean
    values will follow a normal distribution. This is the *central limit theorem*,
    and it’s fundamental to statistics.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-1](ch01.xhtml#ch01fig01)中的值大约从−6到6。接近0的值最有可能出现，而极端值最不可能出现。正态分布是普遍存在的；许多物理现象都遵循这种分布。关键是，当我们从*任何*分布中获取大量样本时，均值将遵循正态分布。这就是*中心极限定理*，它是统计学的基础。'
- en: In the previous section, [Table 1-2](ch01.xhtml#ch01tab02) and [Table 1-3](ch01.xhtml#ch01tab03)
    tally the number of heads and tails and the number of times each side of a die
    appeared. A histogram is a graphical representation of such a table. The possible
    outputs are placed into bins of some specified width. For a die, the natural bin
    width is 1 so that each side falls into the bin with the same label.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，[表1-2](ch01.xhtml#ch01tab02)和[表1-3](ch01.xhtml#ch01tab03)统计了正反面出现的次数以及每个骰子面出现的次数。直方图是这种表格的图形表示。可能的输出被放入指定宽度的箱子中。对于骰子来说，天然的箱子宽度是1，这样每个面就会落入带有相同标签的箱子中。
- en: 'For a continuous distribution, the bins cover a range. For example, if we have
    a process that generates numbers in the range [0, 1), and we want 10 bins, then
    we might make each bin 0.1 wide. A sample of *x* = 0.3052 will then fall into
    bin 3, counting from 0, because:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连续分布，箱子覆盖一个范围。例如，如果我们有一个生成[0, 1)区间中数字的过程，并且我们想要10个箱子，那么我们可能会将每个箱子的宽度设为0.1。那么，*x*
    = 0.3052的样本将落入从0开始计算的第3个箱子，因为：
- en: '![Image](../images/f0005-01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0005-01.jpg)'
- en: Likewise, a sample of *x* = 0.0451 will fall into bin 0, and so on. When all
    samples have been placed in a bin, the histogram plots either the count in each
    bin or the fraction of samples that fell into that bin. The fraction is found
    by dividing each bin’s count by the sum of all the bins. A histogram using fractions
    per bin approximates the true probability distribution.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个样本*x* = 0.0451会落入区间0，依此类推。当所有样本都被放入区间后，直方图会绘制每个区间的计数或落入该区间的样本比例。比例是通过将每个区间的计数除以所有区间的总和得到的。使用区间比例的直方图可以近似真实的概率分布。
- en: Let’s return to [Figure 1-1](ch01.xhtml#ch01fig01). The figure uses 1,000 bins,
    which explains why the curve looks more like a curve than a bar plot. The figure
    plots the fraction in each bin, not the count, which lets us compare different
    distributions without worrying about the number of samples used to generate the
    histogram. As the number of samples increases, such a histogram becomes a better
    approximation of the true probability distribution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[图 1-1](ch01.xhtml#ch01fig01)。该图使用了1,000个区间，这解释了为什么曲线看起来更像一条曲线而不是条形图。图中绘制的是每个区间的比例，而不是计数，这让我们可以在不必担心生成直方图所用样本数量的情况下比较不同的分布。随着样本数量的增加，这种直方图会更接近真实的概率分布。
- en: The horizontal line in [Figure 1-1](ch01.xhtml#ch01fig01) represents a continuous
    uniform distribution selecting values in the range [–6, 6). If each value is equally
    likely, then on average, each bin will be equally populated and 1/1,000 = 0.001,
    thereby explaining the *y*-axis value for the uniform distribution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](ch01.xhtml#ch01fig01)中的水平线表示一个连续的均匀分布，在[–6, 6)的范围内选择值。如果每个值的选择概率相等，那么平均而言，每个区间的样本数量会相同，1/1,000
    = 0.001，从而解释了均匀分布的*y*轴值。'
- en: We need only remember that the random processes powering our experiments generate
    values according to some distribution, primarily the uniform or normal distributions.
    There are many other standard distributions, but we won’t explore them in this
    book.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要记住，驱动我们实验的随机过程是根据某种分布生成值的，主要是均匀分布或正态分布。还有许多其他标准分布，但我们在本书中不会深入探讨它们。
- en: '**NOTE**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To learn more about probability and statistics, I recommend* Statistics Done
    Wrong *by Alex Reinhart (2015) or my book* Math for Deep Learning *(2021), both
    available from No Starch Press. You’ll find discussions of probability and statistics,
    along with differential calculus, all of which we’ll touch on at various points
    throughout this book.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*想要更深入了解概率和统计，我推荐* Alex Reinhart的《Statistics Done Wrong》（2015年）或我的书*《深度学习数学》（2021年），这两本书均由No
    Starch Press出版。你将会看到关于概率和统计的讨论，以及微分学，我们将在本书中的多个地方提到这些内容。*'
- en: We need to know how close our random processes come to being, well, random.
    Before we dive into randomness engines proper, let’s consider how to approach
    testing the output of a random process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道我们的随机过程离“真正的随机”有多近。在深入探讨随机性引擎之前，让我们考虑一下如何测试一个随机过程的输出。
- en: '**Testing for Randomness**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**随机性测试**'
- en: 'How can we know that the output of a random process is truly random? The short
    answer is: we can’t. However, that shouldn’t deter us. We’re not attempting to
    solve deep philosophical issues, as interesting as they might be. Instead, we
    seek what’s good enough to accomplish our immediate goals and no more.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么知道一个随机过程的输出是否真的是随机的？简短的回答是：我们不能。然而，这不应该让我们气馁。我们并不是试图解决深奥的哲学问题，尽管它们可能很有趣。相反，我们要做的是找到足够好的方法来实现我们的即时目标，仅此而已。
- en: Is this string of binary digits random?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这串二进制数字是随机的吗？
- en: '0101010011100000110000011101101111111011100000'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '0101010011100000110000011101101111111011100000'
- en: Well, it looks kind of random, but how can we tell? Earlier, we used the frequency
    of each possible output to tell us whether the sample matches expectations. A
    random process generating 0 or 1 with expected equal likelihood should match as
    well. In this case, there are 23 zeros and 23 ones. Does that indicate that the
    sequence is random?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，它看起来有点随机，但我们怎么知道呢？早些时候，我们使用每个可能输出的频率来判断样本是否符合预期。一个随机过程以相等的概率生成0或1也应该符合预期。在这种情况下，有23个零和23个一。这是否表明序列是随机的？
- en: 'You begin to see what I mean when I say we can’t tell whether a process is
    truly random. All we can do is apply tests to increase our confidence in our belief
    that the sequence israndom. We can check the expected frequency of the various
    outputs, but that’s not sufficient. For example, the following sequences also
    have equal numbers of zeros and ones:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说我们无法判断一个过程是否真的随机时，你开始明白我的意思了。我们所能做的就是应用测试，以增加我们对序列是随机的信心。我们可以检查各种输出的预期频率，但这并不充分。例如，以下序列也有相等数量的零和一：
- en: '![Image](../images/f0006-01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0006-01.jpg)'
- en: Most of us wouldn’t consider either sequence to be particularly random.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人不会认为这两种序列是特别随机的。
- en: In truth, none of the previous three sequences are the output of a random process.
    The first one is the binary representation of the operation codes for a 6502 microprocessor
    program to display the letter A on the screen of an old Apple II computer. The
    bit patterns for the opcodes are not random, but depend critically on the internal
    architecture of the microprocessor. I made the other two sequences by hand to
    have equal numbers of zeros and ones.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，前面提到的三个序列都不是随机过程的输出。第一个是6502微处理器程序的操作码的二进制表示，用于在旧版Apple II计算机的屏幕上显示字母A。操作码的比特模式不是随机的，而是严重依赖于微处理器的内部架构。我手动生成了另外两个序列，它们有相等数量的零和一。
- en: Over the years, researchers have invented many statistical tests designed, collectively,
    to detect whether a sequence of values is worthy of being called random. We have
    no space here to dive into these tests, but they go far beyond frequencies and
    consider short- and long-term correlations of all kinds. A few such test suites
    are DieHarder, TestU01, and PractRand. These suites generally require vast collections
    of values, far more than we can work with here.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，研究人员发明了许多统计测试，它们共同设计用于检测一串值是否值得被称为随机。我们在这里没有足够的空间深入探讨这些测试，但它们远远超出了频率的范畴，还考虑了各种短期和长期的相关性。一些这样的测试套件有DieHarder、TestU01和PractRand。这些套件通常需要大量的值，远超过我们在这里能处理的数量。
- en: So what’s a person to do? We cannot prove that a randomness engine is generating
    random outputs, but we can gain enough confidence to believe more or less strongly.
    To accomplish this, we’ll use a command line program called `ent`, from the word
    *entropy*. It applies a small set of statistical tests that might influence our
    beliefs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个人该怎么做呢？我们无法证明一个随机引擎正在生成随机输出，但我们可以获得足够的信心，以便或多或少地相信它。为此，我们将使用一个名为`ent`的命令行程序，源自*熵*（entropy）一词。它应用了一组小的统计测试，可能会影响我们的信念。
- en: 'Many Linux distributions include `ent`, but if yours doesn’t, install it using
    the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Linux发行版都包括`ent`，但如果你的系统没有，可以使用以下命令安装它：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Check the following website for a compiled Windows version (along with a link
    to its GitHub repository, should you wish to examine `ent`’s source code): *[https://www.fourmilab.ch/random](https://www.fourmilab.ch/random)*.
    To install `ent` on macOS in the previous command, replace `sudo apt-get` with
    `brew`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问以下网站，查看编译好的Windows版本（以及它的GitHub仓库链接，如果你想查看`ent`的源代码）：*[https://www.fourmilab.ch/random](https://www.fourmilab.ch/random)。*
    要在macOS上安装`ent`，在前面的命令中将`sudo apt-get`替换为`brew`。
- en: The `ent` program requires a file of bytes, which it assumes are uniformly distributed
    in the range [0, 255]. This means that the random process under test must have
    its output converted into a set of uniformly distributed bytes. We’ll learn how
    to do this later in the chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ent`程序需要一个字节文件，它假定这些字节在[0, 255]范围内均匀分布。这意味着被测试的随机过程必须将其输出转换为一组均匀分布的字节。我们将在本章稍后学习如何做到这一点。'
- en: 'For now, the book’s GitHub page includes a file we can use to understand `ent`’s
    output, *ent_test.bin*. Pass it to `ent` like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，书籍的GitHub页面包含一个文件，我们可以用它来理解`ent`的输出，*ent_test.bin*。像这样将其传递给`ent`：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The file *ent_test.bin* contains bytes generated by a good, but rarely used,
    pseudorandom number generator called MWC (multiply-with-carry). We might expect
    `ent` to report that the file is random. However, `ent` doesn’t make that determination
    for us. Instead, `ent` runs a set of six statistical tests and reports the results,
    leaving it up to us to decide whether those results warrant a belief toward randomness.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*ent_test.bin*包含了由一种良好但很少使用的伪随机数生成器MWC（乘法与进位）生成的字节。我们可能期望`ent`报告该文件是随机的。然而，`ent`不会为我们做出这个判断。相反，`ent`会运行一组六个统计测试并报告结果，留给我们自己决定这些结果是否足以支持随机性的信念。
- en: The first test measures the entropy of the bytes. *Entropy* is a measure of
    disorder in a system. To a physicist, entropy is related to the number of microstates
    of a system—for example, the position and momentum of the molecules in a gas leading
    to the same macroscopic values of large-scale properties like temperature and
    pressure and the ways in which those molecules can be arranged. The entropy reported
    by `ent`, however, is deeper than that. It is the *Shannon entropy*, a measure
    of information content. In this case, it’s expressed in bits. There are 8 bits
    in a byte, so a maximally random sequence would have an entropy of 8.0, meaning
    information content is maximized. Our test file has an entropy of 7.999996 bits
    per byte, which is extremely close to 8, a good sign.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试衡量字节的熵。*熵* 是衡量系统无序度的标准。对物理学家来说，熵与系统的微观状态数有关——例如，气体分子的位置和动量，它们导致相同的宏观物理量，如温度和压力，以及这些分子可以如何排列。然而，`ent`
    报告的熵比这更深刻。它是 *香农熵*，一种衡量信息内容的标准。在这种情况下，它以比特为单位表达。一个字节有 8 比特，因此最大程度随机的序列将具有 8.0
    的熵，意味着信息内容最大化。我们的测试文件具有每字节 7.999996 比特的熵，非常接近 8，这是一个良好的迹象。
- en: We use the entropy reported by `ent` to estimate how much it’s possible to compress
    the file. It’s an alternative presentation of the entropy. Compression algorithms
    work by taking advantage of the information contained in a file, as measured by
    its entropy. The lower the entropy, the more redundant the data, and the lower
    the information content. If the information content is low, there is another way
    to express the information that takes less space. However, if the file is random
    and entropy is maximized, there is no alternative way to express the file’s contents,
    so it cannot be compressed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ent` 报告的熵来估算文件压缩的可能性。这是熵的另一种表现形式。压缩算法通过利用文件中包含的信息（通过其熵来衡量）来工作。熵越低，数据的冗余性越高，信息内容越低。如果信息内容较低，就有其他方式表达这些信息，占用更少的空间。然而，如果文件是随机的且熵已最大化，则无法以其他方式表达文件内容，因此无法压缩。
- en: Next, `ent` applies a *χ*² test. The important part here is the percentage reported.
    If this percentage is below 5 percent or above 95 percent, then the expected frequencies—that
    is, the number of times each byte value appears—is suspect. Here, we have 72 percent,
    so we’re again on solid ground.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`ent` 应用了 *χ*² 测试。这里重要的是报告的百分比。如果这个百分比低于 5% 或高于 95%，那么预期频率——即每个字节值出现的次数——就是可疑的。这里我们得到了
    72%，所以我们仍然处于可靠的范围内。
- en: If the sequence of bytes is random, we might, correctly, expect the average
    value of the bytes to be 255/2 = 127.5\. Here, we have an average value of 127.5064,
    which is quite close.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字节序列是随机的，我们可能会正确地预计字节的平均值为 255/2 = 127.5。这里，我们得到了一个平均值 127.5064，非常接近。
- en: It’s possible to estimate *π* with random numbers; `ent` uses this as another
    test of randomness. In this case, `ent` arrives at an estimate 0.01 percent off
    from the number of digits shown. If there is something in the sequence of bytes
    that biases the simulation, then it should manifest itself in the calculated *π*
    value. We’ll use random numbers to estimate *π* in [Chapter 3](ch03.xhtml).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过随机数估算 *π*；`ent` 将此用作另一种随机性测试。在这种情况下，`ent` 估算出的值与显示的数字相差 0.01%。如果字节序列中有某些因素偏向模拟结果，那么它应该在计算的
    *π* 值中表现出来。我们将在[第 3 章](ch03.xhtml)中使用随机数估算 *π*。
- en: The final output line applies a statistical test to measure how related byte
    *n* is to byte *n* + 1; that is, it pays attention to the order of the bytes.
    If the bytes are not serially correlated, at least to the level of one to the
    next, the resulting coefficient will be zero. Here, it’s ever so slightly negative
    but quite close to zero.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出行应用统计测试来衡量字节 *n* 与字节 *n* + 1 的相关性；也就是说，它关注字节的顺序。如果字节之间没有序列相关性，至少在一个字节到下一个字节的层面上，结果系数将为零。在这里，它略微为负，但非常接近零。
- en: All in all, then, `ent`’s report gives us strong confidence that the contents
    of the file *ent_test.bin* are worthy of being called random. Would you secure
    your bank account with this level of confidence? I sincerely hope not, but we’re
    not interested in cryptography; we’re interested in random processes, real or
    synthetic, that are sufficiently random to power our experiments. For that, `ent`
    is the only tool we need.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`ent`的报告让我们对文件*ent_test.bin*的内容是否可以称为随机有了很大的信心。你会用这种信心水平来保护你的银行账户吗？我真心希望不是，但我们并不关注密码学；我们关注的是足够随机的随机过程，不论是自然的还是合成的，足以支持我们的实验。为此，`ent`是我们唯一需要的工具。
- en: 'However, `ent`’s output is needlessly verbose, especially since we’ll use it
    often in this chapter. Let’s define an abbreviated version. Instead of the output
    shown earlier, I’ll report `ent` results like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ent`的输出过于冗长，特别是我们在本章中将经常使用它。让我们定义一个简化版本。与之前显示的输出不同，我将以如下方式报告`ent`的结果：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s put our nifty randomness detector to work. We’ll begin with truly random
    processes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用我们精巧的随机性检测器。我们将从真正的随机过程开始。
- en: '**Truly Random Processes**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**真正的随机过程**'
- en: 'In this section, we’ll review several sources generally accepted as true random
    processes: experimenting with coins, dice, electrical noise in different forms,
    and the decay of radioactive elements. We’ll use the datasets we create here for
    experiments later in the book. The random processes covered in this section also
    provide a comparison against the next section’s pseudorandom processes, which
    merely give the appearance of randomness.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾几种通常被认为是真正随机过程的来源：掷硬币、掷骰子、各种形式的电噪声以及放射性元素的衰变。我们将在本书后续的实验中使用我们在此创建的数据集。本节涵盖的随机过程也为下一节的伪随机过程提供了对比，后者只是给人随机的假象。
- en: Humanity has, over the centuries, developed multiple ways of generating randomness,
    including coin flips and dice rolls. Let’s consider these to see if we might trust
    them as randomness engines.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 人类在几个世纪以来，已经发展出多种生成随机性的方式，包括掷硬币和掷骰子。让我们考虑这些方法，看看我们是否可以将它们当作随机性引擎来信任。
- en: '***Flipping Coins***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***掷硬币***'
- en: Most people consider a coin flip to be a reasonable source of randomness, but
    is that really the case? In 2009, two undergraduate students at the University
    of California, Berkeley, flipped a coin a total of 40,000 times while keeping
    track of the coin’s starting orientation, either heads up or tails up. [Table
    1-4](ch01.xhtml#ch01tab04) shows what they found (data used with permission).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人认为掷硬币是一个合理的随机性来源，但真的是这样吗？2009年，两个加利福尼亚大学伯克利分校的本科生总共掷了40,000次硬币，并记录了硬币的起始方向，正面朝上或反面朝上。[表1-4](ch01.xhtml#ch01tab04)展示了他们的发现（数据使用经许可）。
- en: '**Table 1-4:** Flipping 40,000 Coins by Hand'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**表1-4：** 手动掷硬币40,000次'
- en: '| **Orientation** | **Heads** | **Tails** | **p-value** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **方向** | **正面** | **反面** | **p值** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Heads up | 10,231 | 9,770 | 0.0011 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 朝上 | 10,231 | 9,770 | 0.0011 |'
- en: '| Tails up | 9,985 | 10,016 | 0.8265 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 反面朝上 | 9,985 | 10,016 | 0.8265 |'
- en: A glance at [Table 1-4](ch01.xhtml#ch01tab04) shows that when the coin was facing
    heads up, there were more heads at the end of the flip. The same is true for tails
    up; more tails were measured. We can use the *χ*² test to see if these proportions
    are in concert with the expected 50-50 split of a fair coin. The resulting p-values
    are in the rightmost column.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 看一眼[表1-4](ch01.xhtml#ch01tab04)，可以看到当硬币正面朝上时，翻转结束时正面朝上的次数更多。反面朝上的情况也是如此；反面朝上的次数更多。我们可以使用*χ*²检验来查看这些比例是否与公平硬币的预期50-50分配一致。得到的p值在最右列。
- en: A p-value is the probability of measuring the observed number of heads and tails,
    given that the null hypothesis is true. In statistical testing, the *null hypothesis*
    is the hypothesis being tested. In this case, for the *χ*² test, the null hypothesis
    is that the observed number of heads and tails is consistent with equal likelihoods.
    The p-value provides evidence for or against this hypothesis. If the p-value is
    below the standard, somewhat arbitrary rule-of-thumb threshold of 0.05 (5 percent),
    then we say that the p-value is *statistically significant*, and we claim evidence
    against the null hypotheses.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: p值是指在零假设为真的情况下，观测到的正反面次数的概率。在统计检验中，*零假设*是被检验的假设。在此例中，对于*χ*²检验，零假设是观测到的正反面次数与相等概率一致。p值为我们提供了支持或反对该假设的证据。如果p值低于标准的、略显任意的经验法则阈值0.05（5%），则我们认为该p值是*统计显著*的，并宣称反对零假设。
- en: The smaller the p-value, the stronger our evidence becomes. For a p-value threshold
    of 0.05, we might expect to falsely reject the null hypothesis about 1 time in
    20, while for a p-value of 0.01, the false rejection rate becomes 1 in 100, and
    so on as the p-values get smaller and smaller. However, only death and taxes are
    certain. A small p-value is not *proof* of anything; it’s only an indicator, a
    reason to believe or not to believe, though with perhaps strong evidence.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: p 值越小，我们的证据就越强。对于 0.05 的 p 值阈值，我们可能会期望大约每 20 次中有 1 次错误地拒绝零假设；而对于 0.01 的 p 值，错误拒绝的比率变成了每
    100 次 1 次，随着 p 值变得越来越小，错误拒绝的比率也越来越低。然而，只有死亡和税收是确定的。一个小的 p 值并不是任何事情的*证明*；它只是一个指标，是相信与否的理由，尽管可能有强有力的证据支持。
- en: Look again at the Heads up row in [Table 1-4](ch01.xhtml#ch01tab04). The p-value
    is 0.0011, or 0.11 percent. According to the *χ*² test, there is a 0.11 percent
    probability of the observed counts (or a more extreme difference), given the null
    hypothesis is true. Therefore, we have evidence in favor of rejecting the null
    hypothesis. In other words, we have evidence for believing that Subject 1, who
    did the heads-up portion of the experiment, was not random, but was instead biased
    toward heads.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看[表 1-4](ch01.xhtml#ch01tab04)中的“正面朝上”行。p 值为 0.0011，或 0.11%。根据*χ*² 检验，给定零假设为真，观察到的计数（或更极端的差异）的概率为
    0.11%。因此，我们有证据支持拒绝零假设。换句话说，我们有证据表明进行正面朝上的实验部分的受试者 1 不是随机的，而是有偏向正面的倾向。
- en: Subject 2, however, produced results consistent with the null hypothesis. For
    her, the p-value was 0.8265, or 83 percent. Again, the p-value, in this case,
    means the *χ*² test reports a probability of 83 percent for observing the counts,
    given the null hypothesis is true. This makes perfect sense, so we have evidence
    supporting the null hypothesis for the tails-up case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，受试者 2 得到的结果与零假设一致。对于她来说，p 值为 0.8265，或 83%。同样，这里的 p 值意味着*χ*² 检验报告了 83% 的概率，表明在零假设为真的情况下观察到这些计数是合理的。这完全有道理，因此我们有证据支持零假设，适用于反面朝上的情况。
- en: 'The *χ*² test compared the tallies with the expected 50-50 split. We can do
    one more test: a *t-test*. The t-test compares two datasets and returns a p-value
    we interpret as the likelihood the datasets were generated by the same process.
    In this case, the t-test between the heads-up and tails-up data-sets returned
    a p-value of 0.0139, or 1.39 percent, again below the standard 0.05 threshold.
    This serves as evidence that the two datasets are likely drawn from different
    processes.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*χ*² 检验将计数与预期的 50-50 分布进行了比较。我们可以再进行一次检验：*t 检验*。t 检验比较两个数据集，并返回一个 p 值，我们可以将其解释为这两个数据集是否由相同的过程生成的可能性。在这个例子中，正面朝上和反面朝上的数据集之间进行
    t 检验，得到了 p 值 0.0139，或 1.39%，再次低于标准的 0.05 阈值。这作为证据表明这两个数据集很可能来自不同的过程。'
- en: What does that mean in this case? We have a single set of flips from two subjects,
    and each subject only flipped coins with the same side up each time. It’s conceivable,
    but not proven, that Subject 1 was highly consistent in her flips and, as such,
    biased the coin tosses so that heads were favored when heads were the starting
    condition. For us, this fun example serves as an indication that humans are not
    to be trusted to act randomly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这意味着什么？我们有两个受试者的单一翻转集，每个受试者每次翻转硬币时，硬币的正面始终朝上。可以想象，但并未证明，受试者 1 在翻转时非常一致，因此可能使得硬币投掷存在偏差，从而当正面是起始条件时，正面出现的几率较大。对于我们来说，这个有趣的例子表明人类不能被信任去随机行动。
- en: 'We have evidence that Subject 1 biased the coin flips. Are we stuck with the
    bias? Actually, no. American mathematician and computer scientist John von Neumann
    came up with a clever algorithm to make a biased coin fair. The algorithm is straightforward:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有证据表明受试者 1 对硬币翻转存在偏差。我们是否被这种偏差困住了？实际上，并没有。美国数学家和计算机科学家约翰·冯·诺依曼提出了一种巧妙的算法，可以使有偏的硬币变得公平。这个算法非常简单：
- en: Flip the biased coin twice.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将有偏的硬币翻转两次。
- en: If both flips came up the same—that is, both heads or both tails—start again
    from step 1.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两次翻转结果相同——即，都是正面或都是反面——从第 1 步重新开始。
- en: Otherwise, keep the result of the first flip and disregard the second.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，保留第一次翻转的结果，忽略第二次。
- en: Applying this algorithm to the sequence of heads and tails generated by Subject
    1 leaves us with 2,475 heads and 2,538 tails. The *χ*² test delivers a p-value
    of 0.37, which is well above 0.05 and strong evidence that the resulting dataset
    is now acting as expected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个算法应用于受试者 1 生成的正反面序列，我们得到了 2,475 次正面和 2,538 次反面。*χ*² 检验得到了 0.37 的 p 值，远高于
    0.05，这强烈证明结果数据集现在的表现符合预期。
- en: 'Why does von Neumann’s algorithm work? Consider a biased coin where the probability
    of getting a heads is not 0.5 but 0.8, implying that the probability of a tails
    is 0.2, since probabilities add to 1\. In that case, flipping the coin twice will
    lead to the four possible combinations of heads and tails with the following probabilities:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么冯·诺依曼算法有效？考虑一枚偏的硬币，其正面朝上的概率不是0.5，而是0.8，这意味着反面朝上的概率是0.2，因为概率之和为1。在这种情况下，掷硬币两次会产生四种可能的正反面组合，并且具有以下概率：
- en: '![Image](../images/f0010-01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0010-01.jpg)'
- en: Recall that if events are independent, as even the flips of a biased coin are,
    then the probabilities multiply. Also, the probability of getting heads followed
    by tails equals that of getting tails followed by heads. Therefore, consistently
    selecting the first (or the second) in either of these cases must lead to selecting
    heads or tails with equal likelihood.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果事件是独立的，即使是偏硬币的投掷也是如此，那么它们的概率相乘。而且，正面后接反面和反面后接正面的概率是相等的。因此，在这两种情况下，始终选择第一个（或第二个）结果必然会以相同的概率选择正面或反面。
- en: The file *40000cointosses.csv* contains the dataset used in this experiment
    with the associated code in *40000cointosses.py*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*40000cointosses.csv*包含了本实验中使用的数据集，以及相关的代码*40000cointosses.py*。
- en: '**NOTE**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please review the original web page for other comments on how the experiment
    was conducted, including suitable warnings about taking the results as anything
    more than a hint that further experimentation might uncover something interesting:*
    [https://www.stat.berkeley.edu/∼ldous/Real-World/coin_tosses.html](https://www.stat.berkeley.edu/∼ldous/Real-World/coin_tosses.html).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*请查看原始网页，了解关于实验如何进行的其他评论，包括有关将结果仅视为进一步实验可能揭示有趣内容的提示的适当警告：* [https://www.stat.berkeley.edu/∼ldous/Real-World/coin_tosses.html](https://www.stat.berkeley.edu/∼ldous/Real-World/coin_tosses.html)。'
- en: '***Rolling Dice***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***骰子投掷***'
- en: Flipping a fair coin is a random process, as is rolling a fair die. But is there
    really such a thing as a “fair” die? Imperfections in the manufacturing process,
    a slight deviation in shape, or unequal density throughout the die’s body might
    lead to a bias. Still, overall, and especially for our purposes, we might believe
    that dice rolls are random enough to be useful.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 投掷公平硬币是一个随机过程，投掷公平骰子也是如此。但真的有“公平”的骰子吗？制造过程中可能存在的缺陷、形状的轻微偏差，或者骰体内的不均匀密度可能会导致偏差。然而，总的来说，尤其是对于我们的目的来说，我们可能认为骰子投掷足够随机，可以作为有用的数据。
- en: I gathered 14 six-sided dice and rolled them, en masse, using a dice cup from
    a game. I then took a picture of the results so I could count how many of each
    face appeared. I repeated this process 50 times for a total of 700 dice rolls.
    [Table 1-5](ch01.xhtml#ch01tab05) shows the results.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我收集了14颗六面骰，并使用游戏中的骰盅将它们一起掷出。然后我拍下了结果的照片，以便统计每个面朝上的次数。我重复了这个过程50次，总共进行了700次骰子投掷。[表1-5](ch01.xhtml#ch01tab05)显示了结果。
- en: '**Table 1-5:** Tallying Dice Rolls'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**表1-5：** 骰子投掷计数'
- en: '| **Outcome** | **Count** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **结果** | **计数** |'
- en: '| --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 122 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 122 |'
- en: '| 2 | 98 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 98 |'
- en: '| 3 | 106 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 106 |'
- en: '| 4 | 126 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 126 |'
- en: '| 5 | 119 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 119 |'
- en: '| 6 | 129 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 129 |'
- en: 'As before, if the dice are fair, we expect each count to be the same. For 700
    rolls, we expect each possible output to appear 700/6 ≈ 117 times—a spartan number
    because of the small scale of the experiment, but sufficient for us to acknowledge
    the chief concern of this section: to master our appreciation of truly random
    processes.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所述，如果骰子是公平的，我们期望每个结果的出现次数相同。在700次投掷中，我们期望每个可能的结果出现700/6 ≈ 117次——由于实验规模较小，这是一个简单的数字，但足以让我们关注本节的主要问题：掌握我们对真正随机过程的理解。
- en: The counts in [Table 1-5](ch01.xhtml#ch01tab05) are not 117 but deviate, often
    by quite a bit. Does this mean the dice are loaded? Perhaps, but we’ll never know
    for sure; we can only gain evidence favoring one answer over another. The *χ*²
    test is our tool of choice here, as it was for the preceding coin flips. Applying
    it returns a p-value of 0.28, well above the threshold of 0.05 that is generally
    accepted as statistically significant. Therefore, we do not reject the null hypothesis
    and believe that the dice are reasonably fair and, consequently, a potential source
    of true randomness.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[表1-5](ch01.xhtml#ch01tab05)中的计数值并不是117，而是有偏差，通常偏差较大。这是否意味着骰子是加权的？也许是，但我们永远无法确定；我们只能收集有利于一个答案的证据。*χ*²检验是我们在这里选择的工具，就像在前面的硬币掷投中一样。应用它返回的p值为0.28，远高于通常认为具有统计显著性的0.05阈值。因此，我们不拒绝零假设，并认为骰子是合理公平的，因此可能是一个真正的随机来源。'
- en: Macroscopic physical systems are likely insufficient if the goal is to create
    truly random numbers; there are too many biases involved, though we can use an
    algorithm like von Neumann’s to improve the situation. Also, a physical randomness
    engine, perhaps based on automatic dice rolls, will degrade over time, further
    introducing bias. Therefore, we must search in a different direction. Let’s now
    consider processes more suitable for a randomness engine.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是生成真正的随机数，宏观物理系统可能不足以胜任；涉及的偏差太多，尽管我们可以使用像冯·诺依曼（von Neumann）算法来改善这种情况。而且，基于物理的随机性引擎，或许是基于自动掷骰子的方式，随着时间推移会退化，进一步引入偏差。因此，我们必须朝着不同的方向寻找。现在让我们考虑更适合用作随机性引擎的过程。
- en: '**ROULETTE WHEELS**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮盘赌轮**'
- en: Roulette is another physical process that comes to mind when contemplating potential
    sources of randomness. In roulette, people bet on the position in which a marble
    will ultimately land when rolled against a spinning wheel. It is a favorite target
    for people trying to game the system because players can make bets while the wheel
    is spinning. On the face of it, a roulette wheel should be as random as rolling
    dice, but mechanical defects, especially if the wheel is tilted even the tiniest
    bit, bias the final ball position to the advantage of the clever.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 轮盘赌是另一个在考虑潜在随机性来源时会想到的物理过程。在轮盘赌中，人们下注预测弹珠最终落在哪个位置。它是试图“破解”系统的人们的最爱目标，因为玩家可以在轮盘转动时下注。从表面上看，轮盘赌应该和掷骰子一样是随机的，但机械缺陷，特别是如果轮盘倾斜哪怕一点点，也会让最终的球位置偏向那些聪明的玩家。
- en: The first occurrence of gaming a roulette wheel that I could find happened around
    1880 when Englishman Joseph Jagger, a textile worker, realized that imperfections
    in the construction of the roulette wheels in Monte Carlo enabled him to predict
    the final ball position reliably enough to win more often than he lost. His success
    forced improvements to the design of roulette wheels.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我能找到的第一个轮盘赌“破解”事件发生在1880年左右，当时英国人约瑟夫·贾格（Joseph Jagger），一名纺织工人，意识到蒙特卡洛的轮盘赌轮的构造缺陷使他能够可靠地预测球的最终位置，从而比失误更多地获胜。他的成功促使轮盘赌轮设计的改进。
- en: Around 1960, Edward Thorp, working with Claude Shannon, constructed what is
    likely the first wearable computer for the sole purpose of gaming roulette. The
    full account is in Thorp’s paper, titled “The Invention of the First Wearable
    Computer,” published in 1998\. The computer was small, with only 12 transistors,
    and was operated by a footswitch concealed in a shoe. As the roulette wheel turned,
    the footswitch started a timer that delivered one of eight tones to a tiny earpiece,
    each tone indicting a predicted octant in which the ball was more likely to fall.
    The system, though fragile, worked and was tried in Las Vegas in 1961 with some
    success.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在1960年，爱德华·索普（Edward Thorp）与克劳德·香农（Claude Shannon）合作，构建了可能是世界上第一个可穿戴计算机，唯一的目的是用来玩轮盘赌。完整的内容可以在索普1998年发表的论文《第一个可穿戴计算机的发明》中找到。该计算机体积小，只有12个晶体管，并通过藏在鞋子里的脚踏开关操作。当轮盘转动时，脚踏开关启动一个计时器，通过一个小耳机发出八种音调中的一种，每种音调表示球更可能落入的一个八分之一区域。虽然该系统脆弱，但它有效，并且在1961年在拉斯维加斯试验时取得了一定的成功。
- en: In the 1970s, J. Doyne Farmer and Norman Packard essentially repeated that experiment
    using a microcomputer. Like Thorp and Shannon, they were similarly successful
    in the casinos; see Farmer’s brief page at *[http://www.doynefarmer.com/roulette](http://www.doynefarmer.com/roulette)*
    or the more detailed account in Thomas Bass’s book *The Eudaemonic Pie*, which
    is available online via the Internet Archive (*[https://archive.org](https://archive.org)*).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年代，J·多伊恩·法默（J. Doyne Farmer）和诺曼·帕卡德（Norman Packard）基本上用微型计算机重复了这个实验。像索普和香农一样，他们在赌场中同样取得了成功；请参阅法默简短的页面
    *[http://www.doynefarmer.com/roulette](http://www.doynefarmer.com/roulette)* 或托马斯·巴斯（Thomas
    Bass）所著的《幸福派》（*The Eudaemonic Pie*）一书中的更详细内容，该书可以通过互联网档案馆在线获取 (*[https://archive.org](https://archive.org)*)。
- en: '***Using Voltage***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用电压***'
- en: 'Most desktop computers have a microphone input jack. A program like Audacity
    can record samples from this input device. We might expect recording when no microphone
    is connected to give us an empty file, but it doesn’t. The microphone input is
    an analog input and is susceptible to electronic noise: minor, random variations
    in voltage due to the nature of the components involved and other environmental
    factors. We’ll use the variation of this voltage as a randomness engine.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数台式计算机都有麦克风输入插孔。像Audacity这样的程序可以从这个输入设备录制样本。我们可能会认为，在没有连接麦克风的情况下进行录音会得到一个空文件，但事实并非如此。麦克风输入是模拟输入，容易受到电子噪声的影响：由于相关组件的特性和其他环境因素，电压会出现微小的随机变化。我们将利用这种电压的变化作为随机性引擎。
- en: 'This experiment requires you to record a WAV file. It doesn’t matter which
    tool you use to do so. I used Audacity, an open source sound editor available
    for most systems. Install it under Ubuntu with the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验要求你录制一个WAV文件。使用什么工具录制都没有关系。我使用了Audacity，这是一款开源的声音编辑器，适用于大多数操作系统。在Ubuntu系统中，可以使用以下命令安装它：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Visit *[https://www.audacityteam.org](https://www.audacityteam.org)* to install
    Audacity for Windows and macOS.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 *[https://www.audacityteam.org](https://www.audacityteam.org)* 安装适用于Windows和macOS的Audacity。
- en: We want to record from the microphone input using a single channel (mono) and
    at a high sampling rate, like 176,400 Hz (samples per second). For Audacity, this
    means changing the project rate to 176,400 (see the lower left of the screen)
    and changing the recording channel drop-down menu to **Mono**. We also need to
    select the microphone as the input source. The name of this device on your system
    is beyond my powers of clairvoyance, but experimentation with the drop-down menu
    next to the microphone icon will likely turn up the proper device. To test the
    input, select **Click to Start Monitoring**. You should see a slowly varying sound
    bar for only one channel (for example, the left channel). If not, play around
    a bit more until you do.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用单声道（mono）和较高的采样率（如176,400 Hz，样本每秒）从麦克风输入进行录制。对于Audacity来说，这意味着将项目速率更改为176,400（参见屏幕左下角），并将录音通道下拉菜单更改为**单声道**。我们还需要选择麦克风作为输入源。系统中该设备的名称超出了我的预知能力，但通过实验，点击麦克风图标旁边的下拉菜单，应该能找到正确的设备。要测试输入，请选择**点击开始监视**。你应该看到只有一个通道（例如左声道）产生的逐渐变化的声音条。如果没有，继续调整，直到出现。
- en: To record a sample, click the red record button. I suggest recording for several
    minutes. To stop, click the square stop button. Use the appropriate option on
    the File menu to export the recording as a WAV file, setting the output format
    in the File Save dialog to **32-bit float PCM**. If you can’t use this method
    to record a WAV file, there are several small ones available on the book’s website
    that you can use with the upcoming code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要录制样本，请点击红色的录音按钮。我建议录制几分钟。要停止录音，请点击方形的停止按钮。在文件菜单中使用适当的选项将录音导出为WAV文件，在文件保存对话框中设置输出格式为**32位浮点PCM**。如果你无法使用此方法录制WAV文件，本书的网站上有一些小的WAV文件，你可以在接下来的代码中使用。
- en: Audio signals are represented as a continuous voltage that changes with time.
    Sampling an audio signal means measuring the instantaneous voltage at a set time
    interval, the sampling rate, and turning that voltage into a number over some
    range. For example, a compact disc uses 16-bit samples, so each voltage is assigned
    a number in the range −32,768 to 32,767\. The sampling rate decides how frequently
    the voltage is measured.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 音频信号是表示为随时间变化的连续电压。采样音频信号意味着在设定的时间间隔——即采样率——内测量瞬时电压，并将该电压转换为某个范围内的数字。例如，光盘使用16位采样，因此每个电压都被赋予一个范围为−32,768到32,767的数字。采样率决定了电压测量的频率。
- en: When a digitized signal is played back, meaning converted back into a voltage
    to drive a speaker, for instance, the quality of the sound depends on how many
    numbers were used to represent the signal and how often it was sampled. For our
    experiment, the samples are represented as 32-bit floating-point numbers, and
    the sampling rate is 176,400 Hz. By comparison, a compact disc samples at 44,100
    Hz.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当数字化信号被回放时——意味着将其转换回电压以驱动扬声器——音质的好坏取决于用于表示信号的数字数量以及采样的频率。在我们的实验中，样本表示为32位浮点数，采样率为176,400
    Hz。相比之下，光盘的采样率为44,100 Hz。
- en: '[Figure 1-2](ch01.xhtml#ch01fig02) shows a subset of audio samples and their
    corresponding histogram.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-2](ch01.xhtml#ch01fig02)展示了一部分音频样本及其对应的直方图。'
- en: '![Image](../images/01fig02.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig02.jpg)'
- en: '*Figure 1-2: The audio samples (left) and corresponding histogram (right)*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：音频样本（左）和相应的直方图（右）*'
- en: The *x*-axis in [Figure 1-2](ch01.xhtml#ch01fig02) is time, that is, the sample
    number, and the *y*-axis is the floating-point sample value, or the digitized
    value representing the voltage at that time. The horizontal line is the mean value
    of all the samples in the file; [Figure 1-2](ch01.xhtml#ch01fig02) shows only
    the first 200\. As we might expect, the mean value is virtually 0.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](ch01.xhtml#ch01fig02)中的*x*轴是时间，即样本编号，*y*轴是浮动的样本值，或表示当时电压的数字化值。水平线是文件中所有样本的均值；[图
    1-2](ch01.xhtml#ch01fig02)只显示了前200个。正如我们所预料的，均值几乎为0。'
- en: The right side of [Figure 1-2](ch01.xhtml#ch01fig02) shows us the histogram
    of all the samples in a two-second clip. We’ve seen this shape before; it’s nearly
    identical to [Figure 1-1](ch01.xhtml#ch01fig01), and it tells us that the noise
    samples are normally distributed with a mean value of 0\. We’ll use this observation
    to convert the audio stream into a file of random bytes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](ch01.xhtml#ch01fig02)的右侧显示了一个两秒钟片段中所有样本的直方图。我们以前见过这种形状；它几乎与[图 1-1](ch01.xhtml#ch01fig01)完全相同，告诉我们噪声样本呈正态分布，均值为0。我们将利用这个观察结果，把音频流转换成一个随机字节文件。'
- en: We cannot use the recording as is; we must process the samples to make them
    more random, using the code in *silence.py*. Let’s walk through it part by part.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接使用录音；必须处理样本，使其更具随机性，使用*silence.py*中的代码。让我们逐部分地分析。
- en: 'First, we `import` some library routines:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们`import`一些库函数：
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `sys` module provides an interface to the command line; `numpy` we know.
    To read WAV files, we need the `read` function from SciPy. Here, I’m renaming
    it `wavread`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys`模块提供了命令行的接口；`numpy`我们已经知道了。为了读取WAV文件，我们需要SciPy中的`read`函数。在这里，我将其重命名为`wavread`。'
- en: 'At the bottom of the script, we load the desired WAV file and process it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的底部，我们加载所需的WAV文件并进行处理：
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `wavread` function returns the sampling rate (`s`) and the samples themselves
    as a NumPy vector (`d`). We display the sampling rate, then split the samples
    into two halves and pass each half to `MakeBytes` before assigning the return
    values `a` and `b`, respectively. `MakeBytes` turns a vector of audio samples
    into a vector of bytes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`wavread`函数返回采样率（`s`）和样本本身作为NumPy向量（`d`）。我们显示采样率，然后将样本分为两半，并将每一半传递给`MakeBytes`，然后分别将返回值赋给`a`和`b`。`MakeBytes`将一个音频样本向量转换为字节向量。'
- en: 'The final set of bytes is in `c`. This is the exclusive-OR (XOR) of the bytes
    in `a` and `b`. XOR is a logical operation on the bits of an integer. If one of
    the inputs to XOR is 1 and the other 0, then the output is 1\. If the inputs are
    the same, the output is 0\. I remember the phrase “one or the other, but not both.”
    XOR is different from the standard OR operation, which outputs 1 if any input
    is 1, including if both are 1, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的字节集在`c`中。这是`a`和`b`中字节的异或（XOR）。XOR是一种对整数位进行的逻辑操作。如果XOR的一个输入为1，另一个为0，则输出为1。如果两个输入相同，则输出为0。我记得那句“要么一个，要么另一个，但不能都选。”XOR与标准的OR操作不同，OR操作在任一输入为1时输出1，包括两者都为1的情况，如下所示：
- en: 1 XOR 1 = 0, but 1 OR 1 = 1
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 1 XOR 1 = 0，但 1 OR 1 = 1
- en: Using one part of the generated stream of bytes to modify the other is a powerful
    way to alter the bit patterns, which adds to the random nature of the output.
    In *silence.py*, one of the byte streams is reversed (`[::-1]`) before XOR to
    add that much more randomness to the process.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成的字节流的一部分来修改另一部分，是改变位模式的强大方法，这增加了输出的随机性。在*silence.py*中，字节流在XOR之前被反转（`[::-1]`），以增加过程的随机性。
- en: The number of bytes returned by `MakeBytes` depends on the actual samples passed
    to it, not the number of samples. Therefore, it is likely that the vector `a`
    will be of different length than `b`, hence the `if` statement and indexing based
    on `len`. When `c` is ready, it’s written to disk in binary via `tofile`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeBytes`返回的字节数取决于实际传递给它的样本，而不是样本的数量。因此，`a`的向量长度可能与`b`不同，这就是`if`语句和基于`len`的索引的原因。当`c`准备好时，它通过`tofile`以二进制形式写入磁盘。'
- en: 'All the action is in the `MakeBytes` function. Converting the stream of audio
    samples into bytes requires four steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的操作都在`MakeBytes`函数中。将音频样本流转换为字节需要四个步骤：
- en: Subtract the overall mean from each sample.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从每个样本中减去总体均值。
- en: 'Convert each sample to a bit based on its sign: 1 if positive, 0 if negative.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据每个样本的符号将其转换为位：如果为正，设为1；如果为负，设为0。
- en: De-bias the bits using the von Neumann algorithm from the previous section.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前一节中的冯·诺依曼算法来去偏比特。
- en: Group each set of 8 bits into an output byte.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每一组8个位组合成一个输出字节。
- en: 'The function `MakeBytes` performs each of these steps, using the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`MakeBytes`执行了这些步骤，使用了以下代码：
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code passes in the samples as `A`, a NumPy vector. Now come the four steps.
    First, we subtract any mean value (`t`) ➊. Next, we define `thresh` to be 1 percent
    of the maximum range of the samples. I’ll explain why momentarily.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将样本作为`A`传入，这是一个NumPy向量。接下来是四个步骤。首先，我们减去任何均值（`t`） ➊。然后，我们将`thresh`定义为样本最大范围的1%。稍后我会解释为什么。
- en: 'Step 2 says to use the sign of each sample as a bit ➋. We observed that the
    samples are normally distributed, and the mean is now zero because we subtracted
    it, so roughly half the samples will be negative and half positive. This sounds
    a lot like a coin flip: either one value or another. Therefore, we make the positive
    samples ones and the negative samples zeros. But what’s the point of `thresh`?'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2表示使用每个样本的符号作为一个比特 ➋。我们观察到样本呈正态分布，且均值已被减去，因此大约一半的样本会是负数，另一半是正数。这听起来很像掷硬币：要么一个值，要么另一个值。因此，我们将正样本设为1，负样本设为0。那么，`thresh`的意义何在呢？
- en: The bits are collected in the list `w`, initially empty. The loop after initializing
    `w` examines each sample and asks if the sample’s absolute value is less than
    1 percent of the maximum range. If it is, we ignore that sample (`continue`);
    otherwise, we use the sample’s sign to add a new bit to `w`. There may be a tiny,
    nonrandom signal with a low amplitude in the samples. Ignoring samples close to
    zero helps remove any such signal. In effect, we are saying we’re interested in
    only “large” deviations from the mean of zero.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 位被收集到列表`w`中，初始为空。初始化`w`后，循环检查每个样本，判断该样本的绝对值是否小于最大范围的1%。如果是，我们忽略该样本（`continue`）；否则，我们使用样本的符号将一个新的比特添加到`w`中。样本中可能存在一个微小的、非随机的低振幅信号。忽略接近零的样本有助于去除这种信号。实际上，我们的意思是我们只对“较大”的偏离零均值的值感兴趣。
- en: We now have a long list of individual bits (`w`). These bits might be biased,
    representing a collection of unfair coin tosses. To handle this, we de-bias by
    using the von Neumann algorithm, which makes a new list of bits in `b` ➌.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个长长的单个位列表（`w`）。这些位可能有偏，代表一系列不公平的掷硬币结果。为了解决这个问题，我们使用冯·诺依曼算法进行去偏，生成一个新的位列表`b`
    ➌。
- en: Finally, we convert each set of eight bits in `b` into a new list of bytes in
    `z` ➍ by reshaping `b` into an *N*×8 array before multiplying each row of that
    array, column by column, by the value of each bit position in a byte. When all
    is said and done, the code converts the list of bytes into a NumPy array and returns
    it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`b`中的每一组8个位转换成`z`中的新字节列表 ➍，方法是将`b`重塑为一个*N*×8的数组，然后按位与每个字节中的每个比特位置值相乘。当一切完成后，代码将字节列表转换为NumPy数组并返回。
- en: You may want to review the code again to ensure you follow each step. The central
    concept is that we took advantage of the fact that the samples are normally distributed
    to generate a stream of bits that, when de-biased, form the stream of bytes used
    to make the final output of the code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要再次查看代码，确保你理解每个步骤。核心概念是我们利用样本正态分布的特点，生成一个比特流，在去偏后，形成最终输出字节流。
- en: To test out this code, I made a 30-minute recording using Audacity and saved
    the samples in the file *silence.wav*. I then used *silence.py* to convert this
    large WAV file into *silence.bin*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这段代码，我用Audacity做了一个30分钟的录音，并将样本保存为文件*silence.wav*。然后，我使用*silence.py*将这个大WAV文件转换成*silence.bin*。
- en: '**NOTE**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The file* silence.wav *is too large to include in the book’s repository. However,
    if your heart is set on having it, contact me, and I’ll see what I can do.*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件* silence.wav *太大，无法包含在书的资源库中。不过，如果你非常希望拥有它，可以联系我，我会尽力帮忙。*'
- en: 'Here’s the command line I used to convert the WAV file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我用来转换WAV文件的命令行：
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `wavread` function tends to complain about WAV file elements it doesn’t
    understand. Adding `-W ignore` to the command line suppresses these warnings.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`wavread`函数往往会抱怨它无法理解的WAV文件元素。将`-W ignore`添加到命令行中可以抑制这些警告。'
- en: 'The resulting output file, *silence.bin*, is not quite 6MB. It’s a collection
    of random bytes, so we can pass it to `ent` to get a report:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出文件*silence.bin*的大小不到6MB。它是一个随机字节的集合，所以我们可以将它传递给`ent`来生成报告：
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These are reasonably good values. The only value that is not where we might
    want it to be is *χ*², but we can live with that. Keep *silence.bin* on hand to
    use as a randomness engine later in the book.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是相当不错的。唯一一个不符合我们预期的值是*χ*²，但我们可以接受这一点。以后可以将*silence.bin*保留在手边，作为本书后续章节中随机数引擎的来源。
- en: '**Random Physical Processes**'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**随机物理过程**'
- en: 'Many physical processes are random, though possibly biased. In this section,
    we’ll explore three physical processes leading to randomness: atmospheric radio
    frequency noise, plasma and charged particle rates as detected by the *Voyager
    1* and *Voyager 2* spacecraft during their 40-plus-year mission, and the decay
    of radioactive isotopes.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 许多物理过程是随机的，尽管可能存在偏差。在这一部分中，我们将探讨三种导致随机性的物理过程：大气射频噪声、*旅行者1号*和*旅行者2号*探测器在其超过40年的任务中所探测到的等离子体和带电粒子速率，以及放射性同位素的衰变。
- en: '***Atmospheric Radio Frequency Noise***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***大气射频噪声***'
- en: In 1997, Mads Haahr, a computer science professor at Trinity College, Dublin,
    started *[https://www.random.org](https://www.random.org)*, a website dedicated
    to generating truly random numbers from atmospheric radio frequency noise. The
    site has been running ever since and offers free random numbers to internet users,
    along with a host of paid services involving random numbers. You can take a look
    at the services offered at *[https://www.random.org](https://www.random.org)*,
    but for the purposes of this book, we’ll stick to the free collection of random
    bytes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 1997年，来自都柏林圣三一大学的计算机科学教授Mads Haahr启动了* [https://www.random.org](https://www.random.org)
    *，这是一个致力于从大气射频噪声中生成真正随机数字的网站。该网站自启动以来一直在运行，并向互联网用户提供免费的随机数字服务，同时还提供一些付费的随机数字相关服务。你可以浏览*
    [https://www.random.org](https://www.random.org) *上的服务，但为了本书的目的，我们将继续使用免费的随机字节收集。
- en: There are two primary ways to get random data from the site. First, random data
    in 16KB chunks are available at *[https://www.random.org/bytes](https://www.random.org/bytes)*.
    Simply select the desired format and download. However, since we need larger collections
    of bytes to use as a randomness engine for our experiments, we are better served
    by using the archive available at *[https://archive.random.org](https://archive.random.org)*.
    Downloading files directly from the site requires a small fee. However, if you
    are comfortable using torrents, the files can be legally acquired for free. Our
    reference Linux distribution includes Transmission, a client for accessing torrents.
    The application is also available for other operating systems; visit *[https://transmissionbt.com](https://transmissionbt.com)*
    for download instructions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从网站获取随机数据有两种主要方式。首先，可以通过* [https://www.random.org/bytes](https://www.random.org/bytes)
    *获取16KB块的随机数据。只需选择所需格式并下载。然而，由于我们需要更大的字节集合作为实验的随机数引擎，因此使用* [https://archive.random.org](https://archive.random.org)
    *提供的存档文件会更合适。从网站直接下载文件需要支付小额费用。然而，如果你熟悉使用种子下载，文件可以合法地免费获取。我们的参考Linux发行版包括Transmission，一个用于访问种子下载的客户端。该应用也可用于其他操作系统；访问*
    [https://transmissionbt.com](https://transmissionbt.com) *获取下载说明。
- en: 'As a test, I used Transmission to download several months’ worth of random
    bytes (the Binary Files option). I then combined all the binary files into one
    using the `cat` command. For example, a command like this will merge all binary
    files ending in *.bin* into the file *random_bytes*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试，我使用Transmission下载了几个月的随机字节（选择了二进制文件选项）。然后，我使用`cat`命令将所有二进制文件合并为一个。例如，像这样的命令会将所有以*.bin*结尾的二进制文件合并为文件*random_bytes*：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I then passed *random_bytes* (about 126MB) to `ent` to get the following results:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将*random_bytes*（约126MB）传递给`ent`，得到了以下结果：
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We see that `ent` is quite happy with *random_bytes*. I have a much larger
    collection of bits from *[random.org](http://random.org)*, including bits from
    two previous years. It’s over 500MB in size, and `ent` likes this one as well:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`ent`对*random_bytes*非常满意。我还拥有来自* [random.org](http://random.org) *的更大字节集合，包括过去两年的位数据。它的大小超过500MB，`ent`也喜欢这个数据集。
- en: '[PRE11]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code shows that the entropy is maximized, with 8 bits per byte.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示熵值已最大化，每个字节8位。
- en: '#### ***Voyager Plasma and Charged Particle Data***'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***旅行者号等离子体和带电粒子数据***'
- en: In 1977, NASA launched the twin *Voyager* spacecraft to explore the outer solar
    system. *Voyager 1* encountered Jupiter and Saturn before heading out of the solar
    system. *Voyager 2* passed by Jupiter, Saturn, Uranus, and Neptune on its grand
    tour. To date, *Voyager 2* is the only spacecraft to explore Uranus and Neptune.
    In August 2012, *Voyager 1* became the first human-made object to leave the solar
    system and enter interstellar space. As of this writing, October 2023, both spacecraft
    are still performing well and have enough power for perhaps a decade.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 1977年，NASA发射了双子座*旅行者*航天器，探索外太阳系。*旅行者1号*在接近木星和土星后，继续向太阳系外部进发。*旅行者2号*则在大巡游中经过木星、土星、天王星和海王星。迄今为止，*旅行者2号*是唯一一艘探测天王星和海王星的航天器。2012年8月，*旅行者1号*成为首个人造物体离开太阳系并进入星际空间。截至本文写作时，2023年10月，两个航天器仍在良好运行，并且有足够的电力，或许还能再工作十年。
- en: The *Voyager*s are best known for the fantastic images they returned. However,
    both spacecraft carry multiple scientific instruments for measuring the environment
    through which they travel. This includes devices for measuring plasma protons
    and the flux of other charged particles and nuclei. These measurements are not
    entirely random but vary around certain values, much like the microphone input
    we used previously. Therefore, it’s possible to use the *Voyager* data to construct
    a binary file suitable for use as a source of randomness.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*旅行者*号最著名的是它们返回的精彩图像。然而，两个航天器都携带了多个科学仪器，用于测量它们所穿越环境的各项参数。这些仪器包括用于测量等离子体质子和其他带电粒子及核子通量的设备。这些测量数据并非完全随机，而是围绕某些值波动，就像我们之前使用的麦克风输入一样。因此，可以利用*旅行者*号的数据构造一个适合作为随机源的二进制文件。'
- en: The file *voyager_plasma_lecp.bin* contains bytes formed from a set of *Voyager*
    datafiles, including plasma proton counts, density, and temperature for 1977 through
    1980, and low-energy charged particle fluxes (particles passing through an area
    over time) from 1977 through 2021\. I used the code in *process_vgr_data.py* to
    merge several smaller files to process the individual plasma and charged particle
    datasets.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*voyager_plasma_lecp.bin*包含由一组*旅行者*数据文件构成的字节，其中包括1977年至1980年的等离子体质子计数、密度和温度数据，以及1977年至2021年期间的低能带电粒子通量（粒子在单位时间内通过某个区域）。我使用*process_vgr_data.py*中的代码合并了几个较小的文件，以处理单独的等离子体和带电粒子数据集。
- en: 'For each type of data—plasma protons, low-energy protons, low-energy ions,
    and cosmic ray protons—the process was the same: find the median value over the
    time interval and mark each observation as a 1 bit if above the median and a 0
    bit if below. To expand the collection of bits, I repeated this process for the
    median along with 80 percent of the median and 120 percent of the median. I then
    de-biased the final collection of bits using the von Neumann algorithm.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种类型的数据——等离子体质子、低能质子、低能离子和宇宙射线质子——处理过程是相同的：在时间间隔内找到中位值，并且如果观察值高于中位值，则标记为1位，如果低于中位值，则标记为0位。为了扩展位的集合，我对中位值及其80%和120%的值重复了这个过程。然后，我使用冯·诺依曼算法对最终的位集合进行了去偏处理。
- en: 'The resulting file contains 77,265 bytes, and `ent` reports the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件包含77,265字节，`ent`报告如下：
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These are reasonable values.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是合理的数值。
- en: '[Figure 1-3](ch01.xhtml#ch01fig03) shows sample *Voyager* data from the plasma
    and low-energy charged particle experiments.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-3](ch01.xhtml#ch01fig03)展示了来自等离子体和低能带电粒子实验的*旅行者*数据样本。'
- en: '![Image](../images/01fig03.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig03.jpg)'
- en: '*Figure 1-3: Sample* Voyager *data. Clockwise from top left: low-energy ions,
    cosmic ray protons, plasma proton temperature, and plasma proton speed.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-3：*旅行者*数据样本。从左上角开始，顺时针方向：低能离子、宇宙射线质子、等离子体质子温度和等离子体质子速度。*'
- en: The dashed line in each plot marks the median value over the dataset. Observations
    above the median became 1 bits, and those below the median 0 bits. The plot on
    the upper right shows the flux of cosmic ray protons over the entire mission.
    The vertical dashed line marks August 2012, the date when *Voyager 1* officially
    left the solar system. Notice the increase in cosmic ray protons after this time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图中的虚线标记了数据集的中位值。高于中位值的观察值变成1位，低于中位值的变成0位。右上方的图显示了整个任务期间宇宙射线质子的通量。垂直虚线标记了2012年8月，这是*旅行者1号*正式离开太阳系的日期。注意，在这之后宇宙射线质子数量的增加。
- en: '**NOTE**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* Voyager *datasets were gathered from multiple websites. They are presented,
    typically, in text format and required a fair bit of processing on my part to
    whip them into shape. The files used inconsistent formatting, had typos in places,
    and, on occasion, used data from the wrong year. If you want the files as I used
    them, please contact me directly.*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*旅行者*数据集是从多个网站收集的。通常它们以文本格式呈现，需要我进行相当多的处理，才能整理成适合使用的格式。文件使用了不一致的格式，存在拼写错误，有时还使用了错误年份的数据。如果你想要我使用过的文件，请直接与我联系。*'
- en: '#### ***Radioactive Decay***'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***放射性衰变***'
- en: 'From 1996 through December 2022, the HotBits website (*[https://www.fourmilab.ch/hotbits](https://www.fourmilab.ch/hotbits)*)
    delivered truly random data to the public using the most random of random processes:
    radioactive decay.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从1996年到2022年12月，HotBits网站（* [https://www.fourmilab.ch/hotbits](https://www.fourmilab.ch/hotbits)
    *）通过最随机的随机过程——放射性衰变，向公众提供了真正的随机数据。
- en: Radioactive elements, like the cesium-137 used by HotBits, are unstable. Eventually,
    all such atoms decay by some process to another element, in this case, barium-137\.
    The number of protons in an atom determines which element it is. Cesium has 55
    protons in its nucleus; that’s its *atomic number*. *Isotopes* are versions of
    an element where the number of neutrons, also in the nucleus, varies. The sum
    of the two, ignoring the very light electrons, gives the *atomic mass*. If cesium-137
    has 55 protons, it must have 82 neutrons. When an atom of cesium-137 decays, one
    of the neutrons converts into a proton, changing the atomic number to 56 and thereby
    converting the atom to barium-137, an atom with 56 protons and 81 neutrons. Barium-137
    is stable, so the decay process stops. This process varies for different elements.
    For example, the decay of uranium passes through many stages to reach a stable
    isotope of lead.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 放射性元素，如HotBits使用的铯-137，是不稳定的。最终，这些原子通过某种过程衰变成另一种元素，在这个例子中是铋-137。原子中的质子数决定了它是哪个元素。铯的原子核中有55个质子；这就是它的*原子序数*。*同位素*是元素的不同版本，其中中子的数量（也在原子核中）有所变化。两者的总和，忽略非常轻的电子，给出了*原子质量*。如果铯-137有55个质子，它就必须有82个中子。当铯-137的一个原子衰变时，其中一个中子会转变为质子，使原子序数变为56，从而将原子转变为铋-137，这是一个具有56个质子和81个中子的原子。铋-137是稳定的，因此衰变过程停止。这个过程对于不同元素会有所不同。例如，铀的衰变经历多个阶段，最终转变为稳定的铅同位素。
- en: 'When a neutron becomes a proton, it releases a beta particle (an electron)
    and an antineutrino. Neutrinos have virtually no mass and are almost undetectable.
    However, a Geiger counter easily detects beta particles. This is how the HotBits
    site generates random bits. To be complete, the decay from cesium to barium passes
    through two stages: the barium nucleus begins in a metastable state, then, about
    two minutes later, returns to the ground state by emitting a gamma ray. A gamma
    ray is a high-energy photon, that is, light.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个中子变为质子时，它会释放出一个贝塔粒子（电子）和一个反中微子。中微子几乎没有质量，几乎无法探测。然而，盖革计数器可以轻松探测到贝塔粒子。这就是HotBits网站生成随机位的方式。为了完整性，铯到铋的衰变经历两个阶段：铋的原子核开始时处于亚稳定状态，然后大约两分钟后，通过释放一个伽马射线回到基态。伽马射线是一种高能光子，也就是光。
- en: The time when a particular decay will happen is governed by quantum physics
    and all the “weirdness” we associate with it. For radioactive decay, the weirdness
    at play is *quantum tunneling*, the fact that even though the cesium atom lacks
    the energy to, in effect, push itself up and out of the bowl it’s in, it nevertheless
    has a nonzero probability of doing so. There is no classical physics analog for
    quantum tunneling.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 特定衰变发生的时间由量子物理学以及我们所称的所有“怪异现象”决定。对于放射性衰变，起作用的怪异现象是*量子隧穿效应*，即便铯原子缺乏足够的能量去将自己从所处的碗形区域推出来，它仍然有一定的非零概率能够做到这一点。量子隧穿效应在经典物理中没有类似的解释。
- en: HotBits takes advantage of this unpredictability by using the timing between
    two pairs of detections to output a 1 or a 0\. First, a beta particle is detected,
    then another. The time interval between the two detections is denoted as *T*[1].
    Next, another pair is detected with that time interval labeled *T*[2]. If *T*[1]
    ≠ *T*[2], a bit is generated. If *T*[1] < *T*[2], the bit is a 0; otherwise, *T*[1]
    > *T*[2] and the output bit is a 1\. The sense of the comparison is reversed after
    each bit to frustrate any systematic bias introduced by the physical setup.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: HotBits通过利用两对检测之间的时间间隔来输出1或0，利用了这种不可预测性。首先，检测到一个β粒子，然后是另一个。两次检测之间的时间间隔称为*T*[1]。接下来，检测到另一对，并将其时间间隔标记为*T*[2]。如果*T*[1]
    ≠ *T*[2]，则生成一个比特。如果*T*[1] < *T*[2]，则该比特为0；否则，*T*[1] > *T*[2]，输出比特为1。每次比特之后，比较的方向会被反转，以防止物理设置引入任何系统性偏差。
- en: 'HotBits required an API key to request up to 2,048 bytes at a time. There was
    a strict limit to the number of bytes granted in a 24-hour period. I downloaded
    bytes daily as I worked on this book and now have one 3,033,216-byte file. It’s
    pretty good data according to `ent`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: HotBits需要一个API密钥才能一次请求最多2,048字节。在24小时内，分配的字节数量有限制。我在写这本书时每天下载字节，现在我有了一个3,033,216字节的文件。根据`ent`的测试，这个数据相当不错：
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this section, we’ve discussed several different processes that generate random
    data. While all of them are, as we’ll see later, useful, none can generate massive
    quantities of random numbers—and we’ll sometimes need millions of random numbers
    later in the book. We have no choice but to turn to what we might call synthetic
    random processes and generate random numbers using deterministic means. The use
    of the word *deterministic* in the previous sentence should bother you, but I
    suspect you’ll be more comfortable with the idea of simulating a random process
    via a deterministic process by the end of the next section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了几种不同的生成随机数据的过程。虽然它们都很有用（正如我们稍后将看到的），但没有一种能够生成大量的随机数——在本书的后续部分，我们有时需要数百万个随机数。我们别无选择，只能转向我们可以称之为合成随机过程的方式，并通过确定性手段生成随机数。前一句话中使用的*确定性*一词可能会让你不安，但我怀疑你到下一节结束时会更容易接受通过确定性过程模拟随机过程的想法。
- en: '**Deterministic Processes**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**确定性过程**'
- en: As von Neumann once said, “Anyone who attempts to generate random numbers by
    deterministic means is, of course, living in a state of sin.” The very idea of
    a random process is its unpredictability, such that knowledge of what came before
    is of no utility in predicting what will come after. By definition, a deterministic
    process follows a predictable algorithm; therefore, it cannot possibly be a true
    random process.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如冯·诺依曼曾经说过的：“任何试图通过确定性方式生成随机数的人，当然是生活在罪恶之中。” 随机过程的核心思想在于其不可预测性，因此，了解先前发生的事情对预测之后的结果毫无帮助。根据定义，确定性过程遵循可预测的算法；因此，它不可能是真正的随机过程。
- en: Why use deterministic processes, then? Even if the process is deterministic,
    it can approximate a random process to the level where the outputs are helpful.
    A *pseudorandom process* approximates a random process. We’ll make heavy use of
    pseudorandom processes throughout the book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要使用确定性过程呢？即使过程是确定性的，它也可以逼近一个随机过程，直到输出足够有用。*伪随机过程*逼近一个随机过程。我们将在本书中广泛使用伪随机过程。
- en: This section also covers how pseudorandom processes are related to *quasirandom
    processes*. Finally, we’ll discuss two hybrid processes likely already available
    on your computer.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还讨论了伪随机过程与*准随机过程*的关系。最后，我们将讨论两种可能已在你的计算机上可用的混合过程。
- en: '***Pseudorandom Numbers***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***伪随机数***'
- en: There are many ways to approximate a random process that delivers pseudorandom
    numbers on demand. Here, I’ll introduce one such approach for use in our future
    experiments.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以逼近一个随机过程，按需生成伪随机数。在这里，我将介绍一种这样的方法，用于我们未来的实验。
- en: A *linear congruential generator (LCG)* is a simple approach to creating a sequence
    of pseudorandom numbers. The numbers generated by an LCG are good enough for a
    video game and for many of our experiments, but they are statistically weak and
    not recommended for serious use, like in cryptography.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性同余生成器（LCG）*是一种生成伪随机数序列的简单方法。LCG生成的数字对于视频游戏和许多实验来说足够好，但它们在统计学上较弱，不推荐用于严肃的用途，如密码学。'
- en: 'The best way to understand an LCG is to dive right in:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 理解LCG的最好方法就是直接动手实践：
- en: '*x*[*i* + 1] = (*ax[i]* + *c*) mod *m*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*i* + 1] = (*ax[i]* + *c*) mod *m*'
- en: The entire generator is that single equation, where *x* is the value produced
    by the generator. The subscript means that the next value in the sequence, *x*[*i*
    + 1], is derived from the previous, *x[i]*. The initial value, *x*[0], is the
    *seed*, the value that primes the generator. Virtually all pseudorandom generators
    use a seed of some kind.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 整个生成器就是那个单一方程，其中*x*是由生成器产生的值。下标表示序列中的下一个值，*x*[*i* + 1]是从前一个值*x[i]*推导出来的。初始值*x*[0]是*种子*，它为生成器提供了初始值。几乎所有的伪随机生成器都使用某种形式的种子。
- en: The equation consists of two parts. The first is *ax[i]* + *c*, where *a* and
    *c* are carefully chosen positive integers. The second part takes the result of
    the first, *y*, and calculates *y* mod *m*, where *m* is another carefully chosen
    positive integer. The mod operator refers to the modulo, which is nothing more
    than the remainder. To calculate it, the generator first finds *y*/*m* using integer
    division, then the remainder, which must be a number in the range [0, *m*). The
    final result is then used as both the output of the generator and the value used
    to calculate the following output.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程由两部分组成。第一部分是*ax[i]* + *c*，其中*a*和*c*是精心选择的正整数。第二部分取第一部分的结果*y*，并计算*y* mod
    *m*，其中*m*是另一个精心选择的正整数。mod运算符指的是取模，实际上就是求余数。计算时，生成器首先使用整数除法找出*y*/*m*，然后得到余数，该余数必须在[0,
    *m*)范围内。最终结果既作为生成器的输出，又作为计算下一个输出的值。
- en: 'As an example of how this works, let me show you an LCG in action. I’ll use
    small numbers, which helps in understanding, but would be terrible choices in
    practice, as we’ll see:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个原理，让我给你展示一个LCG的实际应用。我将使用小数字，这有助于理解，但在实际应用中会是糟糕的选择，正如我们接下来看到的那样：
- en: '*x*[*i* + 1] = (3*x[i]* + 0) mod 7'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*i* + 1] = (3*x[i]* + 0) mod 7'
- en: 'The seed must be less than 7, so let’s use *x*[0] = 4\. Here’s the sequence
    produced by this LCG:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 种子必须小于7，所以我们使用*x*[0] = 4。以下是这个LCG产生的序列：
- en: '![Image](../images/f0022-02.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0022-02.jpg)'
- en: The output might seem a bit random, but after *x*[5], the sequence begins to
    repeat. All pseudorandom generators repeat eventually. The number of outputs before
    repeating determines the generator’s *period*. Here the period is 6, with 4, 5,
    1, 3, 2, 6 repeating forever.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来有些随机，但在*x*[5]之后，序列开始重复。所有伪随机生成器最终都会重复。重复前的输出数量决定了生成器的*周期*。在这里，周期为6，4、5、1、3、2、6将永远重复。
- en: With properly chosen constants, the period can be much larger. For our experiments,
    we’ll use a set of constants popular in the 1980s, which came to be called the
    *MINSTD (minimum standard generator)*. It produces a sequence of unsigned integers
    with a period of 2^(31) ≈ 10⁹. That’s a reasonable period for many applications,
    but there’s more to a good generator than its period. The closer the pseudorandom
    generator is to a truly random sequence, the better. Statistical test suites like
    `ent`, or more professional ones, seek to uncover all manner of correlations in
    the sequence spit out by the generator. With those test suites, it quickly becomes
    evident that MINSTD is a poor generator for serious work, but sufficient for our
    purposes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果常数选择得当，周期可以大得多。在我们的实验中，我们将使用一组1980年代流行的常数，这些常数后来被称为*MINSTD（最小标准生成器）*。它生成一个无符号整数序列，周期为2^(31)
    ≈ 10⁹。对于许多应用来说，这是一个合理的周期，但一个好的生成器不仅仅看它的周期。伪随机生成器越接近真正的随机序列，就越好。像`ent`这样的统计测试套件，或者更专业的测试套件，旨在揭示生成器输出序列中的各种相关性。通过这些测试套件，很快就能发现MINSTD对于严肃工作来说是一个差劲的生成器，但对于我们的目的来说已经足够。
- en: 'I created a file of 100 million bytes using MINSTD and handed it to `ent`.
    I got the following results:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用MINSTD创建了一个100百万字节的文件，并将其交给了`ent`。我得到了以下结果：
- en: '[PRE14]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output is very reasonable, so MINSTD will likely be of use to us.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输出非常合理，因此MINSTD可能对我们有用。
- en: 'The generator uses *a* = 48,271, *c* = 0, and *m* = 2,147,483,647 to make the
    generating equation:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该生成器使用*a* = 48,271、*c* = 0和*m* = 2,147,483,647来构造生成方程：
- en: '*x*[*i* + 1] = 48271*x[i]* mod 2147483647'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*i* + 1] = 48271*x[i]* mod 2147483647'
- en: If you’re familiar with how computers store numbers internally, you’ll notice
    that *m* is not using all 32 bits of a 32-bit integer. Instead, *m* = 2^(31) –
    1 is the largest positive integer that can be stored in a *signed* 32-bit value.
    Because of the modulo operation, the output of the generator must be in the range
    [0, 2^(31) – 1), implying the generator can create at most only some 2 billion
    unique values.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉计算机如何内部存储数字，你会注意到 *m* 并没有使用 32 位整数的全部 32 位。相反，*m* = 2^(31) – 1 是可以存储在 *有符号*
    32 位值中的最大正整数。由于取模操作，生成器的输出必须在 [0, 2^(31) – 1) 的范围内，这意味着该生成器最多只能生成约 20 亿个唯一值。
- en: If we need to generate a sequence of bytes, [0, 255], then we’re good. But what
    if we want to create a sequence of 64-bit floating-point values, what the C language
    calls a `double`? In that case, we have to do more work. The simplest approach
    is to divide *x* by *m*, since that must produce a number in the range [0, 1).
    For many applications, that’s sufficient, but it still only delivers a value selected
    from a set of 2 billion or so numbers. You don’t need to know the details of this,
    but a 64-bit floating-point value can store more than that because it uses a 52-bit
    base-2 mantissa. If we want to make full use of what a 64-bit floating-point value
    can give us, we need to generate two outputs from MINSTD and assign 52 bits extracted
    from both of them to the mantissa of a floating-point value with an exponent of
    0\. Thankfully, we don’t need that much precision, but it’s worth noting that
    simply dividing by *m* isn’t giving you all that you might think it is.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要生成一个字节序列 [0, 255]，那就没问题。但如果我们想创建一个 64 位浮点值的序列，即 C 语言中的 `double` 类型呢？在这种情况下，我们需要做更多的工作。最简单的方法是将
    *x* 除以 *m*，因为那必须会产生一个在 [0, 1) 范围内的数字。对于许多应用来说，这已经足够了，但它仍然只能从大约 20 亿个数字中选择一个。你不需要知道这些细节，但一个
    64 位浮点值可以存储更多内容，因为它使用的是 52 位的二进制尾数。如果我们想充分利用 64 位浮点值能给我们的容量，就需要从 MINSTD 生成两个输出，并将从它们中提取的
    52 位赋值给浮点值的尾数，指数为 0。幸运的是，我们并不需要那么高的精度，但值得注意的是，简单地除以 *m* 并没有给你所有你可能想象中的内容。
- en: I previously mentioned that pseudorandom generators use seed values, a starting
    value. This requirement is a double-edged sword. Setting the seed to a specific
    number causes the generator to repeatedly output the same sequence of values,
    but the downside is that sometimes we might need to jump through hoops to make
    sure we aren’t using the same seed repeatedly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过伪随机生成器使用种子值，即起始值。这个要求是双刃剑。将种子设置为特定的数字会导致生成器重复输出相同的数值序列，但缺点是有时我们可能需要费些劲来确保不重复使用相同的种子。
- en: 'For example, MINSTD with a seed of *x* = 8,675,309 will produce this sequence
    each time:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用种子 *x* = 8,675,309 的 MINSTD 每次都会产生这个序列：
- en: 0.00304057,  0.77134655,  0.66908364,  0.33651287,  0.8128977, . . .
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 0.00304057,  0.77134655,  0.66908364,  0.33651287,  0.8128977, . . .
- en: 'Meanwhile, using a seed of *x* = 1,234 will consistently produce:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，使用 *x* = 1,234 作为种子将始终产生：
- en: 0.02773777,  0.93004224,  0.06911496,  0.24831591,  0.45733623, . . .
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 0.02773777,  0.93004224,  0.06911496,  0.24831591,  0.45733623, . . .
- en: The floating-point numbers are produced by dividing *x* by *m* = 2,147,483,647.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些浮点数是通过将 *x* 除以 *m* = 2,147,483,647 生成的。
- en: Often, we’ll use a pseudorandom generator, like those built into NumPy, without
    specifying a seed value. In that case, we want an unrepeatable sequence, at least
    unrepeatable for us, because we won’t know the seed selected. If no seed value
    is supplied, NumPy selects a value from `/dev/urandom`, a special system device
    discussed later in the chapter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会使用伪随机生成器，比如 NumPy 内置的那些，而不指定种子值。在这种情况下，我们希望得到一个不可重复的序列，至少对我们来说是不可重复的，因为我们无法知道选择了哪个种子。如果没有提供种子值，NumPy
    会从 `/dev/urandom` 中选择一个值，稍后在本章会讨论这个特殊的系统设备。
- en: 'The pseudorandom generator we’ll use most often is PCG64, the generator NumPy
    uses by default. It’s a good generator, with a period of 2^(128). NumPy’s old
    default generator was the Mersenne Twister. Statistically, it’s still quite good,
    much better than MINSTD. The Mersenne Twister’s period is 2^(19,937) – 1, which
    explains its more common name: MT19937\. To be precise, its period is a huge number,
    6,002 digits, and is utterly without meaning in human terms. PCG64’s period isn’t
    anything to scoff at either:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最常用的伪随机生成器是 PCG64，这是 NumPy 默认使用的生成器。它是一个优秀的生成器，周期为 2^(128)。NumPy 以前的默认生成器是梅森旋转算法（Mersenne
    Twister）。从统计上讲，它仍然非常好，远远优于 MINSTD。梅森旋转算法的周期为 2^(19,937) – 1，这也解释了它更常见的名字：MT19937。准确地说，它的周期是一个巨大的数字，达
    6002 位，并且对人类来说完全没有意义。PCG64 的周期也不容小觑：
- en: 2^(128) = 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 2^(128) = 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456
- en: That’s a number similarly without meaning in human terms. None of our experiments
    will come anywhere close to exhausting the sequence generated by either MT19937
    or PCG64, both of which we’ll use frequently throughout the book.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个在人的理解中没有意义的数字。我们任何实验都无法穷尽由 MT19937 或 PCG64 生成的序列，书中将频繁使用这两种序列。
- en: 'The output of these generators follows a uniform distribution. Any other distribution,
    like a normal distribution, can be formed from a collection of uniformly distributed
    numbers. For example, it is straightforward to generate normally distributed numbers
    via the Box-Muller transformation, which maps two uniformly distributed numbers,
    *u*[1] and *u*[2], to two normally distributed numbers:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成器的输出遵循均匀分布。任何其他分布，比如正态分布，都可以通过一组均匀分布的数字来生成。例如，通过 Box-Muller 变换，可以将两个均匀分布的数字
    *u*[1] 和 *u*[2] 转换为两个正态分布的数字：
- en: '![Image](../images/f0024-01.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0024-01.jpg)'
- en: There’s much more to say about pseudorandom generators; many computer scientists
    have spent their careers working with them. However, we now understand all we
    need for our purposes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 关于伪随机生成器，还有很多可以说的；许多计算机科学家一生致力于与之相关的研究。然而，我们现在已经了解了满足我们需求的所有内容。
- en: '***Quasirandom Sequences***'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***准随机序列***'
- en: For some experiments, we’ll want random data that is *space-filling*. By that
    I mean a generator producing a sequence that appears random but that will, over
    time, fill space more or less evenly. A purely random process offers us no such
    guarantee, but a quasirandom sequence does.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些实验，我们需要的随机数据是 *空间填充型* 的。我的意思是，一个生成器生成的序列看似随机，但随着时间推移，会较为均匀地填充空间。纯随机过程并不提供这种保证，但准随机序列则能做到这一点。
- en: The difference between a random or pseudorandom sequence and a quasirandom sequence
    is best understood via example. [Figure 1-4](ch01.xhtml#ch01fig04) compares two
    sequences of 40 points, one generated pseudorandomly and one generated quasirandomly.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 随机或伪随机序列与准随机序列之间的区别，最好通过实例来理解。[图 1-4](ch01.xhtml#ch01fig04)比较了两个包含 40 个点的序列，一个是伪随机生成的，另一个是准随机生成的。
- en: '![Image](../images/01fig04.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig04.jpg)'
- en: '*Figure 1-4: Two sets of 40 points, random (at 0.1) and quasirandom (at 0.2)*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-4：两组 40 个点，随机（在 0.1 处）和准随机（在 0.2 处）*'
- en: The lower sequence, at *y* = 0.1, was generated pseudorandomly. It covers the
    range from 0 to 1 (the *x*-axis), but does so with gaps. The second sequence,
    at *y* = 0.2, is a quasirandom sequence. It covers the same range, but is more
    consistent, with no crowding or gaps. Given enough samples, both sequences will
    eventually fill in the entire range, but the quasirandom sequence does so by scattering
    values more or less evenly throughout.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下方的序列，在 *y* = 0.1 时，是伪随机生成的。它覆盖了从 0 到 1 的范围（*x* 轴），但中间存在空隙。第二个序列，在 *y* = 0.2
    时，是准随机序列。它覆盖了相同的范围，但更为一致，没有拥挤或空隙。只要足够的样本，两个序列最终都会填满整个范围，但准随机序列通过更均匀地散布值来做到这一点。
- en: Our quasirandom process uses what is known as a *Halton sequence*. A Halton
    sequence is based on a prime number that divides the interval [0, 1) first by
    the base (the prime), then the base squared, then cubed, and so on. For a base
    of 2, the interval is first divided in half, then quarters, then eighths, and
    so on. This process will eventually cover the interval in the infinite limit and
    fills the interval approximately evenly. For example, [Table 1-6](ch01.xhtml#ch01tab06)
    shows the first few values of the Halton sequence for the given base (rounded
    to three digits).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的准随机过程使用了所谓的 *哈尔顿序列*。哈尔顿序列基于一个质数，首先按照基数（质数）划分区间 [0, 1)，然后是基数的平方，再是基数的立方，以此类推。对于基数为
    2，区间首先被分为两部分，然后是四分之一、八分之一，以此类推。这个过程最终将在无限极限中覆盖整个区间，并且大致均匀地填充该区间。例如，[表 1-6](ch01.xhtml#ch01tab06)展示了给定基数的哈尔顿序列的前几个值（四舍五入到三位数字）。
- en: '**Table 1-6:** Halton Sequences'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-6：** 哈尔顿序列'
- en: '| **Base** | **Sequence** |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **基数** | **序列** |'
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2 | `0, 0.5 ,  0.25 , 0.75 , 0.125, 0.625, 0.375, 0.875` |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `0, 0.5 ,  0.25 , 0.75 , 0.125, 0.625, 0.375, 0.875` |'
- en: '| 3 | `0, 0.333, 0.667, 0.111, 0.444, 0.778, 0.222, 0.556` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `0, 0.333, 0.667, 0.111, 0.444, 0.778, 0.222, 0.556` |'
- en: '| 5 | `0, 0.2 ,  0.4 ,  0.6 ,  0.8 ,  0.04 , 0.24 , 0.44` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `0, 0.2 ,  0.4 ,  0.6 ,  0.8 ,  0.04 , 0.24 , 0.44` |'
- en: Each sequence begins with 0 and is entirely deterministic, like a pseudorandom
    generator with a fixed seed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每个序列都从 0 开始，并且完全是确定性的，就像是带有固定种子的伪随机生成器。
- en: If the quasirandom sequence is so predictable, why is it useful? There are times
    when it is more important to fill space evenly than purely randomly. For example,
    some of our experiments will involve searching a multidimensional space to locate
    a point in that space that we consider best, for some definition of best. In that
    case, it often makes more sense to initialize the search so that the locations
    evaluated at first represent all of the space more or less equally.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果准随机序列如此可预测，为什么它还有用呢？有时，均匀填充空间比纯粹的随机填充更重要。例如，我们的一些实验涉及在多维空间中搜索，找到我们认为最佳的某个点，根据某种定义的“最佳”。在这种情况下，初始化搜索时，使得最初评估的位置大致均匀地代表整个空间往往更有意义。
- en: Quasirandom sequences are most useful in combination. [Figure 1-4](ch01.xhtml#ch01fig04)
    used a single quasirandom sequence with a base of 2 to fill in a one-dimensional
    space, the interval from 0 to 1\. What if, instead, we wanted to fill in a two-dimensional
    space, like the *xy*-plane? For that, we need pairs of numbers. The seemingly
    obvious thing to do is sample twice to use the first number as the *x*-coordinate
    and the second as the *y*-coordinate. Let’s see what happens when we apply this
    approach to pseudorandom and quasi-random numbers.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 准随机序列最有用的地方是组合使用。[图 1-4](ch01.xhtml#ch01fig04)使用了一个基数为2的单一准随机序列来填充一维空间，即从0到1的区间。如果我们想填充一个二维空间，比如*xy*平面呢？为此，我们需要一对数字。看似显而易见的做法是采样两次，将第一个数字作为*x*坐标，第二个数字作为*y*坐标。让我们看看当我们将这种方法应用于伪随机数和准随机数时会发生什么。
- en: '[Figure 1-5](ch01.xhtml#ch01fig05) attempts to fill 2D space with points.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-5](ch01.xhtml#ch01fig05)试图用点填充二维空间。'
- en: '![Image](../images/01fig05.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig05.jpg)'
- en: '*Figure 1-5: From left to right: examples of bad quasirandom, pseudorandom,
    and good quasirandom sequences*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-5：从左到右：坏的准随机数、伪随机数和好的准随机数序列的示例*'
- en: In the middle of [Figure 1-5](ch01.xhtml#ch01fig05), I plotted 500 pairs sampled
    from a pseudorandom generator. The points are randomly distributed in space, but
    there are regions with fewer points and regions with more points, as expected.
    Next, I repeated this exercise using a quasirandom sequence with base 2\. That
    is, I asked the sequence for two samples, one after the other, and plotted them
    as a point. The result is on the left in [Figure 1-5](ch01.xhtml#ch01fig05). Clearly,
    something strange is happening.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-5](ch01.xhtml#ch01fig05)的中间，我绘制了从伪随机生成器中采样的500对数据点。这些点在空间中是随机分布的，但有些区域的点较少，而有些区域的点较多，这是预期的。接下来，我用基数为2的准随机序列重复了这个实验。也就是说，我让序列连续采样两个值，并将它们绘制成一个点。结果如[图
    1-5](ch01.xhtml#ch01fig05)左侧所示。显然，出现了一些奇怪的情况。
- en: The plot isn’t a mistake; the quasirandom sequence is doing precisely what it’s
    supposed to do. We’ve defined a random process as one where knowledge of previous
    values is of no utility in predicting subsequent values. That’s what the pseudorandom
    generator supplied; therefore, we can use sequentially generated values as coordinates
    for a point in 2D space. However, the quasirandom sequence offers no assurance
    that previous values do not indicate what comes next. Instead, the sequence is
    entirely predictable. Pairs of samples will be in a simple relationship to each
    other, which is what we see on the left in [Figure 1-5](ch01.xhtml#ch01fig05).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图并不是一个错误；准随机序列正做着它应该做的事情。我们将随机过程定义为一种在已知前值的情况下，无法预测后续值的过程。这正是伪随机生成器所提供的；因此，我们可以使用按顺序生成的值作为二维空间中一个点的坐标。然而，准随机序列并不保证前面的值不能预测接下来会发生什么。相反，序列是完全可预测的。采样对之间会存在简单的关系，这正是我们在[图
    1-5](ch01.xhtml#ch01fig05)左侧看到的情况。
- en: This does not mean we cannot use quasirandom sequences beyond one-dimensional
    cases. The trick is to use a different base for each dimension. Here, we have
    two dimensions, so we need *two* quasirandom sequences, each with a different
    base. The plot on the right in [Figure 1-5](ch01.xhtml#ch01fig05) was generated
    this way. The *x*-coordinates are the first 500 samples from a quasirandom sequence
    with base 2, and the *y*-coordinates are the first 500 from a quasi-random sequence
    using base 3\. Recall that the base must be a prime number. Since the two quasirandom
    sequences are not using the same base, the values are not (simply) correlated,
    so the points fill in the 2D space. Likewise, as each sequence is filling in the
    interval from [0, 1), and we are plotting them in pairs, it makes intuitive sense
    that they will fill in the 2D space as well, which is what the plot shows.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们不能在一维情况之外使用准随机序列。诀窍是为每个维度使用不同的基数。在这里，我们有两个维度，因此需要*两个*准随机序列，每个序列使用不同的基数。[图1-5](ch01.xhtml#ch01fig05)右侧的图就是这样生成的。*x*坐标是使用基数2的准随机序列中的前500个样本，*y*坐标是使用基数3的准随机序列中的前500个样本。请记住，基数必须是质数。由于这两个准随机序列使用的基数不同，因此它们的值并不（简单地）相关，因此这些点填充了二维空间。同样，由于每个序列填充了区间[0,
    1)，而我们将它们成对绘制，直观上看它们也会填充二维空间，这就是图示所展示的内容。
- en: The moral of the story is that we can use quasirandom sequences, one base per
    dimension of the problem, to fill in some space in a way that seems random.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的寓意是，我们可以使用准随机序列，每个问题维度一个基数，按某种方式填充空间，这种方式看起来像是随机的。
- en: '***Combining Deterministic and Truly Random Processes***'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结合确定性和真正随机的过程***'
- en: Truly random processes are the gold standard, but they tend to be relatively
    slow, at least given how quickly a computer works. A pseudorandom generator is
    a good substitute, but it’s only a truly random process wannabe. Why not merge
    the two? This section will examine two approaches to combining truly random processes
    with pseudorandom generators. I call these *hybrid processes*. We’ll discuss `/dev/urandom`,
    the Linux operating system’s approach, and `RDRAND`, a CPU-based hybrid processor
    instruction supported by many newer Intel and AMD processors.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的随机过程是黄金标准，但它们通常相对较慢，至少考虑到计算机的工作速度。伪随机生成器是一个不错的替代品，但它只是一个真正随机过程的“追随者”。为什么不将两者结合起来呢？本节将探讨两种将真正的随机过程与伪随机生成器结合的方法。我称这些为*混合过程*。我们将讨论`/dev/urandom`，即Linux操作系统的方法，以及`RDRAND`，一种由许多新款Intel和AMD处理器支持的基于CPU的混合处理器指令。
- en: 'Both `/dev/urandom`, henceforth `urandom`, and `RDRAND` operate in the same
    way: they use a slow source of true randomness to reseed a cryptographically secure
    pseudorandom number generator. We learned earlier in the chapter that pseudorandom
    generators have seeds, something that sets the initial state of the generator.
    Set the seed the same way, and the sequence of values generated repeats. The hybrid
    approaches frequently reseed the generator with the intention of altering the
    sequence to the point where, even if an adversary were to figure out what the
    pseudorandom generator was doing, it wouldn’t matter in practice because the seed
    would be random, making any knowledge of the state of the generator useless after
    a short time interval.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/urandom`，以下简称`urandom`，和`RDRAND`的工作方式相同：它们使用一种缓慢的真正随机源来重新种子一个加密安全的伪随机数生成器。我们在本章前面学到，伪随机生成器有种子，种子设置了生成器的初始状态。以相同的方式设置种子，生成的值序列就会重复。混合方法通常会重新种子生成器，目的是改变序列，使得即便对手弄清楚伪随机生成器的工作方式，在实践中也无关紧要，因为种子是随机的，任何对生成器状态的了解在短时间后都将变得毫无用处。'
- en: 'I slipped a new phrase into the previous paragraph: *cryptographically secure*.
    Our experiments are not worried about adversaries and cryptography (well, mostly);
    we’re only concerned that the pseudorandom generator is “pretty good” in the sense
    that our experiments perform well using the generator.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上一段中插入了一个新短语：*加密安全*。我们的实验并不担心对手和加密技术（嗯，主要是）；我们关心的是伪随机数生成器在“相当不错”的意义上表现良好，换句话说，我们的实验使用该生成器时表现良好。
- en: 'A cryptographically secure pseudorandom generator is a high-quality pseudorandom
    generator with the following properties:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一个加密安全的伪随机生成器是一个高质量的伪随机生成器，具有以下特性：
- en: An attacker’s knowledge of the generator’s state at time *t[c]* offers no ability
    for the attacker to know anything about the state of the generator at any previous
    time *t* < *t[c]*.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者对生成器在时间 *t[c]* 时的状态的了解，并不能帮助攻击者知道在任何早于 *t[c]* 的时刻 *t* 时，生成器的状态。
- en: For any output bit *i*, there is no polynomial-time algorithm operating on all
    previously generated bits, 0, . . . , *i* – 1, that can predict *i* with better
    than 50 percent accuracy.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何输出位*i*，没有一个多项式时间的算法可以在所有先前生成的位0，...，*i*–1上操作，以比50%的准确度更好地预测*i*。
- en: The second property is known as the *next-bit* test. It’s what marks the cryptographically
    secure generator as a high-quality generator.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个特性被称为*下一位*测试。它标志着加密安全生成器作为高质量生成器的标准。
- en: The phrase *polynomial-time algorithm* comes from the study of algorithms and
    how they perform regarding time and space. Polynomial-time algorithms are the
    nice ones; they are the algorithms that might finish sometime before the heat
    death of the universe. The classic bubble sort algorithm is a polynomial-time
    algorithm because its runtime scales as the square of the number of elements to
    sort; that is, sorting *n* elements takes time on the order of *n*², a polynomial.
    Any algorithm whose time or space resources are bounded by a polynomial is also
    a polynomial-time algorithm. For example, the Quicksort algorithm scales as *n*
    log *n* for *n* items. That’s a function easily bounded by a polynomial, like
    *n*², so Quicksort is also a polynomial-time algorithm. An algorithm that scales
    as 2*^n* is not a polynomial-time algorithm because 2*^n* is an exponential, not
    a polynomial. Exponential algorithms are bad because they quickly become intractable,
    which is precisely what people concerned about attacks on their pseudorandom number
    generators want.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 短语*多项式时间算法*来自于对算法的研究，特别是它们在时间和空间方面的表现。多项式时间算法是好的算法，它们可能在宇宙热寂之前某个时候完成。经典的冒泡排序算法就是一个多项式时间算法，因为它的运行时间与需要排序的元素数量的平方成正比；也就是说，排序*n*个元素的时间大约是*n*²的量级，这是一个多项式。任何时间或空间资源由多项式限制的算法也是多项式时间算法。例如，快速排序算法在*n*个元素时的时间复杂度是*n*
    log *n*。这是一个容易被多项式如*n*²所界定的函数，因此快速排序也是多项式时间算法。任何按2*^n*增长的算法都不是多项式时间算法，因为2*^n*是指数级的，而不是多项式的。指数级算法是糟糕的，因为它们很快变得不可处理，这正是那些关注伪随机数生成器攻击的人所希望避免的。
- en: Algorithmically, a hybrid process uses a strong pseudorandom generator to deliver
    random values on demand while periodically reseeding said generator from a truly
    random source. Let’s explore the `urandom` and `RDRAND` approaches to this problem.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从算法的角度来看，混合过程使用强伪随机生成器按需提供随机值，同时定期从真正的随机源重新播种该生成器。让我们探讨`urandom`和`RDRAND`对这个问题的解决方法。
- en: '**Reading Random Bytes from urandom**'
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从 urandom 读取随机字节**'
- en: 'Unix systems treat many things that are not files as if they were files, and
    `urandom` is no exception. To acquire random bytes from `urandom`, we need to
    treat it like a file. For example, let’s run Python, open `urandom`, and dump
    60 million bytes from it to a disk file so `ent` can evaluate them:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 系统将许多非文件的事物视为文件，`urandom`也不例外。为了从`urandom`获取随机字节，我们需要将其视为文件。例如，让我们运行 Python，打开`urandom`，并将其60百万字节写入磁盘文件，以便`ent`进行评估：
- en: '[PRE15]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output file is *ttt.bin*, a throwaway name. When I ran the code, `ent`
    reported the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件是*ttt.bin*，这是一个临时的名字。当我运行代码时，`ent`报告了以下内容：
- en: '[PRE16]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As expected, `urandom` performs well and will work for our purposes as a randomness
    engine.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`urandom`表现良好，并且可以作为我们的随机性引擎来使用。
- en: The Linux kernel maintains an *entropy pool*, a collection of bytes derived
    from system operations that it uses to update the seed of the pseudorandom generator
    every 300 seconds, according to kernel file *random.c*, which is available at
    *[https://github.com/torvalds/linux/blob/master/drivers/char/random.c](https://github.com/torvalds/linux/blob/master/drivers/char/random.c)*.
    The same file also reveals the kernel’s entropy sources, if curiosity strikes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核维护一个*熵池*，这是一个从系统操作中派生的字节集合，内核每300秒用它来更新伪随机生成器的种子，具体信息可以在内核文件*random.c*中找到，该文件可在*[https://github.com/torvalds/linux/blob/master/drivers/char/random.c](https://github.com/torvalds/linux/blob/master/drivers/char/random.c)*查看。如果有好奇心，文件中也暴露了内核的熵源。
- en: 'We can monitor the size of the entropy pool by reading the contents of the
    file *entropy_avail*:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过读取文件*entropy_avail*的内容来监视熵池的大小：
- en: '[PRE17]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, we’re told that at the particular moment I executed the command,
    there were 3,693 bytes in the entropy pool, meaning that 3,693 bytes were available
    to reseed the generator when the reseed interval expired.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们得知在我执行命令的那一刻，熵池中有3,693字节，意味着当重新种子间隔到期时，3,693字节可以用来重新种子生成器。
- en: Linux uses the ChaCha20 pseudorandom number generator. It’s a reasonably new
    generator that performs exceptionally well overall, even when subjected to more
    intensive test suites. The details don’t concern us here, only that `urandom`
    delivers the goods.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Linux使用ChaCha20伪随机数生成器。这是一个相对较新的生成器，整体性能非常出色，即使在更高强度的测试套件下也能表现良好。这里的细节我们不关心，只关心`urandom`能提供结果。
- en: '**NOTE**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you spend much time reviewing resources related to* /dev/urandom, *you’ll
    run across its cousin,* /dev/random*. The latter device was intended for small
    amounts of high-quality random data, and it will block until enough entropy is
    available. This is contrary to our requirements, so we’re ignoring* /dev/random
    *entirely. Indeed, it was announced in March 2022 that future versions of the
    Linux kernel will make* /dev/random *nothing more than another name for* /dev/urandom.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你花费大量时间审阅与* /dev/urandom *相关的资源，你会遇到它的“亲戚”，* /dev/random*。后者设备是为了少量高质量的随机数据而设计的，它会阻塞直到足够的熵可用。这与我们的需求相悖，因此我们完全忽略了*
    /dev/random*。事实上，2022年3月宣布，未来版本的Linux内核将把* /dev/random*变成* /dev/urandom*的别名。'
- en: '**Using the RDRAND Instruction**'
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用RDRAND指令**'
- en: The RDRAND instruction, if available for your CPU, provides access to high-quality
    random numbers using much the same approach as the Linux kernel and `urandom`.
    The key differences are that the entropy source is part and parcel of the CPU
    itself and the pseudorandom generator is updated at an interval no longer than
    after returning 1,022 random values. That is, `RDRAND` is reseeded based on the
    number of samples returned, not on a fixed time interval like `urandom`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的CPU支持，RDRAND指令可以提供高质量的随机数，采用与Linux内核和`urandom`类似的方法。主要的区别在于，熵源是CPU本身的一部分，且伪随机生成器会在返回1,022个随机值之后更新，即`RDRAND`是基于返回样本的数量重新种子的，而不是像`urandom`那样基于固定的时间间隔。
- en: The pseudorandom number generator used is not ChaCha20 but CTR_DRBG, a generator
    developed by the National Institute of Standards and Technology (NIST), part of
    the United States Department of Commerce. The close association between NIST and
    the US government has caused some to distrust `RDRAND`’s output, but as we are
    not concerned with cryptographic security, `RDRAND` is fair game.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的伪随机数生成器不是ChaCha20，而是CTR_DRBG，这是一种由美国国家标准与技术研究院（NIST）开发的生成器，NIST隶属于美国商务部。NIST与美国政府的紧密关系导致一些人对`RDRAND`的输出产生不信任，但由于我们不关心加密安全问题，`RDRAND`是可以使用的。
- en: 'Unlike `urandom`, which is accessed as if it were a binary file and therefore
    available immediately to all programming languages, `RDRAND` is a CPU instruction,
    so we need to access it via lower-level code or by installing a Python library
    that uses the instruction for us. As it happens, the `rdrand` library will do
    nicely:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 与`urandom`不同，`urandom`作为二进制文件可立即被所有编程语言访问，而`RDRAND`是一个CPU指令，因此我们需要通过底层代码或安装一个使用该指令的Python库来访问它。实际上，`rdrand`库非常适合：
- en: '[PRE18]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The class `RdRandom` returns an interface to `RDRAND` and supports the `random`
    method to return a random float. Alternatively, the `rdrand_get_bytes` function
    returns the requested number of random bytes, here 60 million, so we can compare
    `ent`’s report with the output of `urandom`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`RdRandom`类提供了一个接口来访问`RDRAND`，并支持`random`方法来返回一个随机浮动值。或者，`rdrand_get_bytes`函数返回请求的随机字节数，这里是6000万字节，供我们将`ent`的报告与`urandom`的输出进行比较。'
- en: 'Passing the bytes in *ttt.bin* to `ent` gives us the following results:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 将*ttt.bin*中的字节传递给`ent`，我们得到以下结果：
- en: '[PRE19]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For our purposes, these results are indistinguishable from those of `urandom`;
    therefore, we’ll rely on `RDRAND` from time to time as well.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们的目的而言，这些结果与`urandom`的结果没有区别；因此，我们也将不时依赖`RDRAND`。
- en: If you’re looking to access `RDRAND` from C, the code in *drng.c* will serve
    as a guide. Note the `gcc` compile instructions at the top of the file.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在C语言中访问`RDRAND`，*drng.c*中的代码可以作为指南。请注意文件顶部的`gcc`编译指令。
- en: In the next section, I’ll detail the `RE` class, a Python wrapper for different
    randomness sources, and the randomness engine we’ll use consistently for all the
    book’s experiments.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将详细介绍 `RE` 类，这是一个为不同随机源提供封装的 Python 类，也是我们将为所有书中的实验一致使用的随机引擎。
- en: '**NOTE**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For other ways to generate pseudorandom numbers, see my book* Random Numbers
    and Computers *(Springer, 2018). It includes a thorough treatment of all things
    related to pseudorandom number generation, including code for specific algorithms.*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关生成伪随机数的其他方法，请参见我的书籍* 《随机数与计算机》 *(Springer, 2018)。它包括了对伪随机数生成相关内容的全面讨论，包括特定算法的代码。*'
- en: '**The Book’s Randomness Engine**'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**本书的随机引擎**'
- en: In this section, we build the `RE` class, the randomness engine that will power
    most of our experiments throughout the remainder of the book. If you’d prefer
    to jump right in, read through *RE.py*, and then come back here to fill in any
    details you missed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建 `RE` 类，这是一个随机引擎，将支持本书后续的大部分实验。如果你更喜欢直接进入实践，可以先阅读 *RE.py*，然后回来补充遗漏的细节。
- en: 'We want to design a class that will accomplish the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望设计一个类，完成以下功能：
- en: Provide a vector of a specified number of uniform random samples
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供指定数量的均匀随机样本向量
- en: Generate pseudorandom output using PCG64, MT19937, or MINSTD
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PCG64、MT19937 或 MINSTD 生成伪随机输出
- en: Generate hybrid random output using `urandom` or `RDRAND`
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `urandom` 或 `RDRAND` 生成混合随机输出
- en: Generate quasirandom output for any specified prime base
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为任何指定的素数基生成准随机输出
- en: Produce floats or integers in any range, [*a*, *b*)
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任意范围内生成浮动数或整数，[*a*, *b*)
- en: Produce bytes ([0, 255]) or bits ([0, 1])
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成字节（[0, 255]）或比特（[0, 1]）
- en: Allow a seed value to generate the same output repeatedly
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许使用种子值重复生成相同的输出
- en: Substitute a file of bytes as the randomness source
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个字节文件作为随机源
- en: Let’s review `RE`’s source code before taking it for a brief test drive.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `RE` 类进行简短的测试之前，让我们先回顾一下它的源代码。
- en: '***The RE Class***'
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RE 类***'
- en: 'The `RE` class is configured via its constructor and provides only one method
    meant for public use: `random`. This method takes a single argument, an integer
    specifying the number of samples to return as a NumPy vector.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`RE` 类通过其构造函数进行配置，并且只提供一个公共方法：`random`。该方法接受一个单一参数，一个整数，指定要返回的样本数量，并作为 NumPy
    向量返回。'
- en: The `RE` class’s private methods implement the possible randomness sources,
    shown in [Table 1-7](ch01.xhtml#ch01tab07).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`RE` 类的私有方法实现了可能的随机源，如 [表 1-7](ch01.xhtml#ch01tab07) 所示。'
- en: '**Table 1-7:** `RE`’s Methods'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-7：** `RE` 的方法'
- en: '| **Method** | **Description** |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Fetch` | Sample from a disk file |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `Fetch` | 从磁盘文件中取样 |'
- en: '| `MINSTD` | Sample from MINSTD |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `MINSTD` | 从 MINSTD 中取样 |'
- en: '| `Urandom` | Read from `/dev/urandom` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `Urandom` | 从 `/dev/urandom` 读取 |'
- en: '| `RDRAND` | Read from `RDRAND` |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `RDRAND` | 从 `RDRAND` 读取 |'
- en: '| `Quasirandom` | Sample from the Halton sequence |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `Quasirandom` | 从 Halton 序列中取样 |'
- en: '| `NumPyGen` | Sample from PCG64 or MT19937 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `NumPyGen` | 从 PCG64 或 MT19937 取样 |'
- en: Each private method accepts a single argument, the number of samples to return.
    Also, aside from `Fetch`, each private method returns a floating-point vector
    of samples in the range [0, 1).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 每个私有方法接受一个单一参数，即要返回的样本数量。此外，除了 `Fetch`，每个私有方法返回一个浮动点向量，样本范围为 [0, 1)。
- en: '**NumPyGen and MINSTD**'
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**NumPyGen 和 MINSTD**'
- en: 'Let’s look first at `NumPyGen` and `MINSTD`, as they are straightforward. To
    save space, I’ve removed comments and doc strings. They are present in *RE.py*:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下 `NumPyGen` 和 `MINSTD`，因为它们比较简单。为了节省空间，我删除了注释和文档字符串。它们存在于 *RE.py* 中：
- en: '[PRE20]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s begin with `NumPyGen`, as it’s about as simple as you can get. The `RE`
    class constructor, which we’ll discuss later, creates a NumPy generator, if that’s
    the source desired, and stores it in the `g` member variable. Don’t give me that
    look; we’re experimenting, and `g` is a perfectly good variable name.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `NumPyGen` 开始，因为它是最简单的。`RE` 类的构造函数（稍后我们会讨论）会创建一个 NumPy 生成器，如果这是所需的随机源，并将其存储在
    `g` 成员变量中。别用那种眼神看我；我们是在做实验，`g` 是一个完全合适的变量名。
- en: NumPy already knows how to return vectors of floating-point numbers, so all
    that remains is to tell NumPy we want `N` of them, which we immediately return
    to the caller, `random`, which we’ll also discuss later on.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 已经知道如何返回浮动数向量，所以剩下的就是告诉 NumPy 我们想要 `N` 个，然后立即将其返回给调用者 `random`，我们稍后也会讨论这个。
- en: Similarly, `MINSTD`’s job is also to return a vector of floating-point samples.
    We first create a vector to hold the samples and then loop, applying the LCG equation
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`MINSTD` 的任务也是返回一组浮点数样本。我们首先创建一个向量来存储样本，然后循环应用 LCG 方程。
- en: '*x*[*i*+1] = (*ax[i]*) mod *m*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*i*+1] = (*ax[i]*) mod *m*'
- en: with *a* = 48,271 and *m* = 2^(31) – 1 = 2,147,483,647\. To convert *x*[*i*+1]
    to a float in [0, 1), we divide by *m* or, as here, multiply by 1/*m*.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a* = 48,271，*m* = 2^(31) – 1 = 2,147,483,647。为了将 *x*[*i*+1] 转换为 [0, 1) 范围内的浮点数，我们将其除以
    *m*，或者像这里一样，乘以 1/*m*。
- en: There are a few things to notice. First, the `seed` member variable *is x* if
    the MINSTD generator is selected. That’s why it’s updated. Second, the MINSTD
    equation is iterative; to get *x*[*i*+1] we need *x[i]* as pseudorandom values
    must be generated sequentially (usually). In practice, this means that our implementation
    of MINSTD is a bit slow, but that’s fine for our experiments.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个值得注意的地方。首先，如果选择了 MINSTD 生成器，则 `seed` 成员变量 *就是 x*。这就是为什么它会被更新。其次，MINSTD 方程是迭代的；为了得到
    *x*[*i*+1]，我们需要 *x[i]*，因为伪随机值通常需要顺序生成。在实践中，这意味着我们实现的 MINSTD 稍微有点慢，但对于我们的实验来说是可以接受的。
- en: Remember that MINSTD deals with 32-bit integers, meaning floating-point numbers
    returned by `MINSTD` are only as precise as 32-bit floats. If you know C, this
    means it returns `float`, not `double`. A Python `float` is a C `double`, and
    likewise uses 64 bits (52 for the mantissa or significand). For most of what we
    do in this book, the loss of precision isn’t important, but you should be aware
    of it if you wish to use `RE` in your projects.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，MINSTD 使用的是 32 位整数，这意味着 `MINSTD` 返回的浮点数精度仅为 32 位浮点数。如果你了解 C 语言，这意味着它返回的是
    `float` 类型，而不是 `double`。Python 中的 `float` 对应 C 语言中的 `double`，并且也使用 64 位（其中 52
    位用于尾数或有效数字）。对于本书中的大部分内容，精度损失并不重要，但如果你希望在项目中使用 `RE`，应当注意这一点。
- en: '**RDRAND**'
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**RDRAND**'
- en: The `RDRAND` method needs to use the CPU’s RDRAND instruction, which it does
    via the `rdrand` module. When the `RE` class is imported, Python tries to load
    `rdrand` (see the top of *RE.py*). If present, the `RDRAND` method uses the library
    to access samples. If the library isn’t present, `RDRAND` still works but falls
    back to NumPy’s PCG64 generator and issues a suitable warning message.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`RDRAND` 方法需要使用 CPU 的 RDRAND 指令，它通过 `rdrand` 模块来实现。当导入 `RE` 类时，Python 会尝试加载
    `rdrand`（见 *RE.py* 顶部）。如果存在，`RDRAND` 方法将使用该库访问样本。如果库不存在，`RDRAND` 仍然有效，但会回退到 NumPy
    的 PCG64 生成器并发出相应的警告信息。'
- en: 'Let’s look at `RDRAND`, ignoring the part where `rdrand` isn’t available:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `RDRAND`，忽略 `rdrand` 不可用的部分：
- en: '[PRE21]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `rdrand` module supports a handful of methods, but we’re restricting ourselves
    to `random`, which returns a single float in [0, 1), using all 52 bits of the
    mantissa. However, as `random` is returning a single number, we need a loop, so
    `RDRAND` isn’t particularly fast. If you want bytes from `rdrand`, you’ll be better
    served by using the module’s `rdrand_get_bytes` function directly.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`rdrand` 模块支持多个方法，但我们仅使用 `random`，它返回一个位于 [0, 1) 范围内的单一浮点数，使用了所有 52 位尾数。然而，由于
    `random` 返回的是一个单一数字，我们需要一个循环，因此 `RDRAND` 并不是特别快速。如果你想要从 `rdrand` 获取字节，直接使用模块的
    `rdrand_get_bytes` 函数会更高效。'
- en: '**Urandom**'
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Urandom**'
- en: 'The `RE` class uses `/dev/urandom` as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`RE` 类使用 `/dev/urandom` 如下：'
- en: '[PRE22]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code first reads four times as many bytes as requested into a Python byte
    array. Then, it tells NumPy to treat the byte array as a buffer and read 32-bit
    unsigned integers from it. The resulting array is divided by 2^(32) to change
    it into a vector in [0, 1). Like `MINSTD`, we’re treating `urandom` as a source
    of 32-bit floats.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先将请求的字节数的四倍读取到一个 Python 字节数组中。然后，它告诉 NumPy 将字节数组视为缓冲区并从中读取 32 位无符号整数。得到的数组被除以
    2^(32) 转换为 [0, 1) 范围内的向量。像 `MINSTD` 一样，我们将 `urandom` 视为 32 位浮点数源。
- en: '**Quasirandom**'
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**准随机**'
- en: 'Quasirandom numbers are a bit different, as we saw earlier in the chapter,
    but the implementation is similar to the other sources:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 准随机数有些不同，正如我们在本章前面所见，但其实现与其他来源类似：
- en: '[PRE23]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output vector (`v`) is constructed sample by sample. The `while` loop calls
    `Halton`, a function contained within `Quasirandom`. This function returns a specific
    number in the Halton sequence for the given prime base. The next number to use
    is in member variable `qnum`. We’ll return to `qnum` later when discussing the
    `RE` constructor.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 输出向量（`v`）是逐个样本构建的。`while` 循环调用 `Halton`，这是一个包含在 `Quasirandom` 中的函数。该函数根据给定的素数基返回
    Halton 序列中的特定数字。下一个要使用的数字存储在成员变量 `qnum` 中。我们稍后会在讨论 `RE` 构造函数时回到 `qnum`。
- en: '**Random**'
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**随机**'
- en: 'The `RE` class’s only public method is `random`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`RE` 类的唯一公共方法是 `random`：'
- en: '[PRE24]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we’re not using a disk file, then the process is the same, regardless of
    the randomness source: first, generate the requested number of floating-point
    samples in [0, 1), and then modify them to be in the desired range and of the
    desired type.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用磁盘文件，那么过程是一样的，不管随机源是什么：首先，生成请求的浮点样本数量，范围在[0, 1)之间，然后将它们修改为所需的范围和类型。
- en: As all randomness sources accept the same argument and return the same [0, 1)
    vector, we store references to the particular methods in the dictionary `generators`.
    Then, to get `v`, we need only call the appropriate method indexing by `kind`
    and passing the number of samples (`N`), which defaults to 1.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有随机源都接受相同的参数并返回相同的[0, 1)向量，我们将特定方法的引用存储在字典`generators`中。然后，为了获得`v`，我们只需要根据`kind`调用相应的方法，并传入样本数（默认为1）。
- en: With `v` in hand, we modify it according to the selected configuration. If we
    want floating-point, we multiply by `high` and add `low`, which default to 1 and
    0, respectively. This returns a float in the range [low, high).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到`v`之后，我们根据选定的配置进行修改。如果我们需要浮点数，则将其乘以`high`并加上`low`，默认值分别为1和0。这会返回一个范围在[low,
    high)之间的浮点数。
- en: For integers, we first map `v` to [0, high) before adding `low` to give an integer
    in the range [low, high). The upper limit is not present in both cases, thereby
    following Python convention.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数，我们首先将`v`映射到[0, high)之间，然后加上`low`，得到一个范围在[low, high)之间的整数。在这两种情况下，上限都不包括在内，符合Python惯例。
- en: To get bytes, multiply by 256 and round. Finally, to get bits, round `v`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 获取字节时，先将其乘以256并四舍五入。最后，获取比特时，将`v`四舍五入。
- en: '**Fetch**'
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Fetch**'
- en: 'What about `Fetch`, you ask? It’s a mix of `Urandom` and `random`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你问`Fetch`怎么办？它是`Urandom`和`random`的混合：
- en: '[PRE25]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code is split into three paragraphs. The first calculates the number of
    bytes to read from the disk file (`nbytes`). As with `Urandom`, we’re restricting
    ourselves to 32-bit floats.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分为三个段落。第一段计算从磁盘文件中读取的字节数（`nbytes`）。与`Urandom`一样，我们将自己限制为32位浮点数。
- en: The second paragraph reads the bytes from disk and stores them in `b`. If we
    run out of file, we start again from the beginning. Remember this to ensure you
    don’t ask for far more samples than the file can supply. Think of the size of
    the file divided by four as the period of the generator.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 第二段从磁盘读取字节并将其存储在`b`中。如果文件读取完毕，我们将从头开始。记住这一点，以确保你不会请求文件无法提供的过多样本。可以将文件大小除以四视为生成器的周期。
- en: The third paragraph massages the data accordingly. If we want bytes, we’re done;
    we simply convert the list `b` into a NumPy vector and return it. Otherwise, we
    first treat the bytes as a buffer and read them as unsigned 32-bit integers, which
    we divide by 2^(32) to make `v` in the range [0, 1). We then convert the data
    to the final output format as in the `random` method. There is some code duplicated
    between `random` and `Fetch`, but pedagogically, the clarity this provides is
    worth it.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 第三段根据需要处理数据。如果我们需要字节，则直接完成；我们只需将列表`b`转换为NumPy向量并返回。如果不是字节，我们首先将字节作为缓冲区处理，并将其读取为无符号32位整数，然后将其除以2^(32)，使得`v`的范围在[0,
    1)之间。然后，我们将数据转换为与`random`方法相同的最终输出格式。`random`和`Fetch`之间有一些重复代码，但从教学角度来看，这种清晰性是值得的。
- en: '**The Constructor**'
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构造函数**'
- en: 'The `RE` class constructor configures the randomness engine. The first part
    defines defaults and builds the dictionary of private methods:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`RE`类的构造函数配置随机引擎。第一部分定义默认值并构建私有方法字典：'
- en: '[PRE26]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `mode` defines what `RE` returns. It’s a string: `float`, `int`, `byte`,
    or `bit`. Use `kind` to define the source. Possible values are the keys of `generators`
    or a pathname to a disk file. Case matters here.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode`定义了`RE`返回的内容。它是一个字符串：`float`、`int`、`byte`或`bit`。使用`kind`来定义源。可能的值是`generators`的键或磁盘文件的路径名。这里区分大小写。'
- en: Use `low` and `high` to set the output range, ignored for bytes and bits. Remember,
    the output does not include `high`. To get deterministic sequences, set the `seed`.
    Finally, use `base` if working with a quasirandom sequence.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`low`和`high`来设置输出范围，字节和比特不受影响。请记住，输出不包括`high`。要获得确定性的序列，请设置`seed`。最后，如果处理的是拟随机序列，使用`base`。
- en: 'The second part handles source-specific things:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分处理源特定的内容：
- en: '[PRE27]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I leave parsing the second part to you. I’ll just point out that for quasi-random
    sequences, the seed value is used to set the initial Halton sequence value, which
    is random if a negative seed is given. Use a negative seed to spice up the deterministic
    Halton sequence with a bit of randomness.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 解析第二部分留给你自己。我只想指出，对于准随机序列，种子值用于设置初始的Halton序列值，如果给定负种子，则该值是随机的。使用负种子为确定性的Halton序列添加一些随机性。
- en: With that, we’re finished with the implementation of `RE`. Now let’s learn how
    to use it.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经完成了`RE`的实现。现在，让我们学习如何使用它。
- en: '***RE Class Examples***'
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RE 类示例***'
- en: The following examples illustrate how we’ll use the `RE` class.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何使用`RE`类。
- en: 'The first example imports `RE` and defines a generator using all the defaults—PCG64
    with floating-point output in [0, 1):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例导入了`RE`，并使用所有默认设置定义了一个生成器——PCG64，返回[0, 1)区间内的浮动值：
- en: '[PRE28]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second example creates an instance of the MT19937 generator and uses it
    to return five floating-point values in [–3, 5):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例创建了一个MT19937生成器的实例，并使用它返回五个位于[–3, 5)区间内的浮动值：
- en: '[PRE29]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we use `urandom` to return integers in [–3, 5) and use `RDRAND` to sample
    bytes:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`urandom`返回[–3, 5)区间内的整数，并使用`RDRAND`进行字节采样：
- en: '[PRE30]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here’s an example that specifies a seed value to return the same sequence each
    time:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，指定了一个种子值，以便每次返回相同的序列：
- en: '[PRE31]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For a quasirandom sequence, if no seed is given, the sequence begins at zero
    each time. If the seed is less than zero, the starting position is set randomly:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个准随机序列，如果没有提供种子，则每次序列都从零开始。如果种子小于零，则起始位置随机设置：
- en: '[PRE32]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This example sets `kind` to a filename to sample from a disk file, here called
    *hotbits.bin*:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将`kind`设置为文件名，从磁盘文件（这里是*hotbits.bin*）进行采样：
- en: '[PRE33]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now that we know how to use `RE`, let’s start experimenting.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何使用`RE`，让我们开始实验吧。
- en: '### **Summary**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '### **总结**'
- en: This chapter focused on generating randomness, that is, on random processes.
    First, we explored the relationship between probability and randomness and learned
    that random processes sample from probability distributions, either continuous
    or discrete. We learned that there is generally no concrete answer to the question,
    How do we know if the output of a process is random? However, there are ways to
    test sequences to enhance our belief one way or the other. In practice, we declared
    the output of `ent` as our standard, since our experiments do not need state-of-the-art
    random processes.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了生成随机性的过程，即随机过程。首先，我们探讨了概率与随机性之间的关系，并了解到随机过程是从概率分布中抽样的，这些分布可以是连续的或离散的。我们了解到，通常没有具体的答案来回答“我们如何知道一个过程的输出是否是随机的？”然而，确实有一些方法可以测试序列，以增强我们对输出是随机的或非随机的信心。实际上，我们将`ent`的输出声明为标准，因为我们的实验不需要最先进的随机过程。
- en: Next, we discussed truly random processes. We began with classical approaches
    like coin flips and dice rolls, and then shifted our attention to physical processes
    such as random fluctuations in an analog signal, radio frequency noise due to
    atmospheric effects, and the decay of radioactive elements.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了真正的随机过程。我们从经典方法开始，比如抛硬币和掷骰子，然后将注意力转向物理过程，如模拟信号中的随机波动、大气效应引起的无线电频率噪声，以及放射性元素的衰变。
- en: Pseudorandom and quasirandom sequences are random process mimics. Though they
    pretend to be the output of truly random processes, they are not. However, they
    do shadow truly random processes with sufficient fidelity to make them the primary
    drivers for our experiments. After learning the basics of pseudorandom and quasirandom
    generators, we covered hybrid generators, the marriage of pseudorandomness and
    truly random processes. Hybrid generators provide cryptographically secure sequences.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机和准随机序列是随机过程的模拟。尽管它们假装是来自真正随机过程的输出，但它们并非如此。然而，它们确实以足够的精确度模拟真正的随机过程，使得它们成为我们实验的主要驱动因素。在学习了伪随机和准随机生成器的基础之后，我们讨论了混合生成器——伪随机性和真正随机过程的结合。混合生成器提供加密安全的序列。
- en: The chapter concluded with a walkthrough of the design and code for the `RE`
    class, the randomness engine that will power all of our experiments.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后，展示了`RE`类的设计和代码，这个随机性引擎将驱动我们所有的实验。
