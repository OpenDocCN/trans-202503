- en: '**1**'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '**1**'
- en: '**What Computers Think About Numbers**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**计算机如何看待数字**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: To do math, a computer needs a way of representing numbers. As it turns out,
    computers think about numbers pretty differently than humans do.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行数学运算，计算机需要一种表示数字的方式。事实证明，计算机处理数字的方式与人类有很大不同。
- en: For example, we like to think we can keep counting to higher and higher numbers
    forever, but computers have a limited amount of storage space. If they start counting,
    they eventually run out of room. There is no biggest number, but there *is* a
    biggest number your computer can represent in Scratch.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们喜欢认为我们可以一直数下去，数到越来越大的数字，但计算机有有限的存储空间。如果它们开始计数，最终会用完空间。没有最大的数字，但在Scratch中，*确实*有一个计算机能够表示的最大数字。
- en: Similarly, we think about fractions and decimal numbers as matching up with
    points on a number line, with an infinite number of points fitting between any
    two whole numbers. But as we pack points more and more tightly together in the
    finite world of computers, eventually we run out of room to keep track of them.
    There is no smallest positive number, but there *is* a smallest positive number
    your computer can work with in Scratch.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们将分数和小数看作与数轴上的点相对应，任意两个整数之间都有无限多个点。然而，随着我们将这些点在计算机有限的世界中越来越紧密地压缩，最终会没有足够的空间来记录它们。没有最小的正数，但*确实*有一个计算机能够在Scratch中使用的最小正数。
- en: In this chapter, we’ll look at what’s going on behind your computer screen and
    how computers think about numbers. We’ll explore the limitations of what numbers
    Scratch can represent. It’s important to understand these limits so we can be
    sure the results we get from a program are accurate. You’ll also learn some hacks
    for getting around Scratch’s limits and tricking the computer into representing
    more numbers than would normally be possible.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨计算机屏幕后发生的事情，以及计算机如何看待数字。我们将深入了解Scratch能够表示的数字的限制。理解这些限制非常重要，这样我们才能确保程序的结果是准确的。你还将学习一些绕过Scratch限制的小技巧，并欺骗计算机以表示比正常情况下更多的数字。
- en: What Are Numbers, Anyway?
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字究竟是什么？
- en: 'Everybody *thinks* they know what numbers are, but there are many number systems
    to choose from, depending on what we want the numbers to do. We usually learn
    to count with numbers starting from 1, so we call those numbers *counting numbers*.
    Sometimes we want to start counting from 0, in which case the numbers are called
    *whole numbers*. When we go forward and backward, allowing negative numbers too,
    we generate the set of *integers*: { . . . , –3, –2, –1, 0, 1, 2, 3, . . . }.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都*认为*他们知道什么是数字，但实际上有许多不同的数字系统可供选择，取决于我们希望数字做什么。我们通常从1开始学习计数，这些数字被称为*计数数字*。有时我们希望从0开始计数，这时这些数字就叫做*整数*。当我们可以前进或后退，允许负数时，就生成了*整数集*：{
    . . . , –3, –2, –1, 0, 1, 2, 3, . . . }。
- en: We can make an association with geometry and think of numbers as corresponding
    to points on a line, building the set of *real numbers*. We can also divide integers
    by other (nonzero) integers to make *rational numbers*. Here we use *rational*
    not to mean logical and making sense, but because the numbers are built from *ratios*.
    Sometimes rational numbers are called *fractions*, but this can be misleading.
    In common language, a *fraction* of something is only a portion of it, suggesting
    a part less than 1, whereas rational numbers like 3/2 and 4/3 can be bigger than
    1\. Also, fractions are usually thought of with a denominator of 2 or more (halves,
    thirds, and so on), but rational numbers sometimes have a denominator of 1, as
    in 2/1, 3/1, and so on. In this way, an integer is a special kind of rational
    number.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数字与几何学建立联系，把数字看作对应于数轴上的点，从而构建出*实数集*。我们还可以通过将整数除以其他（非零）整数来得到*有理数*。这里的*有理*不是指逻辑性和合理性，而是因为这些数字是由*比率*构成的。有时候有理数被称为*分数*，但这可能会造成误解。在日常语言中，*分数*通常指的是某物的一部分，意味着小于1的部分，而像3/2和4/3这样的有理数可以大于1。此外，分数通常是指分母大于或等于2的情况（如二分之一、三分之一等等），但有理数有时也有分母为1的情况，如2/1、3/1等。这样，整数实际上是一种特殊的有理数。
- en: 'With all these kinds of numbers, we use our intuition that when we name a particular
    number, we’re identifying one element of an infinite collection. That is, we expect
    numbers to go on forever: “To infinity and beyond,” as Buzz Lightyear says. There’s
    another way that numbers can be used, though, where they wrap around and recycle
    their values over and over, like the numbers on a clock. This way of working with
    numbers is useful for tracking things that happen regularly or repeatedly, and
    it has some interesting properties that we’ll explore in the next chapter when
    we look at modular arithmetic.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些数字的使用方式中，我们依靠直觉，当我们命名一个特定数字时，实际上是在识别一个无限集合中的一个元素。也就是说，我们期望数字会永无止境地延续下去：“通向无限，超越一切”，正如巴斯光年所说。然而，数字还有另一种使用方式，它们会循环回绕，反复使用它们的值，就像时钟上的数字一样。这种数字的使用方式非常适合追踪定期或重复发生的事件，并且具有一些有趣的特性，我们将在下一章讨论模运算时进一步探讨。
- en: 'In the first few chapters of this book, we’ll be most interested in counting
    numbers, also called *positive integers*. When we talk about numbers without being
    more specific, that’s the default interpretation to use. But so far, we’ve considered
    only what numbers are or aren’t included in a number system. There’s a whole other
    factor to consider as well: how those numbers are *represented*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章，我们将最关注计数数字，也就是*正整数*。当我们谈论数字而不加具体说明时，这就是默认的解释。但到目前为止，我们仅仅考虑了数字在数字系统中是否被包含。还有一个需要考虑的因素：这些数字是如何*表示*的。
- en: Base 10? Base 2? You Pick!
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 十进制？二进制？你来选择！
- en: A *basis representation system* determines how numbers are broken down into
    groups for ease of counting and how many symbols are needed to represent those
    numbers. Probably because we have 10 fingers, humans typically think of numbers
    in *decimal*, a basis system that uses groups of 10\. We start counting one at
    a time and use a different symbol for each new number, 1 through 9\. When we run
    out of fingers, we group double handfuls of fingers and count by tens. When there
    are no units left over after separating groups of 10, we use the symbol 0, a closed
    fist, to show this. So we understand 34 as 3 tens and 4 ones, and 60 as 6 tens
    and 0 ones.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*基数表示系统*决定了数字如何分组以便于计数，以及需要多少符号来表示这些数字。也许是因为我们有10根手指，人类通常使用*十进制*来思考数字，这是一种使用10为一组的基数系统。我们从一一数起，并为每个新数字使用不同的符号，从1到9。当我们数完手指后，我们会将手指分成两组十根手指，并按十进制数数。当分组后的十位数没有剩余时，我们使用符号0，表示握紧的拳头，来表示这一点。因此，我们理解34为3个十和4个一，60为6个十和0个一。
- en: 'We can extend the pattern of grouping by 10 to represent increasingly large
    numbers with relatively few digits, introducing a third-place digit for 10 tens
    (100), a fourth place for 10 hundreds (1,000), and so on. It helps to use exponents
    to indicate the repeated multiplication. For example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展按10分组的模式，用相对较少的数字来表示越来越大的数字，引入第三位数字表示10个十（100），第四位表示10个百（1,000），依此类推。使用指数可以帮助我们表示重复的乘法。例如：
- en: '![Image](../images/pg23_Image_6.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg23_Image_6.jpg)'
- en: 'We always have the option of sorting out the grouping using expanded notation.
    Here’s an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以选择使用展开记法来整理分组。这里有一个例子：
- en: '![Image](../images/pg23_Image_7.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg23_Image_7.jpg)'
- en: Since the decimal system hinges on powers of 10, it’s also called *base 10*.
    But while humans favor base 10, other ways of grouping are possible. For example,
    if you wanted to count using only the fingers on one hand, you could group by
    fives and have a *base 5* system. Base 5 numeration needs only the symbols 0,
    1, 2, 3, and 4\. The number five is written as 10, six as 11, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于十进制系统基于10的幂，它也被称为*十进制*。但尽管人类偏爱十进制，其他分组方式也是可能的。例如，如果你只想用一只手的手指来计数，你可以按五个一组，这样就是*五进制*系统。五进制计数只需要符号0、1、2、3和4。数字五写作10，六写作11，依此类推。
- en: 'Eggs and donuts are sold by the dozen, a group of 12, and we even have a word
    for a dozen dozen: a *gross*. *Base 12* numeration uses the symbols 0, 1, 2, 3,
    4, 5, 6, 7, 8, and 9 as usual, but it needs two extra single-digit symbols to
    represent the numbers ten and eleven. Usually we use T and E. If we need to specify
    the base, we can do it with a subscript, such as 15[10] to indicate that 15 is
    written in base 10\. This makes it easier to compare numbers written in different
    basis systems. For example, 15[10] = 13[12] = 30[5], which is to say that (1 ⋅
    10) + 5 = (1 ⋅ 12) + 3 = (3 ⋅ 5) + 0.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 鸡蛋和甜甜圈是按打出售的，每打为12个，我们甚至有一个词来表示一打打：*gross*（一打打为144个）。*12进制*计数法使用符号0, 1, 2, 3,
    4, 5, 6, 7, 8, 和9，和通常一样，但它需要两个额外的单字符符号来表示数字10和11。通常我们使用T和E。如果我们需要指定进制，可以用下标来表示，比如15[10]表示15是十进制。这使得比较不同进制系统中的数字更容易。例如，15[10]
    = 13[12] = 30[5]，也就是说（1 ⋅ 10）+ 5 = （1 ⋅ 12）+ 3 = （3 ⋅ 5）+ 0。
- en: 'Most computers use a *base 2* system, also called *binary*, to represent numbers
    internally. This system has the advantage that it requires only two symbols, 0
    and 1\. This matters because 0 and 1 are easy to keep track of with the position
    of a switch: the switch is either off (0) or on (1). Having only two symbols is
    good for expressing logic, too, where the two possibilities could represent *false*
    and *true*. A drawback is that powers of 2 (1, 2, 4, 8, 16, . . .) grow more slowly
    than powers of 10 (1, 10, 100, 1,000, . . .), so it typically takes more digits
    to represent a number in binary than it does to represent the same number in decimal.
    We’ll talk more about this later.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机使用*二进制*（base 2）系统来内部表示数字。这个系统的优点是它只需要两个符号，0和1。这很重要，因为0和1很容易通过开关的位置来跟踪：开关要么是关闭（0），要么是开启（1）。只有两个符号在表示逻辑时也很有用，其中两个可能性可以表示*假*和*真*。一个缺点是，2的幂（1,
    2, 4, 8, 16，……）的增长速度比10的幂（1, 10, 100, 1,000，……）慢，因此，通常需要更多的数字来表示一个数字的二进制形式，而表示同一个数字的十进制则需要较少的数字。我们稍后会进一步讨论这个问题。
- en: 'Project 1: What’s 77 in Binary?'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 1：77的二进制是多少？
- en: For a given positive integer, there’s a unique way of writing it in base 10,
    and it also has a unique representation in binary. In this project, we’ll write
    a Scratch program that converts from decimal to binary so we can see what the
    computer is seeing when it represents a number.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的正整数，它有一种独特的方式表示为十进制（base 10），它也有唯一的二进制表示。在这个项目中，我们将编写一个Scratch程序，将十进制转换为二进制，这样我们就能看到计算机在表示一个数字时所看到的样子。
- en: 'There are two ways we might approach this problem: strategies we can call *big-to-little*
    and *little-to-big*. According to the big-to-little strategy, we first find the
    largest power of 2 contained in a decimal number, to determine the leftmost digit
    of the base 2 representation. Then we subtract that power of 2 and find the largest
    power of 2 in the difference. We keep repeating this process to build up the binary
    representation, generating the digits from left to right. For example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两种方式来解决这个问题：我们可以称之为*从大到小*和*从小到大*的策略。根据从大到小策略，我们首先找到十进制数中包含的最大2的幂，以确定二进制表示的最左边数字。然后我们减去该2的幂，并找到差值中的最大2的幂。我们不断重复这个过程，从左到右生成二进制表示。举个例子：
- en: '![Image](../images/pg24_Image_9.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg24_Image_9.jpg)'
- en: The big-to-little strategy matches the way most humans would approach doing
    a decimal-to-binary conversion in their heads, but the little-to-big strategy
    is much easier to code on a computer. Instead of searching for the largest power
    of 2 contained in a number, all we have to do is program a series of divisions
    by 2 and keep track of the remainders. This builds up the binary representation
    from right to left. [Figure 1-1](ch01.xhtml#ch1fig1) shows a Scratch program that
    uses the little-to-big approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从大到小策略与大多数人在头脑中进行十进制到二进制转换时的方式相匹配，但从小到大的策略在计算机中编程要容易得多。我们不需要去寻找数字中包含的最大2的幂，只需编写一系列的除以2的操作，并记录下余数。这将从右到左构建二进制表示。[图
    1-1](ch01.xhtml#ch1fig1)展示了一个使用从小到大的方法的Scratch程序。
- en: '![Image](../images/pg24_Image_8.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg24_Image_8.jpg)'
- en: '*Figure 1-1: A program to convert decimal (base 10) numbers into binary (base
    2)*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：将十进制（base 10）数转换为二进制（base 2）的程序*'
- en: We build up the binary version of a number in the `string` variable, which starts
    out blank at the beginning of the program. (A *string* is a sequence of characters;
    more on this in “Hacking the Code” on [page 5](ch01.xhtml#ch01lev5).) To get started,
    we use the `ask and wait` block to have Scratch Cat prompt the user for a number
    in base 10, storing the user’s `answer` in the `n` variable. Then we enter a `repeat
    until` loop ❶, where the real logic is.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `string` 变量中构建数字的二进制版本，程序开始时该变量为空。（*string* 是字符的序列；有关详细信息，请参见“破解代码”部分中的
    [第 5 页](ch01.xhtml#ch01lev5)。）首先，我们使用 `ask and wait` 块让 Scratch Cat 提示用户输入一个十进制数字，并将用户的
    `answer` 存储在 `n` 变量中。然后，我们进入一个 `repeat until` 循环 ❶，在这里实现真正的逻辑。
- en: '`n mod 2` returns the remainder of dividing `n` by `2`, which will be `1` if
    `n` is odd or `0` if `n` is even. Each time through the loop, this `mod` operation
    gives us one digit of the binary representation of the number, starting with the
    least significant (rightmost) digit. We use the `join` block to merge that digit
    with the contents already in the `string` variable, putting the result back in
    `string`. Then we divide `n` by `2` and use `floor` to round the result down to
    the nearest whole number. This removes the value of the binary digit we just accounted
    for from `n`. Then, the loop can start again to find the next binary digit.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`n mod 2` 返回将 `n` 除以 `2` 的余数，如果 `n` 是奇数则为 `1`，如果是偶数则为 `0`。每次通过循环时，这个 `mod`
    操作会给我们数字的一个二进制位，从最不重要的（最右边的）位开始。我们使用 `join` 块将该数字与 `string` 变量中已有的内容合并，然后将结果放回
    `string`。接着我们将 `n` 除以 `2`，并使用 `floor` 函数将结果向下取整到最接近的整数。这将移除我们刚刚处理过的二进制位的值。然后，循环可以重新开始，找到下一个二进制位。'
- en: Once `n` gets down to `0`, we’ve built up the complete binary representation
    of the number from right to left. We then use some more `join` blocks to put together
    a meaningful sentence reporting the result, which Scratch Cat announces through
    the `say` block.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `n` 减少到 `0`，我们就从右到左构建了该数字的完整二进制表示。然后，我们使用更多的 `join` 块将其组合成一个有意义的句子，报告结果，Scratch
    Cat 会通过 `say` 块宣布这个结果。
- en: The Results
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: Run the program and try entering **77** when Scratch Cat asks for a number.
    You should get 1001101 as the result, as shown in [Figure 1-2](ch01.xhtml#ch1fig2).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并尝试在 Scratch Cat 提示输入一个数字时输入 **77**。你应该会得到 1001101 作为结果，正如 [图 1-2](ch01.xhtml#ch1fig2)
    中所示。
- en: '![Image](../images/pg25_Image_10.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg25_Image_10.jpg)'
- en: '*Figure 1-2: Converting 77[10] into base 2*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：将 77[10] 转换为二进制*'
- en: Because of the way Scratch works, you’ll see a lot of figures in this book that
    combine different points from a program’s execution into one image, like this
    one. In this case, you can see Scratch Cat’s speech bubbles from both the `ask
    and wait` and `say` blocks, as well as the box for entering the base 10 number.
    The execution flow will be clear when you’re doing these experiments yourself,
    but when you’re looking at the figures in the book you might need to do a little
    interpretation of what happens when.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Scratch 的工作方式，你会在本书中看到很多将程序执行过程中的不同点合并成一张图像的示例，就像这个图一样。在这个例子中，你可以看到 Scratch
    Cat 的对话框来自 `ask and wait` 和 `say` 块，以及输入十进制数字的框。当你自己做这些实验时，执行流程会很清楚，但在查看书中的图示时，你可能需要稍微解释一下每个步骤发生的时机。
- en: Hacking the Code
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: 'The program treats the decimal-to-binary conversion as a sequence of halvings.
    You could also think of it in reverse, as a sequence of doublings, with a +1 for
    each 1 in the binary representation and a +0 for each 0\. For example, we can
    represent the conversion of 77 mathematically as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将十进制到二进制的转换视为一系列的除以 2 操作。你也可以从反向思考，将其看作一系列的乘以 2 操作，每遇到二进制表示中的 1 就加 1，每遇到
    0 就加 0。例如，我们可以通过以下方式数学表示转换 77：
- en: '![Image](../images/pg25_Image_11.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg25_Image_11.jpg)'
- en: You can see the digits of the binary representation in red. Stacking up the
    multiplications in this way puts every binary digit with its appropriate power
    of 2.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到二进制表示中的数字是红色的。以这种方式堆叠乘法，使得每个二进制数字都与其相应的 2 的幂匹配。
- en: Another important thing to know about this program is that while the answer
    Scratch reports looks like a number, it’s actually a string. As I mentioned earlier,
    a string is just a list of characters. Usually those characters are letters of
    the alphabet strung together to form messages like `Hello` or `Tell me a number`,
    but in this case, the characters happen to be 0s and 1s. So even though the result
    looks like binary digits making up a number, Scratch has no idea that `1001101`
    is a binary number with a decimal value of 77.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要了解的关于这个程序的重要点是，虽然Scratch报告的答案看起来像一个数字，但实际上它是一个字符串。正如我之前提到的，字符串只是一个字符列表。通常这些字符是字母组成的，用来形成像`Hello`或`Tell
    me a number`这样的消息，但在这种情况下，这些字符恰好是0和1。所以，即使结果看起来像是由二进制数字构成的一个数字，Scratch并不知道`1001101`是一个具有十进制值77的二进制数字。
- en: We have to use strings because Scratch doesn’t have a built-in way to work directly
    with binary numbers. If we wanted Scratch to do binary arithmetic on base 2 numbers,
    we would have to write a custom program to teach it how. This is the first of
    many cases in this book where we’ll have to treat numbers as strings to “trick”
    Scratch into doing what we want.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用字符串，因为Scratch没有内建的方法直接处理二进制数字。如果我们想让Scratch对基数2的数字进行二进制运算，我们就需要编写一个自定义程序来教它怎么做。这是本书中很多需要将数字当作字符串处理的情况之一，目的是“欺骗”Scratch执行我们想要的操作。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**1.1** Write a program that prompts for a base *b*, then prompts for a base
    10 number *n*, and then returns the number *n* written in the base *b*. You might
    limit the base *b* to be between 2 and 10, or go on to use the digits E and T
    to allow base 11 or 12.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.1** 编写一个程序，提示输入一个基数*b*，然后提示输入一个十进制数字*n*，最后返回该数字*n*在基数*b*下的表示。你可以将基数*b*限制为2到10之间，或者继续使用数字E和T来允许基数为11或12。'
- en: '**1.2** A popular computer-related base is base 16, *hexadecimal*, which usully
    uses the extra symbols A, B, C, D, E, and F to stand for 10, 11, 12, 13, 14, and
    15\. Extend your base converter to give hexadecimal representations. See if you
    can spot the trick for converting back and forth between binary and hexadecimal.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.2** 一个常见的与计算机相关的进制是16进制，*十六进制*，它通常使用额外的符号A、B、C、D、E和F来表示10、11、12、13、14和15。扩展你的进制转换器，给出十六进制表示。看看你能否找到二进制和十六进制之间转换的技巧。'
- en: 'Project 2: What’s 1001101 in Decimal?'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目2：1001101的十进制是多少？
- en: Now let’s try converting backward from a binary representation to a decimal
    one. [Figure 1-3](ch01.xhtml#ch1fig3) shows a Scratch program that does this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试从二进制表示转换回十进制。[图1-3](ch01.xhtml#ch1fig3)展示了一个实现这一功能的Scratch程序。
- en: We first ask the user for a string representing a binary value with an `ask
    and wait` block. Then we use a `repeat` loop and the `index` variable to look
    at the string one character at a time, from left to right, with `letter index
    of answer` accessing the current character. The variable `n` starts at `0`. For
    each digit in the binary representation, `n` is doubled and then has the value
    of the current digit (either `0` or `1`) added to it. When there are no more binary
    digits left, `n` holds the decimal representation of the number.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过`ask and wait`模块请求用户输入一个表示二进制值的字符串。然后，我们使用`repeat`循环和`index`变量一次查看字符串中的一个字符，从左到右，通过`letter
    index of answer`访问当前字符。变量`n`从`0`开始。对于二进制表示中的每个数字，`n`会翻倍，然后将当前数字（`0`或`1`）的值加到`n`中。当没有更多的二进制数字时，`n`就保存了该数字的十进制表示。
- en: '![Image](../images/pg27_Image_13.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg27_Image_13.jpg)'
- en: '*Figure 1-3: A program to convert binary (base 2) numbers into decimal (base
    10)*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-3：将二进制（基数2）数字转换为十进制（基数10）的程序*'
- en: The Results
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: We know that 77 in binary is 1001101\. Try running the program and entering
    1001101 to see if it gives 77 back. [Figure 1-4](ch01.xhtml#ch1fig4) shows the
    results.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道77的二进制表示是1001101。尝试运行程序并输入1001101，看看它是否返回77。[图1-4](ch01.xhtml#ch1fig4)显示了结果。
- en: '![Image](../images/pg27_Image_14.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg27_Image_14.jpg)'
- en: '*Figure 1-4: Converting 1001101[2] into base 10*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-4：将1001101[2]转换为十进制*'
- en: We’ve worked a lot with 77, converting it to binary in [Figure 1-2](ch01.xhtml#ch1fig2)
    and then back to decimal again in [Figure 1-4](ch01.xhtml#ch1fig4). But what is
    the number 77 *really*? Whether we write it in binary or decimal, 77 represents
    the same quantity. How we choose to write a number might reveal interesting facts
    about it (for instance, if a number written in decimal ends in a 0, the number
    must be divisible by 10, and if a number written in binary ends in a 0, the number
    has to be divisible by 2), but it doesn’t change the value of the number at all.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[图 1-2](ch01.xhtml#ch1fig2)中将77转换为二进制，并在[图 1-4](ch01.xhtml#ch1fig4)中再转换回十进制。但是，77*到底*是什么？无论我们是用二进制还是十进制表示，77代表的数量是相同的。我们选择如何表示一个数字可能会揭示出它的一些有趣的特性（例如，如果一个十进制数以0结尾，那么这个数字一定能被10整除；如果一个二进制数以0结尾，那么这个数字必须能被2整除），但它并不会改变数字的实际值。
- en: Hacking the Code
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: One problem with our binary-to-decimal program is that it has no check to make
    sure it’s working with a string of binary digits. If you input something that
    isn’t a number in binary notation, Scratch Cat is happy to tell you nonsense,
    as the examples in [Figure 1-5](ch01.xhtml#ch1fig5) show.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的二进制转十进制程序的一个问题是，它没有检查输入是否为二进制数字串。如果你输入的不是二进制表示的数字，Scratch Cat 很高兴地告诉你一些无意义的内容，正如[图
    1-5](ch01.xhtml#ch1fig5)中的例子所示。
- en: '![Image](../images/pg28_Image_15.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg28_Image_15.jpg)'
- en: '*Figure 1-5: Three outputs from the binary-to-decimal converter. There’s nothing
    to stop you from entering something other than a binary number!*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-5：二进制转十进制转换器的三个输出。没有任何东西能阻止你输入非二进制数字！*'
- en: 'We could fix this by including a custom `Screen string` block to check the
    input. This block, shown in [Figure 1-6](ch01.xhtml#ch1fig6), makes sure the input
    is in the right form: a string of characters that includes only 0s and 1s.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包含一个自定义的`Screen string`块来检查输入，从而修复这个问题。这个块在[图 1-6](ch01.xhtml#ch1fig6)中显示，它确保输入格式正确：一个仅包含0和1的字符串。
- en: '![Image](../images/pg28_Image_16.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg28_Image_16.jpg)'
- en: '*Figure 1-6: Making sure only base 2 numbers are allowed*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-6：确保只允许二进制数字*'
- en: The block sets the logical (*Boolean*, or true/false) variable `binary string?`
    to `true` as long as the user didn’t input any other characters (like spaces,
    letters, or digits greater than 1). Otherwise, it sets `binary string?` to `false`.
    We can now use this block with an `if...else` statement so we don’t get any silly,
    incorrect answers, as shown in [Figure 1-7](ch01.xhtml#ch1fig7). The operator
    blocks that Scratch uses for Boolean tests are all green hexagons that you can
    plug into the test condition in control blocks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该块将逻辑（*布尔*，即真/假）变量`binary string?`设置为`true`，只要用户没有输入其他字符（例如空格、字母或大于1的数字）。否则，它将`binary
    string?`设置为`false`。现在，我们可以使用这个块与`if...else`语句结合，以确保不会得到任何荒谬、不正确的答案，正如[图 1-7](ch01.xhtml#ch1fig7)所示。Scratch用于布尔测试的运算符块都是绿色六边形，可以插入到控制块中的测试条件里。
- en: '![Image](../images/pg29_Image_17.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg29_Image_17.jpg)'
- en: '*Figure 1-7: The binary-to-decimal converter done more carefully*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-7：更加小心的二进制转十进制转换器*'
- en: Here, we’ve moved the original binary-to-decimal code inside the `if` branch
    of an `if...else` block so it runs only if the `binary string?` variable is `true`.
    Otherwise, Scratch Cat will inform the user that the input wasn’t a binary number.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将原始的二进制转十进制代码移到`if...else`块的`if`分支中，这样只有在`binary string?`变量为`true`时，它才会运行。否则，Scratch
    Cat 会告知用户输入的不是二进制数字。
- en: You may be disappointed that the program is a little longer now than it was
    originally. Scratch makes it easy to write really compact programs, and it even
    encourages this by telling you how many blocks there are in the programming window.
    But sometimes, it’s better to be careful even if it makes your program a bit longer.
    If it’s possible to misunderstand something or make a mistake in the input, at
    some point someone will do that, so it’s better to be safe than sorry! Some programming
    languages have special commands to intercept errors and reroute them somewhere
    harmless (the syntax usually involves the keywords `try` and `catch`), but Scratch
    leaves it up to you to anticipate problems and guard against them, as we’ve done
    with the `Screen string` block.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会失望地发现，现在程序的长度比最初稍长。Scratch 让编写非常紧凑的程序变得容易，甚至通过告诉你编程窗口中有多少个积木来鼓励这种方式。但有时，即使这会让你的程序变得稍长一些，还是小心为好。如果某些内容可能会被误解或在输入时出错，总会有人在某些时候犯这样的错误，因此还是谨慎为好！一些编程语言有专门的命令来拦截错误并将其引导到某个无害的地方（语法通常涉及
    `try` 和 `catch` 关键字），但 Scratch 让你自己预见问题并加以防范，就像我们用 `Screen string` 积木所做的那样。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenge'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**1.3** Sometimes news stories talk about *exponential growth* as a general
    term to suggest rapid increase. Exponential growth means something specific in
    mathematics, where progression from one value in a sequence of numbers to the
    next value is done by multiplication using a fixed factor. For example, every
    number might be two times larger than the one before it. An alternative is *linear
    growth*, where the change happens by *adding* a fixed increment, such as when
    each number is two more than the previous one.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.3** 有时新闻报道中提到的 *指数增长* 是一个通用术语，用来表示快速增长。指数增长在数学中有特定的含义，指的是在数字序列中，从一个值到下一个值的进展是通过乘法并使用一个固定的因子来完成的。例如，每个数字可能是前一个数字的两倍。另一种选择是
    *线性增长*，其中变化是通过 *加* 上一个固定增量来完成的，比如每个数字比前一个大两个。'
- en: 'Write some Scratch code that prompts the user for a multiplier or an increment,
    and answers with a sequence of numbers that grows exponentially or linearly. Compare
    the growth: What happens if the user gives a number less than 1 for exponential
    growth? What happens if the user gives a number less than 0 for linear growth?
    Maybe this is a situation that calls for input screening.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些 Scratch 代码，提示用户输入一个乘数或增量，并返回一个按指数或线性增长的数字序列。比较增长：如果用户输入一个小于 1 的数字用于指数增长会发生什么？如果用户输入一个小于
    0 的数字用于线性增长会发生什么？也许这是一个需要输入筛选的情况。
- en: How Computers Represent Numbers
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算机如何表示数字
- en: Computers can represent numbers internally in different ways, but they all involve
    some kind of compromise. Earlier I mentioned that humans think of number systems
    like integers and real numbers as being infinite. Computers aren’t built to handle
    infinite collections, though. They have to work within the confines of the architecture
    of their hardware or the logical structure of the programming language they’re
    running.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机可以以不同的方式内部表示数字，但它们都涉及某种妥协。之前我提到过，人类将整数和实数等数字系统视为无限的。然而，计算机并不是为了处理无限的集合而构建的。它们必须在硬件架构或所运行编程语言的逻辑结构的限制内工作。
- en: On the hardware side, central processing units (CPUs) typically have *registers*,
    which are areas of the CPU that can hold and operate on a certain number of binary
    digits, or *bits*, at once. Programming languages are designed to allocate a fixed
    number of bits to represent each number, so language designers need to make decisions
    about what exactly those bits mean (for example, whether some represent a base
    and others an exponent). They also need to make decisions about things like how
    to represent a number as negative or positive and what to do if a number takes
    up more than the available space. Should the computation halt with a warning or
    an error, or should the representation wrap back around without complaint, possibly
    leading to unexpected and incorrect results?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件方面，中央处理单元（CPU）通常有 *寄存器*，这是 CPU 中可以一次性存储和操作一定数量的二进制数字或 *位* 的区域。编程语言被设计为为每个数字分配固定数量的位，因此语言设计者需要做出决定，确定这些位究竟代表什么（例如，某些位是否代表基数，其他位代表指数）。他们还需要做出有关如何表示正数或负数以及如果一个数字超出了可用空间应该怎么做的决定。计算是否应该在出现警告或错误时停止，还是应该在没有提示的情况下重新循环，可能会导致意外和不正确的结果？
- en: Ultimately, we can’t fit infinitely many numbers into a computer’s finite space
    of possibilities, so “most” numbers have to be left out. This means the developers
    of a computer language need to decide which numbers and what kinds of numbers
    are interesting and important enough to include. Some people need to represent
    tiny numbers, the size of subatomic particles, while others need to represent
    massive numbers, the size of the universe, and still others need everything in
    between. Different languages may be designed to fill some of these needs but not
    others.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们无法在计算机有限的可能空间中容纳无限多个数字，因此必须舍弃“多数”数字。这意味着计算机语言的开发者需要决定哪些数字以及哪种类型的数字足够有趣或重要，值得被包括在内。有些人需要表示微小的数字，比如亚原子粒子的大小，而另一些人则需要表示巨大的数字，比如宇宙的大小，还有一些则需要表示介于两者之间的数字。不同的语言可能会设计来满足其中的一些需求，但不是所有需求。
- en: Beyond questions of how big or small the numbers are, language designers might
    also want to consider how the numbers will be used. For instance, sometimes numbers
    are used to count, answering questions about “How many?” In this case, the answer
    is often a whole number. (This comes up often enough that lots of programming
    languages give integers their own representation system, separate from other kinds
    of numbers.) Other times, numbers are used to measure, answering questions about
    “How much?” The answers to those questions are less likely to be whole numbers.
    Language designers need a way to represent those “in between” numbers, and they
    have to decide exactly how far “in between” to go.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数字的大小或小的问题外，语言设计者还可能想要考虑数字的使用方式。例如，有时数字用于计数，回答“多少？”的问题。在这种情况下，答案通常是一个整数。（这类问题出现得相当频繁，以至于许多编程语言为整数提供了独立的表示系统，区别于其他类型的数字。）另一些时候，数字用于测量，回答“多少？”的问题。对此类问题的回答不太可能是整数。语言设计者需要一种表示这些“介于两者之间”的数字的方法，并且他们必须决定到底要表示多大的“介于两者之间”。
- en: The Point of Floating Point
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 浮点数的要点
- en: '*Floating-point notation* allows for “in between” numbers by including powers
    of the base smaller than 1\. In base 10, there’s a *decimal point*, with digits
    to the right of the decimal point representing a number between 0 and 1 with a
    combination of powers of 1/10, 1/100, and so on. For instance, the approximation
    of *π*, 3.14, indicates a number that’s a little more than 3:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮点表示法*通过包括小于1的基数幂来表示“介于两者之间”的数字。在十进制中，有一个*小数点*，小数点右侧的数字表示一个介于0和1之间的数字，结合了1/10、1/100等的幂。例如，*π*的近似值3.14表示的是一个稍微大于3的数字：'
- en: '![Image](../images/pg31_Image_18.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg31_Image_18.jpg)'
- en: 'If you need a closer approximation, you can include a few more digits:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更精确的近似值，可以再加上几个数字：
- en: '![Image](../images/pg31_Image_19.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg31_Image_19.jpg)'
- en: The same principle applies to floating-point notation for binary numbers, where
    digits to the right of the *binary point* (the binary equivalent of a decimal
    point) represent powers of 1/2\. You’re probably familiar with using binary fractions
    to represent numbers—even if you don’t realize it—if you’ve ever measured lengths
    with a ruler or tape measure (see [Figure 1-8](ch01.xhtml#ch1fig8)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原理适用于二进制浮点表示法，其中位于*二进制点*（即小数点的二进制等价物）右侧的数字表示1/2的幂。你可能已经熟悉使用二进制小数表示数字——即使你没有意识到——如果你曾经用尺子或卷尺测量过长度（见[图
    1-8](ch01.xhtml#ch1fig8)）。
- en: '![Image](../images/pg31_Image_20.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg31_Image_20.jpg)'
- en: '*Figure 1-8: Binary fractions on a tape measure*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-8：卷尺上的二进制小数*'
- en: Inches are subdivided into halves (1/2), quarters (1/4), eighths (1/8), sixteenths
    (1/16), and so on. These are binary fractions in that each denominator is a power
    of 2\. You could measure 1 13/16 inches, for example, by going over 1, then 1/2,
    then 1/4, then 1/16, and write 1 13/16 with a binary representation of 1.1101.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 英寸被细分为二分之一（1/2）、四分之一（1/4）、八分之一（1/8）、十六分之一（1/16）等。这些是二进制小数，因为每个分母都是2的幂。例如，你可以通过先走过1，再走过1/2，接着是1/4，再是1/16，最后写作1
    13/16，并用二进制表示为1.1101来表示1 13/16英寸。
- en: Binary fractions give us a way to write non-whole numbers, but how many bits
    should be used to represent a number, and how should they be interpreted? Anyone
    who invents a computer language can make their own rules, but it’s better to have
    a standard that everyone agrees to use so there won’t be any confusion when switching
    from one language to another. One such standard is the IEEE Standard for Floating-Point
    Arithmetic, or IEEE 754\. The makers of Scratch chose to use this standard to
    represent all numbers, even whole numbers, whereas some languages use IEEE 754
    for floating-point numbers and a different standard for integers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制小数为我们提供了一种表示非整数的方式，但应该使用多少比特来表示一个数字，以及如何解释这些比特呢？任何发明计算机语言的人都可以制定自己的规则，但最好有一个大家都同意使用的标准，这样在从一种语言切换到另一种语言时就不会产生混淆。其中一个标准就是IEEE浮点数运算标准，或称IEEE
    754。Scratch的开发者选择使用这个标准来表示所有数字，甚至是整数，而一些语言则将IEEE 754用于浮点数，采用不同的标准表示整数。
- en: Double the Precision, Double the Fun
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 精度翻倍，乐趣翻倍
- en: IEEE 754 uses *double precision*, meaning a floating-point number in binary
    will occupy 64 bits (unlike *single precision*, which allows for 32 bits per number).
    [Figure 1-9](ch01.xhtml#ch1fig9) shows how the 64 bits are allocated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE 754使用*双精度*，意味着二进制中的浮点数将占用64个比特（与*单精度*不同，后者每个数字只允许32个比特）。[图1-9](ch01.xhtml#ch1fig9)显示了64个比特是如何分配的。
- en: '![Image](../images/pg32_Image_21.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg32_Image_21.jpg)'
- en: '*Figure 1-9: How bits are allocated in the IEEE 754 standard*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-9：IEEE 754标准中比特是如何分配的*'
- en: 'The first bit, shown in cyan in the figure, is for the sign: 0 or 1 for plus
    or minus. The last 64 – 1 – 11 = 52 bits, shown in orange, represent a number,
    conventionally a value between 1 and 2, that is called the *mantissa*. Since a
    binary number between 1 and 2 always looks like a 1, then a binary point, then
    some other digits, we can save one binary digit by not writing the initial 1 explicitly.
    So instead of 52 bits of precision, we really have 53 bits. The 11 bits after
    the sign bit, colored in purple in the figure, are for the exponent, specifying
    a power of 2 used to multiply the mantissa. Sometimes the exponent is called the
    *characteristic*. Having 11 bits in the characteristic gives a range of 2^(11)
    possible exponents, which are interpreted as going from 2^(–1,023) to 2^(1,024),
    but the very top and bottom numbers are reserved for special use.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个比特，如图中所示的青色部分，用于表示符号：0或1代表正负。剩下的64 – 1 – 11 = 52个比特，如图中橙色部分所示，表示一个数字，通常是一个介于1和2之间的值，称为*尾数*。由于介于1和2之间的二进制数总是以1开始，然后是二进制点和其他数字，因此我们可以通过不显式写出初始的1来节省一个二进制位。所以，实际上我们有53位精度，而不是52位。符号位之后的11个比特，图中的紫色部分，表示指数，指定用于乘以尾数的2的幂。有时，指数也称为*特征*。拥有11个位数的特征给出了2^(11)个可能的指数范围，这些指数从2^(-1,023)到2^(1,024)不等，但最顶端和最底端的数字被保留供特殊用途。
- en: '**NOTE**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For a hands-on look at how IEEE 754 works, there are interactive online tools
    that let you change floating-point numbers bit by bit (literally) to see what
    happens. Some examples are the double-precision tools at* [https://float.exposed](https://float.exposed)
    *and* [http://evanw.github.io/float-toy/](http://evanw.github.io/float-toy/).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*要实际了解IEEE 754是如何工作的，可以使用一些在线交互工具，逐位（字面意义上）修改浮点数，看看发生了什么。一些示例包括* [https://float.exposed](https://float.exposed)
    *和* [http://evanw.github.io/float-toy/](http://evanw.github.io/float-toy/)。'
- en: Keep in mind that 53 digits of precision in binary doesn’t translate into 53
    digits of precision in decimal. For example, 2^(10) = 1,024, which is about the
    same as 10³ = 1,000\. This indicates that 10 binary digits convey about as much
    information as 3 decimal digits, so 53 binary digits can hold as much information
    as about 16 or 17 decimal digits. That’s still a lot—way more than you’re likely
    to see on a calculator screen—but it’s far from infinite.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，二进制中53位的精度并不等同于十进制中53位的精度。例如，2^(10) = 1,024，大约等同于10³ = 1,000。这表明，10个二进制数字传达的信息量大约相当于3个十进制数字，因此53个二进制数字可以承载大约16或17个十进制数字的信息量。这仍然是非常大的——远远超过你在计算器屏幕上看到的数字——但它远非无限。
- en: In this book, we’re mainly interested in integers, so 16 decimal digits of precision
    means that a 16-digit number, somewhere in the low quadrillions, is the biggest
    number Scratch can be counted on to represent exactly as a counting number. When
    we test numbers for properties such as divisibility in future chapters, we’ll
    need to be sure all the digits of the numbers are reliably represented to get
    correct results. We’ll explore this limitation in our next project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们主要关注整数，因此 16 位十进制数字的精度意味着一个 16 位数字，处于低四千万亿范围内，是 Scratch 能够保证精确表示的最大数字。当我们在未来的章节中测试数字的属性，如可除性时，我们需要确保所有数字的每一位都能可靠地表示，以便获得正确的结果。我们将在下一个项目中探索这一限制。
- en: 'Project 3: 2^(53) + 1 = ?'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 3：2^(53) + 1 = ?
- en: 'Some languages give the largest integer that can be represented exactly in
    floating-point notation a special name, *flintmax*, which is an abbreviation for
    *floating-point integer maximum*. The value of flintmax in Scratch is:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言为可以精确表示的最大整数在浮点表示法中起了一个特殊的名字，*flintmax*，是 *floating-point integer maximum*
    的缩写。在 Scratch 中，flintmax 的值是：
- en: '![Image](../images/pg33_Image_22.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg33_Image_22.jpg)'
- en: '[Figure 1-10](ch01.xhtml#ch1fig10) shows a little program illustrating how
    arithmetic goes awry when you try to work with numbers bigger than flintmax. Keep
    an eye on the variables as you run the program to see where the problem arises.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-10](ch01.xhtml#ch1fig10) 展示了一个小程序，说明了当你尝试处理大于 flintmax 的数字时，算术运算是如何出错的。在运行程序时，注意观察变量，看看问题是在哪里出现的。'
- en: '![Image](../images/pg33_Image_23.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg33_Image_23.jpg)'
- en: '*Figure 1-10: Integer arithmetic is unreliable above flintmax.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-10：大于 flintmax 时，整数运算不可靠。*'
- en: Subtracting 1 from flintmax works fine, but adding 1 to flintmax doesn’t give
    the expected result. The value of the variable `flintmax+1` is flintmax itself.
    You have to add 2 to change flintmax and get a correct answer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从 flintmax 中减去 1 是有效的，但将 1 加到 flintmax 上并没有得到预期的结果。变量 `flintmax+1` 的值仍然是 flintmax
    本身。你必须加 2 才能改变 flintmax 并得到正确的答案。
- en: Hacking the Code
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: It’s always interesting to test the limits and see where a computer language
    or other system breaks down. People who are interested in video games, for example,
    spend lots of time looking for glitches and locations that break the game’s underlying
    model or make the game’s objects behave weirdly. It’s part of the fun to see how
    things can go wrong and to conduct experiments to try to work out how the computer
    is handling itself.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 测试极限并看看计算机语言或其他系统在哪里出问题总是很有趣。例如，对视频游戏感兴趣的人会花大量时间寻找漏洞和破坏游戏基础模型的位置，或者让游戏中的物体表现得很怪异。看到事情出错并进行实验，尝试弄明白计算机是如何处理这些问题的，成为其中的一部分乐趣。
- en: In this case, our program showed that when calculations in Scratch exceed flintmax,
    the results are suspect and may not correspond to exact integer arithmetic. We’ll
    need to keep that in mind as we design programs to explore integer arithmetic
    in Scratch. As long as the numbers, including intermediate results, remain under
    flintmax, though, the results will be exact. For instance, you can write a Scratch
    program that counts up starting from 1, and you’ll get all the way to flintmax
    before there’s a missing integer value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的程序显示，当 Scratch 中的计算超出 flintmax 时，结果是可疑的，可能不对应于精确的整数算术。我们在设计程序以探索 Scratch
    中的整数运算时需要记住这一点。不过，只要数字，包括中间结果，保持在 flintmax 之下，结果将是精确的。例如，你可以编写一个 Scratch 程序，从
    1 开始计数，直到 flintmax，你将得到所有整数值，直到没有缺失的整数值。
- en: Our program also showed that IEEE 754 can represent *some* integers above flintmax,
    such as flintmax + 2, correctly. In fact, it can represent even numbers (multiples
    of 2) above flintmax exactly for a while, but eventually it loses another digit
    of binary accuracy, after which point it represents only multiples of 4 exactly.
    You can try extending the program in [Figure 1-10](ch01.xhtml#ch1fig10) to illustrate
    this. What’s the largest integer *n* for which Scratch can correctly distinguish
    between *n* and *n* + 2? How does that value compare with flintmax? Likewise,
    what’s the largest integer *n* where there’s a difference between *n* and *n*
    + 4?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序还显示，IEEE 754 可以正确表示*某些*大于 flintmax 的整数，例如 flintmax + 2。事实上，它可以精确表示大于 flintmax
    的偶数（2 的倍数），但在一段时间后，它会失去一位二进制精度，从那时起，它只会精确表示 4 的倍数。你可以尝试扩展 [图 1-10](ch01.xhtml#ch1fig10)
    中的程序来说明这一点。Scratch 能正确区分 *n* 和 *n* + 2 的最大整数 *n* 是多少？这个值与 flintmax 相比如何？同样，*n*
    和 *n* + 4 之间有差异的最大整数 *n* 是多少？
- en: Another way that arithmetic can get broken in Scratch is when the result of
    a computation doesn’t match any numerical value. For example, Scratch reports
    `Infinity` when you try to divide by 0, as in [Figure 1-11](ch01.xhtml#ch1fig11).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scratch 中，算术运算可能会出错的另一种方式是，当计算结果不匹配任何数值时。例如，当你尝试除以 0 时，Scratch 会报告 `Infinity`，如
    [图 1-11](ch01.xhtml#ch1fig11) 所示。
- en: '![Image](../images/pg34_Image_24.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg34_Image_24.jpg)'
- en: '*Figure 1-11: Sometimes the answer is* Infinity.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-11：有时答案是* 无限大。'
- en: But what happens when you try to subtract `Infinity` from `Infinity`? The answer
    reported in [Figure 1-12](ch01.xhtml#ch1fig12) is `NaN`, which means *not a number*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你尝试从 `Infinity` 中减去 `Infinity`，会发生什么呢？在 [图 1-12](ch01.xhtml#ch1fig12) 中报告的答案是
    `NaN`，这意味着 *不是一个数字*。
- en: '![Image](../images/pg35_Image_25.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg35_Image_25.jpg)'
- en: '*Figure 1-12: Sometimes the answer is not a number.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-12：有时答案不是一个数字。*'
- en: We’ll encounter these special values, `Infinity` and `NaN`, in the output of
    some of our programs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的某些程序输出中，我们会遇到这些特殊值：`Infinity` 和 `NaN`。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**1.4** What’s the largest number that Scratch can represent, integer or not?
    What happens when that number is exceeded?'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.4** Scratch 能表示的最大数字是多少，无论是整数还是非整数？当超过这个数字时会发生什么？'
- en: '**1.5** Try using Scratch to create a floating-point simulator like the ones
    mentioned in the note on [page 12](ch01.xhtml#common1). You should be able to
    look at a 64-bit string of 0s and 1s and see the floating-point number associated
    with it, then change the bits to see how the number changes.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.5** 尝试使用 Scratch 创建一个浮点模拟器，就像在 [第 12 页](ch01.xhtml#common1) 中提到的那些。你应该能够查看一个由
    0 和 1 组成的 64 位字符串，并看到与之相关的浮点数，然后改变这些位，看看数字如何变化。'
- en: 'Project 4: A Million-Digit Number?'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 4：百万位数字？
- en: In this project, we’ll trick Scratch into doing exact integer arithmetic with
    many more digits of precision than flintmax provides. To get around the limits
    of the IEEE 754 standard for number representation, we’ll have to program our
    own alternative representation system for large numbers. We have a few different
    options here. For example, we could store decimal numbers one digit at a time
    in a list, in which case the only limit would be Scratch’s maximum list length
    of 200,000\. If we stored five digits at a time as list entries, we could get
    to one million digits!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将通过编程技巧让 Scratch 进行精确的整数运算，计算出比 flintmax 提供的精度更多的位数。为了绕过 IEEE 754 标准对数字表示的限制，我们必须编写自己的大数字表示系统。我们这里有几种不同的选择。例如，我们可以将十进制数字一个一个地存储在列表中，这样唯一的限制就是
    Scratch 最大的列表长度 200,000。如果我们每次存储五个数字作为列表项，我们就能达到一百万个数字！
- en: Another option could be to store the numbers as strings. Strings can be very
    long, even millions of characters. Scratch doesn’t provide any built-in operations
    for performing arithmetic on strings, though, so if we wanted to work with numbers
    represented as strings we’d have to program the arithmetic operations ourselves.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将数字存储为字符串。字符串可以非常长，甚至有数百万个字符。然而，Scratch 并没有提供对字符串进行算术运算的内置操作，因此如果我们想处理以字符串表示的数字，就必须自己编写算术运算操作。
- en: '[Figure 1-13](ch01.xhtml#ch1fig13) shows an example of a program that reliably
    performs calculations on numbers well beyond flintmax. The program prompts for
    an exponent *n* and then displays all the digits of 2^(*n*), both as a list of
    digits and as a string built by joining the digits together.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-13](ch01.xhtml#ch1fig13) 显示了一个程序的示例，它可以可靠地对超出 flintmax 范围的数字进行计算。该程序提示输入指数
    *n*，然后显示 2^(*n*) 的所有数字，既以数字列表的形式，也以将数字连接起来构建的字符串形式。'
- en: '![Image](../images/pg36_Image_27.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg36_Image_27.jpg)'
- en: '*Figure 1-13: Calculating powers of 2 with extended precision*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-13：使用扩展精度计算 2 的幂*'
- en: The program builds up 2^(*n*) as a list of digits from right to left. The list
    (called `Digits`) starts with just the number 1, which is 2⁰. Then we repeat the
    process of doubling `n` times, calculating the next highest power of 2 by stepping
    through each digit in the list (using the `i` variable) and doubling it ❶. A problem
    comes up for digits with values between 5 and 9, though, which double into two-digit
    numbers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序从右到左构建 2^(*n*) 的数字列表。该列表（称为 `Digits`）以数字 1 开始，即 2⁰。然后，我们重复此过程，进行 `n` 次倍增，通过逐步遍历列表中的每个数字（使用
    `i` 变量）并将其加倍 ❶ 来计算下一个更高的 2 的幂。
- en: To solve this problem, think about how addition works. In particular, consider
    how you’re taught to add multidigit numbers from right to left while keeping track
    of a *carry*. If you wanted to calculate 24 + 18, for example, you would start
    with the ones digit, so you would calculate 4 + 8 = 12, write down 2, and carry
    the 1\. Then you would look at the tens digit; you would calculate 2 + 1 = 3,
    add the carry to get 4, and then report the answer as 42\. The 1 that was carried
    in the first step was actually 10, so it counts as 1 ⋅ 10 when we keep track of
    the groups of 10 counted in the leftmost place.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，可以考虑加法是如何进行的。特别是，考虑到你被教导如何从右到左加多位数，并跟踪*进位*。例如，如果你要计算24 + 18，你会从个位数开始，因此你会计算4
    + 8 = 12，写下2，并进位1。然后，你会查看十位数；你会计算2 + 1 = 3，加上进位得到4，然后报告答案为42。第一步中进位的1实际上是10，因此当我们跟踪最左侧的10的组时，它作为1
    ⋅ 10来计算。
- en: The second nested repeat loop ➋ in [Figure 1-13](ch01.xhtml#ch1fig13) implements
    this carrying logic to limit every number in the list to a single digit. Calculating
    `floor of item i of Digits / 10` gives us `1` if the current number has two digits.
    We add that `1` to the next item in the list (item `i + 1`) to perform the carry,
    then take `item i of Digits mod 10` to limit the current number to just its ones
    digit. Before all this, we add a `0` to the end of the list in case the last item
    needs a carry operation. The `if...then` statement near the end of the program
    removes that `0` if it wasn’t needed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-13](ch01.xhtml#ch1fig13)中的第二个嵌套重复循环➋实现了这个进位逻辑，确保列表中的每个数字只有一个数字。计算`floor
    of item i of Digits / 10`如果当前数字有两位数则给出`1`。我们将该`1`添加到列表中的下一个项目（项目`i + 1`）以执行进位，然后使用`item
    i of Digits mod 10`将当前数字限制为个位数。在所有这些之前，我们在列表的末尾添加一个`0`，以防最后一个项目需要进位操作。程序接近结束时的`if...then`语句会在不需要时去除该`0`。'
- en: Hacking the Code
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: It would be nice to see the answer reported so it looks like a number, not a
    digit-by-digit list. We can do that with the custom `To string` block shown in
    [Figure 1-14](ch01.xhtml#ch1fig14).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能看到报告的答案呈现为一个数字，而不是逐个列出每个数字，那就太好了。我们可以通过在[图1-14](ch01.xhtml#ch1fig14)中展示的自定义`To
    string`模块来实现这一点。
- en: '![Image](../images/pg37_Image_28.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg37_Image_28.jpg)'
- en: '*Figure 1-14: Merging the list of digits into a string*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-14：将数字列表合并成字符串*'
- en: This block joins the items of the list into a string, building it up from right
    to left, so the answer is exhibited in a more readable way.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块将列表中的项目连接成一个字符串，从右到左构建它，因此答案以更易读的方式展示出来。
- en: The Results
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: Try testing the program on a bigger number than Scratch would normally be able
    to represent. For example, [Figure 1-15](ch01.xhtml#ch1fig15) shows a run of the
    program calculating 2^(106), which is flintmax squared.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在比Scratch通常能够表示的更大的数字上测试程序。例如，[图1-15](ch01.xhtml#ch1fig15)展示了计算2^(106)的程序运行结果，这就是flintmax的平方。
- en: '![Image](../images/pg38_Image_29.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg38_Image_29.jpg)'
- en: '*Figure 1-15: Accurately calculating flintmax squared*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-15：精确计算flintmax的平方*'
- en: All 32 digits are reported correctly (after Scratch finishes, you can scroll
    down through the list to see them all). Notice that `Digits` lists the digits
    starting from the ones place.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有32位数字都正确报告（Scratch完成后，你可以滚动查看所有数字）。请注意，`Digits`列出了从个位开始的数字。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**1.6** Modify the power of 2 code in [Figure 1-13](ch01.xhtml#ch1fig13) to
    calculate 3^(53).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.6** 修改[图1-13](ch01.xhtml#ch1fig13)中的2的幂代码来计算3^(53)。'
- en: '**1.7** Modify the power of 2 code in [Figure 1-13](ch01.xhtml#ch1fig13) so
    it works on “digits” that are between 0 and 99,999\. That makes each list entry
    give five digits of the calculated power, allowing Scratch to hold up to one million
    digits.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.7** 修改[图1-13](ch01.xhtml#ch1fig13)中的2的幂代码，使其能够处理介于0和99,999之间的“数字”。这样，每个列表项将提供计算出的幂的五个数字，使得Scratch可以保存最多一百万个数字。'
- en: '**1.8** Program an extended precision addition, where Scratch Cat prompts for
    two large numbers entered as strings, resolves the numbers as lists of digits,
    and then adds the numbers using the same technique as the program in [Figure 1-13](ch01.xhtml#ch1fig13).
    Try to extend the code to handle multiplication as well.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.8** 编写一个扩展精度的加法程序，在其中，Scratch Cat 提示输入两个作为字符串输入的大数字，将这些数字解析为数字列表，然后使用与[图1-13](ch01.xhtml#ch1fig13)中程序相同的技巧进行加法。尝试将代码扩展以处理乘法。'
- en: Conclusion
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: If we understand how Scratch keeps track of numbers, we can be sure to avoid
    generating errors by asking for more than Scratch can give us. This will be especially
    important for integer arithmetic, where we need all the digits of a number to
    correctly manage questions about divisibility and counting.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们理解了Scratch是如何跟踪数字的，就能确保避免通过请求超过Scratch能提供的数字来生成错误。这在整数运算中特别重要，因为我们需要数字的所有位数来正确处理关于可除性和计数的问题。
- en: Scratch’s internal representation of numbers matches that of many modern programming
    languages, so the information in this chapter is widely applicable. Once we know
    the limits, we can figure out how to work around them to get more information
    out of a program than the language could normally provide. That’s the best hack
    of all!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch的内部数字表示与许多现代编程语言一致，因此本章中的信息具有广泛的适用性。一旦我们了解了这些限制，就可以想出绕过它们的方法，从程序中获取更多的信息，而这些信息通常是语言无法提供的。这才是最棒的技巧！
