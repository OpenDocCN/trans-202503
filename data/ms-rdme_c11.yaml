- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Creating Evolvable Architectures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可演化架构
- en: Requirements volatility—changing customer demands—is an unavoidable challenge
    for software projects. Product requirements and context will change over time;
    your application must change as well. But changing requirements can cause instability
    and derail development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 需求波动——客户需求的变化——是软件项目中不可避免的挑战。产品需求和环境会随着时间发生变化；你的应用也必须做出相应的改变。但需求的变化会导致不稳定，并可能使开发偏离轨道。
- en: Managers try to deal with requirements volatility using iterative development
    processes like Agile development (discussed in the next chapter). You can do your
    part to accommodate changing requirements by building *evolvable architectures*.
    Evolvable architectures eschew complexity, the enemy of evolvability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 管理者通过采用迭代开发流程（如敏捷开发，下一章会讨论）来应对需求波动。你可以通过构建*可演化架构*来为适应需求变化做出贡献。可演化架构避免了复杂性——演化的敌人。
- en: This chapter will teach you techniques that can make your software simpler and
    thus easier to evolve. Paradoxically, achieving simplicity in software can be
    difficult; without conscious effort, code will grow tangled and complex. We’ll
    begin by describing complexity and how it leads to rigid and confusing codebases.
    We’ll then show you design principles that reduce complexity. Finally, we’ll translate
    these design principles into concrete API and data layer best practices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你一些可以使软件更简单、从而更易于演化的技巧。矛盾的是，实现软件的简单性可能是困难的；如果没有有意识的努力，代码会变得混乱和复杂。我们将首先描述复杂性及其如何导致僵化和混乱的代码库。然后，我们将展示减少复杂性的设计原则。最后，我们会将这些设计原则转化为具体的API和数据层最佳实践。
- en: Understanding Complexity
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解复杂性
- en: 'In *A Philosophy of Software Design* (Yaknyam Press, 2018), Stanford computer
    science professor John Ousterhout writes, “Complexity is anything related to the
    structure of a system that makes it hard to understand and modify the system.”
    Per Ousterhout, complex systems have two characteristics: high *dependency* and
    high *obscurity*. We add a third: high *inertia*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在《软件设计哲学》（Yaknyam Press，2018年）一书中，斯坦福大学计算机科学教授约翰·奥斯特豪特（John Ousterhout）写道：“复杂性是与系统结构相关的任何因素，使得理解和修改系统变得困难。”根据奥斯特豪特的观点，复杂系统有两个特征：高*依赖性*和高*模糊性*。我们增加了第三个特征：高*惯性*。
- en: High *dependency* leads software to rely on other code’s API or behavior. Dependency
    is obviously unavoidable and even desirable, but a balance must be struck. Every
    new connection and assumption makes code harder to change. High-dependency systems
    are hard to modify because they have *tight coupling* and high *change amplification*.
    Tight coupling describes modules that depend heavily on one another. It leads
    to high change amplification, where a single change requires modifications in
    dependencies as well. Thoughtful API design and a restrained use of abstraction
    will minimize tight coupling and change amplification.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 高*依赖性*使软件依赖于其他代码的API或行为。依赖性显然是不可避免的，甚至是值得追求的，但必须找到一个平衡点。每一个新的连接和假设都会让代码变得更难修改。高依赖性的系统很难修改，因为它们具有*紧密耦合*和高*变更放大*。紧密耦合描述的是模块之间的高度依赖关系，这会导致高变更放大效应，其中一次更改会导致依赖项的修改。精心设计的API和克制使用抽象可以最小化紧密耦合和变更放大。
- en: High *obscurity* makes it difficult for programmers to predict a change’s side
    effects, how code behaves, and where changes need to be made. Obscure code takes
    longer to learn, and developers are more likely to inadvertently break things.
    *God objects*that “know” too much, global state that encourages side effects,
    excessive indirection that obscures code, and *action at distance* that affects
    behavior in distant parts of the program are all symptoms of high obscurity. APIs
    with clear contracts and standard patterns reduce obscurity.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 高*模糊性*使程序员难以预测变更的副作用、代码的行为以及需要修改的地方。模糊的代码学习起来更困难，开发人员更容易无意中破坏东西。*神对象*（拥有过多知识）、鼓励副作用的全局状态、过度间接化导致代码模糊和*远程操作*（影响程序中远距离部分的行为）都是高模糊性的症状。具有清晰契约和标准模式的API可以减少模糊性。
- en: '*Inertia*, the characteristic that we’ve added to Ousterhout’s list, is software’s
    tendency to stay in use. Easily discarded code used for a quick experiment has
    low inertia. A service that powers a dozen business-critical applications has
    high inertia. Complexity’s cost accrues over time, so high-inertia, high-change
    systems should be simplified, while low-inertia or low-change systems can be left
    complex (as long as you discard them or continue to leave them alone).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*惯性*，是我们在Ousterhout列表中新增的特性，是指软件倾向于保持使用状态。用于快速实验的容易被丢弃的代码惯性较低，而支撑多个业务关键应用的服务则具有较高的惯性。复杂度的成本随着时间的推移积累，因此高惯性、高变化的系统应该简化，而低惯性或低变化的系统则可以保持复杂（只要你愿意丢弃它们或继续置之不理）。'
- en: Complexity cannot always be eliminated, but you can choose where to put it.
    Backward-compatible changes (discussed later) might make code simpler to use but
    more complicated to implement. Layers of indirection to decouple subsystems reduce
    dependency but increase obscurity. Be thoughtful about when, where, and how to
    manage complexity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性并不总能被消除，但你可以选择将它放在哪里。向后兼容的变更（稍后讨论）可能会使代码更容易使用，但实现上却更复杂。通过引入间接层来解耦子系统，减少了依赖性，但也增加了模糊性。在管理复杂性时，要深思熟虑地选择何时、何地以及如何进行处理。
- en: Design for Evolvability
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计可演化性
- en: 'Faced with unknown future requirements, engineers usually choose one of two
    tactics: they try to guess what they’ll need in the future, or they build abstractions
    as an escape hatch to make subsequent code changes easier. Don’t play this game;
    both approaches lead to complexity. Keep things simple (known as KISS—*keep it
    simple, stupid*—thanks to the US Navy’s penchant for acronyms and tough love).
    Use the KISS mnemonic to remember to build with simplicity in mind. Simple code
    lets you add complexity later, when the need becomes clear and the change becomes
    unavoidable.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 面对未知的未来需求，工程师通常会选择两种策略中的一种：他们要么试图猜测未来需要什么，要么构建抽象作为逃生舱，使后续的代码更易于修改。不要玩这个游戏；这两种方式都会导致复杂性。保持简单（即KISS——*保持简单，傻瓜*——感谢美国海军对首字母缩略词和“严厉关爱”的偏好）。使用KISS助记符来提醒自己在构建时考虑简洁。简单的代码让你可以在需要变得明确且变化不可避免时，稍后添加复杂性。
- en: The easiest way to keep code simple is to avoid writing it altogether. Tell
    yourself that *you ain’t gonna need it* *(YAGNI**)*. When you do write code, use
    the principle of least astonishment and encapsulation. These design principles
    will keep your code easy to evolve.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 保持代码简单的最简单方法就是完全避免编写它。告诉自己*你不会*需要它*(YAGNI)*。当你编写代码时，使用最小惊讶原则和封装原则。这些设计原则将使你的代码更容易演化。
- en: You Ain’t Gonna Need It
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你*不会*需要它
- en: 'YAGNI is a deceptively simple design practice: don’t build things you don’t
    need. YAGNI violations happen when developers get excited, fixated, or worried
    about some aspect of their code. It’s difficult to predict what you’ll need and
    what you won’t. Every wrong guess is wasted effort. After the initial waste, the
    code continues to bog things down, it needs to be maintained, developers need
    to understand it, and it must be built and tested.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: YAGNI是一种看似简单的设计实践：不要构建你不需要的东西。YAGNI违规发生在开发人员变得过于激动、执着或担心某些代码细节时。很难预测你会需要什么，什么又是不需要的。每一个错误的猜测都是浪费的努力。在初始的浪费之后，代码继续拖慢进展，它需要被维护，开发人员需要理解它，且必须构建并进行测试。
- en: Luckily, there are a few habits you can build to avoid unnecessary development.
    Avoid premature optimization, unnecessarily flexible abstractions, and product
    features that aren’t needed for a *minimum viable product* *(MVP**)*—the bare-minimum
    feature set that you need to get user feedback.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以培养一些习惯来避免不必要的开发。避免过早优化、不必要的灵活抽象，以及对*最小可行产品*（*MVP*）——你为了获取用户反馈所需的最低功能集——不必要的产品特性。
- en: '*Premature optimization* occurs when a developer adds a performance optimization
    to code before it’s proven to be needed. In the classic scenario, a developer
    sees an area of code that could be made faster or more scalable by adding complex
    logic and architectural layers such as caches, sharded databases, or queues. The
    developer optimizes the code before it’s been shipped, before anyone has used
    it. After shipping the code, the developer discovers that the optimization was
    not needed. Removing optimization never happens, and complexity accrues. Most
    performance and scalability improvements come with a high complexity cost. For
    example, a cache is fast, but it can also become inconsistent with underlying
    data.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*过早优化*发生在开发者在代码未证明需要优化之前就添加了性能优化。在经典场景中，开发者看到某段代码可以通过添加复杂的逻辑和架构层（如缓存、分片数据库或队列）来加快速度或提高可扩展性。开发者在代码发布前进行了优化，在代码发布之前没人使用过它。发布代码后，开发者发现这个优化其实并不需要。优化很少会被移除，复杂性不断增加。大多数性能和可扩展性改进都伴随着高复杂性的代价。例如，缓存虽然很快，但也可能与底层数据不一致。'
- en: 'Flexible abstractions—plugin architectures, wrapper interfaces, and generic
    data structures like key-value pairs—are another temptation. Developers think
    they can easily adjust if some new requirement pops up. But abstraction comes
    with a cost; it boxes implementations into rigid boundaries that the developer
    ends up fighting later. Flexibility also makes code harder to read and understand.
    Take this distributed queuing interface:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活的抽象——插件架构、包装接口以及像键值对这样的通用数据结构——是另一种诱惑。开发者认为如果出现新的需求，他们可以轻松调整。但抽象是有代价的；它将实现封装在僵化的边界中，开发者最终会为此而苦恼。灵活性还使得代码更难以阅读和理解。以这个分布式队列接口为例：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`IDistributedQueue` looks simple enough: you send and receive messages. But
    what if the underlying queue supports both keys and values for a message (as Apache
    Kafka does) or message ACKing (as Amazon’s Simple Queue Service does)? Developers
    are faced with a choice: Should the interface be the union of all features from
    all message queues or the intersection of all features? The union of all features
    produces an interface where no single implementation works for all methods. The
    intersection of all features leads to a limited interface that doesn’t have enough
    features to be useful. You’re better off directly using an implementation. You
    can refactor later if you decide you need to support another implementation.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDistributedQueue` 看起来很简单：你发送和接收消息。但如果底层队列支持消息的键和值（就像 Apache Kafka 所做的那样）或消息确认（就像
    Amazon 的简单队列服务所做的那样）怎么办？开发者面临一个选择：接口应该是所有消息队列特性的并集，还是所有特性的交集？所有特性的并集会产生一个接口，使得没有任何单一实现适用于所有方法。所有特性的交集则会导致一个有限的接口，它没有足够的功能来发挥作用。直接使用某个实现会更好。如果你决定以后需要支持另一种实现，再进行重构也不迟。'
- en: The best way to keep your code flexible is to simply have less of it. For everything
    you build, ask yourself what is absolutely necessary, and throw away the rest.
    This technique—called *Muntzing*—will keep your software trim and adaptable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 保持代码灵活的最佳方法就是简单地减少代码量。对于你构建的每一项内容，问问自己什么是绝对必要的，其余的就抛弃掉。这种方法——叫做 *Muntzing*——能保持你的软件精简且具有适应性。
- en: 'Adding cool new product features is also tempting. Developers talk themselves
    into the cool-feature pitfall for a variety of reasons: they mistake their usage
    for what most users want, they think it’ll be easy to add, or they think it’ll
    be neat! Each new feature takes time to build and maintain, and you don’t know
    if the feature will actually be useful.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 添加酷炫的新产品特性也是一种诱惑。开发者因各种原因陷入酷炫特性的陷阱：他们把自己的使用误认为是大多数用户的需求，认为添加特性很容易，或者觉得它很酷！每个新特性都需要时间来构建和维护，而且你无法确定它是否真的有用。
- en: Building an MVP will keep you honest about what you really need. MVPs allow
    you to test an idea without investing in a full-fledged implementation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个MVP能让你对自己真正需要的东西保持清醒。MVP 让你在不投入完整实现的情况下测试一个想法。
- en: There are, of course, caveats to YAGNI. As your experience grows, you’ll get
    better at predicting when flexibility and optimization are necessary. In the meantime,
    place interface shims where you suspect optimizations can be inserted, but don’t
    actually implement them. For example, if you are creating a new file format and
    suspect you’ll need compression or encryption later, provide a header that specifies
    the encoding, but only implement the uncompressed encoding. You can add compression
    in the future, and the header will make it easy for new code to read older files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，YAGNI（你不需要它）也有一些警告。随着经验的积累，你会更好地预测什么时候需要灵活性和优化。与此同时，在你怀疑可能需要插入优化的地方放置接口适配器，但不要实际实现它们。例如，如果你正在创建一个新的文件格式，并且怀疑以后可能需要压缩或加密，可以提供一个指定编码的头部，但只实现未压缩的编码。以后可以添加压缩功能，而头部会使得新代码能够轻松读取旧文件。
- en: Principle of Least Astonishment
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小惊讶原则
- en: 'The *principle of least astonishment* is pretty clear: don’t surprise users.
    Build features that behave as users first expect. Features with a high learning
    curve or strange behavior frustrate users. Similarly, don’t surprise developers.
    Surprising code is obscure, which causes complexity. You can eliminate surprises
    by keeping code specific, avoiding implicit knowledge, and using standard libraries
    and patterns.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*最小惊讶原则*非常明确：不要让用户感到惊讶。构建行为符合用户预期的功能。具有高学习曲线或奇怪行为的功能会让用户感到沮丧。同样，不要让开发者感到惊讶。令人惊讶的代码是晦涩的，增加了复杂性。通过保持代码的具体性，避免隐性知识，并使用标准库和模式，可以消除惊讶。'
- en: Anything nonobvious that a developer needs to know to use an API and is not
    part of the API itself is considered *implicit knowledge*. APIs that require implicit
    knowledge will surprise developers, causing bugs and a high learning curve. Two
    common implicit knowledge violations are hidden ordering requirements and hidden
    argument requirements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 任何开发者需要知道的，并且不是API本身一部分的非显性信息，都被认为是*隐性知识*。需要隐性知识的API会让开发者感到惊讶，从而导致错误和较高的学习曲线。两种常见的隐性知识违规情况是隐藏的排序要求和隐藏的参数要求。
- en: '*Ordering requirements* dictate that actions take place in a specific sequence.
    Method ordering is a frequent violation: method A must be called before method
    B, but the API allows method B to be called first, surprising the developer with
    a runtime error. Documenting an ordering requirement is good, but it’s better
    not to have one in the first place. Avoid method ordering by having methods invoke
    submethods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*排序要求*规定了操作必须按照特定的顺序进行。方法排序是常见的违反规则：方法A必须在方法B之前调用，但API却允许先调用方法B，从而在运行时让开发者感到意外并出现错误。记录排序要求是有益的，但最好一开始就不要有这种要求。通过让方法调用子方法来避免方法排序：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are other approaches to avoiding ordering: combining the methods into
    one, using the *builder pattern*, using the type system and having `pontoonWorples`
    work only on `FlubberizedWorples` rather than all `Worples`, and so on. All of
    these are better than requiring your user to know about hidden requirements. If
    nothing else, you can at least make the method name give developers a heads-up
    by calling it `pontoonFlubberizedWorples()`. Counterintuitively, short method
    and variable names actually increase cognitive load. Specific, longer method names
    are more descriptive and easier to understand.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他避免排序的方法：将方法合并为一个，使用*构建者模式*，使用类型系统，并让`pontoonWorples`只作用于`FlubberizedWorples`而不是所有的`Worples`，等等。所有这些方法都比要求用户了解隐藏的要求要好。如果没有其他办法，至少你可以通过命名方法为`pontoonFlubberizedWorples()`来让开发者提前意识到。与直觉相反，短的函数和变量名实际上增加了认知负担。更具体、更长的函数名更具描述性，更容易理解。
- en: '*Hidden argument requirements* occur when a method signature implies a wider
    range of valid inputs than the method actually accepts. For example, accepting
    an `int` while only allowing numbers 1 to 10 is a hidden constraint. Requiring
    that a certain value field is set in a plain JSON object is also requiring implicit
    knowledge on the part of the user. Make argument requirements specific and visible.
    Use specific types that accurately capture your constraints; when using flexible
    types like JSON, consider using JSON Schema to describe the expected object. At
    the least, advertise argument requirements in documentation when they can’t be
    made programmatically visible.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐含的参数要求*发生在方法签名暗示了一个比方法实际接受的更广泛的有效输入范围。例如，接受一个`int`类型却只允许1到10之间的数字，这是一个隐含的约束。要求在普通的JSON对象中设置某个字段值，也是在要求用户具备隐含的知识。让参数要求变得具体和可见。使用具体的类型来准确捕捉你的约束；在使用像JSON这样的灵活类型时，考虑使用JSON
    Schema来描述预期的对象。至少，在文档中宣传参数要求，特别是当它们不能通过编程方式可见时。'
- en: 'Finally, use standard libraries and development patterns. Implementing your
    own square root method is surprising; using a language’s built-in `sqrt()` method
    is not. The same rule applies for development patterns: use idiomatic code style
    and development patterns.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用标准库和开发模式。实现你自己的平方根方法很惊人；使用语言内置的`sqrt()`方法则不然。同样的规则适用于开发模式：使用地道的代码风格和开发模式。
- en: Encapsulate Domain Knowledge
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 封装领域知识
- en: Software changes as business requirements change. Encapsulate domain knowledge
    by grouping software based on business domain—accounting, billing, shipping, and
    so on. Mapping software components to business domains will keep code changes
    focused and clean.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着业务需求的变化，软件也会变化。通过按业务领域（如会计、账单、运输等）分组软件来封装领域知识。将软件组件映射到业务领域，将有助于保持代码变更的集中和简洁。
- en: Encapsulated domains naturally gravitate toward *high cohesion* and *low coupling*—desirable
    traits. Highly cohesive software with low coupling is more evolvable because changes
    tend to have a smaller “blast radius.” Code is highly *cohesive* when methods,
    variables, and classes that relate to one another are near each other in modules
    or packages. *Decoupled* code is self-contained; a change to its logic does not
    require changes to other software components.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的领域自然趋向于*高内聚*和*低耦合*——这些是理想的特性。具有高内聚和低耦合的软件更具可演化性，因为变更的影响范围通常较小。当方法、变量和类相互关联并在模块或包中靠近时，代码就具有很高的*内聚性*。*解耦*的代码是自包含的；其逻辑变更不需要修改其他软件组件。
- en: 'Developers often think about software in terms of layers: frontend, middle
    tier, and backend. Layered code is grouped according to technical domain, with
    all the UI code in one place and all object persistence in another. Grouping code
    by technical domain works great within a single business domain but grows messy
    as businesses grow. Separate teams form around each tier, increasing coordination
    cost since every business logic change slices through all tiers. And shared horizontal
    layers make it too easy for developers to mix business logic between domains,
    leading to complex code.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者常常将软件视为多个层次：前端、中间层和后端。分层的代码按照技术领域进行分组，所有UI代码集中在一个地方，所有对象持久化代码集中在另一个地方。按技术领域分组代码在单一业务领域内非常有效，但随着业务的扩展，这种方式会变得混乱。围绕每一层形成的独立团队会增加协调成本，因为每次业务逻辑的变更都会影响到所有层次。而共享的横向层次则让开发者在不同领域间混淆业务逻辑，导致复杂的代码。
- en: Identifying domain boundaries and encapsulating domain knowledge is as much
    art as science. There is an entire architectural approach called *Domain-Driven
    Design* *(DDD**)*, which defines an extensive set of concepts and practices to
    map business concepts to software. Full-blown DDD is necessary only for the most
    complex situations. Still, familiarizing yourself with DDD will help you make
    better design decisions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 确定领域边界并封装领域知识既是一门艺术，也是一门科学。有一种叫做*领域驱动设计*(DDD*)的架构方法，它定义了一整套概念和实践，用于将业务概念映射到软件中。只有在最复杂的情况中，才需要全面实施DDD。不过，熟悉DDD将有助于你做出更好的设计决策。
- en: Evolvable APIs
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可演化的API
- en: As requirements change, you’ll need to change your APIs, the shared interfaces
    between code. Changing an API is easy to do, but it’s hard to do right. Many small,
    rational changes can lead to a sprawling mess. Worse, a minor API change can completely
    break compatibility. If an API changes in an incompatible way, clients will break;
    these breakages may not be immediately obvious, especially changes that break
    at runtime, not during compilation. APIs that are small, clearly defined, compatible,
    and versioned will be easier to use and evolve.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 随着需求的变化，你需要更改你的 API，即代码之间共享的接口。更改 API 很容易做到，但要做到正确却很难。许多小而合理的变更可能导致一团糟。更糟糕的是，微小的
    API 更改可能完全破坏兼容性。如果 API 发生不兼容的更改，客户端将无法正常工作；这些故障可能不会立即显现，特别是那些在运行时发生的更改，而不是在编译时发生的更改。小而清晰、兼容且版本化的
    API 会更容易使用和演进。
- en: Keep APIs Small
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持 API 小巧
- en: Small APIs are easier to understand and evolve. Larger APIs put more cognitive
    load on developers, and you’ll have more code to document, support, debug, and
    maintain. Every new method or field grows the API and locks you further into a
    specific usage pattern.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 小型 API 更容易理解和演进。大型 API 会增加开发者的认知负担，并且你需要为更多代码编写文档、提供支持、调试和维护。每新增一个方法或字段，就会增加
    API 的复杂度，并将你锁定在特定的使用模式中。
- en: 'Apply the YAGNI philosophy: only add API methods or fields that are immediately
    needed. When creating an API data model, only add methods you need at the time.
    When bootstrapping your API using a framework or generator tool, eliminate fields
    or methods you’re not using.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 YAGNI（你不需要的东西）哲学：只添加当前需要的 API 方法或字段。在创建 API 数据模型时，只添加你当时需要的方法。当使用框架或生成工具启动
    API 时，删除你不使用的字段或方法。
- en: API methods with a lot of fields should have sensible defaults. Developers can
    focus on relevant fields knowing they’ll inherit defaults for the others. Defaults
    make large APIs feel small.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有大量字段的 API 方法应该有合理的默认值。开发者可以专注于相关字段，因为他们知道其他字段会继承默认值。默认值让大型 API 感觉更小巧。
- en: Expose Well-Defined Service APIs
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 曝露定义良好的服务 API
- en: Evolvable systems have clearly defined request and response schemas that are
    versioned and have clear compatibility contracts. Schema definitions should be
    published so they can be used to automatically test both client and server code
    (see “Package Different Resources Separately” in Chapter 8 for more).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可演进的系统具有清晰定义的请求和响应模式，这些模式是版本化的，并且具有明确的兼容性契约。模式定义应当公开，以便可以用来自动测试客户端和服务器代码（更多信息请参见第
    8 章中的“分别打包不同资源”）。
- en: Use standard tools to define service APIs. A well-defined service will declare
    its schemas, request and response methods, and exceptions. OpenAPI is commonly
    used for RESTful services, while non-REST services use Protocol Buffers, Thrift,
    or a similar *interface definition language* *(IDL**)*. Well-defined service APIs
    make compile-time validation easier and keep clients, servers, and documentation
    in sync.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准工具来定义服务 API。定义良好的服务将声明其模式、请求和响应方法以及异常。OpenAPI 通常用于 RESTful 服务，而非 REST 服务则使用
    Protocol Buffers、Thrift 或类似的*接口定义语言*（*IDL*）。定义良好的服务 API 可以简化编译时验证，并保持客户端、服务器和文档的一致性。
- en: Interface definition tools come with code generators that convert service definitions
    to client and server code. Documentation can also be generated, and test tools
    can use IDLs to generate stubs and mock data. Some tools even have discoverability
    features to find services, learn who maintains them, and show how the service
    is used.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义工具配有代码生成器，可将服务定义转换为客户端和服务器代码。文档也可以生成，测试工具可以使用 IDL 来生成存根和模拟数据。有些工具甚至具有可发现性功能，用于查找服务，了解谁在维护它们，并展示如何使用该服务。
- en: Use your company’s API definition framework if they’ve already chosen one; choosing
    a “better” one will require too much interoperability work. If your company still
    hand-rolls REST APIs and the JSON interfaces are evolved in code without a formal
    spec, your best bet is OpenAPI, as it can be retrofitted on preexisting REST services
    and does not require major migrations to adopt.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果公司已经选择了某个 API 定义框架，使用该框架。如果选择一个“更好”的框架将需要大量的互操作性工作。如果公司仍在手动编写 REST API，而 JSON
    接口在没有正式规范的情况下在代码中演进，最佳选择是 OpenAPI，因为它可以适配现有的 REST 服务，并且采用时不需要进行大规模迁移。
- en: Keep API Changes Compatible
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持 API 变更兼容
- en: 'Keeping API changes compatible lets client and server versions evolve independently.
    There are two forms of compatibility to consider: forward and backward.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 API 变更的兼容性可以让客户端和服务器版本独立演进。有两种兼容性需要考虑：前向兼容和向后兼容。
- en: '*Forward-compatible* changes allow clients to use a new version of an API when
    invoking an older service version. A web service that’s running version 1.0 of
    an API but can receive calls from a client using version 1.1 of the API is forward
    compatible.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*向前兼容* 的更改允许客户端在调用旧版服务时使用新版本的 API。一个运行着 1.0 版本 API 的 Web 服务，如果能够接收来自使用 1.1
    版本 API 的客户端的调用，则是向前兼容的。'
- en: '*Backward-compatible* changes are the opposite: new versions of the library
    or service do not require changes in older client code. A change is backward compatible
    if code developed against version 1.0 of an API continues to compile and run when
    used with version 1.1.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*向后兼容* 的更改正好相反：库或服务的新版本不需要对旧的客户端代码进行修改。如果基于版本 1.0 的 API 开发的代码仍然可以在使用版本 1.1
    时编译和运行，那么这个更改就是向后兼容的。'
- en: 'Let’s take a look at a simple gRPC Hello World service API defined with Protocol
    Buffers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的使用 Protocol Buffers 定义的 gRPC Hello World 服务 API：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Greeter` service has one method, called `SayHello`, which receives a `HelloRequest`
    and returns a `HelloReply` with a fun message about `favorite_number`. The numbers
    next to each field are *field ordinals*; Protocol Buffers internally refer to
    fields using numbers rather than strings.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greeter` 服务有一个方法，名为 `SayHello`，它接收一个 `HelloRequest` 并返回一个包含 `favorite_number`
    的有趣消息的 `HelloReply`。每个字段旁边的数字是*字段序号*；Protocol Buffers 在内部通过数字而非字符串来引用字段。'
- en: 'Suppose we decide to send our greeting over email. We’d need to add an email
    field:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定通过电子邮件发送问候语。我们需要添加一个电子邮件字段：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a *backward-incompatible* change because old clients don’t supply an
    email. When a client invokes the new `SayHello` with the old `HelloRequest`, the
    email will be missing, so the service can’t parse the request. Removing the `required`
    keyword and skipping emails when no address is supplied will maintain backward
    compatibility.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*向后不兼容*的更改，因为旧客户端不提供电子邮件。当客户端使用旧版 `HelloRequest` 调用新版的 `SayHello` 时，电子邮件将缺失，因此服务无法解析请求。移除
    `required` 关键字并在未提供地址时跳过电子邮件将保持向后兼容性。
- en: Required fields are such an evolvability problem that they were removed from
    Protocol Buffers v3\. Kenton Varda, the primary author of Protocol Buffers v2,
    said, “The ‘required’ keyword in Protocol Buffers turned out to be a horrible
    mistake” ([https://capnproto.org/faq.html#how-do-i-make-a-field-required-like-in-protocol-buffers](https://capnproto.org/faq.html#how-do-i-make-a-field-required-like-in-protocol-buffers)).
    Many other systems have required fields, so be careful, and remember, “Required
    is forever.”
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`required` 字段是一个可演化性问题，因此在 Protocol Buffers v3 中被移除。Protocol Buffers v2 的主要作者
    Kenton Varda 说：“Protocol Buffers 中的 `required` 关键字证明是一个可怕的错误” ([https://capnproto.org/faq.html#how-do-i-make-a-field-required-like-in-protocol-buffers](https://capnproto.org/faq.html#how-do-i-make-a-field-required-like-in-protocol-buffers))。许多其他系统有必填字段，因此需要小心，记住，“`required`
    是永远有效的”。'
- en: 'We can create a *forward-incompatible* change by tweaking `HelloRequest`. Perhaps
    we want to accommodate negative favorite numbers. The Protocol Buffer documentation
    reads, “If your field is likely to have negative values, use `sint32` instead,”
    so we change the type of `favorite_number` accordingly:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调整 `HelloRequest` 来创建一个*向前不兼容*的更改。也许我们想要支持负数的最喜欢数字。Protocol Buffers 文档写道：“如果你的字段可能包含负值，请使用
    `sint32`，”因此我们相应地更改了 `favorite_number` 的类型：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Changing `int32` to `sint32` is both backward and forward incompatible. A client
    with the new `HelloRequest` will encode `favorite_number` using a different serialization
    scheme than an old version of `Greeter`, so the service will fail to parse it;
    and the new version of `Greeter` will fail to parse messages from old clients!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `int32` 改为 `sint32` 是既向后又向前不兼容的。使用新 `HelloRequest` 的客户端将使用与旧版 `Greeter` 不同的序列化方案对
    `favorite_number` 进行编码，因此服务将无法解析；而新版的 `Greeter` 也将无法解析来自旧客户端的消息！
- en: The `sint32` change can be made forward compatible by adding a new field. Protocol
    Buffers let us rename fields as long as the field number remains the same.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`sint32` 的更改可以通过添加新字段来实现向前兼容。Protocol Buffers 允许我们重命名字段，只要字段编号保持不变。'
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The server code needs to handle both fields for as long as the old clients are
    supported. Once rolled out, we can monitor how often clients use the deprecated
    field and clean up once clients upgrade or a deprecation schedule expires.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器代码需要处理两个字段，直到旧客户端被支持为止。推出后，我们可以监控客户端使用弃用字段的频率，并在客户端升级或弃用计划到期后进行清理。
- en: 'Our example uses Protocol Buffers because they have a strongly typed system,
    and type compatibility is more straightforward to demonstrate and reason about.
    The same problems occur in other contexts, including “simple” REST services. When
    client and server content expectations diverge, errors crop up no matter what
    format you’re using. Moreover, it’s not just the message fields you need to worry
    about: a change in *semantics* of the message, or the logic of what happens when
    certain events transpire, can also be backward or forward incompatible.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例使用了协议缓冲（Protocol Buffers），因为它们有强类型系统，并且类型兼容性更容易展示和推理。在其他环境中也会出现相同的问题，包括“简单”的REST服务。当客户端和服务器的内容期望出现分歧时，无论你使用什么格式，错误都会出现。此外，不仅仅是消息字段需要关注：消息的*语义*变化，或者在某些事件发生时的逻辑变化，也可能导致向后或向前的不兼容。
- en: Version APIs
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本API
- en: As APIs evolve over time, you will need to decide how to handle compatibility
    across multiple versions. Fully backward- and forward-compatible changes interoperate
    with all previous and future versions of an API; this can be hard to maintain,
    creating *cruft* like the logic for dealing with deprecated fields. Less stringent
    compatibility guarantees allow for more radical changes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着API随着时间演变，你需要决定如何处理多个版本之间的兼容性。完全向后兼容和向前兼容的更改可以与API的所有先前版本和未来版本互操作；但是，这种方式很难维护，可能会产生像处理已弃用字段的逻辑这样的*杂乱*。不那么严格的兼容性保证允许更激进的更改。
- en: Eventually, you’ll want to change your API in a way that isn’t compatible with
    old clients—requiring a new field, for example. Versioning your APIs means you
    introduce a new version when changes are made. Old clients can continue using
    the old API version. Tracking versions also helps you communicate with your customers—they
    can tell you what version they’re using, and you can market new features with
    a new version.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你可能会需要以不兼容旧客户端的方式更改你的API——例如，增加一个新字段。版本控制API意味着在做出更改时会引入新版本。旧客户端可以继续使用旧版本的API。追踪版本也有助于与客户沟通——他们可以告诉你正在使用哪个版本，而你可以通过新版本来推广新特性。
- en: 'API versions are usually managed with an API gateway or a service mesh. Versioned
    requests are routed to the appropriate service: a v2 request will be routed to
    a v2.X.X service instance, while a v3 request will be routed to a v3.X.X service
    instance. Absent a gateway, clients invoke RPC calls directly to version-specific
    service hosts, or a single service instance runs multiple versions internally.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: API版本通常通过API网关或服务网格进行管理。版本化请求会被路由到适当的服务：一个v2请求将被路由到v2.X.X服务实例，而v3请求将被路由到v3.X.X服务实例。如果没有网关，客户端会直接调用指定版本的RPC服务，或者一个服务实例内部运行多个版本。
- en: API versioning comes with a cost. Older major versions of the service need to
    be maintained, and bug fixes need to be backported to prior versions. Developers
    need to keep track of which versions support which features. Lack of version management
    tooling can push version management on to engineers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: API版本控制是有成本的。服务的较旧主要版本需要维护，且需要将修复的bug回传到先前版本。开发人员需要跟踪哪些版本支持哪些特性。缺乏版本管理工具可能会将版本管理的工作推给工程师。
- en: Be pragmatic about versioning methodologies. Semantic versioning, discussed
    in Chapter 5, is a common API versioning scheme, but many companies version APIs
    using dates or other numeric schemes. Version numbers can be specified in URI
    paths, query parameters, or HTTP Accept headers, or using a myriad of other techniques.
    There are trade-offs between all of these approaches, and a lot of strong opinions.
    Defer to whatever the standard is at your company; if there isn’t one, ask your
    manager and tech leads for their thoughts on what’s best.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本控制方法上要务实。语义化版本控制（在第五章讨论过）是一种常见的API版本管理方案，但许多公司使用日期或其他数字方案来进行API版本控制。版本号可以在URI路径、查询参数、HTTP
    Accept头中指定，或者使用其他各种技术。这些方法之间存在权衡，也有很多不同的强烈观点。请遵循公司标准；如果没有标准，可以向经理和技术负责人询问他们对最佳实践的看法。
- en: Keep documentation versioned along with your APIs. Developers dealing with older
    versions of your code need accurate documentation. It’s really confusing for users
    to reference a different version of the documentation and discover that the API
    they’re using doesn’t match up. Committing API documentation in the main code
    repository helps to keep documentation and code in sync. Pull requests for code
    can update documentation as they change APIs and behavior.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 保持文档版本与您的API一起更新。处理旧版本代码的开发者需要准确的文档。对于用户来说，引用不同版本的文档并发现他们使用的API不匹配，确实会感到困惑。在主代码库中提交API文档有助于保持文档和代码的同步。代码的拉取请求可以在更改API和行为时更新文档。
- en: API versioning is most valuable when client code is hard to change. You’ll usually
    have the least control over external (customer) clients, so customer-facing APIs
    are the most important to version. If your team controls both the service and
    client, you might be able to get away without internal API versioning.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端代码难以更改时，API版本控制最为重要。你通常对外部（客户）客户端的控制最少，因此面向客户的API最需要版本控制。如果你的团队同时控制服务端和客户端，可能可以在内部API中省略版本控制。
- en: Evolvable Data
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可演化数据
- en: APIs are more ephemeral than persisted data; once the client and server APIs
    are upgraded, the work is done. Data must be evolved as applications change. Data
    evolution runs the gamut from simple schema changes such as adding or removing
    a column to rewriting records with new schemas, fixing corruption, rewriting to
    match new business logic, and massive migrations from one database to another.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: API比持久化数据更为短暂；一旦客户端和服务器的API升级完毕，工作就完成了。数据必须随着应用程序的变化而演化。数据演化的范围从简单的模式更改（如添加或删除列）到重写记录以适应新模式、修复损坏、重写以匹配新业务逻辑，以及从一个数据库迁移到另一个数据库的大规模迁移。
- en: Isolating databases and using explicit schemas will make data evolution more
    manageable. With an isolated database, you need only worry about the impact of
    a change on your own application. Schemas protect you from reading or writing
    malformed data, and automated schema migrations make schema changes predictable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离数据库并使用明确的模式将使数据演化更加可控。通过使用隔离的数据库，你只需要关注变更对自己应用程序的影响。模式可以保护你免于读取或写入格式不正确的数据，自动化的模式迁移使得模式变化变得可预测。
- en: Isolate Databases
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离数据库
- en: Shared databases are difficult to evolve and will result in a loss of *autonomy*—a
    developer’s or team’s ability to make independent changes to the system. You will
    not be able to safely modify schemas, or even read and write, without worrying
    about how everyone is using your database. The architecture grows brittle as schemas
    become an unofficial, deeply entrenched API. Separate application databases make
    changes easier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 共享数据库很难演化，会导致*自治性*的丧失——即开发者或团队独立修改系统的能力。你将无法安全地修改架构，甚至无法读写数据，而不必担心其他人如何使用你的数据库。随着架构的演化，模式会成为一个非正式且根深蒂固的API，架构变得脆弱。分离的应用程序数据库让修改变得更容易。
- en: Isolated databases are accessed by only a single application, while shared databases
    are accessed by more than one (see [Figure 11-1](#figure11-1)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离的数据库仅由单个应用程序访问，而共享数据库则由多个应用程序访问（见[图11-1](#figure11-1)）。
- en: '![f11001](image_fi/501836c11/f11001.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![f11001](image_fi/501836c11/f11001.png)'
- en: 'Figure 11-1: Shared databases'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1：共享数据库
- en: Shared databases present several problems. Applications with shared databases
    can grow to depend directly on each other’s data. Applications act as a control
    point for the underlying data they serve. You can’t apply business logic on your
    raw data before serving it, and you can’t easily redirect queries to a new data
    store during a migration if queries bypass your application. If there are multiple
    applications writing, the meaning (*semantics*) of the data might diverge, making
    it harder for readers to reason about. Application data is not protected, so other
    applications might mutate it in unexpected ways. Schemas aren’t isolated; a change
    in one application’s schema can impact others. Nor is performance isolated, so
    if an application overwhelms the database, all other applications will be affected.
    In some cases, security boundaries might be violated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 共享数据库存在几个问题。具有共享数据库的应用程序可能会直接依赖于彼此的数据。应用程序充当它们服务的基础数据的控制点。在提供数据之前，您无法在原始数据上应用业务逻辑，也无法在迁移期间轻松重定向查询，如果查询绕过您的应用程序的话。如果有多个应用程序进行写入，数据的语义可能会发散，使读者更难以理解。应用程序数据没有受到保护，因此其他应用程序可能会以意外的方式对其进行更改。模式不是隔离的；一个应用程序模式的更改可能会影响其他应用程序。性能也不是隔离的，因此如果一个应用程序压倒性地影响了数据库，所有其他应用程序都会受到影响。在某些情况下，安全边界可能会被违反。
- en: By contrast, isolated databases have just a single reader and writer (see [Figure
    11-2](#figure11-2)). All other traffic goes through remote procedural calls.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，隔离的数据库只有一个读取者和写入者（见[图 11-2](#figure11-2)）。所有其他流量都通过远程过程调用进行。
- en: '![f11002](image_fi/501836c11/f11002.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![f11002](image_fi/501836c11/f11002.png)'
- en: 'Figure 11-2: Isolated databases'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2：隔离的数据库
- en: Isolated databases afford you all of the flexibility and isolation that shared
    databases do not. You need only worry about your own application when making database
    schema changes, and database performance is governed by your usage.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离的数据库为您提供了共享数据库所不具备的所有灵活性和隔离性。在进行数据库模式更改时，您只需关注自己的应用程序，并且数据库性能由您的使用情况管理。
- en: There are occasional cases where a shared database is valuable. When breaking
    a monolith up, sharing a database serves as a useful intermediate step before
    data has been migrated to a new isolated database. Managing many databases comes
    at a high operational cost. Early on, it might make sense to co-locate many databases
    on the same machines. But make sure any shared databases eventually get isolated
    and split up or replaced.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔有些情况下，共享数据库是有价值的。在拆分单体应用程序时，共享数据库可以作为在数据迁移到新的隔离数据库之前的有用中间步骤。管理多个数据库的操作成本高昂。早期可能有理由将许多数据库放置在同一台机器上。但请确保任何共享数据库最终都得到隔离、拆分或替换。
- en: Use Schemas
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模式
- en: Rigid predefined columns and types, and the heavyweight processes for evolving
    them, have led to the emergence of popular *schemaless* data management. Most
    modern datastores support storing JSON or JSON-like objects without predeclaring
    its structure. Schemaless doesn’t literally mean “no schema” (data would be unusable);
    rather, schemaless data has an implicit schema that is supplied or inferred at
    read time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的刚性列和类型以及演变它们的繁重过程，导致了流行的*无模式*数据管理的出现。大多数现代数据存储支持存储 JSON 或类 JSON 对象，而无需预先声明其结构。无模式并不字面意味着“无模式”（数据将无法使用）；相反，无模式数据在读取时具有隐式模式，该模式在读取时提供或推断。
- en: In practice, we’ve found that a schemaless approach has significant data integrity
    and complexity problems. A strongly typed schema-forward approach decreases the
    obscurity, and therefore complexity, of your application. The short-term simplicity
    is not usually worth the obscurity trade-off. Like code itself, data is sometimes
    described as “write once, read many”; use schemas to make reads easier.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们发现无模式方法存在重要的数据完整性和复杂性问题。强类型模式推进方法减少了应用程序的晦涩度和复杂性。短期内的简单通常不值得为了晦涩性的权衡。像代码本身一样，数据有时被描述为“写一次，多次读取”；使用模式使读取更容易。
- en: 'You’d think not having a schema would make a change easier: you simply start
    or stop writing fields as you need to evolve data. Schemaless data actually makes
    changes harder because you don’t know what you’re breaking as you evolve your
    data. Data quickly becomes an unintelligible hodgepodge of different record types.
    Developers, business analysts, and data scientists struggle to keep up. It’s going
    to be a tough day for the data scientist that wants to parse this JSON data:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为没有模式会使更改更容易：你只需根据需要开始或停止写入字段，以便数据得以演变。然而，无模式的数据实际上会使更改变得更加困难，因为你不知道在演变数据时会破坏什么。数据很快变得不成形，各种记录类型杂乱无章。开发人员、业务分析师和数据科学家都很难跟上进度。对于想要解析这些
    JSON 数据的数据科学家来说，今天会是艰难的一天：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Defining explicit schemas for your data will keep your application stable and
    make your data usable. Explicit schemas let you sanity-check data as it is written.
    Parsing data using explicit schemas is usually faster, too. Schemas also help
    you detect when forward- and backward-incompatible changes are made. Data scientists
    know what to expect with data in the following table.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的数据模式定义将使你的应用程序保持稳定，并使数据更易于使用。显式模式可以在数据写入时对其进行合理性检查。使用显式模式解析数据通常也更快。模式还有助于你发现前向和后向不兼容的更改。数据科学家可以根据下表预期数据的内容。
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The rigidity of explicit schemas also carries a cost: they can be difficult
    to change. This is by design. Schemas force you to slow down and think through
    how existing data is going to be migrated and how downstream users will be affected.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 显式模式的刚性也有其成本：它们可能很难更改。这是有意为之的。模式迫使你放慢速度，仔细思考现有数据将如何迁移，以及下游用户将如何受到影响。
- en: Don’t hide schemaless data inside schematized data. It’s tempting to be lazy
    and stuff a JSON string into a field called “data” or define a map of strings
    to contain arbitrary key-value pairs. Hiding schemaless data is self-defeating;
    you get all of the pain of explicit schemas but none of the gain.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将无模式数据隐藏在有模式的数据中。虽然很有诱惑力去懒惰地把一个 JSON 字符串放入一个名为“data”的字段中，或者定义一个字符串到任意键值对的映射，但隐藏无模式数据是自我失败的；你将面临显式模式的所有痛苦，却没有获得任何好处。
- en: There are some cases where a schemaless approach is warranted. If your primary
    goal is to move fast—perhaps before you know what you need, when you are iterating
    rapidly, or when old data has little to no value—a schemaless approach lets you
    cut corners. Some data is legitimately nonuniform; some records have certain fields
    that others don’t. Flipping data from explicit to implicit schema is also a helpful
    trick when migrating data; you might temporarily make data schemaless to ease
    the transition to a new explicit schema.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，无模式的方法是合理的。如果你的主要目标是快速推进——也许是在你还不知道需要什么的时候，或者当你在快速迭代时，或者当旧数据几乎没有价值时——无模式的方法让你可以节省时间。一些数据本身就是不规则的；某些记录可能有一些其他记录没有的字段。当迁移数据时，从显式模式切换到隐式模式也是一个有用的技巧；你可能暂时将数据设置为无模式，以便顺利过渡到新的显式模式。
- en: Automate Schema Migrations
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化模式迁移
- en: Changing a database’s schema is dangerous. A minor tweak—adding an index or
    dropping a column—can cause the entire database or application to grind to a halt.
    Managing database changes by manually executing *database description language*
    *(DDL**)* commands directly on the database is error prone. Database schemas in
    different environments diverge, the state of the database is uncertain, no one
    knows who changed what when, and performance impacts are unclear. The mix of error-prone
    changes and the potential for major downtime is an explosive combination.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数据库的模式是危险的。一点小改动——比如添加索引或删除列——可能会导致整个数据库或应用程序停滞不前。通过手动执行*数据库描述语言* *(DDL)*
    命令直接在数据库上管理数据库更改是容易出错的。不同环境中的数据库模式会发生分歧，数据库的状态变得不确定，没有人知道谁在什么时候更改了什么，性能影响也不清楚。易出错的更改和可能的长时间停机结合在一起，是一种爆炸性的组合。
- en: 'Database schema management tools make database changes less error prone. Automated
    tooling does two things for you: it forces you to track the entire history of
    a schema, and it gives you tools to migrate a schema from one version to another.
    Track schema changes, use automated database tools, and work with your database
    team to manage schema evolution.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式管理工具能让数据库更改减少出错。自动化工具为你做了两件事：它迫使你跟踪模式的整个历史，并且提供工具来将模式从一个版本迁移到另一个版本。跟踪模式更改，使用自动化数据库工具，并与数据库团队合作管理模式演变。
- en: The entire history of a schema is usually kept in a series of files defining
    every change from the initial creation of a schema all the way to its current
    form. Tracking DDL changes in files helps developers see how the schema has changed
    over time. Files tracked in a version control system will show who made which
    changes, when, and why. Pull requests will afford the opportunity for schema reviews
    and linting.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的整个历史通常保存在一系列文件中，这些文件定义了从最初创建模式到其当前形式的每个更改。通过文件跟踪DDL更改，帮助开发人员了解模式随着时间的推移如何变化。通过版本控制系统跟踪的文件将显示是谁在何时进行了哪些更改，以及为什么进行这些更改。拉取请求将提供模式审查和代码检查的机会。
- en: 'We can take our users table from the “Use Schemas” section and put it in a
    versioned file for a schema migration tool like Liquibase:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从“使用模式”部分获取用户表，并将其放入一个版本化文件中，以供像Liquibase这样的模式迁移工具使用：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can then define an `ALTER` in a separate block:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在单独的代码块中定义一个`ALTER`：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Liquibase can use these files to upgrade or downgrade schemas through the CLI:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Liquibase可以通过CLI使用这些文件来升级或降级模式：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If Liquibase is pointed at an empty database, it will run both the `CREATE`
    and `ALTER` commands. If it’s pointed at a database where the `CREATE` has already
    been executed, it will run only the `ALTER`. Tools like Liquibase often track
    the current version of a database schema in special metadata tables in the database
    itself, so don’t be surprised if you find tables with names like `DATABASECHANGELOG`
    or `DATABASECHANGELOGLOCK`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Liquibase指向一个空数据库，它将运行`CREATE`和`ALTER`命令。如果它指向一个已经执行过`CREATE`命令的数据库，它将只运行`ALTER`命令。像Liquibase这样的工具通常在数据库中使用特殊的元数据表来跟踪数据库模式的当前版本，因此如果你发现名为`DATABASECHANGELOG`或`DATABASECHANGELOGLOCK`的表，不必感到惊讶。
- en: In the previous example, the Liquibase command is run from the command line,
    usually by a *database administrator* *(DBA**)*. Some teams will automate the
    execution itself through a commit hook or a web UI.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，Liquibase命令通常由*数据库管理员*（*DBA*）从命令行运行。一些团队会通过提交钩子或Web UI自动执行该操作。
- en: Don’t couple database and application lifecycles. Tying schema migrations to
    application deployment is dangerous. Schema changes are delicate and can have
    serious performance implications. Separating database migrations from application
    deployment lets you control when schema changes go out.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将数据库和应用程序生命周期耦合。将模式迁移与应用程序部署绑定是危险的。模式更改是非常细致的，可能会对性能产生严重影响。将数据库迁移与应用程序部署分开，可以让你控制模式更改何时发布。
- en: Liquibase is just one tool that can manage database migrations; there are others
    like Flyway and Alembic. Many *object-resource mappers* *(ORMs**)* come with schema
    migration managers as well. If your company already has one in place, use it;
    if not, work with the team to figure out what to use. Once selected, use the database
    migration system for all the changes; circumventing it will negate the tool’s
    benefit since reality has diverged from what’s tracked.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Liquibase只是其中一个可以管理数据库迁移的工具；还有像Flyway和Alembic这样的工具。许多*对象-资源映射器*（*ORMs*）也附带了模式迁移管理器。如果你的公司已经有了这样的工具，使用它；如果没有，请与团队合作找出应该使用哪个工具。一旦选择了，就使用数据库迁移系统来处理所有更改；绕过它会导致工具的好处失效，因为现实已经与追踪的内容不一致。
- en: More sophisticated database operations tools also exist. Tools like GitHub’s
    gh-ost and Percona’s pt-online-schema-change help database administrators run
    large schema changes without impacting performance. Other tools like Skeema and
    Square’s Shift provide more sophisticated versioning that lets you “diff” database
    schemas and automatically derive changes. All of these tools help make database
    evolution safer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 也有更复杂的数据库操作工具。像GitHub的gh-ost和Percona的pt-online-schema-change这样的工具帮助数据库管理员在不影响性能的情况下执行大规模的模式更改。其他工具，如Skeema和Square的Shift，提供了更复杂的版本控制，允许你“比较”数据库模式并自动推导出更改。所有这些工具都有助于让数据库演进更加安全。
- en: Most migration tools support rollbacks, which undo a migration’s changes. Rollbacks
    can only do so much, so be careful. For example, rolling back a column deletion
    will recreate a column, but it will not recreate the data that used to be stored
    in that column! Backing up a table prior to deletion is prudent.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数迁移工具都支持回滚，回滚会撤销迁移的更改。回滚能做的事有限，所以要小心。例如，回滚列删除操作将重新创建该列，但不会重新创建曾经存储在该列中的数据！在删除之前备份表是明智的。
- en: Because of the permanent and large-scale nature of these types of changes, organizations
    will often have specific subteams responsible for ensuring the changes are done
    correctly. These might be DBAs, operations or SREs, or a set of senior engineers
    familiar with the tools, performance implications, and application-specific concerns.
    These teams are a great resource for understanding the nuances of data storage
    systems; learn from them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些类型的变化具有长期性和大规模的特性，组织通常会有专门的子团队负责确保这些变化的正确实施。这些团队可能是DBA、运维人员或SRE，或者是熟悉工具、性能影响和应用特定问题的高级工程师。
    这些团队是理解数据存储系统细微差别的宝贵资源；向他们学习。
- en: Maintain Schema Compatibility
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护架构兼容性
- en: Data written to disk has the same compatibility problems that APIs have. Like
    APIs, the reader and writer of the data can change independently; they might not
    be the same software and might not be on the same machine. And like APIs, data
    has a schema with field names and types. Changing schemas in a forward- or backward-incompatible
    way can break applications. Use schema compatibility checks to detect incompatible
    changes, and use data products to decouple internal and external schemas.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 写入磁盘的数据与API存在相同的兼容性问题。像API一样，数据的读写方可以独立变化；它们可能不是同一个软件，也可能不在同一台机器上。像API一样，数据有一个包含字段名称和类型的架构。以向前或向后不兼容的方式更改架构可能会破坏应用程序。使用架构兼容性检查来检测不兼容的更改，并使用数据产品来解耦内部和外部架构。
- en: Developers think databases are an implementation detail that’s hidden from other
    systems. Fully encapsulated databases are ideal but not often realized in practice.
    Even if a production database is hidden behind an application, the data is often
    exported to data warehouses.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员认为数据库是隐藏在其他系统背后的实现细节。完全封装的数据库是理想的，但在实践中不常实现。即使生产数据库隐藏在应用程序后面，数据通常也会被导出到数据仓库中。
- en: Data warehouses are databases used for analytic and reporting purposes. Organizations
    set up an *extract, transform, load* *(ETL**)* data pipeline that extracts data
    from production databases and transforms and loads it into a data warehouse (see
    [Figure 11-3](#figure11-3)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 数据仓库是用于分析和报告的数据库。组织会设置一个*提取、转换、加载*（*ETL*）数据管道，该管道从生产数据库中提取数据，并将其转换后加载到数据仓库中（见[图11-3](#figure11-3)）。
- en: '![f11003](image_fi/501836c11/f11003.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![f11003](image_fi/501836c11/f11003.png)'
- en: 'Figure 11-3: ETL data pipeline'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-3：ETL 数据管道
- en: ETL pipelines depend heavily on database schemas. Simply dropping the column
    in a production database could cause the entire data pipeline to grind to a halt.
    Even if dropping a column doesn’t break the data pipeline, downstream users might
    be using the field for reporting, machine learning models, or ad hoc queries.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ETL管道在很大程度上依赖于数据库架构。简单地删除生产数据库中的某一列可能会导致整个数据管道停滞。即使删除某列不会破坏数据管道，下游用户也可能正在使用该字段进行报告、机器学习模型或临时查询。
- en: Other systems might also depend on your database schemas. *Change data capture*
    *(CDC**)* is an event-based architecture that converts insert, update, and delete
    operations into messages for downstream consumers. An insert into a “members”
    table might trigger a message that an email service uses to send an email to the
    new user. Such messages are an implicit API, and making backward-incompatible
    schema changes can break other services.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其他系统可能也依赖于你的数据库架构。*变更数据捕获*（*CDC*）是一种基于事件的架构，将插入、更新和删除操作转换为消息，供下游消费者使用。向“members”表插入一条记录可能会触发一条消息，电子邮件服务使用这条消息向新用户发送邮件。这些消息是隐式的API，进行不兼容的架构更改可能会破坏其他服务。
- en: Data warehouse pipelines and downstream users must be protected from breaking
    schema changes. Validate that your schema changes are safe before executing them
    in production. Compatibility checks should be done as early as possible, ideally
    at code commit time by inspecting database DDL statements. Executing DDL statements
    in a preproduction integration testing environment, if one exists, can also protect
    changes. Run your DDL statements and integration tests to verify that downstream
    systems don’t break.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 数据仓库管道和下游用户必须避免因为架构更改而导致故障。在生产环境中执行架构更改之前，确保验证这些更改的安全性。兼容性检查应该尽早进行，理想情况下是在代码提交时通过检查数据库DDL语句来完成。如果有预生产集成测试环境，执行DDL语句也可以防止更改带来问题。运行DDL语句并进行集成测试，确保下游系统不会因此而故障。
- en: You can also protect internal schemas by exporting a *data product* that explicitly
    decouples internal schemas from downstream users. Data products map internal schemas
    to separate user-facing schemas; the development team owns both the production
    database and the published data products. Separate data products, which might
    simply be database views, allow teams to maintain compatibility with data consumers
    without having to freeze their internal database schemas.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过导出*数据产品*来保护内部模式，从而明确地将内部模式与下游用户解耦。数据产品将内部模式映射到独立的面向用户的模式；开发团队同时拥有生产数据库和发布的数据产品。独立的数据产品，可能只是数据库视图，使团队能够在不冻结内部数据库模式的情况下与数据消费者保持兼容性。
- en: Do’s and Don’ts
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做的事项与不做的事项
- en: '| **Do’s** | **Don’ts** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **做的事项** | **不做的事项** |'
- en: '| --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **DO** remember YAGNI: “You Ain’t Gonna Need It.” | **DON’T** build too many
    abstractions without purpose. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **做** 记住 YAGNI：“你不会需要它。” | **不要** 构建没有明确目的的过多抽象。 |'
- en: '| **DO** use standard libraries and development patterns. | **DON’T** write
    methods with hidden ordering or argument requirements. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **做** 使用标准库和开发模式。 | **不要** 编写具有隐式排序或参数要求的方法。 |'
- en: '| **DO** use an IDL to define your APIs. | **DON’T** surprise other developers
    with exotic code. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **做** 使用 IDL 来定义你的 API。 | **不要** 用奇异的代码让其他开发者感到惊讶。 |'
- en: '| **DO** version external APIs and documentation. | **DON’T** make incompatible
    API changes. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **做** 对外部 API 和文档进行版本控制。 | **不要** 做出不兼容的 API 更改。 |'
- en: '| **DO** isolate application databases from each other. | **DON’T** be dogmatic
    about internal API versioning. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **做** 将应用数据库相互隔离。 | **不要** 对内部 API 版本控制过于固执。 |'
- en: '| **DO** define explicit schemas for all your data. | **DON’T** embed schemaless
    data in string or byte fields. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **做** 为所有数据定义明确的模式。 | **不要** 在字符串或字节字段中嵌入无模式数据。 |'
- en: '| **DO** use migration tools to automate database schema management. |  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **做** 使用迁移工具来自动化数据库模式管理。 |  |'
- en: '| **DO** maintain schema compatibility if downstream consumers use your data.
    |  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **做** 如果下游消费者使用你的数据，请保持模式兼容性。 |  |'
- en: Level Up
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级
- en: A book-length treatment on evolvable architectures can be found in *Building
    Evolutionary Architectures*, written by Neal Ford, Rebecca Parsons, and Patrick
    Kua (O’Reilly Media, 2017). For more depth on evolvable APIs and data, see their
    work. They discuss DDD briefly; for the full experience, refer to *Implementing
    Domain Driven Design* by Vaughn Vernon (Addison-Wesley Professional, 2013).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '有关可演化架构的详细讨论可以在*《构建演化架构》*一书中找到，作者为 Neal Ford、Rebecca Parsons 和 Patrick Kua（O''Reilly
    Media，2017）。欲了解更多关于可演化 API 和数据的深度内容，请参考他们的作品。书中简要讨论了领域驱动设计（DDD）；要深入了解，建议阅读 Vaughn
    Vernon 的*《实施领域驱动设计》*（Addison-Wesley Professional，2013）。  '
- en: We cite John Ousterhout’s work on complexity in the beginning of the chapter.
    See his excellent (and short) book, *A Philosophy of Software Design* (Yaknyam
    Press, 2018), to learn more about complexity and how to manage it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开头引用了 John Ousterhout 关于复杂性的研究。请参阅他那本简短且精彩的书*《软件设计哲学》*（Yaknyam Press，2018），以了解更多关于复杂性以及如何管理复杂性。
- en: 'Zach Tellman’s *Elements of Clojure* ([lulu.com](http://lulu.com), 2019) is
    a wonderful book that has only four chapters: “Names,” “Idioms,” “Indirection,”
    and “Composition.” It is a lucid, concise discussion of these four topics, which
    will help you build evolvable architectures (even if you never touch a line of
    Clojure).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Zach Tellman 的*《Clojure 元素》*（[lulu.com](http://lulu.com)，2019）是一本精彩的书，只有四个章节：“命名”，“习惯用法”，“间接性”和“组合”。这是对这四个主题的简洁明了的讨论，它将帮助你构建可演化的架构（即使你从未接触过一行
    Clojure 代码）。
- en: Richard Hickey has a beautiful talk called *Simple Made Easy* ([https://www.youtube.com/watch?v=oytL881p-nQ](https://www.youtube.com/watch?v=oytL881p-nQ)).
    Hickey’s talk discusses simplicity, complexity, “easiness,” and how to build good
    software. The talk is a must-watch.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Richard Hickey 有一场精彩的演讲，名为*《简化使之更易》*（[https://www.youtube.com/watch?v=oytL881p-nQ](https://www.youtube.com/watch?v=oytL881p-nQ)）。Hickey
    的演讲讨论了简洁、复杂性、"简易性"以及如何构建优秀的软件。这场演讲不容错过。
- en: '*Data Mesh: Building a Next Generation Data Architecture* by Zhamak Dehghani
    (coming out end of 2021) contains a deeper discussion of data products.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*《数据网格：构建下一代数据架构》*由 Zhamak Dehghani 编写（2021年底发布），书中深入讨论了数据产品。'
- en: '*Designing Data-Intensive Applications* by Martin Kleppman (O’Reilly Media,
    2017) is an excellent book that covers, among other things, the subjects of data
    evolution, data schemas, IDLs, and change data capture. This book is an instant
    classic, and we highly recommend it.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*《设计数据密集型应用》*由 Martin Kleppman 编写（O''Reilly Media，2017）是一本优秀的书，涵盖了数据演化、数据模式、IDL
    和变更数据捕获等主题。这本书是一本即时经典，强烈推荐。'
