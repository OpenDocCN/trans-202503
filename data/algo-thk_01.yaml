- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: HASH TABLES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表**
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common01.jpg)'
- en: It’s amazing how often computer programs need to search for information, whether
    it’s to find a user’s profile in a database or to retrieve a customer’s orders.
    No one likes waiting for a slow search to complete.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序多么频繁地需要搜索信息，是否为了在数据库中查找用户资料，或者检索客户订单。没有人喜欢等待一个缓慢的搜索完成。
- en: In this chapter, we’ll solve two problems whose solutions hinge on being able
    to perform efficient searches. The first problem is determining whether or not
    all snowflakes in a collection are identical. The second is determining how many
    passwords can be used to log in to someone’s account. We want to solve these problems
    correctly, but we’ll see that some correct approaches are simply too slow. We’ll
    be able to achieve enormous performance increases using a data structure known
    as a hash table, which we’ll explore at length.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决两个依赖于能够执行高效搜索的问题。第一个问题是确定集合中的所有雪花是否相同。第二个问题是确定有多少密码可以用于登录某人的账户。我们希望正确解决这些问题，但我们将看到一些正确的方法实在太慢了。我们将能够通过使用一种被称为哈希表的数据结构来大幅提升性能，我们将详细探讨它。
- en: 'We’ll end the chapter by looking at a third problem: determining how many ways
    a letter can be deleted from one word to arrive at another. Here we’ll see the
    risks of uncritically using a new data structure—when learning something new,
    it’s tempting to try to use it everywhere!'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后，我们将探讨第三个问题：确定如何从一个单词中删除字母以得到另一个单词。在这里，我们将看到盲目使用新数据结构的风险——在学习新东西时，往往会有尝试在所有地方使用它的冲动！
- en: 'Problem 1: Unique Snowflakes'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 1：独特的雪花
- en: This is DMOJ problem `cco07p2`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`cco07p2`。
- en: '*The Problem*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: We’re given a collection of snowflakes, and we have to determine whether any
    of the snowflakes in the collection are identical.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被给定了一组雪花，我们必须确定这些雪花中是否有相同的。
- en: 'A snowflake is represented by six integers, where each integer gives the length
    of one of the snowflake’s arms. For example, this is a snowflake:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个雪花由六个整数表示，每个整数代表雪花一条臂的长度。例如，这是一个雪花：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Snowflakes can also have repeated integers, such as
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 雪花也可以包含重复的整数，例如：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What does it mean for two snowflakes to be identical? Let’s work up to that
    definition through a few examples.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 两个雪花相同意味着什么呢？我们通过几个例子逐步理解这个定义。
- en: 'First, we’ll look at these two snowflakes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看这两个雪花：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: and
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These are clearly identical because the integers in one snowflake match the
    integers in their corresponding positions in the other snowflake.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些显然是相同的，因为一个雪花中的整数与另一个雪花中对应位置的整数匹配。
- en: 'Here’s our second example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第二个例子：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: and
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These are also identical. We can see this by starting at the `1` in the second
    snowflake and moving right. We see the integers `1`, `2`, and `3` and then, wrapping
    around to the left, we see `4`, `5`, and `6`. These two pieces together give us
    the first snowflake.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也是相同的。我们可以通过从第二个雪花的`1`开始并向右移动来验证这一点。我们看到整数`1`、`2`和`3`，然后，当我们绕到左边时，看到`4`、`5`和`6`。这两部分加在一起就构成了第一个雪花。
- en: We can think of each snowflake as a circle as in [Figure 1-1](ch01.xhtml#ch01fig01).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将每个雪花看作是一个圆形，如[图 1-1](ch01.xhtml#ch01fig01)所示。
- en: '![Image](../images/ch01fig01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch01fig01.jpg)'
- en: '*Figure 1-1: Two identical snowflakes*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：两个相同的雪花*'
- en: The two snowflakes are identical because we can start at the `1` in the second
    snowflake and follow it clockwise to get the first snowflake.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个雪花是相同的，因为我们可以从第二个雪花中的`1`开始，顺时针移动，得到第一个雪花。
- en: 'Let’s try a different kind of example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来试一个不同类型的例子：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: and
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From what we’ve seen so far, we would deduce that these are not identical. If
    we start with the `1` in the second snowflake and move right (wrapping around
    to the left when we hit the right end), we get `1, 6, 5, 4, 3, 2`. That’s not
    even close to the `1, 2, 3, 4, 5, 6` in the first snowflake.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从目前为止所见，我们可以推断这些雪花并不相同。如果我们从第二个雪花中的`1`开始，向右移动（当到达右端时绕到左边），得到的是`1, 6, 5, 4, 3,
    2`。这与第一个雪花中的`1, 2, 3, 4, 5, 6`差得远。
- en: However, if we begin at the `1` in the second snowflake and move left instead
    of right, then we do get exactly `1, 2, 3, 4, 5, 6`! Moving left from the `1`
    gives us `1, 2, 3`, and wrapping around to the right, we can proceed leftward
    to collect `4, 5, 6`. In [Figure 1-2](ch01.xhtml#ch01fig02), this corresponds
    to starting at the `1` in the second snowflake and moving counterclockwise.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们从第二个雪花中的`1`开始并向左移动，而不是向右移动，那么我们确实得到 `1, 2, 3, 4, 5, 6`！从`1`开始向左移动，得到
    `1, 2, 3`，然后再绕回右侧，继续向左收集 `4, 5, 6`。在[图 1-2](ch01.xhtml#ch01fig02)中，这相当于从第二个雪花中的`1`开始，按逆时针方向移动。
- en: '![Image](../images/ch01fig02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch01fig02.jpg)'
- en: '*Figure 1-2: Two other identical snowflakes*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：另外两个相同的雪花*'
- en: 'That’s our third way for two snowflakes to be identical: two snowflakes are
    identical if they match when we move counterclockwise through the numbers.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是雪花相同的第三种方式：如果两个雪花在我们按逆时针方向遍历数字时匹配，则它们相同。
- en: Putting it all together, we can conclude that two snowflakes are identical if
    they are the same, if we can make them the same by moving rightward through one
    of the snowflakes (moving clockwise), or if we can make them the same by moving
    leftward through one of the snowflakes (moving counterclockwise).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 综合来看，我们可以得出结论：如果两个雪花相同，或者我们可以通过右移其中一个雪花（顺时针方向）使它们相同，或者我们可以通过左移其中一个雪花（逆时针方向）使它们相同，那么这两朵雪花就是相同的。
- en: Input
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The first line of input is an integer *n*, the number of snowflakes that we’ll
    be processing. The value *n* will be between 1 and 100,000\. Each of the following
    *n* lines represents one snowflake: each line has six integers, where each integer
    is at least 0 and at most 10,000,000.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行输入是一个整数*n*，表示我们将处理的雪花数量。值*n*将在 1 和 100,000 之间。接下来的*n*行表示每个雪花，每行包含六个整数，每个整数至少为
    0，最多为 10,000,000。
- en: Output
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: 'Our output will be a single line of text:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出将是一个单行文本：
- en: If there are no identical snowflakes, output exactly `No two snowflakes are
    alike.`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有相同的雪花，输出`No two snowflakes are alike.`（没有两个雪花是相同的）。
- en: If there are at least two identical snowflakes, output exactly `Twin snowflakes
    found.`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果至少有两个相同的雪花，输出`Twin snowflakes found.`（找到双胞胎雪花）。
- en: The time limit for solving the test cases is one second.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制为一秒。
- en: '*Simplifying the Problem*'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*简化问题*'
- en: One general strategy for solving competitive programming challenges is to first
    work with a simpler version of the problem. Let’s warm up by eliminating some
    of the complexity from this problem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 解决竞争编程挑战的一般策略是首先处理问题的简化版本。让我们通过去掉一些复杂性来热身一下这个问题。
- en: Suppose that instead of working with snowflakes made of multiple integers, we’re
    working with single integers. We have a collection of integers, and we want to
    know whether any are identical. We can test whether two integers are identical
    with C’s `==` operator. We can test all pairs of integers, and if we find even
    one pair of identical integers, we’ll stop and output
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不是处理由多个整数构成的雪花，而是处理单个整数。我们有一组整数，我们想知道是否有任何两个是相同的。我们可以使用 C 语言的`==`运算符来测试两个整数是否相等。我们可以测试所有整数对，如果找到任何一对相同的整数，我们就停止并输出
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If no identical integers are found, we’ll output
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到相同的整数，我们将输出
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s make an `identify_identical` function with two nested loops to compare
    pairs of integers, as shown in [Listing 1-1](ch01.xhtml#ch01ex01).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`identify_identical`函数，使用两个嵌套循环来比较整数对，如[清单 1-1](ch01.xhtml#ch01ex01)所示。
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 1-1: Finding identical integers*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-1：查找相同的整数*'
- en: We feed the integers to the function through the `values` array. We also pass
    in `n`, the number of integers in the array.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`values`数组将整数传递给函数。我们还传递`n`，即数组中的整数数量。
- en: Notice that we start the inner loop at `i + 1` and not `0` ❶. If we started
    at `0`, then eventually `j` would equal `i`, and we’d compare an element to itself,
    giving us a false positive result.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的内层循环从`i + 1`开始，而不是从`0`开始❶。如果我们从`0`开始，最终`j`会等于`i`，我们会将一个元素与其自身进行比较，导致错误的正面结果。
- en: 'Let’s test `identify_identical` using this small `main` function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个小的`main`函数来测试`identify_identical`：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the code and you will see from the output that our function correctly identified
    a matching pair of `1`s. In general, I won’t provide much test code in this book,
    but it’s important that you play with and test the code yourself as we go along.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，你将从输出中看到我们的函数正确地识别出了一对匹配的`1`。通常，在本书中我不会提供太多的测试代码，但在过程中你需要亲自动手操作并测试代码。
- en: '*Solving the Core Problem*'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决核心问题*'
- en: 'Let’s take our `identify_identical` function and try to modify it to solve
    the Snowflake problem. To do so, we need to make two extensions to our code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿到`identify_identical`函数，并尝试修改它来解决雪花问题。为此，我们需要对代码做两项扩展：
- en: 'We have to work with six integers at a time, not one. A two-dimensional array
    should work nicely here: each row will be a snowflake with six columns (one column
    per element).'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须一次处理六个整数，而不是一个。这里使用二维数组应该会很合适：每一行将代表一个雪花，六列（每列对应一个元素）。
- en: As we saw earlier, there are multiple ways for two snowflakes to be identical.
    Unfortunately, this means we can’t just use `==` to compare snowflakes. We need
    to take into account our “moving right” and “moving left” criteria (not to mention
    that `==` in C doesn’t compare contents of arrays anyway!). Correctly comparing
    snowflakes will be the major update to our algorithm.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，两个雪花可以有多种方式是相同的。不幸的是，这意味着我们不能仅仅使用`==`来比较雪花。我们需要考虑“向右移动”和“向左移动”的条件（更不用说，C语言中的`==`本身也无法比较数组的内容！）。正确地比较雪花将是我们算法的主要更新内容。
- en: 'To begin, let’s write a pair of helper functions: one for checking “moving
    right” and one for checking “moving left.” Each of these helpers takes three parameters:
    the first snowflake, the second snowflake, and the starting point for the second
    snowflake.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写一对辅助函数：一个用于检查“向右移动”，另一个用于检查“向左移动”。每个辅助函数都接受三个参数：第一个雪花、第二个雪花以及第二个雪花的起始点。
- en: Checking to the Right
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向右检查
- en: 'Here is the function signature for `identical_right`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`identical_right`函数的函数签名：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To determine whether the snowflakes are the same by “moving right,” we scan
    `snow1` from index `0` and `snow2` from index `start`. If we find corresponding
    elements that are not equal, then we return `0` to signify that we haven’t found
    identical snowflakes. If all the corresponding elements do match, then we return
    `1`. Think of `0` as representing false and `1` as representing true.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断雪花是否相同，通过“向右移动”进行扫描，我们从索引`0`开始扫描`snow1`，从索引`start`开始扫描`snow2`。如果发现对应的元素不相等，则返回`0`，表示没有找到相同的雪花。如果所有对应的元素都匹配，则返回`1`。可以把`0`看作是“假”，`1`看作是“真”。
- en: In [Listing 1-2](ch01.xhtml#ch01ex02) we make a first attempt at writing this
    function’s code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 1-2](ch01.xhtml#ch01ex02)中，我们第一次尝试编写这个函数的代码。
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 1-2: Identifying identical snowflakes moving right (bugged!)*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-2：识别向右移动的相同雪花（有错误！）*'
- en: As you may notice, this code won’t work as we hope. The problem is `start +
    offset` ❶. If we have `start = 4` and `offset = 3`, then `start + offset = 7`.
    The trouble is `snow2[7]`, as `snow2[5]` is the farthest index to which we are
    allowed to go.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，这段代码并不会像我们希望的那样工作。问题出在`start + offset` ❶。如果`start = 4`，`offset = 3`，那么`start
    + offset = 7`。问题出在`snow2[7]`，因为`snow2[5]`是我们允许访问的最大索引。
- en: This code doesn’t take into account that we must wrap around to the left of
    `snow2`. If our code is about to use an erroneous index of `6` or greater, we
    should reset our index by subtracting six. This will let us continue with index
    `0` instead of index `6`, index `1` instead of index `7`, and so on. Let’s try
    again with [Listing 1-3](ch01.xhtml#ch01ex03).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有考虑到我们必须将`snow2`的索引回绕到左侧。如果代码即将使用错误的索引（比如`6`或更大），我们应该通过减去六来重置索引。这样，我们就可以继续使用索引`0`而不是索引`6`，使用索引`1`而不是索引`7`，以此类推。让我们再试一次，[清单
    1-3](ch01.xhtml#ch01ex03)。
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 1-3: Identifying identical snowflakes moving right*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-3：识别向右移动的相同雪花*'
- en: This works, but we can still improve it. One change that many programmers would
    consider making at this point involves using `%`, the mod operator. The `%` operator
    computes remainders, so `x % y` returns the remainder of integer-dividing `x`
    by `y`. For example, `9 % 3` is 0, because there is no remainder when dividing
    9 by 3\. `10 % 4` is 2, because 2 is left over when dividing 10 by 4.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以工作，但我们仍然可以改进它。此时，许多程序员可能会考虑做一个更改，使用`%`，即取模运算符。`%`运算符计算余数，所以`x % y`返回`x`除以`y`的余数。例如，`9
    % 3`等于0，因为9除以3没有余数；`10 % 4`等于2，因为10除以4余2。
- en: 'We can use mod here to help with the wraparound behavior. Notice that `0 %
    6` is 0, `1 % 6` is 1, . . . , `5 % 6` is 5\. Each of these numbers is smaller
    than 6, and so will itself be the remainder when dividing 6\. The numbers 0 to
    5 correspond to the legal indices of `snow2`, so it’s good that `%` leaves them
    alone. For our problematic index `6`, `6 % 6` is 0: 6 divides 6 evenly, with no
    remainder at all, wrapping us around to the start. That’s precisely the wraparound
    behavior we wanted.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里使用模运算来帮助实现循环行为。注意，`0 % 6` 等于 0，`1 % 6` 等于 1，……，`5 % 6` 等于 5。每个数字都小于 6，因此它们自己就是除以
    6 的余数。数字 0 到 5 对应着 `snow2` 的合法索引，所以 `%` 运算符不会改变它们，这很好。对于我们问题中的索引 `6`，`6 % 6` 等于
    0：6 能够被 6 整除，没有余数，从而使我们回到起点。这正是我们想要的循环行为。
- en: Let’s update `identical_right` to use the `%` operator. [Listing 1-4](ch01.xhtml#ch01ex04)
    shows the new function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `identical_right` 以使用 `%` 运算符。[示例 1-4](ch01.xhtml#ch01ex04)展示了新的函数。
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 1-4: Identifying identical snowflakes moving right using mod*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-4：使用模运算识别向右移动的相同雪花*'
- en: Whether you use this “mod trick” is up to you. It saves a line of code and is
    a common pattern that many programmers will be able to identify. However, it doesn’t
    always easily apply, even in cases that exhibit similar wraparound behavior, such
    as `identical_left`. Let’s turn to this now.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用这个“模运算技巧”由你决定。它节省了一行代码，是一种许多程序员都能识别的常见模式。然而，它并不总是容易应用，哪怕是类似的循环行为，比如 `identical_left`。我们现在就来看看这个。
- en: Checking to the Left
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查向左移动
- en: The function `identical_left` is very similar to `identical_right`, except that
    we need to move left and then wrap around to the right. When traversing right,
    we had to be wary of erroneously accessing index 6 or greater; this time, we have
    to be wary of accessing index –1 or less.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`identical_left` 函数与 `identical_right` 非常相似，唯一的区别是我们需要向左移动，然后再回绕到右边。当向右遍历时，我们需要小心不要错误地访问索引
    6 或更大的值；而这次，我们需要小心不要访问索引 -1 或更小的值。'
- en: Unfortunately, our mod solution won’t directly work here. In C, `-1 / 6` is
    0, leaving a remainder of –1, and so `-1 % 6` is –1\. We’d need `-1 % 6` to be
    5.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的模运算解决方案在这里不能直接使用。在 C 语言中，`-1 / 6` 等于 0，余数是 -1，因此 `-1 % 6` 等于 -1。我们需要的是
    `-1 % 6` 等于 5。
- en: Let’s just do this without using mod. In [Listing 1-5](ch01.xhtml#ch01ex05),
    we provide the code for the `identical_left` function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不使用模运算来实现这个。我们在[示例 1-5](ch01.xhtml#ch01ex05)中提供了 `identical_left` 函数的代码。
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 1-5: Identifying identical snowflakes moving left*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-5：识别向左移动的相同雪花*'
- en: Notice the similarity between this function and that of [Listing 1-3](ch01.xhtml#ch01ex03).
    All we did was subtract the offset instead of adding it and change the bounds
    check at `6` to a bounds check at `-1`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个函数与[示例 1-3](ch01.xhtml#ch01ex03)的相似性。我们所做的只是将偏移量相减而不是相加，并将 `6` 的边界检查改为 `-1`
    的边界检查。
- en: Putting It Together
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 综合起来
- en: With these two helper functions, `identical_right` and `identical_left`, we
    can finally write a function that tells us whether two snowflakes are identical.
    [Listing 1-6](ch01.xhtml#ch01ex06) gives the code for an `are_identical` function
    that does this. We simply test moving right and moving left for each of the possible
    starting points in `snow2`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个辅助函数 `identical_right` 和 `identical_left`，我们终于可以编写一个函数，告诉我们两朵雪花是否相同。[示例
    1-6](ch01.xhtml#ch01ex06) 给出了一个实现此功能的 `are_identical` 函数的代码。我们只需测试每个可能的起始点在 `snow2`
    中向右和向左移动即可。
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 1-6: Identifying identical snowflakes*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-6：识别相同的雪花*'
- en: We test whether `snow1` and `snow2` are the same by moving right in `snow2`
    ➊. If they are identical according to that criterion, we return `1` (true). We
    then similarly check the moving-left criterion ➋.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `snow2` 中向右移动 ➊ 来测试 `snow1` 和 `snow2` 是否相同。如果它们在这个标准下相同，我们返回 `1`（即 true）。然后，我们同样检查向左移动的标准
    ➋。
- en: It’s worth pausing here to test the `are_identical` function on a few sample
    snowflake pairs. Please do that before continuing!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，值得暂停一下，测试 `are_identical` 函数在一些示例雪花对上的效果。请在继续之前先进行测试！
- en: '*Solution 1: Pairwise Comparisons*'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案 1：成对比较*'
- en: When we need to compare two snowflakes, we just deploy our `are_identical` function
    instead of `==`. Comparing two snowflakes is now as easy as comparing two integers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要比较两朵雪花时，我们直接调用 `are_identical` 函数，而不是使用 `==`。比较两朵雪花现在就像比较两个整数一样简单。
- en: Let’s revise our earlier `identify_identical` function ([Listing 1-1](ch01.xhtml#ch01ex01))
    to work with snowflakes using the new `are_identical` function ([Listing 1-6](ch01.xhtml#ch01ex06)).
    We’ll make pairwise comparisons between snowflakes, printing out one of two messages
    depending on whether we find identical snowflakes. The code is given in [Listing
    1-7](ch01.xhtml#ch01ex07).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的`identify_identical`函数（[列表 1-1](ch01.xhtml#ch01ex01)），使其能够使用新的`are_identical`函数（[列表
    1-6](ch01.xhtml#ch01ex06)）处理雪花。我们将对雪花进行逐对比较，根据是否找到相同的雪花输出两条消息之一。代码见[列表 1-7](ch01.xhtml#ch01ex07)。
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 1-7: Finding identical snowflakes*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-7：寻找相同的雪花*'
- en: This `identify_identical` function on snowflakes is almost, symbol for symbol,
    the same as the `identify_identical` function on integers in [Listing 1-1](ch01.xhtml#ch01ex01).
    All we’ve done is swap `==` for a function that compares snowflakes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关于雪花的`identify_identical`函数几乎和[列表 1-1](ch01.xhtml#ch01ex01)中处理整数的`identify_identical`函数一模一样，符号逐一对应。我们所做的只是用一个比较雪花的函数替换了`==`。
- en: Reading the Input
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 读取输入
- en: We’re not quite ready to submit to our judge. We haven’t yet written the code
    to read the snowflakes from standard input. Revisit the problem description at
    the start of the chapter. We need to read a line containing integer *n* that tells
    us how many snowflakes there are and then read each of the following *n* lines
    as an individual snowflake.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有准备好提交给评测系统。我们还没有写代码从标准输入中读取雪花。请回顾一下本章开头的问题描述。我们需要读取一行包含整数*n*，告诉我们雪花的数量，然后读取接下来的*n*行，每行表示一片雪花。
- en: '[Listing 1-8](ch01.xhtml#ch01ex08) is a `main` function that processes the
    input and then calls `identify_identical` from [Listing 1-7](ch01.xhtml#ch01ex07).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-8](ch01.xhtml#ch01ex08)是一个`main`函数，它处理输入，然后调用[列表 1-7](ch01.xhtml#ch01ex07)中的`identify_identical`函数。'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 1-8: The* main *function for Solution 1*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-8：* 主 *函数（Solution 1）*'
- en: Notice that the `snowflakes` array is a `static` array ➊. This is because the
    array is huge; without using such a `static` array, the amount of space needed
    would likely outstrip the amount of memory available to the function. We use `static`
    to place the array in its own, separate piece of memory, where space is not a
    concern. Be careful with `static`, though. Regular local variables are initialized
    on each call of a function, but `static` ones retain whatever value they had on
    the previous function call (see “Static Keyword” on page xxvi).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`雪花（snowflakes）`数组是一个`静态（static）`数组➊。这是因为数组非常大；如果不使用`静态`数组，所需的空间很可能会超过函数可用的内存量。我们使用`static`将数组放置在一个单独的内存块中，在那里空间不是问题。然而，使用`static`时要小心。普通的局部变量在每次调用函数时会被初始化，而`static`变量会保留上一次函数调用时的值（参见第xxvi页的“Static
    关键字”）。
- en: 'Also notice that we’ve allocated an array of 100,000 snowflakes ➊. You might
    be concerned that this is a waste of memory. What if the input has only a few
    snowflakes? For competitive programming problems, it’s generally okay to hardcode
    the memory requirements for the largest problem instance: the test cases are likely
    to stress test your submission on the maximum size anyway!'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另外请注意，我们已经分配了一个包含100,000片雪花的数组➊。你可能会担心这是浪费内存。如果输入只有几片雪花怎么办？对于竞赛编程问题，通常可以为最大问题实例硬编码内存要求：无论如何，测试用例很可能会在最大规模下对你的提交进行压力测试！
- en: The rest of the function is straightforward. We read the number of snow-flakes
    using `scanf`, and we use that number to determine the number of iterations of
    the outer `for` loop. For each such iteration, we loop six times in the inner
    `for` loop, each time reading one integer. We then call `identify_identical` to
    produce the appropriate output.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的部分很简单。我们使用`scanf`读取雪花的数量，并用这个数字来确定外层`for`循环的迭代次数。每次迭代时，我们会在内层`for`循环中循环六次，每次读取一个整数。然后，我们调用`identify_identical`函数，生成相应的输出。
- en: Putting this `main` function together with the other functions we have written
    gives us a complete program that we can submit to the judge. Try it out . . .
    and you should get a “Time-Limit Exceeded” error. It looks like we have more work
    to do!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个`main`函数与我们写的其他函数结合起来，就得到一个完整的程序，可以提交给评测系统。试一下……你应该会看到一个“时间限制超出”错误。看来我们还有工作要做！
- en: Diagnosing the Problem
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 诊断问题
- en: Our first solution was too slow, so we got a “Time-Limit Exceeded” error. Let’s
    understand why.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个解决方案太慢了，因此出现了“时间限制超出（Time-Limit Exceeded）”错误。我们来理解一下为什么。
- en: For our discussion here, we’ll assume that there are no identical snow-flakes.
    This is the worst-case scenario for our code, since then it doesn’t stop processing
    early.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这里的讨论中，我们假设没有相同的雪花。这是我们代码的最坏情况，因为这样它不会提前停止处理。
- en: The reason that our first solution is slow is because of the two nested `for`
    loops in [Listing 1-7](ch01.xhtml#ch01ex07). Those loops compare each snowflake
    to every other snowflake, resulting in a huge number of comparisons when the number
    of snowflakes *n* is large.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个解决方案慢的原因是 [Listing 1-7](ch01.xhtml#ch01ex07) 中的两个嵌套 `for` 循环。这些循环将每个雪花与其他所有雪花进行比较，当雪花数量
    *n* 很大时，会导致进行大量的比较。
- en: 'Let’s figure out the number of snowflake comparisons our program makes. Since
    we might compare each pair of snowflakes, we can restate this question as asking
    for the total number of snowflake pairs. For example, if we have four snowflakes
    numbered 1, 2, 3, and 4, then our scheme performs six snowflake comparisons: Snowflakes
    1 and 2, 1 and 3, 1 and 4, 2 and 3, 2 and 4, and 3 and 4\. Each pair is formed
    by choosing one of the *n* snowflakes as the first snowflake and then choosing
    one of the remaining *n* – 1 snow-flakes as the second snowflake.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算一下我们的程序进行的雪花比较次数。由于我们可能会比较每对雪花，因此我们可以将这个问题重新表述为求雪花对的总数。例如，如果我们有四个编号为 1、2、3
    和 4 的雪花，那么我们的方案会进行六次雪花比较：雪花 1 和 2、1 和 3、1 和 4、2 和 3、2 和 4、以及 3 和 4。每一对由选择一个 *n*
    雪花作为第一个雪花，再选择一个剩下的 *n* – 1 个雪花作为第二个雪花。
- en: For each of *n* decisions for the first snowflake, we have *n* – 1 decisions
    for the second snowflake. This gives a total of *n*(*n* – 1) decisions. However,
    *n*(*n* – 1) double-counts the true number of snowflake comparisons that we make—it
    includes both of the comparisons 1 and 2 and 2 and 1, for example. Our solution
    compares these only once, so we can divide by 2, giving *n*(*n* – 1)/2 snowflake
    comparisons for *n* snowflakes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个雪花的每个 *n* 决策，我们对第二个雪花有 *n* – 1 个决策。这一共会有 *n*(*n* – 1) 次决策。然而，*n*(*n* –
    1) 计算的是比较的总次数，但它重复计算了真实的雪花比较次数——例如，它同时包括了比较 1 和 2 以及比较 2 和 1。我们的解决方案只进行一次比较，所以我们可以除以
    2，从而得到 *n*(*n* – 1)/2 次雪花比较，适用于 *n* 个雪花。
- en: 'This might not seem so bad, but let’s substitute some values of *n* into *n*(*n*
    – 1)/2 and see what happens. Substituting 10 gives 10(9)/2 = 45\. Performing 45
    comparisons is a piece of cake for any computer and can be done in milliseconds.
    How about *n* = 100? That gives 4,950: still no problem. It looks like we’re okay
    for a small *n*, but the problem statement says that we can have up to 100,000
    snowflakes. Go ahead and substitute 100,000 for *n* in *n*(*n* – 1)/2: this gives
    4,999,950,000 snowflake comparisons. If you run a test case with 100,000 snowflakes
    on a typical laptop, it will take something like three minutes. That’s far too
    slow—we need at most one second, not several minutes! As a conservative rule of
    thumb for today’s computers, think of the number of steps that we can perform
    per second as about 30 million. Trying to make nearly 5 billion snowflake comparisons
    in one second is not doable.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来没什么大不了的，但让我们代入一些 *n* 的值到 *n*(*n* – 1)/2 中看看会发生什么。代入 10 得到 10(9)/2 = 45。进行
    45 次比较对于任何计算机来说都轻松可以完成，并且可以在毫秒内完成。那如果 *n* = 100 呢？那会得到 4,950：还是没问题。看起来对于小的 *n*
    我们还可以应付，但问题陈述中说我们最多可以有 100,000 个雪花。试着代入 100,000 到 *n*(*n* – 1)/2 中：得到 4,999,950,000
    次雪花比较。如果你在一台普通笔记本电脑上运行 100,000 个雪花的测试用例，可能需要三分钟左右。这太慢了——我们最多需要一秒钟，而不是几分钟！对于今天的计算机，可以将每秒能执行的步骤数大约看作
    3000 万。试图在一秒钟内进行接近 50 亿次雪花比较是不可行的。
- en: If we expand *n*(*n* – 1)/2, we get *n*²/2 – *n*/2\. The largest exponent there
    is 2\. Algorithm developers therefore call this an *O*(*n*²) algorithm, or a *quadratic-time
    algorithm*. *O*(*n*²) is pronounced “big O of *n* squared,” and you can think
    of it as telling you that the rate at which the amount of work grows is quadratic
    relative to the problem size. For a brief introduction to big O, see [Appendix
    A](app01.xhtml).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们展开 *n*(*n* – 1)/2，会得到 *n*²/2 – *n*/2。这里最大的指数是 2。所以，算法开发者通常将这种算法称为 *O*(*n*²)
    算法，或者叫做 *二次时间算法*。*O*(*n*²) 被读作“*n* 平方的大 O”，你可以理解为它表示工作量的增长速度与问题规模的平方成正比。关于大 O
    的简要介绍，请参见 [附录 A](app01.xhtml)。
- en: We need to make such a large number of comparisons because identical snowflakes
    could show up anywhere in the array. If there were a way to get identical snowflakes
    close together in the array, we could quickly determine whether a particular snowflake
    was part of an identical pair. Maybe we can try sorting the array to get the identical
    snowflakes close together?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做这么多比较，因为相同的雪花可能出现在数组的任何位置。如果有办法把相同的雪花聚集在一起，我们就能快速判断某个雪花是否属于一个相同的配对。或许我们可以尝试通过排序来将相同的雪花靠得更近？
- en: Sorting Snowflakes
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 排序雪花
- en: 'C has a library function called `qsort` that we can use to sort an array. The
    key requirement is a comparison function: it takes pointers to two elements to
    sort, and it returns a negative integer if the first element is less than the
    second, `0` if they are equal, and a positive integer if the first is greater
    than the second. We can use `are_identical` to determine whether two snowflakes
    are equal; if they are, we return `0`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言有一个名为 `qsort` 的库函数，我们可以用它来对数组进行排序。关键要求是一个比较函数：它接收两个待排序元素的指针，如果第一个元素小于第二个，则返回负整数，若相等则返回
    `0`，若第一个元素大于第二个，则返回正整数。我们可以使用 `are_identical` 来判断两个雪花是否相同；如果相同，则返回 `0`。
- en: What does it mean, though, for one snowflake to be less than or greater than
    another? It’s tempting to just agree on some arbitrary rule here. We might say,
    for example, that the snowflake that is “less” is the one whose first differing
    element is smaller than the corresponding element in the other snowflake. We do
    that in [Listing 1-9](ch01.xhtml#ch01ex09).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一个雪花小于或大于另一个雪花是什么意思呢？我们很容易就想在这里达成某种任意的规则。例如，我们可以说，"更小" 的雪花是其第一个不同元素比另一雪花对应元素小的那个雪花。我们在[清单
    1-9](ch01.xhtml#ch01ex09)中做了这个操作。
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 1-9: A comparison function for sorting*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-9：排序用的比较函数*'
- en: 'Unfortunately, sorting in this way will not help us solve our problem. You
    might try writing a program that uses sorting to put identical snow-flakes next
    to each other so that you can find them quickly. But here’s a four-snowflake test
    case that would likely fail on your laptop:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种排序方法并不能帮助我们解决问题。你可能会尝试编写一个程序，使用排序将相同的雪花排列在一起，以便能够快速找到它们。但这是一个四个雪花的测试用例，可能会在你的笔记本电脑上失败：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first and fourth snowflakes are identical—but the message `No two snowflakes
    are alike.` may be output. What’s going wrong?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一和第四个雪花是相同的——但是可能会输出消息`No two snowflakes are alike.`。出了什么问题？
- en: 'Here are two facts that `qsort` might learn as it executes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `qsort` 在执行过程中可能学到的两个事实：
- en: Snowflake 4 is less than Snowflake 2.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 雪花 4 小于雪花 2。
- en: Snowflake 2 is less than Snowflake 1.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 雪花 2 小于雪花 1。
- en: From this, `qsort` could conclude that Snowflake 4 is less than Snowflake 1,
    without ever directly comparing Snowflake 4 and Snowflake 1! Here it’s relying
    on the transitive property of less than. If *a* is less than *b*, and *b* is less
    than *c*, then surely *a* should be less than *c*. It seems like our definitions
    of “less” and “greater” matter after all.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，`qsort` 可以得出雪花 4 小于雪花 1，而无需直接比较雪花 4 和雪花 1！这里它依赖于“小于”的传递性。如果 *a* 小于 *b*，且
    *b* 小于 *c*，那么 *a* 当然应该小于 *c*。看来我们对“更小”和“更大”的定义最终还是很重要的。
- en: Unfortunately, it isn’t clear how one would define “less” and “greater” on snowflakes
    so as to satisfy transitivity. If you’re disappointed, perhaps you can take solace
    in the fact that we’ll be able to develop a faster solution without using sorting
    at all.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前并不清楚如何在雪花上定义“小于”和“大于”，以满足传递性。如果你感到失望，也许可以安慰自己，因为我们将能够开发一个不使用排序的更快解决方案。
- en: In general, collecting similar values with sorting can be a useful data-processing
    technique. As a bonus, good sorting algorithms run quickly— certainly faster than
    *O*(*n*²), but we aren’t going to be able to use sorting here.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，利用排序将相似的值聚集在一起是一种有用的数据处理技巧。作为额外的好处，好的排序算法运行速度很快——肯定比 *O*(*n*²) 快，但我们在这里无法使用排序。
- en: '*Solution 2: Doing Less Work*'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案 2：做更少的工作*'
- en: Comparing all pairs of snowflakes and trying to sort the snowflakes proved to
    be too much work. To work up to our next, and ultimate, solution, let’s pursue
    the idea of trying to avoid comparing snowflakes that are obviously not identical.
    For example, if we have snowflakes
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 比较所有雪花的配对并尝试对雪花进行排序，结果证明工作量太大。为了朝着下一个、也是最终的解决方案迈进，让我们探索避免比较显然不相同的雪花的思路。例如，如果我们有雪花
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: and
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: there’s no way that these snowflakes can be identical. We shouldn’t even waste
    our time comparing them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些雪花肯定不可能是相同的。我们甚至不应该浪费时间去比较它们。
- en: 'The numbers in the second snowflake are very different from the numbers in
    the first snowflake. To devise a way to detect that two snowflakes are different
    without having to directly compare them, we might begin by comparing the snowflake’s
    first elements, because 1 is very different from 82\. But now consider these two
    snowflakes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个雪花中的数字与第一个雪花中的数字差异很大。为了设计一种方法来检测两个雪花是否不同，而无需直接比较它们，我们可以从比较雪花的第一个元素开始，因为1和82差别很大。但现在考虑这两种雪花：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: and
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以及
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These two snowflakes *are* identical even though 3 is very different from 82\.
    We need to do more than just look at first elements.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管3与82差异很大，这两个雪花*是*相同的。我们需要做的远不止只看第一个元素。
- en: A quick litmus test for determining whether two snowflakes might be identical
    is to use the *sum* of their elements. When we sum our two example snowflakes,
    for `1, 2, 3, 4, 5, 6`, we get a total of 21, and for `82, 100, 3, 1, 2, 999`,
    we get 1,187\. We say that the *code* for the former snowflake is 21 and the code
    for the latter is 1,187.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 判断两个雪花是否可能相同的快速测试是使用它们元素的*和*。当我们将两个示例雪花的元素求和时，`1, 2, 3, 4, 5, 6`的总和为21，`82,
    100, 3, 1, 2, 999`的总和为1,187。我们说，第一个雪花的*代码*是21，第二个雪花的代码是1,187。
- en: 'Our hope is that we can throw the “21 snowflakes” in one bin and throw the
    “1,187 snowflakes” in another, and then we never have to compare the 21s to the
    1,187s. We can do this binning for each snowflake: add up its elements, get a
    code of *x*, and then store it along with all of the other snow-flakes with code
    *x*.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的希望是将“21代码的雪花”放进一个箱子，将“1,187代码的雪花”放进另一个箱子，然后我们就再也不需要将21和1,187的雪花进行比较了。我们可以为每个雪花执行这样的分箱操作：将它的元素加起来，得到一个*代码*，然后将它与所有具有相同代码*代码*的雪花一起存储。
- en: Of course, finding two snowflakes with a code of 21 does not guarantee they
    are identical. For example, both `1, 2, 3, 4, 5, 6` and `16, 1, 1, 1, 1, 1` have
    a code of 21, and they are surely not identical.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，找到两个代码为21的雪花并不能保证它们是相同的。例如，`1, 2, 3, 4, 5, 6`和`16, 1, 1, 1, 1, 1`的代码都是21，但它们肯定不是相同的。
- en: That’s okay, because our “sum” rule is designed to weed out snowflakes that
    are clearly not identical. This allows us to avoid comparing all pairs—the source
    of the inefficiency in Solution 1—and only compare pairs that have not been filtered
    out as obviously nonidentical.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这没关系，因为我们的“和”规则旨在排除明显不相同的雪花。这使我们能够避免比较所有的配对——这是方案1中低效的根源——只比较那些没有被过滤掉的、显然不同的配对。
- en: 'In Solution 1, we stored each snowflake consecutively in the array: the first
    snowflake at index `0`, the second at index `1`, and so on. Here, our storage
    strategy is different: sum codes determine snowflakes’ locations in the array!
    That is, for each snowflake, we calculate its code and use that code as the index
    for where to store the snowflake.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在方案1中，我们将每个雪花按顺序存储在数组中：第一个雪花存储在索引`0`，第二个存储在索引`1`，以此类推。在这里，我们的存储策略不同：求和代码决定了雪花在数组中的位置！也就是说，对于每个雪花，我们计算它的代码，并将该代码作为存储雪花的索引。
- en: 'We have to solve two problems:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决两个问题：
- en: Given a snowflake, how do we calculate its code?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一朵雪花，我们如何计算它的代码？
- en: What do we do when multiple snowflakes have the same code?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当多个雪花具有相同代码时，我们该怎么办？
- en: Let’s deal with calculating the code first.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理计算代码的问题。
- en: Calculating Sum Codes
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计算求和代码
- en: 'At first glance, calculating the code seems easy. We could just sum all of
    the numbers within each snowflake like so:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，计算代码似乎很简单。我们可以像这样将每个雪花中的所有数字加起来：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This works fine for many snowflakes, such as `1, 2, 3, 4, 5, 6`, and `82, 100,
    3, 1, 2, 999`, but consider a snowflake with huge numbers, such as
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这对许多雪花有效，例如`1, 2, 3, 4, 5, 6`和`82, 100, 3, 1, 2, 999`，但考虑一下具有大数字的雪花，例如
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code that we calculate is `21000000`. We plan to use that code as the *index*
    in an array that holds the snowflakes, so to accommodate this, we’d have to declare
    an array with room for 21 million elements. As we’re using at most 100,000 elements
    (one for each snowflake), this is an outrageous waste of memory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算出的代码是`21000000`。我们计划将这个代码作为数组中的*索引*来存储雪花，因此为了容纳它，我们必须声明一个可以存储2100万个元素的数组。由于我们最多使用100,000个元素（每个雪花一个），这将是一个极为浪费内存的做法。
- en: We’re going to stick with an array that has room for 100,000 elements. We’ll
    need to calculate a snowflake’s code as before, but then we must force that code
    to be a number between `0` and `99999` (the minimum and maximum index in our array).
    One way to do this is to break out the `%` (mod) operator again. Taking a nonnegative
    integer mod *x* yields an integer between 0 and *x* – 1\. No matter the sum of
    a snowflake, if we take it mod 100,000, we’ll get a valid index in our array.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用一个可以容纳100,000个元素的数组。我们需要像之前一样计算雪花的代码，但之后必须将该代码强制转换为`0`到`99999`之间的数字（我们数组中的最小和最大索引）。实现这一点的一种方法是再次使用`%`（模）运算符。对一个非负整数取模*x*会得到一个介于0和*x*
    – 1之间的整数。无论雪花的和是多少，只要对其取模100,000，我们就能得到一个有效的数组索引。
- en: 'This method has one downside: taking the mod like this will force *more* nonidentical
    snowflakes to end up with the same code. For example, the sums for `1, 1, 1, 1,
    1, 1` and `100001, 1, 1, 1, 1, 1` are different—`6` and `100006`—but once we take
    them mod 100,000, we get `6` in both cases. This is an acceptable risk to take:
    we’ll just hope that this doesn’t happen much; when it does, we’ll perform the
    necessary pairwise comparisons.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个缺点：像这样取模会强制*更多*不同的雪花最终得到相同的代码。例如，`1, 1, 1, 1, 1, 1`和`100001, 1, 1, 1,
    1, 1`的和是不同的——`6`和`100006`——但一旦对它们取模100,000，结果都是`6`。这是一个可以接受的风险：我们只希望这种情况不会发生得太频繁；当它发生时，我们将进行必要的逐对比较。
- en: We’ll calculate the sum code for a snowflake and mod it, as displayed in [Listing
    1-10](ch01.xhtml#ch01ex010).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算雪花的和并对其取模，如[清单 1-10](ch01.xhtml#ch01ex010)中所示。
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 1-10: Calculating the snowflake code*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-10：计算雪花代码*'
- en: Snowflake Collisions
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 雪花碰撞
- en: 'In Solution 1, we used the following fragment to store a snowflake at index
    `i` in the `snowflakes` array:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案1中，我们使用了以下片段将一个雪花存储在`snowflakes`数组的索引`i`处：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This worked because exactly one snowflake was stored in each row of the two-dimensional
    array.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有效，是因为二维数组的每一行只存储一个雪花。
- en: However, now we have to contend with the `1, 1, 1, 1, 1, 1` and `100001, 1,
    1, 1, 1, 1` kind of collision, where, because they’ll end up with the same mod
    code and that code serves as the snowflakes index in the array, we need to store
    multiple snowflakes in the same array element. That is, each array element will
    no longer be one snowflake but a collection of zero or more snowflakes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们必须处理`1, 1, 1, 1, 1, 1`和`100001, 1, 1, 1, 1, 1`类型的碰撞问题，因为它们最终会得到相同的模代码，而该代码作为雪花在数组中的索引，我们需要在同一个数组元素中存储多个雪花。也就是说，每个数组元素将不再是一个雪花，而是零个或多个雪花的集合。
- en: One way to store multiple elements at the same array index is to use a *linked
    list*, a data structure that links each element to the next. Here, each element
    in the snowflakes array will point to the first snowflake in the linked list;
    the remainder of the snowflakes can be accessed through `next` pointers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 存储多个元素在同一数组索引中的一种方法是使用*链表*，一种将每个元素与下一个元素连接起来的数据结构。在这里，雪花数组中的每个元素将指向链表中的第一个雪花；剩余的雪花可以通过`next`指针访问。
- en: 'We’ll use a typical linked list implementation. Each `snowflake_node` contains
    both a snowflake and a pointer to the next snowflake. To collect these two components,
    we’ll use a struct. We’ll also make use of `typedef`, which allows us to later
    use `snowflake_node` instead of the full `struct snowflake_node`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用典型的链表实现。每个`snowflake_node`包含一个雪花和指向下一个雪花的指针。为了收集这两个组件，我们将使用一个结构体。我们还会使用`typedef`，这让我们可以后续使用`snowflake_node`代替完整的`struct
    snowflake_node`：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This change necessitates updates to two functions, `main` and `identify_identical`,
    because those functions use our old two-dimensional array.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化需要更新两个函数，`main`和`identify_identical`，因为这两个函数使用了我们之前的二维数组。
- en: The New main Function
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 新的主函数
- en: You can see the updated `main` code in [Listing 1-11](ch01.xhtml#ch01ex011).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[清单 1-11](ch01.xhtml#ch01ex011)中看到更新后的`main`代码。
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 1-11: The* main *function for Solution 2*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-11：解决方案2的*main*函数*'
- en: Let’s walk through this code. First, notice that we changed the type of our
    array from a two-dimensional array of numbers to a one-dimensional array of pointers
    to snowflake nodes ➊. We also declare `snow` ➋, which will point to snowflake
    nodes that we allocate.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这段代码。首先，注意到我们将数组的类型从一个二维数字数组更改为一个一维指向雪花节点的指针数组 ➊。我们还声明了`snow` ➋，它将指向我们分配的雪花节点。
- en: We use `malloc` to allocate memory for each `snowflake_node` ➌. Once we have
    read in and stored the six numbers for a snowflake ➍, we use `snowflake_code`
    to hold the snowflake’s code ➎, calculated using the function we wrote in [Listing
    1-10](ch01.xhtml#ch01ex010).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`malloc`为每个`snowflake_node`分配内存 ➌。当我们读取并存储了一个雪花的六个数字 ➍后，我们使用`snowflake_code`来保存雪花的代码
    ➎，该代码是通过我们在[列表 1-10](ch01.xhtml#ch01ex010)中编写的函数计算得出的。
- en: 'The last thing to do is to add the snowflake to the `snowflakes` array, which
    amounts to adding a node to a linked list. We do this by inserting the snow-flake
    at the beginning of the linked list. We first point the inserted node’s `next`
    pointer to the first node in the list ➏, and then we set the start of the list
    to point to the inserted node ❼. The order matters here: if we had reversed the
    order of these two lines, we would lose access to the elements already in the
    linked list!'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将雪花添加到`snowflakes`数组中，这相当于向链表中添加一个节点。我们通过将雪花插入到链表的开头来完成此操作。我们首先将插入节点的`next`指针指向链表中的第一个节点
    ➏，然后将链表的起始点指向插入的节点 ❼。这里的顺序很重要：如果我们反转这两行的顺序，之前已经在链表中的元素将无法访问！
- en: Notice that, in terms of correctness, it doesn’t matter where in the linked
    list we add the new node. It could go at the beginning, the end, or somewhere
    in the middle—it’s our choice. So we should do whatever is fastest, and adding
    to the beginning is fastest because it doesn’t require us to traverse the list
    at all. If we instead chose to add an element to the end of a linked list, we’d
    have to traverse the entire list. If that list had a million elements, we’d have
    to follow the next pointers a million times until we got to the end—that would
    be very slow!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，就正确性而言，我们在链表中添加新节点的位置并不重要。它可以添加到开头、结尾或中间——这由我们决定。所以我们应该选择最快的方式，而将节点添加到开头是最快的，因为这不需要遍历整个链表。如果我们选择将元素添加到链表的末尾，则必须遍历整个链表。如果这个链表有一百万个元素，我们就得跟随`next`指针一百万次，直到到达末尾——那会非常慢！
- en: 'Let’s work on a quick example of how this `main` function works. Here’s the
    test case:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个关于`main`函数如何工作的快速示例。以下是测试用例：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Each element of `snowflakes` begins as `NULL`, the empty linked list. As we
    add to `snowflakes`, elements will begin to point at snowflake nodes. The numbers
    in the first snowflake add up to 21, so it goes into index `21`. The second snowflake
    goes into index `49`. The third snowflake goes into index `21`. At this point,
    index `21` is a linked list of *two* snowflakes: `16, 1, 1, 1, 1, 1` followed
    by `1, 2, 3, 4, 5, 6`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`snowflakes`中的每个元素最初都是`NULL`，即空链表。当我们向`snowflakes`中添加元素时，元素将开始指向雪花节点。第一个雪花的数字之和为21，因此它进入了索引`21`。第二个雪花进入了索引`49`。第三个雪花进入了索引`21`。此时，索引`21`处的链表包含*两个*雪花：`16,
    1, 1, 1, 1, 1`后面跟着`1, 2, 3, 4, 5, 6`。'
- en: How about the fourth snowflake? That goes into index `21` again, and now we
    have a linked list of three snowflakes there. See [Figure 1-3](ch01.xhtml#ch01fig03)
    for the hash table that we’ve built.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 那第四个雪花呢？它又进入了索引`21`，现在我们在该位置有了一个包含三个雪花的链表。请参见[图 1-3](ch01.xhtml#ch01fig03)了解我们构建的哈希表。
- en: '![Image](../images/ch01fig03.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch01fig03.jpg)'
- en: '*Figure 1-3: A hash table with four snowflakes*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-3：包含四个雪花的哈希表*'
- en: There are multiple snowflakes in index `21`. Does this mean that we have identical
    snowflakes? No! This emphasizes the fact that a linked list with multiple elements
    is not sufficient evidence to claim that we have identical snowflakes. We have
    to compare each pair of those elements to correctly state our conclusion. That’s
    the final piece of the puzzle.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`21`中有多个雪花。这是否意味着我们有相同的雪花？不！这强调了这样一个事实：一个包含多个元素的链表不足以证明我们有相同的雪花。我们必须比较这些元素中的每一对，才能正确地得出结论。这是谜题的最后一块拼图。
- en: The New identify_identical Function
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 新的 `identify_identical` 函数
- en: We need `identify_identical` to make all pairwise comparisons of snowflakes
    within each linked list. [Listing 1-12](ch01.xhtml#ch01ex012) shows the code to
    do so.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`identify_identical`来在每个链表中进行所有雪花的成对比较。[列表 1-12](ch01.xhtml#ch01ex012)展示了实现该功能的代码。
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 1-12: Identifying identical snowflakes in linked lists*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-12：在链表中识别相同的雪花*'
- en: We begin with `node1` at the first node in a linked list ➊. We use `node2` to
    traverse from the node to the right of `node1` ➋ all the way to the end of the
    linked list. This compares the first snowflake in the linked list to all other
    snowflakes in that linked list. We then advance `node1` to the second node ➌,
    and we compare that second snowflake to each snowflake to its right. We repeat
    this until `node1` reaches the end of the linked list.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`node1`开始，位于链表的第一个节点➊。我们使用`node2`从`node1`右侧的节点➋开始遍历，直到链表的末尾。这样，我们将链表中的第一个雪花与该链表中所有其他雪花进行比较。然后我们将`node1`移动到第二个节点➌，并将第二个雪花与右侧的每个雪花进行比较。我们一直重复这个过程，直到`node1`到达链表的末尾。
- en: This code is dangerously similar to `identify_identical` from Solution 1 ([Listing
    1-7](ch01.xhtml#ch01ex07)), which made all pairwise comparisons between any two
    snow-flakes. By contrast, our new code only makes pairwise comparisons within
    a single linked list. But what if someone crafts a test case where all snowflakes
    end up in the same linked list? Wouldn’t the performance then be as bad as in
    Solution 1? It would, yes, but absent such nefarious data, we’re in great shape.
    Take a minute to submit Solution 2 to the judge and see for yourself. You should
    see that we’ve discovered a much more efficient solution! What we’ve done is use
    a data structure called a hash table. We’ll learn more about hash tables next.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与解决方案1中的`identify_identical`非常相似（见[列表 1-7](ch01.xhtml#ch01ex07)），它对所有雪花进行了两两比较。相比之下，我们的新代码仅在单个链表内进行两两比较。但如果有人构造了一个测试用例，将所有雪花都放入同一个链表中呢？那样的话，性能是不是会和解决方案1一样差？是的，确实会，但在没有这样的恶意数据时，我们的性能就很好。花一点时间提交解决方案2给评测系统，亲自看看效果。你应该会发现我们找到了一个更高效的解决方案！我们做的是使用了一种叫做哈希表的数据结构。接下来我们会深入了解哈希表。
- en: Hash Tables
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希表
- en: 'A *hash table* consists of two things:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈希表*由两部分组成：'
- en: An array. Locations in the array are referred to as *buckets*.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个数组。数组中的位置称为*桶*。
- en: A *hash function*, which takes an object and returns its code as an index into
    the array.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*哈希函数*，它接收一个对象并返回其代码作为数组的索引。'
- en: The code returned by the hash function is referred to as a *hashcode*; that
    code determines at which index an object is stored or *hashed*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数返回的代码称为*哈希码*；该代码决定了对象存储或*哈希*的位置。
- en: Look closely at what we did in [Listings 1-10](ch01.xhtml#ch01ex010) and [1-11](ch01.xhtml#ch01ex011)
    and you’ll see that we already have both of these things. That `code` function,
    which took a snow-flake and produced its code (a number between 0 and 99,999),
    is a hash function; and that `snowflakes` array is the array of buckets, where
    each bucket contains a linked list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看我们在[列表 1-10](ch01.xhtml#ch01ex010)和[1-11](ch01.xhtml#ch01ex011)中的操作，你会发现我们已经有了这两项内容。那个`code`函数，它接收一个雪花并生成它的代码（一个0到99,999之间的数字），就是一个哈希函数；而那个`snowflakes`数组就是桶数组，每个桶里包含一个链表。
- en: '*Hash Table Design*'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*哈希表设计*'
- en: Designing a hash table involves many design decisions. Let’s talk about three
    of them here.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 设计哈希表涉及许多设计决策。这里我们将讨论其中的三项。
- en: The first decision concerns size. In Unique Snowflakes, we used an array size
    of 100,000\. We could have instead used a smaller or larger array. A smaller array
    saves memory. For example, on initialization, a 50,000-element array stores half
    as many `NULL` values as does a 100,000-element array. However, a smaller array
    leads to more objects ending up in the same bucket. When objects end up in the
    same bucket, we say that a *collision* has occurred. The problem with having many
    collisions is that they lead to long linked lists. Ideally, all of the linked
    lists would be short so that we wouldn’t have to walk through and do work on many
    elements. A larger array avoids some of these collisions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个决策是大小。在《独特的雪花》项目中，我们使用了100,000的数组大小。我们也可以选择使用更小或更大的数组。较小的数组节省内存。例如，在初始化时，50,000个元素的数组存储的`NULL`值是100,000个元素数组的一半。然而，较小的数组会导致更多的对象落入同一个桶中。当多个对象落入同一个桶时，我们说发生了*碰撞*。碰撞过多的问题在于它们会导致长链表。理想情况下，所有的链表都应该很短，这样我们就不需要遍历并处理很多元素。较大的数组可以避免一些碰撞。
- en: To summarize, we have a memory–time tradeoff here. Make the hash table too small
    and collisions run rampant. Make the hash table too big and memory waste becomes
    a concern. In general, try to choose an array size that’s a reasonable percentage—such
    as 20 percent or 50 percent or 100 percent—of the maximum number of elements you
    expect to insert into the hash table.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们这里存在一个内存-时间的权衡。哈希表太小会导致碰撞泛滥，哈希表太大则会浪费内存。一般来说，尝试选择一个合理的数组大小，比如最大元素数量的20%、50%或100%，作为哈希表中元素的预计数量。
- en: In Unique Snowflakes, we used an array size of 100,000 to match the maximum
    number of snowflakes; had we been constrained to use less memory, smaller arrays
    would have worked just fine as well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在“独特的雪花”示例中，我们使用了100,000的数组大小来匹配雪花的最大数量；如果我们被限制使用更少的内存，较小的数组也能很好地工作。
- en: The second consideration is our hash function. In Unique Snowflakes, our hash
    function adds up a snowflake’s numbers mod 100,000\. Importantly, this hash function
    guarantees that, if two snowflakes are identical, they will end up in the same
    bucket. (They might also end up in the same bucket if they are not identical,
    of course.) This is the reason why we can search within linked lists, and not
    between them, for identical snowflakes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个考虑因素是我们的哈希函数。在“独特的雪花”示例中，我们的哈希函数将雪花的数字加起来，取模100,000。重要的是，这个哈希函数保证了，如果两个雪花是相同的，它们将被哈希到同一个桶中。（当然，如果它们不相同，它们也可能被哈希到同一个桶中。）这就是为什么我们可以在链表内查找，而不是在链表之间查找相同雪花的原因。
- en: When solving a problem with a hash table, the hash function that we use should
    take into account what it means for two objects to be identical. If two objects
    are identical, then the hash function must hash them to the same bucket. In the
    case in which two objects must be exactly equal to be considered “identical,”
    we can scramble things so extensively that the mapping between object and bucket
    is far more intricate than what we did with the snowflakes. Check out the `oaat`
    (one-at-a-time) hash function in [Listing 1-13](ch01.xhtml#ch01ex013) for an example.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用哈希表解决问题时，我们所用的哈希函数应该考虑到什么情况下两个对象是相同的。如果两个对象相同，那么哈希函数必须将它们哈希到同一个桶中。如果两个对象必须完全相同才能被认为是“相同的”，我们可以进行复杂的混淆，使得对象与桶之间的映射远比我们在雪花示例中做的更为复杂。查看[清单
    1-13](ch01.xhtml#ch01ex013)中的`oaat`（逐个处理）哈希函数，了解一个例子。
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 1-13: An intricate hash function*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-13：一个复杂的哈希函数*'
- en: 'To call `oaat` ➊ as we do in the `main` function, we pass three parameters:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了像我们在`main`函数中那样调用`oaat` ➊，我们需要传入三个参数：
- en: key   The data that we want to hash (here, we’re hashing the `word` string)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: key    我们希望哈希的数据（这里是我们正在哈希的`word`字符串）
- en: len   The length of those data (here, the length of the `word` string)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: len    数据的长度（这里是`word`字符串的长度）
- en: bits   The number of bits that we want in the resulting hashcode (here, 17)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: bits   我们希望得到的哈希码的位数（这里是17）
- en: The maximum value that a hashcode could have is one less than 2 to the power
    of `bits`. For example, if we choose 17, then 2^(17) – 1 = 131,071 is the maximum
    that a hashcode could be.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希码的最大值是`bits`次方减去1。例如，如果我们选择17，那么2^(17) - 1 = 131,071就是哈希码的最大值。
- en: 'How does `oaat` work? Inside the `for` loop, it starts by adding the current
    byte of the key. That part is similar to what we did when adding up the numbers
    in a snowflake ([Listing 1-10](ch01.xhtml#ch01ex010)). Those left shifts and exclusive
    ors are in there to put the key through a blender. Hash functions do this blending
    to implement an *avalanche effect*, which means that a small change in the key’s
    bits makes a huge change to the key’s hashcode. Unless you intentionally created
    pathological data for this hash function or inserted a huge number of keys, it
    would be unlikely that you’d get many collisions. This highlights an important
    point: with a single hash function, there is *always* a collection of data that
    will lead to collisions galore and subsequently horrible performance. A fancy
    hash function like `oaat` can’t protect against that. Unless we’re concerned about
    malicious input, though, we can often get away with using a reasonably good hash
    function and can assume that it will spread the data around.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`oaat`是如何工作的？在`for`循环内部，它首先将当前字节的键值添加进去。这个部分类似于我们在计算雪花中的数字和时做的事情（[清单1-10](ch01.xhtml#ch01ex010)）。这些左移和异或操作的目的是将键值进行混合。哈希函数通过这种混合实现*雪崩效应*，也就是说，键的位发生细微变化时，会导致键的哈希值发生巨大变化。除非你故意为这个哈希函数创建了病态数据或插入了大量的键，否则很难发生多次碰撞。这突显了一个重要的观点：对于单个哈希函数，总是存在一组数据会导致大量碰撞，进而带来糟糕的性能。像`oaat`这样的复杂哈希函数无法防止这一点。不过，除非我们担心恶意输入，否则通常可以使用一个相当不错的哈希函数，并假设它能有效地分散数据。'
- en: Indeed, this is why using our hash table solution (Solution 2) for Unique Snowflakes
    was so successful. We used a good hash function that distributes many nonidentical
    snowflakes into different buckets. Since we’re not securing our code from attack,
    we don’t have to worry about some evil person studying our code and figuring out
    a way to cause millions of collisions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，这就是我们使用哈希表解决方案（解决方案2）来处理独特雪花问题如此成功的原因。我们使用了一个优秀的哈希函数，将许多不同的雪花分配到不同的桶中。由于我们没有保护代码免受攻击，因此不需要担心某个恶意人物研究我们的代码并找到方法造成数百万次碰撞。
- en: For our third and final design decision, we have to think about what we want
    to use as our buckets. In Unique Snowflakes, we used a linked list as each bucket.
    Using linked lists like this is known as a *chaining* scheme.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第三个也是最后一个设计决策，我们需要考虑使用什么作为桶。在独特雪花中，我们将链表作为每个桶的存储结构。像这样使用链表被称为*链式法*。
- en: In another approach, known as *open-addressing*, each bucket holds at most one
    element, and there are no linked lists. To deal with collisions, we search through
    buckets until we find one that is empty. For example, suppose that we try to insert
    an object into bucket number 50, but Bucket 50 is already occupied. We might then
    try Bucket 51, then 52, then 53, stopping when we find an empty bucket. Unfortunately,
    this simple sequence can lead to poor performance when a hash table has many elements
    stored in it, so more nuanced search schemes are often used in practice.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法被称为*开放寻址法*，每个桶最多存放一个元素，并且没有链表。为了解决碰撞问题，我们会遍历桶，直到找到一个空桶。例如，假设我们尝试将一个对象插入到桶号50中，但桶50已经被占用了。那么我们可能会尝试桶51，再试桶52，再试桶53，直到找到一个空桶。不幸的是，这种简单的序列在哈希表中存储了许多元素时，可能导致较差的性能，因此在实践中通常会使用更复杂的查找方案。
- en: Chaining is generally easier to implement than open-addressing, which is why
    we used chaining for Unique Snowflakes. However, open-addressing does have some
    benefits, including saving memory by not using linked list nodes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 链接法通常比开放寻址法更容易实现，这也是我们在独特雪花问题中使用链接法的原因。然而，开放寻址法确实有一些优点，包括通过不使用链表节点来节省内存。
- en: '*Why Use Hash Tables?*'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为什么使用哈希表？*'
- en: Using a hash table turbocharges our solution to Unique Snowflakes. On a typical
    laptop, a test case with 100,000 elements will take only a fraction of a second
    to run! No pairwise comparisons of all elements and no sorting is needed, just
    a little processing on a bunch of linked lists.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希表大大加速了我们解决独特雪花问题的方案。在典型的笔记本电脑上，处理包含100,000个元素的测试用例只需几分之一秒的时间！不需要进行元素之间的配对比较，也不需要排序，只需对一堆链表进行一些处理。
- en: Recall that we used an array size of 100,000\. The maximum number of snowflakes
    that can be presented to our program is also 100,000\. If we’re given 100,000
    snowflakes and assume the perfect scenario of each one going into its own bucket,
    then we’d have only one snowflake per linked list. If we have a little bad luck,
    then maybe a few of those snowflakes will collide and end up in the same bucket.
    In the absence of pathological data, though, we expect that each linked list will
    have at most a few elements. As such, making all pairwise comparisons within a
    bucket will take only a small, constant number of steps. We expect hash tables
    to give us a *linear-time* solution, because we take a constant number of steps
    in each of the *n* buckets. So we take something like *n* steps, in comparison
    to the *n*(*n* – 1)/2 formula we had for Solution 1\. In terms of big O, we’d
    say that we expect an *O*(*n*) solution.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们使用的数组大小是100,000。我们程序中最多可以处理的雪花数量也是100,000。如果我们给定100,000个雪花，并假设每个雪花都放入自己的桶中，那么每个链表中将只有一个雪花。如果我们运气稍差，可能会有几个雪花发生碰撞并进入同一个桶。不过，在没有病态数据的情况下，我们预计每个链表最多只有几个元素。因此，在一个桶内进行所有成对比较只需要很少的常数步骤。我们预计哈希表能提供一个*线性时间*的解决方案，因为我们在每个*n*个桶中都只进行常数次数的步骤。所以我们预计需要大约*n*步，而不是我们在解决方案1中使用的*n*（*n*
    – 1）/2公式。从大O的角度来看，我们预计会得到一个*O*(*n*)的解决方案。
- en: Whenever you’re working on a problem and you find yourself repeatedly searching
    for some element, consider using a hash table. A hash table takes a slow array
    search and converts it into a fast lookup. For some problems, you may be able
    to sort an array rather than use a hash table. A technique called binary search
    (discussed in [Chapter 7](ch07.xhtml)) could then be used to quickly search for
    elements in the sorted array. But often—such as in Unique Snowflakes and the problem
    we’ll solve next—that won’t work. Hash tables to the rescue!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在解决一个问题时发现自己反复搜索某个元素时，可以考虑使用哈希表。哈希表将慢速的数组搜索转换为快速查找。对于某些问题，你可能能通过排序数组而不是使用哈希表来解决。此时，可以使用一种叫做二分查找的技术（在[第7章](ch07.xhtml)中讨论）来快速查找已排序数组中的元素。但通常——就像在独特雪花问题和我们接下来要解决的问题中——那是行不通的。哈希表来救援！
- en: 'Problem 2: Login Mayhem'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题2：登录混乱
- en: Let’s go through another problem and pay attention to where a naive solution
    would rely on a slow search. We’ll then drop in a hash table to cause a dramatic
    speedup. We’ll go a little more quickly than we did for Unique Snowflakes because
    now we know what to look for.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看一个问题，并注意一个天真的解决方案如何依赖于慢速搜索。然后，我们将引入哈希表来实现显著的加速。我们会比解决独特雪花问题时快一点，因为现在我们知道该注意什么了。
- en: This is DMOJ problem `coci17c1p3hard`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`coci17c1p3hard`。
- en: '*The Problem*'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: To log in to your account on a social network website, you’d expect that only
    your password would work—no one should be able to use a different password to
    get into your account. For example, let’s say that your password is `dish`. (That’s
    a terribly weak password—don’t actually use that anywhere!) To log in to your
    account, someone would need to enter exactly `dish` as the password. That’s just
    how logins work.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要登录社交网站上的账户，你会期望只有你的密码有效——没有人能用其他密码进入你的账户。例如，假设你的密码是`dish`。（这是一个非常弱的密码——千万不要在任何地方使用它！）要登录你的账户，某人需要输入准确的`dish`作为密码。这就是登录的工作原理。
- en: 'But now imagine that you are wanting to join a (hopefully theoretical) social
    network website that has a major security concern: other passwords besides yours
    can be used to get into your account! Specifically, if someone tries a password
    that has your password as a substring, then they’re in. If your password were
    `dish`, for example, then passwords like `brandish` and `radishes` would work
    to get into your account because the string `dish` is in them. You don’t know
    what password to choose for your account—so at various points you will ask: “If
    I chose this password, how many current users’ passwords would get in to my account?”'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在想象一下，你想加入一个（希望是理论上的）社交网络网站，这个网站有一个重大的安全问题：除了你的密码，其他密码也可以用来进入你的账户！具体来说，如果某人尝试一个包含你密码作为子字符串的密码，那么他们就能进入。如果你的密码是`dish`，那么像`brandish`和`radishes`这样的密码也能用来进入你的账户，因为字符串`dish`包含在其中。你不知道该为你的账户选择什么密码——所以你会在不同的时刻问自己：“如果我选择了这个密码，有多少当前用户的密码能够进入我的账户？”
- en: 'We need to support two types of operations:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要支持两种类型的操作：
- en: '**Add**   Sign up a new user with the given password.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加**   使用给定的密码注册一个新用户。'
- en: '**Query**   Given a proposed password *p*, return the number of current users’
    passwords that could be used to get into an account whose password is *p*.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询**   给定一个提议密码 *p*，返回当前用户密码中有多少个可以用来进入密码为 *p* 的账户。'
- en: Input
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of the following lines:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含以下几行：
- en: A line containing *q*, the number of operations to be performed. *q* is between
    1 and 100,000.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 *q* 的一行，表示要执行的操作次数。*q* 介于 1 和 100,000 之间。
- en: '*q* lines, each giving one add or query operation to be performed.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q* 行，每行执行一个添加或查询操作。'
- en: 'Here are the operations that can be performed in those *q* lines:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以在 *q* 行中执行的操作：
- en: An add operation is specified as the number `1`, a space, and then the new user’s
    password. It indicates that a new user has joined with the provided password.
    This operation doesn’t result in any output.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加操作以数字 `1` 开头，后跟一个空格和新用户的密码。它表示一个新用户已加入，并使用提供的密码。此操作不会产生任何输出。
- en: A query operation is specified as the number `2`, a space, and then a proposed
    password *p*. It indicates that we should output the number of current users’
    passwords that could be used to get into an account whose password is *p*.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询操作以数字 `2` 开头，后跟一个空格和提议的密码 *p*。它表示我们应当输出能够进入密码为 *p* 的账户的当前用户密码的数量。
- en: All passwords provided in these operations are between 1 and 10 lowercase characters.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在这些操作中提供的密码都是由 1 到 10 个小写字母组成。
- en: Output
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: Output the result of each query operation, one per line.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 输出每个查询操作的结果，每行一个。
- en: The time limit for solving the test case is three seconds.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制是三秒钟。
- en: '*Solution 1: Looking at All Passwords*'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案 1：查看所有密码*'
- en: Let’s work through a test case to make sure that we know exactly what we’re
    being asked to do.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个测试用例来确保我们完全理解需要做什么。
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can tell from the first line ➊ that there are 6 operations for us to perform.
    The first operation ➋ asks us how many of the existing users’ passwords would
    get into an account whose password is `dish`. Well, there are no existing users,
    so the answer is `0`!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一行 ➊ 可以看出我们需要执行 6 次操作。第一次操作 ➋ 问我们有多少个现有用户的密码能够进入一个密码为 `dish` 的账户。好吧，当前没有任何用户，所以答案是
    `0`！
- en: Next, we add three user passwords, and then we get to our next query operation
    ➌. Now we’re being asked about `dish` in the context of these three passwords.
    You might be thinking that we need to search through the existing passwords to
    count up the ones that have `dish` in them. (Hmmm, searching! That’s our first
    inkling that a hash table may be needed here.) If you do that, you’ll find that
    two of the passwords—`brandish` and `radishes`—have `dish` in them. The answer
    is therefore `2`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加三个用户密码，然后进行下一个查询操作 ➌。现在我们要查询 `dish` 在这三个密码中的情况。你可能会想，我们需要遍历现有的密码，统计其中有多少个包含
    `dish`。 （嗯，搜索！这给了我们第一个提示，可能需要使用哈希表。）如果你这样做，你会发现两个密码——`brandish` 和 `radishes`——包含了
    `dish`。所以答案是 `2`。
- en: And what about the final query ➍? We’re looking for passwords that have an `a`
    in them. If you search through the three existing passwords, you’ll find that
    all three of them do! The answer is therefore `3`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 那么最后一个查询 ➍ 呢？我们要查找包含 `a` 的密码。如果你遍历这三个现有的密码，你会发现它们都有 `a`！因此，答案是 `3`。
- en: 'We’re done! The correct output for the full test case is:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整测试用例的正确输出是：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we implement the solution strategy that we just used, we might arrive at
    something like [Listing 1-14](ch01.xhtml#ch01ex014).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实现刚才使用的解决策略，最终可能会得到像 [清单 1-14](ch01.xhtml#ch01ex014) 这样的内容。
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 1-14: Solution 1*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-14：解决方案 1*'
- en: The problem description says that we’ll have at most 100,000 operations. If
    each is an add operation, then we get 100,000 users ➊, and we can’t have any more
    than that.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 问题描述中说，我们最多会有 100,000 次操作。如果每次都是添加操作，那么我们会得到 100,000 个用户 ➊，并且不能超过这个数量。
- en: For each add operation ➋, we copy the new password into our users array. And
    for each query operation ➌, we loop through all of the existing user passwords,
    checking how many of them have the proposed password as a substring.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个添加操作 ➋，我们将新密码复制到我们的用户数组中。而对于每个查询操作 ➌，我们遍历所有现有用户的密码，检查其中有多少个密码包含了提议的密码作为子字符串。
- en: Like our first solution to Unique Snowflakes, this solution is not fast enough
    to pass the test cases in time. That’s because we have an *O*(*n*²) algorithm
    here, where *n* is the number of queries.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对独特雪花问题的第一个解决方案一样，这个解决方案的速度不足以及时通过测试用例。因为我们这里使用的是一个 *O*(*n*²) 算法，其中 *n*
    是查询的数量。
- en: We are able to quickly add user passwords to our array—no problem there. What
    slows us down are the query operations, because each of them has to scan through
    all existing user passwords. That’s where the quadratic-time behavior comes from.
    Suppose, for example, that a test case starts by adding 50,000 user passwords,
    and then hammers us with 50,000 queries. Taken together, that would require about
    50,000 × 50,000 = 2,500,000,000 steps. That’s over 2 billion steps; there’s no
    way that we can do that many in our allowed time limit of three seconds.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够迅速将用户密码添加到数组中——这没有问题。让我们速度变慢的是查询操作，因为每次查询都需要扫描所有现有的用户密码。这就是二次时间行为的来源。例如，假设一个测试案例开始时添加了50,000个用户密码，然后再进行50,000次查询。总共需要大约50,000
    × 50,000 = 2,500,000,000步。超过了20亿步；在我们允许的三秒时间限制内，显然无法完成这么多步骤。
- en: '*Solution 2: Using a Hash Table*'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案 2：使用哈希表*'
- en: We need to speed up the query operations. And we’re going to use a hash table
    to do so. But how? Isn’t it just a fact of life that we need to compare each query
    password with each existing password? No! Read on as we turn the problem on its
    head.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要加快查询操作的速度。我们将使用哈希表来实现这一点。但是怎么做呢？难道我们不需要将每个查询密码与所有现有密码进行比较吗？不！继续阅读，我们将从另一个角度解决这个问题。
- en: How to Use the Hash Table
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 如何使用哈希表
- en: For each query operation, it would be nice if we could just look up the needed
    password in a hash table to determine how many existing user passwords could get
    into its account. For example, once we add the users with passwords `brandish`,
    `radishes`, and `aaa`, then it would be nice to be able to look up `dish` in the
    hash table and get a value of `2`. But while we’re adding those three user passwords,
    how are we supposed to know to be keeping track of what’s going on with `dish`?
    We don’t know which passwords are going to be queried later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个查询操作，如果我们能够直接在哈希表中查找所需的密码，以确定有多少现有用户密码可以进入其账户，那就太好了。例如，一旦我们添加了密码为`brandish`、`radishes`和`aaa`的用户，那么我们就能够在哈希表中查找`dish`并得到一个值`2`。但是，在我们添加这三个用户密码的同时，我们怎么知道需要跟踪`dish`的情况呢？我们并不知道哪些密码会在之后被查询。
- en: Well, since we don’t know the future, let’s just add one to the total for every
    single substring of each user password. That way we’ll be ready if we ever need
    to look any of them up.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，因为我们无法预知未来，不如对每个用户密码的每个子字符串都加一。这样一来，如果我们以后需要查找任何子字符串的总数，就已经做好准备了。
- en: 'Focus on the `brandish` password. If we consider each substring, then we’ll
    increment the total for `b`, `br`, `bra`, `bran`, `brand`, `brandi`, `brandis`,
    `brandish`, `r`, `ra`, and so on. Don’t worry: if we process them all, we’ll definitely
    hit `dish` and increment it. We’ll increment `dish` again when we do the same
    kind of substring processing on `radishes`. So, `dish` will end up with a total
    of 2, as needed.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 关注`brandish`密码。如果我们考虑每个子字符串，那么我们会为`b`、`br`、`bra`、`bran`、`brand`、`brandi`、`brandis`、`brandish`、`r`、`ra`等子字符串递增总数。别担心：如果我们处理所有这些子字符串，我们肯定会碰到`dish`并对它进行递增。当我们对`radishes`进行相同的子字符串处理时，我们会再次递增`dish`。因此，`dish`的总数最终会达到2，正如我们需要的那样。
- en: You might worry that we’re being excessive here, processing a ton of substring
    passwords, the vast majority of which are not going to be queried. However, remember
    from the problem description that passwords can be at most 10 characters. Each
    substring has a starting point and an ending point. In a password of 10 characters,
    there are only 10 possible starting points and 10 possible ending points, so an
    upper bound on the number of substrings in a password is 10 × 10 = 100\. As we
    have at most 100,000 user passwords, each of which has at most 100 substrings,
    we’ll store at most 100,000 × 100 = 10,000,000 substrings in our hash table. That’ll
    take up a few megabytes of memory, for sure, but that’s nothing to worry about.
    We’re trading a little memory for the ability to look up any password’s total
    when we need it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会担心我们在这里做得过于冗余，处理大量的子字符串密码，而其中绝大部分不会被查询。然而，请记住，从问题描述中我们知道密码最多有10个字符。每个子字符串都有一个起始点和一个终止点。在一个10个字符的密码中，只有10个可能的起始点和10个可能的终止点，所以一个密码中子字符串的最大数量是10
    × 10 = 100。由于我们最多有100,000个用户密码，每个密码最多有100个子字符串，我们在哈希表中最多会存储100,000 × 100 = 10,000,000个子字符串。这肯定会占用一些兆字节的内存，但这完全不值得担心。我们正在用一点内存换取在需要时能够查找任何密码总数的能力。
- en: As with Unique Snowflakes, our solution will use a hash table of linked lists.
    We also need a hash function. We won’t use something like the snow-flake hash
    function here, because it would lead to collisions between passwords like `cat`
    and `act` that are anagrams. Unlike in the Unique Snowflakes problem, passwords
    should be distinguished not just by their letters but by the locations of those
    letters. Some collisions are inevitable, of course, but we should do what we can
    to limit their prevalence. To that end, we’ll wield that wild `oaat` hash function
    from [Listing 1-13](ch01.xhtml#ch01ex013).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 与“独特雪花”问题类似，我们的解决方案将使用链表的哈希表。我们还需要一个哈希函数。这里我们不会使用像雪花哈希函数那样的方式，因为它会导致像`cat`和`act`这样的密码发生冲突（它们是字母重排的）。与“独特雪花”问题不同，密码不仅应该通过字母来区分，还应该通过字母的位置来区分。当然，某些冲突是不可避免的，但我们应该尽力减少它们的发生频率。为此，我们将使用[清单
    1-13](ch01.xhtml#ch01ex013)中的那个“狂野”的`oaat`哈希函数。
- en: Searching the Hash Table
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 搜索哈希表
- en: 'We’ll use the following node to store passwords in our hash table:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下节点在哈希表中存储密码：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This node is similar to `snowflake_node` from Unique Snowflakes, but we now
    also have a `total` member to keep track of the total count for this password.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点类似于“独特雪花”中的`snowflake_node`，但我们现在还增加了一个`total`成员，用来跟踪该密码的总计数。
- en: Now we can write a helper function to search the hash table for a given password.
    See [Listing 1-15](ch01.xhtml#ch01ex015) for the code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个辅助函数来在哈希表中搜索给定的密码。查看[清单 1-15](ch01.xhtml#ch01ex015)获取代码。
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 1-15: Searching for a password*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-15：搜索密码*'
- en: This `in_hash_table` function takes a hash table and a password to find in the
    hash table. If the password is found, the function returns a pointer to the corresponding
    `password_node`; otherwise, it returns `NULL`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`in_hash_table`函数接收一个哈希表和一个要查找的密码。如果找到该密码，函数将返回指向对应`password_node`的指针；否则，返回`NULL`。
- en: The function works by calculating the hashcode of the password ➊ and using that
    hashcode to find the appropriate linked list to search ➋. It then checks each
    password in the list, looking for a match ➌.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过计算密码的哈希码 ➊，并利用该哈希码找到合适的链表来进行搜索 ➋。然后，它检查链表中的每个密码，寻找匹配项 ➌。
- en: Adding to the Hash Table
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向哈希表添加数据
- en: We also need a function that will add one to a given password in the hash table.
    See [Listing 1-16](ch01.xhtml#ch01ex016) for the code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数，用于在哈希表中将给定密码的数量加一。查看[清单 1-16](ch01.xhtml#ch01ex016)获取代码。
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 1-16: Adding one to a password’s total*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-16：将密码的总数加一*'
- en: 'We use our `in_hash_table` function ➊ to determine whether the password is
    already in the hash table. If it isn’t, we add it to the hash table and give it
    a count of 0 for now ➋. The technique for adding each password to the hash table
    is the same as for the Unique Snowflakes problem: each bucket is a linked list,
    and we add each password to the beginning of one of those lists.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`in_hash_table`函数 ➊来判断密码是否已经存在于哈希表中。如果没有，我们将它添加到哈希表，并暂时将其计数设置为 0 ➋。将每个密码添加到哈希表的技术与“独特雪花”问题中的方法相同：每个桶都是一个链表，我们将每个密码添加到这些链表的开头。
- en: Next, whether the password was already in there or not, we increment its total
    ➌. In that way, a password that we just added will have its `total` increased
    from 0 to 1, whereas existing passwords will simply have their `total` incremented.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，无论密码是否已经存在，我们都将其总数增加 ➌。这样，我们刚添加的密码的`total`将从 0 增加到 1，而已存在的密码则只是将其`total`增加。
- en: The main Function, Take 1
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`main`函数，第一版'
- en: Ready for the `main` function? Our first attempt is in [Listing 1-17](ch01.xhtml#ch01ex017).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好编写`main`函数了吗？我们的第一次尝试在[清单 1-17](ch01.xhtml#ch01ex017)中。
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 1-17: The* main *function (bugged!)*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-17：主函数（有 Bug！）*'
- en: 'To determine the size of the hash table, we’ve used this strange bit of code:
    `1 << NUM_BITS` ➊. We set `NUM_BITS` to 20 in [Listing 1-15](ch01.xhtml#ch01ex015);
    `1 << 20` is a shortcut for computing 2^(20), which is 1,048,576\. (The `oaat`
    hash function requires that the hash table have a number of elements that is a
    power of 2.) Remember that the maximum number of users we’ll have is 100,000;
    the hash table size that I chose is about 10 times this maximum to account for
    the fact that we insert multiple strings for each password. Smaller or larger
    hash tables would have worked fine, too.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定哈希表的大小，我们使用了这段奇怪的代码：`1 << NUM_BITS` ➊。我们在[列表1-15](ch01.xhtml#ch01ex015)中将`NUM_BITS`设置为20；`1
    << 20`是计算2^(20)的快捷方式，结果是1,048,576（`oaat`哈希函数要求哈希表的元素数量是2的幂）。记住，我们的最大用户数量是100,000；我选择的哈希表大小大约是这一最大值的10倍，以考虑到每个密码会插入多个字符串。较小或较大的哈希表也能正常工作。
- en: For each add operation ➋, we increment the total for each substring by using
    our `add_to_hash_table` helper function ➌. And for each query operation ➍, we
    use our `in_hash_table` helper function ➎ to retrieve the total for the password;
    if the password isn’t in the hash table ➏ then we output `0`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个添加操作 ➋，我们通过使用`add_to_hash_table`辅助函数 ➌来为每个子字符串增加总数。对于每个查询操作 ➍，我们使用`in_hash_table`辅助函数
    ➎来检索密码的总数；如果密码不在哈希表中 ➏，那么我们输出`0`。
- en: Put all of our functions together and let’s try running our code! Remember this
    test case?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们所有的函数放在一起，试试运行我们的代码！记得这个测试用例吗？
- en: '[PRE42]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is supposed to be:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是：
- en: '[PRE43]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Unfortunately, our code gives this instead:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的代码给出了以下结果：
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Wait, `5`? Where’s that `5` coming from?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，`5`？这个`5`从哪里来的？
- en: 'Look at the password `aaa`. How many `a` substrings are in there? There are
    three! And we’re going to find each of them, resulting in three increments to
    the total for `a`. But that doesn’t make sense: `aaa` should be able to bump up
    the total for `a` at most once, not multiple times. After all, `aaa` is only one
    password.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 看看密码`aaa`。里面有多少个`a`的子字符串？有三个！我们将找到其中的每一个，从而使`a`的总数增加三次。但这不合理：`aaa`最多应该让`a`的总数增加一次，而不是多次。毕竟，`aaa`只是一个密码。
- en: The main Function, Take 2
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主函数，第2版
- en: What we need to do is make sure that, for each password, each of its substrings
    counts only once. To do that, we’ll maintain an array of all of the substrings
    that we’ve generated for the current password. Prior to using a substring, we’ll
    search to make sure that we haven’t used that substring yet.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是确保，对于每个密码，它的每个子字符串只计数一次。为此，我们将维护一个数组，记录当前密码生成的所有子字符串。在使用一个子字符串之前，我们会检查，确保该子字符串还没有被使用过。
- en: 'We’re introducing a new search here, so it’s worth thinking about whether we
    need a new hash table of substrings. While we could indeed add another hash table
    for that, we don’t need to: as we already argued, each password won’t have too
    many substrings, so a *linear search* (that is, an element-by-element search)
    through them is going to be fast enough.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里引入了一个新的搜索，所以值得思考是否需要一个新的子字符串哈希表。虽然我们确实可以为此添加另一个哈希表，但我们不需要这样做：正如我们之前所说，每个密码的子字符串数量不会太多，因此通过它们进行*线性搜索*（即逐个元素搜索）会足够快。
- en: Check out [Listing 1-18](ch01.xhtml#ch01ex018) for the finishing touch.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[列表1-18](ch01.xhtml#ch01ex018)了解最后的调整。
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 1-18: A new helper function and fixed* main *function*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表1-18：一个新的辅助函数和修正过的*主*函数*'
- en: We have a new `already_added` helper function here ➊ that we’ll use to tell
    us whether the `find` substring is already in the `all_substrings` array for the
    current password.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个新的`already_added`辅助函数 ➊，它用来告诉我们当前密码的`find`子字符串是否已经存在于`all_substrings`数组中。
- en: In the `main` function itself, notice now that we check whether we’ve seen the
    current substring ➋. If we have not, only then do we add it to the hash table.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，注意我们现在检查是否已经遇到当前子字符串 ➋。如果没有，只有在此时我们才将其添加到哈希表中。
- en: It’s time to submit our code to the judge. Go for it! As with Unique Snowflakes,
    the speedup from using a hash table amounts to an improvement from *O*(*n*²) to
    *O*(*n*), which is plenty fast for the three-second time limit.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的代码提交给评审了。加油！像《唯一的雪花》一样，使用哈希表带来的加速效果将时间复杂度从*O*(*n*²)改进为*O*(*n*)，这对于三秒的时间限制来说已经足够快了。
- en: 'Problem 3: Spelling Check'
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题3：拼写检查
- en: Sometimes, problems look like they can be solved in a particular way because
    they bear resemblance to other problems. Here’s a problem where it seems that
    a hash table is appropriate, but on further reflection we see that hash tables
    vastly overcomplicate what is required.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，问题看起来可以通过某种方式解决，因为它们与其他问题相似。这里有一个问题，看起来哈希表很合适，但经过进一步思考，我们发现哈希表过于复杂，超出了实际要求。
- en: This is Codeforces problem `39J` (Spelling Check). (The easiest way to find
    it is to search online for *Codeforces 39J*.)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Codeforces 问题 `39J`（拼写检查）。(找到它的最简单方法是在线搜索 *Codeforces 39J*)。
- en: '*The Problem*'
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: 'In this problem, we are given two strings where the first string has one more
    character than the second. Our task is to determine the number of ways in which
    one character can be deleted from the first string to arrive at the second string.
    For example, there is one way to get from `favour` to `favor`: we can remove the
    `u` from the first string.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们给定了两个字符串，第一个字符串比第二个字符串多一个字符。我们的任务是确定从第一个字符串中删除一个字符到达第二个字符串的方式数量。例如，从
    `favour` 到 `favor` 只有一种方法：我们可以删除第一个字符串中的 `u` 字符。
- en: 'There are three ways to get from `abcdxxxef` to `abcdxxef`: we can remove any
    of the `x` characters from the first string.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `abcdxxxef` 到 `abcdxxef` 有三种方法：我们可以从第一个字符串中删除任意一个 `x` 字符。
- en: The context for the problem is a spellchecker. The first string might be `bizzarre`
    (a misspelled word) and the second might be `bizarre` (a correct spelling). In
    this case, there are two ways to fix the misspelling—by removing either one of
    the two `z`s from the first string. The problem is more general, though, having
    nothing to do with actual English words or spelling mistakes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题的背景是拼写检查器。第一个字符串可能是 `bizzarre`（一个拼写错误的单词），第二个字符串可能是 `bizarre`（一个正确的拼写）。在这种情况下，有两种方法可以修正拼写错误——删除第一个字符串中的两个
    `z` 中的任意一个。然而，问题更为一般，和实际的英语单词或拼写错误无关。
- en: Input
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: The input is two lines, with the first string on the first line and the second
    string on the second line. Each string can be up to one million characters.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是两行，第一行是第一个字符串，第二行是第二个字符串。每个字符串最多可以有一百万个字符。
- en: Output
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: 'If there is no way to remove a character from the first string to get the second
    string, output `0`. Otherwise, output two lines:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有办法从第一个字符串中删除一个字符以获得第二个字符串，输出 `0`。否则，输出两行：
- en: On the first line, output the number of ways in which a character can be deleted
    from the first string to get the second string.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行输出从第一个字符串中删除一个字符以获得第二个字符串的方式数量。
- en: On the second line, output a space-separated list of the indices of the characters
    in the first string that can be removed to get the second string. The problem
    requires we index a string from `1`, not `0`. (That’s a bit annoying, but we’ll
    be careful.)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行输出一个以空格分隔的列表，列出可以从第一个字符串中删除的字符的索引，以获得第二个字符串。问题要求我们从 `1` 开始索引字符串，而不是从 `0`（虽然这有点麻烦，但我们会小心）。
- en: 'For example, for this input:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于以下输入：
- en: '[PRE46]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'we would output:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输出：
- en: '[PRE47]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `5 6 7` are the indices of the three `x` characters in the first string,
    since we are counting from one (not zero).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`5 6 7` 是第一个字符串中三个 `x` 字符的索引，因为我们是从一开始计数（而不是从零）。'
- en: The time limit for solving the test cases is two seconds.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制是两秒。
- en: '*Thinking About Hash Tables*'
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*思考哈希表*'
- en: I spent a truly embarrassing number of hours searching for the problems that
    drive the chapters in this book. The problems dictate what I can teach you about
    the relevant data structure or algorithm. I need the problem solutions to be algorithmically
    complex, but the problems themselves need to be sufficiently simple so that we
    can understand what is being asked and keep the relevant details at hand. I really
    thought I had found exactly that kind of hash table problem I needed for this
    section. Then I went to solve it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了非常多的时间去寻找驱动本书章节的题目，这些题目决定了我可以教你有关相关数据结构或算法的内容。我需要这些问题的解决方案在算法上足够复杂，但问题本身要简单到足以让我们理解要求并保留相关细节。我真的以为我找到了这种类型的哈希表问题，正好适合这一章节。然后我去解决它。
- en: In Problem 2, Login Mayhem, we were given the passwords as part of the input.
    That was nice, because we just jammed each substring from the passwords into a
    hash table and then used the hash table to search for them as needed. Here, in
    Problem 3, we’re not given any such list of strings to insert. Unfazed, when I
    first tried solving this problem, I created a hash table and I inserted into it
    each prefix of the second (that is, shorter) string. For example, for the word
    `abc`, I would have inserted `a`, `ab`, and `abc`. I also created another hash
    table for the suffixes of the second string. For the word `abc`, I would have
    inserted `c`, `bc`, and `abc`. Armed with those hash tables, I proceeded to consider
    each character of the first string. Removing each character is tantamount to splitting
    the string into a prefix and a suffix. We can just use the hash tables to check
    whether both the prefix and suffix are present. If they are, then removing that
    character is one of the ways in which we can transform the first string into the
    second.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题2，登录混乱中，我们作为输入得到了密码。这是件好事，因为我们只需将密码的每个子字符串放入哈希表中，然后根据需要使用哈希表进行查找。而在这里，在问题3中，我们没有得到任何这样的字符串列表来插入。毫不气馁，当我第一次尝试解决这个问题时，我创建了一个哈希表，并将第二个（即较短）字符串的每个前缀插入其中。例如，对于单词`abc`，我会插入`a`、`ab`和`abc`。我还为第二个字符串的后缀创建了另一个哈希表。对于单词`abc`，我会插入`c`、`bc`和`abc`。有了这些哈希表，我开始考虑第一个字符串的每个字符。删除每个字符相当于将字符串分成一个前缀和一个后缀。我们只需使用哈希表检查前缀和后缀是否都存在。如果它们存在，那么删除这个字符就是我们将第一个字符串转换为第二个字符串的一种方式。
- en: This technique is tempting, right? Want to give it a try?
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技巧很诱人，对吧？想试试看吗？
- en: 'The thing I had failed to keep in mind was that each string could be up to
    a million characters long. We certainly can’t store all of the prefixes and suffixes
    themselves in the hash table—that would take up way too much memory. I played
    around with using pointers in the hash table to point to both the start and end
    of the prefixes and suffixes. That solves the concerns of memory use, but it doesn’t
    free us from having to compare these extra-long strings whenever we perform a
    search using the hash table. In Unique Snowflakes and Login Mayhem, the elements
    in the hash table were small: 6 integers for a snowflake and 10 characters for
    a password. That’s nothing. However, here, the situation is different: we might
    have strings of a million characters! Comparing such long strings is very time-consuming.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有考虑到的一点是，每个字符串的长度可能达到一百万个字符。我们当然不能将所有的前缀和后缀本身存储在哈希表中——那会占用太多内存。我尝试过在哈希表中使用指针指向前缀和后缀的开始和结束位置。这解决了内存使用的问题，但并没有让我们摆脱每次使用哈希表进行搜索时都要比较这些超长字符串的问题。在《独特的雪花》和《登录混乱》中，哈希表中的元素很小：一个雪花6个整数，密码10个字符。那没什么。然而，在这里，情况不同：我们可能有一百万个字符的字符串！比较这么长的字符串非常耗时。
- en: Another timesink here is computing the hashcode of prefixes and suffixes of
    these strings. We might call `oaat` on a string of length 900,000, and then call
    it again on a string with one additional character. That duplicates all of the
    work from the first `oaat` call, when all we wanted was to incorporate one more
    character into the string being hashed.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个时间杀手是计算这些字符串的前缀和后缀的哈希码。我们可能会在一个长度为900,000的字符串上调用`oaat`，然后在一个多了一个字符的字符串上再次调用它。这会重复执行第一次`oaat`调用中的所有工作，而我们只想将一个额外的字符加入到正在哈希的字符串中。
- en: Yet, I persisted. I had it in my mind that a hash table was the way to go here,
    and I failed to consider alternatives. At this point, I probably should have taken
    a fresh look at the problem. Instead, I learned about *incremental hash functions*,
    hash functions that are very fast when generating the hash-code for an element
    that is very similar to the previously hashed element. For example, if I already
    have the hashcode for `abcde`, then computing the hashcode for `abcdef` using
    an incremental hash function will be very fast, because it can lean on the work
    already done for `abcde` rather than starting from scratch.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我坚持了下去。我心里一直认为哈希表是解决此问题的正确方式，因此没考虑其他选择。此时，我本应该重新审视这个问题。然而，我学到了关于*增量哈希函数*的知识，这种哈希函数在生成与之前哈希元素非常相似的元素的哈希码时非常快速。例如，如果我已经拥有了`abcde`的哈希码，那么使用增量哈希函数计算`abcdef`的哈希码会非常快速，因为它可以依赖于已完成的`abcde`的工作，而不需要从头开始。
- en: Another insight was that, if it is too costly to compare extra-long strings,
    we should try to avoid comparing them at all. We could just hope that our hash
    function is good enough and that we’re lucky enough with the test cases so that
    no collisions occur. If we look for some element in the hash table, and we find
    a match . . . well, let’s hope it was an actual match and not us getting unlucky
    with a false positive. If we’re willing to make this concession, then we can use
    a structure that’s simpler than the hash table array that we used up to this point
    in the chapter. In array `prefix1`, each index `i` gives the hashcode for the
    prefix of length `i` from the first string. In array `prefix2`, each index `i`
    gives the hashcode for the prefix of length `i` from the second string. In each
    of two other arrays, we can do similarly for the suffixes of the first string
    and suffixes of the second string.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个见解是，如果比较过长的字符串代价太高，我们应该尽量避免进行比较。我们可以仅仅寄希望于我们的哈希函数足够好，并且测试用例足够幸运，不会发生碰撞。如果我们在哈希表中查找某个元素，并且找到了匹配……好吧，我们希望它确实是一个有效的匹配，而不是我们在碰到假阳性时运气不好。如果我们愿意做出这个让步，那么我们可以使用比本章到目前为止所用的哈希表数组更简单的结构。在数组`prefix1`中，每个索引`i`给出了第一个字符串长度为`i`的前缀的哈希值。在数组`prefix2`中，每个索引`i`给出了第二个字符串长度为`i`的前缀的哈希值。在另外两个数组中，我们可以对第一个字符串的后缀和第二个字符串的后缀做类似的操作。
- en: 'Here is some code that shows how the `prefix1` array can be built:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些代码，展示了如何构建`prefix1`数组：
- en: '[PRE48]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The other arrays can be built similarly.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数组可以类似构建。
- en: It’s important that we use unsigned integers here. In C, overflow is well defined
    on unsigned integers but not signed integers. If a word is long enough, we’ll
    definitely get overflow, so we don’t want to allow undefined behavior.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用无符号整数非常重要。在C语言中，溢出对于无符号整数是定义明确的，但对于有符号整数则不然。如果一个单词足够长，我们肯定会发生溢出，因此我们不希望出现未定义行为。
- en: Now we can use these arrays to determine whether prefixes or suffixes match.
    For example, to determine whether the first `i` characters of the first string
    equal the first `i` characters of the second string, just check whether `prefix1[i]`
    and `prefix2[i]` are equal.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这些数组来确定前缀或后缀是否匹配。例如，要确定第一个字符串的前`i`个字符是否等于第二个字符串的前`i`个字符，只需检查`prefix1[i]`和`prefix2[i]`是否相等。
- en: 'Note how little work it takes to calculate the hashcode for `prefix1[i]` given
    the hashcode for `prefix1[i - 1]`: it’s just a multiplication, followed by adding
    the new character ➊. Why multiply by 39 and add the character? Why not use something
    else for the hash function? Honestly, because what I chose didn’t lead to any
    collisions in the Codeforces test cases. Yes, I know, it’s unsatisfying.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，给定`prefix1[i - 1]`的哈希值，计算`prefix1[i]`的哈希值需要做的工作非常少：仅仅是一次乘法操作，再加上新的字符➊。为什么要乘以39并加上字符呢？为什么不使用其他方法作为哈希函数？说实话，因为我选择的方法在Codeforces的测试用例中没有导致任何碰撞。是的，我知道，这样的答案不够令人满意。
- en: 'Not to worry, though: there’s a better way! To get there, we’ll stare at the
    problem a little more closely, instead of just jumping to a hash table solution.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心：还有更好的方法！为了达到这个目标，我们将更仔细地看待问题，而不是直接跳到哈希表的解决方案。
- en: '*An Ad Hoc Solution*'
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*临时解决方案*'
- en: 'Let’s think more carefully through an earlier example:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再仔细思考一个早期的例子：
- en: '[PRE49]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Suppose that we remove the `f` from the first string (index `9`). Does this
    make the first string equal the second? No, so `9` will not show up in our space-separated
    list of indices. The strings have a long prefix of matching characters. There
    are six such characters to be exact: `abcdxx`. After that, the two strings diverge,
    where the first string has an `x` and the second has an `e`. If we don’t fix that,
    then we have no hope that the two strings will be equal. The `f` is too far to
    the right for its deletion to produce equal strings.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从第一个字符串中删除了`f`（索引`9`）。这样会使第一个字符串与第二个字符串相等吗？不，所以`9`不会出现在我们以空格分隔的索引列表中。这两个字符串有很长的匹配前缀。确切来说，有六个匹配字符：`abcdxx`。之后，两个字符串开始分歧，第一个字符串有一个`x`，而第二个字符串有一个`e`。如果我们不解决这个问题，那么我们就不可能希望这两个字符串相等。`f`的位置太靠右，它的删除不会让两个字符串相等。
- en: 'That leads to our first observation: if the length of the *longest common prefix*
    (in our example, six, the length of `abcdxx`) is *p*, then our only options for
    deleting characters are those with indices of *≤* *p* + 1\. In our example, we
    should consider deleting the characters whose indices are *≤* 7: `a`, `b`, `c`,
    `d`, the first `x`, the second `x`, and the third `x`. Deleting anything to the
    right of index *p* + 1 doesn’t fix the diverging character at index *p* + 1 and
    hence can’t make the strings equal.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了我们的第一个观察：如果*最长公共前缀*的长度（在我们的例子中是六，即`abcdxx`的长度）是*p*，那么我们删除字符的选择只能是索引小于等于*p*
    + 1的字符。在我们的例子中，我们应该考虑删除索引小于等于7的字符：`a`、`b`、`c`、`d`、第一个`x`、第二个`x`和第三个`x`。删除索引大于*p*
    + 1的字符无法修复位于索引*p* + 1处的不同字符，因此无法使字符串相等。
- en: Notice that only some of these deletions actually work. For example, deleting
    the `a`, `b`, `c`, or `d` from the first string does not give us the second string.
    Only each of the three deletions of `x` gives us the second string. So, while
    we’ve got an upper bound for indices to consider (*≤* *p* + 1), we also need a
    lower bound.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并不是所有的删除操作都有效。例如，删除第一个字符串中的`a`、`b`、`c`或`d`并不能得到第二个字符串。只有删除每一个`x`才能得到第二个字符串。因此，虽然我们有一个上界来限制需要考虑的索引（*≤*
    *p* + 1），我们仍然需要一个下界。
- en: 'To think about a lower bound, consider removing the `a` from the first string.
    Does that make the two strings equal? Nope. The reasoning is similar to that in
    the previous paragraph: there are diverging characters to the right of the `a`
    that can’t possibly be fixed by removing the `a`. If the length of the *longest
    common suffix* (in our example, four, the length of `xxef`) is *s*, then we should
    consider deleting each of the final *s* + 1 characters of the first string. In
    terms of indices, we’re interested only in those that are ≥ *n* – *s*, where *n*
    is the length of the first string. In our example, this tells us to consider only
    indices that are *≥* 9 – 4 = 5\. In the above paragraph, we argued that we should
    look at only indices that are *≤* 7\. Together, we see that indices `5`, `6`,
    and `7` are the ones whose deletion transforms the first string into the second.
    As can be seen in [Figure 1-4](ch01.xhtml#ch01fig04), what matters here are the
    indices that are included in both the prefixes and suffixes: each of those characters
    is a valid deletion.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要考虑下界，可以考虑从第一个字符串中删除`a`。这样会使两个字符串相等吗？不会。这个推理与上一段类似：在`a`右侧有不同的字符，删除`a`也无法修复这些字符。如果*最长公共后缀*（在我们的例子中为四，即`xxef`的长度）是*s*，那么我们应该考虑删除第一个字符串的最后*s*
    + 1个字符。从索引的角度来看，我们只关注那些大于等于*n* - *s*的索引，其中*n*是第一个字符串的长度。在我们的例子中，这告诉我们只需要考虑索引大于等于9
    - 4 = 5的情况。在上一段中，我们曾提到应只关注小于等于7的索引。综合来看，我们发现索引`5`、`6`和`7`是删除后能将第一个字符串转变为第二个字符串的索引。如[图
    1-4](ch01.xhtml#ch01fig04)所示，关键在于那些同时出现在前缀和后缀中的索引：这些字符的删除是有效的。
- en: '![Image](../images/ch01fig04.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch01fig04.jpg)'
- en: '*Figure 1-4: Overlap between the longest prefix and longest suffix*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-4：最长前缀与最长后缀的重叠*'
- en: In general, the indices of interest go from *n* – *s* to *p* + 1\. For any index
    in this range, we know from *p* + 1 that the two strings are the same prior to
    the index. We also know from *n* – *s* that the two strings are the same after
    the index. Therefore, once we remove the index, the two strings are identical.
    If the range is empty, then there are *no* indices whose deletion transforms the
    first string into the second, so `0` is output in this case. Otherwise, we use
    a `for` loop to loop through the indices and `printf` to produce the space-separated
    list. Let’s take a look at the code!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，感兴趣的索引范围从*n* - *s*到*p* + 1。对于这个范围内的任何一个索引，我们知道从*p* + 1开始，两个字符串在该索引之前是相同的。我们也知道从*n*
    - *s*开始，两个字符串在该索引之后是相同的。因此，一旦我们删除该索引，两个字符串将变得完全相同。如果该范围为空，则没有任何索引的删除能够将第一个字符串转换为第二个字符串，因此此时输出`0`。否则，我们使用`for`循环遍历这些索引，并用`printf`输出以空格分隔的索引列表。让我们来看一下代码吧！
- en: Longest Common Prefix
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最长公共前缀
- en: We have a helper function in [Listing 1-19](ch01.xhtml#ch01ex019) to calculate
    the length of the longest common prefix of two strings.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[清单 1-19](ch01.xhtml#ch01ex019)中有一个辅助函数来计算两个字符串的最长公共前缀的长度。
- en: '[PRE50]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 1-19: Calculating the longest common prefix*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-19：计算最长公共前缀*'
- en: Here `s1` is the first string and `s2` is the second string. We use `1` as the
    starting index of the strings. Starting at index `1`, the loop continues as long
    as corresponding characters are equal. (In a case such as `abcde` and `abcd`,
    the `e` will fail to match the null terminator at the end of `abcd`, so `i` will
    correctly end up with value `5`.) When the loop terminates, index `i` is the index
    of the first mismatched character; therefore, `i - 1` is the length of the longest
    common prefix.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`s1`是第一个字符串，`s2`是第二个字符串。我们使用`1`作为字符串的起始索引。从索引`1`开始，循环会继续，只要相应的字符相等。（在像`abcde`和`abcd`这样的情况下，`e`无法与`abcd`结尾的空终止符匹配，因此`i`会正确地为`5`。）当循环终止时，索引`i`是第一个不匹配字符的索引；因此，`i
    - 1`就是最长公共前缀的长度。
- en: Longest Common Suffix
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最长公共后缀
- en: Now, to calculate the longest common suffix, we use [Listing 1-20](ch01.xhtml#ch01ex020).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了计算最长公共后缀，我们使用[列表 1-20](ch01.xhtml#ch01ex020)。
- en: '[PRE51]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 1-20: Calculating the longest common suffix*'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-20：计算最长公共后缀*'
- en: The code is quite similar to [Listing 1-19](ch01.xhtml#ch01ex019). This time,
    however, we compare from right to left, rather than left to right. For this reason,
    we need the `len` parameter, which gives us the length of the first string. The
    final comparison that we’re allowed to make is `i == 2`. If we had `i == 1`, then
    we’d be accessing `s2[0]`, which is not a valid element of the string!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[列表 1-19](ch01.xhtml#ch01ex019)非常相似。不同的是，这次我们是从右到左比较，而不是从左到右。基于这个原因，我们需要`len`参数，它给出了第一个字符串的长度。我们允许进行的最终比较是`i
    == 2`。如果是`i == 1`，我们就会访问`s2[0]`，这不是字符串的有效元素！
- en: The main Function
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主函数
- en: Finally, we have our `main` function in [Listing 1-21](ch01.xhtml#ch01ex021).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在[列表 1-21](ch01.xhtml#ch01ex021)中得到了我们的`main`函数。
- en: '[PRE52]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 1-21: The* main *function*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-21：*主 *函数*'
- en: We use `SIZE + 2` as the size of our two character arrays ➊. The maximum number
    of characters that we’re required to read is one million, but we need an extra
    element for the null terminator. And we need one element on top of that because
    we start indexing our strings at index `1`, “wasting” index `0`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`SIZE + 2`作为两个字符数组的大小➊。我们需要读取的最大字符数为一百万，但我们需要一个额外的元素来存储空字符终止符。除此之外，我们还需要一个元素，因为我们从索引`1`开始索引字符串，"浪费"了索引`0`。
- en: 'We read the first ➋ and second string ➌. Notice we pass a pointer to index
    `1` of each string: `gets` therefore starts storing characters at index `1` rather
    than index `0`. After calling our helper functions, we calculate the number of
    indices that can be deleted from `s1` to give us `s2` ➍. If this number is negative
    ➎, then we set it to `0` ➏. This makes the `printf` call correct ❼. We use a `for`
    loop ❽ to print the correct indices. We want to start printing at `len - suffix`,
    so we add `len - suffix` to each integer `i`.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取了第一个➋和第二个字符串➌。注意，我们将指针传递给每个字符串的索引`1`：因此，`gets`从索引`1`开始存储字符，而不是从索引`0`开始。在调用我们的辅助函数后，我们计算可以从`s1`中删除的索引数量，以得到`s2`
    ➍。如果这个数字为负数 ➎，我们将其设置为`0` ➏。这使得`printf`调用是正确的 ❼。我们使用`for`循环 ❽打印正确的索引。我们希望从`len
    - suffix`开始打印，因此我们将`len - suffix`添加到每个整数`i`。
- en: When submitting to the judge, you may need to choose GNU G++ rather than GNU
    GCC.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 提交给评测系统时，可能需要选择GNU G++而不是GNU GCC。
- en: 'There we have it: a linear-time solution. We had to perform some tough analysis,
    but after that we were able to proceed without complex code and without the need
    for a hash table. Before considering a hash table, ask yourself, is there anything
    about the problem that would make hash tables unwieldy? Is a search really necessary,
    or are there features of the problem that obviate such searching in the first
    place?'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：一个线性时间的解决方案。我们不得不进行一些艰难的分析，但在此之后我们能够不使用复杂的代码，也不需要哈希表。考虑哈希表之前，问问自己，问题中有没有任何因素会使得哈希表难以使用？是否真的需要搜索，或者问题中是否有某些特性使得根本不需要这种搜索？
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'A hash table is a data structure: a way to organize data so that certain operations
    are fast. Hash tables speed up the search for some specified element. To speed
    up other operations, we need other data structures. For example, in [Chapter 8](ch08.xhtml),
    we’ll learn about a heap, which is a data structure that can be used when we need
    to quickly identify the maximum or minimum element in an array.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是一种数据结构：它是一种组织数据的方法，使某些操作变得快速。哈希表加速了对指定元素的查找。为了加速其他操作，我们需要其他数据结构。例如，在[第8章](ch08.xhtml)中，我们将学习堆，这是一种数据结构，当我们需要快速识别数组中的最大或最小元素时，它非常有用。
- en: Data structures are general approaches to organizing and manipulating data.
    Hash tables apply to all kinds of problems beyond what is shown here; I hope that
    you now have good intuition for when a hash table can be used. Be on the lookout
    for other problems where otherwise efficient solutions are hampered by repeated,
    slow searches.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是组织和操作数据的通用方法。哈希表适用于各种问题，超出了这里展示的内容；希望你现在能有良好的直觉，知道在何时可以使用哈希表。注意观察其他效率高的解决方案，看看哪些问题因为反复的、缓慢的查找而受到制约。
- en: Notes
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Unique Snowflakes is originally from the 2007 Canadian Computing Olympiad.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 独特的雪花问题最早出自2007年加拿大计算机奥林匹克竞赛。
- en: Login Mayhem is based on a problem from the 2017 Croatian Open Competition in
    Informatics, Round 1.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 登录混乱问题来源于2017年克罗地亚信息学奥林匹克竞赛第一轮的一个题目。
- en: 'Spelling Check is originally from the 2010 School Team Contest #1, hosted by
    Codeforces. The prefix-suffix solution (used after I finally gave up on a hash
    table solution) originates from a note posted at [*https://codeforces.com/blog/entry/786*](https://codeforces.com/blog/entry/786).'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 拼写检查问题最早出自2010年Codeforces举办的学校队伍竞赛#1。前缀-后缀的解决方案（在我最终放弃哈希表方案后使用）来源于[这个链接](https://codeforces.com/blog/entry/786)上的一篇帖子。
- en: 'In our hash table code, we used `malloc` to allocate nodes of our linked lists.
    It’s sometimes possible to avoid using `malloc` and node structures altogether.
    See “Unique Snowflakes: Implicit Linked Lists” in [Appendix B](app02.xhtml) if
    you’re interested in how that can be done.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的哈希表代码中，我们使用了`malloc`来分配链表的节点。有时可以完全避免使用`malloc`和节点结构。如果你有兴趣了解如何做到这一点，请参阅[附录B](app02.xhtml)中的“独特的雪花：隐式链表”部分。
- en: The `oaat` hash function is by Bob Jenkins (see [*http://burtleburtle.net/bob/hash/doobs.html*](http://burtleburtle.net/bob/hash/doobs.html)).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`oaat`哈希函数由Bob Jenkins设计（参见[*http://burtleburtle.net/bob/hash/doobs.html*](http://burtleburtle.net/bob/hash/doobs.html)）。'
- en: 'For additional information about hash table applications and implementations,
    see *Algorithms Illuminated (Part 2): Graph Algorithms and Data Structures* by
    Tim Roughgarden (2018).'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '有关哈希表应用和实现的更多信息，请参见Tim Roughgarden（2018年）的《*Algorithms Illuminated (Part 2):
    Graph Algorithms and Data Structures*》。'
