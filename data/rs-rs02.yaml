- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Types
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类型
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Now that the fundamentals are out of the way, we’ll look at Rust’s type system.
    We’ll skip past the basics covered in *The Rust Programming Language* and instead
    dive headfirst into how different types are laid out in memory, the ins and outs
    of traits and trait bounds, existential types, and the rules for using types across
    crate boundaries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基础知识已经讲完，我们来看看Rust的类型系统。我们将跳过《Rust编程语言》一书中涵盖的基础内容，直接深入探讨不同类型在内存中的布局、特征和特征约束的细节、存在类型以及跨crate边界使用类型的规则。
- en: Types in Memory
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存中的类型
- en: Every Rust value has a type. Types serve many purposes in Rust, as we’ll see
    in this chapter, but one of their most fundamental roles is to tell you how to
    interpret bits of memory. For example, the sequence of bits `0b10111101` (written
    in hexadecimal notation as `0xBD`) does not mean anything in and of itself until
    you assign it a type. When interpreted under the type `u8`, that sequence of bits
    is the number 189\. When interpreted under the type `i8`, it is –67\. When you
    define your own types, it’s the compiler’s job to determine where each part of
    the defined type goes in the in-memory representation for that type. Where does
    each field of your struct appear in the sequence of bits? Where is the discriminant
    for your enum stored? It’s important to understand how this process works as you
    begin to write more advanced Rust code, because these details affect both the
    correctness and the performance of your code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Rust值都有一个类型。类型在Rust中有许多用途，正如我们在本章中将看到的那样，但它们最基本的作用之一是告诉你如何解释内存中的比特。例如，比特序列`0b10111101`（以十六进制表示为`0xBD`）本身并没有意义，直到你给它指定一个类型。当按`u8`类型解释时，这个比特序列是数字189。当按`i8`类型解释时，它是-67。当你定义自己的类型时，编译器的工作是确定定义类型的每个部分在该类型的内存表示中放置的位置。你的结构体的每个字段会出现在比特序列的哪里？你的枚举的判别值存储在哪里？理解这个过程如何工作非常重要，因为这些细节会影响到你代码的正确性和性能，尤其是在你开始编写更复杂的Rust代码时。
- en: Alignment
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对齐
- en: Before we talk about how a type’s in-memory representation is determined, we
    first need to discuss the notion of *alignment*, which dictates where the bytes
    for a type can be stored. Once a type’s representation has been determined, you
    might think you can take any arbitrary memory location and interpret the bytes
    stored there as that type. While that is true in a theoretical sense, in practice
    the hardware also constrains where a given type can be placed. The most obvious
    example of this is that pointers point to *bytes*, not *bits*. If you placed a
    value of type `T` starting at bit 4 of your computer’s memory, you would have
    no way to refer to its location; you can create a pointer pointing only to byte
    0 or byte 1 (bit 8). For this reason, all values, no matter their type, must start
    at a byte boundary. We say that all values must be at least *byte-aligned*—they
    must be placed at an address that is a multiple of 8 bits.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论一个类型的内存表示是如何确定之前，我们首先需要讨论*对齐*的概念，它决定了一个类型的字节应该存储在哪里。一旦确定了一个类型的表示，你可能认为可以随便选一个内存位置，并将存储在那里的字节解释为该类型。虽然从理论上讲这是正确的，但在实践中，硬件也会限制某个类型可以放置的位置。最明显的例子是指针指向的是*字节*，而不是*比特*。如果你把一个类型为`T`的值放在计算机内存的第4位开始，你将无法引用它的位置；你只能创建一个指向字节0或字节1（第8位）的指针。因此，所有的值，不论其类型，都必须从字节边界开始。我们说所有的值必须至少是*字节对齐的*——它们必须放置在一个是8位倍数的地址上。
- en: Some values have more stringent alignment rules than just being byte-aligned.
    In the CPU and the memory system, memory is often accessed in blocks larger than
    a single byte. For example, on a 64-bit CPU, most values are accessed in chunks
    of 8 bytes (64 bits), with each operation starting at an 8-byte-aligned address.
    This is referred to as the CPU’s *word size*. The CPU then uses some cleverness
    to handle reading and writing smaller values, or values that span the boundaries
    of these chunks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有些值的对齐规则比仅仅字节对齐要严格。在CPU和内存系统中，内存通常是按比单个字节更大的块访问的。例如，在64位CPU上，大多数值是按8字节（64位）为一组访问的，每次操作都会从一个8字节对齐的地址开始。这被称为CPU的*字长*。然后，CPU会使用一些巧妙的方法来处理读取和写入较小的值，或者跨越这些块边界的值。
- en: Where possible, you want to ensure that the hardware can operate in its “native”
    alignment. To see why, consider what happens if you try to read an `i64` that
    starts in the middle of an 8-byte block (that is, the pointer to it is not 8-byte-aligned).
    The hardware will have to do two reads—one from the second half of the first block
    to get to the start of the `i64`, and one from the first half of the second block
    to read the rest of the `i64`—and then splice the results together. This is not
    very efficient. Since the operation is spread across multiple accesses to the
    underlying memory, you may also end up with strange results if the memory you’re
    reading from is concurrently written to by a different thread. You might read
    the first 4 bytes before the other thread’s write has happened and the second
    4 bytes after, resulting in a corrupted value.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，您需要确保硬件能够以其“本地”对齐方式运行。为了理解为什么这样做很重要，请考虑如果您尝试读取一个从8字节块中间开始的`i64`会发生什么（即，它的指针没有8字节对齐）。硬件将不得不进行两次读取——第一次从第一个块的后半部分读取以获取`i64`的开始，第二次从第二个块的前半部分读取以获取`i64`的其余部分——然后将结果拼接在一起。这种方式效率不高。由于该操作跨多个访问底层内存进行，如果您读取的内存正在被另一个线程并发写入，您可能会得到奇怪的结果。您可能会在另一个线程写入之前读取前4字节，而在写入之后读取后4字节，导致值被破坏。
- en: Operations on data that is not aligned are referred to as *misaligned accesses*
    and can lead to poor performance and bad concurrency problems. For this reason,
    many CPU operations require, or strongly prefer, that their arguments are *naturally
    aligned*. A naturally aligned value is one whose alignment matches its size. So,
    for example, for an 8-byte load, the provided address would need to be 8-byte-aligned.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对未对齐数据的操作被称为*未对齐访问*，这可能导致性能低下和不良的并发问题。正因为如此，许多CPU操作要求或强烈偏好它们的参数是*自然对齐*的。自然对齐的值是指其对齐方式与其大小相匹配。例如，对于一个8字节加载，提供的地址需要是8字节对齐的。
- en: Since aligned accesses are generally faster and provide stronger consistency
    semantics, the compiler tries to take advantage of them where possible. It does
    this by giving every type an alignment that’s computed based on the types that
    it contains. Built-in values are usually aligned to their size, so a `u8` is byte-aligned,
    a `u16` is 2-byte-aligned, a `u32` is 4-byte-aligned, and a `u64` is 8-byte-aligned.
    Complex types—types that contain other types—are typically assigned the largest
    alignment of any type they contain. For example, a type that contains a `u8`,
    a `u16`, and a `u32` will be 4-byte-aligned because of the `u32`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对齐访问通常更快，并且提供更强的统一性语义，编译器会尽可能利用它们。它通过为每个类型计算一个基于其包含类型的对齐方式来实现这一点。内置值通常按照其大小对齐，因此`u8`按字节对齐，`u16`按2字节对齐，`u32`按4字节对齐，`u64`按8字节对齐。复杂类型——即包含其他类型的类型——通常会分配它们所包含的任何类型中最大的对齐方式。例如，一个包含`u8`、`u16`和`u32`的类型将会按4字节对齐，因为它包含`u32`。
- en: Layout
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布局
- en: Now that you know about alignment, we can explore how the compiler decides on
    the in-memory representation, known as the *layout*, of a type. By default, as
    you’ll see shortly, the Rust compiler gives very few guarantees about how it lays
    out types, which makes for a poor starting point for understanding the underlying
    principles. Luckily, Rust provides a `repr` attribute you can add to your type
    definitions to request a particular in-memory representation for that type. The
    most common one you will see, if you see one at all, is `repr(C)`. As the name
    suggests, it lays out the type in a way that is compatible with how a C or C++
    compiler would lay out the same type. This is helpful when writing Rust code that
    interfaces with other languages using the foreign-function interface, which we’ll
    talk about in Chapter 11, as Rust will generate a layout that matches the expectations
    of the other language’s compiler. Since the C layout is predictable and not subject
    to change, `repr(C)` is also useful in unsafe contexts if you’re working with
    raw pointers into the type, or if you need to cast between two different types
    that you know have the same fields. And, of course, it is perfect for taking our
    first steps into layout algorithms.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了对齐方式，我们可以探讨编译器如何决定类型的内存布局，也就是所谓的*布局*。默认情况下，正如你很快会看到的，Rust编译器对类型的布局几乎没有什么保证，这使得它成为理解底层原理的一个不太理想的起点。幸运的是，Rust提供了一个`repr`属性，你可以在类型定义中添加它来请求特定的内存表示。最常见的，假如你看到了这个属性，便是`repr(C)`。顾名思义，它将类型按照与C或C++编译器布局相兼容的方式进行布局。当编写与其他语言通过外部函数接口（FFI）交互的Rust代码时，这非常有帮助，我们将在第11章讨论，因为Rust会生成与其他语言编译器预期的布局相匹配的布局。由于C的布局是可预测的，并且不会改变，`repr(C)`在不安全上下文中也很有用，尤其是当你在处理指向类型的原始指针时，或者当你需要在两个具有相同字段的不同类型之间进行转换时。它当然也是进入布局算法的完美起点。
- en: 'So, let’s look how the compiler would lay out a particular type with `repr(C)`:
    the `Foo` type in [Listing 2-1](#listing2-1). How do you think the compiler would
    lay this out in memory?'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们看看编译器如何使用`repr(C)`布局某个特定类型：在[示例 2-1](#listing2-1)中的`Foo`类型。你认为编译器会如何在内存中布局这个类型？
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: Alignment affects layout.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-1：对齐方式影响布局。
- en: First the compiler sees the field `tiny`, whose logical size is 1 bit (`true`
    or `false`). But since the CPU and memory operate in terms of bytes, `tiny` is
    given 1 byte in the in-memory representation. Next, `normal` is a 4-byte type,
    so we want it to be 4-byte-aligned. But even if `Foo` is aligned, the 1 byte we
    allocated to `tiny` is going to make `normal` miss its alignment. To rectify this,
    the compiler inserts 3 bytes of *padding*—bytes with an indeterminate value that
    are ignored in user code—into the in-memory representation between `tiny` and
    `normal`. No values go into the padding, but it does take up space.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译器看到字段`tiny`，它的逻辑大小是1位（`true`或`false`）。但是由于CPU和内存以字节为单位进行操作，`tiny`在内存中的表示占用了1字节。接着，`normal`是一个4字节类型，因此我们希望它按照4字节对齐。但即使`Foo`已经对齐，分配给`tiny`的1字节也会使得`normal`错过它的对齐位置。为了解决这个问题，编译器在`tiny`和`normal`之间插入了3字节的*填充*——这些字节值不确定，在用户代码中被忽略——以便使内存表示正确对齐。填充字节中没有值，但它确实占用了空间。
- en: 'For the next field, `small`, alignment is simple: it’s a 1-byte value, and
    the current byte offset into the struct is 1 + 3 + 4 = 8\. This is already byte-aligned,
    so `small` can go immediately after `normal`. With `long` we have a problem again,
    though. We are now 1 + 3 + 4 + 1 = 9 bytes into `Foo`. If `Foo` is aligned, then
    `long` is not 8-byte-aligned the way we want it to be, so we must insert another
    7 bytes of padding to make `long` aligned again. This also conveniently ensures
    the 2-byte alignment we need for the last field, `short`, bringing the total to
    26 bytes. Now that we’ve gone through all the fields, we also need to determine
    the alignment of `Foo` itself. The rule here is to use the largest alignment of
    any of `Foo`’s fields, which will be 8 bytes because of `long`. So, to ensure
    that `Foo` remains aligned if placed in, say, an array, the compiler then adds
    a final 6 bytes of padding to make `Foo`’s size a multiple of its alignment at
    32 bytes.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个字段，`small`，对齐很简单：它是一个1字节的值，而当前结构的字节偏移量是1 + 3 + 4 = 8\。这已经是字节对齐的，因此`small`可以紧跟在`normal`后面。不过，`long`又出现了问题。现在我们已经进入`Foo`的1
    + 3 + 4 + 1 = 9字节。如果`Foo`是对齐的，那么`long`就不是我们希望的8字节对齐，因此我们必须插入7个字节的填充，使`long`重新对齐。这个操作也方便地确保了最后一个字段`short`需要的2字节对齐，总共使得大小为26字节。现在我们已经处理完所有字段，还需要确定`Foo`本身的对齐。这里的规则是使用`Foo`所有字段中最大的对齐方式，这将是8字节，因为`long`字段的原因。因此，为了确保`Foo`在被放入数组时仍然对齐，编译器会最终添加6字节的填充，使`Foo`的大小成为其对齐的倍数，总计32字节。
- en: Now we are ready to shed the C legacy and consider what would happen to the
    layout if we did not use `repr(C)` in [Listing 2-1](#listing2-1). One of the primary
    limitations of the C representation is that it requires that we place all fields
    in the same order that they appear in the original struct definition. The default
    Rust representation `repr(Rust)` removes that limitation, along with a couple
    of other lesser restrictions, such as deterministic field ordering for types that
    happen to have the same fields. That is, even two different types that share all
    the same fields, of the same type, in the same order, are not guaranteed to be
    laid out the same when using the default Rust layout!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备抛弃C语言的遗产，考虑一下如果我们不使用`repr(C)`，会发生什么情况，如[Listing 2-1](#listing2-1)所示。C表示的一个主要限制是它要求我们按原始结构定义中出现的顺序放置所有字段。默认的Rust表示`repr(Rust)`消除了这个限制，并且去除了其他一些较小的限制，例如对类型字段的确定性排序——即使两个不同的类型共享完全相同的字段，且字段顺序相同，在默认的Rust布局下也不能保证它们的布局相同！
- en: 'Since we’re now allowed to reorder the fields, we can place them in decreasing
    order of size. This means we no longer need the padding between `Foo`’s fields;
    the fields themselves are used to achieve the necessary alignment! `Foo` is now
    just the size of its fields: only 16 bytes. This is one of the reasons why Rust
    by default does not give many guarantees about how a type is laid out in memory:
    by giving the compiler more leeway to rearrange things, we can produce more efficient
    code.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在允许重新排序字段，我们可以按照字段大小的递减顺序排列它们。这意味着我们不再需要在`Foo`的字段之间添加填充；字段本身就能实现所需的对齐！`Foo`现在只占用其字段的大小：仅16字节。这也是Rust默认情况下不会对类型在内存中的布局做出太多保证的原因之一：通过给编译器更多的调整空间，我们可以生成更高效的代码。
- en: It turns out there’s also a third way to lay out a type, and that is to tell
    the compiler that we do not want any padding between our fields. In doing so,
    we’re saying that we are willing to take the performance hit of using misaligned
    accesses. The most common use case for this is when the impact of every additional
    byte of memory can be felt, such as if you have a lot of instances of the type,
    if you have very limited memory, or if you’re sending the in-memory representation
    over a lower-bandwidth medium like a network connection. To opt in to this behavior,
    you can annotate your type with `#[repr(packed)]`. Keep in mind that this may
    lead to much slower code, and in extreme cases, this can cause your program to
    crash if you try to perform operations that the CPU supports only on aligned arguments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，还有第三种布局类型的方法，那就是告诉编译器我们不希望字段之间有任何填充。在这样做时，我们表示愿意接受使用未对齐访问所带来的性能损失。这种做法最常见的用例是当每增加一个字节的内存都会带来影响时，比如当你有大量的类型实例、内存非常有限，或者你正在通过低带宽的媒介（如网络连接）传输内存中的表示。要启用这种行为，你可以用`#[repr(packed)]`注解你的类型。请记住，这可能会导致代码变得更慢，在极端情况下，如果你尝试执行仅在对齐参数上支持的操作，程序可能会崩溃。
- en: Sometimes, you wanttogive a particular field or type a larger alignment than
    it technically requires. You can do that using the attribute `#[repr(align(n))]`.
    A common use case for this is to ensure that different values stored contiguously
    in memory (like in an array) end up in different cache lines on the CPU. That
    way, you avoid *false sharing*, which can cause huge performance degradations
    in concurrent programs. False sharing occurs when two different CPUs access different
    values that happen to share a cache line; while they can theoretically operate
    in parallel, they both end up contending to update the same single entry in the
    cache. We’ll talk about concurrency in much greater detail in Chapter 10.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望给某个特定字段或类型一个比它技术上要求的更大的对齐方式。你可以使用属性`#[repr(align(n))]`来实现。一个常见的用例是确保在内存中连续存储的不同值（例如在数组中）最终会位于CPU的不同缓存行中。这样，你可以避免*伪共享*，它会导致并发程序中的性能大幅下降。伪共享发生在两个不同的CPU访问恰好共享同一缓存行的不同值时；尽管它们理论上可以并行操作，但最终它们都会争抢更新缓存中的同一个条目。我们将在第10章中更详细地讨论并发。
- en: Complex Types
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂类型
- en: 'You might be curious about how the compiler represents other Rust types in
    memory. Here’s a quick reference:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能好奇编译器是如何在内存中表示其他Rust类型的。这里有一个快速参考：
- en: Tuple Represented like a struct with fields of the same type as the tuple values
    in the same order.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元组 表示方式类似于结构体，其中字段与元组值的类型相同，且顺序一致。
- en: Array Represented as a contiguous sequence of the contained type with no padding
    between the elements.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组 表示为包含类型的连续序列，元素之间没有填充。
- en: Union Layout is chosen independently for each variant. Alignment is the maximum
    across all the variants.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联合体 布局对于每个变体独立选择。对齐方式是所有变体中的最大值。
- en: Enumeration Same as union, but with one additional hidden shared field that
    stores the enum variant discriminant. The discriminant is the value the code uses
    to determine which of the enum variants a given value holds. The size of the discriminant
    field depends on the number of variants.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举 与联合体相同，但多了一个隐藏的共享字段，用于存储枚举变体的区分符。区分符是代码用来判断给定值属于哪个枚举变体的值。区分符字段的大小取决于变体的数量。
- en: Dynamically Sized Types and Wide Pointers
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态大小类型和宽指针
- en: 'You may have come across the marker trait `Sized` in various odd corners of
    the Rust documentation and in error messages. Usually, it comes up because the
    compiler wants you to provide a type that is `Sized`, but you (apparently) did
    not. Most types in Rust implement `Sized` automatically—that is, they have a size
    that’s known at compile time—but two common types do not: trait objects and slices.
    If you have, for example, a `dyn Iterator` or a `[u8]`, those do not have a well-defined
    size. Their size depends on some information that is known only when the program
    runs and not at compile time, which is why they are called *dynamically sized
    types (DSTs)*. Nobody knows ahead of time whether the `dyn Iterator` your function
    received is this 200-byte struct or that 8-byte struct. This presents a problem:
    often the compiler must know the size of something in order to produce valid code,
    such as how much space to allocate to a tuple of type `(i32, dyn Iterator, [u8],
    i32)` or what offset to use if your code tries to access the fourth field. But
    if the type isn’t `Sized`, that information isn’t available.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在Rust文档的各个奇怪角落和错误消息中遇到过标记特性`Sized`。通常，它会出现是因为编译器希望你提供一个`Sized`的类型，但你（显然）没有提供。Rust中的大多数类型会自动实现`Sized`，也就是说，它们的大小在编译时是已知的，但有两个常见类型不是：特性对象和切片。例如，如果你有一个`dyn
    Iterator`或`[u8]`，它们的大小是没有明确规定的。它们的大小依赖于程序运行时才会知道的信息，而不是在编译时已知的，这就是为什么它们被称为*动态大小类型（DSTs）*。没有人能提前知道你的函数接收到的`dyn
    Iterator`是这个200字节的结构体还是那个8字节的结构体。这就提出了一个问题：编译器通常必须知道某个事物的大小才能生成有效的代码，比如如何为类型`(i32,
    dyn Iterator, [u8], i32)`的元组分配空间，或者如果你的代码试图访问第四个字段时应该使用什么偏移量。但如果类型不是`Sized`，那就无法获得这些信息。
- en: 'The compiler requires types to be `Sized` nearly everywhere. Struct fields,
    function arguments, return values, variable types, and array types must all be
    `Sized`. This restriction is so common that every single type bound you write
    includes `T: Sized` unless you explicitly opt out of it with `T: ?Sized` (the
    `?` means “may not be”). But this is pretty unhelpful if you have a DST and want
    to do something with it, like if you really want your function to accept a trait
    object or a slice as an argument.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '编译器几乎在所有地方都要求类型必须是`Sized`。结构体字段、函数参数、返回值、变量类型和数组类型都必须是`Sized`。这种限制非常常见，几乎每次你编写类型约束时，都会包括`T:
    Sized`，除非你显式地选择不使用它，像是通过`T: ?Sized`（`?`表示“可能不是”）。但是，如果你有一个动态大小类型（DST），并且想对其执行某些操作，比如你真的希望你的函数接受一个特征对象或者切片作为参数，这样的约束就显得不太有用了。'
- en: 'The way to bridge this gap between unsized and sized types is to place unsized
    types behind a *wide pointer* (also known as a *fat pointer*). A wide pointer
    is just like a normal pointer, but it includes an extra word-sized field that
    gives the additional information about that pointer that the compiler needs to
    generate reasonable code for working with the pointer. When you take a reference
    to a DST, the compiler automatically constructs a wide pointer for you. For a
    slice, the extra information is simply the length of the slice. For a trait object—well,
    we’ll get to that later. And crucially, that wide pointer *is* `Sized`. Specifically,
    it is twice the size of a `usize` (the size of a word on the target platform):
    one `usize` for holding the pointer, and one `usize` for holding the extra information
    needed to “complete” the type.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 弥合大小类型和非大小类型之间的差距的方法是将非大小类型放在一个*宽指针*（也叫做*胖指针*）后面。宽指针就像普通指针，但它包含一个额外的与字长相同大小的字段，提供指针的额外信息，这些信息是编译器在生成合理的指针操作代码时所需要的。当你获取一个DST的引用时，编译器会自动为你构造一个宽指针。对于切片，额外的信息就是切片的长度。对于特征对象——嗯，我们稍后会详细讲解。而关键是，这个宽指针*是*`Sized`的。具体来说，它的大小是`usize`的两倍（`usize`是目标平台上一个字的大小）：一个`usize`用于存储指针，另一个`usize`用于存储完成类型所需的额外信息。
- en: Traits and Trait Bounds
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征和特征约束
- en: 'Traits are a key piece of Rust’s type system—they are the glue that allows
    types to interoperate even though they don’t know about each other at the time
    they are defined. *The Rust Programming Language* does a great job of covering
    how to define and use traits, so I won’t go over that here. Instead, we’re going
    to take a look at some of the more technical aspects of traits: how they’re implemented,
    restrictions you have to adhere to, and some more esoteric uses of traits.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 特征是Rust类型系统的关键部分——它们是允许类型之间进行交互的粘合剂，尽管这些类型在定义时彼此并不知情。《*Rust编程语言*》很好地介绍了如何定义和使用特征，所以我在这里就不再赘述。相反，我们将探讨一些更技术性的特征方面：它们是如何实现的，你需要遵守的限制，以及特征的一些更深奥的使用方式。
- en: Compilation and Dispatch
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译和分派
- en: By now, you’ve probably written a decent amount of generic code in Rust. You’ve
    used generic type parameters on types and methods, and maybe even a few trait
    bounds here and there. But have you ever wondered what actually happens to generic
    code when you compile it, or what happens when you call a trait method on a `dyn
    Trait`?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经编写了相当多的Rust泛型代码。你已经在类型和方法上使用了泛型类型参数，甚至可能还使用了一些特征约束。但是，你是否曾经想过，当你编译这些泛型代码时，实际发生了什么？或者，当你在`dyn
    Trait`上调用一个特征方法时，发生了什么？
- en: When you write a type or function that is generic over `T`, you’re really telling
    the compiler to make a copy of that type or function for each type `T`. When you
    construct a `Vec<i32>` or a `HashMap<String, bool>`, the compiler essentially
    copy-pastes the generic type and all its implementation blocks and replaces all
    instances of each generic parameter with the concrete type you provided. It makes
    a full copy of the `Vec` type with every `T` replaced with `i32`, and a full copy
    of the `HashMap` type with every `K` replaced with `String` and every `V` with
    `bool`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个对`T`泛型的类型或函数时，你实际上是在告诉编译器为每个类型`T`创建该类型或函数的副本。当你构造一个`Vec<i32>`或`HashMap<String,
    bool>`时，编译器本质上是复制粘贴了泛型类型及其所有实现块，并将每个泛型参数的实例替换为你提供的具体类型。它为`Vec`类型做了一个完整的副本，将所有的`T`替换为`i32`，为`HashMap`类型做了一个完整的副本，将所有的`K`替换为`String`，将所有的`V`替换为`bool`。
- en: The same thing applies to generic functions. Consider the code in [Listing 2-2](#listing2-2),
    which shows a generic method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于泛型函数。请看[示例 2-2](#listing2-2)，其中展示了一个泛型方法。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 2-2: A generic method using static dispatch'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-2：使用静态分派的泛型方法
- en: 'A copy of this method is made for every distinct pattern type (recall that
    `impl Trait` is shorthand for `<T: Trait>`). We need a different copy of the function
    body for each `impl Pattern` type because we need to know the address of the `is_contained_in`
    function to call it. The CPU needs to be told where to jump to and continue execution.
    For any *given* pattern, the compiler knows that that address is the address of
    the place where that pattern type implements that trait method. But there is no
    one address we could use for *any* type, so we need to have one copy for each
    type, each with its own address to jump to. This is referred to as *static dispatch*,
    since for any given copy of the method, the address we are “dispatching to” is
    known statically.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '对于每种不同的模式类型，都需要为其创建一个该方法的副本（回想一下，`impl Trait` 是 `<T: Trait>` 的简写）。我们需要为每个 `impl
    Pattern` 类型准备一个不同的函数体副本，因为我们需要知道 `is_contained_in` 函数的地址以便调用它。CPU 需要知道跳转到哪里继续执行。对于任何*给定的*模式，编译器知道那个地址就是该模式类型实现该特征方法的地方的地址。但我们无法为*任何*类型使用一个地址，所以我们需要为每个类型准备一个副本，每个副本都有自己的跳转地址。这种方式被称为*静态分派*，因为对于该方法的任何副本，我们“分派到”的地址是静态已知的。'
- en: This process of going from a generic type to many non-generic types is called
    *monomorphization*, and it’s part of the reason generic Rust code usually performs
    just as well as non-generic code. By the time the compiler starts optimizing your
    code, it’s as if no generics were there at all! Each instance is optimized separately
    and with all of the types known. As a result, the code is just as efficient as
    if the `is_contained_in` method of the pattern that is passed in were called directly
    without any traits present. The compiler has full knowledge of the types involved
    and can even inline the implementation of `is_contained_in` if it wishes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个泛型类型转换为多个非泛型类型的过程被称为*泛型化*，这也是泛型 Rust 代码通常与非泛型代码性能相当的原因之一。等到编译器开始优化你的代码时，几乎就好像根本没有泛型存在！每个实例都会单独优化，并且所有类型都已知。因此，代码的效率与直接调用传入模式的
    `is_contained_in` 方法（没有任何特征）时的效果是一样的。编译器完全了解所涉及的类型，甚至可以根据需要内联 `is_contained_in`
    的实现。
- en: 'Monomorphization also comes at a cost: all those instantiations of your type
    need to be compiled separately, which can increase compile time if the compiler
    cannot optimize them away. Each monomorphized function also results in its own
    chunk of machine code, which can make your program larger. And because instructions
    aren’t shared between different instantiations of a generic type’s methods, the
    CPU’s instruction cache is also less effective as it now needs to hold multiple
    copies of effectively the same instructions.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型化也有其成本：所有这些类型实例化需要单独编译，如果编译器不能优化掉它们，这会增加编译时间。每个泛型化的函数还会生成自己的机器代码块，这可能会使程序变大。而且，因为不同实例化的泛型类型方法之间的指令不能共享，CPU
    的指令缓存也会变得不那么高效，因为它现在需要存储多个几乎相同的指令副本。
- en: 'The alternative to static dispatch is *dynamic dispatch*, which enables code
    to call a trait method on a generic type without knowing what that type is. I
    said earlier that the reason we needed multiple instances of the method in [Listing
    2-2](#listing2-2) was that otherwise your program wouldn’t know what address to
    jump to in order to call the trait method `is_contained_in` on the given pattern.
    Well, with dynamic dispatch, the caller simply tells you. If you replace `impl
    Pattern` with `&dyn Pattern`, you tell the caller that they must give *two* pieces
    of information for this argument: the address of the pattern *and* the address
    of the `is_contained_in` method. In practice, the caller gives us a pointer to
    a chunk of memory called a virtual method table, or *vtable*, that holds the address
    of the implementation of *all* the trait’s methods for the type in question, one
    of which is `is_contained_in`. When the code inside the method wants to call a
    trait method on the provided pattern, it looks up the address of that pattern’s
    implementation of `is_contained_in` in the vtable and then calls the function
    at that address. This allows us to use the same function body regardless of what
    type the caller wants to use.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 静态派发的替代方案是*动态派发*，它使得代码能够在不知晓类型的情况下调用泛型类型的trait方法。我之前说过，之所以在[Listing 2-2](#listing2-2)中需要多个方法实例，是因为否则你的程序无法知道跳转到哪个地址以调用给定模式上的trait方法`is_contained_in`。好了，使用动态派发时，调用者会直接告诉你。如果你将`impl
    Pattern`替换为`&dyn Pattern`，你就是在告诉调用者，他们必须为此参数提供*两个*信息：模式的地址*和*`is_contained_in`方法的地址。在实践中，调用者给我们提供一个指向内存块的指针，这个内存块称为虚拟方法表（vtable），它保存了给定类型的trait方法的所有实现地址，其中之一就是`is_contained_in`。当方法内部代码想要调用提供的模式上的trait方法时，它会在vtable中查找该模式的`is_contained_in`实现地址，然后调用该地址的函数。这使得我们无论调用者希望使用何种类型，都可以使用相同的函数体。
- en: You’ll notice that when we opted in to dynamic dispatch using the `dyn` keyword,
    we had to place an `&` in front of it. The reason is that we no longer know at
    compile time the size of the pattern type that the caller passes in, so we don’t
    know how much space to set aside for it. In other words, `dyn Trait` is `!Sized`,
    where the `!` means not. To make it `Sized` so we can take it as an argument,
    we place it behind a pointer (which we know the size of). Since we also need to
    pass along the table of method addresses, this pointer becomes a wide pointer,
    where the extra word holds the pointer to the vtable. You can use any type that
    is able to hold a wide pointer for dynamic dispatch, such as `&mut`, `Box`, and
    `Arc`. [Listing 2-3](#listing2-3) shows the dynamic dispatch equivalent of [Listing
    2-2](#listing2-2).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`dyn`关键字选择动态派发时，你会注意到我们必须在前面加上一个`&`。原因是我们在编译时无法知道调用者传入的模式类型的大小，因此我们不知道需要为其预留多少空间。换句话说，`dyn
    Trait`是`!Sized`，其中`!`表示不是。为了让它变成`Sized`，以便我们可以将其作为参数传入，我们将其放在指针后面（我们知道指针的大小）。由于我们还需要传递方法地址的表格，因此这个指针变成了一个宽指针，其中额外的字保存了指向虚拟方法表（vtable）的指针。你可以使用任何能够持有宽指针的类型来进行动态派发，例如`&mut`、`Box`和`Arc`。[Listing
    2-3](#listing2-3)展示了与[Listing 2-2](#listing2-2)相对应的动态派发示例。
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 2-3: A generic method using dynamic dispatch'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-3: 使用动态派发的泛型方法'
- en: The combination of a type that implements a trait and its vtable is known as
    a *trait object*. Most traits can be turned into trait objects, but not all. For
    example, the `Clone` trait, whose `clone` method returns `Self`, cannot be turned
    into a trait object. If we accept a `dyn Clone` trait object and then call `clone`
    on it, the compiler won’t know what type to return. Or, consider the `Extend`
    trait from the standard library, which has a method `extend` that is generic over
    the type of the provided iterator (so there may be many instances of it). If you
    were to call a method that took a `dyn Extend`, there would be no single address
    for `extend` to place in the trait object’s vtable; there would have to be one
    entry for every type `extend` might ever be called with. These are examples of
    traits that are not *object-safe* and therefore may not be turned into trait objects.
    To be object-safe, none of a trait’s methods can be generic or use the `Self`
    type. Furthermore, the trait cannot have any static methods (that is, methods
    whose first argument does not dereference to `Self`), since it would be impossible
    to know which instance of the method to call. It is not clear, for example, what
    code `FromIterator::from_iter(&[0])` should execute.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了特性的类型与其虚表的组合被称为*特性对象*。大多数特性可以转换为特性对象，但并非所有。例如，`Clone`特性，其`clone`方法返回`Self`，不能转换为特性对象。如果我们接受一个`dyn
    Clone`特性对象并在其上调用`clone`，编译器将无法知道返回什么类型。再比如，来自标准库的`Extend`特性，它有一个`extend`方法，该方法对于提供的迭代器类型是泛型的（因此可能有多个实例）。如果你调用一个接受`dyn
    Extend`的方法，则`extend`在特性对象的虚表中无法放入一个唯一的地址；必须为`extend`可能被调用的每个类型插入一个条目。这些都是不能*安全作为对象*的特性，因此无法转换为特性对象。为了安全作为对象，特性中的方法不能是泛型的，也不能使用`Self`类型。此外，特性不能有任何静态方法（即那些第一个参数不是解引用到`Self`的方法），因为无法知道应该调用哪个方法实例。例如，`FromIterator::from_iter(&[0])`应该执行什么代码是不明确的。
- en: 'When reading about trait objects, you may see mentions of the trait bound `Self:
    Sized`. Such a bound implies that `Self` is not being used through a trait object
    (since it would then be `!Sized`). You can place that bound on a trait to require
    that the trait never use dynamic dispatch, or you can place it on a specific method
    to make that method unavailable when the trait is accessed through a trait object.
    Methods with a `where Self: Sized` bound are exempted when checking if a trait
    is object-safe.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '当阅读关于特性对象的内容时，可能会看到提到特性约束`Self: Sized`。这样的约束意味着`Self`没有通过特性对象使用（因为它那时会是`!Sized`）。你可以将这个约束放在一个特性上，要求该特性从不使用动态分发，或者将它放在特定方法上，使得该方法在通过特性对象访问时不可用。具有`where
    Self: Sized`约束的方法在检查特性是否安全作为对象时会被豁免。'
- en: Dynamic dispatch cuts compile times, since it’s no longer necessary to compile
    multiple copies of types and methods, and it can improve the efficiency of your
    CPU instruction cache. However, it also prevents the compiler from optimizing
    for the specific types that are used. With dynamic dispatch, all the compiler
    can do for `find` in [Listing 2-2](#listing2-2) is insert a call to the function
    through the vtable—it can no longer perform any additional optimizations as it
    does not know what code will sit on the other side of that function call. Furthermore,
    every method call on a trait object requires a lookup in the vtable, which adds
    a small amount of overhead over calling the method directly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分发减少了编译时间，因为不再需要编译多个类型和方法的副本，而且它还可以提高CPU指令缓存的效率。然而，它也阻止编译器对所使用的具体类型进行优化。在动态分发中，编译器对[示例
    2-2](#listing2-2)中的`find`方法所能做的唯一优化，就是通过虚表插入一个对该函数的调用——它无法执行任何其他优化，因为它不知道函数调用的另一侧将执行什么代码。此外，特性对象上的每个方法调用都需要在虚表中查找，这比直接调用方法多了一点额外开销。
- en: When you’re given the choice between static and dynamic dispatch, there is rarely
    a clear-cut right answer. Broadly speaking, though, you’ll want to use static
    dispatch in your libraries and dynamic dispatch in your binaries. In a library,
    you want to allow your users to decide what kind of dispatch is best for them,
    since you don’t know what their needs are. If you use dynamic dispatch, they’re
    forced to do the same, whereas if you use static dispatch, they can choose whether
    to use dynamic dispatch or not. In a binary, on the other hand, you’re writing
    the final code, so there are no needs to consider except those of the code you
    are writing. Dynamic dispatch often allows you to write cleaner code that leaves
    out generic parameters and will compile more quickly, all at a (usually) marginal
    performance cost, so it’s usually the better choice for binaries.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在静态分发和动态分发之间做选择时，通常没有明确的正确答案。大体而言，你会希望在库中使用静态分发，而在二进制文件中使用动态分发。在库中，你希望允许用户自行决定哪种分发方式最适合他们，因为你不知道他们的需求。如果你使用动态分发，他们也必须做出同样的决定；而如果你使用静态分发，他们可以选择是否使用动态分发。另一方面，在二进制文件中，你是写最终的代码，所以只有你写的代码的需求需要考虑。动态分发通常允许你编写更简洁的代码，省略泛型参数，且编译速度更快，虽然通常会有微小的性能损失，因此它通常是二进制文件的更好选择。
- en: Generic Traits
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型特征
- en: 'Rust traits can be generic in one of two ways: with generic type parameters
    like `trait Foo<T>` or with associated types like `trait Foo { type Bar; }`. The
    difference between these is not immediately apparent, but luckily the rule of
    thumb is quite simple: use an associated type if you expect only one implementation
    of the trait for a given type, and use a generic type parameter otherwise.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Rust特征可以通过两种方式实现泛型：使用泛型类型参数，如`trait Foo<T>`，或使用关联类型，如`trait Foo { type Bar;
    }`。这两者之间的区别不容易立刻看出来，但幸运的是，经验法则非常简单：如果你期望某个特征对于给定类型只有一个实现，就使用关联类型；否则使用泛型类型参数。
- en: The rationale for this is that associated types are often significantly easier
    to work with, but will not allow multiple implementations. So, more simply put,
    the advice is really just to use associated types whenever you can.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是，关联类型通常更容易使用，但不允许多次实现。更简单地说，这条建议的核心就是尽可能使用关联类型。
- en: 'With a generic trait, users must always specify all the generic parameters
    and repeat any bounds on those parameters. This can quickly get messy and hard
    to maintain. If you add a generic parameter to a trait, all users of that trait
    must also be updated to reflect the change. And since multiple implementations
    of a trait may exist for a given type, the compiler may have a hard time deciding
    which instance of the trait you meant to use, leading to awful disambiguating
    function calls like `FromIterator::<u32>::from_iter`. But the upside is that you
    can implement the trait multiple times for the same type—for example, you can
    implement `PartialEq` against multiple right-hand side types for your type, or
    you can implement both `FromIterator<T>` *and* `FromIterator<&T> where T: Clone`,
    precisely because of the flexibility that generic traits provide.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '对于一个泛型特征，用户必须始终指定所有泛型参数并重复这些参数的任何约束条件。这可能很快变得混乱且难以维护。如果你向特征中添加一个泛型参数，那么所有使用该特征的用户也必须更新以反映这一变化。而且，由于对于给定类型可能存在多个特征实现，编译器可能很难决定你想使用哪个特征实例，从而导致像`FromIterator::<u32>::from_iter`这样的糟糕歧义函数调用。但好处是，你可以为同一类型多次实现该特征——例如，你可以为你的类型实现针对多个右侧类型的`PartialEq`，或者你可以同时实现`FromIterator<T>`
    *和* `FromIterator<&T> where T: Clone`，这正是由于泛型特征所提供的灵活性。'
- en: With associated types, on the other hand, the compiler needs to know only the
    type that implements the trait, and all the associated types follow (since there
    is only one implementation). This means the bounds can all live in the trait itself
    and do not need to be repeated on use. In turn, this allows the trait to add further
    associated types without affecting its users. And because the type dictates all
    the associated types of the trait, you never have to disambiguate with the unified
    function calling syntax shown in the previous paragraph. However, you cannot implement
    `Deref` against multiple `Target` types, nor can you implement `Iterator` with
    multiple different `Item` types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用关联类型时，编译器只需要知道实现了该特征的类型，所有的关联类型都会随之确定（因为只有一个实现）。这意味着所有的约束条件可以全部放在特征本身，而无需在使用时重复。这反过来允许特征添加更多的关联类型，而不会影响其使用者。而且，由于类型决定了特征的所有关联类型，你永远不需要像前一段所示那样使用统一的函数调用语法来消除歧义。然而，你不能对多个`Target`类型实现`Deref`，也不能对多个不同的`Item`类型实现`Iterator`。
- en: Coherence and the Orphan Rule
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一致性与孤儿规则
- en: 'Rust has some fairly strict rules about where you can implement traits and
    what types you can implement them on. These rules exist to preserve the *coherence
    property: for any given type and method, there is only ever one correct choice
    for which implementation of the method to use for that type. To see why this is
    important, consider what would happen if I could write my own implementation of
    the `Display` trait for the `bool` type from the standard library. Now, for any
    code that tries to print a `bool` value and includes my crate, the compiler won’t
    know whether to pick the implementation I wrote or the one from the standard library.
    Neither choice is correct or better than the other, and the compiler obviously
    cannot choose randomly. The same issue occurs if the standard library is not involved
    at all, but we instead have two crates that depend on each other, and they both
    implement a trait for some shared type. The coherence property ensures that the
    compiler never ends up in these situations and never has to make these choices:
    there will always be exactly one obvious choice.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Rust对你可以在哪些类型上实现特征以及如何实现它们有一些相当严格的规则。这些规则的存在是为了保持*一致性属性：对于任何给定的类型和方法，始终只有一个正确的选择来决定该类型使用哪种方法实现。为了理解这一点，想象一下如果我能为标准库中的`bool`类型编写自己的`Display`特征实现会发生什么。现在，对于任何尝试打印`bool`值并且包含我的crate的代码，编译器将不知道是选择我写的实现还是标准库中的实现。没有哪个选择是正确的或比另一个更好，而且编译器显然不能随机选择。如果完全没有标准库的参与，而是我们有两个相互依赖的crate，它们都为某个共享类型实现了一个特征，也会发生同样的问题。一致性属性确保编译器永远不会陷入这些情况，并且永远不需要做出这些选择：总会有一个明确的选择。*
- en: '*A facile way to uphold coherence would be to ensure only the crate that defines
    a trait can write implementations for that trait; if no one else can implement
    the trait, then there can be no conflicting implementations elsewhere. However,
    this is too restrictive in practice and would essentially make traits useless,
    as there would be no way to implement traits like `std::fmt::Debug` and `serde::Serialize`
    for your own types, unless you got your own type included into the defining crate.
    The opposite extreme, saying that you can implement traits for only your own types,
    solves that problem but introduces another: a crate that defines a trait now cannot
    provide implementations of that trait for types in the standard library or in
    other popular crates! Ideally, we would like to find some set of rules that balances
    the desire for downstream crates to implement upstream traits for their own types
    against the desire for upstream crates to be able to add implementations of their
    own traits without breaking downstream code.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*维持一致性的一个简单方法是确保只有定义特征的crate可以为该特征编写实现；如果没有其他人能实现这个特征，那么就不会有冲突的实现。然而，实践中这太过严格，基本上会让特征变得没用，因为你无法为自己的类型实现像`std::fmt::Debug`和`serde::Serialize`这样的特征，除非你将自己的类型包含进定义特征的crate中。相反的极端说法是，只能为自己的类型实现特征，这虽然解决了问题，但又引入了另一个问题：一个定义特征的crate现在不能为标准库或其他流行crate中的类型提供该特征的实现！理想情况下，我们希望找到一组规则，既能平衡下游crate为自己的类型实现上游特征的需求，又能让上游crate在不破坏下游代码的情况下添加自己的特征实现。*'
- en: In Rust, the rule that establishes that balance is the *orphan rule*. Simply
    stated, the orphan rule says that you can implement a trait for a type only if
    the trait *or* the type is local to your crate. So, you can implement `Debug`
    for your own type, and you can implement `MyNeatTrait` for `bool`, but you cannot
    implement `Debug` for `bool`. If you try, your code will not compile, and the
    compiler will tell you that there are conflicting implementations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，确立这种平衡的规则是*孤儿规则*。简单来说，孤儿规则规定，只有当 trait *或*类型属于你自己的 crate 时，你才可以为该类型实现
    trait。因此，你可以为你自己的类型实现 `Debug`，你也可以为 `bool` 实现 `MyNeatTrait`，但不能为 `bool` 实现 `Debug`。如果你尝试这么做，编译器会告诉你代码无法编译，因为存在冲突的实现。
- en: This gets you pretty far; it allows you to implement your own traits for third-party
    types and to implement third-party traits for your own types. However, the orphan
    rule is not the end of the story. There are a number of additional implications,
    caveats, and exceptions to it that you should be aware of.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这使你走得很远；它允许你为第三方类型实现你自己的 trait，并为你自己的类型实现第三方 trait。然而，孤儿规则并不是故事的全部。它还有许多额外的影响、注意事项和例外情况，你应该了解这些内容。
- en: Blanket Implementations
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通用实现
- en: The orphan rule allows you to implement traits over a range of types with code
    like `impl<T> MyTrait for T where T:` and so on. This is a *blanket implementation*—it
    is not limited to just one particular type but instead applies to a wide range
    of types. Only the crate that defines a trait is allowed to write a blanket implementation,
    and adding a blanket implementation to an existing trait is considered a breaking
    change. If it were not, a downstream crate that contained `impl MyTrait for Foo`
    could suddenly stop compiling just because you update the crate that defines `MyTrait`
    with an error about a conflicting implementation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 孤儿规则允许你通过像 `impl<T> MyTrait for T where T:` 这样的代码对一系列类型实现 trait。这是一种*通用实现*——它不限于某一个特定类型，而是适用于广泛的类型。只有定义
    trait 的 crate 才能编写通用实现，并且向现有 trait 添加通用实现会被视为破坏性变更。如果不是这样，某个下游 crate 中的 `impl
    MyTrait for Foo` 可能会因为你更新定义 `MyTrait` 的 crate 而突然无法编译，原因是冲突的实现。
- en: Fundamental Types
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本类型
- en: Some types are so essential that it’s necessary to allow anyone to implement
    traits on them, even if this seemingly violates the orphan rule. These types are
    marked with the `#[fundamental]` attribute and currently include `&`, `&mut`,
    and `Box`. For the purposes of the orphan rule, fundamental types may as well
    not exist—they are effectively erased before the orphan rule is checked in order
    to allow you to, for example, implement `IntoIterator for &MyType`. With just
    the orphan rule, this implementation would not be permitted since it implements
    a foreign trait for a foreign type—`IntoIterator` and `&` both come from the standard
    library. Adding a blanket implementation over a fundamental type is also considered
    a breaking change.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类型是如此重要，以至于必须允许任何人都能为它们实现 trait，即使这看起来违反了孤儿规则。这些类型会标记上 `#[fundamental]` 属性，目前包括
    `&`、`&mut` 和 `Box`。就孤儿规则而言，基本类型可以说是不存在的——它们在检查孤儿规则之前会被有效地“擦除”，从而允许你例如为 `&MyType`
    实现 `IntoIterator`。如果仅有孤儿规则，这种实现是不被允许的，因为它为一个外来类型实现了一个外来 trait——`IntoIterator`
    和 `&` 都来自标准库。为基本类型添加通用实现同样会被视为破坏性变更。
- en: Covered Implementations
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 覆盖实现
- en: There are some limited cases where we want to allow implementing a foreign trait
    for a foreign type, which the orphan rule does not normally allow. The simplest
    example of this is when you want to write something like `impl From<MyType> for
    Vec<i32>`. Here, the `From` trait is foreign, as is the `Vec` type, yet there
    is no danger of violating coherence. This is because a conflicting implementation
    could be added only through a blanket implementation in the standard library (the
    standard library cannot otherwise name `MyType`), which is a breaking change anyway.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有限的情况，我们希望允许为外来类型实现外来 trait，这是孤儿规则通常不允许的。最简单的例子是当你想写类似 `impl From<MyType>
    for Vec<i32>` 的代码时。在这里，`From` trait 是外来的，`Vec` 类型也是外来的，但没有违反一致性的风险。这是因为冲突的实现只能通过标准库中的通用实现添加（标准库不能直接命名
    `MyType`），而且这本身就是破坏性变更。
- en: To allow these kinds of implementations, the orphan rule includes a narrow exemption
    that permits implementing foreign traits for foreign types under a very specific
    set of circumstances. Specifically, a given `impl<P1..=Pn> ForeignTrait<T1..=Tn>
    for T0` is allowed only if at least one `Ti` is a local type and no `T` before
    the first such `Ti` is one of the generic types `P1..=Pn`. Generic type parameters
    (`P`s) *are* allowed to appear in `T0..Ti` as long as they are *covered* by some
    intermediate type. A `T` is covered if it appears as a type parameter to some
    other type (like `Vec<T>`), but not if it stands on its own (just `T`) or just
    appears behind a fundamental type like `&T`. So, all the implementations in [Listing
    2-4](#listing2-4) are valid.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许这些类型的实现，孤儿规则包括一个狭义的豁免，允许在非常特定的情况下为外部类型实现外部特征。具体来说，只有当至少有一个 `Ti` 是本地类型，并且在第一个
    `Ti` 之前没有任何 `T` 是泛型类型 `P1..=Pn` 时，才允许给定的 `impl<P1..=Pn> ForeignTrait<T1..=Tn>
    for T0`。只要它们被某个中介类型所“涵盖”，泛型类型参数（`P`）*是*允许出现在 `T0..Ti` 中的。一个 `T` 被认为是被涵盖的，如果它作为某个其他类型的类型参数出现（例如
    `Vec<T>`），但如果它单独存在（只是 `T`）或仅出现在基本类型后面（例如 `&T`），则不被视为涵盖。所以，[列表 2-4](#listing2-4)中的所有实现都是有效的。
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 2-4: Valid implementations of foreign traits for foreign types'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-4：外部类型的外部特征有效实现
- en: However, the implementations in [Listing 2-5](#listing2-5) are invalid.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，[列表 2-5](#listing2-5)中的实现是无效的。
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 2-5: Invalid implementations of foreign traits for foreign types'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-5：外部类型的外部特征无效实现
- en: This relaxation of the orphan rule complicates the rules for what constitutes
    a breaking change when you add a new implementation for an existing trait. In
    particular, adding a new implementation to an existing trait is non-breaking only
    if it contains at least one *new* local type, and that new local type satisfies
    the rules for the exemption described earlier. Adding any other new implementation
    is a breaking change.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对孤儿规则的放宽使得在为现有特征添加新实现时，什么构成破坏性变更的规则变得更加复杂。特别是，向现有特征添加新实现只有在它包含至少一个*新的*本地类型，并且该新本地类型满足前面描述的豁免规则时，才算作非破坏性变更。添加任何其他新实现都是破坏性变更。
- en: Trait Bounds
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特征边界
- en: The standard library is flush with trait bounds, whether it’s that the keys
    in a `HashMap` must implement `Hash + Eq` or that the function given to `thread::spawn`
    must be `FnOnce + Send + 'static`. When you write generic code yourself, it will
    almost certainly include trait bounds, as otherwise your code cannot do much with
    the type it is generic over. As you write more elaborate generic implementations,
    you’ll find that you also need more fidelity from your trait bounds, so let’s
    look at some of the ways to achieve that.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库充满了特征边界，无论是 `HashMap` 中的键必须实现 `Hash + Eq`，还是传递给 `thread::spawn` 的函数必须是 `FnOnce
    + Send + 'static`。当你自己编写泛型代码时，几乎肯定会涉及特征边界，否则你的代码无法在泛型类型上做很多事情。随着你编写越来越复杂的泛型实现，你会发现你需要更多的特征边界精度，那么我们来看看如何实现这一点。
- en: 'First and foremost, trait bounds do not have to be of the form `T: Trait` where
    `T` is some type your implementation or type is generic over. The bounds can be
    arbitrary type restrictions and do not even need to include generic parameters,
    types of arguments, or local types. You can write a trait bound like `where String:
    Clone`, even though `String: Clone` is always true and contains no local types.
    You can also write `where io::Error: From<MyError<T>>`; your generic type parameters
    do not need to appear only on the left-hand side. This not only allows you to
    express more intricate bounds but also can save you from needlessly repeating
    bounds. For example, if your method wants to construct a `HashMap<K, V, S>` whose
    keys are some generic type `T` and whose value is a `usize`, instead of writing
    the bounds out like `where T: Hash + Eq, S: BuildHasher + Default`, you could
    write `where HashMap<T, usize, S>: FromIterator`. This saves you from looking
    up the exact bounds requirements for the methods you end up using and more clearly
    communicates the “true” requirement of your code. As you can see, it can also
    significantly reduce the complexity of your bounds if the bounds on the underlying
    trait methods you want to call are complex.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，trait 边界不必是 `T: Trait` 的形式，其中 `T` 是你实现或类型所泛型化的某种类型。边界可以是任意类型限制，甚至不需要包含泛型参数、参数类型或局部类型。你可以写出像
    `where String: Clone` 这样的 trait 边界，即使 `String: Clone` 永远为真且不包含局部类型。你还可以写出 `where
    io::Error: From<MyError<T>>`；你的泛型类型参数不需要仅出现在左侧。这不仅让你能够表达更复杂的边界，还能避免不必要的重复边界。例如，如果你的方法想要构造一个
    `HashMap<K, V, S>`，其中键是某种泛型类型 `T`，值是 `usize`，你可以避免像 `where T: Hash + Eq, S: BuildHasher
    + Default` 这样写出边界，而是写 `where HashMap<T, usize, S>: FromIterator`。这样可以避免查找你最终使用的方法的确切边界要求，同时更清晰地传达代码的“真正”要求。如你所见，如果你想调用的底层
    trait 方法的边界很复杂，这也可以显著减少边界的复杂性。'
- en: Sometimes, you want bounds on associated types of types you’re generic over.
    As an example, consider the iterator method `flatten`, which takes an iterator
    that produces items that in turn implement `Iterator` and produces an iterator
    of the items of those inner iterators. The type it produces, `Flatten`, is generic
    over `I`, which is the type of the outer iterator. `Flatten` implements `Iterator`
    if `I` implements `Iterator` *and* the items yielded by `I` themselves implement
    `IntoIterator`. To enable you to write bounds like this, Rust lets you refer to
    associated types of a type using the syntax `Type::AssocType`. For example, we
    can refer to `I`’s `Item` type using `I::Item`. If a type has multiple associated
    types by the same name, such as if the trait that provides the associated type
    is itself generic (and therefore there are many implementations), you can disambiguate
    with the syntax `<Type as Trait>::AssocType`. Using this, you can write bounds
    not only for the outer iterator type but also for the item type of that outer
    iterator.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要对泛型中关联类型设置边界。例如，考虑 `flatten` 迭代器方法，它接收一个产生项目的迭代器，而这些项目本身实现了 `Iterator`，并生成这些内部迭代器项的迭代器。它生成的类型
    `Flatten` 是泛型的，泛型参数 `I` 是外部迭代器的类型。如果 `I` 实现了 `Iterator`，*并且* `I` 产生的项本身实现了 `IntoIterator`，那么
    `Flatten` 就实现了 `Iterator`。为了使你能够编写类似的边界，Rust 允许你使用 `Type::AssocType` 语法来引用类型的关联类型。例如，我们可以通过
    `I::Item` 来引用 `I` 的 `Item` 类型。如果一个类型有多个相同名称的关联类型（例如，提供该关联类型的 trait 本身是泛型的，因此有多个实现），你可以通过
    `<Type as Trait>::AssocType` 语法来消除歧义。使用这种方式，你不仅可以为外部迭代器类型编写边界，还可以为该外部迭代器的项类型编写边界。
- en: 'In code that uses generics extensively, you may find that you need to write
    a bound that talks about references to a type. This is normally fine, as you’ll
    tend to also have a generic lifetime parameter that you can use as the lifetime
    for these references. In some cases, however, you want the bound to say “this
    reference implements this trait for any lifetime.” This type of bound is known
    as a *higher-ranked trait bound*, and it’s particularly useful in association
    with the `Fn` traits. For example, say you want to be generic over a function
    that takes a reference to a `T` and returns a reference to *inside* that `T`.
    If you write `F: Fn(&T) -> &U`, you need to provide a lifetime for those references,
    but you really want to say “any lifetime as long as the output is the same as
    the input.” Using a higher-ranked lifetime, you can write `F: for<''a> Fn(&''a
    T) -> &''a U` to say that for *any* lifetime `''a`, the bound must hold. The Rust
    compiler is smart enough that it automatically adds the `for` when you write `Fn`
    bounds with references like this, which covers the majority of use cases for this
    feature. The explicit form is needed so exceedingly rarely that, at the time of
    writing, the standard library uses it in just three places—but it does happen
    and so is worth knowing about.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '在广泛使用泛型的代码中，你可能会发现需要写一个与类型的引用相关的约束。通常这没问题，因为你通常会有一个泛型生命周期参数，可以用作这些引用的生命周期。然而，在某些情况下，你希望约束能够说“这个引用在任何生命周期下都实现这个
    trait”。这种类型的约束被称为 *高阶 trait 约束*，它在与 `Fn` trait 结合使用时尤其有用。例如，假设你想要对一个函数进行泛型化，该函数接受对
    `T` 的引用并返回对该 `T` 内部的引用。如果你写 `F: Fn(&T) -> &U`，你需要为这些引用提供生命周期，但你实际上想说的是“任何生命周期，只要输出和输入相同”。通过使用高阶生命周期，你可以写
    `F: for<''a> Fn(&''a T) -> &''a U`，表示对于 *任何* 生命周期 `''a`，约束必须成立。Rust 编译器足够智能，当你像这样使用带有引用的
    `Fn` 约束时，它会自动添加 `for`，这涵盖了该特性的绝大多数使用场景。显式的形式如此罕见，以至于在写作时，标准库仅在三个地方使用了它——但它确实存在，所以值得了解。'
- en: To bring all of this together, consider the code in [Listing 2-6](#listing2-6),
    which can be used to implement `Debug` for any type that can be iterated over
    and whose elements are `Debug`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有这些内容结合起来，考虑 [示例 2-6](#listing2-6) 中的代码，它可以用于为任何可以迭代且其元素为 `Debug` 的类型实现
    `Debug`。
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 2-6: An excessively generic implementation of `Debug` for any iterable
    collection'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-6：适用于任何可迭代集合的过于泛化的 `Debug` 实现
- en: You could copy-paste this implementation for pretty much any collection type
    and it would “just work.” Of course, you may want a smarter debug implementation,
    but this illustrates the power of trait bounds quite well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个实现复制并粘贴到几乎任何集合类型中，它都会“正常工作”。当然，你可能希望有一个更智能的调试实现，但这很好地展示了 trait 约束的强大功能。
- en: Marker Traits
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记 Trait
- en: Usually, we use traits to denote functionality that multiple types can support;
    a `Hash` type can be hashed by calling `hash`, a `Clone` type can be cloned by
    calling `clone`, and a `Debug` type can be formatted for debugging by calling
    `fmt`. But not all traits are functional in this way. Some traits, called *marker
    traits*, instead indicate a property of the implementing type. Marker traits have
    no methods or associated types and serve just to tell you that a particular type
    can or cannot be used in a certain way. For example, if a type implements the
    `Send` marker trait, it is safe to send across thread boundaries. If it does not
    implement this marker trait, it isn’t safe to send. There are no methods associated
    with this behavior; it’s just a fact about the type. The standard library has
    a number of these in the `std::marker` module, including `Send`, `Sync`, `Copy`,
    `Sized`, and `Unpin`. Most of these (all except `Copy`) are also *auto-traits*;
    the compiler automatically implements them for types unless the type contains
    something that does not implement the marker trait.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用 trait 来表示多个类型可以支持的功能；`Hash` 类型可以通过调用 `hash` 进行哈希，`Clone` 类型可以通过调用 `clone`
    进行克隆，`Debug` 类型可以通过调用 `fmt` 进行调试格式化。但并非所有的 trait 都是以这种方式具有功能性的。有些 trait，称为 *标记
    trait*，则表示实现类型的某种属性。标记 trait 没有方法或关联类型，仅仅是告诉你某个特定类型是否可以或不能以某种方式使用。例如，如果一个类型实现了
    `Send` 标记 trait，那么它可以安全地跨线程边界发送。如果没有实现这个标记 trait，那么发送它是不安全的。与这种行为没有关联的方法；它只是类型的一个事实。标准库中有许多这样的
    trait，位于 `std::marker` 模块中，包括 `Send`、`Sync`、`Copy`、`Sized` 和 `Unpin`。其中大多数（除了
    `Copy`）也是 *自动 trait*；编译器会自动为这些类型实现它们，除非类型包含某些未实现标记 trait 的内容。
- en: 'Marker traits serve an important purpose in Rust: they allow you to write bounds
    that capture semantic requirements not directly expressed in the code. There is
    no call to `send` in code that requires that a type is `Send`. Instead, the code
    *assumes* that the given type is fine to use in a separate thread, and without
    marker traits the compiler would have no way of checking that assumption. It would
    be up to the programmer to remember the assumption and read the code very carefully,
    which we all know is not something we’d like to rely on. That path is riddled
    with data races, segfaults, and other runtime issues.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标记特性在 Rust 中发挥着重要作用：它们允许你编写捕获语义需求的约束，而这些需求并未直接在代码中表达。代码中没有调用 `send` 来要求某个类型是
    `Send`。相反，代码 *假设* 给定类型可以安全地在单独的线程中使用，如果没有标记特性，编译器将无法检查这一假设。程序员必须记住这个假设，并仔细阅读代码，而我们都知道，这并不是我们希望依赖的方式。那条道路充满了数据竞争、段错误和其他运行时问题。
- en: 'Similar to marker traits are *marker types*. These are unit types (like `struct
    MyMarker;`) that hold no data and have no methods. Marker types are useful for,
    well, marking a type as being in a particular state. They come in handy when you
    want to make it impossible for a user to misuse an API. For example, consider
    a type like `SshConnection`, which may or may not have been authenticated yet.
    You could add a generic type argument to `SshConnection` and then create two marker
    types: `Unauthenticated` and `Authenticated`. When the user first connects, they
    get `SshConnection<Unauthenticated>`. In its `impl` block, you provide only a
    single method: `connect`. The `connect` method returns a `SshConnection<Authenticated>`,
    and it’s only in that `impl` block that you provide the remaining methods for
    running commands and such. We will look at this pattern further in Chapter 3.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于标记特性的，还有 *标记类型*。这些是单位类型（例如 `struct MyMarker;`），它们不包含任何数据，也没有方法。标记类型的作用是将类型标记为某种特定的状态。当你想确保用户不能误用某个
    API 时，标记类型非常有用。例如，考虑一个类型 `SshConnection`，它可能已经认证过，也可能还没有认证。你可以向 `SshConnection`
    添加一个泛型类型参数，然后创建两个标记类型：`Unauthenticated` 和 `Authenticated`。当用户首次连接时，他们会得到 `SshConnection<Unauthenticated>`。在其
    `impl` 块中，你只提供一个方法：`connect`。`connect` 方法返回一个 `SshConnection<Authenticated>`，并且只有在那个
    `impl` 块中，你才提供运行命令等其他方法。我们将在第 3 章进一步讨论这个模式。
- en: Existential Types
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在类型
- en: In Rust you very rarely have to specify the types of variables you declare in
    the body of a function or the types of generic arguments to methods that you call.
    This is because of *type inference*, where the compiler decides what type to use
    based on what type the code the type appears in evaluates to. The compiler will
    usually infer types only for variables and for the arguments (and return types)
    of closures; top-level definitions like functions, types, traits, and trait implementation
    blocks all require that you explicitly name all types. There are a couple of reasons
    for this, but the primary one is that type inference is much easier when you have
    at least some known points to start the inference from. However, it’s not always
    easy, or even possible, to fully name a type! For example, if you return a closure
    from a function, or an async block from a trait method, its type does not have
    a name that you can type into your code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，你很少需要在函数体内声明变量的类型，或者指定你调用的方法的泛型参数的类型。这是因为 *类型推断*，编译器根据代码中出现的类型推断出使用什么类型。编译器通常只会推断变量的类型以及闭包的参数（和返回类型）；顶层定义，如函数、类型、特性和特性实现块，都要求你显式地指定所有类型。这有几个原因，主要原因是当你至少有一些已知的起始点时，类型推断会更容易。然而，完全命名一个类型并不总是容易，甚至可能是不可能的！例如，如果你从函数中返回一个闭包，或者从特性方法中返回一个异步块，它的类型没有一个你可以在代码中直接写出的名称。
- en: 'To handle situations like this, Rust supports *existential types*. Chances
    are, you have already seen existential types in action. All functions marked as
    `async fn` or with a return type of `impl Trait` have an existential return type:
    the signature does not give the true type of the return value, just a hint that
    the function returns *some* type that implements some set of traits that the caller
    can rely on. And crucially, the caller can only rely on the return type implementing
    those traits, and nothing else.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理类似的情况，Rust 支持 *存在类型*。你很可能已经见过存在类型的应用。所有标记为 `async fn` 或返回类型为 `impl Trait`
    的函数都有一个存在返回类型：该函数签名并没有给出返回值的真实类型，只是给出了一个提示，表明该函数返回 *某种* 类型，该类型实现了调用者可以依赖的某些特性。而且，重要的是，调用者只能依赖返回类型实现这些特性，而不能依赖其他任何东西。
- en: 'This behavior is what gives existential types their name: we are asserting
    that there exists some concrete type that matches the signature, and we leave
    it up to the compiler to find what that type is. The compiler will usually then
    go figure that out by applying type inference on the body of the function.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为赋予了存在类型它们的名字：我们在声明中断言某个具体的类型存在，并且将找到该类型的任务交给编译器。编译器通常会通过在函数体内应用类型推导来找出那个类型。
- en: 'Not all instances of `impl Trait` use existential types. If you use `impl Trait`
    in argument position for a function, it’s really just shorthand for an unnamed
    generic parameter to that function. For example, `fn foo(s: impl ToString)` is
    mostly just syntax sugar for `fn foo<S: ToString>(s: S)`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '并非所有的 `impl Trait` 实例都使用了存在类型。如果你在函数的参数位置使用 `impl Trait`，它实际上只是一个未命名的泛型参数的简写。例如，`fn
    foo(s: impl ToString)` 其实只是 `fn foo<S: ToString>(s: S)` 的语法糖。'
- en: Existential types come in handy particularly when you implement traits that
    have associated types. For example, imagine you’re implementing the `IntoIterator`
    trait. It has an associated type `IntoIter` that holds the type of the iterator
    that the type in question can be turned into. With existential types, you do not
    need to define a separate iterator type to use for `IntoIter`. Instead, you can
    give the associated type as `impl Iterator<Item = Self::Item>` and just write
    an expression inside the `fn into_iter(self)` that evaluates to an `Iterator`,
    such as by using maps and filters over some existing iterator type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 存在类型在实现包含关联类型的特征时特别有用。例如，假设你正在实现 `IntoIterator` 特征。它有一个关联类型 `IntoIter`，表示该类型可以转换成的迭代器类型。有了存在类型，你就不需要定义一个单独的迭代器类型来作为
    `IntoIter`。相反，你可以将关联类型定义为 `impl Iterator<Item = Self::Item>`，然后在 `fn into_iter(self)`
    内部写一个表达式，计算出一个 `Iterator`，例如使用一些现有迭代器类型的 `map` 和 `filter` 方法。
- en: 'Existential types also provide a feature beyond mere convenience: they allow
    you to perform zero-cost type erasure. Instead of exporting helper types just
    because they appear in a public signature somewhere—iterators and futures are
    common examples of this—you can use existential types to hide the underlying concrete
    type. Users of your interface are shown only the traits that the relevant type
    implements, while the concrete type is left as an implementation detail. Not only
    does this simplify the interface, but it also enables you to change that implementation
    as you wish without breaking downstream code in the future.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 存在类型不仅仅提供了便捷功能：它们还允许你进行零成本的类型擦除。你不需要因为某些类型出现在公共签名中而导出辅助类型——迭代器和 `future` 就是常见的例子——你可以使用存在类型来隐藏底层的具体类型。接口的用户只会看到相关类型实现的特征，而具体类型则作为实现细节被隐藏。这样不仅简化了接口，也让你可以随意更改实现，而不会破坏未来的下游代码。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has provided a thorough review of the Rust type system. We’ve looked
    both at how the compiler manifests types in memory and how it reasons about the
    types themselves. This is important background material for writing unsafe code,
    complex application interfaces, and asynchronous code in later chapters. You’ll
    also find that much of the type reasoning from this chapter plays into how you
    design Rust code interfaces, which we’ll cover in the next chapter.*
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了对 Rust 类型系统的全面回顾。我们既看了编译器是如何在内存中表示类型的，也看了编译器是如何推理类型的。这些是编写不安全代码、复杂应用接口和后续章节中异步代码的重要背景材料。你还会发现，本章中大部分类型推理的内容将影响你如何设计
    Rust 代码接口，我们将在下一章中进行讨论。
