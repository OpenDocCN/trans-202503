- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SYNTHESIS,
    PLACE AND ROUTE, AND CROSSING CLOCK DOMAINS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">综合、放置与布线，以及跨时钟域</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: In [Chapter 2](chapter2.xhtml), I provided an overview of the FPGA build process
    to get you comfortable running the tools needed to work on this book’s projects.
    We’ll now take a closer look at the build process, to give you a deeper understanding
    of what exactly is going on when you click the Build FPGA button. Once you have
    a firm knowledge of what your FPGA tools are doing, you’ll be able to avoid many
    common mistakes and write highly reliable code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](chapter2.xhtml)中，我提供了FPGA构建过程的概述，帮助你熟悉运行本书项目所需的工具。接下来，我们将更深入地了解构建过程，帮助你更清楚地理解当你点击“构建FPGA”按钮时究竟发生了什么。一旦你对FPGA工具的工作原理有了清晰的了解，你将能够避免许多常见的错误，并编写高可靠性的代码。
- en: 'As you learned back in [Chapter 2](chapter2.xhtml), after you’ve written your
    Verilog or VHDL code the FPGA design goes through three stages: synthesis, place
    and route, and programming. If any of these processes fails, the FPGA build won’t
    be successful. In this chapter, we’ll focus on the first two stages. We’ll talk
    in detail about synthesis, and break down the differences between synthesizable
    and non-synthesizable code. After that, we’ll revisit the place and route process
    and explore one common issue that arises during this stage: timing errors. You’ll
    learn what causes these errors and how to fix them. Finally, we’ll look in detail
    at a situation where you’re particularly likely to encounter timing issues: when
    signals cross between parts of your FPGA design running at different clock frequencies.
    You’ll learn how to safely cross clock domains in your FPGA.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第二章](chapter2.xhtml)中学到的，写完Verilog或VHDL代码后，FPGA设计会经历三个阶段：综合、放置与布线、以及编程。如果其中任何一个过程失败，FPGA构建将无法成功。在本章中，我们将重点讨论前两个阶段。我们将详细讨论综合，并区分可综合和不可综合的代码。之后，我们将回顾放置与布线过程，并探讨在这一阶段常见的一个问题：时序错误。你将学习这些错误的原因，并了解如何修复它们。最后，我们将详细探讨一个在FPGA设计中尤其容易遇到时序问题的情况：当信号跨越运行在不同时钟频率下的FPGA设计部分时。你将学习如何安全地跨越时钟域。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Synthesis</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">综合</samp>
- en: '*Synthesis* is the process of breaking down your Verilog or VHDL code and converting
    it to simple components (LUTs, flip-flops, block RAMs, and so on) that exist on
    your specific FPGA. In this sense, an FPGA synthesis tool is similar to a compiler,
    which takes code in a language like C and breaks it down into very simple instructions
    that your CPU can understand.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*综合*是将你的Verilog或VHDL代码分解并转换为在特定FPGA上存在的简单组件（如查找表、触发器、块RAM等）的过程。从这个意义上讲，FPGA综合工具类似于编译器，它将类似C语言的代码分解为CPU能够理解的非常简单的指令。'
- en: For the process to work correctly, the synthesis tool needs to know exactly
    what type of FPGA you’re using so it knows what resources are available. Then,
    since these resources are finite, it becomes the synthesis tool’s job to figure
    out how to use them as efficiently as possible. This is called *logic optimization*
    (or *logic minimization*), and it’s a major part of the synthesis process. As
    I mentioned in [Chapter 3](chapter3.xhtml), there’s no reason for you to ever
    perform logic optimization manually; you can simply leave it to the synthesis
    tool. That’s not to say, however, that writing code that uses your available resources
    intelligently isn’t important. Having a good understanding of what your code will
    synthesize into is critical to becoming a strong FPGA designer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保过程正常工作，综合工具需要确切知道你正在使用的FPGA类型，以便它知道有哪些资源可用。然后，由于这些资源是有限的，综合工具的任务就是找出如何尽可能高效地使用它们。这被称为*逻辑优化*（或*逻辑最小化*），它是综合过程中的一个重要部分。正如我在[第三章](chapter3.xhtml)中提到的，你无需手动执行逻辑优化；你可以简单地将其交给综合工具。但这并不意味着，编写能够智能利用可用资源的代码不重要。了解你的代码将如何综合成硬件是成为一个优秀FPGA设计师的关键。
- en: A key output of the synthesis process is your *utilization report*, which tells
    you how many LUTs, flip-flops, block RAMs, and other resources you’re using in
    your design. We’ve examined excerpts from utilization reports in past chapters;
    I recommend always reading through this report to make sure that your expectations
    match reality with regard to the resources being used.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 合成过程的一个重要输出是你的*资源使用报告*，它告诉你在设计中使用了多少LUT、触发器、块RAM和其他资源。我们在过去的章节中曾经分析过部分资源使用报告；我建议你总是通读这个报告，以确保你的预期与实际使用的资源相符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Notes, Warnings,
    and Errors</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">注释、警告和错误</samp>
- en: The synthesis process often generates a very large number of notes and warnings,
    even when it runs successfully. When unsuccessful, the process generates errors
    as well. The notes are mostly informational, telling you how the tool is interpreting
    your code. Warnings are worth looking at to make sure that you’re not making mistakes.
    However, in large designs there might be hundreds of warnings, so they can become
    overwhelming. Some tools allow you to hide warnings once you’re comfortable with
    them. This is a useful feature that allows you to focus on the real problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 合成过程通常会生成大量的注释和警告，即使在运行成功时也是如此。若运行失败，过程还会生成错误。注释大多是信息性的，告诉你工具是如何解读你的代码的。警告则值得关注，以确保你没有犯错误。然而，在大型设计中，可能会有数百个警告，这会让人感到不堪重负。一些工具允许在你对警告感到满意时将其隐藏。这是一个有用的功能，可以帮助你专注于真正的问题。
- en: 'One particular warning worth noting is the *inferred latch* warning. As you
    learned back in [Chapter 4](chapter4.xhtml), latches are bad. They’re often created
    accidentally, and the tools can have trouble analyzing them in the context of
    timing in your FPGA design. If you create a latch, you’ll be notified of it during
    the synthesis process. You’ll get a warning like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特别值得注意的警告是*推断锁存器*警告。正如你在[第4章](chapter4.xhtml)中学到的，锁存器是有问题的。它们通常是偶然创建的，而工具在FPGA设计的时序上下文中可能会很难分析它们。如果你创建了一个锁存器，在合成过程中会收到通知。你会收到如下警告：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don’t ignore this warning. Unless you’re sure that you really want that latch
    in your design, you should try to remove it. I’ve been doing FPGA design for many
    years and I’ve never needed to use a latch, so you should have a very good reason
    if you’re planning to keep it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忽视这个警告。除非你确信真的需要在设计中使用这个锁存器，否则你应该尽量去除它。我做FPGA设计已经很多年了，我从来没有需要使用锁存器，因此如果你打算保留它，必须有非常充分的理由。
- en: If something goes wrong during synthesis, you’ll get an error rather than a
    warning. The two most common errors you’ll encounter are syntax errors and utilization
    errors; we’ll look at those next.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在合成过程中出现问题，你将得到一个错误而不是警告。你会遇到的两个最常见的错误是语法错误和资源使用错误；我们接下来会详细讨论这两种错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Syntax Errors</samp>
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">语法错误</samp>
- en: 'When you start the synthesis process, the first thing the tool will do is check
    your Verilog or VHDL code for syntax errors. These are by far the most common
    errors you’ll encounter. There are literally hundreds of kinds of syntax errors
    that might be lurking in your code; perhaps you forgot to define a signal, mistyped
    a keyword, or left out a semicolon, for example. In the last case, you might see
    an error message like this one in Verilog:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始合成过程时，工具首先会检查你的Verilog或VHDL代码是否有语法错误。这些是你最常遇到的错误。代码中可能潜藏着数百种语法错误；例如，你可能忘记定义一个信号、错误拼写了一个关键字，或者遗漏了分号。在最后这种情况下，你可能会在Verilog中看到如下错误信息：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'or this one in VHDL:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在VHDL中出现这样的警告：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The synthesis tool will tell you on which line of which file it encountered
    the error. In the preceding error messages, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">design.v(5)</samp>
    in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">design.vhd(5)</samp>
    in VHDL is telling you to check line 5 of the file called *design*. You can use
    this information to edit your code to pass the syntax check.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 合成工具会告诉你在哪个文件的哪一行遇到了错误。例如，在前面的错误信息中，Verilog中的<samp class="SANS_TheSansMonoCd_W5Regular_11">design.v(5)</samp>或VHDL中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">design.vhd(5)</samp>告诉你检查名为*design*的文件的第5行。你可以利用这些信息来编辑代码，以通过语法检查。
- en: 'Occasionally, you’ll get an overwhelming number of syntax errors. The best
    thing you can do in this case is find the first error and fix that one. Often,
    a cascade of errors can stem from the first one. This is a good rule for engineering
    in general: fix the first problem first. Once you’ve resolved that first syntax
    error, rerun the synthesis process. If you’re still getting errors, again find
    the first one, fix it, and rerun synthesis. This process is iterative, and it
    often takes a few cycles for all the syntax errors to be resolved and the synthesis
    process to complete successfully.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到大量的语法错误。此时最好的做法是先找到第一个错误并修复它。通常，错误的级联是由第一个错误引起的。这是工程中的一个好规则：先解决第一个问题。一旦解决了第一个语法错误，就重新运行综合过程。如果仍然有错误，再找到第一个错误，修复它，然后重新运行综合。这一过程是迭代的，通常需要几个循环才能解决所有语法错误并成功完成综合。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Utilization Errors</samp>
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">资源利用错误</samp>
- en: Once your code passes the syntax check, the next most common error you’ll encounter
    during synthesis is a *utilization error*, where your design requires more components
    than the FPGA has available. For example, if your FPGA has 1,000 flip-flops but
    your code is requesting 2,000, you’ll get a utilization error. The design simply
    won’t fit on your FPGA, so you’ll need to think of ways to shrink your code to
    instantiate fewer flip-flops. A good rule of thumb is to aim to utilize no more
    than 80 percent of the available LUTs or flip-flops. This will make it easier
    for the place and route process to get your design to meet timing (more on this
    later in the chapter), as well as giving you more flexibility to modify your design
    or add new features in the future.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的代码通过语法检查，接下来你最常遇到的错误就是*资源利用错误*，这意味着你的设计需要的组件数量超出了 FPGA 可用的资源。例如，如果你的 FPGA
    有 1,000 个触发器，而你的代码要求 2,000 个，那么你就会遇到资源利用错误。设计根本无法适配到你的 FPGA 上，所以你需要想办法精简代码，以便实例化更少的触发器。一个好的经验法则是，尽量确保所用的
    LUT 或触发器不超过可用资源的 80%。这样可以让布局和布线过程更容易完成，以确保你的设计满足时序要求（更多内容将在本章后面讨论），同时也能为未来修改设计或增加新功能提供更多灵活性。
- en: 'If you can’t get your code to fit in your chosen FPGA, you have a few options:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码无法适配到选定的 FPGA 上，你有几种选择：
- en: 1.  Switch to a larger FPGA.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  切换到更大的 FPGA。
- en: 2.  Identify the most resource-intensive modules and rewrite them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  识别最占资源的模块并重新编写它们。
- en: 3.  Remove functionality.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  移除功能。
- en: Switching to a larger FPGA might be a big deal, but it isn’t always. Many FPGA
    vendors offer higher-resource FPGAs in the same physical package as lower-resource
    parts. The higher-resource ones often cost a bit more, so you’ll pay a few extra
    dollars for those additional resources, but the new FPGA won’t take up any extra
    space on your circuit board. When you’re selecting an FPGA for a project, it’s
    a good idea to pick an FPGA family and package where you have the option to move
    up in resources, just in case you end up needing more resources than you expect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到更大的 FPGA 可能是个大问题，但并不总是如此。许多 FPGA 厂商提供相同物理封装的高资源 FPGA 与低资源版本。高资源版本通常价格稍贵，因此你需要为额外的资源支付一些额外费用，但新的
    FPGA 不会占用电路板上的额外空间。在为项目选择 FPGA 时，最好选择一个可以升级资源的 FPGA 家族和封装，以防你需要的资源超过预期。
- en: If you can’t switch to a different FPGA, the next step is to analyze your code
    to see if it uses more resources than necessary. This isn’t a matter of low-level
    logic minimization to shave off a LUT here and a flip-flop there—the tools do
    that for you. Rather, there are ways in which you might inadvertently write code
    that uses dramatically more resources than you expect. As an example, I once traced
    a high utilization error to one single line of code that was dividing two numbers.
    As you’ll learn in [Chapter 10](chapter10.xhtml), division is often a very resource-intensive
    operation in an FPGA. I was able to change the division operation into a memory
    operation by creating a table of possible inputs and mapping each input to an
    output. This used a block RAM, but it freed up the LUTs and flip-flops used for
    the division and allowed the FPGA to pass the synthesis process. Rewriting code
    with a focus on lower resource utilization is a skill you’ll sharpen as you gain
    more FPGA experience. You can dig into the utilization reports of each module
    to figure out which are using the most resources, and then examine those individually.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能切换到不同的 FPGA，那么下一步是分析你的代码，看看它是否使用了比必要更多的资源。这并不是为了优化低级逻辑，去削减一些 LUT 或触发器——这些工具会为你做这些工作。实际上，有些方法可能会让你无意中写出使用比预期更多资源的代码。例如，我曾追踪一个高资源利用率的错误，最终发现是因为一行代码在做两个数字的除法操作。正如你将在[第
    10 章](chapter10.xhtml)中学到的，除法通常是 FPGA 中一个非常资源密集的操作。我通过创建一个输入输出映射表，将除法操作转化为内存操作。这使用了块
    RAM，但释放了用于除法的 LUT 和触发器，帮助 FPGA 顺利通过综合过程。以减少资源利用为重点的代码重写是你随着 FPGA 经验的积累而不断提高的技能。你可以深入查看每个模块的利用率报告，找出哪些模块使用了最多资源，然后单独检查它们。
- en: Another approach for reducing resource utilization is to have different inputs
    share the same FPGA resource. FPGAs often perform the same operation on multiple
    input channels. Instead of having dedicated FPGA resources for each channel, you
    can use a single implementation, with each channel taking a turn sharing the hardware.
    For example, say you have 100 channels that all need a cosine operation performed
    on them once a second. You could have channel 1 perform the cosine operation in
    the first 10 ms, then allow channel 2 to perform that same cosine operation in
    the next 10 ms, then channel 3, and so on. This way, the hardware used to perform
    the cosine operation can be shared between all the channels and only needs to
    be instantiated once, rather than being instantiated 100 times, once for each
    channel.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 降低资源利用率的另一种方法是让不同的输入共享同一个 FPGA 资源。FPGA 经常在多个输入通道上执行相同的操作。与其为每个通道分配专用的 FPGA 资源，不如使用一个单一的实现，让每个通道轮流共享硬件。例如，假设你有
    100 个通道，每个通道每秒都需要执行一次余弦运算。你可以让第 1 个通道在前 10 毫秒执行余弦运算，然后让第 2 个通道在接下来的 10 毫秒执行相同的余弦运算，依此类推。通过这种方式，用于执行余弦运算的硬件可以在所有通道之间共享，并且只需要实例化一次，而不是为每个通道实例化
    100 次。
- en: This keeps the overall resource utilization much lower, but it only works if
    you have the time available to share a resource. If your timelines are too tight
    this approach might not work. Additionally, it does add some complexity, because
    now you need to build a component that will negotiate the sharing. We refer to
    the process of sharing a resource as *arbitration*, and the component that performs
    sharing this is often referred to as an *arbiter*. Arbiters can be built to share
    off-FPGA resources as well. For example, we might have several modules that write
    data to a MicroSD card. An arbiter could be designed to allow those modules to
    share the single MicroSD card and prevent two modules from trying to write data
    at the same time, which would cause data loss or corruption.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以大大降低整体资源利用率，但只有在你有足够时间共享资源的情况下才有效。如果你的时间安排非常紧张，这种方法可能行不通。此外，这确实增加了一些复杂性，因为现在你需要构建一个组件来协商资源共享。我们将共享资源的过程称为*仲裁*，而执行共享的组件通常被称为*仲裁者*。仲裁者也可以被构建来共享
    FPGA 之外的资源。例如，我们可能有多个模块需要将数据写入 MicroSD 卡。可以设计一个仲裁者，让这些模块共享同一张 MicroSD 卡，并防止两个模块在同一时间尝试写入数据，从而导致数据丢失或损坏。
- en: If you’ve written very efficient code and you still can’t make it fit on your
    FPGA, the only option left is to remove functionality. Maybe there’s a microcontroller
    on the same board that can do some of the things that the FPGA was supposed to
    do. Or maybe you just need to tell your team that it won’t work. FPGAs simply
    have a limit to the amount of stuff they can fit.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经编写了非常高效的代码，但仍然无法将其放入 FPGA，唯一的选择就是去除某些功能。也许在同一块板子上有一个微控制器，可以执行 FPGA 本来应该完成的某些任务。或者，可能你只需要告诉你的团队，代码无法实现。FPGAs
    确实有其能容纳的限制。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Non-synthesizable
    Code</samp>
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">不可综合代码</samp>
- en: Many keywords in the Verilog and VHDL languages can’t be translated into FPGA
    components by a synthesis tool; they aren’t synthesizable. If you include any
    of these keywords in your project code, the synthesis tool will simply ignore
    them. It might generate a warning or a note, but not an error. The tool will move
    forward with the synthesis process, omitting the non-synthesizable parts from
    the final design—and potentially leading to problems if you were counting on the
    functionality of the non-synthesizable code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Verilog 和 VHDL 语言中，许多关键字无法通过综合工具转化为 FPGA 组件；它们是不可综合的。如果在项目代码中包含这些关键字，综合工具将简单地忽略它们。它可能会生成警告或提示，但不会产生错误。工具会继续进行综合过程，忽略最终设计中的不可综合部分——如果你依赖这些不可综合代码的功能，可能会导致问题。
- en: It might seem strange that non-synthesizable keywords exist in Verilog and VHDL,
    but they’re useful for simulation and testbenches. As we discussed in [Chapter
    5](chapter5.xhtml), testing your code is critical, and the languages provide keywords
    to assist you with this. In fact, you can include non-synthesizable elements in
    your project code for simulation purposes and leave them in when you run the code
    through synthesis, since the tool will just ignore them. To be safe, you can explicitly
    tell the tool not to bother trying to synthesize these parts of your code by preceding
    them with <samp class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_off</samp>
    and succeeding them with <samp class="SANS_TheSansMonoCd_W5Regular_11">synthesis
    translate_on</samp>. This technique works for both Verilog and VHDL. For example,
    if you’re designing a FIFO, you might want to assert that you’re never writing
    to a full FIFO or reading from an empty FIFO when running simulations of the code.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_off</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_on</samp>
    directives let you bake those assertions into the actual design code, without
    having to worry about maintaining separate code for simulation and synthesis.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Verilog 和 VHDL 中出现不可综合的关键字可能看起来很奇怪，但它们对于仿真和测试平台是有用的。正如我们在[第五章](chapter5.xhtml)中讨论的，测试代码至关重要，而这些语言提供了帮助测试的关键字。实际上，你可以在项目代码中包含不可综合的元素用于仿真目的，并在运行代码通过综合时保留它们，因为工具会忽略这些部分。为了安全起见，你可以明确告诉工具不要尝试综合这些代码部分，通过在其前面加上
    <samp class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_off</samp>，在其后面加上
    <samp class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_on</samp>。这种技巧适用于
    Verilog 和 VHDL。例如，如果你在设计一个 FIFO，你可能希望在仿真代码时断言不向满的 FIFO 写入数据，或者不从空的 FIFO 读取数据。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_off</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_on</samp> 指令让你将这些断言直接嵌入到实际的设计代码中，而不必担心维护仿真和综合的独立代码。
- en: Some of the most common areas where non-synthesizable code arises include keeping
    track of time, printing text, working with files, and looping. We’ll consider
    those now.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 非可综合代码常见的几个领域包括跟踪时间、打印文本、处理文件和循环。我们现在来考虑这些问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Keeping Track of Time</samp>
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">跟踪时间</samp>
- en: 'As you know, there’s no inherent way to measure the passage of time in an FPGA.
    Instead, we rely on counting clock cycles. Still, there are parts of both VHDL
    and Verilog that refer to time: for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp>
    in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp> in VHDL
    will provide a current timestamp, while a statement like <samp class="SANS_TheSansMonoCd_W5Regular_11">#100</samp>
    in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">wait</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for 100 ns;</samp> in VHDL will create
    a short delay. These features can be useful for running simulations—for example,
    to trigger input signals at precise time intervals—but they aren’t synthesizable.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的，FPGA 本身没有内建的时间测量方式。相反，我们依赖于计数时钟周期。然而，VHDL 和 Verilog 中有些部分是与时间相关的：例如，Verilog
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp> 或 VHDL 中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">now</samp> 会提供当前的时间戳，而像 Verilog 中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#100</samp> 或 VHDL 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">wait</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for 100 ns;</samp> 这样的语句会创建一个短暂的延迟。这些特性对于运行仿真非常有用——例如，用来在精确的时间间隔触发输入信号——但它们不能被合成。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Printing</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">打印</samp>
- en: 'One common way to get feedback during the testing process is to send text to
    the terminal. In C and Python, for example, you have functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">printf()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> that will send
    text to a console to allow you to see what’s going on. Similar functions exist
    in Verilog and VHDL. In Verilog, you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">$display()</samp>
    to send text to the terminal. In VHDL, it’s a bit more complicated, and there
    are a few options. For example, you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">report</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">severity note</samp> to send text to the
    screen, as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试过程中，获取反馈的常见方式之一是将文本发送到终端。例如，在 C 和 Python 中，你有像 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 这样的函数，它们会将文本发送到控制台，让你看到发生了什么。Verilog
    和 VHDL 中也有类似的函数。在 Verilog 中，你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">$display()</samp>
    将文本发送到终端。在 VHDL 中，这有点复杂，提供了几种选择。例如，你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>
    后跟 <samp class="SANS_TheSansMonoCd_W5Regular_11">report</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">severity
    note</samp> 将文本发送到屏幕，示例如下：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These text outputs only work in simulation. They can’t be synthesized, as the
    concept of a console or terminal doesn’t exist on a physical FPGA.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文本输出只在仿真中有效。它们无法被合成，因为物理 FPGA 上没有控制台或终端的概念。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Working with Files</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">与文件的工作</samp>
- en: In most cases, you can’t synthesize Verilog or VHDL code that involves reading
    from or writing to a file. The FPGA has no concept of “files” or any operating
    system; you have to build all that stuff yourself if you really need it. Consider
    something like storing data from a temperature sensor. You might want to read
    data from the sensor every second and write those values to a file. This is possible
    to do in simulation with functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">$fopen()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">$fwrite()</samp> in Verilog
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">file_open()</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">write()</samp> in VHDL, but in synthesis,
    forget about it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不能合成涉及读取或写入文件的 Verilog 或 VHDL 代码。FPGA 没有“文件”或任何操作系统的概念；如果你真的需要这些功能，你必须自己构建。考虑一下从温度传感器存储数据的情况。你可能希望每秒从传感器读取数据，并将这些值写入文件。这在仿真中是可以做到的，通过
    Verilog 中的函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">$fopen()</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">$fwrite()</samp>，或者 VHDL 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">file_open()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">write()</samp>，但是在综合时，忘了它吧。
- en: One exception here is that some FPGAs allow you to use a text file to preload
    (initialize) a block RAM. The specifics of how different vendors accomplish this
    vary, so refer to the memory usage guide for your FPGA if this is something you
    ever need to do.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例外是，一些 FPGA 允许你使用文本文件来预加载（初始化）块 RAM。不同厂商实现的具体方式有所不同，如果你需要做这件事，参阅你 FPGA 的内存使用指南。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Looping</samp>
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">循环</samp>
- en: 'Loop statements *can* be synthesized, but they probably won’t work the way
    you expect. You might be familiar with <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops from a software language like C or Python: they allow you to write concise
    code that repeats an operation a specific number of times one after another. In
    simulation, Verilog or VHDL <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops work this way. In synthesizable FPGA code, however, <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops work differently; they’re used to condense replicated logic, providing a
    shorthand for writing several similar statements that are meant to be executed
    *at the same time, rather than one after another*. To demonstrate, consider this
    example code for a 4-bit shift register:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 循环语句*是*可以合成的，但它们可能不会按你预期的方式工作。你可能熟悉像 C 或 Python 这样的软件语言中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环：它们允许你编写简洁的代码，重复执行某个操作特定次数，依次进行。在仿真中，Verilog 或 VHDL 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环就是这样工作的。然而，在可合成的 FPGA 代码中，<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环的工作方式不同；它们用于压缩重复的逻辑，提供了一种简便的方式来编写几条相似的语句，这些语句是为了*同时执行，而不是依次执行*。为了演示，考虑这个 4 位移位寄存器的示例代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Each clock cycle, this code shifts data through the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift</samp>
    register. The value from bit 0 is shifted to bit 1, the value from bit 1 is shifted
    to bit 2, and so on. The assignment statements that accomplish this follow a completely
    predictable pattern: the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[i]</samp>
    is assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[i</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1]</samp>.
    Synthesizable Verilog and VHDL <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops provide a more compact way of writing predictable code like this. Using
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, we can rewrite
    the shift register code as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个时钟周期，这段代码将数据通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift</samp>
    寄存器进行移位。位 0 的值被移到位 1，位 1 的值被移到位 2，依此类推。完成这一操作的赋值语句遵循完全可预测的模式：<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[i]</samp>
    的值被赋给 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[i</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">1]</samp>。可合成的 Verilog 和 VHDL <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环提供了一种更简洁的方式来编写像这样的可预测代码。使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环，我们可以将移位寄存器代码重写如下：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we declare a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop with incrementing variable <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    ❶. With each iteration, the statement assigning the value from bit <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    to bit <samp class="SANS_TheSansMonoCd_W5Regular_11">i + 1</samp> ❷ is executed.
    For example, on the first iteration of the loop <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, so the line that gets
    executed is <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[0</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+ 1]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[0]</samp>. The second time
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    so we get <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[1</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+ 1]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[1]</samp>. On the third
    and final iteration, we get <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 1]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[2]</samp>.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个增量变量为 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> ❶。每次迭代时，执行将位 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    的值赋给位 <samp class="SANS_TheSansMonoCd_W5Regular_11">i + 1</samp> ❷ 的语句。例如，在循环的第一次迭代中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，所以执行的语句是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[0</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+
    1]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[0]</samp>。第二次循环时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，所以我们得到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+
    1]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[1]</samp>。在第三次也是最后一次迭代时，我们得到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+
    1]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[2]</samp>。
- en: The important thing to realize here is that *this all happens in one clock cycle*.
    In effect, all iterations of the loop execute simultaneously, just as the three
    separate assignment statements in the version without the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop will execute simultaneously. The two versions do exactly the same thing (and
    will synthesize to the exact same FPGA resources), except the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop version is written in a more compact way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要意识到的重要一点是，*这一切都发生在一个时钟周期内*。实际上，所有的循环迭代是同时执行的，就像没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环的版本中那三条独立的赋值语句会同时执行一样。两种版本做的事情完全一样（并且会合成到完全相同的 FPGA 资源上），只是 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环版本写得更简洁。
- en: 'A common mistake that beginners make is putting a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop inside a clocked <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block and expecting
    each iteration of the loop to take one clock cycle. Take the following snippet
    of C code, for example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者常犯的一个错误是将 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环放在时钟驱动的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块中，并期望每次循环迭代都需要一个时钟周期。例如，考虑以下这段 C 代码：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here we have an array, <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>,
    and we’re incrementing every value inside the array by 1 using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop. (We’re assuming here that <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    has 10 items.) If you try to do the same thing using a Verilog or VHDL <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, expecting that it will take 10 clock cycles to run, you’ll be very confused,
    since the loop will actually be executed in a single clock cycle. If you *do*
    want to run a sequence like this over a number of clock cycles, you can update
    the values inside an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    that checks for an index value to exceed a certain threshold, like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个数组，<samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>，我们通过一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环将数组中的每个值增加1。（我们假设<samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>有10个元素。）如果您尝试使用Verilog或VHDL中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环，期待它运行10个时钟周期，您会非常困惑，因为该循环实际上会在单个时钟周期内执行。如果您*确实*希望将这样的操作运行多个时钟周期，可以在一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句中更新值，该语句检查索引值是否超过某个阈值，像这样：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we use an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    to replicate the check that stops the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop ❶. In this case, we want the operation to run 10 times, or until <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>
    is no longer less than 10\. (We’re assuming that the index value starts at 0,
    although this isn’t shown in the code.) Next, we increment a value in <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Data</samp>,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> to access the
    correct item in the array ❷. Finally, we increment <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>
    ❸, which will then be used on the next clock cycle to update the next value in
    the array. In total, this will take 10 clock cycles to execute. In general, when
    trying to write code that iterates like a conventional <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, usually all you need to do is add a counter signal (like <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>)
    and monitor it with an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, as you’ve seen here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句来复制停止<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环的检查 ❶。在这种情况下，我们希望操作运行10次，或者直到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>不再小于10。（我们假设索引值从0开始，尽管在代码中没有显示。）接下来，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>访问数组中的正确项，增加<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Data</samp>的值
    ❷。最后，我们增加<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> ❸，该值将在下一个时钟周期中用于更新数组中的下一个值。总的来说，这将需要10个时钟周期来执行。一般来说，当试图编写像常规<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环那样迭代的代码时，通常只需添加一个计数信号（如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>）并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句来监控它，正如您在这里看到的那样。
- en: Until you’re very confident in how FPGA <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops work, I recommend avoiding them in any synthesizable code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在您非常确信FPGA <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环的工作原理之前，我建议在任何可综合代码中避免使用它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Place and Route</samp>
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">放置与布线</samp>
- en: '*Place and route* is the process of taking your synthesized design and mapping
    it to physical locations on your specific FPGA. The place and route tool decides
    exactly which LUTs, flip-flops, and block RAMs (and other components we haven’t
    talked about yet) in your FPGA will be used, and wires them all together. At the
    end of the process, you get a file that can be loaded onto the FPGA. As you’ve
    seen, actually programming the FPGA using this file is usually a separate step.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*放置与布线*是将合成设计映射到特定FPGA上的物理位置的过程。放置与布线工具决定了FPGA中将使用哪些查找表（LUT）、触发器、块RAM（以及我们尚未讨论的其他组件），并将它们全部连接起来。过程结束时，您将获得一个可以加载到FPGA上的文件。如您所见，实际上使用此文件对FPGA进行编程通常是一个单独的步骤。'
- en: 'Place and route, as the name implies, is in fact two processes: the placement
    of the synthesized design into your FPGA, and then the routing of that design
    using physical wires to connect everything together. The routing process is often
    the most time-consuming step in the build process, especially for large designs.
    On a single computer, it can take several hours to route a complicated FPGA. This
    is one of the main reasons why simulations are critical. You may only get a few
    chances a day to test your design on an actual FPGA because the build process
    takes so long, so it’s best to iron out as many problems as you can through simulation
    *before* starting this process.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 布局与布线，顾名思义，实际上是两个过程：将合成后的设计放入 FPGA 中，然后使用物理布线将设计连接起来。布线过程通常是构建过程中最耗时的步骤，特别是对于大型设计。在单台计算机上，布线一个复杂的
    FPGA 可能需要几个小时。这也是模拟非常重要的一个主要原因。由于构建过程非常耗时，每天你可能只有几次机会在实际 FPGA 上测试你的设计，因此在开始这个过程之前，通过模拟尽可能解决问题是最好的。*
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constraints</samp>
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">约束</samp>
- en: 'To run the place and route process, you need to constrain at least two aspects
    of your design: the pins and the clock(s). There are other elements that can be
    constrained as well—input/output delays, specific routing, and more—but these
    two are the most fundamental.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行布局与布线过程，你需要约束设计中的至少两个方面：引脚和时钟（如果你有多个时钟域，稍后我们会讨论）。当然，也可以约束其他元素——输入/输出延迟、特定的布线路径等等，但这两个是最基本的。
- en: The pin constraints tell the place and route tool which signals in the Verilog
    or VHDL code are mapped to which physical pins on the FPGA. When you’re working
    with your circuit board, you’ll need to look at the PCB schematic to know which
    FPGA pins connect to switches, which pins connect to LEDs, and so on. This is
    an example of a situation in which having some knowledge of how to read schematics
    is helpful for an FPGA designer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚约束告诉布局与布线工具，Verilog 或 VHDL 代码中的哪些信号映射到 FPGA 上的哪些物理引脚。当你在处理电路板时，你需要查看 PCB 原理图，以了解哪些
    FPGA 引脚连接到开关，哪些引脚连接到 LED，等等。这是一个在 FPGA 设计师中，具备一定原理图阅读知识非常有帮助的例子。
- en: The clock constraints tell the tool about the clock frequency used to drive
    your FPGA (or frequencies, if you have multiple clock domains, as we’ll discuss
    later in the chapter). Clock constraints are fundamental to the routing process,
    in particular, since there are physical limitations on how far a signal can travel
    and how much can be done to it within a single clock period. When the place and
    route process finishes, it will generate a timing report that takes the clock
    constraints into account. If everything is sure to work under the specified clock
    constraints, the design is said to meet timing, and the report will show this.
    If, however, the tool determines that the clock constraints may be too tight for
    what you’ve designed, the tool will display timing errors in your timing report.
    As you’ll see next, timing errors are really bad!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟约束告诉工具用于驱动 FPGA 的时钟频率（或者如果你有多个时钟域，时钟频率可能不同，正如我们将在本章稍后讨论的那样）。时钟约束对布线过程至关重要，尤其是因为信号的传输距离和在单个时钟周期内可以处理的内容有物理限制。当布局与布线过程完成时，它将生成一个时序报告，并考虑到时钟约束。如果在指定的时钟约束下，所有内容都能正常工作，那么设计就被认为是符合时序的，报告会显示这一点。但是，如果工具判断时钟约束可能对你的设计来说过于严格，它将在时序报告中显示时序错误。正如你接下来会看到的，时序错误是非常严重的问题！
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Timing Errors</samp>
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">时序错误</samp>
- en: Timing errors occur when your design and clock constraints are asking for the
    FPGA components and wires to work at a faster pace than the place and route tool
    can guarantee they can handle. This means your FPGA might not work as desired.
    I say *might* because it’s possible that it will work perfectly, despite the timing
    errors—there’s no way to know for sure ahead of time. This is in part because
    an FPGA’s performance is affected by its operating conditions; it can vary, for
    example, based on changes in voltage and temperature. It might sound odd that
    your FPGA will perform slightly differently at cold temperatures versus hot temperatures,
    but that’s the reality.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 时序错误发生在你的设计和时钟约束要求 FPGA 组件和连线以比规划和布局工具保证它们能够处理的更快的速度工作时。这意味着你的 FPGA 可能无法按照预期工作。我说*可能*是因为尽管存在时序错误，它也有可能完美运行——事先没有办法确定这一点。这部分是因为
    FPGA 的性能受到其工作条件的影响；例如，它的表现可能会因电压和温度的变化而有所不同。听起来可能很奇怪，FPGA 在低温和高温下的表现稍有不同，但这就是现实。
- en: It’s the job of the place and route tool to stress your design and analyze how
    it will perform in all possible operating conditions, including worst-case scenarios.
    If the design can run at your specified clock frequency across all those conditions,
    the tool can guarantee that the FPGA will meet timing; otherwise, it will report
    timing errors. The tools won’t stop you from programming your FPGA with a design
    that contains timing errors. Maybe they should, but they don’t. Again, this is
    because it’s uncertain whether or how the timing errors will manifest. The tools
    don’t know if you’ll be running your design on your desk at room temperature,
    or on a satellite in the vacuum of space. In either case, the design might work,
    or it might fail, or it might appear to work perfectly for five minutes before
    manifesting a small error. Timing errors can produce strange behavior.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 规划和布局工具的任务是对你的设计进行压力测试，并分析它在所有可能的操作条件下如何表现，包括最坏情况。如果设计能够在所有这些条件下以你指定的时钟频率运行，工具可以保证
    FPGA 满足时序要求；否则，它将报告时序错误。这些工具不会阻止你用包含时序错误的设计编程 FPGA。也许它们应该阻止，但实际上没有。原因在于无法确定时序错误如何表现出来。工具并不知道你是把设计运行在室温下的桌面上，还是运行在真空空间中的卫星上。在任何一种情况下，设计可能正常工作，也可能失败，或者在运行了五分钟后，才表现出一个小错误。时序错误会导致奇怪的行为。
- en: I once was brought onto an FPGA design for a camera product that was riddled
    with timing errors that the previous designer hadn’t bothered to fix. Instead,
    they had built the design, looked at the report and seen that it contained dozens
    of timing errors, and programmed the FPGA anyway. They then tested it at their
    desk to see if it worked. They ran it for a few minutes and didn’t run into any
    problems, so they decided it was fine and integrated it into the product. Then
    the product started to fail in odd ways. Pixels would blink, or the scene would
    flicker, but only occasionally, so the user might ignore it. Even stranger, only
    some products would have issues, and the severity of the problem varied from unit
    to unit.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经参与过一个相机产品的 FPGA 设计，这个设计充满了时序错误，而之前的设计师并没有处理这些问题。相反，他们设计了这个方案，查看了报告，发现报告中有数十个时序错误，但仍然将
    FPGA 编程完成。然后，他们在自己的桌面上测试了这个设计，查看它是否能正常工作。他们运行了几分钟，没有遇到问题，于是认为它没问题，并将其集成到产品中。随后，产品开始以奇怪的方式出现故障。像素会闪烁，或者场景会闪烁，但只是偶尔发生，所以用户可能会忽视。更奇怪的是，只有部分产品出现问题，且问题的严重程度在不同单元之间有所不同。
- en: Once someone realized how bad the issue was, a serious effort was made to fix
    the timing errors and produce an FPGA design that would work 100 percent of the
    time. The FPGA tools had been trying to tell the original designer that there
    might be a problem. Not a *functional* problem—the code was theoretically OK as
    written—but there was a chance that it wouldn’t work correctly with the given
    clock constraints under all operating conditions. The moral of this story is that
    when an FPGA acts in weird ways, it’s very possible that you haven’t looked closely
    at your timing report (or, as was the case with my prior coworker, ignored it
    completely!).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有人意识到问题的严重性，就开始了一个认真的努力，修复时序错误，并制作一个能够 100% 正常运行的 FPGA 设计。FPGA 工具一直在尝试告诉原设计师，可能存在问题。这并不是一个*功能性*问题——代码在理论上是正确的——但是在给定的时钟约束下，它有可能在所有操作条件下无法正确运行。这个故事的寓意是，当
    FPGA 行为奇怪时，很有可能是你没有仔细查看时序报告（或者，像我以前的同事一样，完全忽视了它！）。
- en: At their root, timing errors arise because FPGAs are subject to physical limitations.
    Up to this point, we’ve been working in an ideal world. We’ve imaged that all
    signals can travel instantly from their source to their destination, and that
    all flip-flops can change their output instantly when they see a rising clock
    edge. We’ve been assuming that if the code is correct, then everything will just
    work.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，时序错误的产生是因为FPGA受限于物理限制。到目前为止，我们一直在一个理想的世界中工作。我们假设所有信号可以立即从源头传输到目标，并且所有触发器在看到上升沿时可以立即改变其输出。我们一直假设如果代码正确，那么一切都会正常工作。
- en: Welcome to reality! In the real world, nothing is truly instantaneous, and components
    behave in unpredictable ways if they’re asked to work too quickly. Three physical
    limitations that contribute to FPGA timing errors are setup time, hold time, and
    propagation delay. Let’s take a quick look at these, and then we’ll explore how
    to fix timing errors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到现实世界！在真实世界中，什么事情都不是真正的瞬时发生的，当组件被要求过快工作时，它们的表现会变得不可预测。导致FPGA时序错误的三个物理限制因素是设置时间、保持时间和传播延迟。让我们快速看看这些因素，然后我们将探讨如何修复时序错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setup and Hold Time</samp>
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">设置时间和保持时间</samp>
- en: '*Setup time* is the amount of time for which the input to a flip-flop is required
    to be stable *before* a clock edge in order for the flip-flop to accurately register
    the input data to its output on that clock edge. *Hold time* is the amount of
    time for which the input must be stable *after* a clock edge in order for the
    flip-flop to reliably hold its current output value until the next clock edge.
    This is illustrated in [Figure 7-1](#fig7-1).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*设置时间*是指触发器输入信号在时钟沿到来之前需要保持稳定的时间，以确保触发器能够在该时钟沿上准确地注册输入数据到输出。*保持时间*是指触发器输入信号在时钟沿之后需要保持稳定的时间，以确保触发器能够可靠地保持当前的输出值，直到下一个时钟沿。这在[图
    7-1](#fig7-1)中有所示意。'
- en: '![](../images/Figure7-1.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: Setup (t</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">su</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)
    and hold (t</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">h</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">) time</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-1：设置时间（t</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">su</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">）和保持时间（t</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">h</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">）</samp>
- en: 'We expect the flip-flop to register some data at the rising clock edge shown
    in the middle of the figure. The time immediately before the rising edge is the
    setup time, labeled *t*su. The time immediately after the rising edge is the hold
    time, labeled *t*h. If the data input to the flip-flop changes outside the setup
    and hold window, then everything works fine. However, bad things can happen if
    your data input changes during the setup and hold window. Specifically, the flip-flop
    can become *metastable*, entering a state where its output is unstable: it could
    be a 1, it could be a 0, or it could even be somewhere in between. [Figure 7-2](#fig7-2)
    shows an example of a metastable event.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望触发器在图中间的上升沿处注册一些数据。上升沿之前的时间是设置时间，标记为*t*su；上升沿之后的时间是保持时间，标记为*t*h。如果触发器的数据输入在设置时间和保持时间之外变化，那么一切都能正常工作。然而，如果数据输入在设置时间和保持时间窗口内变化，就会发生不良情况。具体来说，触发器可能变得*亚稳*，进入一个输出不稳定的状态：它可能是1，可能是0，甚至可能处于两者之间。[图
    7-2](#fig7-2)显示了一个亚稳事件的例子。
- en: '![](../images/Figure7-2.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: A metastable condition</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-2：亚稳态条件</samp>
- en: Here we see a clock signal and the input and output signals of a flip-flop.
    The shaded area of the input signal labeled *t*su represents the flip-flop’s setup
    time, immediately before the rising clock edge. As you can see, the data input
    to the flip-flop transitions from low to high during the setup window. This causes
    the output to be metastable for some amount of time, after which it settles out
    to either a 0 or a 1.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到一个时钟信号以及触发器的输入和输出信号。输入信号中标记为*t*su的阴影区域表示触发器的设置时间，即在上升沿之前的时间段。如你所见，触发器的数据输入在设置窗口期间从低电平过渡到高电平。这导致输出在一段时间内处于亚稳态，之后才会稳定为0或1。
- en: To understand metastability, people often use the analogy of a ball balanced
    on top of a hill, as shown in [Figure 7-3](#fig7-3). The ball could roll down
    the hill either to the left or to the right, and there’s no predicting which way
    it’ll go. A random gust of wind could blow it one way or the other. If it rolls
    down to the left, that’s state 0, and if it rolls to the right, that’s state 1\.
    When the output of a flip-flop is in a metastable state, it’s a ball teetering
    on a hill, trying to find a more stable state to rest into.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解亚稳态，人们常常用一个平衡在山顶的球的类比，如[图 7-3](#fig7-3)所示。球可能朝左或朝右滚下山，无法预测它会滚向哪个方向。一个随机的阵风可能把它吹向任何方向。如果它滚向左边，那就是状态
    0；如果滚向右边，那就是状态 1。当触发器的输出处于亚稳态时，就像是一个摇摇欲坠的球，试图找到一个更稳定的状态来停靠。
- en: '![](../images/Figure7-3.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: A metastable state</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-3：亚稳态</samp>
- en: In addition to not knowing which way the ball will roll, there’s also no way
    to tell how long it will take for the ball to roll down the hill. It might fall
    quickly, or it might take a while. This is known as the *metastable resolution
    time*, or the time it takes for a metastable situation to become stable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不知道球会朝哪个方向滚动外，还无法知道球滚下山的时间。它可能快速滚下，也可能需要一段时间。这被称为*亚稳态解析时间*，即亚稳态变为稳定状态所需的时间。
- en: There’s no way to know ahead of time which state the output will settle on.
    Sometimes it might be a 0, while other times when this situation occurs it might
    be a 1\. Assuming the data input doesn’t change again, the output will definitely
    be a 1 at the next rising clock edge, when the flip-flop again registers its input
    to its output. In the meantime, however, for the duration of this one clock cycle,
    there’s no telling what the output will be, and this is not desired behavior for
    an FPGA.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 无法提前知道输出最终会稳定在哪个状态。有时它可能是 0，而其他时候，当这种情况发生时，它可能是 1。如果数据输入没有再次变化，则在下一个上升沿时，输出肯定会是
    1，因为触发器会再次将输入值传送到输出。然而，在这一个时钟周期内，输出究竟会是什么是无法预测的，这种行为在 FPGA 中是不期望出现的。
- en: If your design has timing errors, your FPGA tools are telling you that one or
    more flip-flops could have their setup and hold windows violated, which could
    put them in a metastable state. Metastability is probabilistic, however, so there’s
    no guarantee that it will actually occur. There’s a chance that your design will
    be completely fine despite the reported timing errors, but there’s also a chance
    that the FPGA will exhibit strange and unpredictable behavior. In FPGA design
    we like things to be predictable, so even the remote possibility of metastability
    occurring is a problem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设计有时序错误，FPGA 工具会告诉你，某些触发器的设置时间和保持时间窗口可能被违反，这可能导致它们进入亚稳态。然而，亚稳态是概率性的，因此无法保证它一定会发生。你的设计可能在报告时序错误的情况下完全正常，但也有可能
    FPGA 会表现出奇怪且不可预测的行为。在 FPGA 设计中，我们喜欢预测性，因此即使是亚稳态发生的微小可能性也是一个问题。
- en: 'Metastable conditions can occur when either the setup or the hold time is violated,
    but setup and hold time are physical properties of your FPGA and are beyond your
    control. You can’t modify your design in a way that will change the setup or hold
    time. In order to resolve a timing error, you must focus your efforts on the other
    main physical limitation of FPGAs: propagation delay.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 亚稳态可能在违反设置时间或保持时间时发生，但设置时间和保持时间是 FPGA 的物理属性，无法控制。你不能以改变设置时间或保持时间的方式修改设计。为了修复时序错误，必须集中精力解决
    FPGA 的另一个主要物理限制：传播延迟。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Propagation Delay</samp>
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">传播延迟</samp>
- en: '*Propagation delay* is the amount of time it takes for a signal to travel from
    a source to a destination. As mentioned previously, in the real world this is
    not instantaneous: it takes some time, albeit a very small amount, for voltage
    changes to propagate down a wire. A decent rule of thumb is that signals can travel
    along a wire at a rate of 1 foot per nanosecond. That may not sound like much
    of a delay, but consider that there are thousands of tiny wires running everywhere
    inside your FPGA. When you add up the physical length of the wires the total can
    be amazingly long, considering how small the chips are. This can lead to a significant
    propagation delay as signals travel from one flip-flop to another.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*传播延迟*是信号从源到目的地传播所需的时间。如前所述，在现实世界中，这不是瞬时的：电压变化在电线中传播需要一些时间，尽管这个时间非常短。一个不错的经验法则是，信号沿着电线传播的速度为每纳秒1英尺。听起来可能不算很长延迟，但考虑到FPGA内部有成千上万条细小的电线，电线的物理长度加起来可能非常长，考虑到芯片的尺寸如此之小。这会导致显著的传播延迟，尤其是信号从一个触发器传播到另一个触发器时。'
- en: Additionally, every piece of logic that a signal goes through—for example, a
    LUT representing an AND gate—adds some extra time to the propagation delay, since
    these logic operations aren’t perfectly instantaneous either. This concept is
    illustrated in [Figure 7-4](#fig7-4).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，信号经过的每一段逻辑——例如，表示与门的查找表（LUT）——都会增加一些传播延迟，因为这些逻辑操作也不是完全瞬时的。这个概念在[图7-4](#fig7-4)中有所说明。
- en: '![](../images/Figure7-4.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: Propagation delay
    between two flip-flops</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-4：两个触发器之间的传播延迟</samp>
- en: Here we have two flip-flops, with data traveling from the output of one flip-flop
    to the input of the other. The logic and routing in between might consist of wires
    and/or LUTs. This is where the propagation delay happens, and the more stuff there
    is in that cloud—for example, longer wires or more LUTs—the longer it will take
    for the output of flip-flop 1 to reach the input of flip-flop 2\. If the propagation
    delay is too long, the design won’t be able to meet timing at the requested clock
    constraint.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个触发器，数据从一个触发器的输出传输到另一个触发器的输入。触发器之间的逻辑和布线可能包括电线和/或LUT。传播延迟发生在这里，且云中包含的物体越多——例如，更长的电线或更多的LUT——从触发器1的输出到触发器2的输入所需的时间就越长。如果传播延迟过长，设计将无法满足请求的时钟约束。
- en: The issue here is that both flip-flops are driven by the same clock. If flip-flop
    1 sees a change on its input and registers that change to its output at one rising
    clock edge, we’d expect flip-flop 2 to see that change and register it at the
    next rising clock edge. The signal only has a single clock period to propagate
    from flip-flop 1 to flip-flop 2\. If the signal can safely arrive within that
    time, the design will work. But if the logic and routing in between the flip-flops
    create too long of a propagation delay, we’ll get a timing error. There might
    be many thousands of flip-flops in the FPGA design, and it’s the responsibility
    of the place and route tool to analyze every single path and show us the worst
    offenders from a timing perspective.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，两个触发器都由同一个时钟驱动。如果触发器1在一个上升时钟沿上看到输入变化并将该变化注册到输出，我们期望触发器2在下一个上升时钟沿看到该变化并将其注册。信号只有一个时钟周期的时间从触发器1传播到触发器2。如果信号能够在这个时间内安全到达，设计将正常工作。但如果触发器之间的逻辑和布线产生的传播延迟过长，我们就会遇到时序错误。FPGA设计中可能有成千上万的触发器，放置和布线工具的责任是分析每一条路径，并从时序角度向我们显示最严重的问题。
- en: 'In fact, the signal has *less* than the length of a single clock period to
    propagate from flip-flop 1 to flip-flop 2, since we also need to take the setup
    time into account. The propagation delay may be less than the clock period, but
    as we’ve just seen, if the signal arrives at flip-flop 2 within its setup window,
    the output of flip-flop 2 will be uncertain. This leads to the following formula
    for calculating the clock period needed for a design to function properly:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，信号从触发器1传播到触发器2所需的时间比一个时钟周期的长度还要短，因为我们还需要考虑建立时间。传播延迟可能小于时钟周期，但正如我们刚才看到的，如果信号在触发器2的建立窗口内到达，触发器2的输出将是不确定的。这就导致了以下计算设计正常工作的时钟周期所需的公式：
- en: '*t*clk(min) = *t*su + *t*p'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*t*clk(min) = *t*su + *t*p'
- en: Here, *t*clk(min) is the minimum clock period required for the design to work
    without timing errors, *t*su is the setup time, and *t*p is the worst propagation
    delay the design will experience between two flip-flops. As an example, say all
    of the flip-flops on the FPGA have a fixed setup time of 2 ns and our design will
    create a propagation delay of up to 10 ns (in the worst case) between two particular
    flip-flops. Our formula tells us that our clock needs to have a period of at least
    2 + 10 = 12 ns, which works out to a frequency of 83.3 MHz. We could easily run
    the design with a slower clock than that if we wanted, in which case the period
    would be even longer, but if we wanted to run the FPGA faster, say at 100 MHz,
    then the clock period would be too short and we would get timing errors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*t*clk(min) 是设计正常工作且没有时序错误所需的最小时钟周期，*t*su 是设置时间，*t*p 是设计在两个触发器之间可能出现的最坏传播延迟。例如，假设
    FPGA 上所有触发器的设置时间固定为 2 ns，且我们的设计在两个特定触发器之间会产生最多 10 ns（在最坏情况下）的传播延迟。我们的公式告诉我们，时钟周期需要至少为
    2 + 10 = 12 ns，这相当于 83.3 MHz 的频率。如果我们想，我们完全可以使用更慢的时钟来运行设计，这样周期会更长；但如果我们想让 FPGA
    更快运行，例如 100 MHz，则时钟周期会太短，导致时序错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">How to Fix Timing Errors</samp>
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">如何修复时序错误</samp>
- en: 'As you’ve just seen, the clock period, setup time, and propagation delay are
    the main factors contributing to timing errors. Since the setup time is fixed,
    there are two basic ways to solve timing errors:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，时钟周期、设置时间和传播延迟是导致时序错误的主要因素。由于设置时间是固定的，解决时序错误有两种基本方法：
- en: Slow down the clock frequency.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低时钟频率。
- en: Reduce the propagation delay by breaking up the logic into stages.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将逻辑划分为多个阶段来减少传播延迟。
- en: Slowing down your clock frequency might seem like the most obvious choice. If
    you’re able to run your FPGA slower, your timing will improve. However, it’s unlikely
    that you’ll be able to change your clock frequency freely; it’s usually set in
    stone for some particular reason, such as if you’re interfacing to a peripheral
    that needs to run at a specific frequency. Chances are you won’t be able to slow
    the clock down just to relax timing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 降低时钟频率可能看起来是最直观的选择。如果你能够让 FPGA 运行得更慢，你的时序会得到改善。然而，你不太可能自由地更改时钟频率；通常它会由于某些特定原因被固定，比如你可能需要与一个必须在特定频率下运行的外设进行接口。很可能你无法仅仅为了放松时序而降低时钟频率。
- en: Breaking up your logic into stages, also known as *pipelining*, is the more
    robust (and often the only) option. If you do less “stuff” between any two flip-flops,
    the propagation delay will decrease, and it will be easier for your design to
    meet timing. [Figure 7-5](#fig7-5) illustrates how this works.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑划分为多个阶段，也称为 *流水线*，是更为稳健（且通常是唯一的）选择。如果你在任何两个触发器之间做得“更少”，传播延迟将会减少，设计也更容易满足时序要求。[图
    7-5](#fig7-5) 展示了这一过程如何工作。
- en: '![](../images/Figure7-5.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: Reducing the propagation
    delay through pipelining</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-5：通过流水线减少传播延迟</samp>
- en: In the top half of the figure, we have a large amount of logic between two flip-flops—so
    much that the design has too long of a propagation delay and fails timing. The
    solution, shown in the bottom half of the figure, is to break up the logic into
    two stages, with another flip-flop added in between. This way, half of the logic
    can be done between flip-flops 1 and 2, and the other half between flip-flops
    2 and 3\. The propagation delay for each of these stages should be short enough
    that the stages can be accomplished in a single clock cycle, and overall the tools
    will have two clock cycles to do what we were originally trying to do in one clock
    cycle.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的上半部分，两个触发器之间有大量的逻辑——多到设计的传播延迟过长，无法通过时序验证。解决方案（如图下半部分所示）是将逻辑拆分为两个阶段，并在中间增加另一个触发器。这样，部分逻辑可以在触发器
    1 和 2 之间完成，另一部分则在触发器 2 和 3 之间完成。每个阶段的传播延迟应足够短，以便每个阶段可以在一个时钟周期内完成，整体上，工具将有两个时钟周期来完成我们最初打算在一个时钟周期内完成的任务。
- en: 'When you break up a single stage in your design into multiple stages like this,
    you’re creating a *pipeline* of operations, with a flip-flop between each stage
    to synchronize the operations with the clock. A well-pipelined design will have
    a much better chance at meeting timing at high clock frequencies. To demonstrate,
    let’s consider an example of some code that has poor timing, and then look at
    how to pipeline the logic to avoid timing errors. First, here’s the problematic
    code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将设计中的单一阶段拆分为多个阶段时，你实际上是在创建一个*流水线*操作，并在每个阶段之间使用触发器来与时钟同步操作。一个良好的流水线设计将大大提高在高时钟频率下满足时序要求的机会。为了演示，我们来看一个时序表现不佳的代码示例，然后探讨如何对逻辑进行流水线处理以避免时序错误。首先，这里是有问题的代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I can’t imagine why anyone would write code like this, but it will do for demonstration
    purposes. The problem arises when we perform some mathematical operations—division,
    addition, and multiplication—on the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp>
    ❶. All three of these operations are performed on the same line, inside a synchronous
    <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block, which means they must occur within one clock cycle. To do all that math,
    the output of the 8-bit-wide register <samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp>
    will pass through a bunch of LUTs, then into the inputs of the flip-flops for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp>, all within one clock
    cycle. This puts us firmly in the upper half of [Figure 7-5](#fig7-5): the mathematical
    operations require a lot of logic and will create a considerable propagation delay.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法想象为什么有人会写出这样的代码，但它足以用作演示。问题出现在我们对<samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp>
    ❶进行一些数学运算——除法、加法和乘法——时。所有这三种操作都在同一行内、在一个同步的<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块内执行，这意味着它们必须在一个时钟周期内完成。为了执行这些数学运算，8位宽的寄存器<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp>的输出将通过一堆LUT，然后进入<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp>的触发器输入，所有这些操作都在一个时钟周期内完成。这使得我们进入了[图7-5](#fig7-5)的上半部分：这些数学操作需要大量的逻辑，并且会产生相当大的传播延迟。
- en: 'Let’s see what happens when we run this code through place and route with a
    100 MHz clock constraint. Here’s the resulting timing report:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们使用100 MHz时钟约束将这段代码通过布局与布线时会发生什么。以下是生成的时序报告：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can see that we tried to drive the clock to 100 MHz, but the place and route
    tool can only guarantee timing up to 89.17 MHz ❶. When the target frequency is
    higher than the maximum achievable frequency, we’ll have timing errors. The timing
    report then tells us about the worst-offending paths in the design, albeit a little
    cryptically. First, the report identifies the beginning ❷ and end ❸ of each problematic
    path. Notice that <samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp>
    is in the signal name of <samp class="SANS_TheSansMonoCd_W5Regular_11">Path Begin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp> is in the signal
    name of <samp class="SANS_TheSansMonoCd_W5Regular_11">Path End</samp>, but there’s
    a bunch of extra stuff there too. The tools add this additional information to
    identify the exact locations of the components in question within the FPGA. The
    downside is that the information isn’t very human-readable, but since the core
    signal names have persisted, we can see that the path from <samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp> is the failing
    path. Further, the report tells us exactly how much the path is failing by ❹.
    The *path slack* is the amount of wiggle room the path has available to meet timing,
    and the fact that it’s negative is telling us we’re too slow; we need an additional
    1,215 picoseconds (ps), or 1.215 ns, to remove this timing error. That makes sense,
    since the difference in clock period between 89.17 MHz and 100 MHz is 1,215 ps.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们尝试将时钟频率提升到 100 MHz，但布线工具只能保证时序达到 89.17 MHz ❶。当目标频率高于最大可实现的频率时，就会出现时序错误。时序报告接着告诉我们设计中最严重的路径，虽然表达有些模糊。首先，报告标识了每条问题路径的开始
    ❷ 和结束 ❸。注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp> 出现在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Path Begin</samp> 的信号名称中，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp>
    出现在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Path End</samp> 的信号名称中，但那里还有一些额外的内容。工具加入了这些附加信息，以便识别
    FPGA 中相关组件的确切位置。缺点是这些信息不太容易理解，但由于核心信号名称保持不变，我们可以看出，从 <samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp> 的路径是失败的路径。此外，报告还精确告诉我们路径的失败程度
    ❹。*路径裕度*是指路径有多大的可调整空间来满足时序要求，负值则告诉我们时序过慢；我们需要额外的 1,215 皮秒（ps），即 1.215 纳秒（ns），来消除这个时序错误。这是有道理的，因为
    89.17 MHz 和 100 MHz 之间的时钟周期差正好是 1,215 ps。
- en: 'Now that we’ve identified the failing path, we can pipeline the path’s logic
    by breaking up the math operations with some flip-flops. Here’s what that might
    look like:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了失败的路径，可以通过使用触发器将数学运算分解，来实现该路径的流水线处理。下面是可能的样子：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’ve taken what used to be a single line of code and broken it up into three
    lines. First, we perform just the division operation and write the result to an
    intermediary signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">r1_Data</samp>
    ❶. Then we perform the addition operation on <samp class="SANS_TheSansMonoCd_W5Regular_11">r1_Data</samp>
    and assign the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">r2_Data</samp>
    ❷, and finally we perform the multiplication operation on <samp class="SANS_TheSansMonoCd_W5Regular_11">r2_Data</samp>
    and assign the result to our original output, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp>
    ❸. We’ve introduced new signals to distribute the large math operation that was
    occurring in a single clock cycle across multiple clock cycles. This should reduce
    the propagation delay. Indeed, if we run the new, pipelined design through place
    and route, we’ll get the following timing report:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把原本一行的代码拆分成了三行。首先，我们只执行除法操作，并将结果写入中间信号 <samp class="SANS_TheSansMonoCd_W5Regular_11">r1_Data</samp>
    ❶。接着，我们对 <samp class="SANS_TheSansMonoCd_W5Regular_11">r1_Data</samp> 执行加法操作，并将结果赋值给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r2_Data</samp> ❷，最后对 <samp class="SANS_TheSansMonoCd_W5Regular_11">r2_Data</samp>
    执行乘法操作，并将结果赋值给我们的原始输出 <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp>
    ❸。我们引入了新的信号，将原本在一个时钟周期内发生的大数学运算分布到多个时钟周期中。这样应该能减少传播延迟。实际上，如果我们将新的流水线设计进行布线，就会得到以下的时序报告：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we’re meeting timing: the place and route tool can guarantee performance
    up to a clock frequency of 110.87 MHz, when the target frequency was 100 MHz.
    As you’ve seen, fixing the timing errors involved a bit of trade-off. We had to
    add flip-flops into our design to break up the logic into stages, so our design
    now uses more FPGA resources than before. Additionally, the math operation that
    was meant to take a single clock cycle now takes three clock cycles. However,
    keep in mind that our module can still take in new input values at a rate of 100
    MHz and spit out calculated output values at a rate of 100 MHz, as we intended
    with the original design; it’s only the *first* result to come out of the pipeline
    that will take two additional clock cycles, due to the added flip-flops.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经满足了时序要求：布图和布线工具可以保证在目标频率为 100 MHz 时，性能达到 110.87 MHz 的时钟频率。如你所见，修复时序错误涉及到一些权衡。我们不得不在设计中添加触发器，将逻辑拆分为多个阶段，因此我们的设计现在比以前使用了更多的
    FPGA 资源。此外，原本应该在一个时钟周期内完成的数学运算，现在需要三个时钟周期。然而，请记住，我们的模块仍然能够以 100 MHz 的速率接收新的输入值，并以
    100 MHz 的速率输出计算结果，这正是我们在原始设计中的预期；只是*第一个*从流水线输出的结果由于添加的触发器需要额外的两个时钟周期。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Unexpected Timing Errors</samp>
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">意外的时序错误</samp>
- en: 'You can fix most timing errors by pipelining your design to cut down on propagation
    delay and avoid metastable conditions. However, place and route tools can’t anticipate
    every timing error. These tools aren’t perfect; they can only analyze your design
    based on the information they have. Even if you don’t see any errors in your timing
    report, there are two situations where metastable conditions may still occur that
    the place and route tool can’t reliably predict:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过对设计进行流水线化来修复大多数时序错误，从而减少传播延迟并避免亚稳态条件。然而，布图和布线工具无法预测所有时序错误。这些工具并不完美；它们只能根据所拥有的信息分析你的设计。即使你在时序报告中没有看到任何错误，也有两种情况下亚稳态条件仍然可能发生，而布图和布线工具无法可靠地预测：
- en: When sampling a signal asynchronous to the FPGA clock
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当采样一个与 FPGA 时钟不同步的信号时
- en: When crossing clock domains
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当跨时钟域时
- en: Sampling a signal asynchronous to the FPGA clock is very common when you have
    an external signal that serves as input to your FPGA. The input signal will go
    directly to the input of a flip-flop in your design, but it will be asynchronous,
    meaning it isn’t coordinated by your main FPGA clock. For example, think about
    someone pushing a button. That button press could come at any time, so if it happens
    to occur during the setup time of the flip-flop the button is wired to, then that
    flip-flop will be in a metastable state. The place and route tool doesn’t know
    anything about this potential issue, so it won’t flag it as a timing error. But
    you, dear FPGA designer, can anticipate and fix the problem. The solution is to
    *double-flop* the input data by passing it through an extra flip-flop, as shown
    in [Figure 7-6](#fig7-6).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个外部信号作为输入信号传递到 FPGA 时，采样一个与 FPGA 时钟不同步的信号是非常常见的。输入信号会直接传递到设计中触发器的输入端，但它是异步的，也就是说，它没有由主
    FPGA 时钟协调。例如，想象一下有人按下按钮。这个按钮的按下可以在任何时刻发生，因此如果它恰好发生在触发器的建立时间内，那么这个触发器将处于亚稳态。布图和布线工具并不了解这个潜在的问题，因此不会将其标记为时序错误。但你，亲爱的
    FPGA 设计师，可以预见并解决这个问题。解决方案是通过让输入数据通过一个额外的触发器来实现*双触发器*，如[图 7-6](#fig7-6)所示。
- en: '![](../images/Figure7-6.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: Double-flopping
    to fix metastability</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-6：通过双触发器修复亚稳态</samp>
- en: In this figure, a signal that’s asynchronous to the clock is being sampled by
    the first flip-flop. Since we can’t guarantee the timing of this input relative
    to the clock, it might violate setup or hold times and create a metastable condition
    at the output of the first flip-flop. As discussed previously, though, the occurrence
    of a metastable condition is probabilistic. It’s also quite rare. Even if the
    first flip-flop enters a metastable state, it’s highly unlikely that the second
    flip-flop will enter one too. In fact, adding a second flip-flop in series with
    the first one reduces the likelihood of a metastable condition at the output to
    effectively zero. (Adding a third flip-flop in series would decrease the likelihood
    even more, but FPGA experts have concluded that two flip-flops in series is enough.)
    We can now use the stable signal internal to our design and be confident that
    we won’t see strange behavior.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，一个与时钟不同步的信号正在被第一个触发器采样。由于我们无法保证这个输入相对于时钟的时序，它可能会违反设置时间或保持时间，并在第一个触发器的输出处产生亚稳态。正如前面讨论的那样，亚稳态的发生是概率性的，且相当罕见。即使第一个触发器进入了亚稳态，也极不可能第二个触发器也进入亚稳态。事实上，将第二个触发器与第一个串联起来，可以将亚稳态在输出处的可能性降到几乎为零。（如果再加一个第三个触发器，亚稳态的可能性会进一步降低，但
    FPGA 专家已经得出结论，两个触发器串联就足够了。）我们现在可以使用设计内部的稳定信号，并确信不会看到奇怪的行为。
- en: The other situation where you still may encounter a metastable state is when
    you cross clock domains in your FPGA. This is a big topic that warrants its own
    section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能遇到亚稳态的情况是，当你在 FPGA 中跨越时钟域时。这是一个很大的话题，值得单独成章讨论。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Crossing Clock Domains</samp>
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">跨越时钟域</samp>
- en: As I’ve mentioned, it’s possible to have multiple clock domains inside a single
    FPGA, with different clocks driving different parts of the design. You might need
    a camera interface running at 25.725 MHz and an HDMI interface running at 148.5
    MHz, for example. If you wanted to send the data from the camera out to the HDMI
    for visualization on a monitor, that data would have to cross clock domains, moving
    from the part of the design controlled by a 25.725 MHz clock to the part of the
    design controlled by a 148.5 MHz clock. However, there’s no way to guarantee the
    alignment between these clock domains; they can drift apart and back together.
    Even if the clocks have a seemingly predictable relationship, like a 50 MHz clock
    and a 100 MHz clock, you can’t be sure that the clocks started at the same time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，单个 FPGA 中可能有多个时钟域，不同的时钟驱动设计的不同部分。例如，你可能需要一个工作在 25.725 MHz 的摄像头接口和一个工作在
    148.5 MHz 的 HDMI 接口。如果你想将摄像头的数据发送到 HDMI，以便在显示器上显示，这些数据就必须跨越时钟域，从由 25.725 MHz 时钟控制的部分移动到由
    148.5 MHz 时钟控制的部分。然而，无法保证这些时钟域之间的对齐；它们可能会彼此偏移然后再对齐。即使时钟之间看似有可预测的关系，比如 50 MHz 时钟和
    100 MHz 时钟，你也不能确定它们是否在同一时刻开始。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The exception is if you’re using an FPGA component called a* phase-locked
    loop (PLL)*, which can generate unique clock frequencies and establish relationships
    between them. The PLL is discussed in detail in [Chapter 9](chapter9.xhtml).*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*例外情况是，如果你使用了一种名为*相位锁定环（PLL）*的 FPGA 组件，它可以生成独特的时钟频率并在它们之间建立关系。PLL 在[第 9 章](chapter9.xhtml)中有详细讨论。*'
- en: The bottom line is that when you have clock domains that are asynchronous to
    each other, signals crossing between domains might produce metastable states within
    some flip-flops. In this section, we’ll look at how to cross clock domains safely,
    from slower to faster and vice versa, and avoid metastability. We’ll also discuss
    how to use a FIFO to send large amounts of data across clock domains.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结论是，当你有彼此不同步的时钟域时，跨越这些时钟域的信号可能会在某些触发器中产生亚稳态。在本节中，我们将探讨如何安全地跨越时钟域，从慢时钟到快时钟，反之亦然，并避免亚稳态。我们还将讨论如何使用
    FIFO 在时钟域之间传送大量数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Crossing from Slower
    to Faster</samp>
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从慢时钟到快时钟的跨越</samp>
- en: 'The simplest situation to handle is going from a slower clock domain to a faster
    clock domain. To avoid problems, all you need to do is double-flop the data when
    it enters the faster domain, as shown in [Figure 7-7](#fig7-7). This is the same
    approach we took to fix the external asynchronous signal, since it’s fundamentally
    the same issue: the signal from the slower clock domain is asynchronous to the
    faster clock domain that it’s entering.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是从较慢时钟域切换到较快时钟域。为避免问题，您只需要在数据进入更快的时钟域时进行双触发器处理，如[图 7-7](#fig7-7)所示。这与我们修复外部异步信号时采用的方法相同，因为它本质上是相同的问题：来自较慢时钟域的信号与它进入的较快时钟域是异步的。
- en: '![](../images/Figure7-7.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-7: Crossing from a
    slower to a faster clock domain</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-7：从较慢时钟域到较快时钟域的跨越</samp>
- en: 'In [Figure 7-7](#fig7-7), we have three flip-flops in series. The first is
    driven by a slower clock, while the others are driven by a faster clock. The slower
    clock is your *source clock domain*, and the faster clock is your *destination
    clock domain*. Since the clocks are asynchronous to each other, we can’t guarantee
    that data coming from the slower clock domain won’t violate the setup or hold
    times of the middle flip-flop (the first one in the faster clock domain) and trigger
    a metastable state. However, we know that the output of the second of these flip-flops
    will be stable, allowing the data to be used in the faster clock domain. Let’s
    look at how this design could be implemented in code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 7-7](#fig7-7)中，我们有三个串联的触发器。第一个由较慢的时钟驱动，后面的由较快的时钟驱动。较慢的时钟是您的*源时钟域*，较快的时钟是您的*目标时钟域*。由于时钟彼此之间是异步的，我们无法保证来自较慢时钟域的数据不会违反中间触发器（即较快时钟域中的第一个触发器）的建立时间或保持时间，从而触发亚稳态。然而，我们知道，第二个触发器的输出将是稳定的，可以在较快的时钟域中使用该数据。让我们看看如何用代码实现这个设计：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code consists of an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block running
    off the positive edges of the faster clock. First, the signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Slow_Data</samp>
    (coming from the slower domain) enters flip-flop <samp class="SANS_TheSansMonoCd_W5Regular_11">r1_Data</samp>
    ❶. The output of this flip-flop could be metastable if a change in <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Slow_Data</samp>
    violates its setup or hold time, but we resolve this metastable condition by double-flopping
    the data, passing it through a second flip-flop, <samp class="SANS_TheSansMonoCd_W5Regular_11">r2_Data</samp>
    ❷. At this point, we have stable data that we can use in the faster clock domain
    without having to worry about metastable conditions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码由一个<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块组成，该块在较快时钟的正沿上运行。首先，来自较慢时钟域的信号<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Slow_Data</samp>进入触发器<samp class="SANS_TheSansMonoCd_W5Regular_11">r1_Data</samp>
    ❶。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Slow_Data</samp>的变化违反了建立时间或保持时间，这个触发器的输出可能会变成亚稳态，但我们通过双触发器处理来解决这个亚稳态问题，将数据传递给第二个触发器<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r2_Data</samp> ❷。此时，我们得到了稳定的数据，可以在较快时钟域中使用，而无需担心亚稳态问题。
- en: 'One word of caution about writing code for an FPGA that uses two clock domains:
    be very careful to keep the code for the two domains separate. Keep all of your
    slower signals in one <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, clearly
    separated from the faster signals in a different <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block (the exception
    is signals crossing between domains). In fact, I find it helpful to put code that
    runs in different clock domains in completely different files, just to be sure
    I’m not mixing and matching signals.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为使用两个时钟域的FPGA编写代码，有一点需要特别注意：一定要小心将两个时钟域的代码分开。将所有较慢的信号放在一个<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块中，与较快的信号在另一个<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块中明确分开（跨时钟域的信号是个例外）。实际上，我发现将运行在不同时钟域中的代码放在完全不同的文件中是很有帮助的，这样可以确保我不会将信号混合使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Crossing from Faster
    to Slower</samp>
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从更快的时钟域到较慢的时钟域</samp>
- en: Going from a faster clock domain to a slower one is more complicated than the
    other way around, since the data inside the faster clock domain could easily change
    before the slower clock domain even sees it. For example, consider a pulse that
    occurs for one clock cycle in a 100 MHz clock domain, that you’re trying to detect
    in a 25 MHz clock domain. There’s a good chance that you’ll never see this pulse,
    as illustrated in [Figure 7-8](#fig7-8).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个更快的时钟域到一个较慢的时钟域要比反过来更复杂，因为在较慢的时钟域看到数据之前，较快的时钟域中的数据可能已经发生变化。例如，考虑一个在 100 MHz
    时钟域中发生的脉冲，它持续一个时钟周期，而你试图在一个 25 MHz 时钟域中检测这个脉冲。很有可能你永远也看不到这个脉冲，如[图 7-8](#fig7-8)所示。
- en: '![](../images/Figure7-8.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-8: A failed crossing
    from a faster to a slower clock domain</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-8：从更快的时钟域到较慢的时钟域的失败示例</samp>
- en: This figure shows two cycles of the 25 MHz clock. After the clock’s first rising
    edge but before its second rising edge, the 100 MHz pulse comes and goes, so fast
    that the 25 MHz clock never “sees” and registers it. This is because the pulse
    doesn’t occur during the rising edge of the 25 MHz clock. Therefore, the pulse
    will go completely unnoticed in the 25 MHz clock domain. The solution to this
    problem is to *stretch out* any signals from the faster clock domain that are
    meant to enter the slower clock domain, until they’re long enough to guarantee
    that they’ll be noticed. [Figure 7-9](#fig7-9) shows how this works.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了 25 MHz 时钟的两个周期。在时钟的第一次上升沿之后，但在第二次上升沿之前，100 MHz 脉冲来去匆匆，速度太快，以至于 25 MHz
    时钟从未“看到”并注册它。这是因为脉冲并没有出现在 25 MHz 时钟的上升沿。因此，这个脉冲在 25 MHz 时钟域中完全没有被察觉。解决这个问题的方法是将任何从更快时钟域传入较慢时钟域的信号进行*拉伸*，直到它们足够长，确保它们能被注意到。[图
    7-9](#fig7-9)展示了这个原理的实际运作。
- en: '![](../images/Figure7-9.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-9: A successful crossing
    from a faster to a slower clock domain</samp>'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-9：从更快的时钟域到较慢的时钟域的成功示例</samp>
- en: Looking at the new waveform of the 100 MHz pulse, we can see that it’s been
    stretched from a single cycle of the 100 MHz clock to multiple clock cycles, ensuring
    that a rising edge in the 25 MHz clock domain will see the pulse. As a general
    rule, pulses passing from a faster clock domain to a slower clock domain should
    be stretched to last at least two clock cycles in the slower domain. This way,
    even if the pulse violates the setup and hold time of the first clock cycle in
    the slower domain and triggers a metastable state, it will be stable at the second
    clock cycle. In our example, we should stretch out the 100 MHz pulse to at least
    eight 100 MHz clock cycles, the equivalent of two 25 MHz clock cycles. You can
    stretch the signals even longer if you like.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 100 MHz 脉冲的新波形，我们可以看到它已经从一个 100 MHz 时钟周期拉伸到了多个时钟周期，确保在 25 MHz 时钟域中的上升沿可以看到这个脉冲。一般来说，从一个更快的时钟域传递到一个较慢的时钟域的脉冲应该拉伸，至少持续两个时钟周期。这样，即使脉冲违反了较慢时钟域中第一个时钟周期的建立和保持时间，并触发了一个亚稳态，它也会在第二个时钟周期稳定下来。在我们的例子中，我们应该将
    100 MHz 脉冲拉伸至至少八个 100 MHz 时钟周期，相当于两个 25 MHz 时钟周期。如果需要，您可以将信号拉伸得更长。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a FIFO</samp>
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 FIFO</samp>
- en: In the previous examples we looked at how to transmit a simple pulse across
    clock domains. But what if you want to send a lot of data between two clock domains,
    such as when sending camera data to an HDMI interface? In this case, the most
    common method is to use a FIFO. You write data to the FIFO according to one clock
    and read it out according to the other. Of course, the key requirement here is
    that the FIFO must support two different clock frequencies, whereas the FIFO we
    looked at in [Chapter 6](chapter6.xhtml) only supported one clock.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们研究了如何在时钟域之间传输简单的脉冲。但如果你想在两个时钟域之间传输大量数据，比如将相机数据发送到 HDMI 接口呢？在这种情况下，最常见的方法是使用
    FIFO。你按照一个时钟将数据写入 FIFO，然后按照另一个时钟将其读取出来。当然，这里最关键的要求是 FIFO 必须支持两个不同的时钟频率，而我们在[第六章](chapter6.xhtml)中看到的
    FIFO 只支持一个时钟。
- en: To cross clock domains with a FIFO, you’ll likely need to use a *primitive*,
    a dedicated FPGA component designed by the manufacturer specifically for your
    exact FPGA. For example, Intel will have prewritten FIFO primitives that run in
    different clock domains, but the Verilog or VHDL code to create them will differ
    from that of AMD’s FIFO primitives. (We’ll explore more examples of primitives
    in [Chapter 9](chapter9.xhtml).)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要跨时钟域使用FIFO，你可能需要使用一个**原语**，这是由制造商为特定FPGA设计的专用FPGA组件。例如，Intel会有预编写的FIFO原语，可以在不同的时钟域中运行，但创建这些原语的Verilog或VHDL代码将与AMD的FIFO原语不同。（我们将在[第9章](chapter9.xhtml)中探索更多关于原语的示例。）
- en: 'When using FIFOs, always remember not to violate the two cardinal rules: don’t
    read from an empty FIFO, and don’t write to a full FIFO. Many FIFO primitives
    provide a count of the number of words (elements) in the FIFO as an output, but
    I don’t recommend relying on it. Instead, I suggest making heavy use of the *AF*
    and *AE* (almost full and almost empty) flags, introduced in “Input and Output
    Signals” on page 117. It’s best to read from and write to the FIFO in bursts of
    a fixed size, especially when crossing clock domains, and to use that burst size
    to determine your AF and AE threshold levels. Set your AE level equal to your
    fixed burst size, and set your AF level equal to the FIFO depth minus your burst
    size. With this setup, you can guarantee that you’ll never break the two key rules.
    The AF flag can throttle the write clock interface by ensuring that if the FIFO
    doesn’t have enough room for another burst, writes will be disabled. Likewise,
    the AE flag can throttle the read clock interface by ensuring that if the FIFO
    doesn’t have a complete burst in it, the read side will not try to pull data out
    of the FIFO.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FIFO时，始终记住不要违反两个基本规则：不要从空的FIFO中读取，也不要写入到满的FIFO中。许多FIFO原语提供了FIFO中单词数（元素数）的输出计数，但我不建议依赖它。相反，我建议多使用在“输入和输出信号”（第117页）中介绍的**AF**和**AE**（几乎满和几乎空）标志。最好在跨时钟域时，以固定大小的突发方式从FIFO读取和写入数据，并利用这个突发大小来确定你的AF和AE阈值。将你的AE水平设置为固定的突发大小，将你的AF水平设置为FIFO深度减去突发大小。通过这种设置，你可以确保永远不会违反这两个关键规则。AF标志可以通过确保FIFO没有足够的空间容纳另一个突发时，禁用写时钟接口来调节写入速度。同样，AE标志可以通过确保FIFO中没有完整的突发数据时，调节读时钟接口，避免读端尝试从FIFO中取出数据。
- en: Let’s explore an example. Consider a case where we have some module writing
    data to a FIFO at 33 MHz. On the read side, we’re dumping the data as quickly
    as possible to external memory. Let’s say the read clock frequency is 110 MHz.
    In this situation, because the read clock is much faster than the write clock,
    the read side will be idle much of the time, even if the writes are happening
    at every clock cycle. To avoid reading from an empty FIFO, you can set the AE
    flag to some number that indicates to your read code that there’s a burst of data
    ready to be read. If you set it to 50 words, for example, once the FIFO has 50
    words inside it the AE flag will change from a 1 to a 0, which will trigger some
    logic on the read side to drain exactly 50 words from the FIFO.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。假设有一个模块在33 MHz的时钟下向FIFO写入数据。在读取端，我们尽可能快速地将数据转存到外部存储器中。假设读取时钟频率为110
    MHz。在这种情况下，由于读取时钟比写入时钟快得多，读取端大部分时间都会处于空闲状态，即使写入操作在每个时钟周期内都在进行。为了避免从空的FIFO中读取数据，你可以将AE标志设置为某个数值，指示读取代码有一批数据准备好被读取。例如，如果你将其设置为50个单词，那么一旦FIFO中有50个单词，AE标志将从1变为0，这将触发读取端的逻辑，从FIFO中精确地读取50个单词。
- en: This is often how crossing clock domains gets implemented. If you’re using your
    AE/AF flags, you’re doing it correctly. Try not to rely on the flags that tell
    you when the FIFO is completely full or empty, and definitely don’t use the counter
    that some FIFOs support.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是跨时钟域实现的方式。如果你正在使用你的**AE/AF**标志，那说明你做得对。尽量不要依赖于那些告诉你FIFO是否完全满或空的标志，也绝对不要使用一些FIFO支持的计数器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Addressing Timing
    Errors</samp>
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解决时序错误</samp>
- en: When running a design with multiple clock domains through the place and route
    process, you’ll need to include the frequencies of each clock in your clock constraints.
    The place and route tool will analyze data sent and received between these clock
    interfaces and report on any timing errors it observes. As you’ve seen, this is
    the tool telling you that you’re likely to encounter situations where setup and
    hold times will be violated, which could trigger metastable conditions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在将包含多个时钟域的设计通过布局与布线过程时，你需要在时钟约束中包含每个时钟的频率。布局与布线工具会分析在这些时钟接口之间发送和接收的数据，并报告它所观察到的任何时序错误。正如你所看到的，这是工具告诉你，可能会遇到设置时间和保持时间被违反的情况，这可能会触发亚稳态条件。
- en: Let’s assume you’ve handled the clock domain crossings well, using the double-flopping,
    data stretching, and FIFO methods discussed in the previous sections. You’re aware
    of the possibility of the metastable states, and you’ve prepared for them. The
    tool doesn’t know about the steps you’ve taken, though. It’s unable to see that
    you’re a smart FPGA designer and that you’ve got it all under control. To suppress
    the errors in your timing report, you’ll need to create some unique *timing constraints*
    that relax the tools and tell them that you’re a competent designer and that you
    understand that your design may be metastable. Exactly how to create these timing
    constraints is beyond the scope of this book, as each FPGA vendor has its own
    unique style.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经很好地处理了时钟域跨越，使用了前面章节中讨论的双触发器、数据拉伸和FIFO方法。你知道可能会出现亚稳态，并且你已经做好了准备。然而，工具并不知道你所采取的步骤。它无法看到你是一个聪明的FPGA设计师，且你已经掌控了一切。为了抑制时序报告中的错误，你需要创建一些独特的*时序约束*，这些约束将放宽工具的要求，告诉它们你是一个有能力的设计师，并且你知道你的设计可能会出现亚稳态。如何创建这些时序约束超出了本书的范围，因为每个FPGA厂商都有其独特的风格。
- en: You should always aim to have no timing errors in your design. However, as an
    FPGA designer, you’ll inevitably experience situations where you cross clock domains.
    You need to clearly understand the common pitfalls that can occur in these situations.
    If the crossing is simple enough, you can just double-flop the data or perform
    data stretching. For many situations, you’ll likely need to use a FIFO that supports
    two clocks, one for reading and one for writing. When structuring your code that
    handles crossing clock domains, be very careful not to mix and match signals from
    both clock domains.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终力求设计中没有时序错误。然而，作为FPGA设计师，你不可避免地会遇到跨越时钟域的情况。你需要清楚地理解这些情况中可能出现的常见陷阱。如果跨越简单，你可以通过双触发器或者执行数据拉伸来解决。对于许多情况，你可能需要使用支持两个时钟的FIFO，一个用于读取，一个用于写入。在编写处理时钟域跨越的代码时，要特别小心，不要将来自不同时钟域的信号混合使用。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter we’ve explored the FPGA build process in detail, looking closely
    at what happens to your FPGA code when it is synthesized and run through place
    and route. You’ve learned about different categories of non-synthesizable code,
    and in particular seen how <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops synthesize differently than you may expect. While examining the place and
    route process, you learned about some of the physical limitations of FPGAs and
    saw how they can lead to timing errors. Finally, you learned some strategies for
    fixing timing errors, including errors that can arise when crossing clock domains.
    With this knowledge, you’ll be able to write your Verilog or VHDL code more confidently,
    and you’ll be able to address common issues that arise during the build process.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了FPGA构建过程，仔细分析了FPGA代码在综合和通过布局与布线过程中发生了什么。你了解了不同类型的不可综合代码，特别是你看到`for`循环的综合方式可能与你预期的不同。在检查布局与布线过程时，你了解了FPGA的一些物理限制，并看到了这些限制如何导致时序错误。最后，你学习了一些修复时序错误的策略，包括在跨越时钟域时可能出现的错误。有了这些知识，你将能够更自信地编写Verilog或VHDL代码，并能够解决构建过程中常见的问题。
