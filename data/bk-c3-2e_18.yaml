- en: '**18**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**18**'
- en: '**BLEND MODES, FILTER EFFECTS, AND MASKING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合模式、滤镜效果与遮罩**'
- en: '![Image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/common-01.jpg)'
- en: The majority of today’s browsers—desktop and mobile—support the *Scalable Vector
    Graphics (SVG)* format. SVG differs from image formats such as GIF, JPEG, and
    PNG (known as bitmap images), as SVG is made up of a markup language
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目前大多数浏览器——桌面版和移动版——都支持*可缩放矢量图形（SVG）*格式。与GIF、JPEG和PNG等图像格式（即位图图像）不同，SVG是由一种标记语言构成的
- en: (similar to HTML) that describes points, or vectors, rather than the grids of
    pixels that make up bitmap images. One advantage that SVG has over bitmap images
    is that, as a vector format, it scales well to fit screens of any resolution.
    In addition to this, the SVG format offers a built-in array of rich graphical
    effects previously available only in image-editing software such as Photoshop,
    GIMP, and Sketch.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: （类似HTML）它描述的是点或矢量，而不是构成位图图像的像素网格。SVG相较于位图图像的一个优势是，作为一种矢量格式，它能很好地适配各种分辨率的屏幕。除此之外，SVG格式提供了一套丰富的图形效果，这些效果以前仅在Photoshop、GIMP和Sketch等图像编辑软件中才有。
- en: Until recently, however, using those graphical effects in browsers wasn’t practical;
    live image effects are computationally intensive, and using them on the Web would
    have negatively affected performance. Today, however, browsers have become much
    faster and more capable, with almost all rendering graphics directly on the device’s
    GPU. This advance allows for the hardware-accelerated display of transformations
    and animations and unlocks the potential to use the rich graphical effects of
    SVG.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，直到最近，在浏览器中使用这些图形效果并不实际；实时图像效果计算密集，使用它们会对Web性能产生负面影响。然而，如今浏览器的速度和能力大大提升，几乎所有图形渲染都直接在设备的GPU上进行。这一进展使得硬件加速的变换和动画显示成为可能，也释放了使用SVG丰富图形效果的潜力。
- en: 'As browsers implemented SVG graphics effects, it became somewhat of a no-brainer
    to also give other web technologies access to them. So, in this chapter, you’ll
    learn about three features that make SVG’s graphical potential available to CSS:
    *blend modes*, *filter effects*, and *masking*. These nondestructive effects only
    alter the way images are displayed on the page; they don’t modify the source images.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着浏览器实现了SVG图形效果，允许其他Web技术也能够访问这些效果变得非常自然。因此，在本章中，你将了解三个使SVG图形潜力可用于CSS的特性：*混合模式*、*滤镜效果*和*遮罩*。这些非破坏性效果只会改变图像在页面上的显示方式；它们不会修改源图像。
- en: '**NOTE**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Many SVG effects involve variations of color, which are very difficult to
    portray in black and white. I strongly encourage you to see examples of the effects
    yourself at* [http://thebookofcss3.com/](http://thebookofcss3.com/).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多SVG效果涉及颜色的变化，这些变化在黑白显示中很难呈现。我强烈建议你亲自查看这些效果的示例，访问* [http://thebookofcss3.com/](http://thebookofcss3.com/)。'
- en: '**Blend Modes**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**混合模式**'
- en: If you’ve used professional-grade image-editing software like Photoshop or GIMP,
    you may already be familiar with blend modes. Blend modes are a way to mix an
    image into a solid color or another image so the two appear merged or blended.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过专业级的图像编辑软件，比如Photoshop或GIMP，你可能已经熟悉混合模式。混合模式是一种将图像与纯色或其他图像混合的方式，让两者看起来融合或混合在一起。
- en: 'Various blend modes are available, each of which blends images in different
    ways, according to various algorithms. The available modes in CSS are defined
    in the Compositing and Blending Module (*[http://www.w3.org/TR/compositing-1/](http://www.w3.org/TR/compositing-1/)*).
    I can’t cover all of the modes in detail due to a lack of space, so I’ll concentrate
    on three:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了多种混合模式，每种模式根据不同的算法以不同的方式混合图像。CSS中可用的模式定义在《合成与混合模块》(*[http://www.w3.org/TR/compositing-1/](http://www.w3.org/TR/compositing-1/)*)。由于篇幅限制，我无法详细介绍所有模式，因此将集中讲解三种：
- en: '**Screen** In this mode, whites remain white, whereas black lets the background
    color show through. As a result of applying this mode, images tend to become lighter.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**屏幕** 在此模式下，白色保持白色，而黑色则让背景色透过。因此，应用此模式后，图像通常会变得更亮。'
- en: '**Multiply** This mode tends to produce darker images. Blacks remain black,
    whereas whites let the background color pass through.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**叠加** 该模式在“屏幕”与“叠加”模式之间找到平衡。高光和阴影得以保留，增强了对比度。'
- en: '**Overlay** The Overlay mode strikes a balance between the Screen and Multiply
    modes. Highlights and shadows are preserved, increasing contrast.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**覆盖** 该模式在“屏幕”和“叠加”模式之间取得了平衡。高光和阴影被保留下来，从而增强了对比度。'
- en: The remaining blend modes are generally variations on these three. You can read
    a full explanation of each in the spec or see a good visual introduction on *[http://dev.opera.com/articles/getting-to-know-css-blend-modes/](http://dev.opera.com/articles/getting-to-know-css-blend-modes/)*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的混合模式通常是这三种的变体。你可以在规格文档中阅读每种模式的详细说明，或者查看一个很好的视觉介绍，链接地址为 *[http://dev.opera.com/articles/getting-to-know-css-blend-modes/](http://dev.opera.com/articles/getting-to-know-css-blend-modes/)*。
- en: '***background-blend-mode***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***background-blend-mode***'
- en: 'The `background-blend-mode` property is used to blend the background layers
    of an element; for example, you might use it to blend the background color with
    the background image. This property works solely in the context of the element:
    Only the background layers are blended; the element itself doesn’t blend with
    any part of the page below it. The property requires as a value the keyword of
    the blend mode you want to use, such as `screen`, `multiply`, or `overlay`. For
    example, here’s how to apply the Multiply blend mode:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`background-blend-mode` 属性用于混合元素的背景层；例如，你可以用它将背景颜色与背景图片混合。此属性仅在元素的上下文中工作：只有背景层会被混合；元素本身不会与其下方的页面部分混合。该属性的值需要是你想要使用的混合模式的关键词，如
    `screen`、`multiply` 或 `overlay`。例如，下面是如何应用 Multiply 混合模式：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The default value of `background-blend-mode` is `normal`, which leaves the background
    layer unblended.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`background-blend-mode` 的默认值是 `normal`，这意味着背景层不会进行混合。'
- en: '**Blending an Image and a Color**'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**混合图片与颜色**'
- en: 'The simplest way to show how background blend modes work is to blend a background
    image with a background color. The following listing has an element with a background
    image and color applied and is set to use the Screen blend mode:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 展示背景混合模式如何工作的最简单方法是将背景图片与背景颜色混合。下面的代码展示了一个元素，应用了背景图片和颜色，并设置为使用 Screen 混合模式：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Figure 18-1](ch18.html#ch18fig1) shows the result of this and other blend
    modes. Image (A) at top left has no blend mode applied and is provided as a reference.
    The other images each have a different blend mode keyword applied, namely `screen`
    (B), `multiply` (C), and `overlay` (D). (Note that in this case the Overlay mode
    just puts a solid color over the image, which is far from ideal; Overlay blend
    modes are much more useful when blending two images.)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-1](ch18.html#ch18fig1) 显示了此效果和其他混合模式的结果。左上角的图像（A）没有应用任何混合模式，作为参考提供。其他图像分别应用了不同的混合模式关键词，即
    `screen`（B）、`multiply`（C）和 `overlay`（D）。（注意，在这种情况下，Overlay 模式只是将纯色覆盖在图像上，效果远不如预期；Overlay
    混合模式在混合两张图片时要更有用。）'
- en: '![Image](graphics/f18-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f18-01.jpg)'
- en: '*Figure 18-1: Comparing different blend modes applied to a source image*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-1：比较应用不同混合模式的源图像*'
- en: '**Blending Two Images**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**混合两张图片**'
- en: 'In addition to blending a background image layer with a color layer, you can
    also blend a background image layer with other background image layers. To do
    so, apply multiple background images (as discussed in [Chapter 8](ch08.html#ch08))
    and then set the blend mode as before:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将背景图片层与颜色层混合外，你还可以将背景图片层与其他背景图片层混合。要做到这一点，首先应用多个背景图片（如 [第 8 章](ch08.html#ch08)
    所讨论的），然后像之前一样设置混合模式：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Figure 18-2](ch18.html#ch18fig2) shows examples of blending two images. Each
    image has different blend mode keywords applied. From left to right, these are
    `screen`, `multiply`, and `overlay`. (If you’re looking at the example files using
    a desktop browser, hover your mouse over the elements to show the two different
    background images that I’ve used.)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-2](ch18.html#ch18fig2) 显示了混合两张图片的示例。每张图片应用了不同的混合模式关键词。从左到右，分别是 `screen`、`multiply`
    和 `overlay`。（如果你在桌面浏览器中查看示例文件，鼠标悬停在元素上，可以看到我使用的两张不同背景图片。）'
- en: '![Image](graphics/f18-02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f18-02.jpg)'
- en: '*Figure 18-2: Blending multiple background image layers*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-2：多背景图片层的混合*'
- en: Notice that I’ve set a transparent background color on the element. If I hadn’t,
    the `multiply` keyword would have made the lower background image layer blend
    with the background color and then blend with the other image layer, creating
    a different effect than what I intended.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已在元素上设置了透明的背景颜色。如果没有这样做，`multiply` 关键词会让下层背景图片与背景颜色混合，然后再与其他图片层混合，从而产生与我原本想要的效果不同的结果。
- en: '**Multiple Blend Modes**'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**多种混合模式**'
- en: Since you can add multiple background images to an element, it follows that
    you can apply a blend mode to each layer. To do so, you need only list the required
    blend modes in a comma-separated list of values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以为一个元素添加多个背景图像，因此你可以为每一层应用混合模式。为此，你只需在一个逗号分隔的值列表中列出所需的混合模式。
- en: 'In the following code, the element has three background layers: two images
    and a color. I’ve applied two blend mode keywords: Multiply mode will be used
    to blend the background color with *foo.png*; the result will be blended with
    *bar.png* using the Screen blend mode.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，该元素有三个背景层：两张图像和一种颜色。我已经应用了两个混合模式关键词：Multiply 模式将用于将背景颜色与 *foo.png* 混合；结果将与
    *bar.png* 使用 Screen 混合模式混合。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**NOTE**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As with the other multiple background properties, having fewer values on the*
    `*background-blend-mode*` *property than there are background layers will make
    the value list loop.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*与其他多个背景属性一样，如果 `*background-blend-mode*` 属性的值比背景层数少，则该值列表会循环。*'
- en: Varying the blend modes can produce dramatically different results. For example,
    [Figure 18-3](ch18.html#ch18fig3) shows a number of combinations applied to different
    elements with identical background layers. The element on the left uses the Screen
    mode on the top image layer and Multiply mode on the lower; the element in the
    middle uses Multiply mode on the upper image layer and Overlay on the lower; and
    on the right, Overlay mode is applied on the upper and Screen on the lower. As
    you can see, the results are quite different.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 改变混合模式可以产生截然不同的效果。例如，[图 18-3](ch18.html#ch18fig3) 显示了多种组合应用于不同元素，背景层相同。左侧的元素在顶部图像层使用
    Screen 模式，在底部使用 Multiply 模式；中间的元素在顶部图像层使用 Multiply 模式，在底部使用 Overlay 模式；右侧的元素在顶部使用
    Overlay 模式，在底部使用 Screen 模式。正如你所看到的，结果差异显著。
- en: '![Image](graphics/f18-03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f18-03.jpg)'
- en: '*Figure 18-3: Applying multiple blend modes in different combinations*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-3：以不同的组合应用多个混合模式*'
- en: '***mix-blend-mode***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***mix-blend-mode***'
- en: Although blending background layers is undoubtedly useful, the real power lies
    in blending one element with another. In CSS3, you do this with the `mix-blend-mode`
    property. When applied to an element, this property blends the content of the
    element with the content and background of any elements that are directly behind
    it on the screen.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管混合背景图层无疑是有用的，但真正的强大之处在于将一个元素与另一个元素进行混合。在 CSS3 中，你可以通过 `mix-blend-mode` 属性来实现这一点。应用于元素时，该属性会将元素的内容与屏幕上直接位于其后方的任何元素的内容和背景混合。
- en: 'To understand how this differs from `background-blend-mode`, let’s see a quick
    example. In the following listing, I apply a background image to element `*E*`
    and the Multiply blend mode to element `*F*`, nested inside `*E*`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这与 `background-blend-mode` 的区别，让我们看一个简单的例子。在下面的代码中，我为元素 `*E*` 应用一个背景图像，并为嵌套在
    `*E*` 内的元素 `*F*` 应用 Multiply 混合模式：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Figure 18-4](ch18.html#ch18fig4) shows the result, along with other blend
    modes for comparison. The element at top left (A) has no blend mode applied and
    is used as a reference; the remaining three each have blend mode keywords applied:
    `screen` (B), `multiply` (C), and `overlay` (D).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-4](ch18.html#ch18fig4) 显示了结果，并进行其他混合模式的比较。左上角的元素（A）没有应用混合模式，用作参考；其余三个分别应用了混合模式关键词：`screen`（B）、`multiply`（C）和
    `overlay`（D）。'
- en: '![Image](graphics/f18-04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f18-04.jpg)'
- en: '*Figure 18-4: Different blend modes applied to the text element, mixed with
    the background of its parent*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-4：应用于文本元素的不同混合模式，与其父元素的背景混合*'
- en: '***isolation***'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '***隔离***'
- en: 'When using `mix-blend-mode`, be aware that it will blend with *every* visual
    element drawn behind it on the screen, which can cause unintended consequences.
    For example, say you have the following markup structure, in which an `img` element
    is nested inside a `div`, inside the `body`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mix-blend-mode` 时，请注意，它会与屏幕上绘制在其后面的 *每个* 可视元素进行混合，这可能会导致意外的后果。例如，假设你有以下标记结构，其中
    `img` 元素嵌套在 `div` 内，而 `div` 又嵌套在 `body` 内：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now you set a background image on the `body` and the `mix-blend-mode` property
    on the `img`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你在 `body` 上设置一个背景图像，并在 `img` 上设置 `mix-blend-mode` 属性：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, the `img` will blend with the body because the `div` is transparent,
    as shown in the example on the left of [Figure 18-5](ch18.html#ch18fig5).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`img` 将与 `body` 混合，因为 `div` 是透明的，如 [图 18-5](ch18.html#ch18fig5) 左侧的示例所示。
- en: '![Image](graphics/f18-05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f18-05.jpg)'
- en: '*Figure 18-5: Isolating an element to set a new stacking context*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-5：隔离一个元素以设置新的堆叠上下文*'
- en: 'If the result isn’t exactly what you want, you can make an element create a
    new stacking context,^([1](footnote.html#footnote2)) similar to the way setting
    `position: relative` on an element resets the coordinates for absolute positioning.
    When blending, this process is called *isolating* the element, and you use the
    `isolation` property:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '如果结果不是你想要的，你可以使一个元素创建一个新的堆叠上下文，^([1](footnote.html#footnote2))，类似于将 `position:
    relative` 设置在元素上时会重置绝对定位的坐标。混合时，这一过程称为 *隔离* 元素，你需要使用 `isolation` 属性：'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The default value is `auto`, but to create the new stacking context, you must
    use the alternate value, `isolate`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是 `auto`，但要创建新的堆叠上下文，你必须使用另一个值 `isolate`：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see the difference in the example on the right of [Figure 18-5](ch18.html#ch18fig5).
    The `div` is isolated and a new stacking context created, so the `img` is blended
    only with the transparent parent. As a result, you don’t see the background image
    of the `body` as in the example on the left.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [图18-5](ch18.html#ch18fig5) 右侧的示例中看到差异。`div` 被隔离，并创建了一个新的堆叠上下文，因此 `img`
    只与透明的父元素进行混合。因此，你不会像左侧示例中那样看到 `body` 的背景图像。
- en: '**Filter Effects**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**滤镜效果**'
- en: 'Like blend modes, filters are a common part of professional image-editing software.
    Filters are used to change an element’s appearance before it reaches the page,
    and unlike blend modes, they don’t rely on the interaction of two components.
    CSS filters are defined in the CSS Filter Effects Module (*[http://www.w3.org/TR/filter-effects-1/](http://www.w3.org/TR/filter-effects-1/)*)
    and are applied using the `filter` property, shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 像混合模式一样，滤镜是专业图像编辑软件中的常见部分。滤镜用于在元素到达页面之前改变其外观，并且与混合模式不同，它们不依赖于两个组件的交互。CSS 滤镜在
    CSS 滤镜效果模块中定义 (*[http://www.w3.org/TR/filter-effects-1/](http://www.w3.org/TR/filter-effects-1/)*)，并通过
    `filter` 属性应用，如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `*function*` value is at least one of a range of nine filter effect functions.
    Each accepts a single argument, except when a series of arguments is required
    (in a space-separated list). I discuss each one here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`*function*` 值至少是九种滤镜效果函数中的一种。每个函数接受一个参数，除非需要一系列参数（以空格分隔的列表）。我在这里讨论每一个函数。'
- en: '***blur()***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***blur()***'
- en: 'Applies a blur effect to an element. The argument for the `blur()` function
    is a unit of length that controls the radius of the blur. The effect is called
    *Gaussian blur*—a kind of image smoothing that reduces noise in the image. The
    higher the radius value, the greater the blur effect. For example, to create a
    blur of radius 10px, you use this code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对元素应用模糊效果。`blur()` 函数的参数是一个长度单位，用于控制模糊的半径。该效果被称为 *高斯模糊*——一种图像平滑效果，可以减少图像中的噪点。半径值越大，模糊效果越明显。例如，要创建半径为
    10px 的模糊效果，你可以使用以下代码：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see the blur effect in action in [Figure 18-6](ch18.html#ch18fig6).
    The unfiltered image is on the left; the `blur()` filter has been applied to the
    image on the right.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [图18-6](ch18.html#ch18fig6) 中看到模糊效果的实际应用。左侧是未经过滤的图像；右侧是应用了 `blur()` 滤镜的图像。
- en: '![Image](graphics/f18-06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f18-06.jpg)'
- en: '*Figure 18-6: Applying a Gaussian blur filter*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-6：应用高斯模糊滤镜*'
- en: '***brightness() and contrast()***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***brightness() 和 contrast()***'
- en: 'The `brightness()` function changes the brightness of an element, whereas the
    `contrast()` function increases or decreases the contrast between the dark and
    light of an element. Both functions take a percentage as an argument. Here’s an
    example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`brightness()` 函数改变元素的亮度，而 `contrast()` 函数增加或减少元素的明暗对比度。这两个函数都接受百分比作为参数。以下是一个示例：'
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In both cases, an argument of `100%` leaves the element unchanged. An argument
    of `0%` for `brightness()` makes the element fully black, and `0%` for `contrast()`
    makes the element fully gray. You can use values in excess of `100%` to increase
    the brightness and contrast as necessary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`100%` 的参数使元素保持不变。`brightness()` 的 `0%` 参数使元素完全黑色，而 `contrast()` 的 `0%`
    参数使元素完全灰色。你可以使用超过 `100%` 的值来增加亮度和对比度。
- en: '**NOTE**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can also use a number for this function, with* `*1*` *being equivalent
    to* `*100%*`, `*1.5*` *to* `*150%*`*, and so on. The same applies to all other
    functions that accept percentage values.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*你也可以为这个函数使用一个数字，其中* `*1*` *相当于* `*100%*`，`*1.5*` *相当于* `*150%*`*，以此类推。所有其他接受百分比值的函数也适用此规则。*'
- en: '[Figure 18-7](ch18.html#ch18fig7) shows examples of both functions. The first
    image has no filter applied and is shown as a reference. The middle image has
    the `brightness()` function applied, and the image on the right has `contrast()`—each
    function has an argument of `50%`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-7](ch18.html#ch18fig7) 展示了两个函数的示例。第一张图片没有应用任何滤镜，作为参考展示。中间的图片应用了 `brightness()`
    函数，右侧的图片应用了 `contrast()` 函数—每个函数的参数都是 `50%`。'
- en: '![Image](graphics/f18-07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f18-07.jpg)'
- en: '*Figure 18-7: Adjusting brightness and contrast with CSS filter effects*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-7：使用 CSS 滤镜效果调整亮度和对比度*'
- en: '***grayscale(), sepia(), and saturate()***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***grayscale(), sepia(), 和 saturate()***'
- en: The next three functions all deal with color. The `grayscale()` function gives
    you a way to replace colors with shades of gray so you can convert images to black
    and white. The `sepia()` toning function is similar to `grayscale()`, except it
    uses a gold tint to produce a vintage photo effect. Finally, the `saturate()`
    function controls the color intensity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个函数都与颜色处理有关。`grayscale()` 函数提供了一种将颜色替换为灰度的方式，帮助你将图像转换为黑白图像。`sepia()` 着色函数与
    `grayscale()` 类似，只不过它使用金色调来产生复古照片效果。最后，`saturate()` 函数控制颜色的强度。
- en: 'Each of the functions accepts a percentage value as an argument:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都接受一个百分比值作为参数：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A value of `100%` for the `grayscale()` function makes an image completely black
    and white. Passing `100%` to the `sepia()` function makes an image fully sepia
    toned. In the case of both functions, a value of `0%` leaves the image unchanged,
    whereas values greater than `100%` are treated as `100%`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`grayscale()` 函数的 `100%` 值使图像完全黑白。将 `100%` 传递给 `sepia()` 函数会使图像完全呈现褐色调。在这两个函数中，`0%`
    会保持图像不变，而大于 `100%` 的值将被当作 `100%` 处理。'
- en: The `saturate()` function also accepts a percentage as an argument, but it works
    differently from `grayscale()` and `sepia()`. A value of `0%` makes an image appear
    fully unsaturated—or grayscale—whereas values greater than `100%` oversaturate
    the image.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`saturate()` 函数也接受一个百分比值作为参数，但它的工作原理与 `grayscale()` 和 `sepia()` 不同。`0%` 会让图像完全去饱和—也就是灰度图像，而大于
    `100%` 的值会使图像过度饱和。'
- en: '**NOTE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To see these functions in action, view example file 18-a on this book’s companion
    website* ([http://thebookofcss3.com/](http://thebookofcss3.com/)).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*要查看这些函数的实际效果，请访问本书配套网站上的示例文件 18-a* ([http://thebookofcss3.com/](http://thebookofcss3.com/))。'
- en: '***hue-rotate()***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***hue-rotate()***'
- en: 'The prosaically named `hue-rotate()` function is used to rotate the hue of
    an element. Recall from “[Hue, Saturation, Lightness](ch10.html#ch10leve1sec119)”
    on [page 116](ch10.html#page_116) that color hue is calculated from an angle around
    the axis of the color wheel. Therefore, the required argument to the `hue-rotate()`
    function is a degree, like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`hue-rotate()` 函数名虽然平凡，但它用于旋转元素的色调。回想一下在 “[色相、饱和度、亮度](ch10.html#ch10leve1sec119)”
    中提到的内容，在 [第116页](ch10.html#page_116)，色相是通过围绕色轮轴的角度来计算的。因此，`hue-rotate()` 函数所需的参数是一个度数，像这样：'
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Applying `hue-rotate()` actually shifts the hue of all colors in an element
    around the color wheel by the same amount. To see this function in action, view
    example file 18-b on this book’s website.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 `hue-rotate()` 函数实际上是将元素中所有颜色的色调按相同的角度围绕色轮进行旋转。要查看该函数的实际效果，请访问本书网站上的示例文件
    18-b。
- en: '***opacity()***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***opacity()***'
- en: 'The `opacity()` function works the same as the `opacity` property introduced
    in [Chapter 10](ch10.html#ch10). The function accepts a percentage value as an
    argument, with `0%` equal to fully transparent and `100%` equal to fully opaque:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`opacity()` 函数的工作方式与 [第10章](ch10.html#ch10) 中介绍的 `opacity` 属性相同。该函数接受一个百分比值作为参数，其中
    `0%` 代表完全透明，`100%` 代表完全不透明：'
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Values greater than `100%` are treated as `100%`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大于 `100%` 的值将被当作 `100%` 处理。
- en: If the result of the `opacity()` function is identical to that of the `opacity`
    property, why bother using it at all? Because you can combine it with the other
    filter effect functions, as you’ll see shortly in “[Multiple Filter Effect Functions](ch18.html#ch18leve1sec250)”
    on [page 234](ch18.html#page_234).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `opacity()` 函数的结果与 `opacity` 属性完全相同，那为什么还要使用它呢？因为你可以将它与其他滤镜效果函数结合使用，正如你将在
    “[多个滤镜效果函数](ch18.html#ch18leve1sec250)” 中看到的，详见 [第234页](ch18.html#page_234)。
- en: '***drop-shadow()***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***drop-shadow()***'
- en: 'At first, the `drop-shadow()` function may seem to be the same as the `box-shadow`
    property, introduced in [Chapter 9](ch09.html#ch09). Indeed, it even takes the
    same values as arguments: an x-offset, y-offset, blur radius, and shadow color.
    Here’s an example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，`drop-shadow()` 函数可能看起来与第 [9 章](ch09.html#ch09) 中介绍的 `box-shadow` 属性相同。实际上，它接受与
    `box-shadow` 相同的值作为参数：x 偏移量、y 偏移量、模糊半径和阴影颜色。以下是一个示例：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The biggest difference between the two is that the `drop-shadow()` function
    is aware of any alpha value (opacity) in the target element. You can see the difference
    clearly in [Figure 18-8](ch18.html#ch18fig8). The target image has a transparent
    background, so in the image at left (which has the `drop-shadow()` function applied),
    the drop box follows the outline of the image. The image on the right, however,
    has the `box-shadow` property applied. Because the `box-shadow` property doesn’t
    care about alpha transparency, the shadow follows only the outline of the box.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者之间最大的区别是 `drop-shadow()` 函数会识别目标元素的任何 alpha 值（透明度）。你可以在 [图 18-8](ch18.html#ch18fig8)
    中清晰地看到这种区别。目标图像具有透明背景，因此在应用了 `drop-shadow()` 函数的左侧图像中，阴影框跟随图像的轮廓。而右侧的图像则应用了 `box-shadow`
    属性。由于 `box-shadow` 属性不考虑 alpha 透明度，阴影只跟随盒子的轮廓。
- en: '![Image](graphics/f18-08.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f18-08.jpg)'
- en: '*Figure 18-8: Comparing the* `*drop-shadow()*` *filter (left) with the* `*box-shadow*`
    *property (right)*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-8：比较* `*drop-shadow()*` *滤镜（左）与* `*box-shadow*` *属性（右）*'
- en: '***Multiple Filter Effect Functions***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多个滤镜效果函数***'
- en: 'You can apply multiple filter effect functions to an element by simply listing
    them in a space-separated list. For example, you could add both blur and a drop
    shadow to an element:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将多个滤镜效果函数按空格分隔列出，来应用多个滤镜效果函数。例如，你可以同时向元素添加模糊和投影效果：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The order in which you list the functions is important, as that’s the order
    in which they’ll be applied. For example, in this next listing two filter effects
    are applied, but I’ve changed the order: in the first, the `gray-scale()` function
    is applied before `sepia()`, and in the second, I’ve reversed it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 函数列出的顺序很重要，因为它们将按照此顺序应用。例如，在接下来的示例中，应用了两个滤镜效果，但我更改了顺序：在第一个示例中，`gray-scale()`
    函数先于 `sepia()` 应用，而在第二个示例中，我将其顺序颠倒了：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the first example, the `sepia()` function will be applied and then `grayscale()`,
    so all the colors of the `sepia()` filter effect will be converted to grayscale.
    In the second, the `grayscale()` function will be applied and then `sepia()`,
    so the colors of the `sepia()` filter effect will show. Example file 18-c on this
    book’s website shows how this appears.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，`sepia()` 函数将先应用，然后是 `grayscale()`，因此 `sepia()` 滤镜效果的所有颜色都会转换为灰度。第二个示例中，`grayscale()`
    函数先应用，再是 `sepia()`，所以 `sepia()` 滤镜效果的颜色会显示。此书网站上的示例文件 18-c 显示了这种效果。
- en: 'Like CSS Transforms (introduced in [Chapter 12](ch12.html#ch12)), when you
    list multiple functions in the `filter` property, any functions not in the list
    will have their values returned to the default. For example, in the following
    listing, the element loses its `sepia()` filter effect on hover:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 CSS 变换（在 [第 12 章](ch12.html#ch12) 中介绍）一样，当你在 `filter` 属性中列出多个函数时，列表中未列出的任何函数将返回默认值。例如，在以下示例中，当元素悬停时，它失去了
    `sepia()` 滤镜效果：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***Filters in SVG***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SVG 中的滤镜***'
- en: 'Recall that CSS filter effects are simply shorthand for SVG filter presets.
    The Filter Effects Module shows the markup equivalents for all of the CSS functions.
    For example, the SVG markup for the `blur()` filter looks like the following (the
    `*blur-radius*` value is a unitless number):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，CSS 滤镜效果实际上是 SVG 滤镜预设的简写。滤镜效果模块显示了所有 CSS 函数的标记等价物。例如，`blur()` 滤镜的 SVG 标记如下所示（`*blur-radius*`
    值是无单位的数字）：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can create your own filters in SVG and apply them in CSS by using an ID
    reference. The first step is to add an ID value to your filter:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 SVG 中创建自己的滤镜，并通过使用 ID 引用在 CSS 中应用它们。第一步是为你的滤镜添加一个 ID 值：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then refer to it in your CSS using the `url()` notation, containing the ID
    reference, as a value for the `filter` property. If your SVG is in line with the
    markup in your document, you need only the ID reference:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的 CSS 中使用 `url()` 表示法，包含 ID 引用，作为 `filter` 属性的值。如果你的 SVG 与文档中的标记 inline，则只需要
    ID 引用：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If your SVG is in an external asset file (say, *filters.svg*), state the path
    to that file followed by the ID reference:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 SVG 在外部资产文件中（例如，*filters.svg*），则需要指定该文件的路径，并跟上 ID 引用：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Unlike CSS filter effects, this technique only works for a single filter. To
    apply multiple filters to an element, you have to combine them in the SVG markup
    first.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSS滤镜效果不同，这种技术只适用于单个滤镜。要将多个滤镜应用到一个元素，必须先在SVG标记中将它们组合起来。
- en: '**Masking**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**遮罩**'
- en: Masking is a technique in which certain parts of an element are hidden from
    view. There are two approaches `to masking:` clipping, where the area that’s hidden
    is set by a polygonal shape that’s overlaid on an element, and image masking,
    where an image’s alpha channel is used to set the hidden area.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 遮罩是一种技术，其中元素的某些部分被隐藏。遮罩有两种方法：剪切，隐藏区域由一个覆盖在元素上的多边形形状设置，以及图像遮罩，使用图像的 alpha 通道来设置隐藏区域。
- en: '***Clipping***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***剪切***'
- en: 'Clipping is the simplest form of masking. When clipping, a shape is laid over
    an image and any parts of the element that are behind the shape will be shown,
    while any parts outside the boundaries of the shape will be hidden. The boundary
    of the shape is called the *clip path* and is created with the `clip-path` property:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 剪切是最简单的遮罩形式。在剪切时，一个形状覆盖在图像上，任何位于形状后面的元素部分会被显示，而任何超出形状边界的部分则会被隐藏。形状的边界被称为*剪切路径*，可以通过`clip-path`属性来创建：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `*shape*` can be one of four basic types, each of which is represented
    by a function: `circle()`, `ellipse()`, `inset()` (for rectangles), and `polygon()`.
    Each function takes a number of arguments, which define the clip path. For example,
    to create a circle, you supply three arguments to the `circle()` function, using
    a syntax like that for radial gradients (see [Chapter 11](ch11.html#ch11)):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`*shape*`可以是四种基本类型中的一种，每种类型通过一个函数来表示：`circle()`、`ellipse()`、`inset()`（用于矩形）和`polygon()`。每个函数接受多个参数，用于定义剪切路径。例如，要创建一个圆形，您需要为`circle()`函数提供三个参数，使用类似径向渐变的语法（参见[第11章](ch11.html#ch11)）：'
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `*r*` represents the radius of the circle, and `*cx*` and `*cy*` are the
    coordinates of its center. So to clip an element to a 100px circle positioned
    at the center of the target, you use these values:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`*r*`表示圆形的半径，而`*cx*`和`*cy*`是圆心的坐标。因此，要将元素裁剪为位于目标中心的100px圆形，您需要使用以下值：'
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `ellipse()` function is very similar, requiring only an extra argument
    to set the radii of the ellipse:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`ellipse()`函数非常相似，只需要额外一个参数来设置椭圆的半径：'
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here `*rx*` is used to represent the *x*-axis of the radius, and `*ry*` the
    *y*-axis. To create an ellipse with a radius of 50px and 100px, again at the center
    of the target, you use these values:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`*rx*`用来表示半径的* x *轴，`*ry*`表示* y *轴。要创建一个半径为50px和100px的椭圆，并且将其放置在目标的中心位置，您需要使用这些值：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To see how these appear in practice, take a look at [Figure 18-9](ch18.html#ch18fig9).
    The example on the left uses the `circle()` function with the values used earlier,
    and on the right, `ellipse()`, also with the values used earlier.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些在实际中的效果，请参见[图18-9](ch18.html#ch18fig9)。左侧的示例使用`circle()`函数，采用前面使用的值，右侧则使用`ellipse()`，同样采用前面使用的值。
- en: '![Image](graphics/f18-09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f18-09.jpg)'
- en: '*Figure 18-9: Function values for the* `*clip-path*` *property:* `*circle()*`
    *(left) and* `*ellipse()*` *(right)*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-9：`*clip-path*`属性的函数值：* `*circle()*` *（左）和* `*ellipse()*` *（右）*'
- en: As mentioned earlier, the `inset()` function is used to create a rectangle that
    is inset from the border of the element to which it is applied. It can accept
    up to 12 (!) arguments. The first four arguments set the distance that each side
    of the rectangle is offset—just like the `border-image-slice` property (see [Chapter
    9](ch09.html#ch09)). So a single value will set the offset distance equally on
    all sides; if two values are supplied, the first will set the top and bottom and
    the second the left and right; and so on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`inset()`函数用于创建一个从应用它的元素边框内缩的矩形。它可以接受最多12个参数！前四个参数设置矩形每一边的偏移距离——就像`border-image-slice`属性一样（参见[第9章](ch09.html#ch09)）。因此，单个值会在所有边上设置相等的偏移距离；如果提供两个值，第一个设置上下偏移，第二个设置左右偏移；以此类推。
- en: 'If we were to use all four values, the syntax would look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用所有四个值，语法将如下所示：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Each `*o**` represents an offset value (the top, right, bottom and left, respectively).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`*o**`表示一个偏移值（分别对应上、右、下、左）。
- en: 'In its simplest format, a single value would create four equal offsets, as
    in this case, where each offset value is 2em:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的格式下，单个值会创建四个相等的偏移量，如此例所示，每个偏移量值为2em：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also round the corners of the clip path, which is where the remaining
    arguments come in. Following the `round` keyword, you can use syntax identical
    to that of the `border-radius` property (see [Chapter 9](ch09.html#ch09)) to define
    a radius for each corner—with up to eight values for fine control. To prevent
    my having to repeat the explanation of the `border-radius` short-hand here, this
    example shows how you’d set a radius of 20px on each corner of the inset rectangle
    defined earlier:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以圆化剪切路径的角落，这时剩下的参数就派上用场了。在 `round` 关键字之后，你可以使用与 `border-radius` 属性相同的语法（请参见[第9章](ch09.html#ch09)）来定义每个角的半径——最多可以设置八个值来进行精细控制。为了避免在这里重复解释
    `border-radius` 的简写语法，本例展示了如何为之前定义的内嵌矩形的每个角设置20px的半径：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: See the result in [Figure 18-10](ch18.html#ch18fig10). The example on the left
    shows a rectangle with right-angled corners, and on the right, a rectangle with
    rounded corners.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[图18-10](ch18.html#ch18fig10)中的结果。左侧示例显示的是一个有直角的矩形，右侧则是一个有圆角的矩形。
- en: '![Image](graphics/f18-10.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f18-10.jpg)'
- en: '*Figure 18-10: The* `*inset()*` *function without (left) and with (right) border
    radius values*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-10：没有（左）和有（右）边框圆角值的* `*inset()*` *函数*'
- en: 'You can use the `polygon()` function to create more complex clip paths. This
    function takes an unlimited number of arguments, in pairs, in a comma-separated
    list. Each pair creates a coordinate value, and the full set of coordinates is
    used to draw the required clip shape. As a very simple example, this syntax defines
    the three points of a triangle:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `polygon()` 函数来创建更复杂的剪切路径。该函数接受任意数量的参数，成对出现，以逗号分隔的列表形式传递。每一对参数代表一个坐标值，所有坐标值组合起来用于绘制所需的剪切形状。举个简单的例子，这个语法定义了一个三角形的三个点：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The triangle’s points are at the left top, left bottom, and right top of the
    target element. You can see how this is clipped in [Figure 18-11](ch18.html#ch18fig11).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形的三个顶点位于目标元素的左上角、左下角和右上角。你可以在[图18-11](ch18.html#ch18fig11)中看到剪切效果。
- en: '![Image](graphics/f18-11.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f18-11.jpg)'
- en: '*Figure 18-11: A triangular clip path made with the* `*polygon()*` *function*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-11：使用* `*polygon()*` *函数创建的三角形剪切路径*'
- en: '**NOTE**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Clipping an element only changes its visual appearance—the dimensions and
    box model of the element that’s clipped will be unmodified. For a suggestion of
    how this may change in the future, see “[Shapes](ch19.html#ch19leve1sec263)” on
    [page 246](ch19.html#page_246).*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*剪切元素仅改变其视觉外观——被剪切元素的尺寸和盒模型不会被修改。有关此功能未来可能变化的建议，请参见 “[Shapes](ch19.html#ch19leve1sec263)”
    第246页（[page 246](ch19.html#page_246)）。*'
- en: '**Implementation of clip-path in Safari**'
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Safari中clip-path的实现**'
- en: 'The `clip-path` property was implemented in Safari 7, with a vendor prefix,
    but using a now-outdated version of the syntax (the updated syntax was implemented
    in Safari 8). The `polygon()` function works in the same way, but the others are
    slightly different; for example, the `circle()` function looks slightly different,
    requiring three comma-separated arguments:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`clip-path` 属性在 Safari 7 中首次实现，并带有厂商前缀，但使用的是现在已过时的语法版本（更新的语法在 Safari 8 中得以实现）。`polygon()`
    函数的工作方式保持不变，但其他函数稍有不同；例如，`circle()` 函数的语法略有不同，要求三个用逗号分隔的参数：'
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similarly, the `ellipse()` function accepts four arguments:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`ellipse()` 函数接受四个参数：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `inset()` function is known as `inset-rectangle()`, and it requires a minimum
    of four comma-separated values to represent the offset distances:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`inset()` 函数被称为 `inset-rectangle()`，它至少需要四个用逗号分隔的值来表示偏移距离：'
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can round the corners, but the values must be the same for each corner—you
    can’t set an individual value per corner. You can, however, set *x*-axis and *y*-axis
    values to make irregular radii:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以圆化角落，但每个角的值必须相同——不能为每个角设置不同的值。然而，你可以设置 *x* 轴和 *y* 轴的值来创建不规则的圆角半径：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The biggest difference from the standard is in the `rectangle()` function;
    this was originally defined in the spec but has since been pushed back to a future
    version. The `rectangle()` function also lets you create rectangular clipping
    shapes but using coordinates rather than offset values. It accepts up to six arguments:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的最大区别在于 `rectangle()` 函数；这个函数最初在规范中定义，但后来被推迟到未来版本中。`rectangle()` 函数也可以创建矩形剪切形状，但使用坐标而不是偏移值。它最多接受六个参数：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first four arguments are required: `*x*` and `*y*` set the *x*- and *y*-
    coordinates of the top-left corner of the shape, relative to the top-left corner
    of the target element; and `*w*` and `*h*` set the width and height, respectively,
    of the shape. The optional `*rx*` and `*ry*` arguments can be used to set the
    border-radius of all corners of the clip path. (You can use one value to make
    an equal radius, but you can’t set each corner individually.)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个参数是必需的：`*x*` 和 `*y*` 设置形状的左上角的 *x* 和 *y* 坐标，相对于目标元素的左上角；`*w*` 和 `*h*` 分别设置形状的宽度和高度。可选的
    `*rx*` 和 `*ry*` 参数用于设置剪切路径所有角落的圆角半径。（你可以使用一个值来设定相等的半径，但不能单独设置每个角落。）
- en: '[Figure 18-12](ch18.html#ch18fig12) shows how these six values set the clipping
    area of an image.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-12](ch18.html#ch18fig12) 显示了这六个值如何设置图像的剪切区域。'
- en: '![Image](graphics/f18-12.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f18-12.jpg)'
- en: '*Figure 18-12: Six values for the* `*rectangle()*` *shape function that set
    the clipping area*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-12：设置剪切区域的 `*rectangle()*` 形状函数的六个值*'
- en: If we combine these options as shown in the following listing, we would create
    a clip path 10px from the top left of the element it’s set on, with a width of
    50 percent, a height of 100px, and corners with a radius of 20px on both axes.
    [Figure 18-13](ch18.html#ch18fig13) shows what this would look like.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照以下代码组合这些选项，我们将创建一个剪切路径，该路径距离元素的左上角 10px，宽度为 50%，高度为 100px，角落的半径在两个轴上均为
    20px。[图 18-13](ch18.html#ch18fig13) 显示了这将是什么样子。
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Image](graphics/f18-13.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f18-13.jpg)'
- en: '*Figure 18-13: A rectangle made with the* `*rectangle()*` *function of* `*-webkit-clip-path*`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-13：使用 `*rectangle()*` 函数和 `*-webkit-clip-path*` 制作的矩形*'
- en: '**Animating Clip Paths**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**剪切路径动画**'
- en: 'Because clip paths are defined using coordinates, animating them to create
    impressive effects is easy. For example, you can take the triangle polygon defined
    in the previous section and transition it on hover:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于剪切路径是通过坐标定义的，因此动画化它们以创造令人印象深刻的效果变得非常简单。例如，你可以拿前一节中定义的三角形多边形，在鼠标悬停时进行过渡：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this animation, two points of the triangle stay in the same position, while
    the third switches to the corner diagonally opposite. This is animated with a
    transition, causing the effect you see in example file 18-d.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动画中，三角形的两个点保持在相同的位置，而第三个点切换到对角线的另一角落。这通过过渡动画实现，产生了你在示例文件 18-d 中看到的效果。
- en: '**Clip Paths in SVG**'
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SVG 中的剪切路径**'
- en: You can also create clip paths in SVG and apply them to an element using CSS.
    To do so, you first define your clip path markup and then assign it a unique ID.
    For example, the following listing creates a circular clip path using the `clipPath`
    element at the center of the element, with a radius half the width and height.
    It has an ID of `clipping`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 SVG 中创建剪切路径，并通过 CSS 将其应用于元素。为此，你首先定义剪切路径的标记，然后赋予它一个唯一的 ID。例如，以下代码创建了一个圆形剪切路径，该路径使用
    `clipPath` 元素定义，位于元素的中心，半径为宽度和高度的一半。它的 ID 为 `clipping`。
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once defined, I apply this clip path to my element using the `clip-path` property,
    with a value equal to the `url()` notation containing the ID of the clip path:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义好，我会通过 `clip-path` 属性将这个剪切路径应用于我的元素，属性值等于包含剪切路径 ID 的 `url()` 语法：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Unfortunately, this method has drawbacks. For one, as of this writing, it only
    works in Firefox. Also, you can’t animate these shapes without using JavaScript.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法有一些缺点。首先，截止到目前，它仅在 Firefox 中有效。此外，你不能在不使用 JavaScript 的情况下对这些形状进行动画效果处理。
- en: '***Image Masking***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***图像遮罩***'
- en: 'In addition to clipping an element with geometric shapes, you can also mask
    one image with another, using the alpha value of the mask to determine how much
    of the target will be visible. (This process is similar to the way blend modes
    work, except that it uses alpha rather than black and white.) The mask is applied
    using the `mask` property, which takes these values:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用几何形状剪切元素外，你还可以使用另一张图像作为遮罩，利用遮罩的 alpha 值来确定目标中有多少部分是可见的。（这个过程类似于混合模式的工作方式，只是它使用
    alpha 值而不是黑白色。）遮罩是通过 `mask` 属性应用的，它接受以下值：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `*image*` value is the `url()` notation with a path to the image to be
    used as a mask. The properties `*position*` and `*size*` work the same as the
    `background-position` and `background-size` properties (see [Chapter 8](ch08.html#ch08)).
    For example, the following code will set an image called *mask.png* at the center
    of an element, with the mask filling the width of the parent while maintaining
    its original aspect ratio:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`*image*`值是`url()`表示法，指向用作遮罩的图像路径。属性`*position*`和`*size*`的工作方式与`background-position`和`background-size`属性相同（见[第8章](ch08.html#ch08)）。例如，以下代码会将一个名为*mask.png*的图像放置在元素的中心，遮罩填充父元素的宽度，同时保持原始的纵横比：'
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Figure 18-14](ch18.html#ch18fig14) shows the three steps in masking. The target
    image is on the left; the image to be used as a mask is in the middle; and the
    mask applied to the target is on the right.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-14](ch18.html#ch18fig14)展示了遮罩的三个步骤。目标图像在左边；用作遮罩的图像在中间；应用到目标上的遮罩在右边。'
- en: '![Image](graphics/f18-14.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f18-14.jpg)'
- en: '*Figure 18-14: The three steps of image masking*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-14：图像遮罩的三个步骤*'
- en: '**NOTE**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This is a simple mask. The syntax is much more flexible than this, although
    a bit too complicated to explore in detail in this book.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是一个简单的遮罩。语法比这更加灵活，尽管在本书中无法详细探讨，因为它有些复杂。*'
- en: 'The `mask` property is shorthand for a whole range of subproperties, including
    `mask-image`, `mask-position`, and `mask-size`. You can use many more properties
    in addition to these, and the full `mask` shorthand looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`mask`属性是许多子属性的简写，包括`mask-image`、`mask-position`和`mask-size`。除了这些属性外，你还可以使用更多属性，完整的`mask`简写如下：'
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let’s take a brief walk through the unfamiliar properties. The `mask-mode` property
    determines whether the mask should work on the default alpha channel or through
    *luminance* (lightness); `mask-repeat` tiles the mask image just as `background-repeat`;
    `mask-origin` and `mask-clip` also work like their background equivalents (`background-origin`
    and `background-clip` in [Chapter 8](ch08.html#ch08)); and `mask-composite` controls
    how multiple `mask-image` values should interact if they overlap.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单回顾一下这些不太熟悉的属性。`mask-mode`属性决定遮罩是基于默认的alpha通道工作，还是通过*亮度*（光亮度）工作；`mask-repeat`像`background-repeat`一样平铺遮罩图像；`mask-origin`和`mask-clip`也像它们的背景等价物（`background-origin`和`background-clip`在[第8章](ch08.html#ch08)中讨论过）；而`mask-composite`控制多个`mask-image`值在重叠时的交互方式。
- en: '***Border Masking***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***边框遮罩***'
- en: In [Chapter 9](ch09.html#ch09), I introduced the `border-image` property, which
    is used to apply images to the borders of an element. You can use the same basic
    method of slicing an image that we discussed in that context to apply a mask to
    the border of an element.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.html#ch09)中，我介绍了`border-image`属性，用于将图像应用到元素的边框上。你可以使用我们在该章节中讨论的相同方法，通过切片图像来将遮罩应用到元素的边框。
- en: 'The properties involved in border masking are `mask-border-source`, `mask-border-slice`,
    `mask-border-repeat`, `mask-border-width,` and `mask-border-output`. Each can
    be included in the `mask-border` shorthand, and each is identical in function
    to their `border-image-*` counterpart. For example, to set an image *mask.png,*
    with slices of 40px each, which repeats along each side of an element, you use
    this syntax:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与边框遮罩相关的属性有`mask-border-source`、`mask-border-slice`、`mask-border-repeat`、`mask-border-width`和`mask-border-output`。每个属性都可以包含在`mask-border`简写中，并且它们的功能与`border-image-*`对应属性相同。例如，要设置一个名为*mask.png*的图像，切片为每个40px，并沿元素的每一边重复，使用以下语法：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Unfortunately, as of this writing no browser supports this in accordance with
    the spec (though Chrome and Safari support a similar but outdated property called
    `-webkit-mask-box-image`), so I won’t spend any more time discussing border masking.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，截止目前，没有浏览器完全按照规范支持这一功能（虽然Chrome和Safari支持一个类似但过时的属性，叫做`-webkit-mask-box-image`），因此我不会再花时间讨论边框遮罩。
- en: '***Masking in SVG***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SVG中的遮罩***'
- en: 'You can use SVG to mask images, much as you might clip them. To do so, you
    define the mask in markup and then apply it using a CSS property (`mask`). For
    example, the following listing creates a mask of a black box with a white ellipse
    in the center:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用SVG来遮罩图像，就像你可能裁剪它们一样。为此，你需要在标记中定义遮罩，然后使用CSS属性（`mask`）应用它。例如，以下代码创建了一个黑色方框的遮罩，中间有一个白色椭圆：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The next step is to apply the mask to the target element, using the `mask`
    property with a `url()` notation containing the ID of the `mask` element (`masking`):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将遮罩应用到目标元素，使用`mask`属性，并通过`url()`表示法包含`mask`元素（`masking`）的ID：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**NOTE**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For a more in-depth look at masking in SVG and CSS, see Dirk Schulze’s “CSS*
    *Masking”* ([http://www.html5rocks.com/en/tutorials/masking/adobe/](http://www.html5rocks.com/en/tutorials/masking/adobe/)).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*想深入了解 SVG 和 CSS 中的蒙版，请参见 Dirk Schulze 的《CSS* *蒙版》*（[http://www.html5rocks.com/en/tutorials/masking/adobe/](http://www.html5rocks.com/en/tutorials/masking/adobe/)）。'
- en: '**Combining Filter Effects and Masking**'
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结合滤镜效果和蒙版**'
- en: 'Should you want to combine filter effects with masking on the same element,
    it’s important to know that they will be applied in a specific order: filter effects
    are applied first, followed by clipping, then masking, and finally opacity. To
    see the consequence of this order, consider the following listing that applies
    a drop shadow filter and circular clipping path to an element:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将滤镜效果与同一元素的蒙版结合使用，重要的是要知道它们会按特定顺序应用：首先应用滤镜效果，然后是剪裁，接着是蒙版，最后是不透明度。为了看到这个顺序的后果，可以考虑以下代码，它对元素应用了一个阴影滤镜和圆形剪裁路径：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this code, the effects are applied to the image in this order: first, the
    drop shadow is applied; then the image with the drop shadow applied is clipped
    into a circle. To avoid the clipping of the drop shadow, you can apply the filter
    effect to a parent element:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，效果按照以下顺序应用到图像上：首先应用阴影效果；然后将应用了阴影的图像剪裁成圆形。为了避免剪裁掉阴影，你可以将滤镜效果应用到父元素上：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This works because of the way browsers parse the DOM for rendering. The clipping
    of the child element will occur before the filter effect that is inherited from
    the parent. ([Figure 18-15](ch18.html#ch18fig15) compares the two methods.)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以能这样工作，是因为浏览器解析 DOM 渲染的方式。子元素的剪裁会在从父元素继承的滤镜效果之前发生。（[图 18-15](ch18.html#ch18fig15)
    比较了这两种方法。）
- en: '![Image](graphics/f18-15.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f18-15.jpg)'
- en: '*Figure 18-15: Comparing rendering order of graphical CSS effects*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-15：比较图形 CSS 效果的渲染顺序*'
- en: '**Summary**'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Blend modes, filter effects, and masking provide access to web browser features
    that were previously found only in professional photo-imaging software. Each is
    useful on its own, but combine them and designers and developers get a whole new
    way to approach visual design on the Web.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 混合模式、滤镜效果和蒙版为 Web 浏览器提供了以前只有在专业照片处理软件中才能找到的功能。每一种效果单独使用都很有用，但将它们结合起来，设计师和开发者就能以全新的方式进行
    Web 上的视觉设计。
- en: The ability to use graphical effects like these comes thanks to the widespread
    implementation of SVG. The markup that describes an SVG image is already closely
    tied with HTML (it can be dropped into HTML and will be parsed as part of the
    document), and in the future you should see SVG and CSS become much more closely
    tied—we’ve seen that with the graphical effects in this chapter, and modules currently
    in development also describe a shared implementation of the animation properties
    described in [Chapter 14](ch14.html#ch14).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些图形效果的能力得益于 SVG 的广泛应用。描述 SVG 图像的标记与 HTML 紧密相连（可以嵌入 HTML 中，并作为文档的一部分解析），未来你会看到
    SVG 和 CSS 的结合更加紧密——我们已经在本章中的图形效果中看到了这一点，当前正在开发的模块也描述了在[第14章](ch14.html#ch14)中提到的动画属性的共享实现。
- en: '**Blend Modes, Filter Effects, and Masking: Browser Support**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**混合模式、滤镜效果和蒙版：浏览器支持**'
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
- en: '| `background-blend-mode` | Yes | Yes | Safari 8 | No |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `background-blend-mode` | 支持 | 支持 | Safari 8 | 不支持 |'
- en: '| `mix-blend-mode` | No^([*](ch18.html#footnote41a)) | Yes | Safari 8 | No
    |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `mix-blend-mode` | 不支持^([*](ch18.html#footnote41a)) | 支持 | Safari 8 | 不支持
    |'
- en: '| `isolation` | No[*](ch18.html#footnote41a) | No | Safari 8 | No |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `isolation` | 不支持[*](ch18.html#footnote41a) | 不支持 | Safari 8 | 不支持 |'
- en: '| `filter` | Yes^([†](ch18.html#footnote42a)) | No^([‡](ch18.html#footnote43a))
    | Yes^([†](ch18.html#footnote42a)) | No |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | 支持^([†](ch18.html#footnote42a)) | 不支持^([‡](ch18.html#footnote43a))
    | 支持^([†](ch18.html#footnote42a)) | 不支持 |'
- en: '| `clip-path` | Yes[*](ch18.html#footnote41a) | No | Safari 8^([§](ch18.html#footnote44a))
    | No |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `clip-path` | 支持[*](ch18.html#footnote41a) | 不支持 | Safari 8^([§](ch18.html#footnote44a))
    | 不支持 |'
- en: '| `mask` | Yes^([†](ch18.html#footnote42a)) | No | Yes^([†](ch18.html#footnote42a))
    | No |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `mask` | 支持^([†](ch18.html#footnote42a)) | 不支持 | 支持^([†](ch18.html#footnote42a))
    | 不支持 |'
- en: '[*](ch18.html#footnote_41a) Implemented but off by default'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[*](ch18.html#footnote_41a) 已实现，但默认关闭'
- en: '[†](ch18.html#footnote_42a) With vendor prefix'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[†](ch18.html#footnote_42a) 带有厂商前缀'
- en: '[‡](ch18.html#footnote_43a) Can use filters defined in SVG'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[‡](ch18.html#footnote_43a) 可以使用 SVG 中定义的滤镜'
- en: '[§](ch18.html#footnote_44a) With vendor prefix; implemented with outdated syntax
    in Safari 7'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[§](ch18.html#footnote_44a) 带有厂商前缀；在 Safari 7 中使用过时的语法实现'
