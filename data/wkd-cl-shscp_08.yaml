- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**WEB AND INTERNET USERS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**网页和互联网用户**'
- en: '![image](../images/common4.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common4.jpg)'
- en: One area where Unix really shines is the internet. Whether you want to run a
    fast server from under your desk or simply surf the web intelligently and efficiently,
    there’s little you can’t embed in a shell script when it comes to internet interaction.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 真正闪光的一个领域就是互联网。无论你是想在桌子底下运行一个快速的服务器，还是仅仅想高效智能地浏览网页，当涉及到互联网交互时，几乎没有什么是你不能嵌入
    shell 脚本中的。
- en: 'Internet tools are scriptable, even though you might never have thought of
    them that way. For example, FTP, a program that is perpetually trapped in debug
    mode, can be scripted in some very interesting ways, as is explored in [Script
    #53](ch07.xhtml#ch07lev1sec01) on [page 174](ch07.xhtml#page_174). Shell scripting
    can often improve the performance and output of most command line utilities that
    work with some facet of the internet.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '互联网工具是可以脚本化的，即使你可能从未想过它们是这样的。例如，FTP，这个始终处于调试模式的程序，可以用一些非常有趣的方式来编写脚本，这在 [脚本
    #53](ch07.xhtml#ch07lev1sec01) 中有探讨，位于 [第 174 页](ch07.xhtml#page_174)。Shell 脚本通常可以提高大多数命令行工具在与互联网相关的方面的性能和输出。'
- en: The first edition of this book assured readers that the best tool in the internet
    scripter’s toolbox was `lynx`; now we recommend using `curl` instead. Both tools
    offer a text-only interface to the web, but while `lynx` tries to offer a browser-like
    experience, `curl` is designed specifically for scripts, dumping out the raw HTML
    source of any page you’d like to examine.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一版曾向读者保证，互联网脚本编写者工具箱中最好的工具是 `lynx`；现在我们推荐使用 `curl`。这两个工具都提供纯文本界面来访问网页，但
    `lynx` 尝试提供类似浏览器的体验，而 `curl` 则专门为脚本设计，能够提取任何页面的原始 HTML 源代码，供你查看。
- en: 'For example, the following shows the top seven lines of the source from the
    home page of *Dave on Film*, courtesy of `curl`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下显示了通过 `curl` 获取的 *Dave on Film* 首页源代码的前七行：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can accomplish the same result with `lynx` if `curl` isn’t available, but
    if you have both, we recommend `curl`. That’s what we’ll work with in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `curl` 不可用，你可以通过 `lynx` 实现相同的结果，但如果你有两个工具，我们推荐使用 `curl`。这就是本章中我们将使用的工具。
- en: '**WARNING**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*One limitation to the website scraper scripts in this chapter is that if the
    script depends on a website that’s changed its layout or API in the time since
    this book was written, the script might be broken. But if you can read HTML or
    JSON (even if you don’t understand it all), you should be able to fix any of these
    scripts. The problem of tracking other sites is exactly why Extensible Markup
    Language (XML) was created: it allows site developers to provide the content of
    a web page separately from the rules for its layout.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章中的网站抓取脚本的一个限制是，如果脚本依赖的某个网站在本书写作之后更改了其布局或 API，脚本可能会失效。但是，如果你能读取 HTML 或 JSON（即使你不完全理解它），你应该能够修复这些脚本。追踪其他网站的问题正是可扩展标记语言（XML）被创造出来的原因：它允许网站开发者将网页内容与其布局规则分开提供。*'
- en: '**#53 Downloading Files via FTP**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#53 通过 FTP 下载文件**'
- en: One of the original killer apps of the internet was file transfer, and one of
    the simplest solutions is FTP, File Transfer Protocol. At a fundamental level,
    all internet interaction is based on file transfer, whether it’s a web browser
    requesting an HTML document and its accompanying image files, a chat server relaying
    lines of discussion back and forth, or an email message traveling from one end
    of the earth to the other.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的原始杀手级应用之一是文件传输，而最简单的解决方案之一就是 FTP，即文件传输协议。从根本上说，所有的互联网交互都是基于文件传输的，无论是网页浏览器请求
    HTML 文档及其附带的图像文件，聊天服务器来回传递讨论内容，还是电子邮件从地球的一端传递到另一端。
- en: The original FTP program still lingers on, and while its interface is crude,
    the program is powerful, capable, and well worth taking advantage of. There are
    plenty of newer FTP programs around, notably FileZilla (*[http://filezilla-project.org/](http://filezilla-project.org/)*)
    and NcFTP (*[http://www.ncftp.org/](http://www.ncftp.org/)*), plus lots of nice
    graphical interfaces you can add to FTP to make it more user-friendly. With the
    help of some shell script wrappers, however, FTP does just fine for uploading
    and downloading files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 FTP 程序仍然存在，虽然它的界面简陋，但该程序功能强大、能力强，并且非常值得利用。现在有许多更新的 FTP 程序，特别是 FileZilla
    (*[http://filezilla-project.org/](http://filezilla-project.org/)*）和 NcFTP (*[http://www.ncftp.org/](http://www.ncftp.org/)*），以及很多你可以为
    FTP 添加的漂亮图形界面，以使其更加用户友好。然而，借助一些 shell 脚本包装器，FTP 在上传和下载文件方面仍然表现得相当不错。
- en: For example, a typical use case for FTP is to download files from the internet,
    which we’ll do with the script in [Listing 7-1](ch07.xhtml#ch7ex1). Quite often,
    the files will be located on anonymous FTP servers and will have URLs similar
    to *ftp://<someserver>/<path>/<filename>/*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，FTP的典型用例是从互联网上下载文件，这一点我们将在[清单 7-1](ch07.xhtml#ch7ex1)中的脚本中实现。文件通常位于匿名FTP服务器上，且其URL类似于*ftp://<someserver>/<path>/<filename>*。
- en: '***The Code***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-1: The* `*ftpget*` *script*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：* `*ftpget*` *脚本*'
- en: '***How It Works***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'The heart of this script is the sequence of commands fed to the FTP program
    starting at ➊. This illustrates the essence of a batch file: a sequence of instructions
    that’s fed to a separate program so that the receiving program (in this case FTP)
    thinks the instructions are being entered by the user. Here we specify the server
    connection to open, specify the anonymous user (FTP) and whatever default password
    is specified in the script configuration (typically your email address), and then
    get the specified file from the FTP site and quit the transfer.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的核心是从➊开始输入到FTP程序的一系列命令。这展示了批处理文件的本质：一系列指令被传递给一个独立的程序，让接收程序（在这个例子中是FTP）认为这些指令是用户输入的。在这里，我们指定了要打开的服务器连接，指定了匿名用户（FTP）以及脚本配置中指定的默认密码（通常是你的电子邮件地址），然后从FTP站点获取指定的文件并退出传输。
- en: '***Running the Script***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'This script is straightforward to use: just fully specify an FTP URL, and it’ll
    download the file to the current working directory, as [Listing 7-2](ch07.xhtml#ch7ex2)
    details.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本使用起来非常简单：只需要完全指定一个FTP URL，它就会将文件下载到当前工作目录，正如[清单 7-2](ch07.xhtml#ch7ex2)中所详细描述的那样。
- en: '***The Results***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-2: Running the* `*ftpget*` *script*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-2：运行* `*ftpget*` *脚本*'
- en: Some versions of FTP are more verbose than others, and because it’s not too
    uncommon to find a slight mismatch in the client and server protocol, those verbose
    versions of FTP can spit out scary-looking errors, like `Unimplemented command`.
    You can safely ignore these. For example, [Listing 7-3](ch07.xhtml#ch7ex3) shows
    the same script run on OS X.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些版本的FTP比其他版本更冗长，由于客户端和服务器协议有时会稍微不匹配，这些冗长版本的FTP可能会输出看起来很可怕的错误信息，如`Unimplemented
    command`。你可以安全地忽略这些错误。例如，[清单 7-3](ch07.xhtml#ch7ex3)展示了相同的脚本在OS X上的运行结果。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-3: Running the* `*ftpget*` *script on OS X*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-3：在OS X上运行* `*ftpget*` *脚本*'
- en: If your FTP is excessively verbose and you’re on OS X, you can quiet it down
    by adding a `-V` flag to the FTP invocation in the script (that is, instead of
    FTP `-n`, use FTP `-nV`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的FTP过于冗长，并且你使用的是OS X系统，可以通过在脚本中为FTP调用添加`-V`标志来将其静音（也就是说，使用FTP `-nV`，而不是FTP
    `-n`）。
- en: '***Hacking the Script***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改脚本***'
- en: 'This script can be expanded to decompress the downloaded file automatically
    (see [Script #33](ch04.xhtml#ch04lev1sec07) on [page 109](ch04.xhtml#page_109)
    for an example of how to do this) if it has certain file extensions. Many compressed
    files such as *.tar.gz* and *.tar.bz2* can be decompressed by default with the
    system `tar` command.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '如果下载的文件具有某些文件扩展名，这个脚本可以扩展为自动解压下载的文件（参见[脚本 #33](ch04.xhtml#ch04lev1sec07)，以及[第109页](ch04.xhtml#page_109)中的示例，了解如何执行此操作）。许多压缩文件，如*.tar.gz*和*.tar.bz2*，默认可以使用系统的`tar`命令进行解压。'
- en: 'You can also tweak this script to make it a simple tool for *uploading* a specified
    file to an FTP server. If the server supports anonymous connections (few do nowadays,
    thanks to script kiddies and other delinquents, but that’s another story), all
    you really have to do is specify a destination directory on the command line or
    in the script and change the `get` to a `put` in the main script, as shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以调整这个脚本，使其成为一个简单的工具，用于*上传*指定的文件到FTP服务器。如果服务器支持匿名连接（虽然如今很少有服务器支持，因为有脚本小子和其他不法分子，另当别论），你只需要在命令行或脚本中指定目标目录，并将主脚本中的`get`命令改为`put`，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To work with a password-protected account, you could have the script prompt
    for the password interactively by turning off echoing before a `read` statement
    and then turning it back on when you’re done:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理密码保护的账户，你可以通过在`read`语句之前关闭回显，然后在完成后再打开回显，来让脚本提示输入密码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A smarter way to prompt for a password, however, is to just let the FTP program
    do the work itself. This will happen as written in our script because if a password
    is required to gain access to the specified FTP account, the FTP program itself
    will prompt for it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更智能的密码提示方式是直接让 FTP 程序自己处理。这将在我们的脚本中实现，因为如果访问指定的 FTP 账户需要密码，FTP 程序会自动提示输入密码。
- en: '**#54 Extracting URLs from a Web Page**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#54 从网页提取 URL**'
- en: A straightforward shell script application of `lynx` is to extract a list of
    URLs on a given web page, which can be quite helpful when scraping the internet
    for links. We said we’d switched from `lynx` to `curl` for this edition of the
    book, but it turns out that `lynx` is about a hundred times easier to use for
    this script (see [Listing 7-4](ch07.xhtml#ch7ex4)) than `curl`, because `lynx`
    parses HTML automatically whereas `curl` forces you to parse the HTML yourself.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`lynx` 的一种直接的 shell 脚本应用是提取指定网页上的 URL 列表，这在抓取互联网链接时非常有用。我们曾说过我们已经从 `lynx` 切换到
    `curl` 用于本书的这一版本，但事实证明，对于这个脚本来说，`lynx` 使用起来要简单一百倍（参见 [清单 7-4](ch07.xhtml#ch7ex4)），因为
    `lynx` 会自动解析 HTML，而 `curl` 需要你自己手动解析 HTML。'
- en: Don’t have `lynx` on your system? Most Unix systems today have package managers
    such as `yum` on Red Hat, `apt` on Debian, and `brew` on OS X (though `brew` is
    not installed by default) that you can use to install `lynx`. If you prefer to
    compile `lynx` yourself, or just want to download prebuilt binaries, you can download
    it from *[http://lynx.browser.org/](http://lynx.browser.org/)*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上没有 `lynx` 吗？如今大多数 Unix 系统都配有包管理器，如 Red Hat 上的 `yum`、Debian 上的 `apt` 以及 OS
    X 上的 `brew`（尽管 `brew` 默认没有安装），你可以使用它们来安装 `lynx`。如果你更喜欢自己编译 `lynx`，或者想下载预构建的二进制文件，可以从
    *[http://lynx.browser.org/](http://lynx.browser.org/)* 下载。
- en: '***The Code***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-4: The* `*getlinks*` *script*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-4：`*getlinks*` 脚本*'
- en: '***How It Works***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: When displaying a page, `lynx` shows the text of the page formatted as best
    it can followed by a list of all hypertext references, or links, found on that
    page. This script extracts just the links by using a `sed` invocation to print
    everything after the `"References"` string in the web page text ➎. Then the script
    processes the list of links as needed based on the user-specified flags.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示页面时，`lynx` 会将页面的文本按其最佳方式格式化，接着显示该页面上找到的所有超文本引用或链接的列表。这个脚本通过使用 `sed` 命令提取网页文本中
    `"References"` 字符串后的所有内容 ➎，然后根据用户指定的标志处理链接列表。
- en: One interesting technique demonstrated by this script is the way the variable
    `lastcmd` (➊, ➋, ➌, ➍) is set to filter the list of links that it extracts according
    to the flags specified by the user. Once `lastcmd` is set, the amazingly handy
    `eval` command ➏ is used to force the shell to interpret the content of the variable
    as if it were a command instead of a variable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本展示的一个有趣技巧是如何通过设置变量 `lastcmd`（➊, ➋, ➌, ➍）来根据用户指定的标志筛选提取的链接列表。一旦设置了 `lastcmd`，就使用非常方便的
    `eval` 命令 ➏ 强制 shell 将该变量的内容当作命令执行，而不是作为变量。
- en: '***Running the Script***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'By default, this script outputs a list of all links found on the specified
    web page, not just those that are prefaced with `http:`. There are three optional
    command flags that can be specified to change the results, however: `-d` produces
    just the domain names of all matching URLs, `-r` produces a list of just the *relative*
    references (that is, those references that are found on the same server as the
    current page), and `-a` produces just the *absolute* references (those URLs that
    point to a different server).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，脚本会输出指定网页上找到的所有链接列表，而不仅仅是以 `http:` 开头的链接。不过，有三个可选的命令行标志可以指定以更改结果：`-d`
    只输出所有匹配 URL 的域名，`-r` 输出仅包含 *相对* 引用的列表（即那些与当前页面位于同一服务器上的引用），`-a` 输出仅包含 *绝对* 引用的列表（即指向不同服务器的
    URL）。
- en: '***The Results***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: A simple request is a list of all links on a specified website home page, as
    [Listing 7-5](ch07.xhtml#ch7ex5) shows.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的请求是列出指定网站主页上的所有链接，正如 [清单 7-5](ch07.xhtml#ch7ex5) 所示。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-5: Running the* `*getlinks*` *script*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-5：运行 `*getlinks*` 脚本*'
- en: 'Another possibility is to request a list of all domain names referenced at
    a specific site. This time, let’s first use the standard Unix tool `wc` to check
    how many links are found overall:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的请求是列出特定网站上所有引用的域名。这次，让我们先使用标准的 Unix 工具 `wc` 来检查找到的链接总数：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Amazon has 219 links on its home page. Impressive! How many different domains
    does that represent? Let’s generate a list with the `-d` flag:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊首页上有219个链接。很令人印象深刻！这代表了多少个不同的域名呢？让我们使用`-d`标志生成一个列表：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Amazon doesn’t tend to point outside its own site, but there are some partner
    links that creep onto the home page. Other sites are different, of course.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊通常不指向外部站点，但确实有一些合作伙伴链接会出现在主页上。当然，其他网站则不同。
- en: What if we split the links on the Amazon page into relative and absolute links?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将亚马逊页面上的链接分为相对链接和绝对链接，会怎么样？
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you might have expected, Amazon has four times more relative links pointing
    inside its own site than it has absolute links, which would lead to a different
    website. Gotta keep those customers on your own page!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的那样，亚马逊站点内部指向自己站点的相对链接比指向其他网站的绝对链接多四倍，这样做是为了让顾客始终停留在自己的网站上！
- en: '***Hacking the Script***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'You can see where `getlinks` could be quite useful as a site analysis tool.
    For a way to enhance the script, stay tuned: [Script #69](ch09.xhtml#ch09lev1sec01)
    on [page 217](ch09.xhtml#page_217) complements this script nicely, allowing us
    to quickly check that all hypertext references on a site are valid.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到`getlinks`作为站点分析工具是多么有用。为了增强脚本的功能，请关注：[脚本 #69](ch09.xhtml#ch09lev1sec01)在[第217页](ch09.xhtml#page_217)很好地补充了这个脚本，使我们能够快速检查站点上的所有超文本引用是否有效。'
- en: '**#55 Getting GitHub User Information**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#55 获取GitHub用户信息**'
- en: GitHub has grown to be a huge boon to the open source industry and open collaboration
    across the world. Many system administrators and developers have visited GitHub
    to pull down some source code or report an issue to an open source project. Because
    GitHub is essentially a social platform for developers, getting to know a user’s
    basic information quickly can be useful. The script in [Listing 7-6](ch07.xhtml#ch7ex6)
    prints some information about a given GitHub user, and it gives a good introduction
    to the very powerful GitHub API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub已经成为开源行业和全球开放协作的巨大推动力。许多系统管理员和开发者访问GitHub来下载源代码或报告开源项目中的问题。由于GitHub本质上是一个面向开发者的社交平台，快速了解用户的基本信息非常有用。[列表
    7-6](ch07.xhtml#ch7ex6)中的脚本打印了关于某个GitHub用户的一些信息，并很好地介绍了功能强大的GitHub API。
- en: '***The Code***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 7-6: The* `*githubuser*` *script*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-6：* `*githubuser*` *脚本*'
- en: '***How It Works***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: Admittedly, this is almost more of an `awk` script than a bash script, but sometimes
    you need the extra horsepower `awk` provides for parsing (the GitHub API returns
    JSON). We use `curl` to ask GitHub for the user ➊, given as the argument of the
    script, and pipe the JSON to `awk`. With `awk`, we specify a field separator of
    the double quotes character, as this will make parsing the JSON much simpler.
    Then we match the JSON with a handful of regular expressions in the `awk` script
    and print the results in a user-friendly way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这几乎更像是一个`awk`脚本而不是bash脚本，但有时候你确实需要`awk`提供的额外功能来进行解析（GitHub API返回的是JSON格式）。我们使用`curl`向GitHub请求用户➊信息，该信息作为脚本的参数，并将JSON数据传递给`awk`。在`awk`中，我们指定双引号字符作为字段分隔符，这样会使得解析JSON变得更简单。然后，我们使用几个正则表达式匹配JSON数据，并以用户友好的方式打印结果。
- en: '***Running the Script***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'The script accepts a single argument: the user to look up on GitHub. If the
    username provided doesn’t exist, nothing will be printed.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本接受一个参数：在GitHub上查找的用户。如果提供的用户名不存在，则不会打印任何内容。
- en: '***The Results***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: When passed a valid username, the script should print a user-friendly summary
    of the GitHub user, as [Listing 7-7](ch07.xhtml#ch7ex7) shows.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当传入有效的用户名时，脚本应打印出一个用户友好的GitHub用户摘要，如[列表 7-7](ch07.xhtml#ch7ex7)所示。
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 7-7: Running the* `*githubuser*` *script*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-7：运行* `*githubuser*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: This script has a lot of potential due to the information that can be retrieved
    from the GitHub API. In this script, we are only printing four values from the
    JSON returned. Generating a “résumé” for a given user based on the information
    provided by the API, like those provided by many web services, is just one possibility.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以从GitHub API获取大量信息，这个脚本有很大的潜力。在这个脚本中，我们只打印了从JSON返回的四个值。基于API提供的信息为给定用户生成一份“简历”，就像许多网络服务所提供的那样，正是其中的一种可能性。
- en: '**#56 ZIP Code Lookup**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#56 邮政编码查询**'
- en: To demonstrate a different technique for scraping the web, this time using `curl`,
    let’s create a simple ZIP code lookup tool. Give the script in [Listing 7-8](ch07.xhtml#ch7ex8)
    a ZIP code, and it’ll report the city and state the code belongs to. Easy enough.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一种不同的网页抓取技术，这次我们使用`curl`，创建一个简单的邮政编码查询工具。给[清单 7-8](ch07.xhtml#ch7ex8)中的脚本一个邮政编码，它会报告该邮政编码对应的城市和州。非常简单。
- en: Your first instinct might be to use the official US Postal Service website,
    but we’re going to tap into a different site, *[http://city-data.com/](http://city-data.com/)*,
    which configures each ZIP code as its own web page so information is far easier
    to extract.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你最初的想法可能是使用美国邮政局的官方网站，但我们将使用另一个网站，*[http://city-data.com/](http://city-data.com/)*，它将每个邮政编码配置为一个独立的网页，因此信息提取起来更为简单。
- en: '***The Code***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 7-8: The* `*zipcode*` *script*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-8：* `*zipcode*` *脚本*'
- en: '***How It Works***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The URLs for ZIP code information pages on *[http://city-data.com/](http://city-data.com/)*
    are structured consistently, with the ZIP code itself as the final part of the
    URL.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在*[http://city-data.com/](http://city-data.com/)*上，邮政编码信息页面的URL结构是一致的，邮政编码本身作为URL的最后一部分。
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This consistency makes it quite easy to create an appropriate URL for a given
    ZIP code on the fly. The resultant page has the city name in the title, conveniently
    denoted by open and close parentheses, as follows.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种一致性使得为给定的邮政编码即时创建适当的URL变得非常容易。结果页面的标题中包含城市名称，并方便地用括号标明，格式如下。
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Long, but pretty easy to work with!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 很长，但相当容易操作！
- en: '***Running the Script***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: The standard way to invoke the script is to specify the desired ZIP code on
    the command line. If it’s valid, the city and state will be displayed, as shown
    in [Listing 7-9](ch07.xhtml#ch7ex9).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 调用脚本的标准方法是在命令行中指定所需的邮政编码。如果它有效，将显示城市和州，如[清单 7-9](ch07.xhtml#ch7ex9)所示。
- en: '***The Results***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 7-9: Running the* `*zipcode*` *script*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-9：运行* `*zipcode*` *脚本*'
- en: Since 30001 isn’t a real ZIP code, the script generates a `Page not found` error.
    That’s a bit sloppy, and we can do better.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为30001不是一个有效的邮政编码，脚本会生成一个`Page not found`错误。这有点草率，我们可以做得更好。
- en: '***Hacking the Script***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: The most obvious hack to this script would be to do something in response to
    errors other than just spew out that ugly `<title>Page not found – City-Data.com</title>`
    sequence. More useful still would be to add a `-a` flag that tells the script
    to display more information about the specified region, since *[http://city-data.com/](http://city-data.com/)*
    offers quite a bit of information beyond city names—including land area, population
    demographics, and home prices.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个脚本最明显的修改是，在遇到错误时做些处理，而不仅仅是输出那个丑陋的`<title>Page not found – City-Data.com</title>`序列。更有用的做法是添加一个`-a`标志，告诉脚本显示更多关于指定区域的信息，因为*[http://city-data.com/](http://city-data.com/)*提供了除城市名称外的很多信息——包括土地面积、人口统计以及房价。
- en: '**#57 Area Code Lookup**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#57 区号查询**'
- en: 'A variation on the theme of the ZIP code lookup in [Script #56](ch07.xhtml#ch07lev1sec04)
    is an area code lookup. This one turns out to be really simple, because there
    are some very easy-to-parse web pages with area codes. The page at *[http://www.bennetyee.org/ucsd-pages/area.html](http://www.bennetyee.org/ucsd-pages/area.html)*
    is particularly easy to parse, not only because it is in tabular form but also
    because the author has identified elements with HTML attributes. For example,
    the line that defines area code 207 reads like so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[脚本 #56](ch07.xhtml#ch07lev1sec04)中的邮政编码查询的变体是区号查询。这实际上非常简单，因为有一些非常易于解析的网页显示区号。位于*[http://www.bennetyee.org/ucsd-pages/area.html](http://www.bennetyee.org/ucsd-pages/area.html)*的页面尤其容易解析，不仅因为它是表格形式，还因为作者已经用HTML属性标识了元素。例如，定义区号207的那一行如下：'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ll use this site to look up area codes in the script in [Listing 7-10](ch07.xhtml#ch7ex10).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个网站查找在[清单 7-10](ch07.xhtml#ch7ex10)中的脚本中的区号。
- en: '***The Code***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 7-10: The* `*areacode*` *script*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：* `*areacode*` *脚本*'
- en: '***How It Works***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The code in this shell script is mainly input validation, ensuring the data
    provided by the user is a valid area code. The core of the script is a `curl`
    call ➊, whose output is piped to `sed` for cleaning up and then trimmed with `cut`
    to what we want to display to the user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Shell脚本中的代码主要是输入验证，确保用户提供的数据是一个有效的区号。脚本的核心是一个`curl`调用 ➊，其输出通过管道传递给`sed`进行清理，然后使用`cut`裁剪成我们希望显示给用户的内容。
- en: '***Running the Script***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script takes a single argument, the area code to look up information for.
    [Listing 7-11](ch07.xhtml#ch7ex11) gives examples of the script in use.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本接受一个参数，即要查询信息的区号。[清单 7-11](ch07.xhtml#ch7ex11)展示了该脚本的使用示例。
- en: '***The Results***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 7-11: Testing the* `*areacode*` *script*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-11：测试* `*areacode*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: A simple hack would be to invert the search so that you provide a state and
    city and the script prints all of the area codes for the given city.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的破解方法是反转搜索，提供州和城市名称，脚本则会打印给定城市的所有区号。
- en: '**#58 Keeping Track of the Weather**'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#58 跟踪天气**'
- en: Being inside an office or server room with your nose to a terminal all day sometimes
    makes you yearn to be outside, especially when the weather is really nice. Weather
    Underground (*[http://www.wunderground.com/](http://www.wunderground.com/)*) is
    a great website, and it actually offers a free API for developers if you sign
    up for an API key. With the API key, we can write a quick shell script (shown
    in [Listing 7-12](ch07.xhtml#ch7ex12)) to tell us just how nice (or poor) the
    weather is outside. Then we can decide whether taking a quick walk is really a
    good idea.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间待在办公室或服务器房间里，面对终端工作，有时会让你渴望到外面走走，尤其是当天气特别好时。Weather Underground（* [http://www.wunderground.com/](http://www.wunderground.com/)
    *）是一个很棒的网站，实际上它为开发者提供了免费的API，只要你注册一个API密钥。通过这个API密钥，我们可以编写一个快速的Shell脚本（如[清单 7-12](ch07.xhtml#ch7ex12)所示），来告诉我们外面的天气有多好（或多差）。然后我们可以决定是否真的应该去散个步。
- en: '***The Code***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 7-12: The* `*weather*` *script*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-12：* `*weather*` *脚本*'
- en: '***How It Works***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: In this script, we use `curl` to call the Wunderground API and save the HTTP
    response data in the `weather` variable ➊. We then use the `xmllint` (easily installable
    with your favorite package manager such as `apt`, `yum`, or `brew`) utility to
    perform an XPath query on the data returned ➋. We also use an interesting syntax
    in bash when calling `xmllint` with the `<(echo $weather)` at the end. This syntax
    takes the output of the inner command and passes it to the command as a file descriptor,
    so the program thinks it’s reading a real file. After gathering all the relevant
    information from the XML returned, we print a friendly message with general weather
    stats.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们使用`curl`调用Wunderground API，并将HTTP响应数据保存在`weather`变量中➊。然后我们使用`xmllint`（可以通过你喜欢的包管理器，如`apt`、`yum`或`brew`轻松安装）工具对返回的数据执行XPath查询➋。我们还在调用`xmllint`时使用了一个有趣的bash语法，命令后面带有`<(echo
    $weather)`。这种语法将内部命令的输出传递给命令作为文件描述符，这样程序就认为它正在读取一个真实的文件。在从返回的XML中收集到所有相关信息后，我们会打印一条友好的消息，显示天气的基本统计信息。
- en: '***Running the Script***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: When you invoke the script, just specify the desired ZIP code, as [Listing 7-13](ch07.xhtml#ch7ex13)
    shows. Easy enough!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用脚本时，只需指定所需的邮政编码，如[清单 7-13](ch07.xhtml#ch7ex13)所示。非常简单！
- en: '***The Results***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 7-13: Testing the* `*weather*` *script*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-13：测试* `*weather*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'We have a secret. This script can actually take more than just ZIP codes. You
    can also specify regions in the Wunderground API, such as `CA/San_Francisco` (try
    it as an argument to the weather script!). However, this format isn’t incredibly
    user-friendly: it requires underscores instead of spaces and the slash in the
    middle. Adding the ability to ask for the state abbreviation and the city and
    then replacing any spaces with underscores if no arguments are passed would be
    a useful addition. As usual, this script could do with more error-checking code.
    What happens if you enter a four-digit ZIP code? Or a ZIP code that’s not assigned?'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有个小秘密。这个脚本实际上可以接受的不仅仅是邮政编码。你还可以在Wunderground API中指定区域，比如`CA/San_Francisco`（尝试作为天气脚本的参数！）。然而，这种格式并不是非常用户友好：它要求用下划线代替空格，并且中间有一个斜杠。如果能够添加一个功能，允许用户输入州的缩写和城市名，并在没有传入参数时将空格替换为下划线，那会是一个有用的改进。和往常一样，这个脚本还可以加上更多的错误检查代码。如果你输入了一个四位数的邮政编码会发生什么？或者一个未分配的邮政编码呢？
- en: '**#59 Digging Up Movie Info from IMDb**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#59 从IMDb挖掘电影信息**'
- en: The script in [Listing 7-14](ch07.xhtml#ch7ex14) demonstrates a more sophisticated
    way to access the internet through `lynx`, by searching the Internet Movie Database
    (*[http://www.imdb.com/](http://www.imdb.com/)*) to find films that match a specified
    pattern. IMDb assigns every movie, TV series, and even TV episode a unique numeric
    code; if the user specifies that code, this script will return a synopsis of the
    film. Otherwise, it will return a list of matching films from a title or partial
    title.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-14](ch07.xhtml#ch7ex14)中的脚本演示了通过`lynx`访问互联网的一种更复杂方式，通过搜索互联网电影数据库（* [http://www.imdb.com/](http://www.imdb.com/)
    *）查找与指定模式匹配的电影。IMDb 为每部电影、电视系列以及甚至每一集电视剧分配了唯一的数字代码；如果用户指定了该代码，脚本将返回电影的简介。否则，它会根据标题或部分标题返回匹配的电影列表。'
- en: The script accesses different URLs depending on the type of query (numeric ID
    or file title) and then caches the results so it can dig through the page multiple
    times to extract different pieces of information. And it uses a lot—a *lot*!—of
    calls to `sed` and `grep`, as you’ll see.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本根据查询类型（数字ID或文件标题）访问不同的URL，并缓存结果，以便它可以多次浏览页面，提取不同的信息。而且它使用了很多——*很多*——`sed`和`grep`的调用，正如你将看到的那样。
- en: '***The Code***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 7-14: The* `*moviedata*` *script*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-14：* `*moviedata*` *脚本*'
- en: '***How It Works***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: This script builds a different URL depending on whether the command argument
    specified is a film title or an IMDb ID number. If the user specifies a title
    by ID number, the script builds the appropriate URL, downloads it, saves the `lynx`
    output to the `$tempout` file ➋, and finally calls `summarize_film()` ➊. Not too
    difficult.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本根据命令参数指定的是电影标题还是IMDb ID号码来构建不同的URL。如果用户通过ID号码指定标题，脚本会构建适当的URL，下载它，将`lynx`输出保存到`$tempout`文件
    ➋ 中，并最终调用`summarize_film()` ➊。并不难。
- en: 'But if the user specifies a title, then the script builds a URL for a search
    query on IMDb and saves the results page to the temp file. If IMDb can’t find
    a match, then the `<h1>` tag with `class="findHeader"` value in the returned HTML
    will say `No results`. That’s what the invocation at ➌ checks. Then the test is
    easy: if `$fail` is not zero length, the script can report that no results were
    found.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果用户指定了标题，则脚本将为IMDb上的搜索查询构建一个URL，并将结果页面保存到临时文件中。如果IMDb找不到匹配项，则返回的HTML中`<h1>`标签的`class="findHeader"`值将显示`没有结果`。这就是在
    ➌ 中检查的内容。然后，测试很简单：如果`$fail`的长度不为零，脚本可以报告未找到任何结果。
- en: 'If the result *is* zero length, however, that means that `$tempfile` now contains
    one or more successful search results for the user’s pattern. These results can
    all be extracted by searching for `/title/tt` as a pattern within the source,
    but there’s a caveat: IMDb doesn’t make it easy to parse the results because there
    are multiple matches to any given title link. The rest of that gnarly `sed|grep|sed`
    sequence tries to identify and remove the duplicate matches, while still retaining
    the ones that matter.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果结果*是*零长度，这意味着`$tempfile`现在包含一个或多个成功的搜索结果，这些结果符合用户的模式。可以通过在源代码中搜索`/title/tt`作为模式来提取这些结果，但有个警告：IMDb并没有使解析结果变得容易，因为任何给定的标题链接都有多个匹配项。其余的`sed|grep|sed`序列试图识别并移除重复的匹配项，同时保留那些重要的匹配项。
- en: Further, when IMDb has a match like `"Lawrence of Arabia (1962)"`, it turns
    out that the title and year are two different HTML elements on two different lines
    in the result. Ugh. We need the year, however, to differentiate films with the
    same title that were released in different years. That’s what the `awk` statement
    at ➍ does, in a tricky sort of way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当IMDb匹配到类似`"阿拉伯的劳伦斯 (1962)"`的条目时，标题和年份实际上是两个不同的HTML元素，分别位于结果的两行中。呃。我们需要年份来区分同一标题但在不同年份上映的电影。这就是
    ➍ 中的`awk`语句所做的事情，以一种巧妙的方式。
- en: If you’re unfamiliar with `awk`, the general format for an `awk` script is `(*condition*)
    { *action* }`. This line saves odd-numbered lines in `$title` and then, on even-numbered
    lines (the year and match type data), it outputs both the previous and the current
    line’s data as one line of output.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉`awk`，`awk`脚本的一般格式是`(*condition*) { *action* }`。这行代码将奇数行的数据保存在`$title`中，然后在偶数行（年份和匹配类型数据）中，它将前一行和当前行的数据作为一行输出。
- en: '***Running the Script***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: Though short, this script is quite flexible with input formats, as can be seen
    in [Listing 7-15](ch07.xhtml#ch7ex15). You can specify a film title in quotes
    or as separate words, and you can then specify the eight-digit IMDb ID value to
    select a specific match.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该脚本较短，但它在输入格式方面相当灵活，正如在[列表 7-15](ch07.xhtml#ch7ex15)中所示。你可以用引号指定电影标题或作为单独的单词输入，然后你可以指定八位数的
    IMDb ID 值来选择特定的匹配项。
- en: '***The Results***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 7-15: Running the* `*moviedata*` *script*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-15：运行* `*moviedata*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: The most obvious hack to this script would be to get rid of the ugly IMDb movie
    ID numbers in the output. It would be straightforward to hide the movie IDs (because
    the IDs as shown are rather unfriendly and prone to mistyping) and have the shell
    script output a simple menu with unique index values that can then be typed in
    to select a particular film.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个脚本最明显的修改是去掉输出中难看的 IMDb 电影 ID 编号。隐藏电影 ID（因为显示的 ID 相当不友好且容易出错）并让 shell 脚本输出一个简单的菜单，其中包含唯一的索引值，然后可以输入这些值来选择特定的电影，应该是简单的。
- en: In situations where there’s exactly one film matched (try `moviedata monsoon
    wedding`), it would be great for the script to recognize that it’s the only match,
    grab the movie number for the film, and reinvoke itself to get that data. Give
    it a whirl!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在确切匹配到一部电影的情况下（试试 `moviedata monsoon wedding`），如果脚本能识别出这是唯一的匹配项，抓取电影编号并重新调用自己获取数据，那就太好了。试试看！
- en: A problem with this script, as with most scripts that scrape values from a third-party
    website, is that if IMDb changes its page layout, the script will break and you’ll
    need to rebuild the script sequence. It’s a lurking bug but, with a site like
    IMDb that hasn’t changed in years, probably not a dangerous one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的问题，与大多数从第三方网站抓取数据的脚本一样，如果 IMDb 更改了页面布局，脚本就会失效，你需要重新构建脚本顺序。这是一个潜在的错误，但对于像
    IMDb 这样多年来没有变化的网站来说，可能并不是一个危险问题。
- en: '**#60 Calculating Currency Values**'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#60 计算货币值**'
- en: 'In the first edition of this book, currency conversion was a remarkably difficult
    task requiring two scripts: one to pull conversion rates from a financial website
    and save them in a special format and another to use that data to actually do
    the conversion—say from US dollars to Euros. In the intervening years, however,
    the web has become quite a bit more sophisticated, and there’s no reason for us
    to go through tons of work when sites like Google offer simple, script-friendly
    calculators.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，货币转换是一个相当困难的任务，需要两个脚本：一个从金融网站获取转换汇率并以特定格式保存，另一个使用这些数据实际进行转换——比如将美元转换为欧元。然而，在这几年里，互联网变得更加复杂，我们无需再进行大量的工作，因为像
    Google 这样的站点提供了简单、适合脚本使用的计算器。
- en: For this version of the currency conversion script, shown in [Listing 7-16](ch07.xhtml#ch7ex16),
    we’re just going to tap into the currency calculator at *[http://www.google.com/finance/converter](http://www.google.com/finance/converter)*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个版本的货币转换脚本，如[列表 7-16](ch07.xhtml#ch7ex16)所示，我们将直接使用 *[http://www.google.com/finance/converter](http://www.google.com/finance/converter)*
    中的货币计算器。
- en: '***The Code***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 7-16: The* `*convertcurrency*` *script*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-16：* `*convertcurrency*` *脚本*'
- en: '***How It Works***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'The Google Currency Converter has three parameters that are passed via the
    URL itself: the amount, the original currency, and the currency you want to convert
    to. You can see this in action in the following request to convert 100 US dollars
    into Mexican pesos.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Google 货币转换器有三个通过 URL 传递的参数：金额、原始货币和你想转换成的货币。你可以在以下请求中看到它是如何工作的，将 100 美元转换为墨西哥比索。
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the most basic use case, then, the script expects the user to specify each
    of those three fields as arguments, and then passes it all to Google in the URL.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的使用案例中，脚本期望用户指定这三个字段作为参数，然后将它们通过 URL 传递给 Google。
- en: The script also has some usage messages that make it a lot easier to use. To
    see those, let’s just jump to the demonstration portion, shall we?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本还提供了一些使用消息，便于使用。为了看到这些信息，我们不妨直接跳到演示部分，怎么样？
- en: '***Running the Script***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script is designed to be easy to use, as [Listing 7-17](ch07.xhtml#ch7ex17)
    details, though a basic knowledge of at least a few countries’ currencies is beneficial.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的设计目标是易于使用，正如[列表 7-17](ch07.xhtml#ch7ex17)中详细描述的那样，尽管至少对一些国家的货币有基本了解会更有帮助。
- en: '***The Results***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 7-17: Running the* `*convertcurrency*` *script*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-17：运行* `*convertcurrency*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: While this web-based calculator is austere and simple to work with, the output
    could do with some cleaning up. For example, the output in [Listing 7-17](ch07.xhtml#ch7ex17)
    doesn’t entirely make sense because it expresses US dollars with four digits after
    the decimal point, even though cents only go to two digits. The correct output
    should be 84.51, or if rounded up, 84.52\. That’s something fixable in the script.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个基于网页的计算器简单易用，但输出结果可以进行一些整理。例如，[示例 7-17](ch07.xhtml#ch7ex17)中的输出并不完全合理，因为它用四位小数表示美元，而实际上美分只有两位小数。正确的输出应该是84.51，或者四舍五入后为84.52。这是脚本中可以修正的部分。
- en: While you’re at it, validating currency abbreviations would be beneficial. And
    in a similar vein, changing those abbreviated currency codes to proper currency
    names would be a nice feature, too, so you’d know that AWG is the Aruban florin
    or that BTC is Bitcoin.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，验证货币缩写会很有帮助。同样，将这些货币代码转化为完整的货币名称也是一个不错的功能，这样你就能知道AWG是阿鲁巴弗罗林，BTC是比特币。
- en: '**#61 Retrieving Bitcoin Address Information**'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#61 获取比特币地址信息**'
- en: Bitcoin has taken the world by storm, with whole businesses built around the
    technology of the *blockchain* (which is the core of how Bitcoin works). For anyone
    who works with Bitcoin at all, getting useful information about specific Bitcoin
    addresses can be a major hassle. However, we can easily automate data gathering
    using a quick shell script, like that in [Listing 7-18](ch07.xhtml#ch7ex18).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币已经席卷全球，围绕着*区块链*技术（比特币工作的核心）建立了许多企业。对于任何使用比特币的人来说，获取特定比特币地址的有用信息可能是一个麻烦。但是，我们可以通过快速的shell脚本轻松自动化数据收集，像[示例
    7-18](ch07.xhtml#ch7ex18)中所展示的那样。
- en: '***The Code***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 7-18: The* `*getbtcaddr*` *script*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-18：* `*getbtcaddr*` *脚本*'
- en: '***How It Works***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: This script automates a handful of `curl` calls to retrieve a few key pieces
    of information about a given Bitcoin address. The API available on *[http://blockchain.info/](http://blockchain.info/)*
    gives us very easy access to all kinds of Bitcoin and block-chain information.
    In fact, we don’t even need to parse the responses coming back from the API, because
    it returns only single, simple values. After making calls to retrieve the given
    address’s balance, how many BTC have been sent and received by it, and when it
    was made, we print the information to the screen for the user.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本自动化了一些`curl`调用，以检索给定比特币地址的几个关键信息。* [http://blockchain.info/](http://blockchain.info/)*提供的API让我们非常方便地访问各种比特币和区块链信息。实际上，我们甚至不需要解析从API返回的响应，因为它仅返回单一的、简单的值。在获取给定地址的余额、已发送和已接收的BTC数量以及创建时间后，脚本将信息打印到屏幕上供用户查看。
- en: '***Running the Script***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: The script accepts only a single argument, the Bitcoin address we want information
    about. However, we should mention that a string passed in that is not a real Bitcoin
    address will simply print all 0s for the sent, received, and current balance values,
    as well as a creation date in the year 1969\. Any nonzero values are in a unit
    called *satoshis*, which is the smallest denomination of a Bitcoin (like pennies,
    but to many more decimal places).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本只接受一个参数，即我们想要获取信息的比特币地址。然而，我们需要提到，如果传入的字符串不是一个有效的比特币地址，脚本将仅打印所有余额、已发送和已接收的值为0，并且创建日期会显示为1969年。任何非零值都以*satoshis*为单位，satoshi是比特币的最小单位（类似于美分，但小数点后位数更多）。
- en: '***The Results***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Running the `getbtcaddr` shell script is simple as it only takes a single argument,
    the Bitcoin address to request data about, as [Listing 7-19](ch07.xhtml#ch7ex19)
    shows.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`getbtcaddr` shell脚本非常简单，只需要一个参数——请求数据的比特币地址，正如[示例 7-19](ch07.xhtml#ch7ex19)所示。
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 7-19: Running the* `*getbtcaddr*` *script*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-19：运行* `*getbtcaddr*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改脚本***'
- en: 'The numbers printed to the screen by default are pretty large and a bit difficult
    for most people to comprehend. The `scriptbc` script ([Script #9](ch01.xhtml#ch01lev1sec10)
    on [page 34](ch01.xhtml#page_34)) can easily be used to report in more reasonable
    units, such as whole Bitcoins. Adding a scale argument to the script would be
    an easy way for the user to get a more readable printout.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，屏幕上打印的数字相当大，对于大多数人来说有些难以理解。可以很容易地使用`scriptbc`脚本（[脚本 #9](ch01.xhtml#ch01lev1sec10)，在[第34页](ch01.xhtml#page_34)）以更合理的单位报告信息，比如整个比特币。为脚本添加一个比例参数将是让用户获得更易读的输出的一种简单方法。'
- en: '**#62 Tracking Changes on Web Pages**'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#62 跟踪网页变化**'
- en: 'Sometimes great inspiration comes from seeing an existing business and saying
    to yourself, “That doesn’t seem too hard.” The task of tracking changes on a website
    is a surprisingly simple way of collecting such inspirational material. The script
    in [Listing 7-20](ch07.xhtml#ch7ex20), `changetrack`, automates that task. This
    script has one interesting nuance: when it detects changes to the site, it emails
    the new web page to the user, rather than just reporting the information on the
    command line.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，伟大的灵感来自于看到一个现有的业务并对自己说：“这似乎并不难。”在网站上跟踪变化的任务，实际上是收集这种灵感材料的一种出奇简单的方法。[清单 7-20](ch07.xhtml#ch7ex20)中的脚本`changetrack`自动化了这一任务。这个脚本有一个有趣的细节：当它检测到站点发生变化时，它会将新网页发送给用户，而不是仅仅在命令行上报告信息。
- en: '***The Code***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 7-20: The* `*changetrack*` *script*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-20：`*changetrack*`*脚本*'
- en: '***How It Works***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: Given a URL and a destination email address, this script grabs the web page
    content and compares it to the content of the site from the previous check. If
    the site has changed, the new web page is emailed to the specified recipient,
    with some simple rewrites to try to keep the graphics and `href` tags working.
    These HTML rewrites starting at ➋ are worth examining.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个URL和目标电子邮件地址，脚本会获取网页内容并与上次检查时的网站内容进行比较。如果站点发生了变化，新网页会通过电子邮件发送给指定的接收人，并对图形和`href`标签进行一些简单的重写，尽力保持它们正常工作。这个从➋开始的HTML重写值得一看。
- en: The call to `lynx` retrieves the source of the specified web page ➋, and then
    `sed` performs three different translations. First, `SRC="` is rewritten as `SRC="baseurl/`
    ➌ to ensure that any relative pathnames of the form `SRC="logo.gif"` are rewritten
    to work properly as full pathnames with the domain name. If the domain name of
    the site is *[http://www.intuitive.com/](http://www.intuitive.com/)*, the rewritten
    HTML would be `SRC="http://www.intuitive.com/logo.gif"`. Likewise, `href` attributes
    are rewritten ➍. Then, to ensure we haven’t broken anything, the third translation
    pulls the `baseurl` back *out* of the HTML source in situations where it’s been
    erroneously added ➎. For example, `HREF="http://www.intuitive.com/http://www.somewhereelse.com/link"`
    is clearly broken and must be fixed for the link to work.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`lynx`命令获取指定网页的源代码➋，然后`sed`执行三种不同的翻译。首先，`SRC="`被重写为`SRC="baseurl/`➌，确保任何相对路径名（如`SRC="logo.gif"`）都会被重写为带有域名的完整路径名。如果站点的域名是*[http://www.intuitive.com/](http://www.intuitive.com/)*，重写后的HTML将是`SRC="http://www.intuitive.com/logo.gif"`。同样，`href`属性也会被重写➍。然后，为了确保没有破坏任何内容，第三次翻译会在误加了`baseurl`的HTML源中将其移除➎。例如，`HREF="http://www.intuitive.com/http://www.somewhereelse.com/link"`显然是错误的，必须修复才能使链接正常工作。
- en: 'Notice also that the recipient address is specified in the `echo` statement
    ➊ (`echo "To: $2"`) rather than as an argument to `sendmail`. This is a simple
    security trick: by having the address within the `sendmail` input stream (which
    `sendmail` knows to parse for recipients because of the `-t` flag), there’s no
    worry about users playing games with addresses like `"joe;cat /etc/passwd|mail
    larry"`. This is a good technique to use whenever you invoke `sendmail` within
    shell scripts.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '还需要注意的是，接收地址是在`echo`语句➊（`echo "To: $2"）`中指定的，而不是作为`sendmail`的参数。这是一个简单的安全技巧：通过将地址放在`sendmail`的输入流中（`sendmail`会根据`-t`标志知道解析收件人），就不用担心用户恶意篡改地址，例如`"joe;cat
    /etc/passwd|mail larry"`。在使用`sendmail`时，这是一个很好的安全实践。'
- en: '***Running the Script***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'This script requires two parameters: the URL of the site being tracked (and
    you’ll need to use a fully qualified URL that begins with `http://` for it to
    work properly) and the email address of the person (or comma-separated group of
    people) who should receive the updated web page, as appropriate. Or, if you’d
    prefer, just use `-` (a hyphen) as the email address, and the `diff` output will
    instead be displayed on screen.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本需要两个参数：被跟踪站点的URL（为了正常工作，你需要使用以`http://`开头的完整URL）以及应该接收更新网页的人员的电子邮件地址（或者以逗号分隔的多人邮件地址）。或者，如果你更喜欢，可以将电子邮件地址设为`-`（一个连字符），那么`diff`输出将显示在屏幕上。
- en: '***The Results***'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The first time the script sees a web page, the page is automatically mailed
    to the specified user, as [Listing 7-21](ch07.xhtml#ch7ex21) shows.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行脚本时，网页会自动通过电子邮件发送给指定的用户，如[清单 7-21](ch07.xhtml#ch7ex21)所示。
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 7-21: Running the* `*changetrack*` *script for the first time*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-21：第一次运行*`*changetrack*`*脚本*'
- en: 'All subsequent checks on *[http://www.intuitive.com/](http://www.intuitive.com/)*
    will produce an email copy of the site only if the page has changed since the
    last invocation of the script. This change can be as simple as a single typo fix
    or as complex as a complete redesign. While this script can be used for tracking
    any website, sites that don’t change frequently will probably work best: if the
    site is the BBC News home page, checking for changes is a waste of CPU cycles
    because this site is *constantly* updated.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对* [http://www.intuitive.com/](http://www.intuitive.com/)*的所有后续检查，将只在页面自上次脚本调用以来发生变化时，才会发送该网站的电子邮件副本。这一变化可以是一个简单的拼写错误修复，也可以是一个完整的重新设计。虽然这个脚本可以用于跟踪任何网站，但不经常变化的网站可能效果最佳：如果该网站是BBC新闻主页，检查变化就浪费CPU周期，因为这个网站是*不断*更新的。
- en: 'If a site has not changed when the script is invoked the second time, the script
    has no output and sends no email to the specified recipient:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二次调用脚本时，网站没有发生变化，脚本将没有输出，并且不会向指定的接收人发送电子邮件：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***Hacking the Script***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: An obvious deficiency in the current script is that it’s hardcoded to look for
    *http://* links, which means it will reject any HTTP web pages served over HTTPS
    with SSL. Updating the script to work with both would require some fancier regular
    expressions, but is totally possible!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当前脚本的一个明显缺陷是它硬编码为查找*http://*链接，这意味着它会拒绝任何通过HTTPS和SSL提供的HTTP网页。更新脚本以同时支持两者将需要一些更复杂的正则表达式，但完全是可能的！
- en: Another change to make the script more useful could be to have a granularity
    option that would allow users to specify that if only one line has changed, the
    script should not consider the website updated. You could implement this by piping
    the `diff` output to `wc -l` to count lines of output changed. (Keep in mind that
    `diff` generally produces *three* lines of output for each line changed.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使脚本更有用的改动是添加一个粒度选项，允许用户指定如果只有一行发生变化，脚本不应该认为该网站已经更新。你可以通过将`diff`输出传递给`wc -l`来实现这一点，以统计输出发生变化的行数。（记住，`diff`通常会为每行变化输出*三*行内容。）
- en: This script is also more useful when invoked from a `cron` job on a daily or
    weekly basis. We have similar scripts that run every night and send us updated
    web pages from various sites that we like to track.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个脚本从`cron`任务中按日或每周调用时，它也更加有用。我们有类似的脚本每天晚上运行，向我们发送来自各种网站的更新网页，这些网站是我们喜欢跟踪的。
- en: A particularly interesting possibility is to modify this script to work off
    a data file of URLs and email addresses, rather than requiring those as input
    parameters. Drop that modified version of the script into a `cron` job, write
    a web-based front end to the utility (similar to the shell scripts in [Chapter
    8](ch08.xhtml#ch08)), and you’ve just duplicated a function that some companies
    charge people money to use. No kidding.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有趣的可能性是修改这个脚本，使其能够处理一个包含网址和电子邮件地址的数据文件，而不需要将这些作为输入参数。将修改后的脚本放入`cron`任务中，编写一个基于网页的前端工具（类似于[第8章](ch08.xhtml#ch08)中的Shell脚本），你就复制了一个一些公司收费使用的功能。不是开玩笑。
