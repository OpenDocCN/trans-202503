- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Fuzzing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, you’ll explore using fuzzing techniques to discover several
    of the top API vulnerabilities discussed in Chapter 3. The secret to successfully
    discovering most API vulnerabilities is knowing where to fuzz and what to fuzz
    with. In fact, you’ll likely discover many API vulnerabilities by fuzzing input
    sent to API endpoints.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探索使用模糊测试技术来发现第 3 章中讨论的几个顶级 API 漏洞。成功发现大多数 API 漏洞的关键是知道在哪些地方进行模糊测试，以及用什么进行模糊测试。实际上，你很可能通过对
    API 端点发送输入的模糊测试发现许多 API 漏洞。
- en: 'Using Wfuzz, Burp Suite Intruder, and Postman’s Collection Runner, we’ll cover
    two strategies to increase your success: fuzzing wide and fuzzing deep. We’ll
    also discuss how to fuzz for improper assets management vulnerabilities, find
    the accepted HTTP methods for a request, and bypass input sanitization.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Wfuzz、Burp Suite Intruder 和 Postman 的 Collection Runner，我们将介绍两种提高成功率的策略：广泛模糊测试和深度模糊测试。我们还将讨论如何通过模糊测试寻找不当的资产管理漏洞，找到请求的接受
    HTTP 方法，并绕过输入净化。
- en: Effective Fuzzing
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效的模糊测试
- en: In earlier chapters, we defined API fuzzing as the process of sending requests
    with various types of input to an endpoint in order to provoke an unintended result.
    While “various types of input” and “unintended result” might sound vague, that’s
    only because there are so many possibilities. Your input could include symbols,
    numbers, emojis, decimals, hexadecimal, system commands, SQL input, and NoSQL
    input, for instance. If the API has not implemented validation checks to handle
    harmful input, you could end up with a verbose error, a unique response, or (in
    the worst case) some sort of internal server error indicating that your fuzz caused
    a denial of service, killing the app.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们将 API 模糊测试定义为向端点发送各种类型的输入请求，以引发非预期的结果。虽然“各种类型的输入”和“非预期的结果”听起来可能有些模糊，但这仅仅是因为可能性太多。你的输入可能包括符号、数字、表情符号、小数、十六进制、系统命令、SQL
    输入和 NoSQL 输入等。例如，如果 API 没有实施验证检查来处理有害输入，你可能会得到冗长的错误、独特的响应，或者（最坏的情况）某种内部服务器错误，表明你的模糊测试导致了服务拒绝，导致应用程序崩溃。
- en: 'Fuzzing successfully requires a careful consideration of the app’s likely expectations.
    For example, take a banking API call intended to allow users to transfer money
    from one account to another. The request could look something like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的模糊测试需要仔细考虑应用程序可能的期望。例如，考虑一个银行 API 调用，目的是允许用户从一个账户转账到另一个账户。该请求可能看起来像这样：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To fuzz this request, you could easily set up Burp Suite or Wfuzz to submit
    huge payloads as the `userid`, `account`, and `transfer-amount` values. However,
    this could set off defensive mechanisms, resulting in stronger rate limiting or
    your token being blocked. If the API lacks these security controls, by all means
    release the krakens. Otherwise, your best bet is to send a few targeted requests
    to only one of the values at a time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要对这个请求进行模糊测试，你可以轻松地设置 Burp Suite 或 Wfuzz 提交巨大的有效载荷作为 `userid`、`account` 和 `transfer-amount`
    的值。然而，这可能会触发防御机制，导致更强的速率限制或你的令牌被封锁。如果 API 没有这些安全控制，尽管放开手脚去做。否则，你最好的选择是一次只向其中一个值发送几个有针对性的请求。
- en: 'Consider the fact that the `transfer-amount` value likely expects a relatively
    small number. Bank.com isn’t anticipating an individual user to transfer an amount
    larger than the global GDP. It also likely expects a decimal value. Thus, you
    might want to evaluate what happens when you send the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑 `transfer-amount` 值可能期望一个相对较小的数字。Bank.com 并不预计用户会转账超过全球 GDP 的金额。它也很可能期望一个小数值。因此，你可能想评估发送以下内容时会发生什么：
- en: A value in the quadrillions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值达到千万亿
- en: String of letters instead of numbers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母串而非数字
- en: A large decimal number or a negative number
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大数值或负数
- en: Null values like `null`, `(null)`, `%00`, and `0x00`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值，如 `null`、`(null)`、`%00` 和 `0x00`
- en: 'Symbols like the following: `!@#$%^&*();'':''''|,./?>`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似以下符号：`!@#$%^&*();':''|,./?>`
- en: These requests could easily lead to verbose errors that reveal more about the
    application. A value in the quadrillions could additionally cause an unhandled
    SQL database error to be sent back as a response. This one piece of information
    could help you target values across the API for SQL injection vulnerabilities.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些请求可能会导致冗长的错误信息，暴露更多关于应用程序的细节。数值达到千万亿时，还可能导致未处理的 SQL 数据库错误作为响应返回。这一条信息可能帮助你识别
    API 中的 SQL 注入漏洞。
- en: Thus, the success of your fuzzing will depend on where you are fuzzing and what
    you are fuzzing with. The trick is to look for API inputs that are leveraged for
    a consumer to interact with the application and send input that is likely to result
    in errors. If these inputs do not have sufficient input handling and error handling,
    they can often lead to exploitation. Examples of this sort of API input include
    the fields involved in requests used for authentication forms, account registration,
    uploading files, editing web application content, editing user profile information,
    editing account information, managing users, searching for content, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模糊测试的成功将取决于你进行模糊测试的位置以及你使用的模糊测试内容。关键是寻找API输入，这些输入供消费者与应用程序交互，并发送可能导致错误的输入。如果这些输入没有足够的输入处理和错误处理，它们通常会导致漏洞利用。这类API输入的示例包括用于认证表单、账户注册、上传文件、编辑Web应用内容、编辑用户信息、编辑账户信息、用户管理、搜索内容等请求中涉及的字段。
- en: 'The types of input to send really depend on the type of input you are attacking.
    Generically, you can send all sorts of symbols, strings, and numbers that could
    cause errors, and then you could pivot your attack based on the errors received.
    All of the following could result in interesting responses:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的输入类型实际上取决于你攻击的输入类型。一般来说，你可以发送各种符号、字符串和数字，这些可能会导致错误，然后你可以根据收到的错误来调整攻击方法。以下所有内容都可能导致有趣的响应：
- en: Sending an exceptionally large number when a small number is expected
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预期为小数字时发送异常大的数字
- en: Sending database queries, system commands, and other code
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送数据库查询、系统命令和其他代码
- en: Sending a string of letters when a number is expected
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预期为数字时发送一串字母
- en: Sending a large string of letters when a small string is expected
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预期为短字符串时发送一串长字母
- en: Sending various symbols (`-_\!@#$%^&*();':''|,./?>`)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送各种符号（`-_\!@#$%^&*();':''|,./?>`）
- en: Sending characters from unexpected languages (漢, さ, Ж, Ѫ, Ѭ, Ѧ, Ѩ, Ѯ)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送来自意外语言的字符（漢, さ, Ж, Ѫ, Ѭ, Ѧ, Ѩ, Ѯ）
- en: If you are blocked or banned while fuzzing, you might want to deploy evasion
    techniques discussed in Chapter 13 or else further limit the number of fuzzing
    requests you send.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在模糊测试过程中被阻止或禁止，你可能需要部署第13章中讨论的规避技术，或者进一步限制你发送的模糊请求数量。
- en: Choosing Fuzzing Payloads
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择模糊测试有效负载
- en: Different fuzzing payloads can incite various types of responses. You can use
    either generic fuzzing payloads or more targeted ones. *Generic payloads* are
    those we’ve discussed so far and contain symbols, null bytes, directory traversal
    strings, encoded characters, large numbers, long strings, and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的模糊测试有效负载可以引发不同类型的响应。你可以使用通用的模糊测试有效负载，也可以使用更有针对性的模糊测试有效负载。*通用有效负载*是我们到目前为止讨论的内容，包含符号、空字节、目录遍历字符串、编码字符、大数字、长字符串等。
- en: '*Targeted* fuzzing payloads are aimed at provoking a response from specific
    technologies and types of vulnerabilities. Targeted fuzzing payload types might
    include API object or variable names, cross-site scripting (XSS) payloads, directories,
    file extensions, HTTP request methods, JSON or XML data, SQL or No SQL commands,
    or commands for particular operating systems. We’ll cover examples of fuzzing
    with these payloads in this and future chapters.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*针对性*模糊测试有效负载旨在针对特定技术和漏洞类型引发响应。针对性模糊测试有效负载可能包括API对象或变量名称、跨站脚本（XSS）有效负载、目录、文件扩展名、HTTP请求方法、JSON或XML数据、SQL或NoSQL命令，或者特定操作系统的命令。在本章及未来章节中，我们将介绍使用这些有效负载的模糊测试示例。'
- en: You’ll typically move from generic to targeted fuzzing based on the information
    received in API responses. Similar to reconnaissance efforts in Chapter 6, you
    will want to adapt your fuzzing and focus your efforts based on the results of
    generic testing. Targeted fuzzing payloads are more useful once you know the technologies
    being used. If you’re sending SQL fuzzing payloads to an API that leverages only
    NoSQL databases, your testing won’t be as effective.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会根据API响应中收到的信息，从通用模糊测试转向更具针对性的模糊测试。类似于第6章中的侦察工作，你需要根据通用测试的结果调整模糊测试并集中精力。知道使用的技术后，针对性的模糊测试有效性更强。如果你向一个只使用NoSQL数据库的API发送SQL模糊测试有效负载，那么你的测试将不会那么有效。
- en: One of the best sources for fuzzing payloads is SecLists ([https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)).
    SecLists has a whole section dedicated to fuzzing, and its *big-list-of-naughty-strings.txt*
    wordlist is excellent at causing useful responses. The fuzzdb project is another
    good source for fuzzing payloads ([https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb)).
    Also, Wfuzz has many useful payloads ([https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz)),
    including a great list that combines several targeted payloads in their injection
    directory, called *All_attack.txt*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试负载的最佳来源之一是SecLists（[https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)）。SecLists有一个专门的模糊测试部分，其*big-list-of-naughty-strings.txt*词表在引发有用响应方面表现出色。fuzzdb项目是另一个很好的模糊测试负载来源（[https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb)）。此外，Wfuzz也有许多有用的负载（[https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz)），其中包括一个很棒的列表，结合了多个目标负载，位于其注入目录中，名为*All_attack.txt*。
- en: 'Additionally, you can always quickly and easily create your own generic fuzzing
    payload list. In a text file, combine symbols, numbers, and characters to create
    each payload as line-separated entries, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以快速轻松地创建自己的通用模糊测试负载列表。在文本文件中，结合符号、数字和字符，将每个负载作为以换行符分隔的条目创建，像这样：
- en: '`AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`'
- en: '`9999999999999999999999999999999999999999`'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`9999999999999999999999999999999999999999`'
- en: '`~''!@#$%^&*()-_+`'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`~''!@#$%^&*()-_+`'
- en: '`{}[]|\:''''; ''<>?,./`'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{}[]|\:''''; ''<>?,./`'
- en: '`%00`'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%00`'
- en: '`0x00`'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0x00`'
- en: '`$ne`'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ne`'
- en: '`%24ne`'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%24ne`'
- en: '`$gt`'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$gt`'
- en: '`%24gt`'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%24gt`'
- en: '`|whoami`'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`|whoami`'
- en: '`-- -`'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-- -`'
- en: '`'' ''''`'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`'' ''''`'
- en: '`'' OR 1=1-- -`'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`'' OR 1=1-- -`'
- en: '`'''' ''''''''''''`'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`'''' ''''''''''''`'
- en: '`漢, さ, Ж, Ѫ, Ѭ, Ѧ, Ѩ, Ѯ`'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`漢, さ, Ж, Ѫ, Ѭ, Ѧ, Ѩ, Ѯ`'
- en: 😀 😃 😄 😁 😆
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 😀 😃 😄 😁 😆
- en: Note that instead of 40 instances of `A` or `9`, you could write payloads consisting
    of hundreds them. Using a small list like this as a fuzzing payload can cause
    all sorts of useful and interesting responses from an API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与你使用40个`A`或`9`的情况不同，你可以编写包含成百上千个这些字符的负载。像这样的简单列表作为模糊测试负载，可能会从API中引发各种有用和有趣的响应。
- en: Detecting Anomalies
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测异常
- en: 'When fuzzing, you’re attempting to cause the API or its supporting technologies
    to send you information that you can leverage in additional attacks. When an API
    request payload is handled properly, you should receive some sort of HTTP response
    code and message indicating that your fuzzing did not work. For example, sending
    a request with a string of letters when numbers are expected could result in a
    simple response like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行模糊测试时，你的目标是让API或其支持的技术发送信息给你，这些信息可以被用来进行进一步的攻击。当API请求负载被正确处理时，你应该收到某种HTTP响应代码和消息，表明你的模糊测试未能成功。例如，当预期接收数字时，发送一串字母可能会导致如下简单的响应：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From this response, you can deduce that the developers configured the API to
    properly handle requests like yours and prepared a tailored response.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个响应中，你可以推断出开发者已配置API来正确处理像你这样的请求，并准备了一个定制的响应。
- en: 'When input is not handled properly and causes an error, the server will often
    return that error in the response. For example, if you sent input like `~''!@#$%^&*()-_+`
    to an endpoint that improperly handles it, you could receive an error like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入未正确处理并导致错误时，服务器通常会在响应中返回该错误。例如，如果你向一个处理不当的端点发送了类似`~'!@#$%^&*()-_+`的输入，你可能会收到类似下面的错误：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This response immediately reveals that you’re interacting with an API request
    that does not handle input properly and that the backend of the application is
    utilizing a SQL database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应立刻揭示了你正在与一个未正确处理输入的API请求交互，并且该应用程序的后端正在使用SQL数据库。
- en: You’ll typically be analyzing hundreds or thousands of responses, not just two
    or three. Therefore, you need to filter your responses in order to detect anomalies.
    One way to do this is to understand what ordinary responses look like. You can
    establish this baseline by sending a set of expected requests or, as you’ll see
    later in the lab, by sending requests that you expect to fail. Then you can review
    the results to see if a majority of them are identical. For example, if you issue
    100 API requests and 98 of those result in an HTTP 200 response code with a similar
    response size, you can consider those requests to be your baseline. Also examine
    a few of the baseline responses to get a sense of their content. Once you know
    that the baseline responses have been properly handled, review the two anomalous
    responses. Figure out what input caused the difference, paying particular attention
    to the HTTP response code, response size, and the content of the response.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你将分析数百或数千个响应，而不仅仅是两个或三个。因此，你需要过滤响应以便检测异常。做到这一点的一种方法是了解普通响应的样子。你可以通过发送一组预期的请求来建立这个基准，或者如你稍后在实验中看到的那样，发送你预计会失败的请求。然后，你可以查看结果，看看大多数是否是相同的。例如，如果你发出
    100 个 API 请求，其中 98 个返回 HTTP 200 响应码且响应大小相似，你可以将这些请求视为基准。同时，检查一些基准响应的内容，以了解它们的内容。一旦你知道基准响应已被正确处理，再检查两个异常响应。找出导致差异的输入，特别关注
    HTTP 响应码、响应大小和响应内容。
- en: In some cases, the differences between baseline and anomalous requests will
    be miniscule. For example, the HTTP response codes might all be identical, but
    a few requests might result in a response size that is a few bytes larger than
    the baseline responses. When small differences like this come up, use Burp Suite’s
    Comparer to get a side-by-side comparison of the differences within the responses.
    Right-click the result you’re interested in and choose **Send to Comparer (Response)**.
    You can send as many responses as you’d like to Comparer, but you’ll at least
    need to send two. Then migrate to the Comparer tab, as shown in [Figure 9-1](#figure9-1).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，基准请求和异常请求之间的差异可能微乎其微。例如，HTTP 响应码可能完全相同，但某些请求的响应大小可能比基准响应大几字节。当出现这样的小差异时，使用
    Burp Suite 的比较器来进行响应差异的并排比较。右键点击你感兴趣的结果并选择**发送到比较器（响应）**。你可以将任意多个响应发送到比较器，但至少需要发送两个。然后切换到比较器标签，如[图
    9-1](#figure9-1)所示。
- en: '![screenshot of the burp suite comparer tab that lists results to be selected
    for comparison](image_fi/502444c09/F09001.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![显示 burp suite 比较器标签的截图，列出了待选择进行比较的结果](image_fi/502444c09/F09001.png)'
- en: 'Figure 9-1: Burp Suite’s Comparer'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：Burp Suite 的比较器
- en: Select the two results you would like to compare and use the **Compare Words**
    button (located at the bottom right of the window) to pull up a side-by-side comparison
    of the responses (see [Figure 9-2](#figure9-2)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你想要比较的两个结果，并使用**比较单词**按钮（位于窗口右下角）来显示响应的并排比较（参见[图 9-2](#figure9-2)）。
- en: '![screenshot of the burp suite compare words window that shows the responses
    for the results previously selected](image_fi/502444c09/F09002.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![显示已选择结果响应的 burp suite 比较单词窗口截图](image_fi/502444c09/F09002.png)'
- en: 'Figure 9-2: Comparing two API responses with Comparer'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：使用比较器比较两个 API 响应
- en: A useful option located at the bottom-right corner, called Sync Views, will
    help you synchronize the two responses. Sync Views is especially useful when you’re
    looking for small differences in large responses, as it will automatically highlight
    differences between the two responses. The highlights signify whether the difference
    has been modified, deleted, or added.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个位于右下角的有用选项，称为“同步视图”（Sync Views），将帮助你同步两个响应。当你在寻找大响应中的细微差异时，Sync Views 特别有用，因为它会自动突出显示两个响应之间的差异。这些高亮标记表示差异是否已被修改、删除或添加。
- en: Fuzzing Wide and Deep
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊测试广泛与深入
- en: 'This section will introduce you to two fuzzing techniques: fuzzing wide and
    fuzzing deep. *Fuzzing wide* is the act of sending an input across all of an API’s
    unique requests in an attempt to discover a vulnerability. *Fuzzing deep* is the
    act of thoroughly testing an individual request with a variety of inputs, replacing
    headers, parameters, query strings, endpoint paths, and the body of the request
    with your payloads. You can think of fuzzing wide as testing a mile wide but an
    inch deep and fuzzing deep as testing an inch wide but a mile deep.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向你介绍两种模糊测试技术：广泛模糊测试和深入模糊测试。*广泛模糊测试*是指将输入发送到 API 的所有独特请求，以尝试发现漏洞。*深入模糊测试*是指对单个请求进行彻底测试，使用各种输入替换请求中的头部、参数、查询字符串、端点路径和请求体。你可以将广泛模糊测试理解为测试一英里宽但只有一英寸深，而深入模糊测试则是测试一英寸宽但有一英里深。
- en: Wide and deep fuzzing can help you adequately evaluate every feature of larger
    APIs. When you’re hacking, you’ll quickly discover that APIs can greatly vary
    in size. Certain APIs could have only a few endpoints and a handful of unique
    requests, so you may be able to easily test them by sending a few requests. An
    API can have many endpoints and unique requests, however. Alternatively, a single
    request could be filled with many headers and parameters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛和深入的模糊测试可以帮助你充分评估大型 API 的每个功能。当你进行黑客攻击时，你会很快发现 API 的规模差异很大。某些 API 可能只有几个端点和少数独特的请求，因此你可以通过发送少量请求轻松进行测试。然而，一个
    API 可能有许多端点和独特的请求。此外，单个请求可能包含许多头部和参数。
- en: This is where the two fuzzing techniques come into play. Fuzzing wide is best
    used to test for issues across all unique requests. Typically, you can fuzz wide
    to test for improper assets management (more on this later in this chapter), finding
    all valid request methods, token-handling issues, and other information disclosure
    vulnerabilities. Fuzzing deep is best used for testing many aspects of individual
    requests. Most other vulnerability discovery will be done by fuzzing deep. In
    later chapters, we will use the fuzzing-deep technique to discover different types
    of vulnerabilities, including BOLA, BFLA, injection, and mass assignment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是两种模糊测试技术发挥作用的地方。广泛模糊测试最适合用于测试所有独特请求中的问题。通常，你可以使用广泛模糊测试来检测不当的资产管理（稍后在本章中详细讨论），查找所有有效的请求方法、令牌处理问题和其他信息泄露漏洞。深入模糊测试最适合用于测试单个请求的多个方面。其他大多数漏洞发现将通过深入模糊测试完成。在后续章节中，我们将使用深入模糊测试技术发现不同类型的漏洞，包括
    BOLA、BFLA、注入漏洞和批量赋值漏洞。
- en: Fuzzing Wide with Postman
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Postman 进行广泛模糊测试
- en: I recommend using Postman to fuzz wide for vulnerabilities across an API, as
    the tool’s Collection Runner makes it easy to run tests against all API requests.
    If an API includes 150 unique requests across all the endpoints, you can set a
    variable to a fuzzing payload entry and test it across all 150 requests. This
    is particularly easy to do when you’ve built a collection or imported API requests
    into Postman. For example, you might use this strategy to test whether any of
    the requests fail to handle various “bad” characters. Send a single payload across
    the API and check for anomalies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐使用 Postman 进行广泛的模糊测试，以检查 API 中的漏洞，因为该工具的集合运行器使得对所有 API 请求进行测试变得容易。如果一个 API
    包含 150 个独特的请求，你可以设置一个变量为模糊测试载荷，并在所有 150 个请求中进行测试。当你已经构建了一个集合或将 API 请求导入到 Postman
    时，这样做尤其简单。例如，你可以使用此策略来测试是否有任何请求未能处理各种“坏”字符。发送一个单一的载荷到整个 API，并检查是否有异常。
- en: Create a Postman environment in which to save a set of fuzzing variables. This
    lets you seamlessly use the environmental variables from one collection to the
    next. Once the fuzzing variables are set, just as they are in [Figure 9-3](#figure9-3),
    you can save or update the environment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 Postman 环境，用于保存一组模糊测试变量。这样，你就可以无缝地将环境变量从一个集合传递到下一个集合。一旦设置了模糊测试变量，就像在[图
    9-3](#figure9-3)中所示，你可以保存或更新该环境。
- en: At the top right, select the fuzzing environment and then use the variable shortcut
    `{{``variable name``}}` wherever you would like to test a value in a given collection.
    In [Figure 9-4](#figure9-4), I’ve replaced the `x-access-token` header with the
    first fuzzing variable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角选择模糊测试环境，然后在任何你希望测试值的地方使用变量快捷方式 `{{``变量名``}}`。在[图 9-4](#figure9-4)中，我将 `x-access-token`
    头部替换为第一个模糊测试变量。
- en: '![screenshot of postman’s manage environments window that lists fuzzing variables,
    their initial values, and their current values](image_fi/502444c09/F09003.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 管理环境窗口的截图，列出了模糊测试变量、它们的初始值和当前值](image_fi/502444c09/F09003.png)'
- en: 'Figure 9-3: Creating fuzzing variables in the Postman environment editor'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：在 Postman 环境编辑器中创建模糊测试变量
- en: '![screenshot of the postman’s edit collection window’s authorization tab that
    shows the x-access-token header is replaced with fuzz1](image_fi/502444c09/F09004.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 编辑集合窗口的授权标签截图，显示 x-access-token 头被 fuzz1 替换](image_fi/502444c09/F09004.png)'
- en: 'Figure 9-4: Fuzzing a collection token header'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：对集合令牌头进行模糊测试
- en: Additionally, you could replace parts of the URL, the other headers, or any
    custom variables you’ve set in the collection. Then you use the Collection Runner
    to test every request within the collection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以替换 URL 中的部分内容、其他头部，或你在集合中设置的任何自定义变量。然后，你使用集合运行器来测试集合中的每个请求。
- en: Another useful Postman feature when fuzzing wide is Find and Replace, found
    at the bottom left of Postman. Find and Replace lets you search a collection (or
    all collections) and replace certain terms with a replacement of your choice.
    If you were attacking the Pixi API, for example, you might notice that many placeholder
    parameters use tags like `<email>`, `<number>`, `<string>`, and `<boolean>`. This
    makes it easy to search for these values and replace them with either legitimate
    ones or one of your fuzzing variables, like `{{fuzz1}}`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在广泛模糊测试时有用的 Postman 特性是“查找和替换”，它位于 Postman 左下角。查找和替换让你搜索集合（或所有集合），并将某些术语替换为你选择的替代项。例如，如果你正在攻击
    Pixi API，你可能会注意到许多占位符参数使用像 `<email>`、`<number>`、`<string>` 和 `<boolean>` 这样的标签。这使得搜索这些值并将其替换为合法值或你的一些模糊测试变量（如
    `{{fuzz1}}`）变得非常容易。
- en: 'Next, try creating a simple test in the Tests panel to help you detect anomalies.
    For instance, you could set up the test covered in Chapter 4 for a status code
    of 200 across a collection:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试在“Tests”面板中创建一个简单的测试，帮助你检测异常。例如，你可以设置第 4 章中提到的测试，检查集合中的所有请求是否返回状态码 200：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this test, Postman will check that responses have a status code of 200,
    and when a response is 200, it will pass the test. You can easily customize this
    test by replacing 200 with your preferred status code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，Postman 将检查响应是否返回状态码 200，当响应为 200 时，它将通过测试。你可以通过将 200 替换为你喜欢的状态码来轻松定制这个测试。
- en: There are several ways to launch the Collection Runner. You can click the **Runner
    Overview** button, the arrow next to a collection, or the **Run** button. As mentioned
    earlier, you’ll need to develop a baseline of normal responses by sending requests
    with no values or expected values to the targeted field. An easy way to get such
    a baseline is to unselect the checkbox **Keep Variable Values**. With this option
    turned off, your variables won’t be used in the first collection run.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 启动集合运行器有几种方式。你可以点击 **Runner Overview** 按钮、集合旁边的箭头，或点击 **Run** 按钮。如前所述，你需要通过发送没有值或预期值的请求到目标字段，来开发一个正常响应的基线。获得这样的基线的一种简单方法是取消勾选
    **Keep Variable Values** 复选框。关闭此选项后，变量将在第一次集合运行时不会被使用。
- en: When we run this sample collection with the original request values, 13 requests
    pass our status code test and 5 fail. There is nothing extraordinary about this.
    The 5 failed attempts may be missing parameters or other input values, or they
    may just have response codes that are not 200\. Without us making additional changes,
    this test result could function as a baseline.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用原始请求值运行这个示例集合时，13 个请求通过了状态码测试，5 个请求失败了。这并不奇怪。失败的 5 次尝试可能缺少参数或其他输入值，或者它们的响应代码不是
    200。在我们没有做额外修改的情况下，这个测试结果可以作为基准。
- en: Now let’s try fuzzing the collection. Make sure your environment is set up correctly,
    responses are saved for our review, that **Keep Variable Values** is checked,
    and that any responses that generate new tokens are disabled (we can test those
    requests with deep fuzzing techniques). In [Figure 9-5](#figure9-5), you can see
    these settings applied.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试对集合进行模糊测试。确保你的环境设置正确，响应已保存以供审查，**Keep Variable Values** 选项已选中，并且任何生成新令牌的响应都已禁用（我们可以使用深度模糊测试技术测试这些请求）。在
    [图 9-5](#figure9-5) 中，你可以看到这些设置已应用。
- en: '![screenshot of postman’s collection runner results that shows requests and
    their responses](image_fi/502444c09/F09005.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 集合运行器结果截图，显示请求及其响应](image_fi/502444c09/F09005.png)'
- en: 'Figure 9-5: Postman Collection Runner results'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：Postman 集合运行器结果
- en: Run the collection and then look for deviations from the baseline responses.
    Also watch for changes in the request behavior. For example, when we ran the requests
    using the value `Fuzz1('OR 1=1-- -)`, the Collection Runner passed three tests
    and then failed to process any additional requests. This is an indication that
    the web application took issue with the fuzzing attempt involved in the fourth
    request. Although we did not receive an interesting response, the behavior itself
    is an indication that you may have discovered a vulnerability.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行集合后，查看是否有偏离基准响应的情况。还要注意请求行为的变化。例如，当我们使用值`Fuzz1('OR 1=1-- -)`运行请求时，集合运行器通过了三次测试，然后未能处理任何额外请求。这表明
    Web 应用程序对第四个请求中的模糊尝试产生了问题。虽然我们没有收到有趣的响应，但行为本身表明你可能发现了一个漏洞。
- en: Once you’ve cycled through a collection run, update the fuzzing value to the
    next variable you would like to test, perform another collection run, and compare
    results. You could detect several vulnerabilities by fuzzing wide with Postman,
    such as improper assets management, injection weaknesses, and other information
    disclosures that could lead to more interesting findings. When you’ve exhausted
    your fuzzing-wide attempts or found an interesting response, it is time to pivot
    your testing to fuzzing deep.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你循环完成一次集合运行，更新模糊值为下一个你想测试的变量，执行另一次集合运行，并比较结果。你可以通过在 Postman 中广泛进行模糊测试来发现几个漏洞，比如不当的资产管理、注入漏洞以及其他可能导致更有趣发现的信息泄露。当你耗尽了广泛模糊测试的尝试或发现了有趣的响应时，是时候将测试转向深入模糊测试了。
- en: Fuzzing Deep with Burp Suite
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Burp Suite 进行深入模糊测试
- en: You should fuzz deep whenever you want to drill down into specific requests.
    The technique is especially useful for thoroughly testing each individual API
    request. For this task, I recommend using Burp Suite or Wfuzz.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要深入分析特定请求时，应该进行深入模糊测试。这项技术对于彻底测试每个单独的 API 请求尤其有用。对于这个任务，我建议使用 Burp Suite
    或 Wfuzz。
- en: In Burp Suite, you can use Intruder to fuzz every header, parameter, query string,
    and endpoint path, along with any item included in the body of the request. For
    example, in a request like the one in [Figure 9-6](#figure9-6), shown in Postman,
    with many fields in the request body, you can perform a deep fuzz that passes
    hundreds or even thousands of fuzzing inputs into each value to see how the API
    responds.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Burp Suite 中，你可以使用 Intruder 对每个头部、参数、查询字符串和端点路径进行模糊测试，以及请求体中包含的任何项。例如，在如[图
    9-6](#figure9-6)所示的 Postman 请求中，请求体包含许多字段，你可以进行深入的模糊测试，将成百上千的模糊输入传入每个值，以查看 API
    如何响应。
- en: '![screenshot of a request in postman under edit user information; the body
    of the request contains the following: “user”: “<email>”, / “pass”: “<string>”,
    / “id”: “<number>”, “name”: “<string>”, “is_admin”: “<boolean>”, “account_balance”:
    “<number>”](image_fi/502444c09/F09006.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![在 Postman 中编辑用户信息的请求截图；请求体包含以下内容：“user”: “<email>”, / “pass”: “<string>”,
    / “id”: “<number>”, “name”: “<string>”, “is_admin”: “<boolean>”, “account_balance”:
    “<number>”](image_fi/502444c09/F09006.png)'
- en: 'Figure 9-6: A PUT request in Postman'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6：Postman 中的 PUT 请求
- en: While you might initially craft your requests in Postman, make sure to proxy
    the traffic to Burp Suite. Start Burp Suite, configure the Postman proxy settings,
    send the request, and make sure it was intercepted. Then forward it to Intruder.
    Using the payload position markers, select every field’s value to send a payload
    list as each of those values. A sniper attack will cycle a single wordlist through
    each attack position. The payload for an initial fuzzing attack could be similar
    to the list described in the “Choosing Fuzzing Payloads” section of this chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你最初可能在 Postman 中构建请求，但确保将流量代理到 Burp Suite。启动 Burp Suite，配置 Postman 的代理设置，发送请求，并确保它已被拦截。然后将其转发到
    Intruder。使用负载位置标记，选择每个字段的值，将负载列表作为每个值发送。狙击攻击会将单一的字典列表循环通过每个攻击位置。初步模糊攻击的负载可能类似于本章“选择模糊负载”部分描述的列表。
- en: 'Before you begin, consider whether a request’s field expects any particular
    value. For example, take a look at the following PUT request, where the tags (`<
    >`) suggest that the API is configured to expect certain values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，考虑请求的字段是否期望某些特定的值。例如，查看以下 PUT 请求，其中标签（`< >`）表明 API 配置为期望某些值：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you’re fuzzing, it is always worthwhile to request the unexpected. If
    a field expects an email, send numbers. If it expects numbers, send a string.
    If it expects a small string, send a huge string. If it expects a Boolean value
    (true/false), send anything else. Another useful tip is to send the expected value
    and include a fuzzing attempt following that value. For example, email fields
    are fairly predictable, and developers often nail down the input validation to
    make sure that you are sending a valid-looking email. Since this is the case,
    when you fuzz an email field, you may receive the same response for all your attempts:
    “not a valid email.” In this case, check to see what happens if you send a valid-looking
    email followed by a fuzzing payload. That would look something like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行模糊测试时，始终值得请求意外的内容。如果一个字段期望电子邮件，发送数字。如果它期望数字，发送字符串。如果它期望一个小字符串，发送一个巨大的字符串。如果它期望布尔值（true/false），发送其他任何内容。另一个有用的技巧是发送预期值并在该值后添加一个模糊测试尝试。例如，电子邮件字段是相当可预测的，开发人员通常会对输入验证进行严格检查，以确保你发送的是有效的电子邮件。因为是这种情况，当你对电子邮件字段进行模糊测试时，你可能会收到相同的响应：“无效的电子邮件”。在这种情况下，检查如果你发送一个看起来有效的电子邮件，并在其后添加模糊测试有效载荷会发生什么。这将看起来像这样：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you receive the same response (“not a valid email”), it is likely time to
    try a different payload or move on to a different field.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到相同的响应（“无效的电子邮件”），很可能是时候尝试不同的有效载荷或转到其他字段了。
- en: When fuzzing deep, be aware of how many requests you’ll be sending. A sniper
    attack containing a list of 12 payloads across 6 payload positions will result
    in 72 total requests. This is a relatively small number of requests.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行深度模糊测试时，注意你将发送多少请求。一个包含12个有效载荷、跨6个有效载荷位置的狙击攻击将导致72个总请求。这是一个相对较小的请求数量。
- en: When you receive your results, Burp Suite has a few tools to help detect anomalies.
    First, organize the requests by column, such as status code, length of the response,
    and request number, each of which can yield useful information. Additionally,
    Burp Suite Pro allows you to filter by search terms.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你收到结果时，Burp Suite 提供了一些工具来帮助检测异常。首先，按列组织请求，例如状态码、响应长度和请求编号，这些都能提供有用的信息。此外，Burp
    Suite Pro 允许你按搜索词进行筛选。
- en: 'If you notice an interesting response, select the result and choose the **Response**
    tab to dissect how the API provider responded. In [Figure 9-7](#figure9-7), fuzzing
    any field with the payload `{}[]|\:";''<>?,./` resulted in an HTTP 400 response
    code and the response `SyntaxError: Unexpected token in JSON at position 32`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你注意到一个有趣的响应，选择该结果并选择**响应**标签，分析 API 提供方如何响应。在[图 9-7](#figure9-7)中，使用有效载荷
    `{}[]|\:";''<>?,./` 对任何字段进行模糊测试，结果是 HTTP 400 响应代码和响应 `SyntaxError: Unexpected
    token in JSON at position 32`。'
- en: '![screenshot of burp suite showing an http 400 response code and a syntaxerror](image_fi/502444c09/F09007.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![burp suite 截图，显示 HTTP 400 响应代码和语法错误](image_fi/502444c09/F09007.png)'
- en: 'Figure 9-7: Burp Suite attack results'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-7：Burp Suite 攻击结果
- en: Once you have an interesting error like this one, you could improve your payloads
    to narrow down exactly what is causing the error. If you figure out the exact
    symbol or combination of symbols causing the issue, attempt to pair other payloads
    with it to see if you can get additional interesting responses. For instance,
    if the resulting responses indicate a database error, you could use payloads that
    target those databases. If the error indicates an operating system or specific
    programming language, use a payload targeting it. In this situation, the error
    is related to an unexpected JSON token, so it would be interesting to see how
    this endpoint handles JSON fuzzing payloads and what happens when additional payloads
    are added.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到像这样的有趣错误，你可以改进有效载荷，以精确确定导致错误的原因。如果你找出导致问题的确切符号或符号组合，尝试将其他有效载荷与其配对，看看能否获得更多有趣的响应。例如，如果返回的响应指示数据库错误，你可以使用针对这些数据库的有效载荷。如果错误指示操作系统或特定的编程语言，使用针对它的有效载荷。在这种情况下，错误与意外的
    JSON 令牌有关，因此看到该端点如何处理 JSON 模糊测试有效载荷，以及当添加更多有效载荷时会发生什么，将会很有趣。
- en: Fuzzing Deep with Wfuzz
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Wfuzz 进行深度模糊测试
- en: If you’re using Burp Suite CE, Intruder will limit the rate you can send requests,
    so you should use Wfuzz when sending a larger number of payloads. Using Wfuzz
    to send a large POST or PUT request can be intimidating at first due to the amount
    of information you’ll need to correctly add to the command line. However, with
    a few tips, you should be able to migrate back and forth between Burp Suite CE
    and Wfuzz without too many challenges.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Burp Suite CE，Intruder 会限制你发送请求的速率，因此在发送大量有效负载时，你应该使用 Wfuzz。最初，使用 Wfuzz
    发送一个大的 POST 或 PUT 请求可能会让人感到有些复杂，因为你需要在命令行中正确地添加大量信息。然而，只要掌握几个技巧，你应该能够在 Burp Suite
    CE 和 Wfuzz 之间来回切换，而不会遇到太多挑战。
- en: 'One advantage of Wfuzz is that it’s considerably faster than Burp Suite, so
    we can increase our payload size. The following example uses a SecLists payload
    called *big-list-of-naughty-strings.txt*, which contains over 500 values:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Wfuzz 的一个优点是它比 Burp Suite 快得多，因此我们可以增加有效负载的大小。以下示例使用了一个名为 *big-list-of-naughty-strings.txt*
    的 SecLists 有效负载，其中包含超过 500 个值：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let’s build our Wfuzz command step-by-step. First, to match the Burp Suite example
    covered in the previous section, we will need to include the `Content-Type` and
    `x-access-token` headers in order to receive authenticated results from the API.
    Each header is specified with the option `-H` and surrounded by quotes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步构建 Wfuzz 命令。首先，为了匹配前一节中讨论的 Burp Suite 示例，我们需要包含 `Content-Type` 和 `x-access-token`
    头，以便从 API 获取认证后的结果。每个头部通过 `-H` 选项指定，并用引号括起来。
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, note that the request method is PUT. You can specify it with the `-X`
    option. Also, to filter out responses with a status code of 400, use the `--hc
    400` option:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意请求方法是 PUT。你可以通过 `-X` 选项指定它。此外，为了过滤掉状态码为 400 的响应，可以使用 `--hc 400` 选项：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, to fuzz a request body using Wfuzz, specify the request body with the
    `-d` option and paste the body into the command, surrounded by quotes. Note that
    Wfuzz will normally remove quotes, so use backslashes to keep them in the request
    body. As usual, we replace the parameters we would like to fuzz with the term
    `FUZZ`. Finally, we use `-u` to specify the URL we’re attacking:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 Wfuzz 模糊测试请求体时，通过 `-d` 选项指定请求体，并将请求体粘贴到命令中，用引号括起来。请注意，Wfuzz 通常会删除引号，因此需要使用反斜杠来保留它们。在这种情况下，我们将要模糊测试的参数替换为
    `FUZZ`。最后，我们使用 `-u` 来指定我们要攻击的 URL：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a decent-sized command with plenty of room to make mistakes. If you
    need to troubleshoot it, I recommend proxying the requests to Burp Suite, which
    should help you visualize the requests you’re sending. To proxy traffic back to
    Burp, use the `-p` proxy option with your IP address and the port on which Burp
    Suite is running:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的命令，有足够的空间让人出错。如果你需要故障排除，建议将请求代理到 Burp Suite，这将帮助你可视化发送的请求。要将流量代理回 Burp，使用
    `-p` 代理选项，并指定 Burp Suite 运行所在的 IP 地址和端口：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In Burp Suite, inspect the intercepted request and send it to Repeater to see
    if there are any typos or mistakes. If your Wfuzz command is operating properly,
    run it and review the results, which should look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Burp Suite 中，检查拦截的请求并将其发送到 Repeater，以查看是否有任何拼写错误或其他问题。如果你的 Wfuzz 命令正常运行，执行它并查看结果，应该像这样：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now you can seek out the anomalies and conduct additional requests to analyze
    what you’ve found. In this case, it would be worth seeing how the API provider
    responds to the payload that caused a 302 response code. Use this payload in Burp
    Suite’s Repeater or Postman.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以寻找异常并执行额外的请求来分析你发现的内容。在这种情况下，值得观察 API 提供方如何回应导致 302 响应代码的有效负载。使用这个有效负载在
    Burp Suite 的 Repeater 或 Postman 中进行测试。
- en: Fuzzing Wide for Improper Assets Management
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广泛模糊测试不当资产管理
- en: Improper assets management vulnerabilities arise when an organization exposes
    APIs that are either retired, in a test environment, or still in development.
    In any of these cases, there is a good chance the API has fewer protections than
    its supported production counterparts. Improper assets management might affect
    only a single endpoint or request, so it’s often useful to fuzz wide to test if
    improper assets management exists for any request across an API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不当资产管理漏洞通常发生在组织暴露了已退役、处于测试环境中或仍在开发中的 API。在这些情况下，API 可能比其支持的生产环境版本具有更少的保护。不当资产管理可能仅影响单个端点或请求，因此通常需要广泛模糊测试，以检查
    API 中的任何请求是否存在不当资产管理。
- en: As discussed in Chapter 3, you can find improper assets management vulnerabilities
    by paying close attention to outdated API documentation. If an organization’s
    API documentation has not been updated along with the organization’s API endpoints,
    it could contain references to portions of the API that are no longer supported.
    Also, check any sort of changelog or GitHub repository. A changelog that says
    something along the lines of “resolved broken object level authorization vulnerability
    in v3” will make finding an endpoint still using v1 or v2 all the sweeter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 3 章所述，你可以通过密切关注过时的 API 文档来发现不当的资产管理漏洞。如果一个组织的 API 文档没有随着组织的 API 端点更新，它可能会包含指向不再受支持的
    API 部分的引用。此外，检查任何类型的变更日志或 GitHub 仓库。如果变更日志中提到“解决了 v3 中的对象级授权漏洞”，那么找到仍在使用 v1 或
    v2 的端点将变得更加容易。
- en: Other than using documentation, you can discover improper assets vulnerabilities
    through the use of fuzzing. One of the best ways to do this is to watch for patterns
    in the business logic and test your assumptions. For example, in [Figure 9-8](#figure9-8),
    you can see that the `baseURL` variable used within all requests for this collection
    is *https://petstore.swagger.io/v2*. Try replacing *v2* with *v1* and using Postman’s
    Collection Runner.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用文档，你还可以通过模糊测试（fuzzing）来发现不当的资产漏洞。最好的方法之一是观察业务逻辑中的模式并测试你的假设。例如，在[图 9-8](#figure9-8)中，你可以看到在该集合的所有请求中使用的`baseURL`变量是*https://petstore.swagger.io/v2*。尝试将*v2*替换为*v1*，然后使用
    Postman 的集合运行器（Collection Runner）进行测试。
- en: '![screenshot of postman showing the variables tab within a collection](image_fi/502444c09/F09008.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 中显示集合内变量选项卡的截图](image_fi/502444c09/F09008.png)'
- en: 'Figure 9-8: Editing the collection variables within Postman'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-8：在 Postman 中编辑集合变量
- en: 'The production version of the sample API is *v2*, so it would be a good idea
    to test a few keywords, like *v1*, *v3*, *test*, *mobile*, *uat*, *dev*, and *old*,
    as well as any interesting paths discovered during analysis or reconnaissance
    testing. Additionally, some API providers will allow access to administrative
    functionality by adding */internal/* to the path before or after the versioning,
    which would look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 API 的生产版本是*v2*，因此，测试一些关键词会是个好主意，如*v1*、*v3*、*test*、*mobile*、*uat*、*dev*和*old*，以及在分析或侦察测试过程中发现的任何有趣路径。此外，一些
    API 提供商通过在版本号前后添加*/internal/*，允许访问管理功能，路径可能如下所示：
- en: '*/api/v2/****internal****/users*'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/api/v2/****internal****/users*'
- en: '*/api/****internal****/v2/users*'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/api/****internal****/v2/users*'
- en: As discussed earlier in the section, begin by developing a baseline for how
    the API responds to typical requests using the Collection Runner with the API’s
    expected version path. Figure out how an API responds to a successful request
    and how it responds to bad ones (or requests for resources that do not exist).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，首先使用 API 预期的版本路径，通过集合运行器（Collection Runner）开发一个基准，了解 API 对典型请求的响应。弄清楚 API
    如何响应成功的请求以及如何响应错误的请求（或对不存在的资源的请求）。
- en: To make our testing easier, we’ll set up the same test for status codes of 200
    we used earlier in this chapter. If the API provider typically responds with status
    code 404 for nonexistent resources, a 200 response for those resources would likely
    indicate that the API is vulnerable. Make sure to insert this test at the collection
    level so that it will be run on every request when you use the Collection Runner.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的测试，我们将设置与本章前面使用的相同的状态码为 200 的测试。如果 API 提供商通常对不存在的资源返回状态码 404，那么对于这些资源返回
    200 状态码很可能表明该 API 存在漏洞。确保在集合级别插入此测试，以便在使用集合运行器时在每个请求上运行它。
- en: Now save and run your collection. Inspect the results for any requests that
    pass this test. Once you’ve reviewed the results, rinse and repeat with a new
    keyword. If you discover an improper asset management vulnerability, your next
    step will be to test the non-production endpoint for additional weaknesses. This
    is where your information-gathering skills will be put to good use. On the target’s
    GitHub or in a changelog, you might discover that the older version of the API
    was vulnerable to a BOLA attack, so you could attempt such an attack on the vulnerable
    endpoint. If you don’t find any leads during reconnaissance, combine the other
    techniques found in this book to leverage the vulnerability.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存并运行你的集合。检查通过此测试的请求的结果。查看结果后，换一个新关键字继续测试。如果你发现了不当的资产管理漏洞，下一步将是测试非生产环境端点，寻找更多弱点。这时，你的信息收集技巧将派上用场。在目标的GitHub或更新日志中，你可能会发现API的旧版本曾遭受BOLA攻击，因此你可以尝试对该漏洞端点进行攻击。如果在侦察过程中没有找到任何线索，可以结合本书中的其他技术来利用漏洞。
- en: Testing Request Methods with Wfuzz
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Wfuzz测试请求方法
- en: One practical way to use fuzzing is to determine all the HTTP request methods
    available for a given API request. You can use several of the tools we’ve introduced
    to perform this task, but this section will demonstrate it with Wfuzz.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实际使用模糊测试的方法是确定给定API请求的所有可用HTTP请求方法。你可以使用我们介绍的几种工具来执行这个任务，但这一节将使用Wfuzz演示如何进行。
- en: 'First, capture or craft the API request whose acceptable HTTP methods you would
    like to test. In this example, we’ll use the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，捕获或构造你希望测试的API请求及其可接受的HTTP方法。在本例中，我们将使用以下请求：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, create your request with Wfuzz, using `-X FUZZ` to specifically fuzz
    the HTTP method. Run Wfuzz and review the results:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用Wfuzz创建请求，使用`-X FUZZ`来专门模糊测试HTTP方法。运行Wfuzz并查看结果：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Based on these results, you can see that the baseline response tends to include
    a 405 status code (Method Not Allowed) and a response length of 163 characters.
    The anomalous responses include the two request methods with 200 response codes.
    This confirms that GET and HEAD requests both work, which doesn’t reveal much
    of anything new. However, this test also reveals that you can use a POST request
    to the *api/v2/account* endpoint. If you were testing an API that did not include
    this request method in its documentation, there is a chance you may have discovered
    functionality that was not intended for end users. Undocumented functionality
    is a good find that should be tested for additional vulnerabilities.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些结果，你可以看到基础响应通常包括405状态码（方法不被允许）和163个字符的响应长度。异常响应包括两个请求方法，它们返回200状态码。这证实了GET和HEAD请求都有效，但没有透露什么新的信息。然而，这个测试也表明，你可以对*api/v2/account*端点使用POST请求。如果你正在测试的API文档中没有包括这种请求方法，那么你可能发现了一个不应对最终用户开放的功能。未记录的功能是一个很好的发现，应该进一步测试是否存在其他漏洞。
- en: Fuzzing “Deeper” to Bypass Input Sanitization
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对输入清洗进行“更深”模糊测试以绕过限制
- en: When fuzzing deep, you’ll want to be strategic about setting payload positions.
    For example, for an email field in a PUT request, an API provider may do a pretty
    decent job at requiring that the contents of the request body match the format
    of an email address. In other words, anything sent as a value that isn’t an email
    address might result in the same 400 Bad Request error. Similar restrictions likely
    apply to integer and Boolean values. If you’ve thoroughly tested a field and it
    doesn’t yield any interesting results, you may want to leave it out of additional
    tests or save it for more thorough testing in a separate attack.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行深度模糊测试时，你需要有策略地设置有效载荷位置。例如，对于PUT请求中的邮箱字段，API提供者可能会通过要求请求体的内容符合邮箱地址的格式来做得相当不错。换句话说，任何不是邮箱地址的值发送到该字段可能会导致相同的400错误（错误请求）。类似的限制可能也适用于整数和布尔值。如果你已经彻底测试了某个字段并且没有得到任何有趣的结果，你可能会选择将其排除在后续测试之外，或者将其保留用于在单独的攻击中进行更深入的测试。
- en: Alternatively, to fuzz even deeper into a specific field, you could try to escape
    whatever restrictions are in place. By *escaping*, I mean tricking the server’s
    input sanitization code into processing a payload it should normally restrict.
    There are a few tricks you could use against restricted fields.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，为了对特定字段进行更深层次的模糊测试，你可以尝试绕过任何已有的限制。所谓的*绕过*，是指欺骗服务器的输入清洗代码，使其处理原本应当限制的有效载荷。你可以使用一些技巧来针对受限字段进行攻击。
- en: 'First, try sending something that takes the form of the restricted field (if
    it’s an email field, include a valid-looking email), add a null byte, and then
    add another payload position for fuzzing payloads to be inserted. Here’s an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试发送一个看起来像是受限字段的内容（如果是电子邮件字段，包含一个看起来有效的电子邮件），然后添加空字节，再添加另一个有效载荷位置，用于插入模糊测试的有效载荷。以下是一个示例：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Instead of a null byte, try sending a pipe (`|`), quotes, spaces, and other
    escape symbols. Better yet, there are enough possible symbols to send that you
    could add a second payload position for typical escape characters, like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用空字节，试着发送管道符号（`|`）、引号、空格以及其他转义符号。更好的是，有足够多的符号可以发送，你可以为典型的转义字符添加第二个有效载荷位置，如下所示：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use a set of potential escape symbols for the `§escape§`payload and the payload
    you want to execute as the `§test§`. To perform this test, use Burp Suite’s cluster
    bomb attack, which will cycle through multiple payload lists and attempt every
    other payload against it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一组潜在的转义符号作为 `§escape§` 有效载荷，以及你希望执行的 `§test§` 有效载荷。进行此测试时，使用 Burp Suite 的集群炸弹攻击，它会循环通过多个有效载荷列表，并对每个有效载荷进行尝试：
- en: Escape1
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Escape1
- en: Escape1
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Escape1
- en: Escape1
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Escape1
- en: Escape2
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Escape2
- en: Escape2
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Escape2
- en: Escape2
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Escape2
- en: Payload1
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Payload1
- en: Payload2
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Payload2
- en: Payload3
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Payload3
- en: Payload1
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Payload1
- en: Payload2
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Payload2
- en: Payload3
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Payload3
- en: The cluster bomb fuzzing attack is excellent at exhausting certain combinations
    of payloads, but be aware that the request quantity will grow exponentially. We
    will spend more time with the style of fuzzing when we are attempting injection
    attacks in Chapter 12.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 集群炸弹模糊测试攻击非常擅长耗尽某些有效载荷组合，但要注意，请求数量将呈指数增长。当我们在第 12 章尝试注入攻击时，我们会花更多时间讲解这种模糊测试风格。
- en: Fuzzing for Directory Traversal
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录遍历模糊测试
- en: 'Another weakness you can fuzz for is directory traversal. Also known as path
    traversal, *directory traversal* is a vulnerability that allows an attacker to
    direct the web application to move to a parent directory using some form of the
    expression `../` and then read arbitrary files. You could leverage a series of
    path traversal dots and slashes in place of the escape symbols described in the
    previous section, like the following ones:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以进行模糊测试的弱点是目录遍历。目录遍历，也称为路径遍历，*目录遍历* 是一种漏洞，攻击者可以利用它让 Web 应用程序通过某种形式的 `../`
    表达式转到父目录，然后读取任意文件。你可以利用一系列路径遍历的点和斜杠来代替前一节中描述的转义符号，例如以下这些：
- en: '`..`'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`..`'
- en: '`..\`'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`..\`'
- en: '`../`'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`../`'
- en: '`\..\`'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\..\`'
- en: '`\..\.\`'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\..\.\`'
- en: This weakness has been around for many years, and all sorts of security controls,
    including user input sanitization, are normally in place to prevent it, but with
    the right payload, you might be able to avoid these controls and web application
    firewalls. If you’re able to exit the API path, you may be able to access sensitive
    information such as application logic, usernames, passwords, and additional personally
    identifiable information (like names, phone numbers, emails, and addresses).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种弱点已经存在多年，通常会采取各种安全控制措施，包括用户输入净化，以防止此类问题的发生，但如果使用合适的有效载荷，你可能能够绕过这些控制措施和 Web
    应用防火墙。如果你能够退出 API 路径，可能就能访问到敏感信息，如应用逻辑、用户名、密码以及额外的个人身份信息（如姓名、电话号码、电子邮件和地址）。
- en: Directory traversal can be conducted using both wide and deep fuzzing techniques.
    Ideally, you would fuzz deeply across all of an API’s requests, but since this
    can be an enormous task, try fuzzing wide and then focusing in on specific request
    values. Make sure to enrich your payloads with information collected from reconnaissance,
    endpoint analysis, and API responses containing errors or other information disclosures.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 目录遍历可以使用广度和深度模糊测试技术进行。理想情况下，你会对整个 API 的所有请求进行深度模糊测试，但由于这可能是一项庞大的任务，因此可以先进行广度模糊测试，然后再专注于特定的请求值。确保利用从侦察、端点分析和包含错误或其他信息披露的
    API 响应中收集的信息来丰富你的有效载荷。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered the art of fuzzing APIs, one of the most important attack
    techniques you’ll need to master. By sending the right inputs to the right parts
    of an API request, you can discover a variety of API weaknesses. We covered two
    strategies, fuzzing wide and deep, useful for testing the entire attack surface
    of large APIs. In the following chapters, we’ll return to the fuzzing deep technique
    to discover and attack many API vulnerabilities.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了模糊测试 API 的技术，这是你需要掌握的最重要的攻击技术之一。通过向 API 请求的正确部分发送正确的输入，你可以发现各种 API 弱点。我们讨论了两种策略：广度模糊测试和深度模糊测试，它们有助于测试大型
    API 的整个攻击面。在接下来的章节中，我们将回到深度模糊测试技巧，发现并攻击更多的 API 漏洞。
- en: 'Lab #6: Fuzzing for Improper Assets Management Vulnerabilities'
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '实验 #6：模糊测试不当资产管理漏洞'
- en: In this lab, you’ll put your fuzzing skills to the test against crAPI. If you
    haven’t done so already, build a crAPI Postman collection, as we did in Chapter
    7, and obtain a valid token. Now we can start by fuzzing wide and then pivot to
    fuzzing deep based on our findings.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，你将针对 crAPI 测试你的模糊测试技能。如果你还没有这么做，请按照第七章的步骤构建一个 crAPI Postman 集合，并获取一个有效的令牌。现在我们可以开始进行广泛的模糊测试，然后根据我们的发现转向深度模糊测试。
- en: Let’s begin by fuzzing for improper assets management vulnerabilities. First,
    we’ll use Postman to fuzz wide for various API versions. Open Postman and navigate
    to the environmental variables (use the eye icon located at the top right of Postman
    as a shortcut). Add a variable named `path` to your Postman environment and set
    the value to *v3*. Now you can update to test for various versioning-related paths
    (such as *v1*, *v2, internal*, and so on).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始进行不当资产管理漏洞的模糊测试。首先，我们将使用 Postman 对不同的 API 版本进行广泛的模糊测试。打开 Postman，导航到环境变量（使用位于
    Postman 右上角的眼睛图标作为快捷方式）。向 Postman 环境添加一个名为 `path` 的变量，并将其值设置为 *v3*。现在，你可以更新并测试与版本相关的路径（如
    *v1*、*v2*、*internal* 等）。
- en: 'To get better results from the Postman Collection Runner, we’ll configure a
    test using the Collection Editor. Select the crAPI collection options, choose
    **Edit**, and select the **Tests** tab. Add a test that will detect when a status
    code 404 is returned so that anything that does not result in a 404 Not Found
    response will stick out as anomalous. You can use the following test:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 Postman Collection Runner 中获得更好的结果，我们将使用 Collection Editor 配置一个测试。选择 crAPI
    集合选项，点击 **编辑**，然后选择 **测试** 标签。添加一个检测状态码 404 返回的测试，这样任何不返回 404 Not Found 响应的内容都会被视为异常。你可以使用以下测试：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run a baseline scan of the crAPI collection with the Collection Runner. First,
    make sure that your environment is up-to-date and **Save Responses** is checked
    (see [Figure 9-9](#figure9-9)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Collection Runner 对 crAPI 集合进行基线扫描。首先，确保你的环境是最新的，并且 **保存响应** 已勾选（参见 [图 9-9](#figure9-9)）。
- en: '![screenshot of postman’s collection runner window that shows save responses
    as checked](image_fi/502444c09/F09009.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 集合运行器窗口截图，显示保存响应已选中](image_fi/502444c09/F09009.png)'
- en: 'Figure 9-9: Postman Collection Runner'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-9：Postman 集合运行器
- en: Since we’re on the hunt for improper assets management vulnerabilities, we’ll
    only test API requests that contain versioning information in the path. Using
    Postman’s Find and Replace feature, replace the values *v2* and *v3* across the
    collection with the `path` variable (see [Figure 9-10](#figure9-10)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在寻找不当的资产管理漏洞，我们将仅测试路径中包含版本信息的 API 请求。使用 Postman 的查找和替换功能，将集合中的 *v2* 和 *v3*
    替换为 `path` 变量（参见 [图 9-10](#figure9-10)）。
- en: '![screenshot of postman’s find and replace window that shows v2 in the find
    box and {{path}} in the replace box](image_fi/502444c09/F09010.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 查找和替换窗口截图，显示查找框中的 v2 和替换框中的 {{path}}](image_fi/502444c09/F09010.png)'
- en: 'Figure 9-10: Replacing version information in the path with a Postman variable'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-10：用 Postman 变量替换路径中的版本信息
- en: 'You may have noticed a matter of interest regarding our collection: all of
    the endpoints have *v2* in their paths except for the password reset endpoint,
    */identity/api/auth/v3/check-otp*, which is using *v3*.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们集合中的一个有趣事项：除了密码重置端点 */identity/api/auth/v3/check-otp* 使用 *v3*，所有其他端点的路径中都包含
    *v2*。
- en: Now that the variable is set, run a baseline scan with a path that we expect
    to fail across the board. As shown in [Figure 9-11](#figure9-11), the `path` variable
    is set to a current value of `fail12345`, which is not likely to be a valid value
    in any endpoint. Knowing how the API reacts when it fails will help us understand
    how the API responds to requests for nonexistent paths. This baseline will aid
    our attempts to fuzz wide with the Collection Runner (see [Figure 9-12](#figure9-12)).
    If requests to paths that do not exist result in Success 200 responses, we’ll
    have to look out for other indicators to use to detect anomalies.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 变量设置好后，使用我们预计在所有端点中都会失败的路径运行基线扫描。如 [图 9-11](#figure9-11) 所示，`path` 变量的当前值设置为
    `fail12345`，这个值在任何端点中都不太可能有效。了解 API 在失败时的反应将帮助我们理解 API 对不存在路径的请求的响应方式。这一基线将有助于我们使用
    Collection Runner 进行广泛模糊测试（参见 [图 9-12](#figure9-12)）。如果请求不存在的路径时返回成功的 200 响应，我们就需要注意其他指标，以帮助检测异常。
- en: '![screenshot of postman’s manage environments window that shows the variable
    as path, the initial value as v2, and the current value as fail12345](image_fi/502444c09/F09011.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Postman的环境管理窗口截图，显示变量为path，初始值为v2，当前值为fail12345](image_fi/502444c09/F09011.png)'
- en: 'Figure 9-11: The improper assets management variable'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-11：不当的资产管理漏洞
- en: '![screenshot of postman’s collection runner test that shows all nine requests
    have failed](image_fi/502444c09/F09012.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Postman的Collection Runner测试截图，显示所有九个请求都失败了](image_fi/502444c09/F09012.png)'
- en: 'Figure 9-12: A baseline Postman Collection Runner test'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-12：一个基础的Postman Collection Runner测试
- en: As expected, [Figure 9-12](#figure9-12) shows that all nine requests failed
    the test, as the API provider returned a status code 404\. Now we can easily spot
    anomalies when testing for paths such as *test*, *mobile*, *uat*, *v1*, *v2*,
    and *v3*. Update the current value of the `path` variable to these other potentially
    unsupported paths and run the Collection Runner again. To quickly update a variable,
    click the eye icon found at the top right of Postman.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，[图9-12](#figure9-12)显示所有九个请求都失败了，因为API提供者返回了404状态码。现在，我们可以轻松地发现测试路径时的异常，比如*test*、*mobile*、*uat*、*v1*、*v2*和*v3*。将`path`变量的当前值更新为这些其他可能不受支持的路径，然后再次运行Collection
    Runner。要快速更新变量，请点击Postman右上角的眼睛图标。
- en: Things should start to get interesting when you return to the path values */v2*
    and */v3*. When the `path` variable is set to */v3*, all requests fail the test.
    This is slightly odd, because we noted earlier that the password reset request
    was using */v3*. Why is that request failing now? Well, based on the Collection
    Runner, the password reset request is actually receiving a 500 Internal Server
    Error, while all other requests are receiving a 404 Not Found status code. Anomaly!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你返回到路径值*/v2*和*/v3*时，事情应该开始变得有趣。当`path`变量设置为*/v3*时，所有请求都会失败。这有点奇怪，因为我们之前提到过密码重置请求是使用*/v3*路径的。为什么这个请求现在失败了呢？根据Collection
    Runner，密码重置请求实际上收到了一个500内部服务器错误，而所有其他请求都收到了404未找到状态码。异常！
- en: Investigating the password reset request further will show that an HTTP 500
    error is issued using the */v3* path because the application has a control that
    limits the number of times you can attempt to send the one-time passcode (OTP).
    Sending the same request to */v2* also results in an HTTP 500 error, but the response
    is slightly larger. It may be worth retrying the two requests back in Burp Suite
    and using Comparer to see the small differences. The */v3* password reset request
    responds with `{"message":"ERROR..","status":500}`. The */v2* password reset request
    responds with `{"message":"Invalid OTP! Please try again..","status":500}`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步调查密码重置请求会发现，使用*/v3*路径时发出了HTTP 500错误，因为应用程序有一个限制，限制了你尝试发送一次性验证码（OTP）的次数。将相同的请求发送到*/v2*也会导致HTTP
    500错误，但响应稍微大一些。也许可以尝试在Burp Suite中重新发送这两个请求，并使用Comparer查看其中的细微差异。*/v3*密码重置请求响应为`{"message":"ERROR..","status":500}`。*/v2*密码重置请求响应为`{"message":"Invalid
    OTP! Please try again..","status":500}`。
- en: 'The password reset request does not align with the baseline we have developed
    by responding with a 404 status code when a URL path is not in use. Instead, we
    have discovered an improper assets management vulnerability! The impact of this
    vulnerability is that */v2* does not have a limitation on the number of times
    we can guess the OTP. With a four-digit OTP, we should be able to fuzz deep and
    discover any OTP within 10,000 requests. Eventually, you’ll receive a message
    indicating your victory: `{"message":"OTP verified","status":200}`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 密码重置请求并未按照我们开发的基准来响应，当URL路径未使用时，应该返回404状态码。相反，我们发现了一个不当的资产管理漏洞！这个漏洞的影响是*/v2*路径没有限制我们猜测OTP的次数。使用四位数的OTP，我们应该能够通过模糊测试深入并在10,000个请求内发现任何OTP。最终，你会收到一条表明你成功的消息：`{"message":"OTP
    verified","status":200}`。
