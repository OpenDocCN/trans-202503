- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: SOFTWARE DEVELOPMENT METAPHORS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件开发隐喻**'
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: How do we define the software development process? This might seem like a silly
    question. Why not just say “software development is software development” and
    leave it at that? Well, if we can draw analogies between software development
    tasks and other professional endeavors, we can gain insight into the software
    development process. Then we can refine the process by studying process improvements
    in related fields. To that end, this chapter explores some of the common ways
    of understanding software development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何定义软件开发过程？这个问题看起来可能有些傻。为什么不直接说“软件开发就是软件开发”然后就算了呢？其实，如果我们能够将软件开发任务与其他专业领域进行类比，就能更深入地理解软件开发过程。然后我们可以通过研究相关领域的过程改进来优化软件开发过程。为此，本章将探讨一些理解软件开发的常见方式。
- en: '**1.1 What Is Software?**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**1.1 什么是软件？**'
- en: To better understand how programmers create software, we can compare software
    to other things people create. Doing so will provide important insight into why
    certain creative metaphors apply, or don’t apply, to software development.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解程序员如何创建软件，我们可以将软件与其他人类创造的事物进行比较。这样做将为我们提供重要的见解，帮助我们理解为什么某些创意隐喻适用于软件开发，或者为什么不适用。
- en: 'In his book, *Software Engineering: A Beginner’s Approach*, Robert Pressman
    identifies several characteristics of software. This section explores those characteristics
    to illuminate the nature of software and how it defines a computer programmer’s
    work.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的著作《软件工程：初学者的入门》中，罗伯特·普雷斯曼列出了软件的几个特点。本节将探讨这些特点，以阐明软件的本质以及它如何定义计算机程序员的工作。
- en: '***1.1.1 Software Is Not Manufactured***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.1.1 软件不是制造出来的***'
- en: '*Software is developed or engineered; it is not manufactured in the classical
    sense.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件是开发或工程化的；它不像传统意义上的产品那样被制造出来。*'
- en: —Robert Pressman
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: —罗伯特·普雷斯曼
- en: 'Compared to hardware products, the manufacturing cost of a software product
    is very low: stamping out a CD or DVD costs only a few pennies, plus a small amount
    for shipping and handling (and electronic distribution is even less expensive).
    Also, the software design has very little impact on the quality or final cost
    of the manufactured CD/DVD. Assuming reasonable quality controls at the manufacturing
    plant, a computer programmer rarely has to consider manufacturing issues when
    designing a software application.^([1](ch19_footnote.xhtml#ch01fn1)) Contrast
    this with other engineering professions where the engineer has to design in *manufacturability*
    of the product.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬件产品相比，软件产品的制造成本非常低：刻录一张CD或DVD的费用仅为几分钱，再加上一小部分运输和处理费用（而电子分发的成本更低）。此外，软件设计对制造的CD/DVD的质量或最终成本几乎没有影响。假设制造厂有合理的质量控制，计算机程序员在设计软件应用时很少需要考虑制造问题。^([1](ch19_footnote.xhtml#ch01fn1))
    与其他工程专业相比，工程师必须考虑如何设计产品的*可制造性*。
- en: '***1.1.2 Software Doesn’t Wear Out***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.1.2 软件不会磨损***'
- en: Both software and hardware suffer from failures due to poor design early in
    the products’ lives. However, if we could eliminate design flaws in the products
    (that is, deliver a defect-free piece of software or hardware), the differences
    between the two become obvious. Once a piece of software is correct, it doesn’t
    ever fail or “wear out.” As long as the underlying computer system is functioning
    properly, the software will continue to work.^([2](ch19_footnote.xhtml#ch01fn2))
    The software engineer, unlike the hardware engineer, doesn’t have to worry about
    designing in the ability to easily replace components that fail over time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 软件和硬件都可能因为设计不良而在产品生命周期早期出现故障。然而，如果我们能够消除产品中的设计缺陷（即交付一款没有缺陷的软件或硬件），那么二者之间的区别就变得明显了。一旦软件是正确的，它就不会出现故障或“磨损”。只要基础计算机系统正常运行，软件将继续工作。^([2](ch19_footnote.xhtml#ch01fn2))
    与硬件工程师不同，软件工程师不需要担心设计出能够轻松更换随时间失效的组件。
- en: '***1.1.3 Most Software Is Custom***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.1.3 大多数软件是定制开发的***'
- en: '*Most software is custom built rather than being assembled from existing [standard]
    components.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数软件是定制开发的，而不是从现有的[标准]组件中组装而成。*'
- en: —Robert Pressman
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: —罗伯特·普雷斯曼
- en: Although many attempts have been made to create similarly standardized software
    components that software engineers can assemble into large applications, the concept
    of a *software IC* (that is, the equivalent of an electronic integrated circuit)
    has never been realized. Software libraries and object-oriented programming techniques
    encourage reusing prewritten code, but the premise of constructing large software
    systems from smaller preassembled components has failed to produce anything close
    to what’s possible in hardware design.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有很多尝试旨在创建类似的标准化软件组件，以供软件工程师将其组装成大型应用程序，但*软件集成电路*（即电子集成电路的等效物）的概念从未实现。软件库和面向对象编程技术鼓励重用预先编写的代码，但从较小的预组装组件构建大型软件系统的前提未能产生接近硬件设计所能实现的成果。
- en: '***1.1.4 Software Can Be Easily Upgraded***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.1.4 软件可以轻松升级***'
- en: In many cases, it’s possible to completely replace an existing software application
    in the field with a new version (or even a completely different application) without
    incurring a huge cost.^([3](ch19_footnote.xhtml#ch01fn3)) The application’s end
    user can simply replace the old software with the new and enjoy the benefits of
    the upgraded version. In fact, most modern software systems and applications auto-update
    via the internet during normal operation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，完全可以在现场用新版本（甚至是完全不同的应用程序）替代现有的一个软件应用程序，而不会产生巨大的成本。^([3](ch19_footnote.xhtml#ch01fn3))
    应用程序的最终用户只需用新的软件替换旧的，并享受升级版本带来的好处。事实上，大多数现代软件系统和应用程序在正常运行过程中都会通过互联网自动更新。
- en: '***1.1.5 Software Is Not an Independent Entity***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.1.5 软件不是独立存在的实体***'
- en: Software is not a stand-alone product. An electrical engineer can design a hardware
    device that can operate completely on its own. However, software depends upon
    something else (typically a computer system) for proper operation. Therefore,
    a software developer must live with the constraints imposed by external systems
    (computer systems, operating systems, programming languages, and so on) when designing
    and implementing a software application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件不是独立的产品。电气工程师可以设计一个完全独立运行的硬件设备。然而，软件依赖于其他东西（通常是计算机系统）才能正常运行。因此，软件开发者在设计和实现软件应用程序时，必须遵循外部系统（计算机系统、操作系统、编程语言等）所施加的限制。
- en: '**1.2 Parallels to Other Fields**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**1.2 与其他领域的类比**'
- en: Computer programmers are often compared to artists, craftsmen, engineers, architects,
    and technicians. Although computer programming doesn’t match any of these professions
    exactly, we can draw useful parallels to these fields and gain insight from the
    techniques they employ.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序员常被与艺术家、工匠、工程师、建筑师和技术员相比。虽然计算机编程与这些职业没有完全相同的对应关系，但我们可以从这些领域中汲取有益的类比，获得它们所采用技术的启发。
- en: '***1.2.1 Programmer as Artist***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.2.1 程序员作为艺术家***'
- en: In the early days of computer programming, software development was considered
    an art. The ability to write software—to make sense of so much nonsense to create
    a working program—seemed to be a God-given talent exercised by a select few, akin
    to master painters or musical virtuosos. (In fact, considerable anecdotal evidence
    suggests that musicians and computer programmers use the same areas of their brains
    for their creative activities, and a decent percentage of programmers were, or
    are, musicians.^([4](ch19_footnote.xhtml#ch01fn4)))
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程的早期，软件开发被视为一种艺术。编写软件的能力——即将大量杂乱无章的东西整理成一个可工作的程序——似乎是一种上天赋予的天赋，只有少数人具备，就像大师级画家或音乐天才一样。（事实上，许多轶事证据表明，音乐家和计算机程序员在进行创作活动时，使用的是大脑相同的区域，而且相当一部分程序员曾是或现在是音乐家。^([4](ch19_footnote.xhtml#ch01fn4)))
- en: But is software development an actual art form? An *artist* is typically defined
    as someone blessed with certain talents and the skill to use them in a creative
    way. The key word here is *talent*, which is a natural ability. Because not everyone
    is born with the same talents, not everyone can be an artist. To apply the analogy,
    it would seem that if you want to be a programmer, you have to be born that way;
    indeed, some people seem to be born with a natural talent or aptitude for programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，软件开发是否真的是一种艺术形式？*艺术家*通常被定义为拥有某些天赋并能够以创造性方式使用这些天赋的人。这里的关键字是*天赋*，即一种与生俱来的能力。由于不是每个人天生都具备相同的天赋，所以并不是每个人都能成为艺术家。根据这个类比，似乎如果你想成为一名程序员，你必须天生具备这种能力；事实上，有些人似乎天生就具有编程的天赋或才能。
- en: The “programmer as artist” comparison seems to apply to the very best programmers.
    Although artists follow their own set of rules to produce quality art, they often
    produce their most exceptional art when they bend the rules and explore new creative
    ground. Similarly, the very best programmers are familiar with good software development
    rules but are also willing to experiment with new techniques to try to improve
    the development process. Just as true artists are not content with duplicating
    existing work or styles, the “programmer as artist” is happier creating new applications
    than grinding out yet another version of an old one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '"程序员作为艺术家"的比喻似乎适用于那些最优秀的程序员。尽管艺术家遵循自己的一套规则来创作高质量的艺术作品，但他们往往在突破规则、探索新的创作领域时，创造出最具非凡性的作品。类似地，最优秀的程序员熟悉良好的软件开发规则，但也愿意尝试新技术，以期改进开发过程。就像真正的艺术家不满足于复制现有的作品或风格一样，"程序员作为艺术家"更愿意创造新的应用程序，而不是重复做一个旧版的程序。'
- en: '**NOTE**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*One of the most well-respected textbook series on computer science is Donald
    Knuth’s *The Art of Computer Programming*. Clearly, the notion of programming
    as an art form is well entrenched in the computer science field.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机科学中最受尊敬的教科书系列之一是 Donald Knuth 的《计算机程序设计的艺术》。显然，编程作为一种艺术形式的概念在计算机科学领域中根深蒂固。*'
- en: '***1.2.2 Programmer as Architect***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.2.2 程序员作为架构师***'
- en: The artist metaphor works great for small projects where the artist creates
    the idea and implements a work of art, much like a programmer designs and implements
    a small software system. However, for larger software systems, the “programmer
    as architect” analogy is probably a better fit. An architect designs the structure
    but leaves the implementation to others (because often it’s logistically impossible
    for one person to build it). In computer science, those who design a system for
    others to implement are often called *programmer/analysts*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术家比喻非常适用于小型项目，在这些项目中，艺术家创造理念并实现一件艺术作品，就像程序员设计并实现一个小型软件系统一样。然而，对于更大的软件系统，"程序员作为架构师"的类比可能更为贴切。建筑师设计结构，但将实施工作留给他人（因为通常一个人无法完成所有建造工作）。在计算机科学中，那些为他人设计系统以便实施的人通常被称为*程序员/分析师*。
- en: An architect exercises large-scale creative control over a project. For example,
    an architect designing a fancy building defines how it will look, what materials
    to use, and the guidelines for the construction workers to follow, but doesn’t
    handle the construction itself. An architect might supervise the build (much like
    a programmer/analyst would review modules others add to their software system);
    however, the architect doesn’t wield a hammer or operate a crane.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑师对项目行使大规模的创意控制。例如，设计一座豪华建筑的建筑师定义它的外观、使用的材料以及施工工人需要遵循的指导方针，但不负责施工本身。建筑师可能会监督建筑（就像程序员/分析师审查他人添加到软件系统中的模块一样）；然而，建筑师并不拿起锤子或操作起重机。
- en: It might seem that this analogy doesn’t apply to small projects, but it can
    if you allow an individual to “change hats.” That is, during the first phase of
    the project, the programmer puts on their architect/programmer/analyst hat and
    creates the design for the system. Then the programmer switches hats and puts
    on their programmer/coder hat to implement the system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类比似乎不适用于小型项目，但如果允许个人"更换角色"，它同样适用。也就是说，在项目的第一阶段，程序员戴上他们的架构师/程序员/分析师帽子，创造系统的设计。然后，程序员换上他们的程序员/编码员帽子来实现该系统。
- en: What the “programmer as architect” paradigm adds over and above the “programmer
    as artist” model is verification and safety measures. When an artist paints an
    image, composes a piece of music, or sculpts an object, they generally don’t worry
    about whether that work meets any requirements other than their own. Also, they
    don’t have to worry about how that art might physically hurt life or property.^([5](ch19_footnote.xhtml#ch01fn5))
    An architect, on the other hand, must consider physical realities and the fact
    that a bad design can lead to injury or harm. The “programmer as architect” paradigm
    introduces personal responsibility, review (testing), and safety to the programmer’s
    task.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '"程序员作为架构师"这一范式在"程序员作为艺术家"模型之上增加了验证和安全措施。当艺术家绘画、创作音乐或雕塑时，他们通常不会担心这件作品是否符合除他们自己外的任何要求。此外，他们也不必担心这件艺术品可能会对生命或财产造成物理伤害^([5](ch19_footnote.xhtml#ch01fn5))。另一方面，建筑师必须考虑物理现实，且糟糕的设计可能导致伤害或损害。"程序员作为架构师"的范式为程序员的任务引入了个人责任、审查（测试）和安全性。'
- en: '***1.2.3 Programmer as Engineer***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.2.3 程序员作为工程师***'
- en: A NATO conference in 1968 challenged the notion that good programmers are born,
    not made. As mentioned in this book’s introduction, the world was facing a software
    crisis—new software applications were needed faster than programmers could be
    trained to create them. So NATO sponsored the 1968 conference, coining the term
    *software engineering* to describe how to tackle the problem by applying engineering
    principles to the wild world of computer programming.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 1968年北约会议挑战了“优秀的程序员天生就有，而非通过培养”的观点。正如本书介绍中所提到的，世界正面临软件危机——新软件应用的需求远远超过了程序员能够被训练出来的速度。因此，北约赞助了1968年的会议，创造了*软件工程*这一术语，来描述通过将工程学原理应用于计算机编程的混乱世界，来解决这一问题。
- en: Engineers are interested in solving practical problems cost-effectively, in
    terms of both the design effort and the cost of production. For this reason, coupled
    with the fact that the engineering profession has been around for a very long
    time (particularly mechanical and chemical engineering), a large number of procedures
    and policies have been created for engineers over the years to streamline their
    work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师关注的是以具有成本效益的方式解决实际问题，无论是在设计工作量方面，还是在生产成本方面。正因为如此，再加上工程职业历史悠久（特别是机械和化学工程领域），因此多年来为工程师们创造了大量程序和政策，以简化他们的工作。
- en: In many engineering fields today, an engineer’s task is to construct a large
    system from smaller, predesigned building blocks. An electrical engineer who wants
    to design a computer system doesn’t start by designing custom transistors or other
    small components; instead, they use predesigned CPUs, memory elements, and I/O
    devices, assembling them into a complete system. Similarly, a mechanical engineer
    can use predesigned trusses and pedestals to design a new bridge. Design reuse
    is the hallmark of the engineering profession. It’s one of the key elements to
    producing safe, reliable, functional, and cost-effective designs as rapidly as
    possible.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多今天的工程领域中，工程师的任务是将大型系统从较小的预设计构件中构建出来。一位想要设计计算机系统的电气工程师不会从设计定制晶体管或其他小型部件开始；相反，他们会使用预设计的中央处理器（CPU）、存储单元和输入输出设备，将它们组装成一个完整的系统。同样，一位机械工程师可以使用预设计的桁架和基座来设计一座新桥。设计重用是工程职业的标志。它是生产安全、可靠、功能齐全且具成本效益的设计的关键要素之一，也是尽可能快速完成设计的重要因素。
- en: 'Software engineers also follow a set of well-defined procedures and policies
    to construct large systems from smaller predefined systems. Indeed, the Institute
    of Electrical and Electronics Engineers (IEEE) defines *software engineering*
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师还遵循一套明确的程序和政策，从较小的预定义系统构建出大型系统。事实上，电气和电子工程师协会（IEEE）将*软件工程*定义如下：
- en: The application of a systematic, disciplined, quantifiable approach to development,
    operation, and maintenance of software; that is, the application of engineering
    to software.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 采用一种系统化、纪律化、量化的方式进行软件的开发、操作和维护；也就是将工程学应用于软件。
- en: '***1.2.4 Programmer as Craftsman***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.2.4 程序员作为工匠***'
- en: The craftsman model lies somewhere between the artist and the engineer. Central
    to this paradigm is the idea of programmers as individuals; that is, the software
    craftsman metaphor recognizes that people matter. Throwing more people and restrictive
    rules at a problem doesn’t produce higher-quality software, but training individuals
    better and allowing them to apply their natural talents and skills does.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠模型介于艺术家和工程师之间。这个范式的核心思想是程序员是独立的个体；也就是说，软件工匠的比喻认识到人是重要的。增加人手和制定严格的规则并不会提高软件的质量，而是更好地培训个体，允许他们发挥自己的天赋和技能，才能做得更好。
- en: There are parallels between the traditional craftsman’s development process
    and that of the software craftsman. Like all craftsmen, a software craftsman starts
    as an *apprentice* or an *intern*. An apprentice works under the close guidance
    of another craftsman. After learning the ropes, the apprentice programmer becomes
    a *journeyman*, usually working with teams of other programmers under the supervision
    of a software craftsman. Ultimately, the programmer’s skills increase to the point
    that they become a *master craftsman*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 传统工匠的开发过程与软件工匠的过程之间有许多相似之处。像所有工匠一样，软件工匠从*学徒*或*实习生*开始。学徒在另一位工匠的密切指导下工作。学会了基本技能后，学徒程序员成为*熟练工*，通常在其他程序员的团队中工作，且由一位软件工匠进行监督。最终，程序员的技能提升到一定程度后，他们会成为*大师工匠*。
- en: The craftsman model provides the best metaphor for programmers intent upon becoming
    great programmers. I’ll return to the discussion of this metaphor later in this
    chapter, in the section “[Software Craftsmanship](ch01.xhtml#lev-1.4)” on [page
    13](ch01.xhtml#page_13).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠模型为那些有志成为优秀程序员的程序员提供了最好的比喻。我将在本章稍后的部分中回到这一比喻，具体在[第13页](ch01.xhtml#page_13)的“[软件工艺](ch01.xhtml#lev-1.4)”部分。
- en: '***1.2.5 Artist, Architect, Engineer, or Craftsman?***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.2.5 艺术家、建筑师、工程师还是工匠？***'
- en: To write great code, you must understand what makes code great. You need to
    use the best tools, coding techniques, procedures, processes, and policies when
    writing code. In addition, you must constantly increase your knowledge and improve
    the development processes you use to enhance the quality of the software you develop.
    That’s why it’s important to consider different approaches to software development,
    understand the software product, and choose the best approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要写出优秀的代码，你必须理解什么才是优秀的代码。在编写代码时，你需要使用最好的工具、编码技巧、程序、流程和政策。此外，你还必须不断增加自己的知识，改进所使用的开发流程，从而提升你所开发软件的质量。这就是为什么考虑不同的软件开发方法、理解软件产品并选择最佳方法如此重要的原因。
- en: 'You need to work hard to learn how to write great code and then work hard at
    actually writing it. A great software developer adopts ideas that work from each
    of the fields just discussed and dispenses with those that don’t work. To summarize:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要努力学习如何编写优秀的代码，然后再努力去编写它。一个优秀的软件开发者会采纳各个领域中行之有效的思想，摒弃那些行不通的部分。总结一下：
- en: '*Great artists* practice their skills to develop their talents. They engage
    in divergent thinking to explore new ways of presenting their message.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优秀的艺术家**通过练习自己的技能来发展他们的才能。他们进行发散性思维，探索传递信息的新方式。'
- en: '*Great architects* know how to build upon existing designs using standard components
    to create custom objects. They understand cost constraints, safety issues, requirements,
    and the need for overdesign to ensure reliable operation. Great architects understand
    the relationship between form and function, as well as the need to fulfill customer
    requirements.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优秀的建筑师**懂得如何利用现有设计和标准组件，构建定制对象。他们理解成本限制、安全问题、需求，以及为了确保可靠运行所需的过度设计。优秀的建筑师理解形式与功能之间的关系，以及满足客户需求的重要性。'
- en: '*Great engineers* recognize the benefit of consistency. They document and automate
    development steps to avoid missing steps in the process. Like architects, engineers
    encourage the reuse of existing designs to deliver more robust and cost-effective
    solutions. Engineering provides procedures and policies to help overcome personal
    limitations in a project.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优秀的工程师**认识到一致性的重要性。他们记录并自动化开发步骤，以避免遗漏任何步骤。像建筑师一样，工程师鼓励重用现有设计，提供更强大且具成本效益的解决方案。工程学提供了帮助克服项目中个人局限性的程序和政策。'
- en: '*Great craftsmen* train and practice skills under the tutelage of a master
    with the ultimate goal of becoming a master craftsman. This metaphor emphasizes
    the qualities of the individual such as their problem-solving and organizational
    abilities.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优秀的工匠**在大师的指导下训练和练习技能，最终目标是成为一名大师级工匠。这一比喻强调了个体的素质，如他们解决问题的能力和组织能力。'
- en: '**1.3 Software Engineering**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**1.3 软件工程**'
- en: Since its emergence in the late 1960s, software engineering has become an unqualified
    success. Today, few professional programmers would accept the coding horrors that
    were “standard procedure” at the dawn of the field. Concepts that modern programmers
    take for granted—such as structured programming, proper program layout (like indentation),
    commenting, and good naming policies—are all due to software engineering research.
    Indeed, decades of such research have greatly influenced modern programming languages
    and other programming tools.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自20世纪60年代末软件工程兴起以来，它已经成为一个无可争议的成功。今天，几乎没有专业程序员会接受那个时代“标准程序”中的编程噩梦。现代程序员理所当然接受的概念——如结构化编程、适当的程序布局（如缩进）、注释和良好的命名政策——都源于软件工程的研究。事实上，数十年的这类研究极大地影响了现代编程语言和其他编程工具。
- en: Software engineering has been around for so long and has had such an impact
    on all facets of computer programming that many people assume the term *software
    engineer* is synonymous with *computer programmer*. It’s certainly true that any
    professional software engineer should also be a capable computer programmer, but
    computer programming constitutes only a small part of software engineering. Software
    engineering largely involves economics and project management. Interestingly,
    those responsible for managing the projects, maintaining the schedules, choosing
    the methodologies to use, and so on are not called software engineers; they’re
    called managers, project leads, and other titles implying a position of authority.
    Likewise, the people we call software engineers don’t actually do the software
    engineering—they simply write the code specified by the actual software engineers
    (managers and project leads). This is, perhaps, why there is so much confusion
    around the term *software engineering*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程已经存在了很长时间，并且对计算机编程的各个方面产生了深远影响，以至于许多人认为*软件工程师*一词与*计算机程序员*同义。毫无疑问，任何专业的软件工程师应该也是一名合格的计算机程序员，但计算机编程仅构成软件工程的一小部分。软件工程主要涉及经济学和项目管理。有趣的是，那些负责管理项目、保持进度、选择使用的方法论等的人并不叫软件工程师；他们被称为经理、项目负责人以及其他表示权威职位的头衔。同样，我们所称的软件工程师实际上并不做软件工程工作——他们只是编写由真正的软件工程师（经理和项目负责人）指定的代码。这或许就是为什么“软件工程”一词如此令人困惑的原因。
- en: '***1.3.1 A Formal Definition***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.3.1 正式定义***'
- en: No single definition of *software engineering* seems to satisfy everyone. Different
    authors add their own “spin,” making their definition slightly (or greatly) different
    than those found in other texts. The reason this book is titled *Engineering Software*
    is because I want to avoid adding yet another definition to the mix. As a reminder,
    the IEEE defines *software engineering* as
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个*软件工程*的定义能够满足所有人的需求。不同的作者会加入他们自己的“见解”，使他们的定义与其他文本中的定义略有不同（或大不相同）。本书之所以命名为*工程软件*，是因为我希望避免再为这一概念添加另一个定义。作为提醒，IEEE将*软件工程*定义为：
- en: The application of a systematic, disciplined, quantifiable approach to development,
    operation, and maintenance of software; that is, the application of engineering
    to software.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对软件的开发、运营和维护应用一种系统化、规范化、可量化的方法；也就是说，将工程学应用于软件。
- en: The original software engineering definition, and the one I use, is
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的原始软件工程定义是：
- en: Software engineering is the study of the development and management of large
    software systems.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程是关于大型软件系统的开发与管理的研究。
- en: The operative term here is *large*. Progress in software engineering has mostly
    been funded by defense contracts and the like, so it’s no surprise that software
    engineering is synonymous with large systems. The IEEE definition could apply
    to systems of nearly any size, but because most of the research into software
    engineering deals with very large systems, I prefer the second definition.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键术语是*大型*。软件工程的进展大多由国防合同等资助，因此软件工程与大型系统几乎是同义词。IEEE的定义可以适用于几乎任何规模的系统，但由于大多数关于软件工程的研究都涉及非常大型的系统，我更倾向于采用第二种定义。
- en: '**NOTE**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To avoid confusion with the generic term *software engineering*, I use a more
    specialized term, *personal software engineering*, to describe those processes
    and methodologies that apply to a single programmer working on a small project
    or a small part of a larger project. My intent is to describe what computer programmers
    believe is the essence of software engineering without all the extraneous detail
    that has little to do with writing great code.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了避免与通用的*软件工程*一词混淆，我使用一个更为专业的术语，*个人软件工程*，来描述那些适用于单个程序员在一个小型项目或大型项目的小部分上工作的过程和方法论。我的目的是描述计算机程序员认为的软件工程的本质，而不涉及那些与编写优秀代码无关的多余细节。*'
- en: When it comes to software development, people have completely different concepts
    of what “large” means. An undergraduate in a computer science program might think
    that a program containing a couple thousand lines of source code is a large system.
    To a project manager at Boeing (or other large firm), a large system contains
    well over one million lines of code. The last time I counted (which was a long
    time ago), Microsoft’s Windows operating system (OS) exceeded 50 million lines
    of source code; no one questions that Windows is a large system!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，人们对于“庞大”的定义完全不同。一名计算机科学专业的本科生可能认为一个包含几千行源代码的程序是一个大型系统。而对于波音（或其他大型公司）的项目经理来说，一个大型系统的代码行数通常超过一百万行。我上次统计的时候（那已经是很久以前的事了），微软的Windows操作系统（OS）超过了五千万行源代码；没有人会怀疑Windows是一个大型系统！
- en: Because traditional software engineering definitions generally apply to large
    software systems, we need to come up with a reasonable definition of large (and
    small) software systems. Although *lines of code (LOC)* is the metric software
    engineers often use to describe the size of a software system, it is a low-quality
    metric with almost a two-order-of-magnitude variance.^([6](ch19_footnote.xhtml#ch01fn6))
    This book will often use the LOC or *thousands of lines of code (KLOC)* metric.
    But it’s not a good idea to base a formal definition on such a poor metric. Doing
    so weakens the definition.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传统的软件工程定义通常适用于大型软件系统，我们需要提出一个合理的大型（和小型）软件系统定义。尽管*代码行数（LOC）*是软件工程师常用来描述软件系统大小的指标，但它是一个低质量的指标，具有接近两个数量级的误差范围。^([6](ch19_footnote.xhtml#ch01fn6))
    本书将经常使用LOC或*千行代码（KLOC）*指标。但依赖这样一个糟糕的指标来构建正式定义并不是一个好主意。这样做会削弱定义的严谨性。
- en: '***1.3.2 Project Size***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.3.2 项目大小***'
- en: A *small project* is one that an average programmer can complete on their own
    in a reasonable amount of time (less than two years). A *medium-sized project*
    is too large for an individual to complete in a reasonable time frame, but a small
    team of two to five programmers can accomplish it. A *large project* requires
    a large team of programmers (more than five members). In terms of LOC, a small
    project contains about 50 to 100 KLOC; medium-sized projects fall into the 50
    to 1,000 KLOC (one million lines of source code) range; and large projects start
    at around 500 to 1,000 KLOC.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*小型项目*是指一个普通程序员可以在合理的时间内（少于两年）完成的项目。*中型项目*则太大，个体在合理的时间内无法完成，但一个由两到五名程序员组成的小团队能够完成它。*大型项目*则需要一个庞大的程序员团队（超过五人）。就LOC而言，小型项目大约包含50到100
    KLOC；中型项目的LOC在50到1000 KLOC（即一百万行源代码）之间；而大型项目的LOC则从约500到1000 KLOC起步。'
- en: Small projects are trivial to manage. Because small projects require no interaction
    between programmers and very little interaction between the programmer and the
    outside world, productivity depends almost solely upon the programmer’s abilities.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 小型项目很容易管理。因为小型项目不需要程序员之间的互动，也几乎不需要程序员与外界的互动，生产力几乎完全依赖于程序员的能力。
- en: Medium-sized projects introduce new challenges. Because multiple programmers
    are working on the project, communication can become a problem, but the team is
    small enough that this overhead is manageable. Nevertheless, the group dynamics
    require extra support, which increases the cost of each line of code written.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 中型项目带来了新的挑战。因为有多名程序员在参与项目，沟通可能会成为一个问题，但团队足够小，这种开销是可以管理的。尽管如此，团队内部的动态仍需要额外支持，这增加了每行代码编写的成本。
- en: Large projects require a large team of programmers. Communication and other
    overhead often consume 50 percent of each engineer’s productivity. Effective project
    management is crucial.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大型项目需要一个庞大的程序员团队。沟通和其他开销往往消耗每个工程师50%的生产力。有效的项目管理至关重要。
- en: Software engineering deals with the methodologies, practices, and policies needed
    to successfully manage projects requiring large teams of programmers. Unfortunately,
    practices that work well for individuals, or even small teams, don’t scale up
    to large teams, and large-project methodologies, practices, and policies don’t
    scale down to small and medium-sized projects. Practices that work well for large
    projects typically inject unreasonable overhead into small and medium-sized projects,
    reducing the productivity of those small teams.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程处理需要大型程序员团队成功管理项目的方法、实践和政策。不幸的是，适用于个人甚至小团队的实践，无法扩展到大型团队，而大型项目的方法、实践和政策也无法缩小到适应小型和中型项目。适用于大型项目的实践通常会给小型和中型项目带来不合理的开销，降低这些小团队的生产力。
- en: Let’s take a closer look at some benefits and drawbacks of projects of different
    sizes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解不同规模项目的一些优缺点。
- en: '**1.3.2.1 Small Projects**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**1.3.2.1 小型项目**'
- en: On small projects, a single software engineer is completely responsible for
    system design, implementation, testing, debugging, deployment, and documentation.
    On such a project, the lone engineer is accountable for far more tasks than a
    single engineer would be on a medium-sized or large project. But the tasks are
    small and therefore manageable. Because a small project requires an individual
    to perform a wide range of tasks, the programmer must possess a varied skill set.
    Personal software engineering covers all the activities a developer would do on
    a small project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在小型项目中，单个软件工程师完全负责系统设计、实施、测试、调试、部署和文档编写。在这样的项目中，单一工程师需要负责的任务远多于中型或大型项目中的单个工程师。但这些任务相对较小，因此是可管理的。由于小型项目要求个人承担广泛的任务，程序员必须具备多样化的技能。个人软件工程学涵盖了开发者在小型项目中会做的所有活动。
- en: Small projects make the most efficient use of engineering resources. The engineer
    can employ the most productive approach to solving problems because they don’t
    have to reach a consensus with other engineers on the project. The engineer can
    also optimize the time they spend on each development phase. In a structured software
    design regimen, considerable time is spent documenting operations, which doesn’t
    make sense when there’s only a single programmer on a project (though a different
    programmer might need to work with the code later in the product’s lifetime).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 小型项目能够最有效地利用工程资源。工程师可以采用最具生产力的方法来解决问题，因为他们不必与项目中的其他工程师达成共识。工程师还可以优化他们在每个开发阶段所花费的时间。在结构化的软件设计流程中，通常会花费大量时间进行操作文档记录，但当项目中只有一个程序员时，这显得不太合理（尽管在产品生命周期的后期，可能会有其他程序员需要与代码合作）。
- en: The drawback, and the trap, of a small project is that an engineer must be capable
    of handling all the different tasks required. Many small projects fail (or their
    development cost is too high) because the engineer doesn’t have the proper training
    to handle an entire project. More than any other goal, the purpose of the *Write
    Great Code* series is to teach programmers how to do small projects properly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 小型项目的缺点和陷阱在于，工程师必须能够处理所需的各种任务。许多小型项目失败（或其开发成本过高），因为工程师缺乏足够的培训来独立处理整个项目。*Write
    Great Code*系列的目标之一，甚至比其他任何目标都更加重要，就是教会程序员如何正确地完成小型项目。
- en: '**1.3.2.2 Medium-Sized Projects**'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**1.3.2.2 中型项目**'
- en: On a medium-sized project, personal software engineering encompasses those aspects
    of the project for which a single engineer is responsible. This typically includes
    the design of their system component, its implementation (coding), and the documentation
    for that module. Generally, they are also responsible for testing their component
    (*unit testing*), and then the team as a whole tests the entire system (*integration
    testing*). Usually, there’s one engineer in charge of the complete system design
    (the *project head* or *lead programmer*) who also handles deployment. Depending
    on the project, a technical writer might handle system documentation. Because
    engineers share tasks in a medium-sized project, specialization is possible, and
    the project doesn’t require each engineer to be capable of performing all the
    individual tasks. The lead programmer can direct the activities of those less
    experienced to maintain quality throughout the project.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个中型项目中，个人软件工程包括了项目中由单个工程师负责的那些方面。这通常包括他们系统组件的设计、实现（编码）以及该模块的文档。通常，他们还负责对其组件进行测试（*单元测试*），然后由整个团队进行系统测试（*集成测试*）。通常会有一名工程师负责完整的系统设计（*项目负责人*或*首席程序员*），并负责部署。根据项目的不同，技术文档可能由技术写作人员来负责。由于工程师在中型项目中共享任务，因此可以实现专业化，项目也不要求每个工程师都能完成所有单独的任务。首席程序员可以指导经验较少的工程师，以确保项目的整体质量。
- en: 'A single engineer on a small project sees the total picture and can optimize
    certain activities based on their understanding of the entire project. On a large
    project, a single engineer is unaware of much of the project beyond their small
    piece of it. Medium-sized projects provide a hybrid of these two extremes: individuals
    can see much of the entire project and adjust their approach to system implementation.
    They can also specialize on certain aspects of the system without becoming overwhelmed
    by the details of the rest of the system.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个小型项目中，单个工程师能够看到整体情况，并根据对整个项目的理解优化某些活动。而在一个大型项目中，单个工程师对除自己负责的小部分外，其他部分几乎不了解。中型项目则提供了这两种极端的混合：个人可以看到大部分整个项目，并根据实际情况调整他们的系统实施方法。同时，他们也可以在不被其他系统细节压倒的情况下，专注于系统的某些方面。
- en: '**1.3.2.3 Large Projects**'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**1.3.2.3 大型项目**'
- en: On a large project, various team members have specialized roles, from system
    design to implementation, testing, documentation, deployment, and system enhancement
    and maintenance. As with medium-sized projects, in large projects personal software
    engineering encompasses only those activities for which an individual programmer
    is responsible. Software engineers on a large project generally do only a few
    tasks (such as coding and unit testing); therefore, they don’t require the wide-ranging
    skill set of a lone programmer on a small project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型项目中，各团队成员有着更为专业化的角色，从系统设计到实现、测试、文档、部署以及系统的增强和维护。与中型项目一样，在大型项目中，个人软件工程只包括程序员自己负责的那些活动。大型项目中的软件工程师通常只做几项任务（例如编码和单元测试），因此他们不需要像小型项目中的单个工程师那样广泛的技能。
- en: Beyond the scope of activity, the size of a project affects the productivity
    of its engineers. On a large project, engineers can become very specialized and
    concentrate on their one area of expertise. This allows them to do their job more
    efficiently than if they had to use a more generalized skill set. However, large
    projects must use a common software development approach to be effective, and
    some engineers may not be as productive if they don’t like the approach.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了活动的范围外，项目的大小也会影响工程师的生产力。在大型项目中，工程师可以变得非常专业化，专注于自己擅长的领域。这使得他们能够比起使用更广泛的技能集时，更高效地完成工作。然而，大型项目必须使用统一的软件开发方法才能有效，而一些工程师可能因为不喜欢这种方法而生产力下降。
- en: '***1.3.3 Where Software Engineering Fails***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.3.3 软件工程失败的原因***'
- en: 'It’s possible to apply engineering techniques to software development to produce
    applications in a more cost-effective manner. However, as Pete McBreen states
    in *Software Craftsmanship: The New Imperative*, the biggest problem with software
    engineering is the assumption that a “systematic, disciplined, quantifiable approach”
    is the only reasonable approach. In fact, he raises a very good question: is it
    even possible to make software development systematic and quantified? Quoting
    *[http://www.controlchaos.com/](http://www.controlchaos.com/)*, McBreen says:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 确实可以将工程技术应用于软件开发，以更具成本效益的方式生产应用程序。然而，正如皮特·麦克布林在《软件工艺：新的必然性》中所指出的，软件工程面临的最大问题是认为“系统化、严谨、可量化的方法”是唯一合理的途径。事实上，他提出了一个非常好的问题：软件开发是否真的可能变得系统化和量化？引用
    *[http://www.controlchaos.com/](http://www.controlchaos.com/)*，麦克布林说：
- en: If a process can be fully defined, with all things known about it so that it
    can be designed and run repeatedly with predictable results, it is known as a
    defined process, and it can be subjected to automation. If all things about a
    process aren’t fully known—only what generally happens when you mix these inputs
    and what to measure and control to get the desired output—these are called empirical
    processes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个过程可以被完全定义，所有相关内容都已知，可以设计并反复执行，且结果可预测，那么它被称为已定义过程，并且可以进行自动化。如果一个过程的所有内容并不完全已知——只知道当你混合这些输入时通常会发生什么，以及如何测量和控制以获得期望的输出——这些则被称为经验过程。
- en: Software development is not a defined process; it’s an empirical process. As
    such, software development cannot be fully automated, and it’s often difficult
    to apply engineering principles to software development. Part of the problem is
    that practical engineering relies so much on the reuse of existing designs. Although
    a considerable amount of reuse is possible in computer programming, too, it requires
    much more customization than you find in other engineering professions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发不是一个已定义过程；它是一个经验过程。因此，软件开发不能完全自动化，且通常很难将工程原理应用于软件开发。问题的一部分在于，实际的工程工作高度依赖于现有设计的重用。尽管在计算机编程中也可以进行大量的重用，但它需要比其他工程领域更多的定制化。
- en: Another significant problem with software engineering, as briefly discussed
    in the book’s introduction, is that software engineering treats software engineers
    as commodity resources that a manager can swap arbitrarily into and out of a project,
    which disregards the importance of an individual’s talents. The issue isn’t that
    engineering techniques aren’t ever valuable, but that management attempts to apply
    them uniformly to everyone and encourages the use of some current set of “best
    practices” in software development. This approach can produce quality software,
    but it doesn’t allow for thinking outside the box and creating new practices that
    might be better.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程的另一个重要问题，正如本书引言中简要讨论的那样，是软件工程将软件工程师视为可以随意调换进出项目的商品资源，这忽视了个体才能的重要性。问题并不在于工程技术从未有价值，而在于管理层试图将这些技术普遍应用于每个人，并鼓励使用当前的一些“最佳实践”进行软件开发。这种方法能够产生高质量的软件，但它不允许跳出框架思考，去创造可能更好的新实践。
- en: '**1.4 Software Craftsmanship**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**1.4 软件工艺**'
- en: Software craftmanship, where a programmer trains and practices skills under
    the tutelage of a master, is about lifelong learning to be the best software developer
    you can be. Following the craftmanship model, a programmer gets an education,
    completes an apprenticeship, becomes a journeyman programmer, and strives to develop
    a masterpiece.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工艺，指程序员在大师的指导下培养和实践技能，是为了终身学习，成为最优秀的软件开发者。遵循工艺模型，程序员接受教育，完成学徒期，成为中级程序员，并努力开发出杰作。
- en: '***1.4.1 Education***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.4.1 教育***'
- en: Colleges and universities provide the prerequisites that interns need to be
    software craftsmen. If an internship exposed a beginning programmer (intern/apprentice)
    to the same information and challenges that a formal education does, the internship
    might be equivalent to a formal education. Unfortunately, few software craftsmen
    have the time or ability to train an apprentice from scratch. They’re far too
    busy working on real-world projects to devote the time needed to teach an intern
    everything they need to know. Therefore, education is the first step on the road
    to software craftsmanship.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大学为实习生成为软件工匠提供了必备的基础。如果一个实习生（学徒）能够接触到和正规教育相同的信息和挑战，那么这次实习可能与正式教育等效。不幸的是，很少有软件工匠有时间或能力从零开始培养一个学徒。他们太忙于处理实际项目，无法投入足够的时间来教导实习生所有他们需要知道的内容。因此，教育是通向软件工匠之路的第一步。
- en: 'Additionally, a formal education at a college or university accomplishes two
    main objectives: first, you’re forced to study those computer science topics that
    you’d probably just skip over if you were studying the material on your own; and
    second, you prove to the world that you’re capable of finishing a major commitment
    that you’ve started. In particular, after you’ve completed a formal computer science
    program, you’re ready to *really* start learning about software development.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大学的正规教育实现了两个主要目标：首先，你必须学习那些如果你自己学习可能会跳过的计算机科学主题；其次，你向全世界证明了你有能力完成一个你开始的重大承诺。特别是，在完成正规的计算机科学课程后，你已准备好*真正*开始学习软件开发。
- en: However, a college degree, no matter how advanced, doesn’t automatically qualify
    you as a software craftsman. A person with a graduate degree, which requires a
    deeper and more specialized study of computer science, starts out as an intern,
    just as someone with an undergraduate degree does. The intern with the graduate
    degree might spend fewer years as an apprentice but still needs considerable training.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论学位多么高级，都无法自动将你资格化为软件工匠。拥有研究生学位的人，因其需要深入且专门化的计算机科学研究，和拥有本科学位的人一样，也从实习生做起。拥有研究生学位的实习生可能作为学徒的年限较短，但仍然需要大量的培训。
- en: '***1.4.2 Apprenticeship***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.4.2 学徒制***'
- en: Completing a formal computer science program prepares you to start learning,
    at an apprentice level, how to become a craftsman. A typical computer science
    program teaches you about programming languages (their syntax and semantics),
    data structures, and the theory of compilers, operating systems, and the like,
    but doesn’t teach you *how to program* beyond the first- or second-semester Introduction
    to Programming courses. An apprenticeship shows you what programming is about
    when you enter the real world. The purpose of an apprenticeship is to get the
    experience necessary to use what you’ve learned to approach problems in many different
    ways, and to gain as many different experiences as possible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 完成正规的计算机科学课程为你准备了以学徒身份开始学习如何成为一名工匠的基础。典型的计算机科学课程会教授你编程语言（其语法和语义）、数据结构、编译器、操作系统等理论，但不会教授你*如何编程*，除非是在第一或第二学期的编程入门课程中。学徒训练则展示了当你进入实际工作后，编程究竟是什么。学徒训练的目的是获得必要的经验，以便将你所学的知识用来从多种不同角度解决问题，并尽可能多地积累不同的经验。
- en: An apprentice studies under someone who has mastered advanced programming techniques.
    This person can be either a *software journeyman* (see the next section) or a
    *software craftsman*. The “master” assigns tasks to the apprentice, demonstrates
    how to accomplish the task, and reviews the apprentice’s work, making appropriate
    mid-course corrections to obtain high-quality work. Most important, the apprentice
    also reviews their master’s work. This can take various forms, including testing,
    structured walk-throughs, and debugging. The important factor is that the apprentice
    learns how the master’s code operates.^([7](ch19_footnote.xhtml#ch01fn7)) In doing
    so, the apprentice picks up programming techniques they would never master on
    their own.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 学徒在一位掌握了高级编程技巧的人指导下学习。这个人可以是*软件学徒*（见下一节）或者*软件工匠*。这位“导师”给学徒分配任务，展示如何完成任务，并检查学徒的工作，做出适当的中途调整，以确保高质量的工作。最重要的是，学徒还需要检查导师的工作。这可以通过多种形式进行，包括测试、结构化演练和调试。关键是学徒要了解导师的代码是如何工作的。^([7](ch19_footnote.xhtml#ch01fn7))
    通过这样做，学徒能够掌握一些自己无法独立掌握的编程技巧。
- en: 'If an apprentice is lucky, they’ll have the opportunity to study under several
    masters and learn solid techniques from all of them. With each project completed
    under the tutelage of an advanced programmer, the apprentice nears the end of
    their apprenticeship and moves on to the next stage in the software craftsman’s
    route: the software journeyman.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果学徒足够幸运，他们将有机会在几位大师的指导下学习，并从他们那里学习到扎实的技术。每完成一个项目，学徒就会在高级程序员的指导下接近学徒生涯的尽头，并进入软件工匠之路的下一阶段：软件中级工匠。
- en: In one sense, an apprenticeship never ends. You should always be on the lookout
    for new techniques and new skills. For example, consider all the software engineers
    who grew up on structured programming and had to learn object-oriented programming.
    However, at some point, you reach the stage where you’re using your existing skills
    more often than developing new ones. At that point, you start imparting your wisdom
    to others rather than learning from others. It’s then that the “masters” you’re
    working with feel you’re ready to tackle projects on your own without assistance
    or supervision. That’s when you become a software journeyman.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，学徒生涯永远不会结束。你应该始终关注新的技术和新技能。例如，考虑那些从结构化编程成长起来的软件工程师，他们曾经需要学习面向对象编程。然而，在某个时刻，你会达到这样一个阶段：你更多地使用已有的技能，而不是开发新的技能。到了那个时候，你开始把自己的智慧传授给他人，而不是从他人那里学习。此时，你和“大师们”合作的同事会觉得你已经准备好独立承担项目，无需帮助或监督。那时，你就成为了一名软件中级工匠。
- en: '***1.4.3 The Software Journeyman***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.4.3 软件中级工匠***'
- en: Software journeymen handle the bulk of software development. As the name suggests,
    they typically move from project to project, applying their skills to solve application
    problems. Even though a software developer’s education never ends, a software
    journeyman is more focused on application development than on learning how to
    develop applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中级工匠负责大部分软件开发工作。如其名所示，他们通常在不同项目之间流动，运用他们的技能解决应用问题。尽管软件开发者的教育从未结束，但软件中级工匠更专注于应用开发，而不是学习如何开发应用。
- en: Another important task that software journeymen take on is training new software
    apprentices. They review the work of apprentices on their project and share programming
    techniques and knowledge with them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中级工匠还承担着另一个重要任务，那就是培训新的软件学徒。他们会审查学徒在项目中的工作，并与他们分享编程技术和知识。
- en: A software journeyman constantly looks for new tools and techniques that can
    improve the software development process. By adopting new (but proven) techniques
    early on, they stay ahead of the learning curve and keep up with current trends
    to avoid falling behind. Utilizing industry best practices to create efficient
    and cost-effective solutions for customers is the hallmark of this stage of craftsmanship.
    Software journeymen are productive, knowledgeable, and exactly the type of software
    developer most project managers hope to find when assembling a software team.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一名软件中级工匠不断寻找能够改善软件开发过程的新工具和新技术。通过尽早采纳新的（但经过验证的）技术，他们保持领先于学习曲线，跟上当前趋势，避免落后。利用行业最佳实践为客户创造高效且具有成本效益的解决方案是这一阶段工艺的标志。软件中级工匠高效、知识丰富，正是大多数项目经理在组建软件团队时希望找到的类型的开发人员。
- en: '***1.4.4 The Master Craftsman***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.4.4 大师工匠***'
- en: 'The traditional way to become a master craftsman is to create a *masterpiece*,
    a work that sets you apart from your peers. Some (high-end) examples of software
    masterpieces include VisiCalc,^([8](ch19_footnote.xhtml#ch01fn8)) the Linux operating
    system, and the vi and emacs text editors. These products were initially the brainchild
    and creation of a single person, even though they went on to involve dozens or
    hundreds of different programmers. A masterpiece doesn’t have to become famous,
    like Linux or some GNU tool. However, your immediate peers must recognize your
    masterpiece as a useful and creative solution to a problem. A masterpiece doesn’t
    have to be a stand-alone original piece of code, either. Writing a complex device
    driver for an operating system, or extending some other program in several useful
    ways, could very well qualify as a masterpiece. The purpose of the masterpiece
    is to create an item in your portfolio that tells the world: “I’m capable of producing
    serious software—take me seriously!” A masterpiece work lets others know that
    they should seriously consider your opinions and trust what you have to say.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 成为一名高级工匠的传统方式是创作一个*杰作*，这是使你脱颖而出的作品。一些（高端）软件杰作的例子包括VisiCalc，^([8](ch19_footnote.xhtml#ch01fn8))
    Linux操作系统，以及vi和emacs文本编辑器。这些产品最初是一个人的创意和创作，尽管后来涉及了数十甚至数百名不同的程序员。杰作不一定像Linux或某些GNU工具那样成名。然而，你的同行必须认可你的杰作作为解决问题的有用和创造性的解决方案。杰作也不一定是独立的原创代码。为操作系统编写复杂的设备驱动程序，或者在几个有用的方面扩展其他程序，完全可以算作是杰作。杰作的目的是创建一个告诉世界的作品：「我有能力制作严肃的软件——请认真对待我！」杰作让他人知道他们应该认真考虑你的意见，并信任你所说的话。
- en: Generally, the domain of the master craftsman is to determine what current best
    practices are and invent new ones. Best practices describe the best *known* way,
    not necessarily the absolute best way, to accomplish a task. The master craftsman
    investigates whether there’s a better approach for designing applications, recognizes
    the utility of a new technique or methodology as it applies to a wide spectrum
    of applications, and verifies that a practice is best and communicates that information
    to others.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，高级工匠的领域是确定当前的最佳实践并发明新的实践。最佳实践描述了完成任务的最佳*已知*方法，不一定是绝对最佳方法。高级工匠研究是否有更好的方法来设计应用程序，认识到新技术或方法论对广泛应用的实用性，并验证该实践是否最佳，并将这些信息传达给他人。
- en: '***1.4.5 Where Software Craftsmanship Fails***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***1.4.5 软件工艺失败的地方***'
- en: 'Steve McConnell, in his classic software engineering book *Code Complete*,
    claims that experience is one of those characteristics that doesn’t matter as
    much as people think: “If a programmer hasn’t learned C after a year or two, the
    next three years won’t make much difference.” He then asks, “If you work for 10
    years, do you get 10 years of experience or do you get 1 year of experience 10
    times?” McConnell even suggests that book learning might be more important than
    programming experience. He claims that the computer science field changes so fast
    that someone with 10 years of programming experience has missed out on all the
    great research to which new programmers have been exposed during that decade.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫·麦康奈尔在他的经典软件工程著作*代码大全*中声称，经验是那些特征之一，其重要性并不像人们想象的那么大：“如果一个程序员在一两年后还没学会C语言，接下来的三年也不会有多大改变。”然后他问道：“如果你工作了10年，你获得了10年的经验还是获得了1年的经验10次？”麦康奈尔甚至暗示，书本学习可能比编程经验更重要。他声称，计算机科学领域变化如此之快，以至于在过去十年里，有10年编程经验的人错过了新程序员接触到的所有重要研究。
- en: '**1.5 The Path to Writing Great Code**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**1.5 通向编写优秀代码的道路**'
- en: 'Writing great code doesn’t happen because you follow a list of rules. You must
    make a personal decision to put in the effort to ensure the code you’re writing
    is truly great. Violating well-understood software engineering principles is a
    good way to ensure that your code is not great, but rigidly following such rules
    doesn’t guarantee greatness, either. A well-experienced and meticulous developer,
    or software craftsman, can navigate both approaches: following established practices
    when it’s required, but being unafraid to try a different technique or strategy
    when the need arises.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 写出优秀的代码并不是因为你遵循了一串规则。你必须做出个人决定，付出努力，确保你写的代码真的很出色。违反公认的软件工程原则是确保你的代码不优秀的好方法，但严格遵循这些规则也不能保证代码的伟大。一位经验丰富、严谨的开发者或软件工匠能够在两种方法之间游刃有余：在需要时遵循既定的实践，但当需要时，也敢于尝试不同的技术或策略。
- en: Unfortunately, a book can only teach you the rules and methodologies. Creativity
    and wisdom are qualities you need to develop on your own. This book teaches you
    the rules and suggests when you might consider breaking them. However, it’s still
    up to you to decide whether to do so.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一本书只能教给你规则和方法论。创造力和智慧是你需要自己培养的品质。本书教给你规则，并建议你何时可以考虑打破这些规则。然而，是否打破规则仍然取决于你自己。
- en: '**1.6 For More Information**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**1.6 更多信息**'
- en: 'Hunt, Andrew, and David Thomas. *The Pragmatic Programmer*. Upper Saddle River,
    NJ: Addison-Wesley Professional, 1999.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'Hunt, Andrew, 和 David Thomas. *程序员修炼之道*. Upper Saddle River, NJ: Addison-Wesley
    Professional, 1999.'
- en: 'Kernighan, Brian, and Rob Pike. *The Practice of Programming*. Upper Saddle
    River, NJ: Addison-Wesley Professional, 1999.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'Kernighan, Brian, 和 Rob Pike. *编程实践*. Upper Saddle River, NJ: Addison-Wesley
    Professional, 1999.'
- en: 'McBreen, Pete. *Software Craftsmanship: The New Imperative*. Upper Saddle River,
    NJ: Addison-Wesley Professional, 2001.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'McBreen, Pete. *软件工艺：新的命令*. Upper Saddle River, NJ: Addison-Wesley Professional,
    2001.'
- en: 'McConnell, Steve. *Code Complete*. 2nd ed. Redmond, WA: Microsoft Press, 2004.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'McConnell, Steve. *代码大全*. 第二版. Redmond, WA: Microsoft Press, 2004.'
- en: '———. *Rapid Development: Taming Wild Software Schedules*. Redmond, WA: Microsoft
    Press, 1996.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '———. *快速开发：驾驭混乱的软件进度*. Redmond, WA: Microsoft Press, 1996.'
- en: 'Pressman, Robert S. *Software Engineering, A Practitioner’s Approach*. New
    York: McGraw-Hill, 2010.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pressman, Robert S. *软件工程：实践者的方案*. 纽约: McGraw-Hill, 2010.'
