- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Arithmetic
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter discusses arithmetic computation in assembly language. By the end
    of this chapter, you should be able to translate arithmetic expressions and assignment
    statements from high-level languages like Pascal and C/C++ into x86-64 assembly
    language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论汇编语言中的算术运算。通过本章的学习，你应该能够将像 Pascal 和 C/C++ 等高级语言中的算术表达式和赋值语句转换为 x86-64 汇编语言。
- en: 6.1 x86-64 Integer Arithmetic Instructions
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 x86-64 整数算术指令
- en: Before you learn how to encode arithmetic expressions in assembly language,
    it would be a good idea to first discuss the remaining arithmetic instructions
    in the x86-64 instruction set. Previous chapters have covered most of the arithmetic
    and logical instructions, so this section covers the few remaining instructions
    you’ll need.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何在汇编语言中编码算术表达式之前，最好先讨论一下 x86-64 指令集中的其他算术指令。前面的章节已经涵盖了大部分的算术和逻辑指令，因此本节将讨论一些你仍然需要了解的剩余指令。
- en: 6.1.1 Sign- and Zero-Extension Instructions
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 符号扩展和零扩展指令
- en: Several arithmetic operations require sign- or zero-extended values before the
    operation. So let’s first consider the sign- and zero-extension instructions.
    The x86-64 provides several instructions to sign- or zero-extend a smaller number
    to a larger number. [Table 6-1](#table6-1) lists instructions that will sign-extend
    the AL, AX, EAX, and RAX registers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算术操作在执行前需要符号扩展或零扩展的值。因此，我们首先来考虑符号扩展和零扩展指令。x86-64 提供了几条指令来将较小的数值符号扩展或零扩展为较大的数值。[表
    6-1](#table6-1) 列出了可以将 AL、AX、EAX 和 RAX 寄存器进行符号扩展的指令。
- en: 'Table 6-1: Instructions for Extending AL, AX, EAX, and RAX'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1：扩展 AL、AX、EAX 和 RAX 的指令
- en: '| **Instruction** | **Explanation** |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **解释** |'
- en: '| --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cbw` | Converts the byte in AL to a word in AX via sign extension |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `cbw` | 通过符号扩展将 AL 中的字节转换为 AX 中的字 |'
- en: '| `cwd` | Converts the word in AX to a double word in DX:AX via sign extension
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `cwd` | 通过符号扩展将 AX 中的字转换为 DX:AX 中的双字 |'
- en: '| `cdq` | Converts the double word in EAX to a quad word in EDX:EAX via sign
    extension |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `cdq` | 通过符号扩展将 EAX 中的双字转换为 EDX:EAX 中的四字 |'
- en: '| `cqo` | Converts the quad word in RAX to an octal word in RDX:RAX via sign
    extension |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `cqo` | 通过符号扩展将 RAX 中的四字转换为 RDX:RAX 中的八字 |'
- en: '| `cwde` | Converts the word in AX to a double word in EAX via sign extension
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `cwde` | 通过符号扩展将 AX 中的字转换为 EAX 中的双字 |'
- en: '| `cdqe` | Converts the double word in EAX to a quad word in RAX via sign extension
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `cdqe` | 通过符号扩展将 EAX 中的双字转换为 RAX 中的四字 |'
- en: Note that the `cwd` (*convert word to double word*) instruction does not sign-extend
    the word in AX to a double word in EAX. Instead, it stores the HO word of the
    sign extension into the DX register (the notation DX:AX indicates that you have
    a double-word value, with DX containing the upper 16 bits and AX containing the
    lower 16 bits of the value). If you want the sign extension of AX to go into EAX,
    you should use the `cwde` (*convert word to double word, extended*) instruction.
    In a similar fashion, the `cdq` instruction sign-extends EAX into EDX:EAX. Use
    the `cdqe` instruction if you want to sign-extend EAX into RAX.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`cwd`（*将字转换为双字*）指令并不会将 AX 中的字符号扩展为 EAX 中的双字。相反，它将符号扩展的高字存储到 DX 寄存器中（DX:AX
    的表示法意味着你有一个双字值，其中 DX 包含值的高 16 位，AX 包含值的低 16 位）。如果你想将 AX 的符号扩展放入 EAX，应使用 `cwde`（*将字转换为双字，扩展*）指令。同样，`cdq`
    指令将 EAX 符号扩展到 EDX:EAX。如果你希望将 EAX 符号扩展到 RAX，请使用 `cdqe` 指令。
- en: 'For general sign-extension operations, the x86-64 provides an extension of
    the `mov` instruction, `movsx` (*move with sign extension*), that copies data
    and sign-extends the data while copying it. The `movsx` instruction’s syntax is
    similar to that of `mov`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般的符号扩展操作，x86-64 提供了 `mov` 指令的扩展版本 `movsx`（*带符号扩展的移动*），它在复制数据的同时也对数据进行符号扩展。`movsx`
    指令的语法类似于 `mov`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The big difference in syntax between these instructions and the `mov` instruction
    is that the destination operand must usually be larger than the source operand.^([1](#c06-footnote-1))
    For example, if the source operand is a byte, then the destination operand must
    be a word, dword, or qword. The destination operand must also be a register; the
    source operand, however, can be a memory location.^([2](#c06-footnote-2)) The
    `movsx` instruction does not allow constant operands.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令与 `mov` 指令之间语法的一个主要区别是，目标操作数通常必须比源操作数大。^([1](#c06-footnote-1)) 例如，如果源操作数是一个字节，那么目标操作数必须是字（word）、双字（dword）或四字（qword）。目标操作数也必须是一个寄存器；然而，源操作数可以是一个内存位置。^([2](#c06-footnote-2))
    `movsx` 指令不允许常数操作数。
- en: For whatever reason, MASM requires a different instruction mnemonic (instruction
    name) when sign-extending a 32-bit operand into a 64-bit register (`movsxd` rather
    than `movsx`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无论出于什么原因，MASM 在符号扩展 32 位操作数到 64 位寄存器时，需要使用不同的指令助记符（指令名称）（`movsxd` 而不是 `movsx`）。
- en: To zero-extend a value, you can use the `movzx` instruction. It does not have
    the restrictions of `movsx`; as long as the destination operand is larger than
    the source operand, the instruction works fine. It allows 8 to 16, 32, or 64 bits,
    and 16 to 32 or 64 bits. There is no 32- to 64-bit version (it turns out this
    is unnecessary).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行零扩展，可以使用 `movzx` 指令。它没有 `movsx` 的限制；只要目标操作数大于源操作数，指令就能正常工作。它支持 8 到 16、32
    或 64 位，16 到 32 或 64 位之间的扩展。没有 32 到 64 位版本（事实证明这是不必要的）。
- en: 'The x86-64 CPUs, for historical reasons, will always zero-extend a register
    from 32 bits to 64 bits when performing 32-bit operations. Therefore, to zero-extend
    a 32-bit register into a 64-bit register, you need only move the (32-bit) register
    into itself; for example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，x86-64 CPU 在执行 32 位操作时，总是将 32 位寄存器零扩展为 64 位寄存器。因此，要将 32 位寄存器零扩展到 64 位寄存器，你只需将（32
    位）寄存器移动到其自身；例如：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Zero-extending certain 8-bit registers (AL, BL, CL, and DL) into their corresponding
    16-bit registers is easily accomplished without using `movzx` by loading the complementary
    HO register (AH, BH, CH, or DH) with 0\. To zero-extend AX into DX:AX or EAX into
    EDX:EAX, all you need to do is load DX or EDX with 0.^([3](#c06-footnote-3))
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 零扩展某些 8 位寄存器（AL、BL、CL 和 DL）到它们对应的 16 位寄存器，可以通过将互补的 HO 寄存器（AH、BH、CH 或 DH）加载为
    0 来轻松实现，而无需使用 `movzx`。要将 AX 零扩展到 DX:AX 或将 EAX 零扩展到 EDX:EAX，你只需将 DX 或 EDX 加载为 0。^([3](#c06-footnote-3))
- en: Because of instruction-encoding limitations, the x86-64 does not allow you to
    zero- or sign-extend the AH, BH, CH, or DH registers into any of the 64-bit registers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指令编码的限制，x86-64 不允许将 AH、BH、CH 或 DH 寄存器零扩展或符号扩展到任何 64 位寄存器中。
- en: 6.1.2 The mul and imul Instructions
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 mul 和 imul 指令
- en: You’ve already seen a subset of the `imul` instructions available in the x86-64
    instruction set (see “The imul Instruction” in Chapter 4). This section presents
    the extended-precision version of `imul` along with the unsigned `mul` instruction.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到过 x86-64 指令集中的一部分 `imul` 指令（参见第 4 章中的“imul 指令”）。本节将介绍扩展精度版本的 `imul` 和无符号
    `mul` 指令。
- en: The multiplication instructions provide you with another taste of irregularity
    in the x86-64’s instruction set. Instructions like `add`, `sub`, and many others
    in the x86-64 instruction set support two operands, just like the `mov` instruction.
    Unfortunately, there weren’t enough bits in the original 8086 opcode byte to support
    all instructions, so the x86-64 treats the `mul` (*unsigned multiply*) and `imul`
    (*signed integer multiply*) instructions as single-operand instructions, just
    like the `inc`, `dec`, and `neg` instructions. Of course, multiplication *is*
    a two-operand function. To work around this fact, the x86-64 always assumes the
    accumulator (AL, AX, EAX, or RAX) is the destination operand.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法指令展示了 x86-64 指令集中的另一个不规则性。像 `add`、`sub` 等许多 x86-64 指令都支持两个操作数，就像 `mov` 指令一样。不幸的是，原始的
    8086 操作码字节没有足够的位来支持所有指令，因此 x86-64 将 `mul`（*无符号乘法*）和 `imul`（*符号整数乘法*）指令当作单操作数指令，像
    `inc`、`dec` 和 `neg` 指令一样。当然，乘法 *确实* 是一个双操作数功能。为了绕过这个事实，x86-64 总是假设累加器（AL、AX、EAX
    或 RAX）是目标操作数。
- en: Another problem with the `mul` and `imul` instructions is that you cannot use
    them to multiply the accumulator by a constant. Intel quickly discovered the need
    to support multiplication by a constant and added the more general versions of
    the `imul` instruction to overcome this problem. Nevertheless, you must be aware
    that the basic `mul` and `imul` instructions do not support the full range of
    operands as the `imul` appearing in Chapter 4 does.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于`mul`和`imul`指令的问题是，无法使用它们将累加器与常数相乘。英特尔很快意识到需要支持与常数相乘，并添加了更通用版本的`imul`指令以解决这个问题。然而，你必须意识到，基本的`mul`和`imul`指令并不支持像第四章中出现的`imul`那样的完整操作数范围。
- en: 'The multiply instruction has two forms: unsigned multiplication (`mul`) and
    signed multiplication (`imul`). Unlike addition and subtraction, you need separate
    instructions for signed and unsigned operations.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法指令有两种形式：无符号乘法（`mul`）和有符号乘法（`imul`）。与加法和减法不同，你需要分别使用有符号和无符号操作的指令。
- en: 'The single-operand multiply instructions take the following forms:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单操作数乘法指令有以下形式：
- en: 'Unsigned multiplication:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号乘法：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Signed (integer) multiplication:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号（整数）乘法：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result of multiplying two *n*-bit values may require as many as 2 × *n*
    bits. Therefore, if the operand is an 8-bit quantity, the result could require
    16 bits. Likewise, a 16-bit operand produces a 32-bit result, a 32-bit operand
    produces 64 bits, and a 64-bit operand requires as many as 128 bits to hold the
    result. [Table 6-2](#table6-2) lists the various computations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 *n* 位值相乘的结果可能需要多达 2 × *n* 位。因此，如果操作数是8位数量，结果可能需要16位。同样，16位操作数会产生32位结果，32位操作数会产生64位结果，而64位操作数需要最多128位来保存结果。[表6-2](#table6-2)列出了各种计算。
- en: 'Table 6-2: `mul` and `imul` Operations'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '表 6-2: `mul` 和 `imul` 操作'
- en: '| **Instruction** | **Computes** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **计算结果** |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mul` `operand`[8] | AX = AL × *operand*[8] (unsigned) |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `mul` `operand`[8] | AX = AL × *operand*[8]（无符号） |'
- en: '| `imul` `operand`[8] | AX = AL × *operand*[8] (signed) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `imul` `operand`[8] | AX = AL × *operand*[8]（有符号） |'
- en: '| `mul` `operand`[16] | DX:AX = AX × *operand*[16] (unsigned) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `mul` `operand`[16] | DX:AX = AX × *operand*[16]（无符号） |'
- en: '| `imul` `operand`[16] | DX:AX = AX × *operand*[16] (signed) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `imul` `operand`[16] | DX:AX = AX × *operand*[16]（有符号） |'
- en: '| `mul` `operand`[32] | EDX:EAX = EAX × *operand*[32] (unsigned) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `mul` `operand`[32] | EDX:EAX = EAX × *operand*[32]（无符号） |'
- en: '| `imul` `operand`[32] | EDX:EAX = EAX × *operand*[32] (signed) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `imul` `operand`[32] | EDX:EAX = EAX × *operand*[32]（有符号） |'
- en: '| `mul` `operand`[64] | RDX:RAX = RAX × *operand*[64] (unsigned) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `mul` `operand`[64] | RDX:RAX = RAX × *operand*[64]（无符号） |'
- en: '| `imul` `operand`[64] | RDX:RAX = RAX × *operand*[64] (signed) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `imul` `operand`[64] | RDX:RAX = RAX × *operand*[64]（有符号） |'
- en: If an 8×8-, 16×16-, 32×32-, or 64×64-bit product requires more than 8, 16, 32,
    or 64 bits (respectively), the `mul` and `imul` instructions set the carry and
    overflow flags. `mul` and `imul` scramble the sign and zero flags.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 8×8 位、16×16 位、32×32 位或 64×64 位的乘积需要超过 8、16、32 或 64 位（分别），则`mul`和`imul`指令会设置进位和溢出标志。`mul`和`imul`会打乱符号标志和零标志。
- en: 'You’ll use the single-operand `mul` and `imul` instructions quite a lot when
    you learn about extended-precision arithmetic in Chapter 8. Unless you’re doing
    multiprecision work, however, you’ll probably want to use the more generic multi-operand
    version of the `imul` instruction in place of the extended-precision `mul` or
    `imul`. However, the generic `imul` (see Chapter 4) is not a complete replacement
    for these two instructions; in addition to the number of operands, several differences
    exist. The following rules apply specifically to the generic (multi-operand) `imul`
    instruction:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习第8章的扩展精度算术时，你会经常使用单操作数的`mul`和`imul`指令。然而，除非你在做多精度计算，否则你可能更倾向于使用更通用的多操作数版本`imul`指令，而不是扩展精度的`mul`或`imul`。然而，通用的`imul`（参见第4章）并不能完全替代这两条指令；除了操作数的数量外，它们之间还存在一些差异。以下规则专门适用于通用（多操作数）`imul`指令：
- en: There isn’t an 8×8-bit multi-operand `imul` instruction available.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有8×8位的多操作数`imul`指令。
- en: The generic `imul` instruction does not produce a 2×*n*-bit result, but truncates
    the result to *n* bits. That is, a 16×16-bit multiplication produces a 16-bit
    result. Likewise, a 32×32-bit multiplication produces a 32-bit result. These instructions
    set the carry and overflow flags if the result does not fit into the destination
    register.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用的`imul`指令不会产生2×*n*位的结果，而是将结果截断为*n*位。也就是说，16×16位的乘法结果是16位。同样，32×32位的乘法结果是32位。这些指令会在结果不能适配目标寄存器时设置进位和溢出标志。
- en: 6.1.3 The div and idiv Instructions
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 `div`和`idiv`指令
- en: 'The x86-64 divide instructions perform a 128/64-bit division, a 64/32-bit division,
    a 32/16-bit division, or a 16/8-bit division. These instructions take the following
    forms:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64的除法指令执行128/64位除法、64/32位除法、32/16位除法或16/8位除法。这些指令具有以下几种形式：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `div` instruction is an unsigned division operation. If the operand is an
    8-bit operand, `div` divides the AX register by the operand, leaving the quotient
    in AL and the remainder (modulo) in AH. If the operand is a 16-bit quantity, the
    `div` instruction divides the 32-bit quantity in DX:AX by the operand, leaving
    the quotient in AX and the remainder in DX. With 32-bit operands, `div` divides
    the 64-bit value in EDX:EAX by the operand, leaving the quotient in EAX and the
    remainder in EDX. Finally, with 64-bit operands, `div` divides the 128-bit value
    in RDX:RAX by the operand, leaving the quotient in RAX and the remainder in RDX.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`div`指令是无符号除法操作。如果操作数是8位操作数，`div`将AX寄存器除以操作数，将商存入AL，将余数（模）存入AH。如果操作数是16位数，`div`指令将DX:AX中的32位数除以操作数，将商存入AX，余数存入DX。对于32位操作数，`div`将EDX:EAX中的64位数除以操作数，将商存入EAX，余数存入EDX。最后，对于64位操作数，`div`将RDX:RAX中的128位数除以操作数，将商存入RAX，余数存入RDX。'
- en: 'There is no variant of the `div` or `idiv` instructions that allows you to
    divide a value by a constant. If you want to divide a value by a constant, you
    need to create a memory object (preferably in the `.const` section) that is initialized
    with the constant, and then use that memory value as the `div`/`idiv` operand.
    For example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`div`或`idiv`指令的变体可以让你将一个值除以常量。如果你想将一个值除以常量，你需要创建一个内存对象（最好在`.const`段中），并使用常量初始化它，然后将该内存值用作`div`/`idiv`的操作数。例如：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `idiv` instruction computes a signed quotient and remainder. The syntax
    for the `idiv` instruction is identical to `div` (except for the use of the `idiv`
    mnemonic), though creating signed operands for `idiv` may require a different
    sequence of instructions prior to executing `idiv` than for `div`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`idiv`指令计算带符号商和余数。`idiv`指令的语法与`div`相同（唯一的区别是使用`idiv`助记符），尽管在执行`idiv`之前，为`idiv`创建带符号操作数可能需要与`div`不同的指令序列。'
- en: You cannot, on the x86-64, simply divide one unsigned 8-bit value by another.
    If the denominator is an 8-bit value, the numerator must be a 16-bit value. If
    you need to divide one unsigned 8-bit value by another, you must zero-extend the
    numerator to 16 bits by loading the numerator into the AL register and then moving
    0 into the AH register. *Failing to zero-extend AL before executing* `div` *may
    cause the x86-64 to produce incorrect results*! When you need to divide two 16-bit
    unsigned values, you must zero-extend the AX register (which contains the numerator)
    into the DX register. To do this, just load 0 into the DX register. If you need
    to divide one 32-bit value by another, you must zero-extend the EAX register into
    EDX (by loading a 0 into EDX) before the division. Finally, to divide one 64-bit
    number by another, you must zero-extend RAX into RDX (for example, using an `xor
    rdx, rdx` instruction) prior to the division.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86-64架构中，你不能简单地将一个无符号8位值除以另一个。如果除数是8位值，则被除数必须是16位值。如果需要将一个无符号8位值除以另一个，你必须通过将被除数加载到AL寄存器中，并将0移动到AH寄存器中来将被除数扩展为16位。*如果在执行`div`之前未将AL扩展为16位*，*可能会导致x86-64产生错误结果*！当你需要将两个16位无符号值相除时，你必须将AX寄存器（包含被除数）零扩展到DX寄存器。为此，只需将0加载到DX寄存器中。如果需要将一个32位值除以另一个，你必须在除法之前将EAX寄存器零扩展到EDX（通过将0加载到EDX）。最后，要将一个64位数除以另一个，你必须在除法之前将RAX零扩展到RDX（例如，使用`xor
    rdx, rdx`指令）。
- en: When dealing with signed integer values, you will need to sign-extend AL into
    AX, AX into DX, EAX into EDX, or RAX into RDX before executing `idiv`. To do so,
    use the `cbw`, `cwd`, `cdq`, or `cqo` instructions.^([4](#c06-footnote-4)) Failure
    to do so may produce incorrect results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 处理带符号整数值时，在执行`idiv`之前，你需要将AL扩展为AX，将AX扩展为DX，将EAX扩展为EDX，或者将RAX扩展为RDX。为此，可以使用`cbw`、`cwd`、`cdq`或`cqo`指令。^([4](#c06-footnote-4))
    如果没有这样做，可能会产生错误的结果。
- en: 'The x86-64’s divide instructions have one other issue: you can get a fatal
    error when using this instruction. First, of course, you can attempt to divide
    a value by 0\. Another problem is that the quotient may be too large to fit into
    the RAX, EAX, AX, or AL register. For example, the 16/8-bit division 8000h/2 produces
    the quotient 4000h with a remainder of 0\. 4000h will not fit into 8 bits. If
    this happens, or you attempt to divide by 0, the x86-64 will generate a division
    exception or integer overflow exception. This usually means your program will
    crash. If this happens to you, chances are you didn’t sign- or zero-extend your
    numerator before executing the division operation. Because this error may cause
    your program to crash, you should be very careful about the values you select
    when using division.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 的除法指令还存在一个问题：使用该指令时可能会出现致命错误。首先，当然，你可能会尝试将一个值除以 0。另一个问题是商可能太大，无法存入 RAX、EAX、AX
    或 AL 寄存器。例如，16/8 位除法 8000h / 2 产生商 4000h，余数为 0。4000h 无法存入 8 位寄存器。如果发生这种情况，或者你尝试除以
    0，x86-64 将生成除法异常或整数溢出异常。这通常意味着你的程序会崩溃。如果这种情况发生，可能是因为你在执行除法操作之前没有对分子进行符号扩展或零扩展。由于这个错误可能导致程序崩溃，因此在使用除法时，你应非常小心选择数值。
- en: The x86-64 leaves the carry, overflow, sign, and zero flags undefined after
    a division operation. Therefore, you cannot test for problems after a division
    operation by checking the flag bits.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 在除法操作后会将进位标志、溢出标志、符号标志和零标志设置为未定义。因此，你不能通过检查标志位来测试除法操作后的问题。
- en: 6.1.4 The cmp Instruction, Revisited
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 再探 cmp 指令
- en: As noted in “The cmp Instruction and Corresponding Conditional Jumps” in Chapter
    2, the `cmp` instruction updates the x86-64’s flags according to the result of
    the subtraction operation (`leftOperand` `-` `rightOperand`). The x86-64 sets
    the flags in an appropriate fashion so that we can read this instruction as “compare
    `leftOperand` to `rightOperand`.” You can test the result of the comparison by
    using the conditional set instructions to check the appropriate flags in the FLAGS
    register (see “The setcc Instructions” on page 295) or the conditional jump instructions
    (Chapter 2 or Chapter 7).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在第2章《cmp指令及相应的条件跳转》中提到的，`cmp` 指令根据减法操作（`leftOperand` `-` `rightOperand`）的结果更新
    x86-64 的标志。x86-64 会以适当的方式设置标志，使我们可以将该指令解读为“将 `leftOperand` 与 `rightOperand` 进行比较”。你可以通过使用条件设置指令来测试比较结果，检查
    FLAGS 寄存器中的相应标志（参见第295页的《setcc指令》）或条件跳转指令（第2章或第7章）。
- en: 'Probably the first place to start when exploring the `cmp` instruction is to
    look at exactly how it affects the flags. Consider the following `cmp` instruction:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 `cmp` 指令时，可能首先要做的就是查看它如何影响标志。考虑以下 `cmp` 指令：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This instruction performs the computation AX – BX and sets the flags depending
    on the result of the computation. The flags are set as follows (also see [Table
    6-3](#table6-3)):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令执行 AX – BX 计算，并根据计算结果设置标志。标志设置如下（另见[表6-3](#table6-3)）：
- en: '**ZF**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**ZF**'
- en: The zero flag is set if and only if AX = BX. This is the only time AX – BX produces
    a 0 result. Hence, you can use the zero flag to test for equality or inequality.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当 AX = BX 时，零标志才会被设置。这是 AX – BX 产生 0 结果的唯一情况。因此，你可以使用零标志来测试相等或不等。
- en: '**SF**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**SF**'
- en: The sign flag is set to 1 if the result is negative. At first glance, you might
    think that this flag would be set if AX is less than BX, but this isn’t always
    the case. If AX = 7FFFh and BX = –1 (0FFFFh), then subtracting AX from BX produces
    8000h, which is negative (and so the sign flag will be set). So, for signed comparisons
    anyway, the sign flag doesn’t contain the proper status. For unsigned operands,
    consider AX = 0FFFFh and BX = 1\. Here, AX is greater than BX, but their difference
    is 0FFFEh, which is still negative. As it turns out, the sign flag and the overflow
    flag, taken together, can be used for comparing two signed values.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果结果为负，则符号标志被设置为 1。乍一看，你可能认为如果 AX 小于 BX，符号标志就会被设置，但实际上并非总是如此。如果 AX = 7FFFh 且
    BX = -1（0FFFFh），则从 BX 中减去 AX 结果为 8000h，这是负数（因此符号标志将被设置）。所以，对于有符号比较，符号标志并不能提供正确的状态。对于无符号操作数，考虑
    AX = 0FFFFh 和 BX = 1。在这种情况下，AX 大于 BX，但它们的差值是 0FFFEh，仍然是负数。事实证明，符号标志和溢出标志结合起来，可以用来比较两个有符号值。
- en: '**OF**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**OF**'
- en: The overflow flag is set after a `cmp` operation if the difference of AX and
    BX produced an overflow or underflow. As mentioned previously, the sign and overflow
    flags are both used when performing signed comparisons.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 AX 和 BX 的差值发生了溢出或下溢，溢出标志将在 `cmp` 操作后被设置。如前所述，符号标志和溢出标志在进行有符号比较时都会使用。
- en: '**CF**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**CF**'
- en: The carry flag is set after a `cmp` operation if subtracting BX from AX requires
    a borrow. This occurs only when AX is less than BX, where AX and BX are both unsigned
    values.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果从 AX 中减去 BX 需要借位，进位标志将在 `cmp` 操作后被设置。只有当 AX 小于 BX 时，且 AX 和 BX 都是无符号值时，才会发生这种情况。
- en: 'Table 6-3: Condition Code Settings After `cmp`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-3：`cmp` 操作后的条件码设置
- en: '| **Unsigned operands** | **Signed operands** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **无符号操作数** | **有符号操作数** |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ZF: Equality/inequality | ZF: Equality/inequality |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| ZF: 相等/不等 | ZF: 相等/不等 |'
- en: '| CF: Left `<` Right (C = 1) Left `≥` Right (C = 0) | CF: No meaning |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| CF: 左 `<` 右（C = 1） 左 `≥` 右（C = 0） | CF: 无意义 |'
- en: '| SF: No meaning | SF: See discussion in this section |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| SF: 无意义 | SF: 请参阅本节讨论 |'
- en: '| OF: No meaning | OF: See discussion in this section |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| OF: 无意义 | OF: 请参阅本节讨论 |'
- en: 'Given that the `cmp` instruction sets the flags in this fashion, you can test
    the comparison of the two operands with the following flags:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `cmp` 指令以这种方式设置标志，您可以通过以下标志测试两个操作数的比较：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For signed comparisons, the SF (sign) and OF (overflow) flags, taken together,
    have the following meanings:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号比较，SF（符号）和OF（溢出）标志一起具有以下含义：
- en: If [(SF = 0) and (OF = 1)] or [(SF = 1) and (OF = 0)], then `Left` `<` `Right`
    for a signed comparison.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 [(SF = 0) 且 (OF = 1)] 或 [(SF = 1) 且 (OF = 0)]，则对于有符号比较，`Left` `<` `Right`。
- en: If [(SF = 0) and (OF = 0)] or [(SF = 1) and (OF = 1)], then `Left` `≥` `Right`
    for a signed comparison.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 [(SF = 0) 且 (OF = 0)] 或 [(SF = 1) 且 (OF = 1)]，则对于有符号比较，`Left` `≥` `Right`。
- en: Note that (SF `xor` OF) is 1 if the left operand is less than the right operand.
    Conversely, (SF `xor` OF) is 0 if the left operand is greater than or equal to
    the right operand.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果左操作数小于右操作数，则 (SF `xor` OF) 为 1。相反，如果左操作数大于或等于右操作数，则 (SF `xor` OF) 为 0。
- en: To understand why these flags are set in this manner, consider the examples
    in [Table 6-4](#table6-4).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这些标志以这种方式设置，请参考 [表 6-4](#table6-4) 中的示例。
- en: 'Table 6-4: Sign and Overflow Flag Settings After Subtraction'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-4：减法后的符号标志和溢出标志设置
- en: '| **Left** | **Minus** | **Right** | **SF** | **OF** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **Left** | **减去** | **Right** | **SF** | **OF** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0FFFFh (–1) | – | 0FFFEh (–2) | 0 | 0 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 0FFFFh (–1) | – | 0FFFEh (–2) | 0 | 0 |'
- en: '| 8000h (–32,768) | – | 0001h | 0 | 1 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 8000h (–32,768) | – | 0001h | 0 | 1 |'
- en: '| 0FFFEh (–2) | – | 0FFFFh (–1) | 1 | 0 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 0FFFEh (–2) | – | 0FFFFh (–1) | 1 | 0 |'
- en: '| 7FFFh (32767) | – | 0FFFFh (–1) | 1 | 1 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 7FFFh (32767) | – | 0FFFFh (–1) | 1 | 1 |'
- en: Remember, the `cmp` operation is really a subtraction; therefore, the first
    example in [Table 6-4](#table6-4) computes (–1) – (–2), which is (+1). The result
    is positive and an overflow did not occur, so both the S and O flags are 0\. Because
    (SF `xor` OF) is 0, `Left` is greater than or equal to `Right`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`cmp` 操作实际上是减法运算；因此，[表 6-4](#table6-4) 中的第一个示例计算的是 (–1) – (–2)，即 (+1)。结果是正数，并且没有发生溢出，因此
    S 和 O 标志都为 0。由于 (SF `xor` OF) 为 0，`Left` 大于或等于 `Right`。
- en: In the second example, the `cmp` instruction computes (–32,768) – (+1), which
    is (–32,769). Because a 16-bit signed integer cannot represent this value, the
    value wraps around to 7FFFh (+32,767) and sets the overflow flag. The result is
    positive (at least as a 16-bit value), so the CPU clears the sign flag. (SF `xor`
    OF) is 1 here, so `Left` is less than `Right`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，`cmp` 指令计算的是 (–32,768) – (+1)，即 (–32,769)。由于 16 位有符号整数无法表示该值，该值会回绕到
    7FFFh（+32,767），并设置溢出标志。结果是正数（至少在 16 位值中是正数），因此 CPU 会清除符号标志。这里 (SF `xor` OF) 为
    1，因此 `Left` 小于 `Right`。
- en: In the third example, `cmp` computes (–2) – (–1), which produces (–1). No overflow
    occurred, so the OF is 0, and the result is negative, so the SF is 1\. Because
    (SF `xor` OF) is 1, `Left` is less than `Right`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，`cmp` 计算的是 (–2) – (–1)，得到 (–1)。没有发生溢出，因此 OF 为 0，结果是负数，所以 SF 为 1。由于 (SF
    `xor` OF) 为 1，`Left` 小于 `Right`。
- en: In the fourth (and final) example, `cmp` computes (+32,767) – (–1). This produces
    (+32,768), setting the overflow flag. Furthermore, the value wraps around to 8000h
    (–32,768), so the sign flag is set as well. Because (SF `xor` OF) is 0, `Left`
    is greater than or equal to `Right`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个（也是最后一个）示例中，`cmp` 计算 (+32,767) – (–1)。这将得到 (+32,768)，并设置溢出标志。此外，值会回绕到 8000h（–32,768），因此符号标志也会被设置。由于
    (SF `xor` OF) 为 0，`Left` 大于或等于 `Right`。
- en: 6.1.5 The setcc Instructions
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.5 setcc 指令
- en: 'The `set``cc` (*set on condition*) instructions set a single-byte operand (register
    or memory) to 0 or 1 depending on the values in the FLAGS register. The general
    formats for the `set``cc` instructions are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`set``cc`（*条件设置*）指令根据 FLAGS 寄存器中的值将一个字节的操作数（寄存器或内存）设置为 0 或 1。`set``cc` 指令的一般格式如下：'
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `set``cc` represents a mnemonic appearing in Tables 6-5, 6-6, and 6-7\.
    These instructions store a 0 in the corresponding operand if the condition is
    false, and they store a 1 in the 8-bit operand if the condition is true.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`set``cc` 代表在表 6-5、6-6 和 6-7 中出现的助记符。这些指令如果条件为假，则将对应的操作数设置为 0；如果条件为真，则将 8 位操作数设置为
    1。'
- en: 'Table 6-5: `set``cc` Instructions That Test Flags'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-5：`set``cc` 测试标志的指令
- en: '| **Instruction** | **Description** | **Condition** | **Comments** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** | **条件** | **备注** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `setc` | Set if carry | Carry = 1 | Same as `setb`, `setnae` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `setc` | 如果有进位则设置 | 进位 = 1 | 同 `setb`，`setnae` |'
- en: '| `setnc` | Set if no carry | Carry = 0 | Same as `setnb`, `setae` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `setnc` | 如果没有进位则设置 | 进位 = 0 | 同 `setnb`，`setae` |'
- en: '| `setz` | Set if zero | Zero = 1 | Same as `sete` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `setz` | 如果为零则设置 | 零 = 1 | 同 `sete` |'
- en: '| `setnz` | Set if not zero | Zero = 0 | Same as `setne` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `setnz` | 如果不为零则设置 | 零 = 0 | 同 `setne` |'
- en: '| `sets` | Set if sign | Sign = 1 |  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `sets` | 如果符号位为 1 则设置 | 符号 = 1 |  |'
- en: '| `setns` | Set if no sign | Sign = 0 |  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `setns` | 如果没有符号位则设置 | 符号 = 0 |  |'
- en: '| `seto` | Set if overflow | Overflow = 1 |  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `seto` | 如果溢出则设置 | 溢出 = 1 |  |'
- en: '| `setno` | Set if no overflow | Overflow = 0 |  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `setno` | 如果没有溢出则设置 | 溢出 = 0 |  |'
- en: '| `setp` | Set if parity | Parity = 1 | Same as `setpe` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `setp` | 如果有奇偶标志则设置 | 奇偶 = 1 | 同 `setpe` |'
- en: '| `setpe` | Set if parity even | Parity = 1 | Same as `setp` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `setpe` | 如果奇偶标志为偶则设置 | 奇偶 = 1 | 同 `setp` |'
- en: '| `setnp` | Set if no parity | Parity = 0 | Same as `setpo` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `setnp` | 如果没有奇偶标志则设置 | 奇偶 = 0 | 同 `setpo` |'
- en: '| `setpo` | Set if parity odd | Parity = 0 | Same as `setnp` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `setpo` | 如果奇偶标志为奇则设置 | 奇偶 = 0 | 同 `setnp` |'
- en: The `set``cc` instructions in [Table 6-5](#table6-5) simply test the flags without
    any other meaning attached to the operation. You could, for example, use `setc`
    to check the carry flag after a shift, rotate, bit test, or arithmetic operation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`set``cc` 指令在 [表 6-5](#table6-5) 中仅用于测试标志，而没有其他操作含义。例如，你可以在移位、旋转、位测试或算术操作后使用
    `setc` 来检查进位标志。'
- en: The `setp`/`setpe` and `setnp`/`setpo` instructions check the parity flag. These
    instructions appear here for completeness, but this book will not spend much time
    discussing the parity flag; in modern code, it’s typically used only to check
    for an FPU not-a-number (NaN) condition.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`setp`/`setpe` 和 `setnp`/`setpo` 指令检查奇偶标志。虽然这些指令在这里出现是为了完整性，但本书不会花太多时间讨论奇偶标志；在现代代码中，它通常仅用于检查浮点单元（FPU）是否为非数值（NaN）状态。'
- en: The `cmp` instruction works synergistically with the `set``cc` instructions.
    Immediately after a `cmp` operation, the processor flags provide information concerning
    the relative values of those operands. They allow you to see if one operand is
    less than, equal to, or greater than the other.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 指令与 `set``cc` 指令协同工作。在 `cmp` 操作后，处理器标志提供有关操作数相对值的信息。它们可以帮助你查看一个操作数是否小于、等于或大于另一个操作数。'
- en: Two additional groups of `set``cc` instructions are useful after a `cmp` operation.
    The first group deals with the result of an unsigned comparison ([Table 6-6](#table6-6));
    the second group deals with the result of a signed comparison ([Table 6-7](#table6-7)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 两组额外的 `set``cc` 指令在 `cmp` 操作后很有用。第一组处理无符号比较的结果（[表 6-6](#table6-6)）；第二组处理有符号比较的结果（[表
    6-7](#table6-7)）。
- en: 'Table 6-6: `set``cc` Instructions for Unsigned Comparisons'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-6：`set``cc` 无符号比较指令
- en: '| **Instruction** | **Description** | **Condition** | **Comments** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** | **条件** | **备注** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `seta` | Set if above (`>`) | Carry `=` 0, Zero `=` 0 | Same as `setnbe`
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `seta` | 如果大于（`>`）则设置 | 进位 `=` 0，零 `=` 0 | 同 `setnbe` |'
- en: '| `setnbe` | Set if not below or equal (not `≤`) | Carry `=` 0, Zero `=` 0
    | Same as `seta` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `setnbe` | 如果不小于或等于（不 `≤`）则设置 | 进位 `=` 0，零 `=` 0 | 同 `seta` |'
- en: '| `setae` | Set if above or equal (`≥`) | Carry `=` 0 | Same as `setnc`, `setnb`
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `setae` | 如果大于或等于（`≥`）则设置 | 进位 `=` 0 | 同 `setnc`，`setnb` |'
- en: '| `setnb` | Set if not below (not `<`) | Carry `=` 0 | Same as `setnc`, `setae`
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `setnb` | 如果不小于（不 `<`）则设置 | 进位 `=` 0 | 同 `setnc`，`setae` |'
- en: '| `setb` | Set if below (`<`) | Carry `=` 1 | Same as `setc`, `setnae` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `setb` | 如果小于（`<`）则设置 | 进位 `=` 1 | 同 `setc`，`setnae` |'
- en: '| `setnae` | Set if not above or equal (not `≥`) | Carry `=` 1 | Same as `setc`,
    `setb` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `setnae` | 如果不大于或等于（不 `≥`）则设置 | 进位 `=` 1 | 同 `setc`，`setb` |'
- en: '| `setbe` | Set if below or equal (`≤`) | Carry `=` 1 or Zero `=` 1 | Same
    as `setna` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `setbe` | 如果小于或等于（`≤`）则设置 | 进位 `=` 1 或零 `=` 1 | 与 `setna` 相同 |'
- en: '| `setna` | Set if not above (not `>`) | Carry `=` 1 or Zero `=` 1 | Same as
    `setbe` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `setna` | 如果不大于（不是 `>`）则设置 | 进位 `=` 1 或零 `=` 1 | 与 `setbe` 相同 |'
- en: '| `sete` | Set if equal (`==`) | Zero `=` 1 | Same as `setz` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `sete` | 如果相等，则设置（`==`） | 零 `=` 1 | 与 `setz` 相同 |'
- en: '| `setne` | Set if not equal (`≠`) | Zero `=` 0 | Same as `setnz` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `setne` | 如果不相等，则设置（`≠`） | 零 `=` 0 | 与 `setnz` 相同 |'
- en: 'Table 6-7: `set``cc` Instructions for Signed Comparisons'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '表6-7: `set``cc`指令用于带符号比较'
- en: '| **Instruction** | **Description** | **Condition** | **Comments** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** | **条件** | **注释** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `setg` | Set if greater (`>`) | Sign `==` Overflow and Zero `==` 0 | Same
    as `setnle` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `setg` | 如果大于（`>`）则设置 | 符号 `==` 溢出且零 `==` 0 | 与 `setnle` 相同 |'
- en: '| `setnle` | Set if not less than or equal (not `≤`) | Sign `==` Overflow or
    Zero `==` 0 | Same as `setg` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `setnle` | 如果不小于或等于（不是 `≤`）则设置 | 符号 `==` 溢出或零 `==` 0 | 与 `setg` 相同 |'
- en: '| `setge` | Set if greater than or equal (`≥`) | Sign `==` Overflow | Same
    as `setnl` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `setge` | 如果大于或等于（`≥`）则设置 | 符号 `==` 溢出 | 与 `setnl` 相同 |'
- en: '| `setnl` | Set if not less than (not `<`) | Sign `==` Overflow | Same as `setge`
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `setnl` | 如果不小于（不是 `<`）则设置 | 符号 `==` 溢出 | 与 `setge` 相同 |'
- en: '| `setl` | Set if less than (`<`) | Sign `≠` Overflow | Same as `setnge` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `setl` | 如果小于（`<`）则设置 | 符号 `≠` 溢出 | 与 `setnge` 相同 |'
- en: '| `setnge` | Set if not greater or equal (not `≥`) | Sign `≠` Overflow | Same
    as `setl` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `setnge` | 如果不大于或等于（不是 `≥`）则设置 | 符号 `≠` 溢出 | 与 `setl` 相同 |'
- en: '| `setle` | Set if less than or equal (`≤`) | Sign `≠` Overflow or Zero `==`
    1 | Same as `setng` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `setle` | 如果小于或等于，则设置（`≤`） | 符号 `≠` 溢出或零 `==` 1 | 与 `setng` 相同 |'
- en: '| `setng` | Set if not greater than (not `>`) | Sign `≠` Overflow or Zero `==`
    1 | Same as `setle` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `setng` | 如果不大于（不是 `>`）则设置 | 符号 `≠` 溢出或零 `==` 1 | 与 `setle` 相同 |'
- en: '| `sete` | Set if equal (`=`) | Zero `==` 1 | Same as `setz` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `sete` | 如果相等，则设置（`=`） | 零 `==` 1 | 与 `setz` 相同 |'
- en: '| `setne` | Set if not equal (`≠`) | Zero `==` 0 | Same as `setnz` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `setne` | 如果不相等，则设置（`≠`） | 零 `==` 0 | 与 `setnz` 相同 |'
- en: 'The `set``cc` instructions are particularly valuable because they can convert
    the result of a comparison to a Boolean value (false/true or 0/1). This is especially
    important when translating statements from a high-level language like Swift or
    C/C++ into assembly language. The following example shows how to use these instructions
    in this manner:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`set``cc`指令特别有价值，因为它们可以将比较结果转换为布尔值（假/真或0/1）。这在将高层语言（如Swift或C/C++）的语句翻译成汇编语言时尤其重要。以下示例展示了如何以这种方式使用这些指令：'
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Because the `set``cc` instructions always produce 0 or 1, you can use the results
    with the `and` and `or` instructions to compute complex Boolean values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`set``cc`指令总是产生0或1，你可以将结果与`and`和`or`指令一起使用，计算复杂的布尔值：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 6.1.6 The test Instruction
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.6 `test` 指令
- en: 'The x86-64 `test` instruction is to the `and` instruction what the `cmp` instruction
    is to `sub`. That is, the `test` instruction computes the logical AND of its two
    operands and sets the condition code flags based on the result; it does not, however,
    store the result of the logical AND back into the destination operand. The syntax
    for the `test` instruction is similar to `and`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64的`test`指令与`and`指令的关系，类似于`cmp`指令与`sub`指令的关系。也就是说，`test`指令计算其两个操作数的逻辑与，并根据结果设置条件码标志；然而，它不会将逻辑与的结果存储回目标操作数。`test`指令的语法与`and`指令相似：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `test` instruction sets the zero flag if the result of the logical AND operation
    is 0\. It sets the sign flag if the HO bit of the result contains a 1\. The `test`
    instruction always clears the carry and overflow flags.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`指令如果逻辑与操作的结果为0，则设置零标志。它会设置符号标志，如果结果的HO位包含1。`test`指令总是清除进位标志和溢出标志。'
- en: The primary use of the `test` instruction is to check whether an individual
    bit contains a 0 or a 1\. Consider the instruction `test al, 1`. This instruction
    logically ANDs AL with the value 1; if bit 0 of AL contains 0, the result will
    be 0 (setting the zero flag) because all the other bits in the constant 1 are
    0\. Conversely, if bit 0 of AL contains 1, then the result is not 0, so `test`
    clears the zero flag. Therefore, you can test the zero flag after this `test`
    instruction to see if bit 0 contains a 0 or a 1 (for example, using `setz` or
    `setnz` instructions, or the `jz`/`jnz` instructions).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 指令的主要用途是检查单个位是否包含 0 或 1\. 以指令 `test al, 1` 为例。该指令将 AL 与值 1 进行逻辑与运算；如果
    AL 的第 0 位为 0，结果将是 0（设置零标志），因为常量 1 的其他位都为 0\. 相反，如果 AL 的第 0 位为 1，那么结果就不是 0，因此 `test`
    会清除零标志。因此，你可以在执行此 `test` 指令后测试零标志，查看第 0 位是否包含 0 或 1（例如，使用 `setz` 或 `setnz` 指令，或
    `jz` / `jnz` 指令）。'
- en: The `test` instruction can also check whether all the bits in a specified set
    of bits contain 0\. The instruction `test al, 0fh` sets the zero flag if and only
    if the LO 4 bits of AL all contain 0.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 指令还可以检查指定的位集中的所有位是否都包含 0\. 指令 `test al, 0fh` 只有在 AL 的低 4 位全为 0 时才会设置零标志。'
- en: 'One important use of the `test` instruction is to check whether a register
    contains 0\. The instruction `test` `reg``,` `reg`, where both operands are the
    same register, will logically AND that register with itself. If the register contains
    0, the result is 0 and the CPU will set the zero flag. However, if the register
    contains a nonzero value, logically ANDing that value with itself produces that
    same nonzero value, so the CPU clears the zero flag. Therefore, you can check
    the zero flag immediately after the execution of this instruction (for example,
    using the `setz` or `setnz` instructions or the `jz` and `jnz` instructions) to
    see if the register contains 0\. Here are some examples:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 指令的一个重要用途是检查寄存器是否包含 0\. `test` `reg`,` reg` 指令，其中两个操作数是相同的寄存器，将该寄存器与其自身进行逻辑与运算。如果寄存器中包含
    0，结果将是 0，CPU 会设置零标志。然而，如果寄存器中包含非零值，将该值与自身进行逻辑与运算会得到相同的非零值，因此 CPU 会清除零标志。因此，你可以在执行该指令后立即检查零标志（例如，使用
    `setz` 或 `setnz` 指令，或 `jz` 和 `jnz` 指令）来查看寄存器是否包含 0\. 以下是一些示例：'
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: One major failing of the `test` instruction is that immediate (constant) operands
    can be no larger than 32 bits (as is the case with most instructions), which makes
    it difficult to use this instruction to test for set bits beyond bit position
    31\. For testing individual bits, you can use the `bt` (*bit test*) instruction
    (see “Instructions That Manipulate Bits” in Chapter 12). Otherwise, you’ll have
    to move the 64-bit constant into a register (the `mov` instruction does support
    64-bit immediate operands) and then test your target register against the 64-bit
    constant value in the newly loaded register.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 指令的一个主要缺点是立即数（常量）操作数不能大于 32 位（大多数指令都是如此），这使得使用该指令测试超过第 31 位的设置位变得困难。要测试单个位，可以使用
    `bt`（*位测试*）指令（参见第 12 章的“操作位的指令”）。否则，你必须将 64 位常量移动到寄存器中（`mov` 指令确实支持 64 位立即数操作数），然后将目标寄存器与新加载的寄存器中的
    64 位常量值进行测试。'
- en: 6.2 Arithmetic Expressions
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 算术表达式
- en: 'Probably the biggest shock to beginners facing assembly language for the first
    time is the lack of familiar arithmetic expressions. *Arithmetic expressions*,
    in most high-level languages, look similar to their algebraic equivalents. For
    example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 面对汇编语言的初学者，可能最大的冲击是缺乏熟悉的算术表达式。在大多数高级语言中，*算术表达式* 看起来与其代数等价物相似。例如：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In assembly language, you’ll need several statements to accomplish this same
    task:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，你需要几条语句来完成相同的任务：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Obviously, the HLL version is much easier to type, read, and understand. Although
    a lot of typing is involved, converting an arithmetic expression into assembly
    language isn’t difficult at all. By attacking the problem in steps, the same way
    you would solve the problem by hand, you can easily break any arithmetic expression
    into an equivalent sequence of assembly language statements.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，高级语言版本要更容易输入、阅读和理解。尽管需要大量的输入，将算术表达式转换成汇编语言并不难。通过分步处理问题，就像你手动解决问题一样，你可以轻松地将任何算术表达式分解为等效的汇编语言语句。
- en: 6.2.1 Simple Assignments
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 简单赋值
- en: 'The easiest expressions to convert to assembly language are simple assignments.
    *Simple assignments* copy a single value into a variable and take one of two forms:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为汇编语言最简单的表达式是简单赋值。*简单赋值*将单个值复制到变量中，通常有两种形式：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: or
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Converting the first form to assembly language is simple—just use this assembly
    language statement:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一种形式转换为汇编语言非常简单——只需使用以下汇编语言语句：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This `mov` instruction copies the constant into the variable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`mov`指令将常量复制到变量中。
- en: 'The second assignment is slightly more complicated because the x86-64 doesn’t
    provide a memory-to-memory `mov` instruction. Therefore, to copy one memory variable
    into another, you must move the data through a register. By convention (and for
    slight efficiency reasons), most programmers tend to favor AL, AX, EAX, or RAX
    for this purpose. For example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种赋值稍微复杂一些，因为x86-64并不提供内存到内存的`mov`指令。因此，要将一个内存变量复制到另一个变量，必须通过寄存器来移动数据。根据约定（以及出于轻微的效率考虑），大多数程序员倾向于使用AL、AX、EAX或RAX来完成此操作。例如：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: becomes
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: assuming that `var1` and `var2` are 32-bit variables. Use AL if they are 8-bit
    variables, use AX if they are 16-bit variables, or use RAX if they are 64-bit
    variables.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`var1`和`var2`是32位变量。如果它们是8位变量，使用AL；如果是16位变量，使用AX；如果是64位变量，使用RAX。
- en: Of course, if you’re already using AL, AX, EAX, or RAX for something else, one
    of the other registers will suffice. Regardless, you will generally use a register
    to transfer one memory location to another.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你已经在做其他操作时使用了AL、AX、EAX或RAX，那么使用其他寄存器也能满足要求。不管怎样，你通常会使用一个寄存器将一个内存位置的内容传输到另一个位置。
- en: 6.2.2 Simple Expressions
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 简单表达式
- en: The next level of complexity is a simple expression. A *simple expression* takes
    the form
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一层次的复杂度是简单表达式。*简单表达式*的形式为
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: where `var1` is a variable, `term1` and `term2` are variables or constants,
    and `op` is an arithmetic operator (addition, subtraction, multiplication, and
    so on). Most expressions take this form. It should come as no surprise, then,
    that the x86-64 architecture was optimized for just this type of expression.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`var1`是一个变量，`term1`和`term2`是变量或常量，而`op`是一个算术运算符（加法、减法、乘法等）。大多数表达式都采用这种形式。因此，x86-64架构特别针对这种类型的表达式进行了优化，这一点应该不会让人感到意外。
- en: A typical conversion for this type of expression takes the form
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的表达式的典型转换形式为：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: where `op` is the mnemonic that corresponds to the specified operation (for
    example, + is `add`, – is `sub`, and so forth).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`op`是与指定操作相对应的助记符（例如，+是`add`，–是`sub`，以此类推）。
- en: Note that the simple expression `var1` `=` `const1``op``const2``;` is easily
    handled with a compile-time expression and a single `mov` instruction. For example,
    to compute `var1` `= 5 + 3;`, use the single instruction `mov` `var1``, 5 + 3`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，简单表达式`var1` `=` `const1``op``const2``;`通常通过编译时表达式和单一的`mov`指令轻松处理。例如，要计算`var1`
    `= 5 + 3;`，只需使用单一指令`mov var1, 5 + 3`。
- en: You need to be aware of a few inconsistencies. When dealing with the `(``i``)mul`
    and `(``i``)div` instructions on the x86-64, you must use the AL, AX, EAX, and
    RAX registers and the AH, DX, EDX, and RDX registers. You cannot use arbitrary
    registers as you can with other operations. Also, don’t forget the sign-extension
    instructions if you’re performing a division operation to divide one 16-, 32-,
    or 64-bit number by another. Finally, don’t forget that some instructions may
    cause overflow. You may want to check for an overflow (or underflow) condition
    after an arithmetic operation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要注意一些不一致性。在处理x86-64上的`(``i``)mul`和`(``i``)div`指令时，必须使用AL、AX、EAX和RAX寄存器，以及AH、DX、EDX和RDX寄存器。你不能像其他操作那样随意使用寄存器。此外，如果你进行除法运算以将一个16位、32位或64位数除以另一个数，别忘了符号扩展指令。最后，别忘了某些指令可能会导致溢出。在进行算术运算后，你可能需要检查溢出（或下溢）情况。
- en: 'Here are examples of common simple expressions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是常见简单表达式的示例：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Certain unary operations also qualify as simple expressions, producing additional
    inconsistencies to the general rule. A good example of a unary operation is *negation*.
    In a high-level language, negation takes one of two possible forms:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 某些一元运算也符合简单表达式的条件，导致与一般规则有所不一致。一元运算的一个好例子是*取反*。在高级语言中，取反有两种可能的形式：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: or
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that `var` `= –``constant` is really a simple assignment, not a simple
    expression. You can specify a negative constant as an operand to the `mov` instruction:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`var` `= –``constant`实际上是一个简单的赋值，而不是一个简单的表达式。你可以将负常量指定为`mov`指令的操作数：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To handle `var1` `= –``var1`, use this single assembly language statement:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理`var1` `= –``var1`，请使用以下单条汇编语言语句：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If two different variables are involved, use the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果涉及两个不同的变量，请使用以下方式：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 6.2.3 Complex Expressions
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 复杂表达式
- en: A *complex* *expression* is any arithmetic expression involving more than two
    terms and one operator. Such expressions are commonly found in programs written
    in a high-level language. Complex expressions may include parentheses to override
    operator precedence, function calls, array accesses, and so on. This section outlines
    the rules for converting such expressions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*复杂*的*表达式*是指包含超过两个项和一个运算符的任何算术表达式。这种表达式通常出现在用高级语言编写的程序中。复杂的表达式可能包括括号，用以覆盖运算符优先级、函数调用、数组访问等等。本节概述了转换此类表达式的规则。
- en: 'A complex expression that is easy to convert to assembly language is one that
    involves three terms and two operators. For example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容易转换为汇编语言的复杂表达式是包含三个项和两个运算符的表达式。例如：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Clearly the straightforward assembly language conversion of this statement
    requires two `sub` instructions. However, even with an expression as simple as
    this, the conversion is not trivial. There are actually *two ways* to convert
    the preceding statement into assembly language:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个语句的直接汇编语言转换需要两条`sub`指令。然而，即使是像这样的简单表达式，转换也并非微不足道。实际上，有*两种方式*可以将前面的语句转换为汇编语言：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: and
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second conversion, because it is shorter, looks better. However, it produces
    an incorrect result (assuming C-like semantics for the original statement). Associativity
    is the problem. The second sequence in the preceding example computes `w = w –
    (y – z)`, which is not the same as `w = (w – y) – z`. How we place the parentheses
    around the subexpressions can affect the result. Note that if you are interested
    in a shorter form, you can use the following sequence:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种转换，因为较短，显得更好。然而，它会产生一个不正确的结果（假设原语句具有类似 C 语言的语义）。结合性是问题所在。前面示例中的第二种序列计算了`w
    = w – (y – z)`，这与`w = (w – y) – z`并不相同。我们如何将括号放在子表达式周围，会影响结果。请注意，如果你对更简洁的形式感兴趣，可以使用以下序列：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This computes `w = w – (y + z)`, equivalent to `w = (w – y) – z`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这计算了`w = w – (y + z)`，等价于`w = (w – y) – z`。
- en: '*Precedence* is another issue. Consider this expression:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先级*是另一个问题。考虑这个表达式：'
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once again, we can evaluate this expression in two ways:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以用两种方式评估这个表达式：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: or
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By now, you’re probably thinking that this explanation is crazy. Everyone knows
    the correct way to evaluate these expressions is by the former form. However,
    you’d be wrong. The APL programming language, for example, evaluates expressions
    solely from right to left and does not give one operator precedence over another.
    Which way is “correct” depends entirely on how you define precedence in your arithmetic
    system.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能认为这个解释很疯狂。大家都知道评估这些表达式的正确方式是前一种形式。然而，你错了。例如，APL 编程语言仅按从右到左的顺序评估表达式，并且不对运算符的优先级进行区分。哪种方式是“正确的”，完全取决于你如何定义算术系统中的优先级。
- en: 'Consider this expression:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个表达式：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If `op1` takes precedence over `op2`, then this evaluates to `(x` `op1` `y)`
    `op2` `z`*.* Otherwise, if `op2` takes precedence over `op1`, this evaluates to
    `x` `op1` `(y` `op2` `z)`. Depending on the operators and operands involved, these
    two computations could produce different results.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op1`的优先级高于`op2`，那么此表达式会计算为`(x` `op1` `y)` `op2` `z`*。*否则，如果`op2`的优先级高于`op1`，则该表达式计算为`x`
    `op1` `(y` `op2` `z)`。根据所涉及的运算符和操作数，这两种计算可能会产生不同的结果。
- en: Most high-level languages use a fixed set of precedence rules to describe the
    order of evaluation in an expression involving two or more different operators.
    Such programming languages usually compute multiplication and division before
    addition and subtraction. Those that support exponentiation (for example, FORTRAN
    and BASIC) usually compute that before multiplication and division. These rules
    are intuitive because almost everyone learns them before high school.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言使用一组固定的优先级规则来描述在涉及两个或多个不同运算符的表达式中评估的顺序。此类编程语言通常先进行乘法和除法运算，再进行加法和减法运算。那些支持指数运算的语言（例如
    FORTRAN 和 BASIC）通常会在乘法和除法之前计算指数。这些规则是直观的，因为几乎每个人在上高中之前都会学习它们。
- en: 'When converting expressions into assembly language, you must be sure to compute
    the subexpression with the highest precedence first. The following example demonstrates
    this technique:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在将表达式转换为汇编语言时，必须确保首先计算具有最高优先级的子表达式。以下示例演示了这一技巧：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If two operators appearing within an expression have the same precedence, you
    determine the order of evaluation by using associativity rules. Most operators
    are *left-associative*, meaning they evaluate from left to right. Addition, subtraction,
    multiplication, and division are all left-associative. A *right-associative* operator
    evaluates from right to left. The exponentiation operator in FORTRAN is a good
    example of a right-associative operator:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式中的两个操作符具有相同的优先级，你可以通过使用结合性规则来确定评估顺序。大多数操作符是*左结合*的，意味着它们从左到右进行评估。加法、减法、乘法和除法都是左结合的。*右结合*操作符则是从右到左进行评估。FORTRAN
    中的指数运算符就是一个很好的右结合操作符的例子：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: is equal to
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 等于
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: not
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The precedence and associativity rules determine the order of evaluation. Indirectly,
    these rules tell you where to place parentheses in an expression to determine
    the order of evaluation. Of course, you can always use parentheses to override
    the default precedence and associativity. However, the ultimate point is that
    your assembly code must complete certain operations before others to correctly
    compute the value of a given expression. The following examples demonstrate this
    principle:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级和结合性规则决定了评估的顺序。间接地，这些规则告诉你在表达式中放置括号的位置，以确定评估的顺序。当然，你总是可以使用括号来覆盖默认的优先级和结合性。然而，最终的要点是，你的汇编代码必须在完成某些操作之前完成其他操作，以正确计算给定表达式的值。以下示例演示了这一原理：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The associativity rule has one exception: if an expression involves multiplication
    and division, it is generally better to perform the multiplication first. For
    example, given an expression of the form'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 结合性规则有一个例外：如果一个表达式涉及乘法和除法，通常最好先执行乘法。例如，给定一个类似于以下形式的表达式：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: it is usually better to compute `x * z` and then divide the result by `y` rather
    than divide `x` by `y` and multiply the quotient by `z`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，最好先计算`x * z`，然后将结果除以`y`，而不是先将`x`除以`y`，然后将商乘以`z`。
- en: This approach is better for two reasons. First, remember that the `imul` instruction
    always produces a 64-bit result (assuming 32-bit operands). By doing the multiplication
    first, you automatically *sign-extend* the product into the EDX register so you
    do not have to sign-extend EAX prior to the division.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个好处。首先，记住 `imul` 指令总是会产生 64 位结果（假设是 32 位操作数）。通过先执行乘法，你会自动将乘积*符号扩展*到 EDX
    寄存器中，这样就不必在除法前对 EAX 进行符号扩展。
- en: A second reason for doing the multiplication first is to increase the accuracy
    of the computation. Remember, (integer) division often produces an inexact result.
    For example, if you compute 5 / 2, you will get the value 2, not 2.5\. Computing
    (5 / 2) × 3 produces 6\. However, if you compute (5 × 3) / 2, you get the value
    7, which is a little closer to the real quotient (7.5). Therefore, if you encounter
    an expression of the form
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个先进行乘法的理由是为了提高计算的准确性。记住，（整数）除法通常会产生不精确的结果。例如，如果你计算 5 / 2，你将得到值 2，而不是 2.5。计算（5
    / 2）× 3 得到 6。然而，如果你计算（5 × 3）/ 2，你得到的值是 7，这比真实商值（7.5）要接近一些。因此，如果你遇到类似以下形式的表达式：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'you can usually convert it to the following assembly code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以将其转换为以下汇编代码：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the algorithm you’re encoding depends on the truncation effect of the division
    operation, you cannot use this trick to improve the algorithm. Moral of the story:
    always make sure you fully understand any expression you are converting to assembly
    language. If the semantics dictate that you must perform the division first, then
    do so.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编码的算法依赖于除法操作的截断效应，那么你无法使用这个技巧来改进算法。故事的寓意是：始终确保你完全理解任何你正在转换为汇编语言的表达式。如果语义要求你必须先执行除法操作，那么就这么做。
- en: 'Consider the following statement:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下语句：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Because subtraction is not commutative, you cannot compute `y * x` and then
    subtract `x` from this result. Rather than use a straightforward multiplication-and-addition
    sequence, you’ll have to load `x` into a register, multiply ``y and `x` (leaving
    their product in a different register), and then subtract this product from `x`.
    For example:``
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于减法不是可交换的，你不能先计算`y * x`，然后从结果中减去`x`。你不能使用直接的乘法和加法序列，而是必须将`x`加载到一个寄存器中，先计算`y`和`x`的乘积（将它们的乘积保存在另一个寄存器中），然后从`x`中减去这个乘积。例如：``
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
