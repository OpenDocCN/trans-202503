- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PERFORMANCE
    AND EFFICIENCY</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">性能与效率</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Few programmers set out to write inefficient code, but we don’t always have
    time to fine-tune an algorithm to extract the maximum possible performance. Nevertheless,
    it’s important to understand how some coding practices can hurt performance and
    how we can employ alternative approaches to make our code more efficient. In this
    chapter, we’ll put some common techniques and practices under the microscope to
    examine their performance and compare their characteristics with potential alternatives.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有程序员故意编写低效的代码，但我们并不总是有时间对算法进行精细调整，以提取最大可能的性能。然而，了解某些编码实践如何影响性能，以及如何采取替代方法使代码更高效，依然非常重要。在本章中，我们将仔细分析一些常见的技术和实践，检查它们的性能，并将其特点与潜在的替代方案进行比较。
- en: 'We’ll explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下内容：
- en: Where default code behavior may not be optimally efficient
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪些情况下，默认的代码行为可能不是最优的
- en: Why some common performance concerns are misconceptions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么一些常见的性能问题其实是误解
- en: How to evaluate code performance and target its bottlenecks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何评估代码性能并找出瓶颈
- en: When making small optimizations may be worth the trouble
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行小幅优化时，可能值得付出一定的努力
- en: <samp class="SANS_Futura_Std_Bold_B_11">Measuring and Optimizing Performance</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">性能测量与优化</samp>
- en: 'The term *optimization* is often used to mean altering code to make a program
    run more quickly, but we might want to optimize for many other outcomes: lower
    memory use, higher numeric calculation precision, increased data throughput, and
    ease of deployment, to name just a few. Sometimes we trade raw performance for
    code readability or even convenience. We may decide that making our code easy
    to test is more important than making the program run at maximum speed. However,
    optimizing for one area can often adversely affect one or more other areas of
    an application, so we must make sure that the potential benefits are worth the
    cost and that our efforts aren’t actually leading to *pessimization*: writing
    or using code that prevents a program from running efficiently.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化* 这个术语通常指的是修改代码，使程序运行得更快，但我们可能还希望优化其他多种结果：更低的内存使用、更高的数值计算精度、更高的数据吞吐量以及更便捷的部署等。有时候，我们为了代码的可读性或便利性而牺牲纯粹的性能。我们可能会决定，让我们的代码更易于测试比让程序以最大速度运行更为重要。然而，优化某一领域往往会对应用程序的其他领域产生负面影响，因此我们必须确保潜在的收益值得成本，避免我们的努力实际上导致了*恶化*：编写或使用阻碍程序高效运行的代码。'
- en: The easiest and most direct method for optimizing a program’s performance is
    to enable optimizations in the build configuration. A release build configuration
    has optimizations enabled by default. When building the debug configuration, the
    compiler generates code that closely matches the source code’s structure and logic,
    which allows for setting diagnostic features like breakpoints, step-by-step debugging,
    and inspecting variables. The optimizations enabled in a release build may change
    the code’s logical structure in subtle ways, making debugging much more difficult
    but potentially improving the code’s efficiency or reducing the program’s size.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 优化程序性能的最简单直接方法是启用构建配置中的优化。发布版本构建配置默认启用优化。而在构建调试配置时，编译器生成的代码与源代码的结构和逻辑非常接近，这样可以设置诊断功能，如断点、逐步调试和检查变量。发布版本中启用的优化可能会以微妙的方式改变代码的逻辑结构，虽然会使调试变得更加困难，但有可能提高代码效率或减小程序体积。
- en: The C# compiler itself performs very little in the way of optimizing the code,
    leaving the majority of that work to the JIT compiler.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器本身几乎不执行代码优化，而是将大部分工作留给 JIT 编译器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The JIT Compiler</samp>
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">JIT 编译器</samp>
- en: The C# compiler translates our C# code into CIL format, which in turn is translated
    to native machine code either ahead of time (AOT) by a tool such as the CrossGen
    utility or at run time by the JIT compiler, the latter being the default. In normal
    operation, the JIT compiler translates the program piecemeal; rather than producing
    the machine code for the entire program all at once before running it (as AOT
    tools do), the JIT compiler translates portions of the CIL to native format *just
    in time*. A portion would generally be a method, but in principle it could be
    part of a method, such as a loop or <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    block.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器将我们的 C# 代码转换为 CIL 格式，CIL 再通过像 CrossGen 工具这样的工具提前转换为本机机器代码（AOT），或者在运行时通过
    JIT 编译器转换，后者是默认方式。在正常操作中，JIT 编译器逐块翻译程序；它不会像 AOT 工具那样在运行程序之前一次性生成整个程序的机器代码，而是*及时*地将
    CIL 的部分内容翻译为本机格式。一个部分通常是一个方法，但原则上它也可以是方法的一部分，比如一个循环或 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    块。
- en: Because JIT compiler optimizations occur during a program’s execution, they’ll
    vary among platforms and run-time environments. While AOT compilation may improve
    a program’s startup time, the JIT compiler can take advantage of optimizations
    specific to a particular CPU, register set, operating system, and program state
    to produce efficient code on the fly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JIT 编译器的优化发生在程序执行期间，它们会因平台和运行时环境而异。虽然 AOT 编译可能改善程序的启动时间，但 JIT 编译器可以利用特定 CPU、寄存器集、操作系统和程序状态的优化，动态生成高效的代码。
- en: One common optimization is to inline the code within a method, avoiding the
    overhead of a method call. The JIT compiler may also be able to replace some method
    calls with native intrinsic CPU instructions, further improving performance. Once
    a block has been translated by the JIT compiler, its native code remains in memory,
    so it usually doesn’t need to be recompiled if the program runs it more than once.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的优化方法是将代码内联到方法中，避免方法调用的开销。JIT 编译器也可能能够用本机的内在 CPU 指令替换某些方法调用，从而进一步提高性能。一旦一个代码块被
    JIT 编译器翻译，它的本机代码就会保留在内存中，因此如果程序多次运行它，通常不需要重新编译。
- en: In a debug build, the JIT compiler is much less aggressive in the optimizations
    it applies so that normal debugging operations are supported. When we’re trying
    to assess our code’s performance, it usually makes the most sense to base that
    assessment on a release build so it will account for all of the optimizations
    performed by the JIT compiler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试版本中，JIT 编译器对其应用的优化要保守得多，以支持正常的调试操作。当我们尝试评估代码性能时，通常最合理的做法是基于发布版本进行评估，这样可以考虑到
    JIT 编译器所做的所有优化。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performance Benchmarks</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">性能基准</samp>
- en: When our code runs more slowly than we expect, simply observing the running
    application may give us some insights, but measuring performance precisely will
    allow us to target our optimization efforts more effectively.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码运行速度比预期慢时，仅仅观察正在运行的应用程序可能会给我们一些启示，但精确测量性能将使我们能够更有效地定位优化工作。
- en: Recording the time it takes for code to run—whether it’s a complete end-to-end
    run or just a portion of a program—is known as *benchmarking*. More generally,
    a *benchmark* is a standard against which something is measured. By timing our
    code, we establish a benchmark with which to compare a new version, to determine
    whether our changes have made the code faster or slower, or have had no discernible
    effect.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 记录代码运行所需时间——无论是完整的端到端运行，还是程序的一部分——被称为*基准测试*。更一般来说，*基准*是用来衡量某物的标准。通过计时我们的代码，我们建立了一个基准，可以用来与新版本进行比较，从而判断我们的修改是让代码更快、更慢，还是没有明显效果。
- en: Many unit-testing frameworks report how long it takes for the tests to run,
    and even the elapsed time taken for individual tests. Keeping an eye on these
    numbers is certainly worthwhile because a sudden increase can indicate that an
    efficiency problem has been introduced somewhere. This approach can be particularly
    valuable in an automated *continuous integration (CI)* service, in which changes
    from multiple contributors are automatically integrated into a program; we can
    set up a CI service to alert us if the timing of the unit tests begins to change.
    If a particular test that usually runs in a few hundred milliseconds starts taking
    considerably longer, we can focus on the piece of code being tested to see if
    further investigation is warranted.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多单元测试框架会报告测试运行所需的时间，甚至单个测试的耗时。关注这些数字是非常有价值的，因为突如其来的增加可能表明某处引入了效率问题。这种方法在自动化的*持续集成
    (CI)* 服务中尤为重要，其中来自多个贡献者的更改会自动集成到程序中；我们可以设置 CI 服务，当单元测试的时间开始发生变化时给我们发出警报。如果一个通常在几百毫秒内完成的测试开始耗时更长，我们可以集中注意力查看正在测试的代码，看看是否需要进一步调查。
- en: 'A more fine-grained and precise approach to measuring how fast a section of
    code runs is to instrument the code itself. The basic technique is simple in principle:
    just before running the code to be measured, we create a timer to record the elapsed
    time, and when the code has finished running, we record the timer’s measurement.
    [Listing 8-1](#list8-1) shows a simple but naïve benchmark using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</samp>
    class from the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Diagnostics</samp>
    namespace.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 更加细粒度且精确的方法是对代码段本身进行计时。基本原理非常简单：在运行要测量的代码之前，我们创建一个计时器来记录经过的时间，当代码执行完毕时，我们记录计时器的测量值。[清单
    8-1](#list8-1)展示了一个简单但天真的基准测试，使用了来自<samp class="SANS_TheSansMonoCd_W5Regular_11">System.Diagnostics</samp>命名空间的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</sup>类。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: A simple benchmarking
    approach</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-1：一种简单的基准测试方法</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</samp> class is
    a lightweight high-resolution timer that records elapsed time with very high precision.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch.Frequency</samp> value
    is the number of ticks per second, so by multiplying the count of elapsed ticks
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">1000.0</samp> before dividing
    by the frequency, we can report the time taken with millisecond granularity. This
    technique simply measures the elapsed time since the clock was started, so it
    can’t, for instance, determine whether the code being measured is actually running
    for all that time. The clock continues to tick even if the code is interrupted
    (for example, by switching to a different thread).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</samp>类是一个轻量级的高分辨率计时器，能够以极高的精度记录经过的时间。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch.Frequency</samp>值表示每秒的计时滴答数，因此通过将经过的滴答数乘以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1000.0</samp>，再除以频率，我们可以以毫秒为单位报告所花费的时间。这种技术仅仅是测量时钟开始后经过的时间，因此它无法确定所测量的代码是否在那段时间内一直在运行。例如，如果代码被中断（比如切换到其他线程），时钟依然会继续计时。
- en: Instrumenting code with a timer and recording it in the log or another audit
    trail can be a useful way to measure code running in a live system. However, measuring
    and reporting the performance takes time too, so we must be sure to take the measurements
    at a relatively high level. For instance, measuring and reporting how long code
    takes to respond to an <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP</samp>
    request or call a remote procedure probably wouldn’t significantly impact the
    application’s performance. On the other hand, using this technique in a tight
    loop might well introduce more overhead than the cost of the loop itself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中加入计时器并将其记录到日志或其他审计轨迹中，可以有效地测量在实时系统中运行的代码性能。然而，测量和报告性能本身也需要时间，因此我们必须确保在相对较高的层次进行测量。例如，测量和报告代码响应一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HTTP</samp> 请求或调用远程过程的时间，可能不会显著影响应用程序的性能。另一方面，在紧密循环中使用这种技术，可能会带来比循环本身更大的开销。
- en: Benchmarking is also a useful way to explore performance in a test environment,
    perhaps to compare alternative approaches to solving a specific problem. The technique
    in [Listing 8-1](#list8-1) is naïve in that it measures the code only once. A
    more accurate approach for measuring performance would run the code many times
    and report the average time. We could write our own framework based on [Listing
    8-1](#list8-1), although a few freely available libraries for C# will do the heavy
    lifting for us, producing a report of the recorded performance along with other
    useful statistics, such as margin for error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试也是在测试环境中探索性能的一种有用方式，可能是用来比较解决特定问题的替代方法。[清单 8-1](#list8-1)中的技术是幼稚的，因为它只对代码进行了一次测量。更精确的性能测量方法是多次运行代码，并报告平均时间。我们可以基于[清单
    8-1](#list8-1)编写自己的框架，尽管一些免费的 C# 库可以帮助我们完成繁重的工作，生成包含记录的性能和其他有用统计数据（如误差范围）的报告。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Profiler</samp>
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分析器</samp>
- en: Benchmarking will tell us overall how quickly a piece of code runs, but to determine
    what the code does in detail, we need a *profiler*. Using a benchmarking tool
    in combination with profiling will give us the most accurate measurements. Among
    the several kinds of profiler available, the two most common are performance profilers
    and memory profilers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试将告诉我们代码运行的整体速度，但要确定代码的具体操作，我们需要一个*分析器*。将基准测试工具与分析结合使用将提供最准确的测量。在几种可用的分析器中，最常见的两种是性能分析器和内存分析器。
- en: A *memory profiler* will show us where our program allocates memory, how much
    is being used, and when it’s garbage collected. If we need to find out which parts
    of our code are using the most CPU time or which methods are being called most
    often, a *performance profiler* will give us precise measurements, allowing us
    to target specific hot spots in the code and optimize them if necessary. While
    optimizing memory usage is important, in this chapter we’ll focus on discovering
    bottlenecks in our code by using a performance profiler.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存分析器*将显示我们的程序在哪里分配内存，使用了多少内存，以及何时进行垃圾回收。如果我们需要找出哪些部分的代码使用了最多的 CPU 时间，或者哪些方法被调用得最频繁，*性能分析器*将提供精确的测量，帮助我们定位代码中的热点，并在必要时进行优化。虽然优化内存使用很重要，但在本章中，我们将重点通过使用性能分析器来发现代码中的瓶颈。'
- en: 'Performance profilers usually operate on a release build of a program and so
    take into account any optimizations applied by the compiler and JIT compiler.
    Measuring a debug build for its performance usually makes little sense, although
    sometimes it can be useful: comparing the results of profiling both a debug build
    and a release build of the same code, for instance, can provide insights into
    some of the optimizations the JIT compiler performs.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器通常在程序的发布版本上运行，因此会考虑编译器和 JIT 编译器所做的任何优化。测量调试版本的性能通常意义不大，尽管有时它可能会有用：例如，比较同一代码的调试版本和发布版本的分析结果，可以为我们提供
    JIT 编译器执行的一些优化的见解。
- en: While performance measurements can give us an idea of where bottlenecks may
    be slowing our code, it’s vital to keep in mind that a program’s performance is
    affected by many factors other than the code, including the version of the CLR
    or the version of the software development kit (SDK) we use. Even running the
    same program twice on the same machine can produce a different result, depending
    on how cache memory is allocated or how instructions are pipelined by the CPU’s
    scheduler. The JIT compiler may also apply different optimizations for each run,
    possibly further affecting the result. We must therefore be cautious of attaching
    too much importance to the absolute times in a profiler’s report, and instead
    look for trends or obvious anomalies, such as results differing by an order of
    magnitude or more.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管性能测量可以让我们了解瓶颈可能会在哪些地方拖慢代码，但必须牢记，程序的性能受多种因素的影响，除了代码外，还包括我们使用的 CLR 版本或软件开发工具包（SDK）的版本。即使在同一台机器上运行相同的程序两次，也可能产生不同的结果，这取决于缓存内存的分配方式或
    CPU 调度器如何流水线处理指令。JIT 编译器还可能为每次运行应用不同的优化，这可能进一步影响结果。因此，我们必须小心不要过于看重性能分析报告中的绝对时间，而是要寻找趋势或明显的异常，例如结果相差一个数量级或更多。
- en: We’ll use a performance profiler to selectively measure specific aspects of
    code and analyze the profiler’s results. Remember that the specific results shown
    in this chapter are particular to the machine on which the test was performed,
    but we’ll try multiple approaches, measuring each attempt so that we can identify
    some common, repeatable patterns in the results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用性能分析器选择性地测量代码的特定方面，并分析分析器的结果。请记住，本章中显示的具体结果是针对执行测试的机器特定的，但我们会尝试多种方法，衡量每次尝试的结果，以便我们能够识别出结果中的一些常见、可重复的模式。
- en: To demonstrate how this works, next we’ll examine how simply changing a field’s
    type can dramatically affect the performance of code that relies on using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，接下来我们将研究如何仅仅改变字段类型就能显著影响依赖于使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    的代码性能。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Measuring Basic Performance with Equals</samp>
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 Equals 测量基本性能</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is an
    often neglected aspect of code optimization in C#. This method is a good candidate
    for performance measurement because it’s always available (since every type inherits
    it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class)
    but also customizable (as a virtual member of <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>).
    In this section, we measure the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for a simple value type so that we can compare the profiler’s results with the
    results from overriding <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    with our own implementation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法是 C# 中常被忽视的代码优化方面之一。该方法是性能测量的良好候选，因为它始终可用（因为每种类型都从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 基类继承它），同时也可以自定义（作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 的虚拟成员）。在本节中，我们将测量一个简单值类型的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 的默认行为，以便将分析器的结果与通过我们自己的实现重写
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 后的结果进行比较。
- en: Struct types inherit a value-based equality comparison from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    class, overriding the default implementation defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    universal base class. This ensures that when we copy an instance of a struct,
    the copy compares equal to the original by comparing the fields of each instance.
    We might be tempted to rely on this behavior, rather than implementing our own
    override of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    because it keeps our type definitions shorter and simpler, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct in [Listing 8-2](#list8-2).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体类型继承自 <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> 类的基于值的相等性比较，并覆盖了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 通用基类中定义的默认实现。这确保了当我们复制结构体的实例时，复制品通过比较每个实例的字段与原始实例相等。我们可能会倾向于依赖这种行为，而不是实现我们自己的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法的重写，因为它使我们的类型定义更简短、更简单，就像
    [Listing 8-2](#list8-2) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    结构体一样。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Defining a simple
    struct type</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: 定义一个简单的结构体类型</samp>'
- en: Two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    that have the same property values will compare equal. Furthermore, like all structs,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> inherits a value-based
    implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>, ensuring
    that two equal <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values
    always produce the same hash code. Additionally, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is an immutable type, making it suitable for use as a key in a data structure
    that relies on hash codes for efficiency. In [Listing 8-3](#list8-3), we create
    many random <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances
    and then add them to a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    in a simple test that we can use to measure how well the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct performs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 两个属性值相同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例会被认为相等。此外，像所有结构体一样，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 从 <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    继承了基于值的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 实现，确保两个相等的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 值始终生成相同的哈希码。此外，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 是不可变类型，适合用作依赖哈希码效率的数据结构的键。在
    [列表 8-3](#list8-3) 中，我们创建了许多随机的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    实例，然后将它们添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> 中，进行简单的测试，用以衡量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 结构体的性能。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: Generating a hashing
    collection</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-3：生成哈希集合</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp> class is the
    Standard Library’s *pseudorandom number generator*, the name for an algorithm
    that uses a deterministic process to produce a sequence of numbers that *appear*
    random. Notably, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp>
    class will produce the same sequence if it’s initialized with the same *seed*—that
    is, the value used to calculate the first number of the sequence.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp> 类是标准库的 *伪随机数生成器*，它是一个算法的名称，利用确定性过程生成一系列看似随机的数字。值得注意的是，如果使用相同的
    *种子* 初始化，<samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp> 类会生成相同的数字序列——即用于计算序列第一个数字的值。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Different versions of .NET (or .NET Core) may produce different sequences
    for a given seed.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*不同版本的 .NET（或 .NET Core）可能会为给定的种子生成不同的序列。*'
- en: In [Listing 8-3](#list8-3), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    as the seed and create new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances using the numbers generated by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Next</samp>
    on the random-number generator. Since we use the same seed each time, we’ll get
    the same sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances each time the code runs. This characteristic is most often considered
    a downside of pseudorandom numbers, but it suits our purpose perfectly because
    we can run this code multiple times, and the same values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances will be generated for each run. In turn, comparing the performance of
    different runs is fair in that each run will be comparing identical sequences
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values. We’re using
    a randomly generated sequence to ensure that the final <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    contains a reasonably realistic population of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8-3](#list8-3) 中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    作为种子，并使用通过调用随机数生成器的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Next</samp>
    方法生成的数字来创建新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例。由于我们每次都使用相同的种子，因此每次运行代码时都会生成相同的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例序列。这一特性通常被认为是伪随机数的缺点，但它完全符合我们的需求，因为我们可以多次运行此代码，并且每次运行都会生成相同的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例值。因此，在比较不同运行的性能时是公平的，因为每次运行都将比较相同的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 值序列。我们使用随机生成的序列来确保最终的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> 包含一个合理真实的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    值集合。
- en: In [Listing 8-3](#list8-3), we create each <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance by masking off the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    values from each random number. The profiler output in [Table 8-1](#tab8-1) shows
    the performance of the hash table’s constructor. For this test, we’re simply measuring
    elapsed time, also called *CPU sampling*, for each method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 8-3](#list8-3)中，我们通过从每个随机数中屏蔽掉<code>Red</code>、<code>Green</code>和<code>Blue</code>值来创建每个<code>Color</code>实例。[表
    8-1](#tab8-1)中的性能分析器输出显示了哈希表构造函数的性能。对于这个测试，我们只是简单地测量每个方法的经过时间，也称为*CPU采样*。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Profile
    Report of Creating the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-1：</samp> <samp class="SANS_Futura_Std_Book_11">创建</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> <samp class="SANS_Futura_Std_Book_11">的性能报告</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% HashSet''1..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1..ctor
    (IEnumerable, IEqualityComparer)</samp> |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% HashSet''1..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1..ctor
    (IEnumerable, IEqualityComparer)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% UnionWith</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.UnionWith
    (IEnumerable)</samp> |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% UnionWith</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.UnionWith
    (IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.AddIfNot
    Present(T, out Int32)</samp> |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.AddIfNot
    Present(T, out Int32)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">36.5% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">21</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp>
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">36.5% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">21</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">14.0% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">7.9</samp> |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">14.0% [垃圾回收]</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">7.9</samp> |  |'
- en: We’re focusing on the creation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    and ignoring everything else, including the random-number generation and creation
    of individual <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> objects.
    Different profilers represent their reports differently, but the information presented
    is generally similar.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于<code>HashSet</code>的创建，并忽略其他所有内容，包括随机数生成和单个<code>Color</code>对象的创建。不同的性能分析器以不同的方式展示报告，但呈现的信息通常是相似的。
- en: The indentation in the first column of this report shows the call stack being
    measured. The <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> constructor
    on the first line calls a method named <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionWith</samp>,
    which in turn calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>.
    This last method eventually calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. The leftmost value in the output shows the time spent by that method as
    a percentage of the test’s total time. In our test, creating the initial sequence
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values takes up
    the remainder of the time but isn’t really relevant to testing <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    The next field is the simple name of the method, followed by the absolute time
    in milliseconds spent in that method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 报告第一列的缩进显示了正在测量的调用栈。第一行中的<samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>构造函数调用了一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UnionWith</samp>的方法，该方法又调用了<samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>。最后这个方法最终调用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法。输出中的最左边值显示了该方法所花费时间占测试总时间的百分比。在我们的测试中，创建初始的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>值序列占用了剩余的时间，但与测试<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的方法并不直接相关。接下来的字段是方法的简单名称，后面跟着该方法所用的绝对时间（以毫秒为单位）。
- en: Finally, the fully qualified name of the method indicates which specific method
    is being reported. Since our simple <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct doesn’t provide its own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    the output shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    is used to add unique keys to the hash table.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，方法的完全限定名表明了具体报告的是哪个方法。由于我们的简单<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>结构体没有提供自己的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>实现，因此输出显示使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>来为哈希表添加唯一键。
- en: As noted earlier, the actual times in milliseconds reported here could change
    based on a combination of many factors, so they shouldn’t be taken literally.
    However, they establish a baseline we can use to compare the results of other
    tests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，报告的实际毫秒数可能会基于多个因素的组合而有所变化，因此不应字面理解。然而，它们为我们提供了一个基准，可以用来比较其他测试的结果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hidden Costs of Simplicity</samp>
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">简化的隐藏成本</samp>
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type uses three
    values for the RGB components. Although they’re being stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    properties, each one 4 bytes wide, we use only 1 byte for each value by masking
    off the lowest 8 bits of each argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    constructor. We might infer that we can save on storage space by storing the properties
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> fields rather than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. [Listing 8-4](#list8-4)
    shows the changed <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类型使用三个值表示RGB组件。虽然它们被存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>属性中，每个属性占4个字节，但我们通过将每个参数的最低8位掩码掉，使用了每个值仅占1个字节的方式来存储。我们可能会推测，通过将属性存储为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>字段，而不是<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，可以节省存储空间。[示例
    8-4](#list8-4)显示了修改后的<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>结构体。
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: Storing byte fields
    for color components</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 8-4：存储颜色组件的字节字段</samp>
- en: 'We still allow <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> arguments
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> constructor
    so that our users won’t have to explicitly cast the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    when creating <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values.
    Casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> values explicitly
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> has the same effect
    as the masking operations we used in [Listing 8-3](#list8-3): the value is truncated
    to just the lowest 8 bits. If we use this version of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    in the test to produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    from [Listing 8-3](#list8-3), the results are quite different. [Table 8-2](#tab8-2)
    shows just the call tree for <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然允许<sup class="SANS_TheSansMonoCd_W5Regular_11">int</sup>类型的参数传递给<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>构造函数，以确保用户在创建<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>值时无需显式地将参数转换为<sup class="SANS_TheSansMonoCd_W5Regular_11">byte</sup>类型。将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">int</sup>值显式转换为<sup class="SANS_TheSansMonoCd_W5Regular_11">byte</sup>与我们在[清单8-3](#list8-3)中使用的掩码操作效果相同：值会被截断，只保留最低的8位。如果我们在测试中使用这种版本的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>来生成一个来自[清单8-3](#list8-3)的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</sup>，结果会大不相同。[表8-2](#tab8-2)仅显示了<sup
    class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</sup>的调用树。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-2:</samp> <samp class="SANS_Futura_Std_Book_11">Profile
    Report of Adding Objects with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    <samp class="SANS_Futura_Std_Book_11">Fields to the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表8-2：</samp> <samp class="SANS_Futura_Std_Book_11">使用</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> <samp class="SANS_Futura_Std_Book_11">字段将对象添加到</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>的性能报告
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">99.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">7,494</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.Collections.Generic.HashSet`1
    .AddIfNotPresent(T, out Int32)</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">99.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">7,494</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.Collections.Generic.HashSet`1
    .AddIfNotPresent(T, out Int32)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">39.6% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2,967</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType.Equals(Object)</samp>
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">39.6% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2,967</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType.Equals(Object)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.66% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">650</samp> |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.66% [垃圾回收]</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">650</samp> |  |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.16% [Thread suspended]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.16% [线程挂起]</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> |  |'
- en: We see a dramatic change in the execution profile of the code, with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp> method taking well
    over seven full seconds to complete. Comparing this report to [Table 8-1](#tab8-1),
    we can see clearly that the main reason for the extra time is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method inherited by <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> base class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到代码的执行情况发生了显著变化，<samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>方法完成需要超过七秒钟。将此报告与[表8-1](#tab8-1)进行比较，我们可以清楚地看到额外时间的主要原因是<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>方法，该方法由<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>类从<sup
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</sup>基类继承。
- en: 'In some instances, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    can perform a *very* fast bitwise comparison, but with several caveats: this comparison
    can’t be used if any field is a reference, a floating-point number, or a type
    that itself overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Two different reference values could refer to objects of a type with its own <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, and a bitwise comparison
    would compare them as not equal, even if <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    would return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. For the
    same reason, any value type with its own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method could use that method to compare some values with different bit patterns
    as equal. Two floating-point numbers with matching bit patterns aren’t necessarily
    equal; in particular, if both values are <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>,
    they shouldn’t compare equal.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>可以执行*非常*快速的按位比较，但有几个注意事项：如果任何字段是引用类型、浮点数，或者是重写了<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>的方法类型，那么这个比较就不能使用。两个不同的引用值可能指向具有自己<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>方法的对象，按位比较会将它们视为不相等，即使<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>会返回<sup class="SANS_TheSansMonoCd_W5Regular_11">true</sup>。出于同样的原因，任何具有自己<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>方法的值类型也可能会用该方法将具有不同位模式的值视为相等。两个具有匹配位模式的浮点数不一定相等；特别是如果两个值都是<sup
    class="SANS_TheSansMonoCd_W5Regular_11">NaN</sup>，它们不应视为相等。
- en: Another condition for the fast comparison to be used is that a struct must be
    *tightly packed*, meaning its fields don’t require any padding to be properly
    aligned in memory. The three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    fields in the original implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    would automatically be aligned in memory. However, using <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    instead means the fields aren’t tightly packed, so we must use another, much slower
    comparison, with the substantial performance penalty shown in [Table 8-2](#tab8-2).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用快速比较的另一个条件是，结构体必须是*紧凑打包的*，即其字段不需要额外填充就能在内存中正确对齐。在<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>原始实现中的三个<sup
    class="SANS_TheSansMonoCd_W5Regular_11">int</sup>字段会自动在内存中对齐。然而，使用<sup class="SANS_TheSansMonoCd_W5Regular_11">byte</sup>代替意味着字段不再是紧凑打包的，因此必须使用另一种速度较慢的比较，这会带来显著的性能损失，见[表
    8-2](#tab8-2)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ValueType.Equals
    Method</samp>
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ValueType.Equals
    方法</samp>
- en: When the fast bitwise comparison isn’t applicable, the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    is necessarily very general, because it must work for any struct type, regardless
    of the number of fields the struct has or their type. In addition to having fields
    of built-in primitive types, a struct can contain references to class instances
    and instances of other user-defined values, any of which may have its own custom
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> implementation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当快速的按位比较不可用时，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>中<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>的实现必然是非常通用的，因为它必须适用于任何结构体类型，无论结构体有多少个字段，或字段的类型是什么。除了拥有内建原始类型的字段，结构体还可以包含对类实例和其他用户定义值的引用，而这些值可能有自己的自定义<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>实现。
- en: The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    first must determine which fields need to be compared. It does this by using *reflection*—programmatically
    inspecting (or changing) the run-time structure of the program—to discover all
    the instance fields, which immediately comes with a quite significant run-time
    cost. Reflection isn’t usually associated with high-performance algorithms, and
    this certainly accounts for the reduction in performance caused by altering our
    struct’s <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> fields to use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> instead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> 方法的实现首先必须确定需要比较哪些字段。它通过使用
    *反射*——以编程方式检查（或修改）程序的运行时结构——来发现所有实例字段，这立即带来了相当显著的运行时开销。反射通常与高性能算法无关，这也确实解释了由于我们将结构中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 字段改为使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>，导致的性能下降。
- en: After determining the array of fields, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    obtains each field’s value. If the field value isn’t a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    is called with the value from the corresponding field in the struct being compared.
    As a result, every value type field in both structs will be boxed in order to
    perform the comparison, because using reflection to obtain the values means each
    value is accessed via an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    reference, adding further cost.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定字段数组之后，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    会获取每个字段的值。如果字段值不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 引用，则会调用其
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，并使用来自与之比较的结构中的相应字段的值。因此，两个结构中每个值类型的字段都会进行装箱以执行比较，因为使用反射获取值意味着每个值都是通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 引用来访问的，这进一步增加了成本。
- en: The root cause of our performance problem is that the change from using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> properties to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    values means that the underlying backing fields of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    are no longer tightly packed. Consequently, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    can’t use the fast bitwise comparison and instead employs reflection to discover
    the values to be compared. To address this issue, in [Listing 8-5](#list8-5) we
    override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    and provide our own implementation to compare the property values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们性能问题的根本原因是，从使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 属性改为使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> 值意味着 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    的底层字段不再紧密打包。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    无法使用快速的按位比较，而是使用反射来发现需要比较的值。为了解决这个问题，在 [Listing 8-5](#list8-5) 中，我们重写了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法，并提供了我们自己的实现来比较属性值。
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: Overriding the
    Equals method</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: 重写 Equals 方法</samp>'
- en: The report in [Table 8-3](#tab8-3) from rerunning the test shows that while
    we’ve substantially improved its speed, we still have work to do.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从重新运行测试的报告中，见 [Table 8-3](#tab8-3)，虽然我们已经大幅提高了速度，但仍然有进一步改进的空间。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-3:</samp> <samp class="SANS_Futura_Std_Book_11">How
    the Overridden</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    <samp class="SANS_Futura_Std_Book_11">Method Performs</samp>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-3:</samp> <samp class="SANS_Futura_Std_Book_11">重写的</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> <samp class="SANS_Futura_Std_Book_11">方法的性能</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2,889</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .AddIfNotPresent(T,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">out Int32)</samp>
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2,889</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .AddIfNotPresent(T,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">out Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20.4% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">588</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals(Object)</samp>
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20.4% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">588</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals(Object)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.15% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">236</samp> |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.15% [垃圾回收]</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">236</samp> |  |'
- en: Notice that our override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is consuming a much smaller percentage of the overall time in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>,
    although this approach is still much slower than the test using our original version
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that had <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    properties.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们重写的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法消耗的时间占总时间的比例远小于<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp></sup>方法的时间，尽管这种方式仍然比我们使用原始版本的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>（该版本使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>属性）时要慢得多。
- en: This report tells us that the majority of the time was spent in the code of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp> as opposed
    to any methods called by it. To discover why, we’ll use a different kind of profiling,
    sometimes known as *instrumentation profiling*, or *tracing*, which records the
    number of times each method is called in a program. Because this requires the
    profiler to intrusively measure a running program, the time measurements are often
    much higher; however, knowing which methods are being called most often is valuable
    information. [Table 8-4](#tab8-4) shows the tracing report for <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>
    and the methods called within it, including the number of times each method was
    called.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这份报告告诉我们，大部分时间花费在了<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp></sup>方法上，而不是它所调用的其他方法。为了发现原因，我们将使用另一种类型的性能分析，有时被称为*插装分析*，或*跟踪*，它记录程序中每个方法的调用次数。因为这要求分析工具以侵入性方式测量正在运行的程序，所以时间测量通常要高得多；然而，知道哪些方法被调用得最多是非常有价值的信息。[表
    8-4](#tab8-4)展示了<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp></sup>方法及其内部调用的跟踪报告，包括每个方法的调用次数。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-4:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-4:</samp> <samp class="SANS_Futura_Std_Book_11">Equals的跟踪报告</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">调用次数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp>
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">99.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">16,681</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">99.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">16,681</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">40.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">6,724</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">312,222,485</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp> |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">40.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">6,724</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">312,222,485</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.76%</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[Garbage
    collection]</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">293</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1,593</samp> |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.76%</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[垃圾回收]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">293</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1,593</samp>
    |  |'
- en: This report has an extra column that shows the number of times each method was
    called during the program’s execution. The tracing report took significantly longer
    to run, but more importantly, it shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method being invoked a huge number of times. In fact, the number of invocations
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is suspiciously
    close to the triangular number of 25,000—the number of elements in the original
    sequence. The *triangular number* of some number *n* is the sum of the whole numbers
    from 1 to *n*. When *n* is 25,000, the triangular number is 312,512,500.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本报告有一个额外的列，显示程序执行过程中每个方法被调用的次数。跟踪报告运行时间显著较长，但更重要的是，它显示了<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法被调用了大量次。事实上，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的调用次数与25,000的三角形数字非常接近——这就是原始序列中的元素数量。某个数字*n*的*三角形数字*是从1到*n*的所有整数之和。当*n*为25,000时，三角形数字为312,512,500。
- en: While we’ve customized <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> class also uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> when adding or searching
    for a key, and our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type relies on the default <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    implementation inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>.
    Let’s look at how this relates to the number of times <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is called in our test.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们为<Color>结构定制了<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，但<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>类在添加或查找键时也会使用<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>，而我们的<Color>类型依赖于从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>继承的默认<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>实现。让我们看看这与在我们的测试中调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法的次数有何关系。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ValueType.GetHashCode
    Method</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ValueType.GetHashCode
    方法</samp>
- en: As [Chapter 5](chapter5.xhtml) explained, the elements in a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    are unique; every key in the table exists only once. A new object is added to
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> only if it doesn’t
    already exist in the table; otherwise, it’s ignored.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第5章](chapter5.xhtml)所解释，<samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>中的元素是唯一的；表中的每个键只出现一次。只有当新对象在表中不存在时，才会将其添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>中；否则，它将被忽略。
- en: When we add an item to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    in this example, the implementation uses <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    to identify existing keys with the same hash code. The fact that the hash codes
    are the same doesn’t necessarily mean any of the existing keys have the same value
    as the new item. If no existing key has the same hash code as the new item, the
    new object is added to the table. If one or more existing keys have hash codes
    that match the new item’s hash code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is used to determine whether the item should be added. Each key with the
    same hash code is compared with the new item in turn, and if no match is found,
    the new item is added to the table as a new key.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这个例子中向<samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>添加一个项目时，实施方法使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>来识别具有相同哈希码的现有键。哈希码相同并不一定意味着任何现有键的值与新项相同。如果没有现有键的哈希码与新项相同，则新对象将被添加到表中。如果一个或多个现有键的哈希码与新项的哈希码匹配，则会使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法来确定是否应该添加该项。每个与新项哈希码相同的键都会与新项逐一进行比较，如果没有找到匹配项，则将新项作为新键添加到表中。
- en: Having <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> being called
    so often in our test indicates that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type is producing
    hash codes that aren’t well distributed. When the first element is added to the
    hash table, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> isn’t
    called at all, because there’s nothing to compare with. If the second element
    has an identical hash code to the first, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is called to determine if they’re identical keys. This process will repeat for
    each subsequent element that has the same hash code as an existing key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试中经常调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，这表明我们为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 类型实现的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    方法生成的哈希码分布不均匀。当第一个元素被添加到哈希表时，根本不会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，因为没有可比较的元素。如果第二个元素的哈希码与第一个元素相同，则会调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 来确定它们是否是相同的键。如果随后的元素的哈希码与已存在的键相同，这个过程会重复进行。
- en: If all of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> objects
    in the initial sequence of 25,000 elements produce identical hash codes but have
    different values, adding the final new element will require a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for all of the existing 24,999 keys.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始序列中的 25,000 个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    对象生成相同的哈希码但值不同，那么添加最后一个新元素时，需要对所有现有的 24,999 个键调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>。
- en: In fact, the default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp>
    inherited by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct
    will likely produce many identical hash codes, regardless of whether the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances have different
    values. The reason is related to the poor performance of the implementation of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> provided by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>, and it explains why
    the number of calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is so close to the triangular number of the sequence length.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp>
    的默认实现被 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 结构体继承时，可能会生成许多相同的哈希码，而不管
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例的值是否不同。原因与 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> 提供的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    实现的性能较差有关，这也解释了为什么调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    的次数接近于序列长度的三角数。
- en: If instances of a struct can be compared using the fast bitwise comparison for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp>
    method produces hash codes based on the bit pattern of the instance in memory.
    If, on the other hand, the struct isn’t eligible for the fast bitwise comparison,
    the default <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> implementation
    considers only the first non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    instance field of the struct—the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>
    property in our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type—with
    the result that we can get a maximum of only 256 unique hash codes. We solve that
    problem by implementing our own <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    method to produce more unique hash codes, preferably so that each distinct <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value produces a unique hash
    code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个结构体的实例可以通过快速的位运算比较（使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>）进行比较，那么
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp> 方法将根据实例在内存中的位模式生成哈希码。另一方面，如果该结构体不适合进行快速的位运算比较，默认的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 实现则只考虑结构体的第一个非
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 实例字段——在我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    类型中是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp> 属性——因此最多只能生成 256
    个唯一的哈希码。我们通过实现自己的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    方法来解决这个问题，生成更多的唯一哈希码，最好是每个不同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    值生成一个唯一的哈希码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The HashCode.Combine
    Method</samp>
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">HashCode.Combine
    方法</samp>
- en: In [Listing 8-6](#list8-6), we add our own override of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct to complement
    our overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    and implement the new <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashCode.Combine</samp>
    method from the Standard Library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8-6](#list8-6) 中，我们为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    结构添加了自定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 重写方法，以补充我们重写的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，并通过使用标准库中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashCode.Combine</samp> 方法来实现新的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 方法。
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Overriding a GetHashCode
    method</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-6：重写 GetHashCode 方法</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Combine</samp> method produces
    well-distributed hash codes based on its inputs, and while we might be able to
    write our own carefully optimized replacement, doing so is far from trivial. Now
    when we run the test, we see that the combined effect of overriding both <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    reduces the number of calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method by a considerable amount, as shown in [Table 8-5](#tab8-5).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Combine</samp> 方法基于输入生成分布均匀的哈希码，尽管我们可能能够编写自己精心优化的替代方法，但这么做远非易事。现在，当我们运行测试时，发现同时重写
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    方法的综合效果大大减少了对 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法的调用次数，如
    [表 8-5](#tab8-5) 所示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-5:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for the Overridden</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-5：</samp> <samp class="SANS_Futura_Std_Book_11">重写
    GetHashCode 的跟踪报告</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">调用次数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp>
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">48.8% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">48.8% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">38.1% Combine</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.HashCode.Combine(T1, T2,
    T3)</samp> |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">38.1% Combine</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.HashCode.Combine(T1, T2,
    T3)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.42% Resize</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .Resize(Int32, Boolean)</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.42% Resize</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.Resize(Int32,
    Boolean)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.27% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">0.09</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">18</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp> |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.27% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">0.09</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">18</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp> |'
- en: Even accounting for the overhead of counting the method calls, this report shows
    a vast improvement in speed compared with our previous results and demonstrates
    the close relationship between <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>. We pay a
    high cost in efficiency if we accept the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> provided
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> rather than
    implementing those methods ourselves in our custom struct types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 即便考虑到方法调用的开销，本报告显示与我们之前的结果相比，速度有了显著提升，并且展示了<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>之间的紧密关系。如果我们接受由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>提供的默认行为，而不是在自定义结构体类型中实现这些方法，我们的效率将会付出较高的代价。
- en: If we revisit the profile of our original struct that had <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    fields but no method overrides, we can see that even though that struct could
    be packed efficiently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is still invoked much more frequently than in our latest version (see [Table
    8-6](#tab8-6)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新审视原始结构体的分析，原始结构体中有<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>字段，但没有方法重写，可以看到即使该结构体可以高效地打包，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法仍然比我们最新版本中调用得更频繁（参见[表 8-6](#tab8-6)）。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-6:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for a Packed Struct with No Overrides</samp>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-6：</samp> <samp class="SANS_Futura_Std_Book_11">无重写的打包结构体跟踪报告</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">调用次数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp>
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">85.6% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">85.6% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">30.1% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">36</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">1,219,104</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp>
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">30.1% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">36</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">1,219,104</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.54% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">8.9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>
    |  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.54% [垃圾回收]</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">8.9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>
    |  |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.42% Resize</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .Resize(Int32, Boolean)</samp> |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.42% 调整大小</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .Resize(Int32, Boolean)</samp> |'
- en: We’d certainly notice a performance problem if we were to scale up the number
    of elements being added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们增加添加到<samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>中的元素数量，肯定会注意到性能问题。
- en: Besides <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, several
    other collection types rely on hash codes for efficiency, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Lookup</samp> types. Therefore,
    it’s essential that we override both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods for
    any type that could be used as a key for hashing collections.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>，还有几种其他集合类型依赖于哈希码来提高效率，包括
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Lookup</samp>
    类型。因此，对于任何可能作为哈希集合的键使用的类型，重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 方法是至关重要的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Optimizing Equality</samp>
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">优化相等性</samp>
- en: While overriding both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> produces
    the most impressive performance improvements, we can do more to fine-tune equality
    comparisons. After all, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is used in circumstances other than when we’re creating data structures
    that rely on hash codes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    可以带来最显著的性能提升，但我们还可以做更多工作来微调相等性比较。毕竟，<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法不仅在创建依赖于哈希码的数据结构时会使用。
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct is a relatively
    simple data type, and its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is already quite efficient. To probe the characteristics of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    we’ll make a much more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    value type, shown in [Listing 8-7](#list8-7). The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    struct overrides both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> with custom
    implementations but doesn’t yet implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface. We’ll implement that interface for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    later to see how that affects the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 结构体是一个相对简单的数据类型，其
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法已经非常高效。为了探讨 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 的特性，我们将创建一个更加复杂的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    值类型，如 [列表 8-7](#list8-7) 所示。<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    结构体重写了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    方法，并提供了自定义实现，但还没有实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> 接口。我们稍后会为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    实现该接口，看看它如何影响 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 的性能。
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Defining a more
    complex data type, Purchase</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-7：定义一个更复杂的数据类型，Purchase</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> type has
    three fields, one of which is another nontrivial type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>,
    shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 类型有三个字段，其中一个是名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 的非平凡类型，如下所示：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> needs to do a little more
    work than the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type back in
    [Listing 8-5](#list8-5). When we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances for equality, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method must also ensure that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    properties match, which involves a method call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    类型中需要做比 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 类型中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法更多的工作，如 [示例 8-5](#list8-5)
    所示。当我们比较两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 实例的相等性时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法还必须确保 <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    属性匹配，这涉及到对 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>
    方法的调用。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The Purchase type is quite large—40 bytes plus padding, assuming a 64-bit
    architecture—so we should expect copying instances around to be less efficient
    than for the smaller Color type. That won’t affect our profiling, though, as we’ll
    still be comparing reports for the same types. We’ll return to the cost of copying
    large struct instances in “Copying Large Instances” on [page 272](#sec18).*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*Purchase 类型相当大——假设是 64 位架构，则为 40 字节加上填充——因此我们应该预期复制实例的效率低于较小的 Color 类型。不过，这不会影响我们的性能分析，因为我们仍然会比较相同类型的报告。我们将在《复制大型实例》一节中返回讨论复制大型结构实例的成本，见
    [第 272 页](#sec18)。*'
- en: Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, we’ll
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    to compare two very large lists of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects, as shown in [Listing 8-8](#list8-8). This process will exercise the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, allowing us to measure
    its efficiency. To magnify the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    compared to the cost of the surrounding code, we increase the number of elements
    to 10 million.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> 方法来比较两个非常大的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 对象列表，而不是使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>，如 [示例 8-8](#list8-8) 所示。此过程将测试
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，从而允许我们衡量它的效率。为了放大
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法与周围代码开销的性能对比，我们将元素数量增加到
    1000 万。
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: Testing to exercise
    equality</samp>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 8-8：测试以练习相等性</samp>
- en: 'In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>
    method, we use digit separators, available since C# v7.0, to make the large literal
    number easy for human readers to parse. Digit separators make no difference to
    the compiler: the number we use for the length of the initial sequence is still
    a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp> 方法中，我们使用自
    C# v7.0 起提供的数字分隔符，使得大型字面量数字更易于人类阅读和解析。数字分隔符对编译器没有影响：我们用于初始序列长度的数字仍然是一个普通的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 值。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    compares two sequences and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    if they have the same elements in the same order. The algorithm obtains an element
    from each sequence and compares those elements by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> doesn’t
    try to optimize its result by checking if the two sequences are in fact the *same*
    sequence, so here we create only one sequence of 10 million elements and compare
    it with itself. [Table 8-7](#tab8-7) shows the profiler report for the call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> 方法比较两个序列，如果它们的元素按相同顺序排列，则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>。该算法从每个序列中获取一个元素，并通过使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法进行比较。<samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    不会通过检查这两个序列是否实际上是 *相同* 的序列来优化其结果，因此在这里我们只创建一个包含 1000 万个元素的序列，并将其与自身进行比较。[表 8-7](#tab8-7)
    显示了调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> 的性能分析报告。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-7:</samp> <samp class="SANS_Futura_Std_Book_11">Exercising
    the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> <samp class="SANS_Futura_Std_Book_11">Method</samp>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-7:</samp> <samp class="SANS_Futura_Std_Book_11">执行</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> <samp class="SANS_Futura_Std_Book_11">方法</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">77.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1,227</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">77.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1,227</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">49.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">781</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Object)</samp>
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">49.3% 等于</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">781</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Object)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">24.3% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">384</samp> |  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">24.3% [垃圾回收]</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">384</samp> |  |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.6% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">168</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Object)</samp>
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.6% 等于</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">168</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Object)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.75% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Item()</samp>
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.75% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Item()</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.38% Unbox</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Runtime.CompilerServices
    .CastHelpers.Unbox(Void*, Object)</samp> |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.38% 解包</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Runtime.CompilerServices
    .CastHelpers.Unbox(Void*, Object)</samp> |'
- en: We can see that garbage collection contributes a significant portion of the
    time required by <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instance results
    in the argument being boxed, as <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    is a struct and the parameter type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    override is <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, a reference
    type. Furthermore, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>
    method calls <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>,
    which also requires its argument to be boxed. The consequence is that we’re allocating
    many boxed objects on the heap, placing the garbage collector under fairly significant
    pressure to keep memory usage under control.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，垃圾回收在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 所需的时间中占有重要部分。每次调用带有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 实例的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法都会导致参数被装箱，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 是一个结构体，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 重载的参数类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>，即引用类型。此外，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp> 方法会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>，这也需要将其参数装箱。结果是我们在堆上分配了许多装箱对象，这给垃圾回收器带来了相当大的压力，以保持内存使用的控制。
- en: In each <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    the parameter needs to be unboxed back to its original type so that its properties
    can be compared; the cost of unboxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter for each of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    methods is tiny but has a measurable impact. We can avoid the costs of boxing,
    and much of the associated cost of garbage collection, by implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> types.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法中，需要将参数拆箱回其原始类型，以便比较其属性；拆箱
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 参数的成本对于每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法来说非常小，但会产生可衡量的影响。通过为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 类型实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp>，我们可以避免装箱的成本，以及垃圾回收的相关成本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Effect of IEquatable<T></samp>
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">IEquatable<T> 的效果</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    automatically selects the best (the most efficient) implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    available to perform the comparisons. Internally, <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    helper class from [Chapter 5](chapter5.xhtml) to determine how to compare elements.
    If the element type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>, it’s guaranteed
    to implement a type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    and that overload will be called by <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> 方法会自动选择可用的最佳（最有效的）<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 实现来执行比较。内部，<samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    使用 [第 5 章](chapter5.xhtml) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    辅助类来确定如何比较元素。如果元素类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 实现了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>，则保证实现了类型安全的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 重载，并且该重载会被 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    调用。
- en: If we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface and provide our own type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Purchase></samp>
    interface method by default, avoiding the need for boxing and then unboxing the
    argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. In turn,
    this reduces memory pressure because the arguments aren’t copied to the heap,
    resulting in fewer objects for the garbage collector to inspect. In our example,
    those reductions are considerable, so implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface should produce a measurable benefit. [Listing 8-9](#list8-9)
    shows the changes required in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Purchase></samp>
    接口并提供我们自己的类型安全的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 重载方法，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> 方法将默认使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> 接口的方法，从而避免了拆箱和重新拆箱 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    参数的需求。这样，内存压力得到减轻，因为参数不会被复制到堆上，从而减少了垃圾回收器需要检查的对象数量。在我们的示例中，这些减少是相当可观的，因此实现 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Purchase></samp> 接口应该带来可衡量的好处。[清单
    8-9](#list8-9) 显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    中所需的更改。
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: The IEquatable</samp><
    Purchase> <samp class="SANS_Futura_Std_Book_Oblique_I_11">implementation</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-9：IEquatable</samp>< Purchase>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">实现</samp>
- en: We’ve added an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Purchase
    other)</samp> overload to perform the comparisons between each of the property
    values. The original <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    override still needs to unbox its <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter in order to call the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    overload, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method won’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    because we’ve also changed the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    declaration to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface. In [Listing 8-10](#list8-10), we make similar changes
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> so that calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp> from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp> method won’t require
    boxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Purchase other)</samp>
    重载方法，用于比较每个属性值。原始的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    重写方法仍然需要对其 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 参数进行拆箱，以便调用类型安全的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 重载方法，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    方法不会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>，因为我们还修改了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 的声明，使其实现了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Purchase></samp> 接口。在 [清单
    8-10](#list8-10) 中，我们对 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    进行了类似的更改，以便从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>
    方法调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp> 时，不需要对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 实例进行拆箱。
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: Implementing
    IEquatable</samp>< Product>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-10：实现 IEquatable</samp><
    Product>
- en: The results of the test from [Listing 8-8](#list8-8), incorporating the changes
    from [Listings 8-9](#list8-9) and [8-10](#list8-10), still with 10 million <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> elements, are shown in
    [Table 8-8](#tab8-8).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结合了 [清单 8-9](#list8-9) 和 [8-10](#list8-10) 中的更改后，从 [清单 8-8](#list8-8) 进行的测试结果，仍然是
    1000 万个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 元素，显示在 [表格
    8-8](#tab8-8) 中。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-8:</samp> <samp class="SANS_Futura_Std_Book_11">Measuring
    the Type-Safe</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    <samp class="SANS_Futura_Std_Book_11">Method</samp>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表格 8-8：</samp> <samp class="SANS_Futura_Std_Book_11">衡量类型安全的</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> <samp class="SANS_Futura_Std_Book_11">方法</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">62.6% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">546</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">62.6% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">546</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual(IEnumerable,
    IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">13.0% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">114</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">13.0% 等于</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">114</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.Equals(Purchase)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.48% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">48</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.48% 等于</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">48</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.05% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.op_Equality(DateTime,
    DateTime)</samp> |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.05% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.op_Equality(DateTime,
    DateTime)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.37% get_Ordered</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Ordered()</samp>
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.37% get_Ordered</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Ordered()</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.37% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Item()</samp>
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.37% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Item()</samp>
    |'
- en: Comparing this report with [Table 8-7](#tab8-7), we can see that the total time
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> has been
    greatly reduced, but also that our new <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is significantly faster than the original <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type’s version without the type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp>. Much of the difference is thanks to the lack of garbage collection,
    but we’re also benefiting from removing the need to box and unbox the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> values.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对比此报告与[表 8-7](#tab8-7)，我们可以看到，<samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>的总时间大幅减少，但也能看出，我们的新<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法明显比原本没有类型安全实现的<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>类型版本运行得更快，后者未实现类型安全的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<Purchase></samp>。其中很大一部分差异要归功于没有垃圾回收，但我们也从去除打包和解包<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>值的需求中获益。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Property Accesses</samp>
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">属性访问</samp>
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Purchase)</samp> method
    spends a measurable portion of its time accessing properties to compare them.
    All of the properties of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> are automatic
    properties, and every access to those properties is a method call—for example,
    the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Item</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Ordered</samp> shown in [Table
    8-8](#tab8-8). While the JIT compiler may often be able to optimize such calls
    away by inlining the underlying method, there’s no guarantee that it will. In
    [Listing 8-11](#list8-11), we change <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    to introduce our own private fields and alter <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to compare the fields directly rather than accessing the property values for comparison.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Purchase)</samp> 方法在比较属性时花费了可测量的时间。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    的所有属性都是自动属性，每次访问这些属性都会调用一个方法——例如，访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Item</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Ordered</samp> 方法，如[表8-8](#tab8-8)所示。尽管
    JIT 编译器通常能够通过内联底层方法来优化这些调用，但不能保证它一定会这样做。在[清单8-11](#list8-11)中，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    修改为引入我们自己的私有字段，并修改 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法直接比较字段，而不是通过访问属性值来进行比较。
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: Comparing fields
    rather than properties</samp>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单8-11：比较字段而不是属性</samp>
- en: Although not shown here, we also change <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    to replace its automatic properties with private fields. [Table 8-9](#tab8-9)
    shows the results of comparing 10 million elements the same way we have previously.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此处未显示，我们还修改了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>，将其自动属性替换为私有字段。[表8-9](#tab8-9)展示了我们之前同样方式比较1千万个元素的结果。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-9:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    the Performance of Fields vs. Properties</samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表8-9：</samp> <samp class="SANS_Futura_Std_Book_11">字段与属性性能比较</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">51.2% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">442</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">51.2% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">442</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.73% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">84</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.73% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">84</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.47% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">30</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.47% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">30</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.op_Equality(DateTime,
    DateTime)</samp> |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.op_Equality(DateTime,
    DateTime)</samp> |'
- en: Although replacing automatic properties with fields shows a small improvement,
    it’s an example of a micro-optimization. We’ve cut the time needed for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    by more than half compared to the version that didn’t implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp>, but we’re still talking about only a few hundred milliseconds
    in absolute time. We had to dramatically increase the size of the sequence to
    amplify the results enough to be observable, and most applications don’t routinely
    need to compare lists of 10 million elements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将自动属性替换为字段显示出了一些小的改进，但这只是一个微优化的例子。与未实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> 的版本相比，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    的执行时间减少了一半以上，但我们仍然只是在谈论几百毫秒的绝对时间。我们不得不显著增加序列的大小，才能放大结果到足够观察到的程度，而大多数应用程序通常不需要比较
    1000 万个元素的列表。
- en: Implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T
    ></samp> interface is a much more important step. Not only do we benefit from
    an increase in speed, but our type makes much more efficient use of memory by
    not needing to box the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>
    for value types is more than a performance optimization; it establishes that our
    type follows that protocol, enabling certain library features to operate more
    efficiently and signaling efficiency to human readers too.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> 接口是一个更重要的步骤。这样不仅能提高速度，我们的类型还能更高效地使用内存，因为不再需要对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法的参数进行装箱。对于值类型来说，实施
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> 不仅仅是性能优化，它还证明我们的类型遵循该协议，使得某些库功能能更高效地运作，同时也向人类读者传达了效率的信息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Equality Operators</samp>
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">相等操作符</samp>
- en: The final part of implementing a full set of equality comparisons for a type
    is to write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    with its companion <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>.
    [Listing 8-12](#list8-12) shows those operators implemented for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类型的完整相等比较的最后一步是编写我们自己的 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    及其伴随的 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>。[清单 8-12](#list8-12) 展示了这些操作符是如何为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 类型实现的。
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-12: Implementing
    equality operators for Purchase</samp>'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-12：为 Purchase 实现相等操作符</samp>
- en: Again, we also add equality operators to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type (not shown), allowing us to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp>
    field in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> by using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> instead of calling its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. Each operator
    implementation simply forwards to our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, where the comparison is performed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们还将相等操作符添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    类型（未展示），使我们可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 来比较
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 类型中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp>
    字段，而不必调用其 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法。每个操作符实现都简单地转发到我们类型安全的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，在该方法中执行比较。
- en: While we can write a test to call <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    in order to measure its performance characteristics, we can also arrange for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method to call
    the operator rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    by providing our own equality comparer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以编写测试来调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    来衡量其性能特性，但我们也可以通过提供我们自己的相等比较器，安排 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    方法调用该操作符，而不是调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Generic IEqualityComparer<T>
    Interface</samp>
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">泛型 IEqualityComparer<T> 接口</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    doesn’t invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> directly
    on the sequence elements to compare them. Instead, it relies on an implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>,
    which is part of the Standard Library and declared in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic</samp>
    namespace.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> 方法不会直接在序列元素上调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 进行比较。相反，它依赖于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp> 的实现，这部分属于标准库并声明在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic</samp>
    命名空间中。
- en: An implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> requires an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method taking two parameters of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method
    with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> parameter.
    The Standard Library provides some default implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp>, including one for instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    that implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T
    ></samp> interface, which is what our uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    have relied upon thus far.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>
    的实现需要一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，该方法接受两个类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 的参数，以及一个带有单个 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    参数的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 方法。标准库提供了一些
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp> 的默认实现，包括一个用于实现了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> 接口的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 实例的实现，这也是我们到目前为止使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    时所依赖的。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    has an overload that takes a second parameter whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp>, so we can provide our own implementation to be used instead of the
    default comparer. In [Listing 8-13](#list8-13), we create our own implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>
    interface, substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    as the generic parameter, and pass an instance of our custom comparer to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> 方法有一个重载，接受第二个参数，其类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>，因此我们可以提供自己的实现来替代默认的比较器。在[示例
    8-13](#list8-13)中，我们创建了自己的 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> 接口的实现，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    作为泛型参数，并将自定义比较器的实例传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>。
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-13: Creating a custom
    IEqualityComparer</samp>< T > <samp class="SANS_Futura_Std_Book_Oblique_I_11">implementation</samp>'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 8-13：创建自定义 IEqualityComparer</samp><
    T > <samp class="SANS_Futura_Std_Book_Oblique_I_11">实现</samp>
- en: Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    Purchase></samp> defines its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method to compare its two parameter values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    instead of the parameter type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. We don’t need a separate implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> member
    method in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> directly to compare the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> values. Now, when we use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> to compare
    two sequences of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    items, the algorithm will use <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    for the comparisons. [Table 8-10](#tab8-10) shows the profiler report for comparing
    10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> items.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< Purchase></samp>
    的实现定义了其 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，通过 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 来比较两个参数值，而不是使用参数类型的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法。我们不需要为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 编写单独的实现，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    成员方法直接使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 来比较 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    值。现在，当我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    来比较两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 序列时，算法将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> 进行比较。[表格 8-10](#tab8-10)
    显示了比较 1000 万个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 项目的分析报告。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-10:</samp> <samp class="SANS_Futura_Std_Book_11">How</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> <samp class="SANS_Futura_Std_Book_11">Performs</samp>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表格 8-10：</samp> <samp class="SANS_Futura_Std_Book_11">如何</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> <samp class="SANS_Futura_Std_Book_11">执行</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">48.8% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">475</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">48.8% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">475</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">22.2% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">216</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer
    .Equals(Purchase, Purchase)</samp> |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">22.2% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">216</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer
    .Equals(Purchase, Purchase)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">9.28% op_Equality</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">90</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.op_Equality(Purchase,
    Purchase)</samp> |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">9.28% op_Equality</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">90</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.op_Equality(Purchase,
    Purchase)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.28% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.28% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.53% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">54</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.op_Equality(Product,
    Product)</samp> |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.53% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">54</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.op_Equality(Product,
    Product)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.69% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.69% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
- en: When we define <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    for any type, the compiler translates it to a static method named <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp>,
    shown in this profiler report. That method takes both of its parameters by value,
    so we’re making a lot of copies of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instances. We
    can reduce the number of copies needed by changing the <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    methods to take their parameters by reference instead.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为任何类型定义<samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>时，编译器将其转换为一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp>的静态方法，如此性能分析报告中所示。该方法按值传递其两个参数，因此我们实际上会复制多个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>实例。我们可以通过将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>方法改为按引用传递参数来减少需要复制的次数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Read-Only in Parameters</samp>
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">只读参数</samp>
- en: To reap the benefits of altering our <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    methods to take their parameters by reference rather than by value, we can use
    read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters.
    They are specifically intended for avoiding copies of large value type instances
    and are appropriate when we don’t need to mutate the parameter variables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用将<samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>方法改为按引用传递其参数而不是按值传递的好处，我们可以使用只读<samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp>参数。它们专门用于避免复制大型值类型实例，并且适用于我们不需要修改参数变量的情况。
- en: We shouldn’t expect a huge improvement, however, because we can’t avoid all
    the copies being made when comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    elements in our sequence. In particular, the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals</samp>
    method must take its parameters by value to match the signature defined in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp> interface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不应指望会有巨大的改进，因为在比较我们序列中的<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>元素时，我们无法避免所有复制的发生。特别是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals</samp>方法必须按值传递其参数，以匹配<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>接口中定义的签名。
- en: Similarly, as shown in [Listing 8-14](#list8-14), the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    itself takes its parameter by value according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface, but we can add a new overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    that uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter
    and use the same mechanism to alter the equality operators to take all their parameters
    by reference.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如[列表 8-14](#list8-14)所示，在<sup class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>中定义的类型安全的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法按照<samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp>接口的要求按值传递其参数，但我们可以添加一个新的重载的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp>参数，并使用相同的机制来修改相等操作符，使它们按引用传递所有参数。
- en: '[PRE14]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-14: Overloading using
    in parameters</samp>'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-14: 使用 in 参数的重载</samp>'
- en: We make the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter the
    main implementation and forward to it from the equality operators and the implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Purchase></samp>.
    Although <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters are
    transparent to calling code, the rules for overloading will give preference to
    the method with no parameter modifiers, unless we add an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier to the argument when calling the method. Therefore, we explicitly select
    the overload with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword
    to the argument we pass wherever we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法作为主要实现，并从等式运算符和 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Purchase></samp>
    的实现中转发到它。尽管 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数对调用代码是透明的，但重载规则将优先选择没有参数修饰符的方法，除非我们在调用方法时将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 修饰符添加到参数。因此，我们通过在调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 时向传递的参数添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    关键字，显式选择具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数的重载。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Replacing value parameters with in parameters is a version-breaking change,
    requiring extra care if binary compatibility is a consideration.*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*将值参数替换为 in 参数是一个破坏版本的更改，如果二进制兼容性是一个考虑因素，则需要格外小心。*'
- en: We don’t need to change the implementation of our <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer</samp>
    to pass the arguments by reference, since our <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    method doesn’t have an overload taking parameters by value. We can reuse the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer</samp> from [Listing
    8-13](#list8-13) to run the test, with the results shown in [Table 8-11](#tab8-11).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无需更改 <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer</samp>
    的实现以通过引用传递参数，因为我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    方法没有接受值传递的重载。我们可以重用来自[列表 8-13](#list8-13)的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer</samp>
    来运行测试，结果显示在[表格 8-11](#tab8-11)中。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-11:</samp> <samp class="SANS_Futura_Std_Book_11">Results
    of Passing by Reference to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-11：</samp> <samp class="SANS_Futura_Std_Book_11">通过引用传递给</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> 的结果
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">45.1% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">437</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">45.1% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">437</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20.9% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">203</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals(Purchase,
    Purchase)</samp> |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20.9% 等于</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">203</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals(Purchase,
    Purchase)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.5% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">102</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.op_Equality(in
    Purchase, in Purchase)</samp> |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.5% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">102</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.op_Equality(in
    Purchase, in Purchase)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.23% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(in
    Purchase)</samp> |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.23% 等于</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(in Purchase)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.38% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">72</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.op_Equality(in
    Product, in Product)</samp> |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.38% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">72</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.op_Equality(in
    Product, in Product)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.38% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">72</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(in
    Product)</samp> |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.38% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">72</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(in
    Product)</samp> |'
- en: Comparing these results to [Table 8-10](#tab8-10), we can see the improvement
    is quite modest. While we certainly get some benefit from avoiding copying <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects, that benefit
    is limited to <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    actually being called. [Table 8-12](#tab8-12) shows a tracing report with counts
    of the number of method calls, showing that the JIT compiler is inlining all but
    a very few calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些结果与[表 8-10](#tab8-10)进行比较，我们可以看到改进是相当有限的。虽然我们确实从避免复制<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>对象中受益，但这种好处仅限于实际调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>。 [表 8-12](#tab8-12)展示了一个追踪报告，列出了方法调用的次数，显示JIT编译器将除了少数几个调用外，所有对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>的调用都内联了。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-12:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for Comparing</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    <samp class="SANS_Futura_Std_Book_11">Parameter Values</samp>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-12：</samp> <samp class="SANS_Futura_Std_Book_11">比较的追踪报告</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">在</samp> <samp class="SANS_Futura_Std_Book_11">参数值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">调用次数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp>
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.88% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2,013</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    call</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.88% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2,013</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    次调用</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.69% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">735</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10,000,000
    calls</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals(Purchase,
    Purchase)</samp> |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.69% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">735</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10,000,000
    次调用</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals(Purchase,
    Purchase)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |  |  |  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |  |  |  |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.08% op_Equality</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">82</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">126,402
    calls</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.op_Equality(in
    Purchase, in Purchase)</samp> |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.08% op_Equality</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">82</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">126,402
    次调用</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.op_Equality(in
    Purchase, in Purchase)</samp> |'
- en: While using <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    in our definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    is free in that it requires no changes to calling code, we shouldn’t expect too
    much from it. We also shouldn’t simply apply <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters routinely, even when using them wouldn’t detract from a method’s readability.
    Passing small value types by reference may incur a penalty due to the extra level
    of indirection required to access the value itself via a by-reference variable.
    As with any optimization feature in the code, we should introduce <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters only where our measurements show that they’re warranted.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在定义<code class="SANS_TheSansMonoCd_W5Regular_11">operator==</code>时使用<code
    class="SANS_TheSansMonoCd_W5Regular_11">in</code>参数是免费的，因为它不需要修改调用代码，但我们不应期望它带来太多的好处。我们也不应当在使用<code
    class="SANS_TheSansMonoCd_W5Regular_11">in</code>参数时简单地例行公事，即使使用它不会影响方法的可读性。通过引用传递小的值类型可能会产生额外的开销，因为访问值本身需要通过引用变量进行额外的间接访问。与任何代码优化特性一样，我们只有在测量表明有必要时，才应该引入<code
    class="SANS_TheSansMonoCd_W5Regular_11">in</code>参数。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Type Affects Performance</samp>
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <code class="SANS_Futura_Std_Bold_B_11">类型如何影响性能</code>
- en: Our choice of types in an application can affect its overall performance in
    various ways. The types we use to represent values in an application are the most
    important part of that choice because the other types will usually be classes
    in any case. Values, on the other hand, can be represented as structs, classes,
    records, or record structs. In this section, we’ll examine some of the factors
    that can help us decide between using struct types and class types to implement
    those value types, and how much those factors affect performance.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中选择类型可能会以各种方式影响其整体性能。我们用来表示应用程序中值的类型是这种选择中最重要的部分，因为其他类型通常无论如何都会是类。另一方面，值可以通过结构体、类、记录或记录结构体来表示。在本节中，我们将探讨一些有助于我们决定使用结构类型还是类类型来实现这些值类型的因素，以及这些因素对性能的影响程度。
- en: We often hear that structs, and therefore record structs, should be small because
    it’s expensive to copy large instances around in memory. With that in mind, we’ll
    start by attempting to isolate the cost of copying instances from the other factors
    affecting performance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常常听说结构体，因此记录结构体，应该尽量小，因为在内存中复制大型实例是昂贵的。考虑到这一点，我们将首先尝试将复制实例的开销与其他影响性能的因素分开。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring the Cost
    of Copying</samp>
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <code class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">测量复制的开销</code>
- en: As with our previous performance measurements, we need to establish a simple
    baseline against which we can compare further performance reports. Since we want
    to measure the cost of copying a large value type, first we have to measure the
    cost of copying a small, simple type, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    struct we create in [Listing 8-15](#list8-15).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的性能测量一样，我们需要建立一个简单的基准线，以便可以将进一步的性能报告与之进行比较。由于我们希望测量复制大值类型的开销，因此首先需要测量复制一个小而简单的类型的开销，比如我们在[清单
    8-15](#list8-15)中创建的<code class="SANS_TheSansMonoCd_W5Regular_11">IntField</code>结构体。
- en: '[PRE15]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-15: Creating a simple
    struct with a single int field</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <code class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-15：创建一个具有单个 int 字段的简单结构体</code>
- en: To exercise copying, we’ll again use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method, which copies elements from the sequences to compare them and will copy
    them again to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Equals</samp>
    method. Here, we return to using the default equality comparer, which will call
    our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    passing its argument by value. [Listing 8-16](#list8-16) shows the code we’ll
    use to produce our benchmark performance profile.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试复制，我们将再次使用<code class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</code>方法，它将从序列中复制元素进行比较，并再次复制它们以调用<code
    class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<T></code><code class="SANS_TheSansMonoCd_W5Regular_11">.Equals</code>方法。在这里，我们返回使用默认的相等比较器，它将调用我们的类型安全的<code
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</code>方法，并按值传递其参数。[清单 8-16](#list8-16)展示了我们将用来生成基准性能分析的代码。
- en: '[PRE16]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-16: Testing simple
    copies</samp>'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 8-16：测试简单的复制</samp>
- en: For this test, we’ll profile a debug build of this code to try to minimize the
    effects of the method inlining performed by the JIT compiler. Method arguments
    are copied only if the method is invoked normally, and inlining would make measuring
    the cost of those copies unreliable; two different runs of the code could easily
    make a different number of copies. [Table 8-13](#tab8-13) shows the CPU sampling
    report for comparing two sequences of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    items in a debug build, which inhibits the JIT compiler from inlining method calls.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我们将分析此代码的调试版本，以尽量减少JIT编译器进行方法内联的影响。只有在方法正常调用时，方法参数才会被复制，而内联会使得测量这些复制的成本变得不可靠；两次不同的代码运行可能会产生不同的复制次数。[表
    8-13](#tab8-13)展示了在调试版本中比较两个包含1000万个<samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>项的序列的CPU采样报告，这会抑制JIT编译器进行方法调用的内联。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-13:</samp> <samp class="SANS_Futura_Std_Book_11">Measuring
    the Cost of Copying a Simple Struct</samp>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-13：</samp> <samp class="SANS_Futura_Std_Book_11">测量复制简单结构体的成本</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">57.0% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">57.0% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.60% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField.Equals(IntField)</samp>
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.60% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField.Equals(IntField)</samp>
    |'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> algorithm
    does little other than obtain an element from each sequence and compare one to
    the other with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The
    difference between the time taken by <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and the total time spent in <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    here is all overhead, representing the time taken to obtain each pair of elements
    from the sequences and copy the arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>算法所做的事情很少，它仅仅是从每个序列中获取一个元素，并使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>将它们进行比较。这里<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>所花的时间与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>的总时间之间的差异，都是开销，表示获取每对元素以及为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>复制参数所花费的时间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Large Instances</samp>
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">复制大型实例</samp>
- en: Copying a simple struct type such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    struct in [Listing 8-15](#list8-15) is no more expensive than copying a plain
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value; a simple test
    (not shown here) that compares two sequences of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    values will confirm it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    struct in [Listing 8-17](#list8-17), which adds three entirely redundant <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> fields, is significantly larger
    than the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp> struct.
    Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> is 16 bytes, making
    this struct somewhat larger than even the most generous recommended limit for
    the size of a value type.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 复制一个简单的结构体类型，如[列表 8-15](#list8-15)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    结构体，和复制一个普通的 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 值一样，并不会增加额外的开销。一个简单的测试（这里未展示）可以验证这一点，通过比较两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 值的序列。<samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    结构体，位于[列表 8-17](#list8-17)，它添加了三个完全冗余的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>
    字段，比 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp> 结构体要大得多。每个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> 字段占用 16 字节，因此这个结构体的大小甚至比推荐的值类型大小限制还要大。
- en: '[PRE17]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-17: Creating an extremely
    large struct</samp>'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-17：创建一个极大的结构体</samp>
- en: 'Note one subtlety in the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    struct: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    doesn’t consider any of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>
    fields of the type, because they’re always all identical in any case. The reason
    is that we’re trying to measure just the cost of copying, so this <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method performs precisely the same operations as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    type in [Listing 8-15](#list8-15). While the padding fields play no part in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method or any other
    operation, the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    type is a struct and therefore copied by value, so *every* field will be copied.
    We run the same test from [Listing 8-16](#list8-16), with the results shown in
    [Table 8-14](#tab8-14).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp> 结构体的一个细节：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法不会考虑类型中的任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>
    字段，因为它们在任何情况下都是相同的。原因在于我们只是想衡量复制的成本，因此这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法与[列表 8-15](#list8-15)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    类型执行的是完全相同的操作。虽然填充字段在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法或其他任何操作中不起作用，但由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    类型是一个结构体，因此按值复制它时，*每个* 字段都会被复制。我们从[列表 8-16](#list8-16)中运行相同的测试，结果显示在[表 8-14](#tab8-14)中。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-14:</samp> <samp class="SANS_Futura_Std_Book_11">Measuring
    the Cost of Copying an Extra-Large Struct</samp>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-14：</samp> <samp class="SANS_Futura_Std_Book_11">衡量复制超大结构体的成本</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">52.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">228</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">52.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">228</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.71% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16.Equals(IntPlus3x16)</samp>
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.71% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16.Equals(IntPlus3x16)</samp>
    |'
- en: 'Compare [Table 8-14](#tab8-14) with [Table 8-13](#tab8-13): the time spent
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is identical
    in both reports, although the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method has taken over twice as long to complete because of the extra overhead
    of copying the instances of the larger <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method in
    both tests is performing the same operation, so the increase in time must be entirely
    due to the cost of copying instances.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对比 [表 8-14](#tab8-14) 和 [表 8-13](#tab8-13)：两份报告中 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法所花费的时间相同，尽管 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    方法的执行时间是其两倍以上，因为复制较大的 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    类型实例的额外开销。在两次测试中，<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法执行的是相同的操作，因此时间的增加完全是由于复制实例的成本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weighing Object Construction
    Costs</samp>
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">衡量对象构造成本</samp>
- en: The cost of copying a large struct is not the only aspect to consider when using
    a type with several fields. For one thing, equality comparisons will usually take
    every field or property into account, making those comparisons more costly than
    for a type with only one or two fields. Initializing an instance of a type with
    several fields also comes with a cost.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 复制大型结构体的成本并不是使用具有多个字段的类型时需要考虑的唯一因素。首先，相等比较通常会考虑每个字段或属性，这使得这些比较比只有一个或两个字段的类型更为昂贵。初始化一个具有多个字段的类型实例同样会产生额外的开销。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> types in [Listing 8-18](#list8-18)
    are the positional record struct equivalents of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> structs we defined
    earlier in [Listing 8-7](#list8-7). Because they’re record struct types, the compiler
    generates all the equality comparisons, making them much simpler to define than
    their struct counterparts.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-18](#list8-18) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 类型是我们在 [列表 8-7](#list8-7)
    中定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    结构体的定位记录结构等效体。由于它们是记录结构类型，编译器会自动生成所有的相等比较，使得它们比结构体版本更易于定义。'
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-18: Defining Product
    and Purchase as record structs</samp>'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-18：将 Product 和 Purchase
    定义为记录结构体</samp>
- en: We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareSequences</samp>
    method shown in [Listing 8-19](#list8-19) to create a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances and record the performance. We return here to profiling a release build
    so that the results account for any optimizations afforded by the JIT (or AOT)
    compiler.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 [列表 8-19](#list8-19) 中展示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareSequences</samp>
    方法来创建一系列 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 实例并记录性能。我们回到发布版构建的性能分析，这样结果就能够考虑到
    JIT（或 AOT）编译器所带来的任何优化。
- en: '[PRE19]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-19: Creating a sequence
    of randomly generated objects</samp>'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-19：创建一个随机生成对象的序列</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareSequences</samp> method
    follows a pattern similar to that we’ve used previously to create a sequence and
    then call <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> to
    compare the elements. For the purposes of making the performance report clear,
    we use <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> as a
    method group argument for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    expression. That way, we can measure its performance directly, without introducing
    any overhead by using a lambda expression—something we’ll return to in “How Common
    Idioms and Practices Affect Performance” on [page 279](#sec23). [Table 8-15](#tab8-15)
    shows the profiler report for creating 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects using the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareSequences</samp> 方法遵循与我们之前创建序列并调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> 比较元素的模式相似。为了使性能报告更加清晰，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    表达式的一个方法组参数。这样，我们就可以直接测量它的性能，而不会通过使用 lambda 表达式引入任何开销——我们将在《常见习惯用法和实践如何影响性能》中详细讨论这个问题，见
    [第279页](#sec23)。[表 8-15](#tab8-15) 显示了使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    方法创建 1000 万个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 对象的分析器报告。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-15:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    Report for Creating the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    <samp class="SANS_Futura_Std_Book_11">Sequence</samp>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-15：</samp> <samp class="SANS_Futura_Std_Book_11">创建</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> <samp class="SANS_Futura_Std_Book_11">序列的性能报告</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">29.4% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">294</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">29.4% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">294</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.45% op_Implicit</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.op_Implicit(Int32)</samp>
    |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.45% op_Implicit</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.op_Implicit(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.03% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.03% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% Product..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">14</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product..ctor(Int32,
    Decimal, String)</samp> |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% Product..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">14</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product..ctor(Int32,
    Decimal, String)</samp> |'
- en: While the nested constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type increases the time taken to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects, the majority of the time is spent within the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>, suggesting that initializing
    the instances and copying them around is the costlier factor. In particular, creating
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> and then copying
    the instance to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    constructor is one copy we can avoid by making <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    a reference type.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然嵌套的构造函数会增加创建<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>对象所需的时间，但大部分时间都花费在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>的实现上，这表明初始化实例并进行复制是更昂贵的因素。特别是，创建一个新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>并将实例复制到<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>构造函数时，复制是我们可以通过将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>变为引用类型来避免的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reference Type Performance</samp>
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">引用类型性能</samp>
- en: 'When we copy a reference variable, the object instance isn’t copied at all,
    making the copy inexpensive. Here we make <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    a sealed record instead of a read-only record struct:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们复制一个引用变量时，对象实例本身并不会被复制，因此复制成本很低。在这里，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>变成一个封闭的记录，而不是只读记录结构体：
- en: '[PRE20]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Records using this positional syntax are immutable reference types by default.
    For the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type, the
    compiler inserts <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    properties for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Id</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Price</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    properties, meaning that one instance can be safely and efficiently referenced
    by several containing objects. Since none of the properties has a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor, there’s no risk of inadvertent changes being made via aliasing references.
    More pertinently for our test, once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance is created, only the reference to it needs to be passed to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> constructor.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种位置语法的记录默认是不可变的引用类型。对于<samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>类型，编译器为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Id</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Price</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>属性插入了仅限<samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>的属性，这意味着一个实例可以被多个包含对象安全高效地引用。由于这些属性没有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">set</samp>访问器，因此不存在通过别名引用进行意外修改的风险。更重要的是，对于我们的测试来说，一旦<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>实例被创建，仅需将其引用传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>构造函数。
- en: For this test, we leave the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type as a record struct, since we’re trying to avoid having to copy its nested
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>. However, using a
    reference type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    introduces other overhead, as we can see in the profiler report in [Table 8-16](#tab8-16)
    for creating 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>类型保持为记录结构体，因为我们希望避免复制其嵌套的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>。然而，使用引用类型来表示<samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>引入了其他开销，正如我们在[表8-16](#tab8-16)中看到的，对于创建1000万个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>对象的分析报告。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-16:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    Report for Creating Reference Type Values</samp>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表8-16：</samp> <samp class="SANS_Futura_Std_Book_11">创建引用类型值的性能报告</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">77.8% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1,409</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">77.8% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1,409</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">34.9% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">632</samp> |  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">34.9% [垃圾回收]</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">632</samp> |  |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.33% Product..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product..ctor(Int32,
    Decimal, String)</samp> |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.33% Product..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product..ctor(Int32,
    Decimal, String)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.33% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.33% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method
    is significantly slower than in [Table 8-15](#tab8-15), with the main culprit
    being garbage collection. Changing <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    to be a record rather than a record struct has put considerable pressure on the
    garbage collector, which takes time even if it can’t collect any objects.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> 方法比 [表 8-15](#tab8-15)
    中的速度慢得多，主要原因是垃圾回收。将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    改为记录类型而不是记录结构体，给垃圾回收器带来了很大的压力，即使它无法回收任何对象，也需要花费时间。
- en: The lesson here is that the common advice to use value types for objects that
    are short-lived is at least partly related to memory pressure and the cost of
    garbage collection. Value type instances, because they aren’t allocated on the
    heap, don’t incur those costs. Copying even huge object instances isn’t always
    the most significant expense, so changing large value types to be reference types
    to avoid copying can, as in this example, have a detrimental effect on a program’s
    overall performance.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，关于短生命周期对象应使用值类型的常见建议，至少部分原因与内存压力和垃圾回收的成本有关。值类型实例因为不在堆上分配内存，因此不会产生这些成本。即使是复制巨大对象实例，也不总是最显著的开销，因此像这个例子一样，将大型值类型更改为引用类型以避免复制，可能会对程序的整体性能产生不利影响。
- en: We have other factors to consider. If, for instance, we expect many of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects in an application
    to have identical <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    values, we may benefit considerably by having all those <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances sharing the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance, making a reference type implementation much more attractive.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有其他因素需要考虑。例如，如果我们预计应用程序中的许多 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    对象具有相同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 值，那么让所有这些
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 实例共享相同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    实例，可能会带来显著的好处，使得引用类型的实现更加吸引人。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Benefits of Reference Equality</samp>
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">引用相等性的好处</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method
    from [Listing 8-19](#list8-19) that we’ve been using to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    object for each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    object. In [Listing 8-20](#list8-20), we change <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    so that rather than creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    each time, we assign one of a small number of shared <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instances to each new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a record
    and therefore a reference type, each <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    will be shared by many <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [列表 8-19](#list8-19) 中使用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    方法，用于创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">购买</samp> 实例时，每次都会为每个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">购买</samp> 对象创建一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">产品</samp>
    对象。在 [列表 8-20](#list8-20) 中，我们修改了 <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    方法，使得它不再每次都创建一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">产品</samp>，而是将少数几个共享的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">产品</samp> 实例中的一个分配给每个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">购买</samp>。由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">产品</samp> 是一个记录类型，因此它是引用类型，每个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">产品</samp> 实例会被多个 <samp class="SANS_TheSansMonoCd_W5Regular_11">购买</samp>
    对象共享。
- en: '[PRE21]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-20: Sharing references
    among objects</samp>'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-20：在对象间共享引用</samp>
- en: We initialize a short list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instances before creating any <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> reference
    is selected from this list according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>
    value used to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
    Now that the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method isn’t creating any new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instances, we’d expect it to run much more quickly, which the report in [Table
    8-17](#tab8-17) confirms.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">购买</samp> 对象之前，我们先初始化一个包含少量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">产品</samp> 实例的短列表。根据用于创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">购买</samp>
    对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> 值，从该列表中选择一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">产品</samp> 引用。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    方法不再创建新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">产品</samp> 实例，我们预期它的执行会更快，报告中的
    [表 8-17](#tab8-17) 已经确认了这一点。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-17:</samp> <samp class="SANS_Futura_Std_Book_11">Assigning
    Preallocated</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    <samp class="SANS_Futura_Std_Book_11">Objects</samp>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-17：</samp> <samp class="SANS_Futura_Std_Book_11">分配预分配的</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">产品</samp> <samp class="SANS_Futura_Std_Book_11">对象</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">17.1% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">86</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">17.1% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">86</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.38% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.38% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.18% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">5.9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.List`1
    .get_Item(Int32)</samp> |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.18% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">5.9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.List`1
    .get_Item(Int32)</samp> |'
- en: More significantly, comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances for equality will now be much faster because so many of them share a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance. The implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for record types
    includes the simple optimization of starting with an identity comparison of the
    two references. When two <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    variables that are being compared both refer to the same instance in memory, there’s
    no need to continue checking the individual fields, since they must be identical.
    [Table 8-18](#tab8-18) shows the report for comparing sequence elements for 10
    million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，由于许多`Purchase`实例共享一个`Product`实例，比较`Purchase`实例是否相等的速度现在会更快。记录类型的`Equals`方法的实现包含了一个简单的优化，即首先进行两个引用的身份比较。当两个被比较的`Product`变量都引用内存中的同一个实例时，就不需要继续检查单独的字段，因为它们必须是相同的。[表8-18](#tab8-18)展示了对1000万个`Purchase`对象进行序列元素比较的报告。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-18:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    Sequences with Shared References</samp>
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表8-18：</samp> <samp class="SANS_Futura_Std_Book_11">共享引用的序列比较</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">68.3% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">350</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">68.3% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">350</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">27.1% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">139</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">27.1% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">139</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">11.7% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">60</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">11.7% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">60</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.36% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">48</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.36% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">48</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.52% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.52% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
- en: If we run the same test by using a record struct for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>—that
    is, assigning one of a few precreated instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    to each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>—we can compare
    the performance of sharing references versus copying each <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>.
    [Table 8-19](#tab8-19) shows the report for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    for 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects
    when <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a record
    struct.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用记录结构（record struct）来运行相同的测试，针对 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>——也就是说，将几个预创建的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 实例之一分配给每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>——我们可以比较共享引用与复制每个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 对象的性能。[表 8-19](#tab8-19)
    显示了在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 是记录结构时，10百万个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    的报告。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-19:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    Sequences with Copied Instances</samp>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-19：</samp> <samp class="SANS_Futura_Std_Book_11">比较复制实例的序列</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">59.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">591</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">59.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">591</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">13.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">132</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">13.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">132</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12.7% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">126</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12.7% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">126</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.01% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">89</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.01% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">89</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.22% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.Equals(DateTime)</samp>
    |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.22% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.Equals(DateTime)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
- en: Although the headline time for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>
    method is almost identical in each case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method using the record struct in [Table 8-19](#tab8-19) is considerably slower
    than for the record in [Table 8-18](#tab8-18). Record structs can’t take advantage
    of the simple reference identity optimization available to records, although many
    of the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>
    will have been inlined by the JIT compiler. The result is that we see the extra
    cost of having to copy the record struct values and compare their fields in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>, rather than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>方法的头时间在每种情况下几乎相同，但在[表8-19](#tab8-19)中使用记录结构的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>方法的执行速度明显比在[表8-18](#tab8-18)中使用记录的要慢。记录结构无法利用记录类型的简单引用标识优化，尽管许多对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>的调用可能已经被JIT编译器内联。结果是，我们看到了在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>中必须复制记录结构值并比较其字段的额外开销，而不是在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring the Compiler-Generated
    Equals Method</samp>
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">衡量编译器生成的 Equals 方法</samp>
- en: The positional record struct syntax used in [Listing 8-18](#list8-18) for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    types makes their definition compact, but that comes with minor, although measurable,
    efficiency compromises. The type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface for records and record structs is generated by the compiler,
    whether or not they use the positional syntax. While convenient, that’s not necessarily
    the most efficient implementation. When we’re working with many objects, it can
    be worth our while to write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for record and record struct types, in which case the compiler won’t generate
    one for us.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表8-18](#list8-18)中使用的位置记录结构语法使得<sup class="SANS_TheSansMonoCd_W5Regular_11">Purchase</sup>和<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Product</sup>类型的定义紧凑，但这也带来了一些轻微但可测量的效率折衷。实现了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<T></samp>接口的类型安全的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法是由编译器生成的，无论它们是否使用位置语法。虽然方便，但这不一定是最有效的实现。当我们处理大量对象时，编写我们自己的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法可能会更有价值，在这种情况下，编译器将不会为我们生成一个。
- en: You saw in [Chapter 5](chapter5.xhtml) that the compiler inserts code to obtain
    the default <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    object for each field. For example, [Listing 8-21](#list8-21) shows roughly the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method created by
    the compiler for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    record struct in [Listing 8-18](#list8-18).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](chapter5.xhtml)中，你看到编译器插入了代码以获取每个字段的默认<samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>对象。例如，[列表8-21](#list8-21)大致展示了编译器为[列表8-18](#list8-18)中的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</sup>记录结构创建的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法。
- en: '[PRE22]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-21: A record struct’s
    Equals method</samp>'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表8-21：记录结构的 Equals 方法</samp>
- en: The real names of the backing fields assigned by the compiler are invalid in
    regular C#, so there’s no chance they could clash with any of our own identifiers;
    the names used here merely illustrate the idea. Despite using the backing fields
    directly rather than accessing the properties to perform the comparisons, obtaining
    the default <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    implementation for each field on *every call* to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    could impair efficiency. [Table 8-20](#tab8-20) shows the profiler output when
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    to compare two lists of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    record struct objects.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器分配的后台字段的真实名称在常规 C# 中是无效的，因此不可能与我们的任何标识符发生冲突；这里使用的名称仅用于说明这个概念。尽管直接使用后台字段而不是访问属性来执行比较，但每次调用时为每个字段获取默认的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp> 实现可能会影响效率。[表
    8-20](#tab8-20) 显示了在使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    方法比较两个包含 1000 万个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    记录结构对象的列表时的分析器输出。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-20:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    Sequences with Record Struct Instances</samp>
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-20：</samp> <samp class="SANS_Futura_Std_Book_11">使用记录结构实例比较序列</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">55.7% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">558</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">55.7% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">558</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">13.7% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">138</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">13.7% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">138</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.2% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">102</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.2% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">102</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.58% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.58% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.80% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.Equals(Decimal)</samp>
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.80% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.Equals(Decimal)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Int32.Equals(Int32)</samp>
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Int32.Equals(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
- en: While the JIT compiler may inline some or all of the uses of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Default</samp>
    property and the calls to its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, there’s no guarantee that it will be able to do so. As we did earlier
    when replacing property accesses with fields, we can define our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method to directly compare the values without needing to use <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T ></samp>. However, we can’t access the compiler-generated backing fields for
    the properties generated for a positional record struct. Instead, in [Listing
    8-22](#list8-22) we use a simple record struct for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>,
    where we define our own private fields and a constructor to initialize them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JIT 编译器可能会内联一些或所有对 `<samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Default</samp>
    属性的使用，以及对其 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>` 方法的调用，但并不能保证它能够做到这一点。正如我们之前在用字段替代属性访问时所做的那样，我们可以定义自己的
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>` 方法，直接比较值，而无需使用 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer< T ></samp>`。然而，我们无法访问为位置记录结构生成的属性的编译器生成的后备字段。相反，在
    [Listing 8-22](#list8-22) 中，我们使用了一个简单的记录结构体 `Purchase`，在其中定义了我们自己的私有字段和构造函数来初始化它们。
- en: '[PRE23]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-22: Constructing
    a private field for the Purchase struct</samp>'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-22: 为 Purchase 结构体构造私有字段</samp>'
- en: We also add our own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to directly compare the fields we’ve defined. This custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    replaces the implementation that the compiler would have introduced had we not
    defined our own. We’d also need to add properties to expose the field values,
    although neither that nor the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type, which changes in a similar way, is shown here. Rerunning the code to compare
    two sequences of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    items produces the report shown in [Table 8-21](#tab8-21).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了自己的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>` 实现，直接比较我们定义的字段。这个自定义的
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>` 替代了编译器在我们没有定义自己的情况下会引入的实现。我们还需要添加属性来暴露字段的值，尽管这些内容，以及以类似方式变化的
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>` 类型在此处没有显示。重新运行代码以比较两个包含
    1000 万个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>` 项目的序列时，会生成在
    [表 8-21](#tab8-21) 中显示的报告。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-21:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Comparison Using Customized</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-21：</samp> <samp class="SANS_Futura_Std_Book_11">使用自定义的</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% SequenceEqual</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">440</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% SequenceEqual</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">440</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">54</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">54</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.18% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.18% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.36% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.Equals(DateTime)</samp>
    |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.36% 等于</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.Equals(DateTime)</samp>
    |'
- en: By providing our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, we’ve improved the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    by around 20 percent compared with the results in [Table 8-20](#tab8-20), partly
    because our implementation may be giving the JIT compiler more effective opportunities
    for inlining code. Comparing larger sequences produces similar results, so if
    we’re particularly sensitive to performance and frequently compare many items,
    this kind of optimization may be beneficial.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供我们自己的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>的性能提高了大约20%，与[表8-20](#tab8-20)中的结果相比，部分原因是我们的实现可能为JIT编译器提供了更有效的内联代码机会。比较更大的序列会产生类似的结果，因此，如果我们特别关注性能并且频繁比较许多项目，这种优化可能会带来好处。
- en: The performance improvement we see here occurs primarily because <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    is a relatively complex type. A much simpler positional record struct—for example,
    one with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> field—most
    likely wouldn’t benefit from the optimizations we made in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>. The principal
    benefit of the positional record syntax is its simplicity, which makes it clear
    to any reader what the type represents. We sacrificed that simplicity for a small
    gain in raw performance, an improvement that was visible only with the help of
    a profiler. This example highlights the importance of measuring performance before
    trying to hand-optimize our code by second-guessing the compiler.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的性能提升，主要是因为<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>是一个相对复杂的类型。一个更简单的位置记录结构——例如，只有一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>字段——可能不会像在<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>中进行的优化那样带来好处。位置记录语法的主要优点是它的简洁性，使任何读者都能清楚地了解类型所代表的内容。我们为了一点点原始性能提升而牺牲了这种简洁性，而这一提升只有在使用性能分析工具时才可见。这个例子突显了在尝试通过猜测编译器来手动优化代码之前，先进行性能测量的重要性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Common Idioms and Practices Affect
    Performance</samp>
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">常见的习惯用法和实践如何影响性能</samp>
- en: 'Some common practices in C# draw undue criticism regarding performance. It’s
    natural and common to believe that a higher level of abstraction in source code
    comes with a cost in performance, and that’s true to some extent: C# is a *high-level*
    programming language, and our programs are ultimately translated to native machine
    code over multiple steps. We could handcraft our own machine code to perform the
    same task, but C# code is more portable, more easily maintained, considerably
    less error-prone, and much easier to read and write than machine code. Those benefits
    usually far outweigh any cost in performance.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，一些常见的做法由于性能问题受到过度批评。我们通常会认为源代码中更高层次的抽象会导致性能上的开销，这在某种程度上是正确的：C#是一种*高级*编程语言，我们的程序最终会经过多个步骤转换为本地机器代码。我们可以手动编写机器代码来执行相同的任务，但C#代码更具可移植性、更容易维护、出错的可能性较低，并且比机器代码更容易阅读和编写。这些优势通常远大于性能上的任何损失。
- en: It’s not, however, universally true that high-level code results in performance
    penalties. In this section, we’ll investigate looping and pattern matching, two
    common C# features that enable us to succinctly express complex ideas in C# while
    providing performance comparable or even superior to their lower-level counterparts.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，高级代码并不总是会导致性能上的惩罚。在本节中，我们将探讨循环和模式匹配这两个常见的C#特性，它们使我们能够简洁地表达复杂的C#思想，同时提供与底层代码相当甚至更优的性能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Looping and Iteration</samp>
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">循环和迭代</samp>
- en: In this chapter, we’ve used LINQ in its *fluent syntax* form several times for
    the purposes of creating sequences of objects. LINQ, which has been part of C#
    for many years, will be recognizable to most programmers with more than a passing
    familiarity for the language and its idioms. [Listing 8-23](#list8-23) shows an
    example of using the fluent syntax to create a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已多次使用 LINQ 的*流畅语法*形式来创建对象序列。LINQ 已经成为 C# 的一部分多年，对于大多数对该语言及其习惯用法有一定了解的程序员来说，应该是熟悉的。[清单
    8-23](#list8-23)展示了使用流畅语法创建一个<sup class="SANS_TheSansMonoCd_W5Regular_11">Purchase</sup>对象列表的例子。
- en: '[PRE24]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-23: LINQ fluent syntax</samp>'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-23：LINQ 流畅语法</samp>
- en: LINQ has an alternative *query syntax* that some C# programmers find more agreeable.
    [Listing 8-24](#list8-24) shows the equivalent query syntax for creating the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">items</samp> sequence in [Listing 8-23](#list8-23).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 还有一种替代的*查询语法*，一些 C# 程序员觉得它更加容易使用。[清单 8-24](#list8-24)展示了使用查询语法创建[清单 8-23](#list8-23)中的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">items</sup>序列的等效方式。
- en: '[PRE25]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-24: LINQ query syntax</samp>'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-24：LINQ 查询语法</samp>
- en: 'The compiler generates identical CIL for both [Listings 8-23](#list8-23) and
    [8-24](#list8-24), so the choice between them is primarily driven by which we
    find clearer to read. One optimization is possible, although it can be applied
    only to the fluent version: avoiding the lambda as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method. That lambda needs to capture the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    variable so the compiler will generate a closure object, which results in an extra
    level of indirection to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method. To avoid the closure, we can instead pass <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    as a method group argument, as shown in [Listing 8-25](#list8-25).'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为[清单 8-23](#list8-23)和[8-24](#list8-24)生成相同的 CIL，因此选择哪种方式主要取决于我们认为哪种方式更易读。有一种优化是可能的，但仅适用于流畅语法版本：避免将
    lambda 作为参数传递给<sup class="SANS_TheSansMonoCd_W5Regular_11">Select</sup>方法。该 lambda
    需要捕获<sup class="SANS_TheSansMonoCd_W5Regular_11">i</sup>变量，因此编译器会生成一个闭包对象，这会导致调用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</sup>方法时需要额外的间接层。为了避免闭包，我们可以改为将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</sup>作为方法组参数传递，如[清单 8-25](#list8-25)所示。
- en: '[PRE26]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-25: Optimizing LINQ
    by using a method group</samp>'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-25：通过使用方法组优化 LINQ</samp>
- en: To compare the efficiency of each approach, first we profile the version from
    [Listing 8-23](#list8-23), which uses a lambda. [Table 8-22](#tab8-22) shows the
    report for creating a list of 10 million items.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较每种方法的效率，首先我们分析了来自[清单 8-23](#list8-23)的版本，该版本使用了一个 lambda。表格[8-22](#tab8-22)展示了创建
    1000 万项列表的性能报告。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-22:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    of Creating a Sequence Using LINQ with a Lambda</samp>
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-22：</samp> <samp class="SANS_Futura_Std_Book_11">使用
    LINQ 和 Lambda 创建序列的性能</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">98.1% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">415</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .ToList(IEnumerable)</samp> |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">98.1% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">415</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .ToList(IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">36.0% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">152</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">36.0% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">152</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">31.3%</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><
    Closure>b__3_0</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">132</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><>c.< Closure>b__3_0(Int32)</samp>
    |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">31.3%</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><
    Closure>b__3_0</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">132</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><>c.< Closure>b__3_0(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">31.3% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">132</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">31.3% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">132</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
- en: The identifier name <samp class="SANS_TheSansMonoCd_W5Regular_11"><> c</samp>
    is the closure object the compiler generates to capture the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    variable, and one example of the compiler introducing names that would be illegal
    in our own code. The closure has an instance method, <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    Closure>b__3_0</samp>, which in turn calls our <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method makes two appearances in this report—both inside and outside the closure
    method—as a result of the JIT compiler inlining some calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    Closure>b__3_0</samp> method and calling <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    directly.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符名称 <samp class="SANS_TheSansMonoCd_W5Regular_11"><> c</samp> 是编译器生成的闭包对象，用于捕获
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 变量，这是编译器引入的一个示例，展示了在我们自己的代码中非法的名称。闭包有一个实例方法
    <samp class="SANS_TheSansMonoCd_W5Regular_11">< Closure>b__3_0</samp>，该方法又调用了我们的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> 方法。<samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    方法在本报告中出现了两次——一次是在闭包方法内部，一次是在闭包方法外部——这是由于 JIT 编译器内联了一些对 <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    Closure>b__3_0</samp> 方法的调用，并直接调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>。
- en: The report in [Table 8-23](#tab8-23) shows the performance when using the method
    group approach to create 10 million items.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-23](#tab8-23)中的报告显示了使用方法组方式创建1000万个项目时的性能。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-23:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    of Creating a Sequence Using LINQ with a Method Group</samp>
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-23：</samp> <samp class="SANS_Futura_Std_Book_11">使用方法组通过
    LINQ 创建序列的性能</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">430</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.ToList(IEnumerable)</samp>
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">430</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.ToList(IEnumerable)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">71.9% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">309</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">71.9% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">309</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
- en: Somewhat counterintuitively, the version with the closure object was just slightly
    faster than that with the method group. We shouldn’t read too much into that,
    as the difference is well within the margin for error when comparing runs. However,
    it does tell us that no matter the absolute difference, using a lambda carries
    no significant performance penalty.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有些出乎意料的是，带闭包对象的版本略微比方法组版本更快。我们不应过度解读这一点，因为这个差异在比较多次运行时的误差范围内。然而，这确实告诉我们，无论绝对差异如何，使用
    lambda 表达式不会带来显著的性能损失。
- en: The closure object representing the lambda is created only once for the whole
    expression, not for every element produced for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method. Even though the closure object represents an extra level of indirection
    for each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>,
    the JIT compiler inlines many of the calls to the closure’s <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    Closure>b__3_0</samp> method and either calls <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    directly or inlines its contents too.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 表示lambda的闭包对象只会为整个表达式创建一次，而不是为每个通过<samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>方法生成的元素创建一次。尽管闭包对象为每次调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>提供了一个额外的间接层，但JIT编译器会内联许多对闭包<samp
    class="SANS_TheSansMonoCd_W5Regular_11">< Closure>b__3_0</samp>方法的调用，直接调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>，或者也内联其内容。
- en: We could create a similar sequence in a few other ways. Let’s investigate two
    common approaches to see how their performance compares with using LINQ.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过其他几种方式创建类似的序列。让我们探讨两种常见的方法，看看它们的性能与使用LINQ相比如何。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterator Approach</samp>
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">迭代器方法</samp>
- en: '*Iterators* are a fundamental part of C# and underpin other higher-level features,
    including LINQ. In fact, LINQ has become so ubiquitous in modern C# that it can
    be easy to forget that it’s based on two system interfaces: the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> interface, which is an abstract view of a sequence of elements of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator<
    T ></samp> interface, which represents an iterator that can get each element of
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp> one at
    a time. The basic mechanics are that the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> interface has a single method named <samp class="SANS_TheSansMonoCd_W5Regular_11">GetEnumerator</samp>
    that returns an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator<
    T ></samp>.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代器*是C#的一个基础部分，并且支撑着其他更高层次的功能，包括LINQ。实际上，LINQ已经在现代C#中变得如此普遍，以至于很容易忘记它是基于两个系统接口的：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp>接口，它是类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>的元素序列的抽象视图，以及<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< T ></samp>接口，它表示一个可以逐个获取<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp>元素的迭代器。基本原理是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp>接口有一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">GetEnumerator</samp>的方法，它返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< T ></samp>的实现。'
- en: Both interfaces are largely hidden in modern code, although <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> remains important as the protocol for types that represent sequences
    and as the home of the extension methods, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Where</samp>, that make up most
    of the LINQ system.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个接口在现代代码中大多被隐藏，但<samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp>仍然是代表序列的类型协议的重要组成部分，并且是扩展方法的“家”，如<samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Where</samp>，这些方法构成了LINQ系统的大部分。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< T ></samp> interface
    also forms the basis for the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    loop, which is one way of enumerating the elements of a sequence that implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp>. In [Listing
    8-26](#list8-26), we write our own simple <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    method, which allows us to record its performance for comparison with the LINQ
    equivalents. Our <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> uses
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> to populate a list
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects and therefore
    depends on the iterator provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>
    method.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< T ></samp> 接口也是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> 循环的基础，这是枚举实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> 序列元素的一种方式。在 [Listing 8-26](#list8-26) 中，我们编写了一个简单的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    方法，允许我们记录其性能，并与 LINQ 版本进行对比。我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> 填充一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    对象的列表，因此它依赖于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>
    方法提供的迭代器。
- en: '[PRE27]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-26: Populating a
    list using foreach</samp>'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-26: 使用 foreach 填充列表</samp>'
- en: Comparing our <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> method
    with the LINQ version in [Listing 8-23](#list8-23), the first thing to notice
    is that we need to declare the target list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects before the loop. The <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    loop obtains an <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< int></samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>, and
    the body of the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> block
    is run for each element in the iterator. We can see the basic mechanics when we
    look at the profiler’s report for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    method in [Table 8-24](#tab8-24).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 比较我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> 方法和 LINQ 版本的
    [Listing 8-23](#list8-23)，首先需要注意的是，在循环之前我们需要声明目标的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    对象列表。<samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> 循环从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>
    获取一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< int></samp>，并且
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> 块的主体会针对迭代器中的每个元素运行。当我们查看
    [Table 8-24](#tab8-24) 中 <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    方法的分析报告时，我们可以看到基本的机制。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-24:</samp> <samp class="SANS_Futura_Std_Book_11">Profiling
    the Iterator Approach</samp>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-24:</samp> <samp class="SANS_Futura_Std_Book_11">分析迭代器方法</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">638</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">638</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">41.2% AddWithResize</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">263</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.List`1
    .AddWithResize(T)</samp> |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">41.2% AddWithResize</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">263</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.List`1
    .AddWithResize(T)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">38.1% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">243</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">38.1% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">243</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.95% MoveNext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+RangeIterator
    .MoveNext()</samp> |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.95% MoveNext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+RangeIterator
    .MoveNext()</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.95% get_Current</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+Iterator`1
    .get_Current()</samp> |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.95% get_Current</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+Iterator`1
    .get_Current()</samp> |'
- en: This profile report shows the workings of the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    construct; the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Current</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MoveNext</samp> methods belong
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< T ></samp> interface
    and, as their names suggest, allow us to obtain the current element and move the
    iterator to the next item in the sequence.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这个性能报告展示了<samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>结构的工作原理；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_Current</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">MoveNext</samp>方法属于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< T ></samp>接口，正如它们的名字所示，它们允许我们获取当前元素并将迭代器移动到序列中的下一个项。
- en: 'This report also shows that our handcrafted <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    is considerably slower than the LINQ version reported in [Table 8-22](#tab8-22),
    but we haven’t made optimal use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    Purchase></samp> facilities. Since we know in advance the number of items we need,
    we can avoid most of the expense of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddWithResize</samp>
    method and specify the list’s capacity in the constructor call like this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这个报告还显示，我们手动实现的<samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>比在[表
    8-22](#tab8-22)中报告的LINQ版本要慢得多，但我们并没有充分利用<samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    Purchase></samp>的功能。因为我们提前知道需要的项数，我们可以避免大部分<samp class="SANS_TheSansMonoCd_W5Regular_11">AddWithResize</samp>方法的开销，并在构造函数调用中像这样指定列表的容量：
- en: '[PRE28]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By explicitly requesting a capacity, we allocate enough memory for <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    items before adding new elements so that the list won’t need resizing when it
    runs out of space. If we rerun our profile test, as [Table 8-25](#tab8-25) shows,
    it’s much more in line with the previous tests.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 通过显式请求容量，我们在添加新元素之前为<samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>个项分配足够的内存，这样列表在空间不足时就无需重新调整大小。如果我们重新运行性能测试，如[表
    8-25](#tab8-25)所示，它与之前的测试结果更加一致。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-25:</samp> <samp class="SANS_Futura_Std_Book_11">Preallocating
    a List’s Capacity</samp>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-25:</samp> <samp class="SANS_Futura_Std_Book_11">预分配列表的容量</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">426</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">426</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">63.0% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">268</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">63.0% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">268</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4.28% MoveNext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+RangeIterator
    .MoveNext()</samp> |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4.28% MoveNext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+RangeIterator
    .MoveNext()</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% get_Current</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+Iterator`1
    .get_Current()</samp> |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% get_Current</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+Iterator`1
    .get_Current()</samp> |'
- en: 'Our tests demonstrate that using LINQ, at least for the reasonably simple task
    of generating a sequence of elements, is at least as efficient as using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop. We can try one other
    approach, however: the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试表明，使用 LINQ，至少在生成元素序列这一相对简单的任务中，其效率至少与使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    循环一样。然而，我们可以尝试另一种方法：<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Loop Approach</samp>
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">循环方法</samp>
- en: Our method of creating a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects is based on creating a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    values and translating them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method into a new sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects. [Listing 8-27](#list8-27) shows how we achieve the same result with a
    basic <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, which doesn’t
    rely on iterators and merely runs the body of the loop the number of times specified
    in the loop condition.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 对象的方式是基于创建一系列
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 值，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    方法将其转换为一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 对象序列。[清单
    8-27](#list8-27) 展示了如何使用基本的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环实现相同的结果，该循环不依赖于迭代器，而仅仅是根据循环条件指定的次数执行循环体。
- en: '[PRE29]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-27: Using a simple
    for loop</samp>'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-27：使用简单的 for 循环</samp>
- en: As we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    loop, we must create the target <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    Purchase></samp> before entering the loop, and we use the constructor to set its
    capacity. In the loop’s body, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method to add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    as we have previously. [Table 8-26](#tab8-26) shows the profiler report for creating
    a list of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects with the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> 循环时一样，我们必须在进入循环之前创建目标
    <samp class="SANS_TheSansMonoCd_W5Regular_11">List< Purchase></samp>，并使用构造函数设置其容量。在循环体内，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> 方法来添加新的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>，就像我们之前那样。[表 8-26](#tab8-26)
    展示了使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环创建 1000 万个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 对象的性能报告。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-26:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Direct</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> <samp class="SANS_Futura_Std_Book_11">Loop
    Performance</samp>
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-26：</samp> <samp class="SANS_Futura_Std_Book_11">直接</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> <samp class="SANS_Futura_Std_Book_11">循环性能</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">417</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">417</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">67.3% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">281</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">67.3% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">281</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.70% op_Implicit</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">24</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.op_Implicit(Int32)</samp>
    |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.70% op_Implicit</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">24</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.op_Implicit(Int32)</samp>
    |'
- en: 'Once again, there’s no significant difference between the performance of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop approach and that
    of the other approaches we’ve tried. The main difference between using LINQ and
    using either the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is one of style:
    the LINQ code is more direct and allows us to express our intent declaratively,
    whereas the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loops are more procedural.
    The LINQ expression allows us to focus on the outcome we require, whereas both
    looping approaches focus on the steps or instructions to follow.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环方法和我们尝试过的其他方法在性能上没有显著差异。使用LINQ与使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环的主要区别在于风格：LINQ代码更直接，使我们能够声明性地表达意图，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>循环则更加过程化。LINQ表达式让我们关注所需的结果，而循环方式则更多关注执行的步骤或指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pattern Matching
    and Selection</samp>
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">模式匹配与选择</samp>
- en: One common benefit of a declarative rather than procedural style is that we
    write less code to achieve the same result. While this saves on the amount of
    typing we do, that is just a side effect. The real benefit comes from having less
    syntax for a human reader to comprehend. Replacing explicit loops with LINQ-style
    functional expressions is one example. Many of the LINQ expressions are based
    on loops internally, but the loop constructs themselves are hidden from user code.
    Manually iterating sequences with loops and explicit conditions can be prone to
    errors, and complex loop constructs are generally harder for a human reader to
    follow than a call to a method like <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程风格相比过程式编程风格的一个常见好处是，我们能够通过更少的代码实现相同的结果。虽然这节省了我们输入的量，但这只是一个副作用。真正的好处在于对于人类读者来说，语法更简洁易懂。用LINQ风格的函数表达式替代显式的循环就是一个例子。虽然许多LINQ表达式在内部基于循环，但循环结构本身对于用户代码是隐藏的。手动用循环和显式条件遍历序列容易出错，而且复杂的循环结构通常比像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>这样的函数调用更难被人类读者理解。
- en: 'The other common application of declarative techniques is in selection code:
    replacing <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements with pattern-matching expressions.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式技术的另一个常见应用是选择代码：用模式匹配表达式替代<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句。
- en: Consider the constructor in [Listing 8-28](#list8-28), which validates the parameter
    value by matching it against the rules specified by some patterns.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下[示例8-28](#list8-28)中的构造函数，它通过将参数值与某些模式指定的规则进行匹配来验证参数值。
- en: '[PRE30]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-28: Pattern matching
    for validation</samp>'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例8-28：用于验证的模式匹配</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp> constructor
    throws an exception if the argument given is <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp>
    and also prohibits values that are less than <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroKelvin</samp>
    or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">PositiveInfinity</samp>.
    Values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">celsius</samp> parameter
    that don’t match either of those rules are assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    field by the discard pattern, which is the final pattern in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入的参数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp>，则 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp> 构造函数会抛出异常，并且禁止小于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroKelvin</samp> 或等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">PositiveInfinity</samp>
    的值。对于不符合这些规则的 <samp class="SANS_TheSansMonoCd_W5Regular_11">celsius</samp> 参数值，会通过丢弃模式将其分配给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> 字段，这个模式是 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    表达式中的最后一个模式。
- en: Compare [Listing 8-28](#list8-28) with [Listing 8-29](#list8-29), which achieves
    exactly the same outcome but uses <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp>
    statements to test the incoming parameter value.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 比较 [Listing 8-28](#list8-28) 和 [Listing 8-29](#list8-29)，后者实现了完全相同的结果，但使用了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> 语句来测试传入的参数值。
- en: '[PRE31]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-29: Chaining if and
    else for validation</samp>'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-29: 链接 if 和 else
    进行验证</samp>'
- en: We could make this code less syntax-heavy by removing the redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statements and allowing the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    blocks to fall through if the value doesn’t meet the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    condition. While doing so would make the code shorter, it’s more error-prone if
    new conditions are added.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除冗余的 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 语句，允许
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 块在值不符合 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    条件时继续执行，从而使这段代码不那么繁琐。虽然这样会缩短代码，但如果添加新条件时，它会变得更容易出错。
- en: Another alternative is to use a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement, as shown in [Listing 8-30](#list8-30).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句，如 [Listing
    8-30](#list8-30) 所示。
- en: '[PRE32]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-30: Using a switch
    statement for validation</samp>'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-30: 使用 switch 语句进行验证</samp>'
- en: This version is closer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression in [Listing 8-28](#list8-28), and the two forms of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    can be easily confused. The principal difference is that here we assign the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> field as part of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">default</samp> leg, whereas in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expression, the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    field is assigned the value of the whole expression.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更接近于 [Listing 8-28](#list8-28) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    表达式，且这两种形式的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 容易混淆。主要的区别在于，在这里我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> 字段作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    分支的一部分进行赋值，而在 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 表达式中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> 字段的值是整个表达式的结果。
- en: In a departure from the rest of this chapter, we don’t need to run a performance
    profile to compare [Listings 8-28](#list8-28) through [8-30](#list8-30) because
    the compiler produces almost identical code for each—broadly, the same code as
    shown in [Listing 8-29](#list8-29). The compiler may change the order of the conditions
    in the CIL, but that doesn’t change the logic in any way.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章其他部分不同的是，我们无需运行性能分析来比较 [Listings 8-28](#list8-28) 和 [8-30](#list8-30)，因为编译器为每种情况生成的代码几乎完全相同——大致上与
    [Listing 8-29](#list8-29) 中显示的代码相同。编译器可能会改变 CIL 中条件的顺序，但这不会改变逻辑。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: '*We do not consider it as good engineering practice to consume a resource lavishly
    just because it happens to be cheap.*'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们认为，单纯因为资源便宜而过度消耗资源并不是一种好的工程实践。*'
- en: ''
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—Niklaus Wirth, *Project Oberon: The Design of an Operating System, a Compiler,
    and a Computer*'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —尼克劳斯·维尔特，《*奥伯龙计划：操作系统、编译器和计算机的设计*》
- en: Code optimized by hand is often harder for a human reader to follow, usually
    because it frequently involves replacing simple idioms, such as loops and pattern
    matching, with lower-level constructs. When a program runs more slowly than we
    think it should, it can be tempting to dive straight in and change the parts of
    the code we suspect are bottlenecks. Programmers’ optimization instincts are,
    however, notoriously unreliable. We’re likely to make our code more difficult
    to read while failing to improve performance in any meaningful way.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 手动优化的代码通常更难为人类读者理解，通常是因为它常常涉及将简单的习惯用法，如循环和模式匹配，替换为更低级的构造。当一个程序运行速度比我们预期的要慢时，我们很容易冲动地直接修改我们怀疑是瓶颈的代码部分。然而，程序员的优化直觉通常并不可靠。我们可能会让代码变得更加难以阅读，却未能以任何有意义的方式提高性能。
- en: Optimizing code by hand is almost always an exercise in exchanging clarity and
    simplicity for performance. We can judge whether this is a reasonable trade only
    by measuring the performance before and after the change. Even when we improve
    performance in a section of code, we must still decide whether we’ve made the
    code less clear and, if so, whether the change is justified. We must also be certain
    that our optimizations haven’t changed the program’s behavior in any way. Slow,
    correct code is always preferable to incorrect code, however good its performance.
    That’s not to say that good enough can’t be correct—frequently a compromise is
    necessary between performance and accuracy or precision—but we need to know the
    point at which inaccurate really does mean incorrect.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 手动优化代码几乎总是将清晰性和简洁性换取性能的过程。我们只能通过在变更前后测量性能，来判断这种交换是否合理。即便我们在某段代码中提高了性能，我们仍然需要判断是否使代码变得不那么清晰，若是如此，这个改动是否合理。我们还必须确信我们的优化没有以任何方式改变程序的行为。慢而正确的代码总是优于错误的代码，无论其性能如何。这并不是说“足够好”就不能是正确的——通常在性能与准确性或精度之间需要做出妥协——但我们必须知道不准确究竟意味着什么程度的错误。
- en: The use of well-known idioms and patterns helps human readers easily understand
    code. Correspondingly, when we depart from those common designs, we make our code
    harder to follow. Therefore, we must be selective in applying optimizations to
    the areas of code that will bring the greatest benefits.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 使用众所周知的习惯用法和模式有助于人类读者轻松理解代码。因此，当我们偏离这些常见设计时，我们的代码也会变得更难理解。因此，我们必须在优化代码时有选择地针对那些能够带来最大效益的区域。
- en: Overriding the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    isn’t difficult for the vast majority of types, but it adds an implementation
    detail that represents extra cognitive overhead for anyone who needs to *understand*
    our code.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 的行为对大多数类型来说并不困难，但它增加了一个实现细节，这对任何需要*理解*我们代码的人来说，都是额外的认知负担。
- en: Using records to represent value-like types removes much of that added complexity
    because the compiler generates the correct implementations for us. However, even
    accepting that default behavior won’t necessarily yield the most efficient code.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记录类型来表示值类型可以去除许多附加的复杂性，因为编译器会为我们生成正确的实现。然而，即便接受这种默认行为，也不一定会产生最有效的代码。
- en: Careful code optimization, supported by evidence from a profiler, can yield
    better performance in both speed *and* memory use. Modern computers are fast and
    usually have more than enough memory, but that doesn’t mean we should waste either
    resource.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 精心的代码优化，结合分析器提供的证据，可以在速度*和*内存使用方面带来更好的性能。现代计算机速度很快，通常内存也足够，但这并不意味着我们可以浪费任何一种资源。
