- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: An Introduction to WebAssembly
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly简介
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll acquire background knowledge of WebAssembly and explore
    the tools you’ll need to start working with WebAssembly and its textual representation,
    WebAssembly Text (WAT). We’ll discuss the benefits of WebAssembly, including improved
    performance, legacy library integration, portability, security, and its use as
    an alternative to JavaScript. We’ll consider JavaScript’s relationship with WebAssembly
    and what WebAssembly is and isn’t. You’ll learn the WAT inline and S-expression
    syntax. We’ll introduce the concepts of the embedding environment and discuss
    embedding WebAssembly in web browsers, Node.js, and the WebAssembly System Interface
    (WASI).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将获得WebAssembly的背景知识，并探索开始使用WebAssembly及其文本表示WebAssembly Text (WAT)所需的工具。我们将讨论WebAssembly的好处，包括提升性能、旧版库集成、可移植性、安全性，以及它作为JavaScript替代品的应用。我们将考虑JavaScript与WebAssembly的关系，并阐明WebAssembly是什么以及不是什么。你将学习WAT内联和S表达式语法。我们将介绍嵌入环境的概念，并讨论如何在网页浏览器、Node.js和WebAssembly系统接口（WASI）中嵌入WebAssembly。
- en: Then we’ll discuss the benefits of using Visual Studio Code as a development
    environment for WAT. You’ll learn the basics of Node.js and how to use it as an
    embedding environment for WebAssembly. We’ll show you how to use npm to install
    the wat-wasm tool, which provides you with everything you need to build WebAssembly
    applications from WAT. In addition, we’ll write our first WebAssembly app and
    execute it with Node.js as the embedding environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将讨论使用Visual Studio Code作为WAT开发环境的好处。你将学习Node.js的基础知识，以及如何将其用作WebAssembly的嵌入环境。我们将展示如何使用npm安装wat-wasm工具，它为你提供了从WAT构建WebAssembly应用程序所需的一切。此外，我们还将编写第一个WebAssembly应用程序，并使用Node.js作为嵌入环境执行它。
- en: What Is WebAssembly?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是WebAssembly？
- en: WebAssembly is a technology that will massively improve the performance of web
    applications over the next several years. Because WebAssembly is new and requires
    some explanation, many people misunderstand it and how to use it. This book teaches
    you what WebAssembly is and how to use it to make high-performing web applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly是一项技术，将在未来几年大幅提升网页应用程序的性能。由于WebAssembly是新技术，并且需要一定的解释，许多人对它及其使用方法存在误解。本书将教你WebAssembly是什么，以及如何使用它来构建高性能的网页应用程序。
- en: '*WebAssembly* is a virtual *Instruction Set Architecture (ISA)* for a stack
    machine. Generally, an ISA is a binary format designed to execute on a specific
    machine. However, WebAssembly is designed to run on a *virtual* machine, meaning
    it’s not designed for physical hardware. The virtual machine allows WebAssembly
    to run on a variety of computer hardware and digital devices. The WebAssembly
    ISA was designed to be compact, portable, and secure, with small binary files
    to reduce download times when deployed as part of a web application. It’s easy
    to port the bytecode to a variety of computer hardware, and it has a secure platform
    for deploying code over the web.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*WebAssembly*是一个虚拟的*指令集架构（ISA）*，用于栈机器。通常，ISA是一种为特定机器设计的二进制格式。然而，WebAssembly是为运行在*虚拟*机器上而设计的，这意味着它并不是为物理硬件设计的。虚拟机器使得WebAssembly能够在多种计算机硬件和数字设备上运行。WebAssembly的ISA旨在紧凑、可移植且安全，具有小巧的二进制文件，以减少作为网页应用程序一部分进行部署时的下载时间。它容易将字节码移植到多种计算机硬件，并提供一个安全的平台来通过网络部署代码。'
- en: All major browser vendors have adopted WebAssembly. According to the Mozilla
    Foundation, WebAssembly code runs between 10 percent and 800 percent faster than
    the equivalent JavaScript code. One eBay WebAssembly project executed 50 times
    faster than the original JavaScript version. Later in the book we’ll build a collision
    detection program that we can use to measure performance. When we ran it, our
    performance benchmarking found that our WebAssembly collision detection code ran
    more than four times faster than JavaScript in Chrome and more than two times
    faster than JavaScript in Firefox.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要浏览器厂商都已经采用了WebAssembly。根据Mozilla基金会的说法，WebAssembly代码的执行速度比等效的JavaScript代码快10%到800%。一个eBay的WebAssembly项目比原始的JavaScript版本执行速度快了50倍。在本书后续内容中，我们将构建一个碰撞检测程序，用于衡量性能。我们运行它时，性能基准测试发现我们的WebAssembly碰撞检测代码在Chrome中运行速度比JavaScript快了四倍多，在Firefox中则比JavaScript快了两倍多。
- en: WebAssembly offers the most significant performance improvement the web has
    seen since the introduction of the just-in-time (JIT) JavaScript compilers. Modern
    browser JavaScript engines can parse and download the WebAssembly binary format
    an order of magnitude faster than JavaScript. The fact that WebAssembly is a binary
    target, not a programming language like JavaScript, allows the developer to choose
    the programming language that best suits their application’s needs. The saying
    “JavaScript is the assembly language of the web” might have become fashionable
    recently, but the JavaScript format is a terrible compilation target. Not only
    is JavaScript less efficient than a binary format like WebAssembly, but any JavaScript
    target code also has to handle the specifics of the JavaScript language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 提供了自引入即时编译（JIT）JavaScript 编译器以来，网页性能上最显著的提升。现代浏览器的 JavaScript 引擎能比
    JavaScript 快一个数量级地解析和下载 WebAssembly 二进制格式。WebAssembly 作为一个二进制目标，而不是像 JavaScript
    这样的编程语言，允许开发者选择最适合其应用需求的编程语言。最近流行的说法“JavaScript 是网页的汇编语言”或许变得时髦，但 JavaScript 格式是一个糟糕的编译目标。JavaScript
    不仅效率不如像 WebAssembly 这样的二进制格式，而且任何 JavaScript 目标代码还必须处理 JavaScript 语言的细节。
- en: WebAssembly offers tremendous web application performance improvements in two
    areas. One is startup speed. Currently, the most compact JavaScript format is
    minified JavaScript, which improves application download sizes but must parse,
    interpret, JIT compile, and optimize the JavaScript code. These steps are unnecessary
    with a WebAssembly binary, which is also more compact. WebAssembly still needs
    to be parsed, but it’s faster because it’s a bytecode format rather than text.
    Web engines still do optimization passes on WebAssembly, but it’s much faster
    because the language is more cleanly designed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 在两个领域提供了巨大的网页应用性能提升。其中之一是启动速度。目前，最紧凑的 JavaScript 格式是最小化的 JavaScript，它提高了应用程序的下载大小，但必须解析、解释、JIT
    编译并优化 JavaScript 代码。这些步骤在 WebAssembly 二进制格式中是多余的，WebAssembly 也更紧凑。WebAssembly
    仍然需要解析，但它的速度更快，因为它是字节码格式而非文本格式。Web 引擎仍然会对 WebAssembly 进行优化，但速度要快得多，因为这种语言设计得更为简洁。
- en: The other significant performance improvement WebAssembly offers is in throughput.
    WebAssembly makes it easier for the browser engine to optimize. JavaScript is
    a highly dynamic and flexible programming language, which is helpful to a JavaScript
    developer, but creates a code optimization nightmare. WebAssembly doesn’t make
    any web-specific assumptions (despite its name) and can be used beyond the browser.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 提供的另一个显著的性能提升体现在吞吐量上。WebAssembly 使得浏览器引擎更容易进行优化。JavaScript 是一种高度动态且灵活的编程语言，这对
    JavaScript 开发者来说非常有帮助，但却会带来代码优化的噩梦。WebAssembly 不做任何网页特定的假设（尽管它的名字如此），并且可以在浏览器之外使用。
- en: Eventually, WebAssembly might be able to do everything JavaScript can. Unfortunately,
    the current version, its MVP (Minimum Viable Product) release version 1.0, cannot.
    In the MVP release, WebAssembly can do certain tasks very well. It’s not intended
    to be a drop-in replacement for JavaScript or a framework, such as Angular, React,
    or Vue. If you want to work with WebAssembly right now, you should have a specific
    computationally intensive project that requires very high performance. Online
    games, WebVR, 3D math, and crypto are effective ways people currently use WebAssembly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，WebAssembly 可能能够做 JavaScript 能做的一切。不幸的是，目前的版本——其 MVP（最小可行产品）版本 1.0——做不到。在
    MVP 版本中，WebAssembly 可以很好地完成某些任务。它并不是为了成为 JavaScript 或像 Angular、React 或 Vue 这样的框架的直接替代品。如果你现在想使用
    WebAssembly，你应该有一个需要非常高性能的特定计算密集型项目。在线游戏、WebVR、3D 数学和加密是人们目前使用 WebAssembly 的有效方式。
- en: Reasons to Use WebAssembly
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 WebAssembly 的理由
- en: Before we take a closer look at WebAssembly, let’s consider a few reasons you
    might be interested in using it. These explanations should also give you an idea
    of what WebAssembly is and why and how to use it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更深入地了解 WebAssembly 之前，先来看看你可能对使用它感兴趣的几个理由。这些解释还应该能帮助你理解 WebAssembly 是什么，以及为什么和如何使用它。
- en: Better Performance
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好的性能
- en: JavaScript requires software engineers to make choices that will affect how
    they design the JavaScript engine. For example, you can optimize a JavaScript
    engine for peak performance using a JIT optimizing compiler, which can execute
    code faster but requires more startup time. Alternatively, you can use an interpreter,
    which starts running code right away but won’t reach the peak performance of a
    JIT optimizing compiler. The solution most JavaScript engine designers use in
    their web browsers is to implement both, but that requires a much larger memory
    footprint. Every decision you make is a trade-off.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 要求软件工程师做出会影响 JavaScript 引擎设计的选择。例如，你可以使用 JIT 优化编译器来优化 JavaScript
    引擎的峰值性能，这可以使代码执行更快，但需要更多的启动时间。或者，你可以使用解释器，它可以立即开始执行代码，但无法达到 JIT 优化编译器的峰值性能。大多数
    JavaScript 引擎设计师在他们的 Web 浏览器中使用的解决方案是同时实现这两者，但这需要更大的内存占用。你做的每一个决策都是一个权衡。
- en: WebAssembly allows for a faster startup time and higher peak performance without
    all of the memory bloat. Unfortunately, you can’t just rewrite your JavaScript
    in AssemblyScript, Rust, or C++ and expect this to happen without a little extra
    work. WebAssembly isn’t magic, and merely porting JavaScript to another language
    and compiling it without understanding what WebAssembly is doing at a lower level
    can lead to some disappointing results. Writing C++ code and compiling it to WebAssembly
    using optimization flags will usually be a bit faster than JavaScript. Occasionally,
    programmers will complain that they’ve spent all day rewriting their app in C++
    and it only runs 10 percent faster. If that’s the case, it’s likely that these
    apps wouldn’t benefit from converting to WebAssembly, and their C++ gets compiled
    into mostly JavaScript. Take the time to learn WebAssembly, not C++, and make
    your web applications run lightning fast.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 允许更快的启动时间和更高的峰值性能，同时避免了过多的内存膨胀。不幸的是，你不能仅仅将 JavaScript 重新编写为 AssemblyScript、Rust
    或 C++，然后期待它会发生这种情况，而不做一些额外的工作。WebAssembly 不是魔法，单纯地将 JavaScript 移植到另一种语言并编译它，而不了解
    WebAssembly 在更低层次上是如何工作的，可能会导致一些令人失望的结果。编写 C++ 代码并使用优化标志将其编译为 WebAssembly 通常会比
    JavaScript 稍微快一些。偶尔，程序员会抱怨他们整整一天都在用 C++ 重写应用程序，结果它只比原来快了 10%。如果是这种情况，可能这些应用程序并不会从转向
    WebAssembly 中受益，它们的 C++ 最终会被编译成大部分的 JavaScript。花时间学习 WebAssembly，而不是 C++，让你的 Web
    应用程序运行得飞快。
- en: Integrating Legacy Libraries
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成遗留库
- en: Two popular libraries for porting existing libraries to WebAssembly are *wasm-pack*
    for Rust and *Emscripten* for C/C++. Using WebAssembly is ideal for when you have
    existing code written in C/C++ or Rust that you want to make available to web
    applications, or want to port entire existing desktop applications to make them
    available on the web. The Emscripten toolchain is particularly efficient at porting
    existing C++ desktop applications to the web using WebAssembly. If this is your
    path, you’ll likely want your app to perform as closely as possible to the native
    speed of your existing application, which should be feasible as long as the application
    isn’t a resource hog. However, you might also have an app that needs performance
    tuning to make it run as it does on the desktop. By the end of this book, you’ll
    be able to evaluate the WebAssembly module your toolchain generates from your
    existing code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个流行的库用于将现有库移植到 WebAssembly，它们分别是 Rust 的 *wasm-pack* 和 C/C++ 的 *Emscripten*。使用
    WebAssembly 非常适合当你有现有的 C/C++ 或 Rust 编写的代码，想要将其提供给 Web 应用程序，或是想将整个现有的桌面应用程序移植到
    Web 上。如果你选择这条路径，Emscripten 工具链特别适合将现有的 C++ 桌面应用程序移植到 Web 上并使用 WebAssembly。 如果这是你的选择，你可能希望你的应用程序在性能上尽可能接近原生应用的速度，只要应用程序不是资源消耗过大的话，这应该是可行的。然而，你也可能有一个需要性能调优的应用程序，使其在
    Web 上的表现接近桌面版的效果。在本书结束时，你将能够评估你的工具链从现有代码生成的 WebAssembly 模块。
- en: Portability and Security
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可移植性和安全性
- en: We combined the portability and security features into one section because they
    frequently go together. WebAssembly started as a technology to run in the browser
    but is quickly expanding to become a sandboxed environment to run anywhere. From
    server-side WASI code to WebAssembly for embedded systems and the internet of
    things (IoT), the WebAssembly working group is creating a highly secure runtime
    that prevents bad actors from compromising your code. I recommend listening to
    Lin Clark’s excellent talk about WebAssembly security and package reuse at the
    first WebAssembly Summit ([https://www.youtube.com/watch?v=IBZFJzGnBoU/](https://www.youtube.com/watch?v=IBZFJzGnBoU/)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将便携性和安全性特性合并到一个部分，因为它们通常是一起出现的。WebAssembly 起初是为了在浏览器中运行的技术，但它正在迅速扩展，成为一个可以在任何地方运行的沙盒环境。从服务器端的
    WASI 代码到 WebAssembly 在嵌入式系统和物联网（IoT）中的应用，WebAssembly 工作组正在创建一个高度安全的运行时环境，防止恶意行为者破坏你的代码。我推荐你收听
    Lin Clark 在第一次 WebAssembly Summit 上关于 WebAssembly 安全性和包重用的精彩演讲（[https://www.youtube.com/watch?v=IBZFJzGnBoU/](https://www.youtube.com/watch?v=IBZFJzGnBoU/)）。
- en: Even though the WebAssembly working group focuses on security, no system is
    entirely secure. Learning to understand WebAssembly at a low level will prepare
    you for any future security risks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 WebAssembly 工作组专注于安全性，但没有任何系统是完全安全的。学习从低层次理解 WebAssembly 将帮助你为未来的安全风险做好准备。
- en: JavaScript Skeptics
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 怀疑论者
- en: Some people simply dislike JavaScript and would rather that JavaScript not be
    the dominant web programming language. Unfortunately, WebAssembly isn’t in a position
    to dethrone JavaScript. Today, JavaScript and WebAssembly must coexist and play
    well together, as shown in [Figure 1-1](#figure1-1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人简单地不喜欢 JavaScript，希望 JavaScript 不是主流的 Web 编程语言。不幸的是，WebAssembly 并没有能力推翻 JavaScript。今天，JavaScript
    和 WebAssembly 必须共存，并且能够良好配合，如 [图 1-1](#figure1-1) 所示。
- en: 'But there is good news for the JavaScript skeptics in the world: WebAssembly
    toolchains offer many options for writing web applications without having to write
    JavaScript. For example, Emscripten allows you to write web applications in C/C++
    with very little, if any, JavaScript. You can also write entire web applications
    using Rust and wasm-pack. Not only do these toolchains generate WebAssembly, but
    they also create copious JavaScript glue code for your application. The reason
    is that currently, there are limits to WebAssembly’s capabilities, and the toolchains
    fill these gaps with JavaScript code. The beauty of mature toolchains like Emscripten
    is that they do this for you. If you’re developing with one of these toolchains,
    it’s helpful to understand when your code will turn into WebAssembly and when
    it will be JavaScript. This book helps you know when this will happen.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但是对于世界上的 JavaScript 怀疑论者来说，还是有好消息的：WebAssembly 工具链提供了许多选项，让你能够在不写 JavaScript
    的情况下编写 Web 应用程序。例如，Emscripten 允许你用 C/C++ 编写 Web 应用程序，几乎不需要，甚至完全不需要 JavaScript。你还可以使用
    Rust 和 wasm-pack 编写完整的 Web 应用程序。这些工具链不仅生成 WebAssembly，还为你的应用程序生成大量的 JavaScript
    配套代码。原因是，目前 WebAssembly 的能力有限，工具链用 JavaScript 代码填补这些空白。像 Emscripten 这样的成熟工具链的优点就是，它们为你做了这些。如果你正在使用这些工具链开发，了解你的代码何时会转化为
    WebAssembly，何时会是 JavaScript，是很有帮助的。这本书将帮助你了解什么时候会发生这种情况。
- en: '![f01001](Images/f01001.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![f01001](Images/f01001.png)'
- en: 'Figure 1-1: JavaScript and WebAssembly can coexist in harmony.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：JavaScript 和 WebAssembly 可以和谐共存。
- en: WebAssembly’s Relationship with JavaScript
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebAssembly 与 JavaScript 的关系
- en: 'It’s important to clarify how WebAssembly is used with and compares to JavaScript.
    WebAssembly isn’t a direct replacement for JavaScript; rather, WebAssembly:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 澄清 WebAssembly 如何与 JavaScript 一起使用并进行比较非常重要。WebAssembly 并不是 JavaScript 的直接替代品；相反，WebAssembly：
- en: Is faster to download, compile, and execute
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载、编译和执行速度更快
- en: Allows you to write applications for the web in languages other than JavaScript
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你使用除了 JavaScript 之外的其他语言编写 Web 应用程序
- en: Can provide near-native speed for your application when used properly
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当正确使用时，可以为你的应用程序提供接近本地的速度
- en: Works *with* JavaScript to improve the performance of your web applications
    when appropriately used
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当使用时，*与* JavaScript 一起工作，可以提高你的 Web 应用程序的性能
- en: Isn’t an assembly language, although there is a pseudo assembly language associated
    with it (WAT)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是一种汇编语言，尽管它有一个与之相关的伪汇编语言（WAT）
- en: Isn’t only for the web but can execute from non-browser JavasScript engines,
    such as Node.js, or can execute using runtimes that implement the WASI
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅仅适用于 Web，还可以从非浏览器 JavaScript 引擎（如 Node.js）执行，或者使用实现了 WASI 的运行时执行
- en: Isn’t yet a one-size-fits-all solution for creating web applications
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前还没有一种适用于所有情况的解决方案来创建 Web 应用程序
- en: WebAssembly is the result of all major browser vendors collaborating to create
    a new platform for distributing applications over the internet. The JavaScript
    language evolved from the needs of web browsers in the late 1990s to the mature
    scripting language it is today. Although JavaScript has become a reasonably fast
    language, web developers have noticed that it sometimes performs inconsistently.
    WebAssembly is a solution to many of the performance problems associated with
    JavaScript.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 是所有主要浏览器厂商合作的结果，旨在创建一个新的平台，用于通过互联网分发应用程序。JavaScript 语言源于 1990 年代末期对
    web 浏览器的需求，发展成今天成熟的脚本语言。尽管 JavaScript 已经成为一种相对快速的语言，web 开发者们注意到它有时表现得不稳定。WebAssembly
    是解决 JavaScript 性能问题的一个方案。
- en: Even though WebAssembly can’t do everything JavaScript can, it can execute certain
    operations much faster than JavaScript while consuming less memory. Throughout
    this book, we compare JavaScript code with the corresponding WebAssembly. We’ll
    repeatedly benchmark and profile the code for comparison. By the end of this book,
    you’ll be able to judge when you should use WebAssembly and when it makes sense
    to continue using JavaScript.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 WebAssembly 无法完成 JavaScript 所能做的所有事情，但它能够在执行某些操作时，比 JavaScript 更快且消耗更少的内存。本书中，我们将对比
    JavaScript 代码与对应的 WebAssembly。我们将反复进行基准测试和性能分析进行比较。在本书的结尾，你将能够判断什么时候应该使用 WebAssembly，什么时候继续使用
    JavaScript 更为合适。
- en: Why Learn WAT?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要学习 WAT？
- en: Many WebAssembly books and tutorials focus on specific toolchains, such as the
    aforementioned wasm-pack for Rust or Emscripten for C/C++. Toolchains for other
    languages like AssemblyScript (a subset of TypeScript) and Go are currently in
    development. These toolchains are a major reason programmers turn to WebAssembly,
    and more WebAssembly language toolchains are continually becoming available. In
    the future, web developers will be able to choose the language they use to develop
    based on project needs rather than language availability.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 WebAssembly 书籍和教程专注于特定的工具链，例如上述的用于 Rust 的 wasm-pack 或用于 C/C++ 的 Emscripten。其他语言的工具链，如
    AssemblyScript（TypeScript 的一个子集）和 Go，目前正在开发中。这些工具链是程序员转向 WebAssembly 的一个主要原因，越来越多的
    WebAssembly 语言工具链不断涌现。未来，web 开发者将能够根据项目需求而非语言可用性来选择开发语言。
- en: One factor that is useful across any of these languages is understanding what
    WebAssembly does at its lowest level. A deep understanding of WAT tells you why
    the code might not run as fast as you thought it would. It can help you comprehend
    how WebAssembly interacts with its embedding environment. Writing a module in
    WAT is the best way to work as close to the metal (low-level) as possible in a
    web browser. Knowledge of WAT can help you make the highest-performing web applications
    possible and allows you to disassemble and evaluate any web application written
    for the WebAssembly platform. It helps you assess any potential future security
    risks. In addition, it enables you to write code that is as close to native speed
    as possible without writing native code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些语言中，有一个因素是通用的，那就是理解 WebAssembly 在最低层级的工作原理。深入理解 WAT 可以让你明白为什么代码的执行速度可能没有你预期的快。它有助于你理解
    WebAssembly 如何与其嵌入环境交互。在 WAT 中编写模块是尽可能接近底层（低级）工作的最佳方式。了解 WAT 可以帮助你创建最高性能的 web
    应用，并允许你反汇编和评估任何为 WebAssembly 平台编写的 web 应用程序。它有助于你评估潜在的安全风险。此外，它使你能够编写尽可能接近本地速度的代码，而无需编写本地代码。
- en: So what is WAT? WAT is like an assembly language for the WebAssembly virtual
    machine. Let’s look at what this means in a practical sense. Writing WebAssembly
    programs in a language like Rust or C++ uses a toolchain, which, as mentioned
    earlier, compiles a WebAssembly binary file as well as JavaScript glue code and
    HTML that embeds the WebAssembly module. A WebAssembly file is very similar to
    machine code because it includes sections, opcodes, and data all stored as a series
    of binary numbers. When you have an executable file in machine code, you can disassemble
    that file into that machine’s *assembly language,* the lowest level of programming
    languages. Assembly replaces the numeric opcodes in the binary with mnemonic codes
    that are intended to be readable by a human being. WAT acts as the assembly language
    for WebAssembly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是 WAT？WAT 就像是 WebAssembly 虚拟机的汇编语言。让我们从实际的角度来看看这意味着什么。用 Rust 或 C++ 等语言编写
    WebAssembly 程序时，使用的工具链会编译出一个 WebAssembly 二进制文件，还会生成 JavaScript 配合代码和嵌入 WebAssembly
    模块的 HTML。WebAssembly 文件与机器代码非常相似，因为它包含了各个部分、操作码和数据，所有这些都存储为一系列二进制数字。当你拥有一个机器代码的可执行文件时，可以将该文件反汇编成该机器的*汇编语言*，这是一种最低级的编程语言。汇编语言将二进制中的数字操作码替换为助记码，旨在便于人类读取。WAT
    就充当了 WebAssembly 的汇编语言。
- en: WAT Coding Styles
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WAT 编码风格
- en: There are two primary styles of WAT coding to choose from. One style is the
    *linear instruction list* style. This coding style requires the developer to mentally
    keep track of items on the stack. Most WAT instructions push items onto a stack,
    pop them off a stack, or both. If you choose to write in the linear instruction
    style, there is an implicit stack where the parameters of your instructions must
    be placed before the instruction is called. The other coding style is called *S-Expressions*.
    S-Expressions are a tree-like coding structure where parameters are passed into
    the tree in a way that looks a bit more like function calls in JavaScript. If
    you have trouble visualizing the stack and the items being pushed onto and off
    of it, the S-Expression syntax might be more your style. You can also mix the
    two styles depending on the implicit stack for less complicated instructions and
    use an S-Expression when the number of parameters become challenging to keep track
    of.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要的 WAT 编码风格可以选择。一种风格是*线性指令列表*风格。这种编码风格要求开发者在心理上跟踪栈中的项。大多数 WAT 指令会将项推入栈中、从栈中弹出项，或两者兼有。如果选择使用线性指令风格，那么在调用指令之前，指令的参数必须放置在隐式栈中。另一种编码风格叫做*S-表达式*。S-表达式是一种树状结构的编码方式，参数以一种类似于
    JavaScript 函数调用的方式传入树中。如果你在可视化栈和项的推入与弹出时遇到困难，S-表达式语法可能更适合你。你也可以根据隐式栈使用两种风格：对于较不复杂的指令使用线性指令风格，对于参数数量较多且难以跟踪时使用
    S-表达式。
- en: Example Using Linear Instruction List Style
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用线性指令列表风格的示例
- en: Consider the simple addition function in [Listing 1-1](#listing1-1), which is
    in JavaScript.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在[清单 1-1](#listing1-1)中展示的简单加法函数，它使用的是 JavaScript。
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 1-1: JavaScript code adding `a_val` and `b_val` variables'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-1：JavaScript 代码添加 `a_val` 和 `b_val` 变量
- en: After executing these lines, the value in the `c_val` variable is now `3`, which
    is the result of adding `a_val` and `b_val`. To do the same task in WAT, you would
    need quite a few lines of code. [Listing 1-2](#listing1-2) shows the same program
    using WAT.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些代码行后，`c_val` 变量的值现在是 `3`，这是将 `a_val` 和 `b_val` 相加的结果。要在 WAT 中完成相同的任务，你需要编写相当多的代码行。[清单
    1-2](#listing1-2)展示了使用 WAT 编写的相同程序。
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 1-2: WebAssembly adding `$a_val` to `$b_val`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-2：WebAssembly 将 `$a_val` 加到 `$b_val`
- en: '[Listing 1-2](#listing1-2) contains more lines of code because WAT must be
    more explicit than JavaScript. JavaScript has no idea whether the types in the
    previous two examples are floating-point data, integers, strings, or a mix until
    the code runs. The WebAssembly is compiled into a bytecode ahead of time and must
    be made aware of the types it’s using when it’s compiled. The JavaScript must
    be parsed and tokenized before the JIT compiler can turn it into bytecode. Once
    the optimizing compiler begins working on that bytecode, the compiler must watch
    to see whether the variables are consistently integers. If they are, the JIT can
    create a bytecode that makes that assumption.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-2](#listing1-2) 包含更多的代码行，因为 WAT 必须比 JavaScript 更加明确。JavaScript 在代码运行之前无法知道前两个示例中的类型是浮点数据、整数、字符串，还是它们的混合。而
    WebAssembly 是提前编译成字节码的，并且必须在编译时意识到它使用的类型。JavaScript 必须在 JIT 编译器将其转换为字节码之前进行解析和标记化。一旦优化编译器开始处理这些字节码，编译器就必须观察变量是否始终为整数。如果是这样，JIT
    编译器就可以创建一个假设这些变量为整数的字节码。'
- en: However, JavaScript is never quite sure whether it will end up with string data
    or floating-point data when it expected integers; so at any time, it must be ready
    to throw out its optimized code and start over again. The WAT code might be harder
    to write and to understand, but it’s much easier for the web browser to run. WebAssembly
    moves a lot of work from the browser to the toolchain compiler or the developer.
    Not having to do as much work makes for happy browsers and faster applications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript 永远无法确定在期望整数时是否会得到字符串数据或浮点数据；因此，随时都必须准备好丢弃优化后的代码并重新开始。WAT 代码可能更难编写和理解，但它更容易被网页浏览器执行。WebAssembly
    将大量工作从浏览器转移到工具链编译器或开发人员身上。不必做那么多工作，使得浏览器更加高兴，应用程序运行得更快。
- en: Stack Machines
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 堆栈机器
- en: As mentioned earlier, WebAssembly is a virtual stack machine. Let’s explore
    what this means. Think of a stack as a stack of dishes. Each dish in this metaphor
    is a piece of data. When you add a dish to the stack, you place it on top of the
    dishes already there. When you take a dish off the stack, you don’t take it from
    the bottom, you take it off the top. For this reason, the last dish you put on
    the stack is the first dish you remove. In computer science, this is called *last-in,
    first-out* (*LIFO*). Adding data to a stack is called a *push*, and taking data
    off a stack is called a *pop*. When you use a stack machine, almost all commands
    perform some interaction with the stack, either adding more data to the top of
    the stack with a push or removing data from the top with a pop. [Figure 1-2](#figure1-2)
    shows a depiction of stack interaction.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，WebAssembly 是一个虚拟堆栈机器。让我们来探讨一下这意味着什么。可以将堆栈想象成一堆碗碟。这个比喻中的每个碗碟就是一块数据。当你将一个碗碟放到堆栈上时，你将它放在已经存在的碗碟上面。当你从堆栈中取出一个碗碟时，你不是从底部取出，而是从顶部取出。因此，你最后放到堆栈上的碗碟是第一个取出的碗碟。在计算机科学中，这叫做*后进先出*（*LIFO*）。将数据添加到堆栈中叫做*推入*（*push*），从堆栈中取出数据叫做*弹出*（*pop*）。使用堆栈机器时，几乎所有指令都会与堆栈进行某种交互，要么通过推入操作将数据添加到堆栈顶部，要么通过弹出操作从堆栈顶部移除数据。[图
    1-2](#figure1-2) 显示了堆栈交互的示意图。
- en: '![f01002](Images/f01002.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![f01002](Images/f01002.png)'
- en: 'Figure 1-2: A stack machine pops values off and pushes values onto the stack.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：堆栈机器从堆栈中弹出值并将值推入堆栈。
- en: As you saw earlier, the first two lines of the `$main` function in [Listing
    1-2](#listing1-2) push `$a_val` on the top of the stack 1 and then push `$b_val`
    on top of that 2. The result is a stack with two values on it. The bottom of the
    stack has the value in `$a_val` because we added it first, and the top has the
    value in `$b_val` because it was added last.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所见，在[示例 1-2](#listing1-2)中，`$main` 函数的前两行先将 `$a_val` 推入堆栈 1 的顶部，然后再将 `$b_val`
    推入其上面 2。结果是堆栈中有两个值。堆栈底部的值是 `$a_val` 中的值，因为它是第一个添加的，堆栈顶部的值是 `$b_val` 中的值，因为它是最后添加的。
- en: It’s important to make the distinction between an ISA for a stack machine, like
    WebAssembly, and an ISA for a register machine, such as x86, ARM, MIPS, PowerPC,
    or any other popular hardware architecture of the past 30 years. Register machines
    must move data from memory into CPU registers to perform mathematical operations
    on them. WebAssembly is a virtual stack machine that must run on register machines.
    As we write WAT formatted code, you’ll see this interaction up close.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要区分堆栈机器的 ISA（指令集架构），比如 WebAssembly，和寄存器机器的 ISA，比如 x86、ARM、MIPS、PowerPC 或过去
    30 年里任何其他流行的硬件架构。寄存器机器必须将数据从内存移动到 CPU 寄存器中，以便执行数学运算。WebAssembly 是一个虚拟堆栈机器，必须运行在寄存器机器上。当我们编写
    WAT 格式的代码时，你将近距离观察到这种交互。
- en: Stack machines push data onto and off of a stack to perform calculations. Hardware
    stack machines are a rare breed of computer. Virtual stack machines like WebAssembly
    are more common; examples include Java’s JVM, Adobe Flash player’s AVM2, Ethereum’s
    EVM, and the CPython bytecode interpreter. The advantage of virtual stack machines
    is that they create smaller bytecode sizes, which is handy for any bytecode intended
    to be downloaded or streamed over the internet.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 栈机器通过将数据推入栈中和从栈中弹出数据来执行计算。硬件栈机器是一种稀有的计算机类型。像WebAssembly这样的虚拟栈机器则更为常见；例如Java的JVM、Adobe
    Flash播放器的AVM2、以太坊的EVM和CPython字节码解释器。虚拟栈机器的优势在于它们能创建更小的字节码，这对于任何需要通过互联网下载或流式传输的字节码来说非常有用。
- en: Stack machines make no assumptions about the number of general-purpose registers
    available to the embedding environment. That allows the hardware to choose which
    registers to use and when. The WAT code can be a little confusing if you’re not
    aware of how a stack machine works, so let’s take another look at the first two
    lines of the function `$main` with the stack in mind ([Listing 1-3](#listing1-3)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 栈机器不对嵌入环境中可用的一般寄存器数量做出任何假设。这使得硬件能够选择何时使用哪些寄存器。如果你不清楚栈机器是如何工作的，WAT代码可能会有些混乱，那么让我们再次看看`$main`函数的前两行代码，特别是在考虑栈的情况下（[列表1-3](#listing1-3)）。
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 1-3: Retrieving `$a_val` and `$b_val`, and then pushing them on the
    stack'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-3：获取`$a_val`和`$b_val`，然后将它们推入栈中
- en: The first line gets the value of `$a_val`, which we define as a global value,
    and the second line gets the global variable `$b_val`. Both items end up on the
    stack waiting to be processed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行获取了`$a_val`的值，我们将其定义为全局值，第二行获取了全局变量`$b_val`。这两个项最终被推入栈中，等待处理。
- en: The function `i32.add` takes two 32-bit integer variables off the stack, adds
    them together, and then pushes the result back onto the top of the stack. Once
    the two values are on the stack, we can call `i32.add`. If you run a function
    that pops more values off the stack than were available, the tools you use to
    convert your WAT into a WebAssembly binary won’t allow this and will throw a compiler
    error. We use the final line in the `$main` function to set the `$c_val` variable
    to the value on the stack. That value is the result of the `i32.add` function
    call.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`i32.add`从栈中取出两个32位整数变量，将它们相加，然后将结果重新推入栈顶。当这两个值被放入栈中时，我们可以调用`i32.add`。如果你运行一个弹出栈中更多值的函数，而栈中没有足够的值，转换WAT为WebAssembly二进制的工具将不允许这样做，并会抛出编译错误。我们在`$main`函数的最后一行使用栈中的值来设置`$c_val`变量。这个值是`i32.add`函数调用的结果。
- en: Example Using S-Expressions
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用S表达式的示例
- en: S-Expressions are a nested tree structure coding style used in programming languages,
    such as Lisp. In [Listing 1-3](#listing1-3), we used the linear instruction list
    style for writing WAT. The linear instruction style implicitly uses the stack
    for each call statement and expression called. For those with some assembly language
    experience, this method might feel comfortable for you. But if you come to WebAssembly
    from a high-level language, like JavaScript, the S-Expression syntax for WAT is
    likely to feel more familiar. S-Expressions organize your calls to WAT statements
    and expressions in a nested structure. The linear style requires you to mentally
    push items onto the stack and pop them off as you write your code. The S-Expressions
    look more like JavaScript function calls than the linear style.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: S表达式是一种用于编程语言中的嵌套树结构编码风格，例如Lisp。在[列表1-3](#listing1-3)中，我们使用了线性指令列表风格来编写WAT。线性指令风格在每个调用语句和表达式调用时，隐式地使用栈。对于有一定汇编语言经验的人来说，这种方法可能会感觉比较熟悉。但如果你是从高层语言（如JavaScript）转向WebAssembly的话，S表达式语法可能会更容易理解。S表达式以嵌套结构组织你对WAT语句和表达式的调用。线性风格要求你在编写代码时，脑海中将项推入栈中并弹出。而S表达式更像是JavaScript函数调用，而不是线性风格。
- en: 'In [Listing 1-2](#listing1-2), we set `c_val` to `a_val` + `b_val` using the
    stack. The code in [Listing 1-4](#listing1-4) is the fragment of code in [Listing
    1-2](#listing1-2) where we added those values together:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表1-2](#listing1-2)中，我们通过栈将`c_val`设置为`a_val` + `b_val`。在[列表1-4](#listing1-4)中的代码是[列表1-2](#listing1-2)中将这些值相加的代码片段：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 1-4: Adding and setting `$c_val` in WebAssembly'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-4：在WebAssembly中添加并设置`$c_val`
- en: We push two 32-bit integer variables onto the stack that we retrieved from global
    variables using `global.get` 1. We then popped those two values off the stack
    with a call to `i32.add`. After adding those two values together, the `i32.add`
    2 function pushed the resulting value back onto the stack. That’s how the stack
    machine works. Each instruction either pushes a value onto the stack, pops a value
    off, or both.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个 32 位整数变量推送到堆栈中，这些变量是通过 `global.get` 1 从全局变量中获取的。然后我们通过调用 `i32.add` 弹出这两个值。将这两个值相加后，`i32.add`
    2 函数将结果值推回堆栈。这就是堆栈机器的工作方式。每个指令要么将值推送到堆栈中，要么从堆栈中弹出值，或者两者兼有。
- en: '[Listing 1-5](#listing1-5) shows the same function using the alternative S-Expression
    syntax.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-5](#listing1-5) 显示了使用替代的 S-Expression 语法的相同函数。'
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 1-5: WebAssembly module to add two values'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-5：WebAssembly 模块，用于相加两个值
- en: 'Don’t let the parentheses confuse you: they work the same way as the `{}` characters
    do in many languages to create code blocks. When writing a WAT function, we enclose
    the function in parentheses. When you bring a matching parenthesis below the opening
    parenthesis with the same indentation, it looks similar to the way you would indent
    the `{` and `}` characters in a language like JavaScript. For instance, look at
    the indentation of the `(` before the `global.set` 1 call and match it up by eye
    with the closing `)` below it.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让括号弄混你：它们的作用和许多语言中的`{}`字符相同，用来创建代码块。当编写 WAT 函数时，我们将函数包含在括号中。当你将匹配的右括号放在与左括号相同的缩进位置时，它看起来类似于你在像
    JavaScript 这样的语言中缩进 `{` 和 `}` 字符。例如，看看 `global.set` 1 调用前的 `(` 的缩进，并用眼睛对齐它下面的闭合
    `)`。
- en: This code looks more like a conventional programming language than [Listing
    1-2](#listing1-2), because it appears to pass parameters into a function instead
    of pushing and popping values with a stack. To be clear, this code compiles into
    the same binary. If you write your code in an S-Expressions style, you’re still
    pushing items on and off the stack. This style of writing WAT is just *syntactic
    sugar* (syntax to make code easier to read). When you’re comfortable disassembling
    WebAssembly files into WAT, you’ll find that the S-Expression syntax isn’t provided
    by disassemblers, such as *wasm2wat*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来更像是一种传统的编程语言，而不是 [列表 1-2](#listing1-2)，因为它似乎将参数传递给函数，而不是通过堆栈推送和弹出值。明确来说，这段代码会编译成相同的二进制文件。如果你以
    S-Expressions 风格编写代码，你仍然是在堆栈上推送和弹出项。这种写 WAT 的风格只是 *语法糖*（使代码更易读的语法）。当你熟悉将 WebAssembly
    文件反汇编成 WAT 时，你会发现反汇编工具（例如 *wasm2wat*）并没有提供 S-Expression 语法。
- en: The Embedding Environment
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入环境
- en: As mentioned earlier, WebAssembly doesn’t run directly on hardware. You must
    embed the WebAssembly binary in a host environment that controls the loading and
    initializing of a WebAssembly module. In this book, we work with JavaScript engines,
    such as Node.js, and web browsers as embedding environments. Other environments
    include WASI, such as wasmtime (defined shortly). But even though we discuss WASI,
    we won’t use it in this book because it’s still very new and under development.
    It’s up to the embedding environment to implement the stack machine. Because modern
    hardware is typically a register machine, the embedding environment manages the
    stack using the hardware registers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，WebAssembly 并不直接运行在硬件上。你必须将 WebAssembly 二进制嵌入到一个主机环境中，这个环境控制着 WebAssembly
    模块的加载和初始化。在本书中，我们使用 JavaScript 引擎，如 Node.js 和 Web 浏览器作为嵌入环境。其他环境包括 WASI，如 wasmtime（稍后定义）。但是即便我们讨论
    WASI，我们在本书中不会使用它，因为它仍然非常新且在开发中。实现堆栈机器的是嵌入环境。由于现代硬件通常是寄存器机器，嵌入环境通过硬件寄存器来管理堆栈。
- en: The Browser
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器
- en: There’s a good chance that you’re interested in WebAssembly because you want
    it to improve the performance of your web applications. All modern browser JavaScript
    engines implement WebAssembly. Currently, Chrome and Firefox have the best tools
    for debugging WebAssembly, so we suggest choosing one of those browsers for development.
    Your WAT applications should also run just fine in Microsoft Edge, but Internet
    Explorer is no longer adding features. Unfortunately, Internet Explorer doesn’t
    support WebAssembly and never will.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你很有可能对 WebAssembly 感兴趣，因为你希望它能提升你网页应用程序的性能。所有现代浏览器的 JavaScript 引擎都实现了 WebAssembly。目前，Chrome
    和 Firefox 拥有最好的 WebAssembly 调试工具，因此我们建议选择其中一款浏览器进行开发。你的 WAT 应用程序在 Microsoft Edge
    中也应该能正常运行，但 Internet Explorer 不再增加新功能。遗憾的是，Internet Explorer 不支持 WebAssembly，并且永远不会支持。
- en: When you’re writing WAT for a web browser, it’s crucial to understand which
    parts of an application you can write in WAT and which you must write in JavaScript.
    There might also be cases where the performance improvement you gain with WebAssembly
    might not be worth the additional development time. If you understand WAT and
    WebAssembly, you’ll be able to make these decisions. When you’re working with
    WebAssembly, you must frequently trade performance for development time, or sacrifice
    CPU cycles for memory, or vice versa. Performance optimization is about choices.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为网页浏览器编写WAT时，理解哪些部分可以用WAT编写，哪些必须用JavaScript编写是至关重要的。也可能会有情况，WebAssembly带来的性能提升不一定值得额外的开发时间。如果你理解WAT和WebAssembly，你将能够做出这些决策。在使用WebAssembly时，你必须频繁地在性能和开发时间之间做出权衡，或者在CPU周期和内存之间做出牺牲，反之亦然。性能优化就是关于做出选择。
- en: WASI
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WASI
- en: '*WASI* is a runtime specification for WebAssembly applications and is a standard
    for WebAssembly interaction with the operating system. It allows WebAssembly to
    use the filesystem, make system calls, and handle input and output. The Mozilla
    Foundation has created a WebAssembly runtime called *wasmtime* that implements
    the WASI standard. With WASI, WebAssembly can do everything that a native application
    can do but in a secure and platform-independent way. It does it all with performance
    similar to native apps.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*WASI* 是WebAssembly应用程序的运行时规范，是WebAssembly与操作系统交互的标准。它允许WebAssembly使用文件系统、进行系统调用、处理输入输出。Mozilla基金会创建了一个名为*wasmtime*的WebAssembly运行时，实施了WASI标准。通过WASI，WebAssembly能够做所有本地应用程序可以做的事情，但以安全、平台独立的方式进行。它的性能与本地应用程序相似。'
- en: Node.js can also run a WASI experimental preview using the `--experimental-wasi-unstable-preview1`
    flag. You can use it to run WebAssembly applications that interact with the operating
    system outside of a web browser. Windows, macOS, Linux, or any other operating
    system can implement a WASI runtime, because it’s designed to make WebAssembly
    portable, secure, and eventually universal.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js还可以使用`--experimental-wasi-unstable-preview1`标志运行WASI实验预览版。你可以用它运行与操作系统交互的WebAssembly应用程序，而不依赖网页浏览器。Windows、macOS、Linux或任何其他操作系统都可以实现WASI运行时，因为它的设计目标是使WebAssembly具有可移植性、安全性，并最终实现普遍适用。
- en: Visual Studio Code
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: '*Visual Studio Code (VS Code)* is an open source integrated development environment
    (IDE), and the one I used to write the examples in this book. VS Code is available
    for Windows, macOS, and Linux at[https://code.visualstudio.com/download](https://code.visualstudio.com/download).
    We use VS Code with the WebAssembly extension written by Dmitriy Tsvettsikh, which
    is available at [https://marketplace.visualstudio.com/items?itemName=dtsvet.vscode-wasm](https://marketplace.visualstudio.com/items?itemName=dtsvet.vscode-wasm).
    The extension provides code coloring for the WAT format, as well as several other
    useful menu items. For example, if you have a WebAssembly file, you can disassemble
    it into WAT by right-clicking the file and choosing the **Show WebAssembly** menu
    option. This is very useful if you want to look at WebAssembly code you didn’t
    write or code that was compiled using a toolchain. The extension can also compile
    your WAT files into a WebAssembly binary. You can right-click the *.wat* file
    and choose **Save as WebAssembly binary file**. A save file prompt appears, allowing
    you to specify the filename where you want to save the WebAssembly file.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*Visual Studio Code (VS Code)* 是一个开源集成开发环境（IDE），也是我用来编写本书示例的工具。VS Code可在Windows、macOS和Linux上使用，下载地址为[https://code.visualstudio.com/download](https://code.visualstudio.com/download)。我们使用由Dmitriy
    Tsvettsikh编写的WebAssembly扩展，下载链接为[https://marketplace.visualstudio.com/items?itemName=dtsvet.vscode-wasm](https://marketplace.visualstudio.com/items?itemName=dtsvet.vscode-wasm)。该扩展为WAT格式提供了代码高亮，并且包含几个其他有用的菜单项。例如，如果你有一个WebAssembly文件，你可以通过右键点击文件并选择**Show
    WebAssembly**菜单选项，将其反汇编为WAT格式。如果你想查看不是自己编写的WebAssembly代码，或者是通过工具链编译的代码，这非常有用。该扩展还可以将你的WAT文件编译为WebAssembly二进制文件。你可以右键点击*.wat*文件并选择**Save
    as WebAssembly binary file**，然后会弹出保存文件提示，允许你指定保存WebAssembly文件的文件名。'
- en: '[Figure 1-3](#figure1-3) shows a screenshot of the extension.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-3](#figure1-3) 显示了扩展的截图。'
- en: '![f01003](Images/f01003.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![f01003](Images/f01003.png)'
- en: 'Figure 1-3: Installing the WebAssembly extension for VS Code'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3：为VS Code安装WebAssembly扩展
- en: Node.js
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Node.js
- en: '*Node.js* is an excellent tool for testing the performance of WebAssembly modules
    against existing JavaScript modules and is the JavaScript runtime environment
    we use in much of this book. Node.js comes with *npm (Node Package Manager),*
    which you can use to easily install packages of code. WebAssembly is a great alternative
    to writing a native module in Node.js, which locks you into using specific hardware.
    If you want to create an npm module for general use, writing for WebAssembly can
    give you the performance of a native module with the portability and security
    of a JavaScript module. We’ll execute many of the applications we write in this
    book using Node.js.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*Node.js* 是一个出色的工具，用于测试 WebAssembly 模块与现有 JavaScript 模块的性能，并且是本书中我们在许多示例中使用的
    JavaScript 运行时环境。Node.js 自带 *npm (Node 包管理器)*，你可以使用它轻松安装代码包。WebAssembly 是编写 Node.js
    原生模块的一个很好的替代方案，因为原生模块会将你锁定在特定的硬件上。如果你想为通用用途创建一个 npm 模块，编写 WebAssembly 可以让你获得原生模块的性能，同时保留
    JavaScript 模块的可移植性和安全性。我们将使用 Node.js 执行本书中编写的许多应用程序。'
- en: Node.js is our preferred development tool for executing WebAssembly, whether
    it be from JavaScript or through a web server. We’ll begin by using Node.js to
    execute WebAssembly modules from JavaScript, and in Chapter 7, we’ll write a simple
    web server to serve WebAssembly web applications.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是我们执行 WebAssembly 的首选开发工具，无论是通过 JavaScript 还是通过 Web 服务器。在第 7 章中，我们将使用
    Node.js 从 JavaScript 执行 WebAssembly 模块，并且将编写一个简单的 Web 服务器来提供 WebAssembly Web 应用程序。
- en: Node.js comes with the npm, which makes it easy to install some tools you can
    use to develop WebAssembly. In this section, we’ll show you how to use npm to
    install the *wat-wasm* module, a tool for compiling, optimizing, and disassembling
    WebAssembly. We’ll also show you how to use Node.js to write a simple WebAssembly
    application. Many readers might already be familiar with Node.js, but if not,
    there is a mountain of Node.js documentation available if you want to learn more
    than the short introduction and setup we discuss here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 自带 npm，这使得安装一些用于开发 WebAssembly 的工具变得容易。在本节中，我们将展示如何使用 npm 安装 *wat-wasm*
    模块，它是一个用于编译、优化和反汇编 WebAssembly 的工具。我们还将展示如何使用 Node.js 编写一个简单的 WebAssembly 应用程序。许多读者可能已经熟悉
    Node.js，但如果没有，网上有大量的 Node.js 文档可供参考，如果你想了解更多的内容，而不仅仅是这里简短的介绍和设置部分。
- en: Installing Node.js
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 Node.js
- en: You must have Node.js installed to complete the code examples in this book.
    Fortunately, the installation isn’t complicated. If you’re using Windows or macOS,
    installers are available for both operating systems at [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 必须安装 Node.js 才能完成本书中的代码示例。幸运的是，安装过程并不复杂。如果你使用的是 Windows 或 macOS，可以在 [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    下载适用于这两个操作系统的安装程序。
- en: 'For Ubuntu Linux, you can install Node using the following `apt` command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Ubuntu Linux，你可以使用以下 `apt` 命令安装 Node：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you have Node installed, run the following command from a command prompt
    (on any platform) to make sure everything installed as intended:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 安装好 Node 后，在命令提示符（在任何平台上）中运行以下命令，以确保一切安装正常：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If everything is installed, you should see the version of Node.js installed
    as output. When we run the command `node -v` on our Windows machine, it produces
    the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切安装成功，你应该会看到安装的 Node.js 版本作为输出。当我们在 Windows 机器上运行命令 `node -v` 时，它输出如下内容：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This means that we’re running version 12.14.0.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们正在运行版本 12.14.0。
- en: Installing wat-wasm
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 wat-wasm
- en: 'Many tools are available for converting WAT code to a WebAssembly binary. In
    fact, while writing this book, I used many of these tools. In the end, I wrote
    *wat-wasm* on top of *WABT.js* and *Binaryen.js*to reduce the number of packages
    needed for the features I wanted to demonstrate. To install `wat-wasm`, execute
    the following `npm` command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可用于将 WAT 代码转换为 WebAssembly 二进制文件。事实上，在写这本书的时候，我使用了其中许多工具。最终，我在 *WABT.js*
    和 *Binaryen.js* 的基础上编写了 *wat-wasm*，以减少我想展示的功能所需的包的数量。要安装 `wat-wasm`，请执行以下 `npm`
    命令：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `-g` flag installs `wat-wasm` globally. Throughout this book we’ll use
    command line tools like `wat2wasm` in the terminal window. To use the tools for
    more than just the current project, you need to install it globally. Once you
    have `wat-wasm` installed, make sure you can run it by running the `wat2wasm`
    command from the command line:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` 标志会将 `wat-wasm` 安装为全局模块。在本书中，我们将使用像 `wat2wasm` 这样的命令行工具。为了使这些工具不仅限于当前项目，你需要将它们全局安装。一旦安装了
    `wat-wasm`，可以通过在命令行中运行 `wat2wasm` 命令来确认它是否可以正常运行：'
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You should then see the `wat-wasm` usage logged to your console. This will show
    you a variety of flags that you’ll learn about later in this book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你应该能在控制台中看到 `wat-wasm` 的使用日志。这将展示你在本书后续内容中将要学习的各种标志。
- en: 'You can test `wat2wasm` by creating the simplest possible WAT module, as shown
    in [Listing 1-6](#listing1-6). Create a new file called *file.wat* and enter the
    following code into that file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建最简单的 WAT 模块来测试 `wat2wasm`，如 [列表 1-6](#listing1-6) 所示。创建一个名为 *file.wat*
    的新文件，并将以下代码输入该文件：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 1-6: The simplest possible WebAssembly module'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-6：最简单的 WebAssembly 模块
- en: 'With `wat-wasm`installed, you can use the command in [Listing 1-7](#listing1-7)
    to compile *file.wat* file to *file.wasm*, which is the WebAssembly binary file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `wat-wasm` 后，你可以使用 [列表 1-7](#listing1-7) 中的命令将 *file.wat* 文件编译为 *file.wasm*，即
    WebAssembly 二进制文件：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 1-7: Assembling the *file.**wat* file with `wat2wasm`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-7：使用 `wat2wasm` 汇编 *file.wat* 文件
- en: We’ll use Node.js throughout this book to run WebAssembly command line apps
    and serve WebAssembly web apps to open in a browser. In the next section, we’ll
    write the first WebAssembly app that we’ll execute using Node.js.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将始终使用 Node.js 来运行 WebAssembly 命令行应用，并将 WebAssembly 网络应用提供给浏览器打开。在下一节中，我们将编写第一个
    WebAssembly 应用，并通过 Node.js 执行。
- en: Our First Node.js WebAssembly App
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的第一个 Node.js WebAssembly 应用
- en: We’ll begin the book by using Node.js as the embedding environment instead of
    the web browser so as to remove the need for HTML and CSS in the code examples
    and keep them simple. Later, once you have the basics, we’ll explore using the
    browser as the embedding environment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本书从使用 Node.js 作为嵌入环境开始，而不是使用网页浏览器，以便简化代码示例中的 HTML 和 CSS 部分。稍后，在掌握基础知识后，我们将探索如何使用浏览器作为嵌入环境。
- en: The WAT code in our Node.js apps will work the same as they do in the browser.
    The WebAssembly engine inside Node.js is the same as the one inside Chrome, and
    the WebAssembly part of the app is completely unaware of the environment it’s
    running in.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Node.js 应用中的 WAT 代码将与浏览器中的表现一样。Node.js 内部的 WebAssembly 引擎与 Chrome 内部的 WebAssembly
    引擎相同，应用程序中的 WebAssembly 部分完全不关心它所运行的环境。
- en: Let’s begin by creating a simple WAT file and compiling it using `wat2wasm`.
    Create a file called *AddInt.wat* and add the WAT code in [Listing 1-8](#listing1-8)
    to it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的 WAT 文件开始，并使用 `wat2wasm` 进行编译。创建一个名为 *AddInt.wat* 的文件，并将 [列表 1-8](#listing1-8)
    中的 WAT 代码添加到其中。
- en: '**AddInt.wat**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**AddInt.wat**'
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 1-8: WebAssembly module with a function that adds two integers'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-8：带有两个整数相加函数的 WebAssembly 模块
- en: By now, you should be able to understand this code. Take some time to look it
    over until you’re comfortable with the logic. This is a straightforward WebAssembly
    module with a single function `AddInt` that we export to the embedding environment.
    Now compile *AddInt.wat* into *AddInt.wasm* using `wat2wasm`, as shown in [Listing
    1-9](#listing1-9).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能理解这段代码。花点时间仔细查看，直到你对其逻辑感到熟悉。这是一个简单的 WebAssembly 模块，包含一个 `AddInt` 函数，我们将其导出到嵌入环境中。现在，使用
    `wat2wasm` 将 *AddInt.wat* 编译为 *AddInt.wasm*，如 [列表 1-9](#listing1-9) 所示。
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 1-9: Compiling *AddInt.wat* into *AddInt.wasm*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-9：将 *AddInt.wat* 编译为 *AddInt.wasm*
- en: Now we’re ready to write the JavaScript portion of our first Node.js app.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写第一个 Node.js 应用的 JavaScript 部分。
- en: Calling the WebAssembly Module from Node.js
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Node.js 调用 WebAssembly 模块
- en: We can call the WebAssembly module from Node.js using JavaScript. Create a file
    called *AddInt.js* and add the JavaScript code in [Listing 1-10](#listing1-10).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 JavaScript 从 Node.js 调用 WebAssembly 模块。创建一个名为 *AddInt.js* 的文件，并将 [列表
    1-10](#listing1-10) 中的 JavaScript 代码添加到其中。
- en: '**AddInt.js**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**AddInt.js**'
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 1-10: Calling the `AddInt` WebAssembly function from an asynchronous
    IIFE'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-10：从异步 IIFE 调用 `AddInt` WebAssembly 函数
- en: Node.js can read the WebAssembly file directly from the hard drive where the
    application is running using the built-in module called `fs` 1 that reads files
    from local storage. We load this module using Node.js’s `require` function. We
    use the `fs` module to read in the *AddInt.wasm* file using the `readFileSync`
    function. We also take in two arguments from the command line using the `process.argv`
    2 array. The `argv` array has all the arguments passed in from the command line
    to Node.js. We’ll run the function from the command line; `process.argv[0]` will
    contain the command `node` and `process.argv[1]` will contain the name of the
    JavaScript file *AddInt.js*. When we run the program, we pass in two numbers on
    the command line, which will set `process.argv[2]` and `process.argv[3]`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js可以直接从应用程序运行所在的硬盘读取WebAssembly文件，使用的是名为`fs`的内建模块，该模块可以从本地存储中读取文件。我们使用Node.js的`require`函数加载这个模块。我们使用`fs`模块通过`readFileSync`函数读取*AddInt.wasm*文件。我们还通过`process.argv`
    2数组从命令行接收两个参数。`argv`数组包含了从命令行传递给Node.js的所有参数。我们从命令行运行该函数；`process.argv[0]`将包含命令`node`，`process.argv[1]`将包含JavaScript文件*AddInt.js*的名称。当我们运行程序时，会在命令行传入两个数字，这会设置`process.argv[2]`和`process.argv[3]`。
- en: We use an asynchronous *immediately invoked function expression (IIFE)* to instantiate
    the WebAssembly module, call the WebAssembly function, and output the results
    to the console. For those unfamiliar with the IIFE syntax, it’s a means by which
    JavaScript is able to wait for a promise before executing the rest of the code.
    When you do tasks like instantiate a WebAssembly module, it takes time, and you
    don’t want to tie up the browser or node while waiting for that process to finish.
    The `(async () => {})();` 3 syntax tells the JavaScript engine that there is a
    promise object coming, so go do something else while waiting for the result. Inside
    the IIFE, we call `WebAssembly.instantiate` 4 passing the `bytes` we retrieved
    from the WebAssembly file earlier with the call to `readFileSync`. After instantiating
    the module, we call the `AddInt` 5 function exported from the WAT code. We then
    call a `console.log` 6 statement to output the values we’re adding and the result.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个异步*立即调用函数表达式（IIFE）*来实例化WebAssembly模块、调用WebAssembly函数并将结果输出到控制台。对于不熟悉IIFE语法的人来说，它是一种使JavaScript能够在执行其余代码之前等待Promise的方式。当你执行像实例化WebAssembly模块这样的任务时，它需要时间，而你不希望在等待该过程完成时阻塞浏览器或Node.js。`(async
    () => {})();` 3语法告诉JavaScript引擎将会有一个Promise对象，所以可以在等待结果的过程中做些其他事情。在IIFE内部，我们调用`WebAssembly.instantiate`
    4，传入之前通过`readFileSync`函数读取的WebAssembly文件的`bytes`。实例化模块后，我们调用从WAT代码中导出的`AddInt`
    5函数。然后，我们调用`console.log` 6语句来输出我们正在加的值和结果。
- en: Now that we have the WebAssembly module and the JavaScript file, we can run
    the app from the command line using the call to Node.js, as shown in [Listing
    1-11](#listing1-11).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了WebAssembly模块和JavaScript文件，我们可以通过命令行调用Node.js来运行应用程序，正如[Listing 1-11](#listing1-11)所示。
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 1-11: Running *AddInt.js* using Node.js'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 1-11: 使用Node.js运行*AddInt.js*'
- en: 'Running that command results in the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令会输出以下结果：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The addition of the two integers happens in WebAssembly. Before we move on,
    we’ll quickly show you how to use the `.then` syntax as an alternative to the
    asynchronous IIFE.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 两个整数的加法在WebAssembly中执行。在继续之前，我们将简要展示如何使用`.then`语法作为异步IIFE的替代方法。
- en: The .then Syntax
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .then语法
- en: The other widely used syntax to wait for the return of promises is the `.then`
    syntax. We prefer to use the IIFE syntax in [Listing 1-10](#listing1-10), but
    either syntax is perfectly acceptable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种广泛使用的等待Promise返回的语法是`.then`语法。我们更倾向于在[Listing 1-10](#listing1-10)中使用IIFE语法，但两种语法都是完全可以接受的。
- en: Create a file called *AddIntThen.js* and add the code in [Listing 1-12](#listing1-12)
    to replace the asynchronous IIFE syntax in [Listing 1-10](#listing1-10) with the
    `.then`code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*AddIntThen.js*的文件，并将[Listing 1-12](#listing1-12)中的代码添加到其中，替换掉[Listing
    1-10](#listing1-10)中的异步IIFE语法，改为使用`.then`代码。
- en: '**AddIntThen.js**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**AddIntThen.js**'
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 1-12: Using the `.then` syntax to call a WebAssembly function'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 1-12: 使用`.then`语法调用WebAssembly函数'
- en: The primary difference here lies in the `WebAssembly.instantiate` 1 function,
    followed by `.then` 2, and containing an arrow function callback that passes in
    an object `obj`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于`WebAssembly.instantiate`函数，后跟`.then`，并包含一个箭头函数回调，将一个对象`obj`作为参数传入。
- en: The Time Is Now
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在就是时候了
- en: 'Now is a great time to learn WAT. At the time of writing this, the current
    release of WebAssembly 1.0 has a relatively small instruction set with a total
    of 172 different opcodes in the WebAssembly binary, although you don’t need to
    remember all of them. WebAssembly supports four different data types: `i32`, `i64`,
    `f32`, and `f64`, and many of the opcodes are duplicate commands for each type
    (for example, `i32.add`and `i64.add`). If you eliminate the duplicate opcodes,
    you only need to know about 50 different mnemonics to know the entire language.
    The number of opcodes supported by WebAssembly will increase over time. Starting
    WebAssembly now in its early days gives you a leg up. In the future, remembering
    every opcode will become difficult or impossible.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是学习WAT的好时机。在撰写本文时，WebAssembly 1.0的当前版本具有相对较小的指令集，WebAssembly二进制文件中共有172个不同的操作码，尽管你不需要记住所有这些操作码。WebAssembly支持四种不同的数据类型：`i32`、`i64`、`f32`和`f64`，而且许多操作码是每种类型的重复命令（例如，`i32.add`和`i64.add`）。如果你去除重复的操作码，你只需要了解大约50个不同的助记符就能掌握整个语言。随着时间的推移，WebAssembly支持的操作码数量会增加。从WebAssembly的早期阶段开始学习，你将获得一定的优势。未来，记住每一个操作码将变得困难甚至不可能。
- en: As mentioned earlier, writing your modules in WAT is the best way to work as
    close to the metal as possible within a web browser. The way JavaScript is implemented
    in the browser today can create performance inconsistencies depending on a wide
    variety of factors. WebAssembly can eliminate these inconsistencies, and WAT can
    help you streamline your code to make it as fast as possible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在WAT中编写模块是尽可能在Web浏览器中贴近底层操作的最佳方式。今天JavaScript在浏览器中的实现方式可能会因为各种因素导致性能不一致。WebAssembly可以消除这些不一致，而WAT可以帮助你优化代码，使其尽可能快速。
- en: You can use a toolchain like Emscripten with only a minimal understanding of
    the WebAssembly platform. However, using the toolchains this way might result
    in minimal performance improvements in your application and mislead you to conclude
    that WebAssembly isn’t worth the effort. You would be wrong. If you want to get
    the highest possible performance from your web application, you must learn as
    much as you can about WebAssembly. You need to know what it can and cannot do.
    You must understand what it’s good at and what you should do in JavaScript. The
    best way to gain this knowledge is to write WAT code. In the end, you might not
    write your application in WAT, but knowing the language helps you comprehend WebAssembly
    and the web browser.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用像Emscripten这样的工具链，只需对WebAssembly平台有最基本的了解。然而，这样使用工具链可能会导致你的应用程序性能提升有限，并误导你得出WebAssembly不值得投入的结论。你会错的。如果你想从你的Web应用程序中获得最高性能，你必须尽可能多地了解WebAssembly。你需要知道它能做什么，不能做什么。你必须理解它擅长什么，以及你应该在JavaScript中做什么。获得这些知识的最佳方式是编写WAT代码。最终，你可能不会用WAT编写应用程序，但了解这种语言有助于你理解WebAssembly和Web浏览器。
