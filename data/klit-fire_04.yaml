- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Why Is It Hard?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这么难？
- en: On the surface, each legacy modernization project starts off feeling easy. After
    all, a working system did exist at one point. Somehow the organization managed
    to figure out enough to put something into production and keep it running for
    years. All the modernizing team should need to do is simply repeat that process
    using better technology, the benefit of hindsight, and improved tooling. It should
    be easy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，每个遗留系统现代化项目开始时都感觉很容易。毕竟，曾经有一个可用的系统存在。组织不知怎么地设法弄清楚足够的事情，把某个东西投入生产并让它运行了多年。现代化团队所需要做的只是利用更好的技术、后见之明和改进的工具重复这一过程。应该是很容易的。
- en: But, because people do not see the hidden technical challenges they are about
    to uncover, they also assume the work will be boring. There’s little glory to
    be had reimplementing a solved problem. An organization about to embark on such
    an undertaking craves new features, new functionality, and new benefits. Modernization
    projects are typically the ones organizations just want to get out of the way,
    so they usually launch into them unprepared for the time and resource commitments
    they require.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，因为人们看不到他们即将揭示的隐藏技术挑战，他们也假设这项工作会很无聊。重新实现一个已解决的问题几乎没有什么荣耀可言。一个准备开始这样任务的组织渴望新的特性、新的功能和新的好处。现代化项目通常是组织希望尽快完成的任务，因此他们通常在没有做好时间和资源承诺的准备下就匆忙启动这些项目。
- en: I tell my engineers that the biggest problems we have to solve are not technical
    problems, but people problems. Modernization projects take months, if not years
    of work. Keeping a team of engineers focused, inspired, and motivated from beginning
    to end is difficult. Keeping their senior leadership prepared to invest over and
    over on what is, in effect, something they already have is a huge challenge. Creating
    momentum and sustaining it are where most modernization projects fail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我告诉我的工程师，我们必须解决的最大问题不是技术问题，而是人际问题。现代化项目通常需要几个月，甚至几年的时间。让一个工程师团队从头到尾保持专注、激励和动力十足是困难的。让他们的高级领导层准备好一次次投资于本质上已经拥有的东西也是一项巨大的挑战。创造动力并保持动力是大多数现代化项目失败的地方。
- en: 'By far, the biggest momentum killers are the assumptions that tell us the project
    should be easy in the first place. They are, in no particular order, the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最大的动力杀手是那些告诉我们项目一开始应该是容易的假设。它们，按顺序排列如下：
- en: We can build on the lessons learned from the old system.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在旧系统的经验教训上建立。
- en: We understand the boundaries on the old system.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解旧系统的边界。
- en: We can use tools to speed things up.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用工具来加速进程。
- en: Let’s take a little time discussing why these obvious truths might not be as
    useful as they seem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间讨论一下，为什么这些显而易见的真理可能并不像看起来那么有用。
- en: The Curse of Hindsight
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后见之明的诅咒
- en: In poker, people call it *resulting*. It’s the habit of confusing the quality
    of the outcome with the quality of the decision. In psychology, people call it
    a *self-serving bias*. When things go well, we overestimate the roles of skill
    and ability and underestimate the role of luck. When things go poorly, on the
    other hand, it’s all bad luck or external forces.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在扑克中，人们称之为*结果主义*。这是一种将结果的质量与决策的质量混淆的习惯。在心理学中，人们称之为*自利偏见*。当事情顺利时，我们高估了技能和能力的作用，低估了运气的作用。相反，当事情进展不顺时，一切都是坏运气或外部因素。
- en: One of the main reasons legacy modernization projects are hard is because people
    overvalue the hindsight an existing system offers them. They assume that the existing
    system’s success was a matter of skill and that they discovered all the potential
    problems and resolved them the best possible way in the process of building it
    initially. They look at the results and don’t pay any attention to the quality
    of the decisions or the elements of luck that produced those results.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留系统现代化项目之所以困难的一个主要原因是，人们过高估计了现有系统所提供的后见之明。他们认为现有系统的成功是技术能力的问题，而且他们在最初构建过程中发现了所有潜在的问题并以最佳方式解决了这些问题。他们看到了结果，却没有注意到决策的质量或那些促成这些结果的运气因素。
- en: Of course, more often than not, very little documentation regarding the original
    decisions remains for them to study in the first place. Still, overlooking the
    role that plain luck plays in the success of any project means the team thinks
    they have room for extra innovations on top of the original challenge.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，往往关于原始决策的文档几乎没有，根本没有资料让他们进行研究。尽管如此，忽视运气在任何项目成功中的作用意味着团队认为自己有空间在原始挑战上进行额外的创新。
- en: Software can have serious bugs and still be wildly successful. Lotus 1-2-3 famously
    mistook 1900 for a leap year, but it was so popular that versions of Excel to
    this day have to be programmed to honor that mistake to ensure backward compatibility.
    And because Excel’s popularity ultimately dwarfed that of Lotus 1-2-3, the bug
    is now part of the ECMA Office Open XML specification.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件可能存在严重的 bug，但仍然能取得巨大的成功。Lotus 1-2-3 就以把 1900 年误认为是闰年而闻名，但它的受欢迎程度如此之高，以至于至今
    Excel 的版本仍然需要编程以保持对这一错误的兼容性。而且由于 Excel 的受欢迎程度最终远远超过了 Lotus 1-2-3，这个 bug 现在成为了
    ECMA Office Open XML 规范的一部分。
- en: Success and quality are not necessarily connected. Legacy systems are successful
    systems, but that does not mean every decision made in designing and implementing
    them was the right decision. Most people think they know that, but they go in
    the wrong direction with it. They’re cynical about the system, but despite that,
    they overload the road map with new features and functionality. No matter how
    critical of the system they appear to be, they still assume the underlying problem
    has been solved.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 成功与质量不一定是相关的。遗留系统是成功的系统，但这并不意味着在设计和实施这些系统时所做的每一个决策都是正确的。大多数人认为他们知道这一点，但他们却走入了错误的方向。他们对系统持悲观看法，但尽管如此，他们还是会在路线图上增加新的功能和特性。无论他们看起来多么批评这个系统，他们依然假设基础问题已经得到解决。
- en: 'We struggle to modernize legacy systems because we fail to pay the proper attention
    and respect to the real challenge of legacy systems: the context has been lost.
    We have forgotten the web of compromises that created the final design and are
    blind to the years of modifications that increased its complexity. We don’t realize
    that at least a few design choices were bad choices and that it was only through
    good luck the system performed well for so long. We oversimplify and ultimately
    commit to new challenges before we discover our mistakes.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在现代化遗留系统时遇到困难，是因为我们未能给予遗留系统真正的挑战应有的关注和尊重：背景已经丧失。我们已经忘记了创造最终设计时所做的妥协的复杂网络，也对多年修改带来的复杂性视而不见。我们没有意识到至少有一些设计选择是错误的，系统之所以能够长期良好运作，完全是凭借好运。我们把问题简化了，最终在发现错误之前就承诺了新的挑战。
- en: Being dismissive of legacy systems is no guarantee that we won’t also fall into
    the trap of relying on context that is lost. Remember the game I described in
    Chapter 3 when looking at what parts of the system shouldn’t be in COBOL? It’s
    a useful technique even when COBOL is not a factor. By challenging my team to
    design a system with the same requirements of our legacy system using only technology
    available at the time the legacy system was built, we’re forced to recover some
    context. Many of the “stupid” technical choices from the legacy system seem very
    different. Once forced to look directly at the context, we realize how innovative
    some of those systems really were. This gives us a little insight into which decisions
    were skill and foresight and which were luck.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对遗留系统的轻视并不能保证我们不会陷入依赖已经失去的背景的陷阱。还记得我在第三章中描述的游戏吗？当我们审视系统中哪些部分不应该使用 COBOL 时，这是一个有用的技巧，即使
    COBOL 不是因素。通过挑战我的团队，在我们遗留系统的要求下，使用当时遗留系统构建时可用的技术来设计一个系统，我们被迫恢复一些背景。遗留系统中许多“愚蠢”的技术选择看起来非常不同。一旦我们被迫直接审视背景，我们就会意识到这些系统中的一些其实是非常创新的。这让我们稍微有些洞察，哪些决策是技能和远见，哪些是运气。
- en: A successful system could have a design pattern that will not survive past a
    certain scale of usage but that was able to achieve its operational goals without
    ever crossing that threshold. Is that skill or luck? If the designers knew the
    system would not scale but also knew the system would never reach the point where
    it would need to scale that way, we could assume the design was a deliberate decision.
    For example, perhaps the system is accessible only to certain people for internal
    purposes. Scaling to millions of requests was not necessary, because it would
    only ever get hundreds of requests per second at most.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的系统可能有一个设计模式，虽然无法在达到某种使用规模后继续生存，但它能够在未越过那个门槛之前就实现其运营目标。这是技能还是运气？如果设计者知道系统无法扩展，但同时也知道系统永远不会达到需要那样扩展的地步，那么我们可以假设这个设计是一个有意识的决定。例如，也许这个系统仅对某些人开放，仅供内部使用。扩展到数百万次请求是没有必要的，因为它最多也只会收到每秒几百个请求。
- en: On the other hand, if the system was designed with the idea that its usage would
    continue to grow indefinitely and the designers chose a pattern that will survive
    only up to a certain point, their success is a matter of luck. They simply did
    not reach that tipping point. Twitter was a well-designed system until it became
    so popular it started falling apart, serving users the notorious “fail whale”
    cartoon instead of their content. Overnight, the engineers who built the social
    media platform and the technology it used went from being perceived as skillful
    operators with superior code to a bunch of rank amateurs with an overhyped, dumbed-down
    programming language. They were neither geniuses nor dummies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果系统的设计初衷是其使用会持续增长，并且设计者选择了一个只会在某个临界点之前有效的模式，那么他们的成功就是运气问题。他们只是没有到达那个临界点。Twitter曾是一个设计良好的系统，直到它变得如此受欢迎，以至于开始崩溃，向用户展示了著名的“故障鲸鱼”卡通而不是他们的内容。一夜之间，构建这个社交媒体平台及其所使用技术的工程师，从被认为是熟练操作员和优越代码的创造者，变成了一群使用过度炒作、简化编程语言的普通业余者。他们既不是天才，也不是傻瓜。
- en: Scale always involves some luck. You can plan for a certain number of transactions
    or users, but you can’t really control those factors, especially if you’re building
    anything that involves the public internet. Software systems tend to incorporate
    multiple technologies working together to complete some task. I don’t know anyone
    who can predict how multiple technologies will behave in every potential scale
    condition, especially not when they are combined. Engineering teams do their best
    to mitigate potential problems, but they will never be able to foresee every possible
    combination of events. For that reason, whether a service works at its initial
    scale and then continues to work as it grows is always a mix of skill and luck.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展始终涉及一些运气。你可以为一定数量的交易或用户做规划，但你无法真正控制这些因素，尤其是当你构建的是涉及公共互联网的任何内容时。软件系统通常会集成多种技术协同工作来完成某个任务。我不知道有人能预测在每一种可能的规模条件下多种技术的表现，尤其是在它们被结合在一起时。工程团队会尽最大努力减轻潜在问题，但他们永远无法预见所有可能的事件组合。因此，服务在其初始规模上是否能正常运行，并随着其增长持续正常运行，始终是技能与运气的结合。
- en: Easy and Also Impossible
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容易也不可能
- en: In 1988, computer scientist Hans Moravec observed that it was really hard to
    teach computers to do very basic things, but it was much easier to program computers
    to do seemingly complex things. Skills that had been evolving for thousands of
    years to solve problems like walking, answering questions, and identifying objects
    were intuitive, subconscious, and impossibly difficult to teach a computer how
    to do. Meanwhile skills that had not been a part of the human experience for thousands
    of years—like playing chess or geolocation—were relatively straightforward. His
    theory connecting this paradox to evolution, which had been observed by other
    contemporaneous AI researchers, gained enough traction that the paradox itself
    was named after him.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1988年，计算机科学家汉斯·莫拉维克观察到，教计算机做一些非常基础的事情非常困难，但编程计算机去做看似复杂的事情却容易得多。那些已经发展了数千年，用来解决像走路、回答问题和识别物体等问题的技能是直觉性的、潜意识的，且极其难以教会计算机。而与此同时，那些数千年来并未成为人类经验的一部分的技能——比如下棋或地理定位——相对来说要简单得多。他将这个悖论与进化联系起来的理论，得到了其他同时期AI研究人员的关注，以至于这个悖论最终以他的名字命名。
- en: In Moravec’s own words, “It is comparatively easy to make computers exhibit
    adult-level performance on intelligence tests or playing checkers, and difficult
    or impossible to give them the skills of a one-year-old when it comes to perception
    and mobility.”^([1](#c04-footnote-1))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用莫拉维克自己的话来说，“让计算机在智力测试或玩跳棋时表现出成人水平的能力是比较容易的，而在感知和运动方面，让它们具备一岁婴儿的技能却是困难甚至不可能的。”^([1](#c04-footnote-1))
- en: Those wishing to upgrade large complex systems would do well to keep Moravec’s
    paradox in mind. Systems evolve much faster than nature, but just as in nature,
    as the system evolves, more and more of its underlying logic becomes obscured.
    When we get used to something just working a certain way, we tend to forget about
    it. Once we’ve stopped thinking about it, we fail to factor it into our plans
    to modernize.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那些希望升级大型复杂系统的人，最好牢记莫拉维克悖论。系统的进化速度远远超过自然，但就像自然界一样，随着系统的进化，它的基础逻辑变得越来越难以理解。当我们习惯于某个东西总是以某种方式运作时，我们往往会忘记它。一旦我们不再思考它，就会忽视它在现代化计划中的重要性。
- en: We assume that successful systems solved their core problems well, but we also
    assume things that just work without any thought or effort are simple when they
    may in fact bear the complexity of years of iteration we’ve forgotten about.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设成功的系统解决了其核心问题，但我们也假设那些不需要任何思考或努力就能正常工作的东西其实是简单的，而实际上，它们可能承载了多年迭代的复杂性，而这些我们早已忘记。
- en: This is especially true when the system has multiple layers of abstraction and
    even more so when those abstractions grow past the application boundaries itself—when
    they leverage operating system APIs or even hardware interfaces. When was the
    last time you thought about whether your favorite software is compatible with
    the chip architecture on your computer? When was the last time you needed to hunt
    down a specific driver to get a new accessory to work with your operating system?
    If you were born after the 1990s, you might never have thought about these things
    at all. Hardware and software interfaces haven’t gotten simpler in the last two
    decades, we’ve just abstracted away a lot of annoying differences that made the
    issue of x86 versus x64 or downloading drivers a normal part of working even casually
    with computers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统有多层抽象时，这一点尤其成立，尤其是当这些抽象超出了应用程序的边界时——当它们利用操作系统 API 甚至硬件接口时。你上一次考虑过你的常用软件是否与电脑上的芯片架构兼容是什么时候？你上一次为了让一个新配件与操作系统兼容而需要寻找特定驱动程序是什么时候？如果你是在
    1990 年代之后出生的，或许你从未想过这些问题。硬件和软件接口在过去二十年中并没有变得更简单，我们只是抽象掉了许多让 x86 与 x64 的问题，或者下载驱动程序成了与计算机交互时正常部分的那些令人烦恼的差异。
- en: With very old legacy systems, the abstraction layers might not be there, or
    worse, they themselves might be out-of-date. I like to call this problem *overgrowth*,
    and it’s worth describing in detail.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常古老的遗留系统，可能没有抽象层，或者更糟的是，这些抽象层本身可能已经过时。我喜欢称这个问题为*过度生长*，值得详细描述。
- en: 'Overgrowth: The Application and Its Dependencies'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过度生长：应用程序及其依赖项
- en: '*Overgrowth* is a particular type of coupling between the software and the
    layers of abstraction making up the platform on which it runs. The perils of dependency
    management are well known, but with legacy systems, dependency management is about
    more than just what a package manager might install. The older a system is, the
    more likely the platform on which it runs is itself a dependency. Most modernization
    projects do not think about the platform this way and, therefore, leave the issue
    as an unpleasant surprise to be discovered later.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*过度生长*是软件与构成其运行平台的抽象层之间的一种特定类型的耦合。依赖管理的危险众所周知，但对于遗留系统，依赖管理不仅仅是包管理器可能安装的内容。系统越老，它运行的平台就越可能本身就是一个依赖项。大多数现代化项目并没有以这种方式思考平台，因此会把这个问题作为一个令人不快的惊喜，等待后续发现。'
- en: We’ve made huge leaps in cross-compatibility, but we’ve not yet reached the
    state where applications are 100 percent platform-agnostic, nor are we ever likely
    to achieve that completely.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在跨平台兼容性方面取得了巨大的进步，但我们尚未达到应用程序 100% 平台无关的状态，也不太可能完全实现这一目标。
- en: For that reason, we cannot modernize a system without considering the underlying
    platform. Which features of that platform are unique, and which are found in other
    options? How old is the platform, and has it since been supplanted by a completely
    different way of doing things?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在现代化一个系统时，不能忽视底层平台。这个平台有哪些特性是独特的，哪些是其他选项也可以找到的？这个平台有多老，是否已经被一种完全不同的方式所取代？
- en: What makes major migrations so tricky is that as software ages, elements of
    the platform on which it was defined to run fall out of fashion, and support for
    those elements on other platforms becomes less and less common. This means that
    on our oldest systems, there is typically logic that either must be written out
    of the system or must be reproduced on a modern platform. The existing platform
    becomes auxiliary software that grows around whatever is being migrated. If you’re
    switching databases, for example, you’re not just moving the data. You might have
    to rewrite your queries in a different language or a different implementation
    of SQL. You may need to rethink hooks or stored procedures. One software language
    often has any number of minor languages that facilitate specific functions. There
    are command processors like bash or JCL that trigger jobs, templating languages
    to build interfaces, querying languages to access data, and so on. How well is
    business logic separated out between these layers? Does logic stay where it is
    sensible, or is it injected to where it is convenient?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使得重大迁移如此棘手的是，随着软件的老化，其所定义运行的平台的元素逐渐过时，且在其他平台上对这些元素的支持越来越少。这意味着在我们最老的系统中，通常存在需要从系统中剔除或必须在现代平台上重新构建的逻辑。现有平台变成了围绕被迁移内容的辅助软件。例如，如果你在更换数据库，你不仅仅是在迁移数据。你可能需要用不同的语言或
    SQL 的不同实现来重写查询。你可能需要重新思考钩子或存储过程。一个软件语言往往有许多次要语言，专门执行特定功能。有像 bash 或 JCL 这样的命令处理器来触发作业，还有模板语言来构建界面，查询语言来访问数据，等等。商业逻辑在这些层次之间是如何分离的？逻辑是否停留在合理的位置，还是被注入到方便的位置？
- en: Most web development projects, for example, run on Linux machines. Therefore,
    it is not uncommon for web applications to include shell scripts as part of their
    code base—particularly as part of the setup/installation routine. Imagine what
    migrating those applications would feel like 20 years in the future if Linux were
    supplanted by a different operating system. We would potentially have to rewrite
    all the shell scripts as well as migrate the actual application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 web 开发项目，例如，运行在 Linux 机器上。因此，web 应用程序通常会包含 shell 脚本作为其代码库的一部分——特别是在设置/安装过程中。想象一下，如果
    Linux 被其他操作系统取代，迁移这些应用程序在 20 年后的未来会是什么样子。我们可能需要重写所有的 shell 脚本，还需要迁移实际的应用程序。
- en: Smart engineers will point out that with containerization and configuration
    management tools, such scripts should be a thing of the past, but that’s precisely
    why overgrowth is an issue for legacy code. At one point, doing certain tasks
    via shell script was commonplace; this has since been overtaken by a different
    approach. If we want to migrate an older application, we may find that this older
    approach is not supported by the technology we want to use. We must migrate the
    auxiliary software first.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的工程师会指出，使用容器化和配置管理工具后，这些脚本应该已经是过去式了，但这正是过度增长成为遗留代码问题的原因。曾经，很多任务都是通过 shell
    脚本来完成的；这一做法后来被另一种方法取代。如果我们想迁移一个旧应用程序，我们可能会发现这种旧的做法并不被我们想使用的技术所支持。我们必须先迁移辅助软件。
- en: For modern applications, overgrowth is not usually a significant blocker. Languages
    from the same general era of computing tend to share ecosystems, so it is easier
    to pull out one language and replace it with another while making only minimum
    changes to the auxiliary software around it. Remember, overgrowth is just another
    form of coupling. Coupling is not necessarily a bad thing if the value add is
    there.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代应用程序而言，过度增长通常不是一个重大障碍。来自同一计算机时代的编程语言通常共享生态系统，因此，替换一种语言为另一种语言时，只需要对周围的辅助软件进行最小的更改就更容易了。记住，过度增长只是另一种形式的耦合。如果这种耦合的价值是存在的，它不一定是坏事。
- en: In older applications, however, people seem to have trouble seeing where this
    type of coupling is. We tend to forget about auxiliary software, just as we forget
    the complex processes behind the simple tasks Moravec struggled to program computers
    to do. The longer a piece goes without being upgraded, the less likely modern
    platforms and tools will support it. As auxiliary software slides out of support,
    the challenge of modernizing the actual code becomes more complicated.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在旧有的应用程序中，人们似乎很难看到这种类型的耦合。我们往往会忽略辅助软件，就像我们忘记了莫拉维克（Moravec）曾为编程计算机完成简单任务所付出的复杂努力一样。一段程序未升级的时间越长，现代平台和工具支持它的可能性就越小。当辅助软件逐渐失去支持时，现代化实际代码的挑战就变得更加复杂。
- en: Look for overgrowth at integration points, places where the communication layer
    changes. There are a few different transitions where you are likely to find it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成点处查找过度生长，即通信层发生变化的地方。有几种不同的过渡点，你可能会在这些地方发现过度生长。
- en: 'Shifting Vertically: Moving from One Abstraction Layer to Another'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垂直迁移：从一个抽象层移动到另一个抽象层
- en: 'Many layers exist between modern software and the physical voltage moving through
    circuits in a machine. On the most basic level, we can define three layers: the
    software, the hardware, and an operating system between them. Overgrowth when
    shifting up or down these layers typically takes the form of proprietary standards,
    especially with older technology where the manufacturer of the hardware would
    also provide the software. Look out for situations where your application code
    depends on APIs specific to your operating system or, worse, when it’s specific
    to the chip architecture of the physical machine on which it runs. This was a
    common problem with old mainframes. Software was written in a variant of Assembly
    specific to both the company that built the mainframe and usually the model of
    the machine itself.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件与机器中电路中流动的物理电压之间存在许多层次。在最基础的层次上，我们可以定义三个层次：软件、硬件和它们之间的操作系统。当在这些层次之间上下迁移时，过度生长通常表现为专有标准，特别是在旧技术中，其中硬件制造商通常也会提供软件。要注意你的应用程序代码是否依赖于特定操作系统的API，或者更糟的是，是否依赖于运行该应用程序的物理机器的芯片架构。这是旧大型机中常见的问题。软件是用一种特定于构建大型机的公司以及通常是机器型号的汇编语言变体编写的。
- en: 'Shifting Horizontally: Moving from One Application to Another'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平迁移：从一个应用程序移动到另一个应用程序
- en: Just as there is legacy code, there are also legacy protocols. When two applications
    pass data back and forth between each other, if they are running on machines or
    communicating on networking equipment developed by a corporation with proprietary
    protocols, you may see some overgrowth around the connection. This is less of
    a concern with web development, because the decentralized nature of the internet
    pushed things toward standard protocols like TCP/IP, FTP, and SMTP—all of which
    have a robust ecosystem of tooling and broad support across multiple platforms.
    In other areas of software development, proprietary protocols have a larger footprint.
    How difficult these protocols are depends on how common the technology in question
    is. Proprietary protocols from large vendors are probably supported by other options.
    For example, Microsoft Exchange Server protocols are proprietary but well supported,
    while an application dependent on AppleTalk might prove difficult to migrate.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像有遗留代码一样，也有遗留协议。当两个应用程序在彼此之间传递数据时，如果它们运行在由公司开发的机器上，或者在使用专有协议的网络设备上进行通信，你可能会在连接周围看到一些过度生长。这在
    web 开发中不太成问题，因为互联网的去中心化特性推动了标准协议的普及，如 TCP/IP、FTP 和 SMTP——这些协议都有强大的工具生态系统，并在多个平台上得到了广泛支持。在软件开发的其他领域，专有协议的影响范围更大。这些协议的难易程度取决于相关技术的普及程度。来自大型供应商的专有协议可能会被其他选项支持。例如，Microsoft
    Exchange Server 协议是专有的，但得到了很好的支持，而依赖于 AppleTalk 的应用程序可能会发现迁移困难。
- en: Shifting from Client to Server
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从客户端到服务器的迁移
- en: This shift can take the form of specific software development kits (SDKs) for
    specific tools and integrations, drivers for specific database connections, or
    frontend to backend movement. It might horrify some engineers to know this, but
    internal web applications are still sometimes built to run on certain web browsers
    and rely on features or functions not available in others. Internet Explorer is
    the most likely culprit. Whenever you see IE as the preferred default browser
    for internal applications, double-check that the frontend of these applications
    is not using IE-specific JavaScript features. We also see this frequently with
    Adobe Acrobat. Early-generation digital forms frequently were built to leverage
    Acrobat-specific PDF features and may be difficult to move between versions of
    Acrobat. A famous story about this comes from my time at US Digital Service where
    one of the Department of Veterans Affairs’ websites refused to work unless you
    *downgraded* your version of Acrobat.^([2](#c04-footnote-2))
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化可以表现为针对特定工具和集成的特定软件开发工具包（SDK），针对特定数据库连接的驱动程序，或者前端到后端的迁移。虽然这一点可能让一些工程师感到震惊，但有些内部
    Web 应用仍然是为在特定的 Web 浏览器上运行而构建的，并且依赖于其他浏览器中不可用的功能或特性。Internet Explorer（IE）是最常见的罪魁祸首。每当你看到
    IE 被作为内部应用的首选默认浏览器时，务必再次确认这些应用的前端没有使用 IE 特有的 JavaScript 功能。我们也常常在 Adobe Acrobat
    中看到这种情况。早期的数字表单通常是为了利用 Acrobat 特定的 PDF 功能而构建的，可能在不同版本的 Acrobat 之间转换时会遇到困难。一个著名的故事来自我在美国数字服务局的工作经历，当时退伍军人事务部的一个网站只有在你*降级*
    Acrobat 版本后才能正常工作。^([2](#c04-footnote-2))
- en: Shifting Down the Dependency Tree
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向下转移依赖树
- en: As programming languages mature, they occasionally introduce breaking changes
    to their syntax or internal logic. Not all dependencies upgrade to handle those
    changes at the same pace, creating a mess where the application cannot be upgraded
    until the dependencies are upgraded. In applications that are very old, it is
    likely that some of those dependencies are no longer in active development. For
    instance, perhaps the maintainers never rolled out a version that is compatible
    with the newest version of Java or Node.js, and to get that support, the application
    must switch to a completely different option.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 随着编程语言的成熟，它们偶尔会对语法或内部逻辑进行破坏性更改。并非所有依赖都会以相同的速度升级以处理这些变化，这就导致了应用无法升级，直到相关依赖被升级为止。在非常古老的应用中，这些依赖可能已经不再处于积极开发状态。例如，可能维护者从未推出过与最新版本的
    Java 或 Node.js 兼容的版本，而要获得该支持，应用必须切换到完全不同的选项。
- en: Cutting Back the Overgrowth
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 削减过度生长
- en: Cutting back overgrowth is not technically hard; it is just frustrating and
    demoralizing. Overgrowth slows things down, and if not accurately assessed, it
    creates unfortunate surprises that affect a team’s confidence. To minimize its
    impact, start off by mapping the application’s context. What does it run on? What
    is the process around creating a new instance of it? Map its dependencies two
    levels down.^([3](#c04-footnote-3)) Attempt to trace the flow of data through
    the application to complete one request. This should give you a clearer picture
    of where there are likely to be problems. If you can put these problems on a road
    map, they have less dramatic impact on morale.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 削减过度生长从技术上来说并不难；它只是令人沮丧和士气低落。过度生长会减缓进度，如果没有准确评估，就会产生意外的惊喜，影响团队的信心。为了最小化其影响，首先需要绘制应用的上下文图。它运行在什么环境中？创建新实例的过程是什么？将其依赖关系映射到两级深度。^([3](#c04-footnote-3))
    尝试追踪应用中数据的流动过程，直到完成一个请求。这应该能让你更清楚地看到可能存在问题的地方。如果你能把这些问题列入路线图，它们对士气的影响就会小得多。
- en: You might be tempted to think that modern software development is improving
    this situation. Cross-compatibility is much better than it used to be, that’s
    true, but the growth of the platform as a service (PaaS) market for commercial
    cloud is increasing the options to program for specific platform features. For
    example, the more you build things with Amazon’s managed services, the more the
    application will conform to fit Amazon-specific characteristics, and the more
    overgrowth there will be to contend with if the organization later wants to migrate
    away.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得现代软件开发正在改善这一情况。跨平台兼容性比以前好多了，这是事实，但商业云的 PaaS（平台即服务）市场的增长也在增加为特定平台功能编程的选项。例如，越多地使用亚马逊的托管服务来构建应用，应用就越会符合亚马逊特有的特征，若该组织后来想要迁移，这种“过度生长”就会带来更多的麻烦。
- en: Automation and Conversion
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化与转换
- en: The last assumption people make about legacy systems is that because computers
    can read the code they are trying to modernize, there must be some way to automate
    the process. They introduce tools like transpilers and static analysis with the
    intention of making modernization faster and more efficient.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 人们对遗留系统的最后一个假设是，既然计算机能够读取他们试图现代化的代码，那么一定有某种方式来自动化这个过程。他们引入像转译器和静态分析这样的工具，目的是让现代化过程变得更快、更高效。
- en: Those tools are useful, but only if the expectations for them are realistic.
    If you use them as guides to help inform the process, your modernization team
    can move strategically, side-stepping critical mistakes and maybe reducing some
    costs. However, if you use them as shortcuts and skimp on making a true investment
    in modernization, they will likely let you down. Organizations that think the
    tools are the solution typically end up with longer, more painful, and more expensive
    modernizations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具很有用，但前提是对它们的预期是现实的。如果你把它们当作指导工具来帮助完善过程，你的现代化团队可以采取战略性方法，避免关键错误，并可能减少一些成本。然而，如果你把它们当作捷径，省略了真正对现代化的投资，它们很可能会让你失望。那些认为工具是解决方案的组织，通常会经历更长、更痛苦和更昂贵的现代化过程。
- en: So, what do these tools do exactly, and what’s the right way to use them?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些工具究竟做了什么，如何正确使用它们呢？
- en: Transpiling Code
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转译代码
- en: '*Transpiling* is the process of automatically translating code written in one
    programming language into another programming language. It makes sense to use
    a transpiler when the difference between the language being read and the language
    in which the output will be written is not significant. For example, Python version
    3 had enough breaking changes in it that the transition actually required engineers
    to migrate their code bases rather than simply upgrade them. At the same time,
    Python 3 did not change any of the fundamental philosophies of Python itself,
    just some implementation details. Transpiling worked so well that tools for Python
    2 to Python 3 conversion and Python 3 to Python 2 conversion are now built in
    to Python 3.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*转译*是将用一种编程语言编写的代码自动翻译成另一种编程语言的过程。当被读取的语言与输出将写入的语言之间的差异不大时，使用转译器是有意义的。例如，Python
    3有足够多的破坏性更改，实际上需要工程师迁移他们的代码库，而不仅仅是进行升级。与此同时，Python 3并没有改变Python本身的任何基本哲学，只是一些实现细节。转译工作得如此出色，以至于Python
    3内置了Python 2到Python 3和Python 3到Python 2的转换工具。'
- en: Another great use case for transpilers is when the language that the transpiler
    is reading was specifically designed to enforce good practices on the language
    the transpiler is writing. JavaScript has many different variants of this approach,
    such as CoffeeScript and TypeScript.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 转译器的另一个典型用例是，当转译器读取的语言专门设计用于强制执行转译器所编写语言的良好实践时。JavaScript有许多不同的变种，例如CoffeeScript和TypeScript。
- en: When the differences between the input and output languages are significant,
    transpiling becomes more problematic, and time-saving expectations need to be
    managed properly to ensure a successful outcome. The classic example of this use
    case is COBOL to Java. COBOL is procedural, imperative, and fixed-point by default.
    Java is object-oriented and floating-point by default. Transpiling COBOL to Java
    may produce code that works, but it will not be maintainable unless engineers
    go over the code and fine-tune it. Often this means rewriting parts of it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入和输出语言之间的差异较大时，转译变得更加复杂，节省时间的预期需要得到适当的管理，以确保成功的结果。这种用例的经典例子是从COBOL到Java的转译。COBOL是默认的过程式、命令式和定点数语言，而Java则是面向对象的，且默认使用浮点数。将COBOL转译为Java可能会生成可用的代码，但除非工程师对代码进行检查和微调，否则代码将无法维护。通常这意味着需要重写部分代码。
- en: If you are going to use a transpiler for that kind of upgrade, it is absolutely
    essential that the application has well-designed and comprehensive test suites,
    preferably automated ones. The bugs created by automatically translating one language
    to another, completely different language can be subtle and difficult to track
    down. For example, when you try to put an eight-digit number into a variable defined
    as having seven digits, COBOL truncates the last digit and moves on. Java, on
    the other hand, throws an exception. The transpiler will not add code to handle
    these exceptions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用转译器进行这种升级，那么至关重要的一点是应用程序必须拥有设计良好且全面的测试套件，最好是自动化测试套件。通过将一种语言自动转换为另一种完全不同的语言所产生的错误可能是微妙的，且难以追踪。例如，当你尝试将一个八位数的数字放入一个定义为七位数的变量时，COBOL
    会截断最后一位并继续执行。另一方面，Java 会抛出异常。转译器不会添加代码来处理这些异常。
- en: People often invest in transpilers to help upgrade their legacy code because
    they think it will save engineering time to have a computer program do the first
    pass, or they think it will replace the need for experts in the original language
    to assist altogether. But when the two languages have significant differences,
    the output of such transpilers doesn’t usually follow the structure and conventions
    of the language in which it writes. Transpilers are not capable of rethinking
    how you organize your code. Transpiled COBOL is Java written as if it were COBOL,
    and therefore, it’s unintelligible to most Java programmers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常投资转译器来帮助升级遗留代码，因为他们认为让计算机程序做第一次转换会节省工程时间，或者他们认为转译器会完全替代原语言专家的帮助。但当两种语言有显著差异时，这种转译器的输出通常不会遵循它所写语言的结构和约定。转译器无法重新思考你如何组织代码。转译后的
    COBOL 就是将其当作 COBOL 编写的 Java，因此大多数 Java 程序员无法理解。
- en: The success stories around this kind of transpiling typically come from companies
    that use their transpiling solution as a gateway to consulting services. That
    is to say, first you buy licenses to use the transpiler, and then you buy the
    talent to rewrite the transpiler’s output into something workable. This is a fine
    strategy, as long as you know that’s what you’re getting into.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转译技术的成功案例通常来自那些将转译解决方案作为咨询服务入口的公司。也就是说，首先你购买转译器的许可证，然后你再雇佣人才将转译器的输出重写成可工作的内容。这是一种不错的策略，只要你知道你正在做什么。
- en: Static Analysis
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态分析
- en: 'Although it hasn’t gained much traction outside a theoretical context, some
    interesting work in academia has been done around deploying various forms of static
    analysis to explore and ultimately improve legacy systems. So-called software
    renovation combines techniques from compiler design and reverse engineering to
    steer the refactoring process. Software renovation is intended to be semi-automatic:
    the analysis is automatic, but software engineers do the actual work of restructuring
    the code.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在理论领域之外尚未得到广泛应用，但学术界在利用各种静态分析方法探索并最终改进遗留系统方面做了一些有趣的工作。所谓的软件翻新结合了编译器设计和逆向工程的技术，旨在引导重构过程。软件翻新是半自动的：分析是自动化的，但软件工程师需要实际进行代码重构工作。
- en: 'Some common types of static analysis used for software renovation include the
    following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的静态分析类型用于软件翻新，包括以下几种：
- en: Dependency graphs In this style of software renovation, the dependency graph
    is mapped, and clustering algorithms are used to determine where there is overlap,
    redundancy, unused libraries, or circular dependencies.^([4](#c04-footnote-4))
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖图 在这种软件翻新方式中，依赖图会被映射，并使用聚类算法来确定是否存在重叠、冗余、未使用的库或循环依赖^([4](#c04-footnote-4))。
- en: Grammars These are language-specific tools that produce analysis by parsing
    the abstract syntax tree. Typically they look for duplicate code or specific practices
    that are considered anti-patterns (like goto statements).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语法 这些是特定语言的工具，通过解析抽象语法树进行分析。通常它们会查找重复的代码或被认为是反模式的特定做法（如 goto 语句）。
- en: Control flow/data flow graphs These graphs are tools that track how software
    executes. Control flow graphs map the order in which lines of code are executed,
    while data flow graphs map the variable assignments and references. You can use
    such analysis to discover lost business requirements or track down dead code.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制流/数据流图 这些图表是追踪软件执行方式的工具。控制流图映射了代码执行的顺序，而数据流图则映射了变量的赋值和引用。你可以使用这样的分析来发现丢失的业务需求或追踪死代码。
- en: Software renovation methodology hasn’t quite broken out of theoretical studies,
    but static analysis tools are available both as stand-alone products and as features
    of larger integrated development environments or continuous integration and deployment
    solutions. This is unfortunate because the methodology is what drives the bulk
    of the impact. The tools themselves are not as important as the phases of excavating,
    understanding, documenting, and ultimately rewriting and replacing legacy systems.
    Tools will come and go.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 软件翻新方法学尚未完全脱离理论研究，但静态分析工具无论是作为独立产品，还是作为大型集成开发环境或持续集成与部署解决方案的功能，都已可用。这是令人遗憾的，因为方法学是驱动大部分影响的关键。工具本身没有方法学重要，挖掘、理解、记录，最终重写和替换遗留系统的阶段才是关键。工具会来来去去。
- en: A Guide to Not Making Things Harder
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不让事情变得更难的指南
- en: Expectation management is really important. Typically organizations make the
    mistakes described in this chapter because they believe they are making the process
    more efficient. They misjudge how long modernization projects take, and they misjudge
    how much time they can save and how to save it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 期望管理非常重要。通常，组织会犯本章所描述的错误，因为他们认为自己正在提高流程效率。他们错误估计了现代化项目所需的时间，错误判断了可以节省多少时间以及如何节省。
- en: 'Modernization projects have better outcomes when we replace the false assumptions
    described at the opening of this chapter with the following guidelines:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用以下准则替代本章开头描述的错误假设时，现代化项目会有更好的成果：
- en: Keep it simple. Don’t add new problems to solve just because the old system
    was successful. Success does not mean the old system completely solved its problem.
    Some of those technical decisions were wrong, but never caused any problems.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持简单。不要因为旧系统成功就添加新的问题来解决。成功并不意味着旧系统完全解决了它的问题。一些技术决策是错误的，但从未引发任何问题。
- en: Spend some time trying to recover context. Treat the platform as a dependency
    and look for coupling that won’t transfer easily to a modern platform.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花些时间尝试恢复上下文。将平台视为一个依赖项，并寻找那些不容易迁移到现代平台的耦合。
- en: Tools and automation should supplement human effort, not replace it.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具和自动化应该是对人类努力的补充，而不是替代。
- en: Individual contributors often find the barrier to following that advice is not
    convincing themselves, but convincing others. Particularly when the organization
    is big, the pressure to run projects the same way everyone else does, so that
    they look correct even at the expense of being successful, is significant. In
    later chapters, we’ll tackle navigating the organization and strategies to advance
    your goals.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 个人贡献者通常发现，遵循这一建议的障碍不在于说服自己，而在于说服他人。尤其是当组织庞大时，压力很大，要按照大家都在做的方式来推进项目，即使这样做会牺牲成功，只为了看起来是正确的。在后面的章节中，我们将探讨如何在组织中导航以及推进目标的策略。
