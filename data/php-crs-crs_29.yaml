- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 24 LOGGING EVENTS, MESSAGES, AND TRANSACTIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24 日志事件、消息和事务
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Almost all live, commercial web applications keep a *log*, a record of messages,
    errors, events, performance summaries, and other information generated by the
    application while it runs. In this chapter, we’ll explore how to maintain logs
    for PHP web applications so you can analyze application performance and respond
    to problems when they occur. You’ll learn about PHP’s built-in resources for logging,
    as well as Monolog, a popular third-party PHP logging package, and you’ll see
    how to log messages to various locations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的实时商业 Web 应用程序都会保持一个*日志*，记录应用程序在运行过程中生成的消息、错误、事件、性能摘要和其他信息。在本章中，我们将探讨如何为
    PHP Web 应用程序维护日志，以便您在应用程序发生问题时能够分析性能并做出响应。您将了解 PHP 的内置日志资源，以及 Monolog，一个流行的第三方
    PHP 日志包，还将学习如何将日志消息写入不同的地方。
- en: Sometimes a log records events for auditing purposes, such as to review electronic
    monetary transactions for irregularities. Other times, transactions are logged
    for backup and recovery purposes. For example, if something goes wrong while writing
    information to a database, the database can be returned to a correct state by
    reverting to a backup (called an *image*, or *snapshot*) from a known point in
    time and then rerunning the sequence of transactions logged after that snapshot
    was created. Logging also goes hand in hand with exceptions, which we discussed
    in the preceding chapter. When an exception is thrown, it can be recorded in the
    system log for later analysis.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，日志会记录审计事件，例如查看电子货币交易是否存在异常。其他时候，交易会被记录用于备份和恢复目的。例如，如果在向数据库写入信息时出现问题，可以通过恢复到已知时间点的备份（称为*镜像*或*快照*），然后重新运行该快照创建后记录的交易序列，从而将数据库恢复到正确的状态。日志记录也与异常密切相关，我们在上一章中已经讨论过。当抛出异常时，它可以被记录到系统日志中，供日后分析。
- en: Built-in PHP Resources for Logging
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置 PHP 日志资源
- en: Logging is such a core part of server programming that PHP provides many resources
    to facilitate it. These include a set of predefined constants corresponding to
    various log severity levels, as well as built-in functions for logging messages
    to files. We’ll explore these features now.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是服务器编程的核心部分，因此 PHP 提供了许多资源来简化这一过程。这些资源包括一组预定义常量，表示不同的日志严重性级别，以及用于将日志消息写入文件的内置函数。我们现在将探讨这些功能。
- en: Predefined Constants for Severity Levels
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 严重性级别的预定义常量
- en: Most computer logging systems allow messages to be classified according to a
    particular level of urgency or importance. To that end, PHP comes with eight predefined
    constants establishing levels of logging severity. These severity levels, numbered
    0 through 7, from most to least urgent, correspond to the eight levels laid out
    in RFC 5424, a widely used standard for the syslog protocol set by the IETF. You
    can find this protocol at *[https://www.rfc-editor.org/rfc/rfc5424](https://www.rfc-editor.org/rfc/rfc5424)*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机日志系统允许根据特定的紧急性或重要性级别对消息进行分类。为此，PHP 提供了八个预定义常量，用于确定日志的严重性级别。这些严重性级别从 0
    到 7 编号，从最紧急到最不紧急，对应于 RFC 5424 中定义的八个级别，RFC 5424 是 IETF 制定的广泛使用的 syslog 协议标准。您可以在
    *[https://www.rfc-editor.org/rfc/rfc5424](https://www.rfc-editor.org/rfc/rfc5424)*
    查找该协议。
- en: You can use the PHP constants in conjunction with the built-in syslog() function,
    which we’ll discuss next, to generate log messages of the appropriate severity
    level. [Table 24-1](#tab24-1) shows the eight severity levels, their RFC 5424
    level names, and a summary of their meanings.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以结合使用 PHP 常量和内置的 syslog() 函数（我们将在接下来的内容中讨论），生成适当严重性级别的日志消息。[表 24-1](#tab24-1)
    显示了八个严重性级别，它们的 RFC 5424 级别名称以及其含义的摘要。
- en: 'Table 24-1: Levels of Severity for Log Messages from RFC 5424'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 24-1：来自 RFC 5424 的日志消息严重性级别
- en: '| Syslog severity value | RFC 5424 log level | Meaning |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| Syslog 严重性值 | RFC 5424 日志级别 | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Emergency | The system is unusable or unavailable. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 紧急 | 系统无法使用或不可用。 |'
- en: '| 1 | Alert | A problem has happened, and immediate action is required. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 警报 | 发生了问题，需要立即采取行动。 |'
- en: '| 2 | Critical | A problem is about to happen and must be addressed immediately.
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 严重 | 问题即将发生，必须立即解决。 |'
- en: '| 3 | Error | A failure has occurred that is non-urgent but needs action in
    a given time frame. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 错误 | 发生了一个非紧急但需要在一定时间内采取行动的故障。 |'
- en: '| 4 | Warning | An event requires action, since it is likely to lead to an
    error. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 警告 | 需要采取行动，因为该事件可能导致错误。 |'
- en: '| 5 | Notice | An expected but significant event has occurred that warrants
    logging, but no action is required. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 通知 | 发生了一个预期但重要的事件，值得记录日志，但不需要采取任何行动。 |'
- en: '| 6 | Info | An expected event has occurred for reporting and measurement.
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 信息 | 发生了一个预期的事件，供报告和度量使用。 |'
- en: '| 7 | Debug | Used by software developers to record detailed information supporting
    current debugging and code analysis. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 调试 | 用于软件开发人员记录支持当前调试和代码分析的详细信息。 |'
- en: '[Table 24-2](#tab24-2) shows the eight named PHP constants corresponding to
    the RFC 5424 log levels as well as the integer values of these constants for macOS,
    Unix, and Windows systems.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 24-2](#tab24-2) 显示了与 RFC 5424 日志级别相对应的 PHP 八个命名常量，以及这些常量在 macOS、Unix 和 Windows
    系统中的整数值。'
- en: 'Table 24-2: PHP Log-Level Constants'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表 24-2：PHP 日志级别常量
- en: '| PHP constant | macOS and Unix value | Windows value |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| PHP 常量 | macOS 和 Unix 值 | Windows 值 |'
- en: '| --- | --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| LOG_EMERG | 0 | 1 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| LOG_EMERG | 0 | 1 |'
- en: '| LOG_ALERT | 1 | 1 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| LOG_ALERT | 1 | 1 |'
- en: '| LOG_CRIT | 2 | 1 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| LOG_CRIT | 2 | 1 |'
- en: '| LOG_ERR | 3 | 4 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| LOG_ERR | 3 | 4 |'
- en: '| LOG_WARNING | 4 | 5 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| LOG_WARNING | 4 | 5 |'
- en: '| LOG_NOTICE | 5 | 6 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| LOG_NOTICE | 5 | 6 |'
- en: '| LOG_INFO | 6 | 6 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| LOG_INFO | 6 | 6 |'
- en: '| LOG_DEBUG | 7 | 6 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| LOG_DEBUG | 7 | 6 |'
- en: On macOS and Unix systems, each constant has an integer value corresponding
    to one of the eight severity levels. For example, the LOG_EMERG constant has a
    value of 0 in macOS and Unix. If you’re running PHP on a Windows server, the values
    of these constants are slightly different, because of different standards for
    system header files. For all systems, however, the severity of the log level increases
    as the value of the constant decreases, in line with the principles of RFC 5424\.
    We’ll refer to the macOS and Unix values throughout this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 和 Unix 系统中，每个常量都有一个整数值，对应八个严重性级别中的一个。例如，LOG_EMERG 常量在 macOS 和 Unix 中的值为
    0。如果你在 Windows 服务器上运行 PHP，这些常量的值会有所不同，因为系统头文件的标准不同。无论哪种系统，日志级别的严重性随着常量值的减少而增加，这与
    RFC 5424 的原则一致。在本章中，我们将以 macOS 和 Unix 的值为准。
- en: The various severity levels have their own conventional uses. When testing and
    debugging code, for example, it’s customary to use LOG_DEBUG severity and perhaps
    to direct these log entries to their own debugging logfile. You might log messages
    about standard, noncritical issues, such as a user trying to upload files that
    are too big or of the wrong file type, with a severity of LOG_INFO or LOG_NOTICE.
    This way, user-interface or file-size improvements could be considered if the
    same issues occur many times. Much thought should go into events likely to lead
    to errors, and these should be logged as LOG_ERR severity. Likewise, it’s always
    important when coding for exceptions to identify those that might impact the overall
    functioning of the web application and log them with LOG_EMERG, LOG_ALERT, or
    LOG_CRIT severity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 各种严重性级别有其传统用途。例如，在测试和调试代码时，通常使用 LOG_DEBUG 严重性，可能会将这些日志条目定向到自己的调试日志文件中。你可能会将关于标准、非关键问题的消息记录为
    LOG_INFO 或 LOG_NOTICE 严重性，比如用户尝试上传过大或类型错误的文件。这样，如果同样的问题多次发生，就可以考虑对用户界面或文件大小进行改进。应当充分考虑那些可能导致错误的事件，并将其记录为
    LOG_ERR 严重性。同样，编写异常处理代码时，识别那些可能影响 Web 应用程序整体功能的异常，并使用 LOG_EMERG、LOG_ALERT 或 LOG_CRIT
    严重性进行记录，始终是非常重要的。
- en: Classifying log messages by severity level allows you to design computer systems
    with logic to respond to new log messages of different importance in different
    ways. For example, when a new log message occurs at the top three severity levels
    (Emergency, Alert, or Critical), the logging system rules might perform actions
    such as sending text messages and automated phone calls to the site technicians
    listed as being on call. Meanwhile, messages of lower importance might be written
    to archive files or perhaps sent via a web API to a cloud logging system. We’ll
    explore an example of creating customized responses for different severity in
    “Managing Logs According to Severity” on [page 466](#pg_466).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按照严重性级别对日志消息进行分类，可以让你设计出具有逻辑响应的计算机系统，以不同的方式应对不同重要性的日志消息。例如，当新的日志消息出现在前三个严重性级别（紧急、警报或危急）时，日志系统规则可能会执行诸如发送短信和自动电话呼叫给值班技术人员等操作。与此同时，较低重要性的消息可能会被写入归档文件，或者通过
    Web API 发送到云日志系统。我们将在《根据严重性管理日志》一节中详细讨论如何为不同的严重性级别创建定制化响应，[第 466 页](#pg_466)。
- en: '#### Logging Functions'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 日志功能'
- en: 'PHP has two built-in functions for logging messages: error_log() and syslog().
    They differ based on where the messages get logged.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 有两个内置的函数用于记录消息：error_log() 和 syslog()。它们的区别在于消息记录的位置。
- en: The error_log() function appends to the PHP error logfile, whose location is
    defined by the error_log path in your *php.ini* file or your server log settings,
    or to another location that can be passed as a parameter when calling the function.
    (See [Appendix A](appendix-a.xhtml) for information on how to locate your system’s
    *php.ini* file.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: error_log() 函数将消息附加到 PHP 错误日志文件，该文件的位置由 *php.ini* 文件中的 error_log 路径或服务器日志设置定义，或者可以通过调用函数时作为参数传递到其他位置。（有关如何定位系统的
    *php.ini* 文件的信息，请参见 [附录 A](appendix-a.xhtml)）
- en: By contrast, the syslog() function appends messages to your computer system’s
    general syslog file. [Table 24-3](#tab24-3) shows the default name and location
    of this file on macOS, Unix, and Windows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，syslog() 函数将消息附加到计算机系统的通用 syslog 文件中。[表 24-3](#tab24-3) 显示了该文件在 macOS、Unix
    和 Windows 上的默认名称和位置。
- en: 'Table 24-3: Default Names and Locations of Syslog Files'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表 24-3：Syslog 文件的默认名称和位置
- en: '| Operating system | Filename | Location |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 操作系统 | 文件名 | 位置 |'
- en: '| --- | --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| macOS | system.log | /var/log |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| macOS | system.log | /var/log |'
- en: '| Unix | syslog | /etc |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Unix | syslog | /etc |'
- en: '| Windows | SysEvent.evt | C:\WINDOWS\system32\config\ |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Windows | SysEvent.evt | C:\WINDOWS\system32\config\ |'
- en: 'When setting up an application, choosing where to log messages can be difficult:
    Do you want to have dedicated logfiles just for this application, do you want
    to log your PHP web application messages to the same location as other PHP logs,
    or do you want logs from the application to be added to the computer system’s
    general logging system? As you’ll see in “Logging to the Cloud” on [page 472](#pg_472),
    using a third-party logging library provides even more options to select from:
    choosing the filename and location, using multiple files for different log types,
    or even logging to a web API.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置应用程序时，选择记录消息的位置可能会很困难：你是想为这个应用程序单独设置日志文件，还是想将 PHP Web 应用程序的日志记录到与其他 PHP 日志相同的位置，或者你希望将应用程序的日志添加到计算机系统的通用日志系统中？正如你将在
    [第 472 页](#pg_472) 的“记录到云端”中看到的，使用第三方日志库提供了更多的选择：选择文件名和位置、使用多个文件记录不同类型的日志，甚至可以记录到
    Web API。
- en: The decision partly depends on the nature of the project. For personal project
    development, logging to your local machine might make sense, whereas for mission-critical
    reporting of a live production system, logging to files on a web server or the
    cloud is probably more appropriate and may be mandated by the requirements and
    standards of the organization you’re working for.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用哪个函数在一定程度上取决于项目的性质。对于个人项目开发，将日志记录到本地机器可能是合理的，而对于需要报告实时生产系统的关键任务系统，可能更适合将日志记录到
    Web 服务器或云端的文件中，甚至可能是你所工作组织的要求和标准所规定的。
- en: An advantage of logging to the system’s general syslog file, as with PHP’s syslog()
    function, is that logs for all applications and processes will be in one place,
    so you can look at issues with your web application in relation to other system
    issues (such as memory or processing speed problems). Also, you can use a range
    of applications for viewing, searching, and analyzing the general logging system,
    whether it be for Windows, macOS, or Unix. However, general logs are large and
    constantly being appended to by running processes, so when developing and even
    when running a production site, targeting logs for the web application to a dedicated
    file, as with the error_log() function, can make a lot of sense. With this in
    mind, let’s take a look at how the two built-in PHP logging functions work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志记录到系统的通用 syslog 文件中的一个优点（就像 PHP 的 syslog() 函数一样）是，所有应用程序和进程的日志都集中在一个地方，因此你可以查看与你的
    Web 应用程序相关的其他系统问题（例如内存或处理速度问题）。此外，你可以使用多种应用程序来查看、搜索和分析通用日志系统，无论是 Windows、macOS
    还是 Unix。然而，通用日志文件很大，并且不断被正在运行的进程附加内容，因此在开发和运行生产站点时，将 Web 应用程序的日志定向到专用文件（如 error_log()
    函数那样）通常是更有意义的。有鉴于此，我们来看看这两个内置的 PHP 日志记录函数是如何工作的。
- en: 'You can log a message to the PHP error logfile with error_log() by writing
    a statement such as the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过写出类似以下的语句，使用 error_log() 将消息记录到 PHP 错误日志文件：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Pass the message you want to log as an argument to the function. By default,
    this message will be appended to the file specified in your *php.ini* settings.
    You can view that file from the command line by using cat (macOS/Unix) or type
    (Windows), followed by the filename. For example, here’s the entry added to the
    logfile on my macOS laptop (which logs to a file named *php_error.log*) by the
    previous error_log() call:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将你想要记录的消息作为参数传递给函数。默认情况下，这条消息将被附加到*php.ini*设置中指定的文件中。你可以通过命令行使用cat（macOS/Unix）或type（Windows）命令查看该文件，后跟文件名。例如，以下是我在macOS笔记本上通过之前的error_log()调用添加到日志文件中的条目（该文件名为*php_error.log*）：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The log entry starts with a timestamp, followed by the message string passed
    as an argument to the function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 日志条目以时间戳开始，后跟作为参数传递给函数的消息字符串。
- en: 'The syslog() function takes two arguments. The first is one of the integers
    (0 through 7) indicating the severity level, or a constant declared with that
    integer value. This is where the built-in PHP constants discussed earlier come
    in. The second argument is a string message to be logged to the system’s general
    syslog file. Here’s an example call to the function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: syslog()函数接受两个参数。第一个是表示严重性级别的整数（0到7）之一，或者是用该整数值声明的常量。这正是之前讨论过的PHP内建常量的作用所在。第二个参数是要记录到系统通用syslog文件中的字符串消息。以下是调用该函数的示例：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the LOG_WARNING constant as the first argument, which PHP defines with
    a value of 4, corresponding to the fifth level on the RFC 5424 severity scale.
    This event requires action since it’s likely to lead to an error.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用LOG_WARNING常量作为第一个参数，PHP将其定义为值4，对应于RFC 5424严重性等级表中的第五级。此事件需要采取行动，因为它可能导致错误。
- en: 'The syslog file often contains hundreds or even thousands of entries, logging
    many events and actions from many system programs and applications. Rather than
    display the whole logfile, filtering it to just the entries you want is helpful.
    For macOS or Unix, you can use grep to see entries containing a certain string.
    Windows has an equivalent findstr command. Here’s an example of using grep to
    view the log entry just created with the syslog() function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: syslog文件通常包含数百甚至数千条条目，记录了来自许多系统程序和应用程序的事件和操作。与其显示整个日志文件，过滤出你需要的条目更为有用。对于macOS或Unix，你可以使用grep查看包含特定字符串的条目。Windows有等效的findstr命令。以下是使用grep查看刚刚通过syslog()函数创建的日志条目的示例：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here I’ve used grep to show only log entries containing the string "from Matt".
    (In Windows, the command would be findstr "from Matt" SysEvent.evt.) On my Apple
    MacBook, the log entry created by syslog() begins with a formatted date, followed
    by the computer name (matts-MacBook-Pro-2). Next comes the program or service
    appending to the log (in this case, php), followed by the process ID (4304), a
    number assigned by the operating system to uniquely identify each active process.
    Finally, the entry ends with the message string passed to the syslog() function.
    The contents of each syslog entry are similar for Windows, containing the event
    type, event ID, source, message, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我使用grep只显示包含字符串“from Matt”的日志条目。（在Windows中，命令将是findstr "from Matt" SysEvent.evt。）在我的Apple
    MacBook上，syslog()创建的日志条目以格式化日期开头，后跟计算机名称（matts-MacBook-Pro-2）。接下来是附加到日志的程序或服务（在这种情况下是php），然后是进程ID（4304），这是操作系统分配给每个活动进程的唯一标识符。最后，条目以传递给syslog()函数的消息字符串结束。Windows中的每个syslog条目的内容类似，包含事件类型、事件ID、来源、消息等。
- en: '> NOTE'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '> 注意'
- en: '*If you aren’t comfortable perusing syslog files at the command line, many
    applications are available for viewing, filtering, and analyzing these files.
    For example, Windows has Event Viewer, and macOS has Console.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你不习惯在命令行查看syslog文件，许多应用程序可以用来查看、过滤和分析这些文件。例如，Windows有事件查看器，而macOS有控制台。*'
- en: The Monolog Logging Library
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Monolog日志库
- en: Logging is so common in web applications that several third-party PHP libraries
    exist to help with it, including the popular Monolog library. The majority of
    PHP web frameworks and cloud logging systems provide integration with Monolog.
    It’s usually the first, and sometimes only, logging system many PHP programmers
    learn to use. The library makes it easy to develop customized, sophisticated logging
    strategies, with different types of log entries handled in different ways, and
    messages being logged to a variety of locations, including local files, cloud-based
    systems, and more.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中，日志记录非常常见，因此存在多个第三方 PHP 库来帮助处理日志，其中包括流行的 Monolog 库。大多数 PHP Web 框架和云日志系统都与
    Monolog 提供集成。它通常是许多 PHP 程序员学习使用的第一个日志系统，有时也是唯一一个。这个库使得开发定制化、复杂的日志记录策略变得更加容易，不同类型的日志条目会以不同的方式处理，日志消息可以记录到各种位置，包括本地文件、基于云的系统等。
- en: Monolog is compliant with PSR-3, a standards recommendation for PHP logging
    systems. This standard uses the same eight levels of log severity as the RFC 5424
    syslog standard. To be PSR-3 compliant, a logging interface should have methods
    for each of the eight log levels. Each method should require a string argument
    containing the message to be logged and an optional array for more information
    about the context of the message.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Monolog 遵循 PSR-3，这是一个针对 PHP 日志系统的标准推荐。该标准使用与 RFC 5424 syslog 标准相同的八个日志严重性级别。为了符合
    PSR-3 标准，日志接口应为每个日志级别提供方法。每个方法应要求一个字符串参数，该字符串包含要记录的消息，并且可以选择性地提供一个数组，以提供有关消息上下文的更多信息。
- en: NOTE
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Monolog’s source code and documentation can be found on GitHub at* [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog)*,
    and you can learn more about the PSR-3 standard at* [https://www.php-fig.org/psr/psr-3/](https://www.php-fig.org/psr/psr-3/)*.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*Monolog 的源代码和文档可以在 GitHub 上找到，网址是* [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog)*，你还可以在*
    [https://www.php-fig.org/psr/psr-3/](https://www.php-fig.org/psr/psr-3/)* *了解更多关于
    PSR-3 标准的内容。*'
- en: Let’s create an example project that uses Monolog to log messages. Create a
    new project folder and then use the command composer require monolog/monolog to
    add the Monolog library. You should now have a *composer.json* file and a *vendor*
    folder with an autoloader and the Monolog library classes. Next, create an index
    script in *public/index.php* containing the code in [Listing 24-1](#lis24-1).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用 Monolog 记录消息的示例项目。创建一个新的项目文件夹，然后使用命令 composer require monolog/monolog
    来添加 Monolog 库。现在，你应该有一个 *composer.json* 文件和一个包含自动加载器和 Monolog 库类的 *vendor* 文件夹。接下来，在
    *public/index.php* 中创建一个包含 [列表 24-1](#lis24-1) 代码的索引脚本。
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 24-1: Setting up and using Monolog in public/index.php'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 24-1：在 public/index.php 中设置和使用 Monolog
- en: As usual, our index script begins by requiring the autoloader script. Then we
    provide use statements for the Monolog Logger and StreamHandler classes. Next,
    we declare a path to *mylogs.log* in the *logs* folder for this project; this
    is where we’ll log our messages, but you could provide a path to any file you
    wish. The first time Monolog tries to append a message to this file, it will create
    the file and directory if they don’t already exist.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，我们的索引脚本通过加载自动加载器脚本开始。然后我们为 Monolog 的 Logger 和 StreamHandler 类提供使用声明。接下来，我们声明了一个指向
    *logs* 文件夹中的 *mylogs.log* 文件的路径，用于记录日志消息，但你也可以提供任何你想要的文件路径。第一次 Monolog 尝试将消息附加到这个文件时，它会在文件和目录不存在时创建它们。
- en: We next create a new Logger object to manage the logging, providing the channel
    name demo. We’ll explore channels and why they’re useful in the next section.
    Every Logger object needs one or more *log handler* classes to tell it what to
    do with log entries, so we also create a log handler by calling the Logger object’s
    pushHandler() method, passing in a new object of Monolog’s StreamHandler class.
    This is a class for logging messages to files (in our case, the *logs/mylogs.log*
    file specified in the $logFile variable), but Monolog has different handler classes
    for other actions, such as logging to the browser, a cloud API, or a database.
    We’ll explore another log handler in “Logging to the Cloud” on [page 472](#pg_472).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的 Logger 对象来管理日志，提供频道名称 demo。我们将在下一节中探讨频道及其用途。每个 Logger 对象都需要一个或多个
    *log handler* 类来告诉它如何处理日志条目，因此我们还通过调用 Logger 对象的 pushHandler() 方法来创建一个日志处理程序，并传入
    Monolog 的 StreamHandler 类的新对象。这个类用于将消息记录到文件中（在我们的例子中，是 $logFile 变量指定的 *logs/mylogs.log*
    文件），但 Monolog 也有其他处理程序类用于执行其他操作，例如记录到浏览器、云 API 或数据库。我们将在“记录到云端”一节中讨论另一个日志处理程序，见
    [第472页](#pg_472)。
- en: Since Monolog is PSR-3 compliant, Logger objects have methods for logging messages
    with each of the eight standard severity levels. We use two of these methods.
    First, we use warning() to create a warning log entry with the text 'I am a warning.'❶
    Then we use the error() method to create an error log entry with the text 'I am
    a test error!'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Monolog 遵循 PSR-3 标准，Logger 对象提供了用于记录每个八个标准严重性级别的日志消息的方法。我们使用了其中的两个方法。首先，我们使用
    warning() 方法创建一个警告日志条目，内容为 'I am a warning.'❶ 然后，我们使用 error() 方法创建一个错误日志条目，内容为
    'I am a test error!'
- en: 'After executing the index script, the contents of *logs/mylogs.log* should
    look something like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 index 脚本后，*logs/mylogs.log* 文件的内容应类似于以下内容：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Remember, you can view the file at the command line via cat (macOS and Unix)
    or type (Windows).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以通过 cat（macOS 和 Unix）或 type（Windows）在命令行查看文件。
- en: Notice that each log entry generated by Monolog starts with a timestamp, followed
    by the channel name and severity level (for example, demo .WARNING), followed
    by the log message. The empty square brackets at the end of each log entry indicate
    no additional information was provided. We’ll add more information about the context
    of the log message in “Logging Exceptions” on [page 469](#pg_469).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个由 Monolog 生成的日志条目都以时间戳开始，后跟通道名称和严重性级别（例如 demo .WARNING），然后是日志消息。每个日志条目末尾的空方括号表示没有提供额外的信息。我们将在“记录异常”部分的
    [第 469 页](#pg_469) 中添加更多关于日志消息上下文的信息。
- en: Organizing Logs with Channels
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用通道组织日志
- en: Larger systems are organized into well-defined subsystems, and knowing which
    subsystems have generated which log entries greatly aids debugging, error tracking,
    and code evaluations. Monolog makes this possible by giving each Logger object
    a channel name. By creating multiple Logger objects with unique channel names,
    you can organize your log based on the source of the entries. For example, an
    online shop might have channels like security, database, and payments for logging
    different kinds of system events.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的系统被组织成定义明确的子系统，知道哪些子系统生成了哪些日志条目对调试、错误追踪和代码评估有很大帮助。Monolog 通过为每个 Logger 对象分配通道名称，使这一点成为可能。通过创建具有唯一通道名称的多个
    Logger 对象，你可以根据日志条目的来源来组织日志。例如，一个在线商店可能会有像 security、database 和 payments 这样的通道，用于记录不同种类的系统事件。
- en: 'In the previous section, we created our Logger object to be part of the demo
    channel, and we saw how this channel name was included in each log entry. Let’s
    now modify our project to distinguish between two channels: demo and security.
    Update *public/index.php* to match the contents of [Listing 24-2](#lis24-2).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个 Logger 对象，并将其设置为 demo 通道的一部分，我们还看到该通道名称被包含在每个日志条目中。现在，让我们修改项目，以区分两个通道：demo
    和 security。更新 *public/index.php* 以匹配 [清单 24-2](#lis24-2) 的内容。
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 24-2: Logging to two separate channels in index.php'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 24-2：在 index.php 中将日志记录到两个独立的通道
- en: We create a new Logger object called $demoLogger for a channel named demo and
    set its log handler to be a StreamHandler to the *logs/mylogs.log* file. Then
    we create a second Logger object with a channel named security. Next, we use the
    $demoLogger object’s withName() method to create a clone of the object with a
    channel name of security ❶. This saves us from having to create the second Logger
    object and its log handler (which points to the same file as $demoLogger) from
    scratch.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为名为 demo 的通道创建了一个新的 Logger 对象 $demoLogger，并将其日志处理器设置为 StreamHandler，指向 *logs/mylogs.log*
    文件。然后我们创建了一个名为 security 的通道的第二个 Logger 对象。接下来，我们使用 $demoLogger 对象的 withName()
    方法，创建一个通道名为 security 的克隆对象 ❶。这样，我们就避免了重新创建第二个 Logger 对象及其日志处理器（该处理器指向与 $demoLogger
    相同的文件）。
- en: 'We now have two Logger objects, $demoLogger (channel name demo) and $securityLogger
    (channel name security). Both of these Logger objects use the same log handler,
    writing logs to *logs/mylogs.log*. Depending on which Logger object we use, we
    can ensure that log entries are marked with the appropriate channel to aid later
    logfile analysis. We finish the script by logging a message to each channel. The
    resulting contents of the *logs/mylogs.log* file should look something like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个 Logger 对象，$demoLogger（通道名为 demo）和 $securityLogger（通道名为 security）。这两个
    Logger 对象使用相同的日志处理器，将日志写入 *logs/mylogs.log* 文件。根据我们使用的 Logger 对象，可以确保日志条目被标记上适当的通道名称，从而有助于后续的日志文件分析。我们通过将消息记录到每个通道来完成脚本。最终的
    *logs/mylogs.log* 文件内容应类似于以下内容：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the error log entry went to the demo channel, while the warning
    entry went to the security channel. We could filter the logfile to show entries
    from just one of the channels by using the Unix grep or Windows findstr commands.
    For example, we could search for security channel entries by entering findstr
    "security." logs/mylogs.log in a Windows command terminal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，错误日志条目被发送到演示频道，而警告日志条目则发送到安全频道。我们可以通过使用Unix的grep命令或Windows的findstr命令过滤日志文件，仅显示某一频道的条目。例如，我们可以通过在Windows命令终端输入findstr
    "security." logs/mylogs.log来搜索安全频道的条目。
- en: Managing Logs According to Severity
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 根据严重性管理日志
- en: Beyond sorting entries into channels, we can add even more sophistication to
    our logging strategy by treating log entries differently according to their level
    of severity. Monolog can do this by adding multiple log handlers, collectively
    referred to as a *stack*, to the same Logger object. When we add a log handler,
    we can optionally specify which severity levels it applies to. We could, for example,
    have one log handler for the three most severe levels that works with a web API
    to automatically notify IT staff via text message to address the problem immediately.
    A second log handler could respond to lower severity levels and record the messages
    to a logfile.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将条目按频道分类外，我们还可以通过根据日志条目的严重性等级对其进行不同的处理，进一步提升日志记录策略的复杂性。Monolog可以通过将多个日志处理器（统称为*栈*）添加到同一个Logger对象来实现这一点。当我们添加日志处理器时，可以选择指定它适用于哪些严重性等级。例如，我们可以为三个最严重的等级设置一个日志处理器，该处理器与Web
    API配合使用，自动通过短信通知IT工作人员立即处理问题。第二个日志处理器则可以响应较低严重性的日志条目，并将消息记录到日志文件中。
- en: Monolog handlers also have an optional feature called *bubbling* that allows
    log entries to be processed by one handler and also passed (*bubbled*) down the
    stack to be processed again by other log handlers. In addition to high-severity
    log entries triggering automated messages to IT staff phones, for example, those
    same log entries could also be stored to a logfile for archive and analysis purposes,
    along with the low-severity entries. [Figure 24-1](#fig24-1) shows an example
    log handler stack that uses bubbling and manages log entries according to severity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Monolog处理器还有一个可选功能，称为*冒泡*，它允许日志条目由一个处理器处理，并且也会被传递（*冒泡*）到栈下，由其他日志处理器再次处理。例如，除了高严重性的日志条目会触发自动消息发送到IT工作人员的手机外，这些相同的日志条目也可以与低严重性的条目一起存储到日志文件中，以供归档和分析。[图
    24-1](#fig24-1)展示了一个使用冒泡机制并根据严重性管理日志条目的日志处理器栈的示例。
- en: '![](../images/figure24-1.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure24-1.jpg)'
- en: 'Figure 24-1: Using bubbling and severity levels to create a sophisticated logging
    strategy'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 24-1：使用冒泡机制和严重性等级创建复杂的日志记录策略
- en: The diagram illustrates a stack of three log handlers. At the top of the stack,
    handler1 catches any log entries of Critical or more importance (severity levels
    0 through 2) and records them in *immediateActions.log*. This first handler has
    bubbling enabled, so the high-severity log entries are also passed further down
    the stack for additional processing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了一个由三个日志处理器组成的栈。在栈的顶部，handler1捕获任何严重性为临界或更高（严重性等级0到2）的日志条目，并将其记录在*immediateActions.log*中。这个第一个处理器启用了冒泡机制，因此高严重性的日志条目也会进一步传递到栈下进行额外处理。
- en: Next in the stack is handler2, which catches all log entries of Info or more
    importance (levels 0 through 6) and records them in *infoActions.log*. Thanks
    to bubbling, the high-severity log entries will therefore be recorded in two separate
    files. Bubbling is turned off for handler2, so any log entries this handler processes
    won’t be sent down the stack for further action. As a result, the only log entries
    arriving at the bottom of the log handler stack are those of severity level 7
    (Debug). These are received by handler3 and recorded in *debug.log*. Notice that
    handler3 is set to receive log entries of any severity, but in practice it will
    receive only debug entries because all other severity levels stop at handler2.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 栈中的下一个是handler2，它捕获所有重要性为信息或更高（等级0到6）的日志条目，并将其记录在*infoActions.log*中。由于冒泡机制，高严重性日志条目因此会被记录在两个独立的文件中。handler2的冒泡功能被关闭，因此该处理器处理的任何日志条目都不会传递到栈下继续处理。因此，唯一到达日志处理栈底部的日志条目是严重性等级为7（调试）的条目。这些条目会被handler3接收，并记录在*debug.log*中。请注意，handler3被设置为接收任何严重性等级的日志条目，但实际上它只会接收调试条目，因为所有其他严重性等级的日志条目都停留在handler2处。
- en: Let’s modify our project to implement the stack of these three log handlers.
    To make sure the stack works as expected, we’ll generate log entries for all eight
    levels of severity and check the contents of the three logs. Update *public/index.php*
    as shown in [Listing 24-3](#lis24-3).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改项目，实施这三个日志处理程序的堆栈。为了确保堆栈按预期工作，我们将为所有八个严重性级别生成日志条目，并检查三个日志的内容。更新*public/index.php*，如[清单24-3](#lis24-3)所示。
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 24-3: Managing log entries by severity level with a stack of three
    log handlers in index.php'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 清单24-3：在index.php中使用三个日志处理程序的堆栈按严重性级别管理日志条目
- en: First, we have added a use statement to give us access to the constants in the
    Monolog\Level class ❶. We declare three variables for the filepaths to *immediateActions.log*,
    *infoActions.log*, and *debug.log* ❷. Then we create three variables referencing
    three StreamHandler objects ❸. These will be the three log handlers in our stack.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个use语句来让我们访问Monolog\Level类中的常量❶。我们声明了三个变量，分别对应*immediateActions.log*、*infoActions.log*和*debug.log*的文件路径❷。然后我们创建了三个引用StreamHandler对象的变量❸。这些将是我们堆栈中的三个日志处理程序。
- en: For the first, $handler1, we pass the path to the immediate actions logfile,
    and we use the constant Level::Critical as the second argument to assign this
    handler to entries of Critical or greater importance. The handler has bubbling
    enabled by default. We provide $handler2 the path to the info actions file and
    use Level::Info to assign it to Info-level log entries or greater (all logs except
    Debug entries). The third argument of false turns bubbling off for handler2.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个$handler1，我们传递即时操作日志文件的路径，并使用常量Level::Critical作为第二个参数，将此处理程序分配给Critical或更高重要性的条目。处理程序默认启用冒泡机制。我们为$handler2提供信息操作文件的路径，并使用Level::Info将其分配给Info级别或更高的日志条目（所有日志，除调试条目外）。第三个参数false关闭了$handler2的冒泡机制。
- en: To create $handler3, we simply pass the path to the debug logfile and omit the
    other arguments. By default, all log entries will be processed by this handler
    and bubbling will be enabled. However, the handler will receive only Debug-level
    entries, and since it will be at the bottom of the stack, no other log handler
    exists for log entries to bubble down to.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建$handler3，我们只需传递调试日志文件的路径并省略其他参数。默认情况下，所有日志条目将由此处理程序处理，并启用冒泡机制。然而，处理程序只会接收调试级别的条目，并且由于它位于堆栈的底部，因此没有其他日志处理程序可供日志条目冒泡到。
- en: Next, we create a new Logger object ❹ and assign all three log handlers to it,
    one at a time. When multiple handlers are added to the same Logger object, the
    last one added is considered to be at the top of the stack and will get the chance
    to process all log entries first. Therefore, we add the handlers in reverse order,
    starting with $handler3 and ending with $handler1. Finally, we log eight messages
    ❺, one for each level of severity, with a message confirming the level number
    and name.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的Logger对象❹并逐一将所有三个日志处理程序分配给它。当多个处理程序被添加到同一个Logger对象时，最后添加的一个会被认为是堆栈的顶部，并且将优先处理所有日志条目。因此，我们以相反的顺序添加处理程序，从$handler3开始，最后是$handler1。最后，我们记录了八条消息❺，每条消息对应一个严重性级别，并附上了确认级别编号和名称的消息。
- en: 'After executing the index script, the *logs/immediateActions.log* file should
    look something like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 执行index脚本后，*logs/immediateActions.log*文件应类似于以下内容：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Only Critical, Alert, and Emergency logs were processed and written to *immediateActions.log*
    by $handler1 at the top of the log handler stack. Here are the contents of *logs/infoActions.log*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只有Critical、Alert和Emergency日志由位于日志处理程序堆栈顶部的$handler1处理并写入*immediateActions.log*。以下是*logs/infoActions.log*的内容：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'All logs from levels 0 to 6 were processed and written to *infoActions.log*
    by $handler2 from the middle of the log handler stack. Since we’ve already seen
    the level 0, 1, and 2 logs in *immediateActions.log* from $handler1, seeing them
    again in *infoActions.log* confirms that the bubbling mechanism has worked, allowing
    these logs to also be received by $handler2. Finally, here are the contents of
    the *logs/debug.log* file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从级别0到6的日志都由位于日志处理程序堆栈中间的$handler2处理并写入*infoActions.log*。由于我们已经在*immediateActions.log*中看到来自$handler1的级别0、1和2的日志，因此在*infoActions.log*中再次看到它们，确认了冒泡机制的正常工作，允许这些日志也被$handler2接收。最后，以下是*logs/debug.log*文件的内容：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Only the entry for severity level 7 (Debug) can be seen in *debug.log*. This
    demonstrates that $handler3 at the bottom of the stack received only this single
    log entry.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只有级别7（调试）的条目可以在*debug.log*中看到。这表明位于堆栈底部的$handler3只接收了这一单一的日志条目。
- en: Logging Exceptions
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录异常
- en: 'A common use of logs is to record when exceptions occur during program execution.
    In [Chapter 23](chapter23.xhtml), we explored how programs can be organized around
    try...catch statements: a try statement with the code that should execute under
    normal circumstances, and a catch statement for handling exceptions. When an application
    uses logging, the exceptions are logged as part of the catch statement.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 日志的一个常见用途是记录程序执行过程中发生的异常。在[第23章](chapter23.xhtml)中，我们探讨了如何通过try...catch语句组织程序：try语句包含正常情况下应该执行的代码，catch语句用于处理异常。当应用程序使用日志时，异常会作为catch语句的一部分被记录。
- en: Let’s create a simple, single-class project to illustrate how to do this. Our
    project will have a Product class that throws an exception when we try to create
    a Product object with a negative price. We’ll use Monolog to log those exceptions
    to a *logs/debug.log* file. We’ll begin by declaring the Product class. Create
    a new project with *src/Product.php* containing the code in [Listing 24-4](#lis24-4).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的单类项目，来说明如何做到这一点。我们的项目将有一个Product类，当我们尝试创建一个价格为负的Product对象时，它会抛出异常。我们将使用Monolog将这些异常记录到*logs/debug.log*文件中。我们将首先声明Product类。创建一个新项目，并在*src/Product.php*中编写[清单24-4](#lis24-4)中的代码。
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 24-4: A Product class that throws an exception'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 清单24-4：一个抛出异常的Product类
- en: We declare the Product class in the Mattsmithdev namespace and give it two private
    properties, name and price. The class’s constructor method takes in $name and
    $price values for the new object being created. Within the constructor, we validate
    the $price argument and throw an exception if its value is negative ❶. For this
    simple example, we’re using PHP’s root Exception class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Mattsmithdev命名空间中声明了Product类，并为其定义了两个私有属性，name和price。类的构造方法接收$name和$price值，用于创建新对象。在构造函数中，我们验证$price参数的值，如果其值为负，则抛出异常❶。对于这个简单的例子，我们使用PHP的根Exception类。
- en: We now need to create a *composer.json* file to autoload the class. [Listing
    24-5](#lis24-5) shows how.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建一个*composer.json*文件来自动加载该类。[清单24-5](#lis24-5)展示了如何操作。
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 24-5: The composer.json file'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单24-5：composer.json文件
- en: 'Next, use Composer at the command line to generate the autoloader scripts and
    add the Monolog library to the project:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在命令行中使用Composer生成自动加载器脚本，并将Monolog库添加到项目中：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we need to write an index script that attempts to create a Product object
    and logs the exception if the attempt is unsuccessful. Create *public/index.php*
    to match [Listing 24-6](#lis24-6).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编写一个index脚本，尝试创建一个Product对象，并在尝试失败时记录异常。创建*public/index.php*，其内容与[清单24-6](#lis24-6)一致。
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 24-6: Attempting to create an invalid Product object in index.php'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 清单24-6：在index.php中尝试创建无效的Product对象
- en: First, we read and execute the autoloader and add use statements for the classes
    we need. Then we get set up for logging by creating a variable for the *logs/debug.log*
    filepath, creating a new Logger object for a channel named demo and giving it
    a log handler. Next, inside a try block, we create a new Product object, passing
    -1 for the price. In the related catch block, we log an entry of Error-level severity
    with the Logger object if creating the product fails ❶.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取并执行自动加载器，并为所需的类添加use语句。然后，我们通过创建一个变量来设置日志记录的*logs/debug.log*文件路径，创建一个新的Logger对象，为其命名为demo的频道，并为其指定日志处理器。接下来，在try块中，我们创建一个新的Product对象，传递-1作为价格。在相关的catch块中，如果创建产品失败，我们使用Logger对象记录一个Error级别的日志条目❶。
- en: In addition to providing a message to log ('problem creating new product'),
    we include an array as the second argument to log additional information. Specifically,
    we pass the entire Exception object $e and give it the key exception. In the Monolog
    documentation, this optional array is called the *context* of the log entry. It
    can contain multiple elements with keys of your choosing, which can be helpful
    when reviewing the logs and analyzing them for patterns.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供日志消息（'创建新产品时出问题'），我们还将一个数组作为第二个参数来记录额外的信息。具体来说，我们传递整个Exception对象$e，并将其指定为键exception。在Monolog文档中，这个可选的数组被称为日志条目的*上下文*。它可以包含多个元素，并可以自定义键，这在查看日志并分析模式时非常有用。
- en: 'After executing the index script, the *logs/debug.log* file should look something
    like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行index脚本后，*logs/debug.log*文件应该如下所示：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An Error-level log has been added to the logfile for the demo channel, with
    the message problem creating new product. The log entry also contains the details
    of the Exception object that was thrown by the Product constructor method, including
    the message associated with the exception (attempting to set price to a negative
    value) and the location of the exception-triggering code.  ### Logging to the
    Cloud'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '已向演示通道的日志文件添加了一个错误级别的日志，消息为 "创建新产品时出现问题"。该日志条目还包含由 Product 构造方法抛出的异常对象的详细信息，包括与异常相关的消息（尝试将价格设置为负值）和触发异常的代码位置。
    ### 云日志记录'
- en: So far we’ve been logging messages to files, but most large-scale web applications
    log to a dedicated cloud-based logging system rather than to files on the server.
    One popular cloud logging system is Mezmo (previously LogDNA). Using a cloud logging
    API such as Mezmo provides many benefits, including historical storage of logs,
    powerful filtering and search features, and comprehensive analytical and reporting
    features. Cloud logging APIs such as Mezmo can also be linked to alert notification
    systems such as Atlassian’s Opsgenie to send the email or text alerts for log
    entries requiring immediate actions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在将消息记录到文件中，但大多数大型 Web 应用程序会将日志记录到专用的基于云的日志系统，而不是服务器上的文件。一个流行的云日志系统是
    Mezmo（之前称为 LogDNA）。使用如 Mezmo 这样的云日志 API 提供了许多好处，包括日志的历史存储、强大的过滤和搜索功能，以及全面的分析和报告功能。像
    Mezmo 这样的云日志 API 还可以与警报通知系统（如 Atlassian 的 Opsgenie）连接，发送需要立即处理的日志条目的电子邮件或短信警报。
- en: Let’s create a project that sends log entries to Mezmo. We’ll log to two separate
    channels and try out entries of each severity level. First, visit the Mezmo website
    (*[https://www.mezmo.com](https://www.mezmo.com)*) and create a free account.
    Make a note of the unique hexadecimal Mezmo ingestion key created for you in your
    account details; you’ll need to reference it in your script.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个向 Mezmo 发送日志条目的项目。我们将记录到两个独立的通道，并尝试每个严重级别的日志条目。首先，访问 Mezmo 网站（* [https://www.mezmo.com](https://www.mezmo.com)
    *），并创建一个免费账户。记下在账户详情中为你创建的唯一十六进制 Mezmo 摄取密钥；你将在脚本中引用它。
- en: To interact with Mezmo from your PHP code, we’ll use the monolog -logdna package,
    maintained by Nicolas Vanheuverzwijn. This package adds Mezmo API communication
    capabilities to Monolog. Create a new project folder and add the package by entering
    composer require nvanheuverzwijn/monolog-logdna at the command line. You should
    now have a *composer.json* file and a *vendor* folder containing an autoloader
    and the Monolog and other library classes for logging to the Mezmo API. Now create
    an index script in *public/index.php* containing the code in [Listing 24-7](#lis24-7).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PHP 代码中与 Mezmo 交互，我们将使用由 Nicolas Vanheuverzwijn 维护的 monolog-logdna 包。这个包为
    Monolog 添加了 Mezmo API 通信功能。创建一个新的项目文件夹，并通过在命令行输入 composer require nvanheuverzwijn/monolog-logdna
    来添加该包。你现在应该拥有一个 *composer.json* 文件和一个 *vendor* 文件夹，其中包含自动加载器以及用于记录到 Mezmo API
    的 Monolog 和其他库类。现在，在 *public/index.php* 中创建一个包含 [Listing 24-7](#lis24-7) 中代码的索引脚本。
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 24-7: Setting up and using Monolog in public/index.php'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 24-7：在 public/index.php 中设置和使用 Monolog
- en: We provide use statements for Monolog’s Logger class and for LogDnaHandler,
    the log handler needed to log to Mezmo. Then we declare a variable for the necessary
    Mezmo ingestion key; be sure to fill in your own key here ❶. Next, we create a
    new Logger object named $generalLogger, providing general as the channel name,
    and we give it a log handler, passing the ingestion key and naming the host source
    of logs as host-mgw.com (short for My Great Website, as usual). Different web
    applications or subsites could use different hostnames in their handlers, to further
    differentiate the source of logs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了 Monolog 的 Logger 类和 LogDnaHandler 的 use 语句，这是记录到 Mezmo 所需的日志处理器。然后，我们声明一个变量，用于存储所需的
    Mezmo 摄取密钥；务必在此处填写你自己的密钥 ❶。接下来，我们创建一个名为 $generalLogger 的新 Logger 对象，提供 "general"
    作为通道名称，并为其设置日志处理器，传递摄取密钥并将日志主机源命名为 host-mgw.com（通常是 My Great Website 的缩写）。不同的
    Web 应用程序或子站点可以在其处理器中使用不同的主机名，以进一步区分日志的来源。
- en: We log eight messages to our $generalLogger object ❷, one for each level of
    severity, with a message confirming the level number and name. Then we save a
    bit of work by using the withName() method to create a clone of the $generalLogger
    object called $securityLogger with a channel name of security ❸. Both Logger objects
    use the same log handler and so can send logs to the Mezmo API. We use this second
    object to log a debug entry, passing a second argument of a single-element array
    with the 'context-1' key and 'some data' data string. This tests how we might
    record extra data in a log entry.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将八条消息记录到 $generalLogger 对象 ❷ 中，每条消息对应一个严重级别，并附带确认该级别编号和名称的消息。然后，我们通过使用 withName()
    方法创建一个名为 $securityLogger 的 $generalLogger 对象的克隆，并将频道名称设置为 security ❸。这两个 Logger
    对象使用相同的日志处理程序，因此可以将日志发送到 Mezmo API。我们使用第二个对象记录一个调试条目，传递一个包含 'context-1' 键和 'some
    data' 数据字符串的单元素数组作为第二个参数。这测试了我们如何在日志条目中记录额外数据。
- en: '[Figure 24-2](#fig24-2) shows the logs from our executed index script, received
    and displayed on the Mezmo site.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 24-2](#fig24-2) 显示了我们执行的索引脚本的日志，这些日志已接收并显示在 Mezmo 网站上。'
- en: '![](../images/figure24-2.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure24-2.jpg)'
- en: 'Figure 24-2: Log entries on the Mezmo cloud service'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 24-2：Mezmo 云服务上的日志条目
- en: Mezmo shows timestamped logs from the general and security channels, with all
    entries coming from host-mgw. Each entry is marked with its severity level. The
    details of the final log, to the security channel, have been expanded in the figure,
    revealing the context data we passed to the Logger object via an array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Mezmo 显示来自 general 和 security 频道的时间戳日志，所有条目来自 host-mgw。每个条目都标有其严重级别。最后一条日志（发送到
    security 频道）的详细信息在图中已展开，显示了我们通过数组传递给 Logger 对象的上下文数据。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: As you’ve seen in this chapter, you can create logs for a web application in
    several ways, from simple error_log() function calls to the sophisticated Monolog
    open source logging library package to APIs like Mezmo for cloud storage and analytics.
    The scale and importance of each project will determine the most appropriate approach
    to take, but for almost all projects that you need to quality-assure and maintain,
    you’ll probably have to adopt some form of logging to record and manage errors
    and exceptions, and to collect historical data about use and performance of the
    system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在本章中所见，你可以通过多种方式为 Web 应用程序创建日志，从简单的 error_log() 函数调用到复杂的 Monolog 开源日志库包，再到像
    Mezmo 这样的 API 用于云存储和分析。每个项目的规模和重要性将决定最合适的方式，但对于几乎所有需要质量保证和维护的项目，你可能需要采用某种形式的日志记录来记录和管理错误与异常，并收集有关系统使用和性能的历史数据。
- en: Exercises
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 1.   Create message entries by using both the syslog() and error_log() functions.
    Locate the files that these functions write to on your computer system and view
    your messages in the logfiles.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   通过使用 syslog() 和 error_log() 函数创建消息条目。在你的计算机系统中找到这些函数写入的文件，并查看日志文件中的消息。
- en: 2.   Create a new project and use Composer to add the Monolog package. In your
    index script, create a new Logger object for a channel named general, and add
    a StreamHandler to append logs to the *logs/mylogs.log* file. Log several entries
    of different severity levels, and view the log entries in your logfile after executing
    your index script.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   创建一个新项目，并使用 Composer 添加 Monolog 包。在你的索引脚本中，为名为 general 的频道创建一个新的 Logger
    对象，并添加一个 StreamHandler，将日志追加到*logs/mylogs.log*文件中。记录几条不同严重级别的日志条目，并在执行索引脚本后查看日志文件中的日志条目。
- en: '3.   Create a new project with a stack of two handlers: handler1 (appending
    to the *urgent.log* file) and handler2 (appending to the *other.log* file). Add
    handler2 first so that handler1 will be on the top of the stack. Turn off bubbling
    for handler1 and configure it to catch all log entries of Critical or more importance.
    Generate log entries for all eight levels of severity. You should see log entries
    of severity 0, 1, and 2 in *urgent.log*, and all others (3 through 7) in *other.log*.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   创建一个新项目，使用两个处理程序的堆栈：handler1（追加到*urgent.log*文件）和 handler2（追加到*other.log*文件）。首先添加
    handler2，这样 handler1 将位于堆栈的顶部。关闭 handler1 的冒泡，并将其配置为捕捉所有严重级别为 Critical 或更高的日志条目。生成所有八个严重级别的日志条目。你应该能在*urgent.log*中看到严重级别为
    0、1 和 2 的日志条目，在*other.log*中看到所有其他（3 到 7）级别的日志条目。
- en: 4.   Create an account at a cloud logging site such as Mezmo, and update the
    project from Exercise 3 to log entries to that site’s API. View the logs online
    to confirm that your program successfully sent them via the API.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   在像 Mezmo 这样的云日志网站上创建一个账户，并更新第 3 题中的项目，将日志条目发送到该网站的 API。在线查看日志，确认你的程序通过
    API 成功发送了日志。
