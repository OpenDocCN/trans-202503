- en: '29'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '29  '
- en: THE MAXWELL EQUATIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '麦克斯韦方程  '
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)  '
- en: In the past several chapters, we’ve introduced electric and magnetic fields
    and suggested that these fields are properly part of the description of the state
    of a physical system, at least one in which electric charge plays a role. What
    we have not yet done is shown how the electric and magnetic fields evolve in time.
    This chapter addresses that issue by introducing the Maxwell equations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '在过去的几章中，我们介绍了电场和磁场，并指出这些场实际上是描述物理系统状态的一部分，至少对于那些电荷起作用的系统是如此。但我们尚未展示电场和磁场是如何随时间发展的。本章将通过引入麦克斯韦方程来解决这个问题。  '
- en: The Maxwell equations describe how electric and magnetic fields are created
    by charge and current, how the fields are related to each other, and how the fields
    evolve in time. Together with the Lorentz force law, the Maxwell equations express
    modern electromagnetic theory.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '麦克斯韦方程描述了电场和磁场如何由电荷和电流产生，它们之间的关系以及它们如何随时间变化。与洛伦兹力定律一起，麦克斯韦方程表达了现代电磁理论。  '
- en: We’ll begin the chapter with some introductory code, after which we’ll present
    the Maxwell equations. We’ll then discuss four relationships between electricity
    and magnetism implied by these equations and how the equations relate to our treatment
    of electric and magnetic fields in previous chapters. We’ll also show how the
    state-update technique can be applied to the Maxwell equations. Finally, we’ll
    present the finite difference time domain (FDTD) method for solving the Maxwell
    equations and use it to animate the electric field produced by oscillating charge.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '本章将从一些引言代码开始，接着介绍麦克斯韦方程。然后，我们将讨论这些方程所蕴含的电磁学之间的四种关系，以及这些方程如何与我们在前几章中对电场和磁场的处理相关。最后，我们将展示如何将状态更新技术应用于麦克斯韦方程。最后，我们将介绍有限差分时域（FDTD）方法来求解麦克斯韦方程，并利用该方法来模拟由振荡电荷产生的电场。  '
- en: Introductory Code
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '引言代码  '
- en: '[Listing 29-1](ch29.xhtml#ch29list1) shows the first lines of the code in the
    `Maxwell` module we’ll write in this chapter.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 29-1](ch29.xhtml#ch29list1)展示了我们将在本章编写的`Maxwell`模块的前几行代码。  '
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 29-1: Opening lines of code for the `Maxwell` module*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 29-1：`Maxwell`模块的开头代码*  '
- en: We use types and functions from the `SimpleVec` module of [Chapter 10](ch10.xhtml),
    the `CoordinateSystems` module of [Chapter 22](ch22.xhtml), and the `ElectricField`
    module of [Chapter 25](ch25.xhtml). We also do a qualified import of `Data.Map.Strict`,
    giving it the short name `M`, for use in the section on the FDTD method. We import
    several types and functions from the `Diagrams` package to do asynchronous animation
    at the end of the chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了[第10章](ch10.xhtml)中`SimpleVec`模块的类型和函数，[第22章](ch22.xhtml)中`CoordinateSystems`模块的类型和函数，以及[第25章](ch25.xhtml)中`ElectricField`模块的类型和函数。在FDTD方法的部分，我们还做了对`Data.Map.Strict`的限定导入，并将其简写为`M`。我们还从`Diagrams`包中导入了几个类型和函数，以便在本章末进行异步动画演示。
- en: The Maxwell Equations
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '麦克斯韦方程  '
- en: 'In SI units, the Maxwell equations consist of the following four equations:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '在国际单位制（SI）中，麦克斯韦方程包括以下四个方程：  '
- en: '![Image](Images/552equ01.jpg)![Image](Images/552equ02.jpg)![Image](Images/552equ03.jpg)![Image](Images/552equ04.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/552equ01.jpg)![图片](Images/552equ02.jpg)![图片](Images/552equ03.jpg)![图片](Images/552equ04.jpg)  '
- en: 'The electric field is denoted **E**, the magnetic field **B**, the current
    density **J**, and the charge density *ρ*. Remember that *ϵ*[0] is the permittivity
    of free space, first introduced in [Chapter 21](ch21.xhtml). The symbol *∇* is
    called the *del operator*, and in Cartesian coordinates it is given by:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '电场用**E**表示，磁场用**B**表示，电流密度用**J**表示，电荷密度用*ρ*表示。记住，*ϵ*[0]是自由空间的介电常数，首次在[第21章](ch21.xhtml)中介绍。符号*∇*被称为*散度算子*，在笛卡尔坐标系中其形式为：  '
- en: '![Image](Images/553equ01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/553equ01.jpg)  '
- en: The word *operator* here is used as physicists use it, meaning something that
    takes a function as input and produces a function as output. Functional programmers
    call such a thing a higher-order function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的*算子*一词是物理学家使用的意思，指的是将一个函数作为输入并产生一个函数作为输出的东西。函数式编程中的程序员将此类对象称为高阶函数。  '
- en: 'The combination of the del operator followed by a dot product symbol, as in
    Equations 29.1 and 29.2, is called the *divergence*, a higher-order function that
    takes a vector field as input and produces a scalar field as output. The definition
    of divergence is flux per unit volume, so a place where a vector field has positive
    divergence is a place that the vectors point away from. Similarly, a place where
    a vector field has negative divergence is a place that the vectors point toward.
    In Cartesian coordinates, the divergence of a vector field looks like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程29.1和29.2中，梯度算符与点积符号的组合被称为*散度*，这是一个高阶函数，它将一个向量场作为输入，输出一个标量场。散度的定义是单位体积的通量，因此，向量场有正散度的地方是向量指向远离的地方。同样，向量场有负散度的地方是向量指向的地方。在笛卡尔坐标系中，向量场的散度看起来像以下形式：
- en: '![Image](Images/553equ02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/553equ02.jpg)'
- en: 'The combination of the del operator followed by a cross product symbol, as
    in Equations 29.3 and 29.4, is called the *curl*, a higher-order function that
    takes a vector field as input and produces a vector field as output. The definition
    of curl is circulation per unit area, so it describes how the vectors form a pattern
    of circulation. A place where a vector field has curl in the z-direction is a
    place where the vectors point in a counterclockwise sense parallel to the xy-plane.
    In Cartesian coordinates, the curl of a vector field looks like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程29.3和29.4中，梯度算符与叉积符号的组合被称为*旋度*，这是一个高阶函数，它将一个向量场作为输入，输出一个向量场。旋度的定义是单位面积的环流，因此它描述了向量如何形成环流模式。向量场在z方向上有旋度的地方，是向量以逆时针方向平行于xy平面指向的地方。在笛卡尔坐标系中，向量场的旋度看起来像以下形式：
- en: '![Image](Images/553equ03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/553equ03.jpg)'
- en: Equation 29.1 is called Gauss’s law (you may have encountered Gauss’s law in
    the exercises in [Chapter 25](ch25.xhtml)). Gauss’s law says that charge dictates
    the divergence of the electric field. Since vectors point away from a place of
    positive divergence and toward a place of negative divergence, Gauss’s law says
    that the electric field points away from positive charge and toward negative charge.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 方程29.1被称为高斯定律（你可能在[第25章](ch25.xhtml)的习题中遇到过高斯定律）。高斯定律指出电荷决定了电场的散度。由于向量指向正散度的地方远离，而指向负散度的地方靠近，高斯定律说明电场从正电荷指向负电荷。
- en: Equation 29.2 is called Gauss’s law for magnetism, or “no magnetic monopoles.”
    Since the divergence of the magnetic field must be 0 at all points in space and
    time, there is no magnetic charge for the magnetic field to point toward or away
    from.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 方程29.2被称为高斯的磁学定律，或称“没有磁单极子”。由于磁场的散度在空间和时间中的所有点都必须为0，因此磁场没有磁荷可以指向或远离。
- en: Equation 29.3 is called Faraday’s law (you may have encountered Faraday’s law
    in the exercises in [Chapter 27](ch27.xhtml)). It asserts a link between the curl
    of the electric field and the time rate of change of the magnetic field. Faraday’s
    law explains electric generators and transformers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 方程29.3被称为法拉第定律（你可能在[第27章](ch27.xhtml)的习题中遇到过法拉第定律）。它断言了电场的旋度与磁场的时间变化率之间的关系。法拉第定律解释了电动发电机和变压器的原理。
- en: Equation 29.4 is the *Ampere-Maxwell law*. It asserts a relationship among the
    curl of the magnetic field, the time rate of change of the electric field, and
    the current density.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 方程29.4是*安培-麦克斯韦定律*，它断言了磁场的旋度、电场的时间变化率和电流密度之间的关系。
- en: 'There are four independent variables in the Maxwell equations: three space
    coordinates and one time coordinate. There are six dependent variables: three
    electric field components and three magnetic field components. We can think of
    the charge and current densities as source terms. They are inputs to the Maxwell
    equations that determine the fields and how they change.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 麦克斯韦方程中有四个独立变量：三个空间坐标和一个时间坐标。共有六个依赖变量：三个电场分量和三个磁场分量。我们可以将电荷和电流密度看作源项，它们是麦克斯韦方程的输入，决定了场以及场的变化。
- en: With the Maxwell equations, we have electric field and magnetic field appearing
    in the same equations for the first time. The Maxwell equations describe four
    relationships between electricity and magnetism, which we describe next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在麦克斯韦方程中，电场和磁场首次出现在同一方程中。麦克斯韦方程描述了电与磁之间的四个关系，接下来我们将对此进行描述。
- en: Relationships Between Electricity and Magnetism
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电与磁之间的关系
- en: Equation 29.1 is purely electric, and Equation 29.2 is purely magnetic. The
    remaining two Maxwell equations express four relationships between electricity
    and magnetism.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 方程29.1是纯电场方程，方程29.2是纯磁场方程。剩下的两个麦克斯韦方程表达了电与磁之间的四个关系。
- en: First, electric charge produces a magnetic field when it moves. This was Hans
    Christian Oersted’s 1820 discovery. He saw that electric current could deflect
    a compass needle. This relationship is described by the Ampere-Maxwell law, Equation
    29.4, in that the current density **J** is related to the curl of the magnetic
    field, ∇ × **B**. An earlier version of this law, called Ampere’s law, omitted
    the time derivative of the electric field and thus expressed in a simpler, if
    less comprehensive, way the dependence of magnetic field on current.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，电荷在运动时会产生磁场。这是汉斯·克里斯蒂安·欧斯特德在1820年的发现。他观察到电流能够偏转指南针针头。这个关系通过安培-麦克斯韦定律（方程29.4）来描述，其中电流密度**J**与磁场的旋度∇
    × **B**相关。该定律的早期版本，即安培定律，忽略了电场的时间导数，因此以一种更简单（但不那么全面）方式表达了磁场对电流的依赖。
- en: 'Second, a changing magnetic field produces an electric field. This was Faraday’s
    discovery and goes by the name of Faraday’s law, Equation 29.3\. So, there are,
    in a sense, two sources of electric fields: one is charge and the other is a changing
    magnetic field. Coulomb’s law is missing this changing magnetic field contribution
    to the electric field and is incompatible with relativity. Most electric generation
    plants today use Faraday’s law to produce alternating electric current. The rotation
    of a turbine produces a changing magnetic field, which produces an electric field
    that drives the current.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，变化的磁场会产生电场。这是法拉第的发现，称为法拉第定律（方程29.3）。因此，从某种意义上说，电场有两个来源：一个是电荷，另一个是变化的磁场。库仑定律没有考虑磁场变化对电场的贡献，因此与相对论不兼容。今天，大多数电力发电厂使用法拉第定律来产生交流电流。涡轮机的旋转产生变化的磁场，进而产生电场，推动电流。
- en: Third, a changing electric field produces a magnetic field. In 1865, Maxwell
    added the term with the time derivative of the electric field to Ampere’s law,
    creating the Ampere-Maxwell law, Equation 29.4\. The added term is known as *displacement
    current* because, although it is not an electrical current, it serves a similar
    role in the creation of a magnetic field.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，变化的电场会产生磁场。1865年，麦克斯韦在安培定律中加入了电场时间导数项，形成了安培-麦克斯韦定律（方程29.4）。这个新增的项被称为*位移电流*，因为尽管它不是电流，但在磁场的产生中起着类似的作用。
- en: Finally, electric and magnetic fields constitute light. The modern theory of
    optics asserts that light is an electromagnetic wave. There is no such thing as
    an electric wave or a magnetic wave by itself. Wavelike electric fields are always
    accompanied by wavelike magnetic fields.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，电场和磁场构成了光。现代光学理论断言，光是电磁波。不存在单独的电波或磁波。波动性质的电场总是伴随着波动性质的磁场。
- en: Connection to Coulomb’s Law and Biot-Savart Law
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与库仑定律和比奥-萨伐尔定律的关系
- en: If the Maxwell equations describe how electric and magnetic fields are created
    and how they evolve, why did we not use them in [Chapters 25](ch25.xhtml) and
    [27](ch27.xhtml)? Those chapters gave methods for how an electric field is created
    by charge and how a magnetic field is created by current, respectively. How do
    the methods given in those chapters relate to the Maxwell equations?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果麦克斯韦方程描述了电场和磁场是如何产生并发展的，为什么我们在[第25章](ch25.xhtml)和[第27章](ch27.xhtml)中没有使用它们呢？那两章分别介绍了电荷如何产生电场，电流如何产生磁场。那么，这些章节中的方法与麦克斯韦方程有什么关系呢？
- en: Remember that [Chapter 25](ch25.xhtml) gave methods for calculating the electric
    field in static situations (that is, in situations where charge is not moving
    or accelerating). In practice, the methods of that chapter, which are equivalent
    to Coulomb’s law, work reasonably well for charges moving slowly compared with
    the speed of light. In static situations, we can remove the two time derivative
    terms from the Maxwell equations, causing the equations for electricity to decouple
    from those for magnetism. Thus, in static situations, Equations 29.1 and 29.3
    become
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，[第25章](ch25.xhtml)介绍了在静态情况下（即电荷不运动或加速的情况）计算电场的方法。实际上，该章节的方法等同于库仑定律，对于相对于光速运动较慢的电荷，计算效果相当不错。在静态情况下，我们可以从麦克斯韦方程中去除两个时间导数项，使得电场的方程与磁场的方程解耦。因此，在静态情况下，方程29.1和29.3变为：
- en: '![Image](Images/555equ01.jpg)![Image](Images/555equ02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/555equ01.jpg)![Image](Images/555equ02.jpg)'
- en: and describe static electricity. Coulomb’s law is the solution to Equations
    29.8 and 29.9.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 并描述静电。库仑定律是方程29.8和29.9的解。
- en: Similarly, in static situations, Equations 29.2 and 29.4 become
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在静态情况下，方程29.2和29.4变为
- en: '![Image](Images/555equ03.jpg)![Image](Images/555equ04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/555equ03.jpg)![Image](Images/555equ04.jpg)'
- en: and describe the magnetic field created by steady currents. The Biot-Savart
    law of [Chapter 27](ch27.xhtml) is the solution to Equations 29.10 and 29.11.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 并描述由稳态电流产生的磁场。[第27章](ch27.xhtml)中的比奥-萨伐尔定律是方程29.10和29.11的解。
- en: The static methods we introduced in [Chapters 25](ch25.xhtml) and [27](ch27.xhtml)
    are useful and substantially simpler than the Maxwell equations, but they do not
    account for dynamic situations where charge is moving quickly or accelerating.
    We turn now to the task of solving the Maxwell equations, employing a state-update
    similar to what we used to solve Newton’s second law in [Part II](part02.xhtml)
    of the book.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第25章](ch25.xhtml)和[第27章](ch27.xhtml)中介绍的静态方法非常有用，并且比麦克斯韦方程简单得多，但它们无法解释电荷快速或加速移动的动态情况。现在我们将转向解决麦克斯韦方程的任务，采用类似于我们在本书[第二部分](part02.xhtml)中解决牛顿第二定律时使用的状态更新方法。
- en: State Update
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态更新
- en: To understand how electric and magnetic fields change in time, it is helpful
    to rearrange Maxwell Equations 29.3 and 29.4 so that they give the rates of change
    of the fields in terms of the fields and the current density.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解电场和磁场如何随时间变化，重新排列麦克斯韦方程29.3和29.4，使其给出电场和电流密度对场的变化速率会很有帮助。
- en: '![Image](Images/555equ05.jpg)![Image](Images/555equ06.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/555equ05.jpg)![Image](Images/555equ06.jpg)'
- en: Equations 29.1 and 29.2 serve as constraints; as long as the electric and magnetic
    fields satisfy them at one point in time, they will continue to satisfy them as
    they change according to Equations 29.12 and 29.13.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 方程29.1和29.2作为约束；只要电场和磁场在某一时刻满足这些方程，它们将继续满足这些方程，随着时间的推移根据方程29.12和29.13发生变化。
- en: '[Figure 29-1](ch29.xhtml#ch29fig1) shows a schematic diagram for the Maxwell
    equations.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图29-1](ch29.xhtml#ch29fig1)显示了麦克斯韦方程的示意图。'
- en: '![Image](Images/556fig01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/556fig01.jpg)'
- en: '*Figure 29-1: A schematic diagram representing the Maxwell equations*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图29-1：表示麦克斯韦方程的示意图*'
- en: This diagram is similar to the diagrams we made in [Part II](part02.xhtml) of
    the book for Newton’s second law. The most striking difference is that the values
    carried by the wires here are vector fields, whereas in mechanics they were numbers
    or vectors. As we integrated acceleration to obtain velocity in mechanics, here
    we integrate the curl of the electric field to obtain the magnetic field. As a
    loop in this kind of schematic diagram signaled a differential equation in mechanics,
    the loop here also signals that the Maxwell equations are differential equations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图与我们在本书[第二部分](part02.xhtml)中为牛顿第二定律所作的图类似。最显著的区别是，这里由电线承载的值是矢量场，而在力学中它们是数值或矢量。正如我们在力学中通过积分加速度来获得速度一样，这里我们通过积分电场的旋度来获得磁场。就像在这种示意图中的环路表示力学中的微分方程一样，这里的环路也表明麦克斯韦方程是微分方程。
- en: As you can see in [Figure 29-1](ch29.xhtml#ch29fig1), magnetic field change
    is controlled by the negative curl of the electric field. Electric field change
    is controlled by both current density and the curl of the magnetic field. This
    schematic diagram represents Equations 29.3 and 29.4\. The integrators are with
    respect to time, as they have been in all of the schematic diagrams like this.
    The type `VectorField` below each integrator indicates the nature of the state
    contained in the integrator. Each integrator here contains a full vector field
    as state that gets updated by the vector field acting as input to the integrator.
    Equations 29.1 and 29.2 place constraints on the vector fields that can be held
    as state by the integrators. The multiplications by *c*² and –*μ* [0]*c*² are
    appropriate for SI units.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图29-1](ch29.xhtml#ch29fig1)中看到的，磁场变化由电场的负旋度控制。电场的变化则由电流密度和磁场的旋度共同控制。这个示意图表示了方程29.3和29.4。积分器是关于时间的，正如我们在所有类似的示意图中所做的那样。每个积分器下方的`VectorField`类型表示积分器中状态的性质。每个积分器都包含一个完整的矢量场作为状态，这个状态通过作为输入作用于积分器的矢量场来更新。方程29.1和29.2对可以作为状态由积分器保持的矢量场设置了约束。乘以*c*²和–*μ*
    [0]*c*²是适用于国际单位制（SI）的。
- en: As in [Part II](part02.xhtml) of the book, our methods for solving the Maxwell
    equations involve treating time discretely, updating the quantities we care about
    over a time step that is small compared with time scales on which significant
    change occurs, and then iterating this update procedure over many small time steps.
    For the Maxwell equations, the quantities we care about are the electric and magnetic
    fields. We update the electric and magnetic fields using Equations 29.12 and 29.13
    to provide the rate at which electric and magnetic fields change. The updated
    fields change by the product of the rate with the time step.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如同本书[第二部分](part02.xhtml)所述，我们解决麦克斯韦方程的方法涉及将时间离散化，更新我们关心的量，时间步长相对于显著变化发生的时间尺度来说是非常小的，然后在许多小的时间步长中迭代这一更新过程。对于麦克斯韦方程，我们关心的量是电场和磁场。我们使用方程29.12和29.13更新电场和磁场，以提供电场和磁场变化的速率。更新后的场值通过速率与时间步长的乘积进行变化。
- en: '![Image](Images/557equ01.jpg)![Image](Images/557equ02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/557equ01.jpg)![Image](Images/557equ02.jpg)'
- en: To encode Equations 29.14 and 29.15 in Haskell, we need to take the curl of
    a vector field. We’ll turn next to the question of how to write the curl in Haskell.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Haskell中编码方程29.14和29.15，我们需要计算向量场的旋度。接下来我们将讨论如何在Haskell中编写旋度。
- en: Spatial Derivatives and the Curl
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空间导数与旋度
- en: The divergence and curl that appear in the Maxwell equations are types of spatial
    derivatives. Conceptually, the simplest spatial derivative is the *directional
    derivative*, defined to be the rate at which a field changes as we move in a specified
    direction. If *f* is a scalar field and ![Image](Images/ncap.jpg) is a unit vector,
    the directional derivative of *f* in the direction ![Image](Images/ncap.jpg) is
    defined to be the limit of the ratio of the difference of the values of the scalar
    field at two points separated by distance *ϵ* in the direction ![Image](Images/ncap.jpg),
    divided by *ϵ*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在麦克斯韦方程中出现的散度和旋度是空间导数的一种类型。从概念上讲，最简单的空间导数是*方向导数*，它被定义为场值在指定方向上变化的速率。如果*f*是一个标量场，且![Image](Images/ncap.jpg)是单位向量，则*f*在![Image](Images/ncap.jpg)方向上的方向导数被定义为标量场在两个距离为*ϵ*的点之间值的差异与*ϵ*的比率的极限。
- en: '![Image](Images/557equ03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/557equ03.jpg)'
- en: 'Our computational directional derivative will not take a limit but instead
    will simply calculate the ratio using a small displacement ![Image](Images/557equ04.jpg),
    which we call `d` in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算方向导数不会采用极限，而是通过使用一个小的位移来计算比率 ![Image](Images/557equ04.jpg)，在下面的代码中我们将其称为`d`：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The displacement vector `d` that serves as the first input to `directional`
    `Derivative` has two roles. Its direction specifies the direction in which we
    want the derivative. In calculus, where we take limits, this is its only role.
    But in computation, where our derivatives involve small but finite steps, the
    second role of this input is for its magnitude to specify the step size for the
    derivative. We evaluate the field at two points: one shifted half the displacement
    vector from `r` and the other shifted minus half the displacement vector from
    `r`. We find the difference of these two field values and divide it by the magnitude
    of the displacement vector.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`directional` `Derivative`第一个输入的位移向量`d`有两个作用。它的方向指定了我们希望进行导数计算的方向。在微积分中，当我们取极限时，这就是它的唯一作用。但在计算中，我们的导数涉及的是小的但有限的步长，输入的第二个作用是它的大小指定了导数的步长。我们在两个点上评估场值：一个点沿位移向量`d`的半程偏移，另一个点是沿位移向量`d`的负半程偏移。我们找出这两个场值的差异，并除以位移向量的大小。
- en: Recall from Equation 29.7 that we can find the curl from partial derivatives
    along the three coordinate directions. The partial derivative with respect to
    *x* is the directional derivative in the ![Image](Images/icap.jpg) direction.
    The local functions `derivX`, `derivY`, and `derivZ` in the code for `curl` are
    partial derivatives.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾方程 29.7，我们可以通过沿三个坐标方向的偏导数来计算旋度。相对于*x*的偏导数是沿![Image](Images/icap.jpg)方向的方向导数。代码中用于`curl`的局部函数`derivX`、`derivY`和`derivZ`即是偏导数。
- en: We write the curl of a vector field in terms of Cartesian coordinates and partial
    derivatives, as in Equation 29.7.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用笛卡尔坐标系和偏导数的形式来表示向量场的旋度，正如方程 29.7 所示。
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The input `a` is a real number specifying the spatial step size to use for the
    curl. The input `vf` is the vector field for which we want the curl. The local
    variables `vx`, `vy`, and `vz` have type `ScalarField` and are the components
    of the vector field `vf`. The partial derivatives `derivX`, `derivY`, and `derivZ`
    have type `ScalarField -> ScalarField`. Finally, we use Equation 29.7 to find
    the curl.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`a`是一个实数，指定用于计算旋度的空间步长。输入`vf`是我们想要计算旋度的向量场。局部变量`vx`、`vy`和`vz`是`ScalarField`类型，表示向量场`vf`的分量。偏导数`derivX`、`derivY`和`derivZ`的类型是`ScalarField
    -> ScalarField`。最后，我们使用公式29.7来计算旋度。
- en: Now that we can take the curl of a vector field, we are ready to try encoding
    the Maxwell equations in Haskell.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算向量场的旋度了，接下来我们准备尝试用Haskell编码麦克斯韦方程。
- en: A Naive Method
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个朴素的方法
- en: The simplest encoding of the Maxwell equations uses a state space consisting
    of the current time, the electric field, and the magnetic field. We use the type
    synonym `FieldState` to describe a triple consisting of a real number for time,
    a vector field for electric field, and a vector field for magnetic field.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 麦克斯韦方程的最简单编码使用一个状态空间，由当前时间、电场和磁场组成。我们使用类型别名`FieldState`来描述一个三元组，其中包括一个表示时间的实数、一个表示电场的向量场和一个表示磁场的向量场。
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function `maxwellUpdate` encodes Equations 29.14 and 29.15, which describe
    how the electric field and the magnetic field can be updated in time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxwellUpdate`函数编码了公式29.14和29.15，描述了电场和磁场如何随时间更新。'
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The input `dx` to `maxwellUpdate` is a real number describing the spatial step
    size to use for the curl present in Equations 29.14 and 29.15\. The input `dt`
    is a real number describing the time step. The input `j` is a time-dependent vector
    field describing the current density **J**. [Table 29-1](ch29.xhtml#ch29tab1)
    gives a correspondence between the mathematical notation of Equations 29.14 and
    29.15 with the Haskell notation in `maxwellUpdate`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`dx`给`maxwellUpdate`是一个实数，描述用于公式29.14和29.15中的旋度的空间步长。输入`dt`是一个实数，描述时间步长。输入`j`是一个时间依赖的向量场，表示电流密度**J**。[表29-1](ch29.xhtml#ch29tab1)给出了公式29.14和29.15的数学表示与`maxwellUpdate`中的Haskell表示之间的对应关系。
- en: '**Table 29-1:** Correspondence Between Mathematical Notation and Haskell Notation
    for the Maxwell Equations'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**表29-1：** 麦克斯韦方程的数学表示与Haskell表示的对应关系'
- en: '|  | **Mathematics** | **Haskell** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  | **数学** | **Haskell** |'
- en: '| --- | --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Time | *t* | `t` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 时间 | *t* | `t` |'
- en: '| Position | **r** | `r` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | **r** | `r` |'
- en: '| Time step | Δ*t* | `dt` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 时间步长 | Δ*t* | `dt` |'
- en: '| Speed of light | *c* | `cSI` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 光速 | *c* | `cSI` |'
- en: '| Permeability of free space | *μ*[0] | `mu0` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 真空的磁导率 | *μ*[0] | `mu0` |'
- en: '| Current density | **J** | `j` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 电流密度 | **J** | `j` |'
- en: '| Current density | **J**(*t*,**r**) | `j t r` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 电流密度 | **J**(*t*,**r**) | `j t r` |'
- en: '| Electric field | **E**(*t*,**r**) | `eF r` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 电场 | **E**(*t*,**r**) | `eF r` |'
- en: '| Magnetic field | **B**(*t*,**r**) | `bF r` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 磁场 | **B**(*t*,**r**) | `bF r` |'
- en: '| Updated electric field | **E**(*t* + Δ*t*,**r**) | `eF'' r` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 更新后的电场 | **E**(*t* + Δ*t*,**r**) | `eF'' r` |'
- en: '| Updated magnetic field | **B**(*t* + Δ*t*,**r**) | `bF'' r` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 更新后的磁场 | **B**(*t* + Δ*t*,**r**) | `bF'' r` |'
- en: '| Curl | ∇× | `curl dx` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 旋度 | ∇× | `curl dx` |'
- en: '| Curl of electric field | ∇×**E**(*t*,**r**) | `curl dx eF r` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 电场的旋度 | ∇×**E**(*t*,**r**) | `curl dx eF r` |'
- en: '| Curl of magnetic field | ∇×**B**(*t*,**r**) | `curl dx bF r` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 磁场的旋度 | ∇×**B**(*t*,**r**) | `curl dx bF r` |'
- en: '| Vector addition | + | `^+^` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 向量加法 | + | `^+^` |'
- en: '| Vector subtraction | – | `^-^` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 向量减法 | – | `^-^` |'
- en: '| Scalar multiplication | Juxtaposition | `*^` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 标量乘法 | 紧接运算 | `*^` |'
- en: We update the time by adding the time step `dt` to the current time `t` to form
    the updated time `t'`. We update the electric field by adding *c*²[∇×**B**(*t*,**r**)
    – *μ*[0]**J**(*t*,**r**)]Δ*t* to the current electric field to form the updated
    electric field. We update the magnetic field by subtracting [∇×**E**(*t*,**r**)]Δ*t*
    from the current magnetic field to form the updated magnetic field.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将时间步长`dt`加到当前时间`t`来更新时间，得到更新后的时间`t'`。我们通过将 *c*²[∇×**B**(*t*,**r**) – *μ*[0]**J**(*t*,**r**)]Δ*t*
    加到当前电场中来更新电场，得到更新后的电场。我们通过从当前磁场中减去[∇×**E**(*t*,**r**)]Δ*t*来更新磁场，得到更新后的磁场。
- en: To find the electric and magnetic fields as functions of time, we could iterate
    the `maxwellUpdate` function to produce a long list of states. The `maxwell` `Evolve`
    function does this.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到随时间变化的电场和磁场，我们可以迭代`maxwellUpdate`函数，生成一个长长的状态列表。`maxwell`的`Evolve`函数就是这样做的。
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Sadly, there is problem. While the code we have written compiles and in principle
    can be run, it is hopelessly inefficient. The trouble is that the computer does
    not automatically remember the function values it has already calculated, and
    it recalculates the same things over and over again. A function, to the Haskell
    compiler, is a rule for calculating outputs from inputs. If we know that we will
    need the output of a function in the future, it is up to us as Haskell programmers
    to see that it is available, usually by giving it a name. The values of the electric
    field at various places are just such function outputs in this naive method. They
    are not stored anywhere and must be recalculated each time they are needed. By
    the time we get to the eighth time step, for example, the computer needs to know
    the values of the electric and magnetic fields at the seventh time step, but these
    were not stored, so they must be recalculated. But the values for the seventh
    time step depend on those for the sixth, which were not stored and therefore must
    be recalculated.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，存在问题。虽然我们编写的代码可以编译并原则上能够运行，但它效率极低。问题在于计算机不会自动记住它已经计算过的函数值，而是一次又一次地重新计算相同的内容。对
    Haskell 编译器来说，函数是根据输入计算输出的规则。如果我们知道将来需要某个函数的输出，作为 Haskell 程序员，我们有责任确保它可以获取，通常是通过为其指定一个名称。在这种简单方法中，电场在不同位置的值就是这样的函数输出。它们没有被存储，必须在每次需要时重新计算。例如，当我们到达第八个时间步时，计算机需要知道第七个时间步的电场和磁场值，但这些值没有被存储，因此必须重新计算。而第七个时间步的值又依赖于第六个时间步的值，而这些也没有存储，因此同样必须重新计算。
- en: The state `FieldState` and update method `maxwellUpdate` we have written in
    this section, while elegant and illustrative of what we want the computer to do,
    are not usable in practice, which is why we call them “naive” methods. Nevertheless,
    I would argue that there is value in this code. It type checks, indicating that
    the compiler agrees we are asking for something that makes sense. It is written
    in a style that is readable and can help us to understand what the Maxwell equations
    are about. Perhaps some day compilers will be smart enough to be able to plan
    what values should be remembered because they will be used again.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一部分编写的状态 `FieldState` 和更新方法 `maxwellUpdate`，虽然优雅且能说明我们希望计算机执行的操作，但在实践中并不可用，这也是我们称之为“简单”方法的原因。然而，我认为这段代码是有价值的。它通过类型检查，表明编译器同意我们请求的内容是有意义的。它以一种可读的风格编写，有助于我们理解麦克斯韦方程的内容。也许有一天，编译器会足够智能，能够规划哪些值应该被记住，因为它们将会被再次使用。
- en: However, for today, we want to write code that runs and produces results. To
    do that, we’ll turn to a new method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，今天我们希望编写可以运行并产生结果的代码。为此，我们将采用一种新的方法。
- en: The FDTD Method
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FDTD 方法
- en: We saw in the naive method that using functions to describe the state of a system,
    while clear in meaning and elegant in exposition, is not an efficient way to solve
    the Maxwell equations. To get decent executable code, we want numbers describing
    the state of our system rather than functions. To achieve this, we will select
    a large but finite number of positions in space at which to keep track of the
    electric and magnetic field components. The method we describe in detail is called
    the *finite difference time domain* (*FDTD*) method for solving the Maxwell equations.
    It is the simplest method used by people who need to numerically solve the Maxwell
    equations. The FDTD method is described more fully in [**[18](bib.xhtml#bib18)**].
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在简单方法中看到，虽然使用函数来描述系统的状态在意义上是清晰的，且在表达上优雅，但这并不是解决麦克斯韦方程的高效方法。为了得到可以执行的代码，我们希望用数字来描述系统的状态，而不是函数。为了实现这一点，我们将选择一个大的但有限的空间位置数目，来跟踪电场和磁场分量。我们在此详细描述的方法称为*有限差分时域*（*FDTD*）方法，用于求解麦克斯韦方程。它是需要数值求解麦克斯韦方程的人们使用的最简单方法。FDTD
    方法在 [**[18](bib.xhtml#bib18)**] 中有更详细的描述。
- en: The FDTD method is still based on Equations 29.12 and 29.13\. Each of these
    two equations is a vector equation. It is helpful to write out the Cartesian components
    of these equations. Using Equation 29.7 to express the curl, Equations 29.17,
    29.18, and 29.19 list the x-, y-, and z-components of Equation 29.12.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: FDTD 方法仍然基于方程 29.12 和 29.13。每一个方程都是一个向量方程。将这些方程的笛卡尔分量写出是有帮助的。利用方程 29.7 表示旋度，方程
    29.17、29.18 和 29.19 列出了方程 29.12 的 x、y 和 z 分量。
- en: '![Image](Images/560equ01.jpg)![Image](Images/560equ02.jpg)![Image](Images/560equ03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/560equ01.jpg)![Image](Images/560equ02.jpg)![Image](Images/560equ03.jpg)'
- en: 'Similarly, the x-, y-, and z-components of Equation 29.13 are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，方程29.13的x、y和z分量如下：
- en: '![Image](Images/561equ01.jpg)![Image](Images/561equ02.jpg)![Image](Images/561equ03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/561equ01.jpg)![图片](Images/561equ02.jpg)![图片](Images/561equ03.jpg)'
- en: The FDTD method consists of approximating each partial derivative with a symmetric
    finite difference. By symmetric, we mean that we can approximate the partial derivative
    of a field component (*E[x]*, *E[y]*, *E[z]*, *B[x]*, *B[y]*, or *B[z]*) at a
    particular point (*t*,*x*,*y*,*z*) in time and space by sampling the field component
    at two points equidistant from (*t*,*x*,*y*,*z*). In the case of a partial derivative
    with respect to time, the sample points are (*t* + Δ*t*/2,*x*,*y*,*z*) and (*t*
    – Δ*t*/2,*x*,*y*,*z*). In the case of a partial derivative with respect to space,
    say in the y-direction, the sample points are (*t*,*x*,*y* + Δ*y*/2,*z*) and (*t*,*x*,*y*
    – Δ*y*/2,*z*). For example, the partial derivative of *E[x]* with respect to time
    is approximated as
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: FDTD方法通过使用对称的有限差分来近似每个偏导数。这里所说的对称是指，我们可以通过在时间和空间点(*t*,*x*,*y*,*z*)附近，分别采样该场分量的两个等距点，来近似场分量（*E[x]*，*E[y]*，*E[z]*，*B[x]*，*B[y]*，或*B[z]*）的偏导数。在涉及时间的偏导数时，采样点为(*t*
    + Δ*t*/2,*x*,*y*,*z*) 和 (*t* – Δ*t*/2,*x*,*y*,*z*)。在涉及空间的偏导数时，假设在y方向，采样点为(*t*,*x*,*y*
    + Δ*y*/2,*z*) 和 (*t*,*x*,*y* – Δ*y*/2,*z*)。例如，*E[x]*关于时间的偏导数被近似为
- en: '![Image](Images/561equ04.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/561equ04.jpg)'
- en: and the partial derivative of *E[z]* with respect to *y* is approximated as
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 而*E[z]*关于*y*的偏导数被近似为
- en: '![Image](Images/561equ05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/561equ05.jpg)'
- en: Applying this finite difference approximation to Equation 29.17 and performing
    a bit of algebra results in an equation that tells us how to update the value
    of the x-component of electric field.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种有限差分近似应用到方程29.17并进行一些代数运算，得到一个方程，告诉我们如何更新电场x分量的值。
- en: '![Image](Images/561equ06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/561equ06.jpg)'
- en: There are five analogous equations for *E[y]*, *E[z]*, *B[x]*, *B[y]*, and *B[z]*.
    Equation 29.25 and the other five are concisely expressed in vector form as
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对*E[y]*，*E[z]*，*B[x]*，*B[y]*，*B[z]*有五个类似的方程。方程29.25和其他五个方程可以简洁地用向量形式表示为
- en: '![Image](Images/562equ01.jpg)![Image](Images/562equ02.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/562equ01.jpg)![图片](Images/562equ02.jpg)'
- en: 'where components of the curl are approximated as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，旋度的各分量被近似如下：
- en: '![Image](Images/562equ03.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/562equ03.jpg)'
- en: Notice the similarity between Equations 29.26 and 29.27 on one hand and Equations
    29.14 and 29.15 on the other. The only difference is that the curls of the fields
    and the current density are evaluated at a time midway between the original and
    updated values of the fields in the FDTD Equations 29.26 and 29.27, while the
    curls and current density are evaluated at the time of the original values of
    the fields in Equations 29.14 and 29.15, which is closer to the Euler method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方程29.26和29.27与方程29.14和29.15之间的相似性。唯一的不同在于，场的旋度和电流密度在FDTD方程29.26和29.27中，是在场的原值和更新值之间的中间时刻进行评估的，而在方程29.14和29.15中，旋度和电流密度是在场的原值时刻进行评估的，这更接近欧拉法。
- en: The curl of Equation 29.28 requires values of *B[y]* and *B[z]* that are half
    a spatial step away. Updating *E[x]* at a point in time and space depends on *E[x]*
    at the same place one time step *Δt* earlier. It also depends on *B[y]* half a
    spatial step to either side in the z-direction half a time step earlier, and it
    depends on *B[z]* half a spatial step to either side in the y-direction half a
    time step earlier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 方程29.28的旋度要求*B[y]*和*B[z]*的值，这些值距离当前空间步长的一半。更新一个时空点的*E[x]*依赖于同一地点早一步时间步长*Δt*的*E[x]*值。同时，它也依赖于在z方向上，距离该点半个空间步长，且早半个时间步长的*B[y]*值，以及在y方向上，距离该点半个空间步长，且早半个时间步长的*B[z]*值。
- en: These half-spatial-step dependencies imply that the locations at which we keep
    track of the six components should be staggered. The places at which we keep track
    of *E[x]* will be shifted slightly from the places where we keep track of *E[y]*
    or *B[y]*. Equation 29.25 and the five analogous equations for *E[y]*, *E[z]*,
    *B[x]*, *B[y]*, and *B[z]* determine where we should track each component. We
    turn next to describing the locations at which we will keep track of the electric
    and magnetic field components.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些半空间步依赖性意味着我们跟踪六个分量的位置应该是错开的。我们跟踪*E[x]*的位置将略微偏移，和我们跟踪*E[y]*或*B[y]*的位置不同。方程29.25及其他五个类似的方程，分别对应*E[y]*、*E[z]*、*B[x]*、*B[y]*和*B[z]*，决定了我们应该在哪里跟踪每个分量。接下来，我们将描述用于跟踪电场和磁场分量的位置。
- en: The Yee Cell
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Yee单元
- en: We will use a triple `(nx,ny,nz)` of `Int`s to specify a location where we keep
    track of the field components. The integer `nx` measures the number of half spatial
    steps in the x-direction from the origin of our coordinate system. In other words,
    if `dx` is the spatial step size in the x-direction, equivalent to Δ*x* in mathematical
    notation, then the x-coordinate of the position associated with `(nx,ny,nz)` is
    `fromIntegral nx * dx / 2`. Even integers denote whole steps from the origin,
    while odd integers denote an odd number of half steps. [Table 29-2](ch29.xhtml#ch29tab2)
    shows the locations at which each of the six field components is tracked.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个三元组`(nx, ny, nz)`来指定一个位置，用于跟踪场的分量。整数`nx`表示从坐标系原点出发，在x方向上的半空间步数。换句话说，如果`dx`是x方向上的空间步长，相当于数学符号中的Δ*x*，那么与`(nx,
    ny, nz)`相关的位置的x坐标为`fromIntegral nx * dx / 2`。偶数表示从原点起的整步，而奇数表示奇数个半步。[表29-2](ch29.xhtml#ch29tab2)显示了每个场分量的跟踪位置。
- en: '**Table 29-2:** Locations at Which We Calculate Components of the Electric
    and Magnetic Fields'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**表29-2：** 我们计算电场和磁场分量的位置'
- en: '| **Component** | `nx` | `ny` | `nz` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | `nx` | `ny` | `nz` |'
- en: '| --- | --- | --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| *E[x]* | odd | even | even |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| *E[x]* | 奇数 | 偶数 | 偶数 |'
- en: '| *E[y]* | even | odd | even |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| *E[y]* | 偶数 | 奇数 | 偶数 |'
- en: '| *E[z]* | even | even | odd |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| *E[z]* | 偶数 | 偶数 | 奇数 |'
- en: '| *B[x]* | even | odd | odd |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| *B[x]* | 偶数 | 奇数 | 奇数 |'
- en: '| *B[y]* | odd | even | odd |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| *B[y]* | 奇数 | 偶数 | 奇数 |'
- en: '| *B[z]* | odd | odd | even |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| *B[z]* | 奇数 | 奇数 | 偶数 |'
- en: The locations at which values of *E[x]* are kept are held in a list called `exLocs`,
    which is formed using a list comprehension to allow the integer `nx` to range
    over a sequence of consecutive odd integers, `ny` to range over a sequence of
    consecutive even integers, and `nz` to range over a sequence of consecutive even
    integers, as specified in [Table 29-2](ch29.xhtml#ch29tab2). Other lists with
    similar names hold the locations of other field components.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 存储*E[x]*值的位置保存在一个名为`exLocs`的列表中，该列表通过列表推导式形成，允许整数`nx`在一系列连续的奇数中变化，`ny`在一系列连续的偶数中变化，`nz`在一系列连续的偶数中变化，具体如[表29-2](ch29.xhtml#ch29tab2)所示。其他类似名称的列表保存其他场分量的位置。
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The constant `spaceStepsCE` (CE for center to edge) gives the number of full
    spatial steps from the center to the edge of our grid.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 常数`spaceStepsCE`（CE代表从中心到边缘）给出了从网格中心到边缘的完整空间步数。
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use integers to specify locations in the grid. The largest even integer,
    called `hiEven`, is twice the number of full steps from center to edge.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用整数来指定网格中的位置。最大的偶数，称为`hiEven`，是从中心到边缘的完整步数的两倍。
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The even numbers used to specify locations range from `-hiEven` to `hiEven`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指定位置的偶数范围从`-hiEven`到`hiEven`。
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The odd numbers used to specify locations begin one above the lowest even number
    and end one below the highest even number.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指定位置的奇数从最低偶数上方开始，到最高偶数下方结束。
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The pattern of locations for storing the field components is called a *Yee cell*
    and is shown in [Figure 29-2](ch29.xhtml#ch29fig2). The Yee cell is named after
    Kane S. Yee, who pioneered the FDTD method in the 1960s.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 存储场分量的位置模式称为*Yee单元*，如[图29-2](ch29.xhtml#ch29fig2)所示。Yee单元以1960年代首创FDTD方法的Kane
    S. Yee命名。
- en: '![Image](Images/564fig01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/564fig01.jpg)'
- en: '*Figure 29-2: Yee cell showing where electric and magnetic field components
    are calculated*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图29-2：Yee单元，展示电场和磁场分量的计算位置*'
- en: '[Figure 29-2](ch29.xhtml#ch29fig2) shows a patch of three-dimensional space,
    with a coordinate system in which *x* increases to the right, *y* increases up
    the page, and *z* increases out of the page. Double-headed arrows are placed at
    the locations in space where field components are tracked. Black arrows are electric
    field components, and gray arrows are magnetic field components. The direction
    in which the arrow points indicates which of the three components is being shown.
    A left-right arrow, for example, is an x-component. [Figure 29-2](ch29.xhtml#ch29fig2)
    is a visual way of expressing the information in [Table 29-2](ch29.xhtml#ch29tab2).
    For example, an *E[x]*-component is stored at `(nx,ny,nz) = (1,2,0)` since `nx`
    is odd, `ny` is even, and `nz` is even.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 29-2](ch29.xhtml#ch29fig2) 显示了三维空间的一块区域，坐标系中 *x* 向右增加，*y* 向上增加，*z* 向外增加。双箭头表示在空间中跟踪场分量的位置。黑色箭头表示电场分量，灰色箭头表示磁场分量。箭头指向的方向表示显示的是哪一个分量。例如，左右箭头表示
    x 分量。 [图 29-2](ch29.xhtml#ch29fig2) 是一种直观的方式，表达了 [表 29-2](ch29.xhtml#ch29tab2)
    中的信息。例如，*E[x]* 分量存储在 `(nx,ny,nz) = (1,2,0)` 位置，因为 `nx` 是奇数，`ny` 是偶数，`nz` 是偶数。'
- en: One of the features of the Yee cell is that each component’s nearest neighbors
    contain the information needed to update that component in time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Yee 单元格的一个特点是，每个分量的最近邻包含更新该分量所需的信息。
- en: Let’s talk next about how we represent the state of the electric and magnetic
    fields in the FDTD method and how we update that state.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们讨论如何在 FDTD 方法中表示电场和磁场的状态，并如何更新该状态。
- en: A Type for State
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态的类型
- en: Instead of the `FieldState` data type we used in the naive method, which contains
    functions for the electric and magnetic fields, we wish to have a state that holds
    numbers for the components of the electric and magnetic fields at the positions
    identified in the Yee cell of [Figure 29-2](ch29.xhtml#ch29fig2).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在朴素方法中使用的 `FieldState` 数据类型不同，后者包含电场和磁场的函数，我们希望拥有一个状态，该状态保存电场和磁场分量在 [图 29-2](ch29.xhtml#ch29fig2)
    的 Yee 单元格中指定位置的数值。
- en: One of the standard Haskell library modules, `Data.Map.Strict`, includes a data
    structure called a `Map` that is good for this purpose. The type `Map k v` is
    the type of a lookup table of key-value pairs, with `k` being the type of the
    key and `v` being the type of the value. In [Chapter 9](ch09.xhtml) we showed
    how a list of pairs with type `[(k,v)]` can be used as a lookup table, but the
    type `Map k v` is better because it will store the keys in such a way that they
    can be looked up quickly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data.Map.Strict` 是标准的 Haskell 库模块之一，其中包含一个名为 `Map` 的数据结构，适合用于这个目的。类型 `Map
    k v` 是一个键值对查找表的类型，其中 `k` 是键的类型，`v` 是值的类型。在 [第 9 章](ch09.xhtml) 中，我们展示了如何使用类型为
    `[(k,v)]` 的一对列表作为查找表，但类型 `Map k v` 更好，因为它会以一种能够快速查找键的方式存储这些键。'
- en: For the key, we will use a triple `(nx,ny,nz)` of `Int`s to describe the location
    of a field component, and for the value we will use a real number `R`. So, the
    type we want to hold our field data is `Map (Int,Int,Int) R`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于键，我们将使用一个三元组 `(nx,ny,nz)`，它由 `Int` 类型的数字组成，用于描述场分量的位置；而值则使用一个实数 `R`。因此，我们希望存储场数据的类型是
    `Map (Int,Int,Int) R`。
- en: Since electric field components are stored at different locations from magnetic
    field components, we could get away with a single lookup table, but we choose
    to use two tables, one for electric field and one for magnetic field, to make
    the code easier to read.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电场分量存储的位置与磁场分量不同，我们本可以使用一个单独的查找表，但我们选择使用两个表，一个用于电场，一个用于磁场，以使代码更易于阅读。
- en: Our state space, called `StateFDTD`, consists of the time, three real numbers
    for the spatial step size in each direction, a `Map (Int,Int,Int) R` for the electric
    field, and a `Map (Int,Int,Int) R` for the magnetic field. It is not strictly
    necessary to include the spatial step sizes in the state, but it is convenient
    because functions that have a state as input often need to know the spatial step
    sizes to do their jobs. A function that computes the curl of a field, for example,
    needs the spatial step size.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态空间称为 `StateFDTD`，包括时间、三个表示每个方向空间步长的实数、一个 `Map (Int,Int,Int) R` 表示电场，以及一个
    `Map (Int,Int,Int) R` 表示磁场。虽然在状态中包含空间步长并非绝对必要，但这样做很方便，因为以状态作为输入的函数通常需要知道空间步长才能执行其任务。例如，计算场的旋度的函数就需要空间步长。
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the introductory code, the line `import qualified Data.Map.Strict as M` allows
    us to access all of the functions and types defined in `Data.Map.Strict` if we
    prefix them with a capital `M`. Because of the way we imported the module, we
    need to refer to the type `Map (Int,Int,Int) R` as `M.Map (Int,Int,Int) R`, which
    we see above is the type we use to hold the electric field and the magnetic field.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍性代码中，`import qualified Data.Map.Strict as M` 使我们能够访问 `Data.Map.Strict` 中定义的所有函数和类型，只要我们在它们前面加上大写的
    `M`。由于我们是以这种方式导入模块，我们需要将类型 `Map (Int,Int,Int) R` 称为 `M.Map (Int,Int,Int) R`，正如上面所示，这个类型用于保存电场和磁场。
- en: The function `initialStateFDTD` takes a real number that it uses for the spatial
    step size in all three directions as input, and it returns a state in which the
    electric field and the magnetic field are 0 at all positions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `initialStateFDTD` 接收一个实数作为输入，表示在三个方向上的空间步长，并返回一个状态，在该状态下，电场和磁场在所有位置的值都为
    0。
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function `M.fromList` from the `Data.Map.Strict` module turns a list-of-pairs
    lookup table into a `Map` lookup table. We use a list comprehension to form a
    list of pairs in which the key is one of the locations for a field component and
    the value is 0.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data.Map.Strict` 模块中的函数 `M.fromList` 将一个键值对列表的查找表转换为一个 `Map` 查找表。我们使用列表推导式来构建一个键值对列表，其中键是场分量的某个位置，值为
    0。'
- en: The `Data.Map.Strict` module uses strict evaluation instead of Haskell’s default
    lazy evaluation. When doing numerical calculations, we almost never want to use
    lazy evaluation. Lazy evaluation is good when we might, depending on input data,
    compute only a subset of the possible outputs of our program. But when we are
    numerically evaluating a model, we just want to compute the quantities of interest
    at all specified points. In this case, we don’t need to pay the price in memory
    space (a memory pointer to either the code to evaluate a function or the result
    of a previous evaluation) of lazy evaluation. A general rule of thumb is that
    the strict version of a function is usually what you want, unless you really know
    what you are doing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data.Map.Strict` 模块使用严格求值，而不是 Haskell 的默认懒惰求值。在进行数值计算时，我们几乎总是希望使用严格求值。懒惰求值在我们可能根据输入数据计算程序的部分输出时非常有用。但当我们进行数值模型评估时，我们只希望在所有指定的点上计算我们感兴趣的量。在这种情况下，我们不需要为懒惰求值付出内存空间的代价（即内存指针，指向函数的代码或前一次求值的结果）。一个通用的经验法则是，除非你真的知道自己在做什么，否则函数的严格版本通常是你想要的。'
- en: Let’s look now at how we will compute curls in the FDTD method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下如何在 FDTD 方法中计算旋度。
- en: FDTD and the Curl
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FDTD 和旋度
- en: 'Equation 29.28 showed how to compute the x-component of the curl of the magnetic
    field in the FDTD method. There are five other analogous equations: two for the
    y- and z-components of the curl of the magnetic field and three for the components
    of the curl of the electric field. The approximation of the curl in Equation 29.28
    is based on the approximation of the partial derivative in Equation 29.24, so
    we’ll want to encode the partial derivative first. However, even more basic than
    computing the partial derivative is simply looking up values from the key-value
    lookup table, so let’s address that now.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 29.28 显示了如何在 FDTD 方法中计算磁场的 x 分量旋度。还有五个类似的方程：两个用于磁场旋度的 y 分量和 z 分量，三个用于电场旋度的分量。方程
    29.28 中旋度的近似值是基于方程 29.24 中偏导数的近似，因此我们首先需要编码偏导数。然而，比计算偏导数更基本的是从键值查找表中查找值，所以我们先来处理这个问题。
- en: Looking Up Values in the Lookup Table
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在查找表中查找值
- en: The `Data.Map.Strict` module provides the function `lookup`, which we write
    as `M.lookup`, to retrieve values from a lookup table. Let’s look at the type
    of this function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data.Map.Strict` 模块提供了 `lookup` 函数，我们写作 `M.lookup`，用于从查找表中获取值。我们来看看这个函数的类型。'
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we wanted to see the type of `lookup` from `Data.Map.Strict` without loading
    the code in this chapter, we could do the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在不加载本章代码的情况下查看 `Data.Map.Strict` 中 `lookup` 的类型，可以执行以下操作：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we ask for the type of `lookup` using the fully qualified name of the function,
    prefixing the module name before the function name to distinguish the `lookup`
    of `Data.Map.Strict` from the `lookup` of `Prelude`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用函数的完全限定名称来请求 `lookup` 的类型，方法是将模块名加到函数名之前，以区分 `Data.Map.Strict` 中的 `lookup`
    和 `Prelude` 中的 `lookup`。
- en: From the type, we see that `M.lookup` wants a key and a lookup table and will
    return something of type `Maybe a`. If it finds the key in the table, it will
    return the value associated with it, wrapped in the `Just` constructor of the
    `Maybe a` type. If it doesn’t find the key, it will return `Nothing`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型中我们可以看到，`M.lookup`需要一个键和一个查找表，并将返回类型为`Maybe a`的结果。如果它在表中找到了该键，它会返回与之关联的值，值会被`Maybe
    a`类型的`Just`构造函数包裹。如果它没有找到该键，则会返回`Nothing`。
- en: Our helping function `lookupAZ` uses `M.lookup` to do its work.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的辅助函数`lookupAZ`使用`M.lookup`来完成其工作。
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function `lookupAZ` (AZ for assume zero) has a slightly simpler type than
    `M.lookup`. The function serves two purposes. First, it relieves us of the need
    to case analyze the results each time we do a lookup. Second, when we compute
    a curl for a location at the edge of our grid, we will be trying to look up values
    that don’t exist because they are just off the grid. For these two reasons, we
    write a function that treats nonexistent keys as if they had values of 0\. This
    is not the safest procedure, because it will not help us find errors in our code
    if we are asking for nonexistent keys because of a mistake we made in programming.
    I’m generally a pretty careful and conservative person, but in this one case,
    I chose to live on the wild side.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`lookupAZ`（AZ代表假定为零）的类型比`M.lookup`稍微简单一些。这个函数有两个作用。首先，它免去了我们每次查找时都需要对结果进行案例分析的麻烦。其次，当我们计算网格边缘位置的旋度时，我们会尝试查找那些不存在的值，因为它们就在网格之外。出于这两个原因，我们编写了一个函数，将不存在的键视作其值为0。这个做法并不是最安全的，因为如果我们因编程错误请求了不存在的键，它不会帮助我们发现错误。我通常是一个相当小心和保守的人，但在这个特殊情况下，我决定冒点风险。
- en: The partial derivative requires that we look up values of the relevant component
    half a spatial step to either side of where we want to compute the derivative.
    Half a spatial step means one integer higher and one integer lower in the relevant
    direction. The functions `partialX`, `partialY`, and `partialZ` all have the same
    type.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 偏导数要求我们查找目标位置两侧半个空间步长的相关分量值。半个空间步长意味着在相关方向上一个整数较高和一个整数较低。函数`partialX`、`partialY`和`partialZ`的类型是相同的。
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each function takes a spatial step size, a lookup table (called `m` for map),
    and a location as input. Each works by using the `lookupAZ` function to retrieve
    values on either side of the given location. The difference between these values
    is divided by the step size to obtain the approximation to the partial derivative.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都接受一个空间步长、一个查找表（称为`m`，即地图）和一个位置作为输入。每个函数通过使用`lookupAZ`函数来检索给定位置两侧的值。将这些值的差值除以步长，得到偏导数的近似值。
- en: Computing the Curl
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计算旋度
- en: With partial derivative in hand, we now turn to the curl. Here are six functions
    that compute components of the curl of the electric field and the magnetic field.
    Equation 29.7 gives the components of the curl.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有了偏导数之后，我们现在转向旋度。这里有六个函数用于计算电场和磁场的旋度分量。方程29.7给出了旋度的分量。
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each curl function takes a `StateFDTD` and a location as input. The function
    `curlBx` computes the x-component of the curl of the magnetic field. According
    to Equation 29.7, this is the difference between the partial derivative with respect
    to *y* of *B[z]*, denoted `partialY dy b loc` in the code above, and the partial
    derivative with respect to *z* of *B[y]*, denoted `partialZ dz b loc`, each evaluated
    at the given location. Why do we not specify in the expression `partialY dy b
    loc` that it is the z-component we want the derivative of? The answer is that,
    because of the way the Yee cell is constructed, every location at which we need
    to compute `curlBx` has *B[z]* living one integer away in the y-direction. The
    x-component of the curl of the magnetic field is needed only to update the x-component
    of the electric field. We use `curlBx` only when we update *E[x]*, and *B[z]*
    is its neighbor in the y-direction, so taking `partialY` at that location automatically
    takes the partial of *B[z]*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每个旋度函数接受一个`StateFDTD`和一个位置作为输入。函数`curlBx`计算磁场旋度的x分量。根据方程29.7，这是对*B[z]*关于*y*的偏导数（在上面的代码中表示为`partialY
    dy b loc`）和对*B[y]*关于*z*的偏导数（在上面代码中表示为`partialZ dz b loc`）之间的差值，每个值在给定的位置进行评估。为什么我们不在表达式`partialY
    dy b loc`中指定我们要求偏导数的是z分量？答案是，由于Yee单元的构造方式，我们需要计算`curlBx`的每个位置在y方向上有一个间隔为1的*B[z]*。磁场旋度的x分量仅用于更新电场的x分量。我们只有在更新*E[x]*时才使用`curlBx`，而*B[z]*在y方向上是它的邻居，因此在该位置进行`partialY`操作时，自动计算的是*B[z]*的偏导数。
- en: Let’s look now at how we will update the state.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何更新状态。
- en: State Update
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态更新
- en: The function `stateUpdate` takes a time step, a time-dependent current density,
    and a state as input, and it uses that information to produce an updated state
    as output. It passes the real work off to the functions `updateE` and `updateB`,
    which update the electric and magnetic fields, respectively.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`stateUpdate`接受一个时间步长、一个时间依赖的电流密度和一个状态作为输入，并利用这些信息生成更新后的状态作为输出。它将实际的工作委托给`updateE`和`updateB`函数，分别更新电场和磁场。
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Updating the electric field, as Equation 29.25 shows, requires knowledge of
    the current density, so we include the current density at the present time, `j
    t`, as an input to `updateE`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如方程29.25所示，更新电场需要知道电流密度，因此我们将当前时刻的电流密度`j t`作为`updateE`的输入。
- en: The role of `updateE` is to carry out Equation 29.25 and the analogous equations
    for *E[y]* and *E[z]* that come from Equations 29.18 and 29.19.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateE`的作用是执行方程29.25以及从方程29.18和29.19得出的关于*E[y]*和*E[z]*的类似方程。'
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The function `updateE` uses record syntax to update two of the items in the
    state: the time and the electric field. The function updates the current time,
    `timeFDTD st`, by adding half a time step to it. The function `updateB` adds the
    other half time step.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`updateE`使用记录语法更新状态中的两个项目：时间和电场。该函数通过向当前时间`timeFDTD st`添加半个时间步长来更新当前时间。函数`updateB`添加另一个半时间步长。
- en: We update the electric field components at every place they are stored using
    the `mapWithKey` function from `Data.Map.Strict`. Let’s look at the type of `mapWithKey`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Data.Map.Strict`中的`mapWithKey`函数，在每个存储电场分量的位置更新它们。让我们看看`mapWithKey`的类型。
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `mapWithKey` function takes a higher-order function `k -> a -> b` as input.
    For us, this will be a function `(Int,Int,Int) -> R -> R`. It describes how to
    use the key and value of a key-value pair to produce a new value. The function
    `updateEOneLoc dt jVF st`, defined later, serves this role for us, describing
    how to update an electric field component at a particular position in space.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapWithKey`函数接受一个高阶函数`k -> a -> b`作为输入。对我们来说，这将是一个函数`(Int,Int,Int) -> R ->
    R`。它描述了如何使用键值对的键和值来生成一个新的值。稍后定义的函数`updateEOneLoc dt jVF st`为我们提供了这个角色，描述了如何更新空间中特定位置的电场分量。'
- en: The function `updateB` updates the magnetic field. It does for the magnetic
    field what `updateE` does for the electric field. The only difference is that
    the current density is not required to update the magnetic field, so it is not
    an input to `updateB`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`updateB`更新磁场。它对磁场执行的操作与`updateE`对电场执行的操作相同。唯一的区别是更新磁场不需要电流密度，因此它不是`updateB`的输入。
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As promised, `updateB` increases the time by half a time step, so after we have
    used both `updateE` and `updateB`, the time has increased by one whole time step.
    As with `updateE`, `updateB` uses `mapWithKey` to carry out the update over all
    locations we are tracking in the state. For the magnetic field, the function we
    map across the lookup table is called `updateBOneLoc dt st`. We define it later,
    and it describes how to update the magnetic field at one particular location in
    space.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所承诺的，`updateB`通过半个时间步长来增加时间，因此在我们使用了`updateE`和`updateB`之后，时间就增加了一个完整的时间步长。与`updateE`一样，`updateB`使用`mapWithKey`来执行所有我们在状态中跟踪的位置的更新。对于磁场，我们映射的查找表函数叫做`updateBOneLoc
    dt st`。我们稍后会定义它，它描述了如何更新空间中一个特定位置的磁场。
- en: Now we look at the functions that update the electric and magnetic fields at
    one point in space. Here we finally see the Maxwell equations. The function `updateEOneLoc`
    is responsible for updating electric field components at one location in space.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下更新空间中某一点电场和磁场的函数。这里我们终于看到了麦克斯韦方程。`updateEOneLoc`函数负责更新空间中一个位置的电场分量。
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It requires a time step, a current density, the state, a location, and a present
    electric field component value as inputs. It uses a `let` construction to define
    a few local variables. The local variable `r` holds the position described by
    the integer triple `(nx,ny,nz)`. The current density needs this position, and
    we compute it by multiplying each integer by half a spatial step in the appropriate
    direction. The local variables `jx`, `jy`, and `jz` are the components of the
    current density at the relevant location. Finally, we decide which component is
    being updated by examining the oddness or evenness of the three integers. As [Table
    29-2](ch29.xhtml#ch29tab2) indicates, an odd-even-even triple of integers means
    we are updating *E[x]*, an even-odd-even triple of integers means we are updating
    *E[y]*, and an even-even-odd triple of integers means we are updating *E[z]*.
    We include a final line to catch a triple that does not fall into one of these
    three cases, which would indicate an error in our code since `updateEOneLoc` should
    only ever be used at locations that hold electric field components.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要输入时间步长、电流密度、状态、位置和当前的电场分量值。它使用`let`构造来定义一些局部变量。局部变量`r`表示由整数三元组`(nx,ny,nz)`描述的位置。电流密度需要这个位置，我们通过将每个整数乘以适当方向的半个空间步长来计算它。局部变量`jx`、`jy`和`jz`是该位置的电流密度分量。最后，我们通过检查这三个整数的奇偶性来决定更新哪个分量。正如[表29-2](ch29.xhtml#ch29tab2)所示，奇偶偶的整数三元组意味着我们在更新*E[x]*，偶奇偶的整数三元组意味着我们在更新*E[y]*，偶偶奇的整数三元组意味着我们在更新*E[z]*。我们包括最后一行代码来捕捉不属于这三种情况的三元组，这将表示我们的代码中存在错误，因为`updateEOneLoc`只能在包含电场分量的位置使用。
- en: Depending on the case analysis, we update the electric field component, called
    `ec`, using one of the three Cartesian components of Equation 29.26\. The local
    variable `ec` contains the present value of the electric field component to be
    updated (that is, one of *E[x]*, *E[y]*, or *E[z]*).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 根据案例分析，我们使用方程29.26中的三个笛卡尔分量之一来更新电场分量，称为`ec`。局部变量`ec`包含当前要更新的电场分量的值（即*E[x]*、*E[y]*或*E[z]*之一）。
- en: The function `updateBOneLoc` does for the magnetic field what `updateEOneLoc`
    does for the electric field.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateBOneLoc`函数对于磁场的作用类似于`updateEOneLoc`函数对于电场的作用。'
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function is simpler because it does not involve the current density. Again,
    there is a case analysis on the oddness or evenness of the three integers describing
    the location to determine which magnetic field component we are asking the function
    to update. As [Table 29-2](ch29.xhtml#ch29tab2) indicates, an even-odd-odd triple
    of integers means we are updating *B[x]*, an odd-even-odd triple of integers means
    we are updating *B[y]*, and an odd-odd-even triple of integers means we are updating
    *B[z]*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数更简单，因为它不涉及电流密度。再次，根据描述位置的三个整数的奇偶性进行案例分析，以确定我们要求函数更新哪个磁场分量。正如[表29-2](ch29.xhtml#ch29tab2)所示，偶奇奇的整数三元组意味着我们在更新*B[x]*，奇偶奇的整数三元组意味着我们在更新*B[y]*，而奇奇偶的整数三元组意味着我们在更新*B[z]*。
- en: Depending on the case analysis, we update the magnetic field component, called
    `bc`, using one of the three Cartesian components of Equation 29.27\. The local
    variable `bc` contains the magnetic field component to be updated, which could
    be *B[x]*, *B[y]*, or *B[z]*, depending on the oddness or evenness of the integers
    in the triple.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 根据具体的案例分析，我们使用方程29.27中的三个笛卡尔分量之一来更新磁场分量 `bc`。局部变量 `bc` 包含待更新的磁场分量，这可能是 *B[x]*、*B[y]*
    或 *B[z]*，具体取决于三元组中整数的奇偶性。
- en: This completes the description of the FDTD method. The function `stateUpdate`
    is the entry point for those wishing to use the method. It requires a time step,
    a time-dependent current density, and an initial state, and it gives back an updated
    state one time step later. We will likely want to iterate this `stateUpdate` function
    to see the fields evolve over time.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了FDTD方法的描述。`stateUpdate` 函数是希望使用此方法的入口点。它需要一个时间步长、一个时间相关的电流密度和一个初始状态，并返回一个更新后的状态。我们可能需要反复调用这个
    `stateUpdate` 函数，以查看场的随时间变化。
- en: Let’s turn now to a use of the FDTD method by producing an animation of the
    fields for the radiation produced by an oscillating current density.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过制作由振荡电流密度产生的辐射场动画来使用FDTD方法。
- en: Animation
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画
- en: An accelerating charge radiates. In other words, an accelerating charge creates
    wavelike electric and magnetic fields that emanate away from the source charge.
    We can track how the electric and magnetic fields evolve in time by solving the
    Maxwell equations using the FDTD method we developed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 加速电荷会辐射。换句话说，加速电荷会产生波动型的电场和磁场，从源电荷向外传播。我们可以通过使用我们开发的FDTD方法求解麦克斯韦方程来追踪电场和磁场随时间的演变。
- en: Current Density
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电流密度
- en: In this section, we’ll produce an animation of the electric field produced by
    an oscillating current density. Our current density will be localized in space,
    and we’ll center our coordinate system on the current density. There are several
    ways we could produce a localized current density. Since we have discretized space
    in the FDTD method, one way to specify a localized current density is to allow
    the current density to be nonzero at a single location in the FDTD grid. Slightly
    more convenient for us is to specify a current density that extends over several
    grid points but quickly drops off with distance from its center.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将制作一个由振荡电流密度产生的电场动画。我们的电流密度将在空间中局部化，我们将把坐标系的原点设在电流密度的中心。我们可以通过多种方式来产生局部化的电流密度。由于我们已经在FDTD方法中离散化了空间，一种指定局部电流密度的方法是允许电流密度在FDTD网格中的某个位置非零。对我们来说，更方便的一种方法是指定一个电流密度，该密度扩展到几个网格点，但随着距离中心的增加迅速减小。
- en: One function that drops off in this way depends on the distance *r* from the
    origin as *e*^(–*r*²/*l*²). Such a function is called a *Gaussian*. Its largest
    value is at the origin, and its value decreases with distance from the origin.
    The parameter *l* has dimensions of length and gives a sense of the region over
    which the value is significant. At *r* = *l*, the Gaussian value is 36.8 percent
    of its value at the origin. At *r* = 2*l*, its value is only 1.8 percent of its
    value at the origin. And by *r* = 3*l*, its value is only about a hundredth of
    a percent. Equation 29.29 gives the current density we use for our radiation animation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一种以这种方式衰减的函数依赖于原点到位置的距离 *r*，其形式为 *e*^(–*r*²/*l*²)。这样的函数被称为*高斯函数*。它在原点的值最大，且其值随着距离的增加而减小。参数
    *l* 具有长度的量纲，表示电流密度值显著的区域大小。当 *r* = *l* 时，高斯值为原点值的36.8%；当 *r* = 2*l* 时，其值仅为原点值的1.8%；而当
    *r* = 3*l* 时，其值仅约为原点值的千分之一。方程29.29给出了我们用于辐射动画的电流密度。
- en: '![Image](Images/571equ01.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/571equ01.jpg)'
- en: 'We need three parameters to fully specify this current density: an amplitude
    *J*[0], a localization length *l*, and a frequency *f* . We can think of this
    current density as representing a charge at the origin that is oscillating in
    the z-direction.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要三个参数来完全指定这个电流密度：幅度 *J*[0]、局部化长度 *l* 和频率 *f*。我们可以把这个电流密度看作是在原点振荡的电荷，其振荡方向为z轴。
- en: The function `jGaussian` describes the current density in Equation 29.29.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`jGaussian` 函数描述了方程29.29中的电流密度。'
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The function `jGaussian` uses some local variables to specify its behavior.
    We wish for the oscillation to occur with a frequency that will produce radiation
    with a wavelength of 1.08 m. The frequency (in Hz) is the speed of light divided
    by the wavelength. We chose an amplitude of 77.5 A/m² because this radiates about
    100 W of power. We chose the parameter *l* to be 0.108 m, which is the same value
    we will choose later for the spatial step size of the grid. This means that only
    grid points near the origin will contain any significant current density.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`jGaussian`使用一些局部变量来指定其行为。我们希望振荡以一定的频率发生，从而产生波长为1.08米的辐射。频率（以赫兹为单位）是光速除以波长。我们选择了77.5
    A/m²的幅度，因为这样能够辐射约100瓦的功率。我们选择参数*l*为0.108米，这也是我们稍后在网格的空间步长中选择的值。这意味着只有靠近原点的网格点才会包含任何显著的电流密度。
- en: Having decided on a current density to serve as the source of our electric and
    magnetic fields, we turn to a few comments about the boundary of the grid.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定了电流密度作为电场和磁场的源后，我们转向一些关于网格边界的说明。
- en: Grid Boundary
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网格边界
- en: The FDTD method uses a finite grid that keeps track of the electric and magnetic
    fields at a finite number of places. We use neighboring grid points to calculate
    the curl needed by the Maxwell equations, as explained earlier. What happens at
    the edges of the grid? The simple choice we made is to assume that electric and
    magnetic fields beyond the grid are 0\. This choice is enforced by the lookupAZ
    function, which returns 0 for any point off the grid. While this choice is simple
    and seems reasonable, it has some undesirable properties. An outgoing wave will
    reflect at the edge of the grid, bounce back, and interfere. However, if the grid
    is very large, the amplitude of the reflected wave may be very small and its presence
    may be tolerable. In our case, we display only a portion of the grid on which
    calculations occur. Our animation terminates before the wave hits the boundary,
    so we do not see any reflected wave. In general, the results obtained using our
    simple boundary conditions are only valid until the wave propagates to the edge
    of the grid. There are more sophisticated methods available for dealing with the
    boundary conditions at the edge of the grid. One way is to model a material that
    absorbs all of the radiation incident; this more or less acts like an infinite
    box, without requiring computing an infinite number of points. The book by Inan
    and Marshall [**[18](bib.xhtml#bib18)**] has a nice discussion of boundary conditions
    for the FDTD method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: FDTD方法使用有限的网格，在有限数量的位置跟踪电场和磁场。我们使用相邻的网格点来计算麦克斯韦方程所需的旋度，正如前面所解释的那样。网格边缘发生了什么情况？我们做出的简单选择是假设网格之外的电场和磁场为0。这个选择是由lookupAZ函数强制执行的，任何网格外的点都会返回0。虽然这个选择简单且似乎合理，但它也有一些不理想的特性。一个外出的波会在网格的边缘反射，反弹回来并干涉。然而，如果网格非常大，反射波的幅度可能非常小，它的存在可能是可以容忍的。在我们的案例中，我们只显示发生计算的网格的部分区域。我们的动画在波到达边界之前就终止了，因此我们看不到任何反射波。通常情况下，使用我们简单的边界条件得到的结果只在波传播到网格边缘之前有效。也有更复杂的方法可以处理网格边缘的边界条件。一种方法是模拟一个吸收所有入射辐射的材料；这或多或少地像一个无限的盒子，而无需计算无限多的点。Inan和Marshall的书籍[**[18](bib.xhtml#bib18)**]对FDTD方法的边界条件进行了很好的讨论。
- en: Even without sophisticated boundary conditions, the calculations we are doing
    are computationally intensive. It could take 20 minutes or more to generate all
    of the PNG files that will be sewn together to produce the final animation. The
    files are produced as the information becomes available, so you can see on your
    own machine how many files are produced in a minute and estimate how long the
    entire batch will take.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有复杂的边界条件，我们正在进行的计算也具有很高的计算量。生成所有PNG文件可能需要20分钟或更长时间，这些文件将被拼接在一起，生成最终的动画。文件在信息可用时生成，因此你可以在自己的机器上看到每分钟生成的文件数量，并估算整个批次所需的时间。
- en: Now we are ready to turn to the question of producing frames for the asynchronous
    animation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好转向关于生成异步动画帧的问题。
- en: Display Function
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示函数
- en: We want a function that will produce a picture given a `StateFDTD`. The function
    `makeEpng` serves this role. It produces a PNG graphics file from a state of the
    electromagnetic field. We intend to produce one such graphics file at each time
    step and then sew them together into an animation. The picture we produce in `makeEpng`
    is that of the electric field in the xz-plane. We use shading to indicate the
    strength of the field, transitioning from one color (usually black or white) indicating
    a zero field to another color indicating some maximum strength.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个函数能够根据`StateFDTD`生成图片。函数`makeEpng`就是为此而生。它根据电磁场的状态生成一个PNG图形文件。我们计划在每个时间步长生成一个这样的图形文件，然后将它们拼接成动画。我们在`makeEpng`中生成的图片是xz平面上的电场图。我们使用阴影来表示场的强度，从一个表示零场的颜色（通常是黑色或白色）过渡到另一个表示最大强度的颜色。
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The function `makeEpng` takes a pair of colors as input, as well as a pair containing
    an integer `n` and the state of the electromagnetic field. The color pair consists
    of a strong color `scol` for the color of the strongest fields and a zero color
    `zcol` for the color of a zero field. The integer `n` that is paired with the
    state serves as part of the name of the PNG file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`makeEpng`接受一对颜色作为输入，以及一对包含整数`n`和电磁场状态的值。颜色对由表示最强场的强色`scol`和表示零场的零色`zcol`组成。与状态配对的整数`n`作为PNG文件名称的一部分。
- en: The function `makeEpng` uses local variables to name the PNG file, the threshold
    for a strong electric field, and a list of electric field values to be displayed.
    The local name `pngFilePath` is a `String` whose value is the name of the PNG
    file to be produced. This name is *MaxVF* followed by three digits from the integer
    `n`, followed by *.png*. We use the threshold `strongE` for a strong electric
    field to choose the display color for each electric field arrow. We color electric
    field values of 176 V/m or higher with the strong color `scol`, values of 0 with
    the zero color `zcol`, and values in between with a blend of the two colors.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`makeEpng`使用局部变量来命名PNG文件、设置强电场的阈值，并列出需要显示的电场值。局部名称`pngFilePath`是一个`String`，其值是待生成的PNG文件的名称。该名称是*MaxVF*后跟整数`n`的三位数字，再后面是*.png*。我们使用阈值`strongE`来表示强电场，用于选择每个电场箭头的显示颜色。我们将176
    V/m或更高的电场值用强色`scol`表示，0值用零色`zcol`表示，介于两者之间的值则使用两种颜色的混合。
- en: The list `vs` has type `[((R,R),(R,R))]` and contains the two-dimensional locations
    and components of the electric field to be displayed. The function `getAverage`,
    defined next, takes a triple of even integers as input and averages the values
    on either side of the Yee cell to produce a vector at a single point in space.
    Finally, we use the function `gradientVectorPNG`, defined below, to make the picture.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`vs`的类型为`[((R,R),(R,R))]`，包含了要显示的电场的二维位置和分量。下文定义的函数`getAverage`接受一组三个偶数作为输入，通过平均Yee单元两侧的值来生成空间中某一点的向量。最后，我们使用下文定义的函数`gradientVectorPNG`来制作图片。
- en: Two Helping Functions
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 两个辅助函数
- en: The function `getAverage`, used in `makeEpng` earlier, produces field vectors
    at particular locations by averaging the values around the location. Since the
    Yee cell stores different field components at different locations, we might ask
    whether there is any natural way to recombine the components into a single vector.
    The answer is yes, as long as we are willing to use the average of the values
    at two locations. At any point in the Yee cell labeled by an even-even-even triple,
    electric field components are stored at each adjacent location. By averaging these,
    we can produce an electric field vector at any even-even-even location. Similarly,
    we can produce a magnetic field vector at any odd-odd-odd location.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`getAverage`，之前在`makeEpng`中使用，用于通过平均周围位置的值来生成特定位置的场向量。由于Yee单元在不同的位置存储不同的场分量，我们可能会问是否有任何自然的方法可以将这些分量重新组合成一个单一的向量。答案是肯定的，只要我们愿意使用两个位置的值的平均值。在由偶偶偶三元组标记的Yee单元的任何位置，电场分量都存储在每个相邻的位置。通过平均这些值，我们可以在任何偶偶偶位置生成一个电场向量。类似地，我们可以在任何奇奇奇位置生成一个磁场向量。
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The function `getAverage` takes an integer triple as input, which should be
    either even-even-even for an electric field or odd-odd-odd for a magnetic field,
    along with a lookup table, and produces a vector. It does this by sampling the
    six locations adjacent to the input location, averaging the values in each direction,
    and putting the averaged components into a vector.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`getAverage`接受一个整数三元组作为输入，该三元组应该是电场的偶偶偶或磁场的奇奇奇，并附带一个查找表，然后返回一个矢量。它通过采样输入位置相邻的六个位置，平均每个方向的值，并将平均后的分量放入矢量中。
- en: The function `gradientVectorPNG`, used by `makeEpng` earlier, is similar to
    `vfGrad` from [Chapter 22](ch22.xhtml). It produces a gradient vector field picture.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`gradientVectorPNG`，在之前的`makeEpng`中使用，与[第22章](ch22.xhtml)中的`vfGrad`类似。它生成一个梯度矢量场图片。
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The function `gradientVectorPNG` takes three inputs: a name for the PNG file,
    a pair of colors to use, and a list of two-dimensional vector locations and components.
    It gives the local name `fileName` to the string given as a name for the PNG file.
    It gives the local names `scol` and `zcol` to the strong color and zero color
    to be used in the picture. The list `vs :: [((R,R),(R,R))]` gives the locations
    (first pair of real numbers) and components (second pair of real numbers) of the
    vectors to be displayed. The magnitudes of these two-dimensional vectors are expected
    to be in the range 0 (which will get the zero color) to 1 (which will get the
    strong color).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '函数`gradientVectorPNG`接受三个输入：PNG文件的名称、要使用的颜色对以及二维矢量位置和分量的列表。它将传入的PNG文件名称字符串赋予局部名称`fileName`。它将局部名称`scol`和`zcol`分别赋给要在图片中使用的强色和零色。列表`vs
    :: [((R,R),(R,R))]`提供了要显示的矢量的位置（实数对的第一个部分）和分量（实数对的第二个部分）。这些二维矢量的大小预期在0（将获得零色）到1（将获得强色）之间。'
- en: The function `gradientVectorPNG` assigns the local name `maxX` to the largest
    value of *x* describing the locations of the arrows. The local function `normalize`
    takes an (*x*,*y*) pair as input and returns a pair in the square from (–1, –1)
    to (1, 1). The function `normalize` assumes that the region to be displayed is
    a square patch in the xy-plane centered at the origin. The local list `array`
    contains the normalized locations at which arrows are to be placed, along with
    the magnitude and orientation of each arrow.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`gradientVectorPNG`将描述箭头位置的最大值*x*赋予局部名称`maxX`。局部函数`normalize`接受一个(*x*,*y*)对作为输入，并返回一个位于(–1,
    –1)到(1, 1)的平方范围内的对。函数`normalize`假设要显示的区域是位于原点的xy平面上的一个正方形区域。局部列表`array`包含箭头要放置的归一化位置，以及每个箭头的大小和方向。
- en: The function `arrowMagRadColors` is a helping function that produces a diagram
    of a single arrow. We define it as a local function because `gradient` `VectorPNG`
    is the only function that uses it. Since it is a local function, it can use the
    local colors `scol` and `zcol` without these colors being inputs to `arrow` `MagRadColors`.
    The function `arrowMagRadColors` expects the magnitude of arrows to be in the
    range from 0 to 1, assigning the zero color to 0 and the strong color to 1.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`arrowMagRadColors`是一个辅助函数，用于生成单个箭头的图示。我们将其定义为局部函数，因为只有`gradientVectorPNG`函数使用它。由于它是局部函数，因此可以使用局部颜色`scol`和`zcol`，而无需将这些颜色作为`arrowMagRadColors`的输入。函数`arrowMagRadColors`期望箭头的大小在0到1的范围内，将零颜色分配给0，将强色分配给1。
- en: We use the local variable `step` to scale the size of the arrows. It is based
    on the number of arrows to be displayed on each horizontal row, that number being
    equal to the square root of the total number of arrows to be displayed over the
    entire square. The local variable `pic` holds the entire picture that the final
    line of the function renders.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用局部变量`step`来缩放箭头的大小。它基于每行要显示的箭头数量，该数量等于要在整个正方形中显示的箭头总数的平方根。局部变量`pic`保存着函数最终渲染的整个图片。
- en: Main Program
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主程序
- en: '[Listing 29-2](ch29.xhtml#ch29list2) sets the time step size, the number of
    time steps to be taken, and the spatial step size through its specification of
    the initial state.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表29-2](ch29.xhtml#ch29list2)通过指定初始状态设置了时间步长、时间步数和空间步长。'
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 29-2: Stand-alone program to produce PNG files for an electric field
    animation*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表29-2：用于生成电场动画PNG文件的独立程序*'
- en: It uses the `sequence_` function, described in [Chapter 20](ch20.xhtml), to
    turn a list of actions into a single action. Since the function application operator
    `$` is right associative (recall [Table 1-2](ch01.xhtml#ch1tab2)), it’s easiest
    to read the definition of `mainPNGs` from right to left. The rightmost phrase,
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`sequence_`函数，该函数在[第20章](ch20.xhtml)中有描述，将一系列操作转换为一个单一的操作。由于函数应用运算符`$`是右结合的（回顾[表1-2](ch01.xhtml#ch1tab2)），因此最容易从右到左阅读`mainPNGs`的定义。最右边的短语，
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: is an infinite list of states, starting with an initial state in which the electric
    and magnetic fields are 0 everywhere and the spatial step size in each direction
    is 0.108 m. Applying `zip [0..numTimeSteps]` to this infinite list produces a
    finite list, each element being a pair of an integer with a state. Applying `map
    (makeEpng (yellow,black))` to this list of pairs produces a finite list with type
    `[IO ()]`. Finally, applying `sequence_` converts the list of actions into a single
    action. This program will produce 720 files, named *MaxVF000.png* through *MaxVF719.png*,
    that we can combine into an MP4 movie with an external program such as ffmpeg.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个无限状态列表，从初始状态开始，其中电场和磁场在任何地方均为零，每个方向上的空间步长为0.108米。将`zip [0..numTimeSteps]`应用于此无限列表，生成一个有限列表，每个元素都是一个整数与一个状态的配对。将`map
    (makeEpng (yellow,black))`应用于这个配对列表，会生成一个类型为`[IO ()]`的有限列表。最后，应用`sequence_`将这些操作列表转换为一个单一操作。该程序将生成720个文件，命名为*MaxVF000.png*至*MaxVF719.png*，我们可以使用ffmpeg等外部程序将它们合并成一个MP4电影。
- en: The following command asks the external program ffmpeg to combine all PNG files
    named *MaxVFDDD.png*, where the capital Ds are digits. We ask for a frame rate
    of 25 frames/second. The final movie is called *MaxVF.mp4*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令要求外部程序ffmpeg将所有名为*MaxVFDDD.png*的PNG文件合并，其中大写的D是数字。我们要求每秒25帧的帧率。最终的电影叫做*MaxVF.mp4*。
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We use a spatial step size of 0.108 m because it is one tenth of the wavelength
    we expect from our current density. 10 spatial steps per wavelength is about the
    smallest I’d like to go. More spatial steps per wavelength would produce more
    accurate results but would take longer to run, assuming we increase the number
    of grid points to allow the same number of wavelengths to fit across the grid.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用0.108米的空间步长，因为它是我们期望的电流密度对应波长的十分之一。每个波长10个空间步长是我希望的最小步长。更多的空间步长会产生更精确的结果，但假设我们增加网格点的数量，以便使相同数量的波长适应网格，运行时间会更长。
- en: The time step needs to be a bit smaller than the time it takes light to travel
    one spatial step; otherwise, the method becomes unstable. (See [**[18](bib.xhtml#bib18)**]
    for details on the stability criterion.) It takes light about 0.36 ns to travel
    one spatial step. Our time step of 0.02 ns is plenty small to avoid instability.
    Of course, a smaller time step produces more accurate results at the cost of longer
    computation time.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 时间步长需要稍微小于光传播一个空间步长所需的时间；否则，方法会变得不稳定。（有关稳定性标准的详细信息，请参见[**[18](bib.xhtml#bib18)**]）光传播一个空间步长大约需要0.36纳秒。我们的时间步长0.02纳秒足够小，可以避免不稳定性。当然，较小的时间步长会产生更精确的结果，但计算时间会更长。
- en: '[Figure 29-3](ch29.xhtml#ch29fig3) shows one of the frames of the animation,
    except that we used black as the strong color and white as the zero color.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[图29-3](ch29.xhtml#ch29fig3)显示了动画的一个帧，唯一不同的是我们使用了黑色作为强色，白色作为零色。'
- en: '![Image](Images/577fig01.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/577fig01.jpg)'
- en: '*Figure 29-3: Electric field obtained by solving the Maxwell equations using
    the current density `jGaussian`. The image is one of the frames produced by the
    main program and shows the xz-plane.*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图29-3：通过求解麦克斯韦方程组得到的电场，使用的是电流密度`jGaussian`。该图像是主程序生成的帧之一，显示了xz平面。*'
- en: The wavelike nature of the electric field is apparent. The magnetic field, not
    shown in [Figure 29-3](ch29.xhtml#ch29fig3), points into or out of the page. The
    magnitude of the electric field decreases with distance from the source at the
    center. The radiating electric field is stronger in the *z* = 0 plane and weaker
    above and below the source in the z-direction.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 电场的波动性质显而易见。磁场没有显示在[图29-3](ch29.xhtml#ch29fig3)中，它指向或背离页面。电场的强度随着距离源点的增加而减弱。辐射电场在*z*
    = 0平面上较强，而在源点上下的z方向上较弱。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how the Maxwell equations describe the evolution of
    electric and magnetic fields. We identified four relationships between electricity
    and magnetism, and we explained how the Maxwell equations relate to our description
    of electric and magnetic fields in previous chapters. We saw how the Maxwell equations,
    like Newton’s second law, can be viewed as rules for a state-update technique.
    We described the FDTD method for solving the Maxwell equations, and we applied
    it to the radiation produced by an oscillating charge and current density. We
    produced an animation of the wavelike electric field generated by an oscillating
    current density.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了麦克斯韦方程如何描述电磁场的演化。我们确定了电和磁之间的四种关系，并解释了麦克斯韦方程如何与我们在前几章中对电场和磁场的描述相关联。我们看到了麦克斯韦方程如何像牛顿第二定律一样，可以被视为一种状态更新技术的规则。我们描述了用于求解麦克斯韦方程的FDTD方法，并将其应用于振荡电荷和电流密度产生的辐射。我们制作了一个由振荡电流密度产生的类波电场的动画。
- en: We’ve covered a lot of ground in this book. Many of the ideas are really cool
    but not so easy to grasp right away. If you’re like most people, you’ve understood
    some things and gotten stuck on others. Patience and perseverance are my advice
    when you’re stuck. Patience is especially important, and it sometimes means skipping
    ahead to the beginning of the next section or chapter. I’ve had books on my shelves
    that were unreadable for years, but somehow I got the background I needed and
    then one day I could read them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本书我们已经涵盖了很多内容。许多想法真的很酷，但并不容易立即理解。如果你和大多数人一样，你可能已经理解了一些内容，但也有一些卡住了。当你遇到困难时，我建议你保持耐心和毅力。耐心尤其重要，它有时意味着跳到下一节或下一章的开始。我书架上曾有过一些书，几年都没法读懂，但不知怎么的，我逐渐获得了所需的背景知识，某一天终于能读懂它们了。
- en: I hope you’ve enjoyed the introduction to computational physics in Haskell that
    this book provides. You can, of course, do computational physics in any programming
    language you like. You would learn a lot by translating the work we’ve done here
    into another language. Let’s take a brief look back at what we’ve done to recall
    the benefits of a functional language for physics. A pure functional language
    allows and encourages us to express what is central and important in a single
    function. The function `newtonSecondPS` from [Chapter 16](ch16.xhtml) expresses
    Newton’s second law. The function `maxwellUpdate` in this chapter expresses the
    Maxwell equations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢本书提供的Haskell计算物理学的介绍。当然，你可以用任何编程语言来做计算物理学。通过将我们在这里所做的工作翻译成其他语言，你会学到很多东西。让我们简要回顾一下我们所做的工作，回想一下函数式语言在物理学中的好处。纯函数式语言让我们能够并鼓励我们将核心和重要的部分表达为一个单一的函数。[第16章](ch16.xhtml)中的`newtonSecondPS`函数表达了牛顿第二定律。本章中的`maxwellUpdate`函数表达了麦克斯韦方程。
- en: Pure functional programming provides a simpler model of computation than imperative
    languages like Python since names (variables) refer to quantities that never change.
    This encourages the naming of verbs (functions) that change nouns, rather than
    giving names to nouns that change. Physics is a natural candidate to take advantage
    of pure functional writing because the central ideas of physics, like Newton’s
    second law and the Maxwell equations, are expressible as verbs.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数式编程提供了比像 Python 这样的命令式语言更简单的计算模型，因为在纯函数式编程中，名称（变量）指向的是永远不变的量。这鼓励我们为改变名词的动词（函数）命名，而不是为改变的名词命名。物理学是一个天然的候选领域，适合利用纯函数式编程，因为物理学的核心概念，如牛顿第二定律和麦克斯韦方程，可以作为动词来表达。
- en: Moreover, a typed functional language allows us to express with precision the
    nature of the verb a function describes. The type of `newtonSecondPS` expresses
    that we can produce a differential equation from a list of one-body forces. The
    type of `bFieldFromLineCurrent` from [Chapter 27](ch27.xhtml) expresses that we
    can calculate a magnetic field from a curve and a current.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类型化的函数语言使我们能够精确地表达一个函数所描述的动词的性质。`newtonSecondPS`的类型表明我们可以从一个单体力的列表中产生一个微分方程。来自[第27章](ch27.xhtml)的`bFieldFromLineCurrent`的类型表明我们可以通过一条曲线和电流计算出磁场。
- en: The effectful functions we’ve written, those like `gradientVectorPNG` with `IO
    ()` in their type that *do* something, are certainly useful for producing graphs
    and animations, but they are not really part of the “elegant code” promised in
    this book’s subtitle. Haskell is as powerful as any other language for doing these
    things, but the real strength of a functional language for physics lies in the
    elegant expression of its central ideas, which are purely functional. Programming
    in a functional language has allowed me to write code that parallels the organization
    of the subject in my mind. I find that it helps me to think about the subject.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写的有副作用的函数，比如带有`IO ()`类型的`gradientVectorPNG`，它们确实对于生成图形和动画非常有用，但它们并不是真正属于本书副标题中所承诺的“优雅代码”范畴。Haskell在做这些事情上和任何其他语言一样强大，但函数式语言在物理学中的真正强项在于其核心思想的优雅表达，而这些思想是纯粹函数式的。在函数式语言中编程让我能够写出与我脑海中学科组织方式相符的代码。我发现这有助于我思考学科内容。
- en: The practice of writing physics in a functional language is in its infancy.
    Two advanced books on the subject are [**[20](bib.xhtml#bib20)**] and [**[11](bib.xhtml#bib11)**].
    There is a lot more to discover about what physics and functional programming
    can offer each other. I hope you continue to explore these areas if they interest
    you.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中编写物理学的实践仍处于起步阶段。关于这个主题的两本进阶书籍是[**[20](bib.xhtml#bib20)**]和[**[11](bib.xhtml#bib11)**]。物理学和函数式编程可以相互提供更多东西，仍有许多值得探索的领域。如果你对这些感兴趣，我希望你继续探索这些领域。
- en: Exercises
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Exercise 29.1.** Use `gnuplot` to graph the Gaussian function'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习29.1.** 使用`gnuplot`绘制高斯函数图像'
- en: '![Image](Images/579equ02.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/579equ02.jpg)'
- en: for several values of *l*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个*l*值。
- en: '**Exercise 29.2.** Modify the main program and the function `makeEpng` to produce
    an animation of the magnetic field in the xy-plane produced by the current density
    `jGaussian`. Try using 10^(–6) T as the threshold for a strong magnetic field.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习29.2.** 修改主程序和`makeEpng`函数，生成由电流密度`jGaussian`产生的xy平面内的磁场动画。尝试使用10^(–6)
    T作为强磁场的阈值。'
- en: '**Exercise 29.3.** The current density'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习29.3.** 电流密度'
- en: '![Image](Images/579equ01.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/579equ01.jpg)'
- en: has an oscillating magnetic dipole moment, while that of Equation 29.29 has
    an oscillating electric dipole moment. The radiation produced by the current density
    of Equation 29.30 is called magnetic dipole radiation. Produce an animation of
    the magnetic field in the xz-plane. It should look similar to the electric field
    animation we made for the electric dipole radiation from the current density of
    Equation 29.29\. Try using 2 × 10^(–7) T as the threshold for a strong magnetic
    field.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一个振荡的磁偶极矩，而方程29.29的磁偶极矩则是一个振荡的电偶极矩。由方程29.30的电流密度产生的辐射被称为磁偶极辐射。制作一个xz平面内磁场的动画。它应该看起来类似于我们为方程29.29的电流密度制作的电偶极辐射的电场动画。尝试使用2
    × 10^(–7) T作为强磁场的阈值。
