- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: CREATING ADVANCED GUIs AND SHARING YOUR APP
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建高级 GUI 和分享你的应用程序
- en: '![Image](../images/circle.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/circle.jpg)'
- en: For the GUI desktop version of the Secret Messages app, we’re going to provide
    two large text areas that allow the user to copy and paste long messages in the
    GUI interface. By the end of the chapter, we’ll add a slider for key selection
    like the one shown in [Figure 7-1](ch7.xhtml#ch7fig1), which will make cracking
    Caesar ciphers very easy, even when the key is unknown!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Secret Messages 应用程序的桌面版 GUI，我们将提供两个大文本区域，允许用户在 GUI 界面中复制并粘贴长消息。在本章结束时，我们将像
    [图 7-1](ch7.xhtml#ch7fig1) 中所示，添加一个用于选择密钥的滑块，这将使破解凯撒密码变得非常简单，即使密钥未知！
- en: '![Images](../images/f0148-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0148-01.jpg)'
- en: '*Figure 7-1: The Secret Messages encoder/decoder app we’ll build in this chapter*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：我们将在本章构建的 Secret Messages 编码/解码应用程序*'
- en: This version of the app is more user-friendly than the console-based app, and
    we’ll be able to reuse some code from [Chapter 6](ch6.xhtml#ch6) because the algorithm
    for encoding and decoding messages is the same.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的应用程序比基于控制台的应用程序更友好，我们将能够重用一些来自 [第 6 章](ch6.xhtml#ch6) 的代码，因为编码和解码消息的算法是相同的。
- en: Setting Up the Secret Messages GUI App Project
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 Secret Messages GUI 应用程序项目
- en: Open Eclipse and create a new Java project by going to **File** ▸ **New** ▸
    **Java Project**. Name the project `SecretMessagesGUI` and then click **Finish**.
    Close any open files and expand the *SecretMessagesGUI* project folder in the
    Package Explorer pane to find the *src* folder. Right-click the *src* folder and
    select **New** ▸ **Class** to create a new Java source code file. Name this `SecretMessagesGUI`
    as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Eclipse，选择 **文件** ▸ **新建** ▸ **Java 项目** 创建一个新的 Java 项目。将项目命名为 `SecretMessagesGUI`，然后点击
    **完成**。关闭所有打开的文件，展开包资源管理器中的 *SecretMessagesGUI* 项目文件夹，找到 *src* 文件夹。右键单击 *src*
    文件夹，选择 **新建** ▸ **类** 创建一个新的 Java 源代码文件。将文件命名为 `SecretMessagesGUI`。
- en: We’re going to use the Swing toolkit again, so in the New Java Class dialog,
    change the superclass to `javax.swing.JFrame` and select the checkbox to create
    a `main()` method.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 Swing 工具包，因此在新建 Java 类对话框中，将父类更改为 `javax.swing.JFrame`，并选中复选框以创建 `main()`
    方法。
- en: Click **Finish**, and you’ll see some familiar skeleton code for the *SecretMessagesGUI.java*
    file. Right-click the *SecretMessagesGUI.java* file in the Package Explorer and
    select **Open With** ▸ **WindowBuilder Editor** to begin creating the GUI interface
    for the Secret Messages app.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**完成**，你将看到一些熟悉的骨架代码，位于 *SecretMessagesGUI.java* 文件中。右键单击 *SecretMessagesGUI.java*
    文件，在包资源管理器中选择 **打开方式** ▸ **WindowBuilder 编辑器**，开始为秘密消息应用程序创建 GUI 界面。
- en: Designing the GUI and Naming Components
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计 GUI 和命名组件
- en: Open the WindowBuilder Editor’s Design tab. Expand the `javax.swing.JFrame`
    component in the Components pane and select **getContentPane()**. Now go to the
    Properties pane and change the `Layout` property to **Absolute layout**, as shown
    in [Figure 7-2](ch7.xhtml#ch7fig2). This will allow us to position components
    with pixel-perfect accuracy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 WindowBuilder 编辑器的设计标签。在组件面板中展开 `javax.swing.JFrame` 组件并选择 **getContentPane()**。然后，转到属性面板，将
    `Layout` 属性更改为 **绝对布局**，如 [图 7-2](ch7.xhtml#ch7fig2) 所示。这将允许我们以像素级精度定位组件。
- en: '![Images](../images/f0149-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0149-01.jpg)'
- en: '*Figure 7-2: Change the Layout property to* ***Absolute layout*** *before placing
    any GUI components.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：在放置任何 GUI 组件之前，将布局属性更改为* ***绝对布局***。'
- en: Next, in the Components pane, click **javax.swing.JFrame**. Then, in the Properties
    pane, set the `defaultCloseOperation` to **EXIT_ON_CLOSE**. Also, change the `title`
    property to `Your Name``'s Secret Message App`, as shown in [Figure 7-3](ch7.xhtml#ch7fig3).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在组件面板中点击 **javax.swing.JFrame**。然后，在属性面板中，将 `defaultCloseOperation` 设置为
    **EXIT_ON_CLOSE**。此外，将 `title` 属性更改为 `Your Name`'s Secret Message App`，如 [图 7-3](ch7.xhtml#ch7fig3)
    所示。
- en: '![Images](../images/f0149-02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0149-02.jpg)'
- en: '*Figure 7-3: Change the defaultCloseOperation and title properties to customize
    the app.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：更改 `defaultCloseOperation` 和 `title` 属性以自定义应用程序。*'
- en: Next, let’s give ourselves some room to build a slightly larger GUI interface
    so we can encode and decode longer messages. With `javax.swing.JFrame` still selected
    in the Components pane, click the outside border of the window in the design preview.
    Click the small black resize box at the lower-right corner of the window, and
    drag down and to the right to resize the frame to 600 by 400 pixels, as shown
    in [Figure 7-4](ch7.xhtml#ch7fig4).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为自己腾出一些空间，构建一个稍微大的GUI界面，这样我们就可以编码和解码更长的消息。仍然在组件面板中选择`javax.swing.JFrame`，点击设计预览中的窗口外边框。点击窗口右下角的小黑色调整框，向下拖动并向右拖动，将框架大小调整为600×400像素，如[图7-4](ch7.xhtml#ch7fig4)所示。
- en: '![Images](../images/f0150-01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0150-01.jpg)'
- en: '*Figure 7-4: Resize the JFrame to hold bigger messages.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：调整JFrame大小以容纳更大的消息。*'
- en: Now we’re ready to begin placing the GUI interface components. For the GUI version
    of the app, we want to be able to encode and decode long messages, so the first
    component we’ll place is a `JTextArea`. Like a `JTextField`, text areas allow
    you to enter text, but a `JTextArea` can hold, display, and even wrap several
    lines of text.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始放置GUI界面组件。对于该应用程序的GUI版本，我们希望能够编码和解码长消息，因此我们将放置的第一个组件是`JTextArea`。与`JTextField`类似，文本区域允许你输入文本，但`JTextArea`可以容纳、显示，甚至换行显示多行文本。
- en: To insert the first `JTextArea` for the user to input a message, under Components
    in the Palette, click **JTextArea**. Then place it near the top of the `JFrame`
    in the design preview. Click and drag to draw a `JTextArea` approximately one-third
    of the height of the content pane, with a small margin between the `JTextArea`
    and the edge of the frame. The `JTextArea` should be approximately 564 pixels
    wide by 140 pixels tall. Then, in the Properties pane, change the `Variable` property
    to `txtIn`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入第一个`JTextArea`供用户输入消息，在组件面板中的Palette下点击**JTextArea**。然后将其放置在`JFrame`顶部附近的设计预览中。点击并拖动，绘制一个`JTextArea`，大约占据内容面板高度的三分之一，`JTextArea`与框架边缘之间留有小边距。`JTextArea`的宽度应约为564像素，高度为140像素。然后，在属性面板中，将`Variable`属性更改为`txtIn`。
- en: To create the second `JTextArea` for the outputted message, right-click **txtIn**
    in the Preview pane, select **Copy**, right-click the content pane, and select
    **Paste**. Place the new `JTextArea` near the bottom edge of the frame. To name
    the new `JTextArea`, change the `Variable` property to `txtOut`. You should end
    up with two `JTextArea` components, as shown in [Figure 7-5](ch7.xhtml#ch7fig5).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建第二个用于输出消息的`JTextArea`，右键点击预览面板中的**txtIn**，选择**复制**，然后右键点击内容面板，选择**粘贴**。将新的`JTextArea`放置在框架的底部边缘附近。为了给新的`JTextArea`命名，将`Variable`属性更改为`txtOut`。最终你应该会得到两个`JTextArea`组件，如[图7-5](ch7.xhtml#ch7fig5)所示。
- en: '![Images](../images/f0151-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0151-01.jpg)'
- en: '*Figure 7-5: Copy and paste txtIn to create a second JTextArea and name it
    txtOut*.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：复制并粘贴txtIn以创建第二个JTextArea并命名为txtOut。*'
- en: Next, let’s add a text field for the encryption key value. Click **JTextField**
    in the Palette pane under Components and then click near the center of the content
    pane to place the `JTextField`. Change the `JTextField`’s `Variable` property
    to `txtKey` and resize it to about half its original size.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为加密密钥值添加一个文本字段。在组件面板的**JTextField**上点击，然后点击内容面板中接近中心的位置以放置`JTextField`。将`JTextField`的`Variable`属性更改为`txtKey`，并将其大小调整为原始大小的一半。
- en: Add a `JLabel` to the left of `txtKey`, entering `Key:` as the label’s `text`
    property. Set the `horizontalAlignment` to **RIGHT**. Finally, add a `JButton`
    to the right of `txtKey`, entering the words `Encode/Decode` as the button’s `text`
    property. Expand the width of the button until it shows all the text. The interface
    should look like [Figure 7-6](ch7.xhtml#ch7fig6). To preview the interface without
    running the app, press the small Test GUI button above the Palette, circled in
    [Figure 7-6](ch7.xhtml#ch7fig6).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`txtKey`左侧添加一个`JLabel`，将标签的`text`属性设置为`Key:`。将`horizontalAlignment`设置为**RIGHT**。最后，在`txtKey`右侧添加一个`JButton`，将按钮的`text`属性设置为`Encode/Decode`。扩展按钮的宽度，直到它显示完整的文本。界面应该像[图7-6](ch7.xhtml#ch7fig6)所示。要在不运行应用程序的情况下预览界面，请点击Palette上方的“测试GUI”按钮，该按钮在[图7-6](ch7.xhtml#ch7fig6)中被圈出。
- en: '![Images](../images/f0151-02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0151-02.jpg)'
- en: '*Figure 7-6: Test the GUI interface by pressing the Test GUI button above the
    Palette.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：通过点击Palette上方的测试GUI按钮来测试GUI界面。*'
- en: Now that you have the user interface set up, it’s time to code the program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置好了用户界面，是时候编写程序代码了。
- en: Coding the Secret Messages GUI App
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写秘密消息GUI应用程序
- en: 'Switch back to the source view by clicking the Source tab on the bottom left
    of the design view window. You’ll see that Eclipse has added all the GUI code
    in the *SecretMessagesGUI.java* file. To connect the GUI to our app, we first
    need to add the declarations for the two `JTextArea` variables at the top of the
    `SecretMessagesGUI` class. Eclipse knows that `JTextField` components usually
    need event handlers for user input, so it places `txtKey` at the top of the class,
    but we need to do the same with the two `JTextArea` components, `txtIn` and `txtOut`.
    Add the two bottom lines shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击设计视图窗口左下角的Source选项卡切换回源代码视图。你会看到，Eclipse已经将所有GUI代码添加到了*SecretMessagesGUI.java*文件中。为了将GUI与我们的应用程序连接起来，我们首先需要在`SecretMessagesGUI`类的顶部添加两个`JTextArea`变量的声明。Eclipse知道`JTextField`组件通常需要用户输入的事件处理程序，因此将`txtKey`放在了类的顶部，但我们需要对两个`JTextArea`组件，`txtIn`和`txtOut`，做相同的处理。添加以下两行代码：
- en: public class SecretMessagesGUI extends JFrame {
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: public class SecretMessagesGUI extends JFrame {
- en: private JTextField txtKey;
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextField txtKey;
- en: private JTextArea txtIn;
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextArea txtIn;
- en: private JTextArea txtOut;
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextArea txtOut;
- en: 'After declaring the `JTextArea` variables at the top of the file, we need to
    modify the code inside the `SecretMessagesGUI()` constructor. Delete the variable
    type `JTextArea` at the beginning of each of these two lines:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部声明`JTextArea`变量后，我们需要修改`SecretMessagesGUI()`构造函数中的代码。删除以下两行开头的`JTextArea`变量类型：
- en: public SecretMessagesGUI() {
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: public SecretMessagesGUI() {
- en: setTitle("Dr. Payne's Secret Message App");
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: setTitle("Dr. Payne的秘密消息应用");
- en: setDefaultCloseOperation(JFrame.*EXIT_ON_CLOSE*);
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: setDefaultCloseOperation(JFrame.*EXIT_ON_CLOSE*);
- en: getContentPane().setLayout(null);
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().setLayout(null);
- en: txtIn = new JTextArea(); // Delete "JTextArea" from start of line
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: txtIn = new JTextArea(); // 删除行首的“JTextArea”
- en: txtIn.setBounds(10, 11, 564, 140);
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: txtIn.setBounds(10, 11, 564, 140);
- en: getContentPane().add(txtIn);
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().add(txtIn);
- en: txtOut = new JTextArea(); // Delete "JTextArea" from start of line
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut = new JTextArea(); // 删除行首的“JTextArea”
- en: txtOut.setBounds(10, 210, 564, 140);
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut.setBounds(10, 210, 564, 140);
- en: getContentPane().add(txtOut);
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().add(txtOut);
- en: With these changes, we’re ready to begin writing the method to encode messages
    whenever the user clicks the Encode/Decode button.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 做了这些修改后，我们就可以开始编写方法来处理每次用户点击“编码/解码”按钮时的消息编码了。
- en: '*Creating the encode() Method*'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*创建 encode() 方法*'
- en: The `encode()` method we’ll write is similar to `checkGuess()` from the Hi-Lo
    guessing game app in [Chapter 3](ch3.xhtml#ch3). The `checkGuess()` method took
    a string that was the user’s guess, but the method didn’t need to return a value,
    so it returned `void`. Unlike `checkGuess()`, `encode()` will take a message and
    an encryption key as values, and instead of returning `void`, it will return an
    encoded message.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的`encode()`方法类似于[第3章](ch3.xhtml#ch3)中Hi-Lo猜数字游戏应用的`checkGuess()`方法。`checkGuess()`方法接收一个字符串作为用户的猜测，但该方法不需要返回任何值，所以它返回了`void`。与`checkGuess()`不同，`encode()`将接收一个消息和一个加密密钥作为参数，并且不会返回`void`，而是返回一个编码后的消息。
- en: Methods return values so that the program can use them. We want `encode()` to
    take a message and key from the user and then run some code on those values to
    produce the encoded message, which our program will use as the output for the
    user. When declaring a method that returns information, we state the return value’s
    data type before the name of the method. The type of information we want returned
    from `encode()` is a `String` variable. So, `encode()` will be declared as `public
    String encode()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 方法返回值是为了让程序可以使用它们。我们希望`encode()`方法接收来自用户的消息和密钥，然后对这些值进行处理以生成编码后的消息，程序将把它作为用户的输出。当声明一个返回值的方法时，我们在方法名之前指定返回值的数据类型。我们希望从`encode()`返回的值是一个`String`类型的变量。所以，`encode()`将声明为`public
    String encode()`。
- en: 'We need to tell Java what kind of information we want to pass to `encode()`;
    this information is known as a method’s *parameters*. To declare parameters for
    a method, we place them inside the parentheses following the method name, with
    the data type first and the name of the parameter second. Multiple parameters
    are separated by commas. The declaration for the `encode()` method looks like
    this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉Java我们想要传递给`encode()`的信息是什么，这些信息被称为方法的*参数*。要声明方法的参数，我们将它们放在方法名后的圆括号内，参数的数据类型放在前面，参数的名称放在后面。多个参数用逗号分隔。`encode()`方法的声明如下：
- en: public String encode( String message, int keyVal )
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: public String encode( String message, int keyVal )
- en: 'Let’s add braces for the body and place the `encode()` method right below the
    declarations for the two `JTextArea` variables, above the `SecretMessagesGUI()`
    constructor method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为方法体添加大括号，并将`encode()`方法放在两个`JTextArea`变量的声明下面，`SecretMessagesGUI()`构造方法上面：
- en: public class SecretMessagesGUI extends JFrame {
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: public class SecretMessagesGUI extends JFrame {
- en: private JTextField txtKey;
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextField txtKey;
- en: private JTextArea txtIn;
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextArea txtIn;
- en: private JTextArea txtOut;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextArea txtOut;
- en: public String encode( String message, int keyVal ) {
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: public String encode( String message, int keyVal ) {
- en: '}'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public SecretMessagesGUI() {
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: public SecretMessagesGUI() {
- en: Eclipse will underline the `encode()` method in red to let you know you haven’t
    returned a value, but that’s because we haven’t written the code inside the method
    body yet. Here we’ll be reusing some of our code from [Chapter 6](ch6.xhtml#ch6).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse将用红色下划线标出`encode()`方法，提示你还没有返回一个值，但那是因为我们还没有在方法体内编写代码。这里我们将重用[第6章](ch6.xhtml#ch6)中的一些代码。
- en: 'Declare a `String` called `output`, set it equal to an empty string for now,
    and add a line to return `output` as the result of the `encode()` method using
    a `return` statement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个名为`output`的`String`，先将其设为空字符串，并添加一行代码使用`return`语句返回`output`作为`encode()`方法的结果：
- en: public String encode( String message, int keyVal ) {
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: public String encode( String message, int keyVal ) {
- en: String output = "";
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: return output;
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: return output;
- en: '}'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Since `encode()` was declared to return a `String` value and we’re returning
    `output`, which *is* a `String`, Eclipse will remove the red underline to let
    us know we’ve fixed the problem of the missing return value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`encode()`方法声明为返回一个`String`值，而我们正在返回`output`，它*确实*是一个`String`，Eclipse将去掉红色下划线，表明我们已经解决了缺少返回值的问题。
- en: Next, we’ll reuse a selection of code from the text-based version of the app
    for encoding messages. Open the *SecretMessages* project from [Chapter 6](ch6.xhtml#ch6)
    in the Project Explorer pane.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重用该应用程序基于文本的版本中的一部分代码来编码消息。请在项目资源管理器窗格中打开[第6章](ch6.xhtml#ch6)的*SecretMessages*项目。
- en: We can copy the code starting at `char key` and ending at the closing brace
    of the `for` loop, right before `System.out.println(output);` near the end of
    the program. This is the part of the app that encodes a message using the Caesar
    cipher algorithm.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以复制从`char key`开始，到`for`循环的闭括号结束的代码，紧接着在程序末尾的`System.out.println(output);`之前。这部分代码是用凯撒密码算法对消息进行编码的应用部分。
- en: 'Paste the copied code from *SecretMessages.java* into *SecretMessagesGUI.java*,
    inside `encode()`, between the two lines we just added. The finished `encode()`
    method looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将从*SecretMessages.java*复制的代码粘贴到*SecretMessagesGUI.java*中的`encode()`方法内，放在我们刚刚添加的两行之间。完成的`encode()`方法如下所示：
- en: public String encode( String message, int keyVal ) {
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: public String encode( String message, int keyVal ) {
- en: String output = "";
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: char key = (char) keyVal;
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: char key = (char) keyVal;
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = 0; x < message.length(); x++ ) {
- en: char input = message.charAt(x);
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: char input = message.charAt(x);
- en: if (input >= 'A' && input <= 'Z')
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: if (input >= 'A' && input <= 'Z')
- en: '{'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'Z')
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'Z')
- en: input -= 26;
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: if (input < 'A')
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < 'A')
- en: input += 26;
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: input += 26;
- en: '}'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (input >= 'a' && input <= 'z')
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= 'a' && input <= 'z')
- en: '{'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'z')
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'z')
- en: input -= 26;
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: if (input < 'a')
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < 'a')
- en: input += 26;
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: input += 26;
- en: '}'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (input >= '0' && input <= '9')
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= '0' && input <= '9')
- en: '{'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += (keyVal % 10);
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: input += (keyVal % 10);
- en: if (input > '9')
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > '9')
- en: input -= 10;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 10;
- en: if (input < '0')
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < '0')
- en: input += 10;
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: input += 10;
- en: '}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: output += input;
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: output += input;
- en: '}'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return output;
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: return output;
- en: '}'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Because we named our variables consistently, we can reuse the Caesar cipher
    encryption code. Consistent naming is a good habit, and well-written code in Java
    can be reused across multiple platforms.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们一致地命名了变量，所以可以重用凯撒密码加密代码。一致的命名是一个好习惯，并且编写得当的Java代码可以跨多个平台重用。
- en: '*Writing the Event Handler for the Encode/Decode Button*'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为编码/解码按钮编写事件处理程序*'
- en: We want the user to provide both the input message and the key value that we’ll
    pass along to `encode()` in the GUI interface, and we want the output message
    to be returned when the user presses the Encode/Decode button, so let’s write
    the code to handle the button click event.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户提供输入消息和密钥值，我们将把它传递给GUI界面中的`encode()`方法，并希望在用户按下编码/解码按钮时返回输出消息，因此我们需要编写处理按钮点击事件的代码。
- en: 'Switch to the design view in *SecretMessagesGUI.java* and double-click the
    **Encode/Decode** button. Eclipse will switch back to the source view and insert
    the code for the `actionPerformed()` event handler for the Encode/Decode button,
    like the code snippet shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到*SecretMessagesGUI.java*中的设计视图，并双击**编码/解码**按钮。Eclipse将切换回源代码视图，并插入`actionPerformed()`事件处理程序的代码，如下所示：
- en: JButton btnEncodedecode = new JButton("Encode/Decode");
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: JButton btnEncodedecode = new JButton("编码/解码");
- en: btnEncodedecode.addActionListener(new ActionListener() {
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: btnEncodedecode.addActionListener(new ActionListener() {
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: public void actionPerformed(ActionEvent arg0) {
- en: '}'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: This is an anonymous inner class, like the one we first encountered in [Chapter
    3](ch3.xhtml#ch3). All we have to add is the code inside `actionPerformed()` to
    tell Java how the button should behave when it’s clicked.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个匿名内部类，就像我们在[第3章](ch3.xhtml#ch3)中首次遇到的那样。我们只需要添加`actionPerformed()`内部的代码，告诉Java按钮在点击时应该执行什么操作。
- en: 'We want the Encode/Decode button to perform the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`Encode/Decode`按钮执行以下步骤：
- en: 1\. Get the input message from `txtIn`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 从`txtIn`获取输入消息。
- en: 2\. Get the key from `txtKey`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 从`txtKey`获取密钥。
- en: 3\. Encode the message using the key.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 使用密钥对消息进行编码。
- en: 4\. Show the output message in `txtOut`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 在`txtOut`中显示输出消息。
- en: Think about how we might accomplish each of those steps. Try it yourself before
    reading further and then read below to see how my solution compares.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 想想我们如何完成这些步骤。在继续阅读之前，自己尝试一下，然后阅读下面的内容，看看我的解决方案是如何比较的。
- en: 'For the first step, we can set up a `String` called `message` that gets the
    text from the `txtIn` field. Just like a `JTextField`, a `JTextArea` has a `getText()`
    method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一步，我们可以设置一个名为`message`的`String`，它从`txtIn`字段中获取文本。就像`JTextField`一样，`JTextArea`也有一个`getText()`方法：
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: public void actionPerformed(ActionEvent arg0) {
- en: String message = txtIn.getText();
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: String message = txtIn.getText();
- en: 'For the second step, we can get the user’s key from `txtKey` using the `Integer.parseInt()`
    method, which pulls an integer value out of a text string. Then we’ll store the
    integer we get in a variable we’ll call `key`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二步，我们可以通过`Integer.parseInt()`方法从`txtKey`中获取用户的密钥，该方法从文本字符串中提取一个整数值。然后我们将得到的整数存储在一个变量中，我们将其命名为`key`：
- en: String message = txtIn.getText();
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: String message = txtIn.getText();
- en: int key = Integer.parseInt( txtKey.getText() );
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: int key = Integer.parseInt( txtKey.getText() );
- en: To encode the message in the third step, we just need to call the `encode()`
    method and pass it two arguments. *Arguments* are the values we give a method
    to serve as its parameters. Remember we defined `encode()` to require two parameters,
    so we’ll need to pass `encode()` two arguments, which will be the variables `message`
    and `key`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中编码消息，我们只需调用`encode()`方法并传递两个参数。*参数*是我们传递给方法的值，作为方法的输入。记住，我们定义`encode()`需要两个参数，因此我们需要将`message`和`key`作为两个参数传递给`encode()`。
- en: 'We can call `encode()` with the statement `encode(message, key)`. When it has
    finished executing, it will return the encoded message, which is `output`. Note
    that a method returns the value itself, not the variable the value is stored in.
    That means that the encoded message is stored in `output`, but when `encode()`
    returns `output`, we’re actually getting only the encoded string. In addition
    to that, all the code and variables created inside `encode()` aren’t carried over
    to the rest of the program, so the `output` variable doesn’t exist anymore once
    `encode()` returns. We’ll need to store the value returned by the method in a
    new variable if we want to save it. In order to keep our naming consistent, let’s
    call the new variable `output` too:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`encode(message, key)`语句调用`encode()`。当它执行完毕后，它将返回编码后的消息，即`output`。请注意，方法返回的是值本身，而不是存储值的变量。这意味着编码后的消息存储在`output`中，但当`encode()`返回`output`时，我们实际上只得到了编码后的字符串。除此之外，所有在`encode()`内部创建的代码和变量不会传递到程序的其他部分，因此一旦`encode()`返回，`output`变量就不存在了。如果我们希望保存它，我们需要将方法返回的值存储在一个新的变量中。为了保持命名一致性，我们也将新变量命名为`output`：
- en: String message = txtIn.getText();
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: String message = txtIn.getText();
- en: int key = Integer.parseInt( txtKey.getText() );
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: int key = Integer.parseInt( txtKey.getText() );
- en: String output = encode( message, key );
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: String output = encode( message, key );
- en: 'Finally, we’ll use the `setText()` method to show the `output` message in `txtOut`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`setText()`方法在`txtOut`中显示`output`消息：
- en: String message = txtIn.getText();
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: String message = txtIn.getText();
- en: int key = Integer.parseInt( txtKey.getText() );
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: int key = Integer.parseInt( txtKey.getText() );
- en: String output = encode( message, key );
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: String output = encode( message, key );
- en: txtOut.setText( output );
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut.setText( output );
- en: The `actionPerformed()` method is almost complete, except for some error handling.
    We’ve used the `Integer.parseInt()` method, which can throw exceptions if the
    user enters bad input, so we’ll need to add `try-catch` statements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`actionPerformed()` 方法几乎完成，唯一缺少的是一些错误处理。我们已经使用了 `Integer.parseInt()` 方法，这个方法在用户输入错误时可能会抛出异常，因此我们需要添加
    `try-catch` 语句。'
- en: '*Handling Bad Input and User Errors*'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*处理错误输入和用户错误*'
- en: The code to process button clicks includes a call to `Integer.parseInt()`, and
    we learned back in [Chapter 3](ch3.xhtml#ch3) that this method can throw exceptions
    when the user enters erroneous input. In particular, if the user were to leave
    the `txtKey` field blank or type anything other than an integer into that `JTextField`,
    the `Integer.parseInt()` method would fail.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 处理按钮点击的代码中包含了对 `Integer.parseInt()` 的调用，我们在[第 3 章](ch3.xhtml#ch3)学到过，当用户输入错误时，这个方法可能会抛出异常。特别是，如果用户将
    `txtKey` 输入框留空，或者在该 `JTextField` 中输入非整数内容，`Integer.parseInt()` 方法将会失败。
- en: 'We need to protect the program from bad input by using `try-catch` blocks to
    handle exceptions. Since we want to encode or decode a message only when the user
    has correctly entered an encryption key, we can wrap all four lines of `actionPerformed()`
    inside a `try` block by adding the keyword `try` and an opening brace before the
    first line, as well as a closing brace after the fourth line, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过使用 `try-catch` 块来保护程序，处理异常。由于我们只希望在用户正确输入加密密钥后才对消息进行编码或解码，因此我们可以通过在第一行之前添加
    `try` 关键字和一个开括号，并在第四行之后添加闭括号，将 `actionPerformed()` 中的四行代码包装在 `try` 块内，如下所示：
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: public void actionPerformed(ActionEvent arg0) {
- en: try {
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: String message = txtIn.getText();
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: String message = txtIn.getText();
- en: int key = Integer.*parseInt*( txtKey.getText() );
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: int key = Integer.*parseInt*( txtKey.getText() );
- en: String output = encode( message, key );
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: String output = encode( message, key );
- en: txtOut.setText( output );
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut.setText( output );
- en: '} catch (Exception ex) {'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (Exception ex) {'
- en: '}'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Eclipse will highlight the closing brace in red, so let’s go ahead and add the
    `catch` block as shown. We’ll need to tell Java what to do when bad input is received,
    and we’ll add those steps inside the braces for the `catch` statement a little
    later. But first, let’s finish the `main()` method so that we can test the app.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 将用红色高亮显示闭括号，因此我们接着添加 `catch` 块，如下所示。当接收到错误输入时，我们需要告诉 Java 如何处理，并且稍后我们将把这些步骤添加到
    `catch` 语句的括号内。但首先，让我们完成 `main()` 方法，以便可以测试应用程序。
- en: '*Building the main() Method and Running the App*'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*构建 main() 方法并运行应用程序*'
- en: Just like when we created our game app in [Chapter 3](ch3.xhtml#ch3), we need
    to add some setup code to the `main()` method to create an instance of the Secret
    Messages app, correctly size the GUI window, and make the GUI visible to the user.
    Near the bottom of the *SecretMessagesGUI.java* file, find the `main()` method
    stub Eclipse provided and add the following three lines.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第 3 章](ch3.xhtml#ch3)创建游戏应用程序时一样，我们需要在 `main()` 方法中添加一些设置代码，来创建一个 Secret
    Messages 应用程序的实例，正确设置 GUI 窗口的大小，并使 GUI 对用户可见。在 *SecretMessagesGUI.java* 文件的底部，找到
    Eclipse 提供的 `main()` 方法的代码框架，并添加以下三行。
- en: public static void main(String[] args) {
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: ➊ SecretMessagesGUI theApp = new SecretMessagesGUI();
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ SecretMessagesGUI theApp = new SecretMessagesGUI();
- en: ➋ theApp.setSize(new java.awt.Dimension(600,400));
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ theApp.setSize(new java.awt.Dimension(600,400));
- en: ➌ theApp.setVisible(true);
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ theApp.setVisible(true);
- en: '}'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The line at ➊ creates a `SecretMessagesGUI` object called `theApp`. The `new`
    keyword followed by the class name runs the constructor method `SecretMessagesGUI()`,
    which sets up all the components of the GUI interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了一个名为 `theApp` 的 `SecretMessagesGUI` 对象。`new` 关键字后跟类名，调用构造方法 `SecretMessagesGUI()`，它会设置所有
    GUI 界面组件。
- en: Next, we set the size of the `JFrame` to match the width and height that we
    used in designing the layout, 600 by 400 pixels ➋. Finally, we set the `JFrame`’s
    `visible` property to `true` ➌, allowing the user to see the GUI. Save these changes
    and then run the app to test it, as shown in [Figure 7-7](ch7.xhtml#ch7fig7).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `JFrame` 的大小设置为与我们在设计布局时使用的宽度和高度相匹配，即 600x400 像素 ➋。最后，我们将 `JFrame` 的
    `visible` 属性设置为 `true` ➌，使用户能够看到 GUI。保存这些更改，然后运行应用程序进行测试，如[图 7-7](ch7.xhtml#ch7fig7)所示。
- en: '![Images](../images/f0157-01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0157-01.jpg)'
- en: '*Figure 7-7: The Secret Messages app is still a bit plain, but it can encode
    and decode messages!*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Secret Messages 应用程序仍然有些简单，但它可以进行消息的编码和解码！*'
- en: 'The following is the full source code for *SecretMessagesGUI.java* to this
    point:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 *SecretMessagesGUI.java* 文件到目前为止的完整源代码：
- en: import javax.swing.JFrame;
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JFrame;
- en: import javax.swing.JTextArea;
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JTextArea;
- en: import javax.swing.JTextField;
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JTextField;
- en: import javax.swing.JLabel;
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JLabel;
- en: import javax.swing.JButton;
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JButton;
- en: import java.awt.event.ActionListener;
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.event.ActionListener;
- en: import java.awt.Dimension;
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Dimension;
- en: import java.awt.event.ActionEvent;
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.event.ActionEvent;
- en: public class SecretMessagesGUI extends JFrame {
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: public class SecretMessagesGUI extends JFrame {
- en: private JTextField txtKey;
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextField txtKey;
- en: private JTextArea txtIn;
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextArea txtIn;
- en: private JTextArea txtOut;
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextArea txtOut;
- en: public String encode( String message, int keyVal ) {
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: public String encode( String message, int keyVal ) {
- en: String output = "";
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: char key = (char) keyVal;
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: char key = (char) keyVal;
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = 0; x < message.length(); x++ ) {
- en: char input = message.charAt(x);
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: char input = message.charAt(x);
- en: if (input >= 'A' && input <= 'Z')
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: if (input >= 'A' && input <= 'Z')
- en: '{'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'Z')
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'Z')
- en: input -= 26;
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: if (input < 'A')
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < 'A')
- en: input += 26;
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: input += 26;
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (input >= 'a' && input <= 'z')
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= 'a' && input <= 'z')
- en: '{'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'z')
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'z')
- en: input -= 26;
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: if (input < 'a')
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < 'a')
- en: input += 26;
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: input += 26;
- en: '}'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (input >= '0' && input <= '9')
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= '0' && input <= '9')
- en: '{'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += (keyVal % 10);
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: input += (keyVal % 10);
- en: if (input > '9')
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > '9')
- en: input -= 10;
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 10;
- en: if (input < '0')
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < '0')
- en: input += 10;
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: input += 10;
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: output += input;
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: output += input;
- en: '}'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return output;
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: return output;
- en: '}'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public SecretMessagesGUI() {
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: public SecretMessagesGUI() {
- en: setTitle("Dr. Payne's Secret Message App");
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: setTitle("Payne博士的秘密信息应用");
- en: setDefaultCloseOperation(JFrame.*EXIT_ON_CLOSE*);
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: setDefaultCloseOperation(JFrame.*EXIT_ON_CLOSE*);
- en: getContentPane().setLayout(null);
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().setLayout(null);
- en: txtIn = new JTextArea();
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: txtIn = new JTextArea();
- en: txtIn.setBounds(10, 11, 564, 140);
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: txtIn.setBounds(10, 11, 564, 140);
- en: getContentPane().add(txtIn);
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().add(txtIn);
- en: txtOut = new JTextArea();
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut = new JTextArea();
- en: txtOut.setBounds(10, 210, 564, 140);
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut.setBounds(10, 210, 564, 140);
- en: getContentPane().add(txtOut);
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().add(txtOut);
- en: txtKey = new JTextField();
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: txtKey = new JTextField();
- en: txtKey.setBounds(258, 173, 44, 20);
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: txtKey.setBounds(258, 173, 44, 20);
- en: getContentPane().add(txtKey);
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().add(txtKey);
- en: JLabel lblKey = new JLabel("Key:");
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: JLabel lblKey = new JLabel("密钥：");
- en: lblKey.setBounds(202, 176, 46, 14);
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: lblKey.setBounds(202, 176, 46, 14);
- en: getContentPane().add(lblKey);
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().add(lblKey);
- en: JButton btnEncodedecode = new JButton("Encode/Decode");
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: JButton btnEncodedecode = new JButton("编码/解码");
- en: btnEncodedecode.addActionListener(new ActionListener() {
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: btnEncodedecode.addActionListener(new ActionListener() {
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: public void actionPerformed(ActionEvent arg0) {
- en: try {
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: String message = txtIn.getText();
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: String message = txtIn.getText();
- en: int key = Integer.*parseInt*( txtKey.getText() );
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: int key = Integer.*parseInt*( txtKey.getText() );
- en: String output = encode( message, key );
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: String output = encode( message, key );
- en: txtOut.setText( output );
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut.setText( output );
- en: '} catch (Exception ex) {'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (Exception ex) {'
- en: '}'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: btnEncodedecode.setBounds(312, 172, 144, 23);
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: btnEncodedecode.setBounds(312, 172, 144, 23);
- en: getContentPane().add(btnEncodedecode);
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().add(btnEncodedecode);
- en: '}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static void main(String[] args) {
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: SecretMessagesGUI theApp = new SecretMessagesGUI();
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: SecretMessagesGUI theApp = new SecretMessagesGUI();
- en: theApp.setSize(new java.awt.Dimension(600,400));
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: theApp.setSize(new java.awt.Dimension(600,400));
- en: theApp.setVisible(true);
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: theApp.setVisible(true);
- en: '}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This first version of the app is a success, but it leaves a bit to be desired
    visually. We can make the GUI interface look more professional with just a few
    tweaks.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的第一个版本是成功的，但在视觉效果上还有些欠缺。我们可以通过一些小调整，使得GUI界面看起来更加专业。
- en: Improving the GUI
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改善GUI
- en: Let’s switch back to the design view to correct the issues we noted in the last
    section. First, click the **Encode/Decode** button and make it a bit wider. Different
    computers can have other default fonts and sizes, so give the button a little
    extra room to be safe.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换回设计视图，修正我们在上一部分中提到的问题。首先，点击**编码/解码**按钮，并稍微加宽它。不同的计算机可能有不同的默认字体和大小，所以为了保险起见，给按钮留一点额外空间。
- en: Now, let’s make the font sizes in the two `JTextArea` fields larger and easier
    to read. We want to change the font properties of both text areas, so we can select
    both `txtIn` and `txtOut` at the same time by clicking `txtIn` and then using
    CTRL-click (or ![Images](../images/symbol.jpg)-click) to also select `txtOut`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把两个`JTextArea`字段的字体大小调大一些，便于阅读。我们想改变这两个文本区域的字体属性，所以可以通过点击`txtIn`然后按住CTRL键点击（或![图片](../images/symbol.jpg)-点击）来同时选择`txtIn`和`txtOut`。
- en: With both text areas selected, go to the `font` property in the Properties pane
    and click the three dots next to the font size. The Font Chooser dialog will appear,
    as shown in [Figure 7-8](ch7.xhtml#ch7fig8).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 选中两个文本区域后，转到属性面板中的`font`属性，点击字体大小旁边的三个点。字体选择器对话框将会出现，如[图 7-8](ch7.xhtml#ch7fig8)所示。
- en: '![Images](../images/f0159-01.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0159-01.jpg)'
- en: '*Figure 7-8: We can change the font properties for both JTextArea fields at
    the same time.*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：我们可以同时更改两个JTextArea字段的字体属性。*'
- en: Choose a font size of 18 or greater and select a font that you like. Stick with
    a familiar font so that when you share the app with friends on different computers,
    the look and feel won’t change too dramatically. I’ve selected Lucida Console,
    18 point. Click **OK** to save the font selection.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 选择字体大小为18或更大，并选择你喜欢的字体。最好选择一种常见字体，这样当你在不同计算机上与朋友分享应用程序时，外观和感觉不会变化得太剧烈。我选择了Lucida
    Console，18磅。点击**确定**保存字体选择。
- en: Finally, let’s change the background color of the content pane to personalize
    it. Select the content pane by clicking **getContentPane()** in the Components
    pane in the upper left. Then, click the three dots beside the `background` property
    in the Properties pane. In the Color Chooser dialog that pops up, select the **Named
    colors** tab, as shown in [Figure 7-9](ch7.xhtml#ch7fig9). You’ll see a broad
    selection of colors. Choose a color that you like and click **OK**.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更改内容面板的背景颜色来进行个性化设置。在左上角的组件面板中点击**getContentPane()**以选择内容面板。然后，在属性面板中点击`background`属性旁边的三个点。在弹出的颜色选择器对话框中，选择**命名颜色**选项卡，如[图
    7-9](ch7.xhtml#ch7fig9)所示。你将看到一系列的颜色。选择你喜欢的颜色并点击**确定**。
- en: '![Images](../images/f0160-01.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0160-01.jpg)'
- en: '*Figure 7-9: Change the background color of the content pane and button to
    make the app more stylish.*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：更改内容面板和按钮的背景颜色，使应用程序更加时尚。*'
- en: You can also change the background color of the Encode/Decode button. You may
    not see all your changes in the design preview, but if you run the app, you should
    see your new selections, as shown in [Figure 7-10](ch7.xhtml#ch7fig10), along
    with any new background color you chose.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以更改编码/解码按钮的背景颜色。你可能在设计预览中看不到所有更改，但如果你运行应用程序，应该能看到你新的选择，如[图 7-10](ch7.xhtml#ch7fig10)所示，并且显示你选择的任何新背景颜色。
- en: '![Images](../images/f0161-01.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0161-01.jpg)'
- en: '*Figure 7-10: The GUI after you change the button size and font size.*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：更改按钮大小和字体大小后的图形用户界面（GUI）。*'
- en: There are a lot of other properties you can customize based on your preference.
    Explore the Properties pane for each component and adjust things until the app
    looks how you want it. Remember to stop and save your app so your changes don’t
    get erased!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以根据自己的偏好自定义许多其他属性。浏览每个组件的属性面板并进行调整，直到应用程序看起来符合你的要求。记得停止并保存你的应用程序，以免更改丢失！
- en: '*Setting Line Wrap and Word Wrap*'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*设置自动换行和单词换行*'
- en: So far, the messages I’ve used in my examples have been shorter than one line.
    But what happens if we type several lines of text?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我在示例中使用的消息都比一行短。但是，如果我们输入几行文本，会发生什么呢？
- en: 'Let’s try typing or pasting a long sentence into the input text area. I’ll
    use the first sentence of the Gettysburg Address, by US president Abraham Lincoln:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着输入或粘贴一条长句子到输入文本区域。我将使用美国总统亚伯拉罕·林肯的《葛底斯堡演讲》中的第一句话：
- en: Four score and seven years ago our fathers brought forth on this continent,
    a new nation, conceived in Liberty, and dedicated to the proposition that all
    men are created equal.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 八十七年前，我们的先祖在这片大陆上建立了一个新的国家，这个国家立足于自由，致力于所有人生而平等的理念。
- en: You can use this sentence or make up your own long sentence. Either way, as
    soon as you type it in, you’ll notice a problem, as shown in [Figure 7-11](ch7.xhtml#ch7fig11).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这句话或自己编造一个长句。不管怎样，当你输入它时，你会发现一个问题，如[图 7-11](ch7.xhtml#ch7fig11)所示。
- en: '![Images](../images/f0161-02.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0161-02.jpg)'
- en: '*Figure 7-11: Longer messages in the app don’t yet automatically wrap at the
    end of a line.*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-11：应用程序中的长消息目前还不能自动换行。*'
- en: To correctly wrap longer lines of text by full words, you’ll need to change
    *two* properties for each text area in the Properties pane. Select both `JTextArea`
    objects again in the design preview and then, under Properties, select the checkboxes
    next to `lineWrap` and `wrapStyleWord`. The first property, `lineWrap`, tells
    Java to wrap text longer than one line down to the next line. Setting the wrap
    style to `wrapStyleWord` tells Java to break the line at the end of a whole word,
    as we do in a word processor or as you see in this book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地将较长的文本行按完整单词换行，您需要更改每个文本区域的*两个*属性。在设计预览中再次选择两个`JTextArea`对象，然后在属性面板中，勾选`lineWrap`和`wrapStyleWord`旁边的复选框。第一个属性`lineWrap`告诉Java将长于一行的文本换到下一行。将换行样式设置为`wrapStyleWord`告诉Java在完整单词的末尾换行，就像我们在文字处理软件中做的那样，或者像本书中所示的那样。
- en: Now save and run the app again. Paste your long sentence into the first text
    box, and you should notice an improvement. Now the text is correctly wrapped across
    multiple lines, with line breaks after the last full word that fits on each line.
    Enter a key and press the **Encode/Decode** button, and you’ll see the same text
    wrapping in the output text area, as shown in [Figure 7-12](ch7.xhtml#ch7fig12).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存并再次运行应用程序。将你的长句子粘贴到第一个文本框中，你应该会注意到一个改进。现在文本被正确地换行，且每行的最后一个完整单词后面有换行符。输入一个密钥并按下**编码/解码**按钮，你会看到输出文本区域中的文本同样换行，如[图
    7-12](ch7.xhtml#ch7fig12)所示。
- en: '![Images](../images/f0162-01.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0162-01.jpg)'
- en: '*Figure 7-12: Changing both the lineWrap and wrapStyleWord properties to true
    results in a nice multiline interface, complete with word wrapping.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：将`lineWrap`和`wrapStyleWord`属性都设置为true，结果是一个漂亮的多行界面，配有单词换行。*'
- en: This version of the program is becoming more professional looking, but what
    happens if we enter bad input in the text field for the encryption key? Well,
    nothing yet. We added a `try` statement earlier, but we didn’t complete the `catch`
    statement. Let’s do that now. We’ll also learn how to create pop-up message dialogs
    to alert the user to errors.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的程序看起来更加专业，但如果我们在加密密钥的文本框中输入错误的内容会发生什么呢？嗯，目前还没有任何反应。我们之前添加了一个`try`语句，但并没有完成`catch`语句。现在我们来完成它。同时，我们还将学习如何创建弹出消息对话框来提醒用户错误。
- en: '*Handling Bad Input and User Errors: Part 2*'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*处理错误输入和用户错误：第二部分*'
- en: Earlier in the chapter, we added a `try` block around the button event handler,
    but we left the body of the `catch` statement empty. It’s time to fill that in
    with code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前，我们在按钮事件处理程序周围添加了一个`try`块，但我们将`catch`语句的主体留空了。现在是时候用代码填充它了。
- en: Our `catch` statement will handle bad or missing user input in the `txtKey`
    text field. If the user forgets to enter a value for the encryption key or if
    the value they entered is not a number, one way of handling that is to pop up
    a message describing the problem, like the one shown in [Figure 7-13](ch7.xhtml#ch7fig13).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`catch`语句将处理`txtKey`文本框中的错误或缺失的用户输入。如果用户忘记输入加密密钥的值，或者他们输入的值不是数字，一种处理方式是弹出一条消息来描述问题，就像[图
    7-13](ch7.xhtml#ch7fig13)中显示的那样。
- en: '![Images](../images/f0163-01.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0163-01.jpg)'
- en: '*Figure 7-13: A dialog pops up to alert the user to an error.*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：弹出对话框警告用户发生错误。*'
- en: After the user closes the pop-up window, another helpful touch is to move the
    cursor to the `txtKey` text field and highlight or select any text there so the
    user can type a new value easily, without needing to click and select the value
    manually.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 用户关闭弹出窗口后，另一个有用的细节是将光标移动到`txtKey`文本框中，并突出显示或选择那里任何文本，以便用户能够轻松输入新值，而无需手动点击和选择值。
- en: The `javax.swing` toolkit that we’ve been using for GUI components such as `JFrame`
    and `JTextField` also has classes that handle various kinds of pop-up windows.
    Some examples are *input dialogs*, which allow the user to provide text input;
    *confirm dialogs*, which allow the user to select Yes/No/OK or Cancel; and *message
    dialogs*, which provide information to the user in a pop-up window.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用的`javax.swing`工具包为GUI组件，如`JFrame`和`JTextField`，也提供了处理各种类型弹出窗口的类。一些例子包括*输入对话框*，允许用户提供文本输入；*确认对话框*，允许用户选择“是/否/确定”或“取消”；以及*消息对话框*，在弹出窗口中向用户提供信息。
- en: 'The error message we’d like to provide to the user is best displayed in a message
    dialog. The `javax.swing.JOptionPane` class has a method called `showMessageDialog()`
    that takes two parameters, which are the parent window and the message to display.
    If we were writing a larger application, we would use the parent window parameter
    to center the dialog over the main word processing window, for example. But for
    this app, we can use the keyword `null` to center the dialog over the desktop
    instead, as shown here:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望提供给用户的错误信息最好通过消息对话框显示。`javax.swing.JOptionPane`类有一个名为`showMessageDialog()`的方法，该方法接受两个参数，一个是父窗口，另一个是要显示的消息。如果我们正在编写一个更大的应用程序，我们可以使用父窗口参数将对话框居中显示在主文本处理窗口上。例如。但是对于这个应用程序，我们可以使用关键字`null`将对话框居中显示在桌面上，如下所示：
- en: JOptionPane.showMessageDialog(null,
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: JOptionPane.showMessageDialog(null,
- en: '"Please enter a whole number value for the encryption key.");'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '"请输入一个整数值作为加密密钥。");'
- en: When this line of code is called, it will pop up a message dialog reading “Please
    enter a whole number value for the encryption key.”
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当这行代码被调用时，它会弹出一个消息对话框，显示“请输入一个整数值作为加密密钥。”
- en: To add this pop-up error message to the `catch` statement we created earlier,
    go to the design view and double-click the **Encode/Decode** button. This is a
    quick way to have Eclipse take you directly to the source code for the button-click
    event handler that contains the `catch` statement.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个弹出错误消息添加到我们之前创建的`catch`语句中，请进入设计视图，双击**Encode/Decode**按钮。这是一种快速方式，可以让Eclipse直接带你进入包含`catch`语句的按钮点击事件处理源代码。
- en: 'After the error message is displayed, we’ll also want to place the cursor in
    the `txtKey` field and select any text currently in the `txtKey` field, as we
    did for the Hi-Lo guessing game GUI app. We’ll add the message dialog and the
    same `requestFocus()` and `selectAll()` statements we used in the Hi-Lo guessing
    game app inside the braces for the `catch` statement. The finished event handler
    code for the Encode/Decode button looks like the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误信息显示后，我们还希望将光标放置在`txtKey`字段中并选中当前在`txtKey`字段中的所有文本，正如我们在Hi-Lo猜数字游戏GUI应用中所做的那样。我们将在`catch`语句的花括号内添加消息对话框以及相同的`requestFocus()`和`selectAll()`语句，这些语句在Hi-Lo猜数字游戏应用中也用过。Encode/Decode按钮的完成事件处理代码如下所示：
- en: btnEncodedecode.addActionListener(new ActionListener() {
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: btnEncodedecode.addActionListener(new ActionListener() {
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: public void actionPerformed(ActionEvent arg0) {
- en: try {
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: String message = txtIn.getText();
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: String message = txtIn.getText();
- en: int key = Integer.parseInt( txtKey.getText() );
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: int key = Integer.parseInt( txtKey.getText() );
- en: String output = encode( message, key );
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: String output = encode( message, key );
- en: txtOut.setText( output );
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut.setText( output );
- en: '} catch (Exception ex) {'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (Exception ex) {'
- en: JOptionPane.*showMessageDialog*(null,
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: JOptionPane.*showMessageDialog*(null,
- en: '"Please enter a whole number value for the encryption key.");'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '"请输入一个整数值作为加密密钥。");'
- en: txtKey.requestFocus();
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: txtKey.requestFocus();
- en: txtKey.selectAll();
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: txtKey.selectAll();
- en: '}'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '**NOTE**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you add JOptionPane, if you don’t use the content assist or if you see
    an error at JOptionPane, you may need to press ctrl-shift-O to import the javax.swing
    .JOptionPane class correctly at the top of your code.*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你添加JOptionPane时，如果没有使用内容提示或看到JOptionPane的错误，你可能需要按ctrl-shift-O来正确导入javax.swing.JOptionPane类。*'
- en: Run the app now, either leaving the key field blank or entering nonnumeric text
    as the key. The message dialog will pop up, asking you to enter a valid key. It
    will also highlight the text in the key field so that it’s easy to type a whole
    number when the dialog closes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，留空密钥字段或在密钥中输入非数字文本。消息对话框将弹出，要求你输入一个有效的密钥。它还会高亮显示密钥字段中的文本，以便在对话框关闭后，用户可以轻松输入一个整数。
- en: A first-time user might not know what to type into the key field, so adding
    a default value might also be a helpful UI tweak. Click the Design tab, select
    the `txtKey` text field, and enter a default key value into the `text` property
    in the Properties pane. I’ll choose `3` as my default encryption key, but you
    can choose any number. Let’s also change the `horizontalAlignment` property of
    the `txtKey` field to **CENTER**. Feel free to change other properties to make
    `txtKey` look exactly like you want, including the font color and style.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首次使用者可能不知道应该在密钥字段中输入什么内容，因此添加一个默认值也许是一个有用的UI调整。点击设计标签，选择`txtKey`文本字段，并在属性窗格中的`text`属性中输入一个默认的密钥值。我会选择`3`作为我的默认加密密钥，但你可以选择任何数字。我们还将`txtKey`字段的`horizontalAlignment`属性改为**CENTER**。你可以根据需要改变其他属性，使`txtKey`看起来正如你所希望的那样，包括字体颜色和样式。
- en: '*Adding a Slider to the Secret Messages GUI*'
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*将滑块添加到秘密消息GUI中*'
- en: We’ll add one more user interface improvement to the Secret Messages app—a numeric
    slider that will allow the user to quickly slide through key values and see how
    the message changes with each new key.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为秘密消息应用程序添加一个用户界面改进——一个数字滑块，允许用户快速滑动键值，并查看每个新键值下消息的变化。
- en: In design view, under Components in the Palette, select the **JSlider** component.
    Hover over the middle left of the design preview, beside the key prompt, and click
    to drop the `JSlider` into place as shown in [Figure 7-14](ch7.xhtml#ch7fig14)—you
    can adjust the position later if needed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计视图中，在“组件”面板下选择**JSlider**组件。将鼠标悬停在设计预览的中左侧，靠近键提示的地方，点击并将`JSlider`拖放到合适位置，如[图
    7-14](ch7.xhtml#ch7fig14)所示——如果需要，稍后可以调整位置。
- en: '![Images](../images/f0165-01.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0165-01.jpg)'
- en: '*Figure 7-14: Add a JSlider to the graphical user interface for a quick, easy
    way to try different key values.*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-14：将 JSlider 添加到图形用户界面，快速简便地尝试不同的键值。*'
- en: Now let’s customize some properties of the `JSlider`. First, let’s change its
    background color to match the rest of the app. With the new `JSlider` selected
    in the design preview, click the three dots next to the `background` property
    in the Properties pane, go to **Named colors** in the Color Chooser dialog, and
    pick the same color you used for the rest of the GUI. Click **OK** to save the
    new background color for the slider.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们自定义一些`JSlider`的属性。首先，将它的背景颜色更改为与应用程序其余部分相匹配。在设计预览中选中新的`JSlider`，点击属性面板中`background`属性旁边的三个点，进入颜色选择器对话框中的**命名颜色**，然后选择与其余GUI相同的颜色。点击**确定**以保存滑块的新背景颜色。
- en: Next, we’ll add custom labels, tick marks, and a default value for the slider.
    First, turn on the `paintLabels` property by selecting the **true** checkbox beside
    it. Second, enter a `maximum` value of `26` and a `minimum` value of `–26` to
    make it easy to choose a key value in the correct range.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为滑块添加自定义标签、刻度标记和默认值。首先，通过选择**true**复选框来启用`paintLabels`属性。其次，设置`maximum`值为`26`，`minimum`值为`–26`，这样可以方便地选择正确范围内的键值。
- en: Next, for the `minorTickSpacing` property, enter a value of `1`—this will add
    small tick marks on the slider track to help the user see the range of possible
    values. Then, for the `majorTickSpacing` property, enter `13`—this will show a
    label every 13 values between `-26` and `26` on the slider. Now, turn on the `paintTicks`
    property by selecting the **true** checkbox next to it. The complete Properties
    pane with all the changes we’ve made is shown in [Figure 7-15](ch7.xhtml#ch7fig15).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为`minorTickSpacing`属性输入值`1`——这将在滑块轨道上添加小的刻度标记，帮助用户看到可能值的范围。然后，为`majorTickSpacing`属性输入`13`——这将在滑块上显示每13个值（从`-26`到`26`）的标签。现在，通过选择**true**复选框来启用`paintTicks`属性。我们所做的所有更改的完整属性面板显示在[图
    7-15](ch7.xhtml#ch7fig15)中。
- en: '![Images](../images/f0165-02.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0165-02.jpg)'
- en: '*Figure 7-15: Customizing the properties of the slider*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-15：自定义滑块的属性*'
- en: We’re almost done! Change the default value of the slider to match your default
    key value in the key text field by modifying the `value` property. I selected
    `3` as my default key value, so I’ll enter `3` in the `value` property for the
    slider. Finally, you’ll need to make the slider a bit taller to show the labels,
    as shown in the finished slider in [Figure 7-16](ch7.xhtml#ch7fig16).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成了！通过修改`value`属性，将滑块的默认值更改为与键文本字段中的默认键值相匹配。我选择了`3`作为我的默认键值，因此我将在滑块的`value`属性中输入`3`。最后，你需要将滑块的高度稍微增加一些，以显示标签，如[图
    7-16](ch7.xhtml#ch7fig16)中显示的完成滑块。
- en: '![Images](../images/f0166-01.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0166-01.jpg)'
- en: '*Figure 7-16: The Secret Messages app with the GUI slider in place*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-16：秘密消息应用程序中的GUI滑块已就位*'
- en: Now, we need to add the code to make the slider work, allowing the user to slide
    easily among various key values to encode and decode messages quickly.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加代码使滑块生效，允许用户在不同的键值之间轻松滑动，以便快速编码和解码消息。
- en: Code Cracking with the Slider
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用滑块破解代码
- en: We want the user to be able to change the encryption key value by clicking and
    dragging the slider we added in the previous section, so next we’re going to add
    an event handler to listen for changes to the slider.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户能够通过点击并拖动我们在上一部分中添加的滑块来更改加密键值，因此接下来我们将添加一个事件处理程序，以监听滑块的变化。
- en: Right-click or CONTROL-click the slider in the design preview and go to **Add
    event handler** ▸ **change** ▸ **stateChanged**, as shown in [Figure 7-17](ch7.xhtml#ch7fig17).
    The `stateChanged` event handler will work similarly to the `actionPerformed`
    event handler for the Encode/Decode button, but it will run anytime the user changes
    the slider’s position to update the encryption key value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击或按住CTRL键点击设计预览中的滑块，然后选择**添加事件处理程序** ▸ **change** ▸ **stateChanged**，如[图
    7-17](ch7.xhtml#ch7fig17)所示。`stateChanged`事件处理程序的工作方式类似于编码/解码按钮的`actionPerformed`事件处理程序，但它会在用户每次更改滑块位置时运行，以更新加密密钥值。
- en: '![Images](../images/f0166-02.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0166-02.jpg)'
- en: '*Figure 7-17: Adding an event handler to the slider that will detect when the
    user changes the slider’s value*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-17：为滑块添加事件处理程序，以便检测用户何时更改滑块的值*'
- en: 'When you click to add the `stateChanged` event handler to the slider, Eclipse
    will automatically generate another anonymous inner class, much like the one it
    created for the Encode/Decode button. But before we check out the anonymous inner
    class, we’ll need to add the `JSlider` to the top of the class with the `JTextArea`
    declarations. To do that, we have to declare the `JSlider` as an instance variable.
    Add the last line shown here to the declarations at the top of the `SecretMessagesGUI`
    class:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击为滑块添加`stateChanged`事件处理程序时，Eclipse将自动生成另一个匿名内部类，类似于它为编码/解码按钮创建的类。但在查看这个匿名内部类之前，我们需要在类的顶部添加`JSlider`和`JTextArea`声明。为此，我们必须将`JSlider`声明为实例变量。将这里显示的最后一行添加到`SecretMessagesGUI`类顶部的声明中：
- en: public class SecretMessagesGUI extends JFrame {
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: public class SecretMessagesGUI extends JFrame {
- en: private JTextField txtKey;
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextField txtKey;
- en: private JTextArea txtIn;
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextArea txtIn;
- en: private JTextArea txtOut;
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextArea txtOut;
- en: private JSlider slider;
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: private JSlider slider;
- en: 'Then, scroll back down to the slider code. Remember, you can switch back to
    design view and right-click to add the event handler again to go directly to the
    code anytime you get lost. Now, change the first line, removing the `JSlider`
    type declaration, as shown here:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向下滚动回到滑块代码。记住，你可以切换回设计视图，并右键点击再次添加事件处理程序，直接进入代码，每当你迷路时。现在，修改第一行，去掉`JSlider`类型声明，如下所示：
- en: slider = new JSlider();
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: slider = new JSlider();
- en: slider.addChangeListener(new ChangeListener() {
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: slider.addChangeListener(new ChangeListener() {
- en: public void stateChanged(ChangeEvent arg0) {
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: public void stateChanged(ChangeEvent arg0) {
- en: 'The first action we’d like the slider to do is update the `txtKey` text field
    to show the slider’s current position. We can get the slider’s current position
    with the `getValue()` method, and we can set the text of the `txtKey` field with
    its `setText()` method. Adding those together, we can write the first line of
    the `stateChanged()` method:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望滑块执行的第一个操作是更新`txtKey`文本框，显示滑块的当前位置。我们可以通过`getValue()`方法获取滑块的当前位置，并通过`setText()`方法设置`txtKey`文本框的内容。将它们结合起来，我们可以编写`stateChanged()`方法的第一行：
- en: public void stateChanged(ChangeEvent arg0) {
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: public void stateChanged(ChangeEvent arg0) {
- en: txtKey.setText( "" + slider.getValue() );
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: txtKey.setText( "" + slider.getValue() );
- en: The `slider.getValue()` method returns an integer—the current position value
    of the slider—so we added an empty string to the number to turn it into a string
    or text value. This will change the `txtKey` text field to show the slider’s value.
    But it doesn’t automatically re-encode the message using the new value yet. If
    you run the app now, you still need to click the Encode/Decode button to change
    the message.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`slider.getValue()`方法返回一个整数——滑块的当前位置值——因此我们将一个空字符串添加到数字后，将其转换为字符串或文本值。这将使`txtKey`文本框显示滑块的值。但它还不会自动使用新值重新编码消息。如果你现在运行应用程序，你仍然需要点击编码/解码按钮来更改消息。'
- en: 'Let’s modify the code in the `stateChanged()` method so that the slider updates
    the message like the Encode/Decode button would. We can copy the code from inside
    the `try` statement for the Encode/Decode button and paste it after the first
    line of the `stateChanged()` method for the slider, making only one change:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`stateChanged()`方法中的代码，使得滑块像编码/解码按钮一样更新消息。我们可以复制编码/解码按钮内部`try`语句中的代码，并将其粘贴到滑块的`stateChanged()`方法的第一行之后，只做一个更改：
- en: slider = new JSlider();
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: slider = new JSlider();
- en: slider.addChangeListener(new ChangeListener() {
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: slider.addChangeListener(new ChangeListener() {
- en: public void stateChanged(ChangeEvent arg0) {
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: public void stateChanged(ChangeEvent arg0) {
- en: txtKey.setText( "" + slider.getValue() );
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: txtKey.setText( "" + slider.getValue() );
- en: ➊  String message = txtIn.getText();
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ➊  String message = txtIn.getText();
- en: ➋  int key = slider.getValue();
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ➋  int key = slider.getValue();
- en: ➌  String output = encode( message, key );
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ➌  String output = encode( message, key );
- en: ➍  txtOut.setText( output );
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ➍  txtOut.setText( output );
- en: '}'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: The lines at ➊, ➌, and ➍ are copied directly from the Encode/Decode button’s
    event handler, but we’ve made a small change at ➋. Instead of parsing the value
    out of the text field, we can access the slider’s value directly as an integer
    using the `getValue()` method. This means we don’t need a `try-catch` statement,
    because we’re no longer relying on the user to supply a hand-typed value. This
    is more convenient for the user and more secure for the programmer, as using the
    GUI slider removes one potential error while also making the interface easier
    to use.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ➊、➌和➍的代码行直接来自于编码/解码按钮的事件处理程序，但我们在➋处做了一个小改动。我们不再从文本字段中解析出值，而是可以直接使用`getValue()`方法获取滑块的值作为整数。这意味着我们不再需要`try-catch`语句，因为我们不再依赖用户输入手动输入的值。这样对于用户来说更方便，对于程序员来说也更安全，因为使用图形用户界面滑块消除了一个潜在的错误，同时也使界面更易于使用。
- en: Save the changes and run the application, and you’ll see that you can type in
    a message and then change the position of the slider to try different encryption
    key values. To test the ability to decode, copy an encoded message from the bottom
    text area using CTRL-C (or ![Image](../images/symbol.jpg)-C) and paste it into
    the top text area using CTRL-V (or ![Image](../images/symbol.jpg)-V). Then slide
    the slider to the left or right until you see the original message again.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改并运行应用程序，你会看到你可以输入消息，然后改变滑块的位置，尝试不同的加密密钥值。为了测试解码功能，使用CTRL-C（或![Image](../images/symbol.jpg)-C）从底部文本区域复制编码消息，然后使用CTRL-V（或![Image](../images/symbol.jpg)-V）将其粘贴到顶部文本区域。然后将滑块向左或向右移动，直到再次看到原始消息。
- en: 'You’ll even be able to “crack” the Caesar cipher encryption for messages that
    you don’t have the key to by sliding the slider slowly until you can read the
    decoded message in the bottom text area. Give it a try! Type the following message
    into the top text area of your app:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过慢慢移动滑块来“破解”没有密钥的凯撒密码加密消息，直到你能在底部文本区域读取解码后的消息。试试看！在应用程序的顶部文本区域输入以下消息：
- en: Epdetyr esp lmtwtej ez mcplv esp Nlpdlc ntaspc htes xj Dpncpe Xpddlrp laa...
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Epdetyr esp lmtwtej ez mcplv esp Nlpdlc ntaspc htes xj Dpncpe Xpddlrp laa...
- en: Then, slide the slider to the far left and slowly slide it to the right until
    it reveals the secret message. Can you tell what secret key was used to encode
    the message? See [Figure 7-18](ch7.xhtml#ch7fig18) for a hint.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将滑块移至最左侧，慢慢向右滑动，直到揭示出秘密消息。你能猜出用来编码消息的秘密密钥是什么吗？参考[图 7-18](ch7.xhtml#ch7fig18)获取提示。
- en: '![Images](../images/f0168-01.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0168-01.jpg)'
- en: '*Figure 7-18: You can use the Secret Messages app to break Caesar cipher messages
    by sliding the slider left and right until a plaintext message appears!*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-18：你可以通过在秘密消息应用中滑动滑块左移和右移来破解凯撒密码消息，直到出现纯文本消息！*'
- en: Moving the slider to `-11` results in a plaintext English message, so the secret
    key must have been `11`. You may also notice that `15` will break the message
    (because 15 = 26 – 11). You can always find a couple of values that work to break
    messages in the basic Latin alphabet. Of course, you can send messages in other
    languages as well, as shown in [Figure 7-19](ch7.xhtml#ch7fig19).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 将滑块移至`-11`会得到一条纯文本英文信息，因此密钥必须是`11`。你可能还会注意到，`15`会破坏信息（因为15 = 26 - 11）。你总是可以找到几个有效的值来破译基本拉丁字母表中的信息。当然，你也可以使用其他语言发送消息，如[图
    7-19](ch7.xhtml#ch7fig19)所示。
- en: '![Images](../images/f0169-01.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0169-01.jpg)'
- en: '*Figure 7-19: Any languages that use characters in the basic Latin alphabet
    can be used with this version of the Secret Messages app to send and receive encoded
    messages; Spanish (left) and French (right) are shown here.*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-19：任何使用基本拉丁字母的语言都可以在这个版本的秘密消息应用程序中用来发送和接收编码消息；这里展示的是西班牙语（左）和法语（右）。*'
- en: You can copy and paste encoded messages back and forth with your friends using
    email, Twitter, and Facebook—you can even send encoded text messages, although
    that would be easier to do from your mobile device. We’ll see how to turn this
    Secret Messages desktop app into a mobile app in [Chapter 8](ch8.xhtml#ch8).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过电子邮件、Twitter和Facebook与朋友来回复制并粘贴编码消息——你甚至可以发送编码的短信，尽管从手机设备上做会更方便。我们将在[第8章](ch8.xhtml#ch8)中看到如何将这个秘密消息桌面应用程序转变为移动应用程序。
- en: For now, in order to share secret messages back and forth, it would be nice
    to be able to share your Secret Messages app with your friends easily. We’ll learn
    to do that in the following section.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，为了能够轻松地与朋友们交换加密信息，你应该能够轻松地与他们分享你的 Secret Messages 应用程序。我们将在接下来的部分学习如何实现这一点。
- en: 'Bonus: Sharing Your App as a Runnable JAR File'
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 奖励：将你的应用程序共享为可运行的 JAR 文件
- en: For it to be really useful, you need to be able to share the Secret Messages
    app with your friends—possibly even with friends who don’t know how to code in
    Java and don’t have Eclipse installed on their computer.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使它真正有用，你需要能够将 Secret Messages 应用程序与朋友们共享——甚至可能是与那些不知道如何用 Java 编程且电脑上没有安装 Eclipse
    的朋友们共享。
- en: The great news is that Eclipse and Java make it easy to export an application
    as a runnable file and share it with any of the millions of computers worldwide
    that run Java. Your friends don’t even have to download the Java JDK developer’s
    edition; all they need is the JRE, which comes installed on most computers. Eclipse
    can export an application in a runnable Java archive (JAR) file that you can share
    by email, USB flash drive, or some other means. All your friends have to do is
    double-click the JAR file, and they’ll be able to run your app!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Eclipse 和 Java 使得将应用程序导出为可运行文件变得非常简单，并可以与全球数百万台运行 Java 的计算机共享。你的朋友甚至不需要下载
    Java JDK 开发者版；他们只需要安装了 JRE 的计算机，大多数计算机上都预装了 JRE。Eclipse 可以将应用程序导出为可运行的 Java 存档（JAR）文件，你可以通过电子邮件、USB
    闪存驱动器或其他方式与朋友共享。你的朋友只需双击 JAR 文件，就能运行你的应用程序！
- en: To export a runnable JAR file from Eclipse, go to **File** ▸ **Export**. Then
    expand the *Java* folder and click **Runnable JAR file**, as shown in [Figure
    7-20](ch7.xhtml#ch7fig20).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Eclipse 导出可运行的 JAR 文件，前往 **File** ▸ **Export**。然后展开 *Java* 文件夹并点击 **Runnable
    JAR file**，如 [图 7-20](ch7.xhtml#ch7fig20) 所示。
- en: '![Images](../images/f0170-01.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0170-01.jpg)'
- en: '*Figure 7-20: Share your application with others by exporting a runnable JAR
    file.*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-20：通过导出可运行的 JAR 文件与他人共享你的应用程序。*'
- en: Click **Next**, and Eclipse will ask you for a launch configuration and an export
    destination. The launch configuration means which class or app you’d like to run
    and from which project. Under **Launch configuration**, click the drop-down list
    and choose **SecretMessagesGUI – SecretMessagesGUI**. This means you want to run
    the *SecretMessagesGUI.class* file in the *SecretMessagesGUI* project.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Next**，Eclipse 会要求你选择启动配置和导出目标位置。启动配置意味着你想运行哪个类或应用程序，以及它来自哪个项目。在 **Launch
    configuration** 下，点击下拉列表并选择 **SecretMessagesGUI – SecretMessagesGUI**。这意味着你想在
    *SecretMessagesGUI* 项目中运行 *SecretMessagesGUI.class* 文件。
- en: '**NOTE**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You have to compile and run your application at least once to have a launch
    configuration for that app.*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*你必须至少编译并运行一次你的应用程序，以便为该应用程序生成启动配置。*'
- en: The export destination is just the location and filename you want to use for
    your executable app. Under **Export destination**, click **Browse** and then select
    the destination folder you’d like to save your finished app in, such as your *Desktop*
    folder, for example. Give your program file a name, like *Secret Messages.jar*.
    You can use spaces (or other special characters) to name your file exactly how
    you’d like people to see it when they open it. When you’ve made your selections,
    as shown in [Figure 7-21](ch7.xhtml#ch7fig21), click **Save** and then **Finish**.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 导出目标是你想用于你的可执行应用程序的存储位置和文件名。在 **Export destination** 下，点击 **Browse**，然后选择你想保存已完成应用程序的目标文件夹，例如
    *Desktop* 文件夹。给你的程序文件命名，比如 *Secret Messages.jar*。你可以使用空格（或其他特殊字符）来为文件命名，让人们在打开时看到你希望他们看到的名字。当你完成选择后，如
    [图 7-21](ch7.xhtml#ch7fig21) 所示，点击 **Save**，然后点击 **Finish**。
- en: '![Images](../images/f0171-01.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0171-01.jpg)'
- en: '*Figure 7-21: Choose a location and name for your runnable JAR file.*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-21：为你的可运行 JAR 文件选择位置和名称。*'
- en: You may see a warning after clicking Finish, but you can ignore it and click
    **OK**. Go to wherever you saved your JAR file, and you should see a Java icon
    with your filename, as shown in [Figure 7-22](ch7.xhtml#ch7fig22). Now you should
    be able to run the program and send and receive coded messages.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Finish 后，你可能会看到一个警告，但可以忽略它并点击 **OK**。前往你保存 JAR 文件的位置，你应该能看到一个带有你文件名的 Java
    图标，如 [图 7-22](ch7.xhtml#ch7fig22) 所示。现在你应该能够运行程序并发送和接收加密信息。
- en: '![Images](../images/f0171-02.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0171-02.jpg)'
- en: '*Figure 7-22: The desktop icon for the executable JAR file, on Windows (left)
    and on macOS (right)*'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-22：Windows（左）和 macOS（右）上的可执行 JAR 文件桌面图标。*'
- en: '**NOTE**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*On newer versions of macOS, you’ll need to hold down CONTROL when you click
    the app the first time, then select **Open**, and finally click **Open** on the
    dialog that pops up to allow the app to run.*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*在较新的 macOS 版本中，第一次点击应用程序时，你需要按住 CONTROL 键，然后选择 **打开**，最后在弹出的对话框中点击 **打开**，以允许该应用程序运行。*'
- en: Some email programs may block files ending in *.jar* as a safety precaution,
    but you can upload the file to your favorite file-sharing program (Dropbox, Google
    Drive, or SkyDrive, for example) and share the file from there. Once your friend
    has the file, all they have to do is run it, and you can share scrambled messages
    with each other.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 一些电子邮件程序可能会将以 *.jar* 结尾的文件作为安全措施进行阻止，但你可以将文件上传到你喜欢的文件共享程序（例如 Dropbox、Google
    Drive 或 SkyDrive）并从那里分享文件。一旦你的朋友获得文件，他们只需运行它，你们就可以互相分享加密消息。
- en: '**NOTE**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can also export a runnable JAR file for the GUI guessing game app from
    Chapter 3\. Just follow these same steps for the* GuessingGame.java *file in the*
    GuessingGame *project.*'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*你还可以导出一个可运行的 JAR 文件，用于第 3 章中的 GUI 猜数字游戏应用程序。只需对* GuessingGame.java *文件执行相同的步骤，就可以在*
    GuessingGame *项目中导出。*'
- en: What You Learned
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'You reused code from the text-based Secret Messages app in this app, and you
    substantially expanded your understanding of GUI interface design and programming.
    Here are some of the skills covered in this chapter:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这个应用程序中重用了来自文本版 Secret Messages 应用的代码，并大大扩展了你对 GUI 界面设计和编程的理解。以下是本章中涉及的一些技能：
- en: • Naming GUI components and variables consistently for code readability and
    reusability
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: • 一致地命名 GUI 组件和变量，以提高代码的可读性和可重用性
- en: • Reusing algorithms, such as the `encode()` method that we copied from the
    text-based version of this app
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: • 重用算法，例如我们从该应用的文本版本中复制的 `encode()` 方法
- en: • Declaring methods that accept parameters and return information
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: • 声明接受参数并返回信息的方法
- en: • Writing more advanced event handlers for a wider variety of GUI components,
    including buttons, sliders, and text fields
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: • 为更多种类的 GUI 组件编写更高级的事件处理器，包括按钮、滑块和文本字段
- en: • Working with properties of GUI components in design view to customize the
    UI further
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: • 在设计视图中处理 GUI 组件的属性，进一步自定义用户界面
- en: • Setting line wrap and word wrap for `JTextArea` objects
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: • 为 `JTextArea` 对象设置行换行和单词换行
- en: • Popping up `javax.swing.JOptionPane` dialogs, including message dialogs
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: • 弹出 `javax.swing.JOptionPane` 对话框，包括消息对话框
- en: • Adding and working with a `JSlider` GUI slider
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: • 添加并使用 `JSlider` GUI 滑块
- en: • Changing a text field’s text using a `stateChanged()` event handler on a slider
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 `stateChanged()` 事件处理器在滑块上更改文本字段的文本
- en: • Exporting a runnable JAR file to share your app with friends
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: • 导出一个可运行的 JAR 文件与朋友分享你的应用程序
- en: Programming Challenges
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Try these programming challenges to review and practice what you’ve learned
    and to expand your programming skills by trying something new. Visit the book’s
    website at *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    to download sample solutions.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些编程挑战，复习和练习你所学的内容，并通过尝试新事物来扩展你的编程技能。访问本书网站 *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    下载示例解决方案。
- en: '*#1: Movin’ On Up!*'
  id: totrans-394
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#1：向上走！*'
- en: The Secret Messages app is great for sending simple, encoded messages to your
    friends, but it’s also fun to use all by yourself. One task that gets repetitive
    from time to time is copying encoded messages from the output text area and pasting
    them into the input text area. Your first programming challenge is to create a
    Move Up ^ button, which moves the encoded message up and automatically decodes
    it!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Secret Messages 应用程序非常适合向朋友发送简单的编码消息，但单独使用也很有趣。有时会有一个重复的任务，就是从输出文本区域复制编码消息，然后将其粘贴到输入文本区域。你的第一个编程挑战是创建一个“向上移动
    ^”按钮，它能够将编码消息向上移动并自动解码！
- en: Place the Move Up ^ button next to the Encode/Decode button. Then, add an event
    handler that will get the text from the `txtOut` text area and set it as the text
    of the `txtIn` text area. As a bonus, have the event handler for the Move Up ^
    button change the slider to the opposite of its value. You can also change the
    background of the button to match the rest of your app. A sample solution to this
    challenge is shown in [Figure 7-23](ch7.xhtml#ch7fig23).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 将“向上移动 ^”按钮放置在编码/解码按钮旁边。然后，添加一个事件处理器，它将从 `txtOut` 文本区域获取文本，并将其设置为 `txtIn` 文本区域的文本。作为额外的奖励，让“向上移动
    ^”按钮的事件处理器将滑块的值反转。你还可以将按钮的背景更改为与你的应用程序其余部分相匹配。此挑战的示例解决方案见 [图 7-23](ch7.xhtml#ch7fig23)。
- en: '![Images](../images/f0173-01.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0173-01.jpg)'
- en: '*Figure 7-23: Adding a Move Up ^ button to swap the message and slider value
    to automatically decode your message*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-23：添加一个“向上移动”^按钮来交换消息和滑块值，以自动解码你的消息*'
- en: '*#2: Scrolling Away!*'
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#2: 滚动起来！*'
- en: Another improvement we could make to the app would be to handle even longer
    messages. In this case, we should add a scroll bar along the side and scroll down
    automatically whenever the user enters a message too long for the input text area.
    The `JTextArea` won’t add a scroll bar by itself, but Eclipse makes adding a scroll
    bar to any text area quick and easy!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对应用程序做的另一个改进是处理更长的消息。在这种情况下，我们应该在一侧添加滚动条，并在用户输入的消息超出输入文本区域时自动滚动。`JTextArea`不会自动添加滚动条，但Eclipse让向任何文本区域添加滚动条变得又快又简单！
- en: In the design view, right-click either of the `JTextArea` boxes and select **Surround
    with** ▸ **javax.swing.JScrollPane**, as shown in [Figure 7-24](ch7.xhtml#ch7fig24).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计视图中，右键点击任意一个`JTextArea`框，然后选择**环绕为** ▸ **javax.swing.JScrollPane**，如[图7-24](ch7.xhtml#ch7fig24)所示。
- en: '![Images](../images/f0173-02.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0173-02.jpg)'
- en: '*Figure 7-24: Adding an automatic scroll bar to a JTextArea*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-24：向JTextArea添加自动滚动条*'
- en: You’ll need to do this for the other `JTextArea` as well. Run the app when you’re
    finished, typing a long selection of text into the input text box to see the scroll
    bar appear automatically. In [Figure 7-25](ch7.xhtml#ch7fig25), I’ve pasted the
    entire US Constitution into the input text area and encoded it.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要对另一个`JTextArea`进行相同操作。完成后运行应用程序，在输入文本框中键入一段长文本，查看滚动条是否会自动出现。在[图7-25](ch7.xhtml#ch7fig25)中，我已将整个美国宪法粘贴到输入文本区域并进行了编码。
- en: '![Images](../images/f0174-01.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0174-01.jpg)'
- en: '*Figure 7-25: By adding a JScrollPane around each JTextArea, you can encode
    text as long as the US Constitution or even longer!*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-25：通过在每个JTextArea周围添加JScrollPane，你可以编码像美国宪法这样长的文本，甚至更长！*'
- en: Only part of the text is visible in [Figure 7-25](ch7.xhtml#ch7fig25), but now
    there is a scroll bar along the right side of both text areas. The scroll bar
    lets us know that there’s more text than will fit into the text area, and all
    we have to do is scroll down to see it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-25](ch7.xhtml#ch7fig25)中只显示了部分文本，但现在在两个文本区域的右侧都有一个滚动条。滚动条让我们知道文本内容超出了文本区域的显示范围，我们只需向下滚动即可查看全部内容。
- en: To customize the app even more, explore the Properties pane for each of the
    GUI components we’ve added and change various property values such as background
    colors, fonts, and so on. Make the app your own and share it with friends to show
    off what you’ve created!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步定制应用程序，探索我们已添加的每个GUI组件的属性面板，并更改各种属性值，如背景颜色、字体等。让应用程序成为你自己的，并与朋友分享，展示你所创建的作品！
- en: '*#3: Changing the Text to Change the Slider*'
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#3: 更改文本以更改滑块*'
- en: For this challenge, let’s make one last tweak to the user interface. When the
    user slides the slider, the key value shown in the text field changes. But what
    if we want the slider to move whenever the value in the text field changes?
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个挑战，让我们对用户界面做最后的调整。当用户滑动滑块时，文本框中显示的键值会变化。但是如果我们希望每当文本框中的值发生变化时，滑块也随之移动，该怎么办呢？
- en: '**HINT**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*You’ll want to add an event handler to the txtKey text field. Right-click
    the txtKey JTextField and then go to **Add event handler*** ▸ ***key*** ▸ ***keyReleased***.
    *This will create an event handler that listens for keystrokes in the txtKey text
    field.*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*你需要为txtKey文本框添加一个事件处理器。右键点击txtKey JTextField，然后选择**添加事件处理器** ▸ ***key*** ▸
    ***keyReleased***。*这将创建一个事件处理器，用于监听txtKey文本框中的键盘输入。*'
- en: To accomplish this, you’ll need to write code for the event handler that will
    get the integer value from the text field and set the slider to that value. Remember
    to use a `try-catch` block when dealing with user-supplied text. Good luck!
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你需要为事件处理器编写代码，从文本框中获取整数值并将滑块设置为该值。记得在处理用户输入的文本时使用`try-catch`块。祝你好运！
