- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">RSA</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">RSA</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'The Rivest–Shamir–Adleman (RSA) cryptosystem revolutionized cryptography when
    it emerged in 1977 as the first public-key encryption scheme. Whereas classical,
    symmetric-key encryption schemes use the same secret key to encrypt and decrypt
    messages, *public-key encryption* (or *asymmetric* encryption) uses two keys:
    a public key, which anyone who wants to encrypt messages for you can use, and
    a private key, which is required to decrypt messages encrypted using the public
    key. This magic is the reason why RSA was a real breakthrough, and 40 years later,
    it’s still the paragon of public-key encryption and a workhorse of internet security.
    (One year prior to RSA, Whitfield Diffie and Martin Hellman introduced the concept
    of public-key cryptography, but their scheme was able to perform key distribution
    only in a public-key setting.)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1977年，Rivest–Shamir–Adleman (RSA) 加密系统的出现彻底革新了密码学，它是第一个公钥加密方案。与经典的对称密钥加密方案使用相同的密钥来加密和解密消息不同，*公钥加密*（或*非对称*加密）使用两把密钥：公钥，任何想要为你加密消息的人都可以使用；私钥，用于解密通过公钥加密的消息。这种魔法是RSA成为真正突破的原因，40年后，它依然是公钥加密的典范，并且是互联网安全的核心工具。（在RSA出现的前一年，Whitfield
    Diffie和Martin Hellman提出了公钥密码学的概念，但他们的方案只能在公钥设置中执行密钥分发。）
- en: RSA works by creating a *trapdoor permutation*, a function that transforms a
    number *x* to a number *y* in the same range, such that computing *y* from *x*
    is easy using the public key, but computing *x* from *y* is practically impossible
    unless you know the private key—the trapdoor. (Think of *x* as a plaintext and
    *y* as a ciphertext.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: RSA通过创建一个*陷门置换*来工作，这个函数将数字*x*转换为范围内的数字*y*，使得使用公钥计算从*x*到*y*变得容易，但除非知道私钥——也就是陷门，否则从*y*到*x*的计算几乎是不可能的。（可以将*x*看作是明文，将*y*看作是密文。）
- en: In addition to encryption, you can also use RSA to build digital signatures,
    wherein only the owner of the private key is able to sign a message, and the public
    key enables anyone to verify the signature’s validity.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加密，RSA还可以用来构建数字签名，其中只有私钥的拥有者才能签署消息，而公钥则允许任何人验证签名的有效性。
- en: In this chapter, you’ll learn how the RSA trapdoor permutation works and why
    this permutation alone isn’t enough to build *secure* encryption and signatures.
    I also discuss RSA’s security relative to the factoring problem (see [Chapter
    9](chapter9.xhtml)), ways to implement RSA securely, and how to attack it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讲解RSA陷门置换是如何工作的，以及为什么仅靠这种置换不足以构建*安全*的加密和签名。我还将讨论RSA相对于因式分解问题的安全性（见[第9章](chapter9.xhtml)）、如何安全实现RSA以及如何攻击RSA。
- en: We begin with an explanation of the basic mathematical notions behind RSA.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从解释RSA背后的基本数学概念开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Math Behind RSA</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">RSA背后的数学原理</samp>
- en: When processing a message, whether encrypting or signing it, RSA first creates
    a big number from that message and processes it by performing multiplications
    between big numbers. Therefore, to understand how RSA works, you need to know
    what kind of big numbers it manipulates and how multiplication works on those
    numbers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理消息时，无论是加密还是签名，RSA首先会从该消息中创建一个大数字，并通过大数字之间的乘法运算对其进行处理。因此，要理解RSA是如何工作的，你需要了解它操作的那些大数字是什么，以及这些数字上的乘法是如何进行的。
- en: To encrypt or sign, RSA transforms a positive integer between 1 and *n* – 1,
    where *n* is a large number called the *modulus*. Such numbers, when multiplied
    together, yield another number that satisfies these criteria. These numbers form
    a group, which you denote **Z**n^* and call the multiplicative group of integers
    modulo *n*. (See the mathematical definition of a group in “[Groups](chapter9.xhtml#sec12)”
    on page 189.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密或签名，RSA将一个介于1和*n* - 1之间的正整数进行变换，其中*n*是一个称为*模数*的大数字。当这些数字相乘时，会得到另一个符合这些标准的数字。这些数字组成一个群，你可以将其表示为**Z**n^*，并称之为模*n*的乘法群。（参见[第9章](chapter9.xhtml#sec12)第189页中“群”的数学定义。）
- en: For example, consider the group **Z**[4]^* of integers modulo 4\. Recall from
    [Chapter 9](chapter9.xhtml) that a group must include an identity element (that
    is, 1) and that each number *x* in the group must have an inverse, a number *y*
    such that *x* × *y* = 1\. How do you determine the set that makes up **Z**[4]^*?
    Based on the definitions, you know that 0 is not in the group **Z**[4]^* because
    multiplying any number by 0 can never give 1, so 0 has no inverse. The number
    1 belongs to **Z**[4]^* because 1 × 1 = 1, so 1 is its own inverse. However, the
    number 2 doesn’t belong in this group because you can’t obtain 1 by multiplying
    2 with another element of **Z**[4]^* (note that 2 isn’t coprime with 4, because
    4 and 2 share the factor of 2). The number 3 belongs in the group **Z**[4]^* because
    it is its own inverse within **Z**[4]^*. Thus, you have **Z**[4]^* = {1, 3}.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑模 4 的整数群 **Z**[4]^*。回想一下[第 9 章](chapter9.xhtml)，一个群必须包含单位元素（即 1），并且群中的每个数字
    *x* 必须有一个逆元 *y*，使得 *x* × *y* = 1。你如何确定构成 **Z**[4]^* 的集合？根据定义，你知道 0 不属于 **Z**[4]^*，因为任何数字与
    0 相乘都不可能得到 1，因此 0 没有逆元。数字 1 属于 **Z**[4]^*，因为 1 × 1 = 1，所以 1 是它自己的逆元。然而，数字 2 不属于该群，因为无法通过将
    2 与 **Z**[4]^* 的另一个元素相乘得到 1（注意，2 与 4 不是互质的，因为 4 和 2 有公因子 2）。数字 3 属于 **Z**[4]^*，因为它是
    **Z**[4]^* 中的逆元。因此，**Z**[4]^* = {1, 3}。
- en: 'Now consider **Z**[5]^*, the multiplicative group of integers modulo 5\. As
    in [Chapter 9](chapter9.xhtml), **Z**[5]^* = {1, 2, 3, 4}. Indeed, 5 being prime,
    1, 2, 3, and 4 are all coprime with 5, so the set of **Z**[5]^* includes all of
    them. Let’s verify this: 2 × 3 mod 5 = 1; therefore, 2 is 3’s inverse, and 3 is
    2’s inverse; note that 4 is its own inverse because 4 × 4 mod 5 = 1; and finally,
    1 is again its own inverse in the group.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑**Z**[5]^*，即模 5 的整数乘法群。如同[第 9 章](chapter9.xhtml)中所述，**Z**[5]^* = {1, 2,
    3, 4}。实际上，由于 5 是质数，1、2、3 和 4 都与 5 互质，因此 **Z**[5]^* 的集合包含了它们。我们来验证一下：2 × 3 mod
    5 = 1；因此，2 是 3 的逆元，而 3 是 2 的逆元；注意，4 是它自己的逆元，因为 4 × 4 mod 5 = 1；最后，1 在该群中依然是它自己的逆元。
- en: 'To find the number of elements in a group **Z**n^* when *n* isn’t prime, you
    can use *Euler’s totient function*, which we write as φ(*n*), with φ representing
    the Greek letter phi. This function gives the number of elements coprime with
    *n*, which is the number of elements in **Z**n^*. As a rule, if *n* is a product
    of prime numbers *n* = *p*[1] × *p*[2] × . . . × *p*m, the number of elements
    in the group **Z**n^* is the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *n* 不是质数时，要找出群 **Z**n^* 中的元素个数，可以使用*欧拉函数*，我们将其写作 φ(*n*)，其中 φ 代表希腊字母 phi。这个函数给出与
    *n* 互质的元素个数，即 **Z**n^* 中的元素个数。通常，如果 *n* 是质数的积，即 *n* = *p*[1] × *p*[2] × … × *p*m，那么群
    **Z**n^* 中的元素个数如下：
- en: '![](../images/pg197-1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg197-1.jpg)'
- en: RSA deals only with numbers *n* that are the product of two large primes, usually
    noted as *n* = *pq*. The associated group **Z**n^* then contains φ(*n*) = (*p*
    – 1)(*q* – 1) elements. By expanding this expression, you get the equivalent definition
    φ(*n*) = *n* – *p* – *q* + 1, or φ(*n*) = (*n* + 1) – (*p* + *q*), which expresses
    more intuitively the value of φ(*n*) relative to *n*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 仅处理 *n* 是两个大质数的积的数字，通常表示为 *n* = *pq*。相关的群 **Z**n^* 包含 φ(*n*) = (*p* – 1)(*q*
    – 1) 个元素。通过展开这个表达式，你可以得到等价的定义 φ(*n*) = *n* – *p* – *q* + 1，或者 φ(*n*) = (*n* +
    1) – (*p* + *q*)，它更直观地表示了 φ(*n*) 相对于 *n* 的值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The RSA Trapdoor Permutation</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">RSA 陷门置换</samp>
- en: The RSA trapdoor permutation is the core algorithm behind RSA-based encryption
    and signatures. Given a modulus *n* and a number *e*, which you call the *public
    exponent*, the RSA trapdoor permutation transforms a number *x* from the set **Z**n^*
    into a number *y* = *x**^e* mod *n*. In other words, it calculates the value that’s
    equal to *x* multiplied by itself *e –* 1 times modulo *n* and then returns the
    result. When you use the RSA trapdoor permutation to encrypt, the modulus *n*
    and the exponent *e* make up the RSA public key.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 陷门置换是基于 RSA 的加密和签名的核心算法。给定模数 *n* 和一个数字 *e*，你可以称之为*公钥指数*，RSA 陷门置换将集合 **Z**n^*
    中的一个数字 *x* 转换为数字 *y* = *x**^e* mod *n*。换句话说，它计算的结果是 *x* 自乘 *e –* 1 次后对 *n* 取模，然后返回该结果。当你使用
    RSA 陷门置换进行加密时，模数 *n* 和指数 *e* 组成了 RSA 公钥。
- en: 'To get *x* back from *y*, you can use another number, *d*, to compute the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 *y* 中恢复出 *x*，你可以使用另一个数字 *d* 来计算以下公式：
- en: '![](../images/pg197-2.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg197-2.jpg)'
- en: Because *d* is the trapdoor that allows you to decrypt, it’s part of the private
    key in an RSA key pair, meaning it should always be kept secret. The number *d*
    is also called the *secret exponent*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *d* 是让你能够解密的陷阱门，它是RSA密钥对中私钥的一部分，这意味着它应该始终保密。数字 *d* 也叫做 *秘密指数*。
- en: Of course, *d* isn’t just any number; it’s the number such that *e* multiplied
    by *d* is equivalent to 1 and therefore such that *x**^(ed)* mod *n* = *x* for
    any *x*. More precisely, you must have *ed* mod φ(*n*) = 1 to get *x**^(ed)* =
    *x*¹ = *x* and to decrypt the message correctly. Note that you compute modulo
    φ(*n*) and not modulo *n* here because exponents behave like *indexes* of elements
    of **Z**n^* rather than as the elements themselves. Because **Z**n^* has φ*(n*)
    elements, the index must be less than φ*(n*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，*d* 并不是任意一个数字；它是这样一个数字，使得 *e* 乘以 *d* 等于 1，因此有 *x**^(ed)* mod *n* = *x*，对任意
    *x* 都成立。更精确地说，你必须满足 *ed* mod φ(*n*) = 1，才能得到 *x**^(ed)* = *x*¹ = *x* 并正确解密消息。请注意，这里计算的是模
    φ(*n*) 而不是模 *n*，因为指数像是 **Z**n^* 元素的 *索引*，而不是这些元素本身。由于 **Z**n^* 有 φ*(n*) 个元素，索引必须小于
    φ*(n*)。
- en: The number φ(*n*) is crucial to RSA’s security. In fact, finding φ(*n*) for
    an RSA modulus *n* is equivalent to breaking RSA because you can easily derive
    the secret exponent *d* from φ(*n*) and *e* by computing *e*’s inverse. Hence
    *p* and *q* should also be secret, since knowing *p* or *q* gives φ(*n*) by computing
    (*p* – 1)(*q* – 1) = φ(*n*).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 φ(*n*) 对RSA的安全性至关重要。实际上，求解RSA模数 *n* 的 φ(*n*) 相当于破解RSA，因为你可以通过计算 *e* 的逆元轻松从
    φ(*n*) 和 *e* 推导出秘密指数 *d*。因此，*p* 和 *q* 也应保持机密，因为知道 *p* 或 *q* 可以通过计算 (*p* – 1)(*q*
    – 1) = φ(*n*) 来得出 φ(*n*)。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*φ(*n*) is called the* order *of the group* **Z**[n]*^***; the order is an
    important characteristic of a group, which is essential to other public-key systems
    such as Diffie–Hellman and elliptic curve cryptography.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*φ(*n*) 被称为**Z**[n]*^* 的*阶*；阶是群体的重要特征，对其他公钥系统（如Diffie–Hellman和椭圆曲线密码学）至关重要。*'
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">RSA Key Generation and Security</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">RSA 密钥生成与安全性</samp>'
- en: '*Key generation* is the process by which an RSA key pair is created, namely,
    a public key (modulus *n* and public exponent *e*) and its private key (secret
    exponent *d*). As the numbers *p* and *q* (such that *n* = *pq*) and the order
    φ(*n*) should also be secret, you will often include them as part of the private
    key.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*密钥生成* 是创建RSA密钥对的过程，即一个公钥（模数 *n* 和公钥指数 *e*）及其私钥（秘密指数 *d*）。由于数字 *p* 和 *q*（使得
    *n* = *pq*）以及顺序 φ(*n*) 也应保持机密，因此它们通常作为私钥的一部分。'
- en: To generate an RSA key pair, first pick two random prime numbers, *p* and *q*,
    and compute φ(*n*) from them. Then compute *d* as the inverse of *e*. [Listing
    10-1](chapter10.xhtml#Lis10-1) shows how this works using SageMath (*[https://<wbr>www<wbr>.sagemath<wbr>.org](https://www.sagemath.org)*),
    an open source Python-esque environment that includes many mathematical packages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成RSA密钥对，首先选择两个随机素数 *p* 和 *q*，然后从中计算 φ(*n*)。接着将 *d* 计算为 *e* 的逆元。[Listing 10-1](chapter10.xhtml#Lis10-1)
    演示了如何使用SageMath（一个开源的类似Python的环境，包含许多数学包）来实现这一过程，SageMath的网址是 (*[https://<wbr>www<wbr>.sagemath<wbr>.org](https://www.sagemath.org)*）。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: Generating RSA
    parameters using SageMath</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1：使用SageMath生成RSA参数</samp>
- en: Here you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">random_prime()</samp>
    function to pick random primes <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>, which are lower than
    a given argument. Next, you multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> to get the modulus
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> and φ(*n*), which is the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp> variable. You then generate
    a random public exponent, <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>,
    by picking a random prime less than <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp>
    to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> has an inverse
    modulo <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp>.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">random_prime()</samp> 函数来选择小于给定参数的随机素数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>。接下来，你将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    相乘得到模数 <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> 和 φ(*n*)，其中 φ(*n*)
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp> 变量。然后，你通过选择一个小于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">phi</samp> 的随机素数生成随机公钥指数 <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>，以确保
    <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> 在模 <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp>
    下有逆元。
- en: You use the <samp class="SANS_TheSansMonoCd_W5Regular_11">xgcd()</samp> function
    from Sage to generate the associated private exponent *d*. This function computes
    the numbers *s* and *t* given two numbers, *a* and *b*, with the extended Euclidean
    algorithm such that *as* + *bt* = **GCD**(*a*, *b*). Finally, you check that *ed*
    mod φ(*n*) = 1 to ensure that *d* correctly inverts the RSA permutation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 Sage 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">xgcd()</samp> 函数来生成相关的私钥指数
    *d*。这个函数使用扩展欧几里得算法，给定两个数字 *a* 和 *b*，计算出 *s* 和 *t*，使得 *as* + *bt* = **GCD**(*a*,
    *b*)。最后，你检查 *ed* mod φ(*n*) = 1，以确保 *d* 正确地反转了 RSA 置换。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*I’ve used a 64-bit modulus* n *in [Listing 10-1](chapter10.xhtml#Lis10-1)
    to avoid multiple pages of output, but in practice an RSA modulus should be at
    least 2,048 bits to be secure.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在[清单 10-1](chapter10.xhtml#Lis10-1)中使用了一个64位模数* n *，以避免产生多页输出，但在实际应用中，为了确保安全，RSA
    模数应至少为2,048位。*'
- en: Now you can apply the trapdoor permutation, as [Listing 10-2](chapter10.xhtml#Lis10-2)
    shows.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以应用陷门置换，正如[清单 10-2](chapter10.xhtml#Lis10-2)所示。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Computing the
    RSA trapdoor permutation back and forth</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-2：计算 RSA 陷门置换的正反运算</samp>
- en: You assign the integer 1,234,567 to *x* and then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">power_mod(x,
    e, n)</samp> function, the exponentiation modulo *n*, or *x**^e* mod *n* in equation
    form, to calculate *y*. After computing *y* = *x**^e* mod *n*, you calculate *y**^d*
    mod *n* with the trapdoor *d* to return the original *x*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你将整数1,234,567赋值给*x*，然后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">power_mod(x,
    e, n)</samp> 函数，即指数模 *n* 运算，或者以方程形式表示的 *x**^e* mod *n*，来计算 *y*。计算出 *y* = *x**^e*
    mod *n* 后，你使用陷门 *d* 计算 *y**^d* mod *n* 来返回原始的 *x*。
- en: How hard is it to find *x* without the trapdoor *d*? An attacker able to factor
    big numbers could break RSA by recovering *p* and *q* and then φ(*n*) to compute
    *d* from *e*. Another risk to RSA lies in an attacker’s ability to compute *x*
    from *x**^e* mod *n*, or *e*th roots modulo *n*, without necessarily factoring
    *n*. While both risks seem closely connected, we don’t know for sure that they’re
    equivalent.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 没有陷门 *d*，要找到 *x* 有多难？一个能够分解大数的攻击者，可以通过恢复 *p* 和 *q*，然后计算 φ(*n*) 来从 *e* 计算出 *d*，从而破解
    RSA。RSA 还有一个风险，攻击者可以从 *x**^e* mod *n*，即 *e* 次方根模 *n* 计算出 *x*，而不必分解 *n*。虽然这两个风险看起来密切相关，但我们不能确定它们是否等价。
- en: 'Assuming that factoring and finding *e*th roots are about equally hard, RSA’s
    security level depends on three factors: the size of *n*, the choice of *p* and
    *q*, and how the trapdoor permutation is used. If *n* is too small, one could
    factor it in a realistic amount of time, revealing the private key. To be safe,
    *n* should be at least 2,048 bits long (a security level of about 90 bits, requiring
    a computational effort of about 2^(90) operations) but preferably 4,096 bits long
    (a security level of approximately 128 bits). The values *p* and *q* should be
    unrelated random prime numbers of similar size. If they’re too small or too close
    together, it’s easier to determine their value from *n*. Finally, you shouldn’t
    use the RSA trapdoor permutation directly for encryption or signing, as I’ll discuss
    shortly.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设因式分解和求 *e* 次方根的难度相当，RSA的安全性依赖于三个因素：*n* 的大小、*p* 和 *q* 的选择，以及如何使用陷门置换。如果 *n*
    太小，就可以在合理的时间内进行因式分解，从而揭示私钥。为了安全起见，*n* 至少应为2048位（大约90位的安全等级，需要约 2^(90) 次运算），但最好是4096位（大约128位的安全等级）。*p*
    和 *q* 的值应为不相关的随机质数，且大小相似。如果它们太小或太接近，就更容易从 *n* 中确定它们的值。最后，不应直接使用RSA陷门置换进行加密或签名，稍后我会讨论这个问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encrypting with RSA</samp>
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用RSA加密</samp>
- en: Typically, RSA is used in combination with a symmetric encryption scheme, where
    RSA encrypts a symmetric key that serves to encrypt a message with a symmetric
    cipher, such as AES-GCM. But encrypting a message or symmetric key with RSA is
    more complicated than simply converting the target to a number *x* and computing
    *x**^e* mod *n*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RSA与对称加密方案结合使用，其中RSA加密一个对称密钥，该密钥用于使用对称密码（如AES-GCM）加密消息。但使用RSA加密消息或对称密钥比简单地将目标转换为数字
    *x* 并计算 *x**^e* mod *n* 要复杂得多。
- en: In the following subsections, I explain why a naive application of the RSA trapdoor
    permutation is insecure and how strong RSA-based encryption works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我将解释为什么直接应用RSA陷门置换是不安全的，以及基于RSA的强加密是如何工作的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Textbook RSA Encryption’s
    Malleability</samp>
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">教科书版RSA加密的易变性</samp>
- en: 'The phrase *textbook RSA encryption* describes the simplistic RSA encryption
    scheme wherein the number exponentiated contains only the message you want to
    encrypt. For example, to encrypt the string *RSA*, you first convert it to a number—for
    example, by concatenating the ASCII encodings of each of the three letters as
    a byte: *R* (byte <samp class="SANS_TheSansMonoCd_W5Regular_11">52</samp>), *S*
    (byte <samp class="SANS_TheSansMonoCd_W5Regular_11">53</samp>), and *A* (byte
    <samp class="SANS_TheSansMonoCd_W5Regular_11">41</samp>). The resulting byte string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">525341</samp> is equal to 5,395,265
    when converted to decimal, which you might then encrypt by computing 5,395,265*^e*
    mod *n*. Without knowing the secret key, there’s no way to decrypt the message—at
    least in theory.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 短语 *教科书版RSA加密* 描述了简单的RSA加密方案，其中指数运算的数字仅包含你想要加密的消息。例如，为了加密字符串 *RSA*，你首先将其转换为一个数字——例如，通过将每个字母的ASCII编码连接起来作为字节：*R*（字节
    <samp class="SANS_TheSansMonoCd_W5Regular_11">52</samp>）、*S*（字节 <samp class="SANS_TheSansMonoCd_W5Regular_11">53</samp>）和
    *A*（字节 <samp class="SANS_TheSansMonoCd_W5Regular_11">41</samp>）。转换成十进制后，结果字节串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">525341</samp> 等于5,395,265，接下来你可以通过计算
    5,395,265*^e* mod *n* 来加密它。如果没有私钥，理论上是无法解密该消息的。
- en: 'However, textbook RSA encryption is deterministic: if you encrypt the same
    plaintext twice, you’ll get the same ciphertext twice. And there’s an even bigger
    problem: given two textbook RSA ciphertexts *y*[1] = *x*[1]*^e* mod *n* and *y*[2]
    = *x*[2]*^e* mod *n*, you can derive the ciphertext of *x*[1] × *x*[2] by multiplying
    these ciphertexts together:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，教科书版RSA加密是确定性的：如果你两次加密相同的明文，你将得到相同的密文。而且还有一个更大的问题：给定两个教科书版RSA密文 *y*[1] =
    *x*[1]*^e* mod *n* 和 *y*[2] = *x*[2]*^e* mod *n*，你可以通过将这两个密文相乘，推导出 *x*[1] × *x*[2]
    的密文：
- en: '![](../images/pg200-1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg200-1.jpg)'
- en: The result is (*x*[1] × *x*[2])*^e* mod *n*, the ciphertext of the message *x*[1]
    × *x*[2] mod *n*. An attacker could create a new valid ciphertext from two RSA
    ciphertexts, compromising the security of your encryption by allowing them to
    deduce information about the original message. This weakness makes textbook RSA
    encryption *malleable*. (If you know *x*[1] and *x*[2], you can compute (*x*[1]
    × *x*[2])*^e* mod *n*, too, but if you know only *y*[1] and *y*[2], you shouldn’t
    be able to multiply ciphertexts and get the ciphertext of the multiplied plaintexts.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 (*x*[1] × *x*[2])*^e* mod *n*，即消息 *x*[1] × *x*[2] mod *n* 的密文。攻击者可以通过从两个
    RSA 密文中创建一个新的有效密文，从而危及加密的安全性，使他们能够推断出原始消息的信息。这种弱点使教材 RSA 加密变得*可变*。（如果你知道 *x*[1]
    和 *x*[2]，你也可以计算 (*x*[1] × *x*[2])*^e* mod *n*，但如果你只知道 *y*[1] 和 *y*[2]，你不应能将密文相乘并得到相乘的明文的密文。）
- en: Another problem with the naive textbook RSA encryption is the existence of “special”
    messages. Whatever *n* and *e* are, 1*^e* = 1\. Thus, the message 1 is left unchanged
    through encryption. Textbook RSA has many other problems, but you’ll learn to
    avoid them by using a strong RSA encryption.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单的教材 RSA 加密问题是“特殊”消息的存在。无论 *n* 和 *e* 是什么，1*^e* = 1。因此，消息 1 在加密过程中保持不变。教材
    RSA 还有许多其他问题，但你将通过使用强 RSA 加密方法来避免这些问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Strong RSA Encryption
    with OAEP</samp>
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">带 OAEP 的强 RSA 加密</samp>
- en: To make RSA ciphertexts nonmalleable, the number exponentiated during encryption
    should combine message data with additional data called *padding*, as [Figure
    10-1](chapter10.xhtml#fig10-1) shows.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 RSA 密文不可伪造，加密过程中指数化的数字应将消息数据与额外的数据（称为*填充*）结合起来，正如[图 10-1](chapter10.xhtml#fig10-1)所示。
- en: '![](../images/fig10-1.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig10-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Encrypting a symmetric
    key,</samp> <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    with RSA using (</samp><samp class="SANS_Futura_Std_Book_11">n</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,</samp>
    <samp class="SANS_Futura_Std_Book_11">e</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)
    as a public key</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-1：使用 RSA 加密对称密钥</samp>
    <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">，使用
    (</samp><samp class="SANS_Futura_Std_Book_11">n</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,</samp>
    <samp class="SANS_Futura_Std_Book_11">e</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)
    作为公钥</samp>
- en: The standard way to encrypt with RSA in this fashion is to use Optimal Asymmetric
    Encryption Padding (OAEP), a combination commonly called RSA-OAEP. This scheme
    involves creating a bit string as large as the modulus by padding the message
    with extra data and randomness before applying the RSA function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用 RSA 加密的标准方法是使用最优非对称加密填充（OAEP），这种组合通常被称为 RSA-OAEP。该方案涉及创建一个与模数相同大小的比特串，通过在应用
    RSA 函数之前用额外的数据和随机性填充消息。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Official documents such as the PKCS#1 standard and NIST’s Special Publication
    800-56B refer to OAEP as RSAES-OAEP. OAEP improves on the earlier method* *PKCS#1
    v1.5, which is one of the first in a series of Public-Key Cryptography Standards
    (PKCS) by RSA. It is markedly less secure than OAEP yet has remained in use in
    many systems after OAEP’s introduction.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*如 PKCS#1 标准和 NIST 的特别出版物 800-56B 所示，OAEP 被称为 RSAES-OAEP。OAEP 改进了早期的方法* *PKCS#1
    v1.5，这是 RSA 发布的一系列公钥密码标准（PKCS）中的第一个。它的安全性明显低于 OAEP，但在 OAEP 引入后，仍在许多系统中使用。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security</samp>
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">安全性</samp>
- en: OAEP uses a PRNG to ensure the indistinguishability and nonmalleability of ciphertexts
    by making the encryption probabilistic. It’s been proven secure as long as the
    RSA function and the PRNG are secure and, to a lesser extent, the hash functions
    aren’t too weak. You should use OAEP when encrypting with RSA, rather than its
    predecessor, the standard PKCS#1 v1.5.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: OAEP 使用伪随机数生成器（PRNG）确保密文的不可区分性和不可伪造性，通过使加密具有概率性。只要 RSA 函数和 PRNG 安全，且哈希函数不太弱，它已被证明是安全的。在使用
    RSA 加密时，应该使用 OAEP，而不是其前身标准 PKCS#1 v1.5。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Encryption</samp>
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">加密</samp>
- en: Encrypting with RSA in OAEP mode requires a message (such as a symmetric key,
    *K*), a PRNG, and two hash functions. To create the ciphertext, use a given modulus
    *n* long of *m* bytes (that is, 8*m* bits and therefore an *n* lower than 2⁸*^m*).
    To encrypt *K*, form the *encoded message* as
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RSA的OAEP模式加密需要一个消息（如对称密钥*K*）、一个伪随机数生成器（PRNG）和两个哈希函数。为了创建密文，使用给定模数*n*长度的*m*字节（即8*m*位，因此*n*小于2⁸*^m*）。要加密*K*，将*编码后的消息*构造为
- en: '*M* = *H* || <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> . . .
    <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    || *K*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*M* = *H* || <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> . . .
    <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    || *K*'
- en: where *H* is an *h*-byte constant defined by the OAEP scheme, followed by as
    many <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes as necessary
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte. [Figure 10-2](chapter10.xhtml#fig10-2)
    shows how to process this encoded message, *M*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*H*是由OAEP方案定义的*h*字节常量，后跟必要数量的<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>字节和一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp>字节。[图 10-2](chapter10.xhtml#fig10-2)展示了如何处理这个编码后的消息*M*。
- en: '![](../images/fig10-2.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig10-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: Encrypting a symmetric
    key,</samp> <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    with RSA-OAEP, where</samp> <samp class="SANS_Futura_Std_Book_11">H</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">is a fixed parameter and</samp> <samp
    class="SANS_Futura_Std_Book_11">R</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">is
    random bits</samp>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-2：使用RSA-OAEP加密对称密钥，</samp>
    <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">，其中</samp>
    <samp class="SANS_Futura_Std_Book_11">H</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">是一个固定参数，</samp>
    <samp class="SANS_Futura_Std_Book_11">R</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">是随机位</samp>
- en: You generate an *h*-byte random string *R* and set *M* = *M* ⊕ **Hash1**(*R*),
    where **Hash1**(*R*) is as long as *M*. Next, set *R* = *R* ⊕ **Hash2**(*M*),
    where **Hash2**(*M*) is as long as *R*. Now use these new values of *M* and *R*
    to form an *m*-byte string *P* = <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    || *M* || *R*, which is as long as the modulus *n* and which you can convert to
    an integer number less than *n*. This conversion results in the number *x*, which
    you then use to compute the RSA function *x**^e* mod *n* to get the ciphertext.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你生成一个*h*字节的随机字符串*R*，并设置*M* = *M* ⊕ **Hash1**(*R*)，其中**Hash1**(*R*)的长度与*M*相同。接下来，设置*R*
    = *R* ⊕ **Hash2**(*M*)，其中**Hash2**(*M*)的长度与*R*相同。现在，使用这些新的*M*和*R*值来形成一个*m*字节的字符串*P*
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> || *M* || *R*，其长度与模数*n*相同，且你可以将其转换为一个小于*n*的整数。这次转换得到的数字是*x*，然后你可以使用它来计算RSA函数*x**^e*
    mod *n*以得到密文。
- en: To decrypt a ciphertext *y*, first compute *x* = *y**^d* mod *n* and, from this,
    recover the final values of *M* and *R*. Next, retrieve *M*’s initial value by
    calculating *M* ⊕ **Hash1**(*R* ⊕ **Hash2**(*M*)). Finally, verify that *M* is
    of the form *H* || <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> . .
    . <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    || *K*, with an *h*-byte *H* and <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    bytes followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密密文*y*，首先计算*x* = *y**^d* mod *n*，然后从中恢复出*M*和*R*的最终值。接下来，通过计算*M* ⊕ **Hash1**(*R*
    ⊕ **Hash2**(*M*))来恢复*M*的初始值。最后，验证*M*的格式是否为*H* || <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    . . . <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    || *K*，其中*h*字节的*H*后跟若干<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>字节，接着是一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp>字节。
- en: In practice, the parameters *m* and *h* (the length of the modulus and the length
    of **Hash2**’s output, respectively) are typically *m* = 256 bytes (for 2,048-bit
    RSA) and *h* = 32 (using SHA-256 as **Hash2**). This leaves *m* – *h* – 1 = 223
    bytes for *M*, of which up to *m* – 2*h* – 2 = 190 bytes are available for *K*
    (the “– 2” is due to the <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    byte separator in *M*). The **Hash1** hash value is then composed of *m* – *h*
    – 1 = 223 bytes, which is longer than the hash value of any common hash function.
    To build a hash with such an unusual output length, the RSA standard specification
    defines a *mask generating function* technique to create hash functions that return
    arbitrarily large hash values from any hash function. As another approach, use
    an extendable output function (XOF) such as SHAKE or BLAKE3, although this differs
    from the standard specifications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，参数 *m* 和 *h*（分别是模数的长度和**Hash2**输出的长度）通常设置为 *m* = 256 字节（适用于 2048 位 RSA）和
    *h* = 32（使用 SHA-256 作为 **Hash2**）。这意味着 *m* – *h* – 1 = 223 字节用于 *M*，其中最多有 *m*
    – 2*h* – 2 = 190 字节可以用于 *K*（"-2" 是由于 *M* 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    字节分隔符）。然后，**Hash1** 的哈希值由 *m* – *h* – 1 = 223 字节组成，这比任何常见哈希函数的哈希值要长。为了构建具有如此不同寻常输出长度的哈希，RSA
    标准规范定义了一种 *掩码生成函数* 技术，用于创建从任何哈希函数返回任意大小哈希值的哈希函数。另一种方法是使用可扩展输出函数（XOF），例如 SHAKE
    或 BLAKE3，尽管这与标准规范不同。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Signing with RSA</samp>
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 RSA 签名</samp>
- en: Digital signatures can prove that the holder of the private key tied to a particular
    digital signature signed some message, typically to endorse its content. Because
    only the private key holder knows the private exponent *d*, no one else can compute
    a signature *y* = *x**^d* mod *n* from some value *x*, but everyone can verify
    *y**^e* mod *n* = *x* given the public exponent *e*. In principle, one can use
    that verified signature as evidence to demonstrate that the private-key holder
    signed some particular message; this is a property called *nonrepudiation*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名可以证明与特定数字签名相关的私钥持有者签署了某个消息，通常是为了支持其内容。因为只有私钥持有者知道私有指数 *d*，其他任何人都无法根据某个值
    *x* 计算出签名 *y* = *x**^d* mod *n*，但每个人都可以通过公共指数 *e* 验证 *y**^e* mod *n* = *x*。原则上，可以使用该验证的签名作为证据，证明私钥持有者签署了某个特定消息；这就是所谓的
    *不可否认性*。
- en: It’s tempting to see RSA signatures as the converse of encryption, but they
    aren’t. Signing with RSA isn’t the same as encrypting with the private key. Encryption
    provides confidentiality, whereas digital signatures help prevent forgeries. The
    most salient example of this difference is that it’s OK for a signature scheme
    to leak information on the message signed, because the message isn’t secret. For
    example, a scheme that reveals parts of the messages could be a secure signature
    scheme but not a secure encryption scheme.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将 RSA 签名视为加密的逆过程，但它们并不相同。使用 RSA 签名并不等于使用私钥加密。加密提供了保密性，而数字签名则有助于防止伪造。这种区别的最明显例子是，签名方案可以泄露签名消息的部分信息，因为消息本身并不保密。例如，揭示部分消息内容的方案可以是一个安全的签名方案，但却不是一个安全的加密方案。
- en: Because of the necessary processing overhead, public-key encryption can process
    only short messages, which are usually secret keys rather than actual messages.
    A signature scheme, however, can process messages of arbitrary sizes by using
    their hash values **Hash**(*M*) as a proxy, and it can be deterministic yet secure.
    Like RSA-OAEP, RSA-based signature schemes can use a padding scheme, but they
    can also use the maximal message space allowed by the RSA modulus.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于必要的处理开销，公钥加密只能处理短消息，通常是秘密密钥而非实际消息。然而，签名方案可以通过使用其哈希值 **Hash**(*M*) 作为代理来处理任意大小的消息，而且它可以是确定性且安全的。与
    RSA-OAEP 类似，基于 RSA 的签名方案可以使用填充方案，但也可以使用 RSA 模数允许的最大消息空间。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Textbook RSA
    Signatures</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">教科书中的 RSA 签名</samp>'
- en: 'A *textbook RSA signature* is the method that signs a message, *x*, by directly
    computing *y* = *x**^d* mod *n*, where *x* can be any number between 1 and *n*
    – 1\. Like textbook encryption, textbook RSA signing is simple to specify and
    implement but insecure in the face of several attacks. One such attack involves
    a trivial forgery: upon noticing that 1*^d* mod *n* = 1 and (*n* – 1)*^d* mod
    *n* = *n* – 1, regardless of the value of the private key *d*, an attacker can
    forge signatures of 1 or *n* – 1 without knowing *d*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*教科书式的RSA签名*是通过直接计算 *y* = *x**^d* mod *n* 来签名消息 *x* 的方法，其中 *x* 可以是 1 到 *n*
    – 1 之间的任何数字。像教科书加密一样，教科书RSA签名方法简单易于指定和实现，但在面对多种攻击时却不安全。一个这样的攻击涉及到一个简单的伪造：由于 1*^d*
    mod *n* = 1 和 (*n* – 1)*^d* mod *n* = *n* – 1，不管私钥 *d* 的值如何，攻击者可以伪造 1 或 *n* –
    1 的签名，而无需知道 *d*。
- en: More worrying is the *blinding attack*. For example, say you want to get a third
    party’s signature on some message, *M*, that you know they’d never knowingly sign.
    To launch this attack, first find some value, *R*, such that *R**^e**M* mod *n*
    is a message that your victim would knowingly sign. Next, you’d convince them
    to sign that message and to show you their signature, which is equal to *S* =
    (*R**^e**M*)*^d* mod *n*, or the message raised to the power *d*. Given that signature,
    you can derive the signature of *M*, namely, *M**^d*, with the aid of some straightforward
    computations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人担忧的是*盲化攻击*。例如，假设你想让第三方在你知道他们绝不会故意签署的某个消息 *M* 上签名。为了发起这种攻击，首先找出某个值 *R*，使得
    *R**^e**M* mod *n* 是一个你受害者愿意签署的消息。接着，你说服他们签署该消息并展示给你他们的签名，该签名等于 *S* = (*R**^e**M*)*^d*
    mod *n*，即消息的 *d* 次方。得到这个签名后，你可以通过一些简单的计算推导出 *M* 的签名，也就是 *M**^d*。
- en: 'Because you can write *S* as (*R* *^e**M*)*^d* = *R**^(ed)**M**^d*, and because
    *R**^(ed)* = *R* (by definition), you have *S* = (*R**^e**M*)*^d* = *RM**^d*.
    To obtain the signature *M**^d*, divide *S* by *R* as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可以将 *S* 写成 (*R* *^e**M*)*^d* = *R**^(ed)**M**^d*，并且因为 *R**^(ed)* = *R*（根据定义），所以你有
    *S* = (*R**^e**M*)*^d* = *RM**^d*。为了得到签名 *M**^d*，你可以按照以下方式将 *S* 除以 *R*：
- en: '![](../images/pg203-1.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg203-1.jpg)'
- en: This is often a practical and powerful attack.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一种实用且强大的攻击方式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The PSS Signature
    Standard</samp>
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">PSS签名标准</samp>
- en: The RSA *Probabilistic Signature Scheme (PSS)* is to RSA signatures what OAEP
    is to RSA encryption. It was designed to make message signing more secure, thanks
    to the addition of padding data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: RSA *概率签名方案（PSS）* 就像 OAEP 对于 RSA 加密一样，是对 RSA 签名的改进。它的设计目的是通过增加填充数据来使消息签名更加安全。
- en: '[Figure 10-3](chapter10.xhtml#fig10-3) demonstrates that PSS combines a message
    narrower than the modulus with some random and fixed bits before RSAing the results
    of this padding process.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-3](chapter10.xhtml#fig10-3) 展示了 PSS 是如何将比模数更窄的消息与一些随机和固定的比特组合，然后再通过RSA加密这些填充后的结果。'
- en: '![](../images/fig10-3.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig10-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: Signing a message,</samp>
    <samp class="SANS_Futura_Std_Book_11">M</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    with RSA and with the PSS standard, where (</samp><samp class="SANS_Futura_Std_Book_11">n</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">,</samp> <samp class="SANS_Futura_Std_Book_11">d</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">) is the private key</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-3：使用RSA和PSS标准签名消息</samp>
    <samp class="SANS_Futura_Std_Book_11">M</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">，其中（</samp><samp
    class="SANS_Futura_Std_Book_11">n</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">，</samp>
    <samp class="SANS_Futura_Std_Book_11">d</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">）是私钥</samp>
- en: Like all public-key signature schemes, PSS works on a message’s hash rather
    than on the message itself. Signing **Hash**(*M*) is secure only if the hash function
    is collision resistant. You can thus sign messages of any length because after
    hashing a message, you’ll obtain a hash value of the same fixed length regardless
    of the message’s original length.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有公钥签名方案一样，PSS是基于消息的哈希值进行操作，而不是直接在消息本身上签名。签名**Hash**(*M*) 只有在哈希函数是抗碰撞的情况下才是安全的。这样，你就可以签名任何长度的消息，因为在对消息进行哈希后，无论消息的原始长度如何，你都能得到一个相同固定长度的哈希值。
- en: Why not sign by just applying the OAEP encryption to **Hash**(*M*)? Unfortunately,
    you can’t. Although similar to PSS, OAEP has been proven secure only for encryption,
    not for signatures.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不通过对 **Hash**(*M*) 应用 OAEP 加密来签名呢？不幸的是，你不能这样做。虽然OAEP类似于PSS，但已被证明仅在加密中是安全的，而不是用于签名。
- en: Like OAEP, PSS also requires a PRNG and two hash functions. One, **Hash1**,
    is a typical hash with a standard output length, such as SHA-256\. The other,
    **Hash2**, is a wide-output hash like OAEP’s **Hash2**. Like OAEP, PSS can use
    the mask-generating function (MGF) construction to build such a hash.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 OAEP，PSS 也需要一个伪随机数生成器（PRNG）和两个哈希函数。一个，**Hash1**，是一个具有标准输出长度的典型哈希，如 SHA-256。另一个，**Hash2**，是一个宽输出哈希，类似于
    OAEP 的 **Hash2**。与 OAEP 一样，PSS 可以使用掩码生成函数（MGF）构建这样的哈希。
- en: 'The PSS signing procedure works as follows (where *h* is **Hash1**’s output
    length):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: PSS 签名过程如下（其中 *h* 是 **Hash1** 的输出长度）：
- en: 1.  Pick an *r*-byte random string *R* using the PRNG.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  使用 PRNG 选择一个 *r* 字节的随机字符串 *R*。
- en: 2.  Form an encoded message *M* ′ = <samp class="SANS_TheSansMonoCd_W5Regular_11">0000000000000000</samp>
    || **Hash1**(*M*) || *R*, long of *h* + *r* + 8 bytes (with 8 zero bytes at the
    beginning).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  形成编码消息 *M*′ = <samp class="SANS_TheSansMonoCd_W5Regular_11">0000000000000000</samp>
    || **Hash1**(*M*) || *R*，长度为 *h* + *r* + 8 字节（开头有 8 个零字节）。
- en: 3.  Compute the *h*-byte string *H* = **Hash1**(*M*′).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  计算 *h* 字节字符串 *H* = **Hash1**(*M*′)。
- en: 4.  Set *L* = <samp class="SANS_TheSansMonoCd_W5Regular_11">00\. . .00</samp>
    || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> || *R*, or a sequence
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes followed by a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte and then *R*, with
    a number of <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes such
    that *L* is long of *m* – *h* – 1 bytes (the byte width *m* of the modulus minus
    the hash length *h* minus 1).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  设置 *L* = <samp class="SANS_TheSansMonoCd_W5Regular_11">00\. . .00</samp>
    || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> || *R*，或者是一个由 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">00</samp> 字节组成的序列，后跟一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    字节和 *R*，并且有足够数量的 <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> 字节，使得
    *L* 的长度为 *m* – *h* – 1 字节（模数 *m* 的字节宽度减去哈希长度 *h* 再减去 1）。
- en: 5.  Set *L* = *L* ⊕ **Hash2**(*H*) to replace the previous value of *L* with
    a new value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  设置 *L* = *L* ⊕ **Hash2**(*H*)，用新值替换之前的 *L*。
- en: 6.  Convert the *m*-byte string *P* = *L* || *H* || <samp class="SANS_TheSansMonoCd_W5Regular_11">BC</samp>
    to a number, *x*, lower than *n*. Here, the byte <samp class="SANS_TheSansMonoCd_W5Regular_11">BC</samp>
    is a fixed value appended after *H*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  将 *m* 字节字符串 *P* = *L* || *H* || <samp class="SANS_TheSansMonoCd_W5Regular_11">BC</samp>
    转换为小于 *n* 的数字 *x*。这里，字节 <samp class="SANS_TheSansMonoCd_W5Regular_11">BC</samp>
    是附加在 *H* 后的固定值。
- en: 7.  Given the value of *x* just obtained, compute the RSA function *x**^d* mod
    *n* to obtain the signature.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  给定刚得到的 *x* 值，计算 RSA 函数 *x**^d* mod *n* 来获得签名。
- en: 8.  To verify a signature given a message, *M*, compute **Hash1**(*M*) and use
    the public exponent *e* to inverse the RSA function and retrieve *L*, *H*, and
    then *M*′ from the signature, checking the padding’s correctness at each step.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  验证签名时，给定消息 *M*，计算 **Hash1**(*M*)，然后使用公钥指数 *e* 反转 RSA 函数并从签名中恢复 *L*、*H*，然后
    *M*′，并在每个步骤中检查填充的正确性。
- en: In practice, the random string *R* (called a *salt t* in the RSA-PSS standard)
    is usually as long as the hash value. For example, if you use *n* = 2,048 bits
    and SHA-256 as the hash, the value *L* is *m* – *h* – 1 = 256 – 32 – 1 = 223 bytes,
    and the random string *R* would typically be 32 bytes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，随机字符串 *R*（在 RSA-PSS 标准中称为 *salt t*）通常与哈希值的长度相同。例如，如果你使用 *n* = 2,048 位和
    SHA-256 作为哈希函数，则值 *L* 为 *m* – *h* – 1 = 256 – 32 – 1 = 223 字节，随机字符串 *R* 通常为 32
    字节。
- en: 'Like OAEP, PSS is provably secure, standardized, and available in many cryptographic
    software utilities and libraries, including OpenSSL and the Go language’s cryptography
    module. Also like OAEP, it looks needlessly complex and is prone to implementation
    errors and mishandled corner cases. Unlike RSA encryption, there’s a simpler alternative
    to PSS for signing: without a PRNG, with a single hash function, and without padding.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OAEP 一样，PSS 是可证明安全的，已标准化，并且在许多加密软件工具和库中都有实现，包括 OpenSSL 和 Go 语言的加密模块。与 OAEP
    一样，它看起来复杂且容易出现实现错误和处理不当的边界情况。与 RSA 加密不同，PSS 在签名方面有一个更简单的替代方案：不需要 PRNG，只有一个哈希函数，并且没有填充。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Full Domain
    Hash Signatures</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">全域哈希签名</samp>'
- en: '*Full Domain Hash (FDH)* is the simplest signature scheme you can imagine.
    To implement it, convert the byte string **Hash**(*M*) to a number, *x*, and create
    the signature *y* = *x**^d* mod *n*, as in [Figure 10-4](chapter10.xhtml#fig10-4).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*全域哈希（FDH）* 是你能想象的最简单的签名方案。要实现它，将字节字符串 **Hash**(*M*) 转换为数字 *x*，然后创建签名 *y* =
    *x**^d* mod *n*，如[图 10-4](chapter10.xhtml#fig10-4)所示。'
- en: '![](../images/fig10-4.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig10-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: Signing a message
    with RSA using the Full Domain Hash technique</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-4：使用RSA和全域哈希技术对消息进行签名</samp>
- en: Signature verification is straightforward, too. Given a signature that’s a number
    *y*, compute *x* = *y**^e* mod *n* and compare the result with **Hash**(*M*).
    It’s boringly simple, deterministic, yet secure. So why bother with the complexity
    of PSS?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 签名验证也很简单。给定一个签名为数字*y*，计算*x* = *y**^e* mod *n*，然后将结果与**Hash**(*M*)进行比较。这个过程简单、确定且安全。那么，为什么还要去研究PSS的复杂性呢？
- en: PSS was released *after* FDH, in 1996, and it has a security proof that inspires
    more confidence than FDH. Specifically, its proof offers slightly higher security
    guarantees than the proof of FDH, and its use of randomness helped strengthen
    that proof.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: PSS是在1996年，FDH之后发布的，它的安全性证明比FDH更令人信服。具体来说，它的证明提供了比FDH证明略高的安全保障，并且其随机性的使用加强了该证明。
- en: These stronger theoretical guarantees are the main reason why many cryptographers
    prefer PSS over FDH, but most applications using PSS today could switch to FDH
    with no meaningful security loss. In some contexts, however, it’s viable to use
    PSS instead of FDH because PSS’s randomness protects it from some attacks on its
    implementation, such as the fault attacks we’ll discuss in “How Things Can Go
    Wrong” on [page 211](#sec17).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更强的理论保证是许多加密学家偏好PSS而非FDH的主要原因，但今天使用PSS的大多数应用程序可以切换到FDH，而不会有明显的安全损失。然而，在某些情况下，使用PSS而非FDH是可行的，因为PSS的随机性能保护其免受一些对其实现的攻击，例如我们将在“如何出错”一章中讨论的故障攻击，详见[第211页](#sec17)。
- en: In any case, RSA signatures (PSS or FDH) are less and less used. Signatures
    based on elliptic curves, such as ECDSA and EdDSA, have gained in popularity,
    not least because their calculation of a signature is much faster (although signature
    verification is often faster with RSA).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，RSA签名（PSS或FDH）的使用越来越少。基于椭圆曲线的签名，如ECDSA和EdDSA，已变得更为流行，尤其是因为它们计算签名的速度更快（尽管RSA在签名验证时通常更快）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">RSA Implementations</samp>
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">RSA实现</samp>
- en: I hope you’ll never have to implement RSA from scratch. If you’re asked to,
    run as fast as you can and question the sanity of the person who asked you to
    do so. It took decades for cryptographers and engineers to develop RSA implementations
    that are fast, sufficiently secure, and ideally free of debilitating bugs, so
    it isn’t wise to reinvent RSA. Even with all the documentation available, it would
    take months to complete this daunting task.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你永远不需要从零实现RSA。如果有人要求你这样做，尽量跑得快一点，并质疑那个要求你这么做的人是否理智。加密学家和工程师们花了几十年时间，才开发出既快速、足够安全又理想中没有严重漏洞的RSA实现，所以重新发明RSA并不明智。即使有了所有文档，完成这项艰巨任务也需要几个月的时间。
- en: 'Typically, when using RSA in software, you’ll use a library or API that provides
    the necessary functions to carry out RSA operations. For example, the Go language
    has the following function in its <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp>
    package (from *[https://<wbr>go<wbr>.dev<wbr>/src<wbr>/crypto<wbr>/rsa<wbr>/rsa<wbr>.go](https://go.dev/src/crypto/rsa/rsa.go)*):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在软件中使用RSA时，你会使用一个库或API，这些库或API提供执行RSA操作所需的功能。例如，Go语言在其<samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp>包中有以下功能（来自
    *[https://<wbr>go<wbr>.dev<wbr>/src<wbr>/crypto<wbr>/rsa<wbr>/rsa<wbr>.go](https://go.dev/src/crypto/rsa/rsa.go)*）：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptOAEP()</samp>
    takes a hash function, a PRNG, a public key, a message, and a label (an optional
    parameter of OAEP) and returns a ciphertext and an error code. When you call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EncryptOAEP()</samp>, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt()</samp>
    to compute the RSA function given the padded data, as [Listing 10-3](chapter10.xhtml#Lis10-3)
    shows.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数<samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptOAEP()</samp>接受一个哈希函数、一个伪随机数生成器（PRNG）、一个公钥、一个消息和一个标签（OAEP的可选参数），并返回一个密文和错误代码。当你调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EncryptOAEP()</samp>时，它会调用<samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt()</samp>来计算给定填充数据的RSA功能，正如[清单10-3](chapter10.xhtml#Lis10-3)所示。
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: The implementation
    of the core RSA encryption function from the Go language cryptography library</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单10-3：Go语言加密库中核心RSA加密功能的实现</samp>
- en: The main operation here is <samp class="SANS_TheSansMonoCd_W5Regular_11">c.Exp(m,
    e, pub.N)</samp>, which raises a message, <samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp>,
    to the power <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> modulo <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pub.N</samp>, and assigns the result to
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要操作是<samp class="SANS_TheSansMonoCd_W5Regular_11">c.Exp(m, e, pub.N)</samp>，它将消息<samp
    class="SANS_TheSansMonoCd_W5Regular_11">m</samp>提升到指数<samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>的幂次，模<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pub.N</samp>运算，并将结果赋值给变量<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>。
- en: If you choose to implement RSA instead of using a readily available library
    function, be sure to rely on an existing *big-number* library, which is a set
    of functions and types that allow you to define and compute arithmetic operations
    on large numbers thousands of bits long. For example, you might use the GNU Multiple
    Precision (GMP) arithmetic library in C or in Go’s <samp class="SANS_TheSansMonoCd_W5Regular_11">big</samp>
    package. (Believe me, you don’t want to implement big-number arithmetic yourself.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择自己实现RSA，而不是使用现成的库函数，务必依赖现有的*大数*库，这是一组允许你定义并计算大数（数值位数达到几千位）上进行算术运算的函数和类型。例如，你可以在C语言中使用GNU多重精度（GMP）算术库，或者在Go语言中使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">big</samp>包。（相信我，你不想自己实现大数算术运算。）
- en: Even if you just use a library function when implementing RSA, ensure you understand
    how the internals work so you can assess the risk and whether it matches the application’s
    security requirements.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在实现RSA时只使用库函数，也要确保理解其内部实现原理，这样你才能评估风险，判断其是否符合应用的安全需求。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Fast Exponentiation
    Algorithm</samp>
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">快速指数运算算法</samp>
- en: '*Exponentiation* is the operation of raising *x* to the power *e*, when computing
    *x**^e* mod *n*. When working with big numbers, as with RSA, this operation can
    be extremely slow if naively implemented. How to efficiently compute exponentiations?'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*指数运算*是将*x*提升到*e*次方的操作，计算*x**^e* mod *n*时需要使用。当处理大数时，比如RSA，如果实现不当，这个操作可能非常慢。如何高效地计算指数运算呢？'
- en: The naive way to compute *x**^e* mod *n* takes *e* – 1 multiplications, as the
    pseudocode algorithm in [Listing 10-4](chapter10.xhtml#Lis10-4) demonstrates.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 计算*x**^e* mod *n*的简单方法需要*e* – 1次乘法，如[清单10-4](chapter10.xhtml#Lis10-4)中的伪代码算法所示。
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: A naive exponentiation
    algorithm in pseudocode, raising</samp> <samp class="SANS_Futura_Std_Book_11">x</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">to the power</samp> <samp class="SANS_Futura_Std_Book_11">e</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">modulo</samp> <samp class="SANS_Futura_Std_Book_11">n</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单10-4：一种朴素的指数运算伪代码算法，将</samp>
    <samp class="SANS_Futura_Std_Book_11">x</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">提升到指数</samp>
    <samp class="SANS_Futura_Std_Book_11">e</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">模</samp>
    <samp class="SANS_Futura_Std_Book_11">n</samp>
- en: This algorithm is simple but highly inefficient. You can get the same result
    exponentially faster by squaring rather than multiplying intermediate values *y*
    until you reach the correct value. This family of methods is called *square-and-multiply*,
    *exponentiation by squaring*, or *binary exponentiation*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法简单但效率极低。你可以通过对中间值*y*进行平方，而不是相乘，直到达到正确的值，从而以指数级速度获得相同的结果。这种方法族称为*平方-乘法*、*平方指数法*或*二进制指数法*。
- en: 'Say you want to compute 3^(65,537) mod 36,567,232,109,354,321, for example.
    (The number 65,537 is the public exponent in most RSA implementations.) You could
    multiply the number 3 by itself 65,536 times, or you could approach this problem
    knowing that you can write 65,537 as 2^(16) + 1 and use a series of squaring operations
    instead. Essentially, you initialize a variable, *y* = 3, and then compute the
    following squaring (*y*²) operations:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想计算3^(65,537) mod 36,567,232,109,354,321。例如，数字65,537是大多数RSA实现中的公钥指数。你可以将数字3乘以自身65,536次，或者你可以通过知道65,537可以写成2^(16)
    + 1，来使用一系列平方操作来解决这个问题。基本上，你首先初始化一个变量*y* = 3，然后进行以下的平方（*y*²）运算：
- en: 1.  Set *y* = *y*² mod *n* (now *y* = 3² mod *n*).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  设置*y* = *y*² mod *n*（现在*y* = 3² mod *n*）。
- en: 2.  Set *y* = *y*² mod *n* (now *y* = (3²)² mod *n* = 3⁴ mod *n*).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  设置*y* = *y*² mod *n*（现在*y* = (3²)² mod *n* = 3⁴ mod *n*）。
- en: 3.  Set *y* = *y*² mod *n* (now *y* = (3⁴)² = 3⁸ mod *n*).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  设置*y* = *y*² mod *n*（现在*y* = (3⁴)² = 3⁸ mod *n*）。
- en: 4.  Set *y* = *y*² mod *n* (now *y* = (3⁸)² = 3^(16) mod *n*).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  设定 *y* = *y*² mod *n*（现在 *y* = (3⁸)² = 3^(16) mod *n*）。
- en: 5.  Set *y* = *y*² mod *n* (now *y* = (3^(16))² = 3^(32) mod *n*).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  设定 *y* = *y*² mod *n*（现在 *y* = (3^(16))² = 3^(32) mod *n*）。
- en: And so on until *y* = 3^(65,536), by performing 16 squarings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行，直到 *y* = 3^(65,536)，通过进行 16 次平方运算。
- en: To get the final result, you would return 3 × *y* mod *n* = 3^(65,537) mod *n*
    = 26,652,909,283,612,267\. In other words, you compute the result with only 17
    multiplications rather than 65,536 with the naive method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到最终结果，你需要返回 3 × *y* mod *n* = 3^(65,537) mod *n* = 26,652,909,283,612,267。换句话说，你只用了
    17 次乘法运算来计算结果，而朴素方法需要 65,536 次乘法运算。
- en: More generally, a square-and-multiply method works by scanning the exponent’s
    bits one by one, computing the square for each exponent’s bit to double the exponent’s
    value, and multiplying by the original number for each bit with a value of 1 encountered.
    In the preceding example, the exponent 65,537 is 10000000000000001 in binary,
    and you squared *y* for each new bit and multiplied by the original number 3 only
    for the very first and last bits.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，平方和乘法方法通过逐个扫描指数的比特，计算每个指数比特的平方来加倍指数值，并且对于每个遇到值为 1 的比特，乘以原始数值。在上述例子中，指数
    65,537 的二进制表示是 10000000000000001，你为每个新比特进行了平方运算，并且只在第一个和最后一个比特时才乘以原始数值 3。
- en: '[Listing 10-5](chapter10.xhtml#Lis10-5) shows how this works as a general algorithm
    in pseudocode to compute *x**^e* mod *n* when the exponent *e* consists of bits
    *e*m – [1]*e*m – [2] . . . *e*[1]*e*[0], where *e*[0] is the least significant
    bit.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-5](chapter10.xhtml#Lis10-5)展示了如何将 *x**^e* mod *n* 作为一个通用算法来计算，当指数 *e*
    包含比特 *e*m – [1]*e*m – [2] . . . *e*[1]*e*[0] 时，其中 *e*[0] 是最低有效位。'
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: A fast exponentiation
    algorithm in pseudocode, raising</samp> <samp class="SANS_Futura_Std_Book_11">x</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">to the power</samp> <samp class="SANS_Futura_Std_Book_11">e</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">modulo</samp> <samp class="SANS_Futura_Std_Book_11">n</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 10-5：伪代码中的快速指数算法，将</samp>
    <samp class="SANS_Futura_Std_Book_11">x</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">提升到</samp>
    <samp class="SANS_Futura_Std_Book_11">e</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">的幂次</samp>
    <samp class="SANS_Futura_Std_Book_11">modulo</samp> <samp class="SANS_Futura_Std_Book_11">n</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">expMod()</samp> algorithm
    runs in time *O*(*m*), whereas the naive algorithm runs in time *O*(2*^m*), where
    *m* is the bit length of the exponent. Here, *O*() is the asymptotic complexity
    notation introduced in [Chapter 9](chapter9.xhtml).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">expMod()</samp> 算法的运行时间是 *O*(*m*)，而朴素算法的运行时间是
    *O*(2*^m*)，其中 *m* 是指数的比特长度。这里，*O*() 是在 [第 9 章](chapter9.xhtml) 中介绍的渐进复杂度符号。
- en: All serious systems implement some variant of this simplest square-and-multiply
    method. One such variant is the *sliding window* method, which considers blocks
    of bits rather than individual bits to perform a given multiplication operation.
    For example, see the function <samp class="SANS_TheSansMonoCd_W5Regular_11">expNN()</samp>
    of the Go language, whose source code is available at *[https://<wbr>go<wbr>.dev<wbr>/src<wbr>/math<wbr>/big<wbr>/nat<wbr>.go](https://go.dev/src/math/big/nat.go)*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有严肃的系统都会实现这种最简单的平方和乘法方法的某个变体。一个变体是 *滑动窗口* 方法，它考虑比特块而不是单个比特来执行给定的乘法操作。例如，查看
    Go 语言中的函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">expNN()</samp>，其源代码可以在
    *[https://<wbr>go<wbr>.dev<wbr>/src<wbr>/math<wbr>/big<wbr>/nat<wbr>.go](https://go.dev/src/math/big/nat.go)*
    中找到。
- en: How secure are these square-and-multiply exponentiation algorithms? Unfortunately,
    the tricks to speed the process up often result in increased vulnerability against
    some attacks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些平方和乘法指数算法有多安全？不幸的是，加速过程的技巧通常会导致对某些攻击的脆弱性增加。
- en: The weakness of these algorithms stems from the fact that the exponentiation
    operations are heavily dependent on the exponent’s value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    operation in [Listing 10-5](chapter10.xhtml#Lis10-5) takes a different branch
    based on whether an exponent’s bit is 0 or 1\. If a bit is 1, an iteration of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is slower than
    it is for 0, and attackers who monitor the execution time of the RSA operation
    can exploit this time difference to recover a private exponent. This is called
    a *timing attack*. Attacks on hardware can distinguish 1 bit from 0 bits by monitoring
    the device’s power consumption and observing which iterations perform an extra
    multiplication to reveal which bits of the private exponent are 1.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法的弱点源于指数运算高度依赖于指数值的事实。在[列表10-5](chapter10.xhtml#Lis10-5)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>操作会根据指数的位是0还是1而采取不同的分支。如果某个位是1，那么<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环的一个迭代会比为0时慢，攻击者通过监控RSA操作的执行时间，可以利用这个时间差恢复私有指数。这就是所谓的*时序攻击*。对硬件的攻击可以通过监控设备的功耗来区分1位和0位，并观察哪些迭代执行额外的乘法，从而揭示私有指数中哪些位是1。
- en: Depending on the type of platform, the information channel may not be execution
    time. For example, you might distinguish 1-bits in the exponent from 0-bits by
    measuring the device’s power consumption and observing which iterations perform
    additional multiplication, revealing the private exponent bits at 1\. This is
    a *power-analysis attack*. Few open source cryptographic libraries contain effective
    defenses against these types of attacks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 根据平台的不同，信息通道可能不是执行时间。例如，您可能通过测量设备的功耗并观察哪些迭代执行额外的乘法来区分指数中的1位和0位，从而揭示私有指数位为1的部分。这是一种*功耗分析攻击*。很少有开源加密库能够有效防御这些类型的攻击。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Small Exponents for
    Faster Public-Key Operations</samp>
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">较小的指数以实现更快的公钥操作</samp>
- en: Because an RSA computation is essentially the computation of an exponentiation,
    its performance depends on the value of the numbers involved, in particular the
    exponent. Smaller exponents require fewer multiplications and can therefore make
    the exponentiation computation much faster.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为RSA计算本质上是指数运算，所以其性能取决于涉及数字的大小，特别是指数。较小的指数需要更少的乘法，因此可以使指数运算更快。
- en: In principle, the public exponent *e* can be any value between 3 and φ(*n*)
    – 1, as long as *e* and φ(*n*) are coprime. But in practice you’ll find only small
    values of *e*, and most of the time *e* = 65,537 due to concerns with encryption
    and signature verification speed. For example, the Microsoft Windows CryptoAPI
    supports only public exponents that fit in a 32-bit integer. The larger the *e*,
    the slower it is to compute *x**^e* mod *n.*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，公共指数*e*可以是介于3和φ(*n*) - 1之间的任何值，只要*e*与φ(*n*)互质。但实际上，你会发现只有小的*e*值，而且大多数情况下，*e*
    = 65,537是由于加密和签名验证速度的考虑。例如，Microsoft Windows CryptoAPI仅支持适合32位整数的公共指数。*e*越大，计算*x**^e*
    mod *n*的速度就越慢。
- en: Unlike the size of the public exponent, the private exponent *d* is inevitably
    about as large as *n*, making decryption much slower than encryption, and signing
    much slower than verification. Because *d* is secret, it must be unpredictable
    and therefore can’t be restricted to a small value. For example, if *e* is fixed
    to 65,537, the corresponding *d* is usually of the same order of magnitude as
    the modulus *n*, which would be close to 2^(2,048) if *n* is 2,048 bits long.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与公共指数的大小不同，私有指数*d*的大小不可避免地接近*n*，使得解密比加密慢得多，签名比验证慢得多。因为*d*是秘密的，它必须是不可预测的，因此不能限制为一个小值。例如，如果*e*固定为65,537，则相应的*d*通常与模数*n*的数量级相同，如果*n*是2048位长，*d*将接近2^(2,048)。
- en: As discussed in “A Fast Exponentiation Algorithm” on [page 206](#sec14), raising
    a number to the power 65,537 takes 17 multiplications, whereas raising a number
    to the power of some 2,048-bit number takes on the order of 3,000 multiplications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在“快速指数算法”中讨论的那样，在[第206页](#sec14)，将一个数提升到65,537次方需要17次乘法，而将一个数提升到某个2048位数的次方需要大约3000次乘法。
- en: 'You can estimate the speed of RSA by using the OpenSSL toolkit. For example,
    [Listing 10-6](chapter10.xhtml#Lis10-6) shows the results of 512-, 1,024-, 2,048-,
    and 4,096-bit RSA operations on a MacBook equipped with an M2 chipset:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用OpenSSL工具包来估算RSA的速度。例如，[列表 10-6](chapter10.xhtml#Lis10-6)展示了在配备M2芯片组的MacBook上进行512位、1,024位、2,048位和4,096位RSA操作的结果：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Example benchmarks
    of RSA operations using the OpenSSL toolkit (version 3.2.0)</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 10-6：使用OpenSSL工具包（版本3.2.0）进行RSA操作的示例基准测试</samp>
- en: To get an idea of how much slower verification is compared to signature generation,
    compute the ratio of the verification time over signature time. The benchmarks
    in [Listing 10-6](chapter10.xhtml#Lis10-6) show that I’ve got verification-over-signature
    speed ratios of approximately 21.6, 40.1, and 68.7 for 1,024-, 2,048-, and 4,096-bit
    moduli, respectively. The gap grows with the modulus size because the number of
    multiplications for *e* operations remains constant with respect to the modulus
    size (for example, 17 operations when *e* = 65,537), while private-key operations
    always need more multiplications for a greater modulus because *d* grows accordingly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解验证相较于签名生成的速度慢多少，可以计算验证时间与签名时间的比率。[列表 10-6](chapter10.xhtml#Lis10-6)中的基准测试显示，对于1,024位、2,048位和4,096位模数，我得到的验证与签名速度比大约分别为21.6、40.1和68.7。随着模数大小的增加，这一差距会变大，因为*e*操作所需的乘法次数对于模数大小保持不变（例如，当*e*
    = 65,537时为17次操作），而私钥操作则需要更多的乘法，因为*d*也相应增大。
- en: 'If small exponents are so nice, why use 65,537 and not something like 3? It
    would actually be fine (and faster) to use 3 as an exponent when implementing
    RSA with a secure scheme such as OAEP, PSS, or FDH. Cryptographers avoid doing
    so, however, because when *e* = 3, less secure schemes make certain types of mathematical
    attacks possible. The number 65,537 is large enough to avoid such *low-exponent
    attacks*, and it has only two nonzero bits, which decreases the computation time
    when computing *x*^(65,537). The number 65,537 is also special for mathematicians:
    it’s the fourth Fermat number, or a number of the form'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果小指数如此有优势，为什么不使用65,537而选择像3这样的数呢？实际上，当使用OAEP、PSS或FDH等安全方案实现RSA时，使用3作为指数是可以的，甚至更快。然而，加密学家避免这么做，因为当*e*
    = 3时，某些不安全的方案可能会导致特定类型的数学攻击。数字65,537足够大，可以避免这种*低指数攻击*，而且它只有两个非零位，这在计算*x*^(65,537)时可以减少计算时间。对于数学家来说，65,537还是一个特殊的数字：它是第四个费马数，或者是形如
- en: '![](../images/pg209-1.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg209-1.jpg)'
- en: 'because it’s equal to 2^(16) + 1, where 16 = 2⁴, but that’s a curiosity irrelevant
    to most cryptographic engineers.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The
    Chinese Remainder Theorem</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '因为它等于2^(16) + 1，其中16 = 2⁴，但这对大多数加密工程师来说只是一个与主题无关的好奇心。 #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">中国剩余定理</samp>'
- en: The most common trick to speed up decryption and signature generation (that
    is, the computation of *y**^d* mod *n*) is the *Chinese remainder theorem (CRT)*,
    which makes RSA about four times faster.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 加速解密和签名生成（即计算*y**^d* mod *n*）的最常见技巧是*中国剩余定理（CRT）*，它能让RSA速度提高约四倍。
- en: The CRT allows for faster decryption by computing two exponentiations, modulo
    *p* and modulo *q*, rather than a single one modulo *n*. Because *p* and *q* are
    much smaller than *n*, it’s faster to perform two “small” exponentiations than
    a single “big” one.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CRT通过计算两个模*p*和模*q*的指数，而不是单一的模*n*指数，从而加速解密。由于*p*和*q*远小于*n*，因此执行两个“小”指数运算比执行一个“大”指数运算要快。
- en: 'The Chinese remainder theorem isn’t specific to RSA. It’s a general arithmetic
    result that, in its simplest form, states that if *n* = *n*[1]*n*[2]*n*[3] . .
    . , where the *n*is are pairwise coprime (that is, **GCD**(*n*i, *n*j) = 1 for
    any distinct *i* and *j*), then one can compute the value *x* mod *n* from the
    values *x* mod *n*[1], *x* mod *n*[2], *x* mod *n*[3], . . . For example, say
    you have *n* = 1,155, which is the product of prime factors 3 × 5 × 7 × 11, and
    say you want to determine *x* that satisfies *x* mod 3 = 2, *x* mod 5 = 1, *x*
    mod 7 = 6, and *x* mod 11 = 8\. (I’ve chosen 2, 1, 6, and 8 arbitrarily.) To find
    *x* using the Chinese remainder theorem, compute the sum *P*(*n*[1]) + *P*(*n*[2])
    + . . . , where *P*(*n*i) is defined as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 中国剩余定理并不特定于RSA。它是一个通用的算术结果，简单形式为：如果 *n* = *n*[1]*n*[2]*n*[3] . . . ，其中 *n*is
    是两两互质的（即 **GCD**(*n*i, *n*j) = 1 对于任何不同的 *i* 和 *j*），那么就可以从 *x* mod *n*[1]，*x*
    mod *n*[2]，*x* mod *n*[3]，. . . 的值中计算出 *x* mod *n*。例如，假设你有 *n* = 1,155，这是素因数 3
    × 5 × 7 × 11 的乘积，并且你想要确定 *x*，使得 *x* mod 3 = 2，*x* mod 5 = 1，*x* mod 7 = 6，*x*
    mod 11 = 8。（我随意选择了 2、1、6 和 8。）使用中国剩余定理来找到 *x*，计算 *P*(*n*[1]) + *P*(*n*[2]) + .
    . .，其中 *P*(*n*i) 定义如下：
- en: '![](../images/pg210-1.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg210-1.jpg)'
- en: Note that the second term, *n*/*n*i, is equal to the product of all factors
    other than this *n*i.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第二项 *n*/*n*i 等于除这个 *n*i 外所有因子的乘积。
- en: 'To apply this formula to this example and recover *x* mod 1155, compute *P*(3),
    *P*(5), *P*(7), and *P*(11); then add them together to get the following expression:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个公式应用于本例并恢复 *x* mod 1155，计算 *P*(3)，*P*(5)，*P*(7)，和 *P*(11)；然后将它们加起来，得到如下表达式：
- en: '![](../images/pg210-2.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg210-2.jpg)'
- en: Here, I’ve just applied the preceding definition of *P*(*n*i). (The math behind
    finding each number is straightforward, but I won’t detail it here.) You can then
    reduce this expression to [770 + 231 + 1980 + 1680] mod *n* = 41\. As 41 is the
    number I’d picked for this example, you’ve got the correct result.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我刚刚应用了前面定义的*P*(*n*i)。（计算每个数字的数学原理很简单，但我不会在这里详细说明。）然后，你可以将这个表达式简化为[770 +
    231 + 1980 + 1680] mod *n* = 41。由于41是我为这个示例选择的数字，所以你得到了正确的结果。
- en: 'Applying the CRT to RSA is simpler than the previous example because there
    are only two factors for each *n* (namely, *p* and *q*). Given a ciphertext *y*
    to decrypt, instead of computing *y**^d* mod *n*, use the CRT to compute *x*p
    = *y**^s* mod *p*, where *s* = *d* mod (*p* – 1) and *x*q = *y**^t* mod *q*, where
    *t* = *d* mod (*q* – 1). Combine these two expressions and compute *x* to be the
    following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将中国剩余定理应用于RSA比前面的示例更简单，因为每个 *n* 只有两个因子（即 *p* 和 *q*）。给定一个密文 *y* 需要解密时，代替计算 *y**^d*
    mod *n*，使用中国剩余定理计算 *x*p = *y**^s* mod *p*，其中 *s* = *d* mod (*p* – 1)，并且 *x*q =
    *y**^t* mod *q*，其中 *t* = *d* mod (*q* – 1)。将这两个表达式结合起来并计算 *x*，得到如下：
- en: '![](../images/pg210-3.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg210-3.jpg)'
- en: That’s it. This is faster than a single exponentiation even with the square-and-multiply
    trick because the multiplication-heavy operations are carried out on modulo *p*
    and *q*, numbers that are twice as small as *n*, whereas the complexity of exponentiation
    increases faster than linearly. When you double the size of the number, you don’t
    just double the cost of exponentiation—it grows faster.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这比单次指数运算要快，即使使用了平方乘法技巧，因为涉及大量乘法的运算是在模 *p* 和 *q* 上进行的，而这两个数字的大小是 *n* 的一半，而指数运算的复杂度比线性增长还要快。当你将数字的大小加倍时，你不仅仅是将指数运算的成本加倍，它增长得更快。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In the final operation, you can compute the two numbers* q *× (1/*q *mod*
    p*) and* p *× (1/*p *mod* q*) in advance, which means you need to compute only
    two multiplications and an addition of modulo* n *to find* x.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*在最终操作中，你可以提前计算两个数字* q *× (1/*q *mod* p*) 和* p *× (1/*p *mod* q*)，这意味着你只需要计算两个乘法和一次模
    *n* 的加法来找到 *x*。'
- en: Unfortunately, there’s a security caveat attached to these techniques.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些技术存在一个安全警告。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">出错的方式</samp>
- en: Even more elegant than the RSA scheme itself is the range of attacks that work
    either because the implementation leaks (or can be made to leak) information on
    its internals or because RSA is used insecurely. I discuss two classic examples
    of these types of attacks in the sections that follow.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 比RSA方案本身更优雅的是一系列攻击，这些攻击之所以有效，要么是因为实现过程泄露（或者可以被设计为泄露）了关于内部信息，要么是因为RSA被不安全地使用。我将在接下来的章节中讨论两种经典的这类攻击示例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Bellcore Attack
    on RSA-CRT</samp>
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bellcore 攻击与 RSA-CRT</samp>
- en: The Bellcore attack on RSA is one of the most important attacks in the history
    of RSA. First discovered in 1996, it stood out because it exploited RSA’s vulnerability
    to *fault injections*—attacks that force part of the algorithm to misbehave and
    potentially yield incorrect results. For example, one may temporarily perturb
    hardware circuits or embedded systems by suddenly altering their voltage supply
    or beaming a laser pulse to a carefully chosen part of a chip. Attackers can then
    exploit the resulting faults in an algorithm’s internals by observing the impact
    on the result. Comparing the correct result with a faulty one can provide information
    on the algorithm’s internal values, including secret values. Likewise, attempts
    to learn whether the result is valid might leak exploitable information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 上的 Bellcore 攻击是 RSA 历史上最重要的攻击之一。它最早于 1996 年被发现，之所以突出，是因为它利用了 RSA 对 *故障注入*（故意使算法一部分发生故障并可能产生错误结果）的脆弱性。例如，攻击者可以通过突然改变电压供应或向芯片的某个特定部位发射激光脉冲，暂时扰乱硬件电路或嵌入式系统。然后，攻击者可以通过观察结果的影响，利用算法内部故障的结果。通过将正确结果与故障结果进行比较，可以提供关于算法内部值的信息，包括秘密值。同样，尝试验证结果是否有效也可能泄露可被利用的信息。
- en: The Bellcore attack is such a fault attack. It works on RSA signature schemes
    that use the Chinese remainder theorem and that are deterministic—meaning it works
    on FDH but not on PSS, which is probabilistic.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Bellcore 攻击就是这样一种故障攻击。它适用于使用中国剩余定理且是确定性的 RSA 签名方案——这意味着它适用于 FDH，但不适用于 PSS，后者是概率性的。
- en: 'To understand the Bellcore attack, recall from the previous section that with
    CRT, you obtain the result that’s equal to *x**^d* mod *n* by computing the following,
    where *x*p = *y**^s* mod *p* and *x*q = *y**^t* mod *q*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Bellcore 攻击，请回顾上一节的内容，在使用中国剩余定理时，通过计算以下内容，你得到的结果等于 *x**^d* mod *n*，其中 *x*p
    = *y**^s* mod *p*，*x*q = *y**^t* mod *q*：
- en: '![](../images/pg211-1.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg211-1.jpg)'
- en: 'Now assume that an attacker induces a fault in the computation of *x*q so that
    you end up with some incorrect value, which differs from the actual *x*q. Let’s
    call this incorrect value *x*q′ and the final result obtained *x*′. The attacker
    can then subtract the incorrect signature *x*′ from the correct signature *x*
    to factor *n*, which results in the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设攻击者在计算 *x*q 时诱发故障，使得你得到某个不正确的值，该值与实际的 *x*q 不同。我们将这个不正确的值称为 *x*q′，最终得到的结果称为
    *x*′。攻击者随后可以将不正确的签名 *x*′ 从正确签名 *x* 中减去，从而因式分解 *n*，结果如下：
- en: '![](../images/pg211-2.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg211-2.jpg)'
- en: The value *x* – *x*′ is therefore a multiple of *p*, so *p* is a divisor of
    *x* – *x*′. Because *p* is also a divisor of *n*, the greatest common divisor
    of *n* and *x* – *x*′ yields *p*, **GCD**(*x* – *x*′, *n*) = *p*. You can then
    compute *q* = *n*/*p* and *d*, resulting in a total break of RSA signatures.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*x* – *x*′ 的值是 *p* 的倍数，所以 *p* 是 *x* – *x*′ 的约数。因为 *p* 也是 *n* 的约数，所以 *n* 和
    *x* – *x*′ 的最大公约数为 *p*，**GCD**(*x* – *x*′, *n*) = *p*。然后你可以计算 *q* = *n*/*p* 和
    *d*，从而完全破解 RSA 签名。
- en: A variant of this attack works when you know only that the message is signed,
    and not the correct signature. There’s also a similar fault attack on the modulus
    value, rather than on the CRT values computation, but I won’t go into detail on
    that here.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击的变种在你只知道消息已签名而不知道正确签名的情况下有效。还有一种类似的故障攻击针对模数值，而不是针对中国剩余定理（CRT）值的计算，但我在这里不打算详细讨论。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shared Private Exponents
    or Moduli</samp>
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">共享私有指数或模数</samp>
- en: Now I’ll show you why your public key shouldn’t have the same modulus *n* as
    that of someone else.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将向你展示为什么你的公钥不应与他人的模数 *n* 相同。
- en: Private keys belonging to different systems or people should have different
    private exponents, *d*, even if the keys use different moduli. Or you could try
    your own value of *d* to decrypt messages encrypted for other entities, until
    you hit one that shares the same *d*. By the same token, different key pairs should
    have different *n* modulus values, even if they have different *d*s, because *p*
    and *q* are usually part of the private key. Hence, if I share the same *n* and
    thus the same *p* and *q*, I can compute your private key from your public key
    *e* using *p* and *q*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不同系统或不同人的私钥应该有不同的私有指数 *d*，即使它们使用不同的模数。或者你也可以尝试自己设置 *d* 值来解密为其他实体加密的消息，直到你找到一个与之共享相同
    *d* 的密钥。类似地，不同的密钥对应该有不同的 *n* 模数值，即使它们有不同的 *d*，因为 *p* 和 *q* 通常是私钥的一部分。因此，如果我与别人共享相同的
    *n*，从而拥有相同的 *p* 和 *q*，我就可以利用 *p* 和 *q* 从你的公钥 *e* 计算出你的私钥。
- en: Imagine that you know your private exponent *d*[1] and the public exponent *e*[2]
    of another person with whom you share the same modulus *n*, but without knowing
    its factors *p* and *q*. How can you calculate *p* and *q* from your private exponent
    *d*[1] to find the private exponent *d*[2] of the other person? The solution is
    a bit technical but elegant.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你知道你自己的私有指数 *d*[1] 和另一个与你共享相同模数 *n* 的人的公有指数 *e*[2]，但不知道其因子 *p* 和 *q*。那么，你如何从你自己的私有指数
    *d*[1] 计算出 *p* 和 *q*，进而找到另一个人的私有指数 *d*[2] 呢？这个解决方案有点技术性，但非常优雅。
- en: Remember that *d* and *e* satisfy *ed* = *k*φ(*n*) + 1, where φ(*n*) is secret
    and could reveal *p* and *q*. You don’t know *k* or φ(*n*), but you can compute
    *k*φ(*n*) = *ed* – 1.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*d* 和 *e* 满足 *ed* = *k*φ(*n*) + 1，其中 φ(*n*) 是秘密的，可能揭示出 *p* 和 *q*。你不知道 *k*
    或 φ(*n*)，但你可以计算出 *k*φ(*n*) = *ed* – 1。
- en: 'What can you do with *k*φ(*n*)? According to *Euler’s theorem*, for any number
    *a* coprime with *n*, you have *a*^(φ()*^n*^) = 1 mod *n*. Therefore, modulo *n*
    you have the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 *k*φ(*n*) 做什么呢？根据 *欧拉定理*，对于与 *n* 互质的任何数字 *a*，都有 *a*^(φ()*^n*^) = 1 mod
    *n*。因此，模 *n* 下，你可以得到以下结果：
- en: '![](../images/pg212-1.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg212-1.jpg)'
- en: Because *k*φ(*n*) is an even number, you can write it as 2*^s**t* for some numbers
    *s* and *t*. That is, you’ll be able to write *a**^k*^(φ()*^n*^) = 1 mod *n* under
    the form *x*² = 1 mod *n* for some *x* easily computed from *k*φ(*n*). You can
    call such an *x* a *root of unity*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *k*φ(*n*) 是一个偶数，你可以将其写成 2*^s**t* 的形式，其中 *s* 和 *t* 是某些数字。也就是说，你可以将 *a**^k*^(φ()*^n*^)
    = 1 mod *n* 表示为 *x*² = 1 mod *n*，其中 *x* 是从 *k*φ(*n*) 计算出来的。你可以称这种 *x* 为 *单位根*。
- en: The key observation is that *x*² = 1 mod *n* is equivalent to saying that the
    value *x*² – 1 = (*x* – 1)(*x* + 1) divides *n*. In other words, *x* – 1 or *x*
    + 1 must have a common factor with *n*, which can give you the factorization of
    *n*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的观察是，*x*² = 1 mod *n* 等价于 *x*² – 1 = (*x* – 1)(*x* + 1) 整除 *n*。换句话说，*x* –
    1 或 *x* + 1 必须与 *n* 有共同因子，这样就能得到 *n* 的因式分解。
- en: '[Listing 10-7](chapter10.xhtml#Lis10-7) shows a Python implementation of this
    method where, to find the factors *p* and *q* from *n* and *d*, I use small, 64-bit
    numbers for the sake of simplicity.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-7](chapter10.xhtml#Lis10-7) 展示了该方法的 Python 实现，在此实现中，为了简化，我使用了小的 64 位数字来从
    *n* 和 *d* 中找出因子 *p* 和 *q*。'
- en: '[PRE7]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: A Python program
    that computes the prime factors</samp> <samp class="SANS_Futura_Std_Book_11">p</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_11">q</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">from the private exponent</samp>
    <samp class="SANS_Futura_Std_Book_11">d</samp>'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-7：一个计算质因数的 Python 程序</samp>
    <samp class="SANS_Futura_Std_Book_11">p</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_11">q</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">从私有指数</samp>
    <samp class="SANS_Futura_Std_Book_11">d</samp>
- en: 'This program determines *k*φ(*n*) from *e* and *d* ❶ by finding the number
    *t* such that *k*φ(*n*) = 2*^s**t*, for some *s* ❷. Then it looks for *a* and
    *k* such that (*a**^k*)² = 1 mod *n* ❸, using *t* as a starting point for *k*
    ❹. When this condition is satisfied ❺, you’ve found a solution. It then determines
    the factor *p* ❻ and verifies ❼ that the value of *pq* equals the value of *n.*
    It then prints the resulting values of *p* and *q*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序通过找到数字 *t* 使得 *k*φ(*n*) = 2*^s**t*，来从 *e* 和 *d* ❶ 确定 *k*φ(*n*)，其中 *s* ❷ 是某个数。然后，它寻找
    *a* 和 *k* 使得 (*a**^k*)² = 1 mod *n* ❸，以 *t* 作为 *k* 的起点 ❹。当这个条件得到满足 ❺，你就找到了一个解。接下来，它确定因子
    *p* ❻ 并验证 ❼ *pq* 的值是否等于 *n* 的值。最后，它打印出结果值 *p* 和 *q*：
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The program correctly returns the two factors.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序正确地返回了两个因子。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进一步阅读</samp>
- en: RSA deserves a book by itself. I had to omit many important and interesting
    topics, such as Daniel Bleichenbacher’s padding oracle attack on OAEP’s predecessor
    (the standard PKCS#1 v1.5) or Manger’s padding oracle attack on OAEP, both attacks
    being similar in spirit to the padding oracle attack on block ciphers in [Chapter
    4](chapter4.xhtml). There’s also Michael Wiener’s attack on RSA with low private
    exponents, and attacks using Coppersmith’s method on RSA with small exponents
    that potentially also have insecure padding.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: RSA值得专门写一本书。我不得不省略了许多重要且有趣的主题，比如丹尼尔·布莱辛巴赫（Daniel Bleichenbacher）对OAEP前身（标准PKCS#1
    v1.5）进行的填充oracle攻击，或者曼格（Manger）对OAEP的填充oracle攻击，这两种攻击在精神上与[第4章](chapter4.xhtml)中描述的块加密的填充oracle攻击类似。还有迈克尔·维纳（Michael
    Wiener）针对具有低私钥指数的RSA攻击，以及使用科珀史密斯（Coppersmith）方法攻击具有小指数的RSA，并且这些攻击可能也存在不安全的填充。
- en: To see research results related to side-channel attacks and defenses, view the
    CHES workshop proceedings that have run since 1999 at *[https://<wbr>ches<wbr>.iacr<wbr>.org](https://ches.iacr.org)*.
    One of the most useful references while writing this chapter was Dan Boneh’s “Twenty
    Years of Attacks on the RSA Cryptosystem,” a survey that reviews and explains
    the most important attacks on RSA. For reference on timing attacks, the paper
    “Remote Timing Attacks Are Practical” by Billy Bob Brumley and Dan Boneh is a
    must-read, both for its analytical and experimental contributions. To learn more
    about fault attacks, read the full version of the Bellcore attack paper “On the
    Importance of Eliminating Errors in Cryptographic Computations” by Dan Boneh,
    Richard DeMillo, and Richard Lipton.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看与侧信道攻击及其防御相关的研究成果，请访问自1999年以来举行的CHES研讨会论文集，网址为*[https://<wbr>ches<wbr>.iacr<wbr>.org](https://ches.iacr.org)*。在撰写本章时，最有用的参考之一是丹·博内（Dan
    Boneh）的《RSA密码系统二十年攻击回顾》（Twenty Years of Attacks on the RSA Cryptosystem），这篇综述回顾并解释了针对RSA的最重要攻击。关于时间攻击的参考文献，必读的是比利·鲍勃·布鲁姆利（Billy
    Bob Brumley）和丹·博内的论文《远程时间攻击是可行的》（Remote Timing Attacks Are Practical），它不仅在分析上做出了贡献，而且在实验上也非常重要。要深入了解故障攻击，请阅读丹·博内、理查德·德米洛（Richard
    DeMillo）和理查德·利普顿（Richard Lipton）合著的《消除密码计算中的错误的重要性》（On the Importance of Eliminating
    Errors in Cryptographic Computations）的Bellcore攻击论文完整版。
- en: The best way to learn how RSA implementations work, though sometimes painful
    and frustrating, is to review the source code of widely used implementations.
    For example, see RSA and its underlying big-number arithmetic implementations
    in OpenSSL, NSS (the library used by the Mozilla Firefox browser), Crypto++, or
    other popular software, and examine their implementations of arithmetic operations
    as well as their defenses against timing and fault attacks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 学习RSA实现工作原理的最佳方法，虽然有时痛苦且令人沮丧，就是审查广泛使用的实现的源代码。例如，查看OpenSSL、NSS（Mozilla Firefox浏览器使用的库）、Crypto++或其他流行软件中RSA及其底层大数算术的实现，研究它们的算术运算实现以及它们对时间攻击和故障攻击的防御。
