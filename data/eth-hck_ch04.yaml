- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: CRAFTING TCP SHELLS AND BOTNETS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建 TCP 反向连接和僵尸网络**'
- en: '*The cause is hidden. The effect is visible to all.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*原因隐藏，结果显而易见。*'
- en: –Ovid
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: –欧维德
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: So, you’ve intercepted a victim’s traffic. Let’s say you discovered that the
    victim works at a particular company. You decide to break into the company’s server
    and upload a program called a *reverse shell* that allows you to remotely execute
    commands on that server. The reverse shell lets you maintain access to the server
    even after the company fixes the vulnerability that let you gain access in the
    first place. This chapter explains how attackers do this and shows you how to
    execute this attack yourself. I’ll begin by explaining the fundamentals of socket
    programming. Then, you’ll apply these fundamentals to write your own reverse shell.
    Lastly, I’ll conclude by analyzing a real-world botnet that infected more than
    300,000 machines and show you how to write your own botnet.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你截获了一个受害者的流量。假设你发现受害者在某家公司工作。你决定入侵公司的服务器并上传一个名为*反向连接*的程序，该程序允许你远程执行该服务器上的命令。反向连接使你即使在公司修复了让你第一次入侵的漏洞后，依然能保持对服务器的访问。本章将解释攻击者是如何做到这一点的，并展示你如何亲自执行这一攻击。我将从解释套接字编程的基础知识开始。接着，你将应用这些基础知识来编写自己的反向连接。最后，我将通过分析一个现实世界的僵尸网络案例，该网络感染了超过30万台计算机，并展示你如何编写自己的僵尸网络。
- en: '**Sockets and Process Communication**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**套接字和进程通信**'
- en: 'Before you can design your own reverse shell, you must first understand the
    basics of socket programming. A *socket* is an API that allows programs to communicate
    over the network. There are two types of sockets: TCP and UDP. TCP sockets use
    the TCP protocol, as mentioned in [Chapter 2](ch02.xhtml#ch2). They ensure that
    all data sent over the network is reliably delivered. In contrast, UDP sockets
    trade reliability for speed. You’ll often find UDP sockets used in audio or video
    call applications where real-time delivery of packets is important. In this chapter,
    you’ll use TCP sockets.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在你设计自己的反向连接之前，必须先了解套接字编程的基础知识。*套接字*是一个API，允许程序通过网络进行通信。套接字有两种类型：TCP和UDP。如[第2章](ch02.xhtml#ch2)中提到的，TCP套接字使用TCP协议，确保所有通过网络发送的数据都能可靠地传输。相反，UDP套接字则以速度为优先，牺牲可靠性。你会经常看到UDP套接字用于音频或视频通话应用程序中，因为这些应用程序要求数据包实时传输。在本章中，你将使用TCP套接字。
- en: '***TCP Handshakes***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TCP 三次握手***'
- en: Internet routers are designed to process millions of packets per second. However,
    during peak hours, routers can become overwhelmed and delete packets, which is
    just one of the many ways that packets are lost. So how is it possible to reliably
    deliver packets over a network that deletes them? TCP achieves this by keeping
    track of all the packets it transmits. Each packet is assigned a *sequence number*
    representing its place in the sequence of transmitted packets. If a sequence number
    is missing, TCP will know the packet was lost and retransmit it. [Figure 4-1](ch04.xhtml#ch4fig1)
    shows how an image, represented in bits, is converted into TCP packets with sequence
    numbers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网路由器被设计成每秒处理数百万个数据包。然而，在高峰时段，路由器可能会被压垮并删除数据包，这只是数据包丢失的众多方式之一。那么，如何在一个会删除数据包的网络中可靠地传输数据包呢？TCP通过跟踪所有传输的数据包来实现这一点。每个数据包都会被分配一个*序列号*，表示它在传输数据包中的位置。如果某个序列号丢失，TCP就知道该数据包丢失并会重新传输它。[图
    4-1](ch04.xhtml#ch4fig1)展示了如何将一个用比特表示的图像转换成带有序列号的TCP数据包。
- en: '![image](../images/ch04fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch04fig01.jpg)'
- en: '*Figure 4-1: How a file is converted into packets with sequence numbers*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：文件如何被转换为带有序列号的数据包*'
- en: Images, text files, programs, and all other data stored in your computer are
    represented as binary data. Before a file can be transmitted, it must be encapsulated
    into a packet. However, TCP packets have a maximum size of 64KB, so files larger
    than this are divided and placed into several TCP packets. Each packet is assigned
    a *sequence number* so that the file can be reassembled. Sequence numbers are
    consecutive, which allows the recipient to determine the proper order in which
    to interpret the packets; however, each machine starts the sequence with a random
    number to keep hackers from predicting the sequence.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图像、文本文件、程序以及你计算机中存储的所有其他数据都以二进制数据的形式表示。在文件可以传输之前，它必须被封装成一个数据包。然而，TCP数据包的最大大小为64KB，因此大于此大小的文件会被拆分并放入多个TCP数据包中。每个数据包都会分配一个*序列号*，以便能够重新组装文件。序列号是连续的，这使得接收方能够确定数据包的正确顺序；然而，每台计算机都从一个随机数开始序列，以防止黑客预测序列号。
- en: Before two machines can transmit their packets, they must both receive and acknowledge
    the other machine’s starting sequence number so that they can keep track of any
    lost packets. This exchange is a called the *TCP three-way handshake*. [Figure
    4-2](ch04.xhtml#ch4fig2) shows how messages are exchanged in the handshake. If
    a machine responds to the handshake, it means that the server is willing to communicate
    on that port.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在两台机器能够传输数据包之前，它们必须都接收并确认对方的起始序列号，以便能够跟踪丢失的数据包。这个交换过程称为*TCP三次握手*。[图4-2](ch04.xhtml#ch4fig2)展示了握手中消息是如何交换的。如果一台机器回应了握手请求，就意味着服务器愿意在该端口进行通信。
- en: '![image](../images/ch04fig02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch04fig02.jpg)'
- en: '*Figure 4-2: How the TCP three-way handshake is used to establish the communication
    channel*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：TCP三次握手如何用于建立通信通道*'
- en: A client initiates a TCP connection by sending the server a *SYN packet*, which
    is a TCP packet with the SYN flag set to true. This SYN packet also contains the
    client’s starting sequence number. For instance, sending a SYN(3) packet is like
    saying “Hello, my starting sequence number is 3\. What is yours?” Once the server
    receives the SYN packet, it records the client’s sequence number and responds
    by sending a SYN-ACK packet, which has both the SYN and ACK flags set to true.
    This SYN-ACK packet acknowledges receipt of the client’s sequence number and sends
    the server’s sequence number. For example, a SYN(0) ACK(4) packet is equivalent
    to saying, “My starting sequence number is 0, and I expect you to send packet
    4 next.” However, the connection isn’t established until the server receives an
    ACK packet notifying it that the client has received its sequence number and is
    expecting the next value in the sequence.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过发送一个*SYN数据包*来发起TCP连接，该数据包是一个SYN标志设置为true的TCP数据包。这个SYN数据包还包含客户端的起始序列号。例如，发送一个SYN(3)数据包就像是在说：“你好，我的起始序列号是3，您的是多少？”当服务器收到SYN数据包后，它记录下客户端的序列号，并通过发送一个SYN-ACK数据包进行响应，SYN-ACK数据包的SYN和ACK标志都被设置为true。这个SYN-ACK数据包确认已接收到客户端的序列号，并发送服务器的序列号。例如，SYN(0)
    ACK(4)数据包相当于在说：“我的起始序列号是0，我希望你接下来发送数据包4。”但是，直到服务器收到一个ACK数据包，通知它客户端已收到其序列号并期待序列中的下一个值，连接才会建立。
- en: When the systems have finished exchanging packets, they close the connection
    by exchanging FIN and ACK packets. [Figure 4-3](ch04.xhtml#ch4fig3) shows this
    FIN-ACK exchange.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统完成数据包交换后，它们通过交换FIN和ACK数据包来关闭连接。[图4-3](ch04.xhtml#ch4fig3)展示了这种FIN-ACK交换。
- en: '![image](../images/ch04fig03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch04fig03.jpg)'
- en: '*Figure 4-3: How FIN-ACK packets are used to close the channel*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：如何使用FIN-ACK数据包关闭通道*'
- en: TCP allows for *full duplex* communication, which means that both the sender
    and receiver can transmit data at the same time. In contrast, in *half duplex*
    communication, only one party can transmit at a time. Walkie-talkies are half
    duplex; one person must give up the channel before the other person can speak.
    In contrast, cell phones are full duplex, as both parties can talk at the same
    time. Because a TCP connection is full duplex, both machines must send messages
    to close the connection. After one machine sends a FIN packet, it must wait until
    the other machine also sends a FIN packet before closing the connection.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: TCP允许*全双工*通信，这意味着发送方和接收方可以同时传输数据。相反，在*半双工*通信中，只有一方可以同时传输数据。对讲机是半双工的；一个人必须放弃通道，另一个人才能说话。相比之下，手机是全双工的，因为双方可以同时交谈。由于TCP连接是全双工的，因此两台机器必须都发送消息来关闭连接。一个机器发送FIN数据包后，必须等待另一台机器也发送FIN数据包后才能关闭连接。
- en: '***A TCP Reverse Shell***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个TCP反向Shell***'
- en: TCP sockets are the fundamental building blocks of network applications. For
    example, utilities such as secure shell (SSH) use sockets to connect to remote
    servers. Once a hacker compromises a machine, they can install an SSH server and
    control the machine using an SSH client. However, many organizations have routers
    that run firewalls and implement network address translation (NAT), a feature
    that we’ll examine in [Chapter 8](ch08.xhtml#ch8). These features prevent machines
    outside the network from initiating connections to servers inside the network.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TCP套接字是网络应用程序的基本构建模块。例如，像安全外壳（SSH）这样的工具使用套接字连接到远程服务器。一旦黑客攻破了一台机器，他们可以安装一个SSH服务器，并使用SSH客户端控制该机器。然而，许多组织的路由器上运行着防火墙并实现了网络地址转换（NAT），这是我们将在[第8章](ch08.xhtml#ch8)中讨论的一个特性。这些功能阻止了网络外部的机器发起连接到网络内部的服务器。
- en: 'However, many firewalls allow the reverse: machines inside the network can
    still initiate connections to machines outside the network. This allows employees
    to access Google while preventing outside attackers from using SSH clients to
    connect to the organization’s servers. [Figure 4-4](ch04.xhtml#ch4fig4) shows
    an overview of this idea.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多防火墙允许相反的情况：网络内的计算机仍然可以发起连接到网络外的计算机。这使得员工可以访问 Google，同时防止外部攻击者使用 SSH 客户端连接到组织的服务器。[图
    4-4](ch04.xhtml#ch4fig4) 显示了这一概念的概述。
- en: '![image](../images/ch04fig04.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch04fig04.jpg)'
- en: '*Figure 4-4: How firewalls and NAT block incoming connection, but not outgoing
    ones*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：防火墙和 NAT 如何阻止传入连接，但不阻止传出连接*'
- en: To circumvent the firewall and NAT, hackers can install a program called a reverse
    shell on the compromised machine that will initiate a connection from within the
    network to the attacker’s computer outside the network. After the reverse shell
    has connected to the hacker’s machine, the hacker can send commands to the reverse
    shell, which then will execute them on the organization’s server. Many shells
    will also mask their traffic by communicating on port 53 and encapsulating data
    in DNS packets.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过防火墙和 NAT，黑客可以在受感染的机器上安装一个名为反向 shell 的程序，该程序将从网络内部发起连接到网络外部的攻击者计算机。反向 shell
    连接到黑客的机器后，黑客可以向反向 shell 发送命令，然后它将在组织的服务器上执行这些命令。许多 shell 还会通过在端口 53 上进行通信并将数据封装在
    DNS 数据包中来掩盖它们的流量。
- en: 'A reverse shell consists of two parts: a component that connects to the attacker’s
    computer, and a shell component that allows an attacker to execute terminal commands
    on the victim’s machine. [Figure 4-5](ch04.xhtml#ch4fig5) shows how a reverse
    shell on the Metasploitable server communicates with a TCP server socket on the
    attacker’s Kali Linux machine.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 反向 shell 包含两个部分：一个连接到攻击者计算机的组件，以及一个允许攻击者在受害者机器上执行终端命令的 shell 组件。[图 4-5](ch04.xhtml#ch4fig5)
    显示了 Metasploitable 服务器上的反向 shell 如何与攻击者的 Kali Linux 机器上的 TCP 服务器套接字进行通信。
- en: '![image](../images/ch04fig05.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch04fig05.jpg)'
- en: '*Figure 4-5: How the TCP client and server communicate over the network*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：TCP 客户端和服务器如何通过网络进行通信*'
- en: When the client hosted on the Metasploitable machine is run, it requests a new
    socket from the operating system. Once the operating system has created the socket,
    it assigns it a port number and links the socket to the reverse shell. A similar
    process takes place on the Kali Linux machine, which is running a TCP server that
    requests a specific port number from the operating system. The unique combination
    of port number and IP address identifies the TCP server to TCP clients on other
    machines. When you’re developing your own servers, it’s a good idea to select
    large port numbers for them to run on because other applications on the device
    might already be using lower port numbers. The port field is 16 bits long, so
    the largest port number is 2^(16) – 1, or 65,535.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行托管在 Metasploitable 机器上的客户端时，它会向操作系统请求一个新的套接字。一旦操作系统创建了套接字，它就会分配一个端口号，并将该套接字与反向
    shell 连接。在 Kali Linux 机器上也会发生类似的过程，它运行一个 TCP 服务器，并向操作系统请求一个特定的端口号。端口号和 IP 地址的独特组合将
    TCP 服务器标识为其他机器上的 TCP 客户端。当你开发自己的服务器时，选择较大的端口号来运行它们是一个好主意，因为设备上的其他应用程序可能已经在使用较低的端口号。端口字段长度为
    16 位，因此最大端口号是 2^(16) – 1，即 65,535。
- en: '**NOTE**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you are curious about what each port is used for, the Internet Engineering
    Task Force maintains the Service Name and Transport Protocol Port Number Registry,
    which maps port numbers to their associated services:* [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你对每个端口的用途感到好奇，互联网工程任务组（IETF）维护着服务名称和传输协议端口号注册表，它将端口号与其相关联的服务进行映射：* [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)。'
- en: This model, in which clients connect to and communicate with a dedicated server,
    is called the *client-server model*. You can find this client-server model all
    over the internet. For example, your web browser is a TCP client that communicates
    with Google’s TCP web server running on 172.217.12.238 on port 80.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型，其中客户端连接并与专用服务器进行通信，被称为*客户端-服务器模型*。你可以在整个互联网中找到这种客户端-服务器模型。例如，你的网页浏览器是一个
    TCP 客户端，它与运行在 172.217.12.238 上的 Google TCP 网页服务器（端口 80）进行通信。
- en: An alternative to the client-server model is the *peer-to-peer (P2P) model*.
    In the P2P model, clients exchange information directly with one another. Self-hosted
    video chats and BitTorrent are both examples of the P2P model. We’ll use the client-server
    model to develop our reverse shell; however, it’s also possible to develop a P2P
    version of the same tool.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器模型的替代方案是*对等网络（P2P）模型*。在P2P模型中，客户端彼此直接交换信息。自托管的视频聊天和BitTorrent都是P2P模型的例子。我们将使用客户端-服务器模型来开发我们的反向Shell；不过，也可以开发该工具的P2P版本。
- en: '**Accessing the Victim Machine**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**访问受害者机器**'
- en: In [Chapter 2](ch02.xhtml#ch2), you discovered the IP address of the Metasploitable
    server. Now you need to find a way into the server. Once we have access to the
    server, we can upload our reverse shell to it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml#ch2)中，你发现了Metasploitable服务器的IP地址。现在，你需要找到进入服务器的方法。一旦我们访问了服务器，就可以将反向Shell上传到其中。
- en: Remember that processes communicate over the network through open ports, so
    if an attacker discovers one, they can send malicious packets to the process hosted
    on that port and possibly compromise the machine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，进程通过开放端口在网络上进行通信，因此如果攻击者发现了某个端口，他们可以向该端口上托管的进程发送恶意数据包，并可能危及该机器的安全。
- en: '***Scanning for Open Ports***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***扫描开放端口***'
- en: 'Tools like `nmap` allow hackers to scan systems to discover open ports. Let’s
    begin by scanning the Metasploitable server. Luckily, `nmap` is installed by default
    on Kali Linux. Run the following command to start the scan:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmap`等工具允许黑客扫描系统以发现开放端口。让我们从扫描Metasploitable服务器开始。幸运的是，`nmap`在Kali Linux上默认安装。运行以下命令开始扫描：'
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `-sV` flag enables version detection, which tells `nmap` to detect the version
    of each application running on the port. Next, specify the IP address being scanned
    (yours may be different than the one shown here). This command should return the
    open ports, the applications running on those ports, and the versions of those
    applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`-sV`标志启用版本检测，这告诉`nmap`检测每个端口上运行的应用程序的版本。接下来，指定要扫描的IP地址（你可能会看到与此不同的地址）。该命令应返回开放端口、在这些端口上运行的应用程序以及这些应用程序的版本。'
- en: 'One of the ways that `nmap` scans the ports on a host is by trying to establish
    a connection with each port. However, this is slow and will often trigger alarms.
    Therefore, `nmap` performs a *SYN scan* by default. Instead of establishing a
    full connection, a SYN scan sends TCP SYN packets, listens for SYNACK responses
    and marks a port as open if it receives a response. However, `nmap` does not complete
    the handshake by sending the final ACK packet. You can explicitly run a SYN scan
    by using the following command (the `-sS` flag represents the SYN scan):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmap`扫描主机端口的方式之一是尝试与每个端口建立连接。然而，这种方式较慢且经常会触发警报。因此，`nmap`默认执行*SYN扫描*。SYN扫描不会建立完整的连接，而是发送TCP
    SYN数据包，监听SYNACK响应，并在收到响应时标记端口为开放。然而，`nmap`并未通过发送最终的ACK数据包来完成握手。你可以通过以下命令显式地运行SYN扫描（`-sS`标志表示SYN扫描）：'
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Attackers also sometimes use TCP-FIN packets to bypass firewall protections.
    For example, a system administrator can specify rules that govern which packets
    are allowed to enter and leave a system. They might allow only outgoing packets
    on port 22, thus blocking any incoming packets on that port. This means that all
    SYN packets would be blocked. A hacker could instead probe the port using FIN
    packets given that both incoming and outgoing connections use these. Use the following
    command to run a FIN scan on the Metasploitable server:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者有时也使用TCP-FIN数据包绕过防火墙保护。例如，系统管理员可以指定规则来控制哪些数据包可以进出系统。他们可能只允许22端口的出站数据包，从而阻止该端口的任何入站数据包。这意味着所有的SYN数据包都会被阻塞。黑客可以改用FIN数据包探测该端口，因为无论是入站还是出站连接都使用这些数据包。使用以下命令对Metasploitable服务器执行FIN扫描：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In addition to FIN scans, `nmap` lets you perform *XMas scans*, which use an
    odd packet configuration to bypass detection and learn about the system. An XMas
    scan sets the FIN, PSH, and URG flags in the TCP packet. The PSH and URG flags
    are rarely used, and systems often contain incomplete or incorrect implementations
    of the TCP/IP standard that don’t handle them uniformly. By examining how a system
    responds to these flags, an attacker can infer information about the TCP/IP implementation
    and learn about the system. You can run an XMas scan by using this command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了FIN扫描，`nmap`还允许你进行*圣诞树扫描*，这是一种使用奇特数据包配置绕过检测并获取系统信息的扫描方式。圣诞树扫描会在TCP数据包中设置FIN、PSH和URG标志。PSH和URG标志很少使用，而且许多系统的TCP/IP标准实现不完整或错误，无法统一处理这些标志。通过检查系统如何响应这些标志，攻击者可以推测出TCP/IP的实现方式，并进一步了解系统的情况。你可以使用以下命令运行圣诞树扫描：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**NOTE**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s called an XMas scan because when you examine the bits in Wireshark, they
    look like bulbs on a Christmas tree, as depicted in [Figure 4-6](ch04.xhtml#ch4fig6).*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*之所以称其为圣诞树扫描，是因为当你在Wireshark中查看数据包的位时，它们看起来像圣诞树上的灯泡，如[图4-6](ch04.xhtml#ch4fig6)所示。*'
- en: '![image](../images/ch04fig06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch04fig06.jpg)'
- en: '*Figure 4-6: An XMas scan*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：圣诞树扫描*'
- en: '***Exploiting a Vulnerable Service***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***利用漏洞服务***'
- en: Once the you know the version of a running application, you can search for vulnerabilities
    that might give you a way into the server in the National Vulnerability Database
    at *[https://nvd.nist.gov/](https://nvd.nist.gov/)*. In [Chapter 8](ch08.xhtml#ch8),
    you’ll learn how to automate this discovery process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了正在运行的应用程序的版本，就可以在国家漏洞数据库中搜索可能为你提供进入服务器的漏洞，网址是*[https://nvd.nist.gov/](https://nvd.nist.gov/)*。在[第8章](ch08.xhtml#ch8)中，你将学习如何自动化这一发现过程。
- en: If system administrators do regular scans themselves and keep systems up to
    date, it will be difficult for an attacker to use a known vulnerability to gain
    access. In these cases, an attacker will need to discover an unknown vulnerability.
    These are called *zero-day* vulnerabilities because the victim is unaware of them
    and so has zero days to fix them. These vulnerabilities can be profitable. For
    example, an Android and iOS zero-click vulnerability sold for more than two million
    dollars each in 2019 to zero-day firm Zerodium. Many zero-day vulnerabilities
    are found using a technique called *fuzzing*, which we’ll explore in [Chapter
    9](ch09.xhtml#ch9).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统管理员定期自行进行扫描并保持系统更新，攻击者很难利用已知的漏洞获得访问权限。在这种情况下，攻击者需要发现一个未知的漏洞。这些被称为*零日*漏洞，因为受害者并不知道这些漏洞，因此没有时间修复它们。这些漏洞可能会带来利润。例如，2019年，一种Android和iOS的零点击漏洞分别以超过二百万美元的价格出售给零日漏洞公司Zerodium。许多零日漏洞是通过一种叫做*模糊测试*的技术发现的，我们将在[第9章](ch09.xhtml#ch9)中探讨这一点。
- en: 'For now, you’ll use the vsftp backdoor introduced in [Chapter 1](ch01.xhtml#ch1)
    to get into the Metasploitable server. Notice from the `nmap` scan that the system
    is running vsftp 2.3.4, a version that has a backdoor that lets attackers access
    the system. Let’s open the backdoor. Start a new terminal in Kali Linux and run
    the following commands:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用[第1章](ch01.xhtml#ch1)中介绍的vsftp后门来进入Metasploitable服务器。从`nmap`扫描结果可以看到该系统运行的是vsftp
    2.3.4版本，这是一个具有后门的版本，允许攻击者访问系统。让我们打开后门。在Kali Linux中打开一个新的终端并运行以下命令：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the backdoor is opened, it will create a shell running on port 6200\.
    This port number is preprogrammed into the backdoor. If you’ve successfully unlocked
    the backdoor, the terminal will appear to hang. Leave this terminal open and start
    a new one. In the new terminal, walk through the backdoor by connecting to the
    shell running on port 6200 by using the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当后门被打开时，它会在端口6200上创建一个shell。这个端口号是预先编程到后门中的。如果你成功解锁了后门，终端看起来会挂起。保持此终端打开，再启动一个新终端。在新终端中，使用以下命令连接到在端口6200上运行的shell，通过后门进入：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that you’re in, the commands you execute in this terminal will be executed
    on the server you just hacked. You’ll use this terminal later to download your
    reverse shell, so leave it open. This shell will give you access to the machine
    even after the system administrators have discovered the backdoor vulnerability
    and patched vsftp.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经进入了系统，接下来在此终端中执行的命令将在你刚刚入侵的服务器上执行。你将稍后使用这个终端来下载你的反向shell，所以请保持它打开。这个shell将使你在系统管理员发现后门漏洞并修补vsftp后，仍然能够访问该机器。
- en: '**Writing a Reverse Shell Client**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写反向Shell客户端**'
- en: Now that you have a conceptual understanding of reverse shells, let’s walk through
    the process of implementing one. Open Kali Linux and create a folder called “shell”
    on your desktop. For now, we’ll place both our client and server programs in this
    folder.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对反向Shell有了概念性的理解，让我们来看看如何实现它。打开 Kali Linux 并在桌面上创建一个名为“shell”的文件夹。现在，我们将在这个文件夹中放置客户端和服务器程序。
- en: 'We’ll write the program in Mousepad, which is the default text editor in Kali
    Linux, but you can use any editor of your choice. Run the following command to
    open the Mousepad editor:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Kali Linux 中的默认文本编辑器 Mousepad 中编写程序，但你可以使用任何你喜欢的编辑器。运行以下命令打开 Mousepad 编辑器：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The following program receives commands from the hacker’s TCP server and executes
    them on the victim’s machine before sending the results back to the hacker. Copy
    the following reverse shell code into the editor and save the file as *reverseShell.py*
    in the shell folder you just created.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序从黑客的TCP服务器接收命令并在受害者的机器上执行，然后将结果发送回黑客。将以下反向Shell代码复制到编辑器中，并将文件保存为 *reverseShell.py*，保存在你刚刚创建的
    shell 文件夹中。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We read the the attacker’s IP address from the first command line parameter
    you’ll supply when you run the program ➊. Then, we create a new client socket
    ➋. The `AF_INET` parameter tells the socket library to create an `IPV4` socket,
    and the `SOCK_STREAM` parameter tells the socket library to make it a TCP socket.
    If you wanted to create an `IPV6` UDP socket, you would supply the `AF_INET6`
    and `SOCK_DGRAM` parameters instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从运行程序时提供的第一个命令行参数中读取攻击者的IP地址 ➊。然后，我们创建一个新的客户端套接字 ➋。`AF_INET` 参数告诉套接字库创建一个
    `IPV4` 套接字，`SOCK_STREAM` 参数则告诉套接字库将其创建为一个TCP套接字。如果你想创建一个 `IPV6` UDP 套接字，你需要提供
    `AF_INET6` 和 `SOCK_DGRAM` 参数。
- en: 'After you’ve created the socket, you can use it to connect to the socket on
    the hacker’s machine by supplying a *tuple* containing the socket’s IP address
    and port number ➌. Tuples are lists that can’t be modified, and we declare them
    using parentheses () instead of brackets []. In this case, the tuple contains
    variables we defined earlier in the program, so it should look something like
    this: (`172.217.12.238, 8000`).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了套接字之后，你可以通过提供一个包含套接字的IP地址和端口号 ➌ 的 *元组* 来连接到黑客机器上的套接字。元组是不可修改的列表，我们使用圆括号
    () 来声明，而不是方括号 []。在这种情况下，元组包含我们在程序中之前定义的变量，因此它应该像这样：(`172.217.12.238, 8000`)。
- en: The client should then notify the attacker’s machine that it is ready to accept
    commands. The Python `socket` library is designed to send binary data, so if you
    want to send the string `'Bot reporting for duty'`, you must first encode it into
    binary by calling `.encode()` ➍. Similarly, all information received from the
    socket will be in binary, so the program must decode it if you want to view it
    as a string ➎. The value `4064` specifies the maximum number of bytes to read.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应通知攻击者的机器，表明它已准备好接受命令。Python 的 `socket` 库设计用于发送二进制数据，因此如果你想发送字符串 `'Bot reporting
    for duty'`，必须先通过调用 `.encode()` ➔ 将其编码为二进制。类似地，从套接字接收到的所有信息都是二进制的，因此如果你想以字符串形式查看它，程序必须对其进行解码
    ➎。值 `4064` 指定了要读取的最大字节数。
- en: The client will continue accepting and executing commands until the hacker sends
    the `exit` command. The `Popen` method ➏ creates a copy, or *fork*, of the current
    process, called a *subprocess*. It then passes the command to the subprocess,
    which executes it on the client. Once the subprocess has executed the command,
    the `proc.communicate()` function ➐ reads the results, which are then sent to
    the hacker’s machine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将继续接受并执行命令，直到黑客发送 `exit` 命令。`Popen` 方法 ➏ 创建当前进程的副本或 *分叉*，称为 *子进程*。然后，它将命令传递给子进程，子进程在客户端上执行该命令。一旦子进程执行完命令，`proc.communicate()`
    函数 ➐ 会读取结果，并将其发送到黑客的机器。
- en: '**Writing a TCP Server That Listens for Client Connections**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写一个监听客户端连接的TCP服务器**'
- en: 'Now, you’ll write the server that runs on the hacker’s Kali Linux machine.
    This server will be responsible for two key functions: 1) accepting connections
    from clients, and 2) sending and receiving commands. You’ll often hear this server
    called a *command and control (CNC)* server. Open a new window in your text editor,
    enter the following code, and then save the file as *shellServer.py* in the same
    shell folder:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将编写在黑客 Kali Linux 机器上运行的服务器。这个服务器将负责两个关键功能：1）接受来自客户端的连接，2）发送和接收命令。你会经常听到这个服务器被称为
    *命令与控制（CNC）* 服务器。在文本编辑器中打开一个新窗口，输入以下代码，然后将文件保存为 *shellServer.py*，保存在同一个 shell
    文件夹中：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, we create an IPv4 TCP socket ➊. To ensure that sockets can communicate
    effectively, the IP versions and protocols must both match, so we use the same
    protocols as we did with the client. We make the socket more robust by allowing
    the operating system to reuse a socket that was recently used ➋. After we create
    the socket, we can bind it to a port on the machine. The `bind()` function takes
    two parameters ➌ : the machine’s IP address, and the port. If the IP address parameter
    is empty, the function will use the default IP address assigned to the machine.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个IPv4 TCP套接字 ➊。为了确保套接字能够有效通信，IP版本和协议必须匹配，因此我们使用与客户端相同的协议。通过允许操作系统重用最近使用过的套接字，我们使套接字更加健壮
    ➋。创建套接字后，我们可以将其绑定到机器上的端口。`bind()`函数接受两个参数 ➌：机器的IP地址和端口。如果IP地址参数为空，函数将使用分配给机器的默认IP地址。
- en: Now that the socket is bound to a port, it can begin listening for connections
    ➍. Here, you can specify the number of connections you want to support. Because
    you have only one client, it’s okay to support a single connection. Once the client
    connects to our socket, we’ll accept the connection and return a connection object
    ➎. We’ll use this object to send and receive commands. Once we finish sending
    commands, we’ll configure the connection for a quick getaway ➏ and close it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，套接字已绑定到端口，它可以开始监听连接 ➍。在这里，您可以指定要支持的连接数量。由于只有一个客户端，支持单个连接是可以的。一旦客户端连接到我们的套接字，我们将接受连接并返回一个连接对象
    ➎。我们将使用这个对象来发送和接收命令。一旦我们完成发送命令，我们将为快速离开配置连接 ➏并关闭它。
- en: 'Start the server by running the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令启动服务器：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The server is now waiting for the client to connect to it, and you can begin
    the process of loading the client (*reverseShell.py*) onto the Metasploitable
    server.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器现在正在等待客户端连接，您可以开始将客户端（*reverseShell.py*）加载到Metasploitable服务器上的过程。
- en: '**Loading the Reverse Shell onto the Metasploitable Server**'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将反向Shell加载到Metasploitable服务器上**'
- en: Now that you’ve developed both the reverse shell and a hacker server in Python,
    load the Python reverse shell onto the Metasploitable server. We’ll use the reverse
    shell you’ve written to maintain access even after the vulnerability in vsftp
    has been patched. Because an attacker doesn’t have the server’s username or password,
    and thus can’t log into the server, you must use the shell provided by the vsftp
    backdoor to upload your reverse shell onto the Metasploitable server from the
    Kali Linux machine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经用Python开发了反向Shell和黑客服务器，将Python反向Shell加载到Metasploitable服务器上。我们将使用您编写的反向Shell来保持访问权限，即使vsftp中的漏洞已被修补。由于攻击者没有服务器的用户名或密码，因此无法登录到服务器，您必须使用vsftp后门提供的Shell从Kali
    Linux机器将您的反向Shell上传到Metasploitable服务器。
- en: 'Navigate to the directory on the Kali Linux machine that contains the *reverseShell.py*
    and *shellServer.py* files:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到Kali Linux机器上包含*reverseShell.py*和*shellServer.py*文件的目录：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, start a local server that will serve the *reverseShell.py* file to the
    Metasploitable server:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动一个本地服务器，将*reverseShell.py*文件提供给Metasploitable服务器：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `-m` represents the module that is run. Here, you’re running the `http.server`
    module, which allows you to start a web server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m`表示运行的模块。在这里，您正在运行`http.server`模块，它允许您启动一个Web服务器。'
- en: 'Open a terminal window and connect to the vsftp backdoor shell on port 6200,
    as shown in the code that follows. Use this shell to create a new directory on
    the Metasploitable server and download the *reverseShell.py* file into it from
    the hacker’s server. To do so, use the following commands:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，并连接到端口6200上的vsftp后门Shell，如下代码所示。使用该Shell在Metasploitable服务器上创建一个新目录，并从黑客的服务器下载*reverseShell.py*文件到该目录中。为此，使用以下命令：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Start the reverse shell on the Metasploitable machine by entering the following
    command, in the current Netcat session:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在当前Netcat会话中输入以下命令，启动Metasploitable机器上的反向Shell：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Your reverse shell will now attempt to connect to your server. Switch over
    to the Kali Linux machine and try executing the `whoami` command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您的反向Shell现在将尝试连接到您的服务器。切换到Kali Linux机器并尝试执行`whoami`命令：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `whoami` prints the current user. If the output says `root`, you’ve gained
    root access to the Metasploitable server. The preceding output also shows some
    examples of commands you can execute on the Metasploitable machine. The `pwd`
    command prints the working directory, and the `ls` command lists the files in
    the directory. In this case, you should see the *reverseShell.py* file that you’ve
    downloaded.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`whoami`命令打印当前用户。如果输出显示`root`，则说明你已获得Metasploitable服务器的root权限。前面的输出还展示了一些你可以在Metasploitable机器上执行的命令示例。`pwd`命令打印工作目录，`ls`命令列出目录中的文件。在这种情况下，你应该能够看到你下载的
    *reverseShell.py* 文件。
- en: '**Botnets**'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**僵尸网络**'
- en: So far you’ve built a server bot that controls only one client. However, you
    could extend your server so that it can control several clients at once. In *botnets*
    like these, several client machines connect to a single CNC server. These botnets
    can do many things, including performing a *distributed denial of service (DDoS)*
    attack by overwhelming a web server with traffic, causing it to become temporarily
    unavailable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只建立了一个控制单个客户端的服务器僵尸网络。然而，你可以扩展服务器，使其能够同时控制多个客户端。在像这样的*僵尸网络*中，多个客户端机器连接到单个CNC服务器。这些僵尸网络可以做很多事情，包括通过用大量流量压垮Web服务器来执行*分布式拒绝服务（DDoS）*攻击，导致服务器暂时无法使用。
- en: On October 21, 2016, the Dyn DNS service fell victim to a DDOS attack that used
    a botnet called Mirai. The botnet prevented users from accessing sites like Airbnb,
    Amazon, and Netflix. Before your browser accesses a website, it first obtains
    the website’s IP address by communicating with a DNS server. If a botnet overwhelms
    a DNS server, it will prevent users from accessing the domains hosted on that
    server.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年10月21日，Dyn DNS服务遭遇了一个使用Mirai僵尸网络发起的DDOS攻击。这个僵尸网络阻止用户访问像Airbnb、Amazon和Netflix这样的网站。在浏览器访问网站之前，它首先通过与DNS服务器通信获取网站的IP地址。如果一个僵尸网络压垮了DNS服务器，它将阻止用户访问该服务器上托管的域名。
- en: The Mirai botnet was composed of a collection of Internet of Things (IoT) devices
    like cameras and home routers. Instead of using a backdoor, Mirai walked right
    through the devices’ front door by logging in using default usernames and passwords.
    To do this, Mirai used a SYN scan to search for devices with port 23 open. When
    it found a device, a Mirai bot would try to connect using a collection of default
    credentials. If the bot succeeded in logging in, it used the commands `wget` or
    `tftp` to load bot client code onto the machine. If neither command was available,
    it would load its own version of `wget` using a custom loader. Once compromised,
    the device would send its IP address, username, and password back to the CNC server.
    The Mirai botnet compromised more than 350,000 devices.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Mirai僵尸网络由一系列物联网（IoT）设备组成，如摄像头和家庭路由器。Mirai并没有使用后门，而是通过设备的默认用户名和密码直接登录设备。为了实现这一点，Mirai使用了SYN扫描来搜索端口23开放的设备。当它找到设备时，Mirai僵尸网络会尝试使用一组默认的凭据进行连接。如果登录成功，它会使用`wget`或`tftp`命令将僵尸客户端代码加载到机器上。如果这两个命令都不可用，它会通过自定义加载器加载自己的`wget`版本。一旦设备被攻破，它会将设备的IP地址、用户名和密码发送回CNC服务器。Mirai僵尸网络已经攻破了超过35万个设备。
- en: Because the Mirai bot used a dedicated CNC server, security researchers could
    examine the traffic and determine the server’s IP address. The researchers contacted
    the server’s ISP and asked it to disable that IP address. However, the bot code
    didn’t specify a fixed IP address for the server. Instead, the bots determined
    the IP address by resolving a URL. This meant that if the IP address of one CNC
    server was disabled, the botnet could be assigned to a new CNC server by updating
    the mapping between the URL and the IP address in DNS, making it difficult to
    take the botnet offline. The Mirai botnet code is available on GitHub at *[https://github.com/jgamblin/Mirai-Source-Code/](https://github.com/jgamblin/Mirai-Source-Code/)*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Mirai僵尸网络使用了专用的CNC服务器，安全研究人员可以检查流量并确定该服务器的IP地址。研究人员联系了该服务器的ISP，并要求禁用该IP地址。然而，僵尸网络代码并没有为服务器指定固定的IP地址。相反，僵尸网络通过解析URL来确定IP地址。这意味着，如果一个CNC服务器的IP地址被禁用，僵尸网络可以通过更新DNS中URL与IP地址之间的映射来分配新的CNC服务器，从而使得将僵尸网络下线变得困难。Mirai僵尸网络的代码可以在GitHub上找到，链接是
    *[https://github.com/jgamblin/Mirai-Source-Code/](https://github.com/jgamblin/Mirai-Source-Code/)*。
- en: '[Figure 4-7](ch04.xhtml#ch4fig7) shows two types of botnet architecture. The
    first is a clientserver architecture, in which a single server controls multiple
    clients. One of the many disadvantages of this architecture is that the botnet
    can be taken down if the server is disabled. The second is a P2P architecture,
    in which any bot in the network can be designated the server. This removes any
    single point of failure. The Mirai botnet used the client-server model, but mitigated
    the architecture’s single point of failure by having the bots resolve the domain
    to determine the CNC server’s IP address.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7](ch04.xhtml#ch4fig7) 展示了两种僵尸网络架构。第一种是客户端-服务器架构，其中一个服务器控制多个客户端。这种架构的一个缺点是，如果服务器被禁用，整个僵尸网络就会瘫痪。第二种是
    P2P 架构，在这种架构中，网络中的任何一个 bot 都可以被指定为服务器，这样就消除了单点故障。Mirai 僵尸网络采用了客户端-服务器模型，但通过让 bot
    解析域名来确定 CNC 服务器的 IP 地址，缓解了该架构的单点故障问题。'
- en: '![image](../images/ch04fig07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch04fig07.jpg)'
- en: '*Figure 4-7: Two botnet architectures: client-server and P2P*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7：两种僵尸网络架构：客户端-服务器和P2P*'
- en: 'Mirai was sophisticated, but writing a botnet doesn’t have to be complicated.
    Let’s start by creating the file that contains the commands that you want your
    bots to run:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Mirai 很复杂，但编写一个僵尸网络并不一定复杂。让我们从创建一个包含你希望 bot 执行的命令的文件开始：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `touch` command creates a new file called *commands.sh*, and the `echo`
    command writes `"ping 172.217.9.206"` to that file. The `ping` command checks
    to see whether a machine is online by sending it a packet and waiting for a response.
    Put together, this script will send ping packets to the IP address 172.217.9.206\.
    Several machines repeatedly doing this will result in a DDoS attack.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch` 命令创建一个名为 *commands.sh* 的新文件，`echo` 命令将 `"ping 172.217.9.206"` 写入该文件。`ping`
    命令通过发送数据包并等待响应来检查机器是否在线。将这些命令组合在一起，这个脚本将向 IP 地址 172.217.9.206 发送 ping 数据包。多个机器重复执行这个操作将导致
    DDoS 攻击。'
- en: 'Once you’ve created the shell script, create a one-line botnet server using
    the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 shell 脚本之后，使用以下命令创建一个一行的僵尸网络服务器：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now you can write a simple bot client that downloads the script and executes
    it. Remember that the bot will execute all of the commands in the *commands.sh*
    file, so be careful about what you include in it. For instance, if the `ping`
    command were replaced with the command `rm -rf /`, the bot would delete all of
    the data on the machine. Next, run the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以编写一个简单的 bot 客户端，下载并执行脚本。记住，bot 会执行 *commands.sh* 文件中的所有命令，所以要小心你在文件中包含的内容。例如，如果
    `ping` 命令被替换为 `rm -rf /`，那么 bot 会删除机器上的所有数据。接下来，运行以下命令：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `-0-` flag outputs the contents of the downloaded file. The contents are
    then sent, or *piped*, using the `|` operator to the Bash shell where they’re
    executed. The *command.sh* script instructs the client to ping Google’s IP address
    (172.217.9.206).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`-0-` 标志输出下载文件的内容，然后通过 `|` 运算符将内容“管道”到 Bash shell 中执行。*command.sh* 脚本指示客户端
    ping Google 的 IP 地址（172.217.9.206）。'
- en: If a server instructs enough clients to do this at once, it can achieve a DDoS
    attack. Hackers often profit from renting their botnet armies to other hackers,
    who use them for this purpose.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个服务器指示足够多的客户端同时执行这个操作，它就能发起 DDoS 攻击。黑客们通常通过租赁他们的僵尸网络军队来从中获利，其他黑客也用它们来实现这一目的。
- en: '**Exercises**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: Expand your understanding of botnets, reverse shells, and scanning with these
    exercises. In the first exercise, you’ll implement a bot server that can handle
    multiple bots simultaneously. In the second exercise, you’ll use the Scapy library
    to implement a SYN scan. In the final exercise, you’ll implement a Python program
    that will allow you to detect XMas scans.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些练习，扩展你对僵尸网络、反向 shell 和扫描的理解。在第一个练习中，你将实现一个可以同时处理多个 bot 的 bot 服务器。在第二个练习中，你将使用
    Scapy 库实现 SYN 扫描。在最后一个练习中，你将实现一个 Python 程序，帮助你检测 XMas 扫描。
- en: '***A Multiclient Bot Server***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个多客户端僵尸网络服务器***'
- en: In this chapter, you wrote a server that could control only a single bot. Now
    let’s extend your implementation so that it can control multiple bots at once.
    Instead of sending individual commands, the bots will all receive the same command.
    After the CNC server has received a response, it should print out the bot’s IP
    address and the result of executing the command. I recommend that you use the
    `socketserver` library to manage multiple TCP connections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你写了一个只能控制单个机器人的服务器。现在让我们扩展你的实现，使其可以同时控制多个机器人。机器人将不再发送单独的命令，而是会收到相同的命令。在CNC服务器接收到响应后，它应该打印出机器人的IP地址和执行命令的结果。我建议你使用`socketserver`库来管理多个TCP连接。
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We create a new TCP server ➎ and whenever a client connects to the server, it
    creates a new internal thread and instantiates a new `BotHandler` class. Each
    connection is associated with its own instance of the `BotHandler` class ➊. The
    `handle()` method ➋ is called whenever `BotHandler` receives data from a client.
    Instance variables ➌ contain information about the request. For example, `self.request.recv(1024)`
    contains the data from the request, whereas `self.client_address` contains a tuple
    with the client’s IP address and port number. The `self.request.sendall()` method
    ➍ sends to the client all the information it is passed. This example converts
    all the received data to uppercase. The server will continue to run until it is
    terminated (CTRL-C) ➏.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的TCP服务器 ➎，每当客户端连接到服务器时，它会创建一个新的内部线程，并实例化一个新的`BotHandler`类。每个连接都与其自己的`BotHandler`类实例相关联
    ➊。每当`BotHandler`接收到来自客户端的数据时，`handle()`方法 ➋ 会被调用。实例变量 ➌ 包含有关请求的信息。例如，`self.request.recv(1024)`包含请求中的数据，而`self.client_address`包含一个元组，其中包含客户端的IP地址和端口号。`self.request.sendall()`方法
    ➍ 会将所有传递给它的信息发送到客户端。这个示例将所有接收到的数据转换为大写字母。服务器将继续运行，直到被终止（CTRL-C） ➏。
- en: Currently, the server merely converts messages for the clients to uppercase
    letters and sends them back. Extend your server so that it reads from a file and
    sends the commands in that file to the clients.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，服务器仅将客户端的消息转换为大写字母并发送回去。扩展你的服务器，使其从文件中读取并将文件中的命令发送给客户端。
- en: '***SYN Scans***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SYN扫描***'
- en: 'Write a Python program that takes an IP address as a single command line argument
    and runs a SYN scan on all the ports for that address. Hint: use the Scapy library
    that we discussed in [Chapter 2](ch02.xhtml#ch2). The Scapy library uses the `/`
    operator to combine information between layers. For example, this line creates
    an IP packet and overrides its default fields with values from TCP:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，接受一个IP地址作为命令行参数，并对该地址的所有端口进行SYN扫描。提示：使用我们在[第2章](ch02.xhtml#ch2)中讨论的Scapy库。Scapy库使用`/`运算符来组合层之间的信息。例如，这行代码创建了一个IP数据包，并用TCP中的值覆盖其默认字段：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This new SYN packet has the destination IP set to `192.168.1.101` and contains
    a TCP SYN packet with SYN flag `S` set. Also, its destination port value is set
    to `443`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的SYN数据包的目标IP地址设置为`192.168.1.101`，并包含一个带有SYN标志`S`的数据包。此外，它的目标端口值设置为`443`。
- en: 'Here is some skeleton code to help you get started:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些骨架代码，帮助你入门：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We issue an ICMP packet to check whether the host is online ➊. The program
    `traceroute`, which we discussed in [Chapter 3](ch03.xhtml#ch3), also uses this
    type of packet. Note that the Scapy `sr()` function sends and receives packets
    and the `sr1()` function sends and receives one packet only. If the host is available,
    start the SYN scan by sending a SYN packet and checking the response ➋. If you
    don’t receive a response, that port is probably closed. However, if you receive
    a response, check that the response contains a TCP packet with the SYN and ACK
    flags set. If only the SYN flag is set, the flag value of the TCP packet is will
    be set to `\0x02`. If only the ACK flag is set, the value will be `\x10`. If both
    are set, the flag value will be `\0x12`. If the response packet contains a TCP
    packet, you can check the packet’s flags using the following code snippet: `resp_packet.getlayer(''TCP'').flags
    == 0x12`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出一个ICMP数据包来检查主机是否在线 ➊。我们在[第3章](ch03.xhtml#ch3)中讨论的程序`traceroute`也使用这种类型的数据包。请注意，Scapy的`sr()`函数用于发送和接收数据包，而`sr1()`函数只发送和接收一个数据包。如果主机可用，通过发送一个SYN数据包并检查响应来启动SYN扫描
    ➋。如果没有收到响应，该端口可能是关闭的。然而，如果收到响应，请检查响应是否包含一个设置了SYN和ACK标志的TCP数据包。如果只有SYN标志被设置，则TCP数据包的标志值将设置为`\0x02`。如果只有ACK标志被设置，值将为`\x10`。如果两个标志都被设置，标志值将为`\0x12`。如果响应数据包包含TCP数据包，你可以使用以下代码片段检查数据包的标志：`resp_packet.getlayer('TCP').flags
    == 0x12`。
- en: '***Detecting XMas Scans***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检测圣诞扫描***'
- en: 'Write a program that uses the Scapy library (see [Chapter 2](ch02.xhtml#ch2))
    to detect XMas scans. Hint: examine the packets with the FIN, PSH, and URG flags
    set.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个使用Scapy库的程序（见[第2章](ch02.xhtml#ch2)），用于检测XMas扫描。提示：检查设置了FIN、PSH和URG标志的数据包。
