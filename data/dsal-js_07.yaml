- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 5 DESIGNING ALGORITHMS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 设计算法
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter covers several techniques for designing algorithms. We’ll start
    with recursion, which solves a problem by breaking it up into one or more simpler
    cases of the same problem. We’ll also look at *dynamic programming*, which solves
    a complex problem by solving simpler cases first and storing those solutions to
    avoid needless recalculations, as well as the *brute-force* (or *exhaustive*)
    *search* strategy, where you find a solution to a problem by systematically trying
    all possible solutions. Finally, we’ll explore *greedy algorithms* that apply
    a heuristic of choosing the best local option at each junction of a problem, with
    the hope that the given methodology will lead to the
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几种设计算法的技巧。我们将从递归开始，它通过将问题分解成一个或多个更简单的相同问题来解决问题。我们还将讨论*动态规划*，它通过首先解决更简单的子问题并存储这些解决方案来避免不必要的重新计算，从而解决复杂问题；以及*暴力搜索*（或*穷举*）*策略*，该策略通过系统地尝试所有可能的解决方案来找到问题的解。最后，我们将探讨*贪心算法*，该算法在每个问题的分岔点选择最佳的局部选项，期望这种方法最终能得出最优解。
- en: solution. Unlike the other strategies mentioned in this list, greedy algorithms
    may not always arrive at the best solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案。与列表中提到的其他策略不同，贪心算法并不总是能够找到最佳解。
- en: The strategies explored here are successfully applied to develop algorithms
    used along with data structures for the implementation of specific abstract data
    types (ADTs), so focusing on how to design a new solution for any given problem
    is worthwhile. The techniques covered in this chapter aren’t exhaustive, but they
    lie below the surface in many of the algorithms that we’ll explore later.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里探讨的策略已成功应用于与数据结构结合使用的算法开发，具体用于实现特定的抽象数据类型（ADT）。因此，专注于如何为任何给定问题设计新解决方案是值得的。本章涉及的技巧并不穷尽，但它们在我们稍后将要探讨的许多算法中都有所体现。
- en: Recursion
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归
- en: 'The simplest definition of recursion goes something like this: “A function
    calls itself over and over, again and again, until it doesn’t*.*” In other words,
    when facing a problem, if it’s small enough, it can be solved without any further
    recursive calls, but if it isn’t, the function calls itself to solve smaller problems,
    and out of those solutions, it finds the solution for the original, larger problem.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的最简单定义大概是这样：“一个函数反复调用自己，直到它不再调用。”换句话说，当遇到一个问题时，如果它足够小，可以不需要进一步的递归调用来解决，但如果问题较大，函数会调用自己来解决更小的子问题，然后从这些子问题的解中找到原始较大问题的解。
- en: NOTE
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*For a bit of computer humor, here’s a dictionary definition: “recursion: (n)
    see recursion.” A common saying is also “In order to understand recursion, you
    must first understand recursion.”*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了带点计算机幽默，这里有一个词典定义：“递归：（名词）见递归。”一个常见的说法是：“为了理解递归，你必须首先理解递归。”*'
- en: As discussed in [Chapter 2](chapter2.xhtml), recursion is a key technique in
    functional programming. Some languages, like Haskell, for instance, don’t even
    provide common “loops” and instead work exclusively with recursion. In computer
    science, recursion is all-sufficient for any algorithm, and anything you can do
    with loops you can also do with recursion. In fact, using recursion is much easier
    for many algorithms and definitions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](chapter2.xhtml)中讨论的，递归是函数式编程中的一项关键技术。一些语言，例如 Haskell，甚至不提供常见的“循环”，而是完全依赖递归来工作。在计算机科学中，递归对于任何算法来说都是足够的，任何可以用循环完成的事情，递归也能完成。事实上，对于许多算法和定义来说，使用递归要更简单。
- en: 'Recursion appears naturally in several areas:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 递归自然出现在多个领域：
- en: '**Mathematics **Definitions such as the factorial of a number or the Fibonacci
    series are naturally recursive. We’ll explore both later in this chapter.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**数学** 像阶乘或斐波那契数列这样的定义本质上是递归的。我们将在本章稍后探讨这两个例子。'
- en: '**Data structures **Many structures are defined in a recursive fashion. For
    example, as you’ll see in [Chapter 10](chapter10.xhtml), a *list* may either be
    empty or consist of a special node, the head of the list, followed by another
    list; another example from [Chapter 13](chapter13.xhtml) may be a *tree*, consisting
    of a parent node called the *root*, connected to any number of trees as its children.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据结构** 许多结构是以递归方式定义的。例如，正如你将在[第10章](chapter10.xhtml)中看到的，*列表*可以为空，也可以由一个特殊的节点组成，即列表的头部，后面跟着另一个列表；另一个来自[第13章](chapter13.xhtml)的例子是*树*，它由一个父节点（称为*根*）组成，根节点连接着任意数量的子树。'
- en: '**Procedures **Several algorithms can be expressed logically in a recursive
    fashion. An example from everyday life is searching your house for an object.
    You first look in one room, and if you find the object, you’re done; if you don’t
    find it, you search the rest of the place, applying the same logic. If you have
    nowhere left to search, you failed.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程** 几种算法可以通过递归的方式逻辑表达。一个来自日常生活的例子是搜寻家中的某个物品。你首先在一个房间里寻找，如果找到了物品，你就完成了；如果没有找到，你就继续搜寻其他地方，应用相同的逻辑。如果没有地方可搜寻了，那就失败了。'
- en: 'A recursive function always has two kinds of cases: simple ones that can be
    solved directly without any recursion and complex ones that need to use the function
    itself as an aid. The key to solving something recursively is to assume that the
    problem has already been solved and then code it using the (supposedly) available
    function. It’s a four-step procedure—which may seem to be circular:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数总是有两种情况：可以直接解决的简单情况，不需要递归；以及复杂情况，需要使用函数本身来辅助解决。递归解决问题的关键是先假设问题已经被解决，然后使用（假设的）可用函数来编写代码。这是一个四步过程——看起来可能是循环的：
- en: 1. Assume you already have a function that solves your problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 假设你已经有一个解决问题的函数。
- en: 2. Find some simple base cases that you can solve directly without any complications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 找出一些可以直接解决的简单基本情况，没有任何复杂性。
- en: 3. Figure out how you can solve the original problem by first solving one or
    more smaller versions of it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 想出你如何通过先解决一个或多个更小的版本来解决原始问题。
- en: 4. Apply your assumed function from step 1 to solve the minor problems of step
    3, or if they are small enough, solve them as in step 2.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 应用第 1 步中假设的函数来解决第 3 步中的小问题，或者如果它们足够小，像第 2 步一样解决它们。
- en: Let’s look at a couple of recursion techniques to show how to design clear,
    simple-to-understand algorithms.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看几个递归技术，展示如何设计清晰、易于理解的算法。
- en: The Divide-and-Conquer Strategy
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分治法策略
- en: 'As mentioned, the basic idea in recursion is to base the solution of complex
    cases on the solution of simpler ones. You *divide* the problem into smaller versions
    of itself, and *conquer* it using the solutions to all of them. Often you’ll solve
    a problem by recursively solving an “only one smaller” version, and that strategy
    gets its own name, *decrease-and-conquer,* but it’s still the same idea: reduce
    the original problem to smaller versions of itself. The only difference is that
    you solve the big problem by just solving *one* (smaller) version first. We’ll
    start with a look at some simpler decrease-and-conquer examples and then move
    on to the divide-and-conquer strategy.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，递归的基本思想是基于解决简单问题来解决复杂问题。你将问题*分解*成它的更小版本，然后通过解决所有这些小版本来*征服*它。通常，你会通过递归地解决“仅一个更小”的版本来解决问题，这种策略有一个专门的名称，叫做*减治法*，但它仍然是相同的思想：将原始问题减少为更小的版本。唯一的区别是，你通过先解决*一个*（更小的）版本来解决大问题。我们将首先看看一些更简单的减治法例子，然后再探讨分治法策略。
- en: Calculating Factorials
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计算阶乘
- en: 'The most often quoted example of a recursive calculation is likely the factorial
    of a number, *n*!, which is an example of the decrease-and-conquer strategy. The
    factorial of a non-negative integer number *n* is defined as follows: for *n*
    = 0, 0! = 1, and for *n* > 0, *n*! = *n* × (*n* – 1)!, which is the recursive
    definition.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 递归计算中最常被引用的例子可能是一个数字的阶乘，*n*!，这是一个减治法策略的例子。一个非负整数 *n* 的阶乘定义如下：当 *n* = 0 时，0!
    = 1；当 *n* > 0 时，*n*! = *n* × (*n* – 1)！，这是递归定义。
- en: 'This formula comes from a recursive problem; namely, how many ways can you
    order *n* books in a row on a shelf? The answer is simple: if no books are on
    the shelf, there’s only one way—an empty shelf. However, if you have *n* > 0 books,
    you can choose any one of them (there are *n* options), place it at the leftmost
    empty space on the shelf, and then place the (*n* – 1) other books in all possible
    permutations to the right of the book you just placed, which is *n*! = *n* × (*n*
    – 1)! as just described: *n* ways of choosing the first book multiplied by (*n*
    – 1)! ways of ordering the rest.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式来自一个递归问题；即，你可以用多少种方式将 *n* 本书排成一排放在书架上？答案很简单：如果书架上没有书，就只有一种方式——空书架。然而，如果你有
    *n* > 0 本书，你可以选择其中任何一本（有 *n* 种选择），把它放在书架上最左边的空位，然后将剩下的 (*n* – 1) 本书放在刚刚放好的书的右边，所有可能的排列组合就是
    *n*! = *n* × (*n* – 1)!，如上所述：*n* 种选择第一本书的方式乘以 (*n* – 1)! 种排列其余书本的方式。
- en: 'A quick implementation of the factorial (see also question 5.1) is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个阶乘的快速实现（另见问题 5.1）如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code closely follows the definition, with two clear cases: if *n* is 0
    ❶, return 1, and for greater values of *n* ❷, use recursion. It’s hard to go wrong
    with a recursive implementation, because the logic matches the definition closely.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码紧密跟随定义，包含两个明确的情形：如果 *n* 为 0 ❶，返回 1；对于更大的 *n* ❷，使用递归。递归实现很难出错，因为逻辑与定义非常吻合。
- en: Searching and Traversing
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 搜索与遍历
- en: Let’s look at a few other decrease-and-conquer examples using searching and
    traversing. In [Chapter 4](chapter4.xhtml), we mentioned binary search, which
    is a way of searching an ordered array. If the array is empty, you’re out of luck;
    the value you want isn’t there. If the array isn’t empty, check its middle element,
    and if it’s what you want, you succeed. If the element doesn’t match and is higher
    than the value you want, search recursively in the left half of the array; otherwise,
    search its right half.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些其他的递减与征服例子，涉及搜索和遍历。在[第4章](chapter4.xhtml)中，我们提到过二分搜索，它是一种搜索有序数组的方法。如果数组为空，你就没有好运了；你想要的值不在里面。如果数组不为空，检查其中间元素，如果它正是你想要的，那就成功了。如果元素不匹配且大于你想要的值，就递归地搜索数组的左半部分；否则，搜索右半部分。
- en: As another example, think about sorting a deck of cards. If the deck is empty,
    you’re done. Otherwise, you go through the deck looking for the lowest card and
    remove it from the deck. Then, you sort the rest of the deck and put it on top
    of the card you put aside.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，考虑对一副扑克牌进行排序。如果牌堆为空，你就完成了。否则，你遍历牌堆寻找最小的牌并将其移除。然后，你对剩余的牌堆进行排序，并将其放到你刚刚拿起的牌上面。
- en: Finally, let’s consider going through a list of pending tasks. (This is called
    a *traversal* of the list.) If the list is empty, you’ve got nothing to do; you’re
    finished. Otherwise, you take the top task from the list, do it, and then recursively
    go through the remaining tasks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们考虑遍历待办任务列表。（这称为*遍历*列表。）如果列表为空，你就没有事情可做，任务完成。否则，你从列表中取出最上面的任务，完成它，然后递归地处理剩余的任务。
- en: Considering the Fibonacci Series
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考虑斐波那契数列
- en: For a mathematical divide-and-conquer example, consider the Fibonacci series.
    This series starts with 0 and 1, and after that, each item is the sum of the two
    previous ones, so the series goes 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, and so
    on. (You’ll meet a Fibonacci-based structure in [Chapter 15](chapter15.xhtml),
    and the usage of the series even applies to estimating the complexity of tasks
    in agile methodologies, so it’s certainly pervasive.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个数学上的分治法例子，考虑斐波那契数列。该数列以 0 和 1 开始，之后每一项是前两项的和，因此数列是 0, 1, 1, 2, 3, 5, 8,
    13, 21, 34, 55，依此类推。（你将在[第15章](chapter15.xhtml)中遇到基于斐波那契的结构，这个数列的应用甚至涉及估算敏捷方法中的任务复杂度，因此它的应用范围非常广泛。）
- en: NOTE
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*For curious readers, this series was named after an Italian mathematician,
    Leonardo of Pisa, also known as Fibonacci (“filius Bonacci,” or “son of Bonacci”),
    who is also famous for having introduced Arabic numbers to the Western world.
    Fibonacci posed (and solved) a question involving the growth of an idealized population
    of rabbits, but the sequence had already appeared in many other contexts, such
    as counting patterns of verse.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于好奇的读者，这个数列以意大利数学家皮萨的莱昂纳多（即斐波那契）命名，他也因将阿拉伯数字引入西方世界而闻名。斐波那契提出并解决了一个问题，涉及理想化的兔子种群增长，但该数列早已出现在许多其他场合，例如计数诗歌的韵律模式。*'
- en: 'In order to implement the series recursively, you need to give a proper definition,
    and that’s not hard: you can say that F[0] = 0, F[1] = 1, and for *n* > 1, F[*n*]
    = F[*n*][–1] + F[*n*][–2]. Given this definition, here’s the code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了递归地实现该数列，你需要给出一个合适的定义，这并不难：你可以说 F[0] = 0，F[1] = 1，且对于 *n* > 1，F[*n*] = F[*n*][–1]
    + F[*n*][–2]。给定这个定义，下面是代码：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You have two base cases for 0 ❶ and 1 ❷ and a recursive case ❸ for other values.
    The code is so simple, it can’t go wrong, and testing verifies it. However, it
    does have a performance defect, which we’ll consider when we discuss dynamic programming
    later in this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个基本情形：对于 0 ❶ 和 1 ❷，以及一个递归情形 ❸ 适用于其他值。代码非常简单，不可能出错，测试也验证了这一点。然而，它存在性能缺陷，我们将在本章稍后讨论动态规划时考虑这一问题。
- en: Sorting and Puzzles
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 排序与难题
- en: 'Many sorting methods that we’ll explore later in this book, such as merge sort
    or quick sort, are expressed succinctly in a recursive fashion, but let’s look
    at another classic example: the Towers of Hanoi puzzle.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本书后续将探索的许多排序方法，如归并排序或快速排序，都可以通过递归方式简洁地表达，但让我们先看另一个经典例子：汉诺塔问题。
- en: 'This puzzle, invented by French mathematician Édouard Lucas in the 19th century,
    has three posts: the first has a stack of disks of decreasing size (largest at
    the bottom, smallest at the top), and the other two posts are empty. To solve
    the puzzle, you need to move all the disks from the first post to the last one,
    following two rules: you can move only the top disk from any post at a time (you
    can’t move two or more disks at once, and you can’t move any disks from the middle
    of a post), and you can move a disk to another post only if the top disk on that
    post is larger than the one you’re moving (a larger disk can never go on top of
    a smaller one). [Figure 5-1](chapter5.xhtml#fig5-1) shows the initial setup; all
    disks are on the leftmost post, and the goal is to move all the disks to the rightmost
    post.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题由法国数学家埃杜阿尔·卢卡斯（Édouard Lucas）在19世纪发明，包含三根柱子：第一根柱子上堆叠着一组大小递减的盘子（最大盘子在最底部，最小盘子在顶部），另外两根柱子为空。为了解决这个谜题，你需要将所有盘子从第一根柱子移动到最后一根柱子，遵循两个规则：每次只能移动最上面的盘子（不能一次移动两个或更多盘子，也不能从柱子中间的盘子开始移动），并且只有当目标柱子上的最上面盘子比你要移动的盘子大时，才能将盘子移到那个柱子（大盘子永远不能放在小盘子上面）。[图
    5-1](chapter5.xhtml#fig5-1)显示了初始设置；所有盘子都在最左边的柱子上，目标是将所有盘子移到最右边的柱子上。
- en: '![](../images/Figure5-1.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-1.jpg)'
- en: 'Figure 5-1: Towers of Hanoi'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5-1: 汉诺塔'
- en: 'How do you solve this with the divide-and-conquer strategy? You start by thinking
    you already have the required function, which might be towers(disks, origin, extra,
    destination), to move a certain number of disks from the origin post to the destination
    post using the extra post as an auxiliary, and you may use that function to implement
    the function itself. The base case is simple: if there are no disks to move, nothing
    needs to be done; otherwise, you make the moves described previously. The code
    could be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用分治策略来解决这个问题呢？你可以假设已经有了所需的函数，例如 towers(disks, origin, extra, destination)，它将一定数量的盘子从起始柱子移动到目标柱子，并使用额外的柱子作为辅助柱子。你可以利用该函数来实现整个过程。基本情况很简单：如果没有盘子需要移动，什么都不做；否则，按照前面描述的步骤进行移动。代码可能如下所示：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You first test for the base case ❶, because if there are no disks to move, you’re
    clearly done. Otherwise, recursively move all disks but the bottom one to the
    extra pole ❷. Having cleared the large disk, move it to the destination pole ❸,
    and finish by bringing the other disks on top of it ❹.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你测试基本情况 ❶，因为如果没有盘子需要移动，显然任务已经完成。否则，递归地将除了最底部的盘子以外的所有盘子移动到额外的柱子 ❷。清空大盘子后，将它移动到目标柱子
    ❸，最后将其他盘子放到它上面 ❹。
- en: 'A call like towers(4, "A", "B", "C") to move four disks from pole A to pole
    C will produce the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 towers(4, "A", "B", "C") 这样的调用可以将四个盘子从 A 柱移动到 C 柱，产生以下输出：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using recursion to solve the simpler steps of a puzzle is a clear example of
    the divide-and-conquer strategy. (See question 5.2 if you ever need to do this
    puzzle with no computer.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归来解决谜题的简化步骤是分治策略的一个明确示例。（如果你需要在没有计算机的情况下解决这个谜题，请参见问题 5.2。）
- en: NOTE
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注
- en: '*There’s a coda to this puzzle. In the original version, monks had to move
    64 golden disks from one post to another, and the world would end as soon as they
    accomplished the task. (In the original puzzle, the temple was in India; who knows
    how it moved abroad and got to Hanoi?) For n disks, M(n) = 2*^n *– 1 moves are
    required to solve the puzzle, so it’s an algorithm of exponential order; the formula
    can be verified by noting that M(n) = 2M(n – 1) + 1 and M(0) = 0\. At one movement
    per second, the achievement would require 2**^(64)* *– 1 seconds, more than 584
    billion years, so we’re safe!*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个谜题还有一个尾声。在原版谜题中，僧侣们必须将64个金盘子从一根柱子移动到另一根柱子，世界将在他们完成任务后结束。（在原版谜题中，寺庙位于印度；谁知道它是如何传播到国外并来到河内的？）对于
    n 个盘子，解这个谜题需要 M(n) = 2^n – 1 次移动，所以它是一个指数阶的算法；通过注意到 M(n) = 2M(n – 1) + 1 且 M(0)
    = 0 可以验证这个公式。如果每秒移动一次，这个任务将需要 2^(64) – 1 秒，超过584亿年，所以我们是安全的！*'
- en: '#### The Backtracking Technique'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 回溯技术'
- en: '*Backtracking* is another problem-solving technique that’s usually best implemented
    in a recursive way. When facing multiple options, choose one and try finding a
    solution with it. If you succeed, you’re done. If you fail, backtrack to the point
    where you made the selection and choose a different option. If at some point you
    run out of options, there definitely is no solution.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*回溯*是一种通常最好通过递归方式实现的解决问题技巧。当面临多个选项时，选择一个并尝试通过它找到解决方案。如果成功了，你就完成了。如果失败了，回溯到做出选择的点，选择另一个选项。如果在某个时刻没有更多的选项了，那就肯定没有解决方案。'
- en: Finding a Path in a Maze
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在迷宫中寻找路径
- en: Finding the way out of a maze (such as the one shown in [Figure 5-2](chapter5.xhtml#fig5-2))
    is a classic, ancient problem, and you’ll see it again in [Chapter 17](chapter17.xhtml),
    when working with graphs. It’s also the archetypical example for backtracking,
    so you’ll use it here. we’ll explore the full algorithms later; this is just the
    pseudocode.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫的出口（比如[图5-2](chapter5.xhtml#fig5-2)所示）是一个经典且古老的问题，你将在[第17章](chapter17.xhtml)中再次遇到，尤其是在处理图时。这也是回溯的典型示例，所以我们在这里使用它。我们稍后会深入探讨完整的算法，这只是伪代码。
- en: '![](../images/Figure5-2.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-2.jpg)'
- en: 'Figure 5-2: A maze to be solved using backtracking'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2：一个使用回溯解决的迷宫
- en: 'Whenever you get to a junction in the maze with two or more options available,
    you have to choose one, but obviously, you might end up choosing the wrong way.
    The idea is to follow the choice: if you get out of the maze, you succeeded, but
    if not, you backtrack to the last junction and select a different option. If no
    options are left, you’ll need to backtrack again, and again, until you either
    find a solution or decide there isn’t one. Here’s the pseudocode for such a recursive
    algorithm:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你到达迷宫中的一个交叉口，那里有两个或更多的选项时，你必须选择一个，显然，你可能会选择错误的方向。方法是按照选择走下去：如果走出了迷宫，你就成功了；如果没有，你就回溯到上一个交叉口并选择另一个选项。如果没有剩下任何选项，你需要继续回溯，一次又一次，直到找到解决方案或决定没有解决方案。以下是这种递归算法的伪代码：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The parameters for this function ❶ are the starting point of the path, the final
    goal, the maze, and the path you’ll with your journey. If you reach the goal ❷,
    you have succeeded; otherwise ❸, mark the cell as visited so you don’t choose
    it again in the future and start trying all the available options ❹. If a path
    is shown again ❺, you’ve succeeded. When all options have been discarded ❻, you
    know you have to backtrack because you’ve failed. [Figure 5-3](chapter5.xhtml#fig5-3)
    shows an intermediate position in the search.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数❶的参数包括路径的起点、终点、迷宫以及你将要走的路径。如果你到达了目标❷，你就成功了；否则❸，标记该单元格为已访问，这样以后就不会再选择它，并开始尝试所有可用的选项❹。如果路径再次出现❺，说明你已经成功。当所有选项都被排除❻时，你知道必须回溯，因为你失败了。[图5-3](chapter5.xhtml#fig5-3)显示了搜索过程中的一个中间位置。
- en: '![](../images/Figure5-3.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-3.jpg)'
- en: 'Figure 5-3: An intermediate step when solving the maze'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-3：解决迷宫时的一个中间步骤
- en: At position 1, the algorithm had two possible options; it chose the left one
    and failed, and then it backtracked to choose the other one. (All the cells reached
    from that incorrect option were left marked.) At position 2, another selection
    was made; in this case, it chose the option on the right, and the left wasn’t
    (yet) considered, so the cells in that path remain unmarked. The algorithm currently
    stands at 3\. If it doesn’t find a way out from here, it will backtrack to 2 to
    try the pending option. Whether it gets from position 3 to the exit quickly depends
    on the algorithm’s “luck” at choosing the correct option at each junction, but
    in any case, the algorithm is guaranteed to find a path eventually, if there is
    one, by recursively backtracking.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置1时，算法有两个可选项；它选择了左边的那个，结果失败了，然后回溯到选择另一个选项。在位置2时，又做了一个选择；这次选择了右边的那个，左边的尚未（还没有）考虑，所以该路径中的单元格仍未标记。当前算法处于位置3。如果从这里找不到出口，它将回溯到位置2，尝试尚未选择的选项。是否能快速从位置3找到出口，取决于算法在每个交叉点选择正确选项的“运气”，但无论如何，算法最终肯定会通过递归回溯找到一条路径（如果有的话）。
- en: Solving the Squarest Game on the Beach Puzzle
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决沙滩上的方块游戏谜题
- en: Let’s apply this technique to the Squarest Game on the Beach puzzle developed
    by American puzzler Sam Loyd, shown in [Figure 5-4](chapter5.xhtml#fig5-4). In
    this puzzle, the players throw balls at dolls, and if they manage to knock over
    dolls whose numbers add up to 50, they win a cigar. (See question 5.3 for a similar
    puzzle you can also solve with backtracking.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这一技巧应用于由美国拼图大师 Sam Loyd 开发的《海滩上的方块游戏》拼图，如[图 5-4](chapter5.xhtml#fig5-4)所示。在这个拼图中，玩家需要将球投向玩偶，如果他们成功击倒的玩偶编号之和为
    50，则获胜，奖品是一根雪茄。（参见问题 5.3，那里有一个类似的拼图，你也可以通过回溯算法解决。）
- en: '![](../images/Figure5-4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-4.jpg)'
- en: 'Figure 5-4: Sam Lloyd’s Squarest Game on the Beach puzzle (public domain)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：美国拼图大师 Sam Loyd 的《海滩上的方块游戏》拼图（公有领域）
- en: 'You can implement a recursive backtracking algorithm as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实现一个递归回溯算法，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the function ❶, goal is the number of points you try to make, and standing
    represents the available options, an array with the still-standing dolls. The
    points you have gotten so far will be held in score, and the dolls you knock over
    go in the dropped array. If you reach the goal exactly, you are finished ❷, and
    dropped has the list of dolls to drop. If you exceed our goal, or if there are
    no more dolls to drop ❸, you fail. Otherwise, you pick a doll ❹ (taking the first
    is simplest in terms of coding), remove it from future consideration ❺, and then
    attempt to solve the puzzle, including the recently chosen doll. If that fails,
    you backtrack and try again without including that doll ❻. To find the solution
    to the puzzle ❼, call solve() providing the goal (50) and list of doll points.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数 ❶ 中，goal 是你尝试达到的分数，standing 表示可用的选项，一个包含仍然站立的玩偶的数组。你目前获得的分数保存在 score 中，击倒的玩偶则放入
    dropped 数组。如果你恰好达成目标，就完成了 ❷，并且 dropped 中保存了需要击倒的玩偶列表。如果你超出了目标，或者没有更多的玩偶可以击倒 ❸，则失败。否则，你选择一个玩偶
    ❹（从代码实现的角度，选择第一个是最简单的），将其从未来的选择中移除 ❺，然后尝试解决拼图，包括最近选中的玩偶。如果失败了，你就回溯，并尝试不包括那个玩偶
    ❻。要找到拼图的解 ❼，调用 solve() 函数，传入目标分数（50）和玩偶分数列表。
- en: Dynamic Programming
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态规划
- en: '*Dynamic programming (DP)* is a technique for solving a problem by first solving
    other (smaller) problems and storing those results, so they don’t need to be recalculated
    if they’re needed again. Dynamic programming comes in two flavors: top down, which
    solves the problem logically by checking whether it’s already been solved before
    dealing with a subproblem, and *bottom up*, which requires first looking at the
    smaller subproblems and then solving the original problem. In other words, with
    top-down DP, you try to solve the original problem directly and then recursively
    solve smaller problems first, and in bottom-up DP, you start with the simplest
    problems and move upward, solving harder problems step by step.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态规划（DP）* 是一种通过首先解决其他（较小的）问题并存储这些结果，从而避免在需要时重新计算的技术。动态规划有两种类型：自顶向下的方式，先通过检查问题是否已经解决来判断是否处理子问题，再进行子问题的求解；和*自底向上*的方式，首先解决较小的子问题，然后逐步解决原问题。换句话说，在自顶向下的动态规划中，你试图直接解决原问题，然后递归地解决较小的问题；而在自底向上的动态规划中，你从最简单的问题开始，逐步解决更难的问题。'
- en: 'This description begs a question: What’s the best way to save previous results?
    We’ll look at two methods: *memoization*, based on a higher-order function in
    functional programming and probably best suited for top-down DP, and *tabulation*,
    based on arrays or matrices, which is typically best for bottom-up DP. Memoization
    is usually linked to recursive implementations, while tabulation is more useful
    for straightforward, nonrecursive solutions. The trade-off is that tabulation
    is probably quicker (not needing recursion) but may solve subproblems that aren’t
    actually needed, while memoization is slower (because of recursion) but will calculate
    strictly what’s needed.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个描述引出了一个问题：保存先前结果的最佳方式是什么？我们将讨论两种方法：*备忘录*，它基于函数式编程中的高阶函数，可能最适合自顶向下的动态规划；以及*表格法*，它基于数组或矩阵，通常最适合自底向上的动态规划。备忘录通常与递归实现相关，而表格法则更适用于直接的非递归解法。两者的权衡在于，表格法可能更快（因为不需要递归），但可能会解决一些并不真正需要的子问题，而备忘录则较慢（因为递归的原因），但只会计算实际需要的内容。
- en: Calculating Fibonacci Series with Top-Down DP
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用自顶向下动态规划计算斐波那契数列
- en: 'Let’s return to the Fibonacci numbers discussed earlier in the chapter. Here’s
    the code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本章之前讨论的斐波那契数。以下是代码：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a divide-and-conquer case, but as noted, that implementation has a problem,
    and we’ll solve it with dynamic programming. The code is clear, simple, and correct,
    but it can be quite slow. When experimenting with increasingly higher values of
    *n*, the required time to calculate the *n*th Fibonacci number grows exponentially
    as shown in [Figure 5-5](chapter5.xhtml#fig5-5). What’s happening?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个分治法的例子，但如前所述，该实现有一个问题，我们将通过动态规划来解决。代码清晰、简单且正确，但可能会非常慢。当你尝试更大的 *n* 值时，计算第
    *n* 个斐波那契数所需的时间呈指数增长，如[图 5-5](chapter5.xhtml#fig5-5)所示。发生了什么呢？
- en: '![](../images/Figure5-5.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-5.jpg)'
- en: 'Figure 5-5: The number of additions needed to calculate Fibonacci numbers recursively
    grows exponentially.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5：递归计算斐波那契数所需的加法次数呈指数增长。
- en: To understand the problem, consider the calculations involved for fibo(7). [Figure
    5-6](chapter5.xhtml#fig5-6) shows all the required calls.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个问题，考虑计算 fibo(7) 时涉及的所有计算。图[5-6](chapter5.xhtml#fig5-6)展示了所有需要的调用。
- en: '![](../images/Figure5-6.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-6.jpg)'
- en: 'Figure 5-6: Required calls to calculate fibo(7)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：计算 fibo(7) 所需的调用
- en: Clearly too many calls are repeated. Calculating fibo(7) implies summing fibo(6)
    and fibo(5), but the former is calculated as fibo(5) plus fibo(4), so you are
    repeating fibo(5). The diagram shows that the calculation of other Fibonacci numbers
    implies even more repetitions; how many times are fibo(3) or fibo(2) called? (See
    also question 5.4.) This implementation is exponential in order, so how do you
    solve it?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，很多调用是重复的。计算 fibo(7) 需要求和 fibo(6) 和 fibo(5)，但前者是通过 fibo(5) 加上 fibo(4) 计算得到的，所以你重复计算了
    fibo(5)。图表显示，计算其他斐波那契数时还会有更多的重复；fibo(3) 或 fibo(2) 被调用多少次呢？（另见问题 5.4。）这种实现是指数级增长的，那么该如何解决这个问题呢？
- en: '*Memoizing* is a functional programming technique that may be applied to any
    pure function (those with no side effects that always return the same results
    for the same arguments, as discussed in [Chapter 2](chapter2.xhtml)). The idea
    is that when a memoized function is called, it first checks an internal cache
    to see whether the calculation was already made. If so, it returns the cached
    value instead of redoing the calculation. If the requested value hasn’t been calculated
    before, the memoized function does its work, but before returning the result to
    the caller, it stores it in the internal cache for future reference.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*记忆化* 是一种函数式编程技巧，可以应用于任何纯函数（即没有副作用、对于相同的参数始终返回相同结果的函数，见[第 2 章](chapter2.xhtml)）。其思想是，当一个记忆化的函数被调用时，它首先检查内部缓存，看看计算是否已经完成。如果已完成，它直接返回缓存中的值，而不是重新进行计算。如果请求的值尚未计算，记忆化函数会执行计算，但在返回结果之前，它会将结果存储到内部缓存中，以供以后使用。'
- en: 'Higher-order functions, such as fast-memoize (from *[https://www.npmjs.com/package/fast-memoize](https://www.npmjs.com/package/fast-memoize)*),
    are publicly available, but it’s not hard to whip up one yourself:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数，如 fast-memoize（来自 *[https://www.npmjs.com/package/fast-memoize](https://www.npmjs.com/package/fast-memoize)*），是公开可用的，但自己动手写一个并不难：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This higher-order function ❶ receives a function as an argument and returns
    a new one. It uses a closure to maintain a cache of previous calls and calculated
    values; you use a simple object here ❷, but you could also use a set (see [Chapter
    11](chapter11.xhtml) for other possible structures). The returned function ❸ first
    creates a string out of the arguments to the original fn function ❹. If that string
    is already used as a key in the cache ❺, directly return the previously calculated
    value from it ❻; otherwise, call the original function, store the returned value
    in the cache, and return it ❼.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个高阶函数 ❶ 接收一个函数作为参数并返回一个新的函数。它使用闭包来维护先前调用和计算值的缓存；这里你使用的是一个简单的对象 ❷，但你也可以使用集合（有关其他可能的结构，见[第
    11 章](chapter11.xhtml)）。返回的函数 ❸ 首先将原始 fn 函数的参数 ❹ 生成一个字符串。如果该字符串已作为键存在于缓存中 ❺，则直接从缓存中返回先前计算的值
    ❻；否则，调用原始函数，存储返回的值到缓存中，并返回该值 ❼。
- en: 'Given memoize(), you can speed up the calculations straightaway with a minor
    change, wrapping the original function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 memoize()，你可以通过简单的修改，立即加速计算，方法是包装原始函数：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you now try something like fibo(100), the results will be immediate. To understand
    why, you’ll need fibo(99) and fibo(98), but after calculating fibo(99), the value
    of fibo(98) will have been calculated, so it won’t be evaluated again. Each possible
    Fibonacci number between 0 and 100 will be calculated, but only once. The algorithm
    has become linear instead of exponential just by applying the dynamic programming
    technique of storing previously calculated values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试像 fibo(100) 这样的操作，结果会立即显示。要理解为什么，你需要 fibo(99) 和 fibo(98)，但是在计算 fibo(99)
    之后，fibo(98) 的值已经被计算过了，因此不会再次计算。0 到 100 之间的每一个可能的斐波那契数都会被计算，但每个数只会计算一次。通过应用动态规划技术——存储先前计算的值，算法已经变得线性，而不是指数级增长。
- en: Line Breaking with Top-Down DP
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用自顶向下的动态规划进行换行
- en: 'Let’s look at a practical problem you can solve by applying top-down DP: building
    a nice-looking web form. Say you want a web page to be able to generate multiple
    forms onscreen, each with different sets of fields. If you had a fixed number
    of forms with predetermined, fixed sets of fields, it wouldn’t be a problem. However,
    in this case, the number of forms grows unpredictably, and fields need to be added
    or removed, as well as moved around, so you need a more flexible solution. What
    you need is a “form creator” that takes in a list of fields in a given order and
    produces a suitable form as output. For instance, a part of the form to be generated
    might look like the one shown in [Figure 5-7](chapter5.xhtml#fig5-7).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个可以通过应用自顶向下的动态规划解决的实际问题：构建一个外观整洁的网页表单。假设你希望网页能够生成多个表单，每个表单包含不同的字段集。如果表单数量是固定的，并且字段集也是预先确定的，这并不会成为问题。然而，在这种情况下，表单的数量是不可预测的，字段需要添加、删除或移动，因此你需要一个更灵活的解决方案。你需要的是一个“表单创建器”，它接受一个按给定顺序排列的字段列表，并输出一个合适的表单。例如，要生成的表单的一部分可能如下图所示：[图
    5-7](chapter5.xhtml#fig5-7)。
- en: '![](../images/Figure5-7.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-7.jpg)'
- en: 'Figure 5-7: An example web form'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7：一个示例网页表单
- en: The problem is you want a justified right margin, but the widths of the fields
    are inconsistent, so you’ll need to break rows and stretch some fields to make
    everything even. You need to be careful when deciding where to break rows and
    what fields to put in each row.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于你想要一个对齐的右边距，但字段的宽度不一致，因此你需要拆分行并拉伸某些字段，使得一切看起来均匀。你需要在决定拆分行的位置以及每行放哪些字段时小心谨慎。
- en: NOTE
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The TeX typesetting system implements the Knuth-Plass algorithm to determine
    line breaks for paragraphs so they look nice. The problem here is essentially
    the same, but we’ll use DP to solve it instead.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*TeX 排版系统实现了 Knuth-Plass 算法，用来确定段落的换行位置，使其看起来更加美观。这里的问题本质上是一样的，但我们将使用动态规划（DP）来解决它。*'
- en: Consider five fields of widths 7, 2, 5, 3, and 6 (see [Figure 5-8](chapter5.xhtml#fig5-8)).
    You need to arrange them in rows of width 10.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑五个字段，宽度分别为 7、2、5、3 和 6（见[图 5-8](chapter5.xhtml#fig5-8)）。你需要将它们安排成宽度为 10 的行。
- en: '![](../images/Figure5-8.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-8.jpg)'
- en: 'Figure 5-8: Example fields with various widths'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-8：不同宽度的示例字段
- en: You can’t manage with fewer than three rows, and having four or more rows results
    in too much wasted space (although we’ll need to quantify this concept later).
    You won’t add white space between fields (as TeX does between words); instead,
    you’ll expand the fields themselves. First decide how much empty space to leave
    in each row before expanding blocks or separating words. You have three possible
    layouts of three rows (see [Figures 5-9](chapter5.xhtml#fig5-9), [5-10](chapter5.xhtml#fig5-10),
    and [5-11](chapter5.xhtml#fig5-11); blocks in gray represent extra added white
    space at the end of rows; you’ll have to share that space among all blocks in
    the same row).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能少于三行来管理，四行或更多行会导致太多的空间浪费（尽管我们稍后需要量化这一概念）。你不会像 TeX 在单词之间那样添加空白；相反，你将扩展字段本身。首先决定在每一行中留多少空白空间，然后再扩展块或分隔单词。你有三种可能的三行布局（见[图
    5-9](chapter5.xhtml#fig5-9)、[图 5-10](chapter5.xhtml#fig5-10)和[图 5-11](chapter5.xhtml#fig5-11)；灰色区域代表每行末尾额外添加的空白空间；你需要在同一行中的所有块之间共享这些空间）。
- en: '![](../images/Figure5-9.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-9.jpg)'
- en: 'Figure 5-9: Field layout 1'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-9：字段布局 1
- en: '![](../images/Figure5-10.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-10.jpg)'
- en: 'Figure 5-10: Field layout 2'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-10：字段布局 2
- en: '![](../images/Figure5-11.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-11.jpg)'
- en: 'Figure 5-11: Field layout 3'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-11：字段布局 3
- en: What solution is best? Assuming that adding smaller spaces in many rows is better
    than adding larger spaces in fewer rows, consider the “row cost” to be the square
    of the added white space for that row, and the total cost will be the sum of all
    the row costs. (To better understand why squaring is used, imagine you need to
    add two spaces; putting all of them on the same line would cost 2² = 4, but placing
    one space in each of two lines would cost 1² + 1² = 2, so squaring the costs before
    adding them implements a policy that favors smaller spaces.) Given this definition,
    the cost of the layouts would be 1² + 2² + 4² = 21, 3² + 0² + 4² = 25, and 3²
    + 3² + 1² = 19, so the third diagram represents the design the algorithm should
    produce. Let’s program it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种解决方案最好？假设在多行中添加较小的空白空间比在少数几行中添加较大的空白空间更好，考虑“行成本”为该行添加的空白空间的平方，总成本将是所有行成本的总和。（为了更好地理解为什么使用平方，假设你需要添加两个空格；如果把它们都放在同一行中，成本是2²
    = 4，但如果将一个空格放在两行中，成本是1² + 1² = 2，因此，在加总前平方成本实现了一个偏好较小空白的策略。）根据这个定义，布局的成本将是1² +
    2² + 4² = 21，3² + 0² + 4² = 25，和3² + 3² + 1² = 19，因此第三个图表表示算法应该生成的设计。让我们编写代码。
- en: 'Consider a list of block widths (which in this case would be 7, 2, 5, 3, and
    6) and a maximum width (MW) to achieve. The following logic would work: calculate
    the sum *s* of all widths, and if *s* is not greater than MW, the cost is (MW
    – *s*)². You can’t make it better by splitting the list into two or more rows.
    Otherwise, if you have more fields than you can fit in a single row, you can try
    splitting the list into two fragments in all possible ways and then choose the
    split that produces the lowest cost.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一组区块宽度（在这种情况下是7、2、5、3和6）和要实现的最大宽度（MW）。以下逻辑适用：计算所有宽度的和*s*，如果*s*不大于MW，成本为(MW
    - *s*)²。通过将列表拆分为两行或多行不能提高效果。否则，如果你有更多的字段无法在一行中放下，可以尝试以所有可能的方式将列表拆分成两个片段，然后选择产生最低成本的拆分。
- en: 'The following logic does that, but it leaves out the code to distribute white
    space among the fields in a row, since that’s only needed later. This code finds
    the cost of the best set of line breaks and where those breaks should be made:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下逻辑实现了这个目标，但它省略了在一行中分配空白空间的代码，因为这部分内容只在后续需要。这个代码找到了最佳换行集合的成本及这些换行应该在哪里进行：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function finds the best split for a set of blocks from p through q, inclusive,
    and also returns the list of splits to be made. Assume we have a totalWidth(x,y)
    function that calculates the width of blocks x through y (you’ll see how to best
    implement it later). First calculate the width of the whole list of blocks ❶;
    if it’s less than the available space, you won’t need any splits and you are done.
    Calculate the cost per the definition and return that a split is done after the
    q position ❷. If you need a split, set up a search; optimum will be the best possible
    cost ❸, and split will be the place to split the list ❹. Loop through all possible
    breaks ❺ and find the costs of fragments p through r and fragments r + 1 through
    q ❻. The cost of each split is stored ❼, and if it’s better than the previous
    optimum ❽, r is preferred as the new split. The end result ❾ is the best cost
    found, together with the list of split points.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数找出从p到q（包括q）的区块集合的最佳拆分，并返回要进行的拆分列表。假设我们有一个totalWidth(x,y)函数，用来计算从x到y的区块宽度（稍后你将看到如何最佳实现它）。首先计算整个区块列表的宽度❶；如果它小于可用空间，则无需拆分，操作完成。按照定义计算成本并返回拆分发生在q位置之后❷。如果需要拆分，设置一个搜索；最优解将是最佳可能的成本❸，而拆分点则是拆分列表的位置❹。遍历所有可能的换行位置❺，并计算区块p到r和r+1到q的片段成本❻。每个拆分的成本被存储❼，如果它比之前的最优解好❽，则r作为新的拆分点。最终结果❾是找到的最佳成本及拆分点列表。
- en: '[Figure 5-12](chapter5.xhtml#fig5-12) shows how this algorithm would deal with
    your list of blocks.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-12](chapter5.xhtml#fig5-12)展示了这个算法如何处理你的区块列表。'
- en: '![](../images/Figure5-12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-12.jpg)'
- en: 'Figure 5-12: All the possible splits evaluated by the algorithm'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-12：算法评估的所有可能拆分
- en: Calculating costs, [Figure 5-13](chapter5.xhtml#fig5-13) shows the optimum solution.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 计算成本，[图 5-13](chapter5.xhtml#fig5-13)展示了最优解。
- en: '![](../images/Figure5-13.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-13.jpg)'
- en: 'Figure 5-13: The optimum solution'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-13：最优解
- en: 'The cost is shown underneath each block. If a block is split into several blocks,
    its cost is the sum of the costs of its parts. The highlighted path shows how
    to achieve the optimum solution: leave 7 on its own in the first row, place 2
    and 5 in the second row, and place 3 and 6 in the last row, for a total cost of
    19\. Running the algorithm produces the following result:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 成本显示在每个块的下方。如果一个块被拆分为多个块，它的成本是其部分成本的总和。高亮路径显示了如何达到最佳解决方案：在第一行单独留下7，在第二行放置2和5，在最后一行放置3和6，总成本为19。运行算法将产生以下结果：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can define the list of block widths ❶, and using costOfFragment(...) ❷
    produces the result: the best total cost is 19, and you split lines at positions
    0 (just the 7), 2 (the 2 and the 5), and 4 (the 3 and the 6) as expected ❸.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义块宽度的列表 ❶，并使用costOfFragment(...) ❷产生结果：最佳总成本是19，你在位置0（仅7）、2（2和5）和4（3和6）处分割行，正如预期的那样
    ❸。
- en: 'You are done, but if you look closely at [Figure 5-13](chapter5.xhtml#fig5-13),
    you will notice the same problem as with the Fibonacci calculations: the cost
    of some blocks is calculated multiple times, for example, (5, 3, 6), (2, 5, 3),
    and (7, 2). You can apply memoization to avoid this problem, and that produces
    the needed algorithm:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成了，但如果仔细查看[图5-13](chapter5.xhtml#fig5-13)，你会注意到与斐波那契计算相同的问题：某些块的成本被多次计算，例如（5,
    3, 6）、（2, 5, 3）和（7, 2）。你可以应用记忆化来避免这个问题，得到所需的算法：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How would the optimized algorithm deal with this example? [Figure 5-14](chapter5.xhtml#fig5-14)
    shows how little would actually be calculated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 优化后的算法如何处理这个例子？[图5-14](chapter5.xhtml#fig5-14)显示了实际上需要计算的内容非常少。
- en: '![](../images/Figure5-14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-14.jpg)'
- en: 'Figure 5-14: The optimized calculation reduces work in a significant way.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-14：优化后的计算大大减少了工作量。
- en: The grayed-out blocks don’t need recalculation; due to memoization, you just
    reuse the previously calculated costs. At several places (marked with arrows)
    no recursion was needed. All in all, the algorithm worked faster, but see question
    5.5 for a further optimization.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色块不需要重新计算；由于记忆化，你只需重用之前计算过的成本。在多个地方（用箭头标记）不需要递归。总体而言，算法运行得更快，但请参见问题5.5以获取进一步的优化。
- en: Calculating Fibonacci Series with Bottom-Up DP
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用自底向上的动态规划计算斐波那契数列
- en: 'Let’s consider DP the other way round, from the bottom up. When working in
    a top-down fashion, you have to hold off on calculating values until some calculations
    for lower values are finished. For example, in the section “Calculating Fibonacci
    Series with Top-Down DP” on page 72, you couldn’t calculate fibo(7) until the
    calculations for fibo(6) and fibo(5) were done. Using the bottom-up method, you
    start at the lowest cases and work your way up. To find a Fibonacci number from
    the bottom up, make the calculations the same way that the series is defined,
    starting with 0 and 1, and always adding the last two numbers to create the next
    number in the sequence:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑从下到上的动态规划。在自顶向下的方式下，你必须等到某些较小值的计算完成后才能进行计算。例如，在第72页“使用自顶向下动态规划计算斐波那契数列”一节中，你不能在计算fibo(6)和fibo(5)之前计算fibo(7)。使用自底向上的方法，你从最小的情况开始，一步一步向上推进。要从下到上找到斐波那契数，你按照数列的定义进行计算，从0和1开始，始终将最后两个数字相加以生成下一个数字：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s simple code: for 0 or 1 ❶ you need no calculations. For other values ❷,
    set up a loop starting with a = 0 and b = 1 (a and b represent the two latest
    numbers in the sequence), and loop enough times ❸ until b becomes the number you
    are seeking ❹.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是简单的代码：对于0或1 ❶，你不需要进行计算。对于其他值 ❷，设置一个循环，初始时a = 0，b = 1（a和b代表序列中的两个最新数字），然后循环足够多次
    ❸，直到b变成你想要的数字 ❹。
- en: You might notice that all the previously calculated numbers aren’t saved, and
    it’s true, but that’s because you don’t need them for this particular case. The
    algorithm works in a bottom-up fashion, calculating later numbers by using previous
    ones; it so happens that to do this, you always need only the two latest numbers,
    so there’s no need to store all the others.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，所有之前计算的数字并没有保存，确实如此，但这是因为在这个特定的案例中，你不需要它们。该算法采用自底向上的方式，通过使用前面的数字来计算后续数字；恰好为了做到这一点，你总是只需要最新的两个数字，因此不需要存储其他所有数字。
- en: Summing Ranges Recursively with Bottom-Up DP
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用自底向下动态规划递归求和区间
- en: In the line-breaking algorithm (see “Line Breaking with Top-Down DP” on [page
    74](chapter5.xhtml#pg_74)), you needed the totalWidth(x,y) function that would
    add together the widths of values in positions x through y (both inclusive) of
    an array of block widths. This function needs to be as fast as possible so as
    not to impact an algorithm’s performance negatively. The trivial version (looping
    through the array, summing as it goes) has linear *O*(*n*) performance, if *n*
    is the number of blocks. However, you can improve upon this, as you’ll see in
    a couple of alternative implementations, which will focus not only on DP but also
    on other techniques that you’ve seen in this chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在换行算法中（参见[第74页](chapter5.xhtml#pg_74)的“使用自上而下动态规划换行”），你需要一个totalWidth(x, y)函数，用来将数组中从位置x到位置y（包括x和y）的宽度值相加。这个函数需要尽可能快，以免对算法的性能产生负面影响。最简单的版本（遍历数组并逐步累加）具有线性
    *O*(*n*)性能，如果 *n* 是块的数量。然而，你可以通过一些替代实现来进行改进，这些实现不仅关注动态规划，还涉及本章中介绍的其他技术。
- en: 'The first algorithm, using a loop to get the sum, is straightforward. Now include
    another parameter to the function, arr, with the block widths, to make it more
    general and independent of its caller:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个算法，使用循环来获取和，比较简单。现在为函数增加另一个参数arr，它是块的宽度，使其更通用并与调用者无关：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To optimize it using memoization requires only a small change:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用备忘录化优化它只需要做一个小的改动：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This version will be faster if (and this is a big if) you call the function
    two or more times, with the same arguments. Calling it with different arguments
    every time will slow it down instead of speeding it up, because of the extra caching
    work. Suppose you had already calculated the sum of the range from 10 to 20, and
    now you wanted the sum of the range from 10 to 21\. You could add the 21st value
    to the sum of the range from 10 to 20, with no more work.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（而且这是个大前提）你两次或多次使用相同的参数调用该函数，这个版本会更快。每次使用不同的参数调用它反而会使它变慢，因为需要额外的缓存工作。假设你已经计算了从10到20的区间和，现在你想要从10到21的区间和。你可以将第21个值加到10到20的区间和中，而不需要额外的工作。
- en: 'This concept is the key to DP: base a problem’s solution on the solution of
    previous, smaller problems. To implement it, you need to define the sum of a range
    of values in terms of sums of previous ranges. If you want to calculate the sum
    of a range of values of array arr consisting of a single element (from p to p),
    the result is just arr[p]. If you want the sum of values from position 0 to position
    q (greater than zero), first sum the range from 0 to q-1 and then add arr[q] to
    that result. Finally, to find the sum of values from position p (greater than
    zero) to position q (greater than p), find the sum of range 0 to q and subtract
    the sum of range 0 to p-1.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念是动态规划的关键：将问题的解决方案建立在之前较小问题的解决方案之上。要实现这一点，你需要将一个区间值的和定义为之前区间和的组合。如果你想计算数组arr中从位置p到p的单个元素区间和，结果就是arr[p]。如果你想计算从位置0到位置q（大于零）的值的和，首先计算从0到q-1的区间和，然后将arr[q]加到该结果上。最后，要计算从位置p（大于零）到位置q（大于p）的值的和，先计算从0到q的区间和，再减去从0到p-1的区间和。
- en: 'You can also use memoization to keep track of previously calculated values;
    the logic is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用备忘录化（memoization）来跟踪之前计算过的值；其逻辑如下：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function works better and does less work. For instance, if you had asked
    for the sum of range 10 through 20, all sums from 0 to 0, 0 to 1, 0 to 2, and
    so on, up to 0 to 20 would need to be cached. If you then asked for the range
    10 through 21, it would try to calculate the sum of range 0 to 21, which would
    be done immediately (as the sum of range 0 to 20, plus element 21), and subtract
    the sum of range 0 to 9 (which was already available). You still have an *O*(*n*)
    algorithm, but over time, it becomes an *O*(1) process; initial delays become
    amortized. But you can do even better.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的效果更好，工作量更少。例如，如果你请求从第10到第20的区间和，所有从0到0、0到1、0到2，依此类推，直到0到20的所有和都需要被缓存。如果你接着请求第10到第21的区间和，它会尝试立即计算0到21的和（即0到20的和加上第21个元素），并减去已经可得的0到9的和。你依然有一个
    *O*(*n*) 算法，但随着时间的推移，它变成了 *O*(1) 的过程；初始的延迟会被摊销。但你还可以做得更好。
- en: Summing Ranges by Precomputing with Bottom-Up DP
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过预计算并使用自底向上的动态规划来求和区间
- en: 'Seeing how totalWidth2(...) in the previous section needs the sums of ranges
    from 0 to all possible other positions, you could use tabulation to precompute
    all those values, and then all queries would be *O*(1). You can use an internal
    cache (partial) for those values:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看到上一节中的`totalWidth2(...)`需要计算从0到所有可能其他位置的范围和时，你可以使用表格法来预计算所有这些值，然后所有查询将是*O*(1)的。你可以使用内部缓存（`partial`）来存储这些值：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a bit trickier, because you are using a closure for the partial array,
    initialized in an immediately invoked function expression (IIFE). The precalculation
    sets up partial[k] to be the sum of the first *k* elements in the original array,
    which correctly implies that partial[0] should equal 0 ❶. (You are wasting an
    extra array place, but that’s irrelevant in comparison with the speedy algorithm
    that you’ll get.) You also use DP to calculate these partial sums: partial[i+1]
    is calculated based on the previous calculation of partial[i] ❷. The function
    you want will calculate the total between two elements ❸ by taking the sum up
    to the rightmost one (partial[to+1]) and subtracting the sum of elements up to,
    but not including, the leftmost one (partial[from]), which produces the desired
    *O*(1) algorithm. The IIFE trickery is done by providing the original array of
    widths as a parameter ❹. (See question 5.6 for yet another way of doing this work.)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点棘手，因为你使用了一个闭包来处理部分数组，该闭包在立即调用函数表达式（IIFE）中初始化。预计算将`partial[k]`设置为原始数组中前* k
    *个元素的和，这正确地意味着`partial[0]`应等于0 ❶。（你浪费了一个额外的数组位置，但与最终获得的快速算法相比，这并不重要。）你还使用动态规划（DP）来计算这些部分和：`partial[i+1]`是基于先前计算的`partial[i]`来计算的
    ❷。你想要的函数将通过获取到最右侧元素的和（`partial[to+1]`）并减去不包括最左侧元素的和（`partial[from]`）来计算两个元素之间的总和
    ❸，这样就实现了所需的*O*(1)算法。IIFE的巧妙之处在于通过将原始宽度数组作为参数传递 ❹。（参见第5.6题，了解另一种实现该工作的方式。）
- en: You’ve seen two different ways to use DP in a bottom-up fashion to optimize
    an algorithm, eventually reaching *O*(1) performance. Given that width calculations
    are frequently used to calculate line breaks, this is a game-changer for your
    code’s performance and usability.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到两种不同的方式，通过自下而上的动态规划优化算法，最终实现*O*(1)性能。鉴于宽度计算常用于计算换行，这对你代码的性能和可用性是一次重大改变。
- en: Brute-Force Search
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 穷举搜索
- en: Brute-force algorithms attempt to find a solution to a problem by systematically
    trying all possible combinations of values. The main issue with this kind of logic
    is the combinatorial explosion of the number of cases to try. The order of the
    resulting algorithms usually goes into exponential or factorial classes (as discussed
    in [Chapter 4](chapter4.xhtml)) that makes them potentially impossible to use
    for even modest-sized input.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 穷举算法尝试通过系统地尝试所有可能的值组合来找到问题的解决方案。这种逻辑的主要问题在于组合爆炸，试验的案例数成倍增加。由此产生的算法的时间复杂度通常进入指数级或阶乘级（如[第4章](chapter4.xhtml)所讨论），这使得即使是对于适中的输入也可能无法使用。
- en: We’ll look at a problem in each category, going from worse to worst. Given the
    resulting order of algorithms in this category, there’s no surprise that we’ll
    avoid this kind of code in the rest of the book.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按类别查看每个问题，从最差到最糟。鉴于该类别中算法的排序，毫不奇怪，我们将在本书的其余部分避免使用这种代码。
- en: Detecting Tautologies
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检测重言式
- en: 'In terms of logic, a tautology is a boolean expression that is always true.
    For instance, if X, Y, and Z are boolean variables, two of the following JavaScript
    expressions are tautologies:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑上，重言式是始终为真的布尔表达式。例如，如果X、Y和Z是布尔变量，以下两个JavaScript表达式是重言式：
- en: X OR Y OR (NOT X AND NOT Y)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X 或 Y 或（非 X 且 非 Y）
- en: X OR (NOT X AND Y) === X OR Y
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X 或（非 X 且 Y）=== X 或 Y
- en: (NOT X) OR (X AND Z) OR (NOT Y) OR (Y AND Z) OR Z
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （非 X）或（X 且 Z）或（非 Y）或（Y 且 Z）或 Z
- en: Even for readers well versed in logic and expressions, it may not be immediately
    obvious which of these expressions are always true.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是对逻辑和表达式非常熟悉的读者，也可能不立即清楚哪些表达式始终为真。
- en: Recognizing whether a function of *n* boolean parameters is a tautology potentially
    requires 2*^n* tests for each possible combination of true/false values, verifying
    for each one whether the function produces true as its result. Alternatively,
    you could try to find some combination of arguments that would make it false,
    and upon finding such a case, you’d know that the function isn’t a tautology.
    That kind of search would require a logic similar to what you used to solve the
    Squarest Game on the Beach puzzle.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 判断一个有*n*个布尔参数的函数是否为恒等式，可能需要进行2*^n*次测试，检查每种可能的真/假值组合，验证每种情况下该函数是否输出真。或者，你可以尝试找到某个使其为假的参数组合，一旦找到这样的情况，就知道该函数不是恒等式。这样的搜索需要类似于你在海滩上解决Squarest
    Game谜题时使用的逻辑。
- en: 'Using recursion comes in handy: if a function of *n* variables is a tautology,
    setting the first variable to false should also be a tautology, and the same would
    happen if the first variable were set to true. To see whether the original function
    is a tautology, you need to test a couple of functions with one fewer argument,
    which leads to a simple implementation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归非常方便：如果一个有*n*个变量的函数是恒等式，将第一个变量设置为假应该也是恒等式，如果第一个变量设置为真，同样也会是恒等式。为了检查原始函数是否为恒等式，你需要测试几个少一个参数的函数，这就导致了一个简单的实现：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The isTautology() function receives the original function to test, fn, and
    a list of arguments ❶. The latter will be the combination of values with which
    you’ll test whether the function is true. If you have the right number of arguments
    ❷, you evaluate the function ❸, and if it produces a false value ❹, you’ll log
    the fact and return false, which will short-circuit all future and pending evaluations.
    If the function returns true, the search will continue. If not enough arguments
    were provided ❺, you’ll test the function twice: adding a true and adding a false
    to the list of arguments, so all combinations will be tested eventually.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: isTautology()函数接收要测试的原始函数fn和一个参数列表❶。后者将是你用来测试函数是否为真的值的组合。如果你有正确数量的参数❷，你将评估该函数❸，如果它返回假值❹，你会记录这个事实并返回假值，这将中断所有未来和挂起的评估。如果函数返回真，搜索将继续。如果提供的参数不足❺，你将测试该函数两次：一次添加真值，一次添加假值到参数列表中，最终所有组合都会被测试。
- en: 'The following tests the three boolean expressions mentioned earlier:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试之前提到的三个布尔表达式：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first two functions actually were tautologies, but the last one wasn’t.
    The search listed at least one case where the failed function evaluates to false.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数实际上是恒等式，但最后一个不是。搜索列出了至少一个失败的情况，其中该函数的计算结果为假。
- en: Solving Cryptarithmetic Puzzles
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决密码算术谜题
- en: '*Cryptarithmetic puzzles* (also known as *cryptarithms*) are puzzles that provide
    a mathematical equation where the digits have been replaced by letters of the
    alphabet. The goal for the solver is to find which letter stands for which digit.
    Usually no numbers may start with zero, all letters should have different values,
    and the equation should translate to a phrase that makes sense. [Figure 5-15](chapter5.xhtml#fig5-15)
    shows an early example of this, which was invented by British writer, puzzlist
    and mathematician Henry Ernest Dudeney in 1924.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码算术谜题*（也称为*密码算式*）是一类数学谜题，其中数字被字母替换。解答者的目标是找出每个字母代表的数字。通常，数字不能以零开头，所有字母的值必须不同，并且方程式应该翻译成一个有意义的短语。[图5-15](chapter5.xhtml#fig5-15)展示了一个早期的例子，这个谜题由英国作家、谜题专家和数学家亨利·厄尼斯特·杜德尼（Henry
    Ernest Dudeney）于1924年发明。'
- en: '![](../images/Figure5-15.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-15.jpg)'
- en: 'Figure 5-15: A classic cryptarithmetic puzzle'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-15：经典密码算术谜题
- en: You could solve this sort of puzzle with careful analysis (see question 5.7
    for another example), but here you will write a solver that goes through all possible
    combinations of digits, checking whether any work. In this example, given that
    there are 10 digits, you need to check 10! (3,628,800) combinations, but some
    puzzles have numeric bases other than 10, so in general, this is an *O*(*n*!)
    algorithm. A similar example (in terms of its solution) is the traveling salesman
    problem that provides a list of *n* cities and the distances between each pair
    of cities; you need to find the shortest possible route that visits each city
    only once, returning to the starting city. The solution to this is likewise *O*(*n*!),
    and the algorithm is similar to the one you’ll see next. (You’ll also see a different
    type of solution using a greedy algorithm for this problem, later in this chapter.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过仔细分析来解决这种谜题（请参见问题 5.7 中的另一个例子），但在这里你将编写一个求解器，遍历所有可能的数字组合，检查是否有可行的解。在这个例子中，考虑到有
    10 个数字，你需要检查 10!（3,628,800）种组合，但有些谜题使用的是不同的数值基数，因此通常来说，这是一个 *O*(*n*!) 算法。一个类似的例子（就解决方法而言）是旅行商问题，它提供了
    *n* 个城市和每对城市之间的距离；你需要找到一个最短的路线，访问每个城市仅一次，并最终返回到起始城市。这个问题的解决方法同样是 *O*(*n*!)，其算法与接下来你将看到的类似。（你还将看到一种使用贪心算法来解决该问题的不同类型的解决方案，稍后会在本章中讨论。）
- en: 'What algorithm do we need? The idea is simple: try all combinations of digits
    from 0123456789 to 9876543210, and check for each one whether the puzzle is solved.
    (In this case, you’ll use only the first eight digits, but that really doesn’t
    change anything.) You could design the main logic as follows, assuming that puzzle()
    is a function to test whether a combination is valid:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要什么算法？这个想法很简单：尝试从 0123456789 到 9876543210 的所有数字组合，并检查每一个是否能解开谜题。（在这个例子中，你只会使用前八个数字，但这并不会改变任何事情。）你可以设计如下的主要逻辑，假设
    puzzle() 是一个用于测试组合是否合法的函数：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The digits parameter ❶ will have the set of digits that you’ll use for the problem;
    although in this case, 0 to 9 are the possible values, you may as well write code
    that could be used for cryptarithmetic puzzles in other bases. Make a local copy
    of the set of digits ❷ to avoid modifying the original argument and to avoid a
    side effect (as discussed in [Chapter 2](chapter2.xhtml)), and sort it to go through
    the combinations in ascending order. Then set a loop ❸ that will exit when you
    either find a solution or decide none exists. If the current combination of digits
    works out ❹, log it and exit; otherwise, generate the next combination of digits
    ❺ and keep looping, unless you reach the last combination, and then you’ll know
    that the problem has no solution.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: digits 参数 ❶ 将包含你用于此问题的数字集；尽管在这种情况下，可能的值是 0 到 9，但你也可以编写适用于其他进制的密码算术谜题的代码。制作一个
    digits 集合的本地副本 ❷，以避免修改原始参数并避免副作用（如 [第 2 章](chapter2.xhtml) 中讨论的那样），并将其排序，以便按升序遍历所有组合。然后设置一个循环
    ❸，当你找到解或者决定没有解时退出。如果当前数字组合有效 ❹，记录结果并退出；否则，生成下一个数字组合 ❺ 并继续循环，直到到达最后一个组合，这时你就知道这个问题没有解。
- en: 'Generating the next permutation of a given set is a well-known algorithm, likely
    discovered by Indian mathematician Narayana Pandita in the 14th century. Assuming
    that the current permutation is stored in array d, it requires four steps, in
    order:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 生成给定集合的下一个排列是一个众所周知的算法，可能是由印度数学家纳拉扬·潘迪塔（Narayana Pandita）在 14 世纪发现的。假设当前的排列存储在数组
    d 中，它需要四个步骤，按顺序执行：
- en: 1. Find the rightmost index p such that d[p] < d[p + 1]; if no such p exists,
    you were already at the last permutation, and the algorithm finishes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 找到最右侧的索引 p，使得 d[p] < d[p + 1]；如果没有这样的 p，说明你已经到了最后一个排列，算法结束。
- en: 2. Find the rightmost index q such that d[p] < d[q]; d[q] is the least value
    to the right of d[p]greater than it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 找到最右侧的索引 q，使得 d[p] < d[q]；d[q] 是 d[p] 右侧最小的比 d[p] 大的值。
- en: 3. Swap the values of d[p] and d[q]; now the values from d[p + 1] to the end
    of d will be in descending order.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 交换 d[p] 和 d[q] 的值；现在从 d[p + 1] 到 d 末尾的值将按降序排列。
- en: 4. Reverse the list of values from d[p + 1] to the end of d.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 将 d[p + 1] 到 d 末尾的值反转。
- en: '[Figure 5-16](chapter5.xhtml#fig5-16) shows a working example, starting with
    permutation 8403976521.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-16](chapter5.xhtml#fig5-16) 显示了一个有效的例子，从排列 8403976521 开始。'
- en: '![](../images/Figure5-16.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-16.jpg)'
- en: 'Figure 5-16: Generating the next permutation'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-16：生成下一个排列
- en: 'Step 1 sets p to point at 3, because 3 < 9; all other elements from the right
    (976521) are in descending order. Step 2 sets q to point at 5, the least value
    to the right of 3 that is greater than it. Step 3 swaps the values pointed by
    p and q; values to the right of p are again in descending order (976321). Step
    4 ends by reversing the values to the right of p, which end in ascending order
    (123679), and you get the next permutation: 8405123679.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1将p指向3，因为3 < 9；右侧所有其他元素（976521）是降序排列的。步骤2将q指向5，这是3右侧大于它的最小值。步骤3交换p和q所指向的值；p右侧的值再次按降序排列（976321）。步骤4通过反转p右侧的值来结束，使其变为升序排列（123679），你得到了下一个排列：8405123679。
- en: 'With this logic, you can see the complete version of the cryptarithmetic puzzle
    solver by adding the code to generate permutations:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个逻辑，你可以通过添加生成排列的代码，看到完整版本的加密算术谜题求解器：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code is the same as earlier, with steps 1 through 4 of the permutation
    algorithm highlighted.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前相同，突出显示了排列算法的步骤1到步骤4。
- en: 'You can now write a function to test whether a given combination of values
    is actually a solution:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以编写一个函数来测试给定的值组合是否实际上是一个解：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The function is called with all 10 digits ❶, but you use only the first 8, ignoring
    the last 2\. If a leading digit is 0 ❷, the solution isn’t valid, so reject that
    out of hand. If there are no leading zeros ❸, compute the values of the three
    words (SEND, MORE, and MONEY) and we check whether they fulfill the original equation.
    Given this function, all you need to do is pass it to the solve() function ❹ and
    wait (very little) for the solution to appear.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被调用时，传入了所有10个数字❶，但你只使用前8个，忽略最后2个。如果首位数字为0 ❷，则解无效，因此直接拒绝。如果没有前导零 ❸，则计算三个单词（SEND、MORE和MONEY）的值，并检查它们是否满足原始方程。给定这个函数，你只需要将其传递给solve()函数
    ❹，然后稍等片刻（很短时间）就能得到解。
- en: '### Greedy Algorithms'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '### 贪心算法'
- en: 'Let’s conclude with a set of algorithms that have a rather curious characteristic:
    they may not always work. The basic definition of an algorithm implies that it’s
    a well-defined procedure to solve a problem or accomplish some task. *Greedy algorithms*
    may (or may not) achieve that.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们总结一组具有相当奇特特点的算法：它们可能并不总是有效。算法的基本定义意味着它是一个明确的程序，用于解决问题或完成任务。*贪心算法*可能（也可能不会）做到这一点。
- en: Sometimes a heuristic is used to describe a way to get a (hopefully not too
    bad) solution in a faster way by applying some arbitrary choices instead of doing
    a thorough search. For instance, a chess algorithm could, in principle, always
    find the best move by considering all possible moves and all possible opponent
    responses, and all possible responses to those responses, and so on, but that
    approach grows exponentially and isn’t feasible. The alternative is a heuristic.
    Reconsidering the chess example, instead of going to the maximum depth, you would
    stop the search short after a few moves, do a ballpark evaluation of the resulting
    board positions, and choose the move that leads to the best evaluated move. This
    method doesn’t *guarantee* making the best move, but it at least provides some
    solution.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会使用启发式方法来描述通过应用一些任意选择而不是进行彻底搜索，从而更快速地获得一个（希望不是太糟糕的）解决方案。例如，一个国际象棋算法原则上可以通过考虑所有可能的走法、所有可能的对手反应以及所有可能的反应来找到最佳走法，但这种方法的复杂度呈指数增长，因此不可行。另一种选择是启发式方法。以国际象棋为例，避免达到最大深度，而是在几步之后停止搜索，对结果的棋盘位置进行粗略评估，并选择最佳评估的走法。这个方法并不能*保证*做出最佳走法，但至少能提供某种解决方案。
- en: Greedy algorithms are usually applied to optimization problems. You’ve seen
    algorithms that use brute force to try all possibilities; greedy algorithms don’t
    do that. At each step where a decision needs to be made, these algorithms make
    the best possible choice at the time. On one hand, this approach ensures that
    the algorithm proceeds quickly without needing to backtrack. On the other hand,
    the algorithm doesn’t necessarily make the best choice, because it doesn’t look
    far enough ahead. However, under certain conditions, which you’ll explore in the
    following sections, these algorithms perform well and are successful.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心算法通常应用于优化问题。你已经见过使用暴力算法尝试所有可能性的算法；贪心算法则不是这样。每当需要做出决策时，这些算法会在当时做出最佳选择。一方面，这种方法确保算法快速执行，不需要回溯。另一方面，算法不一定做出最佳选择，因为它并没有足够地考虑未来。然而，在某些条件下，正如你在接下来的章节中将会探索的，这些算法表现良好并且成功。
- en: How to Make Change
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何找零
- en: 'How do you make change using the fewest bills and coins? In other words, suppose
    you have to pay out some amount using today’s US currency: $100, $50, $20, $10,
    $5, and $1 bills and $0.25 (quarter), $0.10 (dime), $0.05 (nickel), and $0.01
    (penny) coins. How would you pay $229.60? You could use so many combinations to
    reach that amount, but with a greedy algorithm, you would follow this simple rule:
    at each step, choose as many as possible units of the largest possible denomination,
    and keep going until you’re done.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如何用最少的钞票和硬币找零？换句话说，假设你必须用今天的美国货币支付某个金额：$100、$50、$20、$10、$5和$1钞票，以及$0.25（四分之一美元）、$0.10（十分之一美元）、$0.05（镍币）和$0.01（分币）硬币。如何支付$229.60？你可以使用许多组合来达到这个金额，但使用贪心算法时，你会遵循这样一个简单规则：每一步选择尽可能多的最大面额单位，直到完成为止。
- en: The method starts by using two $100 bills, then one $20, a $5, four $1s, two
    quarters, and a dime. No other solution involves fewer bills and coins. This greedy
    algorithm is guaranteed to succeed, but it depends on the available denominations.
    Paying out $16 (the greedy way) in a country that had $9, $8, and $1 bills would
    end up with one $9 and seven $1 bills, instead of using just two $8 bills. Greedy
    algorithms may (or may not) succeed depending on the case.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从使用两张$100钞票开始，然后是$20钞票、一张$5钞票、四张$1钞票、两枚四分之一美元硬币和一枚十分之一美元硬币。没有其他解决方案涉及更少的钞票和硬币。这个贪心算法保证能够成功，但它依赖于可用的面额。在一个只有$9、$8和$1钞票的国家，支付$16（贪心方式）将会得到一张$9钞票和七张$1钞票，而不是使用仅仅两张$8钞票。贪心算法的成功与否取决于具体情况。
- en: The Traveling Salesman Problem
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旅行商问题
- en: 'Let’s consider a problem that requires a brute-force search but that a greedy
    algorithm usually solves quite well. The traveling salesman problem works like
    this: imagine a salesman has to do a tour, visiting each city on a list once and
    then returning to the starting point. (In graph terms, this is called a *Hamiltonian
    cycle*.) Distances (or costs) for traveling between cities is known. What’s the
    shortest (or cheapest) way to achieve the task?'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个通常需要暴力搜索但贪心算法通常能很好解决的问题。旅行商问题是这样的：想象一个销售员必须进行一次旅行，访问列表上的每个城市一次，然后返回起点。（在图论中，这称为*哈密顿回路*。）城市间的旅行距离（或费用）是已知的。如何以最短（或最便宜）的方式完成任务？
- en: As is, an algorithm for this problem would require testing all possible permutations
    of cities (as you did previously for the SEND + MORE = MONEY cryptarithmetic puzzle).
    If the number of cities grows, the problem becomes intractable because the required
    time to run the algorithm takes too long.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按照目前的方式，解决这个问题的算法需要测试所有可能的城市排列（就像你之前为SEND + MORE = MONEY谜题所做的那样）。如果城市数量增多，问题将变得无法处理，因为运行算法所需的时间会过长。
- en: 'A greedy algorithm for this problem (which may not find the best solution but
    performs quickly) would proceed as follows: at each step visit the nearest not-yet-visited
    city. This method won’t necessarily find the best possible path, and several heuristics
    may discover an even better one, but under some conditions, the algorithm finds
    the optimal solution.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的贪心算法（虽然可能找不到最佳解，但执行迅速）将按如下方式进行：每一步访问最近的未访问城市。此方法不一定能找到最佳路径，几种启发式方法可能会发现一个更好的路径，但在某些条件下，算法能找到最优解。
- en: Minimum Spanning Tree
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最小生成树
- en: Let’s wrap up our discussion of greedy algorithms by considering a problem you’ll
    explore in [Chapter 17](chapter17.xhtml). Imagine a cable TV company must provide
    service to several houses. The company cannot place cables just anywhere and must
    follow existing roads. Where should it put cables to minimize the total cost?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑一个问题来结束我们对贪心算法的讨论，这个问题你将在[第17章](chapter17.xhtml)中探讨。想象一下，某个有线电视公司必须为几户家庭提供服务。公司不能随便铺设电缆，必须遵循现有的道路。为了最小化总成本，它应将电缆铺设在哪里？
- en: The solution for this is technically called a *minimum spanning tree*, and Kruskal’s
    algorithm (which you’ll implement in [Chapter 17](chapter17.xhtml)) is a greedy
    algorithm that solves it and is guaranteed to find the optimal solution. Start
    by choosing the cheapest segment of road until all houses are connected, and always
    add the cheapest possible segment that won’t generate a loop; after all, what
    good would having a closed cable loop be?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题的解决方案在技术上称为*最小生成树*，而克鲁斯卡尔算法（你将在[第17章](chapter17.xhtml)中实现它）是一个贪心算法，能够解决这个问题，并且保证找到最优解。从选择最便宜的路段开始，直到所有房屋都连接起来，并且始终添加最便宜的不会产生回路的路段；毕竟，拥有一个封闭的电缆回路又有什么用呢？
- en: You can solve other graph-related problems using greedy algorithms, so this
    technique may also be a valid one to consider when trying to write code for a
    specific problem.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用贪心算法解决其他与图相关的问题，因此，当尝试为特定问题编写代码时，这种技术可能也是一个有效的选择。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we considered several techniques (recursion, DP, and brute-force
    and greedy algorithms) that will help you develop algorithms on your own, and
    they’ll appear again several times in the rest of the book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑了几种技术（递归、动态规划、暴力法和贪心算法），这些技术将帮助你独立开发算法，它们将在本书的其余部分再次出现。
- en: In the next chapter, we’ll explore several common problems, such as sorting,
    selecting, shuffling, sampling, and searching—that’s a lot of alliteration but
    also a lot of interesting code and plenty of opportunities to study how to write
    algorithms.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨几个常见问题，如排序、选择、洗牌、采样和搜索——这有很多头韵，但也有很多有趣的代码，并且有充足的机会让你学习如何编写算法。
- en: Questions
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: '**5.1  Factorial in One**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.1  一阶阶乘**'
- en: The code for factorial() is totally correct, but it’s seven lines long! Not
    that it matters (having a long correct function is better than a short incorrect
    one), but can you write it in a more compact way?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: factorial() 的代码完全正确，但它有七行！虽然这并不重要（一个长的正确函数比一个短的错误函数要好），但你能把它写得更紧凑一些吗？
- en: '**5.2  Hanoi by Hand**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.2  手动汉诺塔**'
- en: The recursive algorithm for the Towers of Hanoi is good for computers, but not
    so much for normal human beings. Can you design a simple algorithm to solve the
    puzzle that doesn’t involve recursion?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 汉诺塔的递归算法对计算机来说是不错的，但对普通人类来说却不太适用。你能设计一种简单的非递归算法来解决这个难题吗？
- en: '**5.3  Archery Backtracking**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.3  射箭回溯**'
- en: Sam Loyd devised another puzzle (see [Figure 5-17](chapter5.xhtml#fig5-17))
    similar to the Squarest Game on the Beach that you solved earlier in this chapter.
    In this puzzle, you need to get 100 points by aiming arrows at the target. The
    important difference is that in this puzzle, you can hit a ring two or more times,
    while in the other problem you could drop a doll only once.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Sam Loyd 设计了另一个类似于你在本章早些时候解决的《沙滩上的方块游戏》的难题（见 [图5-17](chapter5.xhtml#fig5-17)）。在这个难题中，你需要通过将箭矢射向目标来获得100分。重要的区别在于，在这个难题中，你可以多次击中一个靶环，而在另一个问题中你只能投掷一个娃娃一次。
- en: '![](../images/Figure5-17.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-17.jpg)'
- en: 'Figure 5-17: Another classic puzzle by Sam Loyd, where players must get exactly
    100 points with their arrows (public domain)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-17：Sam Loyd的另一个经典难题，玩家必须用箭矢精确击中100分（公共领域）
- en: Can you modify the backtracking algorithm to deal with this variation? And,
    even with the differences, can you still use the solve() function that you used
    for the other puzzle to find the solution?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你能修改回溯算法来处理这个变体吗？即使存在差异，你还能使用之前解决其他难题时用过的 solve() 函数来找到解吗？
- en: '**5.4  Counting Calls**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.4  计数调用**'
- en: 'If you call *C*(*n*), the total number of calls needed to calculate the *n*th
    Fibonacci number with your recursive implementation, you will see, for example,
    that *C*(7) = 41\. Can you give a recurrence for *C*(*n*) and find an explicit
    solution for it? Hint: the answer will again involve Fibonacci numbers.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用 *C*(*n*)，也就是用递归实现计算第 *n* 个斐波那契数所需的调用总次数，例如你会看到 *C*(7) = 41。你能为 *C*(*n*)
    给出一个递推公式并找到它的显式解吗？提示：答案将再次涉及斐波那契数。
- en: '**5.5  Avoid More Work**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.5  避免过多工作**'
- en: When considering how to arrange blocks in rows (in “Line Breaking with Top-Down
    DP” on [page 74](chapter5.xhtml#pg_74)) and when considering splits, you analyzed
    them as (7, 2, 5) and (3, 6) or (7, 2, 5, 3) and (6). However, this wasn’t really
    needed because blocks 7 + 2 + 5 or 7 + 2 + 5 + 3 couldn’t fit in a line. [Figure
    5-18](chapter5.xhtml#fig5-18) shows crossed-out options that an enhanced algorithm
    wouldn’t have considered.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑如何在行中排列块（在“使用自顶向下的动态规划进行行断裂”中见 [第74页](chapter5.xhtml#pg_74)）以及考虑拆分时，你分析了它们作为（7,
    2, 5）和（3, 6）或（7, 2, 5, 3）和（6）。然而，这其实并不必要，因为块 7 + 2 + 5 或 7 + 2 + 5 + 3 无法适应一行。[图5-18](chapter5.xhtml#fig5-18)
    显示了一个增强算法不会考虑的被划去的选项。
- en: '![](../images/Figure5-18.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-18.jpg)'
- en: 'Figure 5-18: An even more efficient way to find row breaks'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-18：一种更高效的找到行断点的方法
- en: Can you add this optimization to the code?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你能将这个优化添加到代码中吗？
- en: '**5.6  Reduce for Clarity**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.6  简化以提高清晰度**'
- en: The totalWidth3(...) function (in the section “Summing Ranges by Precomputing
    with Bottom-Up DP” on [page 81](chapter5.xhtml#pg_81)) used a common loop to generate
    the partial array. Can you do the same using .reduce(...) instead?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: totalWidth3(...) 函数（在“通过自底向上的动态规划预计算求和范围”这一节中，参见[第81页](chapter5.xhtml#pg_81)）使用了一个常见的循环来生成部分数组。你能用.reduce(...)来替代这个方法吗？
- en: '**5.7  Got GOUT?**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.7  得了痛风吗？**'
- en: '[Figure 5-19](chapter5.xhtml#fig5-19) shows another well-known cryptarithmetic
    puzzle; find what each letter stands for, and then the value of GOUT is your answer.
    You can solve this with the techniques shown earlier in the chapter, or you could
    try your hand at directly working it out.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-19](chapter5.xhtml#fig5-19)展示了另一个著名的密码算术谜题；找到每个字母代表的含义，然后GOUT的值就是你的答案。你可以使用本章前面介绍的技巧来解决这个问题，或者也可以尝试直接解答。'
- en: '![](../images/Figure5-19.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-19.jpg)'
- en: 'Figure 5-19: A simple cryptarithmetic puzzle with only four letters to find'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-19：一个简单的密码算术谜题，只有四个字母需要找到
