- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: LANGUAGE PROCESSING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言处理**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: It’s pretty clear that only crazy people would try to write computer programs.
    That’s always been true, but *programming languages* at least make the job a lot
    easier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，只有疯子才会尝试编写计算机程序。这个一直都是真的，但*编程语言*至少让这项工作变得容易了很多。
- en: This chapter examines how programming languages are implemented. Its aim is
    to help you develop an understanding of what happens with your code. You’ll also
    learn how the code you write is transformed into an executable form called *machine
    language*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了编程语言是如何实现的。其目的是帮助你理解代码发生了什么。你还将了解你编写的代码是如何转换为可执行的*机器语言*。
- en: '**Assembly Language**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**汇编语言**'
- en: We saw a machine language implementation of a program to compute Fibonacci numbers
    back in [Table 4-4](ch04.xhtml#ch04tab04) on [page 108](ch04.xhtml#page_108).
    As you might imagine, figuring out all the bit combinations for instructions is
    pretty painful. Primitive computer programmers got tired of this and came up with
    a better way to write computer programs, called *assembly language*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[表 4-4](ch04.xhtml#ch04tab04)的[第 108 页](ch04.xhtml#page_108)看到过一个用机器语言实现的计算斐波那契数的程序。正如你想象的那样，搞清楚所有的位组合指令是相当痛苦的。原始的计算机程序员厌倦了这种方式，发明了一种更好的编写计算机程序的方法，称为*汇编语言*。
- en: Assembly language did a few amazing things. It let programmers use *mnemonics*
    for instructions so they didn’t have to memorize all the bit combinations. It
    allowed them to give names or *labels* to addresses. And it allowed them to include
    *comments* that can help other people read and understand the program.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言做了几件了不起的事情。它让程序员可以使用*助记符*来表示指令，这样他们就不必记住所有的位组合。它允许程序员为地址命名或使用*标签*。还允许程序员加入*注释*，帮助其他人阅读和理解程序。
- en: A program called an *assembler* reads assembly language programs and produces
    *machine code* from them, filling in the values of the labels or *symbols* as
    it goes. This is especially helpful because it prevents dumb errors caused by
    moving things around.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为*汇编器*的程序读取汇编语言程序，并从中生成*机器代码*，在这个过程中填充标签或*符号*的值。这特别有帮助，因为它能防止因移动内容而导致的愚蠢错误。
- en: '[Listing 8-1](ch08.xhtml#ch08list01) shows what the Fibonacci program from
    [Table 4-4](ch04.xhtml#ch04tab04) looks like in the hypothetical assembly language
    from [Chapter 4](ch04.xhtml#ch04).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](ch08.xhtml#ch08list01)展示了[表 4-4](ch04.xhtml#ch04tab04)中的斐波那契程序在假设的汇编语言中的样子，来自[第
    4 章](ch04.xhtml#ch04)。'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: Assembly language program to compute the Fibonacci sequence*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：计算斐波那契数列的汇编语言程序*'
- en: The `bss` (which stands for *block started by symbol*) *pseudo-instruction*
    reserves a chunk of memory—in this case, one address—without putting anything
    in that location. Pseudo-instructions don’t have a direct correspondence with
    machine language instructions; they’re instructions to the assembler. As you can
    see, assembly language is much easier to deal with than machine language, but
    it’s still pretty tedious stuff.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`bss`（代表*以符号开始的块*）*伪指令*预留了一块内存——在此例中是一个地址——但并没有在该位置存放任何内容。伪指令与机器语言指令没有直接的对应关系；它们是对汇编器的指令。正如你所看到的，汇编语言比机器语言更容易处理，但它仍然是非常繁琐的内容。'
- en: Early programmers had to pull themselves up by their own bootstraps. There *was*
    no assembler to use when the first computer was made, so programmers had to write
    the first one the hard way, by figuring out all the bits by hand. This first assembler
    was quite primitive, but once it worked, it could be used to make a better one,
    and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的程序员必须依靠自己的力量。最初的计算机没有汇编器可用，因此程序员不得不通过手动计算所有的位来编写第一个汇编器。这个第一个汇编器非常原始，但一旦它能工作，就可以用它来制作更好的版本，依此类推。
- en: The term *bootstrap* has stuck around, although it’s often shortened to *boot*.
    Booting a computer often involves loading a small program, which loads a bigger
    one, which in turn loads an even bigger one. On early computers, people had to
    enter the initial bootstrap program by hand, using switches and lights on the
    front panel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: “*引导*”这个术语一直沿用至今，尽管它常常缩写为*引导*。启动计算机通常涉及加载一个小程序，该程序再加载一个更大的程序，然后再加载一个更大的程序。在早期的计算机上，人们必须通过手动输入初始引导程序，使用面板上的开关和指示灯。
- en: '**High-Level Languages**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**高级语言**'
- en: 'Assembly language helped a lot, but as you can see, doing simple things with
    it still takes a lot of work. We’d really like to be able to use fewer words to
    describe more complicated tasks. Fred Brooks’s 1975 book *The Mythical Man-Month:
    Essays on Software Engineering* (Addison-Wesley) claims that on average, a programmer
    can write 3 to 10 lines of documented, debugged code per day. So a lot more work
    could get done if a line of code did more.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言帮助了很多，但正如你所看到的，用它做简单的事情仍然需要很多工作。我们真的希望能够用更少的单词描述更复杂的任务。弗雷德·布鲁克斯（Fred Brooks）在
    1975 年的书《人月神话：软件工程的论文》（Addison-Wesley）中指出，平均而言，一个程序员每天可以编写 3 到 10 行已文档化、调试完毕的代码。所以，如果一行代码能做更多的事情，会有更多的工作完成。
- en: Enter *high-level languages*, which operate at a higher level of abstraction
    than assembly language. Source code in high-level languages is run through a program
    called a *compiler*, which translates or *compiles* it into machine language,
    also known as *object* code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 于是，*高级语言*应运而生，它们在比汇编语言更高的抽象层次上运行。高级语言中的源代码通过一个叫做*编译器*的程序运行，编译器将其翻译或*编译*成机器语言，也就是*目标*代码。
- en: Thousands of high-level languages have been invented. Some are very general,
    and some are designed for specific tasks. One of the first high-level languages
    was called FORTRAN, which stood for “formula translator.” You could use it to
    easily write programs that solved formulas like *y* = *m* × *x* + *b*. [Listing
    8-2](ch08.xhtml#ch08list02) shows what our Fibonacci sequence program would look
    like in FORTRAN.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数以千计的高级语言被发明出来。有些是非常通用的，有些是专门为特定任务设计的。最早的高级语言之一是 FORTRAN，代表“公式翻译器”。你可以用它轻松地编写求解公式的程序，如*y*
    = *m* × *x* + *b*。[列表 8-2](ch08.xhtml#ch08list02)展示了我们斐波那契数列程序在 FORTRAN 中的样子。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 8-2: Fibonacci sequence program in FORTRAN*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：FORTRAN 中的斐波那契数列程序*'
- en: Quite a bit simpler than assembly language, isn’t it? Note that lines that begin
    with the letter `C` are comments. And although we have labels, they must be numbers.
    Also note that we don’t have to explicitly declare memory that we want to use—it
    just magically appears when we use *variables* such as *I* and *J*. FORTRAN did
    something interesting (or ugly, depending on your point of view) that still reverberates
    today. Any variable name that began with the letter *I*, *J*, *K*, *L*, *M*, or
    *N* was an integer, which was borrowed from the way mathematicians write proofs.
    Variables beginning with any other letter were floating-point, or REAL in FORTRAN-speak.
    Generations of former FORTRAN programmers still use *i*, *j*, *k*, *l*, *m*, and
    *n* or their upper-case equivalents as names for integer variables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 比汇编语言简单多了，不是吗？请注意，以字母`C`开头的行是注释。尽管我们有标签，它们必须是数字。另外，注意我们不需要显式声明我们想要使用的内存——当我们使用像*I*和*J*这样的*变量*时，它们会自动出现。FORTRAN
    做了一件有趣（或者说丑陋，取决于你的观点）且至今仍然影响深远的事情。任何以字母*I*、*J*、*K*、*L*、*M*或*N*开头的变量都是整数，这是借鉴了数学家写证明的方式。以其他字母开头的变量则是浮点数，或者在
    FORTRAN 中称为 REAL。几代曾经的 FORTRAN 程序员仍然使用*i*、*j*、*k*、*l*、*m*和*n*或它们的大写形式作为整数变量的名称。
- en: FORTRAN was a pretty cumbersome language that ran on the really big machines
    of the time. As smaller, cheaper machines became available (that is, ones that
    only took up a small room), people came up with other languages. Most of these
    new languages, such as BASIC (which stood for “Beginner’s All-purpose Symbolic
    Instruction Code”), were variations on the FORTRAN theme. All of these languages
    suffered from the same problem. As programs increased in complexity, the network
    of line numbers and `GOTO`s became an unmanageable tangle. People would write
    programs with the label numbers all in order and then have to make a change that
    would mess it up. Many programmers started off by using labels 10 or 100 apart
    so that they’d have room to backfill later, but even that didn’t always work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: FORTRAN 是一种相当笨重的语言，运行在当时的巨大机器上。随着更小、更便宜的机器问世（也就是只占一个小房间的机器），人们发明了其他语言。这些新语言大多数是
    FORTRAN 风格的变种。例如 BASIC（代表“初学者通用符号指令码”）。所有这些语言都有一个共同的问题。随着程序复杂度的增加，行号和 `GOTO` 的网络变得难以管理。人们编写程序时，会将标签号码按顺序排列，但一旦需要修改，就会导致混乱。许多程序员起初会把标签间隔设置为
    10 或 100，以便以后有空间补充，但即便如此，也并非总能奏效。
- en: '**Structured Programming**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结构化编程**'
- en: Languages like FORTRAN and BASIC are called *unstructured* because there is
    no structure to the way that labels and `GOTO`s are arranged. You can’t build
    a house by throwing a pile of lumber on the ground in real life, but you can in
    FORTRAN. I’m talking about original FORTRAN; over time, the language has evolved
    and incorporated structured programming. It’s still the most popular scientific
    language.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 像 FORTRAN 和 BASIC 这样的语言被称为 *非结构化*，因为它们的标签和 `GOTO` 排列没有结构。你不能通过把一堆木材扔在地上来建造房屋，但在
    FORTRAN 中你可以。我说的是原始的 FORTRAN；随着时间的推移，这种语言已经演变并融合了结构化编程。它仍然是最受欢迎的科学计算语言。
- en: '*Structured* programming languages were developed to address this *spaghetti
    code* problem by eliminating the need for the nasty `GOTO`. Some went too far.
    For example, Pascal got rid of it completely, resulting in a programming language
    that was useful only for teaching elementary structured programming. To be fair,
    that’s actually what it was designed to do. C, the successor to the Ken Thompson’s
    B, was originally developed by Dennis Ritchie at Bell Telephone Laboratories.
    It was very pragmatic and became one of the most widely used programming languages.
    A large number of later languages—including C++, Java, PHP, Python, and JavaScript—copied
    elements from C.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构化* 编程语言的出现是为了通过消除恶心的 `GOTO` 来解决 *意大利面条代码* 问题。有些语言走得太远。例如，Pascal 完全去除了 `GOTO`，结果它成为了一种仅用于教学基础结构化编程的编程语言。公平地说，这其实就是它的设计目的。C
    语言是 Ken Thompson 的 B 语言的继任者，最初由 Dennis Ritchie 在贝尔电话实验室开发。它非常务实，并成为最广泛使用的编程语言之一。大量后来的编程语言——包括
    C++、Java、PHP、Python 和 JavaScript——都从 C 语言中复制了许多元素。'
- en: '[Listing 8-3](ch08.xhtml#ch08list03) shows how our Fibonacci program might
    appear in JavaScript. Note the absence of explicit branching.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-3](ch08.xhtml#ch08list03) 展示了我们的 Fibonacci 程序在 JavaScript 中的实现。请注意没有显式的分支结构。'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-3: JavaScript program to compute Fibonacci sequence*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-3：用 JavaScript 计算 Fibonacci 数列的程序*'
- en: The statements inside the curly brackets `{}` are executed as long as the `while`
    condition in the parentheses is true. Execution continues after the `}` when that
    condition becomes false. The flow of control is cleaner, making the program easier
    to understand.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号 `{}` 内的语句会在括号内的 `while` 条件为真时执行。当条件变为假时，执行会在 `}` 后继续。控制流更加清晰，使得程序更易于理解。
- en: '**Lexical Analysis**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**词法分析**'
- en: Now let’s look at what it takes to process a language. We’ll start with *lexical
    analysis*, the process of converting *symbols* (characters) into *tokens* (words).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下处理语言需要什么。我们从 *词法分析* 开始，这个过程是将 *符号*（字符）转换为 *符号*（单词）。
- en: 'A simple way of looking at lexical analysis is to say that a language has two
    types of tokens: words and separators. For example, using the above rules, *lex
    luthor* (the author of all evil programming languages) has two word tokens (*lex*
    and *luthor*) and one separator token (the space). [Figure 8-1](ch08.xhtml#ch08fig01)
    shows a simple algorithm that divides its input into tokens.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的词法分析方式是说，一个语言有两种类型的符号：单词和分隔符。例如，按照上面的规则，*Lex Luthor*（所有邪恶编程语言的作者）有两个单词符号（*lex*
    和 *luthor*）和一个分隔符符号（空格）。[图 8-1](ch08.xhtml#ch08fig01) 展示了一个简单的算法，用于将输入分割成符号。
- en: '![Image](../images/08fig01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig01.jpg)'
- en: '*Figure 8-1: Simple lexical analysis*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：简单的词法分析*'
- en: It’s not enough to just extract tokens; we need to classify them because practical
    languages have many different types of tokens, such as names, numbers, and operators.
    Languages typically have operators and operands, just like math, and operands
    can be variables or constants (numbers). The free-form nature of many languages
    also complicates things—for example, when separators are implied, as in `A+B`
    as opposed to `A + B` (note the spaces). Both forms have the same interpretation,
    but the first form doesn’t have any explicit separators.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅提取符号是不够的；我们需要对它们进行分类，因为实际的编程语言有许多不同类型的符号，如名称、数字和运算符。语言通常有运算符和操作数，就像数学一样，操作数可以是变量或常量（数字）。许多语言的自由形式性质也使得事情更加复杂——例如，当分隔符是隐含的，如
    `A+B` 和 `A + B`（注意空格）的区别。两种形式的含义相同，但第一种形式没有显式的分隔符。
- en: Numeric constants are astonishingly hard to classify, even if we ignore the
    distinctions among octal, hexadecimal, integer, and floating-point numbers. Let’s
    diagram what constitutes a legitimate floating-point number. There are many ways
    to specify a floating-point number, including `1.`, `.1`, `1.2`, `+1.2`, `–.1`,
    `1e5`, `1e+5`, `1e–5`, and `1.2E5`, as shown in [Figure 8-2](ch08.xhtml#ch08fig02).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数值常量异常难以分类，即使我们忽略八进制、十六进制、整数和浮点数之间的区别。让我们画出构成合法浮点数的示意图。有许多方法可以表示浮点数，包括`1.`、`.1`、`1.2`、`+1.2`、`–.1`、`1e5`、`1e+5`、`1e–5`和`1.2E5`，如[图
    8-2](ch08.xhtml#ch08fig02)所示。
- en: '![Image](../images/08fig02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig02.jpg)'
- en: '*Figure 8-2: Diagram for floating-point numbers*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：浮点数的示意图*'
- en: We start at the bubble labeled 1\. A `+` or `–` character brings us to bubble
    2, while a `.` sends us to bubble 4\. We leave bubble 2 for bubble 4 when we get
    a `.` character, but we go to bubble 3 when we receive a digit. Bubbles 3 and
    4 accumulate digits. We’re done if we get a character for which no transition
    is shown. For example, if we received a space while at any of the bubbles, we’d
    be done. Of course, leaving bubble 2 without a digit or decimal point, bubble
    6 without a digit, or bubble 5 without a sign or digit is an error because it
    doesn’t produce a complete floating-point number. These paths are absent from
    the diagram for simplicity’s sake.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从标记为1的气泡开始。一个`+`或`–`字符将我们带到气泡2，而一个`.`将我们带到气泡4。当我们收到`.`字符时，我们从气泡2转移到气泡4，但当我们接收到一个数字时，我们转移到气泡3。气泡3和气泡4积累数字。如果接收到没有显示转换的字符，我们就结束了。例如，如果我们在任何气泡处收到一个空格，我们就结束了。当然，如果没有数字或小数点离开气泡2，或者没有数字离开气泡6，或者没有符号或数字离开气泡5，都会出错，因为这不能产生一个完整的浮点数。为了简化起见，这些路径在图中没有显示。
- en: This is a lot like trying to find treasure using a pirate map. As long as you’re
    following directions, you can get from one place to another. If you don’t follow
    directions—for example, with a Z at bubble 1—you fall off the map and get lost.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像是用海盗地图找宝藏一样。只要你按照指示走，你就可以从一个地方到另一个地方。如果你不按照指示走——例如，在气泡1处有一个Z——你就会掉出地图，迷失方向。
- en: You could view [Figure 8-2](ch08.xhtml#ch08fig02) as the specification for floating-point
    numbers and write software to implement it. There are other, more formal ways
    to write specifications, however, such as Backus-Naur form.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将[图 8-2](ch08.xhtml#ch08fig02)视为浮点数的规范，并编写软件来实现它。然而，还有其他更正式的写法来描述规范，比如巴克斯-诺尔范式。
- en: BACKUS-NAUR FORM
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 巴克斯-诺尔范式
- en: '*Backus-Naur form (BNF)* has its roots in the work of Indian Sanskrit scholar
    Pāṇini (approximately fifth century BCE). BNF is named after American computer
    scientist John Backus (1924–2007), who was also the inventor of FORTRAN, and Danish
    computer scientist Peter Naur (1928–2016). It’s a formal way to specify languages.
    We’re not going to go into great detail about it here, but it’s something you
    should be familiar with because it’s used in the *RFC* (request for comments)
    documents that define internet protocols, among other things. Here’s the BNF for
    a floating-point number:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*巴克斯-诺尔范式（BNF）* 起源于印度梵文学者巴尼尼（公元前五世纪左右）的研究。BNF以美国计算机科学家约翰·巴克斯（1924–2007）的名字命名，他还是FORTRAN的发明者，以及丹麦计算机科学家彼得·诺尔（1928–2016）。它是一种正式的语言规范方法。我们在这里不会深入探讨它，但你应该熟悉它，因为它在定义互联网协议等内容的*RFC*（请求评论）文档中得到了使用。下面是浮点数的BNF：'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Things on the left of the `::=` can be substituted for things on the right.
    The `|` indicates a choice, and things inside of quotes are literals, meaning
    that they must appear exactly as written.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`::=` 左边的内容可以替换为右边的内容。`|` 表示选择，括号中的内容是字面量，意味着它们必须完全按照写法出现。'
- en: '***State Machines***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***状态机***'
- en: Based just on the complexity of numbers, you can imagine that it would take
    a substantial amount of special case code to extract language tokens from input.
    [Figure 8-2](ch08.xhtml#ch08fig02) gave us a hint that there’s another approach.
    We can construct a *state machine*, which consists of a set of states and a list
    of what causes a transition from one state to another—exactly what we saw in [Figure
    8-2](ch08.xhtml#ch08fig02). We can arrange this information as shown in [Table
    8-1](ch08.xhtml#ch08tab01).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 仅从数字的复杂性来看，你可以想象，从输入中提取语言标记需要大量的特殊案例代码。[图 8-2](ch08.xhtml#ch08fig02)给了我们一个提示，表明还有另一种方法。我们可以构建一个*状态机*，它由一组状态和导致从一个状态过渡到另一个状态的条件组成——这正是我们在[图
    8-2](ch08.xhtml#ch08fig02)中看到的内容。我们可以按[表 8-1](ch08.xhtml#ch08tab01)所示的方式安排这些信息。
- en: '**Table 8-1:** State Table for Floating-Point Numbers'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** 浮点数状态表'
- en: '| **Input** | **State** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **输入** | **状态** |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
- en: '| 1 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
- en: '| 2 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
- en: '| 3 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
- en: '| 4 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
- en: '| 5 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
- en: '| 6 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
- en: '| 7 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
- en: '| 8 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
- en: '| 9 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 3 | 3 | 3 | 4 | 7 | 7 | 7 |'
- en: '| e | error | error | 5 | 5 | error | error | done |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| e | error | error | 5 | 5 | error | error | done |'
- en: '| E | error | error | 5 | 5 | error | error | done |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| E | error | error | 5 | 5 | error | error | done |'
- en: '| + | 2 | error | done | done | 6 | error | done |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| + | 2 | error | done | done | 6 | error | done |'
- en: '| – | 2 | error | done | done | 6 | error | done |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| – | 2 | error | done | done | 6 | error | done |'
- en: '| . | 4 | 4 | 4 | done | error | error | done |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| . | 4 | 4 | 4 | done | error | error | done |'
- en: '| other | error | error | done | done | error | error | done |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| other | error | error | done | done | error | error | done |'
- en: Looking at the table, you can see that when we’re in state 1, digits move us
    to state 3, `e` or `E` moves us to state 5, `+` or `–` to state 2, and `.` to
    state 4—anything else is an error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从表格中可以看出，当我们处于状态1时，数字将我们移到状态3，`e`或`E`将我们移到状态5，`+`或`–`将我们移到状态2，而`.`将我们移到状态4——其他任何情况都是错误。
- en: Using a state machine allows us to classify the input using a simple piece of
    code, as shown in [Listing 8-4](ch08.xhtml#ch08list04). Let’s use [Table 8-1](ch08.xhtml#ch08tab01),
    replacing `done` with `0` and `error` with `-1`. For simplicity, we’ll have an
    `other` row in the table for each of the other characters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态机可以让我们通过一段简单的代码来对输入进行分类，如[示例 8-4](ch08.xhtml#ch08list04)所示。我们将使用[表 8-1](ch08.xhtml#ch08tab01)，将`done`替换为`0`，将`error`替换为`-1`。为了简化起见，我们将为表格中的每个其他字符添加一行`other`。
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-4: Using a state machine*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-4：使用状态机*'
- en: This approach could easily be expanded to other types of tokens. Rather than
    have a single value for `done`, we could have a different value for each type
    of token.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以很容易地扩展到其他类型的令牌。我们可以为每种令牌类型设置不同的`done`值，而不是使用单一的值。
- en: '***Regular Expressions***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***正则表达式***'
- en: Building tables like [Table 8-1](ch08.xhtml#ch08tab01) from diagrams like [Figure
    8-2](ch08.xhtml#ch08fig02) is very cumbersome and error-prone for complicated
    languages. The solution is to create languages for specifying languages. American
    mathematician Stephen Cole Kleene (1909–1994) supplied the mathematical foundation
    for this approach way back in 1956\. Ken Thompson first converted it into software
    in 1968 as part of a text editor and then created the UNIX `grep` (which stands
    for “globally search a regular expression and print”) utility in 1974\. This popularized
    the term *regular expression*, which is now ubiquitous. Regular expressions are
    languages themselves, and of course there are now several incompatible regular
    expression languages. Regular expressions are a mainstay of *pattern matching*.
    [Figure 8-3](ch08.xhtml#ch08fig03) shows a regular expression that matches the
    pattern for a floating-point number.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将[表 8-1](ch08.xhtml#ch08tab01)这样的表格从[图 8-2](ch08.xhtml#ch08fig02)这样的图形中构建出来，对于复杂语言来说既繁琐又容易出错。解决方案是创建一种指定语言的语言。美国数学家斯蒂芬·科尔·克莱尼（1909–1994）在1956年提出了这一方法的数学基础。肯·汤普森于1968年首次将其转化为软件，作为文本编辑器的一部分，随后在1974年创建了UNIX的`grep`（表示“全局搜索正则表达式并打印”）工具。这使得“正则表达式”这一术语广为人知，现在它已经无处不在。正则表达式本身就是一种语言，当然现在也有几种不兼容的正则表达式语言。正则表达式是*模式匹配*的主力。[图
    8-3](ch08.xhtml#ch08fig03)展示了一个匹配浮点数模式的正则表达式。
- en: '![Image](../images/08fig03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig03.jpg)'
- en: '*Figure 8-3: Regular expression for floating-point number*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：浮点数的正则表达式*'
- en: This looks like gibberish but really only relies on a few simple rules. It’s
    processed from left to right, meaning that the expression `abc` would match the
    string of characters “abc”. If something in the pattern is followed by `?`, it
    means zero or one of those things, `*` means zero or more, and `+` means one or
    more. A set of characters enclosed in square brackets matches any single character
    in that set, so `[abc]` matches `a`, `b`, or `c`. The `.` matches any single character
    and so needs to be *escaped* with a backslash (`\`) so that it matches the `.`
    character only. The `|` means either the thing on the left or the thing on the
    right. Parentheses `()` are for grouping, just like in math.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是胡言乱语，但实际上只依赖于几个简单的规则。它是从左到右处理的，这意味着表达式`abc`会匹配字符“abc”序列。如果模式中的某个部分后面跟着`?`，表示零个或一个这样的东西，`*`表示零个或多个，`+`表示一个或多个。方括号`[]`内的字符集匹配该集合中的任意单个字符，因此`[abc]`匹配`a`、`b`或`c`。`.`匹配任意单个字符，因此需要用反斜杠（`\`）进行*转义*，这样它就只匹配`.`字符。`|`表示左边的东西或右边的东西。圆括号`()`用于分组，就像数学中的分组一样。
- en: Reading from left to right, we start with an optional plus or minus sign. This
    is followed by either zero or more digits, an optional decimal point, and one
    or more digits (which handles cases like `1.2` and `.2`), or by one or more digits,
    an optional decimal point, and zero or more digits (which handles the `1` and
    `1.` cases). This is followed by the exponent, which begins with an `E` or `e`,
    followed by an optional sign and one or more digits. Not as horrible as it first
    looked, is it?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右读取，我们首先是一个可选的加号或减号。接下来是零个或多个数字，一个可选的小数点，和一个或多个数字（处理`1.2`和`.2`的情况），或者是一个或多个数字，一个可选的小数点，和零个或多个数字（处理`1`和`1.`的情况）。接下来是指数部分，它以`E`或`e`开头，后面跟着一个可选的符号和一个或多个数字。看起来没那么可怕了，是吗？
- en: Having a regular expression language that processed input into tokens would
    be more useful if it automatically generated state tables. And we have one, thanks
    again to research at Bell Telephone Laboratories. In 1975, American physicist
    Mike Lesk—along with intern Eric Schmidt, who today is executive chairman of Google’s
    parent company, Alphabet—wrote a program called `lex`, short for “lexical analyzer.”
    As The Beatles said in “Penny Lane:” “It’s a *Kleene* machine.” An open source
    version called `flex` was later produced by the GNU project. These tools do exactly
    what we want. They produce a state table driven program that executes user-supplied
    program fragments when input matches regular expressions. For example, the simple
    `lex` program fragment in [Listing 8-5](ch08.xhtml#ch08list05) prints `ah` whenever
    it encounters either `ar` or `er` in the input and prints `er` whenever it encounters
    an `a` at the end of a word.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种正则表达式语言能将输入处理成词法单元（token），并且自动生成状态表，那将更加有用。幸运的是，我们正是有这样的一种语言，再次感谢贝尔电话实验室的研究。1975年，美国物理学家迈克·莱斯克（Mike
    Lesk）——以及当时的实习生埃里克·施密特（Eric Schmidt），如今是谷歌母公司Alphabet的执行董事长——编写了一个名为`lex`的程序，简称“词法分析器”。正如披头士在《Penny
    Lane》中所唱的：“它是一个*Kleene*机器。”稍后，GNU项目制作了一个名为`flex`的开源版本。这些工具正是我们需要的。它们生成一个由状态表驱动的程序，当输入与正则表达式匹配时，执行用户提供的程序片段。例如，清单[8-5](ch08.xhtml#ch08list05)中的简单`lex`程序片段会在遇到`ar`或`er`时打印`ah`，在遇到单词结尾的`a`时打印`er`。
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 8-5: Bostonian lex program fragment*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-5：波士顿口音词法程序片段*'
- en: 'The `/` in the second pattern means “only match the thing on its left if it
    is followed by the thing on its right.” Things not matched are just printed. You
    can use this program to convert regular American English to Bostonian: for example,
    inputting the text `Park the car in Harvard yard and sit on the sofa` would produce
    `Pahk the cah in Hahvahd yahd and sit on the sofer` as output.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模式中的`/`表示“只有在左边的东西后面跟着右边的东西时，才匹配左边的东西。”未匹配的部分将直接打印。你可以使用这个程序将标准的美式英语转换为波士顿口音：例如，输入文本`Park
    the car in Harvard yard and sit on the sofa`，输出将是`Pahk the cah in Hahvahd yahd
    and sit on the sofer`。
- en: Classifying tokens is a piece of cake in `lex`. For example, [Listing 8-6](ch08.xhtml#ch08list06)
    shows some `lex` that matches all of our number forms plus variable names and
    some operators. Instead of printing out what we find, we return some values defined
    elsewhere for each type of token. Note that several of the characters have special
    meaning to `lex` and therefore require the backslash escape character so that
    they’re treated as literals.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lex`中，标记分类非常简单。例如，[列表 8-6](ch08.xhtml#ch08list06)展示了匹配我们所有数字形式、变量名和一些运算符的`lex`代码。我们不是输出我们找到的内容，而是为每种类型的标记返回在其他地方定义的值。请注意，几个字符在`lex`中有特殊意义，因此需要使用反斜杠转义字符，以便将其视为字面量。
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 8-6: Classifying tokens using lex*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-6：使用 lex 对标记进行分类*'
- en: Not shown in the listing is the mechanism by which `lex` supplies the actual
    values of the tokens. When we find a number, we need to know its value; likewise,
    when we find a variable name, we need to know that name.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中没有展示的是`lex`如何提供实际标记值的机制。当我们找到一个数字时，我们需要知道它的值；同样，当我们找到一个变量名时，我们需要知道那个名字。
- en: Note that `lex` doesn’t work for all languages. As computer scientist Stephen
    C. Johnson (introduced shortly) explained, “Lex can be easily used to produce
    quite complicated lexical analyzers, but there remain some languages (such as
    FORTRAN) which do not fit any theoretical framework, and whose lexical analyzers
    must be crafted by hand.”
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`lex`并不适用于所有语言。正如计算机科学家斯蒂芬·C·约翰逊（稍后介绍）所解释的，“`Lex`可以很容易地用于生成相当复杂的词法分析器，但仍然有一些语言（如
    FORTRAN）不符合任何理论框架，其词法分析器必须手动编写。”
- en: '**From Words to Sentences**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从单词到句子**'
- en: So far, we’ve seen how we can turn sequences of characters into words. But that’s
    not enough for a language. We now need to turn those words into sentences according
    to some *grammar*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何将字符序列转换为单词。但这对于语言来说还不够。我们现在需要根据某些*语法*将这些单词转换为句子。
- en: Let’s use the tokens from [Listing 8-6](ch08.xhtml#ch08list06) to create a simple
    four-function calculator. Expressions such as `1 + 2` and `a = 5` are legal, whereas
    `1 + + + 2` isn’t. We once again find ourselves in need of pattern matching, but
    this time for token types. Maybe somebody has already thought about this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用[列表 8-6](ch08.xhtml#ch08list06)中的标记来创建一个简单的四则运算计算器。像`1 + 2`和`a = 5`这样的表达式是合法的，而`1
    + + + 2`则不是。我们再次需要模式匹配，但这次是针对标记类型。也许有人已经考虑过这个问题。
- en: That somebody would be Stephen C. Johnson, who also—unsurprisingly—worked at
    Bell Labs. He created `yacc` (for “yet another compiler compiler”) in the early
    1970s. The name should give you an idea of how many people were playing with these
    sorts of things back then. It’s still in use today; an open source version, called
    `bison`, is available from the GNU project. Just like `lex`, `yacc` and `bison`
    generate state tables and the code to operate on them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那个人正是斯蒂芬·C·约翰逊，他也——不出所料——曾在贝尔实验室工作。他在 1970 年代初创建了`yacc`（“又一个编译器生成器”）。这个名字应该能让你明白当时有多少人都在玩这些东西。它至今仍在使用；一个名为`bison`的开源版本可以从
    GNU 项目中获取。就像`lex`一样，`yacc`和`bison`都生成状态表及其操作代码。
- en: The program `yacc` generates is a *shift-reduce* parser using a stack (see “[Stacks](ch05.xhtml#ch05lev1sec3)”
    on [page 122](ch05.xhtml#page_122)). In this context, *shift* means pushing a
    token onto the stack, and *reduce* means replacing a matched set of tokens on
    the stack with a token for that set. Look at the BNF for the calculator in [Listing
    8-7](ch08.xhtml#ch08list07)—it uses the token values produced by `lex` in [Listing
    8-6](ch08.xhtml#ch08list06).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 程序`yacc`生成的是一个使用栈的*移进-归约*解析器（请参阅[《栈》](ch05.xhtml#ch05lev1sec3)第[122页](ch05.xhtml#page_122)）。在此上下文中，*移进*意味着将一个标记推入栈中，而*归约*意味着用一个标记替换栈中匹配的标记集合。查看[列表
    8-7](ch08.xhtml#ch08list07)中的计算器 BNF——它使用了[列表 8-6](ch08.xhtml#ch08list06)中`lex`生成的标记值。
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 8-7: Simple calculator BNF*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7：简单计算器的 BNF*'
- en: Shift-reduce is easy to understand once you see it in action. Look at what happens
    when our simple calculator is presented with the input `4 + 5 – 3` in [Figure
    8-4](ch08.xhtml#ch08fig04). Referring back to “[Different Equation Notations](ch05.xhtml#ch05sb01)”
    on [page 125](ch05.xhtml#page_125), you can see that processing infix notion equations
    requires a deeper stack than postfix (RPN) requires because more tokens, such
    as parentheses, must be shifted before anything can be reduced.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你看到移位归约的实际应用，它就容易理解了。看看当我们的简单计算器接收到输入 `4 + 5 – 3` 时会发生什么，如[图 8-4](ch08.xhtml#ch08fig04)所示。回顾一下[第
    125 页](ch05.xhtml#page_125)的“[不同的方程表示法](ch05.xhtml#ch05sb01)”一节，你可以看到，处理中缀表示法方程式需要比后缀表示法（RPN）更多的栈，因为更多的符号（如括号）必须被移位才能进行归约。
- en: '![Image](../images/08fig04.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig04.jpg)'
- en: '*Figure 8-4: Shift-reduce in action*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：移位归约的实际应用*'
- en: '[Listing 8-8](ch08.xhtml#ch08list08) shows what our calculator would look like
    when coded in `yacc`. Note the similarity to the BNF. This is for illustration
    only; it’s not a fully working example, as that would introduce far too many nitpicky
    distractions.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-8](ch08.xhtml#ch08list08)展示了我们的计算器在 `yacc` 中的编码样式。注意与 BNF 的相似性。这仅仅是为了说明；它并不是一个完全工作的示例，因为那样会引入太多的细枝末节，分散注意力。'
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 8-8: Partial yacc for a simple calculator*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-8：简单计算器的部分 yacc 示例*'
- en: '**The Language-of-the-Day Club**'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**今日语言俱乐部**'
- en: 'Languages used to be difficult. In 1977, Canadian computer scientist Alfred
    Aho and American computer scientist Jeffrey Ullman at Bell Labs published *Principles
    of Compiler Design*, one of the first computer-typeset books published using the
    `troff` typesetting language. One can summarize the book as follows: “languages
    are hard, and you had better dive into the heavy math, set theory, and so on.”
    The second edition, published in 1986 along with Indian computer scientist Ravi
    Sethi, had a completely different feel. Its attitude was more like “languages
    are a done thing, and here’s how to do them.” And people did.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 语言曾经是很困难的。1977年，加拿大计算机科学家 Alfred Aho 和美国计算机科学家 Jeffrey Ullman 在贝尔实验室出版了《编译原理》一书，这是第一本使用
    `troff` 排版语言出版的计算机排版书籍。可以用以下话来总结这本书：“语言是困难的，你最好深入研究数学、集合论等内容。”第二版在1986年出版，由印度计算机科学家
    Ravi Sethi 合著，给人完全不同的感觉。它的态度更像是“语言已经是定型的了，下面是如何做它们。”而人们也的确这样做了。
- en: That edition popularized `lex` and `yacc`. All of a sudden, there were languages
    for everything—and not just programming languages. One of my favorite small languages
    was `chem`, by Canadian computer scientist Brian Kernighan at Bell Labs, which
    drew pretty chemical structure diagrams from input like `C double bond O`. The
    diagrams in the book you’re reading, in fact, were created using Brian Kernighan’s
    picture-drawing language `pic`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的版本使得 `lex` 和 `yacc` 广为流传。突然间，出现了许多不同的语言——不仅仅是编程语言。我最喜欢的小型语言之一是加拿大计算机科学家
    Brian Kernighan 在贝尔实验室开发的 `chem`，它能根据像 `C double bond O` 这样的输入绘制漂亮的化学结构图。事实上，你正在阅读的这本书中的图表，正是使用
    Brian Kernighan 的图形绘制语言 `pic` 创建的。
- en: Creating new languages is fun. Of course, people started making new languages
    without understanding their history and reintroduced old mistakes. For example,
    many consider the handling of *whitespace* (the spaces between words) in the Ruby
    language to be a replay of a mistake in the original C language that was fixed
    long ago. (Note that one of the classic ways to deal with a mistake is to call
    it a feature.)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创造新语言是有趣的。当然，人们在不了解其历史的情况下开始创造新语言，并重新引入了旧有的错误。例如，许多人认为 Ruby 语言中对*空白字符*（单词间的空格）的处理是对原始
    C 语言中一个早已修复的错误的重演。（请注意，处理错误的经典方法之一是将其称为功能特性。）
- en: The result of all this history is that a huge number of languages are now available.
    Most don’t really add much value and are just demonstrations of the designer’s
    taste. It’s worth paying attention to *domain-specific* languages, particularly
    *little languages* such as `pic` and `chem`, to see how specific applications
    are addressed. American computer scientist Jon Bentley published a wonderful column
    about little languages called “Programming Pearls” in *Communications of the ACM*
    back in 1986\. These columns were collected and published in updated book form
    in 1999 as *Programming Pearls* (Addison-Wesley).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切历史的结果是，现在有大量的编程语言可供使用。大多数语言并没有真正增加太多价值，只是设计者品味的展示。值得关注的是*领域特定*语言，尤其是像`pic`和`chem`这样的*小型语言*，看看它们是如何解决特定应用问题的。美国计算机科学家
    Jon Bentley 在1986年在《ACM通讯》上发表了一篇关于小型语言的精彩专栏，名为《编程珍珠》。这些专栏在1999年被收集并更新出版为《编程珍珠》一书（由
    Addison-Wesley 出版）。
- en: '**Parse Trees**'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解析树**'
- en: Earlier I talked about compiling high-level languages, but that’s not the only
    option. High-level languages can be compiled or *interpreted*. The choice is not
    a function of the design of the language but rather of its implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过编译高级语言，但这并不是唯一的选择。高级语言可以被*编译*或*解释*。选择哪种方式并不是语言设计的函数，而是它的实现方式。
- en: Compiled languages produce machine code like you saw back in [Table 4-4](ch04.xhtml#ch04tab04)
    [page 108](ch04.xhtml#page_108). The compiler takes the source code and converts
    it into machine language for a particular machine. Many compilers allow you to
    compile the same program for different target machines. Once a program is compiled,
    it’s ready to run.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 编译语言会生成像你在[表 4-4](ch04.xhtml#ch04tab04) [第108页](ch04.xhtml#page_108)看到的机器代码。编译器将源代码转换成特定机器的机器语言。许多编译器允许你为不同的目标机器编译相同的程序。程序一旦被编译，就可以运行了。
- en: Interpreted languages don’t result in machine language for a real machine (“real”
    as in hardware). Instead, interpreted languages run on *virtual machines*, which
    are machines written in software. They may have their own machine language, but
    it’s not a computer instruction set implemented in hardware. Note that the term
    *virtual machine* has become overloaded recently; I’m using it to mean an abstract
    computing machine. Some interpreted languages are executed directly by the *interpreter*.
    Others are compiled into an *intermediate language* for later interpretation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型语言不会生成真实机器（“真实”的意思是硬件）上的机器语言。相反，解释型语言运行在*虚拟机*上，虚拟机是通过软件编写的计算机。虚拟机可能有自己的机器语言，但它并不是硬件实现的计算机指令集。需要注意的是，*虚拟机*这个术语最近被过度使用；在这里我使用它指的是一种抽象的计算机。一些解释型语言是由*解释器*直接执行的，其他语言则会被编译成*中间语言*，以便后续解释。
- en: In general, compiled code is faster because once it’s compiled, it’s in machine
    language. It’s like translating a book. Once it’s done, anyone who speaks that
    language can read it. Interpreted code is ephemeral, like someone reading a book
    aloud while translating it into the listener’s language. If another person later
    wants the book read to them in their own language, it must be translated again.
    However, interpreted code allows languages to have features that are really difficult
    to build in hardware. Computers are fast enough that we can often afford the speed
    penalty that comes with interpreters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，编译后的代码执行更快，因为一旦它被编译，它就是机器语言。就像是翻译一本书，一旦完成，任何懂这种语言的人都能阅读它。解释型代码则是短暂的，就像有人边读书边将其翻译成听众的语言。如果之后另一个人想让这本书以自己的语言读给他听，那么它必须重新翻译。然而，解释型代码允许语言拥有一些硬件上很难实现的特性。计算机足够快，我们通常可以承受解释器带来的速度损失。
- en: '[Figure 8-4](ch08.xhtml#ch08fig04) depicted the calculator directly executing
    the input. Although this is fine for something like a calculator, it skips a major
    step used for compilers and interpreters. For those cases, we construct a *parse
    tree*, which is a DAG (directed acyclic graph) data structure from the calculator
    grammar. We’ll build this tree out of node structures, as depicted in [Figure
    8-5](ch08.xhtml#ch08fig05).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-4](ch08.xhtml#ch08fig04) 展示了计算器直接执行输入的过程。虽然这种方式对于像计算器这样的应用是可以接受的，但它跳过了编译器和解释器使用的一个重要步骤。在这些情况下，我们构建一个*解析树*，这是一个从计算器语法生成的DAG（有向无环图）数据结构。我们将根据[图
    8-5](ch08.xhtml#ch08fig05)中所示的节点结构来构建这棵树。'
- en: '![Image](../images/08fig05.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig05.jpg)'
- en: '*Figure 8-5: Parse tree node layout*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：解析树节点布局*'
- en: Each node includes a `code` that indicates the type of node. There is also an
    array of leaves; the interpretation of each `leaf` is determined by the `code`.
    Each `leaf` is a union since it can hold more than one type of data. We’re using
    C language syntax for the member naming, so, for example, `.i` is used if we’re
    interpreting a `leaf` as an integer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点包含一个`code`，表示节点的类型。还有一个叶子数组；每个`leaf`的解释由`code`决定。每个`leaf`是一个联合体，因为它可以存储多种类型的数据。我们使用C语言语法来命名成员，因此，例如，`.i`表示我们将`leaf`解释为一个整数。
- en: We’ll assume the existence of a `makenode` function that makes new nodes. It
    takes a `leaf` count as its first argument, a `code` as its second, and the values
    for each `leaf` afterward.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设存在一个`makenode`函数，用于创建新的节点。它的第一个参数是`leaf`数量，第二个参数是`code`，后续是每个`leaf`的值。
- en: Let’s flesh out the code from [Listing 8-8](ch08.xhtml#ch08list08) a bit more
    while still omitting some of the picky details. To keep things simple, we’ll only
    handle integer numbers. What was missing earlier was code to execute when matching
    grammar rules. In `yacc`, the value of each of the right-hand-side elements is
    available as `$1`, `$2`, and so on, and `$$` is what gets returned by the rule.
    [Listing 8-9](ch08.xhtml#ch08list09) shows a more complete version of our `yacc`
    calculator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微扩展一下[清单 8-8](ch08.xhtml#ch08list08)中的代码，同时仍然省略一些细节。为了简化起见，我们只处理整数。之前缺少的是匹配语法规则时执行的代码。在`yacc`中，右侧每个元素的值都可以通过`$1`、`$2`等来访问，而`$$`是规则返回的值。[清单
    8-9](ch08.xhtml#ch08list09)展示了我们更完整的`yacc`计算器版本。
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-9: Simple calculator parse tree construction using yacc*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-9：使用yacc构建简单计算器语法树*'
- en: Here, all the simple rules just return their values. The more complicated rules
    for `statements`, `expression`, and `assignment` create a node, attach the children,
    and return that node. [Figure 8-6](ch08.xhtml#ch08fig06) shows what gets produced
    for some sample input.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有简单规则仅返回它们的值。更复杂的规则，如`statements`、`expression`和`assignment`，会创建一个节点，附加子节点，并返回该节点。[图
    8-6](ch08.xhtml#ch08fig06)展示了对一些示例输入产生的结果。
- en: '![Image](../images/08fig06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig06.jpg)'
- en: '*Figure 8-6: Simple calculator parse tree*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：简单计算器语法树*'
- en: As you can see, the code generates a tree. At the top level, we use the `calculator`
    rule to create a linked list of statements out of tree nodes. The remainder of
    the tree consists of `statement` nodes that contain the `operator` and `operand`s.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码生成了一棵树。在最顶层，我们使用`calculator`规则将树节点转换为一个包含语句的链表。其余的树由包含`operator`和`operand`的`statement`节点组成。
- en: '**Interpreters**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解释器**'
- en: '[Listing 8-9](ch08.xhtml#ch08list09) includes a mysterious `do_something_with`
    function invocation that is passed the root of the parse tree. That function causes
    an interpreter to “execute” the parse tree. The first part of this execution is
    the linked-list traversal, as shown in [Figure 8-7](ch08.xhtml#ch08fig07).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-9](ch08.xhtml#ch08list09)包括一个神秘的`do_something_with`函数调用，它将解析树的根传递给该函数。该函数使解释器“执行”解析树。执行的第一部分是链表遍历，如[图
    8-7](ch08.xhtml#ch08fig07)所示。'
- en: The second part is the evaluation, which we do recursively using depth-first
    traversal. This function is diagrammed in [Figure 8-8](ch08.xhtml#ch08fig08).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是评估，我们通过深度优先遍历递归执行此操作。该函数在[图 8-8](ch08.xhtml#ch08fig08)中进行了示意。
- en: '![Image](../images/08fig07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig07.jpg)'
- en: '*Figure 8-7: Parse tree linked-list traversal*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-7：解析树链表遍历*'
- en: '![Image](../images/08fig08.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig08.jpg)'
- en: '*Figure 8-8: Parse tree evaluation*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-8：语法树评估*'
- en: As you can see, it’s easy to decide what to do since we have a `code` in our
    `node`. Observe that we need an additional function to store a variable (symbol)
    name and value in a *symbol table* and another to look up the value associated
    with a variable name. These are commonly implemented using hash tables (see “[Making
    a Hash of Things](ch07.xhtml#ch07lev1sec19)” on [page 213](ch07.xhtml#page_213)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，决定做什么很容易，因为我们在`node`中有一个`code`。请注意，我们需要一个额外的函数来在*符号表*中存储变量（符号）名称和值，另一个函数用于查找与变量名称相关联的值。这些通常使用哈希表实现（参见[“制作哈希表”](ch07.xhtml#ch07lev1sec19)，第213页）。
- en: Gluing the list traversal and evaluation code into `yacc` allows us to immediately
    execute the parse tree. Another option is to save the parse tree in a file where
    it can be read and executed later. This is how languages such as Java and Python
    work. For all intents and purposes, this is a set of machine language instructions,
    but for a machine implemented in software instead of hardware. A program that
    executes the saved parse tree must exist for every target machine. Often the same
    interpreter source code can be compiled and used for multiple targets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表遍历和评估代码与`yacc`结合在一起，使我们能够立即执行解析树。另一种选择是将解析树保存在文件中，以便以后读取并执行。这就是Java和Python等语言的工作方式。从实际用途来看，这是一组机器语言指令，但它是由软件实现的，而不是硬件。执行已保存解析树的程序必须为每个目标机器存在。通常，相同的解释器源代码可以编译并用于多个目标。
- en: '[Figure 8-9](ch08.xhtml#ch08fig09) summarizes interpreters.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-9](ch08.xhtml#ch08fig09)总结了解释器。'
- en: The front end generates the parse tree, which is represented by some *intermediate
    language*, and the back ends are for various machines to execute that language
    in their target environments.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前端生成语法分析树，这些树用某种*中间语言*表示，后端则为不同的机器提供执行该语言的功能，以便在其目标环境中运行。
- en: '![Image](../images/08fig09.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig09.jpg)'
- en: '*Figure 8-9: Interpreter structure*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-9：解释器结构*'
- en: '**Compilers**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编译器**'
- en: Compilers look a lot like interpreters, but they have code generators instead
    of backend execution code, as shown in [Figure 8-10](ch08.xhtml#ch08fig10).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器看起来很像解释器，但它们有代码生成器，而不是后端执行代码，如[图8-10](ch08.xhtml#ch08fig10)所示。
- en: '![Image](../images/08fig10.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig10.jpg)'
- en: '*Figure 8-10: Compiler structure*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-10：编译器结构*'
- en: A *code generator* generates machine language for a particular target machine.
    The tools for some languages, such as C, can generate the actual assembly language
    (see “[Assembly Language](ch08.xhtml#ch08lev1sec1)” on [page 217](ch08.xhtml#page_217))
    for the target machine, and the assembly language is then run through that machine’s
    assembler to produce machine language.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码生成器*为特定的目标机器生成机器语言。一些语言的工具，如C，能够为目标机器生成实际的汇编语言（参见[“汇编语言”](ch08.xhtml#ch08lev1sec1)，在[第217页](ch08.xhtml#page_217)），然后将汇编语言通过该机器的汇编器处理，生成机器语言。'
- en: A code generator looks exactly like the parse tree traversal and evaluation
    we saw in [Figures 8-7](ch08.xhtml#ch08fig07) and [8-8](ch08.xhtml#ch08fig08).
    The difference is that the rectangles in [Figure 8-8](ch08.xhtml#ch08fig08) are
    replaced by ones that generate assembly language instead of executing the parse
    tree. A simplified version of a code generator is shown in [Figure 8-11](ch08.xhtml#ch08fig11);
    things shown in bold monospace font (like add tmp) are emitted machine language
    instructions for our toy machine from [Chapter 4](ch04.xhtml#ch04). Note that
    the machine there didn’t have multiply and divide instructions but, for this example,
    we pretend that it does.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成器的工作原理与我们在[图8-7](ch08.xhtml#ch08fig07)和[图8-8](ch08.xhtml#ch08fig08)中看到的语法分析树遍历和求值完全相同。不同之处在于，[图8-8](ch08.xhtml#ch08fig08)中的矩形被替换成了生成汇编语言的矩形，而不是执行语法分析树。[图8-11](ch08.xhtml#ch08fig11)中展示了一个简化版的代码生成器；加粗的等宽字体（如add
    tmp）表示我们从[第4章](ch04.xhtml#ch04)中得到的玩具机器指令。请注意，那里机器没有乘法和除法指令，但为了这个例子，我们假设它有。
- en: '![Image](../images/08fig11.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig11.jpg)'
- en: '*Figure 8-11: Assembler generation from parse tree*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-11：从语法分析树生成汇编器*'
- en: Applying [Figure 8-11](ch08.xhtml#ch08fig11) to the parse tree in [Figure 8-6](ch08.xhtml#ch08fig06),
    we get the assembly language program shown in [Listing 8-10](ch08.xhtml#ch08list10).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将[图8-11](ch08.xhtml#ch08fig11)应用于[图8-6](ch08.xhtml#ch08fig06)中的语法分析树，我们得到在[清单8-10](ch08.xhtml#ch08list10)中显示的汇编语言程序。
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 8-10: Machine language output from code generator*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-10：代码生成器生成的机器语言输出*'
- en: As you can see, this generates fairly bad-looking code; there are a lot of unnecessary
    loads and stores. But what can you expect from a contrived simple example? This
    code would be much improved via optimization, which is discussed in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码生成得相当不好看；存在许多不必要的加载和存储操作。但你能从一个人为设计的简单示例中期待什么呢？通过优化，这段代码将得到很大改进，优化内容将在下一节中讨论。
- en: This code can be executed once it’s assembled into machine language. It will
    run much faster than the interpreted version because it’s a much smaller and more
    efficient piece of code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这段代码被汇编成机器语言，它就可以执行。与解释型版本相比，它的运行速度会快得多，因为它是一段更小、更高效的代码。
- en: '**Optimization**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**优化**'
- en: Many language tools include an additional step called an *optimizer* between
    the parse tree and the code generator. The optimizer analyzes the parse tree and
    performs transformations that result in more efficient code. For example, an optimizer
    might notice that all the operands in the parse tree on the left in [Figure 8-12](ch08.xhtml#ch08fig12)
    are constants. It can then evaluate the expression in advance at compile time
    so that evaluation doesn’t have to be done at runtime.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言工具在语法分析树和代码生成器之间加入了一个额外的步骤，称为*优化器*。优化器分析语法分析树并执行转换，产生更高效的代码。例如，优化器可能会注意到[图8-12](ch08.xhtml#ch08fig12)中左侧的语法分析树的所有操作数都是常量。它可以在编译时提前计算表达式，这样在运行时就不需要再计算了。
- en: '![Image](../images/08fig12.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig12.jpg)'
- en: '*Figure 8-12: Optimizing a parse tree*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-12：优化语法分析树*'
- en: The preceding example is trivial because our example calculator doesn’t include
    any way to do conditional branching. Optimizers have a whole bag of tricks. For
    example, consider the code shown in [Listing 8-11](ch08.xhtml#ch08list11) (which
    happens to be in C).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子很简单，因为我们的示例计算器没有包括任何条件分支的实现。优化器有许多技巧。例如，考虑[清单 8-11](ch08.xhtml#ch08list11)中的代码（它恰好是用C语言写的）。
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 8-11: C loop code with assignment in loop*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-11：带有循环赋值的C语言循环代码*'
- en: '[Listing 8-12](ch08.xhtml#ch08list12) shows how an optimizer might restructure
    it.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-12](ch08.xhtml#ch08list12)展示了优化器可能会如何重构这段代码。'
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 8-12: Loop code with loop invariant optimization*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-12：带有循环不变优化的循环代码*'
- en: This example gives the same results as [Listing 8-11](ch08.xhtml#ch08list11)
    but is more efficient. The optimizer determined that `a + b` was *loop invariant*,
    meaning that its value didn’t change inside the loop. The optimizer moved it outside
    the loop so it would need to be computed only once instead of 10 times. It also
    determined that `x * x` was constant inside the loop and moved that outside.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子给出了与[清单 8-11](ch08.xhtml#ch08list11)相同的结果，但更加高效。优化器确定`a + b`是*循环不变的*，意味着它在循环中不会改变。优化器将其移到循环外部，这样它只需要计算一次，而不是计算10次。它还确定`x
    * x`在循环中是常量，并将其移到外部。
- en: '[Listing 8-13](ch08.xhtml#ch08list13) shows another optimizer trick called
    *strength reduction*, which is the process of replacing expensive operations with
    cheaper ones—in this case, multiplication with addition.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-13](ch08.xhtml#ch08list13)展示了另一个优化器技巧，叫做*强度减少*，它是通过用更便宜的操作替代昂贵的操作——在这个例子中，是用加法代替乘法。'
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-13: C loop code with loop-invariant optimization and strength reduction*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-13：包含循环不变优化和强度减少的C语言循环代码*'
- en: Strength reduction could also take advantage of relative addressing to make
    the calculation of `result[i]` more efficient. Going back to [Figure 7-2](ch07.xhtml#ch07fig02),
    `result[i]` is the address of `result` plus `i` times the size of the array element.
    Just like with the `optimizer_created_4_times_i`, we could start with the address
    of `result` and add the size of the array element on each loop iteration instead
    of using a slower multiplication.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 强度减少还可以利用相对寻址来使得`result[i]`的计算更加高效。回到[图 7-2](ch07.xhtml#ch07fig02)，`result[i]`是`result`的地址加上`i`乘以数组元素的大小。就像`optimizer_created_4_times_i`一样，我们可以从`result`的地址开始，并在每次循环迭代时加上数组元素的大小，而不是使用更慢的乘法。
- en: '**Be Careful with Hardware**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**小心硬件**'
- en: Optimizers are wonderful, but they can cause unexpected problems with code that
    manipulates hardware. [Listing 8-14](ch08.xhtml#ch08list14) shows a variable that’s
    actually a hardware register that turns on a light when bit 0 is set, like we
    saw back in [Figure 6-1](ch06.xhtml#ch06fig01).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器很棒，但它们可能会导致处理硬件的代码出现意外问题。[清单 8-14](ch08.xhtml#ch08list14)展示了一个变量，实际上是一个硬件寄存器，当第0位被设置时，它会打开灯光，正如我们在[图
    6-1](ch06.xhtml#ch06fig01)中看到的那样。
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 8-14: Example of code that shouldn’t be optimized*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-14：不应该优化的代码示例*'
- en: This looks great, but what’s the optimizer going to do? It will say, “Hey, this
    is being written but never read, so I can just get rid of it.” Likewise, say we
    have the code in [Listing 8-15](ch08.xhtml#ch08list15), which turns on the light
    and then tests to see whether or not it’s on. The optimizer would likely just
    rewrite the function to return 0x01 without ever storing it in PORTB.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很好，但优化器会怎么做呢？它会说，“嘿，这个变量被写入但从未读取，所以我可以把它去掉。”同样，假设我们有[清单 8-15](ch08.xhtml#ch08list15)中的代码，它打开了灯光，然后测试是否已经打开。优化器很可能会直接重写这个函数，使其返回0x01，而不将值存储到PORTB。
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 8-15: Another example of code that shouldn’t be optimized*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-15：另一个不应该优化的代码示例*'
- en: These examples demonstrate that you need to be able to turn off optimization
    in certain cases. Traditionally, you’d do so by splitting up the software into
    general and hardware-specific files and running the optimizer only on the general
    ones. However, some languages now include mechanisms that allow you to tell the
    optimizer to leave certain things alone. For example, in C the `volatile` keyword
    says not to optimize access to a variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子表明，在某些情况下，你需要能够关闭优化。传统上，你会通过将软件拆分为通用文件和硬件特定文件，然后只对通用文件运行优化器。然而，现在一些语言提供了机制，允许你告诉优化器某些内容不需要优化。例如，在C语言中，`volatile`关键字表示不要优化对变量的访问。
- en: '**Summary**'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: So far in this book, you’ve learned how computers work and how they run programs.
    In this chapter, you saw how programs get transformed so that they can be run
    on machines and learned that programs can be compiled or interpreted.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，你已经学习了计算机是如何工作的，以及它们是如何运行程序的。在本章中，你看到了程序是如何被转换的，以便能够在机器上运行，并且学到了程序可以是编译的或解释的。
- en: In the next chapter, you’ll meet a monster of an interpreter called a *web browser*
    and the languages that it interprets.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将遇到一个叫做*网页浏览器*的解释器怪物，以及它所解释的语言。
