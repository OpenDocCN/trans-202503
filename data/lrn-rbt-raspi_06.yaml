- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: CUSTOMIZING WITH LIGHTS AND SOUND
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用灯光和声音进行自定义
- en: MAKING YOUR ROBOT STAND OUT FROM THE CROWD CAN BE A WHOLE LOT OF FUN. IN THIS
    CHAPTER, I’LL SHOW YOU HOW TO ADD LIGHTS AND SPEAKERS TO YOUR ROBOT TO MAKE IT
    FLASHIER, LOUDER, AND MORE EXCITING. AS USUAL, WE’LL COVER THE THEORY, THE PARTS
    YOU’LL NEED, AND HOW TO USE THEM.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的机器人在人群中脱颖而出是一件非常有趣的事情。在这一章中，我将展示如何为你的机器人添加灯光和扬声器，让它更加闪亮、响亮和激动人心。像往常一样，我们将涵盖理论、所需的零件以及如何使用它们。
- en: ADDING NEOPIXELS TO YOUR RASPBERRY PI ROBOT
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将NeoPixels添加到你的树莓派机器人
- en: One of the best ways to grab attention is to have your robot put on a light
    show. With the right code and wiring and the help of some bright and colorful
    LEDs, you can make dazzling spectacles as your robot scuttles around the floor!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 吸引注意力的最好方式之一是让你的机器人展示一场灯光秀。通过正确的代码和接线，并借助一些明亮多彩的LED，你可以让你的机器人在地板上跑来跑去时，呈现出令人眼花缭乱的精彩演出！
- en: In this project you’ll outfit your robot with a string of super-bright, multicolor
    LEDs. I’ll guide you through getting the components, wiring them up, and programming
    different patterns. We’ll combine these new additions with the Wiimote program
    from [Chapter 4](ch04.xhtml#ch04) so that you can trigger different LED combinations
    by pressing the Wiimote’s buttons.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将为你的机器人安装一串超亮的多色LED灯。我将指导你获取组件、接线并编程不同的图案。我们将把这些新加入的功能与[第4章](ch04.xhtml#ch04)中的Wiimote程序结合，这样你就可以通过按下Wiimote的按钮来触发不同的LED组合。
- en: Introducing NeoPixels and the RGB Color System
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 介绍NeoPixels和RGB颜色系统
- en: At the start of this book, I introduced LEDs and showed you how to wire up a
    single-color LED to your Raspberry Pi and flash it on and off using a simple Python
    script.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开始部分，我介绍了LED并展示了如何将单色LED接到树莓派上，并通过一个简单的Python脚本使其闪烁。
- en: That was a great project to get you started, but a lonely LED is hardly going
    to create the desired wow factor for your robot. Instead, for this project, we’ll
    use *NeoPixels* like the ones shown in [Figure 6-1](ch06.xhtml#ch06fig1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个很好的入门项目，但单一的LED几乎无法为你的机器人创造预期的震撼效果。因此，在这个项目中，我们将使用像[图6-1](ch06.xhtml#ch06fig1)所示的*NeoPixels*。
- en: '![image](../images/f122-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f122-01.jpg)'
- en: '**FIGURE 6-1** NeoPixels on my robot'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-1** 我的机器人上的NeoPixels'
- en: NeoPixels are a range of affordable, ultra-bright RGB LEDs from the open source
    hardware company Adafruit. *RGB*, which stands for *red green blue*, is a system
    of color mixing that computers use to represent a massive spectrum of colors.
    Red, green, and blue light can be combined in various proportions to produce any
    color in the visible light spectrum, from orange to indigo to green! By setting
    the levels of R, G, and B each in a range of 0 to 100 percent intensity, you can
    create new colors. For example, pure red is represented by 100% R, 0% G, and 0%
    B, and purple is 50% R, 0% G, and 50% B.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: NeoPixel是开源硬件公司Adafruit推出的一款经济实惠、超亮的RGB LED灯。*RGB*代表*红绿蓝*，这是一种计算机用来表示大量颜色的混色系统。红色、绿色和蓝色的光可以以不同的比例组合，从而产生可见光谱中的任何颜色，从橙色到靛蓝再到绿色！通过设置R、G和B的强度，每种颜色的强度范围是0到100%，你可以创建新的颜色。例如，纯红色表示100%
    R、0% G和0% B，而紫色表示50% R、0% G和50% B。
- en: Instead of percentages, computers normally represent the levels of each color
    as a range of decimal numbers from 0 to 255 (256 levels). So, for red the combination
    is 255 R, 0 G, and 0 B. See [Figure 6-2](ch06.xhtml#ch06fig2) for the full RGB
    range represented as a color wheel.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通常不使用百分比来表示每种颜色的强度，而是使用从0到255（256个级别）的十进制数值。因此，对于红色，其组合为255 R、0 G和0 B。请参见[图6-2](ch06.xhtml#ch06fig2)，以了解完整的RGB范围，表示为色轮。
- en: '![image](../images/f123-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f123-01.jpg)'
- en: '**FIGURE 6-2** The full RGB range represented as a color wheel'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-2** 完整的RGB范围，表示为色轮'
- en: 'This means that, unlike the single-color LED, each RGB NeoPixel can display
    a huge range of colors. You can calculate the exact range by multiplying the number
    of possibilities for each level: 256 × 256 × 256 = 16,777,216\. That’s almost
    17 million different colors!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，与单色LED不同，每个RGB NeoPixel可以显示巨大的颜色范围。你可以通过将每个级别的可能性数相乘来计算准确的范围：256 × 256
    × 256 = 16,777,216。那几乎是1700多万种不同的颜色！
- en: 'But how can a single LED represent so many colors? Well, if you look closely
    at the NeoPixel in [Figure 6-3](ch06.xhtml#ch06fig3), you’ll see that there are
    three distinct areas. This is because each NeoPixel actually comprises *three*
    LEDs: one each of red, green, and blue. You combine these colors in varying quantities,
    as discussed earlier, to produce an RGB color.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，单个 LED 如何能代表如此多的颜色呢？如果你仔细看 [图 6-3](ch06.xhtml#ch06fig3) 中的 NeoPixel，你会发现它分为三个不同的区域。这是因为每个
    NeoPixel 实际上由 *三* 个 LED 组成：分别是红色、绿色和蓝色。通过将这些颜色按不同的比例组合在一起，就可以产生 RGB 颜色，如前面所述。
- en: '![image](../images/f124-01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f124-01.jpg)'
- en: '**FIGURE 6-3** A macro shot of a NeoPixel'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-3** NeoPixel 的宏观拍摄'
- en: The Parts List
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部件清单
- en: NeoPixels can be used individually or chained together, and Adafruit has a huge
    range of NeoPixel products available in many different forms and sizes—from individual
    pixels to huge matrices made out of hundreds of NeoPixels.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: NeoPixel 可以单独使用或串联在一起，Adafruit 提供了大量的 NeoPixel 产品，种类和尺寸多种多样——从单个像素到由数百个 NeoPixel
    组成的大型矩阵。
- en: In this project I recommend picking up a NeoPixel *Stick*—this is a roughly
    2-inch-long LED arrangement of eight NeoPixels, as shown in [Figure 6-4](ch06.xhtml#ch06fig4).
    Its combination of small size and bright output makes it ideal for your robot.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我建议购买一个 NeoPixel *Stick* ——这是一种大约 2 英寸长、包含八个 NeoPixel 的 LED 排列，如 [图 6-4](ch06.xhtml#ch06fig4)
    所示。它的小尺寸和明亮的输出使其非常适合用于你的机器人。
- en: '![image](../images/f124-02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f124-02.jpg)'
- en: '**FIGURE 6-4** NeoPixel Stick with headers soldered on'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-4** 焊接好引脚的 NeoPixel Stick'
- en: If you’re in the United States, you can buy one of these from Adafruit’s website
    for less than $6\. If you’re elsewhere in the world, just search the net for “NeoPixel
    Stick,” and you should have no trouble finding one for a similar price from another
    retailer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在美国，可以从 Adafruit 的网站上购买一个，价格不到 6 美元。如果你在其他国家或地区，只需在网上搜索 “NeoPixel Stick”，应该能找到类似价格的其他零售商。
- en: 'It is worth noting that the NeoPixel Stick does require a small degree of assembly:
    you will have to solder a set of male *headers* onto the power and Data-In pads,
    as shown in [Figure 6-5](ch06.xhtml#ch06fig5). There are two sets of pads on the
    back that look almost identical, except one side is for *input* into the Stick,
    and the other for *output* from the Stick. This is so you can chain the output
    of one Stick into the input of another Stick to join several together. We will
    only use one NeoPixel Stick in this project, but you may want to experiment with
    more NeoPixels at a later point.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，NeoPixel Stick 确实需要一定的组装工作：你需要将一组男性 *引脚* 焊接到电源和数据输入接点，如 [图 6-5](ch06.xhtml#ch06fig5)
    所示。背面有两组看起来几乎相同的接点，唯一的区别是，一边是用于 Stick 的 *输入*，另一边是用于 Stick 的 *输出*。这样你就可以将一个 Stick
    的输出连接到另一个 Stick 的输入，将多个 Stick 串联在一起。我们在这个项目中只会使用一个 NeoPixel Stick，但你可能会在以后尝试使用更多的
    NeoPixel。
- en: You’ll have to purchase some male headers separately (which cost less than $1)
    and solder them to the set of the terminal pads that includes the *DIN* (Data-In)
    pin.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要单独购买一些男性引脚（价格不到 1 美元），并将它们焊接到包含 *DIN*（数据输入）引脚的接点上。
- en: If you have never soldered before, check out “How to Solder” on [page 204](bm04.xhtml#page_204)
    for guidance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未焊接过，可以参考 [第 204 页](bm04.xhtml#page_204)上的 “如何焊接” 进行指导。
- en: '![image](../images/f125-01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f125-01.jpg)'
- en: '**FIGURE 6-5** The back of my NeoPixel Stick with headers soldered to the input
    side (L); an individual four-pin header (R)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-5** 我焊接好引脚的 NeoPixel Stick 背面（L）；一个四引脚引脚排（R）'
- en: Other than the NeoPixel Stick and headers, you’ll only need a few jumper wires
    to connect the NeoPixels, as well as some sticky tack to affix them to your Raspberry
    Pi robot.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 NeoPixel Stick 和引脚外，你只需要一些跳线来连接 NeoPixel，并且需要一些粘性胶粘剂将它们固定在 Raspberry Pi 机器人上。
- en: Wiring Up Your NeoPixel Stick
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接你的 NeoPixel Stick
- en: Once you have a freshly soldered NeoPixel Stick, you can wire it up to your
    Pi. In total, only three connections are required to get it working. Remember
    that I won’t show the previous connections in the diagrams, but you don’t need
    to disconnect any of your previous projects to follow along with this one.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了 NeoPixel Stick 的焊接，就可以将其连接到你的 Pi 上。总共只需要三个连接就能让它正常工作。记住，图示中我不会显示之前的连接，但你无需断开之前项目的任何连接就能继续进行这个项目。
- en: Like the HC-SR04 in the previous chapter, the Stick can be plugged directly
    into a breadboard, but as with that project, I don’t recommend doing so here.
    Instead, it’s better to connect the Stick using jumper wires so you can mount
    it elsewhere on your robot.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 像上一章中的HC-SR04一样，NeoPixel Stick可以直接插入面包板，但和那个项目一样，我不推荐这样做。相反，最好使用跳线连接NeoPixel
    Stick，这样你可以将它安装在机器人的其他地方。
- en: Use a jumper wire to connect the 4-7VDC pin of your NeoPixel Stick to the +5
    V rail of your breadboard. Note that because these LEDs are extra bright, they
    draw a significant amount of current. Consequently, when we run the software later,
    you’ll need to connect and switch on the robot’s batteries.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将NeoPixel Stick的4-7VDC引脚连接到面包板的+5V轨道。请注意，由于这些LED灯非常亮，它们消耗的电流较大。因此，当我们稍后运行软件时，你需要连接并打开机器人的电池。
- en: Next, use another jumper wire to attach one of the GND pins of your Stick to
    the common ground rail of your breadboard. This grounds your NeoPixels to both
    the power supply (your bat­teries) and the Raspberry Pi. Check out [Figure 6-6](ch06.xhtml#ch06fig6)
    for a diagram of what your setup should look like so far.![image](../images/f126-01.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用另一根跳线将你的NeoPixel Stick的一个GND引脚连接到面包板的公共接地轨道。这将使你的NeoPixel与电源（电池）和树莓派共地。查看[图6-6](ch06.xhtml#ch06fig6)了解你当前设置的示意图。![image](../images/f126-01.jpg)
- en: '**FIGURE 6-6** Adafruit NeoPixel Stick connected to +5 V and ground'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图6-6** Adafruit NeoPixel Stick连接到+5V和接地'
- en: Use a final jumper wire to connect the DIN (Data-In) pin of your NeoPixel Stick
    to physical pin 19 (BCM 10) on your Raspberry Pi (see “Raspberry Pi GPIO Diagram”
    on [page 200](bm02.xhtml#page_200) for a guide to pin numbering). The complete
    circuit should look like [Figure 6-7](ch06.xhtml#ch06fig7).![image](../images/f126-02.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一根跳线将你的NeoPixel Stick的DIN（数据输入）引脚连接到树莓派的物理引脚19（BCM 10）（关于引脚编号的指南请参见[第200页](bm02.xhtml#page_200)的“树莓派GPIO图”）。完整的电路应该如下所示：[图6-7](ch06.xhtml#ch06fig7)。![image](../images/f126-02.jpg)
- en: '**FIGURE 6-7** Complete breadboard diagram with the NeoPixel Stick wired up
    to power and your Pi'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图6-7** 完整的面包板示意图，显示NeoPixel Stick连接到电源和树莓派'
- en: Use sticky tack to mount your NeoPixels somewhere on your robot. I’ve mounted
    mine to the right of the breadboard.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用粘性材料将你的NeoPixel Stick安装在机器人的某个位置。我将它安装在面包板的右侧。
- en: Installing the Software
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装软件
- en: Before you program your NeoPixel Stick, you must first install and configure
    the necessary software. The Python library we’ll use is called `rpi_ws281x`, and
    you can download it from the internet for Python 3 using `pip`, a command line
    tool that allows you to quickly and easily install and manage Python software.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编程NeoPixel Stick之前，必须先安装和配置必要的软件。我们将使用的Python库叫做`rpi_ws281x`，你可以通过命令行工具`pip`从网上下载它，`pip`是一个快速且简便的Python软件安装和管理工具，适用于Python
    3。
- en: 'Before you proceed, you’ll need to ensure that you have `pip` installed for
    Python 3\. To do so, boot up your Raspberry Pi and log in via SSH. Then, enter
    the following command into the terminal:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要确保已经为Python 3安装了`pip`。为此，启动树莓派并通过SSH登录。然后，在终端输入以下命令：
- en: pi@raspberrypi:~ $ sudo apt-get update
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo apt-get update
- en: 'This command doesn’t actually install new software; instead, it updates the
    list of available software your Raspberry Pi can download. After this process
    has completed, you can install `pip` for Python 3 with this command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令实际上并不会安装新软件，而是更新树莓派可以下载的软件列表。完成此过程后，你可以使用以下命令为Python 3安装`pip`：
- en: pi@raspberrypi:~ $ sudo apt-get install python3-pip
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo apt-get install python3-pip
- en: Most likely, you’ll be informed that `pip` is already installed for Python 3,
    in which case you’re ready to use it. If not, go through the installation process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能系统会提示你`pip`已为Python 3安装好，这样你就可以开始使用它了。如果没有安装，按照安装过程继续操作。
- en: 'After this, you can install the `rpi_ws281x` library with one simple command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以通过一个简单的命令安装`rpi_ws281x`库：
- en: pi@raspberrypi:~ $ sudo pip3 install rpi_ws281x
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo pip3 install rpi_ws281x
- en: 'We will use the *SPI bus* to control the NeoPixels. This is just an electronics
    interface (the *serial peripheral interface*, to be exact) on select GPIO pins
    of every Raspberry Pi. By default, SPI is disabled, but you should have enabled
    it in the GUI when you set up your Pi at the start of this book. You can check
    that you have it enabled by opening the Raspberry Pi software configuration tool
    with this command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 *SPI 总线* 来控制 NeoPixels。这只是每个 Raspberry Pi 上某些 GPIO 引脚的电子接口（确切来说是 *串行外设接口*）。默认情况下，SPI
    是禁用的，但在开始本书时您应该已经通过图形界面启用了它。您可以通过以下命令打开 Raspberry Pi 软件配置工具，检查是否已启用 SPI：
- en: pi@raspberrypi:~ $ sudo raspi-config
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo raspi-config
- en: Once the tool opens, scroll down to **Interfacing Options**, select it, and
    then press ENTER. You’ll be presented with the menu in [Figure 6-8](ch06.xhtml#ch06fig8).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工具打开，向下滚动到 **Interfacing Options**，选择它，然后按 ENTER。您将看到 [图 6-8](ch06.xhtml#ch06fig8)
    中的菜单。
- en: '![image](../images/f128-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f128-01.jpg)'
- en: '**FIGURE 6-8** The Interfacing Options menu of the `raspi-config` tool'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-8** `raspi-config` 工具的接口选项菜单'
- en: 'Scroll down and select **SPI**. You’ll then be asked whether you would like
    the SPI interface to be enabled. Use the left/right arrow keys to highlight **Yes**.
    After you’ve done so, you’ll return to the main `raspi-config` menu. You can exit
    the configuration tool by pressing the right arrow key twice (highlighting **Finish**)
    and then pressing ENTER. Now reboot your Raspberry Pi using this command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动并选择 **SPI**。接下来，系统会询问您是否希望启用 SPI 接口。使用左右箭头键高亮选择 **Yes**。选择后，您将返回主 `raspi-config`
    菜单。您可以通过按右箭头键两次（高亮显示 **Finish**）然后按 ENTER 来退出配置工具。现在使用以下命令重启您的 Raspberry Pi：
- en: pi@raspberrypi:~ $ sudo reboot
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo reboot
- en: Now SPI is enabled!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 SPI 已启用！
- en: MAKING SPI WORK CORRECTLY ON PI 3
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PI 3 上使 SPI 正常工作
- en: If you’re using the Raspberry Pi 3 Model B/B+ there is one more step you’ll
    have to take before moving on. You don’t have to worry about this step if you’re
    using an older Pi.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Raspberry Pi 3 Model B/B+，在继续之前，您还需要执行一个额外的步骤。如果您使用的是较旧版本的 Pi，则不需要担心此步骤。
- en: To get SPI to work correctly on a Pi 3, you’ll have to change the GPU core frequency
    to 250 MHz. All this means is that you are changing the graphics unit on your
    Raspberry Pi 3 to run at a slightly different rate. If you don’t do this, your
    NeoPixels may behave erratically and not display the correct patterns.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 SPI 在 Pi 3 上正常工作，您需要将 GPU 核心频率更改为 250 MHz。这意味着您正在将 Raspberry Pi 3 上的图形单元设置为以稍微不同的速度运行。如果不进行此更改，您的
    NeoPixels 可能会表现异常，并且无法显示正确的图案。
- en: 'To make this change, enter the following command into the terminal:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行此更改，请在终端中输入以下命令：
- en: pi@raspberrypi:~ $ sudo nano /boot/config.txt
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo nano /boot/config.txt
- en: 'This will open up a configuration file containing various text and options.
    Scroll down to the bottom of this file and, on a new line, add this text:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个包含各种文本和选项的配置文件。向下滚动到文件底部，在新的一行添加以下文本：
- en: core_freq=250
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: core_freq=250
- en: 'So, for example, the end of my configuration file looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我的配置文件的结尾是这样的：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you have added this line, save the file in Nano by pressing CTRL-X, and
    then press Y and ENTER. Then reboot your Raspberry Pi.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此行后，请按 CTRL-X 保存文件，然后按 Y 和 ENTER。然后重启您的 Raspberry Pi。
- en: '**NOTE**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you think that this process may have changed, or you’re concerned that
    you have done this step incorrectly, check the book’s website at* [https://nostarch.com/raspirobots/](https://nostarch.com/raspirobots/).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您认为此过程可能已经发生变化，或者担心自己可能做错了这一步，请访问本书网站* [https://nostarch.com/raspirobots/](https://nostarch.com/raspirobots/)。'
- en: Configuring the Library’s Example Code
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置库的示例代码
- en: 'Before we go any further, let’s test the library you just installed to make
    sure everything is working perfectly. If you have already downloaded the software
    bundle that comes with this book onto your Raspberry Pi, then you already have
    the test file, *strandtest.py*. This program has been written by Adafruit to test
    out NeoPixels. If you don’t have it, download the example code from the internet
    by entering the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们测试一下您刚刚安装的库，以确保一切正常工作。如果您已经将本书附带的软件包下载到您的 Raspberry Pi 上，那么您已经拥有了测试文件
    *strandtest.py*。该程序是由 Adafruit 编写的，用于测试 NeoPixels。如果没有这个文件，可以通过输入以下命令从互联网上下载示例代码：
- en: pi@raspberrypi:~/robot $ wget https://raw.githubusercontent.com/
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ wget https://raw.githubusercontent.com/
- en: the-raspberry-pi-guy/raspirobots/master/strandtest.py
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: the-raspberry-pi-guy/raspirobots/master/strandtest.py
- en: After this has finished, you will have the exact same test code that is provided
    in the software bundle.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你将拥有与软件包中提供的完全相同的测试代码。
- en: 'Before running the example code, we need to change a few settings. To look
    at the code and the current settings, open the example code file using Nano as
    follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例代码之前，我们需要更改一些设置。要查看代码和当前设置，请使用 Nano 打开示例代码文件，如下所示：
- en: pi@raspberrypi:~/robot $ nano strandtest.py
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ nano strandtest.py
- en: The purpose of this program is run through several example light patterns. The
    code is quite long and full of functions that define the different sequences,
    but you don’t need to edit any of this code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的目的是运行多个示例灯光模式。代码相当长，充满了定义不同序列的函数，但你不需要编辑这些代码。
- en: You will, however, need to edit some of the constants inside the program. Near
    the start of the code you’ll find the chunk of code to be edited, which is reproduced
    in [Listing 6-1](ch06.xhtml#ch06list1).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你需要编辑程序中的一些常量。在代码的开头附近，你会找到需要编辑的代码块，示例代码见[列表 6-1](ch06.xhtml#ch06list1)。
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**LISTING 6-1** LED strip configuration of *strandtest.py*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6-1** *strandtest.py* 的 LED 条配置'
- en: The words after each hash character (#) are *comments*. Programmers will often
    put comments in their code as a form of annotation. Comments help human readers
    and other programmers understand what the various parts of your program do.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个井号字符（#）后的文字是*注释*。程序员经常在代码中添加注释作为注解。注释帮助人类读者和其他程序员理解程序的各个部分做了什么。
- en: In Python, a comment starts with a hash character (`#`). When Python interprets
    this code, it simply ignores everything after the hash. It is good coding practice
    to comment your programs, especially if you are working in a team or open-sourcing
    your work. Commenting is also handy as a reminder to yourself if you revisit a
    program in the future and have forgotten how it works!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，注释以井号字符（`#`）开始。当 Python 解释这段代码时，它会忽略井号后的所有内容。良好的编码实践是为你的程序添加注释，特别是当你在团队中工作或开放源代码时。注释也方便作为提醒，特别是当你未来重新访问程序时，如果忘记了它是如何工作的！
- en: 'The first thing you need to change appears at ➊: `LED_COUNT`. This is a constant
    for the number of NeoPixels you have attached to your Pi. By default it is set
    to 16, so you need to change it to 8 instead.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要更改的第一件事出现在 ➊：`LED_COUNT`。这是一个常量，表示你连接到树莓派的 NeoPixel 数量。默认情况下，它被设置为 16，所以你需要将其更改为
    8。
- en: Secondly, you’ll change the pin number being used. The constant `LED_PIN` at
    ➋ is set to BCM 18 by default, but your NeoPixel Stick is connected to BCM 10\.
    The authors of this example code have noticed that using BCM 10 is a popular choice,
    so they’ve provided an alternative constant definition at ➌, but commented it
    out.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你将更改正在使用的引脚号。常量 `LED_PIN` 在 ➋ 处默认设置为 BCM 18，但你的 NeoPixel Stick 连接到 BCM 10。这个示例代码的作者注意到使用
    BCM 10 是一个流行的选择，所以他们在 ➌ 处提供了一个替代的常量定义，但已将其注释掉。
- en: To swap these lines around, add a hash to the start of the line at ➋. This will
    *comment out* that line so that Python will ignore it. Then, remove the hash at
    ➌ to *uncomment* the line, which will make Python run the line of code assigning
    `LED_PIN` to 10.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要交换这些行的位置，请在 ➋ 处的行首添加井号。这样会将该行*注释掉*，使 Python 忽略它。然后，在 ➌ 处移除井号以*取消注释*该行，这将使 Python
    执行将 `LED_PIN` 赋值为 10 的代码。
- en: Your final block of constants should now look like the code in [Listing 6-2](ch06.xhtml#ch06list2).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最终常量块现在应该类似于[列表 6-2](ch06.xhtml#ch06list2)中的代码。
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**LISTING 6-2** The new LED strip configuration of *strandtest.py*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6-2** *strandtest.py* 的新 LED 条配置'
- en: Once you have your code set up, you can run it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置好代码，就可以运行它了。
- en: Running the Example Code
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行示例代码
- en: 'Save the changes you have made to the example program and run it with the following
    command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你对示例程序所做的更改，并使用以下命令运行它：
- en: pi@raspberrypi:~/robot $ python3 strandtest.py -c
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 strandtest.py -c
- en: And you might want to grab a pair of sunglasses! Your NeoPixels should now be
    going through a sequence of patterns, the names of which are displayed in the
    terminal as they start (see [Figure 6-9](ch06.xhtml#ch06fig9)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要戴上太阳镜！现在你的 NeoPixel 应该会通过一系列的模式，这些模式的名称会在终端中显示出来（如[图 6-9](ch06.xhtml#ch06fig9)所示）。
- en: '![image](../images/f132-01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f132-01.jpg)'
- en: '**FIGURE 6-9** NeoPixels going through the *strandtest.py* example program'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-9** NeoPixels 在 *strandtest.py* 示例程序中的运行效果'
- en: When your retinas have had enough, press CTRL-C to kill the example code. The
    `–c` you should have added to the end of your original run command should turn
    off your LEDs. If you didn’t add `–c` to the command, killing the program will
    just freeze your LEDs and they will remain powered on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的视网膜受够了时，按 CTRL-C 来终止示例代码。你应该在原始运行命令的末尾添加的`–c`参数会关闭你的 LED。如果你没有在命令中添加`–c`，终止程序将只是冻结你的
    LED，它们会保持亮着。
- en: If you’re worried about the intensity of your LEDs and being blinded, don’t
    fret! As we add NeoPixel control to the Wiimote program, I’ll show you how to
    turn down their brightness.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心 LED 的亮度会让你眼睛刺痛，不用担心！在我们将 NeoPixel 控制添加到 Wiimote 程序时，我会向你展示如何调低它们的亮度。
- en: Controlling NeoPixels Using the Wiimote Program
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Wiimote 程序控制 NeoPixels
- en: Now that you have tested out your NeoPixels and seen what they’re capable of,
    it’s time to add LED-controlling capabilities to the accelerometer-based Wiimote
    program you made earlier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经测试了 NeoPixel 并看到了它们的能力，是时候将 LED 控制功能添加到你之前制作的基于加速度计的 Wiimote 程序中了。
- en: 'We’re going to add NeoPixels to the Wiimote program, but it would be ideal
    to keep a copy of the original Wiimote code without these additions just in case
    something goes wrong or we want to go back to it in future. To do this, we’ll
    create and edit a copy of the program instead. First, make sure you are in the
    directory where your code is stored; for me, that’s my *robot* directory. Then,
    in the terminal, copy your original Wiimote program using the command `cp`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 Wiimote 程序添加 NeoPixel，但最好保留原始的 Wiimote 代码副本，以防万一出现问题，或者我们以后想要恢复到原来的状态。为此，我们将创建并编辑该程序的副本。首先，确保你所在的目录是存储代码的目录；对我而言，就是我的*robot*目录。然后，在终端中使用
    `cp` 命令复制原始的 Wiimote 程序：
- en: pi@raspberrypi:~/robot $ cp remote_control_accel.py neo_remote_
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ cp remote_control_accel.py neo_remote_
- en: control.py
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: control.py
- en: 'This command simply copies the contents of its first argument (*remote_control_accel.py*)
    to the new file specified in the second argument. As you can see, I have decided
    to name my NeoPixel version of the Wiimote program *neo_remote_control.py*. After
    this, open the newly copied file with Nano like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令简单地将第一个参数（*remote_control_accel.py*）的内容复制到第二个参数指定的新文件中。正如你所看到的，我决定将我的 Wiimote
    程序的 NeoPixel 版本命名为*neo_remote_control.py*。接下来，用 Nano 打开新复制的文件，操作如下：
- en: pi@raspberrypi:~/robot $ nano neo_remote_control.py
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ nano neo_remote_control.py
- en: Now enter the modifications to the code in [Listing 6-3](ch06.xhtml#ch06list3),
    or you can download the complete program at *[https://nostarch.com/raspirobots/](https://nostarch.com/raspirobots/)*.
    I have omitted and compressed the parts of the program that have not changed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入[Listing 6-3](ch06.xhtml#ch06list3)中的代码修改，或者你也可以在 *[https://nostarch.com/raspirobots/](https://nostarch.com/raspirobots/)*
    下载完整程序。我已经省略并压缩了那些没有变化的程序部分。
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**LISTING 6-3** The updated Wiimote code with NeoPixel functionality'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 6-3** 更新后的 Wiimote 代码，具有 NeoPixel 功能'
- en: This program relies on two additional sets of libraries that the original Wiimote
    code did not, so we need to import both the `time` and `rpi_ws281x` libraries
    ➊.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序依赖于两个额外的库，而原始的 Wiimote 代码没有使用，所以我们需要导入 `time` 和 `rpi_ws281x` 这两个库 ➊。
- en: Then, just as with the original program, we set up the robot and Wiimote for
    use. After this, we define the same chunk of constants we saw in the example NeoPixel
    program. These define the various parameters for the NeoPixel Stick. Most notably,
    you’ll find `LED_BRIGHTNESS` ➋, a constant that can be set between 0 and 255\.
    I have set mine to be dimmer and easier on the eyes at 150.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像原始程序一样，我们设置机器人和 Wiimote 进行使用。之后，我们定义了与示例 NeoPixel 程序中看到的相同的一组常量。这些常量定义了
    NeoPixel Stick 的各种参数。最显著的是，你会发现`LED_BRIGHTNESS` ➋，它是一个常量，可以设置在 0 到 255 之间。我将其设置为
    150，使其更暗、更柔和，减少对眼睛的刺激。
- en: At ➌, we create the NeoPixel Stick object and set up the constants defined previously.
    The library is initialized on the following line.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们创建了 NeoPixel Stick 对象，并设置了之前定义的常量。库在接下来的行初始化。
- en: 'We then define a function called `colorWipe()` ➍ to use later. This function
    has been taken directly out of the *strandtest.py* example. The comment inside
    it describes what the function does: it wipes a color across the NeoPixel Stick
    one pixel at a time. To do this, it takes an RGB `color` parameter and then uses
    a `for` loop ➎ to set each pixel to that color one by one, with a short delay
    in between.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个名为`colorWipe()`的函数 ➍ 以便稍后使用。这个函数直接来自 *strandtest.py* 示例。函数内的注释描述了它的功能：它会一次擦除一个像素，并将颜色逐步应用到
    NeoPixel 条上。为此，它接收一个 RGB `color` 参数，并使用 `for` 循环 ➎ 一次设置每个像素的颜色，中间有短暂的延迟。
- en: After this, we start the main body of code in the infinite `while` loop. At
    the start of each loop, the status of the Wiimote buttons is read ➏. Then, depending
    on whether the user presses the plus, minus, or home button, a different color
    will wipe across the NeoPixel Stick and remain there until another button is pressed.
    If the user presses the B button, the NeoPixels will be reset.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始在无限的 `while` 循环中编写代码。每次循环开始时，读取 Wiimote 按钮的状态 ➏。然后，根据用户按下加号、减号或主页按钮的不同，NeoPixel
    条上会逐渐显示不同的颜色，并保持该颜色，直到按下另一个按钮。如果用户按下 B 按钮，NeoPixel 将会重置。
- en: 'The rest of the program is exactly the same as the original: it deals with
    the accelerometer output from the controller and makes the robot move accordingly.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分与原始程序完全相同：它处理来自控制器的加速度计输出，并使机器人相应移动。
- en: 'Running Your Program: NeoPixels and Wiimote Control'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序：NeoPixel 和 Wiimote 控制
- en: 'Save your work and run your code with the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的工作并使用以下命令运行你的代码：
- en: pi@raspberrypi:~/robot $ python3 neo_remote_control.py
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 neo_remote_control.py
- en: Your robot should now respond to the accelerometer data from your Wiimote. Try
    pressing the plus, minus, home, and B buttons to trigger the different lights,
    as shown in [Figure 6-10](ch06.xhtml#ch06fig10).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的机器人应该能响应来自 Wiimote 的加速度计数据。尝试按下加号、减号、主页和 B 按钮来触发不同的灯光，如 [图 6-10](ch06.xhtml#ch06fig10)
    所示。
- en: '![image](../images/f135-01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f135-01.jpg)'
- en: '**FIGURE 6-10** My robot with its NeoPixels set to blue'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-10** 我的机器人，NeoPixel 设置为蓝色'
- en: Before you kill the program with CTRL-C, make sure you press the B button on
    your Wiimote to turn the NeoPixels off!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 CTRL-C 终止程序之前，确保你按下 Wiimote 上的 B 按钮关闭 NeoPixel！
- en: 'Challenge Yourself: Experiment with Color and Pattern'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战自己：尝试不同的颜色和图案
- en: Once you have played around with your robot and NeoPixels, go back into the
    program and the example code shown previously to see if you can set your own custom
    colors by changing the RGB color combinations. Or, see if you can create more
    adventurous light patterns to display.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你玩过机器人和 NeoPixel，回到程序中，查看之前展示的示例代码，看看你能否通过更改 RGB 颜色组合来设置自己的自定义颜色。或者，看看你是否能够创造更具冒险精神的灯光图案来显示。
- en: If you have more than one NeoPixel Stick, you can chain them together by feeding
    the output of one into the input of the other to create an even more dazzling
    two-wheeler!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个 NeoPixel 条，可以通过将一个条的输出连接到另一个条的输入来将它们连接在一起，打造一个更炫目的双轮车！
- en: ADDING A SPEAKER TO YOUR RASPBERRY PI ROBOT
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向你的树莓派机器人添加扬声器
- en: 'While your robot has already come a long way, one feature that has been notably
    absent is the ability to make noise and communicate. In the following two projects,
    we’ll change that! I’ll guide you through adding a small 3.5 mm speaker to your
    robot and using it to add sound to two previous projects: a car horn for the Wiimote
    program, and a parking-sensor-style beep for your obstacle avoidance program.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你的机器人已经取得了很大进展，但一个显著缺失的功能是能够发出声音和进行通信。在接下来的两个项目中，我们将改变这一点！我将指导你向机器人添加一个小型
    3.5 毫米扬声器，并用它为之前的两个项目增加声音：为 Wiimote 程序添加车喇叭声，为障碍物避让程序添加停车传感器风格的蜂鸣声。
- en: '**WARNING**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*You’ll only be able to follow along with these projects if you have a full-size
    Raspberry Pi like the Pi 3, Pi 2, Pi 1 Model B/B+ or even A+. Models such as the
    Pi Zero and Pi Zero W do not feature 3.5 mm audio jacks and therefore can’t easily
    connect to a speaker.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*你只有拥有像 Pi 3、Pi 2、Pi 1 Model B/B+ 或甚至 A+ 这样的全尺寸树莓派时，才能跟随这些项目。像 Pi Zero 和 Pi
    Zero W 这样的模型没有 3.5 毫米音频插孔，因此无法轻松连接到扬声器。*'
- en: Understanding How 3.5 mm Speakers Work
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解 3.5 毫米扬声器的工作原理
- en: A *loudspeaker* (or just plain *speaker*) converts an electrical audio signal
    into a sound that can be heard by humans. You’ll have come across many speakers
    in a wide range of environments—from huge speakers at concerts to the minuiscule
    ones inside your mobile phone.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*扬声器*（或简单的*音响*）将电气音频信号转换成可以被人类听到的声音。你会在各种环境中见到许多扬声器——从音乐会上的巨大扬声器到手机内部的微型扬声器。
- en: In order to translate an electrical signal into an audible sound, speakers use
    an electromagnet to vibrate a cone. This cone amplifies those vibrations and pumps
    sound waves into the surrounding air and to your ears.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将电气信号转换为可听见的声音，扬声器使用电磁铁使音锥振动。这个音锥会放大振动，并将声波传递到周围的空气中，最终传到你的耳朵里。
- en: For the following two projects you’ll need a small 3.5 mm speaker, like the
    one shown in [Figure 6-11](ch06.xhtml#ch06fig11). The 3.5 mm sizing refers to
    the diameter of the audio jack. This size is an industry standard, and the same
    as most phone headphone jacks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个项目中，你将需要一个小型3.5毫米扬声器，像[图6-11](ch06.xhtml#ch06fig11)中展示的那样。3.5毫米指的是音频插孔的直径。这个尺寸是行业标准，也与大多数手机耳机插孔相同。
- en: '![image](../images/f136-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f136-01.jpg)'
- en: '**FIGURE 6-11** My small 3.5 mm speaker'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-11** 我的3.5毫米小型扬声器'
- en: '**NOTE**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If your speaker isn’t rechargeable, the method you use to power it will depend
    on the exact model. If it requires USB power, you could plug it into one of your
    Pi’s USB ports. Having a rechargeable speaker avoids this issue and is therefore
    the most ideal option in this situation.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的扬声器不可充电，供电方式将取决于具体型号。如果需要USB电源，你可以将其插入Pi的USB端口之一。拥有可充电扬声器可以避免这个问题，因此在这种情况下，它是最理想的选择。*'
- en: You can pick up a 3.5 mm speaker online by searching eBay, Amazon, or any regular
    electronics retailer. It should set you back no more than $10\. The make and brand
    isn’t that relevant; as long as it is small enough to fit on your robot, is relatively
    loud, and has a 3.5 mm jack, you should be good!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在eBay、Amazon或任何常规电子零售商处搜索来购买一个3.5毫米扬声器。它的价格应该不会超过10美元。品牌和型号并不是特别重要；只要它足够小，能够放到你的机器人上，并且声音足够大，且有3.5毫米插孔，你就可以使用它！
- en: Connecting Your Speaker
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接你的扬声器
- en: Most small speakers are rechargeable, so before you begin connecting your speaker
    to your Raspberry Pi, make sure that it is fully charged and operational.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数小型扬声器都是可充电的，所以在将扬声器连接到树莓派之前，请确保它已完全充电并且可以正常工作。
- en: Your Pi’s 3.5 mm audio jack is between the HDMI and Ethernet ports. Take your
    speaker and plug its 3.5 mm cable into the jack on your Pi, as shown in [Figure
    6-12](ch06.xhtml#ch06fig12).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Pi的3.5毫米音频插孔位于HDMI和以太网端口之间。将扬声器的3.5毫米电缆插入Pi上的插孔，如[图6-12](ch06.xhtml#ch06fig12)所示。
- en: '![image](../images/f137-01.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f137-01.jpg)'
- en: '**FIGURE 6-12** Speaker connected to my Raspberry Pi through the 3.5 mm audio
    jack'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-12** 扬声器通过3.5毫米音频插孔连接到我的树莓派'
- en: Now mount your speaker somewhere on your robot chassis. Where you mount it depends
    on the size of your speaker, as well as the free space that you have available.
    Since I didn’t have enough room to simply attach the speaker to the main chassis,
    I decided to create a small stalk out of a few LEGO pieces, and then affixed my
    speaker with sticky tack, as shown in [Figure 6-13](ch06.xhtml#ch06fig13).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将扬声器安装在你的机器人底盘的某个位置。你安装的位置取决于扬声器的大小以及你可用的空余空间。由于我没有足够的空间将扬声器直接安装到主底盘上，我决定用几块LEGO积木做一个小支杆，然后用粘性胶将扬声器固定在上面，正如[图6-13](ch06.xhtml#ch06fig13)所示。
- en: '![image](../images/f138-01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f138-01.jpg)'
- en: '**FIGURE 6-13** My 3.5 mm speaker connected to my Pi and mounted on top of
    a small LEGO stalk'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-13** 我的3.5毫米扬声器连接到我的Pi，并安装在小LEGO支杆上方'
- en: ADDING A CAR HORN TO THE WIIMOTE PROGRAM
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向Wiimote程序添加汽车喇叭音效
- en: Now let’s extend the previous program so that your robot sounds a car horn at
    your command. We’ll edit the NeoPixel Wiimote program to activate a horn sound
    effect when the A button on your Wiimote is pressed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们扩展之前的程序，让你的机器人根据命令发出汽车喇叭的声音。我们将编辑NeoPixel Wiimote程序，使当Wiimote上的A按钮被按下时，激活喇叭音效。
- en: Installing the Software
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装软件
- en: Normally you’d play an audio file by clicking it on a GUI and opening it in
    a music playing application. Unlike a GUI, though, the terminal leaves you with
    no such ability, so you have to use special commands to play audio files. As with
    the NeoPixels, you first need to install the required software and configure the
    sound output.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会通过在图形界面中点击音频文件并在音乐播放器应用程序中打开它来播放音频文件。但与图形界面不同，终端没有这样的功能，所以你必须使用特殊的命令来播放音频文件。与
    NeoPixels 一样，你首先需要安装所需的软件并配置音频输出。
- en: 'First, ensure that the `alsa-utils` software package is already installed on
    your Raspberry Pi. This is a collection of software that relates to audio and
    device drivers. You can check whether it’s installed or install the package using
    this command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你的树莓派上已安装 `alsa-utils` 软件包。这是一个与音频和设备驱动程序相关的软件集合。你可以使用以下命令检查它是否已安装，或者安装该软件包：
- en: pi@raspberrypi:~/robot $ sudo apt-get install alsa-utils
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ sudo apt-get install alsa-utils
- en: If your Pi tells you that it already has the latest version of `alsa-utils`,
    then great! If not, you’ll need to go through the quick installation process,
    responding to the prompts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的树莓派提示你已经安装了最新版本的 `alsa-utils`，那就太好了！如果没有，你需要通过快速安装过程，按照提示进行操作。
- en: 'After this, the only remaining step is to tell the Raspberry Pi to play audio
    through the 3.5 mm audio jack instead of the HDMI port. We do this in the terminal
    by using the Raspberry Pi configuration tool `raspi-config`, just like we did
    earlier. To open this tool, use the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，剩下的唯一步骤是告诉树莓派通过 3.5 毫米音频插孔而不是 HDMI 端口播放音频。我们通过使用树莓派配置工具 `raspi-config`
    来做到这一点，就像之前那样。要打开此工具，请使用以下命令：
- en: pi@raspberrypi:~/robot $ sudo raspi-config
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ sudo raspi-config
- en: You should see a blue screen with options in a gray box in the center, as in
    [Figure 6-14](ch06.xhtml#ch06fig14).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个蓝色的屏幕，中央有一个灰色框内的选项，如[图 6-14](ch06.xhtml#ch06fig14)所示。
- en: '![image](../images/f139-01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f139-01.jpg)'
- en: '**FIGURE 6-14** The Raspberry Pi software configuration tool'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-14** 树莓派软件配置工具'
- en: Now use the arrow keys to scroll down and select **Advanced Options** and then
    press ENTER. This will open up a new menu; scroll down to **Audio**, select it,
    and press ENTER again.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用箭头键向下滚动并选择 **Advanced Options**，然后按 ENTER。这将打开一个新菜单；向下滚动至 **Audio**，选择它，并再次按
    ENTER。
- en: Once here, you will be provided with the three options. Select the **Force 3.5mm
    jack** option, as shown in [Figure 6-15](ch06.xhtml#ch06fig15).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 进入该选项后，你将看到三个选项。选择 **Force 3.5mm jack** 选项，如[图 6-15](ch06.xhtml#ch06fig15)所示。
- en: '![image](../images/f139-02.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f139-02.jpg)'
- en: '**FIGURE 6-15** Choosing the audio output using `raspi-config`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-15** 使用 `raspi-config` 选择音频输出'
- en: Next, you’ll be returned to the original menu shown in [Figure 6-14](ch06.xhtml#ch06fig14).
    From there exit the configuration tool by pressing the right arrow key twice (to
    highlight **Finish**) and then pressing ENTER.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将返回到 [图 6-14](ch06.xhtml#ch06fig14) 中显示的原始菜单。从那里，按右箭头键两次（以高亮 **Finish**），然后按
    ENTER 退出配置工具。
- en: Playing Sounds from the Terminal
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从终端播放声音
- en: 'To play sounds from the terminal, you first need some sounds to play! The audio
    files for this project and the next one can be found online at *[https://nostarch.com/raspirobots/](https://nostarch.com/raspirobots/)*.
    If you have downloaded all of the software in bulk, then you’ll already have the
    files. Alternatively, you can grab the two audio files off the internet with a
    few easy commands. Either way, first create a new directory called *sounds* inside
    the folder where you’re storing all of your robot programs. For me, this command
    looks like:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要从终端播放声音，首先你需要一些声音文件！本项目及下一个项目的音频文件可以在线找到，网址是 *[https://nostarch.com/raspirobots/](https://nostarch.com/raspirobots/)*。如果你已经批量下载了所有软件，那么你应该已经拥有这些文件。或者，你也可以通过一些简单的命令从网上获取这两个音频文件。不管哪种方式，首先在你存储所有机器人程序的文件夹内创建一个名为
    *sounds* 的新目录。对我来说，这个命令如下所示：
- en: pi@raspberrypi:~/robot $ mkdir sounds
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ mkdir sounds
- en: 'If you downloaded the files in bulk, transfer the files *beep.wav* and *horn.wav*
    into this new folder. If you want to download the files directly, then change
    into that directory as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你批量下载了文件，请将 *beep.wav* 和 *horn.wav* 文件转移到这个新文件夹中。如果你想直接下载这些文件，可以按如下方式切换到该目录：
- en: pi@raspberrypi:~/robot $ cd sounds
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ cd sounds
- en: 'Finally, to download each of the audio files, use this command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要下载每个音频文件，请使用以下命令：
- en: pi@raspberrypi:~/robot/sounds $ wget https://raw.githubusercontent
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot/sounds $ wget https://raw.githubusercontent
- en: .com/the-raspberry-pi-guy/raspirobots/master/sounds/beep.wav
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: .com/the-raspberry-pi-guy/raspirobots/master/sounds/beep.wav
- en: 'Followed by this one:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，输入以下命令：
- en: pi@raspberrypi:~/robot/sounds $ wget https://raw.githubusercontent
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot/sounds $ wget https://raw.githubusercontent
- en: .com/the-raspberry-pi-guy/raspirobots/master/sounds/horn.wav
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: .com/the-raspberry-pi-guy/raspirobots/master/sounds/horn.wav
- en: 'Now if you enter `ls` in the terminal, you’ll find two new audio files—*horn.wav*
    and *beep.wav*:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在终端中输入`ls`，你将看到两个新的音频文件——*horn.wav*和*beep.wav*：
- en: '[PRE4]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The former is the file we’ll use in this project. Before you test *horn.wav*,
    increase the software volume level of your speaker to its maximum with this command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前者是我们将在本项目中使用的文件。在你测试*horn.wav*之前，使用以下命令将扬声器的软件音量调至最大：
- en: pi@raspberrypi:~/robot/sounds $ amixer set PCM 100%
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot/sounds $ amixer set PCM 100%
- en: 'Also ensure that any physical volume control on your 3.5 mm speaker is at its
    maximum. Then, to play *horn.wav* through your 3.5 mm speaker, you’ll use `aplay`,
    a terminal-based sound player, like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，确保你的3.5毫米扬声器上的任何物理音量控制也已调至最大。然后，为了通过3.5毫米扬声器播放*horn.wav*，你将使用`aplay`，一个基于终端的声音播放器，如下所示：
- en: pi@raspberrypi:~/robot/sounds $ aplay horn.wav
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot/sounds $ aplay horn.wav
- en: 'Playing WAVE ''horn.wav'' : Signed 24 bit Little Endian in 3bytes,'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正在播放WAVE 'horn.wav'：签名24位小端格式，3字节，
- en: Rate 44100 Hz, Stereo
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 频率 44100 Hz，立体声
- en: You should hear your robot emit a single car horn noise!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能听到机器人发出单一的汽车喇叭声！
- en: Playing Sound Using the Wiimote Program
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Wiimote程序播放声音
- en: Now that you understand how to play sound files through the terminal, you can
    add this functionality to the Wiimote program from earlier in the chapter. This
    means that your robot will be able not only to trigger a light show, but also
    to sound a car horn whenever you wish!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了如何通过终端播放音频文件，你可以将此功能添加到本章早些时候的Wiimote程序中。这意味着你的机器人不仅可以触发灯光秀，还可以在你想要的时候鸣响汽车喇叭！
- en: 'To accomplish this, we’ll call the `aplay` command from inside Python. Navigate
    back into the *robots* directory and then reopen the NeoPixel/Wiimote code with
    this command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将在Python中调用`aplay`命令。返回到*robots*目录，然后使用以下命令重新打开NeoPixel/Wiimote代码：
- en: pi@raspberrypi:~/robot $ nano neo_remote_control.py
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ nano neo_remote_control.py
- en: Then, enter the additions in [Listing 6-4](ch06.xhtml#ch06list4) into your own
    code. As before, all of the unchanged code has been omitted. Alternatively, you
    can grab the modified file from the book’s website.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将[清单6-4](ch06.xhtml#ch06list4)中的新增内容添加到你的代码中。如之前一样，所有未更改的代码已被省略。或者，你可以从本书网站下载修改后的文件。
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**LISTING 6-4** The modified NeoPixel/Wiimote code with car horn sound effect'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单6-4** 修改后的NeoPixel/Wiimote代码，加入汽车喇叭声音效果'
- en: The additions required are simple and span only three lines. The first thing
    to note is at ➊, where the `os` library is imported. The `os` library enables
    us to use the functionality of the Pi’s operating system inside of a Python program.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的新增内容很简单，仅涉及三行。首先需要注意的是在➊处，`os`库被导入。`os`库使我们能够在Python程序中使用树莓派操作系统的功能。
- en: This comes in handy at ➋. Here, the program detects whether the user has pressed
    the A button on the Wiimote. If so, the same `aplay` terminal command you used
    earlier is called using `os.system`. Notice that there is also a short filepath
    to the *horn.wav* sound, as this file is stored in a different directory than
    the program.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这在➋处非常有用。在这里，程序检测用户是否按下了Wiimote上的A按钮。如果是，它会使用`os.system`调用之前使用的相同的`aplay`终端命令。请注意，这里还包括了一个简短的文件路径指向*horn.wav*音频文件，因为这个文件存储在与程序不同的目录中。
- en: 'Running Your Program: NeoPixels, Sound Effects, and the Wiimote Control'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序：NeoPixels、声音效果和Wiimote控制
- en: 'Save your work and run it with the same command as the previous project:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的工作，并使用与上一个项目相同的命令运行它：
- en: pi@raspberrypi:~/robot $ python3 neo_remote_control.py
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 neo_remote_control.py
- en: 'Your robot will now respond exactly as before, with accelero­meter control.
    You’ll also be able to trigger the same lights as before. Now try pressing the
    A button: you should hear your robot honk its horn!'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人现在将像以前一样通过加速度计控制进行响应。你还可以像以前一样触发相同的灯光。现在尝试按下A按钮：你应该听到机器人鸣响喇叭！
- en: ADDING BEEPING TO THE OBSTACLE AVOIDANCE PROGRAM
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向避障程序中添加蜂鸣声
- en: In this project, we’ll revisit the obstacle avoidance program you already coded
    in [Chapter 5](ch05.xhtml#ch05), and add a beeping sound to alert you when your
    robot has detected an obstacle within a 15 cm range.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将重新访问你在[第5章](ch05.xhtml#ch05)中编写的避障程序，并在机器人检测到15厘米范围内的障碍物时添加一个蜂鸣声来提醒你。
- en: Integrating the Beep Sound into the Obstacle Avoidance Program
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将蜂鸣声集成到避障程序中
- en: You’ve already set up your speaker and configured the necessary software, so
    we can jump straight into integrating the beep sound into the obstacle avoidance
    program.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经设置好了扬声器并配置了必要的软件，所以我们可以直接开始将蜂鸣声集成到避障程序中了。
- en: 'We’ll do this as we did with the horn: by calling `aplay` inside of the Python
    program. I recommend using `cp` to create a new copy of the obstacle avoidance
    program. I’ve called mine *beep_obstacle_avoider.py*. Enter the modifications
    I made as shown in [Listing 6-5](ch06.xhtml#ch06list5).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像之前为喇叭所做的那样，通过在 Python 程序中调用 `aplay` 来实现。我建议使用 `cp` 来创建一个避障程序的新副本。我将我的副本命名为
    *beep_obstacle_avoider.py*。请输入我所做的修改，如[清单 6-5](ch06.xhtml#ch06list5)所示。
- en: '[PRE6]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**LISTING 6-5** The *beep_obstacle_avoider.py* program'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 6-5** *beep_obstacle_avoider.py* 程序'
- en: Just as before, we import the `os` module ➊. Then, if the sensor detects an
    object less than or equal to 15 cm away, the program plays the beep sound ➋ and
    the robot changes course.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们导入 `os` 模块 ➊。然后，如果传感器检测到距离小于或等于 15 厘米的物体，程序会播放蜂鸣声 ➋，并且机器人改变方向。
- en: 'Running Your Program: Beeping Obstacle Avoidance'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序：避障时发出蜂鸣声
- en: 'Save your work and run it with the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的工作并使用以下命令运行：
- en: pi@raspberrypi:~/robot $ python3 beep_obstacle_avoider.py
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 beep_obstacle_avoider.py
- en: Your robot will now avoid obstacles and beep when it does so!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的机器人会避开障碍物，并在此过程中发出蜂鸣声！
- en: 'Challenge Yourself: Add Sound Effects to Your Other Projects'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战自己：为你的其他项目添加音效
- en: 'Now that you know the relatively simple process of adding audio effects to
    a program, why not revisit the other programs you have written over the course
    of this book and add sound to them? You could use your phone to record your own
    noises, or you can use online sound libraries that provide free audio files. For
    example, take a look at Freesound: *[https://freesound.org/](https://freesound.org/)*.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你已经了解了将音效添加到程序中的相对简单过程，为什么不回顾一下你在本书中编写的其他程序，并为它们添加声音呢？你可以用手机录制自己的声音，或者使用提供免费音频文件的在线音效库。例如，可以查看
    Freesound: *[https://freesound.org/](https://freesound.org/)*。'
- en: SUMMARY
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you have decked out your robot with some super-bright NeoPixels
    and given it the gift of sound, too! Over the course of three different projects,
    we’ve covered everything from the theory of RGB LEDs to how to play audio in the
    terminal.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你为你的机器人装上了超亮的 NeoPixels，并赋予了它声音的能力！在三个不同的项目中，我们从 RGB LED 的理论到如何在终端播放音频，都做了详细讲解。
- en: In the next chapter, we’ll make your robot a little bit more intelligent! I’ll
    guide you through the process of giving your two-wheeler the ability to autonomously
    follow lines.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使你的机器人更加智能！我将指导你完成让你的两轮车能够自主跟随路线的过程。
