- en: '![](../images/pg2.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg2.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-02.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-02.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">A
    MINIMAL COMPILER</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">一个最小的编译器</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: In this chapter, you’ll write a minimal compiler that can handle only the simplest
    C programs. You’ll learn how to read a simple assembly program, and you’ll implement
    four basic compiler passes that you’ll build on throughout the rest of the book.
    Let’s start by looking at these compiler passes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将编写一个最小的编译器，只能处理最简单的C程序。你将学习如何读取一个简单的汇编程序，并实现四个基本的编译器阶段，这些阶段将贯穿本书的其余部分。让我们先来看看这些编译器阶段。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Four Compiler Passes</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">四个编译器阶段</samp>
- en: 'The compiler you write in this chapter will process source code in four stages:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中编写的编译器将分四个阶段处理源代码：
- en: The *lexer* breaks up the source code into a list of *tokens*. Tokens are the
    smallest syntactic units of a program; they include delimiters, arithmetic symbols,
    keywords, and identifiers. If a program is like a book, tokens are like individual
    words.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*词法分析器*将源代码拆分成一系列*标记*。标记是程序的最小语法单位；它们包括分隔符、算术符号、关键字和标识符。如果程序像一本书，那么标记就像单独的单词。'
- en: The *parser* converts the list of tokens into an *abstract syntax tree (AST)*,
    which represents the program in a form we can easily traverse and analyze.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*解析器*将标记列表转换为*抽象语法树（AST）*，它以一种我们可以轻松遍历和分析的形式表示程序。'
- en: The *assembly generation* pass converts the AST into assembly. At this stage,
    we still represent the assembly instructions in a data structure that the compiler
    can understand, not as text.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*汇编生成*阶段将抽象语法树转换为汇编代码。在此阶段，我们仍然以编译器可以理解的数据结构来表示汇编指令，而不是文本形式。'
- en: The *code emission* pass writes the assembly code to a file so the assembler
    and linker can turn it into an executable.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*代码生成*阶段将汇编代码写入文件，以便汇编器和链接器可以将其转换为可执行文件。'
- en: This is a typical way of structuring a compiler, although the exact stages and
    intermediate representations vary. It’s also overkill for this chapter—you could
    compile the programs you’ll handle here in just one pass—but setting up this structure
    now makes it easier to expand your compiler in future chapters. As you implement
    more language features, you’ll extend these compiler stages and add a few new
    ones. Each chapter starts with a current diagram of the compiler’s architecture,
    including the stages you’ve already implemented and any you need to add. This
    chapter’s diagram shows the four stages you’re about to implement. In the diagrams
    for later chapters, new stages will be bolded.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种典型的编译器结构方式，尽管具体阶段和中间表示形式有所不同。对于本章来说，这也有些过于复杂——你可以在一个阶段内编译本章处理的程序——但是现在设置这个结构将使你在未来章节中更容易扩展编译器。随着你实现更多的语言特性，你将扩展这些编译器阶段，并添加一些新的阶段。每一章开始时，都会展示一个当前的编译器架构图，包括你已经实现的阶段以及你需要添加的任何新阶段。本章的架构图展示了你即将实现的四个阶段。在后续章节的图表中，新的阶段将用粗体标出。
- en: Before you start coding, let’s take a quick look at how to compile C to assembly
    with the C compiler already installed on your system, and how to read assembly
    programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，先快速了解如何使用系统中已安装的C编译器将C代码编译为汇编代码，并了解如何阅读汇编程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hello, Assembly!</samp>
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">你好，汇编语言！</samp>
- en: The simplest C program looks like [Listing 1-1](chapter1.xhtml#list1-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的C程序如下所示：[列表 1-1](chapter1.xhtml#list1-1)。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: A simple program
    that returns the number 2</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 1-1：一个返回数字2的简单程序</samp>
- en: 'This program consists of a single function, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    containing a single <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement, which returns an integer (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>).
    Save this program as *return_2.c*, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>
    command to translate it into assembly:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: "该程序由一个单独的函数组成，<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">main</samp>，其中包含一个<\t\
    samp class=\"SANS_TheSansMonoCd_W5Regular_11\">return</samp>语句，返回一个整数（在这种情况下是<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">2</samp>）。将此程序保存为*return_2.c*，然后使用<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">gcc</samp>命令将其转换为汇编代码："
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you’re using macOS, this command may invoke Clang instead of GCC, but the
    command line options have the same effect. These options produce fairly readable
    assembly:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 macOS，这个命令可能会调用 Clang 而不是 GCC，但命令行选项的效果是相同的。这些选项会生成相当易读的汇编代码：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-S</samp> Don’t run the assembler
    or linker. This makes the compiler emit assembly instead of a binary file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-S</samp> 不要运行汇编器或链接器。这会让编译器生成汇编代码，而不是二进制文件。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-O</samp> Optimize the code. This
    eliminates some instructions we aren’t concerned with right now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-O</samp> 优化代码。这会删除一些我们目前不关心的指令。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-fno-asynchronous-unwind-tables</samp> Don’t
    generate the unwind table, which is used for debugging. We don’t need it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-fno-asynchronous-unwind-tables</samp> 不生成用于调试的展开表。我们不需要它。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-fcf-protection=none</samp> Disable
    control-flow protection, a security feature that adds extra instructions we aren’t
    concerned with. Control-flow protection might already be disabled by default on
    your system, in which case this option won’t do anything. Skip this option if
    you’re using an old version of GCC or Clang that doesn’t support it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-fcf-protection=none</samp> 禁用控制流保护，这是一种安全特性，会添加一些我们当前不关心的额外指令。控制流保护可能在你的系统上默认已经禁用，在这种情况下，这个选项不会起作用。如果你使用的是不支持该选项的旧版本
    GCC 或 Clang，请跳过这个选项。
- en: The result, stored in *return_2.s*, should look similar to [Listing 1-2](chapter1.xhtml#list1-2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 结果保存在*return_2.s*中，应该类似于[清单 1-2](chapter1.xhtml#list1-2)。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-2: The program from
    [Listing 1-1](chapter1.xhtml#list1-1) translated into assembly</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-2: [清单 1-1](chapter1.xhtml#list1-1)
    中的程序翻译成汇编代码</samp>'
- en: Your *.s* file might contain a few other lines, but you can safely ignore them
    for now. The four lines in [Listing 1-2](chapter1.xhtml#list1-2) are a complete
    assembly program. Assembly programs have several kinds of statements. The first
    line, <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp>, is an
    *assembler directive*, a statement that provides directions for the assembler.
    Assembler directives always start with a period. Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    is a *symbol*, a name for a memory address. Symbols appear in assembly instructions
    as well as assembler directives; for example, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp
    main</samp> jumps to whatever address the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    symbol refers to.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 *.s* 文件可能包含其他一些行，但你现在可以安全地忽略它们。 [清单 1-2](chapter1.xhtml#list1-2) 中的四行是一个完整的汇编程序。汇编程序包含几种类型的语句。第一行，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp>，是一个*汇编指令*，它为汇编器提供指示。汇编指令总是以句点开头。在这里，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp>是一个*符号*，它表示一个内存地址。符号出现在汇编指令和汇编指令中；例如，指令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jmp main</samp>会跳转到<code>main</code>符号所指向的地址。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp> directive
    tells the assembler that <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    is a *global* symbol. By default, you can use a symbol only in the same assembly
    file (and therefore the same object file) where it’s defined. But because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp> is global, other object files
    can refer to it too. The assembler records this fact in a section of the object
    file called the *symbol table*, which the linker uses when it links object files
    together. The symbol table contains information about all the symbols in an object
    file or executable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp>指令告诉汇编器，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp>是一个*全局*符号。默认情况下，你只能在定义该符号的同一个汇编文件（因此也是同一个目标文件）中使用它。但由于<code>main</code>是全局的，其他目标文件也可以引用它。汇编器将在目标文件的*符号表*部分记录这一事实，链接器在链接目标文件时会使用符号表。符号表包含目标文件或可执行文件中所有符号的信息。
- en: On the second line, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    as a *label* for the code that follows it. Labels consist of a string or number
    followed by a colon. A label marks the location that a symbol refers to. This
    particular label defines <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    as the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction on the following line. The assembler doesn’t know this instruction’s
    final memory address, but it knows what *section* of the object file it’s in,
    as well as its offset from the start of that section. (An object file is made
    up of several sections that hold various kinds of data; there are separate sections
    for machine instructions, global variables, debug information, and so on. Different
    sections are loaded into different parts of the program’s address space at runtime.)
    The address of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> will
    be in the *text section*, which contains machine instructions. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    refers to the very first machine instruction in this assembly file, its offset
    within the text section is 0\. The assembler records this offset in the symbol
    table.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 作为后续代码的*标签*。标签由一个字符串或数字和一个冒号组成。标签标记了一个符号所指代的位置。这个特定的标签将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 定义为下一行 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    指令的地址。汇编器并不知道该指令的最终内存地址，但它知道该指令所在的*段*以及它在该段中的偏移量。（一个目标文件由多个段组成，包含不同类型的数据；例如，有用于机器指令、全局变量、调试信息等的独立段。不同的段在运行时加载到程序地址空间的不同部分。）<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 的地址将在*文本段*中，该段包含机器指令。因为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 指向该汇编文件中的第一条机器指令，所以它在文本段中的偏移量为0。汇编器会在符号表中记录这个偏移量。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction on
    the next line is a *machine instruction*, which appears in the final executable.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction in [Listing
    1-2](chapter1.xhtml#list1-2) moves the value <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    into a *register*, which is a very small and fast storage slot that has its own
    name and sits right on the CPU. Here, we move <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    into the register named EAX, which can hold 32 bits. According to our platform’s
    calling convention, return values are passed to the caller in EAX (or RAX, the
    64-bit equivalent, depending on the return value’s type). Since the caller also
    knows about this convention, it can retrieve the return value from EAX after the
    function returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> indicates that the
    operands to this instruction are *longwords*, or 32-bit integers (in x64 assembly,
    unlike most modern implementations of C, *long* means 32 bits). A <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp>
    instruction operates on *quadwords*, or 64-bit integers. I’ll just write <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> when I want to refer to this
    instruction without specifying its size.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行的 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> 指令是*机器指令*，它出现在最终的可执行文件中。[列表
    1-2](chapter1.xhtml#list1-2) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    指令将值 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> 移入一个*寄存器*，寄存器是一个非常小且快速的存储单元，它有自己的名字，并且位于
    CPU 上。这里，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> 移入名为 EAX 的寄存器，它可以容纳
    32 位。根据我们平台的调用约定，返回值通过 EAX（或 RAX，视返回值类型而定，64 位等价物）传递给调用者。由于调用者也知道这个约定，它可以在函数返回后从
    EAX 中获取返回值。<samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> 中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">l</samp> 后缀表示该指令的操作数是*长字*，即 32 位整数（在 x64
    汇编中，不同于大多数现代 C 实现，*long* 表示 32 位）。<samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp>
    指令操作的是*四字*，即 64 位整数。当我不指定指令大小时，我会直接写 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    来引用这条指令。
- en: Finally, we have another machine instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>,
    which returns control to the caller. You might see <samp class="SANS_TheSansMonoCd_W5Regular_11">retq</samp>
    here instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>, since
    this instruction implicitly operates on a 64-bit return address. I’m skipping
    a lot of details, including what calling conventions are, who decides on them,
    and how <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> knows where the
    caller is. I’ll revisit these when we add function calls in [Chapter 9](chapter9.xhtml).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有另一条机器指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>，它将控制权返回给调用者。你可能会看到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">retq</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>，因为该指令隐式地操作一个
    64 位的返回地址。我跳过了很多细节，包括调用约定是什么、谁决定这些约定以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    如何知道调用者的位置。等我们在[第 9 章](chapter9.xhtml)中讲解函数调用时，我会再回到这些问题。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*All the assembly listings in this book use AT&T syntax. Elsewhere, you might
    see x64 assembly written in Intel syntax. They’re two different notations for
    the same language; the biggest difference is that they put instruction operands
    in different orders.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书中所有的汇编列表都使用 AT&T 语法。在其他地方，你可能会看到用英特尔语法编写的 x64 汇编。它们是同一种语言的两种不同表示方式；最大的区别在于它们将指令操作数的顺序不同。*'
- en: 'At this point, it’s fair to ask who the caller is, since <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    is the only function in this program. You might also wonder why we need the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp> directive, since there
    don’t seem to be any other object files that could contain references to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. The answer is that the linker
    adds a bit of wrapper code called <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp>
    to handle setup before <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    runs and teardown after it exits. (The <samp class="SANS_TheSansMonoCd_W5Regular_11">crt</samp>
    stands for *C Runtime*.) This wrapper code does the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，公平地说，我们可以问一下调用者是谁，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    是该程序中唯一的函数。你也许会想知道，为什么我们需要 <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl
    main</samp> 指令，因为似乎没有其他目标文件可能包含对 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    的引用。答案是，链接器会添加一些称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp> 的包装代码，用于在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 执行前进行设置，并在其退出后进行清理。（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">crt</samp> 代表 *C 运行时*。）这个包装代码执行以下操作：
- en: Makes a function call to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    This is why <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> needs to
    be globally visible; if it isn’t, <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp>
    can’t call it.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数。这就是为什么 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 必须是全局可见的；如果不是，<samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp>
    就无法调用它。
- en: Retrieves the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 的返回值。
- en: Invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> system
    call, passing it the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> handles whatever
    work needs to happen inside the operating system to terminate the process and
    turn the return value into an exit code.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> 系统调用，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    的返回值传递给它。然后，<samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> 处理操作系统内部需要执行的任务，以终止进程并将返回值转化为退出码。
- en: The bottom line is that you don’t need to worry about process startup or teardown;
    you can treat <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> like a
    normal function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，你无需担心进程的启动或结束；你可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    当作一个普通的函数来处理。
- en: The linker also associates each entry in the symbol table with a memory address
    through a process called *symbol resolution*. It then performs *relocation*, updating
    every place that uses a symbol to use the corresponding address instead. (Actually,
    the linking process is a lot more complicated than this! If you’d like to learn
    more, see “Additional Resources” on [page 21](#pg_21).)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器还通过一个称为 *符号解析* 的过程，将符号表中的每个条目与一个内存地址关联起来。然后，它执行 *重定位*，将每个使用符号的地方更新为使用相应的地址。（实际上，链接过程比这要复杂得多！如果你想了解更多，参考[第
    21 页](#pg_21)的“附加资源”。）
- en: 'To verify that the assembly in *return_2.s* works, assemble and link it, run
    it, and check the exit code with the <samp class="SANS_TheSansMonoCd_W5Regular_11">$?</samp>
    shell operator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证*return_2.s*中的汇编代码是否有效，先汇编并链接它，然后运行，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">$?</samp>命令行操作符检查退出代码：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that you can pass an assembly file to the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>
    command just like a regular source file. It assumes any input files with a *.s*
    extension contain assembly, so it assembles and links those files without trying
    to compile them first.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以像普通源文件一样将汇编文件传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>命令。它假设所有扩展名为*.s*的输入文件都包含汇编代码，因此会直接汇编并链接这些文件，而不会先尝试编译它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Compiler Driver</samp>
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">编译器驱动程序</samp>
- en: 'As you learned in the [Introduction](introduction.xhtml), a compiler isn’t
    very useful on its own. You also need a *compiler driver* that calls the preprocessor,
    compiler, assembler, and linker. So, you’ll write a compiler driver before starting
    on the compiler itself. It should convert a source file to an executable in three
    steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[介绍](introduction.xhtml)中学到的，编译器单独并不十分有用。你还需要一个*编译器驱动程序*，它调用预处理器、编译器、汇编器和链接器。因此，你需要在开始编写编译器之前先编写一个编译器驱动程序。它应该通过三步将源文件转换为可执行文件：
- en: '1. Run this command to preprocess the source file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 运行此命令以预处理源文件：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command preprocesses <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">INPUT_FILE</samp>
    and then writes the result to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PREPROCESSED_FILE</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-E</samp> option tells GCC to
    run only the preprocessor, not the later steps of the compilation process. By
    default, the preprocessor emits *linemarkers* indicating the original source file,
    and the starting line number within that source file, for each part of the preprocessed
    output. (A preprocessed file might include code from multiple source files because
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directives.)
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-P</samp> option tells the preprocessor
    not to emit linemarkers; our lexer and parser won’t be able to process them. By
    convention, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PREPROCESSED_FILE</samp>
    should have a *.i* file extension.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令首先对<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">INPUT_FILE</samp>进行预处理，然后将结果写入<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PREPROCESSED_FILE</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-E</samp>选项告诉GCC仅运行预处理器，而不执行编译过程的后续步骤。默认情况下，预处理器会生成*行标记*，指示原始源文件及该文件中每部分的起始行号。（由于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>指令，预处理文件可能包含来自多个源文件的代码。）<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-P</samp>选项告诉预处理器不生成行标记；我们的词法分析器和解析器将无法处理它们。按照惯例，<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PREPROCESSED_FILE</samp>文件应具有*.i*扩展名。
- en: 2. Compile the preprocessed source file and output an assembly file with a *.s*
    extension. You’ll have to stub out this step, since you haven’t written your compiler
    yet. Delete the preprocessed file when you’re done with it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 编译预处理后的源文件，并生成一个扩展名为*.s*的汇编文件。你需要跳过这一步，因为你还没有编写编译器。完成后删除预处理文件。
- en: '3. Assemble and link the assembly file to produce an executable, using this
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 汇编并链接汇编文件，生成可执行文件，使用以下命令：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Delete the assembly file when you’re done with it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后删除汇编文件。
- en: 'Your compiler driver must have a specific command line interface so this book’s
    test script, *test_compiler*, can run it. It must be a command line program that
    accepts a path to a C source file as its only argument. If this command succeeds,
    it must produce an executable in the same directory as the input file, with the
    same name (minus the file extension). In other words, if you run <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER /path/to/program.c</samp>,
    it should produce an executable at */path/to/program* and terminate with an exit
    code of 0\. If your compiler fails, the compiler driver should return a nonzero
    exit code and shouldn’t write any assembly or executable files; that’s how *test_compiler*
    verifies that your compiler catches errors in invalid programs. Finally, your
    compiler driver should support the following options, which *test_compiler* uses
    to test intermediate stages:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编译器驱动程序必须具有特定的命令行接口，以便本书的测试脚本*test_compiler*能够运行它。它必须是一个命令行程序，接受一个指向C源文件的路径作为唯一参数。如果该命令成功，它必须在与输入文件相同的目录中生成一个可执行文件，并且文件名相同（去掉文件扩展名）。换句话说，如果你运行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER
    /path/to/program.c</samp>，它应该在*/path/to/program*生成一个可执行文件，并以退出码0终止。如果编译器失败，编译器驱动程序应该返回一个非零退出码，并且不应该生成任何汇编或可执行文件；这就是*test_compiler*验证编译器捕捉到无效程序错误的方法。最后，编译器驱动程序应支持以下选项，这些选项是*test_compiler*用于测试中间阶段的：
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--lex</samp> | Directs it to
    run the lexer, but stop before parsing |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--lex</samp> | 指示它运行词法分析器，但在解析之前停止
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--parse</samp> | Directs it
    to run the lexer and parser, but stop before assembly generation |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--parse</samp> | 指示它运行词法分析器和解析器，但在汇编生成之前停止
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--codegen</samp> | Directs it
    to perform lexing, parsing, and assembly generation, but stop before code emission
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--codegen</samp> | 指示它执行词法分析、解析和汇编生成，但在代码生成之前停止
    |'
- en: None of these options should produce any output files, and all should terminate
    with an exit code of 0 if they don’t hit any errors. You might also want to add
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">-S</samp> option that directs
    your compiler to emit an assembly file, but not assemble or link it. You’ll need
    this option to run the tests in [Part III](part3.xhtml); it isn’t required for
    [Parts I](part1.xhtml) and [II](part2.xhtml), but it’s useful for debugging.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项都不应生成任何输出文件，如果没有遇到错误，所有选项都应以退出码0终止。你可能还想添加一个<samp class="SANS_TheSansMonoCd_W5Regular_11">-S</samp>选项，它指示你的编译器生成汇编文件，但不进行汇编或链接。你需要这个选项来运行[第三部分](part3.xhtml)中的测试；它对于[第一部分](part1.xhtml)和[第二部分](part2.xhtml)不是必须的，但它对调试非常有用。
- en: 'Once you’ve written the compiler driver, you’re ready to start working on the
    actual compiler. You need to implement the four compiler passes listed at the
    beginning of the chapter: the lexer, which produces a list of tokens; the parser,
    which turns those tokens into an abstract syntax tree; the assembly generation
    pass, which converts the abstract syntax tree into assembly; and the code emission
    pass, which writes that assembly to a file. Let’s start with the lexer.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写了编译器驱动程序，就可以开始着手编写实际的编译器了。你需要实现本章开头列出的四个编译器阶段：词法分析器，它生成标记列表；解析器，它将这些标记转换成抽象语法树；汇编生成阶段，它将抽象语法树转换为汇编代码；以及代码生成阶段，它将汇编代码写入文件。让我们从词法分析器开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'The lexer should read in a source file and produce a list of tokens. Before
    you can start writing the lexer, you need to know what tokens you might encounter.
    Here are all the tokens in [Listing 1-1](chapter1.xhtml#list1-1):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析器应读取源文件并生成一个标记列表。在开始编写词法分析器之前，你需要了解可能会遇到的所有标记。以下是[清单 1-1](chapter1.xhtml#list1-1)中的所有标记：
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp> | A keyword |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp> | 一个关键字 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">main</samp> | An identifier,
    whose value is “main” |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">main</samp> | 一个标识符，其值为“main”
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(</samp> | An open parenthesis
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(</samp> | 一个左括号 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">void</samp> | A keyword |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">void</samp> | 一个关键字 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">)</samp> | A close parenthesis
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">)</samp> | 一个右圆括号 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">{</samp> | An open brace |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">{</samp> | 一个左大括号 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">return</samp> | A keyword |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">return</samp> | 一个关键字 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">2</samp> | A constant, whose
    value is “2” |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">2</samp> | 一个常量，其值为“2” |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">;</samp> | A semicolon |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">;</samp> | 一个分号 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">}</samp> | A close brace |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">}</samp> | 一个右大括号 |'
- en: I’ve used two lexer-specific terms here. An *identifier* is an ASCII letter
    or underscore followed by a mix of letters, underscores, and digits. Identifiers
    are case sensitive. An integer *constant* consists of one or more digits. (We’ll
    add character and floating-point constants in [Part II](part2.xhtml). We won’t
    implement hexadecimal or octal integer constants in this book.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了两个与词法分析器相关的术语。*标识符*是一个字母或下划线，后面跟着字母、下划线和数字的混合。标识符区分大小写。整数*常量*由一个或多个数字组成。（我们将在[第二部分](part2.xhtml)中添加字符常量和浮点常量。本书中不会实现十六进制或八进制整数常量。）
- en: Note that the identifier and constant in this list of tokens have values, but
    the other types of tokens don’t. There are many possible identifiers (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">variable1</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">my_cool_function</samp>), so
    each identifier token produced by the lexer must retain its specific name. Likewise,
    each constant token needs to hold an integer value. By contrast, there’s only
    one possible <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword,
    so a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword token
    doesn’t need to store any extra information. Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    is the only identifier right now, you should build the lexer to support arbitrary
    identifiers later on. Also note that there are no whitespace tokens. If we were
    compiling a language like Python, where whitespace is significant, we’d need to
    include whitespace tokens.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标识符和常量在此标记列表中有值，但其他类型的标记没有。标识符有许多可能的值（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">variable1</samp>，以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">my_cool_function</samp>），因此词法分析器生成的每个标识符标记必须保留其特定的名称。同样，每个常量标记需要保留一个整数值。相比之下，只有一个可能的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 关键字，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    关键字标记不需要存储任何额外的信息。尽管现在只有一个标识符 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>，你应该构建词法分析器以便以后支持任意标识符。还要注意，这里没有空白标记。如果我们正在编译像
    Python 这样的语言，其中空白符很重要，我们就需要包括空白符标记。
- en: You can recognize each token type with a regular expression, or regex. [Table
    1-1](chapter1.xhtml#tab1-1) gives the corresponding regular expression for each
    token in Perl Compatible Regular Expressions (PCRE) syntax.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过正则表达式（regex）识别每种标记类型。[表1-1](chapter1.xhtml#tab1-1)给出了每个标记在 Perl 兼容正则表达式（PCRE）语法中的对应正则表达式。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp> <samp class="SANS_Futura_Std_Book_11">Tokens
    and Their Regular Expressions</samp>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表1-1：</samp> <samp class="SANS_Futura_Std_Book_11">标记及其正则表达式</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Token</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Regular
    expression</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">标记</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">正则表达式</samp>
    |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Identifier</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">[a-zA-Z_]\w*\b</samp>
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">标识符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">[a-zA-Z_]\w*\b</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Constant</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+\b</samp>
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">常量</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+\b</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">keyword</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int\b</samp> |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">关键字</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int\b</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">keyword</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">void\b</samp> |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">关键字</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">void\b</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> <samp class="SANS_Futura_Std_Book_11">keyword</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">return\b</samp> |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> <samp class="SANS_Futura_Std_Book_11">关键字</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">return\b</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Open parenthesis</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\(</samp>
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">左括号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\()</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Close parenthesis</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\)</samp>
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">右括号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\)</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Open brace</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">左花括号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Close brace</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">右花括号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Semicolon</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">分号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>
    |'
- en: The process of tokenizing a program looks roughly like [Listing 1-3](chapter1.xhtml#list1-3).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 程序标记化的过程大致如下图所示：[Listing 1-3](chapter1.xhtml#list1-3)。
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-3: Converting a string
    to a sequence of tokens</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-3: 将字符串转换为标记序列</samp>'
- en: Note that identifiers, keywords, and constants must end at word boundaries,
    indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>. For example,
    the first three digits of <samp class="SANS_TheSansMonoCd_W5Regular_11">123;bar</samp>
    match the regular expression for a constant, and you should convert them into
    the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">123</samp>. This is
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> isn’t in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">\w</samp> character class, so the boundary
    between <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>
    is a word boundary. However, the first three digits of <samp class="SANS_TheSansMonoCd_W5Regular_11">123bar</samp>
    don’t match the regular expression for a constant, because those digits are followed
    by more characters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">\w</samp>
    character class instead of a word boundary. If your lexer sees a string like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">123bar</samp>, it should raise an error,
    as the start of the string doesn’t match the regular expression for any token.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标识符、关键字和常量必须在单词边界处结束，单词边界由 <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>
    表示。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">123;bar</samp> 的前三个数字匹配常量的正则表达式，你应该将它们转换为常量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">123</samp>。这是因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>
    不在 <samp class="SANS_TheSansMonoCd_W5Regular_11">\w</samp> 字符类中，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> 之间的边界是单词边界。然而，<samp class="SANS_TheSansMonoCd_W5Regular_11">123bar</samp>
    的前三个数字并不匹配常量的正则表达式，因为这些数字后面跟着的是属于 <samp class="SANS_TheSansMonoCd_W5Regular_11">\w</samp>
    字符类的字符，而不是单词边界。如果你的词法分析器看到像 <samp class="SANS_TheSansMonoCd_W5Regular_11">123bar</samp>
    这样的字符串，它应该抛出错误，因为该字符串的开头不匹配任何标记的正则表达式。
- en: 'Now you’re ready to write your lexer. Here are a few tips to keep in mind:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好编写词法分析器了。以下是一些要牢记的提示：
- en: '**Treat keywords like other identifiers.**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**像其他标识符一样对待关键字。**'
- en: The regex for identifiers also matches keywords. Don’t try to simultaneously
    find the end of the next token and figure out whether it’s a keyword. First, find
    the end of the token. Then, if it looks like an identifier, check whether it matches
    any keywords.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符的正则表达式也匹配关键字。不要试图同时找到下一个标记的结尾并判断它是否是关键字。首先，找到标记的结尾。然后，如果它看起来像是标识符，再检查它是否匹配任何关键字。
- en: '**Don’t split on whitespace.**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要在空白字符处分割。**'
- en: It isn’t a good idea to start by splitting the string on whitespace, since whitespace
    isn’t the only boundary between tokens. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">main(void)</samp>
    has four tokens and no whitespace.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议通过按空白字符拆分字符串来开始，因为空白字符并不是标记之间的唯一边界。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">main(void)</samp>包含四个标记，但没有空白字符。
- en: '**You only need to support ASCII characters.**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**你只需要支持ASCII字符。**'
- en: The test programs for this book contain only ASCII characters. The C standard
    provides a mechanism called *universal character names* to include non-ASCII characters
    in identifiers, but we won’t implement them. Many C implementations let you use
    Unicode characters directly, but you don’t need to support that either.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的测试程序只包含ASCII字符。C标准提供了一种叫做*通用字符名称*的机制，用于在标识符中包含非ASCII字符，但我们不会实现它们。许多C语言实现允许直接使用Unicode字符，但你也不需要支持这一点。
- en: Once you’ve written your lexer, the next step is testing it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你写完了词法分析器，下一步就是测试它。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: 'Now that you have a list of tokens, you’ll figure out how those tokens are
    grouped together into language constructs. In most programming languages, including
    C, this grouping is hierarchical: each language construct in the program is composed
    of several simpler constructs. Individual tokens represent the most basic constructs,
    like variables, constants, and arithmetic operators. Tree data structures are
    a natural way to express this hierarchical relationship. As I mentioned at the
    start of this chapter, the parser will accept the list of tokens produced by the
    lexer and generate a tree representation called an abstract syntax tree. After
    the parser has created the AST, the assembly generation stage will traverse it
    to figure out what assembly code to emit.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了标记列表，你将需要弄清楚这些标记如何组合成语言构造。在大多数编程语言中，包括C语言，这种组合是分层的：程序中的每个语言构造由多个更简单的构造组成。单独的标记表示最基本的构造，如变量、常量和算术运算符。树形数据结构是表示这种层次关系的自然方式。正如我在本章开头所提到的，解析器会接受由词法分析器生成的标记列表，并生成一个称为抽象语法树（AST）的树形表示。解析器创建了AST之后，汇编生成阶段会遍历它，确定应该生成什么样的汇编代码。
- en: 'There are two approaches to writing a parser: you can write it by hand, or
    you can use a *parser generator* like Bison or ANTLR to produce your parsing code
    automatically. Using a parser generator is less work, but this book uses a handwritten
    parser. There are a few reasons for this. Most importantly, handwriting a parser
    provides you with a solid understanding of how your parser works. It’s easy to
    use a parser generator without fully understanding the code it produces. Many
    parser generators also have a steep learning curve, and you’re better off learning
    general techniques like recursive descent parsing *before* you spend time mastering
    specific tools.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编写解析器有两种方法：你可以手写，或者使用像Bison或ANTLR这样的*解析器生成器*来自动生成你的解析代码。使用解析器生成器工作量较小，但本书使用的是手写解析器。这样做有几个原因。最重要的是，手写解析器可以让你深入理解解析器的工作原理。使用解析器生成器很容易，但可能无法完全理解它所生成的代码。许多解析器生成器的学习曲线也很陡峭，因此你最好在花时间掌握具体工具之前，先学习一些通用的技术，如递归下降解析。
- en: 'Handwritten parsers also have some practical advantages over those produced
    by parser generators: they can be faster and easier to debug, they’re more flexible,
    and they provide better support for error handling. In fact, both GCC and Clang
    use handwritten parsers, which shows that writing a parser by hand isn’t just
    an academic exercise.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 手写解析器相对于解析器生成器生成的解析器也有一些实际优势：它们可能更快，更容易调试，灵活性更高，并且对错误处理的支持更好。事实上，GCC和Clang都使用手写解析器，这表明手写解析器并非仅仅是一个学术练习。
- en: That said, if you’d rather use a parser generator, that’s fine too. It all depends
    on what you’re hoping to get out of this book. Note, however, that I won’t talk
    about how to use those tools, so you’ll have to figure that out on your own. If
    you go that route, make sure to research what parsing libraries are available
    in your implementation language of choice.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果你更愿意使用解析器生成器，那也没问题。这完全取决于你希望从本书中获得什么。不过请注意，我不会讨论如何使用这些工具，所以你需要自己弄清楚。如果你选择这条路线，请确保研究你选择的实现语言中可用的解析库。
- en: Whichever option you choose, you’ll need to design the abstract syntax tree
    your parser should produce. Let’s start by taking a look at an example of an AST.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪个选项，你都需要设计你的解析器应该生成的抽象语法树。让我们从查看一个抽象语法树的示例开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example Abstract
    Syntax Tree</samp>
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例抽象语法树</samp>
- en: Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    in [Listing 1-4](chapter1.xhtml#list1-4).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑[列表 1-4](chapter1.xhtml#list1-4)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句。
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-4: A simple</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 1-4：一个简单的</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: 'The root node of the corresponding AST represents the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. This node has two children:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 相应抽象语法树的根节点表示整个<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句。这个节点有两个子节点：
- en: The condition, <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件，<samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>
- en: The statement body, <samp class="SANS_TheSansMonoCd_W5Regular_11">return 2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2;</samp>
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语句体，<samp class="SANS_TheSansMonoCd_W5Regular_11">return 2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2;</samp>
- en: 'Each of these constructs can be broken down further. For example, the condition
    is a binary operation with three children:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构中的每一个都可以进一步拆解。例如，条件是一个具有三个子节点的二元操作：
- en: The left operand, variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左操作数，变量<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
- en: The operator, <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运算符，<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
- en: The right operand, variable <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右操作数，变量<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
- en: '[Figure 1-1](#fig1-1) shows the whole AST for this code snippet, with an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">If</samp> AST node representing the root
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> node representing the condition,
    and so on.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](#fig1-1) 显示了这段代码的完整抽象语法树，其中一个<samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp>节点代表<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句的根节点，一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>节点代表条件，等等。'
- en: '![](../images/fig1-1.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: An AST for a simple
    if statement [Description](description-03.xhtml)</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-1：一个简单if语句的抽象语法树 [描述](description-03.xhtml)</samp>
- en: 'The AST in [Figure 1-1](#fig1-1) contains the same information as [Listing
    1-4](chapter1.xhtml#list1-4): it shows what actions the program will take, and
    in what order. But unlike [Listing 1-4](chapter1.xhtml#list1-4), this AST presents
    that information in a way your compiler can easily work with. In later stages,
    the compiler will traverse the tree, performing a different action at each type
    of node it encounters. Your compiler will use this general strategy to accomplish
    a bunch of different tasks, from resolving variable names to generating assembly.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](#fig1-1) 中的抽象语法树包含与[列表 1-4](chapter1.xhtml#list1-4)相同的信息：它展示了程序将执行的操作及其顺序。但与[列表
    1-4](chapter1.xhtml#list1-4)不同，这棵抽象语法树以一种编译器可以轻松处理的方式呈现这些信息。在后续阶段，编译器将遍历这棵树，在遇到每种节点类型时执行不同的操作。你的编译器将使用这种通用策略来完成一系列不同的任务，从解析变量名到生成汇编代码。'
- en: Now let’s look at the AST for the C program from [Listing 1-1](chapter1.xhtml#list1-1).
    [Figure 1-2](#fig1-2) shows this much simpler AST.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看[列表 1-1](chapter1.xhtml#list1-1)中的C程序的抽象语法树。[图 1-2](#fig1-2) 显示了这个更简单的抽象语法树。
- en: '![](../images/fig1-2.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: The AST for [Listing
    1-1](chapter1.xhtml#list1-1) [Description](description-04.xhtml)</samp>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-2： [列表 1-1](chapter1.xhtml#list1-1)的抽象语法树
    [描述](description-04.xhtml)</samp>
- en: Next, you’ll define the necessary data structures to construct ASTs like [Figure
    1-2](#fig1-2) in code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将定义必要的数据结构，以便在代码中构建像[图 1-2](#fig1-2)这样的抽象语法树。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The AST Definition</samp>
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">抽象语法树定义</samp>
- en: This book gives AST descriptions in a language designed for specifying ASTs,
    the *Zephyr Abstract Syntax Description Language (ASDL)*. I’m using ASDL here
    as convenient, programming language–neutral notation. You won’t use ASDL directly
    in your compiler; instead, you’ll define equivalent data structures in your chosen
    implementation language. The next few paragraphs include a very brief overview
    of ASDL. You can find a link to the original paper, which describes the whole
    language, in “Additional Resources” on [page 21](#pg_21).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供了用一种专门用于描述 AST 的语言——*Zephyr 抽象语法描述语言（ASDL）*——的 AST 描述。我在这里使用 ASDL 作为一种方便的、与编程语言无关的符号表示。你不会直接在编译器中使用
    ASDL；而是会在你选择的实现语言中定义等效的数据结构。接下来的几段简要概述了 ASDL。你可以在[第 21 页](#pg_21)的“附加资源”中找到描述整个语言的原始论文链接。
- en: '[Listing 1-5](chapter1.xhtml#list1-5) has the ASDL definition for the tiny
    subset of C you’ll implement in this chapter (programs like [Listing 1-1](chapter1.xhtml#list1-1)).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-5](chapter1.xhtml#list1-5)包含了你将在本章实现的 C 语言子集的 ASDL 定义（类似于[列表 1-1](chapter1.xhtml#list1-1)的程序）。'
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-5: The abstract syntax
    tree definition for this chapter</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 1-5：本章的抽象语法树定义</samp>
- en: 'Each line in [Listing 1-5](chapter1.xhtml#list1-5) describes how to build one
    type of AST node. Note that every AST node in [Figure 1-2](#fig1-2) has a corresponding
    definition in ASDL. The root of this AST is the <samp class="SANS_TheSansMonoCd_W5Regular_11">program</samp>
    node. At the moment, this node can have exactly one child, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>.
    A function definition has two children: a function name, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp>,
    and a function body, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>.
    Right now, a function consists of a single statement and has no arguments. Later,
    you’ll add support for function arguments and more complex function bodies. Note
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp>
    in this definition are *field names*, human-friendly labels that don’t change
    the structure of the AST. Field names are optional in ASDL. When a field name
    is present, it comes immediately after the field type, like in <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier
    name</samp>.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-5](chapter1.xhtml#list1-5)中的每一行描述了如何构建一种 AST 节点类型。请注意，[图 1-2](#fig1-2)中的每个
    AST 节点都有对应的 ASDL 定义。这个 AST 的根节点是 <samp class="SANS_TheSansMonoCd_W5Regular_11">program</samp>
    节点。目前，这个节点只能有一个子节点，类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>。一个函数定义有两个子节点：一个函数名，类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp>，以及一个函数体，类型为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>。现在，函数仅由一个语句组成，并且没有参数。稍后，你将添加对函数参数和更复杂函数体的支持。请注意，在这个定义中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp>
    是*字段名*，它们是对人类友好的标签，不会改变 AST 的结构。字段名在 ASDL 中是可选的。当字段名存在时，它紧跟在字段类型之后，类似于 <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier
    name</samp>。'
- en: 'In ASDL, <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp> is
    a built-in type that represents function and variable names; they’re basically
    strings, but we want to distinguish them from string literals like <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello,
    World!"</samp> because they appear in different parts of an AST. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp>
    is a built-in type, it has no children. The other child of the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>
    node is <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>. Right
    now, the only kind of statement is a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. This statement has one child: its return value, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>,
    short for *expression*. The only <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    at the moment is a constant integer; <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is another built-in ASDL type, so the AST is finished.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASDL 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp> 是一个内置类型，用来表示函数和变量名；它们本质上是字符串，但我们希望将它们与像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello, World!"</samp> 这样的字符串字面量区分开，因为它们出现在抽象语法树（AST）的不同部分。由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp> 是一个内置类型，它没有子节点。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp> 节点的另一个子节点是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>。目前，唯一的语句类型是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句。这个语句有一个子节点：它的返回值，类型是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>，即 *表达式* 的缩写。当前唯一的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> 是常量整数；<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    是另一个内置 ASDL 类型，因此 AST 已经完成。
- en: 'Of course, <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements
    aren’t the only statements in C, and constants aren’t the only expressions. In
    later chapters, we’ll add new constructors to represent the other kinds of statements
    and expressions. For example, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp>
    constructor to <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，<samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句并不是 C 语言中的唯一语句，常量也不是唯一的表达式。在后续章节中，我们将添加新的构造函数来表示其他类型的语句和表达式。例如，我们将为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp> 添加一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp>
    构造函数，用来表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">statement?</samp> type indicates
    an optional statement, since <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements don’t always have an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    clause. The <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> symbol separates
    constructors. Here, it tells us that a <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    can be either a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement,
    defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> constructor,
    or an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, defined
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp> constructor.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">statement?</samp> 类型表示一个可选语句，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句并不总是有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    子句。<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> 符号用来分隔构造函数。在这里，它告诉我们一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp> 可以是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    语句，由 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 构造函数定义，或者是一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句，由 <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp>
    构造函数定义。
- en: Now it’s your turn to implement the AST definition in [Listing 1-5](chapter1.xhtml#list1-5)
    in whatever language you’re using to write your compiler. The standard way to
    represent ASTs varies between programming languages. If you’re implementing your
    compiler in a functional language like F#, ML, or Haskell, you can define the
    AST using algebraic data types. Enums in Rust are basically algebraic data types,
    so they can also represent ASTs. If you’re using an object-oriented language like
    Java, you can define an abstract class for each type of node, then define classes
    that extend or inherit from those abstract classes for each constructor. For example,
    you might define an <samp class="SANS_TheSansMonoCd_W5Regular_11">Exp</samp> abstract
    class and <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">BinaryExp</samp> classes that extend it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到你实现[列表 1-5](chapter1.xhtml#list1-5)中的AST定义，使用你写编译器时所用的任何语言。表示AST的标准方式在不同的编程语言之间有所不同。如果你在像F#、ML或Haskell这样的函数式语言中实现编译器，可以使用代数数据类型来定义AST。Rust中的枚举本质上是代数数据类型，因此它们也可以表示AST。如果你使用的是像Java这样的面向对象语言，可以为每种节点类型定义一个抽象类，然后为每个构造器定义继承自这些抽象类的类。例如，你可以定义一个`Exp`抽象类，以及继承自它的`Constant`和`BinaryExp`类。
- en: If you’re still not sure how to write an AST definition, check out “Additional
    Resources” on [page 21](#pg_21).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不确定如何编写AST定义，请查看[第21页](#pg_21)中的“附加资源”。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Formal Grammar</samp>
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">正式语法</samp>
- en: An AST has all the information you’ll need in later stages of the compiler.
    It does not, however, tell you exactly what tokens make up each language construct.
    For example, nothing in the AST description in [Listing 1-5](chapter1.xhtml#list1-5)
    says that a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement
    must end with a semicolon or that a function body needs to be enclosed in braces.
    (This is why it’s called an *abstract* syntax tree—by contrast, a *concrete* syntax
    tree includes every token from the original input.) Once you have an AST, those
    specific details are irrelevant, so it’s convenient to leave them out. When you’re
    parsing a sequence of tokens to construct your AST, though, those details matter
    a lot because they indicate where each language construct begins and ends.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: AST包含了编译器后续阶段所需的所有信息。然而，它并没有告诉你每个语言结构是由哪些令牌构成的。例如，[列表 1-5](chapter1.xhtml#list1-5)中的AST描述并没有说明`return`语句必须以分号结尾，或者函数体需要用大括号括起来。（这就是为什么它被称为*抽象*语法树——相比之下，*具体*语法树包括了原始输入中的每个令牌。）一旦你拥有了AST，这些具体的细节就变得不重要，因此可以方便地省略它们。然而，当你在解析一系列令牌以构建AST时，这些细节非常重要，因为它们指示了每个语言结构的开始和结束。
- en: So, in addition to an AST description, you need a set of rules defining how
    to build a language construct from a list of tokens. This ruleset is called a
    *formal grammar*, and it corresponds closely to the AST description. [Listing
    1-6](chapter1.xhtml#list1-6) defines the formal grammar for C programs like [Listing
    1-1](chapter1.xhtml#list1-1).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了抽象语法树（AST）描述之外，你还需要一组规则来定义如何从令牌列表构建语言结构。这组规则称为*正式语法*，它与AST描述紧密相关。[列表 1-6](chapter1.xhtml#list1-6)定义了C程序的正式语法，类似于[列表
    1-1](chapter1.xhtml#list1-1)。
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-6: The formal grammar
    for this chapter</samp>'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 1-6：本章的正式语法</samp>
- en: 'The grammar in [Listing 1-6](chapter1.xhtml#list1-6) is in *extended Backus-Naur
    form (EBNF)* notation. Each line of this grammar is a *production rule* that defines
    how a language construct can be formed from a sequence of other language constructs
    and tokens. Every symbol that appears on the left-hand side of a production rule
    (like <samp class="SANS_TheSansMonoCd_W5Regular_11"><function></samp>) is a *non-terminal
    symbol*. Individual tokens, like keywords, identifiers, and punctuation, are *terminal
    symbols*. All non-terminal symbols are wrapped in angle brackets, and specific
    tokens (like <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>) are wrapped
    in quotation marks. The <samp class="SANS_TheSansMonoCd_W5Regular_11"><identifier></samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11"><int></samp> symbols represent
    individual identifier and constant tokens, respectively. Since these tokens aren’t
    fixed strings like the other terminal symbols, we describe each of them using
    a *special sequence*: a plain English description of the symbol, wrapped in question
    marks.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-6](chapter1.xhtml#list1-6) 中的语法是 *扩展巴科斯范式（EBNF）* 表示法。该语法的每一行都是一个 *产生式规则*，定义了如何通过其他语言构造和符号的序列来形成一个语言构造。每个出现在产生式规则左侧的符号（如
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><function></samp>）都是 *非终结符号*。单独的符号，如关键字、标识符和标点符号，是
    *终结符号*。所有非终结符号都用尖括号括起来，而特定的符号（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>）用引号括起来。<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><identifier></samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11"><int></samp>
    符号分别表示单个标识符和常量符号。由于这些符号不像其他终结符号那样是固定的字符串，我们使用 *特殊序列* 来描述它们：即用问号括起来的符号的简明英文描述。'
- en: '[Listing 1-6](chapter1.xhtml#list1-6) looks a lot like the AST definition in
    [Listing 1-5](chapter1.xhtml#list1-5). In fact, it has the same structure; every
    AST node in [Listing 1-5](chapter1.xhtml#list1-5) corresponds to a non-terminal
    symbol in [Listing 1-6](chapter1.xhtml#list1-6). The only difference is that [Listing
    1-6](chapter1.xhtml#list1-6) specifies exactly which tokens we’ll find at each
    node of the tree, which helps us figure out when we need to start processing a
    new node at the next level down in the AST, and when we’ve finished processing
    a node and can go back up to its parent on the level above.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-6](chapter1.xhtml#list1-6) 看起来与 [清单 1-5](chapter1.xhtml#list1-5) 中的 AST
    定义非常相似。事实上，它们具有相同的结构；[清单 1-5](chapter1.xhtml#list1-5) 中的每个 AST 节点都对应于 [清单 1-6](chapter1.xhtml#list1-6)
    中的一个非终结符号。唯一的区别是，[清单 1-6](chapter1.xhtml#list1-6) 明确指定了我们将在树的每个节点找到哪些符号，这有助于我们判断何时开始处理
    AST 中下一级的节点，以及何时完成对一个节点的处理并返回到其上层父节点。'
- en: 'Just as later chapters will introduce multiple constructors for some AST nodes,
    they’ll also introduce multiple production rules for the corresponding symbols.
    For example, here’s how you’ll add a production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>
    to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像后续章节会为一些 AST 节点引入多个构造器一样，它们也会为相应的符号引入多个产生式规则。例如，下面是如何为 <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>
    添加产生式规则，以支持 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that square brackets in EBNF indicate that something is optional, just
    like question marks in ASDL.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，EBNF 中的方括号表示某些内容是可选的，类似于 ASDL 中的问号。
- en: You’ll refer to this formal grammar while writing the parser, but you won’t
    explicitly define these grammar rules anywhere in your compiler.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写解析器时，你会参考这个正式的语法，但你不会在编译器中显式地定义这些语法规则。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Recursive Descent
    Parsing</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">递归下降解析</samp>
- en: Now that you have an AST definition and a formal grammar, let’s talk about how
    to actually write the parser. We’ll use a straightforward technique called *recursive
    descent parsing*, which uses a different function to parse each non-terminal symbol
    and return the corresponding AST node. For example, when the parser expects to
    encounter the <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>
    symbol defined in [Listing 1-6](chapter1.xhtml#list1-6), it calls a function to
    parse that symbol and return the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST node from [Listing 1-5](chapter1.xhtml#list1-5). The main parsing function
    parses the <samp class="SANS_TheSansMonoCd_W5Regular_11"><program></samp> symbol,
    which corresponds to the entire program. With each function call to handle a new
    symbol, the parser descends to a lower level in the tree. That’s where the *descent*
    in recursive descent comes from. (It’s called *recursive* descent because the
    grammar rules are often recursive, in which case the functions to process them
    are too. For example, the operand of an expression could be another expression;
    we’ll see an example of this in the next chapter.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了AST定义和正式文法，我们来谈谈如何实际编写解析器。我们将使用一种直接的技术，叫做*递归下降解析*，它使用不同的函数解析每个非终结符号，并返回相应的AST节点。例如，当解析器期望遇到[清单
    1-6](chapter1.xhtml#list1-6)中定义的<code><statement></code>符号时，它会调用一个函数来解析该符号，并从[清单
    1-5](chapter1.xhtml#list1-5)中返回<code>statement</code> AST节点。主要的解析函数解析<code><program></code>符号，代表整个程序。每次调用一个函数处理一个新符号时，解析器会下降到树的更低层级。这就是递归下降中的*下降*部分。（它被称为*递归*下降是因为文法规则通常是递归的，在这种情况下，处理这些规则的函数也是递归的。例如，一个表达式的操作数可能是另一个表达式；我们将在下一章看到这个例子。）
- en: Let’s walk through one of these parsing functions. The pseudocode in [Listing
    1-7](chapter1.xhtml#list1-7) demonstrates how to parse a <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>
    symbol.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐步解析其中一个解析函数。[清单 1-7](chapter1.xhtml#list1-7)中的伪代码展示了如何解析一个<code><statement></code>符号。
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-7: Parsing a statement</samp>'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-7：解析语句</samp>
- en: 'We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp>
    function when we expect the list of remaining tokens to start with a <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>.
    According to [Listing 1-6](chapter1.xhtml#list1-6), a <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>
    consists of three symbols: the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    keyword, an <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp> symbol,
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> token. First, we
    call a helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>,
    to verify that the first token really is a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    keyword. If it is, <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>
    discards it so we can move on to the next token. If it isn’t, we report a syntax
    error in the program. Next, we need to turn the <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    symbol into an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node.
    Since this is a different non-terminal symbol, it should be handled by a separate
    function, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>, which
    I haven’t defined here. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    to get the AST node representing the return value; then we call <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>
    again to verify that this expression is followed by the last token, a semicolon.
    Finally, we construct the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    AST node and return it.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们期望剩余的令牌列表以一个<samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>开始时，我们调用<sam
    class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp>函数。根据[清单1-6](chapter1.xhtml#list1-6)，一个<sam
    class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>由三个符号组成：<samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>关键字、一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>符号和一个<samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>令牌。首先，我们调用一个辅助函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>，以验证第一个令牌确实是<sam class="SANS_TheSansMonoCd_W5Regular_11">return</samp>关键字。如果是的话，<sam
    class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>会将其丢弃，这样我们就可以继续处理下一个令牌。如果不是的话，我们将报告程序的语法错误。接下来，我们需要将<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>符号转化为一个<sam class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST节点。由于这是一个不同的非终结符号，它应该由一个单独的函数<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>来处理，而我在这里并没有定义它。我们调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>来获取表示返回值的AST节点，然后再次调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>来验证这个表达式后面跟随的是最后一个令牌，一个分号。最后，我们构造<sam
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> AST节点并返回它。
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp>
    removes all the tokens that made up the statement from the <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>
    list. After <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp>
    returns, its caller keeps processing the remaining tokens in <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>.
    If there are any tokens left after parsing the entire program, that’s a syntax
    error.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，<sam class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp>会将构成语句的所有令牌从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>列表中移除。<sam class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp>返回后，它的调用者继续处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>中的剩余令牌。如果在解析整个程序后仍然有令牌剩余，那就会发生语法错误。
- en: Right now, each symbol in the formal grammar has only one production rule. In
    later chapters, when some symbols have multiple production rules, the parser will
    need to figure out which production rule to use. It will do this by looking at
    the first few tokens in the list without removing them. Recursive descent parsers
    that look ahead a few tokens to figure out which production rule to use are called
    *predictive parsers.* The alternative to predictive parsing is *recursive descent
    with backtracking*, which involves trying each production rule in turn until you
    find one that works.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个正式语法中的符号只有一个产生式规则。在后面的章节中，当某些符号有多个产生式规则时，解析器将需要确定使用哪个产生式规则。它将通过查看列表中的前几个令牌来实现这一点，而不会移除它们。递归下降解析器通过查看几个令牌来确定使用哪个产生式规则，这种解析器被称为*预测解析器*。预测解析的替代方法是*带回溯的递归下降解析*，它涉及依次尝试每个产生式规则，直到找到一个有效的规则。
- en: 'Now you can write your own recursive descent parser. Remember that you’ll need
    to write one function to parse each non-terminal symbol in [Listing 1-6](chapter1.xhtml#list1-6).
    Here are a few tips to make it easier:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以编写自己的递归下降解析器了。记住你需要为[清单1-6](chapter1.xhtml#list1-6)中的每个非终结符号编写一个函数来解析。这里有一些提示，能让这变得更容易：
- en: '**Write a pretty-printer.**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**编写一个漂亮的打印程序。**'
- en: 'A pretty-printer is a function that prints out your AST in a human-readable
    way. This will make debugging your parser a lot easier. A pretty-printed AST for
    the program in [Listing 1-1](chapter1.xhtml#list1-1) might look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个漂亮的打印程序是一个以人类可读的方式打印出你的 AST 的函数。这将使调试解析器变得更加容易。对于 [清单 1-1](chapter1.xhtml#list1-1)
    中的程序，一个漂亮打印的 AST 可能如下所示：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Give informative error messages.**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供有用的错误信息。**'
- en: This will also help you debug your parser, and it will make your compiler more
    user-friendly too. An error message like <samp class="SANS_TheSansMonoCd_W5Regular_11">Expected
    ";" but found "return"</samp> is a lot more helpful than <samp class="SANS_TheSansMonoCd_W5Regular_11">Fail</samp>.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这还将帮助你调试解析器，并且使你的编译器更加用户友好。像 <samp class="SANS_TheSansMonoCd_W5Regular_11">Expected
    ";" but found "return"</samp> 这样的错误信息比 <samp class="SANS_TheSansMonoCd_W5Regular_11">Fail</samp>
    更加有帮助。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>
- en: The assembly generation stage should convert the AST into x64 assembly, traversing
    the AST in roughly the order the program executes to produce the appropriate assembly
    instructions for each node. First, define an appropriate data structure to represent
    the assembly program, just like you defined a data structure to represent the
    AST when you wrote the parser. You’re adding yet another data structure, instead
    of writing assembly to a file right away, so that you can modify the assembly
    code after you’ve generated it. You won’t need to rewrite any assembly in this
    chapter, but in later chapters you will.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编生成阶段应将 AST 转换为 x64 汇编代码，按照程序执行的大致顺序遍历 AST，为每个节点生成适当的汇编指令。首先，定义一个适当的数据结构来表示汇编程序，就像你在编写解析器时定义数据结构来表示
    AST 一样。你正在添加另一个数据结构，而不是立即将汇编写入文件，这样你就可以在生成汇编代码后修改它。在本章中你不需要重写任何汇编代码，但在后面的章节中你将需要。
- en: I’ll use ASDL again to describe the structure we’ll use to represent assembly.
    [Listing 1-8](chapter1.xhtml#list1-8) has the definition.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我将再次使用 ASDL 来描述我们将用来表示汇编的结构。[清单 1-8](chapter1.xhtml#list1-8) 中有定义。
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-8: The ASDL definition
    of an assembly program</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-8：汇编程序的 ASDL 定义</samp>
- en: This looks a lot like the AST definition from the last section! In fact, this
    *is* an AST definition, but for assembly programs, not C programs. Every node
    corresponds to a construct in assembly, like a single instruction, rather than
    a construct in C, like a statement. I’ll refer to the data structure defined in
    [Listing 1-8](chapter1.xhtml#list1-8) as the *assembly AST* to distinguish it
    from the AST defined in [Listing 1-5](chapter1.xhtml#list1-5).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来和上一节中的 AST 定义很相似！事实上，这*就是*一个 AST 定义，但它是针对汇编程序的，而不是 C 程序的。每个节点对应汇编中的一个构造，例如单条指令，而不是
    C 中的构造，比如语句。我将把 [清单 1-8](chapter1.xhtml#list1-8) 中定义的数据结构称为*汇编 AST*，以区别于 [清单 1-5](chapter1.xhtml#list1-5)
    中定义的 AST。
- en: 'Let’s walk through [Listing 1-8](chapter1.xhtml#list1-8). The <samp class="SANS_TheSansMonoCd_W5Regular_11">program</samp>
    type represents a whole assembly program, which consists of a single <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">function _definition</samp> has
    two fields: the function name and a list of instructions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction*</samp> indicates
    that this field is a list. The <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp>
    type has two constructors to represent the two instructions that can appear in
    our assembly programs: <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction has two operands: it copies the first operand, the source, to the
    second operand, the destination. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction doesn’t have any operands. The <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    type defines the two possible operands to an instruction: a register and an *immediate
    value*, or constant. For now, you don’t need to specify which register to operate
    on, because your generated code will use only EAX. You’ll refer to other registers
    in later chapters. This stage has a similar structure to the parser: you need
    a function to handle each type of AST node, which calls other functions to handle
    that node’s children. [Table 1-2](chapter1.xhtml#tab1-2) describes the assembly
    you should generate for each AST node.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来详细看看 [列表 1-8](chapter1.xhtml#list1-8)。<samp class="SANS_TheSansMonoCd_W5Regular_11">program</samp>
    类型表示一个完整的汇编程序，它由一个单独的 <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>
    组成。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>
    有两个字段：函数名和一系列指令。<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">instruction*</samp> 中表示该字段是一个列表。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp> 类型有两个构造函数，用来表示可以出现在我们汇编程序中的两条指令：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令有两个操作数：它将第一个操作数（源操作数）复制到第二个操作数（目标操作数）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> 指令没有任何操作数。<samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    类型定义了指令的两个可能操作数：一个寄存器和一个 *立即数*（或常量）。目前，你不需要指定操作的寄存器，因为生成的代码将只使用 EAX。你将在后续章节中提到其他寄存器。这个阶段的结构与解析器类似：你需要一个函数来处理每种类型的
    AST 节点，该函数会调用其他函数来处理该节点的子节点。[表 1-2](chapter1.xhtml#tab1-2) 描述了你应为每个 AST 节点生成的汇编代码。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    AST Nodes to Assembly</samp>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 1-2：</samp> <samp class="SANS_Futura_Std_Book_11">将
    AST 节点转换为汇编代码</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">AST node</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    construct</samp> |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">AST 节点</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编构造</samp>
    |'
- en: '| --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, body)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, body)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(exp)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(exp, Register) Ret</samp> |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(exp)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(exp, Register) Ret</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> |'
- en: This translation is pretty straightforward, but there are a couple of things
    to note. The first is that a single statement results in multiple assembly instructions.
    The second is that this translation works only if an expression can be represented
    as a single assembly operand. This is true right now because the only expression
    is a constant integer, but it won’t be once we add unary operators in the next
    chapter. At that point, your compiler will need to generate multiple instructions
    to calculate an expression and then figure out where that expression is stored
    in order to copy it into EAX.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个翻译相当直接，但有几点需要注意。首先，一个语句可能会生成多条汇编指令。其次，只有当一个表达式能够表示为单一的汇编操作数时，这种翻译才有效。现在这是成立的，因为唯一的表达式是一个常量整数，但当我们在下一章引入一元运算符后，就不再适用了。到时候，编译器需要生成多条指令来计算表达式，然后确定该表达式存储的位置，以便将其复制到EAX寄存器中。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码生成</samp>
- en: Now that your compiler can generate assembly instructions, the last step is
    writing those instructions to a file. This file will look a lot like the assembly
    program in [Listing 1-2](chapter1.xhtml#list1-2), but a couple of details vary
    by platform. First, if you’re on macOS, you should always add an underscore in
    front of the function name. For example, emit the label for the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function as <samp class="SANS_TheSansMonoCd_W5Regular_11">_main</samp>. (Don’t
    add this underscore on Linux.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的编译器可以生成汇编指令，最后一步是将这些指令写入文件。这个文件看起来会很像[清单 1-2](chapter1.xhtml#list1-2)中的汇编程序，但有几个细节因平台而异。首先，如果你使用的是macOS，你应始终在函数名前添加一个下划线。例如，将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">main</sup>函数的标签输出为<sup class="SANS_TheSansMonoCd_W5Regular_11">_main</sup>。（在Linux上不要添加这个下划线。）
- en: 'Second, if you’re on Linux, you’ll need to add this line to the end of the
    file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果你使用的是Linux，你需要在文件末尾添加这一行：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This line enables an important security hardening measure: it indicates that
    your code doesn’t need an *executable stack*. A region of memory is *executable*
    if the processor is permitted to execute machine instructions stored there. The
    *stack*, which you’ll learn more about in the next chapter, is a memory region
    that holds local variables and temporary values. It does not, under normal circumstances,
    hold machine instructions. Making the stack non-executable is a basic defense
    against certain security exploits, but this defense can’t be enabled for every
    program, because a few programs that use certain nonstandard language extensions
    actually need an executable stack. Including this line in an assembly file signals
    that it does *not* require an executable stack, which allows this security measure
    to be enabled. None of the code we generate in this book will require an executable
    stack, so we’ll always emit this line. (For more about executable stacks, see
    “Additional Resources” on [page 21](#pg_21).)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行启用了一个重要的安全加固措施：它表明你的代码不需要*可执行栈*。如果处理器被允许执行存储在某个内存区域的机器指令，那么该区域就是*可执行的*。*栈*，你将在下一章中了解更多，是一个存储局部变量和临时值的内存区域。正常情况下，它不存储机器指令。将栈设置为不可执行是防范某些安全漏洞的基本手段，但并不是每个程序都能启用这一防护措施，因为一些使用了特定非标准语言扩展的程序实际上需要可执行栈。在汇编文件中包括这一行，表明它*不*需要可执行栈，这样就可以启用这一安全措施。我们在本书中生成的所有代码都不需要可执行栈，因此我们将始终生成这一行。（关于可执行栈的更多信息，请参见[第21页](#pg_21)的“附加资源”部分。）
- en: The code emission stage should traverse the assembly AST and print each construct
    it encounters, much like the assembly generation stage traverses the AST from
    [Listing 1-5](chapter1.xhtml#list1-5). Because the assembly AST corresponds so
    closely to the final assembly program, the code emission stage will be very simple,
    even as you add more functionality to the compiler in later chapters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成阶段应遍历汇编AST，并打印它遇到的每个结构，就像汇编生成阶段遍历来自[清单 1-5](chapter1.xhtml#list1-5)的AST一样。由于汇编AST与最终的汇编程序非常相似，代码生成阶段将非常简单，即使你在后续章节中向编译器添加更多功能。
- en: '[Tables 1-3](chapter1.xhtml#tab1-3), [1-4](chapter1.xhtml#tab1-4), and [1-5](chapter1.xhtml#tab1-5)
    illustrate how to print each assembly construct.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-3](chapter1.xhtml#tab1-3)、[1-4](chapter1.xhtml#tab1-4) 和 [1-5](chapter1.xhtml#tab1-5)
    说明了如何打印每个汇编结构。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-3:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 1-3：</samp> <samp class="SANS_Futura_Std_Book_11">格式化顶级汇编结构</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层构造</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Print out the function definition. On
    Linux, add at end of file:</samp>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">程序(函数定义)</samp> | <samp class="SANS_Futura_Std_Book_11">打印出函数定义。在
    Linux 系统上，添加以下内容到文件末尾：</samp>'
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">函数(名称, 指令)</samp> |'
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-4:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 1-4：</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><src></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><dst></samp>
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">移动(src, dst)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><src></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><dst></samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">返回</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-5:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 1-5：</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编操作数</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp>
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">寄存器</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp> |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">立即数(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp> |'
- en: Make sure to include line breaks between instructions. You should also emit
    readable, well-formatted assembly code because you’ll spend a lot of time reading
    this assembly while you debug your compiler. You can make your assembly more readable
    by indenting every line except for labels, like in [Listing 1-2](chapter1.xhtml#list1-2).
    Consider including comments in your assembly programs too. A <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>
    symbol in assembly comments out the rest of the line, similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp>
    in C.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在指令之间加入换行符。你还应该输出可读性强、格式良好的汇编代码，因为你在调试编译器时会花很多时间阅读这些汇编代码。你可以通过缩进每一行（标签除外）来使汇编代码更具可读性，就像在[列表
    1-2](chapter1.xhtml#list1-2)中那样。考虑在你的汇编程序中添加注释。汇编中的<samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>符号表示注释，注释掉行的其余部分，类似于
    C 语言中的<samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp>。
- en: Once you’ve implemented the code emission stage, you’ll be able to compile simple
    programs like [Listing 1-1](chapter1.xhtml#list1-1) into working executables.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你实现了代码生成阶段，你将能够将像[列表 1-1](chapter1.xhtml#list1-1)这样的简单程序编译成可运行的可执行文件。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you wrote a compiler that transforms a complete C program into
    an executable that runs on your computer. You learned how to interpret a program
    written in x64 assembly, a formal grammar in extended Backus-Naur form, and an
    AST definition in ASDL. The skills and concepts you learned in this chapter—and
    the four compiler stages you implemented—are the foundation for everything you’ll
    do in the rest of the book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你编写了一个编译器，能够将完整的 C 程序转化为可以在你的计算机上运行的可执行文件。你学习了如何解释用 x64 汇编语言编写的程序、如何使用扩展的巴科斯范式（Backus-Naur
    Form, BNF）定义语法规则，以及如何在 ASDL 中定义抽象语法树（AST）。你在本章中学到的技能和概念——以及你实现的四个编译器阶段——为你在本书中接下来的所有工作奠定了基础。
- en: In the next chapter, you’ll add support for unary operators to your compiler.
    Along the way, you’ll learn how assembly programs manage the stack, and you’ll
    implement a new intermediate representation of the programs you compile to make
    them easier to analyze, transform, and optimize.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将为编译器添加对一元运算符的支持。在此过程中，你将学习汇编程序如何管理堆栈，并且你将实现一个新的中间表示，使你编译的程序更容易分析、转换和优化。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">附加资源</samp>
- en: To learn more about a few of the concepts introduced in this chapter, check
    out the following resources.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章介绍的一些概念，查看以下资源。
- en: '**Linkers**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**链接器**'
- en: “Beginner’s Guide to Linkers” by David Drysdale is a good starting point (*[https://<wbr>www<wbr>.lurklurk<wbr>.org<wbr>/linkers<wbr>/linkers<wbr>.html](https://www.lurklurk.org/linkers/linkers.html)*).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: David Drysdale的《初学者链接器指南》是一个很好的起点（*[https://<wbr>www<wbr>.lurklurk<wbr>.org<wbr>/linkers<wbr>/linkers<wbr>.html](https://www.lurklurk.org/linkers/linkers.html)*）。
- en: Ian Lance Taylor’s 20-part essay on linkers goes into a lot more depth. The
    first post is at *[https://<wbr>www<wbr>.airs<wbr>.com<wbr>/blog<wbr>/archives<wbr>/38](https://www.airs.com/blog/archives/38)*,
    and there’s a table of contents at *[https://<wbr>lwn<wbr>.net<wbr>/Articles<wbr>/276782<wbr>/](https://lwn.net/Articles/276782/)*.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ian Lance Taylor的20篇关于链接器的文章深入探讨了这一主题。第一篇文章可以在*[https://<wbr>www<wbr>.airs<wbr>.com<wbr>/blog<wbr>/archives<wbr>/38](https://www.airs.com/blog/archives/38)*找到，目录可以在*[https://<wbr>lwn<wbr>.net<wbr>/Articles<wbr>/276782<wbr>/](https://lwn.net/Articles/276782/)*查看。
- en: “Position Independent Code (PIC) in Shared Libraries,” a blog post by Eli Bendersky,
    provides an overview of how compilers, linkers, and assemblers work together to
    produce position-independent code, focusing on 32-bit machines (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2011<wbr>/11<wbr>/03<wbr>/position<wbr>-independent<wbr>-code<wbr>-pic<wbr>-in<wbr>-shared<wbr>-libraries](https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries)*).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eli Bendersky的《共享库中的位置独立代码（PIC）》是一篇博文，提供了编译器、链接器和汇编器如何协同工作以生成位置独立代码的概述，重点讨论了32位机器（*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2011<wbr>/11<wbr>/03<wbr>/position<wbr>-independent<wbr>-code<wbr>-pic<wbr>-in<wbr>-shared<wbr>-libraries](https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries)*）。
- en: “Position Independent Code (PIC) in Shared Libraries on x64,” also by Eli Bendersky,
    builds on the previous article, focusing on 64-bit systems (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2011<wbr>/11<wbr>/11<wbr>/position<wbr>-independent<wbr>-code<wbr>-pic<wbr>-in<wbr>-shared<wbr>-libraries<wbr>-on<wbr>-x64](https://eli.thegreenplace.net/2011/11/11/position-independent-code-pic-in-shared-libraries-on-x64)*).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eli Bendersky的《x64上共享库中的位置独立代码（PIC）》在前一篇文章的基础上展开，专注于64位系统（*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2011<wbr>/11<wbr>/11<wbr>/position<wbr>-independent<wbr>-code<wbr>-pic<wbr>-in<wbr>-shared<wbr>-libraries<wbr>-on<wbr>-x64](https://eli.thegreenplace.net/2011/11/11/position-independent-code-pic-in-shared-libraries-on-x64)*）。
- en: '**AST definitions**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**AST定义**'
- en: “Abstract Syntax Tree Implementation Idioms” by Joel Jones provides a good overview
    of how to implement ASTs in various programming languages (*[https://<wbr>hillside<wbr>.net<wbr>/plop<wbr>/plop2003<wbr>/Papers<wbr>/Jones<wbr>-ImplementingASTs<wbr>.pdf](https://hillside.net/plop/plop2003/Papers/Jones-ImplementingASTs.pdf)*).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Joel Jones的《抽象语法树实现惯例》提供了关于如何在各种编程语言中实现AST的良好概述（*[https://<wbr>hillside<wbr>.net<wbr>/plop<wbr>/plop2003<wbr>/Papers<wbr>/Jones<wbr>-ImplementingASTs<wbr>.pdf](https://hillside.net/plop/plop2003/Papers/Jones-ImplementingASTs.pdf)*）。
- en: “The Zephyr Abstract Syntax Description Language” by Daniel Wang, Andrew Appel,
    Jeff Korn, and Christopher Serra is the original paper on ASDL. It includes examples
    of AST definitions in a few different languages (*[https://<wbr>www<wbr>.cs<wbr>.princeton<wbr>.edu<wbr>/~appel<wbr>/papers<wbr>/asdl97<wbr>.pdf](https://www.cs.princeton.edu/~appel/papers/asdl97.pdf)*).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Daniel Wang、Andrew Appel、Jeff Korn和Christopher Serra的《Zephyr抽象语法描述语言》是关于ASDL的原创论文。它包括了几个不同语言中AST定义的示例（*[https://<wbr>www<wbr>.cs<wbr>.princeton<wbr>.edu<wbr>/~appel<wbr>/papers<wbr>/asdl97<wbr>.pdf](https://www.cs.princeton.edu/~appel/papers/asdl97.pdf)*）。
- en: '**Executable stacks**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**可执行堆栈**'
- en: “Executable Stack,” a blog post by Ian Lance Taylor, discusses which programs
    need executable stacks and describes how Linux systems figure out whether a program’s
    stack should be executable (*[https://<wbr>www<wbr>.airs<wbr>.com<wbr>/blog<wbr>/archives<wbr>/518](https://www.airs.com/blog/archives/518)*).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ian Lance Taylor的《可执行堆栈》是一篇博文，讨论了哪些程序需要可执行堆栈，并描述了Linux系统如何判断一个程序的堆栈是否应该是可执行的（*[https://<wbr>www<wbr>.airs<wbr>.com<wbr>/blog<wbr>/archives<wbr>/518](https://www.airs.com/blog/archives/518)*）。
