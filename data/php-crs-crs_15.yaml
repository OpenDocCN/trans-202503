- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 12 VALIDATING FORM DATA
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12 验证表单数据
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Not all data received through web forms will be valid; users may make mistakes
    or miss required values, or a number of other things could go wrong. In this chapter,
    we’ll explore ways to validate the received data, and we’ll design some typical
    decision logic to take appropriate action depending on the values received (and
    any that are missing).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网页表单接收到的数据并不总是有效的；用户可能会犯错或漏填必填值，或者其他一些问题可能会导致错误。在本章中，我们将探讨验证接收数据的方法，并设计一些典型的决策逻辑，以根据接收到的值（以及缺失的值）采取适当的行动。
- en: It’s important to recognize that HTML forms submit values only as text strings,
    regardless of the input type. One of the very reasons PHP isn’t type-sensitive
    is to make it easy to treat a string containing digits as a number without explicitly
    type-casting or including data-type conversion statements. This makes it that
    much more important to carefully write (and test) the validation rules for processing
    received form data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，HTML 表单提交的值仅作为文本字符串，无论输入类型是什么。PHP 不区分数据类型的一个重要原因是，它让我们可以轻松地将包含数字的字符串当作数字处理，而无需显式地进行类型转换或包括数据类型转换语句。这使得仔细编写（并测试）用于处理接收到的表单数据的验证规则变得尤为重要。
- en: '### Writing Custom Validation Logic'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 编写自定义验证逻辑'
- en: In [Chapter 11](chapter11.xhtml), you learned to use simple built-in filters
    such as FILTER _SANITIZE_SPECIAL_CHARS in conjunction with filter_input() to sanitize
    incoming form data. However, real-world data often has its own special validation
    criteria that goes beyond these built-in filters. Once you’ve retrieved data from
    the submitted form request, you may therefore need to write custom validation
    logic to make sure the data is as it should be.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](chapter11.xhtml)中，你学会了如何使用简单的内建过滤器，如FILTER_SANITIZE_SPECIAL_CHARS，结合filter_input()来净化传入的表单数据。然而，现实中的数据通常有自己特殊的验证标准，超出了这些内建过滤器的范围。因此，一旦你从提交的表单请求中提取数据，你可能需要编写自定义验证逻辑，确保数据符合预期。
- en: 'Let’s illustrate how this works with a simple example: a product details form
    asking the user to enter a product code and a price (see [Figure 12-1](#fig12-1)).
    We’ll assume that the product code must have a minimum of three characters and
    that the price must be a number (either an integer or a decimal value).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的示例来说明这是如何工作的：一个产品详情表单，要求用户输入产品代码和价格（见[图 12-1](#fig12-1)）。我们假设产品代码必须至少有三个字符，价格必须是一个数字（可以是整数或小数）。
- en: '![](../images/figure12-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure12-1.jpg)'
- en: 'Figure 12-1: A product details form in need of validation logic'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1：需要验证逻辑的产品详情表单
- en: As we explored in [Chapter 11](chapter11.xhtml), we can write a simple script
    confirming receipt of the form data with a few lines of PHP. [Listing 12-1](#lis12-1)
    shows how.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第11章](chapter11.xhtml)中探讨的那样，我们可以编写一个简单的脚本来确认接收到的表单数据，使用几行 PHP 代码。[代码清单
    12-1](#lis12-1)展示了如何实现。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 12-1: Confirming the received product code and price'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单 12-1]：确认收到的产品代码和价格'
- en: Here we use the filter_input() function to extract the productCode and price
    variables from the received URL-encoded form data and display them back to the
    user by using PHP short echo tags. This will work if the user has submitted values
    as expected, but it’s never a good idea to assume the data that has arrived from
    the user is all present and correct.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用filter_input()函数从接收到的 URL 编码表单数据中提取 productCode 和 price 变量，并通过 PHP 短版
    echo 标签将它们显示给用户。如果用户按照预期提交了数据，这样会有效，但假设来自用户的数据完全正确并存在，始终不是一个好主意。
- en: 'We should expand the script to validate the data before confirming it to the
    user. We’ll try to validate the price and product code data in the following ways:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该扩展脚本，在确认数据给用户之前进行验证。我们将尝试通过以下方式验证价格和产品代码数据：
- en: If the product code is missing or empty, display the error message missing product
    code.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果产品代码缺失或为空，显示错误消息“缺少产品代码”。
- en: If the product code is less than three characters in length, display the error
    message product code too few characters.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果产品代码少于三个字符，显示错误消息“产品代码字符太少”。
- en: If the price isn’t a numeric value, display the error message price was not
    a number.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果价格不是一个数字，显示错误消息“价格不是数字”。
- en: If no validation errors occur, display the message input data was error free.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有验证错误，显示消息“输入数据没有错误”。
- en: As you’ll see, PHP has built-in functions to help with these sorts of validation
    checks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，PHP 提供了内建函数来帮助进行这些验证检查。
- en: Managing Multiple Validation Errors
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管理多个验证错误
- en: One common approach to managing custom validation logic with multiple potential
    errors is to use an array for the errors. Start with an empty array, then use
    a series of if...else statements to add an error message to the array each time
    a new validation error is detected. If the array is empty after all the validation,
    it means the data was found to be error free. If it isn’t empty, you can loop
    through the array to display all the error messages to the user. [Listing 12-2](#lis12-2)
    uses this approach to implement the validation logic for our product details form.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 管理具有多个潜在错误的自定义验证逻辑的一种常见方法是使用数组来存储错误。首先创建一个空数组，然后使用一系列 if...else 语句，每当检测到新的验证错误时，就将错误信息添加到数组中。如果所有验证完成后数组为空，表示数据没有错误。如果数组不为空，你可以遍历该数组，向用户显示所有错误信息。[列表
    12-2](#lis12-2) 使用这种方法实现了我们产品详情表单的验证逻辑。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 12-2: Implementing custom validation logic with an array of error messages'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-2：使用错误信息数组实现自定义验证逻辑
- en: After extracting the product code and price from the incoming form data as before,
    we create an empty array in the $errors variable ❶. Then we use an if...elseif
    structure ❷ to validate the $productCode variable. The if branch adds the message
    'missing product code' to the $errors array if $productCode is empty. (The empty()
    function will return true if $productCode wasn’t found in the received form data
    or if it contained an empty string.) The elseif branch, which is visited only
    if $productCode isn’t empty, adds the message 'product code too few characters'
    to the array if the strlen() function finds the product code to contain fewer
    than three characters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在从传入的表单数据中提取产品代码和价格后，我们在 $errors 变量中创建一个空数组 ❶。然后，我们使用 if...elseif 结构 ❷ 来验证 $productCode
    变量。如果 $productCode 为空，if 分支会将消息 'missing product code' 添加到 $errors 数组中。（如果 $productCode
    在接收到的表单数据中不存在，或者包含空字符串，empty() 函数会返回 true。）elseif 分支仅在 $productCode 不为空时才会被执行，如果
    strlen() 函数检测到产品代码少于三个字符，则将 'product code too few characters' 添加到数组中。
- en: Next, we use a separate if statement to validate the $price variable ❸. We pass
    the variable to is_numeric(), which returns true if the received string can be
    interpreted as an integer or a float. If not, we add the message 'price was not
    a number' to the array.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用一个单独的 if 语句来验证 $price 变量 ❸。我们将该变量传递给 is_numeric() 函数，如果接收到的字符串可以解释为整数或浮动数，则返回
    true。如果不能，我们将消息 'price was not a number' 添加到数组中。
- en: Finally, we test whether the $errors array contains any errors ❹. If it does,
    we use a foreach loop to display each error to the user as an item in an HTML
    ordered list. Otherwise, if the array is empty, we display the message 'input
    data was error free'.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试 $errors 数组是否包含任何错误 ❹。如果有，我们使用 foreach 循环将每个错误作为 HTML 有序列表中的一项显示给用户。否则，如果数组为空，我们显示消息
    '输入数据没有错误'。
- en: 'This example has illustrated a range of typical validations. You’ll often find
    yourself checking for the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一些典型的验证情况。你经常会检查以下内容：
- en: '**Any required data that’s missing**   You can test for this with the empty()
    function.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**任何缺失的必填数据**   你可以使用 empty() 函数来检测这一点。'
- en: '**Too few characters for text data**   You might need to ensure that the input
    meets minimum-length rules for usernames or passwords, for example. You can test
    for this with the strlen() function.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本数据字符过少**   例如，你可能需要确保输入符合用户名或密码的最小长度规则。你可以使用 strlen() 函数来检测这一点。'
- en: '**Non-numeric values**   You might want to know if the value received is neither
    a valid integer nor a decimal number. You can test for this with the is_numeric()
    function.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**非数字值**   你可能想知道接收到的值是否既不是有效的整数，也不是有效的浮动数。你可以使用 is_numeric() 函数来进行检测。'
- en: While we were able to rely on built-in PHP functions for our validation checks,
    we needed custom logic to string them together and match them to the particular
    requirements of our product details form.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们能够依赖 PHP 内建函数来进行验证检查，但我们需要自定义逻辑将它们串联起来，并使其符合产品详情表单的特定要求。
- en: Testing for a Valid Zero Value
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检测有效的零值
- en: 'Because of PHP’s type insensitivity, it’s easy to write code that incorrectly
    treats a numeric value of 0 as missing or false. This happens because in PHP all
    the following (among other values) are considered false:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PHP 的类型不敏感，编写代码时容易错误地将数值 0 视为缺失或错误。这是因为在 PHP 中，以下所有内容（以及其他值）都被认为是 false：
- en: The Boolean false itself
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值 false 本身
- en: The integers 0 and -0
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数 0 和 -0
- en: The floats 0.0 and -0.0
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮动数 0.0 和 -0.0
- en: The empty string and the string "0"
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串和字符串 "0"
- en: The special NULL type (including unset variables)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊的NULL类型（包括unset变量）
- en: To illustrate the problem, say you want to test whether the user left a form
    field blank. You’d typically use the empty() function, but if the user happened
    to enter the digit 0 in the form field, the test empty('0') will return true,
    just like the test empty('') for a truly empty form field (remember that all form
    values arrive as strings in the HTTP request, even if they are numeric characters).
    If you want the 0 to be a valid entry for the field (for example, if the field
    is to record someone’s score on a test), you’ll need to write code that distinguishes
    between a valid 0 entry and an unacceptable empty string. The solution is to use
    the triple-equal-sign identical operator (===), which tests whether its operands
    have the same value *and* data type, as discussed in [Chapter 2](chapter2.xhtml).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个问题，假设你想测试用户是否留下了表单字段空白。你通常会使用empty()函数，但如果用户在表单字段中输入了数字0，那么测试empty('0')会返回true，就像测试empty('')一样，表示表单字段真的为空（记住，所有表单值在HTTP请求中都会以字符串形式到达，即使它们是数字字符）。如果你希望0是该字段的有效输入（例如，如果该字段用于记录某人的考试成绩），你需要编写代码区分有效的0输入和不可接受的空字符串。解决方案是使用三等号运算符(===)，它测试操作数是否具有相同的值*并且*数据类型，正如在[第2章](chapter2.xhtml)中所讨论的那样。
- en: NOTE
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The PHP documentation describes type comparisons at* [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)*,
    comparing the results of the* == *and* === *operators, as well as showing the
    results for functions such as* gettype()*,* empty()*, and* isset() *for potentially
    confusing values. I recommend you bookmark this page for reference.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP文档描述了类型比较，详见*[https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)*，比较==*和*===*运算符的结果，以及展示如*gettype()*,
    *empty()*, 和*isset()*等函数在处理可能引起混淆的值时的结果。我建议你将此页面添加书签以备查阅。*'
- en: Listing 12-3 assumes a form has been submitted with the GET method sending a
    variable named score. The code uses an if...elseif statement to differentiate
    between no value and a 0 value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-3假设表单已通过GET方法提交，并发送一个名为score的变量。代码使用if...elseif语句来区分没有值和0值的情况。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 12-3: Distinguishing between the number 0 and an empty or NULL value'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-3：区分数字0与空值或NULL值
- en: We first use the === operator to test whether $score holds the exact string
    '0'. If not, we use the empty() function to check whether an empty string was
    received.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用===运算符测试$score是否包含确切的字符串'0'。如果不是，我们使用empty()函数检查是否接收到空字符串。
- en: If testing for a valid 0 is a task you’ll need to perform often, it would be
    useful to encapsulate the necessary logic in a function that returns false when
    given the string '0' or the result of the empty() function otherwise, as shown
    in [Listing 12-4](#lis12-4). Create a *zeroFunction.php* file containing this
    code, since we’ll make use of it later in this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要经常测试有效的0，封装必要的逻辑到一个函数中会很有用，当传入字符串'0'或empty()函数结果时返回false，如[示例12-4](#lis12-4)所示。创建一个*zeroFunction.php*文件，包含这段代码，因为我们将在本章稍后的部分使用它。
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 12-4: A function that tests for an empty string but does not consider
    the digit 0 as empty'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-4：一个测试空字符串但不将数字0视为空字符串的函数
- en: Keep in mind that if a numeric value of 0 is an acceptable form input, you may
    need to do more than simply compare the incoming string with the string literal
    '0'. This is because other strings may also evaluate to 0, such as '0.0', '0.00',
    and so on. To be thorough, you need to test the underlying numeric value that
    the incoming string represents. Fortunately, PHP provides the intval() function,
    which can take in a string and return the numeric integer value of its contents.
    Normal PHP type juggling will take place, and so any valid numeric characters
    at the beginning of the string will be used to determine the string’s integer
    value. As discussed in [Chapter 2](chapter2.xhtml), any non-numeric content in
    a string is ignored during type juggling.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果数字值0是一个可接受的表单输入，你可能需要做的不仅仅是将传入的字符串与字面量字符串'0'进行比较。因为其他字符串也可能被评估为0，例如'0.0'、'0.00'等。为了彻底测试，你需要检查传入字符串所表示的底层数值。幸运的是，PHP提供了intval()函数，它可以接收一个字符串并返回该字符串内容的数字整数值。PHP的类型转换会正常发生，因此字符串开头的任何有效数字字符都会用来确定该字符串的整数值。如[第2章](chapter2.xhtml)所讨论，字符串中的任何非数字内容在类型转换过程中都会被忽略。
- en: '[Table 12-1](#tab12-1) lists examples of strings and their intval() evaluations.
    Notice that the non-numeric remainders of strings are simply ignored (such as
    ''5abc'' evaluating to 5), as are any decimal components of numeric strings.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-1](#tab12-1)列出了字符串及其对应的intval()评估结果。请注意，字符串中的非数字部分会被简单忽略（例如，''5abc''被评估为5），而数字字符串中的任何小数部分也会被忽略。'
- en: 'Table 12-1: Example intval() Calls'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1：intval() 调用示例
- en: '| Function call | Return value |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 函数调用 | 返回值 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| intval(''0'') | 0 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| intval(''0'') | 0 |'
- en: '| intval(''00'') | 0 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| intval(''00'') | 0 |'
- en: '| intval(''0.00'') | 0 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| intval(''0.00'') | 0 |'
- en: '| intval(''0.99'') | 0 (decimal component ignored) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| intval(''0.99'') | 0（小数部分被忽略） |'
- en: '| intval(''0005'') | 5 (leading zeros ignored) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| intval(''0005'') | 5（忽略前导零） |'
- en: '| intval(''5abc'') | 5 (everything from ''a'' on ignored) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| intval(''5abc'') | 5（忽略从''a''开始的部分） |'
- en: At the end of the day, validation should match whatever data the form owner
    specifies is acceptable. It is, of course, always a good idea to offer the user
    a confirmation screen with a chance to correct values after any validation and
    string-to-number evaluation, to make sure the form’s validation logic matches
    the user’s intent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到头来，验证应该符合表单所有者指定的可接受数据。当然，在任何验证和字符串到数字的转换后，始终为用户提供一个确认页面，让他们有机会修正值，以确保表单的验证逻辑符合用户的意图，这始终是一个好主意。
- en: Displaying and Validating Forms in a Single Postback Script
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在单一回发脚本中显示和验证表单
- en: A frequently used strategy for validating web forms is to use a single script,
    known as a *postback*, both to display the form and to perform validation. Combining
    these two actions ensures that the form can be redisplayed to the user in the
    event of any validation errors, with the added validation error messages included.
    A postback also makes it easy to implement a *sticky form*, a form that’s redisplayed
    with the previously submitted values prepopulated in the appropriate fields, saving
    the user from having to enter the data again. (The term *sticky* refers to the
    values remaining, or sticking, in the form after submission.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 验证网页表单的一个常用策略是使用一个单一的脚本，称为*回发（postback）*，既用来显示表单，也用来执行验证。将这两个动作结合起来，确保在出现验证错误时，表单能够重新展示给用户，并附带相应的验证错误信息。回发还便于实现*粘性表单*，即重新展示表单时，之前提交的值会预填充到相应的字段中，避免用户重新输入数据。（*粘性*指的是表单提交后，数据仍然保留在表单中。）
- en: Using a single script to both display and validate has two drawbacks. First,
    the script can get very long, especially for complex forms with lots of validation
    logic. Second, the complexity of a script performing multiple tasks is high, making
    the code potentially harder to understand, more error-prone, and harder to update
    or maintain at a later date. In [Chapter 13](chapter13.xhtml), we’ll address these
    disadvantages as we look at strategies to separate logic from display code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个单一脚本来同时显示和验证有两个缺点。首先，脚本可能变得非常长，尤其是对于包含大量验证逻辑的复杂表单。其次，一个执行多重任务的脚本复杂度较高，可能导致代码更难理解、更容易出错，也更难以在后期进行更新或维护。在[第13章](chapter13.xhtml)中，我们将讨论这些缺点，并探讨如何将逻辑与显示代码分离的策略。
- en: For now, though, we’ll focus on creating single scripts for sticky postback
    forms. We’ll start with a form that requires only simple validation logic, and
    then we’ll revisit the array-based approach to handling multiple validation errors
    discussed earlier in the chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重点关注为粘性回发表单创建单一脚本。我们将从一个仅需要简单验证逻辑的表单开始，然后再回到本章前面讨论的基于数组的多重验证错误处理方法。
- en: '#### Simple Validation Logic'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 简单的验证逻辑'
- en: Let’s create a simple postback script for a sticky form where the user enters
    their name and receives a *Hello <name>* greeting in response. We’ll arbitrarily
    say that the submitted name must have at least three characters to be valid. Our
    postback script needs to handle three possible situations that can occur after
    the server receives a new HTTP request. The first situation is the initial form
    request (via the GET HTTP method), when an empty text box and Submit button are
    presented to the user, as in [Figure 12-2](#fig12-2).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为一个粘性表单创建一个简单的回发脚本，用户输入姓名后，收到*Hello <name>* 的问候响应。我们假设提交的姓名必须至少有三个字符才能有效。我们的回发脚本需要处理服务器收到新
    HTTP 请求后的三种可能情况。第一种情况是初始表单请求（通过 GET HTTP 方法），此时用户看到一个空的文本框和提交按钮，如[图12-2](#fig12-2)所示。
- en: '![](../images/figure12-2.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure12-2.jpg)'
- en: 'Figure 12-2: The first presentation of the sticky postback form'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：粘性回发表单的首次展示
- en: The second situation is a form submission with invalid data (via the POST HTTP
    method). In this case, the form should be redisplayed to the user with an error
    message about the invalid submission. Since the form is sticky, the text box should
    be populated with whatever text the user submitted last, as shown in [Figure 12-3](#fig12-3).
    In this example, a single letter a was submitted.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是提交了无效数据的表单（通过POST HTTP方法）。在这种情况下，表单应重新显示给用户，并显示有关无效提交的错误消息。由于表单是粘性的，文本框应填充用户上次提交的文本，如[图
    12-3](#fig12-3)所示。在本例中，提交的是单个字母a。
- en: '![](../images/figure12-3.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure12-3.jpg)'
- en: 'Figure 12-3: Redisplaying the sticky postback form with a message about the
    invalid data'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-3：带有无效数据消息的回发粘性表单
- en: The third and final situation is a form submission with valid data (via the
    POST HTTP method). In this case, a confirmation message should be displayed to
    the user, as shown in [Figure 12-4](#fig12-4).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个也是最后一种情况是有效数据的表单提交（通过POST HTTP方法）。在这种情况下，应向用户显示确认消息，如[图 12-4](#fig12-4)所示。
- en: '![](../images/figure12-4.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure12-4.jpg)'
- en: 'Figure 12-4: Displaying a confirmation message after valid data is submitted'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-4：提交有效数据后显示确认消息
- en: The logic for our postback PHP script can be visualized as a flow chart with
    two decisions ([Figure 12-5](#fig12-5)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的回发PHP脚本的逻辑可以通过一个有两个决策的流程图来呈现（[图 12-5](#fig12-5)）。
- en: '![](../images/figure12-5.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure12-5.jpg)'
- en: 'Figure 12-5: A decision flowchart for the postback sticky form'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-5：回发粘性表单的决策流程图
- en: 'We’ll write the postback script in a *public/index.php* file in four stages:
    setting default values, validating the submitted data, displaying a confirmation
    for valid data, and displaying the form.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*public/index.php*文件中分四个阶段编写回发脚本：设置默认值、验证提交的数据、显示有效数据的确认消息以及显示表单。
- en: Setting Default Values
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置默认值
- en: First, we need to set default values for the two key postback variables $isSubmitted
    and $isValid. The first of these Boolean flags records whether the form has been
    submitted, as determined by whether the incoming request uses the POST method
    (indicating a form submission) or the GET method (indicating the initial request
    for the form). The second flag signals whether the data received is valid. A third
    variable will set the default value of the $firstName variable for our logic.
    [Listing 12-5](#lis12-5) shows the code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为两个关键的回发变量$isSubmitted和$isValid设置默认值。第一个布尔标志记录表单是否已提交，判断依据是传入请求使用的是POST方法（表示表单提交）还是GET方法（表示初次请求表单）。第二个标志表示接收到的数据是否有效。第三个变量将设置$firstName变量的默认值供我们的逻辑使用。[示例
    12-5](#lis12-5)展示了代码。
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 12-5: Setting default values'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-5：设置默认值
- en: We set the $isSubmitted Boolean flag to true or false depending on the value
    of the 'REQUEST_METHOD' key in the $_SERVER array. This superglobal array holds
    information from the web server about the current executing script, the request
    being processed, and the like. If the value is the string 'POST', then $isSubmitted
    will be true; otherwise, it will be false.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将$isSubmitted布尔标志设置为true或false，具体取决于$_SERVER数组中'REQUEST_METHOD'键的值。这个超全局数组包含来自Web服务器的关于当前执行脚本、正在处理的请求等信息。如果值是字符串'POST'，则$isSubmitted为true；否则，它将是false。
- en: We next set the $isValid Boolean flag to true by default; we’re therefore assuming
    the received data is valid unless later logic determines otherwise. Finally, we
    set $firstName to an empty string to ensure that, whatever happens, we have a
    value for this variable that can be inserted into the form text box when the form
    is presented to the user.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将$isValid布尔标志默认设置为true；因此，我们假设接收到的数据是有效的，除非后续逻辑另行确定。最后，我们将$firstName设置为空字符串，以确保无论发生什么，我们都有一个可以在表单呈现给用户时插入文本框的值。
- en: NOTE
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Learn more about the* $_SERVER *array in the PHP documentation at* [https://www.php.net/manual/en/reserved.variables.server.php](https://www.php.net/manual/en/reserved.variables.server.php)*.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*在PHP文档中* $_SERVER *数组的更多信息，请访问* [https://www.php.net/manual/en/reserved.variables.server.php](https://www.php.net/manual/en/reserved.variables.server.php)*。'
- en: Validating the Submitted Data
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 验证提交的数据
- en: The second block of code in our postback script, shown in [Listing 12-6](#lis12-6),
    attempts to validate the submitted form data after the form has been successfully
    submitted.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在回发脚本中的第二段代码，如[示例 12-6](#lis12-6)所示，尝试在表单成功提交后验证提交的表单数据。
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 12-6: Validating the number of characters in $firstName'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-6：验证$firstName的字符数
- en: We perform the validation inside an if statement whose body will execute only
    if the $isSubmitted Boolean flag is true. Therefore, we’ll skip this code when
    the form is requested for the first time. To validate the data, we use filter_input()
    to retrieve the value of firstName from the submitted POST variables, overwriting
    the default, empty-string value of $firstName in the process ❶. Then we use strlen()
    to check whether the received string contains less than three characters ❷. If
    so, we change the $isValid Boolean flag to false and assign an error message to
    the $errorMessage variable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个if语句内执行验证，只有当$isSubmitted布尔值为true时，其主体才会执行。因此，当表单是第一次请求时，我们会跳过这段代码。为了验证数据，我们使用filter_input()来获取提交的POST变量中的firstName值，从而覆盖默认的空字符串值（$firstName）❶。然后，我们使用strlen()来检查接收到的字符串是否少于三个字符❷。如果是这样，我们将$isValid布尔值设置为false，并将错误信息分配给$errorMessage变量。
- en: Displaying a Confirmation for Valid Data
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示有效数据的确认信息
- en: At this point, we have values in the $isSubmitted and $isValid flags that we
    can use to decide what to present to the user. Our third block of code, shown
    in [Listing 12-7](#lis12-7), uses these flags in a single if statement for the
    situation in which the form has been submitted with valid data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们在$isSubmitted和$isValid标志中有了可以用来决定向用户展示什么的值。我们第三段代码，见[清单12-7](#lis12-7)，在一个单独的if语句中使用了这些标志，适用于表单已经提交且数据有效的情况。
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 12-7: Responding to valid data'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-7：响应有效数据
- en: If both flags are true, we display a "Hello $firstName" confirmation message
    to the user. Then we terminate the script with the die() function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个标志都为true，我们会向用户显示一个“Hello $firstName”的确认消息。然后，我们使用die()函数终止脚本。
- en: Displaying the Form
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示表单
- en: 'If the if statement in [Listing 12-7](#lis12-7) fails, either the form is being
    requested for the first time ($isSubmitted is false) or the submitted data is
    invalid ($isValid is false). In either case, the result is the same: we need to
    display the form to the user. [Listing 12-8](#lis12-8) shows the necessary mix
    of HTML and PHP code.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[清单12-7](#lis12-7)中的if语句未通过，说明表单是第一次请求（$isSubmitted为false），或者提交的数据无效（$isValid为false）。无论哪种情况，结果都是一样的：我们需要向用户展示表单。[清单12-8](#lis12-8)展示了必要的HTML和PHP代码混合。
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 12-8: Displaying the form to the user'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-8：向用户展示表单
- en: In the HTML head, we define a CSS error class for any error message we need
    to display, with a pink background and some padding ❶. In the page’s body, we
    declare a <form> element with the POST method ❷. Notice that we don’t include
    an action attribute setting the PHP script that will process the form; when no
    action is specified, the form submission request is sent by default to the same
    URL that displayed the form. This default is perfect for a postback form like
    this one.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML的head部分，我们为需要显示的任何错误信息定义了一个CSS错误类，设置了粉红色背景和一些内边距❶。在页面的body部分，我们声明了一个使用POST方法的<form>元素❷。请注意，我们没有包含一个action属性来设置处理表单的PHP脚本；当未指定action时，表单提交请求默认会发送到显示表单的相同URL。这个默认设置非常适合像这样的回传表单。
- en: NOTE
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注
- en: '*In HTML 4, a form had to specify an* action *attribute, but in HTML 5, the
    attribute defaults to an empty string, which results in the form submitting to
    the same URL as led to the form’s display.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*在HTML 4中，表单必须指定一个* action *属性，但在HTML 5中，该属性默认为空字符串，这导致表单提交到与显示表单相同的URL。*'
- en: 'Within the <form> element, we use PHP’s alternative if statement syntax to
    display a <div> element with the content of the $errorMessage variable if the
    form is submitted but the data isn’t valid ❸. We style the <div> with our error
    CSS class. We then display the form text input box and set its value attribute
    to the contents of the PHP $firstName variable ❹. If the form is being displayed
    for the first time, this will be the default empty string we declared in [Listing
    12-5](#lis12-5), but if the form is being redisplayed after an invalid input,
    $firstName will hold the user’s previous submission. This mechanism is what makes
    the form sticky: the submitted value sticks in the text box when submitted and
    redisplayed, saving the user from typing values again.  #### Array-Based Validation
    Logic'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在<form>元素内，我们使用PHP的替代if语句语法来显示一个<div>元素，内容为$errorMessage变量的值，前提是表单已提交但数据无效❸。我们使用错误的CSS类来样式化该<div>元素。接着，我们显示文本输入框，并将其value属性设置为PHP变量$firstName的内容❹。如果表单是第一次显示，这将是我们在[Listing
    12-5](#lis12-5)中声明的默认空字符串，但如果表单在输入无效后重新显示，$firstName将保存用户的上次提交。这种机制使表单具有粘性：提交后，提交的值会保留在文本框中，避免用户再次输入值。####
    基于数组的验证逻辑
- en: Let’s now join the two key concepts from this chapter and implement our earlier
    product details form with its array-based approach to error messages as a postback
    sticky form. [Figure 12-6](#fig12-6) shows an example of the error messages to
    be output when the submitted data is missing values or violates any validation
    rules.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将本章的两个关键概念结合起来，实现早先提到的产品详细信息表单，并将其错误消息的基于数组的方法应用于一个粘性回发表单。[图12-6](#fig12-6)展示了在提交的数据缺少值或违反任何验证规则时要输出的错误消息示例。
- en: '![](../images/figure12-6.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure12-6.jpg)'
- en: 'Figure 12-6: The sticky postback product form with errors'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-6：带错误的粘性回发产品表单
- en: 'Even with an array-based approach to data validation, our postback script will
    follow the same basic steps as before: setting default values, validating the
    data, displaying a confirmation for valid input, and displaying the form. [Listing
    12-9](#lis12-9) tackles the first step.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使采用基于数组的数据验证方法，我们的回发脚本也将遵循与之前相同的基本步骤：设置默认值、验证数据、对有效输入进行确认并显示表单。[Listing 12-9](#lis12-9)处理第一步。
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 12-9: Setting default values'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-9：设置默认值
- en: As before, we set the $isSubmitted Boolean flag to true or false depending on
    whether $_SERVER['REQUEST_METHOD'] contains 'POST'. We then set the $productCode
    and $price variables to empty strings to ensure that we can refer to them safely
    for default values in the form inputs. Finally, we set $errors to an empty array.
    We’ll add to this array only if any validation errors are found; an empty array
    will indicate that the data is valid.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们根据$_SERVER['REQUEST_METHOD']是否包含'POST'来设置$isSubmitted布尔标志为true或false。然后，我们将$productCode和$price变量设置为空字符串，以确保在表单输入框中安全地引用它们作为默认值。最后，我们将$errors设置为空数组。只有在发现验证错误时，我们才会往这个数组中添加内容；一个空数组则表示数据有效。
- en: Listing 12-10 attempts to validate the submitted form data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-10尝试验证提交的表单数据。
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 12-10: Validating the submitted form data'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-10：验证提交的表单数据
- en: Once again, all our validation occurs inside an if statement executed only if
    the $isSubmitted flag is true. We first retrieve the productCode and price values
    from the submitted POST variables. Then we test whether $productCode is empty
    ❶ and add an error message to the $errors array if it is. Otherwise, we test whether
    $productCode is less than three characters long ❷, again adding an error message
    to the array if not. For our last validation check, we add another error message
    if $price is empty or isn’t numeric ❸.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们的所有验证都发生在一个if语句内部，只有在$isSubmitted标志为true时才会执行。我们首先从提交的POST变量中获取$productCode和price值。然后我们测试$productCode是否为空❶，如果为空，则将错误消息添加到$errors数组中。否则，我们测试$productCode的长度是否小于三个字符❷，如果不符合，则再次向数组中添加错误消息。对于最后的验证检查，如果$price为空或不是数字❸，我们会添加另一个错误消息。
- en: Next, [Listing 12-11](#lis12-11) shows the code to confirm a valid form submission.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[Listing 12-11](#lis12-11)显示了确认有效表单提交的代码。
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 12-11: Confirming a valid submission'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-11：确认有效的提交
- en: First, we test whether the $errors array is empty and set the $isValid Boolean
    flag accordingly. Then, if both the $isSubmitted and $isValid Boolean flags are
    true, we display a confirmation message to the user and terminate the script with
    the die() function. If either flag is false, we need to display the form to the
    user, with any errors if appropriate. [Listing 12-12](#lis12-12) shows the code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们测试$errors数组是否为空，并相应地设置$isValid布尔标志。然后，如果$isSubmitted和$isValid两个布尔标志都为真，我们向用户显示确认消息，并用die()函数终止脚本。如果任何一个标志为假，我们则需要向用户展示表单，并在适当的情况下显示错误。[清单
    12-12](#lis12-12)展示了这段代码。
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 12-12: Displaying the form with any error messages'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-12：显示表单并附带任何错误消息
- en: Initially, this code is similar to our earlier sticky form template from [Listing
    12-8](#lis12-8), up to the if statement checking whether the form was submitted
    but the data isn’t valid ❶. From there, we use a PHP foreach loop ❷ to print each
    message in the $errors array as a separate list item inside the <div> styled with
    our error CSS class. Later, we make the <form> element sticky by prefilling the
    product code and price fields with the values from the $productCode ❸ and $price
    ❹ variables, which will be either the user’s previous submissions or the default
    empty strings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这段代码与我们之前的粘性表单模板类似，来自[清单 12-8](#lis12-8)，直到检查表单是否已提交但数据无效的if语句 ❶。从那里，我们使用PHP的foreach循环
    ❷，将$errors数组中的每条消息作为一个独立的列表项打印到<div>标签内，并应用我们定义的错误CSS类样式。接着，我们通过预填充产品代码和价格字段（来自$productCode
    ❸ 和$price ❹ 变量的值，这些值可以是用户之前的提交或默认的空字符串）来使<form>元素变得粘性。
- en: As you can see, the same basic structure that worked for our simpler form also
    worked for this more complex postback sticky form script, and the strategy of
    building up and displaying an array of error messages fits well into this structure.
    However, the complete PHP postback script is nearly 60 lines long and performs
    enough actions as to make the single script complex.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，适用于我们简单表单的相同基本结构，也适用于这个更复杂的后置提交粘性表单脚本，而且构建和展示错误消息数组的策略很好地融入了这个结构。然而，完整的PHP后置提交脚本长达60行，并执行了足够多的操作，使得单一脚本变得复杂。
- en: 'In the next chapter, we’ll explore strategies to keep the benefits of the postback
    approach for form processing (such as displaying validation messages with the
    form and using sticky form values to save the user from retyping) while breaking
    up the tasks of form display, validation, error message display, and confirmation
    logic into simpler scripts. In the process, we’ll develop a basic web application
    architecture that can scale up to meet the requirements of complex websites, forms,
    and validation rules.  ### Summary'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一章中，我们将探索策略，保持后置提交方法在表单处理中的优势（例如与表单一起显示验证消息，并使用粘性表单值以避免用户重新输入），同时将表单展示、验证、错误消息展示和确认逻辑的任务分解成更简单的脚本。在这个过程中，我们将开发一个基本的Web应用架构，能够扩展以满足复杂网站、表单和验证规则的需求。
    ### 总结'
- en: In this chapter, we covered strategies for validating submitted form data, including
    using an array to flexibly handle situations where zero, one, or several validation
    errors must be addressed. We highlighted the special care that must be taken when
    a 0 is submitted as a valid entry in a form. Finally, we looked at the postback
    technique for displaying and validating forms with a single script, and we implemented
    sticky forms that conveniently prefill with the user’s previous entries. As a
    PHP programmer, you may have to understand and maintain a range of website programming
    styles, and the postback approach in this chapter is a common one you’ll likely
    come across in other programmers’ code, even if it’s not an approach you use often
    when writing your own.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了验证提交的表单数据的策略，包括使用数组灵活处理需要解决零个、一个或多个验证错误的情况。我们强调了在表单中提交0作为有效条目时需要特别小心。最后，我们介绍了后置提交技术，使用单一脚本展示和验证表单，并实现了粘性表单，方便地预填充用户的上次输入。作为一名PHP程序员，你可能需要理解并维护多种网站编程风格，本章中的后置提交方法是一种常见的方式，你很可能会在其他程序员的代码中遇到它，即使你在编写自己代码时不常使用这种方法。
- en: Exercises
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 1.   Create a sticky form using the HTTP POST method that prompts for an integer
    age and redisplays the form populated with the submitted value each time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   使用HTTP POST方法创建一个粘性表单，提示输入整数年龄，并每次重新显示填写了提交值的表单。
- en: 2.   Improve your answer to Exercise 1 so that an error message is displayed
    if a non-numeric age is entered.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   改进你对练习1的回答，当输入非数字的年龄时，显示错误消息。
- en: 3.   Improve your answer to Exercise 2 so that after a valid (numeric) submission
    is received, a confirmation message displays, stating the user’s age after their
    next birthday.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   改进你对练习 2 的回答，使其在接收到有效（数字）提交后，显示确认消息，告知用户他们下一个生日后的年龄。
- en: 4.   Create a sticky form using the HTTP POST method that prompts for an email
    address. If the address is valid, a confirmation message is displayed; if it’s
    not valid, the form is redisplayed with an error message stating that the email
    address is invalid. Think about the requirements for a valid email address.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   使用 HTTP POST 方法创建一个粘性表单，要求输入电子邮件地址。如果地址有效，则显示确认消息；如果地址无效，则重新显示表单并显示错误消息，说明电子邮件地址无效。思考有效电子邮件地址的要求。
