- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Raspberry Pi (and Linux) I²C Programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派（和Linux）I²C编程
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: After the Arduino, the Raspberry Pi probably ranks second highest in I²C bus
    usage. In some respects, the I²C bus is probably even more important to Raspberry
    Pi hardware hackers than Arduino users because the Pi provides nothing in the
    way of analog-to-digital converters. Most often, Pi users add such capabilities
    to their systems using the I²C bus.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino之后，树莓派在I²C总线的使用上可能排第二。在某些方面，I²C总线对树莓派硬件黑客来说甚至比对Arduino用户更重要，因为树莓派并不提供模拟到数字转换器。树莓派用户最常通过I²C总线为系统增加这类功能。
- en: 'This chapter discusses the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了以下内容：
- en: The I²C bus on the Raspberry Pi’s GPIO header
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派GPIO头上的I²C总线
- en: How to activate the I²C bus on the Raspberry Pi (by default, it is deactivated)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在树莓派上启用I²C总线（默认情况下，它是禁用的）
- en: How to set the I²C bus speed, which may be necessary for slow peripherals as
    the Pi does not support clock stretching
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置I²C总线的速度，这对某些慢速外设可能是必要的，因为树莓派不支持时钟拉伸
- en: How to use the I²C utility package on the Pi
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在树莓派上使用I²C工具包
- en: Programming I²C devices on the Pi
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树莓派上编程I²C设备
- en: I²C on other Linux-based systems
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他基于Linux的系统上的I²C
- en: A bit-banging implementation of I²C on the Raspberry Pi to overcome some of
    the Pi’s limitations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树莓派上通过位带操作实现的I²C，以克服一些Pi的限制
- en: Although this chapter specifically discusses the Raspberry Pi single-board computer,
    Pi OS is really just a variant of the Linux operating system, so much of the information
    in this chapter covers generic Linux systems as well as the Raspberry Pi.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章特别讨论树莓派单板计算机，Pi OS实际上只是Linux操作系统的一个变种，因此本章中的许多信息也适用于通用的Linux系统以及树莓派。
- en: 9.1 The I²C Bus Pins on the Pi General-Purpose Input/Output Header
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 树莓派通用输入输出头上的I²C总线引脚
- en: The Raspberry Pi has always supported at least one I²C bus on the GPIO connector.
    Pins 3 and 5 (GPIO 2 and GPIO 3) provide the SDA and SCL lines, respectively.
    These pins were available on the original 26-pin GPIO header.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派一直支持至少一条I²C总线在GPIO连接器上。3号和5号引脚（GPIO 2和GPIO 3）分别提供SDA和SCL线路。这些引脚在原始的26针GPIO头上就有。
- en: After the introduction of the Raspberry Pi B+, the GPIO header was extended
    to 40 pins, and a second hardware I²C bus was added. This second I²C bus (on pins
    27 and 28 of the 40-pin header; see [Figure 9-1](#figure9-1)) was originally intended
    to connect to EEPROM devices on Pi HATs—Raspberry Pi add-on boards whose name
    stands for “hardware attached on top.” The I²C EEPROM device provided identification
    information for the board so the operating system could identify it and load an
    appropriate device driver in a “plug-and-play” fashion.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派B+推出后，GPIO头扩展至40个引脚，并增加了第二条硬件I²C总线。第二条I²C总线（位于40针头的27号和28号引脚；见[图9-1](#figure9-1)）最初用于连接Pi
    HAT上的EEPROM设备——Pi HAT是指“硬件附加在顶部”的树莓派附加板。I²C EEPROM设备提供了板卡的标识信息，以便操作系统能够识别它，并以“即插即用”的方式加载适当的设备驱动程序。
- en: The second I²C lines were originally intended for EEPROM, camera, and DSI display
    use. Enabling these lines could cause the display, camera, and HAT units to malfunction,
    so most programmers and system designers leave these lines alone. However, if
    you are not using any of these devices, you could use the I²C bus on pins 27 and
    28 for your own purposes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条I²C线路最初是为EEPROM、摄像头和DSI显示器使用而设计的。启用这些线路可能会导致显示器、摄像头和HAT单元出现故障，因此大多数程序员和系统设计师都会保持这些线路不变。然而，如果你不使用这些设备，你可以将I²C总线用于27号和28号引脚，按自己的需求使用。
- en: Technically, there is a third I²C bus on the HDMI connector (a 5-V variant to
    support VESA E-DDC). In theory, you could use it with a bit of work. However,
    this book will not consider the use of that bus as it’s really intended for use
    by the video display subsystem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，HDMI连接器上还有第三条I²C总线（用于支持VESA E-DDC的5V变种）。理论上，经过一些工作，你可以使用它。然而，本书不会讨论该总线的使用，因为它实际上是为视频显示子系统使用而设计的。
- en: '![](image_fi/502468c09/f09001.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c09/f09001.png)'
- en: 'Figure 9-1: Main and alternate (HAT EEPROM) I²C pins on Raspberry Pi bus'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：树莓派总线上的主I²C和备用（HAT EEPROM）I²C引脚
- en: With the arrival of the Raspberry Pi 4, the number of possible I²C buses increased
    yet again. [Figure 9-2](#figure9-2) shows the pinout of the 40-pin GPIO connector
    on the Raspberry Pi 4.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着树莓派4的推出，可用的I²C总线数量再次增加。[图9-2](#figure9-2)显示了树莓派4上40针GPIO连接器的引脚分配。
- en: '![](image_fi/502468c09/f09002.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c09/f09002.png)'
- en: 'Figure 9-2: Raspberry Pi 4 GPIO pinout'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2：树莓派4 GPIO引脚分配图
- en: '[Figure 9-2](#figure9-2) shows six I²C buses on the Raspberry Pi 4:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-2](#figure9-2) 显示了 Raspberry Pi 4 上的六个 I²C 总线：'
- en: i2c-0 SDA0 and SCL0 on pins 27 and 28
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: i2c-0 SDA0 和 SCL0 位于第 27 和 28 引脚
- en: i2c-1 SDA1 and SCL1 on pins 3 and 5
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: i2c-1 SDA1 和 SCL1 位于第 3 和 5 引脚
- en: i2c-3 SDA3 and SCL3 on pins 7 and 29
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: i2c-3 SDA3 和 SCL3 位于第 7 和 29 引脚
- en: i2c-4 SDA4 and SCL4 on pins 31 and 26
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: i2c-4 SDA4 和 SCL4 位于第 31 和 26 引脚
- en: i2c-5 SDA5 and SCL5 on pins 32 and 33
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: i2c-5 SDA5 和 SCL5 位于第 32 和 33 引脚
- en: i2c-6 SDA6 and SCL6 on pins 15 and 16 (shares these pins with i2c-0)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: i2c-6 SDA6 和 SCL6 位于第 15 和 16 引脚（与 i2c-0 共用这些引脚）
- en: Note that the i2c-1 bus on the Raspberry Pi provides pullup resistors to +3.3
    V. The remaining I²C ports do not. Therefore, if you activate any I²C bus other
    than i2c-1, you will need to add pullup resistors for the bus to work properly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Raspberry Pi 上的 i2c-1 总线提供了拉升电阻至 +3.3 V。其他 I²C 端口则没有提供。因此，如果你启用除了 i2c-1
    以外的任何 I²C 总线，你需要为该总线添加拉升电阻，以确保它能够正常工作。
- en: 9.2 Manually Activating the I²C Buses
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 手动激活 I²C 总线
- en: By default, the Raspberry Pi OS does not enable any of the I²C buses on the
    GPIO connector—those pins default to their GPIO pin definitions. You can use the
    raspi-config application to activate the I²C bus. This application will automatically
    edit appropriate system files to activate the I²C bus. If you would like to manually
    make these changes yourself, you must edit a couple files on the Raspberry Pi
    to enable the appropriate I²C bus(es).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Raspberry Pi OS 不会启用 GPIO 连接器上的任何 I²C 总线——这些引脚默认定义为 GPIO 引脚。你可以使用 raspi-config
    应用程序来激活 I²C 总线。该应用程序会自动编辑适当的系统文件以激活 I²C 总线。如果你想手动进行这些更改，必须编辑 Raspberry Pi 上的几个文件，以启用相应的
    I²C 总线。
- en: 'If you want to activate i2c-1, you will need to edit the */boot/config.txt*
    text file as the superuser. In this file you will usually find the following line:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想激活 i2c-1，你需要以超级用户身份编辑 */boot/config.txt* 文本文件。在该文件中，你通常会找到以下这一行：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `#` at the beginning of this statement turns the whole line into a comment,
    making the statement invisible to the system and the I²C bus inactivated. To activate
    the I²C bus, simply delete the `#` character at the beginning of the line.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句开头的`#`将整行变为注释，使得该语句对系统不可见，I²C 总线也被禁用。要激活 I²C 总线，只需删除该行开头的`#`字符。
- en: 'The `i2c_arm` label tells you that this particular I²C port is part of the
    ARM processor (the CPU on the Raspberry Pi). The second I²C port (pins 27 and
    28, which is really Linux port i2c-0) is part of the video controller chip. You
    could activate that I²C bus with the following statement:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_arm`标签告诉你，这个特定的 I²C 端口属于 ARM 处理器（Raspberry Pi 的 CPU）。第二个 I²C 端口（第 27 和
    28 引脚，实际上是 Linux 的 i2c-0 端口）属于视频控制器芯片。你可以使用以下语句激活该 I²C 总线：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, the Raspberry Pi documentation is pretty clear that i2c-0 is reserved
    for HAT EEPROMs and you are not supposed to use it for other purposes (see [https://github.com/raspberrypi/hats/blob/master/designguide.md](https://github.com/raspberrypi/hats/blob/master/designguide.md)).
    Abuse this suggestion at your own risk.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Raspberry Pi 的文档非常明确指出，i2c-0 是为 HAT EEPROM 预留的，不应将其用于其他目的（请参见 [https://github.com/raspberrypi/hats/blob/master/designguide.md](https://github.com/raspberrypi/hats/blob/master/designguide.md)）。滥用这一建议需自行承担风险。
- en: 'If you edit the `dtparam=i2c_arm=on` statement in */boot/config.txt* and reboot,
    you’ll discover that the I²C bus is still not available. This is because Raspberry
    Pi OS uses loadable kernel modules (LKMs) to handle I²C processing. At this point
    the system hasn’t loaded the appropriate module. To do that, execute the following
    two commands:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编辑了*/boot/config.txt*中的`dtparam=i2c_arm=on`语句并重新启动，你会发现 I²C 总线仍然不可用。这是因为
    Raspberry Pi OS 使用可加载的内核模块（LKM）来处理 I²C 相关的操作。此时，系统尚未加载相应的模块。要加载这些模块，请执行以下两条命令：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Of course, manually loading these modules every time you boot the system can
    get old fast if you’re using the I²C all the time. If you edit the */etc/modules*
    file as superuser and add the following two lines to the file, the system will
    automatically load those modules when you boot the system:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你一直使用 I²C，每次启动系统时手动加载这些模块会变得很麻烦。如果你以超级用户身份编辑*/etc/modules*文件，并将以下两行添加到该文件中，系统将在启动时自动加载这些模块：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you have a Raspberry Pi 4 system, you can enable additional I²C buses by
    adding one or more of the following lines to the */boot/config.txt* text file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 Raspberry Pi 4 系统，你可以通过将以下一行或多行添加到*/boot/config.txt*文本文件中，启用额外的 I²C 总线：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The pin numbers to which the `pins``_xx_yy` parameters refer are the GPIO pin
    numbers, not the physical pin numbers on the Pi 40-pin connector. [Table 9-1](#table9-1)
    lists the correspondence between GPIO pin numbers and physical pin numbers. See
    [https://www.raspberrypi.com/documentation/computers/os.xhtml#gpio-and-the-40-pin-header](https://www.raspberrypi.com/documentation/computers/os.xhtml#gpio-and-the-40-pin-header)
    for more information.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`pins``_xx_yy` 参数引用的引脚编号是 GPIO 引脚编号，而不是 Pi 40 引脚连接器上的物理引脚编号。[表 9-1](#table9-1)
    列出了 GPIO 引脚编号和物理引脚编号之间的对应关系。更多信息，请参见 [https://www.raspberrypi.com/documentation/computers/os.xhtml#gpio-and-the-40-pin-header](https://www.raspberrypi.com/documentation/computers/os.xhtml#gpio-and-the-40-pin-header)
    。'
- en: 'Table 9-1: GPIO Pins to Physical Pin Numbers'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1：GPIO 引脚与物理引脚编号对应关系
- en: '| **GPIO pin number** | **Connector pin number** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **GPIO 引脚编号** | **连接器引脚编号** |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GPIO 2 | Board pin 3 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| GPIO 2 | 板 pin 3 |'
- en: '| GPIO 3 | Board pin 5 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| GPIO 3 | 板 pin 5 |'
- en: '| GPIO 4 | Board pin 7 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| GPIO 4 | 板 pin 7 |'
- en: '| GPIO 5 | Board pin 29 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| GPIO 5 | 板 pin 29 |'
- en: '| GPIO 6 | Board pin 31 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| GPIO 6 | 板 pin 31 |'
- en: '| GPIO 7 | Board pin 26 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| GPIO 7 | 板 pin 26 |'
- en: '| GPIO 12 | Board pin 32 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| GPIO 12 | 板 pin 32 |'
- en: '| GPIO 13 | Board pin 33 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| GPIO 13 | 板 pin 33 |'
- en: '| GPIO 22 | Board pin 15 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| GPIO 22 | 板 pin 15 |'
- en: '| GPIO 23 | Board pin 16 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| GPIO 23 | 板 pin 16 |'
- en: 'Finally, make sure the following line is present in *config.txt*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请确保在 *config.txt* 中存在以下行：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In theory, enabling the UART (serial port) shouldn’t have anything to do with
    I²C on the Pi. In practice (at least on a Pi 3), if you don’t include this line,
    the system will run the SCL line at about 65 kHz rather than the nominal 100 kHz.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，在树莓派上启用 UART（串行端口）不应该影响 Pi 上的 I²C。但实际上（至少在 Pi 3 上），如果您不包括此行，系统将以约 65 kHz
    而不是名义上的 100 kHz 运行 SCL 线。
- en: 9.3 Changing the I²C Clock Frequency
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 改变 I²C 时钟频率
- en: 'By default, Raspberry Pi sets the I²C clock frequency to 100 kHz. To change
    the speed of the main I²C bus (i2c-1), use the following statement in */boot/config.txt*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，树莓派将 I²C 时钟频率设置为 100 kHz。要更改主 I²C 总线（i2c-1）的速度，请在 */boot/config.txt* 中使用以下语句：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: where `xxxxxx` stands for the clock frequency (for example, `100000`) that you
    want to use. Normally, you would place this statement immediately after `dtparam=i2c_arm=on`
    in that file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `xxxxxx` 代表您想要使用的时钟频率（例如 `100000`）。通常，您会将此语句直接放置在文件中 `dtparam=i2c_arm=on`
    之后。
- en: The Raspberry Pi OS will choose an available clock frequency that is less than
    or equal to the value you specify.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派 OS 将选择一个小于或等于您指定值的可用时钟频率。
- en: 'On the Raspberry Pi 4, you can set the clock frequency of i2c-3, -4, -5, and
    -6 using the following statements:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派 4 上，您可以使用以下语句设置 i2c-3、-4、-5 和 -6 的时钟频率：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once again, Pi OS will choose a clock frequency that is less than or equal to
    the actual value you specify.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，Pi OS 将选择一个小于或等于您指定的实际值的时钟频率。
- en: 9.4 I²C Clock Stretching Issues and Solutions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 I²C 时钟拉伸问题及解决方案
- en: 'At the time of writing, there has long been a known issue with the I²C protocol
    on the Raspberry Pi: the Pi does not support clock stretching. This issue seems
    to be with the hardware; it’s been around so long (and across many different Raspberry
    Pi models) that you’d expect it to have been fixed by now if it were software.
    The bottom line is that if you have an I²C device that depends on adding wait
    states via clock stretching, that device may not work very well on a standard
    Pi I²C setup.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本文时，树莓派上的 I²C 协议已经存在已久的问题：Pi 不支持时钟拉伸。这个问题似乎与硬件有关；它存在已久（跨多种不同的树莓派型号），如果这是软件问题，我们期望早就修复了。关键问题在于，如果您有一个依赖于通过时钟拉伸添加等待状态的
    I²C 设备，在标准 Pi I²C 设置上，该设备可能无法正常工作。
- en: 'This problem has two solutions. The first is a big kludge: reduce the SCL clock
    frequency using the techniques from the previous section, hoping to slow the clock
    down enough that the clock period provides enough time for the peripheral to do
    its thing. Adafruit, for example, suggests setting the I²C clock frequency (*baudrate*
    in *config.txt* notation) to 10 kHz. Ideally, this is so slow that it gives your
    peripherals sufficient time to process the I²C data.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有两个解决方案。第一个是一个大的变通办法：使用上一节中的技术减少 SCL 时钟频率，希望将时钟速度降低到足以使外设处理 I²C 数据的程度。例如，Adafruit
    建议将 I²C 时钟频率（*config.txt* 表示中的波特率）设置为 10 kHz。理想情况下，这么慢的速度可以给您的外设足够的时间来处理 I²C 数据。
- en: Slowing down the clock frequency is unsatisfactory for two main reasons. First,
    there is no guarantee that the new, slower clock frequency provides enough time
    for an arbitrary peripheral to do its work. Second, this technique slows down
    all bit transfers, including those to and from peripherals that don’t use clock
    stretching as well as all the bits that don’t need clock stretching on the devices
    that use it. In sum, this approach doesn’t guarantee success and is very inefficient
    to boot.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 降低时钟频率是不令人满意的，主要有两个原因。首先，没有保证新的、更慢的时钟频率能够为任意外设提供足够的时间来完成工作。其次，这种技术会减慢所有位传输，包括那些不使用时钟拉伸的外设，以及所有在使用时钟拉伸的设备上不需要时钟拉伸的位。总之，这种方法不能保证成功，而且效率非常低。
- en: The second solution is to use a *bit-banging* (software) I²C transmission. Software
    I²C processing can handle bit stretching properly. True, bit-banging is much slower
    and less efficient than a hardware implementation, but probably no more so than
    slowing down the hardware SCL frequency.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案是使用*位编程*（软件）I²C传输。软件I²C处理可以正确地处理位拉伸。确实，位编程比硬件实现慢得多且效率低，但可能也不会比降低硬件SCL频率更慢。
- en: 'To set up a software-controlled I²C bus using (arbitrary) GPIO pins, add the
    following statement to your */boot/config.txt* file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用（任意）GPIO引脚设置软件控制的I²C总线，请在你的*/boot/config.txt*文件中添加以下语句：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: where `x` represents a bus number, and `y` and `z` represent GPIO pins on the
    Raspberry Pi GPIO connector. This creates an I²C device using the name `i2c-``x`
    that operates on the specified GPIO pins (these are the GPIO pin number designations,
    not the physical pin numbers on the Pi GPIO connector).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`x`表示总线号，`y`和`z`表示Raspberry Pi GPIO连接器上的GPIO引脚。这将创建一个使用名称`i2c-``x`的I²C设备，且该设备在指定的GPIO引脚上运行（这些是GPIO引脚的编号，而不是Pi
    GPIO连接器上的物理引脚编号）。
- en: If the `i2c_gpio_sda` parameter is not present, the system will use GPIO 23
    as the default (physical pin 16 on the connector). If the `i2c_gpio_scl` parameter
    is not present, the system will use GPIO 24 (physical pin 18) as the default.
    If the `bus` parameter is not present, the system will dynamically assign a device
    number, so you really should explicitly provide the `bus` argument.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`i2c_gpio_sda`参数，系统将使用GPIO 23作为默认（连接器上的物理引脚16）。如果没有`i2c_gpio_scl`参数，系统将使用GPIO
    24（物理引脚18）作为默认。如果没有`bus`参数，系统将动态分配设备号，因此你确实应该显式提供`bus`参数。
- en: Note that the i2c-gpio device can use any arbitrary GPIO pins; you don’t have
    to specify pins that have I²C hardware associated with them. This means you can
    actually increase the number of supported I²C buses in the system by using software-based
    I²C devices (though, to be honest, if you need additional I²C buses, an I²C multiplexer
    is probably a better solution).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，i2c-gpio设备可以使用任何任意GPIO引脚；你不必指定与I²C硬件相关联的引脚。这意味着通过使用基于软件的I²C设备，你实际上可以增加系统中支持的I²C总线数量（尽管说实话，如果你需要额外的I²C总线，I²C多路复用器可能是一个更好的解决方案）。
- en: As a general rule, I would advise putting all I²C devices that depend on clock
    stretching on an i2c-gpio device and place all other I²C devices on hardware-based
    I²C buses to make your system more efficient.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我建议将所有依赖时钟拉伸的I²C设备放在i2c-gpio设备上，并将所有其他I²C设备放在基于硬件的I²C总线上，以提高系统效率。
- en: 9.5 Raspberry Pi OS (Linux) I²C Utilities
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 Raspberry Pi OS（Linux）I²C工具
- en: Several I²C-specific utilities are useful on the Raspberry Pi. In addition to
    these, a few normal Linux and Raspberry Pi commands are also of interest when
    working with I²C devices.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Raspberry Pi上，有几个I²C特定的工具非常有用。除了这些，还有一些常规的Linux和Raspberry Pi命令，在使用I²C设备时也很有用。
- en: 'First, to determine whether the I²C device drivers are even operational, enter
    the following Linux command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了确定I²C设备驱动程序是否能正常工作，请输入以下Linux命令：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command lists all the Linux I²C devices you can currently access. For
    example, on my Raspberry Pi 4, I got the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出了当前可以访问的所有Linux I²C设备。例如，在我的Raspberry Pi 4上，得到以下输出：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: which tells me that I²C interface 1 (i2c-1, on pins 3 and 5) and I²C interface
    6 (i2c-6, on pins 15 and 16) are currently active. Before even attempting to run
    an application that uses the I²C signals, you should issue this command to verify
    that the I²C buses are functioning.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我I²C接口1（i2c-1，在引脚3和5上）和I²C接口6（i2c-6，在引脚15和16上）目前处于活动状态。在尝试运行使用I²C信号的应用程序之前，你应该先运行此命令以验证I²C总线是否正常工作。
- en: 'The remaining four utilities I will discuss in this section are part of the
    i2c-tools package. Originally, Raspberry Pi OS did not include these tools by
    default, though later versions of Pi OS seem to include them. If they are not
    present on your system, you must download them using the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本节中讨论的剩余四个工具属于i2c-tools包。最初，Raspberry Pi OS并未默认包含这些工具，但后来的Pi OS版本似乎包含了它们。如果你的系统中没有这些工具，你必须使用以下命令下载它们：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This installs the four programs, `i2cdetect`, `i2cdump`, `i2cget`, and `i2cset`,
    on your system. The `i2cdump` utility is mainly useful for viewing the contents
    of I²C EEPROM devices. We won’t consider that application any further here; see
    the Linux man page for more information about this code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在你的系统上安装四个程序，`i2cdetect`、`i2cdump`、`i2cget`和`i2cset`。`i2cdump`工具主要用于查看I²C
    EEPROM设备的内容。在这里我们不再讨论这个应用程序；有关此代码的更多信息，请参阅Linux手册页。
- en: The `i2cget` and `i2cset` programs allow you to read a byte or word from certain
    I²C devices or write a byte or word to certain I²C devices. Because of the way
    they operate, they will prove to be of marginal value to us in this chapter. Both
    applications assume that they write a register number to the I²C address followed
    by additional data to write to that register (in the case of `i2cset`) or that
    they write a register number and then read data from the specified register number
    (in the case of `i2cget`). This works well for I²C devices such as the MCP23017
    GPIO expander IC. It does not work well for devices such as the MCP4725 DAC we’re
    using as an example in this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2cget`和`i2cset`程序允许你从某些I²C设备读取字节或字，或向某些I²C设备写入字节或字。由于它们的操作方式，它们在本章中对我们来说的价值有限。这两个应用程序假设它们首先向I²C地址写入寄存器编号，然后写入附加数据（对于`i2cset`）或写入寄存器编号后读取指定寄存器的数据（对于`i2cget`）。这种方式适用于像MCP23017
    GPIO扩展IC这样的I²C设备，但不适用于像我们本章示例中的MCP4725 DAC这样的设备。'
- en: 'To run the `i2cget` application, enter the following (the items in braces are
    optional):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`i2cget`应用程序，请输入以下内容（大括号中的项是可选的）：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: where `i2cbus` is the number of an active I²C bus (such as *1* for *i2c-1*),
    `device_address` is the 7-bit I²C address of the device to read from, `register`
    is an 8-bit register number (specifying a particular register on the device),
    and `mode` is one of the letters `b`, `w`, or `c` (corresponding to byte, word,
    or R/W byte, respectively). If the `register` operand is present, this command
    will place the I²C address on the bus and write the `register` value to the I²C
    address. On a device such as the MCP23017, this sets the register inside the IC
    to read. The next operation is a read operation, with the system reading the specified
    register value from the IC. In the case of the MCP4725, there are no registers
    you can select by first writing a byte to the IC, so you should never specify
    the `register` argument when using this command. Doing so will write a value to
    the MCP4725 and affect the analog output.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`i2cbus`是活动I²C总线的编号（例如，*1*表示*i2c-1*），`device_address`是要读取的设备的7位I²C地址，`register`是8位寄存器编号（指定设备上的特定寄存器），`mode`是字母`b`、`w`或`c`之一（分别对应字节、字或读写字节）。如果`register`操作数存在，该命令将在总线上放置I²C地址并将`register`值写入I²C地址。在如MCP23017之类的设备上，这会设置IC内部的寄存器以供读取。下一步是读取操作，系统将从IC中读取指定的寄存器值。以MCP4725为例，由于你不能通过首先向IC写入字节来选择寄存器，因此在使用此命令时，你不应指定`register`参数。这样做会向MCP4725写入值，并影响模拟输出。
- en: Unfortunately, the `i2cget` application is poorly matched to the MCP4725\. The
    MCP4725 returns 5 bytes of data when you read from the chip. The `i2cget` command
    will read a maximum of 2 bytes. There is no real way to use this command to read
    all the MCP4725 data, so we will ignore this command until Chapter 13.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`i2cget`应用程序与MCP4725不太兼容。MCP4725在读取芯片时会返回5字节的数据。`i2cget`命令最多只能读取2个字节。由于没有真正的方法使用此命令读取所有MCP4725数据，因此我们将在第13章中忽略该命令。
- en: 'The `i2cset` command is the output version of the `i2cget` program. It has
    the following syntax:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2cset`命令是`i2cget`程序的输出版本。它具有以下语法：'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'where `i2cbus` and `device_address` have the same meanings as for the `i2cget`
    command. The `data_address` argument is effectively the same thing as the `register`
    operand in the `i2cget` command: it’s a byte value that is written to the IC immediately
    after the address byte is placed on the bus with the assumption that this is selecting
    some register on the IC.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`i2cbus`和`device_address`的含义与`i2cget`命令中的相同。`data_address`参数实际上与`i2cget`命令中的`register`操作数相同：它是一个字节值，在地址字节放到总线上之后立即写入IC，假设这是选择IC上的某个寄存器。
- en: 'Again, the fact that it expects to be able to write a register (`data_address`)
    makes this program somewhat incompatible with the MCP4725 DAC. However, with some
    hackery, this one can actually be made to work with the DAC. The MCP4725 expects
    a 3-byte transmission (for the Fast Mode Write command). The first byte, of course,
    is the address and R/W bit, the second byte is the HO 4 bits of the 12-bit DAC
    value, and the third byte is the LO 8 bits of the DAC value. As it turns out,
    the `i2cset` command can be coerced to output this data using the following syntax:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于该程序期望能够写入寄存器（`data_address`），它与MCP4725 DAC存在一些不兼容性。然而，通过一些技巧，实际上可以使其与DAC一起工作。MCP4725期望一个3字节的传输（用于快速模式写入命令）。第一个字节当然是地址和读写位，第二个字节是12位DAC值的高4位，第三个字节是DAC值的低8位。事实证明，`i2cset`命令可以通过以下语法强制输出此数据：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: where `HOByte` is the upper 4 bits of the DAC output value and `LOByte` is the
    lower 8 bits of the DAC value.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`HOByte`是DAC输出值的高4位，`LOByte`是DAC值的低8位。
- en: Of the four utilities in the i2c-tools package, the `i2cdetect` program is,
    without question, the most useful of the batch. As its name suggests, this program
    detects I²C devices on the I²C bus. This program has three main forms, which the
    following paragraphs describe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在i2c-tools软件包中的四个实用程序中，`i2cdetect`程序无疑是最有用的。顾名思义，该程序用于检测I²C总线上的I²C设备。该程序有三种主要形式，下面的段落将对其进行描述。
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first form scans the system for all available I²C buses and displays them.
    Note that the command-line option is `l` (the letter L, for *list*), not `1` (one).
    This command is similar to using `ls /dev/i2c*` to identify available I²C buses.
    Executing this command on a Raspberry Pi 3 with I²C enabled, I get the following
    output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种形式扫描系统中所有可用的I²C总线并显示它们。请注意，命令行选项是`l`（字母L，表示*列出*），而不是`1`（数字1）。此命令类似于使用`ls
    /dev/i2c*`来识别可用的I²C总线。在启用了I²C的Raspberry Pi 3上执行此命令时，我得到以下输出：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second form of the `i2cdetect` command outputs status and capability information
    about the I²C bus you specify as an argument:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2cdetect`命令的第二种形式输出关于指定I²C总线的状态和能力信息：'
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s some sample output on the Raspberry Pi for `i2c-1`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Raspberry Pi上`i2c-1`的示例输出：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For a description of these Linux-kernel level functionalities, visit [https://www.kernel.org/doc/html/latest/i2c/functionality.xhtml](https://www.kernel.org/doc/html/latest/i2c/functionality.xhtml).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些Linux内核级功能的描述，请访问[https://www.kernel.org/doc/html/latest/i2c/functionality.xhtml](https://www.kernel.org/doc/html/latest/i2c/functionality.xhtml)。
- en: 'The third form of the `i2cdetect` command scans the bus looking for valid I²C
    devices and (if possible) reports their presence:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2cdetect`命令的第三种形式扫描总线，寻找有效的I²C设备，并（如果可能）报告它们的存在：'
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: where `bus` is an I²C bus specification (either an integer such as `1` or the
    bus name such as `i2c-1`). The optional `first` and `last` parameters are device
    addresses (with `first` < `last`) that limit the range of I²C bus addresses that
    `i2cdetect` will scan.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`bus`是I²C总线规格（可以是一个整数，如`1`，也可以是总线名称，如`i2c-1`）。可选的`first`和`last`参数是设备地址（`first`
    < `last`），用于限制`i2cdetect`扫描的I²C总线地址范围。
- en: 'Generally, use the command as follows or supply a different bus value as the
    argument:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用以下命令，或者传入不同的总线值作为参数：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After entering the command, you’ll get a warning prompt that this command may
    mess with I²C devices on the bus. Knowing this, you’ll be asked to verify that
    you want the command to probe the bus.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输入命令后，您将看到一个警告提示，说明此命令可能会干扰总线上的I²C设备。了解这一点后，系统会要求您确认是否希望该命令探测总线。
- en: 'If you would prefer not to respond to this prompt when running `i2cdetect`
    (for example, from within a shell script), add the `-y` option, which tells the
    program “answer yes to the question”:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在运行`i2cdetect`时跳过此提示（例如，在shell脚本中运行时），可以添加`-y`选项，告诉程序“自动回答是”：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This matrix shows the valid I²C addresses and whether `i2cdetect` has found
    a device at that address. The `--` entries indicate that `i2cdetect` doesn’t believe
    a device is at that address, and a hexadecimal number in the matrix indicates
    that a device exists at that address. In this case, `i2cdetect` found two devices
    at addresses 0x04 (probably the Broadcom I²C hardware, as that address is reserved
    for high-speed controllers) and 0x62 (the Adafruit MCP4725 I currently have wired
    to the bus).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵显示了有效的I²C地址以及`i2cdetect`是否在该地址找到设备。`--`条目表示`i2cdetect`认为该地址上没有设备，而矩阵中的十六进制数字表示该地址上存在设备。在这个例子中，`i2cdetect`在地址0x04（可能是Broadcom
    I²C硬件，因为该地址保留给高速控制器）和地址0x62（我当前连接到总线的Adafruit MCP4725设备）找到了两个设备。
- en: If a `UU` appears in one of the matrix entries, a device is installed at that
    address but is currently in use by the kernel, which commonly occurs, for example,
    when you’ve hooked a real-time clock (RTC) to the system to set the date and time
    automatically when the system boots.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩阵中的某个条目显示`UU`，说明该地址上安装了一个设备，但该设备当前正在被内核使用，例如，当你将实时时钟（RTC）连接到系统，以便在系统启动时自动设置日期和时间时，通常会发生这种情况。
- en: As noted in Chapter 2, the I²C bus does not provide a standardized mechanism
    for detecting devices. SMBus devices, in particular, can react in a bad way with
    simple attempts to read or write the device without a data payload. Therefore,
    it is possible for the `i2cdetect` program to change the state of an I²C device
    on the bus just by probing for it, which is why `i2cdetect` asks you to verify
    that you really want to scan the bus before it transmits data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2章所述，I²C总线没有提供标准化的设备检测机制。特别是，SMBus设备可能会在没有数据载荷的情况下简单地尝试读取或写入设备时产生不良反应。因此，`i2cdetect`程序可能仅通过探测就会改变I²C设备在总线上的状态，这也是为什么在传输数据之前，`i2cdetect`要求你确认是否真的要扫描总线的原因。
- en: 'Because `i2cdetect` can mess with certain types of peripherals on the bus,
    it offers an option to limit the scanning to a certain range of addresses. For
    example, if you know an MCP4725 DAC is installed but don’t know what address it’s
    connected to, use the following command to search for the DAC:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`i2cdetect`可能会干扰总线上某些类型的外设，它提供了一个选项来限制扫描的地址范围。例如，如果你知道安装了一个MCP4725 DAC，但不知道它连接到哪个地址，可以使用以下命令来搜索DAC：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `0x60` and `0x67` arguments limit the scanning range of the program (we
    know that the MCP4725 must have an address in the range of 0x60 to 0x67 because
    of its hardware design).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x60`和`0x67`参数限制了程序的扫描范围（我们知道MCP4725的地址必须在0x60到0x67范围内，因为它的硬件设计决定了这个范围）。'
- en: The `-q` (quick write) and `-r` (quick read) arguments are advanced options,
    and using those options can corrupt EEPROMs or hang the system. See the `i2cdetect`
    man page for details and seriously consider what you are doing before using those
    options.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`-q`（快速写入）和`-r`（快速读取）参数是高级选项，使用这些选项可能会损坏EEPROM或导致系统挂起。请参阅`i2cdetect`手册页面了解详细信息，并在使用这些选项之前认真考虑你的操作。'
- en: 9.6 Reading and Writing I²C Data
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 读取和写入I²C数据
- en: Once you have installed and initialized the I²C drivers, transmitting and receiving
    data on the I²C bus is relatively straightforward. Like most devices, Raspberry
    Pi OS (Linux) treats the I²C bus like a file. You open the device driver as a
    file and then read and write data using the Linux `read()` and `write()` functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装并初始化了I²C驱动程序，I²C总线上的数据传输和接收就相对简单了。像大多数设备一样，树莓派操作系统（Linux）将I²C总线视为文件。你像打开文件一样打开设备驱动程序，然后使用Linux的`read()`和`write()`函数读取和写入数据。
- en: 'First, call the Linux `open()` function to get a file handle associated with
    the I²C bus:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，调用Linux的`open()`函数获取与I²C总线关联的文件句柄：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: where `handle` is an integer (file descriptor) type and `busName` is a string
    containing the device name for the I²C bus you want to use. Bus names are the
    */dev/i2c** names for the buses you’ve defined in the */boot/config.txt* file.
    For example, the standard I²C bus is */dev/i2c-1*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`handle`是整数（文件描述符）类型，`busName`是一个包含你要使用的I²C总线设备名称的字符串。总线名称是你在`/boot/config.txt`文件中定义的*/dev/i2c**名称。例如，标准的I²C总线是*/dev/i2c-1*。
- en: The `open()` function returns a negative number on an error and a non-negative
    file handle value if it is successful. Save the file handle value so you can read
    and write data later.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()`函数在出错时返回负数，成功时返回非负的文件句柄值。保存文件句柄值，以便稍后可以读取和写入数据。'
- en: 'Before accessing the I²C bus, you must set the address of the peripheral device
    you want to access using the Linux `ioctl()` (I/O control) function, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问I²C总线之前，必须使用Linux的`ioctl()`（I/O控制）函数设置要访问的外设设备的地址，方法如下：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: where `result` is an integer variable that holds the error return result, `handle`
    is the handle the `open()` function call returns, and `i2cAddr` is the 7-bit address
    of the peripheral to access.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`result`是一个整数变量，用于存储错误的返回结果，`handle`是`open()`函数调用返回的句柄，`i2cAddr`是要访问的外设的7位地址。
- en: You can call `ioctl()` multiple times on the same file handle in order to access
    different peripherals on the same I²C bus. Raspberry Pi OS will continue to use
    the same peripheral address for all read and write operations until you explicitly
    change it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一个文件句柄上多次调用`ioctl()`，以便在同一I²C总线上访问不同的外设。树莓派操作系统将继续使用相同的外设地址进行所有读写操作，直到你显式更改它。
- en: 'To read data from an I²C peripheral, you use the Linux `read()` function using
    the following syntax:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要从I²C外设读取数据，可以使用Linux的`read()`函数，语法如下：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: where `result` is an integer variable that will hold the function return result
    (a negative if an error or number of bytes read if non-negative), `handle` is
    the I²C bus handle returned by `open()`, `buffer` is an array of bytes that will
    receive the data, and `bufferSize` is the number of bytes to read. If everything
    happens correctly, the function returns `bufferSize` as the result.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`result`是一个整数变量，用于存储函数返回结果（如果发生错误则为负值，如果读取字节数为非负值，则为读取的字节数），`handle`是`open()`函数返回的I²C总线句柄，`buffer`是一个字节数组，用于接收数据，`bufferSize`是要读取的字节数。如果一切正常，函数将返回`bufferSize`作为结果。
- en: 'To write data to the peripheral, use the `write` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据写入外设，使用`write`函数：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The arguments are the same as for `read()` except the buffer holds the data
    to be written (rather than being a storage location for the data read).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 参数与`read()`相同，不同之处在于缓冲区存储要写入的数据（而不是存储读取数据的位置）。
- en: The program in [Listing 9-1](#listing9-1) demonstrates reading and writing data
    on the I²C bus using the `open()`, `read()`, `write()`, and `ioctl()` functions.
    As in the previous chapter, this program emits a triangle wave on the MCP4725
    DAC outputs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单9-1](#listing9-1)中的程序演示了如何使用`open()`、`read()`、`write()`和`ioctl()`函数在I²C总线上读取和写入数据。与前一章一样，这个程序在MCP4725
    DAC输出端口上发出三角波。'
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In [Listing 9-1](#listing9-1), the Linux filename for the main Raspberry Pi
    I²C port is `"/dev/i2c-1"` ❶. To write to the Raspberry Pi I²C port, open it like
    a file ❷. To read or write a particular I²C address, you must first issue an `ioctl()`
    call with the `I2C_SLAVE` argument and the I²C address to use. From that point
    forward (until another `ioctl()` call changes the address), reads and writes to
    the I²C bus will use this address ❸. To read data from the I²C bus, just call
    the `read()` function specifying the file handle returned by the earlier `open()`
    call for the I²C port ❹. To write data to the I²C bus, call the `write()` function
    and specify the I²C file handle ❺.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单9-1](#listing9-1)中，树莓派I²C主端口的Linux文件名是`"/dev/i2c-1"` ❶。要写入树莓派I²C端口，像打开文件一样打开它
    ❷。要读取或写入特定的I²C地址，必须首先发出带有`I2C_SLAVE`参数和要使用的I²C地址的`ioctl()`调用。从那时起（直到另一个`ioctl()`调用更改地址为止），对I²C总线的读写将使用此地址
    ❸。要从I²C总线读取数据，只需调用`read()`函数，指定先前`open()`调用返回的I²C端口的文件句柄 ❹。要将数据写入I²C总线，调用`write()`函数并指定I²C文件句柄
    ❺。
- en: '[Figure 9-3](#figure9-3) shows the DAC output on an oscilloscope.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-3](#figure9-3)显示了示波器上的DAC输出。'
- en: '![](image_fi/502468c09/f09003.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c09/f09003.png)'
- en: 'Figure 9-3: Triangle wave output from Raspberry Pi 3'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3：树莓派3的三角波输出
- en: The output is only 3.3 V (rather than 5 V) because the Pi is a 3.3-V machine
    (I’m running the MCP4725 at 3.3 V, though you could run it at 5 V as long as the
    SCL and SDA lines are 3.3 V).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出只有3.3 V（而不是5 V），因为树莓派是3.3 V的设备（我在3.3 V下运行MCP4725，尽管你可以在5 V下运行它，只要SCL和SDA线是3.3
    V）。
- en: 9.7 Advanced I²C Kernel Calls
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 高级I²C内核调用
- en: Although using `open()`, `read()`, `write()`, and `ioctl()` works reasonably
    well for simple I²C bus transactions, various forms of the `ioctl()` function
    provide more advanced operations called *kernel function calls*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用`open()`、`read()`、`write()`和`ioctl()`对于简单的I²C总线事务来说相当有效，但`ioctl()`函数的不同形式提供了更多高级操作，称为*内核函数调用*。
- en: 'The kernel function calls take place through the Linux `ioctl()` API function.
    You marshal up some parameters in a data structure along with a function identifier
    and call `ioctl()`. The `ioctl()` function decodes its arguments and then passes
    the parameters along to the specified function. That function returns appropriate
    function results (via the `ioctl()` return value and the parameter list you pass
    to `ioctl()`). Consider the following `i2c_smbus_access()` function that sets
    parameters for various Linux SMBus (I²C) function calls:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数调用通过 Linux `ioctl()` API 函数进行。你将一些参数封装在一个数据结构中，并附带一个函数标识符，然后调用 `ioctl()`。`ioctl()`
    函数解码其参数，并将参数传递给指定的函数。该函数返回适当的函数结果（通过 `ioctl()` 返回值和你传递给 `ioctl()` 的参数列表）。考虑以下
    `i2c_smbus_access()` 函数，它为各种 Linux SMBus（I²C）函数调用设置参数：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This function copies its arguments into a local data structure (`args`) and
    then passes them on to the `ioctl()` function with the `I2C_SMBUS` argument that
    tells `ioctl()` to call one of the SMBus functions; the `args.command` parameter
    specifies the particular function to call. Most of the `I2C_SMBUS` functions use
    the same parameter list: the `read_write`, `size`, and `data` fields of the `args`
    structure.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将其参数复制到一个本地数据结构（`args`）中，然后将它们与 `I2C_SMBUS` 参数一起传递给 `ioctl()` 函数，告诉 `ioctl()`
    调用其中一个 SMBus 函数；`args.command` 参数指定要调用的特定函数。大多数 `I2C_SMBUS` 函数使用相同的参数列表：`args`
    结构中的 `read_write`、`size` 和 `data` 字段。
- en: 'Note that `i2c_smbus_access()` isn’t actually a specific SMBus function. It’s
    the function that marshals the arguments and passes them on to `ioctl()`, a *dispatcher
    function*: a single entry point (into the OS in this case) that transfers (dispatches)
    control to one of several different functions. An example of a specific SMBus
    function is `i2c_smbus_read_byte()`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`i2c_smbus_access()` 实际上并不是一个特定的 SMBus 函数。它是一个将参数封装并传递给 `ioctl()` 的函数，一个
    *分发函数*：一个单一的入口点（在本例中是操作系统），将控制（分发）传递给多个不同的函数之一。一个特定的 SMBus 函数示例是 `i2c_smbus_read_byte()`：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function uses `i2c_smbus_access()` to marshal the parameters and make the
    actual call to `ioctl()`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用 `i2c_smbus_access()` 来封装参数并实际调用 `ioctl()`。
- en: The following subsections describe the SMBus functions available via the `ioctl()`
    dispatcher. While some of these functions are very SMBus specific, many of them
    are quite useful for normal I²C operations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下子章节描述了通过 `ioctl()` 分发器可以使用的 SMBus 函数。虽然其中一些函数非常特定于 SMBus，但许多函数对于普通的 I²C 操作非常有用。
- en: 9.7.1 The i2c-dev Functions
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.1 i2c-dev 函数
- en: 'The *linux/i2c-dev.h* header file defines the SMBus functions that follow.
    The `apt-get install libi2c-dev` command entered earlier in this chapter installs
    this header file so you can use this library in your applications. You do not
    have to link a specific library against your code to use these functions, because
    the `i2c-dev` functions are installed as part of the kernel (or a loadable module)
    and accessed via the `ioctl()` API call. To access these functions, include the
    following statements at the beginning of your C/C++ applications:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*linux/i2c-dev.h* 头文件定义了以下的 SMBus 函数。前面章节中输入的 `apt-get install libi2c-dev`
    命令会安装这个头文件，从而让你在应用程序中使用此库。你不需要在代码中链接特定的库来使用这些函数，因为 `i2c-dev` 函数作为内核（或可加载模块）的一部分安装，并通过
    `ioctl()` API 调用来访问这些函数。要访问这些函数，请在 C/C++ 应用程序的开头包含以下语句：'
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The header file itself contains the function definitions that the following
    sections describe. They are all *static inline* functions, so the compiler expands
    them (as macros) directly in place of the calls you make.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件本身包含了以下章节描述的函数定义。它们都是 *static inline* 函数，因此编译器会直接在你调用的地方（作为宏）展开它们。
- en: This header file, through its own includes, defines the types shown in [Table
    9-2](#table9-2).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自身的包含文件，此头文件定义了[表 9-2](#table9-2)中显示的类型。
- en: 'Table 9-2: Integer Types'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2：整数类型
- en: '| **Type** | **Meaning** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **含义** |'
- en: '| --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| __u8 | Unsigned 8-bit integer |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| __u8 | 无符号 8 位整数 |'
- en: '| __u16 | Unsigned 16-bit integer |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| __u16 | 无符号 16 位整数 |'
- en: '| __u32 | Unsigned 32-bit integer |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| __u32 | 无符号 32 位整数 |'
- en: '| __s8 | Signed 8-bit integer |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| __s8 | 有符号 8 位整数 |'
- en: '| __s16 | Signed 16-bit integer |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| __s16 | 有符号 16 位整数 |'
- en: '| __s32 | Signed 32-bit integer |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| __s32 | 有符号 32 位整数 |'
- en: You must pass the following functions a file handle specifying the I²C bus to
    use. You obtain the file handle using the `open()` function (see section 9.6,
    “Reading and Writing I²C Data,” earlier in this chapter). You do not pass these
    functions a device address. Instead, specify the device address to use with an
    `ioctl()` call, for example, `ioctl(``handle``, I2C_SLAVE,` `i2cAddr``)`. Once
    you set the device address for a given I²C bus (specified by the `handle`), that
    address remains in effect until you explicitly change it with another `ioctl()`
    call.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须传递以下函数一个指定I²C总线的文件句柄。你可以通过`open()`函数获取文件句柄（见本章9.6节，“读取和写入I²C数据”）。你不需要传递设备地址给这些函数。相反，你需要通过`ioctl()`调用指定要使用的设备地址，例如，`ioctl(``handle``,
    I2C_SLAVE, `i2cAddr`)`。一旦为特定I²C总线（通过`handle`指定）设置了设备地址，该地址将保持有效，直到你明确通过另一个`ioctl()`调用更改它。
- en: The following functions all return `-1` if an error occurs. The `write()` functions
    return `0` if they are successful. The `read()` functions will either return the
    value read from the bus (when reading a single value) or return the number of
    bytes read when reading a block of bytes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数如果发生错误都会返回`-1`。`write()`函数成功时返回`0`。`read()`函数会返回从总线读取的值（当读取单个值时），或者在读取字节块时返回读取的字节数。
- en: 9.7.2 The i2c_smbus_write_quick Function
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.2 i2c_smbus_write_quick函数
- en: 'The `i2c_smbus_write_quick()` function writes a single bit value to an I²C
    device:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_smbus_write_quick()`函数向I²C设备写入单一的位值：'
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this function, `file` is a file handle returned by the open function (generally
    specifying the I²C device, such as i2c-1), while `value` is the bit value (0 or
    1) to write to the I²C bus specified by `file`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，`file`是由open函数返回的文件句柄（通常指定I²C设备，例如i2c-1），而`value`是要写入指定I²C总线的位值（0或1）。
- en: This function writes a single bit to the I²C bus. The data payload is buried
    in the R/W bit of the address byte transmitted on the bus. This function transmits
    the start condition, the address byte (with data payload in R/W), and a stop condition.
    There are no data bytes transmitted as part of this operation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将一个单一的位写入I²C总线。数据负载被封装在总线上传输的地址字节的R/W位中。这个函数传输起始条件、地址字节（数据负载在R/W位中）以及停止条件。在这个操作中不会传输数据字节。
- en: 9.7.3 The i2c_smbus_read_byte Function
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.3 i2c_smbus_read_byte函数
- en: 'The `i2c_smbus_read_byte()` function reads a single byte from the I²C bus.
    Here is the prototype:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_smbus_read_byte()`函数从I²C总线读取一个字节。以下是该函数的原型：'
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function returns a single byte from the I²C device on the bus specified
    by the file handle you pass as an argument (the device address was set up earlier
    with an `ioctl()` call). The function transmits a start condition and an address
    byte to the device. It then reads the response byte from the device. Finally,
    it transmits the stop condition.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数从通过文件句柄传递的I²C设备中返回一个字节（设备地址此前已通过`ioctl()`调用设置）。该函数首先向设备传输起始条件和地址字节。然后，它从设备读取响应字节。最后，传输停止条件。
- en: Do not use this function to read a sequence of bytes from an I²C device—for
    example, reading all the status information from an MCP4725\. Because it brackets
    the address and data values with start and stop conditions, you’ll likely wind
    up reading just the first byte of the data sequence twice in a row. The program
    in [Listing 9-2](#listing9-2) demonstrates this problem.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用这个函数从I²C设备读取字节序列——例如，从MCP4725读取所有状态信息。由于它将地址和值包围在起始和停止条件之间，你可能会发现读取到的数据序列的第一个字节会被重复读取两次。[清单9-2](#listing9-2)中的程序演示了这个问题。
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When connected to a SparkFun MCP4725 at address 0x60, the program in [Listing
    9-2](#listing9-2) produced the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到地址为0x60的SparkFun MCP4725时，[清单9-2](#listing9-2)中的程序输出如下：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The program just read the status information byte twice. When reading data from
    non-SMBus devices (such as the MCP4725), use standard I²C read operations; save
    this function for actual SMBus devices.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 程序只是读取了状态信息字节两次。当从非SMBus设备（如MCP4725）读取数据时，使用标准的I²C读取操作；将此函数保留给实际的SMBus设备使用。
- en: 9.7.4 The i2c_smbus_write_byte() Function
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.4 i2c_smbus_write_byte()函数
- en: 'The `i2c_smbus_write_byte()` function writes a single byte to an I²C device:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_smbus_write_byte()`函数向I²C设备写入单个字节：'
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `file` argument is a handle specifying the bus (device), and `value` is
    the byte to transmit on the bus. This function transmits a start condition, an
    address byte, a data byte, and, finally, a stop condition.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`参数是指定总线（设备）的句柄，`value`是要在总线上传输的字节。此函数传输起始条件、地址字节、数据字节，最后是停止条件。'
- en: As with the `i2c_smbus_read_byte()` function, do not use this function to write
    a sequence of bytes to an I²C device (such as writing the DAC value to an MCP4725).
    Because it brackets the address and data values with start and stop conditions,
    you’ll likely wind up writing only the first byte of the data sequence twice in
    a row.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与`i2c_smbus_read_byte()`函数一样，不要使用此函数向I²C设备写入字节序列（例如，将DAC值写入MCP4725）。由于它在地址和数据值之间加上起始和停止条件，你可能最终只会连续两次写入数据序列的第一个字节。
- en: 9.7.5 The i2c_smbus_read_byte_data() Function
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.5 `i2c_smbus_read_byte_data()`函数
- en: The `i2c_smbus_read_byte_data()` function writes a register number to an I²C
    device and then reads a data byte (presumably from the register specified by the
    write operation). The prototype is
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_smbus_read_byte_data()`函数将一个寄存器号写入I²C设备，然后读取一个数据字节（假设来自写操作指定的寄存器）。其原型为：'
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: where `file` is the file handle specifying the I²C device and `command` is a
    register number or command byte to write to the device before reading from it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`file`是指定I²C设备的文件句柄，`command`是写入设备的寄存器号或命令字节，然后再进行读取操作。
- en: This function transmits the start condition, the address byte with the R/W set
    to 0 (write), and then the `command` byte. Then it sends a (re)start condition,
    followed by another address byte (this time with the R/W bit set to 1). The peripheral
    responds by transmitting a data byte and then the controller puts a stop condition
    on the bus. The program in [Listing 9-3](#listing9-3) demonstrates this call.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数传输起始条件，地址字节（R/W位设置为0，即写操作），然后是`command`字节。接着，它发送一个（重新）起始条件，随后发送另一个地址字节（这次R/W位设置为1，即读操作）。外设响应并传输一个数据字节，然后控制器在总线上发送停止条件。[Listing
    9-3](#listing9-3)中的程序演示了这个调用。
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Figure 9-4](#figure9-4) shows the logic analyzer output when running the program
    in [Listing 9-3](#listing9-3). As you can see from this image, the `i2c_smbus_read_byte_data()`
    function call emits two I²C operations: a write operation (writing the byte 0,
    which was the command argument in the call) and a read operation, which winds
    up reading 0xC0 from the DAC (the status byte). You can’t see it because [Figure
    9-4](#figure9-4) is not in color, but between the two transmissions is a restart
    condition: a start condition without a stop condition from the previous transmission
    (the dot between the commands).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-4](#figure9-4)显示了运行[Listing 9-3](#listing9-3)程序时逻辑分析仪的输出。从该图中可以看出，`i2c_smbus_read_byte_data()`函数调用发出了两个I²C操作：一个写操作（写入字节0，这是调用中的命令参数）和一个读操作，最终从DAC读取0xC0（状态字节）。你看不见这一点，因为[图9-4](#figure9-4)是黑白的，但在两个传输之间有一个重启条件：一个没有停止条件的起始条件（命令之间的点）。'
- en: '![](image_fi/502468c09/f09004.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c09/f09004.png)'
- en: 'Figure 9-4: Logic analyzer output when running the program in [Listing 9-3](#listing9-3)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-4：运行[Listing 9-3](#listing9-3)程序时逻辑分析仪的输出
- en: Normally, you would not use this function on an MCP4725 DAC device. Writing
    a single byte wipes out the HO 4 bits of the output value (without affecting the
    LO byte). Of course, reading a single byte does very little good as well, unless
    you’re interested only in the status byte from the MCP4725.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会在MCP4725 DAC设备上使用此函数。写入单个字节会清除输出值的高4位（不会影响低字节）。当然，读取单个字节也没什么意义，除非你只对MCP4725的状态字节感兴趣。
- en: Generally, you would use this function to talk to a more sophisticated device
    that requires writing a command or register byte before reading a byte back from
    the device, which is a common sequence with SMBus devices. For example, the MCP23017
    GPIO expander IC works in this fashion.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会使用此函数与更复杂的设备进行通信，这些设备需要在读取设备中的字节之前先写入命令或寄存器字节，这是与SMBus设备常见的操作顺序。例如，MCP23017
    GPIO扩展器IC就是这样工作的。
- en: The big difference between this function call and a call to write a byte followed
    by a call to read a byte is that the latter form would emit a stop condition after
    writing the first byte. This stop condition would reset the state machine logic
    of devices, such as the MCP23017, and might cause it to treat the second write
    as an independent operation, leaving the bus vulnerable to a different controller
    sending data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数调用与写一个字节后再读一个字节的调用之间的主要区别在于，后者在写入第一个字节后会发出停止条件。这个停止条件会重置设备（如 MCP23017）的状态机逻辑，可能会导致它将第二次写入当作独立操作处理，从而使总线容易受到其他控制器发送数据的干扰。
- en: 9.7.6 The i2c_smbus_write_byte_data() Function
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.6 `i2c_smbus_write_byte_data()` 函数
- en: 'The `i2c_smbus_write_byte_data()` function writes a byte to specify an I²C
    device register and then writes a second byte to that register. This is its prototype:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_smbus_write_byte_data()` 函数将一个字节写入以指定 I²C 设备寄存器，然后将第二个字节写入该寄存器。其原型如下：'
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Like the `i2c_smbus_read_byte_data()` function, this call is mainly intended
    for use when communicating with devices such as the MCP23017 GPIO expander that
    expect you to transmit a register number immediately before transmitting the data
    byte.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `i2c_smbus_read_byte_data()` 函数一样，此调用主要用于与像 MCP23017 GPIO 扩展器这样的设备进行通信，这些设备要求在传输数据字节之前立即传输寄存器号。
- en: 9.7.7 The i2c_smbus_read_word_data() Function
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.7 `i2c_smbus_read_word_data()` 函数
- en: 'The `i2c_smbus_read_word_data()` function writes a register number to an I²C
    device and then reads a pair of bytes from the device (presumably from the specified
    register). This is its prototype:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_smbus_read_word_data()` 函数将一个寄存器号写入 I²C 设备，然后从设备读取一对字节（假定来自指定寄存器）。其原型如下：'
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function is similar to `i2c_smbus_read_byte_data()` except that it reads
    2 bytes (a word) after writing the `command` byte to the I²C bus.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数类似于 `i2c_smbus_read_byte_data()`，不同之处在于它在将 `command` 字节写入 I²C 总线后，读取 2 个字节（一个字）。
- en: 'When this function executes, the following I²C bus transactions occur:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当此函数执行时，以下 I²C 总线事务将发生：
- en: A start condition is sent.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一个启动条件。
- en: The address byte with an R/W bit of 0 is sent.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有 R/W 位为 0 的地址字节被发送。
- en: The `command` byte is sent.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送 `command` 字节。
- en: A (re)start condition is sent.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一个（重新）启动条件。
- en: The address byte with an R/W bit of 1 is sent.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有 R/W 位为 1 的地址字节被发送。
- en: Two bytes are read from the peripheral device.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从外设设备读取 2 个字节。
- en: A stop condition is sent.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送停止条件。
- en: This function reads the bytes back in little-endian order; that is, the first
    byte it reads from the bus is the LO byte, and the second byte it reads is the
    HO byte, which is often reversed from the way data actually arrives. For example,
    when using this function to read the MCP4725 DAC, the word comes back with the
    status byte in the LO 8 bits and the next byte read (which turns out, coincidentally,
    to be the HO 8 bits of the last DAC value written) in the HO byte. Be aware of
    that issue when using this function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数按小端字节顺序读取字节；也就是说，它从总线读取的第一个字节是 LO 字节，第二个字节是 HO 字节，这通常与数据实际到达的顺序相反。例如，在使用此函数读取
    MCP4725 DAC 时，返回的字是状态字节位于 LO 8 位，接下来读取的字节（恰好是上次写入的 DAC 值的 HO 8 位）在 HO 字节中。在使用此函数时，请注意这个问题。
- en: 9.7.8 The i2c_smbus_write_word_data() Function
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.8 `i2c_smbus_write_word_data()` 函数
- en: 'The `i2c_smbus_write_word_data()` function writes 3 bytes to an I²C device:
    the first byte specifies a register number, and the next 2 bytes are a word value
    that is written to that register. This is its prototype:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_smbus_write_word_data()` 函数将 3 个字节写入 I²C 设备：第一个字节指定寄存器号，接下来的 2 个字节是写入该寄存器的字值。其原型如下：'
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This function is similar to `i2c_smbus_write_byte_data()`, except that it writes
    2 bytes (a word) after writing the `command` byte to the I²C bus. Note that this
    function writes the bytes in little-endian order. Be aware of this issue when
    using this function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数类似于`i2c_smbus_write_byte_data()`，不同之处在于它在将 `command` 字节写入 I²C 总线后，写入 2 个字节（一个字）。请注意，这个函数按小端字节顺序写入字节。在使用这个函数时，请注意这个问题。
- en: 'When this function executes, the following I²C bus transactions occur:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当此函数执行时，以下 I²C 总线事务将发生：
- en: A start condition is sent.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一个启动条件。
- en: The address byte with an R/W bit of 0 is sent.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有 R/W 位为 0 的地址字节被发送。
- en: The command byte is sent.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送命令字节。
- en: The LO byte of value is sent.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值的 LO 字节被发送。
- en: The HO byte of value is sent.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值的 HO 字节被发送。
- en: A stop condition is sent.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送停止条件。
- en: Note that, unlike the read word function, only a single address byte is sent
    with no restart conditions. This function simply writes 3 bytes (a command and
    2 data bytes) after the address byte. The first byte, presumably, is a register
    or command byte followed by 2 data bytes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与读取字函数不同，此函数仅发送一个地址字节，不需要重新启动条件。该函数仅在地址字节后写入3个字节（一个命令字节和2个数据字节）。第一个字节很可能是寄存器或命令字节，后面跟着2个数据字节。
- en: 9.7.9 The i2c_smbus_read_block_data() Function
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.9 i2c_smbus_read_block_data()函数
- en: 'The `i2c_smbus_read_block_data()` function reads a block of data from the specified
    device and places that data in the `values` array. This function first writes
    the register number or command byte to the device, and then the device responds
    with the data. Here is its prototype:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_smbus_read_block_data()`函数从指定设备读取一块数据，并将该数据放入`values`数组中。该函数首先将寄存器号或命令字节写入设备，然后设备返回数据。其原型如下：'
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This command is useful for very specific I²C devices. The bus transactions
    are the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令对于某些特定的I²C设备非常有用。总线事务如下：
- en: A start condition is sent.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送启动条件。
- en: The address byte with an R/W bit of 0 is sent.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有R/W位为0的地址字节被发送。
- en: The `command` byte is sent.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`command`字节被发送。'
- en: A (re)start condition is sent.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送（重新）启动条件。
- en: The address byte with an R/W bit of 1 is sent.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有R/W位为1的地址字节被发送。
- en: The system reads a count byte (*n*) and then reads *n* bytes from the device
    (the particular device determines how many bytes are actually read).
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统读取一个计数字节（*n*），然后从设备读取*n*个字节（具体读取多少字节由设备决定）。
- en: A stop condition is sent.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送停止条件。
- en: To read an arbitrary block of bytes from the I²C bus, without a command or register
    byte, just use the Linux `read` function.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要从I²C总线读取任意字节块，无需命令或寄存器字节，只需使用Linux的`read`函数。
- en: 9.7.10 The i2c_smbus_write_block_data() Function
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.10 i2c_smbus_write_block_data()函数
- en: 'The `i2c_smbus_write_block_data()` function writes a block of data to the specified
    device. This function first writes the register number or command byte to the
    device followed by the data. This is its prototype:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_smbus_write_block_data()`函数将一块数据写入指定设备。该函数首先将寄存器号或命令字节写入设备，然后是数据。其原型如下：'
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This function writes a `command` byte to the device and then a write of `length`
    bytes specified by the values array. The bus transactions are the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将一个`command`字节写入设备，然后写入由值数组指定的`length`字节。总线事务如下：
- en: A start condition is put on the bus.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在总线上放置启动条件。
- en: An address byte with the R/W bit set to 0 is written to the bus.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有R/W位设置为0的地址字节被写入总线。
- en: The `command` byte is written to the bus.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`command`字节被写入总线。'
- en: '`length` bytes from `values` are written to the bus.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`values`中写入`length`字节到总线。
- en: A stop condition is placed on the bus.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在总线上放置停止条件。
- en: No extra address byte is written after the `command` byte. Indeed, this function
    is roughly equivalent to sticking the `command` byte at the beginning of the `values`
    array and calling the Linux `write` function with `length+1` as the number of
    bytes to write.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`command`字节后没有写入额外的地址字节。实际上，这个函数大致相当于将`command`字节放入`values`数组的开头，并调用Linux的`write`函数，写入字节数为`length+1`。
- en: 9.7.11 Miscellaneous Functions
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.11 杂项函数
- en: There are a few other miscellaneous (SMBus-only), lesser-used functions that
    I’m not going to document here. For more information on those functions, check
    out the Linux kernel I²C documentation at [https://www.kernel.org/doc/Documentation/i2c/smbus-protocol](https://www.kernel.org/doc/Documentation/i2c/smbus-protocol).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他杂项（仅限SMBus）较少使用的函数，我在这里不会记录。有关这些函数的更多信息，请查看Linux内核I²C文档：[https://www.kernel.org/doc/Documentation/i2c/smbus-protocol](https://www.kernel.org/doc/Documentation/i2c/smbus-protocol)。
- en: 9.8 Reentrancy Issues with I²C Operations
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8 I²C操作的重入问题
- en: Keep in mind that Linux (Raspberry Pi OS) is a multitasking operating system.
    Therefore, it is perfectly possible for two different threads or processes to
    attempt to access the I²C bus concurrently. Linux will serialize access to the
    I²C/SMBus device driver automatically. Therefore, if some thread is currently
    executing I²C code inside the Linux kernel and another thread attempts to invoke
    some I²C kernel code, the Linux system will block the second task until the first
    thread exits the `ioctl()` call. In that sense, you don’t have to worry about
    reentrancy or anything like that.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Linux（树莓派操作系统）是一个多任务操作系统。因此，两个不同的线程或进程完全有可能同时尝试访问I²C总线。Linux会自动序列化对I²C/SMBus设备驱动程序的访问。因此，如果某个线程当前在Linux内核中执行I²C代码，而另一个线程尝试调用某些I²C内核代码，Linux系统将会阻塞第二个任务，直到第一个线程退出`ioctl()`调用。从这个意义上讲，你不必担心重入性或类似的问题。
- en: That said, two different threads cannot talk concurrently to the same device,
    but two different threads can talk to two independent devices on the I²C bus.
    Therefore, Linux will allow two threads, or even the same thread, to open the
    same bus multiple times. This means that, for example, two different threads could
    open the i2c-1 bus and both of them could write data to the same MCP4725 DAC.
    Of course, the output of the DAC will be really messed up if both threads are
    writing to the DAC independently. Unfortunately, Linux cannot solve this problem
    for you. You must exercise care when writing multiple threads or programs that
    might access the same I²C device concurrently.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，两个不同的线程不能同时与同一个设备通信，但两个不同的线程可以与I²C总线上的两个独立设备通信。因此，Linux允许两个线程，甚至是同一个线程，多次打开同一个总线。这意味着，例如，两个不同的线程可以同时打开i2c-1总线，并且它们都可以向同一个MCP4725数模转换器写入数据。当然，如果两个线程独立地向DAC写数据，那么DAC的输出就会变得非常混乱。不幸的是，Linux无法为你解决这个问题。当编写多个线程或程序时，你必须小心，以防它们可能同时访问同一I²C设备。
- en: 9.9 Multicontroller Operation Under Linux
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9 Linux下的多控制器操作
- en: As far as I can tell, the Raspberry Pi OS (and Linux in general) does not support
    multiple controllers on the same I²C bus. Linux is a single-controller, multiple-peripheral
    I²C interface.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 据我所知，树莓派操作系统（以及Linux系统）不支持同一I²C总线上的多个控制器。Linux是一个单控制器、多外设的I²C接口。
- en: I suspect the Raspberry Pi hardware will not support multiple controllers, given
    the aforementioned hardware issue with the Raspberry Pi I²C controller, which
    doesn’t handle clock stretching properly, and the fact that the same types of
    operations are necessary for clock synchronization and arbitration. Of course,
    this issue applies only to the Pi; other Linux systems will likely support multiple
    controllers on the same bus just fine.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑树莓派硬件不支持多个控制器，考虑到前面提到的树莓派I²C控制器硬件问题，该控制器无法正确处理时钟延展，而且时钟同步和仲裁需要执行相同类型的操作。当然，这个问题仅适用于树莓派；其他Linux系统可能能够很好地支持同一总线上多个控制器。
- en: 9.10 Other Linux Systems
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.10 其他Linux系统
- en: This chapter has largely focused on the Raspberry Pi, but in truth, the only
    really Pi-specific topic in this chapter is activating the I²C bus. Most of the
    functions and utilities this chapter discusses are generic to Linux. The following
    subsections describe some other common Linux-based systems that support I²C for
    general interfacing purposes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要集中在树莓派上，但实际上，本章中唯一真正与树莓派相关的话题是激活I²C总线。本章讨论的大多数功能和工具对于Linux而言都是通用的。以下小节描述了一些支持I²C的其他常见Linux系统，用于一般接口目的。
- en: 9.10.1 PINE A64 and ROCKPro64
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.10.1 PINE A64和ROCKPro64
- en: 'The ROCKPro64 is a 64-bit ARM SBC built to look and behave a whole lot like
    the Raspberry Pi. While it is a great little board (along with its smaller brother,
    the PINE A64), the folks at PINE64 rely on third parties to provide their Linux
    operating system ports. Multiple ports are available, which makes it a bit difficult
    to find a reasonable tutorial on getting the SBC to enable the I²C lines. Here
    are some references (both describe I²C programming on the ROCKPro64 SBC) I’ve
    found that might prove helpful if you’re using one of these machines:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ROCKPro64是一款64位ARM单板计算机，它的外观和行为与树莓派非常相似。尽管它是一款出色的小板（以及它的更小型号PINE A64），PINE64的团队依赖第三方提供Linux操作系统的移植版本。提供了多个版本，这使得很难找到一篇合适的教程来启用该单板的I²C线路。以下是我找到的一些参考资料（这两篇资料都描述了在ROCKPro64单板上的I²C编程），如果你正在使用这些设备，可能会对你有所帮助：
- en: '[https://forum.armbian.com/topic/8792-i2c-and-i2s-on-rock64](https://forum.armbian.com/topic/8792-i2c-and-i2s-on-rock64)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://forum.armbian.com/topic/8792-i2c-and-i2s-on-rock64](https://forum.armbian.com/topic/8792-i2c-and-i2s-on-rock64)'
- en: '[http://synfare.com/599N105E/hwdocs/rock64/index.xhtml](http://synfare.com/599N105E/hwdocs/rock64/index.xhtml)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://synfare.com/599N105E/hwdocs/rock64/index.xhtml](http://synfare.com/599N105E/hwdocs/rock64/index.xhtml)'
- en: 9.10.2 BeagleBone Black
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.10.2 BeagleBone Black
- en: The BeagleBone Black is an open source alternative to the Raspberry Pi. Because
    this device was designed with hardware hackers in mind, it’s not surprising that
    it comes with the i2c-tools set already installed and I²C buses pre-activated.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone Black 是树莓派的一个开源替代品。由于该设备是为硬件黑客设计的，因此它自带 i2c-tools 套件并预激活了 I²C 总线，这并不令人惊讶。
- en: On the BeagleBone Black, bus i2c-2 (pins 19 and 20 on the P9 connector; see
    Figure 6-10 in Chapter 6) is generally available for external use. Use `"/dev/i2c-2"`
    as the filename when opening the bus to access the bus on the BeagleBone Black.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BeagleBone Black 上，i2c-2 总线（P9 连接器的 19 和 20 引脚；参见第 6 章的图 6-10）通常可供外部使用。使用
    `"/dev/i2c-2"` 作为文件名来打开总线，以访问 BeagleBone Black 上的总线。
- en: 9.10.3 Onion Omega2+
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.10.3 Onion Omega2+
- en: The Onion Omega2+ is a small Linux-based module intended for IoT operation.
    This little module comes with I²C communication installed and ready to run.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Onion Omega2+ 是一款小型的基于 Linux 的模块，旨在用于物联网操作。这个小模块自带 I²C 通信，并且可以直接运行。
- en: Onion provides an I²C library you can link with to access I²C devices. Check
    out Onion’s I²C documentation at [https://docs.onion.io/omega2-docs](https://docs.onion.io/omega2-docs).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Onion 提供了一个 I²C 库，您可以链接它来访问 I²C 设备。请查看 Onion 的 I²C 文档：[https://docs.onion.io/omega2-docs](https://docs.onion.io/omega2-docs)。
- en: 9.11 Using the Raspberry Pi as an I²C Peripheral Device
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.11 使用树莓派作为 I²C 外设设备
- en: Although the standard Raspberry Pi hardware and device drivers do not support
    using the Pi as an I²C peripheral device, it is possible to do so using bit-banging
    techniques. The pigpio free software library ([https://abyz.me.uk/rpi/pigpio](https://abyz.me.uk/rpi/pigpio))
    provides an API for dealing with the GPIO pins on the Raspberry Pi. This library
    provides a software-based I²C interface supporting both controller and peripheral
    modes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管标准的树莓派硬件和设备驱动程序不支持将 Pi 用作 I²C 外设设备，但可以通过位波控制技术来实现。pigpio 免费软件库（[https://abyz.me.uk/rpi/pigpio](https://abyz.me.uk/rpi/pigpio)）提供了一个
    API，用于处理树莓派上的 GPIO 引脚。该库提供了一个基于软件的 I²C 接口，支持控制器模式和外设模式。
- en: 'The pigpio library also supports bit-banging controller operations. Using a
    software-controlled I²C driver provides additional features not possible with
    the hardware I²C system, including the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: pigpio 库也支持位波控制器操作。使用软件控制的 I²C 驱动程序提供了硬件 I²C 系统无法实现的附加功能，包括以下内容：
- en: Baud rates as low as 50
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最低波特率为 50
- en: Repeated starts
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复启动
- en: Clock stretching
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟拉伸
- en: I²C on any pair of spare GPIO
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I²C 可通过任意一对空闲 GPIO 引脚使用
- en: See [https://abyz.me.uk/rpi/pigpio/cif.xhtml#bbI2COpen](https://abyz.me.uk/rpi/pigpio/cif.xhtml#bbI2COpen)
    for more information on the bit-banging I²C functions in the pigio library.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见 [https://abyz.me.uk/rpi/pigpio/cif.xhtml#bbI2COpen](https://abyz.me.uk/rpi/pigpio/cif.xhtml#bbI2COpen)
    获取关于 pigpio 库中位波 I²C 函数的更多信息。
- en: Finally, pigpio also provides a veneer (facade design pattern) over the existing
    `ioctl()` functions. See [https://abyz.me.uk/rpi/pigpio/cif.xhtml#i2cOpen](https://abyz.me.uk/rpi/pigpio/cif.xhtml#i2cOpen)
    for a list of these functions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，pigpio 还提供了现有 `ioctl()` 函数的外观（外观设计模式）。请参见 [https://abyz.me.uk/rpi/pigpio/cif.xhtml#i2cOpen](https://abyz.me.uk/rpi/pigpio/cif.xhtml#i2cOpen)
    获取这些函数的列表。
- en: 9.12 Chapter Summary
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.12 章节总结
- en: This chapter discussed I²C programming on the Raspberry Pi, beginning with a
    discussion of the I²C pins on the Pi 40-pin GPIO header. It showed how to activate
    the I²C buses on the Pi and adjust the SCL clock frequency, and then it covered
    some issues with I²C on the Pi, such as its lack of support for clock stretching.
    You also learned various generic Linux utilities you can use to probe the I²C
    bus and access certain types of I²C peripherals. However, the real meat of this
    chapter was its treatment of reading and writing data on the I²C bus via Linux,
    including various advanced kernel calls. Unlike Arduino and other simple systems,
    Linux is a full multitasking/multiprocessing operating system. To address the
    problems in such systems, this chapter briefly discussed reentrancy issues and
    how to work around the problems when multiple threads or processes are accessing
    the same I²C bus concurrently.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了在树莓派上进行I²C编程，首先介绍了树莓派40引脚GPIO头上的I²C引脚。内容展示了如何在树莓派上启用I²C总线并调整SCL时钟频率，接着讨论了树莓派I²C的一些问题，例如其不支持时钟拉伸。你还学习了如何使用各种通用的Linux工具来探测I²C总线并访问某些类型的I²C外设。然而，本章的重点是通过Linux在I²C总线上进行读写数据，包括各种高级内核调用。与Arduino和其他简单系统不同，Linux是一个完整的多任务/多处理操作系统。为了应对这种系统中的问题，本章简要讨论了重入性问题，以及当多个线程或进程同时访问同一个I²C总线时，如何规避这些问题。
- en: Although this chapter focused on the Raspberry Pi, the Pi is a generic Linux
    system, and most of the comments in this chapter that are not Pi-hardware-specific
    apply to other Linux-based systems as well. Therefore, the chapter also gave an
    overview of I²C programming on the PINE A64 or ROCKPro64, the BeagleBone Black,
    and the Onion Omega2+. Finally, you learned to use the Raspberry Pi as an I²C
    peripheral device with the pigpio library, as well as how to use the same library
    for generic bit-banging I²C support.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章主要聚焦于树莓派，但树莓派是一个通用的Linux系统，本章中大部分与硬件无关的内容同样适用于其他基于Linux的系统。因此，本章还概述了在PINE
    A64或ROCKPro64、BeagleBone Black和Onion Omega2+上的I²C编程。最后，你学习了如何使用pigpio库将树莓派用作I²C外设设备，以及如何使用同一库进行通用的位操作I²C支持。
