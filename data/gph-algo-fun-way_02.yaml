- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REPRESENTING
    GRAPHS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">图的表示</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'A *graph* is an abstract data type that can be implemented with a variety of
    data structures. This chapter introduces the fundamental components of a graph,
    nodes and edges, then shows how to build the two most common graph representations:
    adjacency lists and adjacency matrices. Understanding the structure and composition
    of graphs is critical to harnessing their power and designing algorithms to use
    them efficiently.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*图* 是一种抽象数据类型，可以通过多种数据结构实现。本章介绍了图的基本组成部分——节点和边，然后展示了如何构建两种最常见的图表示方法：邻接表和邻接矩阵。理解图的结构和组成对于利用其强大功能并设计高效的算法至关重要。'
- en: To implement the graphs, we define the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    classes upon which almost every algorithm in this book relies. We discuss what
    information the classes store and provide functions for interacting with these
    objects. We also discuss the trade-offs involved in different implementations,
    along with possible alternatives and hybrids.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现图，我们定义了几乎本书中所有算法所依赖的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    类。我们讨论了这些类存储的信息，并提供了与这些对象交互的函数。我们还讨论了不同实现之间的权衡，以及可能的替代方案和混合方案。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Graph Structure</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">图的结构</samp>'
- en: 'A graph consists of two components: nodes and edges. A *node* (also called
    a *vertex*) represents a location or item within the graph. Nodes are often used
    to model concrete entities like people, cities, or computers. *Edges* (also called
    *links* or *arcs*) link together pairs of nodes, defining the relative connections
    within the graph. They are used to represent both concrete items, such as roads
    between cities, and abstract concepts, such as the friendship of two people.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图由两个部分组成：节点和边。*节点*（也称为 *顶点*）表示图中的位置或项目。节点通常用于表示具体的实体，如人、城市或计算机。*边*（也称为 *链接*
    或 *弧*）将一对节点连接在一起，定义了图中节点之间的相对连接。它们用于表示具体的项目，如城市之间的道路，以及抽象的概念，如两个人之间的友谊。
- en: '[Figure 1-1](#fig1-1) shows an example graph with five nodes and seven edges.
    We use the standard graphical representation with nodes as circles and edges as
    lines connecting two circles. Many figures in the book also include a label within
    each circle to identify individual nodes.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](#fig1-1) 显示了一个包含五个节点和七条边的示例图。我们使用标准的图形表示法，节点表示为圆形，边表示为连接两个圆形的线。书中的许多图形也在每个圆形内包含标签，以识别各个节点。'
- en: '![Seven lines, representing edges, join pairs of circles.](../images/f01001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![七条线，表示边，连接成对的圆形。](../images/f01001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: A graph with five
    nodes and seven edges</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-1：一个包含五个节点和七条边的图</samp>
- en: To describe graphs in mathematical notation, we use *V* to represent the set
    of nodes and *E* to represent the set of edges. The number of nodes and edges
    are represented using the mathematical notation for the size of a set, meaning
    the number of nodes is |*V* | and the number of edges is |*E*|.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用数学符号描述图时，我们使用 *V* 来表示节点的集合，使用 *E* 来表示边的集合。节点和边的数量用集合的大小的数学符号表示，这意味着节点的数量是 |*V*|，边的数量是
    |*E*|。
- en: 'Using these simple components, we can represent a surprisingly large number
    of real-world systems and answer a range of real-world practical questions. For
    example, graphs allow us to model the following scenarios:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些简单的组件，我们可以表示出令人惊讶的大量现实世界系统，并回答一系列现实世界中的实际问题。例如，图允许我们建模以下场景：
- en: '**Transportation networks **Nodes are cities, and edges represent paths. We
    can compute the shortest path between points or look for single points of failure
    that would cut off one part of the network from another.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**交通网络 **节点是城市，边表示路径。我们可以计算两点之间的最短路径，或者寻找单一的故障点，这些故障点会切断网络的某一部分与另一部分的连接。'
- en: '**Mazes **Nodes are intersections, and edges are the halls linking them. We
    can search for paths through the maze.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**迷宫 **节点是交叉口，边是连接它们的走廊。我们可以搜索迷宫中的路径。'
- en: '**Educational topics **Each node is a topic, and the edges link two related
    topics. We can sort topics by prerequisite knowledge.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**教育话题** 每个节点是一个话题，边连接两个相关的话题。我们可以根据先修知识对话题进行排序。'
- en: '**Social networks **Nodes are people, and edges are their friendship connections.
    We can model information flow through the network to predict how rumors will travel.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**社交网络** 节点是人，边是他们的友谊连接。我们可以通过网络建模信息流动，以预测谣言如何传播。'
- en: We can further increase the power of our graphs by allowing the edges to provide
    additional information like directionality and weight, as discussed in the following
    subsections and in later chapters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过允许边提供额外的信息，如方向性和权重，进一步增强图的功能，具体内容将在以下小节和后续章节中讨论。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weighted Edges</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加权边</samp>'
- en: In almost every real-world transportation network, there is a different *cost*
    for traversing different edges. We might measure this cost in distance or the
    price of gas, for example; either way, it is cheaper to drive from Boston to New
    York than it is to drive from Boston to Los Angeles. Cost measures can also be
    more complicated, such as factoring in the stress of navigating a narrow, winding
    road through the mountains. Alternatively, for some problems, we want to consider
    the inverse of a cost, such as the strength of a connection between nodes or the
    benefit of following a particular edge. Accounting for the edge’s costs or benefits
    is critical in accurately solving many graph problems, such as finding the shortest
    (or least scary) path between two locations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎每个现实世界的交通网络中，遍历不同的边会有不同的*成本*。例如，我们可能会测量这个成本为距离或油费；无论如何，从波士顿开车到纽约的成本要低于从波士顿开车到洛杉矶的成本。成本度量也可能更复杂，例如考虑到在山间窄而弯曲的道路上行驶的压力。或者，对于某些问题，我们希望考虑成本的反面，例如节点之间连接的强度或沿特定边行进的收益。考虑边的成本或收益对于准确解决许多图问题至关重要，例如找到两地之间最短（或最不吓人的）路径。
- en: '*Weighted edges* capture not only the links between nodes but also the costs
    or benefits of traversing those links. For some applications, the weightings are
    obvious and easy to obtain, such as the distance between cities. For example,
    we could assign an edge between Pittsburgh and Cleveland the weighting of 133
    to reflect 133 miles of highway between the two cities. In other contexts, we
    might use weightings to represent more abstract concepts like the strength of
    a friendship. A weighting of 10 for the connection between Tina and Bob could
    indicate that the two are best friends, while a weighting of 1 for Tina’s connection
    with Alice would indicate that they are mere acquaintances. It is usually obvious
    from context whether a weight represents a cost or benefit.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*加权边*不仅捕捉节点之间的连接，还反映了遍历这些连接的成本或收益。对于某些应用，权重是显而易见且容易获得的，例如城市之间的距离。例如，我们可以为匹兹堡和克利夫兰之间的边赋予133的权重，表示这两个城市之间的公路长度为133英里。在其他情况下，我们可能使用权重来表示更抽象的概念，如友谊的强度。例如，Tina和Bob之间的连接权重为10，可能表示他们是最好的朋友，而Tina与Alice之间的连接权重为1，则表示他们只是泛泛之交。通常可以从上下文中明确判断权重是表示成本还是收益。'
- en: We call graphs with weighted edges *weighted graphs* and those without such
    edges *unweighted graphs*. We visually represent edge weights as numeric labels
    adjacent to the line representing the edge itself. In [Figure 1-2](#fig1-2), for
    example, three of the edges have weight 1.0, one edge has weight 2.0, and the
    remaining three have weight 3.0.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称具有加权边的图为*加权图*，而没有加权边的图为*无权图*。我们通过在表示边的线旁边添加数字标签来直观地表示边的权重。例如，在[图 1-2](#fig1-2)中，三条边的权重为1.0，一条边的权重为2.0，剩下的三条边的权重为3.0。
- en: '![This graph has five nodes and seven edges. Each edge is labeled with a numerical
    weight. The top two edges have weights 1.0 and 2.0.](../images/f01002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![该图有五个节点和七条边，每条边都标有数字权重。上面两条边的权重分别是1.0和2.0。](../images/f01002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: A weighted graph</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-2：一个加权图</samp>
- en: If necessary, we can use weighted graphs to model unweighted edges by either
    using a single weight for all edges, such as 1.0, or ignoring the weight attribute
    in our algorithms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以使用加权图来模拟无权边，方法是为所有边使用相同的权重（如1.0），或在算法中忽略权重属性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Directed Edges</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">有向边</samp>
- en: In some systems, connections between nodes are not symmetric. For example, consider
    the pipe from a building’s water heater to the kitchen faucet. Unless the plumbing
    is very broken, it is not possible for the water to flow into the faucet and back
    to the water heater.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统中，节点之间的连接不是对称的。例如，考虑从建筑物水加热器到厨房水龙头的管道。除非管道损坏严重，否则水不可能流入水龙头再回到水加热器。
- en: '*Directed edges* indicate such directionality in the connection between two
    nodes. We use terminology that mirrors real-world transportation networks: the
    node from which a directed edge begins is the *origin* or <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>,
    while the node to which the directed edge points is the *destination* or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*有向边*表示两个节点之间连接的方向性。我们使用的术语类似于现实世界的交通网络：有向边开始的节点是*起点*或 <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>，而有向边指向的节点是*终点*或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>。'
- en: While directed edges can represent physical directionality, such as a one-way
    road, we can also use them to model more abstract directionality, such as prerequisite
    courses in an educational institution. If each node is a course, a directed edge
    might indicate that we need to take Introduction to Computer Science before Advanced
    Graph Algorithms, as shown in [Figure 1-3](#fig1-3).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有向边可以表示物理方向性，例如单行道，我们也可以用它们来建模更抽象的方向性，例如教育机构中的先决课程。如果每个节点是一个课程，则有向边可能表示我们需要先修计算机科学导论课程，再修高级图算法课程，如[图
    1-3](#fig1-3)所示。
- en: '![Two boxes representing course descriptions. The first box is CS100: Introduction
    to Computer Science and has no prerequisites. The second box is CS401: Advanced
    Graph Algorithms with CS100 and CS201 listed as prerequisites. An arrow goes from
    the first box to the second. Two more arrows to CS401 represent the two other
    prerequisites with ellipses.](../images/f01003.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![两个框表示课程描述，第一个框是CS100：计算机科学导论，没有先决条件。第二个框是CS401：高级图算法，列出了CS100和CS201作为先决条件。从第一个框指向第二个框的箭头，另外两个箭头指向CS401，表示两个其他先决条件，并有省略符号。](../images/f01003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: Arrows showing
    the directionality of course prerequisites</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-3：显示课程先决条件方向性的箭头</samp>
- en: We call graphs with directed edges *directed graphs*. Graphs without directed
    edges (such as those in [Figures 1-1](#fig1-1) and [1-2](#fig1-2)) are known as
    *undirected graphs* with *undirected edges*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称带有有向边的图为*有向图*。没有有向边的图（如[图 1-1](#fig1-1)和[1-2](#fig1-2)）被称为*无向图*，其中包含*无向边*。
- en: We can use directed edges to extend our earlier social network model. While
    it would be ideal if all friendships were reciprocated, this is sadly not always
    the case. Tina and Bob might call each other best friends. However, while Alice
    considers Tina a dear friend, Tina thinks of Alice simply as an acquaintance from
    work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用有向边来扩展我们之前的社交网络模型。虽然理想情况下所有的友谊都是互惠的，但遗憾的是，情况并非总是如此。蒂娜和鲍勃可能会互称对方为最好的朋友。然而，虽然爱丽丝把蒂娜视为亲密朋友，蒂娜却只是把爱丽丝当作工作上的一个熟人。
- en: '[Figure 1-4](#fig1-4) shows an example graph with directed edges, where each
    directed edge is shown as a single arrow indicating its direction.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-4](#fig1-4)展示了一个带有有向边的示例图，其中每条有向边以单箭头表示其方向。'
- en: '![A graph with five nodes and eight directed edges. Each edge is shown as one
    or two arrows.](../images/f01004.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点和八条有向边的图形。每条边显示为一个或两个箭头。](../images/f01004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-4: A directed graph</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-4：一个有向图</samp>
- en: We can represent symmetric or undirected relationships between nodes in a directed
    graph by using pairs of directed edges, one in each direction, as shown between
    the bottom two nodes in [Figure 1-4](#fig1-4). This allows us to model systems
    with a mix of directed and undirected relationships. For example, real-world transportation
    networks contain a mix of one-way and two-way roads, and many social networks
    contain mutual friendships. By using a directed graph and corresponding edge pairs,
    we can fully model these systems.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用每个方向的一对有向边来表示有向图中节点之间的对称或无向关系，如[图 1-4](#fig1-4)中底部两个节点之间所示。这使我们能够建模具有有向和无向关系的混合系统。例如，现实世界的交通网络包含单行道和双行道的混合，许多社交网络也包含互相的友谊。通过使用有向图和相应的边对，我们可以完整地建模这些系统。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Edges with Both Weight
    and Direction</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">同时具有权重和方向的边</samp>
- en: To maximize the representational power of the graph, we can combine the use
    of weighted edges and directed edges, as shown in [Figure 1-5](#fig1-5). This
    representation allows the graph to capture both the directionality and the cost
    versus benefit of each connection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化图的表现力，我们可以结合使用带权重的边和有向边，如[图1-5](#fig1-5)所示。这种表示方法使得图能够同时捕捉每个连接的方向性以及成本与效益的关系。
- en: '![A graph with five nodes and eight directed edges. Each edge is shown as one
    or two arrows and each arrow is labeled with a number representing the weight.](../images/f01005.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点和八条有向边的图。每条边显示为一个或两个箭头，并且每个箭头标注有代表权重的数字。](../images/f01005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-5: A directed and
    weighted graph</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-5：一个有向且加权的图</samp>
- en: We must specify a separate weight for each directed edge between two nodes,
    but, as with the bottom pair of nodes in [Figure 1-5](#fig1-5), these weights
    need not be equal. When modeling the cost of traversing a road, for example, we
    might choose a much higher cost for the uphill direction than for the downhill
    one. Depending on the application, such as planning a cycling trip, the cost of
    uphill roads might be significantly higher. Similarly, Tina and Alice assign different
    levels of importance to their friendship.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为两个节点之间的每条有向边指定一个单独的权重，但正如[图1-5](#fig1-5)中底部一对节点所示，这些权重不必相等。例如，在建模道路的通行成本时，我们可能会选择为上坡方向设定一个比下坡方向高得多的成本。根据应用的不同，比如规划骑行旅行，上坡道路的成本可能会高很多。类似地，Tina和Alice对她们的友谊赋予了不同的重视程度。
- en: Throughout this book, we will use graph implementations that support both weighting
    and directionality. If necessary, these data structures can still be used to store
    simpler graphs without weighted or directed edges. While this generality adds
    some small complexity to the data structure and may potentially add overhead to
    algorithms that do not use all the information, this approach results in a flexible
    data structure that can be used by a range of algorithms.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中，我们将使用支持权重和方向性的图实现。如果需要，这些数据结构仍然可以用于存储没有加权或没有方向的简单图。尽管这种通用性为数据结构带来了一些小的复杂性，并且可能会为那些不使用所有信息的算法增加额外开销，但这种方法使得数据结构更加灵活，能够被多种算法所使用。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Adjacency List Representation</samp>
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">邻接表表示法</samp>
- en: The graph representation used throughout the majority of this book is the *adjacency
    list representation*, which stores a graph’s structure as a set of individual
    lists of neighbors for each node. This allows us to mirror real-world phenomena
    where each node maintains information on its local connections, such as in a social
    network where individuals maintain contact information for their immediate friends.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本书大部分内容中使用的图表示法是*邻接表表示法*，它通过为每个节点存储一组邻居的单独列表来表示图的结构。这使得我们能够模拟现实世界中的现象，其中每个节点维护关于其本地连接的信息，比如社交网络中个人为他们的直接朋友维护联系信息。
- en: 'There are a variety of ways to implement the adjacency list representation.
    Nodes and edges can be represented implicitly through associations or explicitly
    as data structures in their own right. In the simplest implementation, we could
    implicitly store a graph using a single list of lists, where each node has a numeric
    ID and each entry in the list corresponds to a given node’s neighbors. For example,
    consider the following line of code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以实现邻接表表示法。节点和边可以通过关联隐式地表示，或者作为独立的数据结构显式表示。在最简单的实现中，我们可以通过一个单独的列表列表隐式存储图，其中每个节点都有一个数字ID，每个列表条目对应一个给定节点的邻居。例如，考虑以下代码行：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This list of lists <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> represents
    the undirected, unweighted graph with five nodes and seven edges shown in [Figure
    1-6](#fig1-6). The first entry in the list on the right-hand side of the figure
    indicates that node 0 has three neighbors: nodes 1, 3, and 4\. Each undirected
    edge is represented in two different neighbor lists, one for the node on each
    end.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表中的列表<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>表示[图1-6](#fig1-6)中所示的无向、无权图，包含五个节点和七条边。图右侧列表中的第一个条目表示节点0有三个邻居：节点1、3和4。每条无向边在两个不同的邻接列表中都有表示，分别对应边的两端节点。
- en: '![The left figure shows a graph with seven edges and five nodes given labels
    0 through 4\. Node 0 in the graph is connected to nodes 1, 3, and 4\. The right
    figure shows an array where each element points to a list, indicating that node’s
    neighbors. Element 0 in the array points to a list of the numbers 1, 3, and 4.](../images/f01006.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![左图显示了一个包含七条边和五个节点的图，节点的标签为0到4。图中的节点0与节点1、3和4相连。右图显示了一个数组，其中每个元素指向一个列表，表示该节点的邻居。数组中的元素0指向包含数字1、3和4的列表。](../images/f01006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-6: A graph (left)
    and its adjacency list representation (right)</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-6：一个图（左）及其邻接表表示（右）</samp>
- en: Alternatively, we could create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    data structure that contains not only the adjacency list but also supplementary
    information. This might include a label to identify the node, a Boolean indicating
    whether the node has been processed, or an integer indicating the time at which
    we first saw the node. We could also make the representation more detailed by
    defining an <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> data structure
    with information about directionality and weight, then storing a list of adjacent
    edges within each node.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以创建一个包含不仅是邻接表，还有附加信息的<samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>数据结构。这可能包括一个标签来标识节点，一个布尔值表示节点是否已处理，或者一个整数表示我们第一次看到该节点的时间。我们还可以通过定义一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>数据结构来存储关于方向性和权重的信息，然后在每个节点内存储一个相邻边的列表，从而使表示更加详细。
- en: The optimal representation for any given use case depends highly on the purpose
    of the data structure. For large graphs in limited memory environments, a sparser
    representation like the list of lists in [Figure 1-6](#fig1-6) might be ideal.
    However, when modeling more complex problems, such as directional traffic flows
    over different road conditions, we may need to store more information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 任何给定使用场景的最佳表示方式在很大程度上取决于数据结构的目的。对于内存有限的环境中的大规模图，像[图1-6](#fig1-6)中的邻接表这样的稀疏表示可能是理想的。然而，在建模更复杂的问题时，例如不同路况下的交通流向，我们可能需要存储更多的信息。
- en: The rest of this section introduces a highly structured adjacency list representation
    that prioritizes generality and understandability so that we can reuse it throughout
    the different algorithms in this book. We use both <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> objects to facilitate
    the storage of a variety of auxiliary information for both pieces. Each <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> object maintains its own list
    of adjacent <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> objects
    that store the information needed to encode weights and directionality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分介绍了一种高度结构化的邻接表表示方法，优先考虑通用性和可理解性，以便我们能够在本书的不同算法中重复使用它。我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>对象来便于存储这两者的各种辅助信息。每个<samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>对象维护自己相邻的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>对象的列表，这些边对象存储编码权重和方向性所需的信息。
- en: An important aspect of this implementation is that each node has a unique *numeric
    index* that indicates its location within the overall <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    data structure. Throughout this book, we will refer to a node and its index relatively
    interchangeably. For example, we refer to the node at index 0 as node 0\. We might
    also say that a function returns a list of nodes visited when the implementation
    returns a list of indices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现的一个重要方面是每个节点都有一个独特的*数字索引*，指示它在整个<samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>数据结构中的位置。在本书中，我们将节点及其索引在某种程度上交替使用。例如，我们称索引为0的节点为节点0。我们也可能说一个函数返回一个访问过的节点列表，而实际上返回的是一个索引列表。
- en: As we will see throughout the book, this graph representation lends itself to
    algorithms that traverse the graph node by node, such as the majority of algorithms
    in this book. While this implementation is effective for illustrating a range
    of graph algorithms, the reader may want to use more memory-efficient or computationally
    efficient representations that are better optimized for specific problems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在全书中将看到的那样，这种图形表示法适用于通过逐个节点遍历图的算法，书中大部分算法就是如此。虽然这种实现方式对于说明一系列图算法是有效的，但读者可能希望使用更节省内存或计算效率更高的表示法，以便更好地针对特定问题进行优化。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Edges</samp>
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Edges</samp>
- en: 'We define an <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> object
    as little more than a container that stores information for directed and weighted
    edges:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> 对象定义为一个简单的容器，用来存储有向加权边的信息：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">to_node</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the node index of the edge’s destination
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">to_node</samp> **（**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**）** **存储边的目标节点的索引。**
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">from_node</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the node index of the edge’s origin
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">from_node</samp> **（**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**）** **存储边的起始节点的索引。**
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">weight</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **Stores
    the edge’s weight. Where necessary for a particular use case, we’ll use a value
    of 1 to represent unweighted edges
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">weight</samp> **（**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**）** **存储边的权重。对于某些特定用例，我们将使用值
    1 来表示无权边。**
- en: As shown in [Figure 1-7](#fig1-7), the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    object stores all the information we may need to work with an edge independent
    from other classes. The inclusion of <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class may seem
    redundant because we are storing the edges in a list at each node and thus can
    retrieve that information from the node. However, explicitly storing this information
    will enable us to use algorithms later in the book that work with sets of edges
    independent of the nodes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 1-7](#fig1-7) 所示，<samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    对象存储了我们可能需要用来处理边的信息，而不依赖其他类。将 <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    包含在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> 类中似乎有些冗余，因为我们在每个节点的边列表中存储了边，并可以从节点中检索到这些信息。然而，显式地存储这些信息将使我们能够在本书后续部分使用一些与边集独立于节点操作的算法。
- en: '![A pair of circles joined by an arrow from left to right. The left circle
    is labeled “from_node”; the right circle is labeled “to_node.” The arrow is labeled
    “weight.”](../images/f01007.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![一对圆圈通过从左到右的箭头连接在一起。左侧的圆圈标记为“from_node”；右侧的圆圈标记为“to_node”。箭头标记为“weight”。](../images/f01007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-7: The information
    contained in the</samp> <samp class="SANS_TheSansMonoCd_W7Italic">Edge</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">class</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-7：包含在</samp> <samp class="SANS_TheSansMonoCd_W7Italic">Edge</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">类中的信息</samp>
- en: 'Using the attributes of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    class, we define a constructor that copies in the data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> 类的属性，我们定义了一个构造函数，用来复制数据：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class is
    used primarily for storage, it does not include any additional functions. Attributes
    are accessed directly. We can model undirected edges in the graph by storing a
    pair of directed edges from each node. That is, an undirected edge between nodes
    A and B would materialize as a directed edge from node A to node B and a directed
    edge from node B to node A. While this doubles the number of edges stored in an
    undirected graph, it emphasizes flexibility and allows us to use the same class
    for a range of applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> 类主要用于存储，因此它不包含任何额外的功能。属性直接访问。我们可以通过存储每个节点的两个有向边来表示图中的无向边。也就是说，节点
    A 和节点 B 之间的无向边将表现为从节点 A 到节点 B 的有向边和从节点 B 到节点 A 的有向边。虽然这会使无向图中存储的边的数量翻倍，但它强调了灵活性，并允许我们使用相同的类进行多种应用。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class illustrates
    how we use the numeric node identifier throughout the code. Instead of storing
    an explicit link to the node, <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>, we store the
    integer index of the corresponding nodes. When we need to access additional attributes
    within the node, we use these indices to directly look up the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    object from the graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp>
    list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> 类展示了我们如何在代码中使用数字节点标识符。我们不是存储节点的显式链接，而是存储对应节点的整数索引。当我们需要访问节点中的其他属性时，我们使用这些索引直接从图的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp> 列表中查找 <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    对象。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nodes</samp>
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">节点</samp>
- en: 'We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> object
    to both store the information relevant to the node and provide basic operations
    on that information. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    object contains the following attributes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> 对象，用于存储与节点相关的信息，并提供对这些信息的基本操作。每个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> 对象包含以下属性：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">index</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the numeric index of the node
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">index</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **存储节点的数字索引
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">edges</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">dict</samp>**) **Stores
    the edges out of the node
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">edges</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">dict</samp>**) **存储从节点发出的边
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">label</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**,**
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">string</samp>**, or** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">object</samp>**) **An
    optional label used to identify the node or mark its current state
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">label</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**,**
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">string</samp>**, 或** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">object</samp>**) **一个可选的标签，用于标识节点或标记其当前状态
- en: Instead of using a list to store the edges, we use a dictionary keyed by the
    destination node’s integer index and with <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    objects as values. This representation allows us to efficiently ask questions
    like “Is there an edge between node A and node B?” without iterating through all
    of node A’s edges.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用列表来存储边，而是使用一个由目标节点的整数索引键入，且以 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    对象作为值的字典。这种表示方式使我们能够高效地问“节点 A 和节点 B 之间是否有边？”而不需要遍历节点 A 的所有边。
- en: We can visualize the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    object as part of a high school social network. Each student is represented as
    a node with their student ID number as their index. The <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    dictionary represents that student’s personal list of friends. As noted earlier,
    each <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> object can be directional
    and weighted to fully capture the complexities of high school alliances and feuds.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp> string can be used
    to store information about each student, such as whether they have heard the latest
    rumor.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将<sup class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>对象想象成一个高中社交网络中的一部分。每个学生作为一个节点，用他们的学号作为索引。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>字典表示该学生的朋友列表。正如前面所提到的，每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>对象可以是有方向的且加权的，以完全捕捉高中联盟和纷争的复杂性。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">label</samp>字符串可以用于存储有关每个学生的信息，比如他们是否听说了最新的谣言。
- en: 'As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> classes, we define a
    constructor to set up the initial state of the node, as well as a series of helper
    functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与<samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>类一样，我们定义了一个构造函数来设置节点的初始状态，并且定义了一系列辅助函数：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The constructor sets the integer index (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>)
    to the given value. It creates an empty dictionary (<samp class="SANS_TheSansMonoCd_W5Regular_11">self.edges</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>)
    to store future edges and starts with an empty label (<samp class="SANS_TheSansMonoCd_W5Regular_11">self.label</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将整数索引（<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>）设置为给定的值。它创建一个空字典（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">self.edges</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>）来存储未来的边，并且初始化一个空标签（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">self.label</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>）。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> class contains
    a variety of helper functions to facilitate working with it. When implementing
    the graph, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class
    needs to be defined before the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    class. We also need to import <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library
    (by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">from typing import Union</samp>
    at the start of the file) to support the optional type hints used in the example
    code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>类包含各种辅助函数，方便我们与其交互。当实现图时，必须先定义<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Edge</sup>类，然后再定义<sup class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>类。我们还需要从Python的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typing</samp>库导入<samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>（在文件开头添加<samp
    class="SANS_TheSansMonoCd_W5Regular_11">from typing import Union</samp>），以支持示例代码中使用的可选类型提示。
- en: The first two functions provide access to the node’s edges. The <samp class="SANS_TheSansMonoCd_W5Regular_11">num_edges()</samp>
    function returns the number of edges. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp>
    function returns a given edge, or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    if no such edge exists. This allows us to combine lookups and existence checks
    into a single function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数提供对节点边的访问。<samp class="SANS_TheSansMonoCd_W5Regular_11">num_edges()</samp>函数返回边的数量。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp>函数返回给定的边，如果没有该边则返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。这样可以将查找和存在性检查合并到一个函数中。
- en: The next two functions modify the node’s connections. The <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp>
    function takes a destination index and weight, then creates and inserts the corresponding
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> object. It overwrites
    the existing edge if the neighbor’s index already appears in the dictionary, allowing
    us to update edge weights. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp>
    drops an edge from the dictionary if it exists.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个函数修改节点的连接。<samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp>
    函数接受目标索引和权重，然后创建并插入相应的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    对象。如果邻居的索引已经出现在字典中，它会覆盖现有的边，从而允许我们更新边的权重。<samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp>
    函数如果边存在，则从字典中删除该边。
- en: The final two functions are convenience functions for returning the node’s edges
    as lists. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge_list()</samp>
    returns the edges in their dictionary ordering and is used whenever an algorithm
    needs access to the list. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_sorted_edge_list()</samp>
    returns the edges in order of increasing neighbor index and is primarily used
    throughout this book to provide a consistent ordering for examples.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个函数是方便的函数，用于将节点的边返回为列表。函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge_list()</samp>
    按字典顺序返回边，并在算法需要访问列表时使用。函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_sorted_edge_list()</samp>
    按照邻居索引的升序返回边，主要用于本书中，为示例提供一致的顺序。
- en: While these functions use dictionaries to store a node’s edges (indexed by the
    destination node), it’s possible to adapt each function to store the node’s edges
    as a list instead. Compact lists of just the outgoing edges prioritize memory
    usage over the time it takes to look up a specific edge. In contrast, to prioritize
    lookup speed for specific edges, each node could store a list of length |*V* |
    with a space for each possible edge and store <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    for edges that do not occur. The dictionary-based approach balances these two
    competing aspects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些函数使用字典来存储节点的边（以目标节点为索引），但也可以将每个函数调整为将节点的边存储为列表。仅存储出边的紧凑列表更注重内存使用，而不是查找特定边所需的时间。相比之下，为了优先考虑特定边的查找速度，每个节点可以存储一个长度为|*V*|的列表，为每个可能的边预留空间，并将不存在的边存储为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。基于字典的方法平衡了这两个竞争的方面。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Graph Class</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">图类</samp>'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class used in
    the majority of this book consists of a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    objects and some utility information that simplifies common computations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中大多数地方使用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 类由一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> 对象的列表和一些简化常见计算的实用信息组成：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores
    the graph’s nodes
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **存储图中的节点
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the total number of nodes in the graph
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **存储图中的节点总数
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">undirected</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp>**) **Indicates
    whether this is a directed or undirected graph
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">undirected</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp>**) **指示这是有向图还是无向图
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> values can be computed
    from the structure of the graph itself but are stored for convenience.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>
    值可以从图的结构中计算出来，但为了方便，它们被存储了下来。
- en: We always store directed edges and use the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>
    to modify behavior when working with directed and undirected graphs. Most notably,
    as demonstrated later in the section “Accessing, Building, and Modifying the Graph,”
    we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> to insert
    a pair of directed edges when the graph itself is undirected. Other common implementations
    either use separate functions, such as an <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_undirected_edge()</samp>
    function, or create entirely different implementations for directed and undirected
    graphs. Again, we are prioritizing generality of the data structure over pure
    optimization.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终存储有向边，并使用布尔值 <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>
    来修改在处理有向图和无向图时的行为。最显著的是，如本节后面“访问、构建和修改图”部分所示，当图本身是无向图时，我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>
    插入一对有向边。其他常见的实现要么使用单独的函数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_undirected_edge()</samp>
    函数，要么为有向图和无向图创建完全不同的实现。再次强调，我们在这里优先考虑数据结构的通用性，而非纯粹的优化。
- en: 'Given this information, we can create a simple constructor for building a graph
    with a given number of nodes and no edges:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，我们可以创建一个简单的构造函数，用于构建具有指定节点数且没有边的图：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The constructor initializes the convenience variables, then creates a list of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> objects. The function
    does not create any edges. Implicit in this implementation is the existence of
    a unique numeric identifier for each node that corresponds to its location in
    the graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp> list.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化便利变量，然后创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    对象的列表。该函数不会创建任何边。该实现隐含地假设每个节点都有一个唯一的数字标识符，该标识符对应图的 <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp>
    列表中的位置。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class also includes
    a variety of functions to create, search, access, and otherwise process graphs.
    Instead of providing a huge block of code for all graph functions in this section,
    we’ll introduce the general functions throughout this section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 类还包括多种函数，用于创建、搜索、访问以及其他处理图的操作。我们将不会在本节中提供一个包含所有图函数的大块代码，而是会在本节中逐步介绍这些通用函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Accessing, Building, and Modifying
    the Graph</samp>
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">访问、构建和修改图</samp>
- en: 'To facilitate accessing edges, we next define a series of helper functions
    within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便访问边，我们接下来在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 类中定义一系列辅助函数：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function
    takes an origin index and a destination index and returns the corresponding edge,
    if it exists. It performs basic bounds checking for validity, then uses the origin
    node’s corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp>
    function to retrieve an edge if one exists and return <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    otherwise. The <samp class="SANS_TheSansMonoCd_W5Regular_11">is_edge()</samp>
    function simply checks for the existence of any edge with the given origin and
    destination. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_edge_list()</samp>
    function dynamically constructs and returns a list of all edges in the graph.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> 函数接受一个起始索引和一个目标索引，并返回对应的边（如果存在）。它会进行基本的边界检查以验证有效性，然后使用起始节点对应的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> 函数来检索边，如果存在的话，并返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>，否则返回。<samp class="SANS_TheSansMonoCd_W5Regular_11">is_edge()</samp>
    函数只是检查给定起始点和目标点之间是否存在边。最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">make_edge_list()</samp>
    函数动态地构建并返回图中所有边的列表。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class’s constructor
    allocates a given number of nodes but does not create any edges. Obviously, this
    does not produce a remotely useful graph. To model any interesting problem, our
    graph needs to include both nodes and edges. We therefore add a few additional
    functions for creating and modifying our adjacency graph representation. First,
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class, we provide
    the ability to add and remove edges given the indices of the origin and destination
    nodes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 类的构造函数分配了一定数量的节点，但并未创建任何边。显然，这样并不能生成一个有用的图。为了建模任何有趣的问题，我们的图需要包含节点和边。因此，我们添加了一些额外的函数，用于创建和修改邻接图表示。首先，在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 类中，我们提供了根据起始节点和目标节点的索引来添加和删除边的功能：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp> functions
    follow the same flow: they start by checking that both the origin and destination
    indices correspond to nodes included in the graph ❶ ❸. If the node indices are
    invalid, the functions raise an <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_edge()` 和 `remove_edge()` 函数遵循相同的流程：它们首先检查起始节点和目标节点的索引是否对应于图中包含的节点
    ❶ ❸。如果节点索引无效，函数会引发一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>
    异常。'
- en: If the indices are valid, the functions modify the adjacency list of the origin
    node. The insertion function uses the node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp>
    function. The removal function uses the node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp>
    function. Because we are using a single class to represent both directed and undirected
    graphs, the functions also need to add ❷ or remove ❹ the corresponding inverse
    edge in the case of an undirected graph.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引有效，函数会修改起始节点的邻接表。插入函数使用节点的 <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp>
    函数。删除函数使用节点的 <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp>
    函数。由于我们使用同一个类表示有向图和无向图，因此在无向图的情况下，函数还需要添加 ❷ 或删除 ❹ 相应的反向边。
- en: 'We can use these functions together to dynamically create graphs. For example,
    we can use the following code to create a directed graph with five nodes and then
    insert eight weighted edges:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些函数结合起来，动态创建图。例如，我们可以使用以下代码来创建一个有五个节点的有向图，并插入八条加权边：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This generates the graph shown in [Figure 1-8](#fig1-8).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成如 [图 1-8](#fig1-8) 所示的图。
- en: '![a five-node graph with arrows linking the nodes. Each arrow is labeled with
    a number. For example, Node 0 has an arrow to node 1 with weight 1.0, an arrow
    to node 3 with weight 1.0, and an arrow to node 4 with weight 3.0.](../images/f01008.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点的图，箭头连接节点。每个箭头上标有数字。例如，节点 0 有一个指向节点 1 的箭头，权重为 1.0，一个指向节点 3 的箭头，权重为
    1.0，以及一个指向节点 4 的箭头，权重为 3.0。](../images/f01008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-8: A directed and
    weighted graph with nodes labeled by their indices</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-8：一个有向加权图，节点按其索引标记</samp>
- en: 'While we provide the ability to pre-allocate nodes in the constructor, for
    some algorithms, we need to insert new nodes as we explore a graph. To facilitate
    this, we also provide a function for inserting new nodes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在构造函数中提供了预分配节点的功能，但对于某些算法，我们需要在探索图时插入新节点。为方便起见，我们还提供了一个插入新节点的函数：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp> function
    creates a new node and automatically assigns the identification number to the
    next index. The node is then appended to the <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp>
    list, the count of nodes is incremented, and the new node is returned.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_node()` 函数创建一个新节点，并自动将标识号码分配给下一个索引。然后，节点被附加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp>
    列表中，节点计数增加，并返回新节点。'
- en: While the functions in this section provide the building blocks for constructing
    graphs, it would be tedious to manually specify graphs with a long sequence of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    calls. [Appendix A](appendix_A.xhtml) examines a few sample algorithms that build
    off these initial functions to programmatically create graphs from files or common
    problem specifications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本节中的函数提供了构建图的基本构件，但手动指定图形的过程将会非常繁琐，需要一长串的<samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>调用。[附录A](appendix_A.xhtml)中探讨了一些基于这些初始函数的示例算法，通过它们可以从文件或常见问题规格程序化地创建图。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Copying the Graph</samp>
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">复制图</samp>
- en: 'Finally, we also define a helper function within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class that produces a new copy of the graph for use with algorithms that modify
    the graph:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还在<samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>类中定义了一个辅助函数，用于生成图的副本，供修改图的算法使用：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_copy()</samp> code starts
    by creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> object
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>) with the same number
    of nodes and undirected setting as the current graph. It then uses two nested
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to iterate through
    each node and its outgoing edges. For each node, it copies the label ❶. For each
    edge, it inserts an equivalent edge into <samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>
    ❷.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">make_copy()</samp>代码首先创建一个新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>对象（<samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>），该对象具有与当前图相同数量的节点和无向设置。然后，它使用两个嵌套的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历每个节点及其出边。对于每个节点，它复制标签❶。对于每条边，它在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>中插入一个等效的边❷。
- en: Copying the graph will allow us to employ algorithms that destructively modify
    the graph. For example, in [Chapter 16](chapter16.xhtml) we will introduce an
    algorithm for assigning colors that iteratively removes nodes from the graph.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 复制图将允许我们使用那些会破坏性修改图的算法。例如，在[第16章](chapter16.xhtml)中，我们将介绍一种为图分配颜色的算法，该算法会迭代地从图中移除节点。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Adjacency Matrix Representation</samp>
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">邻接矩阵表示法</samp>
- en: Another powerful graph representation is the *adjacency matrix*. While we will
    primarily rely on the previous adjacency list representation for most of the algorithms
    in this book, the adjacency matrix representation is important for an entire class
    of mathematically based algorithms. Many algorithms can be described or analyzed
    via matrix operations. We will make use of the matrix formulation in [Chapter
    13](chapter13.xhtml) when considering random walks on graphs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个强大的图表示法是*邻接矩阵*。虽然我们在本书的大多数算法中主要依赖前面的邻接表表示法，但邻接矩阵表示法对于一类基于数学的算法至关重要。许多算法可以通过矩阵运算进行描述或分析。在考虑图上的随机游走时，我们将在[第13章](chapter13.xhtml)中使用矩阵表示法。
- en: 'The *adjacency matrix* representation of a graph uses a single matrix to indicate
    the edge weights between each pair of nodes. The value in row *i*, column *j*,
    represents the weight of the edge from node *i* to node *j*. A value of 0 indicates
    that no such edge exists. Represented as a list of lists, the following matrix
    would create an undirected, unweighted graph with five nodes and seven edges:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图的*邻接矩阵*表示法使用一个矩阵来表示每一对节点之间的边权重。在第*i*行，第*j*列的值表示从节点*i*到节点*j*的边的权重。值为0表示不存在这样的边。作为一个列表的列表表示，下面的矩阵将创建一个无向、无权重的图，其中包含五个节点和七条边：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This corresponds to the graph shown in [Figure 1-9](#fig1-9), where node 0’s
    three connections are represented by the corresponding nonzero entries in the
    matrix.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于[图1-9](#fig1-9)中显示的图，其中节点0的三个连接通过矩阵中相应的非零条目表示。
- en: '![The left figure shows a graph with five nodes given labels 0 through 4\.
    Node 0 is connected to nodes 1, 3, and 4\. The right figure shows a 5 × 5 matrix
    filled with values of 0 and 1\. The top row, indicating connections from node
    0 reads 0, 1, 0, 1, 1.](../images/f01009.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![左图显示一个包含五个节点、标签为0到4的图。节点0与节点1、3和4相连。右图显示一个5×5的矩阵，矩阵填充了0和1的值。顶行表示从节点0的连接，值为0、1、0、1、1。](../images/f01009.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-9: A graph (left)
    and its adjacency matrix representation (right)</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-9：一个图（左）及其邻接矩阵表示（右）</samp>
- en: The matrix of connection can use any setting of values. Floating-point entries
    can be used to represent weighted edges. Undirected edges are represented by a
    matching pair of values, making undirected graphs symmetric.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 连接矩阵可以使用任何值设置。浮动值条目可以用来表示带权重的边。无向边通过一对匹配的值来表示，使得无向图是对称的。
- en: To create and store adjacency graphs, we’ll use the basic <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    class presented in this section. As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class, we optimize the representation for understandability rather than computational
    cost or memory usage.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建和存储邻接图，我们将使用本节中介绍的基本 <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    类。与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 类一样，我们优化了表示方式，以便于理解，而非计算成本或内存使用。
- en: 'Our <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> class
    contains three pieces of information:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> 类包含三部分信息：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">connections</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>
    **of** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores the
    adjacency matrix
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">connections</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>
    **of** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **存储邻接矩阵
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the total number of nodes in the graph
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **存储图中节点的总数
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">undirected</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp>**) **Indicates
    whether this is a directed or undirected graph
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">undirected</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp>**) **指示这是有向图还是无向图
- en: 'As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data
    structure, we allow <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    to represent both directed and undirected graphs. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>
    attribute to specify which type of edges are included. We define a simple constructor
    for building a graph with a given number of nodes and no edges:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 数据结构一样，我们允许 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> 表示有向图和无向图。我们使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> 属性来指定包含哪种类型的边。我们定义了一个简单的构造函数，用于构建一个具有指定节点数且没有边的图：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code initializes every entry in <samp class="SANS_TheSansMonoCd_W5Regular_11">connections</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, creating a graph without
    any edges.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将 <samp class="SANS_TheSansMonoCd_W5Regular_11">connections</samp> 中的每个条目初始化为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，从而创建一个没有任何边的图。
- en: 'We also define a getter function to retrieve the weight of a connection between
    two nodes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个 getter 函数，用于获取两个节点之间连接的权重：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code checks that both the origin and destination indices are valid. If so,
    the core returns the corresponding floating-point value from the array.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查源节点和目标节点的索引是否有效。如果有效，核心将从数组中返回相应的浮动值。
- en: While we store the adjacency matrix in a list of lists to keep this illustration
    simple, it is often preferable to use a representation optimized for matrix operations,
    such as that provided in the popular numpy package. Such numerical packages will
    be faster and provide a range of helper functions. We leave the implementation
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> in numpy
    or a similar mathematical package as an exercise for the reader.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将邻接矩阵存储在列表的列表中以简化示例，但通常最好使用优化过的矩阵操作表示法，比如流行的 numpy 包所提供的那种。这样的数值包会更快，并提供一系列辅助函数。我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> 在 numpy 或类似数学包中的实现留给读者作为练习。
- en: 'Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class,
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> object
    pre-allocates all the space to store edge information in the main <samp class="SANS_TheSansMonoCd_W5Regular_11">connections</samp>
    matrix. We can directly set entries in this matrix to add or remove edges:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 类不同，新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    对象预分配所有存储边信息的空间到主 <samp class="SANS_TheSansMonoCd_W5Regular_11">connections</samp>
    矩阵中。我们可以直接在该矩阵中设置条目来添加或移除边：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code checks that both the origin and destination indices are valid and,
    if not, raises an error ❶. If the indices are valid, the function sets the matrix
    entry corresponding to this edge ❷. If the graph is undirected, the function modifies
    the symmetric entry in the matrix ❸.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查源节点和目标节点的索引是否有效，如果无效，则会引发错误 ❶。如果索引有效，函数会设置与该边对应的矩阵项 ❷。如果图是无向图，函数会修改矩阵中的对称项
    ❸。
- en: 'We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_edge()</samp>
    function to add, remove, or modify edges. We add new edges by setting the entries
    to nonzero weights. If an edge already exists between those two nodes, the function
    updates the weight. We remove edges by setting an entry to 0\. For example, we
    could create the graph in [Figure 1-8](#fig1-8) as:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">set_edge()</samp> 函数来添加、移除或修改边。通过将条目设置为非零权重来添加新边。如果这两个节点之间已经存在边，函数会更新其权重。我们通过将条目设置为
    0 来移除边。例如，我们可以创建图 [图 1-8](#fig1-8) 如下：
- en: '[PRE13]  ### <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]  ### <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>'
- en: The graph structure and its underlying implementations form the foundation of
    all algorithms in this book and drive their development. Deciding which representation
    to use requires us to consider trade-offs in memory usage, computational efficiency,
    and complexity, depending on what makes sense for the task at hand. In cases where
    we want only to iterate over a node’s immediate neighbors, for example, the best
    choice might be an adjacency list representation because we can access the neighbor
    lists independently. In contrast, for algorithms that are more mathematical, we
    might prefer a matrix representation that can make use of existing mathematical
    libraries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图的结构及其底层实现构成了本书所有算法的基础，并推动了它们的发展。决定使用哪种表示方式要求我们根据任务的具体情况考虑内存使用、计算效率和复杂性之间的权衡。例如，在我们只想遍历一个节点的直接邻居时，最好的选择可能是邻接表表示，因为我们可以独立地访问邻居列表。相比之下，对于那些更具数学性的算法，我们可能更倾向于使用矩阵表示，因为它可以利用现有的数学库。
- en: The goal of introducing the implementations in this chapter is not to provide
    a single canonical approach, but rather to introduce the different ways of thinking
    about graphs and the different trade-offs inherent in their representations. There
    are a huge variety of hybrid approaches or further adaptations we can make to
    the implementations presented in this chapter to optimize a graph representation
    to the problem of interest.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本章引入实现的目的是为了展示图的不同思考方式和它们在表示中固有的不同权衡，而不是提供一种单一的标准方法。我们可以对本章中介绍的实现进行多种混合方式或进一步的调整，以优化图的表示，以解决我们关注的问题。
- en: In the following chapters, we’ll introduce a series of problems we can solve
    using graphs, building on the concepts and code introduced in this chapter as
    we do so. For each problem, we present a few practical algorithms that can readily
    be applied in real-world situations. We’ll start in the next chapter by introducing
    the concept of neighboring nodes and using algorithms to construct neighborhoods.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍一系列可以使用图解决的问题，并在此过程中继续扩展本章引入的概念和代码。对于每个问题，我们将介绍一些可以直接应用于实际情况的实用算法。在下一章，我们将从引入邻居节点的概念开始，并使用算法构建邻域。
