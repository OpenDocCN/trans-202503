- en: Chapter 2. Making Charts Interactive
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章：使图表具有交互性
- en: In [Chapter 1](ch01.html "Chapter 1. Graphing Data") we saw how to create a
    wide variety of simple, static charts. In many cases such charts are the ideal
    visualization, but they don’t take advantage of an important characteristic of
    the Web—interactivity. Sometimes you want to do more than just present data to
    your users; you want to give them a chance to explore the data, to focus on the
    elements they find particularly interesting, or to consider alternative scenarios.
    In those cases we can take advantage of the Web as a medium by adding interactivity
    to our visualizations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章：数据图形化")中，我们学习了如何创建各种简单的静态图表。在许多情况下，这些图表是理想的可视化方式，但它们没有利用互联网的一个重要特性——交互性。有时候，你希望做的不仅仅是展示数据，而是希望给用户一个机会，让他们能够探索数据、聚焦他们感兴趣的元素，或是考虑不同的情境。在这种情况下，我们可以通过为可视化内容添加交互性，来充分利用互联网这一媒介。
- en: Because they’re designed for the Web, virtually all of the libraries and toolkits
    we examine in this book include support for interactivity. That’s certainly true
    of the Flotr2 library used in [Chapter 1](ch01.html "Chapter 1. Graphing Data").
    But let’s take the opportunity to explore an alternative. In this chapter, we’ll
    use the *Flot library* (*[http://www.flotcharts.org/](http://www.flotcharts.org/)*),
    which is based on jQuery and features exceptionally strong support for interactive
    and real-time charts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们是为互联网设计的，几乎所有我们在本书中讨论的库和工具包都支持交互性。Flotr2库就是在[第1章](ch01.html "第1章：数据图形化")中使用的一个例子，它肯定符合这一特点。但让我们抓住机会探索一个替代方案。在本章中，我们将使用*Flot库*（*[http://www.flotcharts.org/](http://www.flotcharts.org/)*），它基于jQuery，并且在交互式和实时图表方面提供了异常强大的支持。
- en: 'For this chapter, we’re also going to stick with a single data source: the
    gross domestic product (GDP) for countries worldwide. This data is publicly available
    from the *World Bank* (*[http://data.worldbank.org/](http://data.worldbank.org/)*).
    It may not seem like the most exciting data to work with, but effective visualizations
    can bring even the most mundane data alive. Here’s what you’ll learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仍然会使用一个数据源：全球各国的国内生产总值（GDP）。这些数据可以从*世界银行*（*[http://data.worldbank.org/](http://data.worldbank.org/)*）公开获取。虽然这看起来并不是最激动人心的数据，但有效的可视化可以让即便是最平凡的数据也焕发活力。你将在本章学到以下内容：
- en: How to let users select the content for a chart
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让用户选择图表的内容
- en: How to let users zoom into a chart to see more details
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让用户放大图表以查看更多细节
- en: How to make a chart respond to user mouse movements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使图表响应用户的鼠标移动
- en: How to dynamically get data for a chart using an AJAX service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过AJAX服务动态获取图表数据
- en: Selecting Chart Content
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择图表内容
- en: If you’re presenting data to a large audience on the Web, you may find that
    different users are especially interested in different aspects of your data. With
    global GDP data, for example, we might expect that individual users would be most
    interested in the data for their own region of the world. If we can anticipate
    inquiries like this from the user, we can construct our visualization to answer
    them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网上向大量观众展示数据，你可能会发现不同的用户特别关注数据的不同方面。例如，针对全球GDP数据，我们可能会预期个别用户最感兴趣的是自己所在地区的数据。如果我们能够预见到用户会有类似的需求，我们就可以根据这些需求来构建我们的可视化。
- en: In this example, we’re targeting a worldwide audience, and we want to show data
    for all regions. To accommodate individual users, however, we can make the regions
    selectable; that is, users will be able to show or hide the data from each region.
    If some users don’t care about data for particular regions, they can simply choose
    not to show it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们面向的是全球观众，并且希望展示所有地区的数据。然而，为了适应个别用户的需求，我们可以使各个地区的数据可选择；也就是说，用户可以选择显示或隐藏各个地区的数据。如果某些用户对某些地区的数据不感兴趣，他们可以简单地选择不显示这些数据。
- en: Interactive visualizations usually require more thought than simple, static
    charts. Not only must the original presentation of data be effective, but the
    way the user controls the presentation *and* the way the presentation responds
    must be effective as well. It usually helps to consider each of those requirements
    explicitly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式可视化通常比简单的静态图表需要更多的思考。数据的初始展示不仅必须有效，用户控制展示的方式*以及*展示响应的方式也必须有效。通常，明确地考虑这些要求会有助于提高效果。
- en: Make sure the initial, static presentation shows the data effectively.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保最初的静态展示有效地显示数据。
- en: Add any user controls to the page and ensure they make sense for the visualization.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向页面添加任何用户控件，并确保它们对于可视化是合理的。
- en: Add the code that makes the controls work.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加使控件工作的代码。
- en: We’ll tackle each of these phases in the following example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下示例中逐一解决这些阶段。
- en: 'Step 1: Include the Required JavaScript Libraries'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步：包含所需的 JavaScript 库
- en: 'Since we’re using the Flot library to create the chart, we need to include
    that library in our web pages. And since Flot requires jQuery, we’ll include that
    in our pages as well. Fortunately, both jQuery and Flot are popular libraries,
    and they are available on public *content distribution networks (CDNs)*. That
    gives you the option of loading both from a CDN instead of hosting them on your
    own site. There are several advantages to relying on a CDN:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Flot 库来创建图表，因此需要在网页中包含该库。由于 Flot 需要 jQuery，我们也会将 jQuery 包含在页面中。幸运的是，jQuery
    和 Flot 都是流行的库，并且它们可以在公共的 *内容分发网络 (CDN)* 上找到。这使得你可以选择从 CDN 加载它们，而不是在自己的网站上托管它们。依赖
    CDN 有几个优点：
- en: '****Better performance****. If the user has previously visited other websites
    that retrieved the libraries from the same CDN, then the libraries may already
    exist in the browser’s local cache. In that case the browser simply retrieves
    them from the cache, avoiding the delay of additional network requests. (See the
    second disadvantage in the next list for a different view on performance.)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****更好的性能****。如果用户之前访问过其他从相同 CDN 获取库的网站，那么这些库可能已经存在于浏览器的本地缓存中。在这种情况下，浏览器只需从缓存中获取这些库，避免了额外网络请求的延迟。（参见下一个列表中的第二个缺点，对于性能有不同的看法。）'
- en: '****Lower cost****. One way or another, the cost of your site is likely based
    on how much bandwidth you use. If your users are able to retrieve libraries from
    a CDN, then the bandwidth required to service their requests won’t count against
    your site.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****成本更低****。无论如何，你的网站成本通常是基于你使用的带宽量。如果用户能够从 CDN 获取库，那么处理他们请求所需的带宽就不算作你网站的带宽使用。'
- en: Of course there are also disadvantages to CDNs as well.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，CDN 也有一些缺点。
- en: '****Loss of control****. If the CDN goes down, then the libraries your page
    needs won’t be available. That puts your site’s functionality at the mercy of
    the CDN. There are approaches to mitigate such failures. You can try to retrieve
    from the CDN and fall back to your own hosted copy if the CDN request fails. Implementing
    such a fallback is tricky, though, and it could introduce errors in your code.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****失去控制****。如果 CDN 崩溃，那么你页面所需的库将无法使用。这将使你网站的功能受制于 CDN。虽然有一些方法可以缓解这种故障，你可以尝试从
    CDN 获取库，如果请求失败，则回退到自己托管的副本。然而，实施这种回退机制比较复杂，可能会在你的代码中引入错误。'
- en: '****Lack of flexibility****. With CDN-hosted libraries, you’re generally stuck
    with a limited set of options. For example, in this case we need both the jQuery
    and Flot libraries. CDNs provide those libraries only as distinct files, so to
    get both we’ll need two network requests. If we host the libraries ourselves,
    on the other hand, we can combine them into a single file and cut the required
    number of requests in half. For high-latency networks (such as mobile networks),
    the number of requests may be the biggest factor in determining the performance
    of your web page.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****缺乏灵活性****。使用 CDN 托管的库时，你通常会受到有限选项的限制。例如，在这种情况下，我们需要同时使用 jQuery 和 Flot 库。CDN
    只提供这些库作为独立的文件，因此为了获取这两个库，我们需要进行两次网络请求。另一方面，如果我们自己托管这些库，我们可以将它们合并成一个文件，从而减少请求的次数。对于高延迟的网络（例如移动网络），请求次数可能是决定网页性能的最大因素。'
- en: There isn’t a clear-cut answer for all cases, so you’ll have to weigh the options
    against your own requirements. For this example (and the others in this chapter),
    we’ll use the CloudFlare CDN.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有情况，并没有明确的答案，因此你需要根据自己的需求权衡选择。对于这个示例（以及本章中的其他示例），我们将使用 CloudFlare CDN。
- en: 'In addition to the jQuery library, Flot relies on the HTML canvas feature.
    To support IE8 and earlier, we’ll include the excanvas.min.js library in our pages
    and make sure that only IE8 and earlier will load it, just like we did for our
    bar chart in [Chapter 1](ch01.html "Chapter 1. Graphing Data"). Also, since excanvas
    isn’t available on a public CDN, we’ll have to host it on our own server. Here’s
    the skeleton to start with:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 jQuery 库，Flot 还依赖于 HTML canvas 特性。为了支持 IE8 及更早版本，我们将在页面中包含 excanvas.min.js
    库，并确保只有 IE8 及更早版本会加载它，就像我们在[第 1 章](ch01.html "第 1 章. 绘制数据")中的条形图所做的那样。此外，由于 excanvas
    在公共 CDN 上不可用，我们必须将其托管在自己的服务器上。下面是开始时的框架：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we’re including the JavaScript libraries at the end of the document.
    This approach lets the browser load the document’s entire HTML markup and begin
    laying out the page while it waits for the server to provide the JavaScript libraries.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在文档的末尾包含了 JavaScript 库。这种做法让浏览器在等待服务器提供 JavaScript 库时，能够先加载整个 HTML 标记并开始布局页面。
- en: 'Step 2: Set Aside a <div> Element to Hold the Chart'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：为图表预留一个 <div> 元素
- en: Within our document, we need to create a `<div>` element to contain the chart
    we’ll construct. This element must have an explicit height and width, or Flot
    won’t be able to construct the chart. We can indicate the element’s size in a
    CSS style sheet, or we can place it directly on the element itself. Here’s how
    the document might look with the latter approach.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文档中，我们需要创建一个 `<div>` 元素来容纳我们将构建的图表。这个元素必须具有明确的高度和宽度，否则 Flot 将无法构建图表。我们可以在
    CSS 样式表中指定元素的大小，或者直接在元素本身上设置。以下是使用后者方法时文档的样子。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note at ➊ that we’ve given the <`div>` an explicit `id` so we can reference
    it later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 ➊，我们为 <`div>` 元素指定了一个明确的 `id`，以便后续引用。
- en: 'Step 3: Prepare the Data'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：准备数据
- en: In later examples we’ll see how to get the data directly from the World Bank’s
    web service, but for this example, let’s keep things simple and assume we have
    the data already downloaded and formatted for JavaScript. (For brevity, only excerpts
    are shown here. The book’s source code includes the full data set.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的例子中，我们将看到如何直接从世界银行的网络服务获取数据，但在这个例子中，为了简化，我们假设数据已经下载并且格式化为 JavaScript 使用。（为了简洁，这里仅展示了部分内容。书本的源代码包括完整的数据集。）
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This data includes the historical GDP (in current US dollars) for major regions
    of the world, from 1960 to 2011\. The names of the variables are the World Bank
    region codes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据包括了1960到2011年期间，世界主要地区的历史 GDP（按当前美元计算）。变量名称为世界银行的区域代码。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**At the time of this writing, World Bank data for North America was temporarily
    unavailable.**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本文写作时，世界银行关于北美的数据暂时无法获取。**'
- en: 'Step 4: Draw the Chart'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4：绘制图表
- en: Before we add any interactivity, let’s check out the chart itself. The Flot
    library provides a simple function call to create a static graph. We call the
    jQuery extension `plot` and pass it two parameters. The first parameter identifies
    the HTML element that should contain the chart, and the second parameter provides
    the data as an array of data sets. In this case, we pass in an array with the
    series we defined earlier for each region.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加任何交互功能之前，先来看一下图表本身。Flot 库提供了一个简单的函数调用来创建静态图表。我们调用 jQuery 扩展 `plot` 并传递两个参数。第一个参数标识了应该包含图表的
    HTML 元素，第二个参数提供了作为数据集数组的数据。在这个例子中，我们传入了一个数组，其中包含了我们之前为每个区域定义的系列数据。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Figure 2-1](ch02.html#flot_can_show_a_static_line_chart_well_w "Figure 2-1. Flot
    can show a static line chart well with just default options.") shows the resulting
    chart.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.html#flot_can_show_a_static_line_chart_well_w "图 2-1. Flot 仅使用默认选项即可很好地显示静态折线图。")
    显示了生成的图表。'
- en: '![Flot can show a static line chart well with just default options.](figs/web/02fig01.png.jpg)Figure 2-1. Flot
    can show a static line chart well with just default options.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![Flot 仅使用默认选项即可很好地显示静态折线图。](figs/web/02fig01.png.jpg) 图 2-1. Flot 仅使用默认选项即可很好地显示静态折线图。'
- en: It looks like we’ve done a good job of capturing and presenting the data statically,
    so we can move on to the next phase.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经很好地捕获并展示了数据的静态版本，因此我们可以进入下一阶段。
- en: 'Step 5: Add the Controls'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 5：添加控件
- en: 'Now that we have a chart we’re happy with, we can add the HTML controls to
    interact with it. For this example, our goal is fairly simple: our users should
    be able to pick which regions appear on the graph. We’ll give them that option
    with a set of checkboxes, one for each region. Here’s the markup to include the
    checkboxes.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个满意的图表，我们可以添加 HTML 控件与其进行交互。在这个例子中，我们的目标相对简单：用户应该能够选择在图表中显示哪些区域。我们将通过一组复选框为每个区域提供这个选项。以下是包含复选框的标记代码。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may be surprised to see that we’ve placed the `<input>` controls inside
    the `<label>` elements. Although it looks a little unusual, that’s almost always
    the best approach. When we do that, the browser interprets clicks on the label
    as clicks on the control, whereas if we separate the labels from the controls,
    it forces the user to click on the tiny checkbox itself to have any effect.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶于我们将 `<input>` 控件放在 `<label>` 元素内。虽然这看起来有点不寻常，但几乎总是最好的做法。这样做时，浏览器会将对标签的点击解释为对控件的点击，而如果我们将标签和控件分开，它就会强迫用户点击微小的复选框本身才能产生效果。
- en: On our web page, we’d like to place the controls on the right side of the chart.
    We can do that by creating a containing `<div>` and making the chart and the controls
    float (left) within it. While we’re experimenting with the layout, it’s easiest
    to simply add the styling directly in the HTML markup. In a production implementation,
    you might want to define the styles in an external style sheet.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网页中，我们希望将控件放在图表的右侧。我们可以通过创建一个包含 `<div>` 来实现，并让图表和控件在其中浮动（向左）。在我们调整布局时，最简单的方法是直接在
    HTML 标记中添加样式。在生产环境中，你可能希望在外部样式表中定义样式。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We should also add a title and instructions and make all the `<input>` checkboxes
    default to `checked`. Let’s see the chart now, to make sure the formatting looks
    okay ([Figure 2-2](ch02.html#standard_html_can_create_controls_for_ch "Figure 2-2. Standard
    HTML can create controls for chart interaction.")).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该添加标题和说明，并将所有的 `<input>` 复选框默认设置为 `checked`。现在让我们看看图表，确保格式看起来没问题（[图 2-2](ch02.html#standard_html_can_create_controls_for_ch
    "图 2-2. 标准 HTML 可以创建图表交互控件。")）。
- en: '![Standard HTML can create controls for chart interaction.](figs/web/02fig02.png.jpg)Figure 2-2. Standard
    HTML can create controls for chart interaction.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![标准 HTML 可以创建图表交互控件。](figs/web/02fig02.png.jpg)图 2-2. 标准 HTML 可以创建图表交互控件。'
- en: 'Now we see how the controls look in relation to the chart in [Figure 2-2](ch02.html#standard_html_can_create_controls_for_ch
    "Figure 2-2. Standard HTML can create controls for chart interaction."), and we
    can verify that they make sense both for the data and for the interaction model.
    Our visualization lacks a critical piece of information, though: it doesn’t identify
    which line corresponds to which region. For a static visualization, we could simply
    use the Flot library to add a legend to the chart, but that approach isn’t ideal
    here. You can see the problem in [Figure 2-3](ch02.html#flot_libraryapostrophes_standard_legend
    "Figure 2-3. The Flot library’s standard legend doesn’t match the chart styles
    well."), as the legend looks confusingly like the interaction controls.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到控制项相对于图表在[图 2-2](ch02.html#standard_html_can_create_controls_for_ch "图
    2-2. 标准 HTML 可以创建图表交互控件。")中的样子，我们可以验证它们是否对数据和交互模型都有意义。然而，我们的可视化缺少一个关键信息：它没有标明哪条线对应哪个区域。对于静态可视化，我们可以简单地使用
    Flot 库向图表添加图例，但这种方法在这里并不理想。你可以在[图 2-3](ch02.html#flot_libraryapostrophes_standard_legend
    "图 2-3. Flot 库的标准图例与图表样式不匹配。")中看到这个问题，因为图例看起来与交互控件相似，容易造成混淆。
- en: '![The Flot library’s standard legend doesn’t match the chart styles well.](figs/web/02fig03.png.jpg)Figure 2-3. The
    Flot library’s standard legend doesn’t match the chart styles well.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![Flot 库的标准图例与图表样式不匹配。](figs/web/02fig03.png.jpg)图 2-3. Flot 库的标准图例与图表样式不匹配。'
- en: We can eliminate the visual confusion by combining the legend and the interaction
    controls. The checkbox controls will serve as a legend if we add color boxes that
    identify the chart lines.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将图例和交互控件结合起来，消除视觉上的混乱。如果我们添加颜色框来标识图表线条，复选框控件将作为图例。
- en: We can add the colored boxes using an HTML `<span>` tag and a bit of styling.
    Here is the markup for one such checkbox with the styles inline. (Full web page
    implementations might be better organized by having most of the styles defined
    in an external style sheet.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 HTML `<span>` 标签和一些样式来添加这些彩色框。这是一个带有内联样式的复选框标记代码。（对于完整的网页实现，可能更好地通过在外部样式表中定义大部分样式来组织。）
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In addition to the background color, the `<span>` needs an explicit size, and
    we use an `inline-block` value for the `display` property to force the browser
    to show the span even though it has no content. As you can also see, we’re using
    `em`s instead of pixels to define the size of the block. Since `ems` scale automatically
    with the text size, the color blocks will match the text label size even if users
    zoom in or out on the page.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了背景色之外，`<span>` 还需要一个明确的大小，我们使用 `inline-block` 值作为 `display` 属性，以强制浏览器显示该 span，即使它没有内容。如您所见，我们使用
    `em` 而不是像素来定义块的大小。由于 `em` 会随着文本大小自动缩放，因此即使用户在页面上缩放，颜色块也会与文本标签大小匹配。
- en: A quick check in the browser can verify that the various elements combine effectively
    ([Figure 2-4](ch02.html#interaction_controls_can_also_serve_as_c "Figure 2-4. Interaction
    controls can also serve as chart elements such as legends.")).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中快速检查可以验证各种元素是否有效地结合在一起（[图 2-4](ch02.html#interaction_controls_can_also_serve_as_c
    "图 2-4. 交互控制也可以作为图表元素，如图例")）。
- en: '![Interaction controls can also serve as chart elements such as legends.](figs/web/02fig04.png.jpg)Figure 2-4. Interaction
    controls can also serve as chart elements such as legends.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![交互控制也可以作为图表元素，如图例](figs/web/02fig04.png.jpg)图 2-4. 交互控制也可以作为图表元素，如图例。'
- en: That looks pretty good, so now we can move on to the interaction itself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来相当不错，现在我们可以继续进行交互部分的开发了。
- en: 'Step 6: Define the Data Structure for the Interaction'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 6：定义交互数据结构
- en: Now that the general layout looks good, we can turn back to JavaScript. First
    we need to expand our data to track the interaction state. Instead of storing
    the data as simple arrays of values, we’ll use an array of objects. Each object
    will include the corresponding data values along with other properties.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一般布局看起来不错，我们可以回到 JavaScript。首先，我们需要扩展数据以跟踪交互状态。我们不再将数据存储为简单的数值数组，而是使用一个对象数组。每个对象将包含相应的数据值以及其他属性。
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each object includes the data points for a region, and it also gives us a place
    to define additional properties, including the label for the series and other
    status information. One property that we want to track is whether the series should
    be included on the chart (using the key `show`). We also need to specify the color
    for each line; otherwise, the Flot library will pick the color dynamically based
    on how many regions are visible at the same time, and we won’t be able to match
    the color with the control legend.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都包含一个区域的数据点，同时也为我们提供了一个地方来定义附加属性，包括系列标签和其他状态信息。我们想要跟踪的一个属性是系列是否应该包含在图表中（使用键
    `show`）。我们还需要为每条线指定颜色；否则，Flot 库会根据同时可见的区域数量动态选择颜色，这样我们就无法将颜色与控制图例匹配。
- en: 'Step 7: Determine Chart Data Based on the Interaction State'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 7：根据交互状态确定图表数据
- en: 'When we call `plot()` to draw the chart, we need to pass in an object containing
    the data series and the color for each region. The `source` array has the information
    we need, but it contains other information as well, which could potentially make
    Flot behave unexpectedly. We want to pass in a simpler object to the plot function.
    For example, the East Asia & Pacific series would be defined this way:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `plot()` 来绘制图表时，需要传入一个包含数据系列和每个区域颜色的对象。`source` 数组包含我们需要的信息，但它还包含其他信息，可能会导致
    Flot 行为异常。我们希望向 `plot` 函数传递一个更简单的对象。例如，东亚与太平洋系列将这样定义：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also want to be sure to show the data only for regions the user has selected.
    That may be only a subset of the complete data set. Those two operations—transforming
    array elements (in this case, to simpler objects) and filtering an array to a
    subset—are very common requirements for visualizations. Fortunately, jQuery has
    two utility functions that make both operations easy: `$.map()` and `$.grep()`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望确保只显示用户选择的区域数据。这可能只是完整数据集的一个子集。这两项操作——将数组元素转换（在这种情况下，转换为更简单的对象）和过滤数组以获取子集——是可视化中非常常见的需求。幸运的是，jQuery
    提供了两个实用函数，使得这两个操作变得非常简单：`$.map()` 和 `$.grep()`。
- en: Both `.grep()` and `.map()` accept two parameters. The first parameter is an
    array or, more precisely, an “array-like” object. That’s either a JavaScript array
    or another JavaScript object that looks and acts like an array. (There is a technical
    distinction, but it’s not something we have to worry about here.) The second parameter
    is a function that operates on elements of the array one at a time. For `.grep()`,
    that function returns `true` or `false` to filter out elements accordingly. In
    the case of `.map()`, the function returns a transformed object that replaces
    the original element in the array. [Figure 2-5](ch02.html#jquery_library_has_utility_functions_to
    "Figure 2-5. The jQuery library has utility functions to help transform and filter
    data.") shows how these functions convert the initial data into the final data
    array.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`.grep()` 和 `.map()` 都接受两个参数。第一个参数是一个数组，或者更准确地说，是一个“类似数组”的对象。它可以是一个 JavaScript
    数组，也可以是另一个看起来并且像数组一样工作的 JavaScript 对象。（这里有技术上的区别，但我们无需担心。）第二个参数是一个对数组元素逐一操作的函数。对于
    `.grep()`，该函数返回 `true` 或 `false`，以相应地过滤掉元素。对于 `.map()`，该函数返回一个转换后的对象，替换数组中的原始元素。[图
    2-5](ch02.html#jquery_library_has_utility_functions_to "图 2-5. jQuery 库提供了帮助转换和过滤数据的实用函数。")
    显示了这些函数如何将初始数据转换为最终的数据数组。'
- en: '![The jQuery library has utility functions to help transform and filter data.](figs/web/02fig05.png.jpg)Figure 2-5. The
    jQuery library has utility functions to help transform and filter data.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![jQuery 库提供了帮助转换和过滤数据的实用函数。](figs/web/02fig05.png.jpg)图 2-5. jQuery 库提供了帮助转换和过滤数据的实用函数。'
- en: Taking these one at a time, here’s how to filter out irrelevant data from the
    response. We use `.grep()` to check the `show` property in our source data so
    that it returns an array with only the objects where `show` is set to `true`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一步一步来看，以下是如何从响应中过滤掉无关数据的过程。我们使用 `.grep()` 来检查源数据中的 `show` 属性，以便返回一个只包含 `show`
    设置为 `true` 的对象的数组。
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And here’s how to transform the elements to retain only relevant properties:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何转换元素以保留相关属性：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There’s no need to make these separate steps. We can combine them in a nice,
    concise expression as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要将这些步骤分开。我们可以将它们组合成一个简洁的表达式，如下所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That expression in turn provides the input data to Flot’s `plot()` function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式进而将输入数据提供给 Flot 的 `plot()` 函数。
- en: 'Step 8: Add the Controls Using JavaScript'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 8 步：使用 JavaScript 添加控件
- en: Now that our new data structure can provide the chart input, let’s use it to
    add the checkbox controls to the page as well. The jQuery `.each()` function is
    a convenient way to iterate through the array of regions. Its parameters include
    an array of objects and a function to execute on each object in the array. That
    function takes two parameters, the array index and the array object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的新数据结构可以提供图表输入，让我们用它来将复选框控件也添加到页面中。jQuery 的 `.each()` 函数是一种方便的方式，可以遍历区域数组。它的参数包括一个对象数组和一个在数组中的每个对象上执行的函数。该函数有两个参数，分别是数组索引和数组对象。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Within the iteration function we do four things. First, we create the checkbox
    `<input>` control. As you can see, we’re giving each control a unique `id` attribute
    that combines the `chk-` prefix with the source array index. If the chart is showing
    that region, the control’s `checked` property is set to `true`. Next we create
    the `<span>` for the color block. We’re setting all the styles, including the
    region’s color, using the `css()` function. The third element we create in the
    function is the `<label>`. To that element we append the checkbox `<input>` control,
    the color box `<span>`, and the region’s name. Finally, we add the `<label>` to
    the document.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代函数中，我们做了四件事。首先，我们创建了复选框 `<input>` 控件。如你所见，我们给每个控件分配了一个唯一的 `id` 属性，组合了 `chk-`
    前缀和源数组索引。如果图表显示该区域，则控件的 `checked` 属性设置为 `true`。接着，我们为颜色块创建了一个 `<span>` 元素。我们使用
    `css()` 函数设置了所有样式，包括该区域的颜色。第三个元素是我们在函数中创建的 `<label>` 元素。我们将复选框 `<input>` 控件、颜色块
    `<span>` 和区域名称添加到该元素中。最后，我们将 `<label>` 元素添加到文档中。
- en: Notice that we don’t add the intermediate elements (such as the `<input>` or
    the `<span>`) directly to the document. Instead, we construct those elements using
    local variables. We then assemble the local variables into the final, complete
    `<label>` and add that to the document. This approach significantly improves the
    performance of web pages. Every time JavaScript code adds elements to the document,
    the web browser has to recalculate the appearance of the page. For complex pages,
    that can take time. By assembling the elements before adding them to the document,
    we’ve only forced the browser to perform that calculation once for each region.
    (You could further optimize performance by combining all of the regions in a local
    variable and adding only that single local variable to the document.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有直接将中间元素（如 `<input>` 或 `<span>`）添加到文档中。相反，我们使用局部变量构建这些元素。然后，我们将局部变量组装成最终的完整
    `<label>` 并将其添加到文档中。这种方法显著提高了网页的性能。每次 JavaScript 代码向文档中添加元素时，网页浏览器都需要重新计算页面的外观。对于复杂的页面来说，这可能需要一些时间。通过在将元素添加到文档之前先进行组装，我们只需要强制浏览器为每个区域执行一次该计算。（你还可以通过将所有区域合并为一个局部变量，并只将该单个局部变量添加到文档中来进一步优化性能。）
- en: If we combine the JavaScript to draw the chart with the JavaScript to create
    the controls, we need only a skeletal HTML structure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将用来绘制图表的 JavaScript 与用来创建控件的 JavaScript 结合起来，我们只需要一个骨架的 HTML 结构。
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our reward is the visualization in [Figure 2-6](ch02.html#setting_the_chart_options_ensures_that_t
    "Figure 2-6. Setting the chart options ensures that the data matches the legend.")—the
    same one as shown in [Figure 2-4](ch02.html#interaction_controls_can_also_serve_as_c
    "Figure 2-4. Interaction controls can also serve as chart elements such as legends.")—but
    this time we’ve created it dynamically using JavaScript.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的奖励是[图 2-6](ch02.html#setting_the_chart_options_ensures_that_t "图 2-6. 设置图表选项确保数据与图例匹配.")中的可视化——与[图
    2-4](ch02.html#interaction_controls_can_also_serve_as_c "图 2-4. 交互控件还可以作为图表元素，例如图例.")中显示的相同——但这一次我们使用
    JavaScript 动态创建了它。
- en: '![Setting the chart options ensures that the data matches the legend.](figs/web/02fig06.png.jpg)Figure 2-6. Setting
    the chart options ensures that the data matches the legend.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![设置图表选项确保数据与图例匹配。](figs/web/02fig06.png.jpg)图 2-6. 设置图表选项确保数据与图例匹配。'
- en: 'Step 9: Respond to the Interaction Controls'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 9 步：响应交互控件
- en: We still haven’t added any interactivity, of course, but we’re almost there.
    Our code just needs to watch for clicks on the controls and redraw the chart appropriately.
    Since we’ve conveniently given each checkbox an `id` attribute that begins with
    `chk-`, it’s easy to watch for the right events.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还没有添加任何交互功能，但我们快完成了。我们的代码只需要监听控件的点击事件，并适当地重新绘制图表。由于我们方便地为每个复选框设置了以 `chk-`
    开头的 `id` 属性，所以很容易监听到正确的事件。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the code sees a click, it should determine which checkbox was clicked,
    toggle the `show` property of the data source, and redraw the chart. We can find
    the specific region by skipping past the four-character `chk-` prefix of the event
    target’s `id` attribute.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码检测到点击时，它应该判断点击了哪个复选框，切换数据源的 `show` 属性，并重新绘制图表。我们可以通过跳过事件目标 `id` 属性中的四个字符的
    `chk-` 前缀来找到具体的区域。
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Redrawing the chart requires a couple of calls to the chart object that `plot()`
    returns. We reset the data and then tell the library to redraw the chart.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重新绘制图表需要对 `plot()` 返回的图表对象进行几次调用。我们重置数据，然后告诉库重新绘制图表。
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And that’s it. We finally have a fully interactive visualization of regional
    gross domestic product, as shown in [Figure 2-7](ch02.html#interactive_chart_gives_users_control_ov
    "Figure 2-7. An interactive chart gives users control over the visualization.").
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们最终得到了一个完全交互式的地区国内生产总值可视化，如[图 2-7](ch02.html#interactive_chart_gives_users_control_ov
    "图 2-7. 交互式图表让用户控制可视化效果.")所示。
- en: '![An interactive chart gives users control over the visualization.](figs/web/02fig07.png.jpg)Figure 2-7. An
    interactive chart gives users control over the visualization.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![交互式图表让用户控制可视化效果。](figs/web/02fig07.png.jpg)图 2-7. 交互式图表让用户控制可视化效果。'
- en: The visualization we’ve created engages users more effectively than a static
    chart. They can still see the overall picture, but the interaction controls let
    them focus on aspects of the data that are especially important or interesting
    to them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的可视化比静态图表更有效地吸引用户。用户仍然可以看到整体情况，但交互控件让他们能够关注对他们来说特别重要或有趣的数据方面。
- en: There is still a potential problem with this implementation. Two data sets (Europe
    and East Asia & Pacific) dominate the chart. When users deselect those regions,
    the remaining data is confined to the very bottom of the chart, and much of the
    chart’s area is wasted. You could address this by rescaling the chart every time
    you draw it. To do this, you would call `plotObj.setupGrid()` before calling `plotObj.draw()`.
    On the other hand, users may find this constant rescaling disconcerting, because
    it changes the whole chart, not just the region they selected. In the next example,
    we’ll address this type of problem by giving users total control over the scale
    of both axes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现仍然存在潜在的问题。两个数据集（欧洲和东亚与太平洋）主导了图表。当用户取消选择这些区域时，剩余的数据被限制在图表的底部，图表的大部分区域被浪费。你可以通过每次绘制图表时重新调整图表的比例来解决这个问题。为此，你需要在调用
    `plotObj.draw()` 之前调用 `plotObj.setupGrid()`。另一方面，用户可能会觉得这种持续的重新缩放令人不安，因为它改变了整个图表，而不仅仅是他们选择的区域。在下一个示例中，我们将通过让用户完全控制两个轴的缩放来解决这类问题。
- en: Zooming In on Charts
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在图表上缩放
- en: So far, we’ve given users some interaction with the visualization by letting
    them choose which data sets appear. In many cases, however, you’ll want to give
    them even more control, especially if you’re showing a lot of data and details
    are hard to discern. If users can’t see the details they need, our visualization
    has failed. Fortunately, we can avoid this problem by giving users a chance to
    inspect fine details within the data. One way to do that is to let users zoom
    in on the chart.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过让用户选择显示哪些数据集，为用户提供了一些交互。但在许多情况下，你可能希望给他们更多控制，特别是当你展示大量数据而细节难以辨别时。如果用户看不到他们需要的细节，那么我们的可视化就失败了。幸运的是，我们可以通过让用户检查数据中的细节来避免这个问题。一种方法是允许用户在图表上进行缩放。
- en: 'Although the Flot library in its most basic form does not support zooming,
    there are at least two library extensions that add this feature: the *selection*
    plug-in and the *navigation* plug-in. The navigation plug-in acts a bit like Google
    Maps. It adds a control that looks like a compass to one corner of the plot and
    gives users arrows and buttons to pan or zoom the display. This interface is not
    especially effective for charts, however. Users cannot control exactly how much
    the chart pans or zooms, which makes it difficult for them to anticipate the effect
    of an action.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Flot 库在最基本的形式下不支持缩放，但至少有两个库扩展可以添加此功能：*选择* 插件和 *导航* 插件。导航插件有点像 Google 地图。它在图表的一个角落添加了一个类似指南针的控制，提供给用户用于平移或缩放显示的箭头和按钮。然而，这种界面对图表并不是特别有效。用户无法精确控制图表的平移或缩放量，这使得他们难以预见操作的效果。
- en: 'The selection plug-in provides a much better interface. Users simply drag their
    mouse across the area of the chart they want to zoom in on. The effect of this
    gesture is more intuitive, and users can be as precise as they like in those actions.
    The plug-in does have one significant downside, however: it doesn’t support touch
    interfaces.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 选择插件提供了一个更好的界面。用户只需拖动鼠标选择他们想要缩放的图表区域。这种操作的效果更加直观，用户可以根据需要精确控制这些操作。然而，该插件确实有一个显著的缺点：它不支持触摸界面。
- en: For this example, we’ll walk through the steps required to support zooming with
    the selection plug-in. Of course, the best approach for your own website and visualizations
    will vary from case to case.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将介绍如何通过选择插件支持缩放的步骤。当然，适用于你自己网站和可视化的最佳方法会因情况而异。
- en: 'Step 1: Prepare the Page'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：准备页面
- en: Because we’re sticking with the same data, most of the preparation is identical
    to the last example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是相同的数据，准备工作大部分与上一个示例相同。
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we do, however, have to add the selection plug-in to the page.
    It is not available on common CDNs, so we host it on our own server, as shown
    at ➊.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们确实需要将选择插件添加到页面中。它在常见的 CDN 上不可用，因此我们将其托管在自己的服务器上，如 ➊ 所示。
- en: 'Step 2: Draw the Chart'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：绘制图表
- en: Before we add any interactivity, let’s go back to a basic chart. This time,
    we’ll add a legend inside the chart since we won’t be including checkboxes next
    to the chart.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何交互性之前，让我们回到一个基本的图表。这一次，我们将在图表内部添加一个图例，因为我们不会在图表旁边包含复选框。
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we call the jQuery extension `plot` (from the Flot library) and pass it
    three parameters. The first parameter identifies the HTML element that should
    contain the chart, and the second parameter provides the data as an array of data
    series. These series contain regions we defined earlier, plus a label to identify
    each series. The final parameter specifies options for the plot. We’ll keep it
    simple for this example—the only option we’re including tells Flot to position
    the legend in the top-left (northwest) corner of the chart.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了jQuery扩展`plot`（来自Flot库），并传递了三个参数。第一个参数指定了应该包含图表的HTML元素，第二个参数提供了数据，数据是一个数据系列数组。这些系列包含了我们之前定义的区域，以及一个标识每个系列的标签。最后一个参数指定了图表的选项。为了简化示例，我们只包括一个选项，它告诉Flot将图例放置在图表的左上（西北）角。
- en: '[Figure 2-8](ch02.html#starting_point_for_most_interactive_char "Figure 2-8. The
    starting point for most interactive charts is a good static chart.") shows the
    resulting chart.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-8](ch02.html#starting_point_for_most_interactive_char "图 2-8. 大多数交互式图表的起点是一个好的静态图表。")
    显示了生成的图表。'
- en: '![The starting point for most interactive charts is a good static chart.](figs/web/02fig08.png.jpg)Figure 2-8. The
    starting point for most interactive charts is a good static chart.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![大多数交互式图表的起点是一个好的静态图表。](figs/web/02fig08.png.jpg) 图 2-8. 大多数交互式图表的起点是一个好的静态图表。'
- en: It looks like we’ve done a good job of capturing and presenting the data statically,
    so we can move on to the next phase.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经成功地静态展示了数据，因此可以进入下一个阶段。
- en: 'Step 3: Prepare the Data to Support Interaction'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：准备数据以支持交互
- en: Now that we have a working static chart, we can plan how to support interaction.
    As part of that support, and for the sake of convenience, we’ll store all the
    parameters we’re passing to `plot()` in local variables.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可工作的静态图表，我们可以规划如何支持交互。作为该支持的一部分，并且为了方便起见，我们将所有传递给`plot()`的参数存储在本地变量中。
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Before we call `plot()`, we create the variables `$el` ➊, `data` ➋, and `options`
    ➌. We’ll also need to save the object returned from `plot()` at ➍.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`plot()`之前，我们创建了变量`$el` ➊、`data` ➋和`options` ➌。我们还需要在 ➍ 保存从`plot()`返回的对象。
- en: 'Step 4: Prepare to Accept Interaction Events'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：准备接受交互事件
- en: Our code also has to prepare to handle the interaction events. The selection
    plug-in signals the user’s actions by triggering custom `plotselected` events
    on the element containing the chart. To receive these events, we need a function
    that expects two parameters—the standard JavaScript event object and a custom
    object containing details about the selection. We’ll worry about how to process
    the event shortly. For now let’s focus on preparing for it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码还需要准备处理交互事件。选择插件通过触发自定义的`plotselected`事件来传达用户的操作，这些事件作用于包含图表的元素。为了接收这些事件，我们需要一个函数，它期望两个参数——标准的JavaScript事件对象和一个包含选择详细信息的自定义对象。我们稍后会讨论如何处理该事件。现在我们先关注如何为它做准备。
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The jQuery `.on()` function assigns a function to an arbitrary event. Events
    can be standard JavaScript events such as `click`, or they can be custom events
    like the one we’re using. The event of interest is the first parameter to `.on()`.
    The second parameter is the function that will process the event. As noted previously,
    it also takes two parameters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的`.on()`函数将一个函数分配给一个任意事件。事件可以是标准的JavaScript事件，如`click`，也可以是我们正在使用的自定义事件。感兴趣的事件是`.on()`的第一个参数。第二个参数是处理该事件的函数。如前所述，它也接受两个参数。
- en: Now we can consider the action we want to take when our function receives an
    event. The `ranges` parameter contains both an `xaxis` and a `yaxis` object, which
    have information about the `plotselected` event. In both objects, the `from` and
    `to` properties specify the region that the user selected. To zoom to that selection,
    we can simply redraw the chart by using those ranges for the chart’s axes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以考虑当函数接收到事件时，我们希望执行的操作。`ranges`参数包含`xaxis`和`yaxis`对象，它们包含关于`plotselected`事件的信息。在这两个对象中，`from`和`to`属性指定了用户选择的区域。为了缩放到该选择区域，我们只需使用这些范围来重新绘制图表的坐标轴。
- en: Specifying the axes for the redrawn chart requires us to pass new options to
    the `plot()` function, but we want to preserve whatever options are already defined.
    The jQuery `.extend()` function gives us the perfect tool for that task. The function
    merges JavaScript objects so that the result contains all of the properties in
    each object. If the objects might contain other objects, then we have to tell
    jQuery to use “deep” mode when it performs the merge. Here’s the complete call
    to `plot()`, which we place inside the `plotselected` event handler.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新绘制图表并指定轴，我们需要将新的选项传递给`plot()`函数，但我们希望保留已经定义的选项。jQuery的`.extend()`函数为我们提供了完美的工具来完成这个任务。该函数合并
    JavaScript 对象，使得结果包含每个对象中的所有属性。如果对象中可能包含其他对象，我们需要告诉 jQuery在执行合并时使用“深度”模式。以下是完整的`plot()`调用，我们将其放入`plotselected`事件处理程序中。
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we use `.extend()`, the first parameter (`true`) requests deep mode, the
    second parameter specifies the starting object, and subsequent parameters specify
    additional objects to merge. We’re starting with an empty object (`{}`), merging
    the regular options, and then further merging the axis options for the zoomed
    chart.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`.extend()`时，第一个参数（`true`）请求深度模式，第二个参数指定起始对象，后续的参数指定要合并的其他对象。我们从一个空对象（`{}`）开始，合并常规选项，然后进一步合并缩放图表的轴选项。
- en: 'Step 5: Enable the Interaction'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步：启用交互
- en: Since we’ve included the selections plug-in library on our page, activating
    the interaction is easy. We simply include an additional `selection` option in
    our call to `plot()`. Its `mode` property indicates the direction of selections
    the chart will support. Possible values include `"x"` (for x-axis only), `"y"`
    (for y-axis only), or `"xy"` (for both axes). Here’s the complete `options` variable
    we want to use.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在页面上包含了选择插件库，激活交互变得非常简单。我们只需在调用`plot()`时添加一个额外的`selection`选项。其`mode`属性指示图表将支持的选择方向。可能的值包括`"x"`（仅限
    x 轴）、`"y"`（仅限 y 轴）或`"xy"`（同时支持两个轴）。以下是我们希望使用的完整`options`变量。
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And with that addition, our chart is now interactive. Users can zoom in to
    see as much detail as they want. There is a small problem, though: our visualization
    doesn’t give users a way to zoom back out. Obviously we can’t use the selection
    plug-in to zoom out, since that would require users to select outside the current
    chart area. Instead, we can add a button to the page to reset the zoom level.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个添加功能，我们的图表现在是交互式的。用户可以缩放以查看任何他们想要的细节。不过有一个小问题：我们的可视化并没有提供一种方式让用户缩小视图。显然，我们不能使用选择插件来缩小视图，因为那需要用户选择当前图表区域之外的内容。相反，我们可以在页面上添加一个按钮来重置缩放级别。
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can see the button in the markup at ➊; it’s right after the `<div>` that
    holds the chart.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在标记中看到按钮的位置在 ➊；它就在包含图表的`<div>`之后。
- en: Now we just need to add code to respond when a user clicks the button. Fortunately,
    this code is pretty simple.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要添加代码来响应用户点击按钮的操作。幸运的是，这段代码非常简单。
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we just set up a click handler with jQuery and redraw the chart using the
    original options. We don’t need any event data, so our event handling function
    doesn’t even need parameters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 jQuery 设置了一个点击处理程序，并使用原始选项重新绘制图表。我们不需要任何事件数据，因此我们的事件处理函数甚至不需要参数。
- en: That gives us a complete, interactive visualization. Users can zoom in to any
    level of detail and restore the original zoom with one click. You can see the
    interaction in [Figure 2-9](ch02.html#interactive_charts_let_users_focus_on_da
    "Figure 2-9. Interactive charts let users focus on data relevant to their needs.").
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就得到了一个完整的交互式可视化。用户可以缩放到任何细节级别，并通过点击一次恢复原始缩放。你可以在[图 2-9](ch02.html#interactive_charts_let_users_focus_on_da
    "图 2-9. 交互式图表让用户专注于与他们需求相关的数据")中看到交互效果。
- en: '![Interactive charts let users focus on data relevant to their needs.](figs/web/02fig09.png.jpg)Figure 2-9. Interactive
    charts let users focus on data relevant to their needs.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![交互式图表让用户专注于与他们需求相关的数据。](figs/web/02fig09.png.jpg)图 2-9. 交互式图表让用户专注于与他们需求相关的数据。'
- en: '[Figure 2-10](ch02.html#users_can_zoom_in_on_a_section_of_partic "Figure 2-10. Users
    can zoom in on a section of particular interest.") shows what the user sees after
    zooming in.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-10](ch02.html#users_can_zoom_in_on_a_section_of_partic "图 2-10. 用户可以缩放到特别感兴趣的部分")展示了用户缩放后看到的内容。'
- en: '![Users can zoom in on a section of particular interest.](figs/web/02fig10.png.jpg)Figure 2-10. Users
    can zoom in on a section of particular interest.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![用户可以缩放到特别感兴趣的部分。](figs/web/02fig10.png.jpg)图 2-10. 用户可以缩放到特别感兴趣的部分。'
- en: If you experiment with this example, you’ll soon see that users cannot select
    an area of the chart that includes the legend. That may be okay for your visualization,
    but if it’s not, the simplest solution is to create your own legend and position
    it off the chart’s canvas, like we did for the first example in this chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试这个示例，你会很快发现用户不能选择包括图例在内的图表区域。这对于你的可视化来说可能没问题，但如果不行，最简单的解决方法是创建你自己的图例，并将其放置在图表画布外面，就像我们在本章第一个示例中所做的那样。
- en: Tracking Data Values
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪数据值
- en: 'A big reason we make visualizations interactive is to give users control over
    their view of the data. We can present a “big picture” view of the data, but we
    don’t want to prevent users from digging into the details. Often, however, this
    can force an either/or choice on users: they can see the overall view, or they
    can see a detailed picture, but they can’t see both at the same time. This example
    looks at an alternative approach that enables users to see overall trends and
    specific details at once. To do that, we take advantage of the mouse as an input
    device. When the user’s mouse hovers over a section of the chart, our code overlays
    details relevant to that part of the chart.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使可视化交互式的一个主要原因是为了让用户控制他们查看数据的方式。我们可以展示数据的“整体视图”，但我们并不想阻止用户深入挖掘细节。然而，通常情况下，这会迫使用户做出“二选一”的选择：他们可以看到整体视图，或者可以看到详细的图像，但不能同时看到两者。这个示例展示了一种替代方法，使用户能够同时看到整体趋势和具体细节。为此，我们利用鼠标作为输入设备。当用户的鼠标悬停在图表的某一部分时，我们的代码会叠加显示与该部分相关的细节。
- en: 'This approach does have a significant limitation: it works only when the user
    has a mouse. If you’re considering this technique, be aware that users on touchscreen
    devices won’t be able to take advantage of the interactive aspect; they’ll see
    only the static chart.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实有一个显著的限制：它仅在用户有鼠标时有效。如果你考虑使用这种技术，请注意，触摸屏设备上的用户将无法利用互动功能；他们只能看到静态图表。
- en: Since simple GDP data doesn’t lend itself well to the approach in this example,
    we’ll visualize a slightly different set of data from the World Bank. This time
    we’ll look at exports as a percentage of GDP. Let’s start by considering a simple
    line chart, shown in [Figure 2-11](ch02.html#plotting_multiple_data_sets_on_a_single
    "Figure 2-11. Plotting multiple data sets on a single chart can be confusing for
    users."), with data for each world region.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于简单的GDP数据并不适合本示例中的方法，我们将可视化世界银行的另一组稍微不同的数据。这次我们将查看出口占GDP的百分比。让我们从考虑一个简单的折线图开始，见[图
    2-11](ch02.html#plotting_multiple_data_sets_on_a_single "图 2-11. 在单个图表上绘制多个数据集可能会让用户感到困惑。")，该图展示了每个世界地区的数据。
- en: '![Plotting multiple data sets on a single chart can be confusing for users.](figs/web/02fig11.png.jpg)Figure 2-11. Plotting
    multiple data sets on a single chart can be confusing for users.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![在单个图表上绘制多个数据集可能会让用户感到困惑。](figs/web/02fig11.png.jpg)图 2-11. 在单个图表上绘制多个数据集可能会让用户感到困惑。'
- en: There are a couple of ways this chart falls short. First, many of the series
    have similar values, forcing some of the chart’s lines to cross back and forth
    over each other. That crisscrossing makes it hard for users to follow a single
    series closely to see detailed trends. Second, it’s hard for users to compare
    specific values for all of the regions at a single point in time. Most chart libraries,
    including Flot, have options to display values as users mouse over the chart,
    but that approach shows only one value at a time. We’d like to give our users
    a chance to compare the values of multiple regions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表有几个不足之处。首先，许多系列的值相似，导致一些图表的线条互相交叉。这种交叉使得用户难以紧跟单一系列的变化，去查看详细的趋势。其次，用户很难在同一时间点上比较所有地区的具体数值。大多数图表库，包括Flot，都提供了当用户将鼠标悬停在图表上时显示数值的选项，但这种方式一次只显示一个数值。我们希望给用户提供一个机会，能够比较多个地区的数值。
- en: In this example we’ll use a two-phase approach to solve both of those problems.
    First, we’ll change the visualization from a single chart with multiple series
    to multiple charts, each with a single series. That will isolate each region’s
    data, making it easier to see a particular region’s trends. Then we’ll add an
    advanced mouse tracking feature that spans all of the charts. This feature will
    let users see individual values in all of the charts at once.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将采用两阶段方法来解决这两个问题。首先，我们将把可视化从一个包含多个系列的单一图表更改为多个图表，每个图表只包含一个系列。这样可以将每个地区的数据隔离开来，更容易看到某一特定地区的趋势。然后，我们将添加一个跨所有图表的高级鼠标追踪功能。该功能允许用户同时查看所有图表中的单个数值。
- en: 'Step 1: Set Aside a <div> Element to Hold the Charts'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：预留一个`<div>`元素来承载图表
- en: Within our document, we need to create a `<div>` element to contain the charts
    we’ll construct. This element won’t contain the charts directly; rather, we’ll
    be placing other `<div>`s within it, which will each contain a chart.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文档中，我们需要创建一个`<div>`元素，用来包含我们将要构建的图表。这个元素不会直接包含图表；相反，我们将在其中放置其他`<div>`元素，每个`<div>`将包含一个图表。
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `"charts" <div>` is added at ➊. We’ve also included the required JavaScript
    libraries here, just as in the previous examples.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`"charts" <div>`元素在➊处添加。我们在这里还包括了所需的JavaScript库，和之前的示例一样。'
- en: We’ll use JavaScript to create the `<div>`s for the charts themselves. These
    elements must have an explicit height and width, or Flot won’t be able to construct
    the charts. You can indicate the element’s size in a CSS style sheet, or you can
    define it when we create the `<div>` (as in the following example). This creates
    a new `<div>`, sets its width and height, saves a reference to it, and then appends
    it to the containing `<div>` already in our document.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JavaScript创建图表的`<div>`元素。这些元素必须有明确的高度和宽度，否则Flot将无法构建图表。你可以在CSS样式表中指定元素的大小，或者在创建`<div>`时直接定义（如下例所示）。这将创建一个新的`<div>`，设置其宽度和高度，保存其引用，然后将其附加到文档中已经存在的包含`<div>`中。
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To iterate through the array of regions, we use the jQuery `.each()` function.
    That function accepts two parameters: an array of objects (`exports`) and a function.
    It iterates through the array one object at a time, calling the function with
    the individual object (`region`) and its index (`idx`) as parameters.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遍历地区数组，我们使用了jQuery的`.each()`函数。该函数接受两个参数：一个对象数组（`exports`）和一个函数。它一次迭代数组中的一个对象，调用该函数，并将单个对象（`region`）及其索引（`idx`）作为参数传递。
- en: 'Step 2: Prepare the Data'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：准备数据
- en: We’ll see how to get data directly from the World Bank’s web service in the
    next section, but for now we’ll keep things simple again and assume we have the
    data downloaded and formatted for JavaScript already. (Once again, only excerpts
    are shown here. The book’s source code includes the full data set.)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节看到如何直接从世界银行的Web服务获取数据，但目前我们保持简单，假设我们已经下载并将数据格式化为JavaScript格式。（再次强调，这里只展示了部分代码，书中的源代码包含了完整的数据集。）
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `exports` array contains an object for each region, and each object contains
    a label and a data series.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`exports`数组包含每个地区的一个对象，每个对象包含一个标签和一个数据系列。'
- en: 'Step 3: Draw the Charts'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：绘制图表
- en: 'With the `<div>`s for each chart now in place on our page, we can draw the
    charts using Flot’s `plot()` function. That function takes three parameters: the
    containing element (which we just created), the data, and chart options. To start,
    let’s look at the charts without any decoration—such as labels, grids, or checkmarks—just
    to make sure the data is generally presented the way we want.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个图表的`<div>`元素已经在我们的页面上就位，我们可以使用Flot的`plot()`函数来绘制图表。该函数接受三个参数：包含元素（我们刚才创建的元素）、数据和图表选项。首先，让我们看一下没有任何装饰——例如标签、网格或勾选标记——的图表，确保数据以我们期望的方式展示。
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code uses several `plot()` options to strip the chart of all the
    extras and set the axes the way we want. Let’s consider each option in turn.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了几个`plot()`选项，去除了图表的多余部分，并按照我们希望的方式设置了坐标轴。我们逐一来看每个选项。
- en: '****`series`****. Tells Flot how we want it to graph the data series. In our
    case we want a line chart (which is the default type), but we want to fill the
    area from the line down to the x-axis, so we set `fill` to `true`. This option
    creates an area chart instead of a line chart. Because our charts are so short,
    an area chart will keep the data visible. For the same reason, we want the line
    itself to be as small as possible to match, so we set `lineWidth` to `1` (pixel),
    and we can dispense with shadows by setting `shadowSize` to `0`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`series`****。告诉Flot我们希望如何绘制数据系列。在我们的例子中，我们想要一个线形图（这是默认类型），但是我们希望填充从线到x轴的区域，所以我们将`fill`设置为`true`。这个选项会创建一个区域图，而不是线形图。因为我们的图表非常短，区域图可以使数据更加可见。出于同样的原因，我们希望线条本身尽可能小，以便匹配，因此我们将`lineWidth`设置为`1`（像素），同时通过将`shadowSize`设置为`0`来去除阴影。'
- en: '****`xaxis`****. Defines the properties of the x-axis. We don’t want to include
    one on these charts, so we set `show` to `false`. We do, however, need to explicitly
    set the range of the axis. If we don’t, Flot will create one automatically, using
    the range of each series. Since our data doesn’t have consistent values for all
    years (the Middle East & North Africa data set, for example, doesn’t include data
    before 1968), we need to make Flot use the exact same x-axis range on all charts,
    so we specify a range from `1960` to `2011`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`xaxis`****。定义x轴的属性。我们不想在这些图表中包含x轴，所以我们将`show`设置为`false`。然而，我们确实需要明确设置轴的范围。如果不这样做，Flot会自动创建一个，使用每个系列的范围。由于我们的数据在所有年份中的值并不一致（例如，中东和北非数据集在1968年之前没有数据），我们需要确保Flot在所有图表中使用完全相同的x轴范围，因此我们指定了从`1960`到`2011`的范围。'
- en: '****`yaxis`****. Works much like the `xaxis` options. We don’t want to show
    one, but we do need to specify an explicit range so that all of the charts are
    consistent.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`yaxis`****。与`xaxis`选项类似。我们不想显示y轴，但我们确实需要指定一个明确的范围，以确保所有图表的一致性。'
- en: '****`grid`****. Tells Flot how to add grid lines and checkmarks to the charts.
    For now, we don’t want anything extra, so we turn off the grid completely by setting
    `show` to `false`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`grid`****。告诉Flot如何在图表中添加网格线和勾选标记。目前，我们不希望图表中有任何额外的内容，所以我们通过将`show`设置为`false`来完全关闭网格。'
- en: We can check the result in [Figure 2-12](ch02.html#separating_individual_data_sets_into_mul
    "Figure 2-12. Separating individual data sets into multiple charts can make it
    easier to see the details of each set.") to make sure the charts appear as we
    want.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[图2-12](ch02.html#separating_individual_data_sets_into_mul "图2-12。将单独的数据集分成多个图表可以更容易地看到每个数据集的细节。")中检查结果，确保图表如我们所愿地显示出来。
- en: '![Separating individual data sets into multiple charts can make it easier to
    see the details of each set.](figs/web/02fig12.png.jpg)Figure 2-12. Separating
    individual data sets into multiple charts can make it easier to see the details
    of each set.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![将单独的数据集分成多个图表可以更容易地看到每个数据集的细节。](figs/web/02fig12.png.jpg)图2-12。将单独的数据集分成多个图表可以更容易地看到每个数据集的细节。'
- en: Next we turn to the decoration for the chart. We’re obviously missing labels
    for each region, but adding them takes some care. Your first thought might be
    to include a legend along with each chart in the same `<div>`. Flot’s event handling,
    however, will work much better if we can keep all the charts—and only the charts—in
    their own `<div>`. That’s going to require some restructuring of our markup. We’ll
    create a wrapper `<div>` and then place separate `<div>`s for the charts and the
    legends within it. We can use the CSS `float` property to position them side by
    side.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向图表的装饰。显然，我们缺少每个区域的标签，但添加它们需要一些小心。你可能首先想到的是将图例与每个图表一起包含在同一个`<div>`中。然而，如果我们能将所有图表——并且仅仅是图表——放在各自的`<div>`中，Flot的事件处理将会更好。因此，这将需要对我们的标记进行一些重构。我们将创建一个包装`<div>`，然后将图表和图例的单独`<div>`放置在其中。我们可以使用CSS的`float`属性来将它们并排放置。
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we create each legend, we have to be sure it has the exact same height
    as the chart. Because we’re setting both explicitly, that’s not hard to do.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建每个图例时，我们必须确保它的高度与图表完全一致。由于我们明确设置了这两个值，因此这并不难做到。
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once again we use `.each`, this time to append a legend for each region to the
    `legends` element.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`.each`，这次是将每个区域的图例添加到`legends`元素中。
- en: Now we’d like to add a continuous vertical grid that spans all of the charts.
    Because the charts are stacked, grid lines in the individual charts can appear
    as one continuous line as long as we can remove any borders or margins between
    charts. It takes several `plot()` options to achieve that, as shown here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要添加一个贯穿所有图表的连续垂直网格线。因为这些图表是堆叠的，只要我们能够去除图表之间的任何边框或外边距，单个图表中的网格线就可以显示为一条连续的线。实现这一点需要几个`plot()`选项，如下所示。
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We enable the grid by setting the `grid` option’s `show` property to `true`.
    Then we remove all the borders and padding by setting the various widths and margins
    to `0`. To get the vertical lines, we also have to enable the x-axis, so we set
    its `show` property to `true` as well. But we don’t want any labels on individual
    charts, so we specify a `labelHeight` of `0`. To be certain that no labels appear,
    we also define a `tickFormatter()` function that returns an empty string.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`grid`选项的`show`属性设置为`true`来启用网格。然后，通过将各种宽度和边距设置为`0`来去除所有边框和内边距。为了显示垂直线，我们还需要启用x轴，因此我们也将其`show`属性设置为`true`。但是，我们不希望在单个图表上显示任何标签，所以我们将`labelHeight`指定为`0`。为了确保没有标签出现，我们还定义了一个`tickFormatter()`函数，它返回一个空字符串。
- en: The last bits of decoration we’d like to add are x-axis labels below the bottom
    chart. To do that, we can create a dummy chart with no visible data, position
    that dummy chart below the bottom chart, and enable labels on its x-axis. The
    following three sections create an array of dummy data, create a `<div>` to hold
    the dummy chart, and plot the dummy chart.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加的最后一些装饰是位于底部图表下方的x轴标签。为了做到这一点，我们可以创建一个没有可见数据的虚拟图表，将该虚拟图表放在底部图表下方，并启用其x轴的标签。以下三个部分将创建一个虚拟数据数组，创建一个`<div>`来容纳虚拟图表，并绘制该虚拟图表。
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With the added decoration, our chart in [Figure 2-13](ch02.html#carefully_stacking_multiple_charts_creat
    "Figure 2-13. Carefully stacking multiple charts creates the appearance of a unified
    chart.") looks great.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些额外的装饰，我们在[图2-13](ch02.html#carefully_stacking_multiple_charts_creat "图2-13。小心地堆叠多个图表可以创建统一图表的外观。")中的图表看起来很棒。
- en: '![Carefully stacking multiple charts creates the appearance of a unified chart.](figs/web/02fig13.png.jpg)Figure 2-13. Carefully
    stacking multiple charts creates the appearance of a unified chart.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![小心地堆叠多个图表可以创建统一图表的外观。](figs/web/02fig13.png.jpg)图2-13。小心地堆叠多个图表可以创建统一图表的外观。'
- en: 'Step 4: Implement the Interaction'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：实现交互
- en: For our visualization, we want to track the mouse as it hovers over any of our
    charts. The Flot library makes that relatively easy. The `plot()` function’s `grid`
    options include the `hoverable` property, which is set to `false` by default.
    If you set this property to `true`, Flot will trigger `plothover` events as the
    mouse moves over the chart area. It sends these events to the `<div>` that contains
    the chart. If there is code listening for those events, that code can respond
    to them. If you use this feature, Flot will also highlight the data point nearest
    the mouse. That’s a behavior we don’t want, so we’ll disable it by setting `autoHighlight`
    to `false`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的可视化，我们想要跟踪鼠标在任何图表上的悬停情况。Flot 库使得这变得相对容易。`plot()`函数的`grid`选项包括`hoverable`属性，默认值为`false`。如果将此属性设置为`true`，Flot会在鼠标移动到图表区域时触发`plothover`事件，并将这些事件发送到包含图表的`<div>`中。如果有代码在监听这些事件，代码就可以对其作出响应。如果使用此功能，Flot还会高亮显示距离鼠标最近的数据点。我们不希望这种行为，因此我们将通过将`autoHighlight`设置为`false`来禁用它。
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that we’ve told Flot to trigger events on all of our charts, you might
    think we would have to set up code to listen for events on all of them. There’s
    an even better approach, though. We structured our markup so that all the charts—and
    only the charts—are inside the containing `charts <div>`. In JavaScript, if no
    code is listening for an event on a specific document element, those events automatically
    “bubble up” to the containing elements. So if we just set up an event listener
    on the `charts <div>`, we can capture the `plothover` events on all of the individual
    charts. We’ll also need to know when the mouse leaves the chart area. We can catch
    those events using the standard `mouseout` event as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经告诉Flot在所有图表上触发事件，你可能会认为我们需要为所有图表设置代码来监听事件。不过，还有一种更好的方法。我们将标记结构化，使得所有的图表——并且只有图表——都位于包含它们的`charts
    <div>`中。在JavaScript中，如果没有代码在特定的文档元素上监听事件，那么这些事件会自动“冒泡”到包含它们的元素。所以，如果我们只在`charts
    <div>`上设置一个事件监听器，就可以捕捉到所有单个图表的`plothover`事件。我们还需要知道何时鼠标离开图表区域。我们可以使用标准的`mouseout`事件来捕获这些事件，如下所示：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To respond to the `plothover` events, we want to display a vertical line across
    all of the charts. We can construct that line using a `<div>` element with a border.
    In order to move it around, we use absolute positioning. It also needs a positive
    `z-index` value to make sure the browser draws it on top of the chart. The marker
    starts off hidden with a `display` property of `none`. Since we want to position
    the marker within the containing `<div>`, we set the containing `<div>`’s `position`
    property to `relative`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应`plothover`事件，我们希望在所有图表上显示一条垂直线。我们可以使用一个带边框的`<div>`元素来构建这条线。为了让它能够移动，我们使用绝对定位。它还需要一个正的`z-index`值，以确保浏览器将其绘制在图表的上方。标记一开始是隐藏的，`display`属性为`none`。由于我们希望将标记放置在包含的`<div>`内，因此我们将包含的`<div>`的`position`属性设置为`relative`。
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When Flot calls the function listening for `plothover` events, it passes that
    function three parameters: the JavaScript event object, the position of the mouse
    expressed as x- and y-coordinates, and, if a chart data point is near the mouse,
    information about that data point. In our example we need only the x-coordinate.
    We can round it to the nearest integer to get the year. We also need to know where
    the mouse is relative to the page. Flot will calculate that for us if we call
    the `pointOffset()` of any of our plot objects. Note that we can’t reliably use
    the third parameter, which is available only if the mouse is near an actual data
    point, so we can ignore it.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当Flot调用监听`plothover`事件的函数时，它会传递三个参数：JavaScript事件对象、鼠标位置（以x和y坐标表示），以及如果鼠标靠近某个数据点，关于该数据点的信息。在我们的示例中，我们只需要x坐标。我们可以将其四舍五入为最接近的整数，从而得到年份。我们还需要知道鼠标相对于页面的位置。如果我们调用任意一个图表对象的`pointOffset()`，Flot会为我们计算这一点。注意，第三个参数只有在鼠标靠近实际数据点时才会提供，因此我们可以忽略它。
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once we’ve calculated the position, it’s a simple matter to move the marker
    to that position, make sure it’s the full height of the containing `<div>`, and
    turn it on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们计算出位置，就可以简单地将标记移动到该位置，确保它覆盖整个包含`<div>`的高度，并将其显示出来。
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this code, we calculate the marker height at ➊, set its position at ➋, and
    set the height at ➌.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们在➊计算标记的高度，在➋设置标记的位置，并在➌设置高度。
- en: We also have to be a little careful on the `mouseout` event. If a user moves
    the mouse so that it is positioned directly on top of the marker, that will generate
    a `mouseout` event for the `charts <div>`. In that special case, we want to leave
    the marker displayed. To tell where the mouse has moved, we check the `relatedTarget`
    property of the event. We hide the marker only if the related target isn’t the
    marker itself.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`mouseout`事件上小心处理。如果用户将鼠标移到标记上方，这将触发`charts <div>`的`mouseout`事件。在这种特殊情况下，我们希望保留标记的显示。为了判断鼠标移动的位置，我们检查事件的`relatedTarget`属性。只有当`relatedTarget`不是标记本身时，我们才会隐藏标记。
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There’s still one hole in our event processing. If the user moves the mouse
    directly over the marker, and then moves the mouse off the chart area entirely
    (without moving it off the marker), we won’t catch the fact that the mouse is
    no longer hovering on the chart. To catch this event, we can listen for `mouseout`
    events on the marker itself. There’s no need to worry about the mouse moving off
    the marker and back onto the chart area; the existing `plothover` event will cover
    that scenario.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的事件处理过程中，仍然存在一个漏洞。如果用户将鼠标直接移到标记上方，然后完全离开图表区域（而不是离开标记），我们无法捕捉到鼠标不再悬停在图表上的事实。为了捕捉这一事件，我们可以监听标记本身的`mouseout`事件。无需担心鼠标是否离开标记并重新返回图表区域，因为现有的`plothover`事件会处理这种情况。
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The last part of our interaction shows the values of all charts corresponding
    to the horizontal position of the mouse. We can create `<div>`s to hold these
    values back when we create each chart. Because these `<div>`s might extend beyond
    the chart area proper, we’ll place them in the outer `charts-wrapper <div>`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们交互的最后一部分显示了所有图表中与鼠标水平位置相对应的数值。我们可以在创建每个图表时，创建`<div>`来保存这些数值。因为这些`<div>`可能会延伸到图表区域之外，所以我们将它们放置在外部的`charts-wrapper
    <div>`中。
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice that as we create these `<div>`s, we set all the properties except the
    left position, since that will vary with the mouse. We also hide the elements
    with a `display` property of `none` at ➊.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在创建这些`<div>`时，我们设置了除了左侧位置之外的所有属性，因为左侧位置会随鼠标的变化而变化。我们还将元素的`display`属性设置为`none`以隐藏它们，见➊。
- en: With the `<div>`s waiting for us in the document, our event handler for `plothover`
    sets the text for each, positions them horizontally, and shows them on the page.
    To set the text value, we can use the jQuery `.grep()` function to search through
    the data for a year that matches. If none is found, the text for the value `<div>`
    is emptied.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中等着我们的`<div>`中，我们的`plothover`事件处理程序会设置每个的文本，水平定位它们，并将它们显示在页面上。为了设置文本值，我们可以使用
    jQuery 的`.grep()`函数在数据中搜索匹配的年份。如果没有找到，值`<div>`的文本将被清空。
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, we need to hide these `<div>`s when the mouse leaves the chart area.
    We should also handle the case of the mouse moving directly onto the marker, just
    as we did before.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在鼠标离开图表区域时隐藏这些`<div>`。我们还应该处理鼠标直接移到标记上的情况，就像之前所做的那样。
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can now enjoy the results of our coding, in [Figure 2-14](ch02.html#final_visualization_combines_multiple_ch
    "Figure 2-14. The final visualization combines multiple charts with mouse tracking
    to more clearly present the data."). Our visualization clarifies the trends in
    exports for each region, and it lets users interact with the charts to compare
    regions and view detailed values.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以享受我们编码的成果，在[图 2-14](ch02.html#final_visualization_combines_multiple_ch
    "图 2-14. 最终的可视化结合了多个图表和鼠标跟踪，更清晰地呈现数据。")中展示。我们的可视化明确了各个地区出口的趋势，并允许用户与图表互动，比较各地区并查看详细数值。
- en: '![The final visualization combines multiple charts with mouse tracking to more
    clearly present the data.](figs/web/02fig14.png.jpg)Figure 2-14. The final visualization
    combines multiple charts with mouse tracking to more clearly present the data.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![最终的可视化结合了多个图表和鼠标跟踪，更清晰地呈现数据。](figs/web/02fig14.png.jpg)图 2-14. 最终的可视化结合了多个图表和鼠标跟踪，更清晰地呈现数据。'
- en: As users move their mouse across the charts, the vertical bar moves as well.
    The values corresponding to the mouse position also appear to the right of the
    marker for each chart. The interaction makes it easy and intuitive to compare
    values for any of the regions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将鼠标移过图表时，垂直条也会随着移动。对应鼠标位置的数值也会出现在每个图表的标记右侧。这种交互使得比较各地区的数值变得简单且直观。
- en: The chart we’ve created in this example is similar to the *small multiples*
    approach for letting users compare many values. In our example the chart takes
    up the full page, but it could also be designed as one element in a larger presentation
    such as a table. [Chapter 3](ch03.html "Chapter 3. Integrating Charts on a Page")
    gives examples of integrating charts in larger web page elements.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中创建的图表类似于*小型多图*方法，允许用户比较多个数值。在我们的例子中，图表占据了整个页面，但它也可以设计为更大展示中的一个元素，比如一个表格。[第
    3 章](ch03.html "第 3 章. 将图表集成到页面中")提供了将图表集成到更大网页元素中的例子。
- en: Retrieving Data Using AJAX
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AJAX 获取数据
- en: 'Most of the examples in this book emphasize the final product of data visualization:
    the graphs, charts, or images that our users see. But effective visualizations
    often require a lot of work behind the scenes. After all, effective data visualizations
    need *data* just as much as they need the visualization. This example focuses
    on a common approach for accessing data—*Asynchronous JavaScript and XML*, more
    commonly known as *AJAX*. The example here details AJAX interactions with the
    World Bank, but both the general approach and the specific techniques shown here
    apply equally well to many other data sources on the Web.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数例子强调数据可视化的最终产品：用户看到的图形、图表或图像。但有效的可视化通常需要在幕后做大量的工作。毕竟，像数据可视化这样的有效展示既需要*数据*，也需要可视化。在这个例子中，我们关注了一种常见的数据访问方法——*异步
    JavaScript 和 XML*，更常见的名称是*AJAX*。这里的例子详细描述了与世界银行的 AJAX 交互，但这里展示的通用方法和具体技术同样适用于网络上的许多其他数据源。
- en: 'Step 1: Understand the Source Data'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步：理解源数据
- en: Often, the first challenge in working with remote data is to understand its
    format and structure. Fortunately, our data comes from the World Bank, and its
    website thoroughly documents its *application programming interface (API)*. We
    won’t spend too much time on the particulars in this example, since you’ll likely
    be using a different data source. But a quick overview is helpful.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，处理远程数据时的第一个挑战是理解其格式和结构。幸运的是，我们的数据来自世界银行，并且其网站详细记录了其*应用程序编程接口（API）*。在这个例子中，我们不会花太多时间讨论细节，因为你可能会使用不同的数据源。不过，快速了解一下是很有帮助的。
- en: The first item of note is that the World Bank divides the world into several
    regions. As with all good APIs, the World Bank API allows us to issue a query
    to get a list of those regions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个需要注意的是，世界银行将世界划分为多个区域。像所有优秀的API一样，世界银行API允许我们发出查询来获取这些区域的列表。
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our query returns the full list as a JSON array, which starts as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的查询返回完整的列表，格式为JSON数组，起始部分如下所示：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first object in the array supports paging through a large data set, which
    isn’t important for us now. The second element is an array with the information
    we need: the list of regions. There are 22 regions in total, but many overlap.
    We’ll want to pick from the total number of regions so that we both include all
    the world’s countries and don’t have any country in multiple regions. The regions
    that meet these criteria are conveniently marked with an `id` property, so we’ll
    select from the list only those regions whose `id` property is not `null`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的第一个对象支持通过大量数据集进行分页，这对我们来说目前并不重要。第二个元素是一个包含我们所需信息的数组：区域列表。总共有22个区域，但许多区域是重叠的。我们希望从所有区域中选择，这样我们既能包含所有国家，又不会有一个国家出现在多个区域。符合这些标准的区域都方便地标记了一个`id`属性，因此我们只会选择那些`id`属性不为`null`的区域。
- en: 'Step 2: Get the First Level of Data via AJAX'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：通过AJAX获取第一层数据
- en: Now that you understand the data format (so far), let’s write some code to retrieve
    the data. Since we have jQuery loaded, we’ll take advantage of many of its utilities.
    Let’s start at the simplest level and work up to a full implementation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了数据格式（到目前为止），接下来我们来写一些代码来获取数据。由于我们已经加载了jQuery，我们将利用它的许多工具。让我们从最简单的实现开始，逐步构建完整的实现。
- en: 'As you might expect, the $`.getJSON()` function will do most of the work for
    us. The simplest way to use that function might be something like the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能预料到的，`$.getJSON()`函数将为我们完成大部分工作。使用该函数的最简单方式可能是如下所示：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that we’re adding `format: "json"` to the query at ➊ to tell the World
    Bank what format we want. Without that parameter, the server returns XML, which
    isn’t at all what `getJSON()` expects.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，我们在查询中添加了`format: "json"`，以告诉世界银行我们希望的数据格式。如果没有这个参数，服务器会返回XML，而`getJSON()`并不期望这种格式。'
- en: Unfortunately, that code won’t work with the current web servers supplying the
    World Bank data. In fact, this problem is very common today. As is often the case
    with the Web, security concerns are the source of the complication. Consider the
    information flow we’re establishing, shown in [Figure 2-15](ch02.html#our_server_left_parenthesisyourdotweb
    "Figure 2-15. Our server (your.web.site.com) sends a web page—including scripts—to
    the user, and those scripts, executing in the user’s browser, query the World
    Bank site (api.worldbank.com).").
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码在当前提供世界银行数据的Web服务器上无法正常工作。实际上，这个问题在今天非常常见。正如Web上常见的情况，安全问题是导致这种复杂性的原因。请考虑我们正在建立的信息流，见[图2-15](ch02.html#our_server_left_parenthesisyourdotweb
    "图2-15. 我们的服务器（your.web.site.com）向用户发送网页，包括脚本，而这些脚本在用户的浏览器中执行，查询世界银行网站（api.worldbank.com）。")。
- en: '![Our server (your.web.site.com) sends a web page—including scripts—to the
    user, and those scripts, executing in the user’s browser, query the World Bank
    site (api.worldbank.com).](figs/web/02fig15.png.jpg)Figure 2-15. Our server *(your.web.site.com)*
    sends a web page—including scripts—to the user, and those scripts, executing in
    the user’s browser, query the World Bank site (*api.worldbank.com*).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![我们的服务器（your.web.site.com）向用户发送网页，包括脚本，而这些脚本在用户的浏览器中执行，查询世界银行网站（api.worldbank.com）。](figs/web/02fig15.png.jpg)图2-15.
    我们的服务器*(your.web.site.com)*向用户发送网页，包括脚本，而这些脚本在用户的浏览器中执行，查询世界银行网站(*api.worldbank.com*)。'
- en: Getting data using AJAX often requires the cooperation of three different systems.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AJAX获取数据通常需要三个不同系统的配合。
- en: The script’s communication with the World Bank is invisible to users, so they
    have no chance to approve or refuse the exchange. In the case of the World Bank,
    it’s hard to imagine any reason for users to reject the query, but what if our
    script were accessing users’ social network profile or, more seriously, their
    online banking site? In such cases user concerns would be justified. Because the
    communication is invisible to the user, and because the web browser cannot guess
    which communications might be sensitive, the browser simply prohibits all such
    communications. The technical term for this is *same-origin policy*. This policy
    means that web pages that our server provides cannot directly access the World
    Bank’s JSON interface.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本与世界银行的通信对用户来说是不可见的，因此他们没有机会批准或拒绝交换。在世界银行的情况下，很难想象用户拒绝查询的任何理由，但如果我们的脚本正在访问用户的社交网络资料，或者更严重的是他们的在线银行账户呢？在这种情况下，用户的担忧是有正当理由的。由于通信对用户是不可见的，而且因为浏览器无法猜测哪些通信可能是敏感的，所以浏览器会简单地禁止所有此类通信。这个技术术语叫做*同源策略*。该策略意味着我们的服务器提供的网页无法直接访问世界银行的
    JSON 接口。
- en: 'Some websites address this problem by adding an HTTP header in their responses.
    The header tells the browser that it’s safe for any web page to access this data:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网站通过在其响应中添加 HTTP 头来解决这个问题。该头部告诉浏览器，任何网页都可以安全地访问这些数据：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Unfortunately, as of this writing, the World Bank has not implemented this
    header. The option is relatively new, so it’s missing from many web servers. To
    work within the constraints of the same-origin policy, therefore, we rely on jQuery’s
    help and a small bit of trickery. The trick relies on the one exception to the
    same-origin policy that all browsers recognize: third-party JavaScript files.
    Browsers do allow web pages to request JavaScript files from third-party servers
    (that is, after all, how services such as Google Analytics can work). We just
    need to make the response data from the World Bank look like regular JavaScript
    instead of JSON. Fortunately, the World Bank cooperates with us in this minor
    deception. We simply add two query parameters to our request:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，截至本文写作时，世界银行尚未实现该头部。这个选项相对较新，因此许多Web服务器都没有实现它。因此，为了在同源策略的约束下工作，我们依赖 jQuery
    的帮助和一些小小的伎俩。这个技巧依赖于所有浏览器都承认的同源策略的一个例外：第三方 JavaScript 文件。浏览器确实允许网页从第三方服务器请求 JavaScript
    文件（毕竟，像 Google Analytics 这样的服务就是通过这种方式工作的）。我们只需要让世界银行的响应数据看起来像是常规的 JavaScript，而不是
    JSON。幸运的是，世界银行与我们在这一小小的欺骗上配合得很好。我们只需向请求中添加两个查询参数：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `format` parameter with a value of `jsonP` tells the World Bank that we
    want the response formatted as *JSON with padding*, which is a variant of JSON
    that is also regular JavaScript. The second parameter, `prefix`, tells the World
    Bank the name of the function that will accept the data. (Without that information,
    the JavaScript that the World Bank constructs wouldn’t know how to communicate
    with our code.) It’s a bit messy, but jQuery handles most of the details for us.
    The only catch is that we have to add `?`*`something`*`=?` to the URL we pass
    to `.getJSON()`, where *`something`* is whatever the web service requires for
    its JSONP response. The World Bank expects `prefix`, but a more common value is
    `callback`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`format` 参数的值为 `jsonP`，它告诉世界银行我们希望将响应格式化为*带填充的 JSON*，这是一种 JSON 的变体，同时也是常规 JavaScript。第二个参数
    `prefix` 告诉世界银行接收数据的函数名称。（没有这个信息，世界银行生成的 JavaScript 将不知道如何与我们的代码进行通信。）这有点复杂，但
    jQuery 为我们处理了大部分细节。唯一的难点是，我们必须在传递给 `.getJSON()` 的 URL 中添加 `?`*`something`*`=?`，其中
    *`something`* 是 Web 服务要求的 JSONP 响应。世界银行期望 `prefix`，但更常见的值是 `callback`。'
- en: Now we can put together some code that will work with the World Bank and many
    other web servers, although the parameter `prefix` is specific to the World Bank.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一些代码，这些代码可以与世界银行及许多其他Web服务器一起使用，尽管 `prefix` 参数是特定于世界银行的。
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We’ve added the `prefix` directly in the URL at ➊, and we’ve changed the format
    to `jsonp` at ➋.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➊ 处直接在 URL 中添加了 `prefix`，并在 ➋ 处将格式更改为 `jsonp`。
- en: 'JSONP does suffer from one major shortcoming: there is no way for the server
    to indicate an error. That means we should spend extra time testing and debugging
    any JSONP requests, and we should be vigilant about any changes in the server
    that might cause previously functioning code to fail. Eventually the World Bank
    will update the HTTP headers in its responses (perhaps even by the time of this
    book’s publication), and we can switch to the more robust JSON format.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: JSONP 确实有一个主要的缺点：服务器无法指示错误。这意味着我们应该花更多时间测试和调试任何 JSONP 请求，并且应该时刻警惕服务器的任何更改，这些更改可能导致之前正常工作的代码失败。最终，世界银行将更新其响应中的
    HTTP 头（或许在本书出版时就会更新），到时我们可以切换到更健壮的 JSON 格式。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**At the time of this writing, the World Bank has a significant bug in its
    API. The server doesn’t preserve the case (uppercase versus lowercase) of the
    callback function. The full source code for this example includes a work-around
    for the bug, but you’re unlikely to need that for other servers. Just in case,
    though, you can look at the comments in the source code for a complete documentation
    of the fix.**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**在撰写本文时，世界银行的 API 存在一个严重的 bug。服务器没有保留回调函数的大小写（大写与小写）。本示例的完整源代码包括了针对该 bug 的解决方法，但对于其他服务器，你不太可能需要这个。万一需要，你可以查看源代码中的注释，那里有完整的修复文档。**'
- en: Now let’s get back to the code itself. In the preceding snippet, we’re defining
    a callback function directly in the call to `.getJSON()`. You’ll see this code
    structure in many implementations. This certainly works, but if we continue along
    these lines, things are going to get quite messy very soon. We’ve already added
    a couple of layers of indentation before we even start processing the response.
    As you can guess, once we get this initial response, we’ll need to make several
    more requests for additional data. If we try to build our code in one monolithic
    block, we’ll end up with so many levels of indentation that there won’t be any
    room for actual code. More significantly, the result would be one massive interconnected
    block of code that would be challenging to understand, much less debug or enhance.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到代码本身。在前面的代码片段中，我们直接在对 `.getJSON()` 的调用中定义了一个回调函数。你会在许多实现中看到这种代码结构。这当然是可行的，但如果我们继续沿着这条路走下去，事情很快就会变得非常混乱。在我们开始处理响应之前，已经添加了几层缩进。正如你可以猜到的，一旦我们收到这个初始响应，我们将需要发起更多请求来获取额外的数据。如果我们尝试将代码构建成一个单一的整体块，我们最终会有太多层缩进，以至于根本没有空间放实际的代码。更重要的是，结果将是一个庞大的互联代码块，理解起来非常困难，更不用说调试或扩展了。
- en: 'Fortunately, jQuery gives us the tool for a much better approach: the `$.Deferred`
    object. A `Deferred` object acts as a central dispatcher and scheduler for events.
    Once the `Deferred` object is created, different parts of our code indicate that
    they want to know when the event completes, while other parts of our code signal
    the event’s status. `Deferred` coordinates all those different activities, letting
    us separate how we trigger and manage events from dealing with their consequences.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，jQuery 为我们提供了一个更好的方法工具：`$.Deferred` 对象。`Deferred` 对象充当事件的中央调度器和调度器。一旦创建了
    `Deferred` 对象，我们代码的不同部分可以表明它们希望知道事件何时完成，而其他部分则通知事件的状态。`Deferred` 协调了这些不同的活动，使我们能够将触发和管理事件的方式与处理其后果的方式分开。
- en: Let’s see how to improve our AJAX request with `Deferred` objects. Our main
    goal is to separate the initiation of the event (the AJAX request) from dealing
    with its consequences (processing the response). With that separation, we won’t
    need a success function as a callback parameter to the request itself. Instead,
    we’ll rely on the fact that the `.getJSON()` call returns a `Deferred` object.
    (Technically, the function returns a restricted form of the `Deferred` object
    known as a `promise`; the differences aren’t important for us now, though.) We
    want to save that returned object in a variable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何使用 `Deferred` 对象改进我们的 AJAX 请求。我们的主要目标是将事件的启动（AJAX 请求）与处理其后果（处理响应）分开。通过这种分离，我们不需要将成功函数作为请求本身的回调参数。相反，我们将依赖于
    `.getJSON()` 调用返回一个 `Deferred` 对象这一事实。（从技术上讲，函数返回的是一种限制形式的 `Deferred` 对象，称为 `promise`；不过现在这些区别对我们来说并不重要。）我们希望将返回的对象保存在一个变量中。
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That’s simple and straightforward. Now, in a different part of our code, we
    can indicate our interest in knowing when the AJAX request is complete.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单直接。现在，在我们代码的其他部分，我们可以表示我们有兴趣知道 AJAX 请求何时完成。
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `done()` method of the `Deferred` object is key. It specifies a new function
    that we want to execute whenever the event (in this case the AJAX request) successfully
    completes. The `Deferred` object handles all the messy details. In particular,
    if the event is already complete by the time we get around to registering the
    callback via `done()`, the `Deferred` object executes that callback immediately.
    Otherwise, it waits until the request is complete. We can also express an interest
    in knowing if the AJAX request fails; instead of `done()`, we use the `fail()`
    method for this. (Even though JSONP doesn’t give the server a way to report errors,
    the request itself could still fail.)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deferred` 对象的 `done()` 方法是关键。它指定了一个新函数，每当事件（在这里是 AJAX 请求）成功完成时，我们希望执行该函数。`Deferred`
    对象处理了所有繁琐的细节。特别是，如果在我们通过 `done()` 注册回调时事件已经完成，`Deferred` 对象会立即执行该回调。否则，它会等待直到请求完成。我们还可以表示希望知道
    AJAX 请求是否失败；对于这个需求，我们使用 `fail()` 方法而不是 `done()`。（即使 JSONP 不提供给服务器报告错误的方式，请求本身仍然可能失败。）'
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We’ve obviously reduced the indentation to a more manageable level, but we’ve
    also created a much better structure for our code. The function that makes the
    request is separate from the code that handles the response. That’s much cleaner,
    and it’s definitely easier to modify and debug.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然已将缩进减少到一个更易管理的级别，但我们也为代码创建了一个更好的结构。发起请求的函数与处理响应的代码是分开的。这种结构更清晰，修改和调试起来也更加容易。
- en: 'Step 3: Process the First Level of Data'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：处理第一层数据
- en: Now let’s tackle processing the response. The paging information isn’t relevant,
    so we can skip right to the second element in the returned response. We want to
    process that array in two steps.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们处理响应。分页信息与我们无关，因此我们可以跳过返回响应中的第一个元素，直接处理第二个元素。我们希望将这个数组分两步进行处理。
- en: Filter out any elements in the array that aren’t relevant to us. In this case
    we’re interested only in regions that have an `id` property that isn’t `null`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤掉数组中与我们无关的元素。在本例中，我们只关心那些 `id` 属性不为 `null` 的地区。
- en: Transform the elements in the array so that they contain only the properties
    we care about. For this example, we need only the `code` and `name` properties.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换数组中的元素，使其仅包含我们关心的属性。在这个例子中，我们只需要 `code` 和 `name` 属性。
- en: This probably sounds familiar. In fact, it’s exactly what we needed to do in
    this chapter’s first example. As we saw there, jQuery’s *`$`*`.map() and` *`$`*`.grep()`
    functions are a big help.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能有些熟悉。事实上，这正是我们在本章第一个例子中需要做的事情。正如我们在那里看到的，jQuery 的 *`$`*`.map()` 和 *`$`*`.grep()`
    函数是非常有用的工具。
- en: Taking these steps one at a time, here’s how to filter out irrelevant data from
    the response.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一步一步来，这里是如何从响应中过滤掉无关数据的方法。
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: And here’s how to transform the elements to retain only relevant properties.
    And as long as we’re doing that, let’s get rid of the parenthetical “(all income
    levels)” that the World Bank appends to some region names. All of our regions
    (those with an `id`) include all income levels, so this information is superfluous.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何转换元素，只保留相关属性的方式。既然我们已经在做这个了，不妨去掉世界银行在某些地区名称后附加的括号内容“（所有收入水平）”。我们所有的地区（那些有
    `id` 的地区）都包含所有收入水平，因此这些信息是多余的。
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There’s no need to make these separate steps. We can combine them in a nice,
    concise expression.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不必将这些步骤分开。我们可以将它们结合成一个简洁的表达式。
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Step 4: Get the Real Data'
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4：获取真实数据
- en: At this point, of course, all we’ve managed to retrieve is the list of regions.
    That’s not the data we want to visualize. Usually, getting the real data through
    a web-based interface requires (at least) two request stages. The first request
    just gives you the essential information for subsequent requests. In this case,
    the real data we want is the GDP, so we’ll need to go through our list of regions
    and retrieve that data for each one.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当然，我们所能获取的只是地区列表。这并不是我们想要可视化的数据。通常，通过基于 Web 的接口获取实际数据需要（至少）两个请求阶段。第一个请求仅提供后续请求所需的基本信息。在这种情况下，我们想要的实际数据是
    GDP，因此我们需要遍历地区列表，并为每个地区检索该数据。
- en: Of course we can’t just blindly fire off the second set of requests, in this
    case for the detailed region data. First, we have to wait until we have the list
    of regions. In Step 2 we dealt with a similar situation by using `.getJSON()`
    with a `Deferred` object to separate event management from processing. We can
    use the same technique here; the only difference is that we’ll have to create
    our own `Deferred` object.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不能盲目地发出第二组请求，即请求详细的地区数据。首先，我们必须等到获得地区列表。在第2步中，我们通过使用`.getJSON()`和`Deferred`对象来处理了一个类似的情况，将事件管理与处理分离。我们可以在这里使用相同的技术；唯一的区别是，我们必须创建自己的`Deferred`对象。
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Later, when the region list is available, we indicate that status by calling
    the object’s `resolve()` method.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，当地区列表可用时，我们通过调用对象的`resolve()`方法来表示该状态。
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The actual processing is handled by the `done()` method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的处理由`done()`方法处理。
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The code that gets the actual region data needs the list of regions, of course.
    We could pass that list around as a global variable, but that would be polluting
    the global namespace. (And even if you’ve properly namespaced your application,
    why pollute your own namespace?) This problem is easy to solve. Any arguments
    we provide to the `resolve()` method are passed straight to the `done()` function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 获取实际地区数据的代码当然需要地区列表。我们可以将该列表作为全局变量传递，但这会污染全局命名空间。（即使你已经正确命名了你的应用，为什么还要污染你自己的命名空间呢？）这个问题很容易解决。我们提供给`resolve()`方法的任何参数都会直接传递给`done()`函数。
- en: Let’s take a look at the big picture so we can see how all the pieces fit together.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看整体情况，这样我们就能看到各个部分是如何配合的。
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: First, starting at ➊, we request the list of regions. Then, at ➋, we create
    a second `Deferred` object to track our processing of the response. In the block
    starting at ➌, we handle the response from our initial request. Most importantly,
    we resolve the second `Deferred` object, at ➍, to signal that our processing is
    complete. Finally, starting at ➎, we can begin processing the response.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从➊开始，我们请求地区列表。然后，在➋处，我们创建第二个`Deferred`对象来跟踪响应处理。在从➌开始的代码块中，我们处理初始请求的响应。最重要的是，在➍处，我们解析第二个`Deferred`对象，表示处理完成。最后，从➎开始，我们可以开始处理响应。
- en: Retrieving the actual GDP data for each region requires a new AJAX request.
    As you might expect, we’ll save the `Deferred` objects for those requests so we
    can process the responses when they’re available. The jQuery `.each()` function
    is a convenient way to iterate through the list of regions to initiate these requests.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 获取每个地区的实际GDP数据需要一个新的AJAX请求。正如你所料，我们将保存这些请求的`Deferred`对象，以便在响应可用时处理它们。jQuery的`.each()`函数是一个方便的方式，可以遍历地区列表并启动这些请求。
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The “`NY.GDP.MKTP.CD`” part of each request URL at ➊ is the World Bank’s code
    for GDP data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求URL中➊处的“`NY.GDP.MKTP.CD`”部分是世界银行的GDP数据代码。
- en: As long as we’re iterating through the regions, we can include the code to process
    the GDP data. By now it won’t surprise you that we’ll create a `Deferred` object
    to track when that processing is complete. The processing itself will simply store
    the returned response (after skipping past the paging information) in the region
    object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们在遍历各个地区，就可以加入处理GDP数据的代码。到现在为止，你应该不会对我们创建一个`Deferred`对象来跟踪处理完成的时机感到惊讶。处理本身将简单地将返回的响应（跳过分页信息后）存储在地区对象中。
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that we’ve also added a check at ➊ to make sure the World Bank actually
    returns data in its response. Possibly due to internal errors, it may return a
    `null` object instead of the array of data. When that happens, we’ll set the `rawData`
    to an empty array instead of `null`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在➊处添加了一个检查，以确保世界银行在响应中实际返回了数据。由于内部错误，它可能返回一个`null`对象，而不是数据数组。发生这种情况时，我们会将`rawData`设置为空数组，而不是`null`。
- en: 'Step 5: Process the Data'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：处理数据
- en: Now that we’ve requested the real data, it’s almost time to process it. There
    is a final hurdle to overcome, and it’s a familiar one. We can’t start processing
    the data until it’s available, which calls for defining one more `Deferred` object
    and resolving that object when the data is complete. (By now it’s probably sinking
    in just how handy `Deferred` objects can be.)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经请求了真实的数据，几乎可以开始处理它了。还有一个最后的难关要克服，而这个难关是我们熟悉的。我们不能在数据不可用之前开始处理，这就需要定义一个新的`Deferred`对象，并在数据完成时解析该对象。（现在你应该已经意识到`Deferred`对象有多么方便了。）
- en: There is one little twist, however. We’ve now got multiple requests in progress,
    one for each region. How can we tell when all of those requests are complete?
    Fortunately, jQuery provides a convenient solution with the `.when()` function.
    That function accepts a list of `Deferred` objects and indicates success only
    when all of the objects have succeeded. We just need to pass that list of `Deferred`
    objects to the `.when()` function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个小小的变化。现在我们有多个请求在进行，每个区域一个请求。我们怎么知道所有这些请求何时完成呢？幸运的是，jQuery 提供了一个方便的解决方案，那就是
    `.when()` 函数。该函数接受一组 `Deferred` 对象，并仅在所有对象都成功时才表示成功。我们只需要将这些 `Deferred` 对象的列表传递给
    `.when()` 函数。
- en: We could assemble an array of `Deferred` objects using the `.map()` function,
    but `.when()` expects a parameter list, not an array. Buried deep in the JavaScript
    standard is a technique for converting an array to a list of function parameters.
    Instead of calling the function directly, we execute the `.when()` function’s
    `apply()` method. That method takes, as its parameters, the context (`this`) and
    an array.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `.map()` 函数组合一个 `Deferred` 对象数组，但 `.when()` 期望的是一个参数列表，而不是数组。JavaScript
    标准中深藏着一种将数组转换为函数参数列表的技巧。我们不直接调用函数，而是执行 `.when()` 函数的 `apply()` 方法。该方法将上下文（`this`）和数组作为参数传递。
- en: Here’s the `.map()` function that creates the array.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建数组的 `.map()` 函数。
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: And here’s how we pass it to `when()` as a parameter list.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何将其作为参数列表传递给 `when()`。
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `when()` function returns its own `Deferred` object, so we can use the methods
    we already know to process its completion. Now we finally have a complete solution
    for retrieving the World Bank data.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`when()` 函数返回它自己的 `Deferred` 对象，因此我们可以使用我们已经知道的方法来处理它的完成。现在我们终于有了一个完整的解决方案来获取世界银行数据。'
- en: With our data safely in hand, we can now coerce it into a format that Flot accepts.
    We extract the `date` and `value` properties from the raw data. We also have to
    account for gaps in the data. The World Bank doesn’t have GDP data for every region
    for every year. When it’s missing data for a particular year, it returns `null`
    for `value`. The same combination of `.grep()` and `.map()` that we used before
    will serve us once again.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据安全到手之后，我们现在可以将其强制转换为 Flot 可接受的格式。我们从原始数据中提取 `date` 和 `value` 属性。我们还必须考虑数据中的缺口。世界银行并不是每个区域每年都有
    GDP 数据。当某一年的数据缺失时，它会返回 `null` 作为 `value`。我们之前使用过的 `.grep()` 和 `.map()` 的组合将在这里再次派上用场。
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, we’re iterating through the list of regions with the `.each()`
    function at ➊. For each region, we create an object of data for the Flot library.
    (No points for originality in naming that object `flotData` at ➋.) Then we filter
    the data starting at ➌ to eliminate any data points with `null` values. The function
    that creates our Flot data array starts at ➍. It takes, as input, a single data
    object from the World Bank, and returns the data as a two-dimensional data point.
    The first value is the date, which we extract as an integer at ➎, and the second
    value is the GDP data, which we extract as a floating-point number at ➏. Dividing
    by `1e12` converts the GDP data to trillions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用 `.each()` 函数在 ➊ 遍历区域列表。对于每个区域，我们创建一个供 Flot 库使用的数据对象。（给这个对象命名为 `flotData`
    在 ➋ 并没有什么创意可言。）然后，我们从 ➌ 开始过滤数据，删除任何值为 `null` 的数据点。创建我们 Flot 数据数组的函数从 ➍ 开始。它的输入是来自世界银行的单个数据对象，并将数据作为二维数据点返回。第一个值是日期，我们在
    ➎ 提取为整数，第二个值是 GDP 数据，我们在 ➏ 提取为浮动点数。通过除以 `1e12`，将 GDP 数据转换为万亿单位。
- en: 'Step 6: Create the Chart'
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 6：创建图表
- en: Since we’ve made it this far with a clear separation between code that handles
    events and code that processes the results, there’s no reason not to continue
    the approach when we actually create the chart. Yet another `Deferred` object
    creates that separation.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在处理事件的代码和处理结果的代码之间进行了清晰的分离，实际上在创建图表时继续采用这种方法也是合理的。又一个 `Deferred` 对象在这里创建了这种分离。
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here we’ve taken the preceding code fragments and wrapped them in `Deferred`
    object handling. Once all of the data has been processed, we resolve that `Deferred`
    object at ➊.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将前面的代码片段封装在 `Deferred` 对象的处理过程中。一旦所有数据处理完毕，我们就在 ➊ 处解析该 `Deferred` 对象。
- en: The entire process is reminiscent of a frog hopping between lily pads in a pond.
    The pads are the processing steps, and `Deferred` objects are the bridges between
    them ([Figure 2-16](ch02.html#deferred_objects_help_keep_each_bit_of_c "Figure 2-16. Deferred
    objects help keep each bit of code isolated to its own pad.")).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程让人想起青蛙在池塘中的荷叶之间跳跃。荷叶是处理步骤，而`Deferred`对象则是它们之间的桥梁（[图2-16](ch02.html#deferred_objects_help_keep_each_bit_of_c
    "图2-16. Deferred对象有助于将每个代码片段隔离在自己的荷叶上。")）。
- en: '![Deferred objects help keep each bit of code isolated to its own pad.](figs/web/02fig16.png.jpg)Figure 2-16. `Deferred`
    objects help keep each bit of code isolated to its own pad.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![Deferred对象有助于将每个代码片段隔离在自己的荷叶上。](figs/web/02fig16.png.jpg)图2-16. `Deferred`对象有助于将每个代码片段隔离在自己的荷叶上。'
- en: The real benefit to this approach is its separation of concerns. Each processing
    step remains independent of the others. Should any step require changes, there’s
    no need to look at the others. Each lily pad, in effect, remains its own island
    without concern for the rest of the pond.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的真正好处在于它的关注点分离。每个处理步骤都独立于其他步骤。如果任何步骤需要更改，则无需查看其他步骤。每个荷叶实际上都保持自己独立的岛屿，而不必担心池塘的其他部分。
- en: 'Once we’re at the final step, we can use any or all of the techniques from
    this chapter’s other examples to draw the chart. Once again, the `.map()` function
    can easily extract relevant information from the region data. Here is a basic
    example:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成最后一步，就可以使用本章其他示例中的任何一种或多种技术来绘制图表。再次强调，`.map()` 函数可以轻松地从区域数据中提取相关信息。以下是一个基本示例：
- en: '[PRE65]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Our basic chart now gets its data directly from the World Bank. We no longer
    have to manually process its data, and our charts are updated automatically whenever
    the World Bank updates its data ([Figure 2-17](ch02.html#with_ajax_we_can_graph_live_data_from_an
    "Figure 2-17. With AJAX we can graph live data from another site in the user’s
    browser.")).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本图表现在直接从世界银行获取数据。我们不再需要手动处理数据，而且每当世界银行更新数据时，我们的图表也会自动更新（[图2-17](ch02.html#with_ajax_we_can_graph_live_data_from_an
    "图2-17. 通过AJAX，我们可以在用户的浏览器中从另一个网站绘制实时数据图表。")）。
- en: '![With AJAX we can graph live data from another site in the user’s browser.](figs/web/02fig17.png.jpg)Figure 2-17. With
    AJAX we can graph live data from another site in the user’s browser.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过AJAX，我们可以在用户的浏览器中从另一个网站绘制实时数据图表。](figs/web/02fig17.png.jpg)图2-17. 通过AJAX，我们可以在用户的浏览器中从另一个网站绘制实时数据图表。'
- en: In this example you’ve seen how to access the World Bank’s application programming
    interface. The same approach works for many other organizations that provide data
    on the Internet. In fact, there are so many data sources available today that
    it can be difficult to keep track of them all.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您已经看到如何访问世界银行的应用程序接口。相同的方法也适用于许多其他提供互联网上数据的组织。事实上，今天有如此多的数据源可供使用，以至于可能很难跟踪它们所有。
- en: 'Here are two helpful websites that serve as a central repository for both public
    and private APIs accessible on the Internet:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个有用的网站，它们作为一个集中库，提供可以访问的公共和私人API：
- en: APIhub (*[http://www.apihub.com/](http://www.apihub.com/)*)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APIhub (*[http://www.apihub.com/](http://www.apihub.com/)*)
- en: ProgrammableWeb (*[http://www.programmableweb.com/](http://www.programmableweb.com/)*)
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ProgrammableWeb (*[http://www.programmableweb.com/](http://www.programmableweb.com/)*)
- en: Many governments also provide a directory of available data and APIs. The United
    States, for example, centralizes its resources at the Data.gov website (*[http://www.data.gov/](http://www.data.gov/)*).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 许多政府也提供了可用数据和API的目录。例如，美国将其资源集中在Data.gov网站上 (*[http://www.data.gov/](http://www.data.gov/)*）。
- en: This example focuses on the AJAX interaction, so the resulting chart is a simple,
    static line chart. Any of the interactions described in the other examples from
    this chapter could be added to increase the interactivity of the visualization.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例重点讲解了AJAX交互，因此生成的图表是一个简单的静态折线图。可以将本章其他示例中描述的任何交互添加到图表中，以增强可视化的互动性。
- en: Summing Up
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: As the examples in this chapter show, we don’t have to be satisfied with static
    charts on our web pages. A little JavaScript can bring charts to life by letting
    users interact with them. These interactions give users a chance to see a “big
    picture” view of the data and, on the same page, look into the specific aspects
    that are most interesting and relevant to them. We’ve considered techniques that
    let users select which data series appear on our charts, zoom in on specific chart
    areas, and use their mouse to explore details of the data without losing sight
    of the overall view. We’ve also looked at how to get interactive data directly
    from its source using AJAX and asynchronous programming.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章中的示例所示，我们不必满足于在网页上展示静态图表。通过一些 JavaScript 代码，可以让图表生动起来，允许用户与其互动。这些互动使用户能够看到数据的“全貌”，并且在同一页面上，深入查看对他们最有趣和相关的具体内容。我们已经考虑了让用户选择在图表上显示哪些数据系列、放大图表特定区域，并通过鼠标探索数据的细节，同时不失去对整体视图的掌控。我们还探讨了如何通过
    AJAX 和异步编程直接从数据源获取互动数据。
