- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: PRINCIPLES OF DYNAMIC TAINT ANALYSIS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 动态污点分析的原理
- en: Imagine that you’re a hydrologist who wants to trace the flow of a river that
    runs partly underground. You already know where the river goes underground, but
    you want to find out whether and where it emerges. One way to solve this problem
    is to color the river’s water using a special dye and then look for locations
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一个水文学家，想要追踪一条部分流经地下的河流的流向。你已经知道河流进入地下的地方，但你想找出它是否以及在哪个地方重新浮出水面。解决这个问题的一种方法是使用特殊的染料给河水上色，然后寻找这些染色水的出现地点。
- en: where the colored water reappears. The topic of this chapter, *dynamic taint
    analysis (DTA)*, applies the same idea to binary programs. Similar to coloring
    and tracing the flow of water, you can use DTA to color, or *taint*, selected
    data in a program’s memory and then dynamically track the data flow of the tainted
    bytes to see which program locations they affect.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在彩色水重新出现的地方。本章的主题，*动态污点分析（DTA）*，将相同的思路应用于二进制程序。类似于给水流上色并追踪其流向，你可以使用DTA给程序内存中的选定数据上色或*标记污点*，然后动态跟踪这些污点字节的数据流，查看它们会影响程序中的哪些位置。
- en: In this chapter, you’ll learn the principles of dynamic taint analysis. DTA
    is a complex technique, so it’s important to be familiar with its inner workings
    to build effective DTA tools. In [Chapter 11](ch11.xhtml#ch11), I’ll introduce
    you to `libdft`, an open source DTA library, which we’ll use to build several
    practical DTA tools.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习动态污点分析的原理。DTA是一项复杂的技术，因此熟悉其内部工作原理对构建有效的DTA工具至关重要。在[第11章](ch11.xhtml#ch11)中，我将向你介绍`libdft`，一个开源的DTA库，我们将使用它来构建几个实用的DTA工具。
- en: 10.1 What Is DTA?
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1 什么是DTA？
- en: Dynamic taint analysis (DTA), also called *data flow tracking (DFT)*, *taint
    tracking*, or simply *taint analysis*, is a program analysis technique that allows
    you to determine the influence that a selected program state has on other parts
    of the program state. For instance, you can *taint* any data that a program receives
    from the network, track that data, and raise an alert if it affects the program
    counter, as such an effect can indicate a control-flow hijacking attack.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 动态污点分析（DTA），也称为*数据流追踪（DFT）*，*污点追踪*，或简称*污点分析*，是一种程序分析技术，可以帮助你确定选定的程序状态对其他程序状态部分的影响。例如，你可以*标记污点*任何程序从网络接收到的数据，追踪这些数据，并在它们影响程序计数器时发出警报，因为这种影响可能表明发生了控制流劫持攻击。
- en: In the context of binary analysis, DTA is typically implemented on top of a
    dynamic binary instrumentation platform such as Pin, which we discussed in [Chapter
    9](ch09.xhtml#ch09). To track the flow of data, DTA instruments all instructions
    that handle data, either in registers or in memory. In practice, this includes
    nearly all instructions, which means that DTA leads to very high performance overhead
    on instrumented programs. Slowdowns of 10x or more are not uncommon, even in optimized
    DTA implementations. While a 10x overhead may be acceptable during security tests
    of a web server, for instance, it usually isn’t okay in production. This is why
    you’ll typically use DTA only for offline analysis of programs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制分析的背景下，DTA通常是在动态二进制插桩平台（如Pin）之上实现的，我们在[第9章](ch09.xhtml#ch09)中讨论过该平台。为了追踪数据流，DTA会插桩所有处理数据的指令，无论数据是在寄存器中还是在内存中。实际上，这几乎包括了所有指令，这意味着DTA会对插桩的程序带来非常高的性能开销。即使是在优化过的DTA实现中，10倍或更大的性能下降也很常见。例如，在进行Web服务器的安全测试时，10倍的开销可能是可以接受的，但在生产环境中通常是不可接受的。这就是为什么DTA通常仅用于程序的离线分析。
- en: You can also base taint analysis systems on static instrumentation instead of
    dynamic instrumentation, inserting the necessary taint analysis logic at compile
    time rather than at runtime. While that approach usually results in better performance,
    it also requires source code. Since our focus is binary analysis, we’ll stick
    to dynamic taint analysis in this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以基于静态插桩来构建污点分析系统，而不是基于动态插桩，在编译时插入必要的污点分析逻辑，而不是在运行时。虽然这种方法通常能带来更好的性能，但它也需要源代码。由于我们关注的是二进制分析，本书将坚持使用动态污点分析。
- en: 'As mentioned, DTA allows you to track the influence of a selected program state
    on interesting program locations. Let’s take a closer look at the details of what
    this means: how do you define interesting state or locations, and what exactly
    does it mean for one part of the state to “influence” another?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，DTA可以让你追踪选定的程序状态对有趣的程序位置的影响。让我们更详细地了解这意味着什么：如何定义有趣的状态或位置，某个状态部分对另一个部分的“影响”到底意味着什么？
- en: '10.2 DTA in Three Steps: Taint Sources, Taint Sinks, and Taint Propagation'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2 三步法中的 DTA：污点源、污点汇和污点传播
- en: 'At a high level, taint analysis involves three steps: defining *taint sources*,
    defining *taint sinks*, and *tracking taint propagation*. If you’re developing
    a tool based on DTA, the first two steps (defining taint sources and sinks) are
    up to you. The third step (tracking the taint propagation) is usually handled
    by an existing DTA library, such as `libdft`, but most DTA libraries also provide
    ways for you to customize this step if you want. Let’s go over these three steps
    and what each entails.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层来看，污点分析包括三个步骤：定义 *污点源*、定义 *污点汇* 和 *追踪污点传播*。如果你正在开发一个基于 DTA 的工具，前两个步骤（定义污点源和污点汇）由你来完成。第三个步骤（追踪污点传播）通常由现有的
    DTA 库来处理，比如 `libdft`，但大多数 DTA 库也提供了让你自定义这一过程的方式。如果你愿意，我们可以逐步了解这三个步骤及其包含的内容。
- en: '*10.2.1 Defining Taint Sources*'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.2.1 定义污点源*'
- en: '*Taint sources* are the program locations where you select the data that’s
    interesting to track. For example, system calls, function entry points, or individual
    instructions can all be taint sources, as you’ll see shortly. What data you choose
    to track depends on what you want to achieve with your DTA tool.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*污点源*是你选择有趣数据进行追踪的程序位置。例如，系统调用、函数入口点或单个指令都可以作为污点源，正如你即将看到的那样。你选择追踪哪些数据，取决于你希望通过
    DTA 工具实现什么目标。'
- en: You can mark data as interesting by tainting it using API calls provided for
    that very purpose by the DTA library you’re using. Typically, those API calls
    take a register or memory address to mark as tainted as the input. For example,
    let’s say you want to track any data that comes in from the network to see whether
    it exhibits any behavior that could indicate an attack. To do that, you instrument
    network-related system calls like `recv` or `recvfrom` with a callback function
    that’s called by the dynamic instrumentation platform whenever these system calls
    occur. In that callback function, you loop over all the received bytes and mark
    them as tainted. In this example, the `recv` and `recvfrom` functions are your
    taint sources.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 DTA 库提供的 API 调用将数据标记为有趣的数据，从而对其进行污点标记。通常，这些 API 调用会接受一个寄存器或内存地址作为输入，来标记为污点数据。例如，假设你想要追踪从网络中传入的任何数据，以查看它是否表现出可能表明攻击的行为。为此，你需要在与网络相关的系统调用（如
    `recv` 或 `recvfrom`）上插入回调函数，每当这些系统调用发生时，动态插桩平台都会调用此回调函数。在该回调函数中，你遍历所有接收到的字节并将其标记为污点数据。在这个例子中，`recv`
    和 `recvfrom` 函数就是你的污点源。
- en: Similarly, if you’re interested in tracking data read from file, then you’d
    use system calls such as `read` as your taint source. If you want to track numbers
    that are the product of two other numbers, you could taint the output operands
    of multiplication instructions, which are then your taint sources, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你对追踪从文件中读取的数据感兴趣，你可以使用 `read` 等系统调用作为你的污点源。如果你想追踪两个数字相乘的结果，你可以对乘法指令的输出操作数进行污点标记，这些输出操作数就是你的污点源，等等。
- en: '*10.2.2 Defining Taint Sinks*'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.2.2 定义污点汇*'
- en: '*Taint sinks* are the program locations you check to see whether they can be
    influenced by tainted data. For example, to detect control-flow hijacking attacks,
    you’d instrument indirect calls, indirect jumps, and return instructions with
    callbacks that check whether the targets of these instructions are influenced
    by tainted data. These instrumented instructions would be your taint sinks. DTA
    libraries provide functions that you can use to check whether a register or memory
    location is tainted. Typically, when taint is detected at a taint sink, you’ll
    want to trigger some response, such as raising an alert.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*污点汇*是你检查程序中是否有可能受到污点数据影响的位置。例如，为了检测控制流劫持攻击，你需要在间接调用、间接跳转和返回指令上插入回调函数，以检查这些指令的目标是否受到污点数据的影响。这些插入回调的指令就是你的污点汇。DTA
    库提供了可以用于检查寄存器或内存位置是否被污点数据影响的函数。通常，当在污点汇检测到污点时，你可能需要触发某种响应，比如触发警报。'
- en: '*10.2.3 Tracking Taint Propagation*'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.2.3 追踪污点传播*'
- en: As I mentioned, to track the flow of tainted data through a program, you need
    to instrument all instructions that handle data. The instrumentation code determines
    how taint propagates from the input operands of an instruction to its output operands.
    For instance, if the input operand of a `mov` instruction is tainted, the instrumentation
    code will mark the output operand as tainted as well, since it’s clearly influenced
    by the input operand. In this way, tainted data may eventually propagate all the
    way from a taint source to a taint sink.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，要追踪程序中污点数据的流动，你需要对处理数据的所有指令进行插装。插装代码决定了污点如何从指令的输入操作数传播到其输出操作数。例如，如果`mov`指令的输入操作数被标记为污点，那么插装代码也会将输出操作数标记为污点，因为输出显然受输入操作数的影响。通过这种方式，污点数据可能最终从污点源传播到污点汇。
- en: Tracking taint is a complicated process because determining which parts of an
    output operand to taint isn’t always trivial. Taint propagation is subject to
    a *taint policy* that specifies the taint relationship between input and output
    operands. As I’ll explain in [Section 10.4](ch10.xhtml#ch10_1), there are different
    taint policies you can use depending on your needs. To save you the trouble of
    having to write instrumentation code for all instructions, taint propagation is
    typically handled by a dedicated DTA library, such as `libdft`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪污点是一个复杂的过程，因为确定输出操作数的哪些部分需要被标记为污点并非总是很简单。污点传播受到*污点策略*的约束，污点策略指定了输入和输出操作数之间的污点关系。正如我在[第10.4节](ch10.xhtml#ch10_1)中所解释的，根据你的需求，你可以使用不同的污点策略。为了避免你为所有指令编写插装代码的麻烦，污点传播通常由专门的DTA库（例如`libdft`）来处理。
- en: Now that you understand how taint tracking works in general, let’s explore how
    you can use DTA to detect an information leak using a concrete example. In [Chapter
    11](ch11.xhtml#ch11), you’ll learn how to implement your own tool to detect just
    this kind of vulnerability!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了污点跟踪的基本原理，让我们通过一个具体的例子来探讨如何使用DTA检测信息泄露。在[第11章](ch11.xhtml#ch11)中，你将学习如何实现自己的工具来检测这种类型的漏洞！
- en: 10.3 Using DTA to Detect the Heartbleed Bug
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3 使用DTA检测Heartbleed漏洞
- en: To see how DTA can be useful in practice, let’s consider how you can use it
    to detect the Heartbleed vulnerability in OpenSSL. OpenSSL is a cryptographic
    library that’s widely used to protect communications on the Internet, including
    connections to websites and email servers. Heartbleed can be abused to leak information
    from systems using a vulnerable version of OpenSSL. This can include highly sensitive
    information, such as private keys and usernames/passwords stored in memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看DTA如何在实践中派上用场，让我们考虑一下如何使用它来检测OpenSSL中的Heartbleed漏洞。OpenSSL是一个广泛用于保护互联网通信的加密库，包括与网站和电子邮件服务器的连接。Heartbleed漏洞可以被利用来从使用易受攻击版本的OpenSSL的系统中泄露信息。这些信息可能包括高度敏感的内容，比如存储在内存中的私钥、用户名/密码等。
- en: '*10.3.1 A Brief Overview of the Heartbleed Vulnerability*'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.3.1 Heartbleed漏洞概述*'
- en: Heartbleed abuses a classic buffer overread in OpenSSL’s implementation of the
    Heartbeat protocol (note that *Heartbeat* is the name of the exploited protocol,
    while *Heartbleed* is the name of the exploit). The Heartbeat protocol allows
    devices to check whether the connection with an SSL-enabled server is still alive
    by sending the server a *Heartbeat request* containing an arbitrary character
    string specified by the sender. If all is well, the server responds by echoing
    back that string in a *Heartbeat response* message.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed利用了OpenSSL实现的Heartbeat协议中的经典缓冲区过度读取漏洞（注意，*Heartbeat*是被利用的协议的名称，而*Heartbleed*是该漏洞的名称）。Heartbeat协议允许设备通过向SSL启用的服务器发送*Heartbeat请求*，该请求包含由发送方指定的任意字符字符串，以检查与服务器的连接是否仍然存活。如果一切正常，服务器会通过回显该字符串的*Heartbeat响应*消息来做出回应。
- en: In addition to the character string, the Heartbeat request contains a field
    specifying the length of that string. It’s the incorrect handling of this length
    field that results in the Heartbleed vulnerability. Vulnerable versions of OpenSSL
    allow an attacker to specify a length that’s much longer than the actual string,
    causing the server to leak additional bytes from memory when copying the string
    into the response.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符字符串外，Heartbeat请求还包含一个字段，用于指定该字符串的长度。正是对该长度字段的错误处理导致了Heartbleed漏洞的出现。易受攻击版本的OpenSSL允许攻击者指定一个远大于实际字符串长度的值，从而导致服务器在将字符串复制到响应中时泄露额外的内存字节。
- en: '[Listing 10-1](ch10.xhtml#ch10list1) shows the OpenSSL code responsible for
    the Heartbleed bug. Let’s briefly discuss how it works and then go over how DTA
    can detect Heartbleed-related information leaks.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-1](ch10.xhtml#ch10list1)展示了导致 Heartbleed 漏洞的 OpenSSL 代码。我们先简要讨论一下它的工作原理，然后再介绍DTA如何检测与Heartbleed相关的信息泄漏。'
- en: '*Listing 10-1: The code that causes the OpenSSL Heartbleed vulnerability*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：导致 OpenSSL Heartbleed 漏洞的代码*'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code in [Listing 10-1](ch10.xhtml#ch10list1) is part of the OpenSSL function
    that prepares a Heartbeat response after receiving a request. The three most important
    variables in the listing are `pl`, `payload`, and `bp`. The variable `pl` is a
    pointer to the payload string in the Heartbeat request, which will be copied into
    the response. Despite the confusing name, `payload` is not a pointer to the pay-load
    string but an `unsigned int` specifying the *length* of that string. Both `pl`
    and `payload` are taken from the Heartbeat request message, so in the context
    of Heartbleed they are *controlled by the attacker*. The variable `bp` is a pointer
    into the response buffer where the payload string is copied.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-1](ch10.xhtml#ch10list1)中的代码是 OpenSSL 函数的一部分，用于在接收到请求后准备心跳响应。清单中三个最重要的变量是`pl`、`payload`和`bp`。变量`pl`是指向心跳请求中负载字符串的指针，该字符串将被复制到响应中。尽管名字让人困惑，`payload`并不是指向负载字符串的指针，而是一个`unsigned
    int`，指定了该字符串的*长度*。`pl`和`payload`都来自心跳请求消息，因此在 Heartbleed 漏洞的上下文中，它们是*由攻击者控制的*。变量`bp`是指向响应缓冲区的指针，用于复制负载字符串。'
- en: 'First, the code in [Listing 10-1](ch10.xhtml#ch10list1) allocates the response
    buffer ➊ and sets `bp` to the start of that buffer ➋. Note that the size of the
    buffer is controlled by the attacker through the `payload` variable. The first
    byte in the response buffer contains the packet type: `TLS1_HB_RESPONSE` (a Heartbeat
    response) ➌. The next 2 bytes contain the payload length, which is simply copied
    (by the `s2n` macro) from the attacker-controlled `payload` variable ➍.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，[清单 10-1](ch10.xhtml#ch10list1)中的代码分配了响应缓冲区➊，并将`bp`设置为该缓冲区的起始位置➋。请注意，缓冲区的大小由攻击者通过`payload`变量控制。响应缓冲区中的第一个字节包含数据包类型：`TLS1_HB_RESPONSE`（心跳响应）➌。接下来的2个字节包含负载长度，该长度直接通过`payload`变量（由`S2N`宏处理）从攻击者控制的`payload`变量中复制过来➍。
- en: 'Now comes the core of the Heartbleed vulnerability: a `memcpy` that copies
    `payload` bytes from the `pl` pointer into the response buffer ➎. Recall that
    both `payload` and the string stored at `pl` are under the attacker’s control.
    Thus, by supplying a short string and a large number for `payload`, you can trick
    the `memcpy` to continue copying past the request string, leaking whatever happens
    to be in memory next to the request. In this way, it’s possible to leak up to
    64KB of data. Finally, after adding some random padding bytes to the end of the
    response ➏, the response containing the leaked information is sent over the network
    to the attacker ➐.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入 Heartbleed 漏洞的核心部分：一个`memcpy`，它将`payload`字节从`pl`指针复制到响应缓冲区➎。回想一下，`payload`和存储在`pl`中的字符串都在攻击者的控制之下。因此，通过提供一个较短的字符串和一个较大的`payload`数值，你可以欺骗`memcpy`继续复制过请求字符串，泄漏请求旁边的内存内容。通过这种方式，最多可以泄漏64KB的数据。最后，在响应的末尾添加一些随机填充字节➏，包含泄漏信息的响应会通过网络发送到攻击者➐。
- en: '*10.3.2 Detecting Heartbleed Through Tainting*'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.3.2 通过污染检测 Heartbleed 漏洞*'
- en: '[Figure 10-1](ch10.xhtml#ch10fig1) shows how you can use DTA to detect this
    kind of information leak by illustrating what happens in the memory of a system
    being attacked by Heartbleed. For the purposes of this example, you can assume
    that the Heartbeat request is stored in memory close to a secret key and that
    you’ve tainted the secret key so that you can track where it’s copied. You can
    also assume the `send` and `sendto` system calls are taint sinks, detecting any
    tainted data that’s about to be sent out over the network. For simplicity, the
    figure shows only the relevant strings in memory but not the type and length fields
    of the request and response messages.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-1](ch10.xhtml#ch10fig1)展示了如何使用DTA检测这种信息泄漏，并说明了在遭受Heartbleed攻击的系统内存中发生的情况。在这个示例中，你可以假设心跳请求存储在靠近一个秘密密钥的内存位置，并且你已经污染了该密钥，以便追踪它被复制的位置。你还可以假设`send`和`sendto`系统调用是污染接收点，用于检测即将通过网络发送的污染数据。为了简便起见，图中只展示了内存中的相关字符串，而没有显示请求和响应消息的类型和长度字段。'
- en: '[Figure 10-1a](ch10.xhtml#ch10fig1) shows the situation just after a Heartbeat
    request crafted by an attacker is received. The request contains the payload string
    `foobar`, which happens to be stored in memory next to some random bytes (marked
    as `?`) and a secret key. The variable `pl` points to the start of the string,
    and the attacker has set `payload` to 21 so that the 15 bytes adjacent to the
    payload string will be leaked.^([1](footnote.xhtml#ch10fn_1)) The secret key is
    tainted so that you can detect when it leaks over the network, and the buffer
    for the response is allocated elsewhere in memory.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-1a](ch10.xhtml#ch10fig1)展示了攻击者精心构造的心跳请求刚刚接收后的情况。请求包含负载字符串`foobar`，它恰好存储在内存中，紧邻一些随机字节（标记为`?`）和一个密钥。变量`pl`指向字符串的起始位置，攻击者已将`payload`设置为21，使得与负载字符串相邻的15个字节会被泄露。^([1](footnote.xhtml#ch10fn_1))
    密钥被标记为污点，以便当它通过网络泄露时可以被检测到，而响应的缓冲区则分配在内存的其他地方。'
- en: '![image](Images/f270-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f270-01.jpg)'
- en: '*Figure 10-1: The Heartbleed buffer overread leaks a secret key into the response
    buffer, which is sent over the network. Tainting the key allows the overread to
    be detected when the leaked information is sent out.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：Heartbleed缓冲区过度读取将一个密钥泄漏到响应缓冲区，该缓冲区将通过网络发送。污点化密钥使得在泄漏信息被发送时，能够检测到过度读取。*'
- en: Next, [Figure 10-1b](ch10.xhtml#ch10fig1) shows what happens when the vulnerable
    `memcpy` is executed. As it should, the `memcpy` begins by copying the payload
    string `foobar`, but because the attacker set `payload` to 21, the `memcpy` continues
    even after it’s done copying the 6 bytes of the payload string. The `memcpy` over-reads,
    first into the random data stored adjacent to the payload string and then into
    the secret key. As a result, the secret key ends up in the response buffer, from
    where it’s about to be sent out over the network.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[图10-1b](ch10.xhtml#ch10fig1)展示了当易受攻击的`memcpy`被执行时发生的情况。正如预期的那样，`memcpy`首先开始复制负载字符串`foobar`，但由于攻击者将`payload`设置为21，`memcpy`会继续复制，即使它已经复制完了负载字符串的6个字节。`memcpy`会过度读取，首先是读取负载字符串旁边存储的随机数据，然后是密钥。结果，密钥被复制到了响应缓冲区，并即将通过网络发送出去。
- en: Without taint analysis, the game would be over at this point. The response buffer,
    including the leaked secret key, would now be sent back to the attacker. Fortunately,
    in this example, you’re using DTA to prevent this from happening. When the secret
    key is copied, the DTA engine notices that it’s copying tainted bytes and marks
    the output bytes as tainted as well. After the `memcpy` completes and you check
    for tainted bytes before executing the network `send`, you’ll notice that part
    of the response buffer is tainted, thereby detecting the Heartbleed attack.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有污点分析，游戏就此结束了。包括泄露的密钥在内的响应缓冲区将被发送回攻击者。幸运的是，在这个例子中，你使用DTA防止了这种情况的发生。当密钥被复制时，DTA引擎会注意到它正在复制被污点标记的字节，并将输出字节也标记为污点。在`memcpy`完成并在执行网络`send`之前检查污点字节时，你会发现响应缓冲区的部分内容已经被污点标记，从而检测到Heartbleed攻击。
- en: This is just one of many applications of dynamic taint analysis, some others
    of which I’ll cover in [Chapter 11](ch11.xhtml#ch11). As I mentioned, you wouldn’t
    want to run this kind of DTA on a production server because of the large slowdown
    it imposes. However, the kind of analysis I just described works well in combination
    with fuzzing, where you test the security of an application or library like OpenSSL
    by providing it with pseudorandomly generated inputs, such as Heartbeat requests
    where the payload string and length fields don’t match up.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是动态污点分析的众多应用之一，其他一些应用我将在[第11章](ch11.xhtml#ch11)中介绍。正如我之前提到的，你不想在生产服务器上运行这种类型的DTA，因为它会造成很大的性能下降。然而，我刚刚描述的这种分析与模糊测试结合使用时效果很好，模糊测试是通过向应用程序或库（如OpenSSL）提供伪随机生成的输入来测试其安全性，例如，当负载字符串和长度字段不匹配的心跳请求。
- en: To detect bugs, fuzzing relies on externally observable effects, such as the
    program crashing or hanging. However, not all bugs produce such visible effects
    since bugs such as information leaks may occur silently without a crash or hang.
    You can use DTA to extend the range of observable bugs in fuzzing to include noncrashing
    bugs such as information leaks. This type of fuzzing could have revealed the presence
    of Heartbleed before vulnerable OpenSSL versions ever went into the wild.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测漏洞，模糊测试依赖于外部可观察的效果，比如程序崩溃或挂起。然而，并非所有漏洞都会产生这种可见效果，因为信息泄露等漏洞可能在没有崩溃或挂起的情况下悄然发生。你可以使用
    DTA 扩展模糊测试中可观察到的漏洞范围，将非崩溃类漏洞（如信息泄露）也包括其中。这种类型的模糊测试本可以在脆弱的 OpenSSL 版本发布之前发现 Heartbleed
    漏洞。
- en: This example involved simple taint propagation where the tainted secret key
    was directly copied into the output buffer. Next I’ll cover more complex types
    of taint propagation with more complicated data flow.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子涉及简单的污点传播，其中污点的密钥直接被复制到输出缓冲区。接下来，我将介绍更复杂的数据流中更复杂的污点传播类型。
- en: '10.4 DTA Design Factors: Taint Granularity, Taint Colors, and Taint Policies'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4 DTA 设计因素：污点粒度、污点颜色数和污点策略
- en: 'In the previous section, DTA required only simple taint propagation rules,
    and the taint itself was also simple: a byte of memory is either tainted or not.
    In more complex DTA systems, there are multiple factors that determine the balance
    between the performance and versatility of the system. In this section, you’ll
    learn about the three most important design dimensions for DTA systems: the *taint
    granularity*, the *number of colors*, and the *taint propagation policy*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，DTA 仅需要简单的污点传播规则，污点本身也很简单：一字节的内存要么是污点，要么不是。在更复杂的 DTA 系统中，有多个因素决定系统性能与通用性之间的平衡。在本节中，你将学习
    DTA 系统的三个最重要的设计维度：*污点粒度*、*污点颜色数*和*污点传播策略*。
- en: Note that you can use DTA for many different purposes, including bug detection,
    preventing data exfiltration, automatic code optimization, forensics, and more.
    In each of these applications, it means something different to say a value is
    tainted. To keep the following discussion simple, when a value is tainted, I’ll
    consistently take that to mean “an attacker can affect this value.”
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，DTA 可用于许多不同的目的，包括漏洞检测、数据外泄防护、自动代码优化、取证等。在这些应用中，"污点"这一概念的意义不同。为了简化以下讨论，当一个值是污点时，我将始终将其理解为“攻击者可以影响该值”。
- en: '*10.4.1 Taint Granularity*'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.4.1 污点粒度*'
- en: '*Taint granularity* is the unit of information by which a DTA system tracks
    taint. For instance, a bit-granular system keeps track of whether each individual
    bit in a register or memory is tainted, whereas a byte-granular system tracks
    taint information only per byte. If even 1 bit in a particular byte is tainted,
    a byte-granular system will mark that whole byte as tainted. Similarly, in a word-granular
    system, taint information is tracked per memory word, and so on.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*污点粒度*是 DTA 系统追踪污点的最小信息单位。例如，比特粒度系统会追踪寄存器或内存中每个比特是否为污点，而字节粒度系统只会按字节追踪污点信息。如果某个字节中的任意
    1 个比特为污点，字节粒度系统将标记整个字节为污点。类似地，字长粒度系统会按内存字长追踪污点信息，以此类推。'
- en: 'To visualize the difference between bit-granularity and byte-granularity DTA
    systems, let’s consider how taint propagates through a bitwise AND (`&`) operation
    on two byte-sized operands where one of the operands is tainted. In the following
    example, I’ll show all the bits of each operand individually. Each bit is enclosed
    in a box. The white boxes represent untainted bits, while the gray ones represent
    tainted bits. First, here’s how the taint would propagate in a bit-granularity
    system:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化比特粒度和字节粒度 DTA 系统之间的差异，让我们考虑一个二进制与运算（`&`）操作，操作数为两个字节，其中一个字节是污点。接下来，我将分别展示每个操作数的所有比特，每个比特都会被框住。白色框表示非污点比特，灰色框表示污点比特。首先，来看一下污点如何在比特粒度系统中传播：
- en: '![image](Images/f271-01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f271-01.jpg)'
- en: As you can see, all the bits in the first operand are tainted, while no bits
    are tainted in the second operand. Since this is a bitwise AND operation, each
    output bit can be set to 1 only if both input operands have a 1 at the corresponding
    position. In other words, if an attacker controls only the first input operand,
    then the only bit positions in the output that they can affect are those where
    the second operand has a 1\. All other output bits will always be set to 0\. That’s
    why in this example, only one output bit is tainted. It’s the only bit position
    the attacker can control since only that position is set to 1 in the second operand.
    In effect, the untainted second operand acts as a “filter” for the first operand’s
    taint.^([2](footnote.xhtml#ch10fn_2))
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，第一个操作数的所有比特都被污染，而第二个操作数的比特没有任何污染。由于这是按位与（AND）操作，只有当两个输入操作数在相应位置都有 1
    时，输出比特才会被设置为 1。换句话说，如果攻击者仅控制第一个输入操作数，那么他们能够影响输出的唯一比特位置就是第二个操作数在该位置上为 1 的那些位置。所有其他输出比特将始终被设置为
    0。因此，在这个例子中，只有一个输出比特被污染。它是攻击者可以控制的唯一比特位置，因为第二个操作数只有在该位置设置了 1。实际上，没有污染的第二个操作数充当了第一个操作数污染的“过滤器”。^([2](footnote.xhtml#ch10fn_2))
- en: Now let’s contrast this with the corresponding operation in a byte-granularity
    DTA system. The two input operands are the same as before.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其与字节粒度 DTA 系统中的相应操作进行对比。两个输入操作数与之前相同。
- en: '![image](Images/f272-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f272-01.jpg)'
- en: Because a byte-granularity DTA system can’t consider each bit individually,
    the whole output is marked as tainted. The system simply sees a tainted input
    byte and a nonzero second operand and therefore concludes that an attacker could
    affect the output operand.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字节粒度 DTA 系统无法单独考虑每个比特，因此整个输出被标记为污染。系统仅看到一个被污染的输入字节和一个非零的第二个操作数，因此得出结论，攻击者可能会影响输出操作数。
- en: 'As you can see, the granularity of a DTA system is an important factor influencing
    its accuracy: a byte-granular system may be less accurate than a bit-granular
    system, depending on the inputs. On the other hand, taint granularity is also
    a major factor in the performance of a DTA system. The instrumentation code required
    to track taint individually for each bit is complex, leading to high performance
    overhead. While byte-granularity systems are less accurate, they allow for simpler
    taint propagation rules, requiring only simple instrumentation code. Generally,
    this means that byte-granular systems are much faster than bit-granular ones.
    In practice, most DTA systems use byte-granularity to achieve a reasonable compromise
    between accuracy and speed.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，DTA 系统的粒度是影响其准确性的重要因素：字节粒度系统可能比比特粒度系统不那么准确，具体取决于输入。另一方面，污染粒度也是 DTA 系统性能的一个主要因素。为了单独跟踪每个比特的污染所需的插装代码是复杂的，这导致了较高的性能开销。尽管字节粒度系统准确性较低，但它们允许更简单的污染传播规则，仅需要简单的插装代码。通常，这意味着字节粒度系统比比特粒度系统要快得多。实际上，大多数
    DTA 系统使用字节粒度，以在准确性和速度之间实现合理的折衷。
- en: '*10.4.2 Taint Colors*'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.4.2 污染颜色*'
- en: In all the examples so far, we’ve assumed that a value is either tainted or
    not. Going back to our river analogy, this was simple enough to do using only
    a single color of dye. But sometimes you may want to simultaneously trace multiple
    rivers that flow through the same cave system. If you dyed multiple rivers using
    just one color, you wouldn’t know exactly how the rivers connect since the colored
    water could have come from any source.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有迄今为止的例子中，我们都假设一个值要么被污染，要么没有被污染。回到我们的河流类比，使用单一颜色的染料来完成这件事相当简单。但有时你可能希望同时追踪多条流经同一洞穴系统的河流。如果你使用同一种颜色给多条河流染色，那么你就无法准确知道河流是如何连接的，因为染色的水可能来自任何源头。
- en: Similarly, in DTA systems, you sometimes want to know not just that a value
    is tainted but *where* the taint came from. You can use multiple *taint colors*
    to apply a different color to each taint source so that when taint reaches a sink,
    you can tell exactly which source affects that sink.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 DTA 系统中，有时你不仅需要知道一个值是否被污染，还需要知道污染*来自哪里*。你可以使用多个*污染颜色*为每个污染源应用不同的颜色，这样当污染到达汇点时，你就可以准确知道哪个源头影响了该汇点。
- en: In a byte-granular DTA system with just one taint color, you need only a single
    bit to keep track of the taint for each byte of memory. To support more than one
    color, you need to store more taint information per byte. For instance, to support
    eight colors, you need 1 byte of taint information per byte of memory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个只有一种污染颜色的字节粒度 DTA 系统中，只需要一个单独的位来跟踪每个字节内存的污染情况。为了支持多于一种颜色，你需要为每个字节存储更多的污染信息。例如，为了支持八种颜色，你需要为每个字节内存存储
    1 字节的污染信息。
- en: 'At first glance, you might think that you can store 255 different colors in
    1 byte of taint information since a byte can store 255 distinct nonzero values.
    However, that approach doesn’t allow for different colors to mix. Without the
    ability to mix colors, you won’t be able to distinguish between taint flows when
    two taint flows run together: if a value is affected by two different taint sources,
    each with their own color, you won’t be able to record both colors in the affected
    value’s taint information.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，你可能会认为可以在 1 字节的污染信息中存储 255 种不同的颜色，因为一个字节可以存储 255 个不同的非零值。然而，这种方法无法支持不同颜色的混合。没有混合颜色的能力，你将无法在两个污染流一起运行时区分污染流：如果一个值受到两个不同污染源的影响，每个污染源都有自己的颜色，那么你将无法在该值的污染信息中记录两种颜色。
- en: To support mixing colors, you need to use a dedicated bit per taint color. For
    instance, if you have 1 byte of taint information, you can support the colors
    `0x01`, `0x02`, `0x04`, `0x08`, `0x10`, `0x20`, `0x40`, and `0x80`. Then, if a
    particular value is tainted by both the colors `0x01` and `0x02`, the combined
    taint information for this value is `0x03`, which is the bitwise OR of the two
    colors. You can think of the different taint colors in terms of actual colors
    to make things easier. For example, you can refer to `0x01` as “red,” `0x02` as
    “blue,” and the combined color `0x03` as “purple.”
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持颜色混合，你需要为每种污染颜色使用一个专用的位。例如，如果你有 1 字节的污染信息，你可以支持颜色 `0x01`、`0x02`、`0x04`、`0x08`、`0x10`、`0x20`、`0x40`
    和 `0x80`。然后，如果某个值受到 `0x01` 和 `0x02` 两种颜色的污染，那么该值的组合污染信息就是 `0x03`，这是两种颜色的按位 OR
    运算结果。你可以通过实际的颜色来理解不同的污染颜色，以便更容易理解。例如，你可以将 `0x01` 称为“红色”，将 `0x02` 称为“蓝色”，将组合颜色
    `0x03` 称为“紫色”。
- en: '*10.4.3 Taint Propagation Policies*'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.4.3 污染传播策略*'
- en: The *taint policy* of a DTA system describes how the system propagates taint
    and how it merges taint colors if multiple taint flows run together. [Table 10-1](ch10.xhtml#ch10tab1)
    shows how taint propagates through several different operations in an example
    taint policy for a byte-granular DTA system with two colors, “red” (R) and “blue”
    (B). All operands in the examples consist of 4 bytes. Note that other taint policies
    are possible, especially for complex operations that perform nonlinear transformations
    on their operands.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: DTA 系统的*污染策略*描述了系统如何传播污染，以及如果多个污染流一起运行时，如何合并污染颜色。[表 10-1](ch10.xhtml#ch10tab1)展示了在一个字节粒度的
    DTA 系统中，污染是如何通过几种不同的操作传播的，使用了两种颜色：“红色”（R）和“蓝色”（B）。所有示例中的操作数均由 4 个字节组成。请注意，其他污染策略也是可能的，特别是对于那些对操作数执行非线性变换的复杂操作。
- en: '**Table 10-1:** Taint Propagation Examples for a Byte-Granularity DTA System
    with Two Colors, Red (R) and Blue (B)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** 一个字节粒度 DTA 系统的污染传播示例，使用两种颜色，红色（R）和蓝色（B）'
- en: '![image](Images/f273-01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f273-01.jpg)'
- en: 'In the first example, the value of a variable *a* is assigned to a variable
    *c* ➊, equivalent to an x86 `mov` instruction. For simple operations like this,
    the taint propagation rules are likewise straightforward: since the output *c*
    is just a copy of *a*, the taint information for *c* is a copy of *a*’s taint
    information. In other words, the taint merge operator in this case is :=, the
    assignment operator.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，变量 *a* 的值被赋给变量 *c* ➊，相当于 x86 `mov` 指令。对于像这样的简单操作，污染传播规则同样很简单：因为输出 *c*
    只是 *a* 的副本，所以 *c* 的污染信息是 *a* 污染信息的副本。换句话说，在这种情况下，污染合并运算符是 :=，赋值运算符。
- en: The next example is an `xor` operation, *c* = *a* ⊕ *b* ➋. In this case, it
    doesn’t make sense to simply assign the taint from one of the input operands to
    the output because the output depends on both inputs. Instead, a common taint
    policy is to take the byte-by-byte union (∪) of the input operands’ taint. For
    instance, the most significant byte of the first operand is tainted red (R), while
    it’s blue (B) in the second operand. Thus, the taint of the most signifi-cant
    output byte is the union of these, colored both red and blue (RB).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例是 `xor` 运算，*c* = *a* ⊕ *b* ➋。在这种情况下，简单地将其中一个输入操作数的污点分配给输出是没有意义的，因为输出依赖于两个输入。相反，一个常见的污点策略是对输入操作数的污点进行逐字节联合（∪）。例如，第一个操作数的最高有效字节被标记为红色（R），而第二个操作数的最高有效字节标记为蓝色（B）。因此，输出的最高有效字节的污点是这两者的联合，既有红色也有蓝色（RB）。
- en: 'The same byte-by-byte union policy is used for addition in the third example
    ➌. Note that for addition there is a corner case: adding 2 bytes can produce an
    overflow bit, which flows into the least significant bit (LSB) of the neighboring
    byte. Suppose that an attacker controls only the least significant byte of one
    of the operands. Then, in this corner case, the attacker may be able to cause
    1 bit to overflow into the neighboring byte, allowing the attacker to also partially
    affect that byte’s value. You can accommodate this corner case in the taint policy
    by adding an explicit check for it and tainting the neighboring byte if an overflow
    occurs. In practice, many DTA systems choose not to check for this corner case
    for simpler and faster taint propagation.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个示例 ➌ 中也使用了逐字节联合策略进行加法运算。请注意，对于加法运算，有一个特殊情况：两个字节的加法可能会产生溢出位，并将其传递到相邻字节的最低有效位（LSB）。假设攻击者只控制其中一个操作数的最低有效字节。那么，在这种特殊情况下，攻击者可能会导致
    1 位溢出到相邻字节，从而使攻击者也能部分影响该字节的值。你可以通过显式检查此特殊情况并在发生溢出时标记相邻字节来在污点策略中考虑此特殊情况。在实际操作中，许多
    DTA 系统选择不检查这种特殊情况，以简化和加快污点传播。
- en: Example ➍ is a special case of the `xor` operation. Taking the `xor` of an operand
    with itself (*c* = *a* *a*) always produces the output zero. In this case, even
    if an attacker controls *a*, they still won’t have any control over the output
    *c*. The taint policy is therefore to clear the taint of each output byte by setting
    it to the empty set (ø).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 ➍ 是 `xor` 运算的特例。对操作数与其自身进行 `xor` 运算（*c* = *a* *a*）始终会产生输出零。在这种情况下，即使攻击者控制了
    *a*，他们也无法控制输出 *c*。因此，污点策略是通过将每个输出字节的污点清除为空集（ø）来清除所有输出字节的污点。
- en: Next is a left-shift operation by a constant value, *c* = *a* ≪ 6 ➎. Because
    the second operand is constant, an attacker can’t always control all output bytes,
    even if they partially control the input *a*. A reasonable policy is to only propagate
    the input taint to those bytes of the output that are (partially or entirely)
    covered by one of the tainted input bytes, in effect “shifting the taint left.”
    In this example, since the attacker controls only the lower byte of *a* and it’s
    shifted left by 6 bits, this means the taint from the lower byte propagates to
    the lower *two* bytes of the output.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个常量值的左移操作，*c* = *a* ≪ 6 ➎。由于第二个操作数是常量，即使攻击者部分控制输入 *a*，也无法始终控制所有输出字节。一个合理的策略是，仅将输入的污点传播到输出中那些（部分或完全）由污点输入字节覆盖的字节，实际上是“将污点向左移动”。在这个例子中，由于攻击者只控制
    *a* 的低字节，并且该字节左移了 6 位，这意味着低字节的污点会传播到输出的低 *两个* 字节。
- en: In example ➏, on the other hand, the value that is shifted (*a*) and the shift
    amount (*b*) are both variable. An attacker who controls *b*, as is the case in
    the example, can affect all bytes of the output. Thus, the taint of *b* is assigned
    to every output byte.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例 ➏ 中，另一方面，移动的值（*a*）和移动的量（*b*）都是变量。控制 *b* 的攻击者（如示例中的情况）可以影响输出的所有字节。因此，*b*
    的污点会被赋给每个输出字节。
- en: DTA libraries, such as `libdft`, have a predefined taint policy, saving you
    the trouble of implementing rules for all types of instructions. However, you
    can tweak the rules on a tool-by-tool basis for those instructions where the default
    policy doesn’t entirely suit your needs. For instance, if you’re implementing
    a tool that’s meant to detect information leaks, you may want to improve performance
    by disabling taint propagation through instructions that alter the data beyond
    recognition.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: DTA库，如`libdft`，具有预定义的污点策略，免去了你为所有类型的指令实现规则的麻烦。然而，你可以根据具体工具调整规则，对于那些默认策略不完全适合你需求的指令进行修改。例如，如果你正在实现一个检测信息泄露的工具，你可能希望通过禁用污点传播来提高性能，尤其是通过那些改变数据使其无法识别的指令。
- en: '*10.4.4 Overtainting and Undertainting*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.4.4 污点过度与污点不足*'
- en: Depending on the taint policy, a DTA system may suffer from undertainting, overtainting,
    or both.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据污点策略，DTA系统可能会出现污点不足、污点过度或两者同时发生的情况。
- en: '*Undertainting* occurs when a value isn’t tainted even though it “should be,”
    which in our case means that an attacker can get away with influencing that value
    without being noticed. Undertainting can be the result of the taint policy, for
    instance if the system doesn’t handle corner cases such as overflow bits in addition,
    as mentioned previously. It can also occur when taint flows through unsupported
    instructions for which no taint propagation handler exists. For example, DTA libraries
    such as `libdft` usually don’t have built-in support for x86 MMX or SSE instructions,
    so taint that flows through such instructions can get lost. Control dependencies
    can also cause under-tainting, as you’ll see shortly.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*污点不足*发生在一个值没有被污点标记，尽管它“应该”被标记，这意味着攻击者可以在不被发现的情况下影响该值。污点不足可能是污点策略的结果，例如系统未处理加法中的溢出位等边缘情况，如前所述。当污点流经不受支持的指令且没有污点传播处理程序时，也可能会发生污点不足。例如，DTA库如`libdft`通常不内置对x86
    MMX或SSE指令的支持，因此，流经这些指令的污点可能会丢失。控制依赖性也可能导致污点不足，正如你稍后会看到的那样。'
- en: Similarly to undertainting, *overtainting* means that values end up tainted
    even though they “shouldn’t be.” This results in false positives, such as alerts
    when there is no actual attack in progress. Like undertainting, overtainting can
    be a result of the taint policy or the way control dependencies are handled.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与污点不足类似，*污点过度*意味着值最终被污点标记，尽管它“本不该被标记”。这会导致假阳性，例如在没有实际攻击发生的情况下触发警报。像污点不足一样，污点过度也可能是污点策略或控制依赖性处理方式的结果。
- en: While DTA systems strive to minimize undertainting and overtainting, it’s generally
    impossible to avoid these problems completely while keeping reasonable performance.
    There is currently no practical DTA library that doesn’t suffer from a degree
    of undertainting or overtainting.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然DTA系统努力最小化污点不足和污点过度，但通常在保持合理性能的同时，完全避免这些问题是不可能的。目前没有任何一个实用的DTA库能够完全避免一定程度的污点不足或污点过度。
- en: '*10.4.5 Control Dependencies*'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.4.5 控制依赖性*'
- en: 'Recall that taint tracking is used to trace *data flows*. Sometimes, however,
    data flows can be implicitly influenced by control structures like branches in
    what is known as an *implicit flow*. You’ll see a practical example of an implicit
    flow in [Chapter 11](ch11.xhtml#ch11), but for now, take a look at the following
    synthetic example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，污点追踪用于追踪*数据流*。然而，有时数据流可能会受到像分支这样的控制结构的隐式影响，这种情况被称为*隐式流*。你将在[第11章](ch11.xhtml#ch11)中看到隐式流的实际示例，但现在，先看一下下面这个合成示例：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, an attacker who controls the loop condition `cond` can determine the value
    of `var`. This is called a *control dependency*. While the attacker can control
    `var` through `cond`, there’s no explicit data flow between the two variables.
    Thus, DTA systems that track only explicit data flows will fail to capture this
    dependency and will leave `var` untainted even if `cond` is tainted, resulting
    in undertainting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个控制循环条件`cond`的攻击者可以确定`var`的值。这就叫做*控制依赖性*。虽然攻击者可以通过`cond`控制`var`，但两者之间没有显式的数据流。因此，只有追踪显式数据流的DTA系统将无法捕捉到这种依赖关系，并且即使`cond`被污点标记，`var`也会保持未被标记，从而导致污点不足。
- en: 'Some research has attempted to resolve this problem by propagating taint from
    branch and loop conditions to operations that execute *because* of the branch
    or loop. In this example, that would mean propagating the taint from `cond` to
    `var`. Unfortunately, this approach leads to massive overtainting because tainted
    branch conditions are common, even if no attack is going on. For example, consider
    user input sanitization checks like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一些研究尝试通过将污点从分支和循环条件传播到因分支或循环而执行的操作来解决这个问题。在这个例子中，这意味着将污点从`cond`传播到`var`。不幸的是，这种方法导致了大量的过度污点化，因为污染的分支条件是常见的，即使没有发生攻击。例如，考虑如下的用户输入清理检查：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s assume we’re tainting all user input to check for attacks and that the
    taint of `user_input` propagates to the return value of the `is_safe` function,
    which is used as the branch condition. Assuming that the user input sanitization
    is done properly, the listing is completely safe despite the tainted branch condition.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对所有用户输入进行污点标记以检查攻击，并且`user_input`的污点传播到`is_safe`函数的返回值，后者被用作分支条件。假设用户输入清理做得很妥当，那么尽管分支条件被污染，代码依然是完全安全的。
- en: But DTA systems that try to track control dependencies cannot distinguish this
    situation from the dangerous one shown in the previous listing. These systems
    will always end up tainting `funcptr`, a function pointer that points to a handler
    for the user input. This may raise false positive alerts when the tainted `funcptr`
    is later called. Such rampant false positives can render a system completely unusable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但尝试追踪控制依赖的DTA系统无法将这种情况与前面列出的危险情况区分开来。这些系统最终会将`funcptr`（指向用户输入处理程序的函数指针）标记为污点。当稍后调用被污染的`funcptr`时，这可能会触发误报警告。这种泛滥的误报会使系统完全无法使用。
- en: Because branches on user input are common while implicit flows usable by an
    attacker are relatively rare, most DTA systems in practice don’t track control
    dependencies.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户输入上的分支很常见，而攻击者可利用的隐式流相对较少，因此大多数实际的DTA系统并不追踪控制依赖。
- en: '*10.4.6 Shadow Memory*'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*10.4.6 影子内存*'
- en: So far, I’ve shown you that taint trackers can track taint for each register
    or memory byte, but I haven’t yet explained where they store that taint information.
    To store the information on which parts of registers or memory are tainted, and
    with what color, DTA engines maintain dedicated *shadow memory*. Shadow memory
    is a region of virtual memory allocated by the DTA system to keep track of the
    taint status of the rest of the memory. Typically, DTA systems also allocate a
    special structure in memory where they keep track of taint information for CPU
    registers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经展示了污点追踪器如何追踪每个寄存器或内存字节的污点，但我还没有解释它们是如何存储这些污点信息的。为了存储哪些寄存器或内存部分被污染以及污染的颜色，DTA引擎维护了专用的*影子内存*。影子内存是由DTA系统分配的一个虚拟内存区域，用于跟踪其余内存的污点状态。通常，DTA系统还会分配一个特殊的内存结构，用来追踪CPU寄存器的污点信息。
- en: The structure of the shadow memory differs depending on the taint granularity
    and how many taint colors are supported. [Figure 10-2](ch10.xhtml#ch10fig2) shows
    example byte-granularity shadow memory layouts for tracking up to 1, 8, or 32
    colors per byte of memory, respectively.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 影子内存的结构根据污点粒度以及支持的污点颜色数量的不同而有所区别。[图10-2](ch10.xhtml#ch10fig2)展示了不同字节粒度的影子内存布局示例，分别用于追踪每字节内存的1、8或32种颜色。
- en: '![image](Images/f276-01.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f276-01.jpg)'
- en: '*Figure 10-2: Shadow memory with byte-granularity and 1, 8, or 32 colors per
    byte*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：具有字节粒度并且每个字节支持1、8或32种颜色的影子内存*'
- en: The left part of [Figure 10-2](ch10.xhtml#ch10fig2) shows the virtual memory
    of a program running with DTA. Specifically, it shows the contents of four virtual
    memory bytes, which are labeled A, B, C, and D. Together, those bytes store the
    example hexadecimal value `0xde8a421f`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-2](ch10.xhtml#ch10fig2)的左侧部分展示了一个运行DTA的程序的虚拟内存。具体来说，它显示了四个虚拟内存字节的内容，标记为A、B、C和D。这些字节共同存储了示例十六进制值`0xde8a421f`。'
- en: Bitmap-Based Shadow Memory
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于位图的影子内存
- en: 'The right part of the figure shows three different types of shadow memory and
    how they encode the taint information for bytes A–D. The first type of shadow
    memory, shown at the top right of [Figure 10-2](ch10.xhtml#ch10fig2), is a *bitmap*
    ➊. It stores a single bit of taint information per byte of virtual memory, so
    it can represent only one color: each byte of memory is either tainted or untainted.
    Bytes A–D are represented by the bits `1101`, meaning that bytes A, B, and D are
    tainted, while byte C is not.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图的右侧显示了三种不同类型的阴影内存，以及它们如何对字节 A–D 编码污点信息。第一种类型的阴影内存，如[图 10-2](ch10.xhtml#ch10fig2)右上方所示，是一个*位图*
    ➊。它为每个虚拟内存字节存储一个污点信息位，因此只能表示一种颜色：每个内存字节要么是被污染的，要么是未污染的。字节 A–D 被表示为位 `1101`，意味着字节
    A、B 和 D 是被污染的，而字节 C 不是。
- en: While bitmaps can represent only a single color, they have the advantage of
    requiring relatively little memory. For instance, on a 32-bit x86 system, the
    total size of the virtual memory is 4GB. A shadow memory bitmap for 4GB of virtual
    memory requires only 4GB/8 = 512MB of memory, leaving the remaining 7/8 of the
    virtual memory available for normal use. Note that this approach does not scale
    for 64-bit systems, where the virtual memory space is vastly larger.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然位图只能表示一种颜色，但它们的优点是所需内存相对较少。例如，在 32 位 x86 系统上，虚拟内存的总大小为 4GB。用于 4GB 虚拟内存的阴影内存位图仅需要
    4GB/8 = 512MB 的内存，剩余的 7/8 虚拟内存可以用于正常使用。请注意，这种方法在 64 位系统上无法扩展，因为虚拟内存空间要大得多。
- en: Multicolor Shadow Memory
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多色阴影内存
- en: Multicolor taint engines and x64 systems require more complex shadow memory
    implementations. For instance, take a look at the second type of shadow memory
    shown in [Figure 10-2](ch10.xhtml#ch10fig2) ➋. It supports eight colors and uses
    1 byte of shadow memory per byte of virtual memory. Again, you can see that bytes
    A, B, and D are tainted (with colors `0x01`, `0x04`, and `0x20`, respectively),
    while byte C is untainted. Note that to store taint for every virtual memory byte
    in a process, an unoptimized eight-color shadow memory must be as large as that
    process’s entire virtual memory space!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 多色污点引擎和 x64 系统需要更复杂的阴影内存实现。例如，看看[图 10-2](ch10.xhtml#ch10fig2)中显示的第二种类型的阴影内存
    ➋。它支持八种颜色，每个虚拟内存字节使用 1 字节的阴影内存。同样，你可以看到字节 A、B 和 D 被污染（分别为颜色 `0x01`、`0x04` 和 `0x20`），而字节
    C 未被污染。请注意，为了存储进程中每个虚拟内存字节的污点信息，一个未优化的八色阴影内存必须和该进程的整个虚拟内存空间一样大！
- en: Luckily, there’s usually no need to store shadow bytes for the memory area where
    the shadow memory itself is allocated, so you can omit shadow bytes for that memory
    area. Even so, without further optimizations, the shadow memory still requires
    half of the virtual memory. This can be reduced further by dynamically allocating
    shadow memory only for the parts of virtual memory that are actually in use (on
    the stack or heap), at the cost of some extra runtime overhead. Moreover, virtual
    memory pages that are not writable can never be tainted, so you can safely map
    all of those to the same “zeroed-out” shadow memory page. With these optimizations,
    multicolor DTA becomes manageable, though it still requires a lot of memory.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通常不需要为分配阴影内存的内存区域存储阴影字节，因此可以省略该内存区域的阴影字节。即便如此，如果没有进一步的优化，阴影内存仍然需要占用虚拟内存的一半。通过仅为实际使用的虚拟内存部分（在堆栈或堆中）动态分配阴影内存，且需要一些额外的运行时开销，可以进一步减少这一占用。此外，不能写入的虚拟内存页面永远不会被污染，因此可以安全地将它们映射到同一个“清零”阴影内存页面上。通过这些优化，多色
    DTA 变得可管理，尽管它仍然需要大量内存。
- en: The final shadow memory type shown in [Figure 10-2](ch10.xhtml#ch10fig2) supports
    32 colors ➌. Bytes A, B, and D are tainted with the colors `0x01000000`, `0x00800000`,
    and `0x00000200`, respectively, while byte C is untainted. As you can see, this
    requires 4 bytes of shadow memory per memory byte, which is quite a hefty memory
    overhead.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种阴影内存类型，如[图 10-2](ch10.xhtml#ch10fig2)所示，支持 32 种颜色 ➌。字节 A、B 和 D 分别被污染为颜色
    `0x01000000`、`0x00800000` 和 `0x00000200`，而字节 C 未被污染。如你所见，这需要每个内存字节 4 字节的阴影内存，这相当于较大的内存开销。
- en: All of these examples implement the shadow memory as a simple bitmap, byte array,
    or integer array. By using more complex data structures, it’s possible to support
    an arbitrary number of colors. For instance, you can implement the shadow memory
    using a C++-style `set` of colors for each memory byte. However, that approach
    significantly increases complexity and runtime overhead of the DTA system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例将阴影内存实现为一个简单的位图、字节数组或整数数组。通过使用更复杂的数据结构，可以支持任意数量的颜色。例如，你可以使用C++风格的`set`为每个内存字节实现阴影内存。然而，这种方法会显著增加DTA系统的复杂性和运行时开销。
- en: 10.5 Summary
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5 总结
- en: In this chapter, I introduced you to dynamic taint analysis, one of the most
    powerful binary analysis techniques. DTA allows you to track the flow of data
    from a taint source to a taint sink, which enables automated analyses ranging
    from code optimization to vulnerability detection. Now that you’re familiar with
    DTA basics, you’re ready to move on to [Chapter 11](ch11.xhtml#ch11), where you’ll
    build practical DTA tools with `libdft`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我向你介绍了动态污点分析（DTA），这是一种非常强大的二进制分析技术。DTA允许你跟踪数据从污点源到污点汇的流动，从而实现从代码优化到漏洞检测的自动化分析。现在你已经了解了DTA的基本概念，你可以继续阅读[第11章](ch11.xhtml#ch11)，在其中你将使用`libdft`构建实用的DTA工具。
- en: Exercise
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 1\. Designing a Format String Exploit Detector
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 设计一个格式字符串漏洞检测器
- en: Format string vulnerabilities are a well-known class of exploitable software
    bugs in C-like programming languages. They occur when there’s a `printf` with
    a user-controlled format string, as in `printf(user)` instead of the correct `printf("%s",
    user)`. For a good introduction to format string vulnerabilities, you can read
    the article “Exploiting Format String Vulnerabilities” available at *[http://julianor.tripod.com/bc/formatstring-1.2.pdf](http://julianor.tripod.com/bc/formatstring-1.2.pdf)*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串漏洞是C类编程语言中一种广为人知的可利用软件缺陷。当存在一个由用户控制的格式字符串的`printf`时，就会发生这种漏洞，例如`printf(user)`而不是正确的`printf("%s",
    user)`。关于格式字符串漏洞的详细介绍，您可以阅读文章“利用格式字符串漏洞”，该文章可以在* [http://julianor.tripod.com/bc/formatstring-1.2.pdf](http://julianor.tripod.com/bc/formatstring-1.2.pdf)
    *中找到。
- en: Design a DTA tool that can detect format string exploits launched from the network
    or the command line. What should the taint sources and sinks be, and what sort
    of taint propagation and granularity do you need? At the end of [Chapter 11](ch11.xhtml#ch11),
    you’ll be able to implement your exploit detector!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个可以检测来自网络或命令行的格式字符串漏洞的DTA工具。污点源和汇应该是什么？你需要什么样的污点传播和粒度？在[第11章](ch11.xhtml#ch11)的末尾，你将能够实现你的漏洞检测器！
