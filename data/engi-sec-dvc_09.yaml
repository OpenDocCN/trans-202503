- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: SECURE COMMUNICATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全通信**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In the past, many embedded systems operated in an *air-gapped* environment,
    not connected to any wired or wireless network. Although this practice is still
    present in some industries, it’s slowly vanishing for the simple reason that none
    of the modern ideas like predictive maintenance, data-driven optimization, and
    remote access work without proper communication channels.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，许多嵌入式系统工作在*隔离网络*环境中，既不连接有线网络，也不连接无线网络。尽管这种做法在某些行业中仍然存在，但它正在慢慢消失，原因很简单，现代的一些理念，如预测性维护、数据驱动优化和远程访问，若没有适当的通信渠道，是无法实现的。
- en: Even the first cryptographic methods in the days of Caesar aimed to protect
    communication, and 2,000 years later, the internet is inconceivable without secure
    communication. However, a significant number of *devices* still don’t use secure
    protocols for data exchange with their administrators and other entities in their
    environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在凯撒时代，最早的加密方法也旨在保护通信，2000年后的今天，互联网在没有安全通信的情况下是不可想象的。然而，仍然有相当数量的*设备*在与管理员及其周围其他实体的数据交换中，未使用安全协议。
- en: 'In this chapter, we’ll first look at the set of requirements that’s imposed
    on robust communication channels, followed by an introduction to the most common
    protocol to tackle these challenges and a corresponding practical case study.
    Afterward, we’ll look at two areas where the standard solution doesn’t help: non-IP
    communication and the need for redundancy.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们首先将探讨对稳健通信渠道的要求，接着介绍应对这些挑战的最常见协议，并提供一个相应的实践案例研究。随后，我们将讨论标准解决方案无法解决的两个领域：非IP通信和冗余需求。
- en: '**All the Protection Goals**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**所有保护目标**'
- en: Communication is inherent to human nature. We exchange thoughts, provide assistance
    to others, and work together in teams. Every child who whispers something into
    somebody’s ear is implicitly aware of confidentiality protection.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 交流是人类天性的一部分。我们交换思想，提供帮助，并在团队中合作。每个低声在别人耳边说话的孩子，都隐含地意识到保密的重要性。
- en: For written messages, confidentiality has been a topic for thousands of years,
    as the example of Caesar shows, and it’s still present in postal privacy laws.
    For centuries, monarchs have used royal seals to guarantee the integrity and authenticity
    of documents, while replication of information by letterpress printing clearly
    targets availability—even if one “information source” fails, still others can
    be used to acquire that same “communication data.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于书面信息，保密性已经是一个讨论了几千年的话题，如凯撒的例子所示，并且它仍然存在于邮政隐私法中。几个世纪以来，君主们使用皇家印章来保证文件的完整性和真实性，而通过活字印刷复制信息显然是为了确保可用性——即使某个“信息源”失败，仍然可以通过其他方式获取相同的“通信数据”。
- en: Digital communication at internet scale has been practiced for roughly 30 years,
    and it’s not surprising that it unites the demands for *all the protection goals*
    of previous communication approaches. Considering the specific field of (I)IoT
    device communication, confidentiality is apparently useful, because either proprietary
    values corresponding to intellectual property are transferred or personal data
    about humans is communicated that deserves privacy protection.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数字通信在互联网规模上已经实践了大约30年，毫不奇怪，它集成了以往通信方法的*所有保护目标*的需求。考虑到(I)IoT设备通信的特定领域，保密性显然是有用的，因为传输的可能是与知识产权相关的专有数据，或是需要隐私保护的个人数据。
- en: Also, integrity and authenticity are valued in many cases—for example, for control
    commands in industrial systems. In those scenarios, it’s very important that the
    origin of communication is a legitimate party and that messages haven’t been altered
    on the way. As mentioned before, typical (I)IoT devices rely on working communication
    channels. Disturbances—for example, those introduced by DoS attacks—threaten proper
    system operation and maybe even related business models.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，完整性和真实性在许多情况下也是非常重要的——例如，在工业系统中的控制命令。在这些场景中，确保通信的来源是合法方，并且信息在传输过程中没有被篡改，非常重要。如前所述，典型的(I)IoT设备依赖于正常工作的通信渠道。干扰——例如，DoS攻击引入的干扰——威胁到系统的正常运行，甚至可能危及相关的商业模式。
- en: '**Transport Layer Security**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**传输层安全性**'
- en: When we talk about data communication, we usually start by locating it within
    the *Open Systems Interconnection (OSI) model*. This model supports us in structuring
    stacks of communication protocols, as shown in [Table 7-1](ch07.xhtml#ch07tab01).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论数据通信时，我们通常从*开放系统互联（OSI）模型*中的位置开始。这个模型帮助我们构建通信协议栈，如[表 7-1](ch07.xhtml#ch07tab01)所示。
- en: '**Table 7-1:** Communication Layers According to the OSI Model'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 根据OSI模型的通信层'
- en: '| **Number** | **Layer** | **Description** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **编号** | **层级** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 7 | Application | Application-specific communication data processing |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 应用层 | 特定应用的通信数据处理 |'
- en: '| 6 | Presentation | Translation between network data and application |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 表示层 | 网络数据与应用之间的转换 |'
- en: '| 5 | Session | Session management for communication between nodes |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 会话层 | 节点之间通信的会话管理 |'
- en: '| 4 | Transport | Management of data transmissions between network nodes |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 传输层 | 网络节点之间数据传输的管理 |'
- en: '| 3 | Network | Management of a multiparticipant network |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 网络层 | 多参与者网络的管理 |'
- en: '| 2 | Data link | Transfer of data frames between two entities |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 数据链路层 | 两个实体之间的数据帧传输 |'
- en: '| 1 | Physical | Wired/wireless transmission over a physical medium |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 物理层 | 通过物理介质进行有线/无线传输 |'
- en: The Ethernet standard IEEE 802.3 is a typical example that specifies properties
    for layers 1 and 2\. Often, Internet Protocol (IP) handles the network layer,
    while Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) cover
    functionalities in layers 4 and 5\. Application protocols like the common HyperText
    Transfer Protocol (HTTP) are represented by layer 7.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网标准IEEE 802.3是一个典型的例子，规定了第1层和第2层的属性。通常，互联网协议（IP）处理网络层，而传输控制协议（TCP）和用户数据报协议（UDP）覆盖第4层和第5层的功能。像常见的超文本传输协议（HTTP）这样的应用协议由第7层表示。
- en: 'This section focuses on one of the most common protocols for secure communication:
    Transport Layer Security (TLS). It might seem obvious that it’s located on layer
    4 of the OSI model; however, encryption and decryption are usually attributed
    to layer 6\. And since TLS also performs some kind of session management, we could
    say that it spans across layers 4 to 6 and, thereby, introduces a protection layer
    between raw packets distributed over a network and the application using the transmitted
    data in the end.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍一种最常见的安全通信协议：传输层安全协议（TLS）。看似显而易见，它位于OSI模型的第4层；然而，加密和解密通常归属于第6层。由于TLS还执行某种会话管理，因此我们可以说它跨越第4到第6层，从而在网络上分发的原始数据包与最终使用传输数据的应用之间引入了一个保护层。
- en: '**NOTE**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*TLS is application agnostic. Its payload might carry any application protocol
    like HTTP or even industrial protocols like Modbus.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*TLS与应用无关。它的有效载荷可以携带任何应用协议，如HTTP或甚至工业协议，如Modbus。*'
- en: '***History***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***历史***'
- en: In the 1990s, while Netscape was working on a browser application of the same
    name, the need for secure internet communication became apparent. In 1995, Netscape
    published the predecessor of TLS, the Secure Sockets Layer (SSL) protocol in version
    2.0\. SSL 2.0 and SSL 3.0, released the following year, had significant security
    issues and should never be used in practice.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代，当Netscape开发同名浏览器应用程序时，安全互联网通信的需求变得显而易见。1995年，Netscape发布了TLS的前身——安全套接层（SSL）协议2.0版本。SSL
    2.0和随后发布的SSL 3.0版本存在严重的安全问题，绝不应该在实际中使用。
- en: Unfortunately, many software applications as well as product marketing brochures
    use *SSL* and *TLS* synonymously. Usually, you can assume it’s “a modern TLS version,”
    but as a customer, I would have much more confidence if the manufacturer would
    show its security know-how by not mentioning SSL anymore, anywhere.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多软件应用程序和产品营销手册将*SSL*和*TLS*同义使用。通常，您可以假设它是“现代TLS版本”，但作为客户，如果制造商不再提及SSL，我会更有信心，认为其展示了更高的安全技术水平。
- en: The new protocol name was introduced in 1999 with TLS 1.0 (which was an upgraded
    version of SSL 3.0), maybe to reduce association with the weaknesses of the previous
    SSL versions. TLS 1.1 fixed security issues with the CBC operation mode of block
    ciphers in 2006\. However, both TLS 1.0 and TLS 1.1 were officially deprecated
    in March 2021 and should not be used in modern products.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 新的协议名称在1999年随TLS 1.0（这是SSL 3.0的升级版本）推出，可能是为了减少与之前SSL版本漏洞的关联。TLS 1.1在2006年修复了基于块加密的CBC操作模式中的安全问题。然而，TLS
    1.0和TLS 1.1在2021年3月正式弃用，不应在现代产品中使用。
- en: Version 1.2 of TLS was specified in August 2008 and is still widely in use.
    It replaced the use of weak hash functions like MD5 and SHA-1 with their modern
    counterpart, SHA-256, and extended the support for authenticated encryption ciphers
    like AES-GCM. However, the complexity of TLS 1.2 became its own enemy, and correct
    configuration was not trivial. To minimize configuration mistakes and maximize
    security and performance at the same time, TLS 1.3 was published in 2018\. Every
    new device should use that version by default.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.2版本于2008年8月发布，至今仍被广泛使用。它用现代对等算法SHA-256替代了MD5和SHA-1等弱哈希函数，并扩展了对AES-GCM等认证加密密码的支持。然而，TLS
    1.2的复杂性反过来成了它的敌人，正确的配置并非易事。为了最小化配置错误，同时最大化安全性和性能，TLS 1.3于2018年发布。每个新设备应默认使用该版本。
- en: '***TLS Basics***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TLS基础知识***'
- en: 'TLS is a set of client-server protocols that unite many modern cryptographic
    primitives introduced in [Chapter 2](ch02.xhtml#ch02). These are the two most
    important sub-protocols in practice:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: TLS是一组客户端-服务器协议，它统一了[第2章](ch02.xhtml#ch02)中引入的许多现代加密原语。这些是实践中最重要的两个子协议：
- en: '**Handshake protocol**    In this subprotocol, the cryptographic algorithms
    used to protect a communication channel are negotiated between client and server.
    Usually, at least one of them is authenticated to the other, but mutual authentication
    is also possible. Additionally, the handshake process establishes shared key material
    for the crypto algorithms used in the following communication. Any errors or tampering
    attacks at this stage lead to the termination of the connection.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**握手协议**    在此子协议中，用于保护通信通道的加密算法在客户端和服务器之间进行协商。通常，其中至少一个会经过认证与对方通信，但也可以进行相互认证。此外，握手过程还建立了用于随后的通信中的加密算法的共享密钥材料。此阶段的任何错误或篡改攻击都会导致连接的终止。'
- en: '**Record protocol**    This subprotocol is responsible for organizing and protecting
    the bulk of traffic between two endpoints based on the algorithms and parameters
    negotiated in the handshake protocol.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**记录协议**    此子协议负责基于在握手协议中协商的算法和参数，组织和保护两个端点之间的大部分流量。'
- en: A further general property of TLS is that it uses X.509 certificates for authentication.
    However, in contrast to the device certificates mentioned in [Chapter 6](ch06.xhtml#ch06),
    the common name in these certificates usually corresponds to the device’s IP address,
    its hostname, or its fully qualified domain name (FQDN). This is because the information
    is used to establish the basic connection to the device on the network layer in
    the first place, and the device then has to prove that it’s the legitimate entity
    at this network node.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TLS的另一个通用特性是它使用X.509证书进行身份验证。然而，与[第6章](ch06.xhtml#ch06)中提到的设备证书不同，这些证书中的通用名称通常对应于设备的IP地址、主机名或完全限定域名（FQDN）。这是因为这些信息用于首先在网络层建立与设备的基本连接，然后设备必须证明它是该网络节点上的合法实体。
- en: Never underestimate the complexity of TLS, and stick to secure defaults whenever
    you don’t have specific requirements to change them. The following sections shed
    light on the main properties of the two TLS versions in use today.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要低估TLS的复杂性，当没有具体要求更改时，请坚持使用安全的默认设置。以下章节阐明了当前使用的两种TLS版本的主要特性。
- en: '***TLS 1.3***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TLS 1.3***'
- en: TLS 1.3 is specified in RFC 8446 and is *the* version that product engineers
    should implement and use. [Figure 7-1](ch07.xhtml#ch07fig01) illustrates the handshake
    process for mutual authentication that could, for example, be part of a machine-to-machine
    communication scenario.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3在RFC 8446中进行了规范，它是*产品工程师应当实现和使用的*版本。[图7-1](ch07.xhtml#ch07fig01)展示了相互认证的握手过程，例如，这可能是机器对机器通信场景的一部分。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig01.jpg)'
- en: '*Figure 7-1: A typical TLS 1.3 handshake with mutual authentication*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：典型的TLS 1.3握手过程，带有相互认证*'
- en: In the first step, the client initiates the connection establishment by sending
    the `ClientHello` ➊ message to a server. This message contains the client’s key
    share for a DHE or ECDHE key agreement scheme, its supported TLS version, and
    a list of available crypto algorithms and parameters. In response, the server
    provides its own data for the intended key exchange, its certificate, and a signature
    proving the possession of the corresponding private key. Further, it requests
    the client to authenticate itself and concludes the `ServerHello` ➋ of the handshake
    with a `Finished` message.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，客户端通过向服务器发送`ClientHello` ➊消息来发起连接建立。此消息包含客户端的密钥共享，用于DHE或ECDHE密钥交换方案、其支持的TLS版本以及可用的加密算法和参数列表。作为回应，服务器提供其用于预期密钥交换的数据、其证书，以及证明其拥有相应私钥的签名。此外，它还要求客户端进行身份验证，并以`Finished`消息结束握手中的`ServerHello`
    ➋。
- en: In the third part of the handshake, the client fulfills the server’s certificate
    request by sending its certificate and a signature proving its identity ➌. After
    the client’s `Finished` message, both parties can be sure about the other’s identity
    and are prepared to securely exchange application data ➍.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在握手的第三部分，客户端通过发送其证书及证明其身份的签名来满足服务器的证书请求 ➌。在客户端的`Finished`消息之后，双方可以确认对方的身份，并准备安全地交换应用数据
    ➍。
- en: '**Further Handshake Options**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**进一步的握手选项**'
- en: Besides key-agreement schemes like DHE and ECDHE that guarantee perfect forward
    secrecy but also consume significant performance, TLS 1.3 also provides a *pre-shared
    key (PSK)* option, which distributes keys to devices in an earlier process. However,
    this isn’t the default variant and should be used only in exceptional cases and
    for solid reasons.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了如DHE和ECDHE等保证完美前向保密性但也消耗显著性能的密钥交换方案，TLS 1.3还提供了*预共享密钥（PSK）*选项，它在早期过程将密钥分发给设备。然而，这不是默认选项，应该仅在特殊情况下并有充分理由时使用。
- en: To reduce the necessity for the execution of a complete handshake, TLS 1.3 allows
    you to reuse PSKs from previous (EC)DHE handshakes if the client and server agree
    on it, which means costly asymmetric crypto operations can be spared and efficiency
    is enhanced.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少执行完整握手的必要性，TLS 1.3允许在客户端和服务器达成一致的情况下重用来自先前（EC）DHE握手的预共享密钥（PSK），这意味着可以避免耗费成本的非对称加密操作，从而提高效率。
- en: 'If a client and server share a PSK, TLS 1.3 provides a zero round-trip time
    (0-RTT) mode that allows a client to send PSK-encrypted data with its first message,
    immediately enabling application data communication. However, this speed improvement
    comes at a price: perfect forward secrecy can’t be guaranteed anymore, and the
    0-RTT messages are not protected against replay of messages obtained earlier.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端和服务器共享PSK，TLS 1.3提供了零往返时间（0-RTT）模式，允许客户端在其第一条消息中发送PSK加密的数据，立即启用应用数据通信。然而，这种速度提升是有代价的：无法再保证完美前向保密性，且0-RTT消息没有受到早期获取的消息重放保护。
- en: '**Selection of Crypto Algorithms**'
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加密算法选择**'
- en: Compared to TLS 1.2, TLS 1.3 has significantly reduced the set of possible crypto
    algorithms to be used. This is a strong security enhancement, since it prevents
    *downgrade attacks* that try to influence crypto parameter negotiation to force
    the usage of weak algorithms. In the course of this cleanup, the *cipher suite*,
    a collection of supported crypto algorithms, was reduced to contain symmetric
    crypto only.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与TLS 1.2相比，TLS 1.3显著减少了可使用的加密算法集。这是一个强有力的安全增强，因为它防止了*降级攻击*，这种攻击试图影响加密参数协商，以迫使使用弱算法。在这一清理过程中，*密码套件*，即支持的加密算法集合，被简化为仅包含对称加密算法。
- en: For this symmetric cryptography, TLS 1.3 requires the implementation of the
    `TLS_AES_128_GCM_SHA256` cipher suite, which means that AES with a 128-bit key
    has to operate in GCM mode, and the hash function SHA-256 must be available to
    be used as an HMAC-based extract-and-expand key derivation function (HKDF), which
    is relevant to derive TLS secrets. The additional `TLS_AES_256_GCM_SHA384` and
    `TLS_CHACHA20_POLY1305_SHA256` cipher suites should also be implemented but aren’t
    mandatory. Two cipher suites based on the CCM mode complete the five possible
    options for symmetric crypto in TLS 1.3, and they all belong to the class of modern
    AEAD algorithms.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对称加密，TLS 1.3 要求实现 `TLS_AES_128_GCM_SHA256` 密码套件，这意味着 AES 必须使用 128 位密钥并在 GCM
    模式下运行，同时必须提供 SHA-256 哈希函数，用于作为基于 HMAC 的提取与扩展密钥推导函数（HKDF），这是推导 TLS 密钥所必需的。额外的 `TLS_AES_256_GCM_SHA384`
    和 `TLS_CHACHA20_POLY1305_SHA256` 密码套件也应该实现，但不是强制的。基于 CCM 模式的两个密码套件完成了 TLS 1.3
    中对称加密的五种可能选择，它们都属于现代 AEAD 算法类。
- en: Regarding digital signature algorithms and certificates, TLS 1.3 implementations
    must support RSA PSS and PKCS1 in combination with SHA-256, but also ECDSA based
    on the NIST curve `secp256r1` and SHA-256\. The mandatory curve for ECDHE is also
    `secp256r1`, but the RFC recommends the additional implementation of X25519\.
    DHE based on finite field groups is also possible.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数字签名算法和证书，TLS 1.3 实现必须支持与 SHA-256 结合使用的 RSA PSS 和 PKCS1，也支持基于 NIST 曲线 `secp256r1`
    和 SHA-256 的 ECDSA。ECDHE 的强制曲线也是 `secp256r1`，但 RFC 推荐额外实现 X25519。基于有限域群的 DHE 也是可能的。
- en: '***TLS 1.2***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TLS 1.2***'
- en: Although TLS 1.3 is the most recent version, many devices still rely on TLS
    1.2 specified in RFC 5246, or at least support its use to maintain compatibility
    to legacy devices. However, this requires taking precautions to guarantee secure
    communication.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 TLS 1.3 是最新版本，但许多设备仍依赖于 RFC 5246 中规定的 TLS 1.2，或者至少支持其使用，以保持与旧版设备的兼容性。然而，这需要采取预防措施以确保安全通信。
- en: '**TLS 1.2 vs. TLS 1.3**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**TLS 1.2 与 TLS 1.3**'
- en: A somewhat formal difference between TLS 1.2 and TLS 1.3 is that version 1.2
    cipher suites include asymmetric as well as symmetric algorithms and parameters.
    For example, the `TLS_DH_RSA_WITH_AES_256_CBC_SHA384` cipher suite specifies that
    DH (without the *E* for *ephemeral*) is used for key exchange; authentication
    is based on an RSA certificate; AES with a 256-bit key in CBC mode is used for
    payload encryption, and SHA-384 is the hash function used in the key-derivation
    scheme.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.2 和 TLS 1.3 之间的一个正式区别是，1.2 版本的密码套件包括非对称和对称算法及其参数。例如，`TLS_DH_RSA_WITH_AES_256_CBC_SHA384`
    密码套件指定使用 DH（没有 *E* 表示 *临时*）进行密钥交换；认证基于 RSA 证书；使用 256 位密钥的 AES 在 CBC 模式下进行负载加密，SHA-384
    是用于密钥推导方案的哈希函数。
- en: In addition to the different cipher suite format, TLS 1.2 supports and allows
    a much larger set of crypto algorithms, which can have negative consequences in
    several cases. Besides the possibility of choosing static key-exchange mechanisms
    based on RSA and DH, it’s even possible to select cipher suites that explicitly
    allow anonymous DH key exchange, which means without any verification of the communication
    partner.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了密码套件格式的不同，TLS 1.2 还支持并允许使用更多的加密算法，这在某些情况下可能带来负面影响。除了可以选择基于 RSA 和 DH 的静态密钥交换机制外，甚至可以选择显式允许匿名
    DH 密钥交换的密码套件，这意味着不对通信伙伴进行任何验证。
- en: TLS 1.2 also allows you to select legacy ciphers like 3DES and Rivest Cipher
    4 (RC4) or even the `NULL` cipher without payload encryption. Further, operation
    modes like CBC can be selected that don’t lead to AEAD-compliant security.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.2 还允许选择旧版加密算法，如 3DES 和 Rivest Cipher 4 (RC4)，甚至选择 `NULL` 密码套件，该密码套件不进行负载加密。此外，还可以选择如
    CBC 这样的操作模式，这些模式无法提供 AEAD 合规的安全性。
- en: The option to compress data before transmitting it over TLS was well-meant by
    the designers and is still available in TLS 1.2, but it facilitates vulnerability,
    as shown by the Compression Ratio Info-Leak Made Easy (CRIME) attack.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TLS 中传输数据前进行压缩的选项出于设计者的良好意图，并在 TLS 1.2 中仍然可用，但它也带来了漏洞，如压缩比信息泄露攻击（CRIME）所示。
- en: Besides those security-related differences, TLS 1.2 also misses some performance
    optimizations introduced by TLS 1.3 and the 0-RTT mode.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些与安全相关的差异外，TLS 1.2 还缺少 TLS 1.3 引入的一些性能优化和 0-RTT 模式。
- en: '**Secure Usage**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**安全使用**'
- en: The key to the secure configuration of TLS 1.2 lies in the strong restriction
    of its options. Your implementation must disallow deprecated ciphers like 3DES,
    RC4, weakened export ciphers, CBC operation mode, and (of course) the `NULL` cipher.
    Key exchange based on RSA key transport has to be denied as well as anonymous
    DH. Further, options like data compression have to be disabled to reduce the attack
    surface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 保证TLS 1.2安全配置的关键在于严格限制其选项。您的实施必须禁止使用像3DES、RC4、弱化的出口密码、CBC操作模式和（当然）`NULL`密码这样的弃用密码。基于RSA密钥传输的密钥交换也必须被拒绝，以及匿名DH。此外，像数据压缩这样的选项必须被禁用以减少攻击面。
- en: Looking at it the other way around, your configuration should enable only cipher
    suites that implement DHE and ECDHE key exchange and symmetric AEAD ciphers in
    combination with hash functions from the SHA-2 family, which means TLS 1.2 can
    be trimmed to behave similarly to TLS 1.3 and provide secure communication channels.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，您的配置应仅启用实施DHE和ECDHE密钥交换以及与SHA-2系列哈希函数结合的对称AEAD密码套件，这意味着TLS 1.2可以被修剪以类似于TLS
    1.3并提供安全通信通道的方式行事。
- en: '***Requirements for Devices and Infrastructure***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设备和基础设施的要求***'
- en: 'Assuming you’ve decided that TLS is the way to go for your device and you want
    to make things happen, you still have some requirements to consider before implementing
    a semi-secure communication helter-skelter. From a device perspective, you should
    analyze at least five aspects:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经决定TLS是您设备的选择，并且希望使事情发生，那么在实施半安全通信混乱之前，您仍然需要考虑一些要求。从设备的角度来看，您至少应该分析五个方面：
- en: '**Private-key storage**    If your device has to be able to authenticate itself
    by signing data with a private key, it needs a secure place to store that secret
    in a confidential way.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**私钥存储**    如果您的设备需要通过使用私钥对数据进行签名来进行身份验证，则需要一个安全的地方以保密方式存储该秘密。'
- en: '**Certificate store**    The verification of communication partners’ identities
    is possible only if your device is in possession of corresponding public keys
    and root certificates. These files don’t contain confidential information but
    need to be stored in an integrity-protected way because they represent your device’s
    trust base.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**证书存储**    仅当您的设备拥有相应的公钥和根证书时，才能验证通信伙伴的身份。这些文件不包含机密信息，但需要以完整性保护的方式存储，因为它们代表了您设备的信任基础。'
- en: '**Trustworthy source of randomness**    Key-generation and key-exchange schemes
    in TLS require the availability of trustworthy random numbers. If your device
    generates “random numbers” based on a static value, this might have severe consequences
    for TLS security.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**可信的随机数源**    TLS中的密钥生成和密钥交换方案需要可信的随机数。如果您的设备基于静态值生成“随机数”，这可能会对TLS安全造成严重后果。'
- en: '**Reliable time base**    Especially in industrial scenarios, but also in other
    application domains, devices often don’t need a real-time clock. However, if you
    want to use TLS, your device has to be able to verify the validity period of certificates,
    which is clearly not possible if it’s stuck in the 1980s time-wise.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠的时间基准**    尤其是在工业场景中，但也适用于其他应用领域，设备通常不需要实时时钟。但是，如果您想要使用TLS，则您的设备必须能够验证证书的有效期，这显然在时间上停留在上世纪80年代是不可能的。'
- en: '**Crypto performance**    The TLS handshake performs several operations based
    on asymmetric crypto. Low-performance devices might reach their limit, for example,
    if they have to perform signing with RSA keys. The basic decision of RSA or ECDSA
    might have a strong impact on this point. It also makes a big difference if your
    device is meant to act as a client authenticating once a day, or if it has to
    handle hundreds of connection and authentication requests per minute as a server.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密性能**    TLS握手根据非对称加密执行多个操作。低性能设备可能会达到其极限，例如，如果它们必须使用RSA密钥进行签名。选择使用RSA还是ECDSA可能会对此点产生重大影响。如果您的设备被设计为每天进行一次客户端认证，或者作为服务器处理数百个连接和认证请求，那么这也会产生很大的差异。'
- en: Not only does your device itself need to be prepared for TLS, but also your
    infrastructure and processes need to support it. A common example is the operation
    of a PKI to manage the generation, updating, and revocation of certificates.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您的设备本身不仅需要为TLS做好准备，您的基础设施和流程也需要支持它。一个常见的例子是操作PKI来管理证书的生成、更新和吊销。
- en: Further, the real-time clock in your device probably depends on external time
    synchronization mechanisms like Network Time Protocol (NTP) and Precision Time
    Protocol (PTP), which require appropriate network services, master clocks, and
    the like.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您设备中的实时时钟可能依赖于外部时间同步机制，如网络时间协议（NTP）和精密时间协议（PTP），这些机制需要适当的网络服务、主时钟等支持。
- en: '***Application Examples and Software Libraries***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用示例和软件库***'
- en: 'The most common use case for TLS is HyperText Transfer Protocol Secure (HTTPS),
    the protocol used throughout the internet. It’s also known as *HTTP over TLS*,
    because that’s essentially what’s happening: TLS establishes a secure channel
    between a client and a web server. Within this channel, plain HTTP requests and
    responses are exchanged. In the same way, secure communication can be achieved
    for many other application protocols.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: TLS的最常见应用场景是超文本传输协议安全（HTTPS），这是互联网上普遍使用的协议。它也被称为*基于TLS的HTTP*，因为本质上就是这样：TLS在客户端和Web服务器之间建立了一个安全通道。在这个通道内，交换的是普通的HTTP请求和响应。同样的，许多其他应用协议也可以通过这种方式实现安全通信。
- en: TLS is based on TCP, but is there a way to protect applications like Voice over
    IP (VoIP) or online gaming that rely on UDP or other stateless protocols? Yes,
    you can use a variant called *Datagram Transport Layer Security (DTLS)*. DTLS
    1.2 and DTLS 1.3 are based on TLS 1.2 and TLS 1.3, respectively. They guarantee
    the same security as their TCP-based counterparts but can handle loss and reordering
    of packets.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TLS基于TCP，但是否有办法保护依赖于UDP或其他无状态协议的应用，如VoIP（语音通信）或在线游戏？是的，您可以使用一种变体，称为*数据报传输层安全性（DTLS）*。DTLS
    1.2和DTLS 1.3分别基于TLS 1.2和TLS 1.3，它们保证与其基于TCP的对应版本相同的安全性，但能够处理丢包和数据包重排问题。
- en: When it comes to TLS implementations, OpenSSL is probably the most popular one
    on Linux systems as well as in the field of embedded systems. However, if either
    source code transparency or small footprint are of interest to your product, Mbed
    TLS might be worth a look. Further, implementations are available in a multitude
    of programming languages, such as Rustls for the Rust community.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在TLS实现方面，OpenSSL可能是Linux系统以及嵌入式系统领域中最流行的选择。然而，如果源代码透明度或小巧的占用空间对您的产品很重要，Mbed
    TLS可能值得一试。此外，还有许多编程语言中的实现可供选择，例如为Rust社区提供的Rustls。
- en: '**Case Study: Secure MQTT Communication**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：安全的MQTT通信**'
- en: Over the last few years as a professor, I’ve seen several student projects using
    the MQTT protocol, because it’s pretty comprehensible and perfectly suits the
    needs of resource-constrained devices in IoT scenarios. It’s used to transmit
    sensor values like temperature or pressure as well as to control messages like
    start and stop commands for actuators in a system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，作为一名教授，我看到许多学生项目使用MQTT协议，因为它相当易于理解，且非常适合物联网场景中资源受限设备的需求。它用于传输传感器值，如温度或压力，以及控制消息，如启动和停止命令，用于系统中的执行器。
- en: However, if I ask for a secure communication channel for the obviously sensitive
    message content, I usually get responses like “But it’s only a proof of concept!”
    or “There was no time left to tackle this complex topic.” And, “Why do you always
    ask such painful questions?”
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我要求为显然敏感的消息内容提供一个安全的通信通道，通常会收到类似“但这只是一个概念验证！”或“没有时间处理这个复杂的课题。”以及“为什么你总是问这么痛苦的问题？”这样的回答。
- en: In this case study, I’ll set up the Eclipse Mosquitto MQTT broker service on
    my STM32MP157F-DK2 board and configure it properly for secure communication based
    on TLS. Further, I’ll dynamically test the implementation for misconfigurations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究中，我将在STM32MP157F-DK2开发板上设置Eclipse Mosquitto MQTT代理服务，并根据TLS配置它以实现安全通信。此外，我将动态测试实现中的配置错误。
- en: '***Mosquitto Installation and Configuration***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Mosquitto 安装与配置***'
- en: Because the toolchain for my STM32MP157F-DK2 device is based on the Yocto Project,
    I can simply add the `mosquitto` recipe from `recipes-connectivity` of the `meta-networking`
    layer to my image to install the broker software on my device. The version I get
    is `2.0.14`. Of course, this comes only with a default configuration located at
    */etc/mosquitto/mosquitto.conf*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我的STM32MP157F-DK2设备的工具链是基于Yocto项目的，所以我可以简单地将`meta-networking`层中的`recipes-connectivity`里的`mosquitto`配方添加到我的镜像中，以便在设备上安装代理软件。我得到的版本是`2.0.14`。当然，这只带有位于*/etc/mosquitto/mosquitto.conf*的默认配置。
- en: In MQTT, the broker is a central component that receives messages and data published
    by clients and distributes this information to clients that subscribe to it. For
    clients, it’s essential to share their data only with legitimate brokers and rely
    on messages only from brokers they trust. Therefore, MQTT brokers have to cryptographically
    authenticate to connecting clients.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在MQTT中，代理是一个核心组件，它接收客户端发布的消息和数据，并将这些信息分发给订阅它的客户端。对于客户端来说，至关重要的是仅将数据与合法的代理共享，并且只依赖它们信任的代理发布的消息。因此，MQTT代理必须通过加密认证来验证连接的客户端。
- en: 'As mentioned previously, TLS uses certificates for authentication, so the first
    step for broker authentication is to generate a corresponding certificate. I used
    Python and OpenSSL to create a CA and a MQTT broker certificate in a similar way,
    as described for device identities in [Chapter 6](ch06.xhtml#ch06). An important
    difference is the chosen common name in the certificate: it corresponds to the
    hostname *http://mqtt.iot-device-corp.com/* under which the device can be reached
    within my network. This is important for hostname verification by the clients,
    so they can be sure to be connected to the correct host.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TLS使用证书进行身份验证，因此代理认证的第一步是生成相应的证书。我使用Python和OpenSSL以类似于[第6章](ch06.xhtml#ch06)中描述的设备身份的方式，创建了一个CA和一个MQTT代理证书。一个重要的区别是证书中选择的公共名称：它对应于在我的网络中可以通过*http://mqtt.iot-device-corp.com/*访问的主机名。这对于客户端的主机名验证至关重要，以便它们能够确保连接到正确的主机。
- en: Armed with the CA certificate `ca.crt`, the broker certificate `mqtt_broker.crt`,
    and its corresponding private key `mqtt_broker.key`, we can configure the basic
    TLS settings for `mosquitto` as shown in [Listing 7-1](ch07.xhtml#ch07list01).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借CA证书`ca.crt`、代理证书`mqtt_broker.crt`及其对应的私钥`mqtt_broker.key`，我们可以按照[列表 7-1](ch07.xhtml#ch07list01)中所示，配置`mosquitto`的基本TLS设置。
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: The basic TLS configuration for* mosquitto'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-1：mosquitto的基本TLS配置*'
- en: While plain MQTT is usually offered at port 1883, the version using secure communication
    based on TLS is typically provided at port 8883\. Required certificates and keys
    can, for example, be stored in */etc/mosquitto/ certs/*. So far, so good.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然普通的MQTT通常通过1883端口提供，但基于TLS的安全通信版本通常通过8883端口提供。所需的证书和密钥可以存储在*/etc/mosquitto/certs/*中。例如，至此一切正常。
- en: However, up until now, the system is configured only for server-side authentication.
    Client authentication would have to be managed by maintaining a password file
    on the device hosting the broker application (for example, at */etc/mosquitto/password_file*),
    which might be tedious, and the associated security level would be medium at best.
    But since TLS supports mutual certificate-based authentication, and Mosquitto
    is able to utilize that procedure for application layer usage, it’s worth a look.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，直到现在，系统仅配置了服务器端认证。客户端认证需要通过在托管代理应用程序的设备上维护一个密码文件来管理（例如，在*/etc/mosquitto/password_file*），这可能会比较繁琐，且相关的安全级别最多只能算中等。但由于TLS支持基于证书的双向认证，而Mosquitto能够利用这一过程进行应用层的使用，因此值得一探。
- en: '[Listing 7-2](ch07.xhtml#ch07list02) shows the two options that have to be
    added to *mosquitto.conf*.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-2](ch07.xhtml#ch07list02)展示了必须添加到*mosquitto.conf*的两个选项。'
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-2: Important options for certificate-based authentication of MQTT
    clients*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-2：基于证书的MQTT客户端认证的重要选项*'
- en: The first line makes the broker request a certificate for authentication from
    each connecting client, while the second line enables the use of the common name
    contained in the provided certificate as the username in the MQTT application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使代理请求每个连接的客户端提供用于身份验证的证书，而第二行则启用了将提供的证书中包含的公共名称用作MQTT应用程序中的用户名。
- en: It’s important to note that, in this case, the client certificate has to be
    issued by the CA provided before by the `cafile` parameter. If you want to provide
    several trusted CAs to Mosquitto, the `capath` option is your friend. In my case,
    I just used the same CA as for the MQTT broker to create a further certificate,
    this time with the common name `mqtt-client123`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在这种情况下，客户端证书必须由`cafile`参数之前提供的CA颁发。如果你想为Mosquitto提供多个受信任的CA，`capath`选项是你的好帮手。在我的案例中，我使用了与MQTT代理相同的CA来创建一个额外的证书，这次使用了公共名称`mqtt-client123`。
- en: '***The First Test Run***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***第一次测试运行***'
- en: After starting `mosquitto` with the new configuration file, a brief `nmap` scan
    reveals that the MQTT broker is now available at port 8883, as shown in [Listing
    7-3](ch07.xhtml#ch07list03).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用新配置文件启动`mosquitto`之后，简短的`nmap`扫描表明，MQTT代理现在可以通过端口8883访问，如[清单 7-3](ch07.xhtml#ch07list03)所示。
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-3: An* nmap *scan showing open port 8883*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-3：显示开放端口8883的*nmap*扫描*'
- en: To test the secure communication, I wrote a little Python script that uses the
    Eclipse Paho MQTT client library. [Listing 7-4](ch07.xhtml#ch07list04) shows the
    basic settings.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试安全通信，我写了一个小的Python脚本，使用了Eclipse Paho MQTT客户端库。[清单 7-4](ch07.xhtml#ch07list04)显示了基本的设置。
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-4: The basic Paho MQTT client configuration in Python*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-4：Python中的基本Paho MQTT客户端配置*'
- en: Besides obvious necessities like the hostname and the port of the MQTT broker,
    the client is also able to handle TLS settings like a trusted CA in *ca.crt*,
    and the client’s authentication data located in the *mqtt_client.crt* and *mqtt_client.key*
    files.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了MQTT代理的主机名和端口等明显的必要信息外，客户端还能够处理TLS设置，如*ca.crt*中的受信任CA，以及位于*mqtt_client.crt*和*mqtt_client.key*文件中的客户端认证数据。
- en: In the test application, the client subscribes to the topic `foo/bar`, publishes
    some data to the same topic, and receives the information again from the broker,
    as shown in [Listing 7-5](ch07.xhtml#ch07list05).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试应用程序中，客户端订阅主题`foo/bar`，向同一主题发布一些数据，并再次从代理接收信息，如[清单 7-5](ch07.xhtml#ch07list05)所示。
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 7-5: The* mosquitto *console output during a test*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-5：测试期间* mosquitto *控制台输出*'
- en: Clearly, a connection was successfully established on port 8883 ➊. Also, `mosquitto`
    directly uses the client certificate’s common name (`mqtt-client123`) as the associated
    username ➋ for this connection. Both client commands, `SUBSCRIBE` ➌ and `PUBLISH`
    ➍, are correctly received and handled on the broker side as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，连接已成功建立在端口8883上 ➊。此外，`mosquitto`直接使用客户端证书的通用名称（`mqtt-client123`）作为此连接的相关用户名
    ➋。两个客户端命令，`SUBSCRIBE` ➌和`PUBLISH` ➍，也都正确地在代理端接收到并处理。
- en: '***Communication Security Analysis with Wireshark and SSLyze***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Wireshark和SSLyze进行通信安全分析***'
- en: The application seems to be working properly even though we already activated
    several TLS security features. That raises hope, but as security engineers, we’d
    prefer to base our trust on thorough analysis rather than gut feelings.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经启用了多个TLS安全特性，但应用程序似乎仍然运行正常。这让人有希望，但作为安全工程师，我们更倾向于通过深入分析而非直觉来建立信任。
- en: One of the tools for such analysis is Wireshark. It allows us to capture network
    communication traffic and analyze it for security properties. I first configured
    it to collect all exchanged data between the test station and the STM32MP157F
    device. Afterward, I filtered for TLS packets. [Figure 7-2](ch07.xhtml#ch07fig02)
    shows a snippet of the result.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此类分析的工具之一是Wireshark。它允许我们捕获网络通信流量并分析其安全性。我首先将其配置为收集测试站和STM32MP157F设备之间交换的所有数据。然后，我过滤了TLS数据包。[图
    7-2](ch07.xhtml#ch07fig02)显示了结果的片段。
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig02.jpg)'
- en: '*Figure 7-2: The TLS messages exchanged during MQTT communication*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：MQTT通信中交换的TLS消息*'
- en: You can see that a TLS handshake with its characteristic `ClientHello` and `ServerHello`
    messages took place. Afterward, encrypted `Application Data` packets were transmitted
    between client and broker.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，TLS握手过程，包括其特征性的`ClientHello`和`ServerHello`消息，已经发生。之后，加密的`Application Data`数据包在客户端和代理之间传输。
- en: As shown in [Figure 7-3](ch07.xhtml#ch07fig03), Wireshark also provides the
    details of the TLS negotiation—namely, that the cipher suite `TLS_AES_256_GCM_SHA384`
    was selected for bulk data transmissions. This, in turn, tells us that TLS 1.3
    is used, because that specific cipher suite belongs to the most recent TLS version.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 7-3](ch07.xhtml#ch07fig03)所示，Wireshark还提供了TLS协商的详细信息——即选择了`TLS_AES_256_GCM_SHA384`密码套件用于大数据传输。这也告诉我们使用的是TLS
    1.3，因为该密码套件属于最新的TLS版本。
- en: '![Image](../images/07fig03.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig03.jpg)'
- en: '*Figure 7-3: The details of the TLS handshake*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：TLS握手的详细信息*'
- en: '**WARNING**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Be careful when analyzing the TLS version used in network traffic. The legacy*
    Version *field says it’s* TLS 1.2*, but it’s not.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*在分析网络流量中的TLS版本时要小心。遗留的* Version *字段显示它是* TLS 1.2*，但实际上并非如此。*'
- en: At this point, it seems that functionality and security measures work as expected.
    Let’s use one more tool to finalize our confidence in this work. The SSLyze Python
    application is able to test TLS servers of all kinds regarding a variety of pitfalls
    and misconfigurations that would lower your product’s security if they go unnoticed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，功能和安全措施似乎按预期工作。让我们再使用一个工具来最终确认我们对这项工作的信心。SSLyze Python 应用程序能够测试各种 TLS
    服务器，检查一系列的陷阱和配置错误，如果这些问题被忽视，将会降低产品的安全性。
- en: 'To start the TLS scan, simply enter the hostname and corresponding port: sslyze
    mqtt.iot-device-corp.com:8883.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 TLS 扫描，只需输入主机名和相应的端口：sslyze mqtt.iot-device-corp.com:8883。
- en: The comprehensive results shed light on some interesting details. The extract
    shown in [Listing 7-6](ch07.xhtml#ch07list06) deals with certificate verification.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 综合结果揭示了一些有趣的细节。[列表 7-6](ch07.xhtml#ch07list06)中展示的摘录涉及证书验证。
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-6: The* sslyze *console output regarding certificate verification*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-6：* sslyze *关于证书验证的控制台输出*'
- en: The good news is that I created the certificate correctly, which means that
    I included the correct server name of my device as the common name in the certificate
    ➊. However, many `FAILED` entries ➋ also occur. This happens because my certificate
    is not part of the popular certificate stores from Android, Windows, Mozilla,
    and the like, which was never the plan, but if you aim for broad trust compatibility
    of your certificates, this test might be important for you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我正确创建了证书，这意味着我将设备的正确服务器名称作为证书中的通用名称 ➊。然而，也有许多 `FAILED` 条目 ➋。之所以出现这种情况，是因为我的证书并不属于
    Android、Windows、Mozilla 等常见证书存储库的一部分，这本来不是计划中的事情，但如果你希望证书具有广泛的信任兼容性，那么这个测试对你来说可能很重要。
- en: The main part of the results is about the cipher suites and TLS versions that
    a server accepts. The results in [Listing 7-7](ch07.xhtml#ch07list07) indicate
    that deprecated TLS versions and their corresponding cipher suites are all rejected
    by the implemented MQTT broker as intended. The default settings of `mosquitto`
    already seem to prohibit the use of these old protocols and ciphers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的主要部分是关于服务器接受的加密套件和 TLS 版本的。[列表 7-7](ch07.xhtml#ch07list07)中的结果表明，已弃用的 TLS
    版本及其相应的加密套件都被实现的 MQTT 代理如预期地拒绝。`mosquitto`的默认设置似乎已经禁止了这些旧协议和加密算法的使用。
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-7: The desired rejection of all deprecated cipher suites*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-7：所需拒绝的所有已弃用加密套件*'
- en: As shown in [Listing 7-8](ch07.xhtml#ch07list08), the standard settings of `mosquitto`
    still support TLS 1.2, which is a good thing regarding backward compatibility,
    because many legacy devices in the field don’t support TLS 1.3, but the list of
    supported cipher suites as given by `sslyze` exhibits some weaknesses.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表 7-8](ch07.xhtml#ch07list08)所示，`mosquitto`的默认设置仍然支持 TLS 1.2，这对于向后兼容性是一个好事，因为许多现场的老旧设备不支持
    TLS 1.3，但由 `sslyze` 给出的受支持加密套件列表则展示了一些弱点。
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-8: The offered TLS 1.2 ciphers*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-8：提供的 TLS 1.2 加密算法*'
- en: The output shows that the implementation at hand still offers options that allow
    for RSA-based key exchange (`TLS_RSA_WITH_...`) and others that still use the
    CBC operation mode for AES encryption of application data. Both are not supported
    by TLS 1.3 and are not recommended anymore.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果显示，目前的实现仍提供一些选项，允许基于 RSA 的密钥交换（`TLS_RSA_WITH_...`）和其他仍使用 CBC 操作模式进行 AES
    应用数据加密的选项。这两者都不被 TLS 1.3 支持，也不再推荐使用。
- en: This insight allows us to adjust the *mosquitto.conf* file again by specifying
    the parameter `ciphers`, as shown in [Listing 7-9](ch07.xhtml#ch07list09).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这一见解使我们能够再次调整 *mosquitto.conf* 文件，通过指定 `ciphers` 参数，如[列表 7-9](ch07.xhtml#ch07list09)所示。
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-9: The restriction of TLS 1.2 ciphers in* mosquitto.conf'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-9：mosquitto.conf 中 TLS 1.2 加密算法的限制*'
- en: This restricts the TLS 1.2 ciphers of `mosquitto` to only six modern options
    for RSA-based authentication and three for ECDSA certificates, which means the
    security of the MQTT communication at hand is enhanced one step further.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`mosquitto`的 TLS 1.2 加密算法限制为仅六个现代的 RSA 认证选项和三个 ECDSA 证书选项，这意味着目前的 MQTT 通信安全性进一步提升。
- en: '**NOTE**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Mosquitto relies on OpenSSL for secure TLS communication. Enter* openssl ciphers
    *to list all ciphers offered by OpenSSL on a specific system.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mosquitto 依赖 OpenSSL 来实现安全的 TLS 通信。输入* openssl ciphers *以列出 OpenSSL 在特定系统上提供的所有加密套件。*'
- en: Regarding TLS 1.3, the recommended cipher suites are supported correctly, as
    shown in [Listing 7-10](ch07.xhtml#ch07list010).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 TLS 1.3，推荐的加密套件得到了正确的支持，如[列表 7-10](ch07.xhtml#ch07list010)所示。
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 7-10: TLS 1.3 support is available as intended*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：TLS 1.3 支持按预期可用*'
- en: This is the base for future-proof device communication.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是未来设备通信的基础。
- en: '**Secure Communication Without TLS**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**没有 TLS 的安全通信**'
- en: As mentioned multiple times in this chapter, TLS should be the default solution
    if your device needs to communicate securely. However, not all application scenarios
    and communication technologies allow TLS to be used.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章多次提到的那样，如果你的设备需要进行安全通信，TLS 应该是默认的解决方案。然而，并非所有应用场景和通信技术都允许使用 TLS。
- en: For example, wireless communication for dedicated use cases like sensor or mesh
    networks might rely on proprietary protocols that don’t include a TCP/IP stack.
    Further, some wired bus architectures like the controller area network (CAN) bus
    specify their own message format and data structures without relying on TCP/IP
    technology, and they might require a certain real-time behavior that can’t be
    guaranteed with TLS. Also, very power-constrained devices like battery-powered
    remote control units for alarm systems, garage doors, and industrial cranes often
    use frequencies of 433 and 868 MHz within the license-free industrial, scientific,
    and medical (ISM) radio band, and they optimize message content and lengths for
    energy consumption, which renders a TLS handshake impossible.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像传感器或网状网络这样的专用无线通信可能依赖于不包含 TCP/IP 栈的专有协议。此外，一些有线总线架构，如控制器局域网络（CAN）总线，定义了自己的消息格式和数据结构，而不依赖于
    TCP/IP 技术，并且可能需要某些实时行为，而 TLS 无法保证这些实时需求。而且，一些电池供电的设备，如用于报警系统、车库门和工业起重机的遥控器，通常使用
    433 和 868 MHz 的频率，这些频率位于免许可证的工业、科学和医疗（ISM）无线电频段内，它们优化消息内容和长度以减少能耗，从而使 TLS 握手变得不可能。
- en: However, it would be naive to conclude that these applications have to live
    without security measures because TLS doesn’t fit. The issue just requires a different
    development approach. For those cases, usually no out-of-the-box solution exists,
    but custom, application-specific security protocols have to be developed. Of course,
    having extensive experience in cryptography, protocol design, and verification
    of such systems would be useful, but, in reality, that’s rarely the case.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，得出这些应用程序必须在没有安全措施的情况下运行，因为 TLS 不适用，这种结论是天真的。这个问题仅需要一种不同的开发方法。对于这些情况，通常没有现成的解决方案，但必须开发定制的、特定应用的安全协议。当然，拥有丰富的密码学、协议设计和此类系统验证经验将非常有帮助，但实际上，情况往往并非如此。
- en: A pragmatic approach could be to regard TLS 1.3 and the cryptographic primitives
    it uses as a self-service store. If you’re looking for specific protection measures
    (for example, to protect authenticity and integrity of commands sent by your remote
    control), digital signatures based on RSA or ECDSA would be a reliable solution.
    Whether you decide to work with certificates, as TLS does, or manage the raw public
    keys yourself depends on your requirements and possibilities.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一种务实的方法是将 TLS 1.3 及其使用的密码学原语视为自助服务商店。如果你需要特定的保护措施（例如，保护遥控器发送的命令的真实性和完整性），基于
    RSA 或 ECDSA 的数字签名将是可靠的解决方案。你是否决定像 TLS 那样使用证书，还是自己管理原始公钥，取决于你的需求和可能性。
- en: Also, if your CAN bus traffic contains confidential messages, and integrity
    is also on your wish list, AES-GCM or ChaCha20-Poly1305 might be suitable candidates.
    If your scenario allows for management and distribution of pre-shared secrets,
    you can spare the costly key-exchange algorithms. If not, DHE or ECDHE, as used
    by TLS 1.3, might be the algorithms of your choice.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你的 CAN 总线流量包含机密消息，并且完整性也是你的需求之一，AES-GCM 或 ChaCha20-Poly1305 可能是合适的候选算法。如果你的场景允许管理和分发预共享密钥，你可以避免昂贵的密钥交换算法。如果不行，那么像
    TLS 1.3 使用的 DHE 或 ECDHE 可能是你选择的算法。
- en: This sounds rather shallow and, to some extent it is, because you have to clarify
    hundreds of details on the way to your specific implementation. However, this
    information gives you some guidance as to where your journey needs to go.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来这似乎有些肤浅，某种程度上确实如此，因为在实现特定方案的过程中，你需要澄清数百个细节。然而，这些信息为你指明了前进的方向。
- en: '**Redundancy in Secure Communication**'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安全通信中的冗余**'
- en: 'If you’ve made it to this point, you’ve read a lot about how secure communication
    can be achieved by using TLS and its magical crypto features to protect confidentiality
    and integrity of messages as well as authenticity of communication partners. However,
    at the beginning of this chapter, I said that communication demands all the protection
    goals, including availability. But to be clear: TLS and cryptography in general
    are *not able to protect availability*.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经读到这里，你已经了解了许多关于如何通过使用TLS及其神奇的加密特性来保护消息的机密性和完整性，以及通信伙伴的真实性。然而，在本章开头，我提到过通信要求所有保护目标，包括可用性。但明确来说：TLS和一般的加密技术*无法保护可用性*。
- en: Of course, in some use cases, the availability of transmitted data is essential—for
    example, in domains where technical safety measures protect humans from accidents
    and injuries, but also in systems where downtime leads to significant financial
    losses, as in production or transportation. In those applications, if a message
    is lost, the correct functionality of a device or a whole system is at risk. These
    threats have to be handled by *logical or physical redundancy*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在某些应用场景中，传输数据的可用性至关重要——例如，在技术安全措施保护人类免受事故和伤害的领域，也包括那些系统中，停机时间会导致显著的财务损失，如生产或运输领域。在这些应用中，如果消息丢失，设备或整个系统的正常功能就会受到威胁。这些威胁必须通过*逻辑或物理冗余*来处理。
- en: Approaching this problem on a logical level means sending messages multiple
    times or adding redundancy data generated by error-detecting codes like CRC checksums
    or error-correcting algorithms like Hamming codes. This is useful for transmissions
    over noisy or unreliable channels and to handle disturbance events originating,
    for example, from electromagnetic interference or cosmic radiation. However, these
    measures don’t offer adequate protection against deliberate destruction and continuous
    interruption of a physical communication line.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑层面处理这个问题意味着多次发送消息或添加由错误检测代码（如CRC校验和）生成的冗余数据，或像汉明码这样的纠错算法。这对于在嘈杂或不可靠的信道上传输数据，以及处理由电磁干扰或宇宙辐射等引起的干扰事件非常有用。然而，这些措施并不能提供足够的保护，以防止故意破坏和持续中断物理通信线路。
- en: The only way to be resilient in such situations is to implement multiple physical
    communication channels. A common example is a *ring topology*, used in many industrial
    infrastructures to connect devices to one another in a ring-like structure. However,
    that configuration requires devices to have two network interfaces, left and right,
    and messages always have to be sent in both directions and can be received on
    two different interfaces.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，唯一能保持韧性的方法就是实施多个物理通信通道。一个常见的例子是*环形拓扑*，它在许多工业基础设施中用于将设备连接成一个环状结构。然而，这种配置要求设备必须具有两个网络接口，左侧和右侧，并且消息必须始终双向发送，并能在两个不同的接口上接收。
- en: This leads to engineering and component efforts on each device, and the system
    installation as a whole becomes more expensive. In addition, the communication
    delay depends on the number of devices in the ring, and the bandwidth has to be
    shared among all network participants. However, this physical redundancy is robust
    against corrupted messages, broken or cut cables, and even device replacement
    during system operation. The international standard IEC 62439 describes several
    ways to achieve high availability in industrial networks, for example, based on
    a ring or a mesh topology.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要在每个设备上进行工程和组件工作，整个系统的安装成本也变得更高。此外，通信延迟取决于环中的设备数量，并且带宽需要在所有网络参与者之间共享。然而，这种物理冗余对于损坏的消息、断裂或被切断的电缆，甚至在系统运行期间更换设备，都是非常坚固的。国际标准IEC
    62439描述了实现工业网络高可用性的几种方法，例如，基于环形或网状拓扑结构。
- en: '**Summary**'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The IoT and its industrial counterpart are not possible without secure communication.
    A variety of protection goals from confidentiality to integrity to authenticity,
    and even availability, are demanded for modern communication channels. Besides
    the necessary cryptographic capabilities, devices need to support state-of-the-art
    protocols like TLS 1.3 to achieve a high security level. In some use cases, where
    the loss of messages is critical and redundant physical communication media are
    required, devices even have to provide multiple communication interfaces.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网及其工业对应物如果没有安全的通信，是无法实现的。现代通信通道需要满足从保密性、完整性、真实性，甚至可用性等各种保护目标。除了必要的密码学能力，设备还需要支持如TLS
    1.3等先进的协议，以实现高安全级别。在一些应用场景中，当消息丢失至关重要且需要冗余物理通信介质时，设备甚至需要提供多个通信接口。
- en: This chapter’s case study showed an example implementation of a MQTT-broker
    with TLS-based communication and the necessary configuration parameters. It showed
    that thorough security analysis of the final result can help spot misconfigurations
    and weak cipher suites offered by a service.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究展示了一个基于TLS通信的MQTT代理实现示例，并给出了必要的配置参数。它表明，对最终结果进行彻底的安全分析有助于发现服务中的配置错误和弱加密套件。
- en: Although TLS is one of the most common and most popular security protocols,
    many others exist that are meant for dedicated applications. For example, Internet
    Protocol security (IPsec) can be used to establish a virtual private network (VPN)
    on OSI layer 3, while the SSH protocol enables remote access to devices for administrators.
    On OSI layer 2, the idea of Time-Sensitive Networking (TSN) takes care of communication
    channel separation on a shared physical medium, while IEEE 802.1AE (also known
    as *MACsec*) aims for protected communication.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然TLS是最常见和最流行的安全协议，但还有许多其他协议是为特定应用设计的。例如，Internet协议安全（IPsec）可用于在OSI第3层建立虚拟专用网络（VPN），而SSH协议则使管理员能够远程访问设备。在OSI第2层，时间敏感网络（TSN）的概念负责在共享物理介质上进行通信通道的分隔，而IEEE
    802.1AE（也称为*MACsec*）则致力于保护通信安全。
- en: And even if you don’t find any protocol that directly suits your needs, the
    conglomeration of modern security protocols can definitely serve as inspiration
    for solving your specific challenges.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有找到完全符合需求的协议，现代安全协议的融合也绝对可以为解决你的具体挑战提供灵感。
