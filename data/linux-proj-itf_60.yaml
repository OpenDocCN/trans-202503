- en: 'Chapter 60. Sockets: Server Design'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第60章. 套接字：服务器设计
- en: This chapter discusses the fundamentals of designing iterative and concurrent
    servers and describes *inetd*, a special daemon designed to facilitate the creation
    of Internet servers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了设计迭代型和并发型服务器的基本原理，并描述了 *inetd*，这是一个专门的守护进程，用于简化互联网服务器的创建。
- en: Iterative and Concurrent Servers
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代型和并发型服务器
- en: 'Two common designs for network servers using sockets are the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用套接字设计网络服务器的两种常见方式如下：
- en: '*Iterative*: The server handles one client at a time, processing that client’s
    request(s) completely, before proceeding to the next client.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代*：服务器一次处理一个客户端，完全处理该客户端的请求后，再处理下一个客户端。'
- en: '*Concurrent*: The server is designed to handle multiple clients simultaneously.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并发*：服务器设计用于同时处理多个客户端请求。'
- en: We have already seen an example of an iterative server using FIFOs in [A Client-Server
    Application Using FIFOs](ch44.html#a_client-server_application_using_fifos "A
    Client-Server Application Using FIFOs") and an example of a concurrent server
    using System V message queues in Section 46.8.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [使用 FIFO 的客户端-服务器应用](ch44.html#a_client-server_application_using_fifos
    "使用 FIFO 的客户端-服务器应用") 中看到了一个使用 FIFO 的迭代型服务器示例，并在第 46.8 节中看到了一个使用 System V 消息队列的并发型服务器示例。
- en: Iterative servers are usually suitable only when client requests can be handled
    quickly, since each client must wait until all of the preceding clients have been
    serviced. A typical scenario for employing an iterative server is where the client
    and server exchange a single request and response.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代型服务器通常只适用于那些客户端请求可以快速处理的场景，因为每个客户端必须等待所有前面的客户端请求处理完毕后才能被服务。使用迭代型服务器的典型场景是客户端和服务器之间交换单个请求和响应。
- en: 'Concurrent servers are suitable when a significant amount of processing time
    is required to handle each request, or where the client and server engage in an
    extended conversation, passing messages back and forth. In this chapter, we mainly
    focus on the traditional (and simplest) method of designing a concurrent server:
    creating a new child process for each new client. Each server child performs all
    tasks necessary to service a single client and then terminates. Since each of
    these processes can operate independently, multiple clients can be handled simultaneously.
    The principal task of the main server process (the parent) is to create a new
    child process for each new client. (A variation on this approach is to create
    a new thread for each client.)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 并发型服务器适用于需要较长处理时间来处理每个请求，或者客户端和服务器进行长时间的交互，不断交换消息的场景。在本章中，我们主要关注设计并发型服务器的传统方法（也是最简单的）：为每个新客户端创建一个新的子进程。每个服务器子进程执行所有必要的任务来服务单个客户端，然后终止。由于这些进程可以独立运行，因此可以同时处理多个客户端。主服务器进程（父进程）的主要任务是为每个新客户端创建一个新的子进程。（这种方法的变体是为每个客户端创建一个新的线程。）
- en: In the following sections, we look at examples of an iterative and a concurrent
    server using Internet domain sockets. These two servers implement the *echo* service
    (RFC 862), a rudimentary service that returns a copy of whatever the client sends
    it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将展示使用互联网域套接字的迭代型和并发型服务器示例。这两个服务器实现了 *回显* 服务（RFC 862），这是一个基本服务，返回客户端发送的任何内容的副本。
- en: An Iterative UDP *echo* Server
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个迭代的 UDP *回显* 服务器
- en: In this and the next section, we present servers for the *echo* service. The
    *echo* service operates on both UDP and TCP port 7. (Since this is a reserved
    port, the *echo* server must be run with superuser privileges.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和下一节中，我们将介绍 *回显* 服务的服务器。*回显* 服务在 UDP 和 TCP 端口 7 上运行。（由于这是一个保留端口，*回显* 服务器必须以超级用户权限运行。）
- en: The UDP *echo* server continuously reads datagrams, returning a copy of each
    datagram to the sender. Since the server needs to handle only a single message
    at a time, an iterative server design suffices. The header file for the server
    is shown in [Example 60-1](ch60.html#header_file_for_id_underscore_echo_under
    "Example 60-1. Header file for id_echo_sv.c and id_echo_cl.c").
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: UDP *回显* 服务器持续读取数据报，并将每个数据报的副本返回给发送者。由于服务器一次只需要处理一个消息，迭代型服务器设计足够满足需求。服务器的头文件如
    [示例 60-1](ch60.html#header_file_for_id_underscore_echo_under "示例 60-1. `id_echo_sv.c`
    和 `id_echo_cl.c` 的头文件") 所示。
- en: Example 60-1. Header file for `id_echo_sv.c` and `id_echo_cl.c`
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 60-1. `id_echo_sv.c` 和 `id_echo_cl.c` 的头文件
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 60-2](ch60.html#an_iterative_server_that_implements_the "Example 60-2. An
    iterative server that implements the UDP echo service") shows the implementation
    of the server. Note the following points regarding the server implementation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例60-2](ch60.html#an_iterative_server_that_implements_the "Example 60-2. An
    iterative server that implements the UDP echo service")展示了服务器的实现。请注意以下几点关于服务器实现的内容：'
- en: We use the *becomeDaemon()* function of [Creating a Daemon](ch37.html#creating_a_daemon
    "Creating a Daemon") to turn the server into a daemon.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用[创建守护进程](ch37.html#creating_a_daemon "Creating a Daemon")中的*becomeDaemon()*函数将服务器转变为守护进程。
- en: To shorten this program, we employ the Internet domain sockets library developed
    in [An Internet Domain Sockets Library](ch59.html#an_internet_domain_sockets_library
    "An Internet Domain Sockets Library").
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化该程序，我们采用了在[互联网域套接字库](ch59.html#an_internet_domain_sockets_library "An Internet
    Domain Sockets Library")中开发的互联网域套接字库。
- en: If the server can’t send a reply to the client, it logs a message using *syslog()*.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务器无法向客户端发送回复，它会使用*syslog()*记录一条消息。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a real-world application, we would probably apply some rate limit to the
    messages written with *syslog()*, both to prevent the possibility of an attacker
    filling the system log and because each call to *syslog()* is expensive, since
    (by default) *syslog()* in turn calls *fsync()*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们可能会对使用*syslog()*写入的消息应用一些速率限制，既是为了防止攻击者填满系统日志，也是因为每次调用*syslog()*都比较昂贵，因为（默认情况下）*syslog()*又会调用*fsync()*。
- en: Example 60-2. An iterative server that implements the UDP *echo* service
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 示例60-2。实现UDP *echo*服务的迭代服务器
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To test the server, we use the client program shown in [Example 60-3](ch60.html#a_client_for_the_udp_echo_service
    "Example 60-3. A client for the UDP echo service"). This program also employs
    the Internet domain sockets library developed in [An Internet Domain Sockets Library](ch59.html#an_internet_domain_sockets_library
    "An Internet Domain Sockets Library"). As its first command-line argument, the
    client program expects the name of the host on which the server resides. The client
    executes a loop in which it sends each of its remaining command-line arguments
    to the server as separate datagrams, and reads and prints each response datagram
    sent back by the server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试服务器，我们使用[示例60-3](ch60.html#a_client_for_the_udp_echo_service "Example 60-3. A
    client for the UDP echo service")中显示的客户端程序。该程序也使用了在[互联网域套接字库](ch59.html#an_internet_domain_sockets_library
    "An Internet Domain Sockets Library")中开发的互联网域套接字库。作为第一个命令行参数，客户端程序期望接收到服务器所在主机的名称。客户端会执行一个循环，将剩余的每个命令行参数作为独立的数据报发送给服务器，并读取并打印每个由服务器返回的响应数据报。
- en: Example 60-3. A client for the UDP *echo* service
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 示例60-3。UDP *echo*服务的客户端
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is an example of what we see when we run the server and two instances
    of the client:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们运行服务器和两个客户端实例时看到的例子：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A Concurrent TCP *echo* Server
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个并发的TCP *echo*服务器
- en: The TCP *echo* service also operates on port 7\. The TCP *echo* server accepts
    a connection and then loops continuously, reading all transmitted data and sending
    it back to the client on the same socket. The server continues reading until it
    detects end-of-file, at which point it closes its socket (so that the client sees
    end-of-file if it is still reading from its socket).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TCP *echo*服务也运行在7端口。TCP *echo*服务器接受一个连接后，开始持续循环，读取所有传输的数据并通过同一套接字将其返回给客户端。服务器继续读取直到检测到文件结束，此时会关闭其套接字（这样客户端如果仍在从套接字读取，会看到文件结束）。
- en: 'Since the client may send an indefinite amount of data to the server (and thus
    servicing the client may take an indefinite amount of time), a concurrent server
    design is appropriate, so that multiple clients can be simultaneously served.
    The server implementation is shown in [Example 60-4](ch60.html#a_concurrent_server_that_implements_the
    "Example 60-4. A concurrent server that implements the TCP echo service"). (We
    show an implementation of a client for this service in Section 61.2.) Note the
    following points about the implementation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端可能会向服务器发送无限量的数据（因此为客户端提供服务可能需要无限时间），因此并发服务器设计是合适的，以便多个客户端可以同时得到服务。服务器的实现见[示例60-4](ch60.html#a_concurrent_server_that_implements_the
    "Example 60-4. A concurrent server that implements the TCP echo service")。我们将在第61.2节中展示该服务的客户端实现。关于该实现，请注意以下几点：
- en: The server becomes a daemon by calling the *becomeDaemon()* function shown in
    Section 37.2.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器通过调用第37.2节中显示的*becomeDaemon()*函数成为一个守护进程。
- en: To shorten this program, we employ the Internet domain sockets library shown
    in [Example 59-9](ch59.html#an_internet_domain_sockets_librar "Example 59-9. An
    Internet domain sockets library") (page 1228).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化程序，我们使用了在[示例 59-9](ch59.html#an_internet_domain_sockets_librar "Example
    59-9. An Internet domain sockets library")（第1228页）中展示的互联网域套接字库。
- en: Since the server creates a child process for each client connection, we must
    ensure that zombies are reaped. We do this within a `SIGCHLD` handler.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务器为每个客户端连接创建一个子进程，因此我们必须确保僵尸进程得到回收。我们在 `SIGCHLD` 处理程序中执行这项操作。
- en: The main body of the server consists of a `for` loop that accepts a client connection
    and then uses *fork()* to create a child process that invokes the *handleRequest()*
    function to handle that client. In the meantime, the parent continues around the
    `for` loop to accept the next client connection.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器的主体部分由一个 `for` 循环组成，该循环接受客户端连接，然后使用 *fork()* 创建一个子进程，子进程调用 *handleRequest()*
    函数来处理该客户端。同时，父进程继续执行 `for` 循环，接受下一个客户端连接。
- en: Note
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a real-world application, we would probably include some code in our server
    to place an upper limit on the number of child processes that the server could
    create, in order to prevent an attacker from attempting a remote fork bomb by
    using the service to create so many processes on the system that it becomes unusable.
    We could impose this limit by adding extra code in the server to count the number
    of children currently executing (this count would be incremented after a successful
    *fork()* and decremented as each child was reaped in the `SIGCHLD` handler). If
    the limit on the number of children were reached, we could then temporarily stop
    accepting connections (or alternatively, accept connections and then immediately
    close them).
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实际应用中，我们可能会在服务器中包含一些代码，限制服务器能够创建的子进程数量，以防止攻击者通过使用该服务创建大量进程，从而使系统变得无法使用，类似于远程
    fork bomb 攻击。我们可以通过在服务器中添加额外的代码，来统计当前正在执行的子进程数量（每次成功调用 *fork()* 后该数量递增，每次子进程被回收时在
    `SIGCHLD` 处理程序中递减）。如果子进程数量达到了上限，我们可以暂时停止接受连接（或者，接受连接后立即关闭它们）。
- en: After each *fork()*, the file descriptors for the listening and connected sockets
    are duplicated in the child ([File Sharing Between Parent and Child](ch24.html#file_sharing_between_parent_and_child
    "File Sharing Between Parent and Child")). This means that both the parent and
    the child could communicate with the client using the connected socket. However,
    only the child needs to perform such communication, and so the parent closes the
    file descriptor for the connected socket immediately after the *fork()*. (If the
    parent did not do this, then the socket would never actually be closed; furthermore,
    the parent would eventually run out of file descriptors.) Since the child doesn’t
    accept new connections, it closes its duplicate of the file descriptor for the
    listening socket.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次调用 *fork()* 后，监听和连接套接字的文件描述符会在子进程中被复制（参见[父子进程间的文件共享](ch24.html#file_sharing_between_parent_and_child
    "File Sharing Between Parent and Child")）。这意味着父进程和子进程都可以使用连接的套接字与客户端进行通信。然而，只有子进程需要执行这样的通信，因此父进程在
    *fork()* 后会立即关闭连接套接字的文件描述符。（如果父进程不这样做，套接字将永远不会被关闭；此外，父进程最终会耗尽文件描述符。）由于子进程不接受新的连接，它会关闭它所复制的监听套接字的文件描述符。
- en: Each child process terminates after handling a single client.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个子进程在处理完单个客户端后终止。
- en: Example 60-4. A concurrent server that implements the TCP *echo* service
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 60-4. 实现 TCP *回显* 服务的并发服务器
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Other Concurrent Server Designs
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他并发服务器设计
- en: The traditional concurrent server model described in the previous section is
    adequate for many applications that need to simultaneously handle multiple clients
    via TCP connections. However, for very high-load servers (for example, web servers
    handling thousands of requests per minute), the cost of creating a new child (or
    even thread) for each client imposes a significant burden on the server (refer
    to [Speed of Process Creation](ch28.html#speed_of_process_creation "Speed of Process
    Creation")), and alternative designs need to be employed. We briefly consider
    some of these alternatives.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面章节中描述的传统并发服务器模型适用于许多需要通过 TCP 连接同时处理多个客户端的应用程序。然而，对于高负载的服务器（例如，每分钟处理成千上万请求的
    Web 服务器），为每个客户端创建一个新的子进程（甚至是线程）会给服务器带来显著的负担（参见[进程创建速度](ch28.html#speed_of_process_creation
    "Speed of Process Creation")），因此需要采用替代设计。我们简要考虑一下这些替代方案。
- en: Preforked and prethreaded servers
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 预派生和预线程化的服务器
- en: 'Preforked and prethreaded servers are described in some detail in [Chapter 30](ch30.html
    "Chapter 30. Threads: Thread Synchronization") of [Stevens et al., 2004]. The
    key ideas are the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 预创建的进程和线程服务器在[第30章](ch30.html "第30章。线程：线程同步")中有一些详细描述，出自[Stevens 等人，2004年]。关键思想如下：
- en: Instead of creating a new child process (or thread) for each client, the server
    precreates a fixed number of child processes (or threads) immediately on startup
    (i.e., before any client requests are even received). These children constitute
    a so-called *server pool*.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器不会为每个客户端创建新的子进程（或线程），而是在启动时预先创建固定数量的子进程（或线程）（即，在接收到任何客户端请求之前）。这些子进程构成了所谓的*服务器池*。
- en: Each child in the server pool handles one client at a time, but instead of terminating
    after handling the client, the child fetches the next client to be serviced and
    services it, and so on.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器池中的每个子进程一次处理一个客户端，但在处理完客户端后，子进程不会终止，而是获取下一个需要服务的客户端，并继续服务，依此类推。
- en: Employing the above technique requires some careful management within the server
    application. The server pool should be large enough to ensure adequate response
    to client requests. This means that the server parent must monitor the number
    of unoccupied children, and, in times of peak load, increase the size of the pool
    so that there are always enough child processes available to immediately serve
    new clients. If the load decreases, then the size of the server pool should be
    reduced, since having excess processes on the system can degrade overall system
    performance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述技术需要在服务器应用程序中进行一些细致的管理。服务器池应该足够大，以确保能够响应客户端请求。这意味着服务器父进程必须监控空闲子进程的数量，并在高峰负载时增加池的大小，以便始终有足够的子进程可以立即服务新的客户端。如果负载减少，服务器池的大小应减少，因为系统中存在过多的进程会降低整体系统性能。
- en: In addition, the children in the server pool must follow some protocol to allow
    them to exclusively select individual client connections. On most UNIX implementations
    (including Linux), it is sufficient to have each child in the pool block in an
    *accept()* call on the listening descriptor. In other words, the server parent
    creates the listening socket before creating any children, and each of the children
    inherits a file descriptor for the socket during the *fork()*. When a new client
    connection arrives, only one of the children will complete the *accept()* call.
    However, because *accept()* is not an atomic system call on some older implementations,
    the call may need to be bracketed by some mutual-exclusion technique (e.g., a
    file lock) to ensure that only one child at a time performs the call ([Stevens
    et al., 2004]).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，服务器池中的子进程必须遵循某些协议，以便它们能够独占地选择各个客户端连接。在大多数UNIX实现（包括Linux）中，足以让每个子进程在监听描述符上阻塞在*accept()*调用中。换句话说，服务器父进程在创建任何子进程之前，首先创建监听套接字，而每个子进程在*fork()*时会继承该套接字的文件描述符。当一个新的客户端连接到达时，只有一个子进程会完成*accept()*调用。然而，由于在某些旧的实现中，*accept()*并不是一个原子系统调用，因此该调用可能需要通过一些互斥技术（例如，文件锁）来确保只有一个子进程在同一时刻执行该调用（[Stevens
    等人，2004年]）。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are alternatives to having all of the children in the server pool perform
    *accept()* calls. If the server pool consists of separate processes, the server
    parent can perform the *accept()* call, and then pass the file descriptor containing
    the new connection to one of the free processes in the pool, using a technique
    that we briefly describe in [Passing File Descriptors](ch61.html#passing_file_descriptors
    "Passing File Descriptors"). If the server pool consists of threads, the main
    thread can perform the *accept()* call, and then inform one of the free server
    threads that a new client is available on the connected descriptor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些替代方法，避免让服务器池中的所有子进程执行*accept()*调用。如果服务器池由独立的进程组成，服务器父进程可以执行*accept()*调用，然后将包含新连接的文件描述符传递给池中一个空闲的进程，使用我们在[传递文件描述符](ch61.html#passing_file_descriptors
    "传递文件描述符")中简要描述的技术。如果服务器池由线程组成，主线程可以执行*accept()*调用，然后通知一个空闲的服务器线程，新客户端已连接到该描述符。
- en: Handling multiple clients from a single process
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理来自单个进程的多个客户端
- en: In some cases, we can design a single server process to handle multiple clients.
    To do this, we must employ one of the I/O models (I/O multiplexing, signal-driven
    I/O, or *epoll*) that allow a single process to simultaneously monitor multiple
    file descriptors for I/O events. These models are described in [Chapter 63](ch63.html
    "Chapter 63. Alternative I/O Models").
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以设计一个单一服务器进程来处理多个客户端。为此，我们必须采用其中一种I/O模型（I/O复用、信号驱动I/O或*epoll*），这些模型允许单个进程同时监控多个文件描述符上的I/O事件。这些模型在[第63章](ch63.html
    "Chapter 63. Alternative I/O Models")中有所描述。
- en: In a single-server design, the server process must take on some of the scheduling
    tasks that are normally handled by the kernel. In a solution that involves one
    server process per client, we can rely on the kernel to ensure that each server
    process (and thus client) gets a fair share of access to the resources of the
    server host. But when we use a single server process to handle multiple clients,
    the server must do some work to ensure that one or a few clients don’t monopolize
    access to the server while other clients are starved. We say a little more about
    this point in [Edge-Triggered Notification](ch63.html#edge-triggered_notification
    "Edge-Triggered Notification").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一服务器设计中，服务器进程必须承担一些通常由内核处理的调度任务。在每个客户端都有一个服务器进程的解决方案中，我们可以依赖内核来确保每个服务器进程（因此也包括每个客户端）能够公平地访问服务器主机的资源。但当我们使用单一服务器进程来处理多个客户端时，服务器必须做一些工作，确保一个或少数客户端不会垄断对服务器的访问，导致其他客户端无法获得资源。我们将在[边缘触发通知](ch63.html#edge-triggered_notification
    "Edge-Triggered Notification")中对此做进一步讨论。
- en: Using server farms
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用服务器集群
- en: Other approaches to handling high client loads involve the use of multiple server
    systems—a *server farm*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 处理高客户端负载的其他方法涉及使用多个服务器系统——即*服务器集群*。
- en: One of the simplest approaches to building a server farm (employed by some web
    servers) is *DNS round-robin load sharing* (or *load distribution*), where the
    authoritative name server for a zone maps the same domain name to several IP addresses
    (i.e., several servers share the same domain name). Successive requests to the
    DNS server to resolve the domain name return these IP addresses in round-robin
    order. Further information about DNS round-robin load sharing can be found in
    [Albitz & Liu, 2006].
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 构建服务器集群的最简单方法之一（某些Web服务器采用）是*DNS轮询负载共享*（或*负载分配*），在这种方式中，区域的权威名称服务器将相同的域名映射到多个IP地址（即，多个服务器共享同一个域名）。连续的DNS请求返回这些IP地址，并按轮询顺序进行。关于DNS轮询负载共享的更多信息可以在[Albitz
    & Liu, 2006]中找到。
- en: Round-robin DNS has the advantage of being inexpensive and easy to set up. However,
    it does have some shortcomings. A DNS server performing iterative resolution may
    cache its results (see [Domain Name System (DNS)](ch59.html#domain_name_system_open_parenthesis_dns
    "Domain Name System (DNS)")), with the result that future queries on the domain
    name return the same IP address, instead of the round-robin sequence generated
    by the authoritative DNS server. Also, round-robin DNS doesn’t have any built-in
    mechanisms for ensuring good load balancing (different clients may place different
    loads on a server) or ensuring high availability (what if one of the servers dies
    or the server application that it is running crashes?). Another issue that we
    may need to consider—one that is faced by many designs that employ multiple server
    machines—is ensuring *server affinity*; that is, ensuring that a sequence of requests
    from the same client are all directed to the same server, so that any state information
    maintained by the server about the client remains accurate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询DNS的优点是成本低，且易于设置。然而，它也有一些缺点。一个执行迭代解析的DNS服务器可能会缓存其结果（参见[域名系统（DNS）](ch59.html#domain_name_system_open_parenthesis_dns
    "Domain Name System (DNS)")），导致未来对该域名的查询返回相同的IP地址，而不是权威DNS服务器生成的轮询顺序。此外，轮询DNS没有内建机制来确保良好的负载均衡（不同客户端可能会对服务器施加不同负载）或确保高可用性（如果某个服务器死掉或它运行的服务器应用崩溃怎么办？）。另一个我们可能需要考虑的问题——这是许多采用多个服务器机器的设计面临的挑战——是确保*服务器亲和性*；也就是说，确保来自同一客户端的一系列请求都指向同一台服务器，这样服务器维护的关于该客户端的状态信息才能保持准确。
- en: A more flexible, but also more complex, solution is *server load balancing*.
    In this scenario, a single load-balancing server routes incoming client requests
    to one of the members of the server farm. (To ensure high availability, there
    may be a backup server that takes over if the primary load-balancing server crashes.)
    This eliminates the problems associated with remote DNS caching, since the server
    farm presents a single IP address (that of the load-balancing server) to the outside
    world. The load-balancing server incorporates algorithms to measure or estimate
    server load (perhaps based on metrics supplied by the members of the server farm)
    and intelligently distribute the load across the members of the server farm. The
    load-balancing server also automatically detects failures in members of the server
    farm (and the addition of new servers, if demand requires it). Finally, a load-balancing
    server may also provide support for server affinity. Further information about
    server load balancing can be found in [Kopparapu, 2002].
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更灵活但也更复杂的解决方案是*服务器负载均衡*。在这种情况下，一个负载均衡服务器将传入的客户端请求路由到服务器农场中的某个成员。（为了确保高可用性，可能会有一个备用服务器，在主要负载均衡服务器崩溃时接管。）这消除了与远程DNS缓存相关的问题，因为服务器农场向外界呈现的是单一的IP地址（即负载均衡服务器的地址）。负载均衡服务器采用算法来测量或估计服务器负载（可能基于服务器农场成员提供的度量标准），并智能地将负载分配到服务器农场的各个成员。负载均衡服务器还会自动检测服务器农场成员的故障（以及如果需求增加时，添加新服务器）。最后，负载均衡服务器还可能支持服务器亲和性。有关服务器负载均衡的更多信息，请参阅[Kopparapu,
    2002]。
- en: The *inetd* (Internet Superserver) Daemon
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*inetd*（Internet Superserver）守护进程'
- en: If we look through the contents of `/etc/services`, we see literally hundreds
    of different services listed. This implies that a system could theoretically be
    running a large number of server processes. However, most of these servers would
    usually be doing nothing but waiting for infrequent connection requests or datagrams.
    All of these server processes would nevertheless occupy slots in the kernel process
    table, and consume some memory and swap space, thus placing a load on the system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`/etc/services`的内容，会看到字面上列出了数百个不同的服务。这意味着一个系统理论上可以运行大量的服务器进程。然而，这些服务器大多数情况下通常什么也不做，只是在等待偶尔的连接请求或数据报文。尽管如此，这些服务器进程仍然会占用内核进程表中的插槽，并消耗一定的内存和交换空间，从而给系统带来负担。
- en: 'The *inetd* daemon is designed to eliminate the need to run large numbers of
    infrequently used servers. Using *inetd* provides two main benefits:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*inetd*守护进程旨在消除运行大量不常用的服务器的需求。使用*inetd*提供了两个主要的好处：'
- en: Instead of running a separate daemon for each service, a single process—the
    *inetd* daemon—monitors a specified set of socket ports and starts other servers
    as required. Thus, the number of processes running on the system is reduced.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其为每个服务运行单独的守护进程，不如让一个单独的进程——*inetd*守护进程——监控一组指定的套接字端口，并根据需要启动其他服务器。这样，系统上运行的进程数量得以减少。
- en: The programming of the servers started by *inetd* is simplified, because *inetd*
    performs several of the steps that are commonly required by all network servers
    on startup.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于*inetd*执行了启动时所有网络服务器通常需要的几个步骤，因此它简化了由*inetd*启动的服务器的编程。
- en: Since it oversees a range of services, invoking other servers as required, *inetd*
    is sometimes known as the *Internet superserver*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它管理一系列服务，根据需要调用其他服务器，*inetd*有时被称为*互联网超级服务器*。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An extended version of *inetd*, *xinetd*, is provided in some Linux distributions.
    Among other things, *xinetd* adds a number of security enhancements. Information
    about *xinetd* can be found at [http://www.xinetd.org/](http://www.xinetd.org/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Linux发行版中提供了*inetd*的扩展版本——*xinetd*。*xinetd*增加了许多安全增强功能。有关*xinetd*的信息可以在[http://www.xinetd.org/](http://www.xinetd.org/)找到。
- en: Operation of the *inetd* daemon
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*inetd*守护进程的操作'
- en: 'The *inetd* daemon is normally started during system boot. After becoming a
    daemon process ([Creating a Daemon](ch37.html#creating_a_daemon "Creating a Daemon")),
    *inetd* performs the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*inetd*守护进程通常在系统启动时启动。在成为守护进程后（[创建守护进程](ch37.html#creating_a_daemon "Creating
    a Daemon")），*inetd*执行以下步骤：'
- en: For each of the services specified in its configuration file, `/etc/inetd.conf`,
    *inetd* creates a socket of the appropriate type (i.e., stream or datagram) and
    binds it to the specified port. Each TCP socket is additionally marked to permit
    incoming connections via a call to *listen()*.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其配置文件中指定的每个服务，`/etc/inetd.conf` 中的 *inetd* 会创建一个适当类型的套接字（即流套接字或数据报套接字），并将其绑定到指定的端口。每个
    TCP 套接字还会被标记为允许通过 *listen()* 调用接收传入连接。
- en: Using the *select()* system call ([The *select()* System Call](ch63.html#the_select_open_parenthesis_close_parent
    "The select() System Call")), *inetd* monitors all of the sockets created in the
    preceding step for datagrams or incoming connection requests.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *select()* 系统调用（[*select()* 系统调用](ch63.html#the_select_open_parenthesis_close_parent
    "select() 系统调用")），*inetd* 监控在前一步中创建的所有套接字，等待数据报或传入的连接请求。
- en: The *select()* call blocks until either a UDP socket has a datagram available
    to read or a connection request is received on a TCP socket. In the case of a
    TCP connection, *inetd* performs an *accept()* for the connection before proceeding
    to the next step.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*select()* 调用会阻塞，直到一个 UDP 套接字有可读的数据报，或一个连接请求在 TCP 套接字上接收到。在 TCP 连接的情况下，*inetd*
    在继续执行下一步之前会执行 *accept()* 来接受该连接。'
- en: 'To start the server specified for this socket, *inetd()* calls *fork()* to
    create a new process that then does an *exec()* to start the server program. Before
    performing the *exec()*, the child process performs the following steps:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了启动为此套接字指定的服务器，*inetd()* 调用 *fork()* 创建一个新进程，然后执行 *exec()* 启动服务器程序。在执行 *exec()*
    之前，子进程执行以下步骤：
- en: Close all of the file descriptors inherited from its parent, except the one
    for the socket on which the UDP datagram is available or the TCP connection has
    been accepted.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭从父进程继承的所有文件描述符，除了用于接收 UDP 数据报或已接受的 TCP 连接的套接字文件描述符。
- en: Use the techniques described in [Duplicating File Descriptors](ch05.html#duplicating_file_descriptors
    "Duplicating File Descriptors") to duplicate the socket file descriptor on file
    descriptors 0, 1, and 2, and close the socket file descriptor itself (since it
    is no longer required). After this step, the execed server is able to communicate
    on the socket by using the three standard file descriptors.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [复制文件描述符](ch05.html#duplicating_file_descriptors "复制文件描述符") 中描述的技巧，将套接字文件描述符复制到文件描述符
    0、1 和 2，并关闭套接字文件描述符本身（因为它不再需要）。在此步骤之后，执行的服务器可以通过这三个标准文件描述符在套接字上进行通信。
- en: Optionally, set the user and group IDs for the execed server to values specified
    in `/etc/inetd.conf`.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，为被执行的服务器设置用户和组 ID，设置值来自 `/etc/inetd.conf` 文件。
- en: If a connection was accepted on a TCP socket in step 3, *inetd* closes the connected
    socket (since it is needed only in the execed server).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在步骤 3 中在 TCP 套接字上接受了连接，*inetd* 会关闭已连接的套接字（因为它只在执行的服务器中需要）。
- en: The *inetd* server returns to step 2.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*inetd* 服务器返回到步骤 2。'
- en: The `/etc/inetd.conf` file
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`/etc/inetd.conf` 文件'
- en: The operation of the *inetd* daemon is controlled by a configuration file, normally
    /`etc/inetd.conf`. Each line in this file describes one of the services to be
    handled by *inetd*. [Example 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "Example 60-5. Example lines from /etc/inetd.conf") shows some examples of entries
    in the `/etc/inetd.conf` file that comes with one Linux distribution.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*inetd* 守护进程的操作由配置文件控制，通常是 `/etc/inetd.conf`。该文件中的每一行描述了一个由 *inetd* 处理的服务。[示例
    60-5](ch60.html#example_lines_from_solidus_etc_solidus_i "示例 60-5. `/etc/inetd.conf`
    文件中的示例行") 显示了一个 Linux 发行版附带的 `/etc/inetd.conf` 文件中的一些示例条目。'
- en: Example 60-5. Example lines from `/etc/inetd.conf`
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 60-5. `/etc/inetd.conf` 文件中的示例行
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first two lines of [Example 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "Example 60-5. Example lines from /etc/inetd.conf") are commented out by the initial
    `#` character; we show them now since we’ll refer to the *echo* service shortly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i "示例 60-5. `/etc/inetd.conf`
    文件中的示例行") 的前两行被初始的 `#` 字符注释掉；我们现在展示它们，因为我们将很快提到 *echo* 服务。'
- en: 'Each line of `/etc/inetd.conf` consists of the following fields, delimited
    by white space:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/inetd.conf` 文件的每一行由以下字段组成，字段之间由空白字符分隔：'
- en: '*Service name*: This specifies the name of a service from the `/etc/services`
    file. In conjunction with the *protocol* field, this is used to look up `/etc/services`
    to determine which port number *inetd* should monitor for this service.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务名称*：此项指定来自 `/etc/services` 文件的服务名称。与 *协议* 字段一起使用，用来查找 `/etc/services`，从中确定
    *inetd* 应该监控该服务的端口号。'
- en: '*Socket type*: This specifies the type of socket used by this service—for example,
    `stream` or `dgram`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*套接字类型*：此项指定此服务使用的套接字类型——例如，`stream` 或 `dgram`。'
- en: '*Protocol*: This specifies the protocol to be used by this socket. This field
    can contain any of the Internet protocols listed in the file `/etc/protocols`
    (documented in the *protocols(5)* manual page), but almost every service specifies
    either `tcp` (for TCP) or `udp` (for UDP).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*协议*：此项指定此套接字将使用的协议。该字段可以包含文件 `/etc/protocols` 中列出的任何互联网协议（在 *protocols(5)*
    手册页中有文档），但几乎每个服务都指定 `tcp`（用于 TCP）或 `udp`（用于 UDP）。'
- en: '*Flags*: This field contains either `wait` or `nowait`. This field specifies
    whether or not the server execed by *inetd* (temporarily) takes over management
    of the socket for this service. If the execed server manages the socket, then
    this field is specified as `wait`. This causes *inetd* to remove this socket from
    the file descriptor set that it monitors using *select()* until the execed server
    exits (*inetd* detects this via a handler for `SIGCHLD`). We say some more about
    this field below.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标志*：此字段包含 `wait` 或 `nowait`。此字段指定由 *inetd* 执行的服务器是否（临时）接管该服务的套接字管理。如果执行的服务器管理套接字，则此字段指定为
    `wait`。这会导致 *inetd* 从它通过 *select()* 监视的文件描述符集移除该套接字，直到执行的服务器退出（*inetd* 通过处理 `SIGCHLD`
    来检测这一点）。我们将在下面详细说明此字段。'
- en: '*Login name*: This field consists of a username from `/etc/passwd`, optionally
    followed by a period (`.`) and a group name from `/etc/group`. These determine
    the user and group IDs under which the execed server is run. (Since *inetd* runs
    with an effective user ID of *root*, its children are also privileged and can
    thus use calls to *setuid()* and *setgid()* to change process credentials if desired.)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*登录名*：此字段包含来自 `/etc/passwd` 的用户名，后面可选地跟一个点（`.`）和来自 `/etc/group` 的组名。这些确定了执行的服务器运行时的用户和组
    ID。（由于 *inetd* 以 *root* 的有效用户 ID 运行，因此它的子进程也具有特权，进而可以使用 *setuid()* 和 *setgid()*
    系统调用来更改进程的凭据（如果需要的话）。）'
- en: '*Server program*: This specifies the pathname of the server program to be execed.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务器程序*：此项指定要执行的服务器程序的路径名。'
- en: '*Server program arguments*: This field specifies one or more arguments, separated
    by white space, to be used as the argument list when execing the server program.
    The first of these corresponds to *argv[0]* in the execed program and is thus
    usually the same as the basename part of the *server program* name. The next argument
    corresponds to *argv[1]*, and so on.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务器程序参数*：此字段指定一个或多个参数，参数之间用空格分隔，当执行服务器程序时作为参数列表使用。这些参数中的第一个对应于执行程序中的 *argv[0]*，因此通常与
    *服务器程序* 名称的基本名称部分相同。下一个参数对应于 *argv[1]*，以此类推。'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the example lines shown in [Example 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "Example 60-5. Example lines from /etc/inetd.conf") for the *ftp*, *telnet*, and
    *login* services, we see the server program and arguments are set up differently
    than just described. All three of these services cause *inetd* to invoke the same
    program, *tcpd(8)* (the TCP daemon wrapper), which performs some logging and access-control
    checks before in turn execing the appropriate program, based on the value specified
    as the first server program argument (which is available to *tcpd* via *argv[0]*).
    Further information about *tcpd* can be found in the *tcpd(8)* manual page and
    in [Mann & Mitchell, 2003].
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i "示例 60-5. 来自
    /etc/inetd.conf 的示例行") 中，对于 *ftp*、*telnet* 和 *login* 服务，我们看到服务器程序和参数的设置与之前描述的有所不同。这三项服务都导致
    *inetd* 调用相同的程序，*tcpd(8)*（TCP 守护进程包装器），它在执行适当的程序之前，先进行一些日志记录和访问控制检查，这取决于作为第一个服务器程序参数指定的值（该值可以通过
    *argv[0]* 提供给 *tcpd*）。有关 *tcpd* 的更多信息，请参阅 *tcpd(8)* 手册页以及 [Mann & Mitchell, 2003]。
- en: Stream socket (TCP) servers invoked by *inetd* are normally designed to handle
    just a single client connection and then terminate, leaving *inetd* with the job
    of listening for further connections. For such servers, *flags* should be specified
    as `nowait`. (If, instead, the execed server is to accept connections, then `wait`
    should be specified, in which case *inetd* does not accept the connection, but
    instead passes the file descriptor for the *listening* socket to the execed server
    as descriptor 0.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由 *inetd* 调用的流式套接字（TCP）服务器通常设计为只处理单个客户端连接，然后终止，将进一步监听连接的任务留给 *inetd*。对于这样的服务器，*标志*
    应指定为 `nowait`。（如果执行的服务器需要接受连接，则应指定为 `wait`，在这种情况下，*inetd* 不接受连接，而是将 *监听* 套接字的文件描述符作为描述符
    0 传递给执行的服务器。）
- en: For most UDP servers, the *flags* field should be specified as `wait`. A UDP
    server invoked by *inetd* is normally designed to read and process all outstanding
    datagrams on the socket and then terminate. (This usually requires some sort of
    timeout when reading the socket, so that the server terminates when no new datagrams
    arrive within a specified interval.) By specifying `wait`, we prevent the *inetd*
    daemon from simultaneously trying to *select()* on the socket, which would have
    the unintended consequence that *inetd* would race the UDP server to check for
    datagrams and, if it won the race, start another instance of the UDP server.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数UDP服务器，应该将*flags*字段指定为`wait`。通过*inetd*调用的UDP服务器通常设计为读取并处理套接字上的所有未处理数据报，然后终止。（这通常需要某种类型的超时机制来读取套接字，以便在指定的时间间隔内没有新数据报到达时，服务器终止。）通过指定`wait`，我们可以防止*inetd*守护进程同时尝试对套接字执行*select()*，这样会导致*inetd*与UDP服务器争抢检查数据报，如果它赢得了竞争，就会启动另一个UDP服务器实例。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because the operation of *inetd* and the format of its configuration file are
    not specified by SUSv3, there are some (generally small) variations in the values
    that can be specified in the fields of `/etc/inetd.conf`. Most versions of *inetd*
    provide at least the syntax that we describe in the main text. For further details,
    see the *inetd.conf(8)* manual page.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*SUSv3*没有规定*inetd*的操作和其配置文件的格式，因此在`/etc/inetd.conf`字段中可以指定的值存在一些（通常很小的）差异。大多数版本的*inetd*至少提供了我们在正文中描述的语法。有关更多详细信息，请参见*inetd.conf(8)*手册页。
- en: As an efficiency measure, *inetd* implements a few simple services itself, instead
    of execing separate servers to perform the task. The UDP and TCP *echo* services
    are examples of services that *inetd* implements. For such services, the *server
    program* field of the corresponding `/etc/inetd.conf` record is specified as `internal`,
    and the *server program arguments* are omitted. (In the example lines in [Example 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "Example 60-5. Example lines from /etc/inetd.conf"), we saw that the *echo* service
    entries were commented out. To enable the *echo* service, we need to remove the
    `#` character at the start of these lines.)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种效率措施，*inetd*自己实现了一些简单的服务，而不是执行单独的服务器来执行任务。UDP和TCP *echo*服务就是*inetd*实现的服务示例。对于这些服务，相应`/etc/inetd.conf`记录中的*server
    program*字段被指定为`internal`，而*server program arguments*被省略。（在[示例60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "示例60-5. 来自/etc/inetd.conf的示例行")中的示例行中，我们看到*echo*服务条目被注释掉了。要启用*echo*服务，我们需要删除这些行开头的`#`字符。）
- en: 'Whenever we change the `/etc/inetd.conf` file, we need to send a `SIGHUP` signal
    to *inetd* to request it to reread the file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们更改`/etc/inetd.conf`文件时，需要向*inetd*发送`SIGHUP`信号，要求它重新读取该文件：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Example: invoking a TCP *echo* service via *inetd*'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：通过*inetd*调用TCP *echo*服务
- en: 'We noted earlier that *inetd* simplifies the programming of servers, especially
    concurrent (usually TCP) servers. It does this by carrying out the following steps
    on behalf of the servers it invokes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，*inetd*简化了服务器的编程，特别是并发（通常是TCP）服务器。它通过代表被调用的服务器执行以下步骤来实现这一点：
- en: Perform all socket-related initialization, calling *socket()*, *bind()*, and
    (for TCP servers) *listen()*.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行所有与套接字相关的初始化，调用*socket()*、*bind()*和（对于TCP服务器）*listen()*。
- en: For a TCP service, perform an *accept()* for the new connection.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于TCP服务，执行*accept()*以建立新的连接。
- en: Create a new process to handle the incoming UDP datagram or TCP connection.
    The process is automatically set up as a daemon. The *inetd* program handles all
    details of process creation via *fork()* and the reaping of dead children via
    a handler for `SIGCHLD`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新进程来处理传入的UDP数据报或TCP连接。该进程会自动设置为守护进程。*inetd*程序通过*fork()*执行所有进程创建的细节，并通过`SIGCHLD`信号处理程序回收死去的子进程。
- en: Duplicate the file descriptor of the UDP socket or the connected TCP socket
    on file descriptors 0, 1, and 2, and close all other file descriptors (since they
    are unused in the execed server).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制UDP套接字或连接的TCP套接字的文件描述符到文件描述符0、1和2，并关闭所有其他文件描述符（因为在被execed的服务器中它们不会被使用）。
- en: Exec the server program.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行服务器程序。
- en: (In the description of the above steps, we assume the usual cases that the *flags*
    field of the service entry in `/etc/inetd.conf` is specified as `nowait` for TCP
    services and `wait` for UDP services.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: （在上述步骤的描述中，我们假设`/etc/inetd.conf`中服务条目的*flags*字段通常为TCP服务指定`nowait`，为UDP服务指定`wait`。）
- en: As an example of how *inetd* simplifies the programming of a TCP service, in
    [Example 60-6](ch60.html#tcp_echo_server_designed_to_be_invoked_v "Example 60-6. TCP
    echo server designed to be invoked via inetd"), we show the *inetd*-invoked equivalent
    of the TCP *echo* server from [Example 60-4](ch60.html#a_concurrent_server_that_implements_the
    "Example 60-4. A concurrent server that implements the TCP echo service"). Since
    *inetd* performs all of the above steps, all that remains of the server is the
    code executed by the child process to handle the client request, which can be
    read from file descriptor 0 (`STDIN_FILENO`).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为*inetd*如何简化TCP服务编程的示例，在[示例60-6](ch60.html#tcp_echo_server_designed_to_be_invoked_v
    "示例60-6. 通过inetd调用的TCP回显服务器")中，我们展示了通过*inetd*调用的等效TCP*回显*服务器，源自[示例60-4](ch60.html#a_concurrent_server_that_implements_the
    "示例60-4. 一个实现TCP回显服务的并发服务器")。由于*inetd*执行了上述所有步骤，服务器剩下的部分仅是由子进程执行的代码，用于处理客户端请求，该代码可以通过文件描述符0（`STDIN_FILENO`）读取。
- en: 'If the server resides in the directory `/bin` (for example), then we would
    need to create the following entry in `/etc/inetd.conf` in order to have *inetd*
    invoke the server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器位于目录`/bin`（例如），那么我们需要在`/etc/inetd.conf`中创建以下条目，以便让*inetd*调用该服务器：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 60-6. TCP *echo* server designed to be invoked via *inetd*
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例60-6. 通过*inetd*调用的TCP*回显*服务器
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: An iterative server handles one client at a time, processing that client’s request(s)
    completely, before proceeding to the next client. A concurrent server handles
    multiple clients simultaneously. In high-load scenarios, a traditional concurrent
    server design that creates a new child process (or thread) for each client may
    not perform well enough, and we outlined a range of other approaches for concurrently
    handling large numbers of clients.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代服务器一次处理一个客户端，完全处理该客户端的请求后，才会继续处理下一个客户端。并发服务器则能同时处理多个客户端。在高负载场景下，传统的并发服务器设计每个客户端创建一个新的子进程（或线程），可能表现得不够好，我们概述了多种其他方法来并发处理大量客户端。
- en: The Internet superserver daemon, *inetd*, monitors multiple sockets and starts
    the appropriate servers in response to incoming UDP datagrams or TCP connections.
    Using *inetd* allows us to decrease system load by minimizing the number of network
    server processes on the system, and also simplifies the programming of server
    processes, since it performs most of the initialization steps required by a server.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网超级服务器守护进程*inetd*监控多个套接字，并在接收到UDP数据报或TCP连接时启动相应的服务器。使用*inetd*可以通过最小化系统中的网络服务器进程数量来减少系统负载，并且简化了服务器进程的编程，因为它执行了服务器所需的大部分初始化步骤。
- en: Further information
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: Refer to the sources of further information listed in [Further Information](ch59.html#further_information-id81
    "Further Information").
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[进一步信息](ch59.html#further_information-id81 "进一步信息")中列出的更多信息来源。
- en: Exercises
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Add code to the program in [Example 60-4](ch60.html#a_concurrent_server_that_implements_the
    "Example 60-4. A concurrent server that implements the TCP echo service") (`is_echo_sv.c`)
    to place a limit on the number of simultaneously executing children.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向[示例60-4](ch60.html#a_concurrent_server_that_implements_the "示例60-4. 一个实现TCP回显服务的并发服务器")（`is_echo_sv.c`）中的程序添加代码，以限制同时执行的子进程数量。
- en: Sometimes, it may be necessary to write a socket server so that it can be invoked
    either directly from the command line or indirectly via *inetd*. In this case,
    a command-line option is used to distinguish the two cases. Modify the program
    in [Example 60-4](ch60.html#a_concurrent_server_that_implements_the "Example 60-4. A
    concurrent server that implements the TCP echo service") so that, if it is given
    a *-i* command-line option, it assumes that it is being invoked by *inetd* and
    handles a single client on the connected socket, which *inetd* supplies via `STDIN_FILENO`.
    If the *-i* option is not supplied, then the program can assume it is being invoked
    from the command line, and operate in the usual fashion. (This change requires
    only the addition of a few lines of code.) Modify `/etc/inetd.conf` to invoke
    this program for the *echo* service.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候，可能需要编写一个套接字服务器，以便它可以直接从命令行调用，也可以通过*inetd*间接调用。在这种情况下，使用一个命令行选项来区分这两种情况。修改[示例
    60-4](ch60.html#a_concurrent_server_that_implements_the "示例 60-4. 一个实现 TCP 回显服务的并发服务器")中的程序，使得如果给定了*-i*命令行选项，它假设是通过*inetd*调用，并在连接的套接字上处理单个客户端，该套接字由*inetd*通过`STDIN_FILENO`提供。如果没有提供*-i*选项，则程序可以假设它是从命令行调用的，并以通常的方式运行。（这个修改只需要添加几行代码。）修改`/etc/inetd.conf`，以便为*echo*服务调用这个程序。
