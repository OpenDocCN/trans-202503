- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 15 EXTENDED HEAPS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15 扩展堆
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, we’ll explore some new data structures that allow extra operations
    on heaps. For example, we’ll be able to change or alter the value of a key by
    increasing or decreasing it, or produce a new heap out of two or more other heaps
    by melding or merging. These new structures are based on several concepts we’ve
    looked at in previous chapters, such as common heaps, linked (and doubly linked)
    lists, forests, and more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将探索一些允许对堆进行额外操作的新数据结构。例如，我们将能够通过增大或减小键值来改变或调整键的值，或通过合并或融合两个或更多堆来产生一个新的堆。这些新结构基于我们在前几章中讨论的几个概念，如常见堆、链表（双向链表）、森林等。
- en: First, we’ll consider *skew heaps*, which are heaps implemented as binary trees,
    and *binomial heaps*, which are a new heap implementation based on a forest that
    allows you to merge heaps quickly. We’ll also study an enhanced version of heaps
    called *lazy binomial heaps* that provide better amortized performance, and finish
    by looking at *Fibonacci heaps*, which allow you to change (increase or decrease)
    a key in (amortized) constant time, and *pairing heaps*, which present an easier
    alternative with surprisingly similar performance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将考虑*偏斜堆*，这是一种作为二叉树实现的堆，以及*二项堆*，它是一种基于森林的新堆实现，可以让你快速合并堆。我们还将研究堆的增强版本——*懒二项堆*，它提供更好的摊销性能，最后我们会介绍*斐波那契堆*，它允许你在（摊销的）常数时间内改变（增加或减少）一个键值，和*配对堆*，它提供了一种更简单的替代方案，且性能出奇地相似。
- en: Meldable and Addressable Priority Queues
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可合并和可寻址的优先队列
- en: 'First review the priority queue abstract data type (ADT) you implemented with
    binary heaps. This ADT requires three operations: add() adds a new value to the
    queue, remove() gets the highest priority from the queue, and top() shows the
    priority of the current top element of the queue. With the binary heap implementation
    that represents the heap as an array, the two first operations run in *O*(log
    *n*) time, and the third runs in *O*(1). The extra change() operation alters the
    priority of an element in the queue, and that also is *O*(log *n*).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先回顾一下你用二项堆实现的优先队列抽象数据类型（ADT）。该ADT需要三个操作：add()将新值添加到队列，remove()从队列中取出最高优先级的元素，top()显示当前队列顶部元素的优先级。使用将堆表示为数组的二项堆实现时，前两个操作的时间复杂度是*O*(log
    *n*)，第三个操作的时间复杂度是*O*(1)。额外的change()操作会改变队列中某个元素的优先级，它的时间复杂度也是*O*(log *n*)。
- en: If those three (or four) operations were all that were needed, you’d have a
    good enough implementation. Working with arrays and no pointers is usually quite
    fast, providing performance that is tough to beat. However, if you need specific
    enhanced times (for example, adding new values in constant time) or extra operations
    (like being able to merge two queues into one), you’ll need other solutions. Each
    structure considered in this chapter allows us to meld (or merge) two separate
    priority queues into one. This is called a *meldable priority queue (MPQ)*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些三（或四）个操作就是你所需要的，那么你将拥有一个足够好的实现。使用数组且没有指针通常非常快速，提供的性能很难被超越。然而，如果你需要特定的增强时间（例如，常数时间内添加新值）或额外的操作（比如能够将两个队列合并为一个），你将需要其他的解决方案。本章讨论的每种结构都允许我们将两个独立的优先队列合并为一个。这称为*可合并优先队列（MPQ）*。
- en: Several algorithms need to be able to meld priority queues, so allowing that
    operation enhances their performance. Imagine you’re implementing a priority queue
    for the printers in your system. If one printer goes down, you want to be able
    to reassign all of its printing jobs to another. A meldable heap would provide
    the fastest performance for such a reassignment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个算法需要能够合并优先队列，因此允许这一操作可以增强它们的性能。想象一下，你正在为系统中的打印机实现一个优先队列。如果某台打印机出现故障，你希望能够将所有打印任务重新分配给另一台。一个可合并堆将为这种重新分配提供最快的性能。
- en: 'You also might want to include a second operation: changing a key value. This
    change is a specific one where the old key is replaced with a new one that should
    go higher in the heap—for instance, a lower value in a min heap for several graph
    algorithms. In fact, when working with min heaps, the operation is usually called
    decreaseKey(). Since you’re working with both max and min heaps, you’ll use the
    name changeKey() but will check to make sure the new value should be nearer the
    top of the heap.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想包括第二个操作：更改一个键值。这个更改是一个特定的操作，其中旧的键值被替换为一个新的键值，这个新值应该位于堆的更高位置——例如，在多个图算法中，最小堆中较小的值。事实上，当处理最小堆时，这个操作通常叫做decreaseKey()。由于你同时处理最大堆和最小堆，因此你将使用changeKey()这个名字，但会检查确保新值应该靠近堆的顶部。
- en: For this, you need a reference to a value that you insert, and you’ll use the
    add() operation for that purpose. A heap that provides such an operation is called
    an *addressable heap*. The main focus of this chapter is on meldable heaps, but
    all of the structures here will be addressable, so we’ll consider both new operations
    together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你需要一个插入值的引用，您将使用add()操作来完成这一任务。提供此类操作的堆称为*可寻址堆*。本章的主要内容是可合并堆，但所有这些结构都将是可寻址的，因此我们将一起考虑这两个新操作。
- en: NOTE
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*We considered max heaps with their highest value at the top in [Chapter 14](chapter14.xhtml).
    Since extended heaps are often used with the lowest value at the top, we’ll use
    the function* goesHigher(a,b) *to determine whether a value* a *should be higher
    than a value* b*. For max heaps, you have* a > b *(so the greater value goes to
    the top), and for min heaps, you have* a < b*. Simply changing a single line in
    the definition of this new function provides max heaps or min heaps as needed.
    All the examples in this chapter use max heaps.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在[第14章](chapter14.xhtml)中考虑了最大堆，其最高值位于顶部。由于扩展堆通常使用最小值位于顶部，我们将使用函数*goesHigher(a,b)*来确定一个值*a*是否应该比一个值*b*更高。对于最大堆，您有*a
    > b*（因此更大的值位于顶部），而对于最小堆，您有*a < b*。只需在此新函数的定义中更改一行代码，即可根据需要提供最大堆或最小堆。本章中的所有示例都使用最大堆。*'
- en: '[Table 15-1](chapter15.xhtml#tab15-1) shows the operations in terms of a meldable
    priority queue ADT, starting with creating the priority queue, modifying the addition
    operation, and including merging and changing.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[表15-1](chapter15.xhtml#tab15-1)显示了按可合并优先队列ADT的操作，首先是创建优先队列，修改添加操作，然后包括合并和更改。'
- en: 'Table 15-1: Operations on Meldable Priority Queues'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-1：可合并优先队列上的操作
- en: '| Operation | Signature | Description |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → MPQ | Create a new MPQ. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → MPQ | 创建一个新的MPQ。 |'
- en: '| Empty? | MPQ → boolean | Determine whether the MPQ is empty. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 空吗？ | MPQ → 布尔值 | 确定MPQ是否为空。 |'
- en: '| Add | MPQ × key → MPQ × node | Given a new key, add it to an MPQ and provide
    a reference to the new node. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | MPQ × 键 → MPQ × 节点 | 给定一个新键，将其添加到MPQ并提供对新节点的引用。 |'
- en: '| Top | MPQ → key | Given an MPQ, produce its top value. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 顶部 | MPQ → 键 | 给定一个MPQ，获取其顶部值。 |'
- en: '| Remove | MPQ → MPQ × key | Given an MPQ, extract its top value and update
    the MPQ correspondingly. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | MPQ → MPQ × 键 | 给定一个MPQ，提取其顶部值并相应更新MPQ。 |'
- en: '| Change | MPQ × node × key → MPQ | Given an MPQ, one of its nodes, and a new
    key value, change the node’s key to the new value and update the MPQ. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 更改 | MPQ × 节点 × 键 → MPQ | 给定一个MPQ、它的一个节点和一个新的键值，将节点的键值更改为新值并更新MPQ。 |'
- en: '| Merge | MPQ1 × MPQ2 → MPQ | Given two distinct MPQs, merge them into a single
    MPQ. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | MPQ1 × MPQ2 → MPQ | 给定两个不同的MPQ，将它们合并为一个MPQ。 |'
- en: Let’s now move on to a different variety of heap.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向另一种堆的变体。
- en: Skew Heaps
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 倾斜堆
- en: In [Chapter 14](chapter14.xhtml), we represented binary heaps with an array,
    which has the advantage of maximum simplicity. However, with that representation,
    the best performance you can achieve when merging two heaps of sizes *m* and *n*
    is O(*m* + *n*) by using Floyd’s algorithm. (As an alternative, think of choosing
    a heap and adding all the other heaps’ values to it, which would not be optimal;
    see question 15.1.) *Skew heaps*, which are based on representing a heap as a
    self-adjusting binary tree, provide better (although amortized) performance. In
    later sections, we’ll look at even speedier data structures, but those will include
    an added degree of complexity.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 14 章](chapter14.xhtml)中，我们用数组表示了二叉堆，这样做的优点是最大程度的简化。然而，采用这种表示方式时，当合并两个大小为
    *m* 和 *n* 的堆时，使用 Floyd 算法能达到的最佳性能是 O(*m* + *n*)。（作为替代方案，可以考虑选择一个堆并将其他堆的所有值添加到其中，这样做并不是最优的；请参见问题
    15.1。）*偏斜堆* 基于将堆表示为自调整二叉树，提供了更好的（尽管是平摊的）性能。在后续章节中，我们将介绍更加快速的数据结构，但这些结构会增加一定的复杂度。
- en: NOTE
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Skew heaps are related to a data structure (which we don’t discuss in this
    book) called a leftist heap. Skew heaps, however, require less space, are competitive
    as to running time, and are easier to implement.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*偏斜堆与一种数据结构（在本书中未讨论）叫做左倾堆相关。偏斜堆的优势在于，它们占用更少的空间、运行时间具有竞争力，而且更容易实现。*'
- en: 'Skew heaps have one characteristic in common with the binary heaps considered
    previously: the heap property must be satisfied, so a root must be greater than
    its children—in other words, a skew heap is a *heap-ordered binary tree*. (Remember,
    we are working with max heaps; for min heaps, a root would be smaller than its
    children.) However, one important difference is that skew heaps have no structural
    constraints, so the tree can have any shape, and its height may be not logarithmic.
    [Figure 15-1](chapter15.xhtml#fig15-1) illustrates this fact. It shows a valid
    heap, but its shape is different from what we saw in [Chapter 14](chapter14.xhtml).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 偏斜堆与之前讨论的二叉堆有一个共同特性：必须满足堆的性质，即根节点必须大于其子节点——换句话说，偏斜堆是一个*堆排序的二叉树*。（记住，我们在这里处理的是最大堆；对于最小堆，根节点将小于其子节点。）然而，一个重要的区别是，偏斜堆没有结构约束，因此树可以有任何形状，且其高度可能不是对数级的。[图
    15-1](chapter15.xhtml#fig15-1)说明了这一点。它展示了一个有效的堆，但其形状不同于我们在[第 14 章](chapter14.xhtml)中看到的。
- en: '![](../images/Figure15-1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-1.jpg)'
- en: 'Figure 15-1: A skew heap isn’t complete as common heaps are.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-1：偏斜堆不像常见堆那样是完整的。
- en: Apart from the heap property and no structural constraints, a third particular
    detail is that all adding and removing operations need to use the *skew-merging*
    operation to assure good amortized performance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了堆的性质和没有结构约束外，还有一个特别的细节是，所有的添加和删除操作都需要使用*偏斜合并*操作，以确保良好的平摊性能。
- en: Representing a Skew Heap
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表示偏斜堆
- en: 'Since a skew heap is a binary tree at its core, you can represent it using
    the same kind of code for binary search trees and others:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于偏斜堆本质上是一个二叉树，因此可以使用与二叉搜索树和其他树结构相同的代码来表示它：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The goesHigher() function determines whether to have a max heap (as shown here)
    or a min heap (by changing the comparison to a < b). The following three functions
    are copies of the binary search tree code, and the final top() is simple, given
    that the heap’s top will be the tree’s root.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: goesHigher() 函数决定是否使用最大堆（如这里所示）或最小堆（通过将比较改为 a < b）。以下三个函数是二叉搜索树代码的副本，而最终的 top()
    非常简单，因为堆的顶部将是树的根节点。
- en: Merging Two Skew Heaps
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合并两个偏斜堆
- en: 'The logic for merging two skew heaps together is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个偏斜堆的逻辑如下：
- en: 1. If you merge two empty heaps, the result is an empty heap.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 如果你合并两个空堆，结果是一个空堆。
- en: 2. If one heap is empty and the other isn’t, the result is the nonempty heap.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 如果一个堆为空，而另一个堆非空，结果是非空堆。
- en: 3. If both heaps are nonempty, the heap with the greater root becomes the merged
    heap, but it swaps its children and then merges its left subtree with the heap
    that has the smaller root.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 如果两个堆都非空，根节点较大的堆将成为合并后的堆，但它会交换其子节点，然后将其左子树与根节点较小的堆合并。
- en: The first two cases are pretty clear, so let’s consider the third, more interesting
    one. If you start with the two skew heaps shown in [Figure 15-2](chapter15.xhtml#fig15-2),
    what’s the result of merging them?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个情况比较清晰，接下来我们来考虑第三种，更有趣的情况。如果从图 [15-2](chapter15.xhtml#fig15-2) 中显示的两个偏斜堆开始，合并后的结果是什么？
- en: '![](../images/Figure15-2.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-2.jpg)'
- en: 'Figure 15-2: Two skew heaps to be merged'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-2：两个待合并的偏斜堆
- en: The root of the merged heap should be 60, because it’s the greater root. (Again,
    keep in mind that you’re working with max heaps.) The left subtree of the corresponding
    tree would switch sides with the right subtree, and the (now) left subtree would
    be merged with the heap with root 56\. Recursively, you’d compare 56 and 34, so
    the new root would be 56, and so on. Can you follow all the steps to the result
    shown in [Figure 15-3](chapter15.xhtml#fig15-3)? For instance, it’s easy to see
    that the old left child of the 60 key now is its right child; the 56 key also
    swapped its subtrees.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 合并后的堆的根应该是60，因为它是更大的根。（再次提醒，你在使用的是最大堆。）相应树的左子树将与右子树交换位置，（现在的）左子树将与根为56的堆合并。递归地，你会比较56和34，所以新的根是56，依此类推。你能跟上这些步骤，最终得到[图15-3](chapter15.xhtml#fig15-3)中显示的结果吗？例如，很容易看出，60键的原左子节点现在是它的右子节点；56键也交换了它的子树。
- en: '![](../images/Figure15-3.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-3.jpg)'
- en: 'Figure 15-3: The result of merging the two skew heaps'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-3：合并两个倾斜堆的结果
- en: 'Switching subtrees is what provides good amortized performance; if you merge
    without swapping, the performance is worse. (See question 15.2 for two specific
    sequences of operations that produce badly shaped structures.) The logic is as
    follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 交换子树是提供良好摊销性能的原因；如果不交换进行合并，性能会更差。（参见问题15.2，其中有两种特定操作序列会导致堆结构不佳。）其逻辑如下：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the second heap is empty, return the first one ❶. (This also covers the case
    when both heaps are empty. Can you see why?) Otherwise, if the first heap is empty
    ❷, return the second heap. If no heap is empty and the first heap has the highest
    key, produce a new heap as described earlier ❸. If the second heap has the highest
    key, just swap them around for the merge ❹. (See question 15.3 for an alternative.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个堆为空，返回第一个堆❶。（这也涵盖了两个堆都为空的情况。你能看出为什么吗？）否则，如果第一个堆为空❷，返回第二个堆。如果两个堆都不为空且第一个堆的键值最大，按照之前描述的方法生成一个新的堆❸。如果第二个堆的键值最大，只需交换它们进行合并❹。（参见问题15.3的替代方法。）
- en: Adding a Key to a Skew Heap
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向倾斜堆添加一个键
- en: 'How do you add a new key to a heap, if all you know is how to merge? Simply
    build a new heap with a single value and merge it to the existing heap. You’ve
    already looked at how to merge heaps, so let’s skip to the actual code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只知道如何合并堆，那么如何将一个新键添加到堆中？简单地创建一个包含单一值的新堆并将其与现有堆合并。你已经了解了如何合并堆，因此我们直接跳到实际代码：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This just creates a single-node heap ❶ and merges it ❷.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是创建一个单节点堆❶并将其合并❷。
- en: Removing the Top Key from a Skew Heap
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从倾斜堆中移除顶部键
- en: 'Removing the top key from a heap is straightforward. When you remove the root,
    you’re left with two subtrees, so all you need to do is merge them to form the
    new heap:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆中移除顶部键是直接的。当你移除根节点时，剩下的是两个子树，因此你只需要将它们合并成新的堆：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the heap is empty ❶, throw an error. Otherwise, get the top key ❷ and merge
    the left and right subtrees ❸.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果堆为空❶，抛出错误。否则，获取顶部键❷并合并左右子树❸。
- en: Considering Performance for Skew Heaps
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑倾斜堆的性能
- en: When first thinking about skew heaps and realizing how their structure could
    become quite awful (in the same way that binary trees can degenerate into linear
    shapes), it’s hard to believe that their performance can be good. However, the
    amortized time of additions, removals, and merging can be proven to be *O*(log
    *n*). [Table 15-2](chapter15.xhtml#tab15-2) shows the results; asterisks denote
    amortized values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初考虑倾斜堆并意识到它们的结构可能变得相当糟糕（就像二叉树可能退化为线性形状一样）时，很难相信它们的性能会很好。然而，添加、移除和合并的摊销时间可以证明是*O*(log
    *n*)。 [表15-2](chapter15.xhtml#tab15-2)展示了结果，星号表示摊销值。
- en: 'Table 15-2: Performance of Operations for Skew Heaps'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表15-2：倾斜堆操作的性能
- en: '| Operation | Performance |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 为空？ | O(1) |'
- en: '| Add | O(log n)* |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log n)* |'
- en: '| Top | O(1) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 顶部 | O(1) |'
- en: '| Remove | O(log n)* |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | O(log n)* |'
- en: '| Change | O(log n)* |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 变更 | O(log n)* |'
- en: '| Merge | O(log n)* |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | O(log n)* |'
- en: The changeKey() method was added, which you can do by first removing the old
    key and then inserting the new one; both are *O*(log *n*) methods. (See question
    15.4.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了changeKey()方法，你可以先删除旧的键，再插入新的键；这两个操作都是*O*(log *n*)方法。（参见问题15.4。）
- en: Binomial Heaps
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二项堆
- en: Skew heaps have amortized logarithmic performance all around, but if you go
    beyond single trees, you can do better. *Binomial heaps* are based on a forest
    of heaps, and not only do they perform well, they also are the basis for some
    enhanced variations with even better performance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 偏斜堆具有整体对数时间的摊销性能，但如果你不止使用单棵树，效果可以更好。*二项堆*基于一片堆的森林，它们不仅性能优秀，而且是一些增强变种的基础，提供了更好的性能。
- en: Binomial Trees
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二项树
- en: 'Start with a definition: a *binomial tree of order k*, or *BT(k)*, is a *k*-ary
    tree that is either empty or consists of a root whose children are binomial trees
    of order 0, 1, 2, . . . up to (*k* – 1). [Figure 15-4](chapter15.xhtml#fig15-4)
    shows the first five binomial trees, from BT(0) to BT(4), each consisting of a
    root and one copy of each previous binomial tree.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从定义开始：*k*阶的二项树，或*BT(k)*，是一个*k*叉树，它要么是空的，要么由一个根节点组成，根节点的子节点是阶次从 0、1、2……到 (*k*
    – 1)的二项树。[图 15-4](chapter15.xhtml#fig15-4)展示了前五个二项树，从 BT(0) 到 BT(4)，每个树由一个根节点和每个前一个二项树的一个副本组成。
- en: '![](../images/Figure15-4.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-4.jpg)'
- en: 'Figure 15-4: The first five binomial trees'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-4：前五个二项树
- en: When looking at the trees, you may notice some mathematical properties that
    can be properly proven, but the most important ones are that BT(*k*) has exactly
    2*^k* nodes and its height is *k*. They share those two properties with full binary
    trees. (Actually, full binary trees of height *k* have 2*^(k+)*¹ – 1 nodes, but
    it’s close enough. Let it go!)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当观察这些树时，你可能会注意到一些可以被适当地证明的数学性质，但最重要的两个性质是：BT(*k*)恰好有 2*^k* 个节点，并且它的高度是 *k*。它们与满二叉树具有相同的这两个属性。（实际上，高度为
    *k* 的满二叉树有 2*^(k+1)* – 1 个节点，但差别不大，可以忽略！）
- en: NOTE
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The order of a binomial tree equals the degree of its root, so in this code,
    we’ll use degree instead of order, because that will help when we consider Fibonacci
    heaps, which don’t use the order concept but work with the root’s degree.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*二项树的阶等于其根的度数，因此在此代码中，我们将使用度数而不是阶，因为这有助于我们考虑斐波那契堆，后者不使用阶的概念，而是使用根的度数。*'
- en: 'If you count how many nodes each level has, you’ll notice another property
    that explains the name of this heap: for the trees in [Figure 15-4](chapter15.xhtml#fig15-4),
    the results are 1; 1 and 1; 1, 2, and 1; 1, 3, 3, and 1; 1, 4, 6, 4, and 1; and
    so on. These are *binomial coefficients*, as in Pascal’s triangle where each value
    is the sum of the two above it, as shown in [Figure 15-5](chapter15.xhtml#fig15-5).
    Another property of the triangle is that the sum of the numbers in a row is a
    power of 2, which also matches the size property for a BT(*k*).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你统计每一层有多少个节点，你会注意到另一个解释这个堆名称的属性：对于[图 15-4](chapter15.xhtml#fig15-4)中的树，结果是
    1；1 和 1；1，2，以及 1；1，3，3 和 1；1，4，6，4 和 1；依此类推。这些是*二项系数*，就像帕斯卡三角形中，每个值是其上方两个值之和，如[图
    15-5](chapter15.xhtml#fig15-5)所示。这个三角形的另一个属性是，每一行数字的和是 2 的幂，这也与 BT(*k*)的大小属性相匹配。
- en: '![](../images/Figure15-5.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-5.jpg)'
- en: 'Figure 15-5: Pascal’s triangle provides the number of values at each level
    of binomial heaps.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-5：帕斯卡三角形提供了二项堆每一层的值的数量。
- en: You can look at these trees another way. Notice that each tree is actually built
    out of two trees of the previous order; modifying [Figure 15-4](chapter15.xhtml#fig15-4)
    a bit makes this clearer, as shown in [Figure 15-6](chapter15.xhtml#fig15-6).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用另一种方式来看这些树。注意到每棵树实际上是由前一个阶次的两棵树构建而成；稍微修改一下[图 15-4](chapter15.xhtml#fig15-4)，可以让这一点更清楚，如[图
    15-6](chapter15.xhtml#fig15-6)所示。
- en: '![](../images/Figure15-6.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-6.jpg)'
- en: 'Figure 15-6: Each binomial tree actually consists of two smaller previous ones.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-6：每个二项树实际上由两个更小的前一个二项树组成。
- en: '[Figure 15-6](chapter15.xhtml#fig15-6) shows the first four binomial trees.
    Each one (except the first) is built out of two copies of the previous tree, joined
    at a new root. If these trees also satisfy the heap order property (all nodes
    are greater than or equal to their children), they’re called *heap-ordered binomial
    trees*. With such trees, you can easily represent a heap whose size is a power
    of 2, but how do you represent other sizes of heaps?'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-6](chapter15.xhtml#fig15-6)展示了前四个二项树。每一棵树（除了第一棵）都是由前一棵树的两份副本构建而成，并连接到一个新的根节点。如果这些树还满足堆的顺序属性（所有节点都大于或等于其子节点），则它们被称为*堆排序的二项树*。使用这样的树，你可以轻松表示大小为
    2 的幂的堆，但如果需要表示其他大小的堆该怎么办呢？'
- en: '#### Defining Binomial Heaps'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 定义二项堆'
- en: A *binomial heap* is a forest of heap-ordered binomial trees. (Some textbooks
    specify that those trees must be ordered by ascending size, but we won’t apply
    that extra rule.) How will this allow us to represent any size of heaps? Binary
    numbers provide an easy answer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*二项堆* 是一个堆有序的二项树森林。（一些教科书规定这些树必须按升序排列，但我们不应用这个额外的规则。）这将如何让我们表示任何大小的堆呢？二进制数提供了一个简单的答案。'
- en: 'The number 22 in binary is 10110, which means that 22 = 16 + 4 + 2; thus, you
    can represent any integer number as a sum of powers of 2\. In the same way, you
    represent a heap of any size with a set of binomial trees whose sizes add up to
    whatever size you need. (You won’t have two binomial trees of the same order.
    Can you see why?) Keep in mind another property: the representation of a number
    *n* in the binary system requires log *n* bits, rounded up (we’ll use this later).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 22 的二进制是 10110，这意味着 22 = 16 + 4 + 2；因此，你可以将任何整数表示为 2 的幂的和。以同样的方式，你用一组二项树来表示任何大小的堆，这些树的大小加起来就是你需要的大小。（你不会有两个相同阶的二项树。你能看出为什么吗？）记住另一个特性：二进制系统中表示一个数字
    *n* 需要 log *n* 位，向上取整（我们稍后会用到这个）。
- en: For simplicity, we represent the forest with an array of trees (you could also
    work with a list of linked trees, but that added complexity isn’t needed). Since
    binomial trees are multiway trees, you also need a way to represent them, so we’ll
    use a binary tree representation. Nodes have a down pointer (instead of left)
    to their first child and a right pointer to their next sibling. Nodes also include
    an up link to their parents, in case you want to implement the changeKey() operation.
    Finally, each node also has its degree.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们用一组树来表示森林（你也可以使用一组链式树，但那种复杂度在这里不需要）。由于二项树是多叉树，你还需要一种方法来表示它们，因此我们将使用二叉树表示法。节点有一个指向第一个子节点的下指针（而不是左指针）和指向下一个兄弟节点的右指针。节点还包括一个指向父节点的上链，以防你想实现
    changeKey() 操作。最后，每个节点还包含它的度。
- en: 'This representation is necessary because these algorithms require two operations:
    splitting a tree into several smaller ones and fusing two trees together, and
    those operations are fast and easy to implement with the links. For example, fusing
    two BT(2)s to build a BT(3) requires changing only two pointers (we’ll look at
    that in the next section).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法是必要的，因为这些算法需要两个操作：将一棵树拆分成几棵较小的树，以及将两棵树合并成一棵，而这些操作通过链表实现非常快捷且简单。例如，将两棵 BT(2)
    合并为一棵 BT(3) 只需要改变两个指针（我们将在下一节中讨论这个）。
- en: 'Start with a few basic functions and then add the rest:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从几个基本函数开始，然后添加其余部分：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A binomial heap, then, is an array ❶, and each of its elements is a binomial
    tree. The nodes have the five attributes described earlier ❷. Checking whether
    the heap is empty just requires testing the length of the array of trees ❸.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，二项堆是一个数组 ❶，它的每个元素都是一棵二项树。节点具有前面描述的五个属性 ❷。检查堆是否为空只需要测试树数组的长度 ❸。
- en: NOTE
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注：
- en: '*You might have wondered about using functions for binomial trees. However,
    since you aren’t actually going to use the trees for searching, you’ll use plain
    records in the code, with* key *and* degree *attributes, as well as with* up*,*
    down*, and* right *pointers. Remember that the order of a binomial tree equals
    the degree of its root; that’s why you have* degree *instead of* order*. Having
    the degree for all roots will help with Fibonacci heaps.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会对使用函数来处理二项树产生疑问。然而，由于你实际上并不打算用这些树来进行搜索，因此你会在代码中使用简单的记录，包含* key *和* degree
    *属性，以及* up*、* down* 和* right *指针。记住，二项树的阶数等于其根节点的度；这就是为什么你使用* degree *而不是* order
    *的原因。为所有根节点提供度数将有助于 Fibonacci 堆。*'
- en: 'First, write the top() procedure, using an auxiliary _findTop() function to
    go through all the roots:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编写 top() 过程，使用辅助的 _findTop() 函数遍历所有根节点：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The _findTop() function ❶ finds which tree has the greatest root; it just goes
    through the trees array looking for the greatest key. With this method, top()
    is simply a matter of checking whether the heap is empty. If so, return undefined;
    otherwise, use _findTop() to get the top value of the heap ❷.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: _findTop() 函数 ❶ 用于找到根值最大的树；它会遍历树数组，寻找最大键值。使用这种方法，top() 仅仅是检查堆是否为空。如果为空，则返回 undefined；否则，使用
    _findTop() 获取堆的顶部值 ❷。
- en: Adding a Value to a Binomial Heap
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向二项堆添加一个值
- en: When adding a value to a heap, start by creating a binomial tree of order 0
    with just the key and add it to the heap; however, this may cause a problem if
    another binomial tree of the same order already exists. (Remember, trees of repeated
    orders aren’t allowed.) You can solve it with merging.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当向堆中添加一个值时，从创建一个阶数为 0 的二项树开始，仅包含键值并将其添加到堆中；然而，如果堆中已经存在另一棵相同阶数的二项树，这可能会导致问题。（记住，重复阶数的树是不允许的。）你可以通过合并来解决这个问题。
- en: Assume you have two binomial trees of the same order, as shown in [Figure 15-7](chapter15.xhtml#fig15-7),
    and want to merge them into one. In general, one of the trees should become a
    subtree of the other.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个相同阶数的二项树，如[图 15-7](chapter15.xhtml#fig15-7)所示，并且想将它们合并成一个。通常情况下，其中一棵树应成为另一棵树的子树。
- en: '![](../images/Figure15-7.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-7.jpg)'
- en: 'Figure 15-7: Merging two binomial heaps where one becomes a subtree of the
    other'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-7：合并两棵二项堆，其中一棵成为另一棵的子树
- en: This example, however, needs further consideration because you’re not dealing
    with just any trees; you’re dealing with trees that satisfy the heap condition.
    So, what do you do in this case? Assume the two trees are as shown in [Figure
    15-8](chapter15.xhtml#fig15-8).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个例子需要进一步考虑，因为你处理的不仅仅是任意的树，而是满足堆条件的树。那么，在这种情况下，你该怎么做呢？假设这两棵树如[图 15-8](chapter15.xhtml#fig15-8)所示。
- en: '![](../images/Figure15-8.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-8.jpg)'
- en: 'Figure 15-8: Two binomial heaps to be merged'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-8：待合并的两棵二项堆
- en: The idea is simple. The greater root becomes the new root, and the smaller root
    becomes its child, as shown in [Figure 15-9](chapter15.xhtml#fig15-9).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思路很简单。较大的根成为新的根，较小的根成为它的子节点，如[图 15-9](chapter15.xhtml#fig15-9)所示。
- en: '![](../images/Figure15-9.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-9.jpg)'
- en: 'Figure 15-9: A way to merge the two trees from [Figure 15-8](chapter15.xhtml#fig15-8)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-9：从[图 15-8](chapter15.xhtml#fig15-8)合并两棵树的方式
- en: But [Figure 15-9](chapter15.xhtml#fig15-9) doesn’t show how to actually do it.
    With the binary representation discussed earlier, both original trees would look
    like the ones shown in [Figure 15-10](chapter15.xhtml#fig15-10).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但是[图 15-9](chapter15.xhtml#fig15-9)并没有展示如何实际操作。通过之前讨论的二进制表示，两个原始的树将会像[图 15-10](chapter15.xhtml#fig15-10)所示那样。
- en: '![](../images/Figure15-10.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-10.jpg)'
- en: 'Figure 15-10: The actual binary tree representation for the two binomial heaps'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-10：两棵二项堆的实际二叉树表示
- en: Correspondingly, the result also follows the same scheme of “down to child,
    right to sibling,” as shown in [Figure 15-11](chapter15.xhtml#fig15-11).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，结果也遵循“下为子，右为兄”的模式，如[图 15-11](chapter15.xhtml#fig15-11)所示。
- en: '![](../images/Figure15-11.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-11.jpg)'
- en: 'Figure 15-11: The merged binomial trees in binary tree representation'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-11：二项树合并后的二叉树表示
- en: 'In this way, you can always merge two BT(*k*)s into a single BT(*k* + 1), and
    thanks to the binary representation, that procedure requires you to change only
    two links. The code for this is as follows, where low is the tree with the smaller
    root and high is the one with the greater root:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以始终将两棵 BT(*k*) 树合并成一棵 BT(*k* + 1) 树，并且由于二进制表示，这个过程只需要更改两个链接。以下是该操作的代码，其中
    low 是较小根的树，high 是较大根的树：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s pretty straightforward. The lower tree will have the higher tree’s children
    as siblings ❶ and that node as the parent ❷ ❸, making the new root’s degree go
    up by one ❹. (You’ll use this operation repeatedly in this chapter.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。较低的树会将较高树的子节点作为兄弟节点❶，而那个节点则成为父节点❷ ❸，使得新根的度数增加 1 ❹。（你将在本章中多次使用此操作。）
- en: Now you have the means to merge two trees, but there could be an extra complication.
    In the example, what would happen if the original heap already had another BT(3)?
    In that case, you’d keep merging the original BT(3) with the new one to get a
    BT(4). And, of course, that might lead to a repeated BT(4), and so on. (You’ll
    look at the complete algorithm in the next section.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了合并两棵树的方法，但可能会遇到一个额外的复杂问题。在这个例子中，如果原始堆中已经有另一棵 BT(3) 树会发生什么？在这种情况下，你需要将原始的
    BT(3) 树与新树不断合并，直到得到 BT(4)。当然，这可能会导致出现重复的 BT(4)，依此类推。（你将在下一节查看完整的算法。）
- en: 'Assume for a moment that you already have a method to add a new tree into a
    heap by merging; then the add() method is short:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经有一种通过合并将新树添加到堆中的方法，那么 add() 方法将会很简洁：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You just have to create a new basic BT(0) with the key to be added ❶, which
    is an array with a single object in it, and merge it with the heap ❷. It’s basically
    the same technique used with skew heaps. The difference is how you go about merging
    the heaps.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要创建一个新的基本BT(0)，其包含要添加的键值❶，这是一个只有一个对象的数组，然后将其与堆❷合并。基本上，这与斜堆使用的技术相同。区别在于合并堆的方式。
- en: Merging Two Binomial Heaps
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合并两个二项堆
- en: Consider the problem of merging two heaps in terms of summing binary numbers.
    If you’re familiar with the 2048 game where you try to merge boxes together to
    reach 2048, you’ll understand the examples fairly quickly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从二进制数求和的角度考虑合并两个堆的问题。如果你熟悉2048游戏，其中的目标是将方块合并以达到2048，那么你会很快理解这些例子。
- en: Start with an easy case. Say you have a binomial heap with 22 elements (22 =
    2 + 4 + 16) and want to merge it with another binomial heap of a single element,
    as when adding a new value, as shown in [Figure 15-12](chapter15.xhtml#fig15-12).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个简单的例子开始。假设你有一个包含22个元素的二项堆（22 = 2 + 4 + 16），并且想将它与另一个只有一个元素的二项堆合并，就像添加一个新值一样，如[图15-12](chapter15.xhtml#fig15-12)所示。
- en: '![](../images/Figure15-12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-12.jpg)'
- en: 'Figure 15-12: Merging two heaps has a lot to do with binary numbers.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-12：合并两个堆与二进制数关系密切。
- en: Start at (a)—the heap consists of three binomial trees of sizes 2, 4, and 16
    (corresponding to the binary representation of 22)—and represent it with an array,
    using the trees’ order as an index. The tree with 2 elements is at position 1;
    the one with 4 is at position 2, and the one with 16 is at position 4, while other
    positions remain empty (black). Match the tree to be added with the corresponding
    place in the current heap, and it’s empty, so just move it into place (this is
    the equivalent of doing 1 + 0 = 1), and you get (b). No more trees remain to be
    merged, so you’re done.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从(a)开始——堆由三个大小分别为2、4和16的二项树组成（对应于22的二进制表示）——并将其用数组表示，使用树的顺序作为索引。包含2个元素的树位于位置1；包含4个元素的树位于位置2；包含16个元素的树位于位置4，其他位置保持空白（黑色）。将要添加的树与当前堆中对应的位置匹配，并且该位置为空，所以直接将其移动到合适的位置（这相当于进行1
    + 0 = 1），得到(b)。不再有树需要合并，所以你完成了。
- en: Now consider the harder case of merging two separate heaps with the resulting
    heap of size 23 (23 = 1 + 2 + 4 + 16) and another heap of size 5 (5 = 1 + 4),
    as shown in [Figure 15-13](chapter15.xhtml#fig15-13).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个更复杂的情况，将两个独立的堆合并，得到一个大小为23的堆（23 = 1 + 2 + 4 + 16）和一个大小为5的堆（5 = 1 + 4），如[图15-13](chapter15.xhtml#fig15-13)所示。
- en: '![](../images/Figure15-13.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-13.jpg)'
- en: 'Figure 15-13: Working through the merging, step by step'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-13：逐步完成合并操作
- en: 'Start at (a), matching 1 and 1: remove the 1 from the top heap and merge it
    with the 1 at the bottom heap, which becomes a 2\. Then you arrive at (b) and
    match 2 and 2\. Again, remove the 2 from the top heap and merge it with the 2
    at the bottom, which becomes a 4\. In (c), the situation repeats: you again remove
    from the top and merge at the bottom. (The bottom values are no longer in ascending
    order—you have an 8 first and a 4 second—but that won’t impact the final result.)
    At (d), you have an easy case because there is no 8 at the top, so just put the
    8 there and remove it from the bottom. At (e), you now have a 4, and it has no
    match, so place it at the top and remove it from the bottom, getting to (f), where
    you are finished, since there are no more values to merge.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从(a)开始，匹配1和1：从顶部堆中移除1，并将其与底部堆中的1合并，得到2。然后到达(b)，匹配2和2：再次从顶部堆中移除2，并将其与底部的2合并，得到4。在(c)中，情况重复：你再次从顶部移除并与底部合并。（底部的值不再是升序排列——你先有8，再有4——但这不会影响最终结果。）在(d)中，你有一个简单的情况，因为顶部没有8，所以直接将8放置在顶部并从底部移除它。在(e)中，你现在有一个4，它没有匹配项，所以把它放在顶部并从底部移除，最终到达(f)，此时完成，因为没有更多的值需要合并。
- en: 'You have now solved the problem: merging goes on until no trees of duplicate
    order remain. Implementing the method isn’t complex:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经解决了问题：合并一直进行，直到没有重复顺序的树存在。实现这个方法并不复杂：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, you place all the binomial trees of the heap in the merged array ❶, setting
    each tree in its place according to its order. Then, start processing all the
    trees in the second list ❷, “adding” them as described. If you don’t have a match
    in merged, just put the new tree in there ❸ and advance to the following tree
    to merge. Otherwise, when there’s a match, merge both trees. You have one case
    if the second tree has the greater root ❹ and a different case if the merged tree
    has it ❺. In both cases, place the resulting tree in the second array, emptying
    the place in merged ❻. At the end, after going through all the trees in the second
    array ❼, filter out the merged array to remove empty trees.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将堆的所有二项树放入合并数组❶中，根据树的阶数将每棵树放在相应的位置。然后，开始处理第二个列表❷中的所有树，按照描述进行“添加”。如果合并数组中没有匹配的树，就将新树放进去❸，并继续合并下一个树。否则，当有匹配时，合并两棵树。如果第二棵树的根较大，处理方式是❹，如果合并树的根较大，处理方式是❺。在这两种情况下，将合并后的树放入第二个数组中，清空合并数组中的位置❻。最后，在处理完第二个数组中的所有树❼后，过滤合并数组，移除空的树。
- en: Removing a Value from a Binomial Heap
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从二项堆中移除值
- en: The method to remove the top value from a heap is based on breaking a binomial
    tree apart by removing its root and then melding the separated trees with the
    original heap. Assume the heap consists of two binomial trees (sizes 2 and 8)
    and remove the top value (60), as shown in [Figure 15-14](chapter15.xhtml#fig15-14).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆中移除顶部值的方法是通过移除二项树的根节点来将树分开，然后将分离出的树与原堆进行合并。假设堆由两棵二项树（大小为2和8）组成，并移除顶部值（60），如[图15-14](chapter15.xhtml#fig15-14)所示。
- en: '![](../images/Figure15-14.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-14.jpg)'
- en: 'Figure 15-14: A heap with two binomial trees'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-14：包含两棵二项树的堆
- en: After removing the top value, separate its subtrees (of sizes 4, 2, and 1),
    leaving four binomial trees, as shown in [Figure 15-15](chapter15.xhtml#fig15-15).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除顶部值之后，分离出其子树（大小分别为4、2和1），剩下四棵二项树，如[图15-15](chapter15.xhtml#fig15-15)所示。
- en: '![](../images/Figure15-15.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-15.jpg)'
- en: 'Figure 15-15: After you remove the 60 value, the tree becomes several heaps.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-15：在移除60值后，树变成了多个堆。
- en: Next, use the same method as before to merge these four trees with an initially
    empty set of trees. The first step melds together the two 2-sized trees, as shown
    in [Figure 15-16](chapter15.xhtml#fig15-16).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用之前相同的方法，将这四棵树与一个初始为空的树集合合并。第一步是将两棵2大小的树合并在一起，如[图15-16](chapter15.xhtml#fig15-16)所示。
- en: '![](../images/Figure15-16.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-16.jpg)'
- en: 'Figure 15-16: The first step of the merge'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-16：合并的第一步
- en: Then, as you have two 4-sized (order 2) trees, do another merge, as shown in
    [Figure 15-17](chapter15.xhtml#fig15-17).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，既然你有两个4大小（阶数为2）的树，进行另一次合并，如[图15-17](chapter15.xhtml#fig15-17)所示。
- en: '![](../images/Figure15-17.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-17.jpg)'
- en: 'Figure 15-17: The second merge finishes the job.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-17：第二次合并完成了工作。
- en: 'And you’re done! The new binomial heap has one fewer element, and you managed
    that easily by splitting the tree into subtrees and using the merging code you
    had already written. The remove() method is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！新的二项堆少了一个元素，你通过将树分割成子树并使用之前编写的合并代码轻松地完成了这一操作。remove()方法如下：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, check whether the heap is empty ❶. Then find which tree has the greatest
    root ❷ and get its value ❸ to return it at the end. Create a newTrees array ❹
    and set up a loop ❺ to push the tree ❻ and its siblings ❼ there. After splitting
    the original tree, remove it from the heap ❽ and use the merge() function ❾ to
    merge the new trees into the rest of the original heap.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查堆是否为空❶。然后找出哪棵树的根最大❷，并获取其值❸，最后将其返回。创建一个新树数组newTrees❹并设置一个循环❺来将树❻及其兄弟树❼放入其中。拆分原始树后，从堆中移除它❽，并使用merge()函数❾将新树与原堆中的其他树合并。
- en: Changing a Value in a Binomial Heap
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在二项堆中更改值
- en: Some graph-oriented algorithms often need to change a value already in a heap.
    In such cases, the heap typically includes full records instead of just a priority
    and keeps an external reference to the heap node that includes the record. (We’ll
    look at such graph algorithms in [Chapter 17](chapter17.xhtml).) We won’t go into
    all of that here, but the logic remains the same.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一些面向图的算法经常需要更改堆中已经存在的值。在这种情况下，堆通常包含完整的记录，而不仅仅是优先级，并保持对包含该记录的堆节点的外部引用。（我们将在[第17章](chapter17.xhtml)中讨论这些图算法。）我们在这里不会深入讨论所有细节，但逻辑保持不变。
- en: NOTE
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The most common case is working with min heaps and decreasing a priority with
    a* decreaseKey() *method. If you want to work with a min heap, all you need to
    do is change the direction of the comparison in the* goesHigher() *function described
    earlier in this chapter.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*最常见的情况是使用最小堆并通过* decreaseKey() *方法降低优先级。如果你想使用最小堆，所需要做的就是改变本章前面描述的* goesHigher()
    *函数中的比较方向。*'
- en: 'We’ve already discussed how to change a value in binary heaps: after effecting
    the change, it’s simply a matter of bubbling it up or sinking it down, depending
    on the relationship with other values. In this chapter, we’ll consider only the
    logic to bubble up a key, moving toward the top of the heap, since that’s the
    case actually needed in practice. In [Figure 15-18](chapter15.xhtml#fig15-18),
    say you want to change the 4 key to 50.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过如何在二叉堆中更改一个值：进行更改后，接下来就是根据与其他值的关系进行冒泡向上或沉降的操作。在本章中，我们只考虑将键值向上冒泡的逻辑，即向堆顶移动，因为这是实际中需要的操作。在[图
    15-18](chapter15.xhtml#fig15-18)中，假设你要将键值4更改为50。
- en: '![](../images/Figure15-18.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-18.jpg)'
- en: 'Figure 15-18: A key-changing example, step by step'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-18：逐步变更键值的示例
- en: Change the key and compare it to the parent, unless you already are at the root,
    which means you’re finished. If you’re not at the root, if the changed key is
    smaller, you’re done; otherwise, you have to swap nodes and keep bubbling up.
    Starting at (a), change the 4 key to a 50 in (b). Now compare 50 with 22 and exchange
    the nodes (actually, it’s the pointers that are exchanged) getting to (c). A new
    comparison, 50 and 40, requires yet another exchange as in (d), but now 50 is
    smaller than its parent (60), so you’re done.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 更改键值并与父节点比较，除非你已经在根节点，这意味着操作已完成。如果不是根节点，如果更改后的键值较小，则完成；否则，你必须交换节点并继续向上冒泡。从（a）开始，将键值4更改为50，在（b）中比较50与22并交换节点（实际上是交换指针），进入（c）。新的比较，50与40，再次交换，如（d）所示，但现在50比它的父节点（60）小，因此操作完成。
- en: NOTE
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The need for a value to bubble up is the only reason we include an* up *pointer
    in the tree’s nodes. If you don’t plan to provide the* changeKey() *method, you
    can remove all instances of* up *in the code.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*值需要冒泡向上的原因是我们在树的节点中包含一个* up *指针。如果你不打算提供* changeKey() *方法，可以删除代码中所有的* up *实例。*'
- en: 'Here’s the implementation for this method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此方法的实现：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First check whether the operation is possible: the heap shouldn’t be empty
    ❶, and the new key should go higher in the heap ❷. If everything’s okay, change
    the node’s key to the new value and call _bubbleUp() to make it climb up the heap
    ❸ if that’s needed.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查操作是否可能：堆不应为空 ❶，新键值应位于堆的较高位置 ❷。如果一切正常，将节点的键值更改为新值，并调用_bubbleUp()方法，如果需要，则将其向上爬升。
- en: 'The code for bubbling up is as follows, and it has the longest line of code
    in this entire book:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡向上的代码如下，它是本书中最长的一行代码：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First see whether any bubbling up is needed. If the node doesn’t have a parent,
    or if it has one but the parent’s key is higher than the node’s key, nothing’s
    required ❶. If you need to swap the node up, get a pointer to its parent ❷, and
    make all the pointer (and degree) changes we saw previously (it’s quite a long
    line ❸ but straightforward in concept). Finally, if the node again has a parent,
    use recursion to check whether it still has to bubble up more ❹. If the node doesn’t
    have a parent ❺ (meaning it got to the top of its heap), you need to fix the reference
    in the array of heaps, so instead of pointing to the old node’s parent, now it
    points to the new top. (Couldn’t we just have exchanged keys between the node
    and its parent, as with binary heaps? The answer is important; see question 15.7
    for more on this.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先查看是否需要向上冒泡。如果节点没有父节点，或者有父节点但父节点的键值高于该节点的键值，则不需要任何操作 ❶。如果需要将节点向上交换，获取指向父节点的指针
    ❷，并进行我们之前看到的所有指针（和度数）更改（虽然这一行很长 ❸，但概念上是直观的）。最后，如果节点仍然有父节点，则使用递归检查是否还需要继续冒泡 ❹。如果节点没有父节点
    ❺（意味着它已到达堆的顶部），你需要修复堆数组中的引用，因此它现在指向新顶部，而不是旧节点的父节点。（我们能否像二叉堆一样交换节点和父节点的键值？这个问题很重要；请参考问题
    15.7 了解更多信息。）
- en: Considering Performance for Binomial Heaps
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑二项堆的性能
- en: '[Table 15-3](chapter15.xhtml#tab15-3) summarizes the binomial heaps’ performance;
    results with an asterisk are amortized.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-3](chapter15.xhtml#tab15-3)总结了二项堆的性能；带星号的结果是摊销后的。'
- en: 'Table 15-3: Performance of Operations for Binomial Heaps'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-3：二项堆操作性能
- en: '| Operation | Performance |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 空？ | O(1) |'
- en: '| Add | O(log n)* |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log n)* |'
- en: '| Top | O(log n) as seen; O(1) with a fix |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 顶部 | O(log n) 如上所示；修复后为 O(1) |'
- en: '| Remove | O(log n) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | O(log n) |'
- en: '| Change | O(log n) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 更改 | O(log n) |'
- en: '| Merge | O(log n) |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | O(log n) |'
- en: Given that a binomial heap may consist of up to log *n* heaps, getting the top
    is *O*(log *n*). If you only did additions but no removals, the amortized order
    of adding a new value would be *O*(1)—see question 15.5 for more on this—but we
    can prove that sequences of operations worsen this result to *O*(log *n*). Getting
    the top value, as implemented previously, means looking through log *n* heaps,
    but that can be enhanced to *O*(1); see question 15.6\. As for the other results,
    removing the top value means separating a heap into, at most, log *n* subtrees,
    doing an *O*(log *n*) procedure, followed by merging, which is another *O*(log
    *n*) procedure, so that’s the total order for the operation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二项堆可能包含最多 log *n* 个堆，因此获取 top 的时间复杂度是 *O*(log *n*)。如果你只做添加而不做删除，那么添加新值的摊销时间复杂度是
    *O*(1)—更多信息请参见问题 15.5—but 我们可以证明，操作序列会使这个结果恶化为 *O*(log *n*)。获取 top 值时，按照之前的实现方法，意味着需要查看
    log *n* 个堆，但这个过程可以优化为 *O*(1)；参见问题 15.6。至于其他结果，删除 top 值意味着将堆分离成最多 log *n* 个子树，执行一个
    *O*(log *n*) 的操作，然后进行合并，这是另一个 *O*(log *n*) 的操作，因此操作的总时间复杂度是 *O*(log *n*)。
- en: Lazy Binomial Heaps
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 懒二项堆
- en: Binomial heaps have a potential performance problem when adding values, when
    you go from *O*(1) to *O*(log *n*), which means you can think in amortized terms
    to find a solution that enhances this procedure at the possible risk of (not too
    often) costlier fixes. *Lazy binomial heaps* do exactly that.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 二项堆在添加值时可能会遇到性能问题，从 *O*(1) 变为 *O*(log *n*)，这意味着你可以通过摊销计算找到一种解决方案，以增强此过程，尽管有可能（不过不常见）需要进行更昂贵的修复。*懒二项堆*
    正是通过这种方式解决了这个问题。
- en: With lazy binomial heaps, when you do additions, you don’t care about merging.
    You just let the heap have more and more trees, so add() is a trivial operation,
    running in *O*(1). Take care, however, to keep track of the greatest value, so
    top() is also *O*(1). You can fix the structure when you try to remove() a value,
    except then you process the heap to bring it back into binomial heap shape.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在懒二项堆中，当你进行添加操作时，你不需要关心合并。你只是让堆中树的数量不断增加，因此 add() 是一个简单的操作，运行时间为 *O*(1)。但是要小心，记得跟踪最大值，因此
    top() 也是 *O*(1)。当你尝试执行 remove() 操作时，可以修复堆结构，但这时你需要处理堆，将其恢复为二项堆的形状。
- en: Defining Lazy Binomial Heaps
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义懒二项堆
- en: 'Lazy binomial heaps are binomial heaps after all, although you add an extra
    top property to keep track of the top value in the heap. The class definition
    then is quite short, as most of the methods are shared with binomial heaps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 懒二项堆毕竟还是二项堆，只不过你添加了一个额外的 top 属性来跟踪堆中的最大值。因此，类定义非常简短，因为大多数方法都与二项堆共享：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So far, there are only two differences. A heap is now a record with two fields:
    top ❶, which will have the top value of the heap, and the trees array, which are
    the individual heaps. An empty heap has no trees ❷, so use that for detection.
    You need to update top when adding to or removing from the heap. The top() method
    ❸ is quite short: if the heap is empty, return undefined; otherwise, return the
    value of heap.top. With this implementation, you don’t need to go through the
    whole trees array to find the top, which provides enhanced performance, although
    later heap.top will need some extra maintenance work.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，只有两个差异。堆现在是一个包含两个字段的记录：top ❶，它保存堆的最大值，以及树数组，它是各个子堆。一个空堆没有树 ❷，因此可以用来检测堆是否为空。你需要在向堆中添加或删除元素时更新
    top。top() 方法 ❸ 非常简短：如果堆为空，返回 undefined；否则，返回堆的 top 值。通过这种实现方式，你不需要遍历整个树数组来查找 top，从而提高了性能，尽管后续维护堆的
    top 值可能需要一些额外的工作。
- en: Adding a Value to a Lazy Binomial Heap
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向懒二项堆中添加一个值
- en: The first important difference with lazy binomial heaps is that you won’t do
    any merging when adding a new key. How is this possible? First, if you want to
    know the top of the heap, you can do that without any structure. The heap.top
    attribute described earlier can be updated easily. As long as you keep adding,
    the heap just grows a tree at a time, and you’ll always know the top of the heap.
    For example, assume that a binomial heap had the structure shown in [Figure 15-19](chapter15.xhtml#fig15-19)
    at a certain moment; the triangle points to the maximum of the heap at that time.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 懒散二项堆的第一个重要区别是，添加新键时不会进行任何合并。这怎么可能呢？首先，如果你想知道堆的顶部，你可以不依赖任何结构来实现。之前描述的 heap.top
    属性可以轻松更新。只要你不断添加，堆每次只增长一棵树，你总是能知道堆的顶部。例如，假设某一时刻，二项堆的结构如图 [Figure 15-19](chapter15.xhtml#fig15-19)
    所示；三角形指向当时堆的最大值。
- en: '![](../images/Figure15-19.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-19.jpg)'
- en: 'Figure 15-19: Tracking the top value just needs a simple property.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-19：追踪最大值只需要一个简单的属性。
- en: If you add three new values, the process is quite fast, as the only thing you
    do is add new trees. The diagram in [Figure 15-20](chapter15.xhtml#fig15-20) with
    several binomial trees of the same order, which wouldn’t be allowed in binomial
    heaps, shows this. Again, after each addition, update the maximum. In this example,
    one of the newly added keys was greater than the previous maximum, so you now
    have a different top of the heap.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加三个新值，过程非常快速，因为你唯一需要做的就是添加新树。图 [Figure 15-20](chapter15.xhtml#fig15-20)
    显示了几个相同阶的二项树，这在二项堆中是不允许的。再次强调，每次添加后都要更新最大值。在这个例子中，新增的一个键大于之前的最大值，因此堆的顶部发生了变化。
- en: '![](../images/Figure15-20.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-20.jpg)'
- en: 'Figure 15-20: After you add values, the property needs adjustment.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-20：添加值后，属性需要调整。
- en: 'But removing the heap’s top is a different scenario, because then finding the
    new _heapTop is too slow: *O*(*n*). You can restructure the heap by merging trees
    together only when removing a key. Some math (which we’ll skip) shows that the
    amortized performance remains quite good.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，移除堆顶则是不同的情况，因为此时找到新的 _heapTop 太慢：*O*(*n*)。你可以在移除键时，通过合并树来重新构建堆。一些数学推导（我们会跳过）表明，摊销性能仍然很好。
- en: 'The code for adding a value is similar to what you saw before, but instead
    of merging a new tree, you just add it with no further process:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 添加值的代码与之前看到的类似，但不同的是，你不需要合并新树，只需直接添加它，不进行其他操作：
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, create a new binomial tree with the new key ❶ and push it to the end
    of the current trees array ❷. The only extra step is possibly updating the heap’s
    top. If the array of trees is empty or if the current top is not greater than
    the newly added value ❸, reset heap.top.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新二项树，并将新的键 ❶ 推入当前树数组的末尾 ❷。唯一的额外步骤是可能需要更新堆的顶部。如果树数组为空，或者当前的顶部不大于新添加的值
    ❸，则重置 heap.top。
- en: Removing a Value from a Lazy Binomial Heap
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从懒散二项堆中移除一个值
- en: As mentioned previously, the idea with lazy binomial heaps is to delay merging
    trees as long as possible (thus, the term *lazy*). When you remove a key, first
    merge together all the current binomial trees to get a binomial heap and then
    proceed with the removal.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，懒散二项堆的思想是尽可能延迟合并树（因此称为*懒散*）。当你移除一个键时，首先将所有当前的二项树合并成一个二项堆，然后再进行移除操作。
- en: You do this because although the number of trees in the heap grows slowly when
    adding values and eventually becomes high, it drops sharply after merging, and
    the balance between many fast operations and an eventual slow one ends with a
    nice amortized cost.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是因为，尽管在添加值时堆中的树的数量增长较慢，最终可能会很大，但合并后会急剧下降，在许多快速操作和最终慢操作之间的平衡以一个良好的摊销成本结束。
- en: 'The code is as follows; notice it has a few changes and additions in comparison
    to the original binomial heaps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下；注意，与原始二项堆相比，它有一些变化和新增内容：
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'First check whether the heap is empty ❶ and save the current top of the heap
    ❷ to return its value later ❽. Then find which tree had the top ❸ and do a loop
    to split its subtrees ❹, which you then add to the list of trees. Then remove
    the split tree ❺, merge all trees together ❻, and update heap.top ❼ to find the
    new current top. It’s not very different from binomial heaps. The way you merge
    all trees together is pretty neat: by merging an empty heap with the list of trees,
    you trigger all the necessary merges that will reduce the number of trees. Can
    you see how it works?'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查堆是否为空 ❶ 并保存当前堆顶 ❷，以便稍后返回其值 ❽。然后找到哪棵树有堆顶 ❸，并进行循环来分割其子树 ❹，然后将其添加到树的列表中。接下来删除分割的树
    ❺，将所有树合并在一起 ❻，并更新 `heap.top` ❼ 以找到新的堆顶。它与二项堆并没有太大不同。合并所有树的方式非常巧妙：通过将空堆与树的列表合并，你触发了所有必要的合并，减少了树的数量。你能理解它是如何工作的吗？
- en: Changing a Value in a Lazy Binomial Heap
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改懒二项堆中的值
- en: 'There is one final method: how to change any key. Here’s the code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个最终的方法：如何更改任何键值。代码如下：
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code is the same as for binomial heaps, with the addition of the single
    line to update heap.top; you did a similar calculation in remove(). The code for
    _bubbleUp() is unchanged, so it’s not repeated here.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与二项堆相同，只是增加了一行来更新 `heap.top`；你在 `remove()` 中做过类似的计算。`_bubbleUp()` 的代码没有变化，因此这里不再重复。
- en: Considering Performance for Lazy Binomial Heaps
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑懒二项堆的性能
- en: The performance of lazy binomial heaps is similar to that of binomial heaps,
    but postponing merges has a positive effect in amortized terms. In particular,
    adding a value is logically faster, since you don’t do practically anything, as
    [Table 15-4](chapter15.xhtml#tab15-4) shows. Remember, asterisks denote amortized
    results.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 懒二项堆的性能与二项堆相似，但推迟合并在摊销成本上有积极影响。特别是，添加值在逻辑上更快，因为你实际上什么都不做，正如[表 15-4](chapter15.xhtml#tab15-4)所示。记住，星号表示摊销结果。
- en: 'Table 15-4: Performance of Operations for Lazy Binomial Heaps'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-4：懒二项堆操作的性能
- en: '| Operation | Performance |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 空？ | O(1) |'
- en: '| Add | O(1) |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(1) |'
- en: '| Top | O(1) |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 堆顶 | O(1) |'
- en: '| Remove | O(log n)* |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | O(log n)* |'
- en: '| Change | O(log n)* |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 更改 | O(log n)* |'
- en: '| Merge | O(log n)* |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | O(log n)* |'
- en: You now have very good performance (in particular, adding a new value is faster),
    but you’ll want a better result when changing a value. Let’s look at another variant
    of binomial heaps that allows this enhancement.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经获得了非常好的性能（特别是添加新值更快），但当更改值时，你希望得到更好的结果。我们来看看另一种二项堆的变体，它可以实现这种优化。
- en: Fibonacci Heaps
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 斐波那契堆
- en: Some graph algorithms use min heaps and frequently call the decreaseKey() operation,
    which we renamed to changeKey() to allow for max heaps and min heaps. In that
    situation, being able to decrease keys in a quicker fashion than the *O*(log *n*)
    performance for lazy binomial heaps becomes important. Enter *Fibonacci heaps*,
    which are quite similar to lazy binomial heaps but allow a faster algorithm to
    change a key.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一些图算法使用最小堆，并且经常调用 `decreaseKey()` 操作，我们将其重命名为 `changeKey()`，以适应最大堆和最小堆。在这种情况下，能够以比懒二项堆的
    *O*(log *n*) 性能更快的方式减少键值变得很重要。于是，*斐波那契堆*应运而生，它与懒二项堆非常相似，但提供了一种更快的算法来更改键值。
- en: NOTE
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Michael Fredman and Robert Tarjan described Fibonacci heaps in their paper
    “Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms” (network
    refers to graphs in this title), but Tarjan later suggested an alternative simpler
    structure called pairing heaps, which we’ll study later.*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*迈克尔·弗雷德曼和罗伯特·塔尔扬在他们的论文《斐波那契堆及其在改进的网络优化算法中的应用》中描述了斐波那契堆（此标题中的网络指的是图），但塔尔扬后来提出了一种更简单的替代结构，称为配对堆，我们稍后会学习。*'
- en: What’s the idea behind Fibonacci heaps? The add() and remove() methods work
    the same way as with lazy binomial heaps, but the difference appears when changing
    a key. If a key is changed and has to bubble up (in a max heap, this would happen
    if the new value was greater than before; in a min heap, if smaller), you obviously
    might need to bubble it up even to the root of its tree—that’s *O*(log *n*).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契堆背后的理念是什么？`add()` 和 `remove()` 方法与懒二项堆相同，但在更改键值时才会出现差异。如果键值发生变化并且需要上浮（在最大堆中，如果新值比之前的值大；在最小堆中，如果新值较小），显然你可能需要将其上浮到树的根节点——这就是
    *O*(log *n*) 的时间复杂度。
- en: Instead of doing any bubbling, just separate that node with its subtree and
    add it as a new tree to the heap—that’s *O*(1). However, since this process alters
    the expected shape of the binomial trees and doing it too often could lead to
    badly structured heaps, there’s a compromise. You won’t allow non-root nodes to
    lose more than one child in the described fashion. Should a node lose a second
    node (and you’ll know it because every time a node loses a child, the node will
    be marked), you’ll also separate it, which itself may lead to further separations.
    And, as with lazy binomial heaps, you’ll patch things up when a removal is done;
    you will see all of this later, but first consider how to represent the new heaps.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要进行任何冒泡操作，只需将该节点及其子树分离，并将其作为一个新树添加到堆中——这就是*O*(1)的复杂度。然而，由于这个过程改变了二项树的预期形状，且过于频繁地执行可能导致堆结构不良，因此需要做出折衷。你不会允许非根节点以这种方式失去超过一个子节点。如果一个节点失去第二个子节点（你可以通过每次节点失去子节点时该节点被标记来知道这一点），你也会将其分离，这可能会导致进一步的分离。与懒惰二项堆一样，当执行删除操作时，你将修复这些问题；这些内容稍后你会看到，但首先考虑如何表示新的堆。
- en: Representing a Fibonacci Heap
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表示斐波那契堆
- en: The structure used earlier—an array of trees where each tree is represented
    with up, right, and down links plus a degree field with the number of children—works,
    but that’s not efficient enough for the operation needed here. When changing a
    key and it bubbles up, the idea is to remove the corresponding node and its subtree,
    but can you quickly unlink it from its siblings? If you keep the siblings in a
    singly linked list, that procedure requires traversing a list with a size of up
    to *O*(log *n*), which will spoil the *O*(1) goal. So, in the same way as shown
    in [Chapter 10](chapter10.xhtml), use a doubly linked list here. But there’s more!
    When merging trees, you want to merge two lists of siblings, so make the lists
    circular, and that will complete the solution.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的结构——一个树的数组，其中每棵树通过向上、向右和向下的链接以及一个表示子节点数量的度数字段来表示——是可行的，但对于这里所需的操作来说效率不够。当改变一个键并且它冒泡向上时，目标是移除对应的节点及其子树，但你能迅速将它从兄弟节点中解绑吗？如果你将兄弟节点保存在一个单向链表中，那么这个过程就需要遍历一个最大长度为
    *O*(log *n*) 的链表，这会破坏 *O*(1) 的目标。因此，就像在[第 10 章](chapter10.xhtml)中所展示的那样，这里也使用双向链表。但还有更多！当合并树时，你想合并两组兄弟节点，因此将这些链表设为循环链表，这将完成解决方案。
- en: '[Figure 15-21](chapter15.xhtml#fig15-21) shows a small BT(3) and how it would
    look with all the added links in a Fibonacci heap.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-21](chapter15.xhtml#fig15-21)展示了一个小的二项树 BT(3) 以及它在斐波那契堆中添加了所有链接后的样子。'
- en: '![](../images/Figure15-21.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-21.jpg)'
- en: 'Figure 15-21: A binomial tree represented in Fibonacci heap style'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-21：以斐波那契堆风格表示的二项树
- en: Showing all the up and down and left and right links makes for a cluttered diagram,
    so from now on, we’ll remove any unnecessary links. For instance, the up links
    to parents will be removed, as you can deduce those from the diagrams. We’ll also
    omit arrowheads and circular links for single node lists for clarity, but we’ll
    point out when we make those alterations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 显示所有的上下左右链接会使图表变得杂乱，因此从现在开始，我们将移除任何不必要的链接。例如，指向父节点的向上链接将被移除，因为你可以通过图示推断出这些链接。为了清晰起见，我们还将省略箭头和单节点链表的圆形链接，但我们会在做这些更改时指出。
- en: 'To sum up the changes, we add a left link to the nodes (so we can build the
    circular doubly linked list) and a marked boolean field, which we’ll use to mark
    a node that has lost a child:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下这些变化，我们在节点中添加了一个左链接（以便我们可以构建循环双向链表）和一个标记布尔字段，用来标记一个失去子节点的节点：
- en: '[PRE16]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The single change is the addition of the **marked** and **left** fields; the
    rest is the same as it was for lazy binomial heaps.  #### Merging Two Fibonacci
    Trees'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '唯一的变化是添加了**标记**和**左**字段；其余部分与懒惰二项堆相同。  #### 合并两棵斐波那契树'
- en: When we first looked at how to merge binomial trees, the procedure was relatively
    simple. Now that siblings are in a circular doubly linked list, however, you’ll
    need to make some changes. Say you want to merge the trees shown in [Figure 15-22](chapter15.xhtml#fig15-22)
    (remember, details for subtrees that won’t be affected by the changes, as well
    as arrowheads and up links, are hidden).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次查看如何合并二项树时，过程相对简单。然而，现在兄弟节点被放置在一个循环双向链表中，你需要做一些修改。假设你想要合并在[图 15-22](chapter15.xhtml#fig15-22)中显示的树（记住，子树的细节不会受到影响的部分，以及箭头和向上链接，都被隐藏了）。
- en: '![](../images/Figure15-22.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-22.jpg)'
- en: 'Figure 15-22: Two Fibonacci trees to be merged'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-22：待合并的两棵斐波那契树
- en: After merging the trees together, you get the result shown in [Figure 15-23](chapter15.xhtml#fig15-23).
    Pay particular attention to the changed links; arrowheads are included only for
    those.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 合并树之后，你将得到[图15-23](chapter15.xhtml#fig15-23)所示的结果。特别注意那些发生变化的链接；箭头仅用于表示这些链接。
- en: '![](../images/Figure15-23.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-23.jpg)'
- en: 'Figure 15-23: The result of merging the trees; only a few pointers needed to
    change.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-23：合并树的结果；只需要更改几个指针。
- en: 'Here’s the new merging code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的合并代码：
- en: '[PRE17]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the tree with the higher key has no children, the logic is simple, because
    you just need to set the lower tree as its child ❸ ❹. However, if it does have
    children ❶, you need to add the lower tree’s root as a new sibling to the higher
    tree’s root’s children ❷. (Notice the four link changes.) After that, make the
    higher root point to the lower root ❸ and vice versa ❹. Then increment the higher
    root’s degree by 1 ❺ since it gained a new child and return the merged tree ❻.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果具有较高键值的树没有子节点，逻辑就很简单，因为你只需将较低的树设置为它的子树 ❸ ❹。然而，如果它确实有子节点 ❶，你就需要将较低树的根节点作为新兄弟添加到较高树根节点的子节点中
    ❷。（注意四个链接变化。）之后，让较高根指向较低根 ❸，并且反之亦然 ❹。然后，将较高根的度数加1 ❺，因为它获得了一个新子节点，并返回合并后的树 ❻。
- en: Adding a Value to a Fibonacci Heap
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向斐波那契堆添加一个值
- en: 'Adding a new value to the Fibonacci heap isn’t very different from lazy binomial
    heaps. The only change is you need to set up the circular list of siblings (initially
    with just the node itself) for future merging operations. The following code highlights
    the needed changes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 向斐波那契堆中添加新值与懒二项堆没有太大区别。唯一的变化是，你需要为将来的合并操作建立兄弟节点的循环链表（最初只有节点本身）。以下代码高亮显示了所需的变化：
- en: '[PRE18]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Initialize the left and right pointers of the new node appropriately, so they
    form a single-node circular list. (Yes, you could write the two lines as a single
    assignment; see question 15.9.) The new tree will have marked set to false, because
    the node hasn’t yet lost any children. To check this, see the newNode() code,
    in the section “Representing a Fibonacci Heap” on page 368.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正确初始化新节点的左右指针，使它们形成一个单节点的循环链表。（是的，你可以将这两行合并为一个赋值语句；见问题15.9。）新树的标记会被设置为false，因为节点还没有失去任何子节点。要验证这一点，请查看newNode()代码，参见第368页的“表示斐波那契堆”一节。
- en: Removing a Value from a Fibonacci Heap
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从斐波那契堆中移除一个值
- en: 'The logic for removing a value is essentially the same as for other binomial
    heaps, with minor changes. Removing the top of the heap also works the same as
    with lazy binomial trees, except beware of infinite loops when traversing the
    circular list of siblings, for example. The new lines are highlighted:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 移除值的逻辑与其他二项堆基本相同，只是有一些小的变化。移除堆顶的操作也和懒二项树一样，唯一需要注意的是，当遍历兄弟节点的循环链表时，必须防止出现无限循环。新添加的代码行如下所示：
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To avoid infinite loops, set the rightmost link of the list to null ❶ to ensure
    that the following loop will stop. (Here, bt points to an element in the circular
    list. Traverse this list to the right, so bt.left points to what should be the
    last element to visit. If you clear the right link of bt.left, this ensures that
    the loop will stop.) The other difference is when you extract a sibling, the root
    must be a circular link by itself ❷, so you have to fix its left and right links.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免无限循环，将链表的最右链接设为null ❶，以确保以下循环能够停止。（在这里，bt指向循环链表中的一个元素。向右遍历该链表，因此bt.left指向应当是最后一个访问的元素。如果清除bt.left的右链接，就能确保循环停止。）另一个区别是，当你提取一个兄弟节点时，根节点必须是一个自我循环链接
    ❷，因此你需要修正它的左右链接。
- en: Changing a Value in a Fibonacci Heap
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在斐波那契堆中改变一个值
- en: 'How a key change is handled is what sets Fibonacci heaps apart from the other
    types of heaps. Instead of bubbling up, you directly separate that key from the
    heap. The code is similar to what you saw before, but it has one significant change
    (in bold):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 处理键值变化的方式是斐波那契堆区别于其他类型堆的地方。与其通过冒泡向上，不如直接将该键从堆中分离。代码与之前看到的类似，但有一个重要的变化（加粗部分）：
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you actually change the node’s key, you *separate* it from the heap instead
    of bubbling up. To illustrate, consider the heap shown in [Figure 15-24](chapter15.xhtml#fig15-24)
    from earlier in the chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实际上改变节点的键时，你会*分离*它而不是向上冒泡。为了说明这一点，请参考本章前面提到的[图15-24](chapter15.xhtml#fig15-24)中的堆。
- en: '![](../images/Figure15-24.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-24.jpg)'
- en: 'Figure 15-24: The previous Fibonacci heap'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-24：前一个斐波那契堆
- en: Suppose the 9 key is changing to 99, as shown in [Figure 15-25](chapter15.xhtml#fig15-25).
    Since it would be bubbling up, just remove it from the heap and mark its parent
    (80).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 假设9这个键值变成了99，如[图 15-25](chapter15.xhtml#fig15-25)所示。由于它会被上浮，因此只需将其从堆中移除，并标记其父节点（80）。
- en: '![](../images/Figure15-25.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-25.jpg)'
- en: 'Figure 15-25: The Fibonacci heap after changing a key from 9 to 99'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-25：斐波那契堆在键值从9变为99后的状态
- en: The only thing you had to do is unlink the 9 (now 99) from its siblings. If
    you now want to change the 60 to 66, you also need to change 80’s down pointer.
    You can make it point to 60’s right sibling, as shown in [Figure 15-26](chapter15.xhtml#fig15-26).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你唯一需要做的就是将9（现在是99）从它的兄弟节点中解除链接。如果现在你想将60改为66，你还需要修改80的下指针。你可以让它指向60的右兄弟节点，如[图
    15-26](chapter15.xhtml#fig15-26)所示。
- en: '![](../images/Figure15-26.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-26.jpg)'
- en: 'Figure 15-26: Another change in the tree, and 60 becomes 66.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-26：树中的另一个变化，60变成了66。
- en: 'Now you need to do an extra step. After this separation, if 80 isn’t the root,
    since it was already marked (meaning it had already lost one child), you’d also
    have to separate it, applying exactly the same logic as earlier. The code looks
    like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要执行一个额外的步骤。经过这次分离后，如果80不是根节点，由于它已经被标记（意味着它已经失去了一个子节点），你还需要对它进行分离，应用和之前完全相同的逻辑。代码如下：
- en: '[PRE21]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Start by unmarking the node to be separated ❶. This is the *only* way a node
    can become unmarked again. You then get the parent of the node ❷, but if it has
    none (meaning the node is a root), don’t do anything. Otherwise, if the node has
    a parent ❸, start unlinking. If the changing node has no siblings ❹, just set
    the parent’s down link to null, and you’re done. But if instead the parent is
    pointing down directly to the node you are changing ❺, you must change the link
    to a sibling, so you don’t break the structure when removing the changing node.
    Now that you are sure the parent is pointing to a different sibling, you can easily
    unlink the node from the doubly linked list ❻. Then you need to reduce the parent’s
    degree by one ❼, since it will be losing a child, and push the separated subtree
    after fixing its links ❽. The last check is if you are removing a child from a
    node that was marked (meaning it had already lost another child), recursively
    separate it ❾; otherwise, just mark it ❿, and you’re finished.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从取消标记要分离的节点开始 ❶。这是节点能够重新变为未标记的*唯一*方式。然后获取节点的父节点 ❷，如果它没有父节点（意味着节点是根节点），则不做任何操作。否则，如果节点有父节点
    ❸，则开始解除链接。如果改变的节点没有兄弟节点 ❹，只需将父节点的下链接设置为 null，就完成了。但如果父节点直接指向正在变化的节点 ❺，你必须将链接改为指向兄弟节点，以便在移除变化节点时不破坏结构。现在你可以确认父节点指向了另一个兄弟节点，就可以轻松地将节点从双向链表中解除
    ❻。然后需要将父节点的度数减一 ❼，因为它将失去一个子节点，并在修复链接后推送分离的子树 ❽。最后检查，如果你正在移除的子节点是已标记的（意味着它已经失去了另一个子节点），则递归地将其分离
    ❾；否则，只需标记它 ❿，就完成了。
- en: Considering Performance for Fibonacci Heaps
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑斐波那契堆的性能
- en: Binomial heaps are formed of binomial trees, and each tree has a number of nodes
    that is a power of 2\. Before any changes (which start pruning the trees), a Fibonacci
    heap has same-sized trees, but how low can they go? [Figure 15-27](chapter15.xhtml#fig15-27)
    shows a Fibonacci heap with as many nodes removed as possible; the white nodes
    were removed, and black nodes are left.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 二项堆由二项树组成，每棵树的节点数是2的幂。改变之前（这时开始修剪树），斐波那契堆中的树是相同大小的，但它们能变得有多小呢？[图 15-27](chapter15.xhtml#fig15-27)展示了一个已经尽可能移除节点的斐波那契堆；白色节点已被移除，黑色节点被保留。
- en: '![](../images/Figure15-27.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-27.jpg)'
- en: 'Figure 15-27: Fibonacci trees with a minimum number of nodes'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-27：具有最小节点数的斐波那契树
- en: How do you remove as many nodes as possible from a tree without causing any
    cascading? Or, how do you build the next tree, out of the previous ones, all pruned
    as much as possible? The worst you can do is promote the largest subtree of every
    node. In that case, the individual trees would at least have 1, 1, 2, 3, 5, 8,
    . . . nodes. Recognize the sequence? The trees in this scheme would have at least
    as many nodes as a Fibonacci number (instead of a power of 2). This also helps
    because Fibonacci numbers are exponential in nature, implying that the algorithms’
    performance will still be logarithmic.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在不引发级联效果的情况下尽可能多地删除树中的节点？或者，如何从先前的树中构建下一棵树，并尽可能多地修剪它们？最差的情况是提升每个节点的最大子树。在这种情况下，单个树至少会有
    1、1、2、3、5、8、……个节点。认出这个序列了吗？这个方案中的树至少有与斐波那契数一样多的节点（而不是 2 的幂）。这也有帮助，因为斐波那契数是指数增长的，这意味着算法的性能仍然是对数级的。
- en: '[Table 15-5](chapter15.xhtml#tab15-5) summarizes the performance of Fibonacci
    heaps; the values with an asterisk are amortized.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-5](chapter15.xhtml#tab15-5) 总结了斐波那契堆的性能；带星号的值是摊销后的。'
- en: 'Table 15-5: Performance of Operations for Fibonacci Heaps'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-5：斐波那契堆操作的性能
- en: '| Operation | Performance |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 空吗？ | O(1) |'
- en: '| Add | O(1) |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(1) |'
- en: '| Top | O(1) |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 顶部 | O(1) |'
- en: '| Remove | O(log n)* |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | O(log n)* |'
- en: '| Change | O(1)* |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 改变 | O(1)* |'
- en: '| Merge | O(1) |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | O(1) |'
- en: You can’t do better than *O*(1) for insertions, but removals possibly could
    be better than *O*(log *n*). However, in that case, you could sort a set of *n*
    values in *O*(*n*) time by inserting all of them into the heap and then removing
    them in order, but you already know you can’t have a sorting algorithm that depends
    on key-to-key comparisons run with a faster time than *O*(*n* log *n*), so you
    can’t do removals with better speed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插入操作，你无法做到比 *O*(1) 更好，但删除操作的时间复杂度可能会比 *O*(log *n*) 更优。然而，在这种情况下，你可以通过将所有 *n*
    个值插入堆中，然后按顺序删除它们，来在 *O*(*n*) 时间内对一组 *n* 个值进行排序，但你已经知道，任何依赖于键值对比的排序算法无法以比 *O*(*n*
    log *n*) 更快的时间运行，因此你无法以更高的速度完成删除操作。
- en: What you can do is use a simpler structure, with less complex algorithms. The
    last type of extended heap we’ll consider in this chapter, the pairing heap, does
    exactly that.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一种更简单的结构，配合更简单的算法。我们将在本章考虑的最后一种扩展堆是配对堆，正是做到了这一点。
- en: Pairing Heaps
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配对堆
- en: A *pairing heap* is a multiary data structure that satisfies the heap property.
    It basically consists of a root that has the top value of the heap and an ordered
    set of heaps, so you could call it an orchard in terms of the definitions from
    [Chapter 13](chapter13.xhtml). In more formal terms, you could say that a pairing
    heap is either an empty structure or a root element plus a (possibly empty) list
    of pairing heaps. Each individual heap is represented in the “left child, right
    sibling” style; [Figure 15-28](chapter15.xhtml#fig15-28) shows an example of a
    pairing heap.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*配对堆*是一种多元数据结构，满足堆属性。它基本上由一个根节点组成，该根节点包含堆中的最大值，并且有一组有序的子堆，因此你可以根据[第13章](chapter13.xhtml)中的定义称其为一个果园。从更正式的角度来看，可以说配对堆要么是一个空结构，要么是一个根元素加上一个（可能为空的）配对堆列表。每个单独的堆以“左孩子，右兄弟”风格表示；[图
    15-28](chapter15.xhtml#fig15-28)展示了一个配对堆的示例。'
- en: '![](../images/Figure15-28.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-28.jpg)'
- en: 'Figure 15-28: A sample pairing heap'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-28：一个配对堆示例
- en: The root is 60 and has three subheaps with keys 22, 56, and 12\. The subheaps
    have 3, 5, and 2 elements, respectively.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点是 60，并且有三个子堆，分别为 22、56 和 12。子堆包含 3、5 和 2 个元素。
- en: '#### Defining a Pairing Heap'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 定义配对堆'
- en: 'We won’t consider the changeKey() operation (but see question 15.4), so the
    representation is a tad simpler. Here’s the basic starting code for a pairing
    heap:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会考虑 changeKey() 操作（但请参见问题 15.4），因此表示方式稍微简单一些。以下是配对堆的基本起始代码：
- en: '[PRE22]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It’s the same code as for skew heaps, except the left pointer is named down
    and a small change was made in isEmpty().
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 它与偏斜堆的代码相同，只是左指针被命名为“down”，并且在isEmpty()函数中做了一些小改动。
- en: Melding Two Pairing Heaps
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合并两个配对堆
- en: How do we meld two heaps? If one of the two heaps is empty, just return the
    other one. Otherwise, if neither heap is empty, the heap with the greatest key
    will have the other heap added (melded) to its list of subtrees. For instance,
    see what happens if you want meld the first two subheaps in [Figure 15-29](chapter15.xhtml#fig15-29)
    (this is an important example, and you’ll return to it later).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何合并两个堆？如果两个堆中的一个为空，则直接返回另一个堆。否则，如果两个堆都不为空，则具有最大键值的堆将把另一个堆添加（合并）到它的子堆列表中。例如，看看如果你想合并[图
    15-29](chapter15.xhtml#fig15-29)中的前两个子堆会发生什么（这是一个重要的示例，稍后你会再遇到它）。
- en: '![](../images/Figure15-29.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-29.jpg)'
- en: 'Figure 15-29: Two pairing heaps to be merged'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-29：两个配对堆待合并
- en: The new root should be 56, so the first heap (the one with root 22) becomes
    a child of the second heap, producing the configuration shown in [Figure 15-30](chapter15.xhtml#fig15-30).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 新的根应该是 56，因此第一个堆（根为 22 的堆）将成为第二个堆的子堆，生成如[图 15-30](chapter15.xhtml#fig15-30)所示的配置。
- en: '![](../images/Figure15-30.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-30.jpg)'
- en: 'Figure 15-30: The result of merging'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-30：合并结果
- en: 'You can implement this easily:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地实现这一点：
- en: '[PRE23]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If one heap is empty ❶ ❷, the result of the merge is just the other tree. Otherwise,
    if the first heap has the highest key ❸, make the second heap its child. The last
    case is the same ❹ but in reverse, making the first heap a child of the second.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个堆为空 ❶ ❷，合并的结果就是另一个堆。否则，如果第一个堆的键值最大 ❸，则将第二个堆作为其子堆。最后一种情况是相同的 ❹，但是反过来，将第一个堆作为第二个堆的子堆。
- en: Adding a Value to a Pairing Heap
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向配对堆中添加值
- en: 'Adding a new value to the heap is done with the same method as for skew heaps.
    Create a new heap with only the new value in it and merge it with the current
    heap. You’ve already seen how merging works. The code is almost a one-liner:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 向堆中添加一个新值的方法与斜堆相同。创建一个仅包含新值的新堆，并将其与当前堆合并。你已经看过合并是如何工作的。代码几乎是一行代码：
- en: '[PRE24]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It creates a new heap ❶ with a single value in it and merges it with the current
    heap ❷.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个新的堆 ❶，其中只有一个值，并将其与当前堆 ❷ 合并。
- en: Removing the Top Value from a Pairing Heap
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从配对堆中删除顶部值
- en: Removing the top value from the heap is harder than adding a new value, and
    it requires a lot of melding. Basically, you want to remove the heap’s root and
    produce a list of subheaps, which you’ll meld in pairs from left to right and
    then meld the resulting list of heaps from right to left.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆中删除顶部值比添加新值要困难，需要更多的合并。基本上，你需要删除堆的根并生成一个子堆列表，然后你会从左到右成对地合并这些子堆，再将合并后的堆列表从右到左合并。
- en: NOTE
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The name pairing heaps comes from the procedure described previously where
    many heaps are always merged in pairs, two by two.*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*“配对堆”这个名字来源于前面描述的过程，在这个过程中，许多堆总是成对地合并，每次合并两个。*'
- en: First, take a look at how to meld several heaps together. [Figure 15-31](chapter15.xhtml#fig15-31)
    shows an example for seven heaps A through G.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看如何将多个堆合并在一起。[图 15-31](chapter15.xhtml#fig15-31)展示了一个包含七个堆（A 到 G）的示例。
- en: '![](../images/Figure15-31.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-31.jpg)'
- en: 'Figure 15-31: Melding seven heaps together, always working two at a time'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-31：合并七个堆，总是每次合并两个
- en: First merge A and B, and combine that with the result of merging C through G.
    The second merge starts by merging C and D, and then it merges E through G. The
    third merge merges E and F first and then waits for the merge of only G (which
    is trivially just G), so you can complete merging E through G, and then C through
    G, and finally A through G.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先合并 A 和 B，再将其与合并 C 到 G 的结果结合起来。第二次合并从合并 C 和 D 开始，然后再合并 E 到 G。第三次合并先合并 E 和 F，然后等待仅合并
    G（这显然就是 G），所以你可以完成 E 到 G 的合并，再合并 C 到 G，最后合并 A 到 G。
- en: 'Implementing this seesaw from left to right and then from right to left is
    actually easy. It’s based on a recursive idea: given a list of heaps, merge the
    initial two heaps on the list to produce a first heap, apply recursion to meld
    all the others into a second heap, and finish by merging both results together:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种从左到右再到从右到左的“跷跷板”其实很简单。它基于递归思想：给定一个堆列表，将列表中的前两个堆合并生成第一个堆，递归地将其余堆合并成第二个堆，最后将两个结果合并在一起：
- en: '[PRE25]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code shows two simple, one-liner cases. If you have no heaps to merge ❶,
    a null heap is returned, and if there is only one heap to merge ❷, the result
    is that heap itself. If you have several heaps ❸, merge the two first heaps, then
    recursively merge all the other heaps, and finish by merging both heaps together.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了两种简单的单行情况。如果没有堆需要合并 ❶，则返回一个空堆；如果只有一个堆需要合并 ❷，则结果就是该堆本身。如果有多个堆 ❸，则先合并前两个堆，然后递归地合并所有其他堆，最后将两个堆合并在一起。
- en: 'This is actually an implementation of the left-to-right then right-to-left
    process described previously, so now redo the case with the seven heaps A through
    G you looked at earlier. Writing mbp() for mergeByPairs() and m() for merge(),
    it would be:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是之前描述的从左到右再到从右到左的过程的实现，现在重新处理一下之前你看到的七个堆 A 到 G 的案例。用mbp()表示mergeByPairs()，用m()表示merge()，代码如下：
- en: '[PRE26]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Given this auxiliary method, you can now write the remove() code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个辅助方法，你现在可以编写remove()代码：
- en: '[PRE27]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the heap is empty ❶, throw an error, because you cannot proceed with the
    removal. Otherwise, get the top value ❷, so you can return it later ❼, and proceed
    to separate the subheaps. Initialize an array for the children ❸ and set up a
    child variable ❹ to loop through all the root’s children ❺. Then push each of
    the subheaps ❻, after remembering to unlink each from its siblings. After pushing
    all children into the array, merge them by pairs as described previously and return
    the removed top ❼.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果堆是空的 ❶，抛出一个错误，因为无法继续进行删除操作。否则，获取顶部值 ❷，以便稍后返回 ❼，并继续分离子堆。为子节点初始化一个数组 ❸，并设置一个子节点变量
    ❹，以便遍历所有根节点的子节点 ❺。然后，推入每个子堆 ❻，记得将它们从兄弟节点中解绑。将所有子节点推入数组后，按之前描述的方式成对合并它们，并返回删除的顶部值
    ❼。
- en: For example, assume you start again with the original pairing heap (see [Figure
    15-32](chapter15.xhtml#fig15-32)) and want to remove its root.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你从原始的配对堆开始（参见[图 15-32](chapter15.xhtml#fig15-32)），并且想要删除其根节点。
- en: '![](../images/Figure15-32.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-32.jpg)'
- en: 'Figure 15-32: The original pairing heap revisited'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-32：重新查看原始的配对堆
- en: Removing the root leaves three heaps. Start by melding the first two, those
    with roots 22 and 56 (you saw this in the previous section), resulting in [Figure
    15-33](chapter15.xhtml#fig15-33).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 删除根节点后，剩下三个堆。首先合并前两个堆，即根节点分别为 22 和 56 的堆（你在前一部分中看过），得到[图 15-33](chapter15.xhtml#fig15-33)。
- en: '![](../images/Figure15-33.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-33.jpg)'
- en: 'Figure 15-33: The pairing heap after removing its root'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-33：删除根节点后的配对堆
- en: The final step is melding those heaps, resulting in the situation shown in [Figure
    15-34](chapter15.xhtml#fig15-34).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将这些堆合并，得到如[图 15-34](chapter15.xhtml#fig15-34)所示的情况。
- en: '![](../images/Figure15-34.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-34.jpg)'
- en: 'Figure 15-34: The separate heaps melded again into a single heap'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-34：将分开的堆再次合并成一个堆
- en: 'Let’s now consider another procedure: changing a key’s value.  #### Changing
    a Value in a Pairing Heap'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们考虑另一种操作：更改键值。  #### 在配对堆中更改键值'
- en: The procedure to change a key is based on what you’ve already seen. First, change
    the key in place, but if it needs bubbling up (as with binomial heaps), separate
    it from the heap (as with Fibonacci heaps). Then merge the separated heap back
    into the original heap. You’re reusing concepts and algorithms.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 更改键值的过程基于你已经看到的内容。首先，在原地更改键值，但如果它需要上浮（像二项堆那样），则将其从堆中分离出来（像斐波那契堆那样）。然后将分离出的堆重新合并到原始堆中。你正在复用概念和算法。
- en: For example, start with the heap shown in [Figure 15-35](chapter15.xhtml#fig15-35).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从[图 15-35](chapter15.xhtml#fig15-35)中所示的堆开始。
- en: '![](../images/Figure15-35.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-35.jpg)'
- en: 'Figure 15-35: A pairing heap just before changing a key'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-35：更改键值前的配对堆
- en: If you want to change the 40 key, for example, and changed it to any value between
    40 and 56, you’d just change the key and be done with it. However, if you change
    it to anything greater than its parent key (56), you have to split the heap and
    remerge it. This means if you want to change it to 78, after changing the key
    and splitting the heap away, you are left with the pair of heaps shown in [Figure
    15-36](chapter15.xhtml#fig15-36).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，如果你想更改键值 40，并将其更改为 40 和 56 之间的任何值，你只需更改键值，操作完成即可。但是，如果你将它更改为大于父节点键（56）的任何值，则必须拆分堆并重新合并。这意味着，如果你想将其更改为
    78，在更改键值并拆分堆后，你将得到如[图 15-36](chapter15.xhtml#fig15-36)所示的两个堆。
- en: '![](../images/Figure15-36.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-36.jpg)'
- en: 'Figure 15-36: Changing the 40 to a 78 splits the heap in two.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-36：将 40 更改为 78 会将堆分成两个。
- en: Applying the merging function we’ve looked at previously, [Figure 15-37](chapter15.xhtml#fig15-37)
    shows the final result.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 应用我们之前看过的合并函数，[图 15-37](chapter15.xhtml#fig15-37)展示了最终结果。
- en: '![](../images/Figure15-37.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-37.jpg)'
- en: 'Figure 15-37: Merging results in a single heap again'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-37：合并结果再次形成单一堆
- en: If you had changed the 40 to 58 instead of 78, the result would be different
    (see [Figure 15-38](chapter15.xhtml#fig15-38)). Can you see why?
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 40 改为 58 而不是 78，结果会不同（见[图 15-38](chapter15.xhtml#fig15-38)）。你能看出为什么吗？
- en: '![](../images/Figure15-38.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-38.jpg)'
- en: 'Figure 15-38: An alternative result if you had changed the 40 to 58'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-38：如果你将 40 改为 58 的替代结果
- en: 'Here’s how to code the process:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何编码这个过程：
- en: '[PRE28]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first two if() statements are the same ones you’ve seen before to check
    whether the change is possible. Then, actually change the node’s key ❶ and get
    a pointer to its parent ❷. If there’s a parent and the new node’s key should go
    higher ❸, then you need to act; otherwise, nothing else is needed. If the node
    was the first child of its parent ❹, separate the node from the heap by changing
    the link down from its parent to point to the node’s first sibling. Otherwise,
    if the node isn’t the first child, loop through the siblings list ❺ ❻ ❼ until
    you find the node’s previous sibling. Then unlink the node from the list ❽ ❾ and
    finish by merging the separated heap back into the original ❿. (Similar procedures
    were discussed in [Chapter 7](chapter7.xhtml).)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个 if() 语句是你之前见过的，用来检查是否可以进行更改。然后，实际更改节点的键值 ❶ 并获取指向其父节点的指针 ❷。如果有父节点且新节点的键应该更大
    ❸，那么你需要采取行动；否则，什么都不需要做。如果该节点是其父节点的第一个子节点 ❹，通过更改从父节点指向该节点的链接，分离该节点；否则，如果该节点不是第一个子节点，遍历兄弟列表
    ❺ ❻ ❼，直到找到该节点的前一个兄弟节点。然后将该节点从列表中断开 ❽ ❾，最后将分离出的堆合并回原堆 ❿。（类似的过程在[第 7 章](chapter7.xhtml)中讨论过。）
- en: Considering Performance for Pairing Heaps
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑配对堆的性能
- en: The performance of pairing heaps is similar to that of Fibonacci heaps, as shown
    in [Table 15-6](chapter15.xhtml#tab15-6); values with an asterisk are amortized.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 配对堆的性能类似于斐波那契堆，如[表 15-6](chapter15.xhtml#tab15-6)所示；带星号的值是摊销时间复杂度。
- en: 'Table 15-6: Performance of Operations for Pairing Heaps'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-6：配对堆操作的性能
- en: '| Operation | Performance |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Top | O(1) |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 顶部 | O(1) |'
- en: '| Add | O(1) |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(1) |'
- en: '| Top | O(1) |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 顶部 | O(1) |'
- en: '| Remove | O(log n)* |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | O(log n)* |'
- en: '| Change | O(log n)? |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 改变 | O(log n)? |'
- en: '| Merge | O(1) |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | O(1) |'
- en: Why does changing a value have a question mark in the table? There’s still no
    consensus as to the precise amortized order of this operation. An initial estimate
    suggested it would be *O*(1), but then it was proven to be at least Ω(log log
    *n*). Further work produced an *O*(log *n*) estimate, but no definite proof has
    yet appeared. In any case, this looks worse than Fibonacci heaps, but in practice,
    the performance of pairing heaps is reported to be excellent, despite the purported
    theoretical deficiency, which is most likely a result of the simpler implementation.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么表格中改变值的操作带有问号？目前对于此操作的精确摊销时间复杂度尚无共识。最初的估计认为它是*O*(1)，但后来证明至少是Ω(log log *n*)。进一步的工作得出*O*(log
    *n*)的估计，但尚未有明确的证明。不管怎样，这看起来比斐波那契堆差，但实际上，尽管存在理论上的缺陷，配对堆的性能被报告为非常优秀，这很可能是由于实现更简单所导致的。
- en: '### Summary'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '### 摘要'
- en: In the previous chapter, we studied binary heaps that were represented with
    an array, and in this chapter, we completed our overview of heaps, exploring several
    extended versions that are implemented with binary trees, multiway trees, or forests
    and that allow operations such as merging two heaps and changing a key in a more
    performant way. These changes not only maintained the functionality of the previous
    heaps, but they also added enhanced performance and new features, allowing us
    to use these structures for other types of problems that common heaps wouldn’t
    handle as well. This chapter presents the best example of the possibilities of
    modified (or hybrid, if you will) structures that add speed and functionality—but
    at the obvious cost, clearly, of some more complex algorithms!
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了通过数组表示的二叉堆，在本章中，我们完成了堆的概述，探讨了几种通过二叉树、多路树或森林实现的扩展版本，它们可以更高效地进行合并两个堆和修改关键字等操作。这些改进不仅保持了之前堆的功能，还提升了性能和增加了新特性，让我们可以将这些结构用于一些常规堆无法处理的其他问题。本章展示了修改（或者说是混合）结构的最佳示例，这些结构提高了速度和功能，但显然是以更复杂的算法为代价的！
- en: Questions
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: '**15.1  Intuitive but Worse**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.1  直观但更差**'
- en: 'Suppose you have two common heaps of sizes *m* and *n* and you implement melding
    by applying the following intuitive method: successively choose all the elements
    from one heap and insert them into the other. What would be the order of this
    method?'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个常见堆，大小分别为*m*和*n*，你通过以下直观方法实现合并：依次选择一个堆中的所有元素，并将其插入到另一个堆中。那么，这种方法的时间复杂度是什么？
- en: '**15.2  Sequential Cases**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.2  顺序情况**'
- en: What’s the shape of a skew heap if you insert keys in ascending order? What
    about in descending order?
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按升序插入键值，斜堆的形状会是什么样？如果按降序插入又会如何？
- en: '**15.3  No Recursion Needed**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.3  无需递归**'
- en: When merging two skew heaps and the second had the greater key, no recursion
    was actually needed; could you do the merge directly?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并两个斜堆时，如果第二个堆的关键字较大，实际上并不需要递归；你能直接进行合并吗？
- en: '**15.4  Change Needed**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.4  需要改变**'
- en: How would you implement the changeKey() function for skew heaps? Would you need
    to make some structure changes, and if so, what would they be?
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何为斜堆实现changeKey()函数？你需要做一些结构上的修改吗？如果需要，应该做哪些修改？
- en: '**15.5  Just Adding**'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.5  仅仅是添加**'
- en: Assume you have a binomial heap with only a BT(3) in it, so it has eight values.
    Add a new value to that node eight times and count how many merges are needed.
    What can you conclude about the amortized cost of the operation?
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个二项堆，里面只有一个BT(3)，即包含八个值。将一个新值加入该节点八次，并计算需要多少次合并。你能得出什么结论关于该操作的摊销成本？
- en: '**15.6  Faster Binomial Top**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.6  更快的二项堆顶**'
- en: You can accelerate reaching the top of a binomial heap with means used for other
    heaps; can you figure out how to do so?
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用其他堆的技术加速到达二项堆的顶部；你能想出该怎么做吗？
- en: '**15.7  Easier Bubbling Up?**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.7  更容易的上浮？**'
- en: Why can’t you implement the _bubbleUp() method for binomial trees in the following
    way, similar to what you wrote for binary heaps? (The reason is easy to miss.)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你不能像写二叉堆时那样实现二项树的_bubbleUp()方法？（这个原因很容易忽略。）
- en: '[PRE29]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**15.8  Searching a Heap**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.8  堆的查找**'
- en: Even if it makes little sense, can you implement a find() function for heaps?
    Be careful with Fibonacci heaps, so you don’t create an infinite loop because
    of the circular lists.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这看起来没有太大意义，你能为堆实现一个find()函数吗？注意斐波那契堆，以免由于循环链表而导致无限循环。
- en: '**15.9  Two in One**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.9  一石二鸟**'
- en: In a Fibonacci heap, you can make the add(), remove(), and mergeA2B() methods
    a few lines shorter by joining assignments with the same right value; can you
    see how?
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在斐波那契堆中，通过将相同右值的赋值语句合并，你可以让add()、remove()和mergeA2B()方法稍微短一些；你能看出怎么做吗？
