- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Denial of Service
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝服务攻击
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: DoS issues are one of the most prevalent vulnerability classes in GraphQL today.
    In this chapter, you’ll learn how GraphQL’s declarative query language can also
    become its Achilles’ heel. We’ll identify opportunities to carry out DoS attacks
    that could exhaust server resources if the application developers don’t implement
    effective security countermeasures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: DoS 问题是当今 GraphQL 中最普遍的漏洞类型之一。在本章中，你将学习 GraphQL 的声明式查询语言如何也可能成为它的阿基里斯之踵。我们将识别出如果应用开发者未实现有效的安全防御措施，可能会导致服务器资源耗尽的
    DoS 攻击机会。
- en: While DoS vulnerabilities aren’t often classified as a critical vulnerability
    in penetration testing reports or bounty programs, they’re common enough in GraphQL
    applications that it’s important to become familiar with them, both from an attacker
    standpoint and as a defender.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 DoS 漏洞在渗透测试报告或奖励计划中通常不被归类为关键漏洞，但它们在 GraphQL 应用中足够常见，因此无论是从攻击者的角度，还是作为防御者，都有必要熟悉它们。
- en: GraphQL DoS Vectors
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL DoS 攻击向量
- en: One of GraphQL’s flagship features is its declarative query language, which
    allows clients to request very complex data structures from the server. This capability
    puts the client in a powerful position, because the client can choose the response
    that a server should return. Given this power, GraphQL servers must have the ability
    to protect themselves against malicious queries coming from untrusted clients.
    If a client can construct a query that the server would find expensive to fulfill,
    it could starve the server for resources. Such attacks could impact the availability
    of the application by causing downtime or degrading the server’s performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 的一大亮点功能是其声明式查询语言，允许客户端从服务器请求非常复杂的数据结构。这个功能使客户端处于强势地位，因为客户端可以选择服务器应该返回的响应。鉴于这种能力，GraphQL
    服务器必须具备保护自己免受来自不可信客户端的恶意查询的能力。如果客户端构造出一个服务器处理起来非常昂贵的查询，它可能会耗尽服务器资源。此类攻击可能会通过导致停机或降低服务器性能来影响应用的可用性。
- en: 'In the GraphQL world, several DoS vectors could lead to resource exhaustion
    conditions: circular queries (also known as *recursive queries*), field duplication,
    alias overloading, directive overloading, circular fragments, and object limit
    overriding. In this chapter, you’ll learn about each vulnerability, how to test
    for them during a penetration test, and how to use DoS exploit code to abuse them.
    Toward the end of the chapter, we’ll discuss the security controls that attempt
    to mitigate some of these threats.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 的世界中，几个 DoS 向量可能会导致资源耗尽的情况：循环查询（也称为 *递归查询*）、字段重复、别名重载、指令重载、循环片段和对象数量限制覆盖。在本章中，你将了解每种漏洞、如何在渗透测试中测试它们，以及如何使用
    DoS 利用代码来滥用它们。在章节的最后，我们将讨论试图缓解这些威胁的安全控制措施。
- en: 'The *Common Weakness Enumeration (CWE)* system categorizes these types of DoS
    vectors as *Uncontrolled Resource Consumption*. The abuse of these vectors might
    result in excessive consumption of central processing unit (CPU) cycles, significant
    server memory usage, or the filling up of the disk space, which could prevent
    other processes from writing to the filesystem. The following are a few examples
    of how a client could craft queries to trigger these conditions:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*常见弱点枚举（CWE）*系统将这些类型的 DoS 攻击向量归类为 *无控制的资源消耗*。滥用这些向量可能导致过度消耗中央处理器（CPU）周期、显著的服务器内存使用，或填满磁盘空间，从而阻止其他进程写入文件系统。以下是一些示例，说明客户端如何构造查询以触发这些条件：'
- en: The client sends a single request containing one complex query.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端发送一个包含一个复杂查询的单一请求。
- en: The client sends a single request containing multiple complex queries.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端发送一个包含多个复杂查询的单一请求。
- en: The client sends multiple parallel requests, each containing a single complex
    query.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端发送多个并行请求，每个请求包含一个复杂查询。
- en: The client sends multiple parallel requests, each containing multiple complex
    queries.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端发送多个并行请求，每个请求包含多个复杂的查询。
- en: The client requests a large number of objects from the server.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端向服务器请求大量对象。
- en: Certain DoS vectors are possible partially because of add-on features in some
    GraphQL implementations, introduced either as part of the base installation package
    or as additional libraries, while other vectors exist in native GraphQL capabilities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 DoS 向量的出现，部分原因是一些 GraphQL 实现中引入的附加功能，这些功能可能作为基础安装包的一部分或作为附加库引入，而其他向量则存在于原生的
    GraphQL 功能中。
- en: Circular Queries
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环查询
- en: Also known as *recursive queries*, *circular queries* occur when two nodes in
    a GraphQL schema are bidirectionally referenced using an edge. This circular reference
    could allow a client to build a complex query that forces the server to return
    an exponentially large response each time the query completes a “circle.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为*递归查询*，*循环查询*发生在GraphQL架构中的两个节点通过边相互引用时。这种循环引用可能导致客户端构建复杂的查询，每次查询完成一个“循环”时，服务器返回一个指数级增长的响应。
- en: In this section, we’ll dive into circular relationships and what they look like
    in a GraphQL schema. We’ll use multiple tools, such as the schema visualizer GraphQL
    Voyager, Altair, InQL, and GraphQL Cop to identify risky design patterns and test
    our target application for these vulnerabilities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨循环关系以及它们在GraphQL架构中的表现方式。我们将使用多种工具，如架构可视化工具GraphQL Voyager、Altair、InQL和GraphQL
    Cop，来识别有风险的设计模式，并测试我们的目标应用程序是否存在这些漏洞。
- en: Circular Relationships in GraphQL Schemas
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL架构中的循环关系
- en: GraphQL’s SDL allows us to define multiple types to represent an application’s
    data model. These types can be interconnected in such a way that allows a client
    to “jump” from one type to another if they are linked together. This condition
    is called a *circular relationship* or a *circular reference*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL的SDL允许我们定义多个类型来表示应用程序的数据模型。这些类型可以以某种方式互相连接，使得客户端可以在它们之间“跳跃”，如果它们是相互链接的。这种条件被称为*循环关系*或*循环引用*。
- en: 'For example, in earlier chapters, we mentioned that the DVGA target application
    allows users to create code snippets (called *pastes*) and upload them to the
    application. A single paste might contain a title and some content (like code
    or other arbitrary text). In GraphQL’s SDL, this information can be represented
    in the following way:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的章节中，我们提到DVGA目标应用程序允许用户创建代码片段（称为*粘贴*）并将其上传到应用程序中。一个粘贴可能包含标题和一些内容（如代码或其他任意文本）。在GraphQL的SDL中，这些信息可以按以下方式表示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This information is pretty limited as it stands. What if we want to extend our
    application so that when a client uploads a paste to the application, we can identify
    which client did so? For example, we could capture some metadata about the uploader,
    such as their IP address or User-Agent string.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这些信息是相当有限的。如果我们想扩展我们的应用程序，使得当客户端上传粘贴内容时，我们能够识别是哪一个客户端上传的呢？例如，我们可以捕获一些关于上传者的元数据，如他们的IP地址或用户代理字符串。
- en: 'Currently, our data model isn’t structured in a way that allows us to represent
    this type of information in the API, but extending it is a fairly easy process.
    We could add additional fields to the `Paste` object in the following way:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的数据模型并没有按照允许在API中表示这种类型信息的方式进行结构化，但扩展它是一个相对简单的过程。我们可以通过以下方式向`Paste`对象添加额外的字段：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another way to structure the SDL to accomplish this goal is to decouple the
    client metadata from the `Paste` object. We might want to do this for multiple
    reasons, such as for better separation of concerns and the ability to extend GraphQL
    types independently of one another. We could create a separate type, called `Owner`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现这一目标的方式是将客户端的元数据与`Paste`对象解耦。我们可能会出于多个原因选择这样做，比如更好地分离关注点，以及能够独立扩展GraphQL类型。我们可以创建一个单独的类型，叫做`Owner`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now have two object types, `Paste` and `Owner`. If we wanted to reveal the
    owner of a given paste, we could link the two types together. We might make a
    schema adjustment such as the following, to add a field named `owner` to the `Paste`
    type that references the `Owner` type:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个对象类型，`Paste`和`Owner`。如果我们想要揭示某个粘贴的所有者，我们可以将这两个类型连接在一起。我们可以做出类似以下的架构调整，为`Paste`类型添加一个名为`owner`的字段，引用`Owner`类型：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now a client could request owner information about a paste, such as the owner’s
    IP address or User-Agent. [Listing 5-1](#listing5-1) shows the complete example
    schema.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端可以请求有关粘贴的所有者信息，比如所有者的IP地址或用户代理。[清单5-1](#listing5-1)展示了完整的示例架构。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 5-1: A circular reference in a schema'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-1：架构中的循环引用
- en: The two object types, `Paste` and `Owner`, have fields that cross-reference
    the other. The `Paste` object type has an `owner` field that references the `Owner`
    object, and the `Owner` type has a `pastes` field that references the `Paste`
    type. This creates a circular condition.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象类型，`Paste`和`Owner`，有相互引用的字段。`Paste`对象类型有一个`owner`字段，引用`Owner`对象，而`Owner`类型有一个`pastes`字段，引用`Paste`类型。这就形成了一个循环条件。
- en: 'A malicious client could cause a recursion by forcing the GraphQL server’s
    function resolver to loop. This could potentially impact the server’s performance.
    The following query example shows what such a circular query looks like:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意客户端可能通过强制 GraphQL 服务器的函数解析器进行循环，从而引发递归。这可能会影响服务器的性能。以下查询示例展示了这样的循环查询是如何呈现的：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This query is simple to execute yet causes an exponentially large response from
    the GraphQL server. The more loops in the query, the larger the response becomes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询执行起来很简单，但会导致 GraphQL 服务器返回一个指数级增长的响应。查询中的循环越多，响应就越大。
- en: Circular relationships are common in GraphQL APIs. While not an anti-pattern
    when it comes to schema design, they should be avoided unless the application
    is able to gracefully handle complex queries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形关系在 GraphQL API 中很常见。在模式设计中，这并不算反模式，但除非应用能够优雅地处理复杂查询，否则应该避免使用。
- en: How to Identify Circular Relationships
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何识别循环关系
- en: Identifying circular queries typically requires insight into the GraphQL schema.
    In white-box penetration tests, we may have access to the SDL files. In black-box
    penetration tests, we may get lucky and find that the application’s developer
    has left introspection enabled.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 识别循环查询通常需要对 GraphQL 模式有深入了解。在白盒渗透测试中，我们可能可以访问 SDL 文件。在黑盒渗透测试中，我们可能会幸运地发现应用程序的开发人员启用了自省功能。
- en: In either case, you should review the schema files for bidirectional relationships
    between objects using static code analysis approaches or by importing the result
    of the introspection query into a schema visualizer such as GraphQL Voyager. Additionally,
    certain dedicated GraphQL security tools, such as InQL, attempt to discover the
    existence of circular relationships in a more dynamic fashion, by discovering
    the schema and analyzing its types and their relationships.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，你都应该使用静态代码分析方法审查模式文件，检查对象之间的双向关系，或通过将自省查询的结果导入到像 GraphQL Voyager 这样的模式可视化工具中来进行分析。此外，某些专门的
    GraphQL 安全工具，如 InQL，尝试以更动态的方式发现循环关系，方法是发现模式并分析其类型及其关系。
- en: Using Schema Definition Language Files
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用模式定义语言文件
- en: Let’s perform a security review of an example SDL file to identify anomalies.
    Consider the schema file in the book’s GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/sdl.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/sdl.graphql).
    This SDL file is a schema representation of DVGA that defines all queries, mutations,
    and subscriptions, which also includes object types and fields.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对一个示例 SDL 文件进行安全审查，以识别异常。请参考书中 GitHub 仓库中的模式文件 [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/sdl.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/sdl.graphql)。这个
    SDL 文件是 DVGA 的模式表示，定义了所有查询、变更和订阅，其中还包括对象类型和字段。
- en: Download the schema file onto your lab machine by copying it and saving it to
    a file named *sdl.graphql*. Then open the file in a text editor to review it.
    Before we highlight where the problems lie, try to spot any relational fields
    that result in bidirectional object relationships.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将模式文件下载到实验室计算机上，方法是将其复制并保存为名为 *sdl.graphql* 的文件。然后在文本编辑器中打开该文件进行查看。在我们强调问题所在之前，尝试找出任何导致双向对象关系的关系字段。
- en: 'The following excerpts show the objects that have bidirectional references:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录展示了具有双向引用的对象：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The schema defines the `owner` field in the `PasteObject` of custom type `OwnerObject`
    ❶. Then it defines the `paste` field of type `[PasteObject]` ❷. The square brackets
    in `[PasteObject]` indicate an array of objects of type `PasteObject`. As you
    can see, these objects cross-reference each other, and clients using these types
    could potentially abuse them for DoS purposes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 模式定义了 `PasteObject` 中 `owner` 字段的自定义类型 `OwnerObject` ❶。然后定义了类型为 `[PasteObject]`
    的 `paste` 字段 ❷。`[PasteObject]` 中的方括号表示 `PasteObject` 类型的对象数组。如你所见，这些对象相互交叉引用，使用这些类型的客户端可能会滥用它们进行拒绝服务攻击（DoS）。
- en: Using GraphQL Voyager
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 GraphQL Voyager
- en: Small SDL files are easy to review. The larger an SDL file is, the more challenging
    it becomes to identify anti-patterns and manually audit for security issues. Let’s
    visualize a schema, a technique that could assist us during audits of larger applications
    with more complex schema definitions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 小型 SDL 文件易于审查。SDL 文件越大，识别反模式和手动审计安全问题就越具挑战性。让我们可视化一个模式，这个技巧可以在审计更大且更复杂的模式定义时提供帮助。
- en: Upload the SDL file you downloaded earlier to GraphQL Voyager (hosted on [http://lab.blackhatgraphql.com:9000](http://lab.blackhatgraphql.com:9000)
    or, alternatively, [https://ivangoncharov.github.io/graphql-voyager](https://ivangoncharov.github.io/graphql-voyager))
    by clicking the **Change Schema** button and copying the SDL file into the box
    under the **SDL** tab. [Figure 5-1](#figure5-1) shows how Voyager illustrates
    the circular reference between the `PasteObject` and `OwnerObject` objects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将你之前下载的 SDL 文件上传到 GraphQL Voyager（托管在 [http://lab.blackhatgraphql.com:9000](http://lab.blackhatgraphql.com:9000)
    或者 [https://ivangoncharov.github.io/graphql-voyager](https://ivangoncharov.github.io/graphql-voyager)）中，通过点击
    **更改模式** 按钮并将 SDL 文件复制到 **SDL** 标签下的框中。[图 5-1](#figure5-1) 显示了 Voyager 如何展示 `PasteObject`
    和 `OwnerObject` 之间的循环引用关系。
- en: '![](image_fi/502840c05/f05001.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c05/f05001.png)'
- en: 'Figure 5-1: Object relationships in GraphQL Voyager'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：GraphQL Voyager 中的对象关系
- en: GraphQL Voyager highlights custom object types, such as `OwnerObject` and `PasteObject`,
    and uses arrows to indicate object relationships. When you identify such a relationship,
    assume the application is vulnerable until you’ve performed a test to check its
    ability to protect against circular queries.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL Voyager 会高亮显示自定义对象类型，如 `OwnerObject` 和 `PasteObject`，并使用箭头指示对象关系。当你识别到这种关系时，假设该应用程序存在漏洞，直到你执行测试来检查其防止循环查询的能力。
- en: You can also paste the introspection response output in Voyager to generate
    the same visual representation of the schema, as we did in earlier chapters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 Voyager 中的 introspection 响应输出粘贴进去，以生成与之前章节相同的模式可视化表示。
- en: Using InQL
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 InQL
- en: Another way to identify circular queries is with the InQL security auditing
    tool. We installed InQL in our lab in Chapter 2. One of InQL’s main features is
    its ability to automatically detect circular relationships. InQL can read JSON
    files generated by an introspection query via the command line. Alternatively,
    it can directly send an introspection query to the target GraphQL server if it
    supports Introspection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 识别循环查询的另一种方法是使用 InQL 安全审计工具。我们在第 2 章中已在实验中安装了 InQL。InQL 的主要功能之一是能够自动检测循环关系。InQL
    可以通过命令行读取由 introspection 查询生成的 JSON 文件。或者，如果目标 GraphQL 服务器支持 Introspection，它也可以直接发送
    introspection 查询。
- en: Let’s run an introspection query using Altair. We’ll save the response to a
    JSON file on our filesystem so InQL can read it, parse it, and traverse the schema
    to find circular relationships.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Altair 运行一个 introspection 查询。我们将把响应保存为 JSON 文件存储在我们的文件系统中，这样 InQL 就可以读取、解析并遍历模式，查找循环关系。
- en: In your lab machine, open Altair and set the URL in the address bar to ***http://localhost:5013/graphql***.
    Copy the introspection query located at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt)
    and paste it into Altair ([Figure 5-2](#figure5-2)). Then click **Send Request**
    to send the query to DVGA.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的实验机上，打开 Altair，并将地址栏中的 URL 设置为 ***http://localhost:5013/graphql***。复制位于 [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt)
    的 introspection 查询，并将其粘贴到 Altair 中（[图 5-2](#figure5-2)）。然后点击 **发送请求** 将查询发送到 DVGA。
- en: '![](image_fi/502840c05/f05002.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c05/f05002.png)'
- en: 'Figure 5-2: An introspection query in Altair'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：Altair 中的 introspection 查询
- en: Once a successful response is returned, download the response in JSON format
    by clicking the **Download** button at the bottom-right corner of Altair. Save
    the file as *introspection_query.json* under the home folder */home/kali*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功返回响应，点击 Altair 右下角的 **下载** 按钮，将响应以 JSON 格式下载。将文件保存为 *introspection_query.json*，并存储在主文件夹
    */home/kali* 下。
- en: 'Next, open the terminal. To execute the circular query check, we’ll pass three
    flags to InQL: the `-f` flag, to use the JSON file we downloaded; the `--generate-cycles`
    flag, to perform the circular query detection check; and the `-o` flag, to write
    the output to a dedicated folder. The following command combines these flags to
    perform the circular query detection:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开终端。为了执行循环查询检查，我们将传递三个标志给 InQL：`-f` 标志，用于使用我们下载的 JSON 文件；`--generate-cycles`
    标志，用于执行循环查询检测检查；以及 `-o` 标志，用于将输出写入指定的文件夹。以下命令将这些标志组合起来执行循环查询检测：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After the check is complete, you’ll notice that a *dvga_cycles* folder was
    created by InQL. Within this folder, look for a text file that starts with the
    word *cycles*; this file will contain the result of the script’s execution. You
    can run this command to see the outcome of the check:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 检查完成后，你会注意到InQL创建了一个*dvga_cycles*文件夹。在此文件夹中，寻找一个以*cycles*为开头的文本文件；该文件将包含脚本执行的结果。你可以运行以下命令查看检查结果：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'InQL was able to find paths in the schema where a circular relationship exists
    between the `PasteObject` and `OwnerObject` nodes. Under the hood, InQL traversed
    the JSON file using two main graph algorithms:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: InQL能够在架构中找到存在循环关系的路径，特别是在`PasteObject`和`OwnerObject`节点之间。在背后，InQL通过两种主要的图算法遍历JSON文件：
- en: The *Tarjan algorithm*, named after its inventor Robert Tarjan, is used to find
    circular relationships in graphs in which nodes are connected by edges and each
    edge has a direction associated with it.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Tarjan算法*，以其发明者Robert Tarjan命名，用于查找图中的循环关系，其中节点通过边连接，每条边都有一个方向。'
- en: The *Johnson algorithm*, named after its inventor Donald B. Johnson, is used
    to find the shortest path between every pair of nodes in a graph.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Johnson算法*，以其发明者Donald B. Johnson命名，用于查找图中每一对节点之间的最短路径。'
- en: 'InQL can also run the same check by connecting directly to the GraphQL API
    and obtaining the introspection information. To do this, use the flag `-t` to
    specify the target:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: InQL还可以通过直接连接到GraphQL API并获取内部信息来运行相同的检查。为此，使用`-t`标志来指定目标：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-t` option allows us to scale this check when we have a list of hosts to
    test. [Listing 5-2](#listing5-2) shows how to add hosts to a file named *hosts.txt*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t`选项允许我们在有多个主机列表需要测试时，扩展此检查。[示例 5-2](#listing5-2)展示了如何将主机添加到名为*hosts.txt*的文件中。'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-2: A file containing target GraphQL servers'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-2：包含目标GraphQL服务器的文件
- en: '[Listing 5-3](#listing5-3) shows how to write a Bash loop to test multiple
    hosts by reading the *hosts.txt* file.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-3](#listing5-3)展示了如何编写一个Bash循环，通过读取*hosts.txt*文件测试多个主机。'
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 5-3: A Bash `for` loop to iterate through the target hosts and run
    InQL against each'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3：一个Bash `for`循环，用于遍历目标主机并对每个主机运行InQL
- en: The `for` loop will read the *hosts.txt* file line by line and assign each line
    to the `host` variable. InQL will then use this variable as its target. This technique
    lets us test dozens of URLs in an automated fashion.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环将逐行读取*hosts.txt*文件，并将每一行分配给`host`变量。InQL将使用这个变量作为目标。这个技术使我们能够以自动化的方式测试多个URL。'
- en: If you attempt to run InQL against large applications, consider using the `--cycles-timeout`
    flag to set a timeout on the circular check. This will ensure that the application
    doesn’t hang while looking for circular queries, if the target schema is of significant
    size.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在大型应用程序上运行InQL，建议使用`--cycles-timeout`标志来设置循环检查的超时时间。这样可以确保在查找循环查询时，如果目标架构较大，应用程序不会挂起。
- en: Circular Query Vulnerabilities
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环查询漏洞
- en: Now that you know how to identify circular queries by using multiple tools,
    let’s see how sending a circular query would impact the DVGA application. We’ll
    craft a special GraphQL query that uses the circular relationship we’ve discovered
    to perform a deeply recursive request.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何通过多种工具识别循环查询，让我们看看发送一个循环查询会如何影响DVGA应用程序。我们将构造一个特别的GraphQL查询，利用我们发现的循环关系，执行一个深度递归请求。
- en: A successful cyclical query will cause heavy load on the server and possibly
    crash it. As a result, testing circular queries can be risky. To be on the safe
    side, we’ll provide both a safe and an unsafe version of a circular query. The
    safe version will have less circularity than the unsafe one, so you can safely
    experiment with it in the lab without crashing the target.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的循环查询会导致服务器负载过重，甚至可能崩溃。因此，测试循环查询可能存在风险。为了安全起见，我们将提供循环查询的安全版和不安全版。安全版的循环性会比不安全版少，因此你可以在实验室中安全地进行实验，而不会导致目标崩溃。
- en: Open Altair and copy in the *safe-circular-query.graphql* file from [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/safe-circular-query.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/safe-circular-query.graphql).
    [Listing 5-4](#listing5-4) shows this query.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Altair并复制来自[https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/safe-circular-query.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/safe-circular-query.graphql)的*safe-circular-query.graphql*文件。[示例
    5-4](#listing5-4)展示了这个查询。
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 5-4: A recursive query in GraphQL'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-4：GraphQL中的递归查询
- en: As the name indicates, *safe-circular-query.graphql* is the safer version of
    a circular query. In this query, we ask for the owners’ names of all pastes on
    the application, except we’re doing so in circles, which exponentially increases
    the number of objects the GraphQL server has to load. Paste the query into Altair
    and run it against the server to prove the concept of circular queries.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，*safe-circular-query.graphql* 是循环查询的更安全版本。在此查询中，我们请求应用程序上所有粘贴的所有者名称，只不过我们是在循环中执行此操作，这会指数级地增加
    GraphQL 服务器需要加载的对象数量。将查询粘贴到 Altair 中，并在服务器上运行它，以证明循环查询的概念。
- en: Circular Introspection Vulnerabilities
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环 introspection 漏洞
- en: A circular relationship exists in GraphQL’s built-in introspection system. Therefore,
    when introspection is enabled, you could potentially have access to a circular
    query right out of the gate.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 内建的 introspection 系统中存在循环关系。因此，当启用 introspection 时，你可能会直接接触到一个循环查询。
- en: 'The introspection system has its own schema, defined in the official GraphQL
    specification document. Here is an excerpt of it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: introspection 系统有其自己的模式，在官方的 GraphQL 规范文档中进行了定义。以下是其中的摘录：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At ❶, the `types` field is defined for the `__Schema` object type. You can see
    that `types` is set to `[__Type!]`, which means that it’s using the `__Type` object
    defined at ❷. The square brackets and exclamation point mean that the `types`
    field will return a non-nullable array of `__Type` objects.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 处，定义了 `__Schema` 对象类型的 `types` 字段。你可以看到 `types` 被设置为 `[__Type!]`，这意味着它使用了在
    ❷ 处定义的 `__Type` 对象。方括号和感叹号表示 `types` 字段将返回一个非空的 `__Type` 对象数组。
- en: The `__Type` object has a `fields` field, set at ❸, of type `[__Field!]`. This
    will return a non-nullable array containing `__Field` objects. At ❹, the `__Field`
    type is defined. This type has a field named `type` at ❺ referencing the `__Type`
    object. As you can see, we have a circular relationship between `__Type.fields`
    and `__Field.type`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`__Type` 对象有一个名为 `fields` 的字段，设置为 ❸，类型为 `[__Field!]`。这将返回一个非空的数组，包含 `__Field`
    对象。在 ❹ 处，定义了 `__Field` 类型。此类型有一个名为 `type` 的字段，位于 ❺，引用了 `__Type` 对象。正如你所看到的，我们在
    `__Type.fields` 和 `__Field.type` 之间有一个循环关系。'
- en: 'You can easily test this circular relationship by running the following query
    with Altair:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Altair 中运行以下查询来轻松测试这种循环关系：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Such circular queries can be fairly easily exploited. While a single query may
    not be able to take down a server, a series of complex queries could have the
    potential to impact it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的循环查询相对容易被利用。虽然单个查询可能无法使服务器崩溃，但一系列复杂的查询有可能会影响服务器的性能。
- en: Circular Fragment Vulnerabilities
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环片段漏洞
- en: 'GraphQL operations can share logic through the use of fragments, as explained
    in Chapter 3. Fragments are defined by the client, and as such, clients can build
    any logic they desire into them. That said, the GraphQL specification documentation
    contains rules about how fragments should be implemented, including this one:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 3 章所述，GraphQL 操作可以通过使用片段共享逻辑。片段由客户端定义，因此客户端可以将其所需的任何逻辑构建到片段中。也就是说，GraphQL
    规范文档包含了有关片段如何实现的规则，包括以下这一条：
- en: The graph of fragment spreads must not form any cycles including spreading itself.
    Otherwise, an operation could infinitely spread or infinitely execute on cycles
    in the underlying data.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 片段传播的图形不能形成任何循环，包括自我传播。否则，某个操作可能会无限传播或在底层数据中无限执行循环。
- en: 'Let’s explore how fragments can be constructed to form a cycle and lead to
    a DoS. In DVGA, run the following query, which uses a fragment named `Start` on
    the object `PasteObject`. The `pastes` field utilizes this fragment using the
    `...Start` syntax:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何构建片段来形成循环并导致拒绝服务（DoS）。在 DVGA 中，运行以下查询，使用名为 `Start` 的片段在 `PasteObject`
    对象上。`pastes` 字段使用 `...Start` 语法来引用此片段：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the query is executed, it returns the `field` and `content` fields of
    `pastes`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询被执行时，它会返回 `pastes` 的 `field` 和 `content` 字段：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, what if we add another fragment named `End` that uses the `Start` fragment,
    and modify the `Start` fragment to use the `End` fragment? An interesting condition
    will occur here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们添加另一个名为 `End` 的片段，它使用了 `Start` 片段，并且修改 `Start` 片段以使用 `End` 片段，会发生什么呢？这里会出现一个有趣的条件：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This condition leads to an infinite execution, just as the GraphQL specification
    suggests. Try experimenting with this query in the lab.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件导致了无限执行，正如 GraphQL 规范所建议的那样。尝试在实验室中对这个查询进行实验。
- en: If you ran the query, you should have seen a pretty immediate crash! You might
    be wondering, are all GraphQL servers vulnerable to this attack? The short answer
    is no, if the GraphQL server is spec compliant. A GraphQL server is supposed to
    reject such queries before they get executed. Still, you never know when you might
    run into a completely custom implementation in a penetration test, so knowing
    about this technique is worthwhile.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了查询，你应该已经看到服务器崩溃了！你可能会想，所有的 GraphQL 服务器都容易受到这种攻击吗？简短的回答是，不是的，如果 GraphQL
    服务器符合规范的话。一个符合规范的 GraphQL 服务器应该在执行查询前拒绝这种类型的查询。不过，你永远不知道在渗透测试中何时会遇到完全定制的实现，因此了解这种技术是值得的。
- en: Field Duplication
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段重复
- en: '*Field duplication* vulnerabilities concern queries that contain repeating
    fields. They are simple to execute, yet less effective than circular queries.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*字段重复*漏洞指的是包含重复字段的查询。它们易于执行，但不如循环查询有效。'
- en: While circular queries are small queries that result in abnormally large responses,
    field duplications are large queries that exhaust the server because of the amount
    of time they take to process and resolve. To effectively abuse GraphQL APIs by
    using field duplications, you must send a constant stream of queries to keep the
    server’s resources continuously busy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然循环查询是小型查询，但它会导致异常大的响应，字段重复则是大型查询，因处理和解析所需的时间会耗尽服务器资源。为了有效地通过使用字段重复来滥用 GraphQL
    API，你必须不断发送查询，以保持服务器资源的持续占用。
- en: Understanding How Field Duplication Works
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解字段重复如何工作
- en: 'To understand how field duplication works, consider the following GraphQL query:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解字段重复如何工作，可以参考以下的 GraphQL 查询：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This query returns the `title` and `content` fields of all pastes in the application.
    When GraphQL receives this query, it will use its query resolvers to provide each
    field requested.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询返回应用程序中所有粘贴的 `title` 和 `content` 字段。当 GraphQL 接收到这个查询时，它将使用查询解析器来提供每个请求的字段。
- en: If we “stuff” additional fields in the query, GraphQL will be forced to resolve
    each field separately. This behavior could introduce additional load on the server,
    cause performance degradation, or completely crash it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在查询中“填充”额外的字段，GraphQL 将被迫分别解析每个字段。这种行为可能会增加服务器的负担，导致性能下降，甚至完全崩溃。
- en: 'The strategy here is fairly simple: choose a field that you think might be
    expensive to resolve, and stuff the query with additional copies of that field’s
    name. [Listing 5-5](#listing5-5) shows an example query.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的策略相当简单：选择一个你认为可能需要较多资源来解析的字段，并将查询填充上该字段名称的额外副本。[列表 5-5](#listing5-5) 展示了一个示例查询。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 5-5: A GraphQL query with repeating fields'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-5：包含重复字段的 GraphQL 查询
- en: 'When a query contains multiple repeating fields, such as in [Listing 5-5](#listing5-5),
    where `content` is repeated five times, you might expect to see the same five
    fields in the response. In reality, GraphQL will consolidate the response and
    display only a single `content` JSON field:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询包含多个重复字段时，像[列表 5-5](#listing5-5) 中那样，其中 `content` 被重复了五次，你可能会期待在响应中看到这五个相同的字段。实际上，GraphQL
    会将响应合并，只显示一个 `content` JSON 字段：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From a client perspective, it might seem like GraphQL is ignoring our repeating
    fields. Fortunately, this is not the case. Through response time analysis, you
    can see the query’s impact on the server. Unless the server has implemented specific
    security defenses, such as query cost analysis (covered later in this chapter),
    you should expect to see these vulnerabilities in most GraphQL implementations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度来看，可能会觉得 GraphQL 忽略了我们重复的字段。幸运的是，事实并非如此。通过响应时间分析，你可以看到查询对服务器的影响。除非服务器已实现特定的安全防御措施，例如查询成本分析（本章后续会介绍），否则你应该期望在大多数
    GraphQL 实现中看到这些漏洞。
- en: Testing for Field Duplication Vulnerabilities
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试字段重复漏洞
- en: To test field duplication attacks in our lab, we’ll write a simple query and
    attempt to repeat a few selected fields to see how our target responds.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的实验室中测试字段重复攻击，我们将编写一个简单的查询，并尝试重复几个选定的字段，看看目标如何响应。
- en: 'Open Altair and ensure that the address bar is set to *http://localhost:5013/graphql*.
    In the left pane, enter the following query, which will serve as a baseline:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Altair，并确保地址栏设置为 *http://localhost:5013/graphql*。在左侧面板中，输入以下查询，它将作为基准：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Click **Send** to query GraphQL. In the response section, you’ll notice that
    Altair provides the total time it took for the server to respond in milliseconds,
    as shown in [Figure 5-3](#figure5-3).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**发送**来查询GraphQL。在响应部分，你会注意到Altair提供了服务器响应所需的总时间（以毫秒为单位），如[图 5-3](#figure5-3)所示。
- en: It took 26 milliseconds for DVGA to respond to the query, which is a normal
    response time. The time you might see in your lab could differ but should be in
    the same ballpark.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: DVGA响应查询的时间为26毫秒，这是一个正常的响应时间。你在实验室中可能看到的时间会有所不同，但应该在同一数量级内。
- en: '![](image_fi/502840c05/f05003.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c05/f05003.png)'
- en: 'Figure 5-3: The Altair response time indicator'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：Altair响应时间指示器
- en: Next, copy the query from [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/field-duplication.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/field-duplication.graphql),
    paste it into Altair, and run it. This query contains approximately 1,000 `content`
    fields. [Figure 5-4](#figure5-4) shows that processing this query took 958 milliseconds,
    which is 36 times slower!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，复制来自[https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/field-duplication.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/field-duplication.graphql)的查询，将其粘贴到Altair中并运行。该查询包含大约1,000个`content`字段。[图
    5-4](#figure5-4)显示，处理此查询需要958毫秒，比正常慢了36倍！
- en: '![](image_fi/502840c05/f05004.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c05/f05004.png)'
- en: 'Figure 5-4: A slower response time to a query with repeating fields'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：查询重复字段的响应时间较慢
- en: Some fields will require more resources to resolve, so the performance impact
    might vary depending on the chosen field.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有些字段在解析时需要更多的资源，因此性能影响可能会根据选择的字段而有所不同。
- en: This attack requires the client to continuously send large payloads. Attempting
    to manually exploit field duplication can be cumbersome. As an alternative method,
    you can use a special Python exploit that attempts to perform a field duplication
    attack at a far larger scale. [Listing 5-6](#listing5-6) shows a snippet of such
    an exploit. It sends a continuous stream of queries to a remote server in order
    to exhaust its resources.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个攻击要求客户端不断发送大型有效载荷。试图手动利用字段重复可能会很麻烦。作为一种替代方法，你可以使用一个特殊的Python漏洞，尝试在更大规模上执行字段重复攻击。[清单
    5-6](#listing5-6)展示了这种漏洞的代码片段。它向远程服务器发送连续的查询流，以消耗其资源。
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-6: A field duplication exploit'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-6：字段重复漏洞
- en: 'This code creates a dynamic `payload` variable ❶ with two duplicated fields:
    `content` and `title`. Each is repeated 1,000 times. At ❷ it concatenates the
    payload with the `query` JSON variable. It then defines a function named `DoS`
    that is responsible for sending the HTTP POST request containing our malicious
    GraphQL query ❸. We run an infinite `while` loop that executes the `DoS` function
    using 50 threads every two seconds ❹. The full exploit code can be found on GitHub
    at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_threaded_field_dup.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_threaded_field_dup.py).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个动态的`payload`变量❶，其中包含两个重复的字段：`content`和`title`，每个字段重复了1,000次。在❷处，它将`payload`与`query`
    JSON变量连接起来。然后，它定义了一个名为`DoS`的函数，负责发送包含我们恶意GraphQL查询的HTTP POST请求❸。我们运行一个无限的`while`循环，每两秒执行一次`DoS`函数，使用50个线程❹。完整的漏洞代码可以在GitHub上找到，链接为[https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_threaded_field_dup.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_threaded_field_dup.py)。
- en: 'You can download this exploit and run it against DVGA with the following command.
    Keep in mind that performance could degrade on your machine while it is running:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以下载这个漏洞，并使用以下命令在DVGA上运行它。请注意，在运行时，你的机器可能会出现性能下降：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since the exploit uses an infinite loop, it won’t stop its operations on its
    own; you can halt it by pressing CTRL-C to send the *SIGINT* signal.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该漏洞使用了无限循环，它不会自行停止；你可以通过按下CTRL-C发送*SIGINT*信号来终止它。
- en: Alias Overloading
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名重载
- en: In Chapter 3, you learned how to use aliases to rename duplicate fields so that
    the GraphQL server treats them as two different queries. The ability to run multiple
    queries in a single HTTP request is quite powerful. Security analysts could easily
    overlook these single requests when hunting for suspicious traffic (as could WAFs).
    After all, they might think, what harm can a single HTTP request possibly cause?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，你学习了如何使用别名重命名重复的字段，以便GraphQL服务器将它们视为两个不同的查询。在单个HTTP请求中运行多个查询的能力非常强大。安全分析人员在寻找可疑流量时很容易忽视这些单独的请求（WAF也可能忽视）。毕竟，他们可能会想，一个单一的HTTP请求能造成什么
    harm 呢？
- en: By default, GraphQL servers won’t limit the number of aliases that can be used
    in a single request. The GraphQL application maintainer could implement custom
    protections, such as counting the aliases and restricting them in some middleware,
    but since aliases are part of the specification, it’s uncommon to remove support
    for them or limit their functionality.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，GraphQL 服务器不会限制单个请求中可以使用的别名数量。GraphQL 应用程序的维护者可以实施自定义保护措施，例如计数别名并在某些中间件中限制它们，但由于别名是
    GraphQL 规范的一部分，因此删除对它们的支持或限制其功能并不常见。
- en: Abusing Aliases for Denial of Service
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用别名进行拒绝服务攻击
- en: When performing a penetration test, you may run into queries that seem to take
    the server longer to process than others. If you identify such a query, you can
    hog system resources by calling the same query over and over again. If the server
    struggles to quickly return a response, flooding the server with the same query
    could result in system overload.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行渗透测试时，你可能会遇到处理时间比其他查询长的查询。如果你识别出这样的查询，可以通过反复调用相同的查询来占用系统资源。如果服务器难以快速返回响应，持续用相同查询淹没服务器可能会导致系统超载。
- en: 'In DVGA, one specific query is slower than others: `systemUpdate`. This query
    is designed to simulate long-running commands, such as those that perform system
    updates. Unauthorized clients should never be allowed to perform queries that
    change system state, but nothing is impossible in real-life penetration testing
    scenarios! Let’s run the `systemUpdate` query in Altair to see how long this command
    takes to fully process. It takes no arguments, as shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DVGA 中，有一个特定的查询比其他查询要慢：`systemUpdate`。该查询旨在模拟长期运行的命令，例如执行系统更新的命令。未经授权的客户端永远不应被允许执行更改系统状态的查询，但在真实的渗透测试场景中，没有什么是不可能的！让我们在
    Altair 中运行 `systemUpdate` 查询，看看此命令完全处理需要多长时间。它不需要任何参数，如下所示：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Send this query to the server and observe the time it takes for the server to
    return a response ([Figure 5-5](#figure5-5)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将此查询发送到服务器，并观察服务器返回响应所需的时间（[图 5-5](#figure5-5)）。
- en: '![](image_fi/502840c05/f05005.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c05/f05005.png)'
- en: 'Figure 5-5: The `systemUpdate` query response time'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5：`systemUpdate` 查询响应时间
- en: The `systemUpdate` took 50,361 milliseconds to complete. That’s around 50 seconds,
    a significant amount of time by today’s web standards. This is an example of a
    query that we might be able to leverage for DoS purposes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemUpdate` 查询花费了 50,361 毫秒完成，大约 50 秒，这在今天的 Web 标准下是相当长的时间。这是我们可能利用来进行拒绝服务（DoS）攻击的查询示例。'
- en: Using GraphQL aliases, we can attempt to run `systemUpdate` a few times to see
    how the server behaves. [Listing 5-7](#listing5-7) shows how you can run `systemUpdate`
    more than once, using aliases.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GraphQL 别名，我们可以尝试多次运行 `systemUpdate` 以观察服务器的行为。[列表 5-7](#listing5-7) 显示了如何使用别名运行多次
    `systemUpdate`。
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 5-7: Aliasing the `systemUpdate` query'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-7：别名化 `systemUpdate` 查询
- en: Running this query in Altair should take longer than normal to complete.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Altair 中运行此查询应该会比正常情况更长时间完成。
- en: If you need to generate hundreds of queries, you can use a short Python script
    in the terminal to craft a query programmatically, as shown in [Listing 5-8](#listing5-8).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要生成数百个查询，可以在终端中使用简短的 Python 脚本以编程方式构建查询，如[列表 5-8](#listing5-8)所示。
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 5-8: Generating aliases with Python'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-8：使用 Python 生成别名
- en: 'Remember: there are no limits to the number of aliases a client can provide
    by default, unless the application maintainer has implemented specific protections
    against these types of attacks or the web server has set HTTP body length limits.
    That means we could specify dozens of aliases and hog server resources in a single
    HTTP request.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住：默认情况下，客户端提供的别名数量没有限制，除非应用程序维护者已针对这些类型的攻击实施了特定保护措施，或者 Web 服务器设置了 HTTP 请求体长度限制。这意味着我们可以在单个
    HTTP 请求中指定数十个别名并占用服务器资源。
- en: Other interesting, non-DoS use cases exist for aliases when it comes to penetration
    testing, such as defeating authentication mechanisms. You’ll learn more about
    those in Chapter 7.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中，别名还有其他有趣的非拒绝服务（DoS）用途，例如绕过认证机制。你将在第7章中学习更多相关内容。
- en: Chaining Aliases and Circular Queries
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链式别名与循环查询
- en: Since aliases are part of the GraphQL specification, any other vulnerability
    you identify can be combined with aliases. The query in [Listing 5-9](#listing5-9)
    shows how we can run a circular query with an alias.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于别名是 GraphQL 规范的一部分，任何你识别出的其他漏洞都可以与别名结合使用。[列表 5-9](#listing5-9) 中的查询展示了如何使用别名运行循环查询。
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 5-9: Circular queries with aliases'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-9：带有别名的循环查询
- en: This query is not recursive enough to cause any harm to a GraphQL server, but
    it illustrates the possibility of making more than one circular query in a single
    GraphQL document.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的递归性不足，不足以对GraphQL服务器造成任何危害，但它展示了在单个GraphQL文档中进行多个循环查询的可能性。
- en: The disadvantage of aliases is that they allow aliasing only queries of the
    same root type. You can alias queries only with queries, or mutations only with
    mutations, but not queries and mutations together.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 别名的缺点在于它们只允许别名相同根类型的查询。你只能将查询与查询别名，或将突变与突变别名，但不能将查询和突变一起别名。
- en: Directive Overloading
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令重载
- en: 'Chapter 3 covered GraphQL directives, which are a way to decorate a field or
    object in GraphQL by using the at (`@`) symbol. While directives are part of the
    GraphQL specification, the specification does not discuss security controls that
    should be implemented for directives. In general, GraphQL implementations check
    whether the client repeats a query directive; if so, the server rejects the query.
    Typical checks on directives are the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章介绍了GraphQL指令，它们是通过使用@符号装饰GraphQL字段或对象的一种方式。尽管指令是GraphQL规范的一部分，但该规范并未讨论应为指令实现的安全控制。通常，GraphQL实现会检查客户端是否重复了查询指令；如果是，服务器会拒绝该查询。指令的典型检查包括：
- en: '`UniqueDirectivesPerLocation` ensures that unique directives are in each document
    location, such as a field.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UniqueDirectivesPerLocation`确保每个文档位置（例如字段）中只有唯一的指令。'
- en: '`UniqueDirectiveNames` ensures that directives have unique names if more than
    one is supplied in a location such as a field.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UniqueDirectiveNames`确保如果在像字段这样的某个位置提供了多个指令，则这些指令具有唯一的名称。'
- en: However, nonexistent queries can be supplied many times. There are effectively
    no limits to the number of nonexistent directives a client can supply in most
    of the popular GraphQL implementations today.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以多次提供不存在的查询。在今天大多数流行的GraphQL实现中，客户端提供的不存在的指令数量实际上没有限制。
- en: Our research has shown that it’s possible to exhaust GraphQL servers’ query
    parsers by passing a large number of nonexistent directives in a single query.
    During our responsible disclosure process for this directive overloading vulnerability,
    we engaged with multiple GraphQL developers on the matter. Opinions on whether
    it’s the maintainers’ or consumers’ responsibility to address the flaw varied
    quite a bit. Companies that were part of the disclosure process and chose to address
    it did so by limiting the number of directives a server will accept or blocking
    the query based on its HTTP request body’s size.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的研究表明，通过在单个查询中传递大量不存在的指令，可能会耗尽GraphQL服务器的查询解析器。在我们对这个指令重载漏洞的负责任披露过程中，我们与多位GraphQL开发者进行了交流。关于是由维护者还是消费者来解决该漏洞，意见有很大分歧。参与披露过程并选择解决此问题的公司，通过限制服务器接受的指令数量或根据HTTP请求体的大小阻止查询来解决此问题。
- en: Abusing Directives for Denial of Service
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滥用指令进行拒绝服务攻击
- en: The directive overloading vulnerability is somewhat similar to field duplication
    in that it requires us to send many directives via several continuous requests.
    Despite requiring more computing power than a vulnerability like circular queries,
    we’ve found it to be effective at degrading the server’s performance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 指令重载漏洞有点类似于字段重复，它需要我们通过多个连续请求发送许多指令。尽管比循环查询等漏洞需要更多的计算能力，但我们发现它在降低服务器性能方面非常有效。
- en: 'The attack is quite simple: stuff directives in multiple parts of a query and
    send it to the server, as shown in [Listing 5-10](#listing5-10).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击非常简单：将指令塞入查询的多个部分并发送到服务器，如[列表5-10](#listing5-10)所示。
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 5-10: An example of directive overloading'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5-10：指令重载的示例
- en: The impact on the server can vary depending on its hardware specifications.
    We’ve seen different server behaviors when using this exploitation technique,
    such as GraphQL server crashes (due to database memory errors) or service performance
    degradation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对服务器的影响可能会根据其硬件规格有所不同。我们在使用此利用技术时见过不同的服务器行为，例如GraphQL服务器崩溃（由于数据库内存错误）或服务性能下降。
- en: Testing for Directive Overloading
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试指令重载
- en: The exploit in the book’s GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_directive_overloading.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_directive_overloading.py)
    abuses this type of vulnerability and can be used against DVGA to perform a directive
    overloading attack.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本书 GitHub 仓库中的攻击代码 [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_directive_overloading.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_directive_overloading.py)
    利用这种漏洞，并可以用来对 DVGA 执行指令重载攻击。
- en: At any point while running this script, you can halt its operation by pressing
    CTRL-Cto send the *SIGINT* signal. Note that while the script is running, DVGA
    will likely be slow or unresponsive.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此脚本的任何时刻，你都可以按下 CTRL-C 来终止其操作，发送 *SIGINT* 信号。请注意，当脚本运行时，DVGA 可能会变得缓慢或无响应。
- en: 'The following command runs the exploit from the command line:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令在命令行中运行攻击：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Listing 5-11](#listing5-11) shows the main exploit code.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-11](#listing5-11) 显示了主要的攻击代码。'
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 5-11: The exploit code to abuse the directive overloading vulnerability'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-11：利用指令重载漏洞的攻击代码
- en: The exploit takes two arguments from the command line, one to identify the target
    API and the other for the number of directives that will be stuffed into the query
    during exploitation. As part of the `start_attack` function, we multiply the `dos`
    directive by the number of directives provided. We then build the GraphQL query
    that will use the malicious payload and create 300 threads, each running the `start_attack`
    function in parallel. This keeps the server resources busy for as long as the
    exploit is running by using an infinite `while` loop.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击代码从命令行接收两个参数，一个用于识别目标 API，另一个用于指定在攻击过程中将塞入查询中的指令数量。作为 `start_attack` 函数的一部分，我们将
    `dos` 指令乘以提供的指令数量。然后，我们构建一个 GraphQL 查询，使用恶意载荷，并创建 300 个线程，每个线程并行运行 `start_attack`
    函数。通过使用无限的 `while` 循环，这会使服务器资源在攻击运行期间保持忙碌。
- en: Object Limit Overriding
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象限制覆盖
- en: 'GraphQL servers can implement limits on the amount of data they return to a
    client by default. This is especially important for fields that return arrays.
    For example, recall that, in DVGA, the `pastes` query returns an array of paste
    objects:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 服务器可以默认实现对返回给客户端的数据量的限制。这对于返回数组的字段尤为重要。例如，回想一下，在 DVGA 中，`pastes` 查询返回一个粘贴对象数组：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The exclamation mark means that `pastes` is non-nullable, so the array must
    have zero or more items. Unless the query is explicitly limited, GraphQL will
    return all objects in response to a request for `pastes`. If the database has
    10,000 objects, for example, GraphQL could return all 10,000.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 感叹号表示 `pastes` 是不可为空的，因此数组必须包含零个或多个项目。除非查询被显式限制，否则 GraphQL 会返回所有 `pastes` 对象。如果数据库中有
    10,000 个对象，例如，GraphQL 可能会返回所有 10,000 个对象。
- en: A response containing 10,000 objects is a lot of data for the server (and client)
    to process. Servers could implement logic to limit the number of returned objects
    to a more restricted number, such as 100\. For example, they might sort objects
    by their creation time and return only the most recent pastes. This filtering
    can happen at the database level, the GraphQL level, or both.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含 10,000 个对象的响应对于服务器（和客户端）来说是大量数据。服务器可以实现逻辑来限制返回对象的数量，限制为更少的数量，比如 100。例如，服务器可能会按创建时间对对象进行排序，并只返回最新的粘贴。这种过滤可以在数据库层、GraphQL
    层，或两者同时进行。
- en: 'Some GraphQL applications may allow a client to override this server-side object
    limit by passing a special argument such as `limit`, as in this example. Go ahead
    and run this query in Altair:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 GraphQL 应用可能允许客户端通过传递特殊参数（如 `limit`）来覆盖服务器端的对象限制，正如这个例子所示。继续在 Altair 中运行这个查询：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When executing this query, GraphQL could convert it to a SQL query behind the
    scenes, as shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个查询时，GraphQL 可能会在后台将其转换为 SQL 查询，如下所示：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: On a small-scale database such as DVGA’s, this won’t do a whole lot of harm.
    However, on very large databases, controlling the number of rows a server returns
    could be powerful and may allow us to perform database-level DoS.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 DVGA 这样的规模较小的数据库中，这不会造成太大损害。然而，在非常大的数据库中，控制服务器返回的行数可能会非常强大，并且可能让我们执行数据库级别的
    DoS 攻击。
- en: If introspection is enabled, GraphQL will auto-complete arguments as you type
    them, making it easy to discover those that the queries support. If introspection
    is disabled, try common keywords such as `limit`, `offset`, `first`, `after`,
    `last`, `max`, and `total`. These keywords are often associated with *API pagination*,
    a way to control the amount of data returned in HTTP responses. Pagination divides
    a large dataset into smaller parts, which allows the client to both request and
    receive data in chunks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了自省（introspection），GraphQL将在你输入时自动完成参数，使你可以轻松发现查询所支持的参数。如果自省被禁用，可以尝试常见的关键字，如`limit`、`offset`、`first`、`after`、`last`、`max`和`total`。这些关键字通常与*API分页*相关，这是控制HTTP响应中返回数据量的一种方法。分页将大型数据集划分为更小的部分，从而使客户端能够按块请求和接收数据。
- en: It’s worth testing how many objects the server allows a client to request. Having
    the ability to request an arbitrary number of records from the server could become
    another DoS vector in an application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 测试服务器允许客户端请求多少对象是值得的。能够从服务器请求任意数量的记录可能会成为应用程序中的另一个拒绝服务（DoS）向量。
- en: Array-Based Query Batching
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于数组的查询批量处理
- en: Now we’ll explore a feature that very conveniently allows us to scale the attacks
    you’ve learned about so far. *Query batching* is any method used to group multiple
    queries and send them to the GraphQL API in parallel. Aliases are one form of
    query batching.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探索一个功能，它非常方便地让我们扩大到目前为止你所学到的攻击。*查询批量处理*是将多个查询分组并并行发送到GraphQL API的任何方法。别名就是查询批量处理的一种形式。
- en: While useful, aliases have a clear disadvantage, as they can batch only queries
    that are of the same operation root type. For instance, you can’t alias a mutation
    and a query together. The technique of *array-based batching* allows us to mix
    queries and mutations. However, arrays aren’t part of the specification and therefore
    may not be available to you during all penetration tests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管别名很有用，但它们有一个明显的缺点，因为它们只能批量处理相同操作根类型的查询。例如，你不能将变更（mutation）和查询（query）一起使用别名。*基于数组的批量处理*技术使我们可以混合查询和变更。然而，数组并不是规范的一部分，因此在所有渗透测试中可能无法使用。
- en: Understanding How Array-Based Query Batching Works
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解基于数组的查询批量处理是如何工作的
- en: 'Array-based query batching is a feature that allows a client to send multiple
    GraphQL queries of any root type in an array as part of a JSON payload. Imagine
    that we want to send a query more than once and receive the same response multiple
    times. Using array-based query batching, we can easily do this by essentially
    duplicating this query and adding the copies as elements to an array. Here is
    a pseudo-query example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数组的查询批量处理是一种功能，允许客户端将多个任何根类型的GraphQL查询以数组的形式作为JSON负载的一部分发送。假设我们想多次发送一个查询并多次收到相同的响应。使用基于数组的查询批量处理，我们可以通过基本上复制这个查询并将副本作为元素添加到数组中，轻松做到这一点。以下是一个伪查询示例：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When GraphQL receives an array of queries from a client, it will process them
    sequentially and refrain from returning a response until the very last array element
    is processed and resolved. Once all queries are resolved, it will return a response
    containing an array of all query responses in a single HTTP response.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当GraphQL从客户端接收到一组查询时，它会按顺序处理这些查询，并且在最后一个数组元素处理并解决之前不会返回响应。一旦所有查询解决，它将返回一个响应，其中包含所有查询响应的数组，并以单个HTTP响应返回。
- en: 'Your hacker senses might be kicking in at this very moment, because there is
    a clear risk here. It’s assumed that the client will send a reasonable number
    of queries in an array. But what happens if a client sends thousands of queries
    in a single array instead? Let’s find out. Spoiler: bad things will happen.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能此刻就已经产生了黑客直觉，因为这里存在明显的风险。假设客户端将发送一个合理数量的查询在数组中。但是，如果客户端在一个数组中发送了成千上万的查询会发生什么呢？让我们来看看。剧透：会发生不好的事情。
- en: As with aliasing, identifying the abuse of array-based batch queries can be
    difficult, because all a security analyst will see in their logs is a single HTTP
    request. This may not immediately stand out as a malicious pattern. Thus, this
    technique could circumvent traditional rate-limiting controls, which may restrict
    clients to a certain number of requests per second (RPS) or requests per minute
    (RPM).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与别名类似，识别基于数组的批量查询滥用可能很困难，因为安全分析员在日志中看到的只是一个单独的HTTP请求。这可能不会立刻显现为恶意模式。因此，这种技术可能会绕过传统的速率限制控制，这些控制可能会限制客户端每秒（RPS）或每分钟（RPM）的请求数。
- en: At the end of the chapter, we’ll discuss some potential mitigations for batched
    queries an application could implement.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将讨论应用程序可以实施的一些潜在缓解措施，以应对批量查询。
- en: Testing for Array-Based Query Batching
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试基于数组的批量查询
- en: GraphQL IDEs such as Altair, GraphQL Playground, and GraphiQL Explorer do not
    support array-based queries directly from the interface. So, to test whether array-based
    query batching is enabled on the DVGA, we’ll need to use an HTTP client such as
    cURL or a scripting language such as Python. We’ll show how to use both methods
    in our lab.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Altair、GraphQL Playground 和 GraphiQL Explorer 这样的 GraphQL IDE 不支持从界面直接进行基于数组的查询。因此，为了测试
    DVGA 是否启用了基于数组的批量查询，我们需要使用 HTTP 客户端，如 cURL，或者使用脚本语言，如 Python。在我们的实验中，我们将展示如何使用这两种方法。
- en: Using cURL
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 cURL
- en: The command in [Listing 5-12](#listing5-12) sends an array of queries using
    cURL.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-12](#listing5-12) 中的命令使用 cURL 发送一个查询数组。'
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5-12: Array-based batch queries using cURL'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-12：使用 cURL 的基于数组的批量查询
- en: In this cURL command, we’re using the `-d` flag to send an array of GraphQL
    queries to the server. The array, which is defined using square brackets `[]`,
    surrounds two similar GraphQL queries. In each query, we’re using the `systemHealth`
    object. The GraphQL server returns two separate responses.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 cURL 命令中，我们使用 `-d` 标志向服务器发送一个包含 GraphQL 查询的数组。这个数组使用方括号 `[]` 定义，包含两个相似的
    GraphQL 查询。在每个查询中，我们使用 `systemHealth` 对象。GraphQL 服务器会返回两个单独的响应。
- en: Sending an array containing two GraphQL queries will result in an equal number
    of query responses if the GraphQL server supports array-based query batching.
    You can tell that this is the case by the `data` JSON field we received in the
    response. When the `-d` flag is used, cURL uses the HTTP POST method under the
    hood.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 GraphQL 服务器支持基于数组的批量查询，发送一个包含两个 GraphQL 查询的数组将返回相同数量的查询响应。你可以通过响应中的 `data`
    JSON 字段判断是否是这种情况。当使用 `-d` 标志时，cURL 在后台使用 HTTP POST 方法。
- en: Using Python
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Python
- en: The same query can be performed using Python, as shown in [Listing 5-13](#listing5-13).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Python 执行相同的查询，如 [列表 5-13](#listing5-13) 所示。
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 5-13: Array-based batch queries using Python'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-13：使用 Python 的基于数组的批量查询
- en: We declare a `queries` array containing our two `systemHealth` queries. We then
    send them in a batch to DVGA and print the response. This should return an array
    containing two elements, each of which is a response to a single query. You can
    find this code in the GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_batch_query.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_batch_query.py).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个包含两个 `systemHealth` 查询的 `queries` 数组。然后，我们将它们批量发送到 DVGA，并打印响应。这应返回一个包含两个元素的数组，每个元素都是对单个查询的响应。你可以在
    GitHub 仓库中的 [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_batch_query.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_batch_query.py)
    找到这段代码。
- en: 'Save the file to your desktop and run the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存到桌面并运行以下命令：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'GraphQL servers that don’t support array-based batching may throw HTML errors
    because they don’t implement logic to handle an array payload. Servers that do
    support arrays but have disabled them may return an error such as the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持基于数组批量查询的 GraphQL 服务器可能会抛出 HTML 错误，因为它们没有实现处理数组有效负载的逻辑。支持数组但已禁用它们的服务器可能会返回如下错误：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, we’ll explore how to perform DoS attacks by combining circular queries
    and array-based query batching.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何通过结合循环查询和基于数组的批量查询来执行DoS攻击。
- en: Chaining Circular Queries and Array-Based Query Batching
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接循环查询和基于数组的批量查询
- en: Using circular queries with array-based batching can wreak havoc on a GraphQL
    server and potentially knock it out. Consider the circular query in [Listing 5-14](#listing5-14).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有基于数组的批量查询的循环查询可能会对 GraphQL 服务器造成严重影响，甚至可能使其瘫痪。考虑 [列表 5-14](#listing5-14)
    中的循环查询。
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 5-14: A circular query'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-14：一个循环查询
- en: This recursive query has a depth level of five. On its own, it may not be enough
    to take down the target server, but we could modify it to make it much deeper.
    Each level creates an additional node that a server needs to process and resolve,
    consuming more server resources.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归查询的深度为五。单独来看，它可能不足以摧毁目标服务器，但我们可以修改它，使其深度更大。每一层都会创建一个额外的节点，服务器需要处理和解析这些节点，从而消耗更多的服务器资源。
- en: 'To experiment with circular queries, we’ve coded a custom exploit for your
    arsenal of hacking tools. This exploit can dynamically extend its circularity
    by letting you specify the number of circles that should be performed. The query
    is also capable of batching queries using arrays. The following code is a snippet
    from [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_circular_queries.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_circular_queries.py):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验循环查询，我们为你的黑客工具库编写了一个自定义的漏洞利用脚本。这个漏洞利用脚本可以通过让你指定应执行的循环次数来动态地扩展其循环性。该查询还能够使用数组批量执行查询。以下代码片段来自[https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_circular_queries.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_circular_queries.py)：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This code builds on the query in [Listing 5-14](#listing5-14) by dynamically
    generating a circular query and adding it to an array based on two main script
    inputs: `ARRAY_LENGTH` and `FIELD_REPEAT`. The `ARRAY_LENGTH` is the number of
    queries to be grouped together. A value of `5` means that the array will have
    five queries. `FIELD_REPEAT` indicates the number of times the script will append
    the circular fields (`pastes` and `owner`) into the query.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基于[列表5-14](#listing5-14)中的查询，动态生成循环查询并根据两个主要的脚本输入值：`ARRAY_LENGTH`和`FIELD_REPEAT`，将其添加到数组中。`ARRAY_LENGTH`表示要组合在一起的查询数。值为`5`意味着数组将包含五个查询。`FIELD_REPEAT`表示脚本将循环添加多少次字段（`pastes`和`owner`）到查询中。
- en: The script then uses a `for` loop to construct the query based on the value
    of `FIELD_REPEAT` and assigns it to the `query` variable. We initialize an empty
    array named `queries` and run another `for` loop to add the query we constructed
    into the `queries` array. To put it simply, we construct a circular query, add
    it to an array based on predefined values, and send it to the target.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本使用`for`循环根据`FIELD_REPEAT`的值构建查询，并将其赋值给`query`变量。我们初始化一个空数组`queries`，并运行另一个`for`循环，将我们构建的查询添加到`queries`数组中。简单来说，我们构建一个循环查询，将其添加到数组中，并根据预定义的值发送给目标。
- en: 'We encourage you to run this script in the lab to see how it works! Download
    the script to your lab and set the executable (`+x`) permissions before running
    it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你在实验室中运行这个脚本，看看它是如何工作的！将脚本下载到你的实验室环境中，并在运行前设置可执行权限（`+x`）：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The script will output the query and some information about it, such as the
    number of times the fields were repeated, the depth level of the query, and the
    length of the array sent to the server. You can alter `FIELD_REPEAT` and `ARRAY_LENGTH`
    to see the change in impact on the server’s responsiveness by dynamically growing
    the query and array.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将输出查询及其相关信息，例如字段重复的次数、查询的深度级别以及发送到服务器的数组长度。你可以修改`FIELD_REPEAT`和`ARRAY_LENGTH`，观察通过动态增长查询和数组对服务器响应速度的影响。
- en: There are no magic numbers here; you will want to gradually increase the numbers
    of fields until the target server becomes noticeably slower. Based on our lab
    experiments, setting `FIELD_REPEAT` to at least `500` should result in DVGA crashing
    with a segmentation fault error. In that case, start it up again by following
    the lab setup guidelines in Chapter 2.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么神奇的数字；你需要逐步增加字段的数量，直到目标服务器变得明显更慢。根据我们的实验室实验，将`FIELD_REPEAT`设置为至少`500`应该会导致DVGA崩溃，并出现段错误。在这种情况下，按照第2章的实验室设置指南重新启动它。
- en: Detecting Query Batching by Using BatchQL
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用BatchQL检测查询批量处理
- en: 'Certain GraphQL tools attempt to detect when batching is available on a target
    GraphQL server. For instance, BatchQL is a small Python utility that scans for
    GraphQL weaknesses. It is able to detect both alias-based batching and array-based
    batching by sending a preflight request and observing the errors returned by the
    server. The following code demonstrates the logic it uses to detect array-based
    batching:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 某些GraphQL工具尝试检测目标GraphQL服务器是否支持批量查询。例如，BatchQL是一个小型Python工具，它扫描GraphQL的弱点。通过发送预检请求并观察服务器返回的错误，它能够检测基于别名的批量处理和基于数组的批量处理。以下代码展示了它用来检测基于数组的批量处理的逻辑：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, BatchQL creates a GraphQL query by using the field `hacktheplanet`.
    It then creates an array containing two copies of the query. BatchQL sends the
    array to a target server and counts the number of errors returned in the response.
    If the number of errors is greater than one, it means that the server processed
    both queries.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，BatchQL 通过使用字段`hacktheplanet`来创建一个 GraphQL 查询。然后，它创建一个包含两个查询副本的数组。BatchQL
    将该数组发送到目标服务器，并计算响应中返回的错误数量。如果错误数量大于一，说明服务器处理了两个查询。
- en: The reason it looks for the number of errors returned is that the query contains
    the `hacktheplanet` field, which will likely not exist on any real target. Therefore,
    GraphQL will return an error for each query it wasn’t able to process. BatchQL
    uses the same error-counting logic for its detection of alias-based batching.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它查看返回错误的数量的原因是查询包含字段`hacktheplanet`，这个字段很可能在任何真实的目标上都不存在。因此，GraphQL 会对每个无法处理的查询返回错误。BatchQL
    对其别名批处理的检测也使用相同的错误计数逻辑。
- en: 'Let’s now attempt to run BatchQL against DVGA and see the kind of output we
    get. Use the `-e` flag to specify the GraphQL endpoint:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试在 DVGA 上运行 BatchQL，看看我们会得到什么样的输出。使用`-e`标志来指定 GraphQL 端点：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: BatchQL was able to detect that both array-based batching and alias-based batching
    are available.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: BatchQL 能够检测到基于数组的批处理和基于别名的批处理都可用。
- en: Performing a DoS Audit with GraphQL Cop
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GraphQL Cop 执行 DoS 审计
- en: '*GraphQL Cop* is a Python-based security auditing utility capable of finding
    DoS and information disclosure weaknesses in GraphQL applications. It can identify
    most DoS classes covered in this chapter. Let’s use this tool against DVGA to
    see what vulnerabilities we can quickly find without a lot of effort.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*GraphQL Cop* 是一个基于 Python 的安全审计工具，能够发现 GraphQL 应用中的 DoS 和信息泄露弱点。它可以识别本章涵盖的大多数
    DoS 类别。让我们将这个工具应用于 DVGA，看看我们能在不费力气的情况下快速发现哪些漏洞。'
- en: 'GraphQL Cop takes very few parameters to do its work. To perform an audit,
    run it using the following commands:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL Cop 需要非常少的参数来完成其工作。要执行审计，请使用以下命令运行它：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, we get output containing a description of each vulnerability
    and its predefined severity. The tool was able to identify four DoS vectors in
    DVGA. If you need to parse this information programmatically during a penetration
    test, you may need a more script-friendly output. To achieve this, use the `-o`
    `json` flag.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们得到了包含每个漏洞描述及其预定义严重性的输出。该工具能够识别 DVGA 中的四个 DoS 向量。如果在渗透测试中需要通过编程方式解析这些信息，你可能需要更适合脚本化的输出。为此，请使用`-o`
    `json`标志。
- en: Denial-of-Service Defenses in GraphQL
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL 中的拒绝服务防御
- en: We’ve explored various techniques for performing DoS attacks against GraphQL
    targets. While most GraphQL implementations don’t include comprehensive DoS mitigations
    by default (with some exceptions), it’s possible to protect against the attacks
    we’ve discussed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了执行 DoS 攻击针对 GraphQL 目标的各种技术。虽然大多数 GraphQL 实现默认不包含全面的 DoS 缓解（有一些例外），但我们讨论的这些攻击是可以防御的。
- en: Query Cost Analysis
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询成本分析
- en: Complex queries are costly for servers to process, especially when many of them
    are sent simultaneously. When performing a penetration test, you may run into
    a GraphQL server that implements a *cost analyzer*. This term refers to any system
    that assigns a numerical value to GraphQL fields based on how much they “cost”
    to process. Processing involves CPU, input/output (I/O), memory, and network resource
    consumption.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的查询对服务器的处理成本较高，特别是当许多查询同时发送时。在执行渗透测试时，可能会遇到一个实现了*成本分析器*的 GraphQL 服务器。这个术语指的是任何根据处理成本（例如
    CPU、输入/输出（I/O）、内存和网络资源消耗）为 GraphQL 字段分配数值的系统。
- en: Query cost analysis can be achieved in multiple ways, such as by evaluating
    the query structure pre-execution using static analysis or by observing the query
    response after it’s fully resolved.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 查询成本分析可以通过多种方式实现，例如使用静态分析在执行前评估查询结构，或在查询完全解析后观察查询响应。
- en: Statically Assigning Cost to the Query
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态地为查询分配成本
- en: 'The more common form of cost analysis is *static analysis*. For instance, consider
    the following query:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的成本分析形式是*静态分析*。例如，考虑以下查询：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We’re using the `pastes` top-level field and specifying some fields, such as
    `title`, `content`, and `owner`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`pastes`顶级字段并指定一些字段，如`title`、`content`和`owner`。
- en: 'With static analysis, you can assign the query a cost in different ways. One
    common way is using a dedicated schema directive to specify values per field or
    per object type. The following example schema illustrates how cost assignment
    can be achieved through the use of schema directives:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态分析时，可以通过不同的方式为查询分配成本。一种常见的方法是使用专用的模式指令来为每个字段或每种对象类型指定值。以下示例模式展示了如何通过使用模式指令来实现成本分配：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, a special `cost` directive accepts a `complexity` argument, and the `complexity`
    argument accepts an integer value. If no value is provided to the `complexity`
    argument, it defaults to `1`. In the schema, the fields in `PasteObject` have
    some cost values assigned to them based on how resource heavy they are to resolve.
    (Imagine a field that requires the server to perform upstream checks against multiple
    third-party services, as opposed to a field that can be resolved by reading directly
    from a local database.)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，一个特殊的`cost`指令接受一个`complexity`参数，而`complexity`参数接受一个整数值。如果没有为`complexity`参数提供值，它默认是`1`。在模式中，`PasteObject`中的字段根据其解析时的资源消耗情况分配了某些成本值。（可以想象，一个字段需要服务器执行上游检查以访问多个第三方服务，而另一个字段则可以通过直接读取本地数据库来解析。）
- en: 'Based on this schema definition, we can add directives to our query as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个模式定义，我们可以像下面这样在查询中添加指令：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The total cost of this query is `12`. Knowing the total cost allows the GraphQL
    server to decide whether it should accept the query or reject it because it’s
    deemed too expensive.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的总成本是`12`。知道总成本可以让 GraphQL 服务器决定是否接受查询，或者因为成本过高而拒绝查询。
- en: Many static cost assignment libraries don’t persist the cost information to
    any database or cache. Therefore, in practice, each query is evaluated per query.
    To illustrate the dangers of failing to track cost usage, consider the diagram
    in [Figure 5-6](#figure5-6).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 许多静态成本分配库不会将成本信息持久化到数据库或缓存中。因此，实际上，每个查询都需要单独评估。为了说明未能追踪成本使用的风险，请参阅[图 5-6](#figure5-6)中的示意图。
- en: '![](image_fi/502840c05/f05006.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c05/f05006.png)'
- en: 'Figure 5-6: The dangers of stateless cost analysis'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：无状态成本分析的风险
- en: Here, a GraphQL server has set the maximum cost allowed (`MAX_COST`) to `200`.
    In this example, queries that have a cost of 200 and below are accepted, which
    means that if a client is sending multiple parallel queries, all with a cost of
    200, all will be accepted. This might introduce risks if the application’s backend
    is not able or ready to sustain parallel queries with such cost. Imagine an attacker
    using the maximum cost allowed to send thousands of requests; if the limit is
    too forgiving, this could choke an application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，GraphQL 服务器已将最大允许成本（`MAX_COST`）设置为`200`。在这个例子中，成本为 200 或以下的查询会被接受，这意味着如果客户端发送多个并行查询，每个查询的成本都为
    200，那么所有查询都会被接受。如果应用程序的后端无法或没有准备好处理如此高成本的并行查询，这可能会带来风险。想象一下，攻击者使用最大允许的成本发送成千上万的请求；如果限制过于宽松，这可能会导致应用程序崩溃。
- en: Dynamically Assigning Cost to the Server Response
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动态分配成本给服务器响应
- en: Cost analysis can also be performed on the server response to a query after
    it is fully resolved. The server must first process the query in order to understand
    its cost. However, looking at the actual resolved query can provide a more accurate
    cost estimation than the static technique.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 成本分析也可以在查询完全解析后的服务器响应上执行。服务器必须首先处理查询，才能了解其成本。然而，查看实际解析后的查询可以提供比静态方法更准确的成本估算。
- en: The advantage of this dynamic method over the static method is that dynamic
    cost assignment takes into account the response complexity as it is returned by
    the server. Think of a client requesting a single field that results in the server
    returning an array containing 1,000 elements. In this case, the response indicates
    a level of complexity that cannot be inferred by just looking at the query.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 动态方法相对于静态方法的优势在于，动态成本分配考虑了服务器返回的响应复杂度。想象一下，一个客户端请求一个字段，而服务器返回一个包含 1,000 个元素的数组。在这种情况下，响应所指示的复杂度是仅通过查询本身无法推断出来的。
- en: Using Credits-Based Rate Limiting
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用基于积分的速率限制
- en: GraphQL servers can be designed to keep track of the cost of queries made throughout
    a client session’s lifetime. Tracking this information allows servers to set hourly
    or daily quota limits, and reject queries after a certain limit is exceeded, as
    part of a credit-based system. For example, a server may set an hourly credit
    allowance (such as 1,000) per user session or per source IP address. If a query
    had a static cost of 200, a client could make only five of these queries per hour.
    To query again, they would have to wait until the credit allowance quota renews.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 服务器可以设计为在客户端会话期间跟踪查询的成本。跟踪这些信息允许服务器设置每小时或每日的配额限制，并在超过某个限制后拒绝查询，作为基于积分的系统的一部分。例如，服务器可以为每个用户会话或每个来源
    IP 地址设置每小时积分配额（如 1,000）。如果一个查询的静态成本是 200，那么客户端每小时最多可以发起五个这样的查询。若要重新查询，他们必须等到积分配额更新。
- en: For this mechanism to work, however, the server must track and store a client’s
    API usage data in a database. Otherwise, query limits based on cost would have
    to be stateless, which is common in GraphQL APIs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使此机制生效，服务器必须在数据库中跟踪并存储客户端的 API 使用数据。否则，基于成本的查询限制将必须是无状态的，这在 GraphQL API
    中很常见。
- en: Discovering a Query’s Cost in Responses
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在响应中发现查询的成本
- en: 'As you’ve learned, there are a few ways to implement cost-analysis controls
    in GraphQL APIs. In some implementations, you may see cost-related metadata in
    the response to a query. Consider the following GraphQL response example, which
    uses the `extensions` response field to provide cost-related information to the
    client:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所学到的，有几种方法可以在 GraphQL API 中实现成本分析控制。在某些实现中，你可能会在查询的响应中看到与成本相关的元数据。考虑以下 GraphQL
    响应示例，它使用 `extensions` 响应字段向客户端提供与成本相关的信息：
- en: '[PRE48]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `extensions` field is used to return some metadata to the client. This metadata
    is often related to query tracing, query cost calculation, or other debugging
    information. In this example, `credits_total` is the total number of available
    credits, and `credits_remaining` is the current number of credits left.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`extensions` 字段用于向客户端返回一些元数据。这些元数据通常与查询追踪、查询成本计算或其他调试信息相关。在此示例中，`credits_total`
    是可用积分的总数，`credits_remaining` 是当前剩余的积分数量。'
- en: You may be asking yourself why a GraphQL server would share this information
    with the client in the first place. Clients can use it to determine when queries
    may start getting throttled by the server and potentially fail. This helps clients
    build better error-handling logic.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么 GraphQL 服务器首先会与客户端共享这些信息。客户端可以利用这些信息判断何时查询可能会被服务器限流并可能失败。这有助于客户端构建更好的错误处理逻辑。
- en: Of course, the availability of cost information is also valuable to hackers.
    If we have a way to know when our queries will be accepted by the server (as in
    the case of hourly credits), we have a way to determine when to launch a new attack
    the next time credits become available to us, instead of repeatedly sending requests
    that will get blocked.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，成本信息的可用性对于黑客也是有价值的。如果我们有办法知道什么时候我们的查询会被服务器接受（例如每小时积分的情况），那么我们就能判断何时在积分重新可用时发起新攻击，而不是反复发送将被阻止的请求。
- en: Query Depth Limits
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询深度限制
- en: Earlier in this chapter, we discussed circular queries and how recursive queries
    in GraphQL could starve a server for resources. To protect a GraphQL server from
    recursive queries, applications can set query depth limits. For example, setting
    a `max_depth` configuration to a value of `10` would allow up to only 10 levels
    of depth. Any query that exceeds the allowed depth would get rejected.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章早些时候，我们讨论了循环查询以及 GraphQL 中的递归查询如何使服务器资源枯竭。为了保护 GraphQL 服务器免受递归查询的影响，应用程序可以设置查询深度限制。例如，将
    `max_depth` 配置设置为 `10` 的值将允许最多 10 层深度。任何超出允许深度的查询都会被拒绝。
- en: Some of the more mature GraphQL implementations support depth analysis out of
    the box or by leveraging external libraries written specifically for this purpose.
    Let’s take a look at how to implement query depth limits in graphql-ruby (Ruby)
    and Graphene (Python).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更成熟的 GraphQL 实现支持开箱即用的深度分析，或者通过利用专门为此目的编写的外部库。让我们来看一下如何在 graphql-ruby（Ruby）和
    Graphene（Python）中实现查询深度限制。
- en: 'In graphql-ruby, it is possible to set a maximum depth limit within the `MySchema`
    class:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 graphql-ruby 中，可以在 `MySchema` 类中设置最大深度限制：
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In Graphene, a maximum depth limit can be set in the following way:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Graphene 中，可以通过以下方式设置最大深度限制：
- en: '[PRE50]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Depth is typically calculated per query. If an attacker sends multiple recursive
    queries simultaneously, this can still impact the server quite drastically.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 深度通常是按查询计算的。如果攻击者同时发送多个递归查询，这仍然可能对服务器造成严重影响。
- en: Alias and Array-Based Batching Limits
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 别名和基于数组的批处理限制
- en: Because GraphQL aliases are part of the GraphQL specification, developers can’t
    disable them easily. Preventing aliases from being abused requires custom middleware
    code that parses the incoming query, counts the number of specified aliases, and
    rejects the request if the number appears high enough that it could be dangerous
    to process. For this type of control to even exist in a GraphQL application, its
    developers need to be aware of the security weaknesses caused by aliases in the
    first place.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 GraphQL 别名是 GraphQL 规范的一部分，开发人员不能轻易禁用它们。防止别名被滥用需要自定义中间件代码来解析传入的查询，计算指定的别名数量，并在数量达到足够高的程度时拒绝请求，因为这可能会导致处理时的危险。要使
    GraphQL 应用程序中存在这种控制，开发人员首先需要意识到别名可能带来的安全隐患。
- en: 'Unlike aliases, array-based batching is not part of the specification document.
    It often requires installing additional packages or enabling the feature in the
    code. Let’s take a look at what disabling array-based batching looks like in Graphene:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与别名不同，基于数组的批处理不是规范文档的一部分。它通常需要安装额外的软件包或在代码中启用该功能。让我们看看在 Graphene 中禁用基于数组的批处理是什么样的：
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `batch` argument accepts a Boolean value of either `True` or `False`. If
    we toggle it to `False`, Graphene will reject any arrays from being processed.
    This is an example of how the GraphQL server implementation natively supports
    disabling batching and doesn’t require custom code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`batch` 参数接受布尔值 `True` 或 `False`。如果将其切换为 `False`，Graphene 将拒绝处理任何数组。这是 GraphQL
    服务器实现本身支持禁用批处理的一个例子，无需自定义代码。'
- en: In penetration tests, use GraphQL fingerprinting tools such as Graphw00f to
    identify the target server implementation. You can then use the GraphQL Threat
    Matrix project we’ve put together ([https://github.com/nicholasaleks/graphql-threat-matrix](https://github.com/nicholasaleks/graphql-threat-matrix))
    to identify whether features such as array-based batching are available. If they
    exist, figure out whether they can be disabled. These insights will be useful
    to document in a penetration test report as part of the remediation section.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中，使用诸如 Graphw00f 之类的 GraphQL 指纹识别工具来识别目标服务器的实现。然后，你可以使用我们整理的 [GraphQL 威胁矩阵项目](https://github.com/nicholasaleks/graphql-threat-matrix)
    来识别是否有像基于数组的批处理等功能。如果存在，了解它们是否可以禁用。这些见解在渗透测试报告中作为修复部分记录将非常有用。
- en: Field Duplication Limits
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段重复限制
- en: By default, GraphQL resolves any field specified in a query, even if it’s specified
    more than once. Even so, we can mitigate against field duplication attacks in
    multiple ways.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，GraphQL 会解析查询中指定的任何字段，即使它被多次指定。尽管如此，我们可以通过多种方式来减轻字段重复攻击的风险。
- en: While it doesn’t directly address the field duplication problem, query cost
    analysis protects GraphQL applications whenever a large number of fields are specified
    in a single query (whether they are duplicated or not). Cost analysis is an effective
    mitigation against any form of attack that involves specifying many fields in
    a single query.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它没有直接解决字段重复问题，但查询成本分析可以保护 GraphQL 应用程序，在单个查询中指定大量字段时（无论它们是否重复）。成本分析是防范任何涉及在单个查询中指定许多字段的攻击的有效措施。
- en: Another form of protection is using a middleware security analyzer to inspect
    the incoming query and take action if any fields are repeated more than once.
    The application might choose to implement multiple actions, such as completely
    rejecting a query or *normalizing* the query by consolidating any repeated fields
    to eliminate the duplications. This would essentially reconstruct the original
    query as a safer version. Currently, no feature in GraphQL does this. Application
    developers will need to develop middleware themselves or use a third-party security
    tool to do it for them.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种保护形式是使用中间件安全分析器来检查传入的查询，并在有字段重复出现多次时采取措施。应用程序可能会选择实施多种操作，例如完全拒绝查询或通过合并重复字段来*规范化*查询，从而消除重复。这基本上是将原始查询重构为更安全的版本。目前，GraphQL
    中没有任何功能执行此操作。应用程序开发人员需要自行开发中间件，或使用第三方安全工具来代替。
- en: Another way applications might go about defending themselves against field duplication
    is by calculating the query’s field “height.” Consider the query in [Figure 5-7](#figure5-7).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序防御字段重复的另一种方法是计算查询的字段“高度”。请参考[图 5-7](#figure5-7)中的查询。
- en: '![](image_fi/502840c05/f05007.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c05/f05007.png)'
- en: 'Figure 5-7: An example GraphQL query height'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7：一个示例 GraphQL 查询的高度
- en: This query requests the `owner` field, and then the `owner` field’s `id` (once)
    and `name` (four times). As you can see, the height altogether is 5\. An application
    might limit any query that exceeds a certain allowed height. Keep in mind that,
    by default, GraphQL does not implement this type of control.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询请求`owner`字段，然后是`owner`字段的`id`（一次）和`name`（四次）。如您所见，总高度为 5。应用程序可能会限制任何超过某个允许高度的查询。请记住，默认情况下，GraphQL
    并未实现这种类型的控制。
- en: Limits on the Number of Returned Records
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回记录数量的限制
- en: 'GraphQL servers could limit the number of objects they return when a client
    requests an array field. To do so, they could set a maximum number of items to
    return on the server side and keep the client from overriding it. Here is an example
    of how this can be achieved in Graphene:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端请求数组字段时，GraphQL 服务器可以限制它们返回的对象数量。为此，它们可以在服务器端设置最大返回项数，并防止客户端覆盖该设置。以下是如何在
    Graphene 中实现这一点的示例：
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This example resolver function is for the `pastes` query. The limit ensures
    that no matter how many pastes exist in the database, the maximum number of pastes
    returned is 1,000.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例解析器函数是用于`pastes`查询的。该限制确保无论数据库中存在多少个 paste，返回的最大 paste 数量为 1,000。
- en: Another way to limit the number of records returned in a response is by introducing
    API pagination, which controls the number of records a client can retrieve in
    a single request.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种限制响应中返回记录数量的方法是引入 API 分页，它控制客户端在单个请求中可以检索的记录数。
- en: Query Allow Lists
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询允许列表
- en: 'Another defense technique an application might implement is an allow-list approach.
    The concept of *allow lists* is simple: you define the GraphQL queries that an
    application can accept, and you reject any queries that aren’t on the list. You
    can consider this to be a safe list of trusted queries.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能实施的另一种防御技术是允许列表方法。*允许列表*的概念很简单：你定义应用程序可以接受的 GraphQL 查询，并拒绝任何不在列表中的查询。你可以将其视为一个可信查询的安全列表。
- en: The allow-list approach is typically safer than the use of a deny list, which
    tends to be prone to more errors. A malicious payload can be constructed in a
    variety of ways, and if you don’t take all of those variations into consideration
    when building a deny list, attackers might find ways to bypass it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 允许列表方法通常比使用拒绝列表更安全，因为拒绝列表更容易出错。恶意负载可以通过多种方式构造，如果在构建拒绝列表时未考虑到所有这些变化，攻击者可能会找到绕过它的方式。
- en: Query allow lists do not normally exist in GraphQL server implementations, nor
    do many external libraries implement them. To leverage such a feature, GraphQL
    application developers must seek a compatible library for their implementation
    or create one from scratch.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 查询允许列表在 GraphQL 服务器实现中通常不存在，也很少有外部库实现此功能。为了利用此功能，GraphQL 应用开发人员必须寻找与其实现兼容的库，或从头开始创建一个。
- en: Automatic Persisted Queries
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动持久化查询
- en: Query allow lists are often used in conjunction with a caching mechanism called
    *automatic persisted queries* *(APQ*), which is used for improving the performance
    of GraphQL queries. Instead of using the normal GraphQL query structure, a GraphQL
    server that implements APQ can accept hashes that represent these queries.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 查询允许列表通常与一种名为*自动持久化查询*（*APQ*）的缓存机制一起使用，用于提升 GraphQL 查询的性能。GraphQL 服务器通过实现 APQ，可以接受代表这些查询的哈希值，而不是使用正常的
    GraphQL 查询结构。
- en: 'In an APQ interaction between a GraphQL client and server, the client first
    attempts to send a hash of a query (such as a SHA-256 hash). The server performs
    a hash lookup in its cache. If the hash doesn’t exist, the server returns an error.
    The client can then follow up with another request containing the raw GraphQL
    query, along with its hash, which will get stored in the server’s database. The
    client can use this hash on any subsequent requests instead of providing the full
    query. The hash might look like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 客户端和服务器的 APQ 交互中，客户端首先尝试发送查询的哈希值（例如 SHA-256 哈希）。服务器在其缓存中执行哈希查找。如果哈希值不存在，服务器会返回错误。然后客户端可以跟进另一个请求，其中包含原始
    GraphQL 查询及其哈希值，该查询会被存储在服务器数据库中。客户端可以在任何后续请求中使用该哈希值，而无需提供完整的查询。哈希值可能如下所示：
- en: '[PRE53]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To generate a SHA-256 hash of any query, you can use the `sha256sum` command,
    like so:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成任何查询的SHA-256哈希值，您可以使用`sha256sum`命令，如下所示：
- en: '[PRE54]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The advantage here is that hashing algorithms produce fixed-length values (for
    example, SHA-256 hashes are 64 characters in length), no matter how large a query
    might be. This eliminates the need for clients to send HTTP requests containing
    large queries over the network and reduces the overall bandwidth consumption.
    [Figure 5-8](#figure5-8) illustrates what a GraphQL deployment with APQ might
    look like.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势在于，哈希算法生成固定长度的值（例如，SHA-256哈希长度为64个字符），无论查询有多大。这消除了客户端通过网络发送包含大查询的HTTP请求的需求，从而减少了总带宽消耗。[图5-8](#figure5-8)说明了具有APQ的GraphQL部署的可能外观。
- en: '![](image_fi/502840c05/f05008.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c05/f05008.png)'
- en: 'Figure 5-8: The APQ architecture'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-8：APQ架构
- en: You might have noticed a weakness. What if the client is an attacker and forces
    the server to cache a malicious query? Will the attacker be able to use it in
    subsequent queries? That is a great question to ask, and also why a mechanism
    like APQ should coexist with a function such as an allow list. The server should
    reject malicious queries before they get cached so that only trusted queries can
    be inserted into the cache.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到一个弱点。如果客户端是攻击者并强制服务器缓存恶意查询，会怎么样？攻击者能否在随后的查询中使用它？这是一个很好的问题，并且为什么像APQ这样的机制应该与白名单函数一起存在。服务器应该在将恶意查询缓存之前拒绝它们，以便只有受信任的查询可以插入缓存中。
- en: APQ is designed as a caching mechanism first, but it can also play as a security
    control to protect GraphQL servers from accepting malicious queries. APQ isn’t
    yet widely used but is supported in some of the mature GraphQL implementations
    on the market, such as Apollo GraphQL. You can refer to the GraphQL Threat Matrix
    project to find out which implementations support APQ.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: APQ首先设计为缓存机制，但它也可以作为安全控制来保护GraphQL服务器免受接受恶意查询的影响。尽管APQ尚未被广泛使用，但它受到市场上一些成熟GraphQL实现的支持，例如Apollo
    GraphQL。您可以参考GraphQL威胁矩阵项目，了解哪些实现支持APQ。
- en: Timeouts
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超时
- en: '*Timeouts* are another form of protection against long-running and resource-consuming
    tasks. When a GraphQL server is bombarded with many queries, it may take minutes
    to completely fulfill the request. To mitigate these cases, servers can introduce
    application timeouts, which define how long a request can take to complete.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*超时* 是另一种防止长时间运行和消耗资源的任务的保护形式。当GraphQL服务器遭受大量查询时，可能需要几分钟才能完全满足请求。为了减轻这些情况，服务器可以引入应用程序超时，定义请求完成所需的时间。'
- en: 'Some GraphQL implementations, such as graphql-ruby, allow setting a timeout
    on the query execution in the following way:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一些GraphQL实现，如graphql-ruby，允许通过以下方式设置查询执行超时：
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However, not all GraphQL implementations support setting query timeouts this
    way. Those GraphQL applications could use timeouts at the web server layer, such
    as in Nginx or Apache, which support setting timeouts.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有GraphQL实现都支持通过此方式设置查询超时。这些GraphQL应用程序可以在Web服务器层使用超时，如Nginx或Apache，它们支持设置超时。
- en: Setting the right application timeout intervals tends to be a tricky task; a
    too-short timeout configuration could mean dropping legitimate client requests
    and impacting the client’s user experience, which is why applications usually
    have a high timeout value set by default. Both Nginx and Apache set their request
    timeout value at around the 60-second range.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 设置正确的应用程序超时间隔往往是一个棘手的任务；过短的超时配置可能意味着丢弃合法的客户端请求并影响客户端的用户体验，这就是为什么应用程序通常默认设置较高的超时值。Nginx和Apache都将其请求超时值设置在大约60秒左右。
- en: Timeouts can be effective, but they shouldn’t be the only mitigation strategy
    a GraphQL application implements.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 超时可以是有效的，但它们不应是GraphQL应用程序实施的唯一缓解策略。
- en: Web Application Firewalls
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web 应用程序防火墙
- en: '*Web application firewalls (WAFs)* are useful for blocking malicious traffic
    before it reaches the application. They allow security teams to respond quickly
    to attacks and vulnerabilities by creating signatures and rules that block traffic
    based on various patterns, such as HTTP payloads, URLs, or a client’s geographical
    location.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*Web 应用程序防火墙（WAFs）* 对于阻止恶意流量在其到达应用程序之前非常有用。它们允许安全团队通过创建基于各种模式（如HTTP负载、URL或客户端地理位置）的签名和规则来快速响应攻击和漏洞。'
- en: WAFs have been battle tested in production environments for many years, protecting
    web applications and APIs such as REST and SOAP across many industries. However,
    commercial and open source WAFs are still adapting to the way GraphQL works, and
    the ways attackers might abuse GraphQL for nefarious purposes, so some gaps remain
    in the protections WAFs can offer GraphQL applications.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: WAF 在生产环境中经过多年的战斗测试，保护着 Web 应用和 API（如 REST 和 SOAP），覆盖了许多行业。然而，商业和开源的 WAF 仍在适应
    GraphQL 的工作方式，以及攻击者可能如何利用 GraphQL 从事恶意活动，因此 WAF 在保护 GraphQL 应用方面仍存在一些空白。
- en: Although some WAFs are not “GraphQL-aware,” the way they inspect traffic still
    allows them to detect many malicious payloads. They can block suspicious payloads,
    such as SQL injections, operating system injections, cross-site scripting (XSS),
    and so on, even when embedded within GraphQL queries or mutations.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些 WAF（Web 应用防火墙）并不“支持 GraphQL”，但它们检查流量的方式仍然可以检测到许多恶意有效载荷。即使恶意载荷嵌入在 GraphQL
    查询或突变中，它们仍然能够阻止可疑的有效载荷，如 SQL 注入、操作系统注入、跨站脚本攻击（XSS）等。
- en: 'Consider the following XSS example in a GraphQL query:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下在 GraphQL 查询中的 XSS 示例：
- en: '[PRE56]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Even WAFs without native GraphQL support will likely identify and reject requests
    containing such common exploit payloads. Additionally, WAFs can provide other
    forms of protection, such as body size restrictions (in the form of byte limits)
    to prevent DoS attacks, or throttling to slow DoS attempts.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是没有原生支持 GraphQL 的 WAF，也很可能识别并拒绝包含常见攻击载荷的请求。此外，WAF 还可以提供其他形式的保护，如限制请求体的大小（以字节限制的形式）来防止
    DoS 攻击，或进行限流以减缓 DoS 攻击。
- en: However, WAFs without GraphQL support will struggle to defend against many of
    the attacks you learned about in this chapter. For instance, WAFs typically don’t
    block single HTTP requests if they don’t contain any malicious patterns, such
    as dangerous JavaScript payloads (like XSS), or SQL commands (in the case of SQL
    injection). Although we can send thousands of queries in a single HTTP request
    by using aliases or array-based batching, WAFs without native GraphQL support
    won’t understand the danger in accepting such requests.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有 GraphQL 支持的 WAF 将难以防御本章所讲解的许多攻击。例如，WAF 通常不会阻止单个 HTTP 请求，如果它们不包含恶意模式，如危险的
    JavaScript 有效载荷（如 XSS）或 SQL 命令（在 SQL 注入的情况下）。尽管我们可以通过使用别名或基于数组的批处理在单个 HTTP 请求中发送成千上万的查询，但没有原生支持
    GraphQL 的 WAF 不会理解接受此类请求的危险性。
- en: Gateway Proxies
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网关代理
- en: GraphQL *gateways* merge multiple GraphQL schemas into one unified schema, either
    by stitching them together or by connecting to each individual GraphQL service
    to fetch its schema content. This schema is then exposed at the gateway layer
    for clients to consume. [Figure 5-9](#figure5-9) shows how such an application
    deployment model might look.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL *网关*将多个 GraphQL 架构合并成一个统一的架构，可以通过将它们拼接在一起，或者通过连接到每个单独的 GraphQL 服务来获取其架构内容。然后，这个架构会在网关层暴露给客户端使用。[图
    5-9](#figure5-9) 展示了这种应用部署模型的可能样貌。
- en: '![](image_fi/502840c05/f05009.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c05/f05009.png)'
- en: 'Figure 5-9: A GraphQL gateway proxying traffic to other services'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-9：一个 GraphQL 网关代理流量到其他服务
- en: GraphQL gateways are becoming more popular in the security space as a network
    choke point that can enforce policies and perform rate limiting. They often act
    as reverse proxies, forwarding traffic to other internal API servers, and can
    manage multiple API schemas. Gateways also provide features such as auditability,
    schema version control, authorization controls, Layer 7 DoS protection, and more.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 网关在安全领域越来越受欢迎，作为一个可以执行策略和进行速率限制的网络瓶颈点。它们通常充当反向代理，将流量转发到其他内部 API 服务器，并且能够管理多个
    API 架构。网关还提供如审计功能、架构版本控制、授权控制、七层 DoS（拒绝服务）保护等功能。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed several ways an attacker might introduce load
    on GraphQL servers for the purpose of carrying out DoS attacks. We used several
    dedicated GraphQL security tools to test for DoS conditions and dissected custom
    exploits to understand how they work under the hood. You also learned how query
    batching works in GraphQL and how to make DoS attacks even more powerful by using
    arrays and aliases. Finally, we explored the types of security defenses GraphQL
    applications could implement to protect themselves against DoS attacks.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了攻击者可能采用的几种方式，通过这些方式向 GraphQL 服务器施加负载，从而实施 DoS 攻击。我们使用了几种专门的 GraphQL
    安全工具来测试 DoS 条件，并解析了自定义漏洞，理解它们在背后是如何运作的。你还学习了 GraphQL 中查询批处理是如何工作的，以及如何通过使用数组和别名使
    DoS 攻击更具威胁性。最后，我们探讨了 GraphQL 应用程序可以实施的安全防御措施，以保护自己免受 DoS 攻击。
