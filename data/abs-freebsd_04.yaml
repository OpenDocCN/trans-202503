- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: START ME UP! THE BOOT PROCESS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开始启动！启动过程**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: While FreeBSD boots easily and automatically when you turn on the power, understanding
    exactly what happens at each stage will make you a better system administrator.
    Intervention during the boot process is rarely necessary, but one day you’ll be
    glad you know how to do it. And once you’re comfortable with adjusting the boot
    process, you’ll find you can solve problems you’ve previously accepted and endured.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FreeBSD 在开机时可以轻松且自动地启动，但了解每个阶段到底发生了什么，将使你成为一个更好的系统管理员。在启动过程中通常不需要干预，但有一天你会很高兴自己知道如何操作。一旦你熟悉了调整启动过程，你会发现自己能够解决那些之前你只能接受并忍受的问题。
- en: We’ll start by discussing how the system loader starts and gathering information
    from the loader. You can use the loader to change the early boot process, including
    booting alternate kernels and starting in single-user mode. We’ll cover serial
    consoles, a standard system management tool. The FreeBSD multiuser startup process
    is responsible for starting all the various services that make your computer useful,
    and we’ll give attention to that as well. In addition, we’ll cover the information
    FreeBSD records about the boot process and how FreeBSD turns itself off without
    corrupting data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论系统加载器是如何启动的，并从加载器获取信息。你可以使用加载器来改变早期的启动过程，包括启动替代内核和进入单用户模式。我们还将讨论串行控制台，这是一种标准的系统管理工具。FreeBSD
    的多用户启动过程负责启动所有各种使你的计算机有用的服务，我们也会关注这一点。此外，我们还将讨论 FreeBSD 记录的关于启动过程的信息，以及 FreeBSD
    如何在不破坏数据的情况下关闭系统。
- en: '**RECURSION WARNING**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归警告**'
- en: Some of the topics in this chapter reference material found in later chapters.
    Those later chapters, in turn, require that you understand this chapter first.
    There’s no good place to begin learning. If you don’t quite understand a part
    of this chapter, just skim over it and continue reading; it really will coalesce
    in your mind as you proceed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些主题引用了后续章节中的内容。这些后续章节反过来要求你先理解本章内容。学习没有固定的起点。如果你对本章的某部分不完全理解，跳过它继续阅读；随着你继续深入，你会发现这些内容会在你的脑海中逐渐清晰。
- en: 'The boot process itself can be divided into three main parts: the loader, single-user
    startup, and multiuser startup.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 启动过程本身可以分为三个主要部分：加载器、单用户模式启动和多用户模式启动。
- en: '**Power-On**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**开机**'
- en: A computer needs enough brains to find and load its operating system. For many
    years, this facility came from the basic input/output system (BIOS). Newer systems
    use the Unified Extensible Firmware Interface (UEFI) instead of the BIOS. New
    installs should use UEFI. Other hardware platforms have console firmware or bootroms
    that perform the same function, but we’re focused on commodity hardware, so we’ll
    cover UEFI and BIOS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机需要足够的智能来找到并加载其操作系统。多年来，这个功能来自基本输入输出系统（BIOS）。较新的系统使用统一可扩展固件接口（UEFI）代替 BIOS。新的安装应该使用
    UEFI。其他硬件平台有控制台固件或启动 ROM，执行相同的功能，但我们关注的是常见硬件，因此我们将讨论 UEFI 和 BIOS。
- en: '***Unified Extensible Firmware Interface***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***统一可扩展固件接口***'
- en: UEFI is a replacement for the three-decades-old BIOS. Any new system will come
    with UEFI enabled and will expect to use it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 是替代三十多年历史的 BIOS 的新技术。任何新系统都将启用 UEFI，并期望使用它。
- en: UEFI searches the boot drive for a partition marked as a UEFI boot partition.
    Despite what the special mark might imply, that partition contains only a FAT
    filesystem with a specific directory and file layout. UEFI executes the file */EFI/BOOT/BOOTX64.EFI*.
    That file might be a fancy multi-OS boot loader, or it might dump you straight
    into an operating system. In FreeBSD, the UEFI boot fires up the boot loader,
    */boot/loader.efi*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 在启动盘上搜索标记为 UEFI 启动分区的分区。尽管这个特殊标记可能暗示一些事情，但该分区仅包含一个 FAT 文件系统，以及特定的目录和文件布局。UEFI
    执行文件 */EFI/BOOT/BOOTX64.EFI*。这个文件可能是一个复杂的多操作系统启动加载器，或者直接将你带入操作系统。在 FreeBSD 中，UEFI
    启动会启动加载器，*/boot/loader.efi*。
- en: UEFI is comparatively new. If your new system has trouble booting FreeBSD, you
    might try enabling a BIOS or “legacy” mode. If the system boots FreeBSD in BIOS
    mode but not with UEFI, please file a bug, as discussed in [Chapter 24](ch24.xhtml#ch24).^([1](footnote.xhtml#ch04fn1))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 相对较新。如果你的新系统在启动 FreeBSD 时遇到问题，你可以尝试启用 BIOS 或“传统”模式。如果系统在 BIOS 模式下能够启动 FreeBSD，但在
    UEFI 模式下无法启动，请按照 [第24章](ch24.xhtml#ch24)中的讨论提交 bug。^([1](footnote.xhtml#ch04fn1))
- en: '***Basic Input/Output System***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基本输入输出系统***'
- en: The primordial Intel PC used a basic input/output system (BIOS) with just enough
    brains to look for an operating system somewhere on a disk. A BIOS searches for
    a disk partition marked active and then executes the first section of that partition.
    For FreeBSD, that chunk of data is called the *loader*. Every FreeBSD system has
    a reference copy of the loader as */boot/loader*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的Intel PC使用了一种基本输入/输出系统（BIOS），它具备足够的能力来在磁盘上查找操作系统。BIOS会搜索一个被标记为活动的磁盘分区，然后执行该分区的第一部分。对于FreeBSD而言，这部分数据被称为*加载器*。每个FreeBSD系统都有一个加载器的引用副本，路径为*/boot/loader*。
- en: A BIOS has all sorts of limitations. The boot loader must reside in a very specific
    section of the disk. BIOS can’t boot from disks larger than 2.2TB. The target
    boot loader must be smaller than 512KB—huge by 1980 standards, yes, but paltry
    today. The installed loader is a binary, not a filesystem, so even minor changes
    require recompiling. UEFI has none of these limitations and offers modern features,
    like mouse support.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS有各种限制。启动加载器必须位于磁盘的一个特定区域。BIOS无法从大于2.2TB的磁盘启动。目标启动加载器必须小于512KB——按1980年的标准来说，这已经很大了，但今天显得微不足道。已安装的加载器是二进制文件，而不是文件系统，因此即使是微小的更改也需要重新编译。UEFI没有这些限制，并且提供现代功能，如鼠标支持。
- en: Ultimately, though, a BIOS and UEFI both have the goal of getting your system
    to the FreeBSD loader.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终来说，BIOS和UEFI的目标都是将系统引导到FreeBSD加载器。
- en: '**The Loader**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加载器**'
- en: 'The *loader*, or *boot blocks*, loads the FreeBSD kernel and presents you with
    a menu before starting that kernel. The loader(8) program offers a menu of seven
    options on the left. A new FreeBSD system presents these options:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*加载器*，或称*启动块*，加载FreeBSD内核，并在启动内核之前为你呈现一个菜单。加载器(8)程序在左侧提供七个选项。新的FreeBSD系统展示了这些选项：'
- en: Boot Multi User [Enter]
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动多用户模式 [Enter]
- en: Boot Single User
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动单用户模式
- en: Escape to loader prompt
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到加载器提示
- en: Reboot
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启
- en: 'Kernel: default/kernel (1 of 2)'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核：default/kernel（1 of 2）
- en: Configure Boot Options…
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置启动选项…
- en: Select Boot Environment…
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择启动环境…
- en: Each option highlights certain words or characters, such as *S* in “Boot Single
    User” and ESC in “Escape to loader prompt.” Select an option by pressing the highlighted
    character or the number.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都突出显示某些单词或字符，比如“启动单用户模式”中的*S*和“跳转到加载器提示”中的ESC。选择一个选项可以通过按下高亮字符或数字来实现。
- en: The options at the top of the menu control how FreeBSD boots. We’ll look at
    each option in turn. If you wait 10 seconds, the loader automatically boots FreeBSD
    by default.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单顶部的选项控制FreeBSD的启动方式。我们将逐一介绍每个选项。如果你等待10秒，加载器将默认自动启动FreeBSD。
- en: The options at the bottom half let you fine-tune the boot process. You can tweak
    how you want the system to boot, as we’ll discuss later, and then choose one of
    the preceding booting options.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单下半部分的选项让你可以微调启动过程。你可以根据需要调整系统的启动方式，稍后我们会讨论这些内容，然后选择前面提到的启动选项之一。
- en: '***Boot Multi User [Enter]***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动多用户模式 [Enter]***'
- en: This is a normal boot. Hit ENTER to boot immediately, skipping the 10-second
    delay.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正常的启动。按ENTER立即启动，跳过10秒的延迟。
- en: '***Boot FreeBSD in Single-User Mode***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在单用户模式下启动FreeBSD***'
- en: '*Single-user mode* is a minimal startup mode that’s very useful on damaged
    systems, especially when the damage was self-inflicted. It’s the earliest point
    where FreeBSD can provide a command prompt, and it’s important enough to have
    its own section later in this chapter.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*单用户模式*是一种最小化启动模式，对于损坏的系统非常有用，尤其是当损坏是人为造成的时。它是FreeBSD提供命令提示符的最早时刻，这个模式足够重要，因此本章稍后会有专门的章节讲解。'
- en: '***Escape to Loader Prompt***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跳转到加载器提示***'
- en: The loader includes a command line interpreter, where you can issue commands
    to tweak your system to boot exactly the way you need. We’ll cover this in detail
    in “[The Loader Prompt](ch04.xhtml#lev106)” on [page 55](ch04.xhtml#page_55).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器包括一个命令行解释器，你可以在其中输入命令来调整系统启动方式，确保它完全符合你的需求。我们将在“[加载器提示](ch04.xhtml#lev106)”中详细介绍此内容，见[第55页](ch04.xhtml#page_55)。
- en: '***Reboot***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重启***'
- en: Once more, this time with feeling!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再来一次，这次要有感觉！
- en: Of these options, the most important are single-user mode and the loader prompt.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些选项中，最重要的是单用户模式和加载器提示。
- en: '**Single-User Mode**'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**单用户模式**'
- en: FreeBSD can perform a minimal boot, called *single-user mode*, that loads the
    kernel and finds devices but doesn’t automatically set up your filesystems, start
    the network, enable security, or run any standard Unix services. Single-user mode
    is the earliest the system can possibly give you a command prompt.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 可以执行一个最小启动，称为 *单用户模式*，它加载内核并查找设备，但不会自动设置文件系统、启动网络、启用安全性或运行任何标准的 Unix
    服务。单用户模式是系统可能提供命令提示符的最早阶段。
- en: Why use single-user mode? If a badly configured daemon hangs the boot, you can
    enter single-user mode to prevent it from starting. If you’ve lost your root password,
    you can boot into single-user mode to change it. If you need to shuffle critical
    filesystems around, again, single-user mode is the place to do it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用单用户模式？如果一个配置错误的守护进程挂起了启动，你可以进入单用户模式以防止其启动。如果你忘记了根密码，可以通过单用户模式启动并进行更改。如果你需要调整关键的文件系统，单用户模式也是执行此操作的地方。
- en: When you choose a single-user mode boot, you’ll see the regular system startup
    messages flow past. Before any programs start, however, the kernel offers you
    a chance to choose a shell. You can enter any shell on the root partition; I usually
    just take the default */bin/sh*, but use */bin/tcsh* if you prefer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择单用户模式启动时，你会看到常规的系统启动信息流过。但在任何程序启动之前，内核会给你一个选择 shell 的机会。你可以进入根分区上的任何 shell；我通常选择默认的
    */bin/sh*，但如果你偏好，可以使用 */bin/tcsh*。
- en: '***Disks in Single-User Mode***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***单用户模式中的磁盘***'
- en: In single-user mode, the root partition is mounted read-only and no other disks
    are mounted. (We’ll discuss mounting filesystems in [Chapter 10](ch10.xhtml#ch10),
    but for now just follow along.) Many of the programs that you’ll want to use are
    on partitions other than the root, so you’ll want them all mounted read-write
    and available. The way to do this varies depending on whether you’re using UFS
    or ZFS.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在单用户模式下，根分区是以只读方式挂载的，且没有其他磁盘被挂载。（我们将在[第10章](ch10.xhtml#ch10)讨论挂载文件系统，但现在请暂时跟随进行。）你想使用的许多程序都位于根分区以外的分区，因此你需要将它们全部挂载为可读写并且可用。执行此操作的方式取决于你使用的是
    UFS 还是 ZFS。
- en: '**UFS in Single-User Mode**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**单用户模式下的 UFS**'
- en: 'To make all the filesystems listed in the filesystem table */etc/fstab* usable,
    run the following commands:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 */etc/fstab* 文件系统表中列出的所有文件系统可用，请运行以下命令：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The fsck(8) program “cleans” the filesystems and confirms that they’re internally
    consistent and that all the files that a disk thinks it has are actually present
    and accounted for.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: fsck(8) 程序“清理”文件系统，并确认它们在内部的一致性，以及磁盘认为它拥有的所有文件实际上都存在并已记录。
- en: The root filesystem is mounted read-only. Whatever drove us to single-user mode
    probably requires changing the root filesystem. Remount the root filesystem read-write.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统是以只读方式挂载的。无论是什么原因导致我们进入单用户模式，可能需要更改根文件系统。重新挂载根文件系统为可读写模式。
- en: Finally, the `-a` flag to mount(8) activates every filesystem listed in */etc/fstab*
    (see [Chapter 10](ch10.xhtml#ch10)). If one of these filesystems is causing you
    problems, you can mount the desired filesystems individually by specifying them
    on the command line (for example, `mount /usr`). If you’re an advanced user with
    NFS filesystems configured (see [Chapter 13](ch13.xhtml#ch13)), you’ll see error
    messages for those filesystems at this point because the network isn’t up yet.
    If the host has network filesystems in */etc/fstab*, mount only the UFS filesystems
    as shown next.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，mount(8) 命令的 `-a` 标志会激活 */etc/fstab* 中列出的每一个文件系统（参见[第10章](ch10.xhtml#ch10)）。如果这些文件系统中的某一个正在给你带来问题，你可以通过在命令行中指定它们来单独挂载所需的文件系统（例如，`mount
    /usr`）。如果你是一个高级用户并且配置了 NFS 文件系统（参见[第13章](ch13.xhtml#ch13)），你将在此时看到这些文件系统的错误信息，因为网络尚未启动。如果主机在
    */etc/fstab* 中有网络文件系统，应该只挂载 UFS 文件系统，如下所示。
- en: 'If you have trouble mounting partitions by name, try using the device name
    instead. The device name for the root partition is probably */dev/ad0s1a*. You’ll
    also need to specify a mount point for this partition. For example, to mount your
    first IDE disk partition as root, enter the command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在按名称挂载分区时遇到困难，可以尝试使用设备名称。根分区的设备名称可能是 */dev/ad0s1a*。你还需要为此分区指定一个挂载点。例如，要将你的第一个
    IDE 磁盘分区挂载为根分区，请输入以下命令：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have network filesystems on your server but your network isn’t up yet,
    you can mount all your local partitions by specifying the filesystem type. Here,
    we mount all of the local filesystems of type UFS, which is FreeBSD’s default
    filesystem type:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务器上有网络文件系统，但网络尚未启动，你可以通过指定文件系统类型来挂载所有本地分区。在这里，我们挂载所有类型为 UFS 的本地文件系统，这是
    FreeBSD 的默认文件系统类型：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can now access your UFS filesystems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以访问你的UFS文件系统了。
- en: '**ZFS in Single-User Mode**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**单用户模式下的ZFS**'
- en: To make all of your ZFS datasets available, use `zfs mount`. You can either
    mount individual datasets by name or mount everything that’s marked as mountable
    with `-a`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要使所有的ZFS数据集可用，使用`zfs mount`。你可以按名称挂载单独的数据集，也可以使用`-a`挂载所有标记为可挂载的数据集。
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ZFS will perform its usual integrity checks before mounting the datasets.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ZFS将在挂载数据集之前执行常规的完整性检查。
- en: Most of the datasets will be exactly as accessible as in multiuser mode, but
    the dataset mounted as root will still be read-only. Turn that off. Here, I’m
    setting the root dataset to read-write on a default FreeBSD install.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据集在单用户模式下与多用户模式下一样可访问，但作为根的挂载数据集仍然是只读的。关闭它。我在这里将根数据集设置为可读写，适用于默认的FreeBSD安装。
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can now change the filesystem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以更改文件系统。
- en: '***Programs Available in Single-User Mode***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***单用户模式下可用的程序***'
- en: The commands available for your use depend on which partitions are mounted.
    Some basic commands are available on the root partition in */bin* and */sbin*,
    and they’re available even if root is mounted read-only. Others live in */usr*
    and are inaccessible until you mount that partition. (Take a look at */bin* and
    */sbin* on your system to get an idea of what you’ll have to work with when things
    go bad.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的命令取决于哪些分区已挂载。一些基本命令可以在根分区的*/bin*和*/sbin*中找到，即使根分区是只读的，它们也可以使用。其他命令存放在*/usr*中，直到挂载该分区之前无法访问。（看看系统中的*/bin*和*/sbin*，你可以了解在出现问题时可用的命令。）
- en: If you’ve scrambled your shared library system (see [Chapter 17](ch17.xhtml#ch17)),
    none of these programs will work. If you’re that unlucky, FreeBSD provides statically
    linked versions of many core utilities in the */rescue* directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你破坏了共享库系统（参见[第17章](ch17.xhtml#ch17)），这些程序将无法使用。如果你真的那么不幸运，FreeBSD在*/rescue*目录中提供了许多核心实用程序的静态链接版本。
- en: '***The Network in Single-User Mode***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***单用户模式下的网络***'
- en: If you want to have network connectivity in single-user mode, use the shell
    script */etc/netstart*. This script calls the appropriate scripts to start the
    network, gives IP addresses to interfaces, and enables packet filtering and routing.
    If you want some, but not all, of these services, you’ll need to read that shell
    script and execute the appropriate commands manually.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在单用户模式下保持网络连接，使用脚本*/etc/netstart*。该脚本会调用适当的脚本启动网络，给接口分配IP地址，并启用数据包过滤和路由。如果你只需要其中的一部分服务，你需要查看该脚本并手动执行适当的命令。
- en: '***Uses for Single-User Mode***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***单用户模式的用途***'
- en: In single-user mode, your access to the system is limited only by your knowledge
    of FreeBSD and Unix.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在单用户模式下，你对系统的访问仅受限于你对FreeBSD和Unix的了解。
- en: 'For example, if you’ve forgotten your root password, you can reset it from
    single-user mode:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你忘记了根密码，你可以从单用户模式重置它：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**NOTE**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll notice that you weren’t asked for the old root password. In single-user
    mode, you’re automatically root, and passwd(8) doesn’t ask root for any password.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*你会注意到系统并没有要求输入旧的根密码。在单用户模式下，你会自动成为root，而passwd(8)不会要求root输入任何密码。*'
- en: Or, if you find that there’s a typo in */etc/fstab* that confuses the system
    and makes it unbootable, you can mount the root partition with the device name
    and then edit */etc/fstab* to resolve the issue.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你发现*/etc/fstab*中有一个错误，导致系统无法启动，你可以通过设备名称挂载根分区，然后编辑*/etc/fstab*来解决问题。
- en: If you have a program that panics the system on boot and you need to stop that
    program from starting again, you can either edit */etc/rc.conf* to disable the
    program or set the permissions on the startup script so that it can’t execute.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个在启动时导致系统崩溃的程序，且你需要阻止该程序再次启动，你可以编辑*/etc/rc.conf*来禁用该程序，或者设置启动脚本的权限，使其无法执行。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ll discuss third-party programs (ports and packages) in [Chapter 15](ch15.xhtml#ch15).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第15章](ch15.xhtml#ch15)讨论第三方程序（端口和包）。
- en: You need to understand single-user mode to be a successful sysadmin, and we’ll
    refer to it throughout this book. For now, though, let’s look at the loader prompt.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解单用户模式才能成为一个成功的系统管理员，我们将在本书中多次提到它。不过现在，让我们先来看一下加载器提示。
- en: '**SYSTEM FAILURES VERSUS HUMAN FAILINGS**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统故障与人为错误**'
- en: There’s a reason all of these examples involve recovering from human errors.
    Hardware failures aren’t common, and FreeBSD failures, even less so. If it weren’t
    for human error, our computers would almost never let us down. As you learn more
    about FreeBSD, you’ll be more and more capable in single-user mode.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都涉及从人为错误中恢复的原因是有原因的。硬件故障并不常见，FreeBSD故障则更少。如果不是因为人为错误，我们的计算机几乎永远不会让我们失望。随着您对FreeBSD的了解不断深入，您将在单用户模式下变得越来越有能力。
- en: '**The Loader Prompt**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加载器提示符**'
- en: 'The loader prompt allows you to make basic changes to your computer’s boot
    environment and the variables that must be configured early in the boot process.
    It’s not a Unix-like environment; it’s cramped and supports only a minimal feature
    set. When you escape to a loader prompt (the third option in the boot menu), you’ll
    see the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器提示符允许您对计算机的启动环境和启动过程中必须配置的变量进行基本更改。它不是类Unix环境；它非常简陋，仅支持最小的功能集。当您进入加载器提示符（启动菜单中的第三个选项）时，您将看到如下内容：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the loader prompt. While the word *OK* might be friendly and reassuring,
    it’s one of the few friendly things about the loader environment. This isn’t a
    full-featured operating system; it’s a tool for configuring a system boot that’s
    not intended for the ignorant nor the faint of heart. Any changes you make at
    the loader prompt affect only the current boot. To undo changes, reboot again.
    (We’ll see how to make loader changes permanent in the next section.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是加载器提示符。虽然*OK*这个词可能显得友好且令人放心，但它是加载器环境中为数不多的友好特性之一。这不是一个功能齐全的操作系统；它是一个配置系统启动的工具，不适合不了解或胆小的人。您在加载器提示符下所做的任何更改只会影响当前的启动。要撤销更改，请重新启动。（我们将在下一节中看到如何使加载器更改永久生效。）
- en: To see all available commands, enter a question mark.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用的命令，请输入问号。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Many loader commands aren’t useful to anyone except a developer, so we’ll focus
    on the commands useful to a system administrator.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 许多加载器命令除了开发者外对其他人没有什么用处，因此我们将重点介绍对系统管理员有用的命令。
- en: '***Viewing Disks***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看磁盘***'
- en: To view the disks that the loader knows about, use `lsdev`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看加载器已识别的磁盘，请使用`lsdev`。
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The loader checks for CD drives ➊ and doesn’t find any. (The loader finds CD
    drives only if you boot from a CD, so don’t be alarmed by this.) It finds a hard
    drive, known to the BIOS as drive C ➋. It then describes the partitions on that
    hard drive. As we’ll see in [Chapter 10](ch10.xhtml#ch10), GPT partitions identify
    partitions with the letter *p* and a number. The partition disk0p1 ➌ is a FreeBSD
    boot partition used to bootstrap FreeBSD from the BIOS. You might find this knowledge
    useful on an unfamiliar system that’s having trouble booting. The loader can also
    identify the ZFS pools ➍ on the host.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器检查CD驱动器➊，但没有找到任何。 （只有在从CD启动时加载器才会找到CD驱动器，所以不要因此而惊慌。）它找到了一个硬盘，BIOS识别为C盘➋。然后它描述了该硬盘上的分区。如我们将在[第10章](ch10.xhtml#ch10)中看到的，GPT分区使用字母*p*和一个数字来标识分区。分区disk0p1
    ➌是一个FreeBSD启动分区，用于从BIOS启动FreeBSD。在一个不熟悉的系统上遇到启动问题时，这些知识可能会很有帮助。加载器还可以识别主机上的ZFS池
    ➍。
- en: '***Loader Variables***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加载器变量***'
- en: The loader has variables set within the kernel and by a configuration file.
    View these variables and their settings with the `show` command, and use the spacebar
    to advance to the next page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器在内核中和配置文件中设置了变量。使用`show`命令查看这些变量及其设置，并使用空格键翻到下一页。
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These values include low-level kernel tunables and information gleaned from
    the hardware BIOS or UEFI. We’ll see a partial list of loader variables in “[Loader
    Configuration](ch04.xhtml#lev111)” on [page 57](ch04.xhtml#page_57), and additional
    values will be brought up throughout the book in the appropriate sections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值包括低级内核调优参数以及从硬件BIOS或UEFI中获取的信息。我们将在[《加载器配置》](ch04.xhtml#lev111)一章的[第57页](ch04.xhtml#page_57)中看到加载器变量的部分列表，书中的相关章节也会提到更多的值。
- en: You can show specific variables by name. Sadly, you can’t show all of a keyword’s
    sub-variables. A command like `show acpi.oem` works, but `show acpi` or `show
    acpi.*` doesn’t.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按名称显示特定的变量。不幸的是，您不能显示一个关键字的所有子变量。像`show acpi.oem`这样的命令可以使用，但`show acpi`或`show
    acpi.*`则无法使用。
- en: 'Change a value for a single boot with the `set` command. For example, to change
    the `console` setting to `comconsole`, you’d enter:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set`命令可以更改单次启动的值。例如，要将`console`设置更改为`comconsole`，可以输入：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The loader lets you change variables that really shouldn’t change. Setting acpi.revision
    to 4 won’t suddenly upgrade your system to ACPI version 4, and you can’t change
    hard drives with a software setting.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器允许您更改那些本不应该更改的变量。将acpi.revision设置为4不会突然将您的系统升级到ACPI版本4，您也不能通过软件设置更换硬盘。
- en: '***Reboot***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重启***'
- en: You didn’t mean to get into the loader? Start over.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您不是故意进入加载器的吗？重新开始吧。
- en: '***Booting from the Loader***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从加载器引导***'
- en: Now that you’ve twiddled your system’s low-level settings, you probably want
    to boot the system. Use the boot(8) command. You can adjust the boot further using
    the boot flags discussed in the man page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经调整了系统的低级设置，您可能想要启动系统。使用boot(8)命令。您可以通过man页面中讨论的启动标志进一步调整启动。
- en: Once your system boots just the way you need it to, you’ll probably want to
    make those settings permanent. FreeBSD lets you do this through the loader configuration
    file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的系统启动到您需要的状态，您可能希望将这些设置永久保存。FreeBSD允许您通过加载器配置文件实现这一点。
- en: '**Loader Configuration**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加载器配置**'
- en: Make loader setting changes permanent with the configuration file */boot/loader.conf*.
    Settings in this file are fed directly into the boot loader at system startup.
    Of course, if you enjoy being at your console every time the system boots, then
    don’t bother with this!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置文件*/boot/loader.conf*使加载器设置永久生效。此文件中的设置会在系统启动时直接传递给引导加载器。当然，如果你喜欢每次系统启动时都呆在控制台前，那就不用管这个了！
- en: The loader has a default configuration file, */boot/defaults/loader.conf*. We
    override many of the values here.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器有一个默认的配置文件，*/boot/defaults/loader.conf*。我们在这里覆盖了许多值。
- en: 'If you look at the default loader configuration, you’ll see many options that
    resemble variables listed in the loader. For example, here we can set the name
    of the console device:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看默认的加载器配置，您会看到许多与加载器中列出的变量类似的选项。例如，在这里我们可以设置控制台设备的名称：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Throughout the FreeBSD documentation, you’ll see references to *boot-time tunables*
    and *loader settings*. All of these are set in *loader.conf*, which includes many
    sysctl values that are read-only once the system is up and kicking. (For more
    on tunables and sysctls, see [Chapter 6](ch06.xhtml#ch06).) Here, we force the
    kernel variable `kern.maxusers` to `32`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个FreeBSD文档中，您会看到提到*启动时可调节项*和*加载器设置*。这些设置都在*loader.conf*中配置，其中包括许多sysctl值，这些值在系统启动后变为只读。（有关可调节项和sysctl的更多信息，请参见[第6章](ch06.xhtml#ch06)）。在这里，我们将内核变量`kern.maxusers`强制设置为`32`。
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Some of these variables don’t have a specific value set in *loader.conf*; instead,
    they appear as empty quotes. This means that the loader normally lets the kernel
    set this value, but if you want to override the kernel’s setting, you can.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有些变量在*loader.conf*中没有设置特定值，而是以空引号出现。这意味着加载器通常让内核设置此值，但如果您想覆盖内核的设置，您可以这样做。
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The kernel has an idea of what the value of `kern.nbuf` should be, but you can
    have the loader dictate a different value if you must.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 内核对`kern.nbuf`的值有一定的认知，但如果需要，您可以让加载器指定一个不同的值。
- en: We’ll discuss system tuning via the boot loader in the appropriate section—for
    example, kernel values will be discussed in [Chapter 6](ch06.xhtml#ch06), where
    they’ll make something resembling sense—but here are some commonly used loader
    values that affect the appearance and operation of the loader itself and basic
    boot functionality. As FreeBSD matures, the developers introduce new loader values
    and alter the functionality of old ones, so be sure to check */boot/defaults/loader.conf*
    on your installation for the current list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在适当的部分讨论通过引导加载器进行系统调优——例如，内核值将在[第6章](ch06.xhtml#ch06)中讨论，届时它们会变得有点道理——但在这里，有一些常用的加载器值，影响加载器本身的外观和操作以及基本的启动功能。随着FreeBSD的成熟，开发人员会引入新的加载器值并修改旧的功能，所以一定要检查您的安装中的*/boot/defaults/loader.conf*，以获取当前的列表。
- en: boot_verbose="NO"
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: boot_verbose="NO"
- en: This value toggles the verbose boot mode that you can reach through the boot
    menu. In a standard boot, the kernel prints out a few basic notes about each device
    as it identifies system hardware. When you boot in verbose mode, the kernel tells
    each device driver to print out any and all information it can about each device
    as well as display assorted kernel-related setup details. Verbose mode is useful
    for debugging and development, but not generally for day-to-day use.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值切换你可以通过启动菜单访问的详细启动模式。在标准启动中，内核会打印出一些关于每个设备的基本信息。当你以详细模式启动时，内核会要求每个设备驱动程序打印出它能获取的关于设备的所有信息，并显示各种内核相关的设置细节。详细模式对于调试和开发很有用，但通常不适合日常使用。
- en: autoboot_delay="10"
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: autoboot_delay="10"
- en: This value indicates the number of seconds between the display of the boot menu
    and the automatic boot. I frequently turn this down to 2 or 3 seconds, as I want
    my machines to come up as quickly as possible.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值表示启动菜单显示与自动启动之间的秒数。我经常将其调低到 2 或 3 秒，因为我希望我的机器尽可能快地启动。
- en: beastie_disable="NO"
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: beastie_disable="NO"
- en: This value controls the appearance of the boot menu (originally, an ASCII art
    image of the BSD “Beastie” mascot decorated the boot menu). If set to `YES`, the
    boot menu will not appear.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值控制启动菜单的显示方式（最初，BSD “Beastie” 吉祥物的 ASCII 艺术图片装饰了启动菜单）。如果设置为 `YES`，启动菜单将不会显示。
- en: loader_logo="fbsdbw"
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: loader_logo="fbsdbw"
- en: This value allows you to choose which logo appears to the right of the boot
    menu. The `fbsdbw` option gives you the default FreeBSD logo in ASCII art. Other
    options include `beastiebw` (the original logo), `beastie` (the logo in color),
    and `none` (no logo).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值允许你选择启动菜单右侧显示的 logo。`fbsdbw` 选项给你默认的 FreeBSD ASCII 艺术 logo。其他选项包括 `beastiebw`（原始
    logo）、`beastie`（彩色 logo）和 `none`（无 logo）。
- en: '**Boot Options**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**启动选项**'
- en: 'The boot menu also presents three options: choosing a kernel, setting boot
    options, and selecting a boot environment. We’ll discuss each of these in an appropriate
    section, but here’s a bit to orient you.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 启动菜单还提供了三个选项：选择内核、设置启动选项和选择启动环境。我们将在适当的章节中讨论这些内容，但这里有一些简要的介绍，帮助你入门。
- en: A host can have multiple kernels in its */boot* directory. Hitting the *Kernel*
    option tells the loader to cycle between the available options. To have a kernel
    appear as an option, list it in *loader.conf* in the kernels variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一台主机可以在其 */boot* 目录下拥有多个内核。选择 *Kernel* 选项会让加载器在可用的选项之间循环切换。要让某个内核作为选项出现，需要在
    *loader.conf* 中的 kernels 变量中列出它。
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The menu recognizes kernels only in directories beginning with */boot/kernel*.
    If you have a kernel in */boot/gerbil*, you’ll have to load it from the loader
    prompt.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单只识别以 */boot/kernel* 开头的目录中的内核。如果你有一个内核在 */boot/gerbil* 中，你将需要从加载器提示符加载它。
- en: FreeBSD supports a number of boot options. Selecting the *Configure Boot Options*
    item brings up the most popular.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 支持多种启动选项。选择 *Configure Boot Options* 项目会弹出最常用的选项。
- en: '**Load System Defaults**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**加载系统默认值**'
- en: You mucked with your settings and want to undo all that? Choose this. You can
    at least boot the system to single-user mode and fix your *loader.conf*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你调整了设置并希望撤销所有这些操作？选择这个。你至少可以将系统启动到单用户模式，并修复你的 *loader.conf*。
- en: '**ACPI Support**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**ACPI 支持**'
- en: ACPI is the Advanced Configuration and Power Interface, an Intel/Toshiba/Microsoft
    standard for hardware configuration. It replaces and subsumes a whole bunch of
    obscure standards. ACPI has been a standard for many years now, but if a particular
    piece of hardware has trouble running FreeBSD, you can turn it off and see what
    happens. If you even think of trying this option, also read [Chapter 24](ch24.xhtml#ch24)
    and file a bug report.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ACPI 是高级配置和电源接口（Advanced Configuration and Power Interface），是英特尔/东芝/微软的硬件配置标准。它取代并包含了一堆晦涩的标准。ACPI
    已经成为标准多年，但如果某个硬件在运行 FreeBSD 时遇到问题，你可以关闭它看看会发生什么。如果你甚至考虑尝试这个选项，务必阅读[第24章](ch24.xhtml#ch24)并提交一个
    bug 报告。
- en: '**Safe Mode**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全模式**'
- en: FreeBSD’s *safe mode* turns on just about every conservative option in the operating
    system. It turns off DMA and write caching on hard disks, limiting their speed
    but increasing their reliability. It turns off ACPI. 32-bit systems disable SMP.
    USB keyboards no longer work in safe mode. This option is useful for debugging
    older hardware.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的 *安全模式* 启用了操作系统中几乎所有保守的选项。它关闭了硬盘的 DMA 和写入缓存，限制了速度但提高了可靠性。它还关闭了 ACPI。32
    位系统会禁用 SMP。在安全模式下，USB 键盘将不再工作。这个选项对于调试旧硬件非常有用。
- en: '**Verbose**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细模式**'
- en: The FreeBSD kernel probes every piece of hardware as it boots. Most of the information
    discovered is irrelevant to day-to-day use, so the boot loader doesn’t display
    it. When you boot in verbose mode, FreeBSD prints all the details it can about
    every system setting and attached device. The information will be available later
    in */var/run/dmesg.boot*, as discussed in the next section. I encourage you to
    try verbose mode on new machines, just to glimpse the system’s complexity.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD内核在启动时会探测每一块硬件。大多数发现的信息与日常使用无关，因此引导加载程序不会显示它们。当您以详细模式启动时，FreeBSD会打印出它能获取的每个系统设置和附加设备的所有细节。这些信息稍后将在*/var/run/dmesg.boot*中可用，正如下一节所讨论的那样。我鼓励您在新机器上尝试详细模式，看看系统的复杂性。
- en: Finally, the *Select Boot Environment* option lets you choose between ZFS boot
    environments, as discussed in [Chapter 12](ch12.xhtml#ch12).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*选择启动环境*选项允许您在ZFS启动环境之间进行选择，如[第12章](ch12.xhtml#ch12)所讨论的。
- en: '**Startup Messages**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**启动消息**'
- en: 'A booting FreeBSD system displays messages indicating the hardware attached
    to the system, the operating system version, and the status of various programs
    and services as they start. These messages are important when you first install
    your system and when you do troubleshooting. The boot messages always start off
    the same way, with a statement listing the copyrights for the FreeBSD Project
    and the Regents of the University of California:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 启动中的FreeBSD系统会显示指示系统附加硬件、操作系统版本以及各种程序和服务启动状态的消息。这些消息在您首次安装系统和进行故障排除时非常重要。启动消息总是以相同的方式开始，首先列出FreeBSD项目和加利福尼亚大学董事会的版权声明：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In addition, you get a notice of the version of FreeBSD that’s booting, along
    with the date and time it was compiled and the compiler used. You can also see
    who compiled this kernel, what machine it was built on, and even where in the
    filesystem this kernel was built. If you build a lot of kernels, this information
    can be invaluable when trying to identify exactly what system features are available.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还会看到正在启动的FreeBSD版本的通知，以及它的编译日期和时间以及使用的编译器。您还可以看到是谁编译了这个内核，在哪台机器上构建的，甚至可以看到这个内核是在文件系统中的哪个位置构建的。如果您经常构建内核，这些信息在确定系统特性时可能非常有价值。
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The kernel will print out diagnostic messages throughout the boot process. The
    preceding message means that I have debugging and fault-identifying code enabled
    in this particular kernel, and my performance will suffer as a result. In this
    case, I don’t care about the performance impact, for reasons which will become
    clear momentarily.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将在整个启动过程中打印诊断消息。前面的消息意味着我在这个特定的内核中启用了调试和故障识别代码，因此我的性能将受到影响。在这种情况下，我不关心性能影响，原因稍后会变得清晰。
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This message identifies a particular piece of hardware. The *timecounter*,
    or *hardware clock*, is a special piece of hardware, and while your computer needs
    one, it’s such a low-level device that the end user really can’t do much with
    it directly. Now and then, you’ll see messages like this for hardware that isn’t
    directly visible to the user but is vital to the system. The boot messages dance
    between showing too much detail and obscuring details that might be critical.
    For example, it’ll also show all the information it can about the CPU in the system:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息标识了特定的硬件。*时间计数器*，或*硬件时钟*，是一种特殊的硬件，虽然您的计算机需要它，但它是如此低级的设备，最终用户实际上无法直接使用它。偶尔，您会看到类似的消息，涉及一些对用户不可见但对系统至关重要的硬件。启动消息在显示过多细节和隐藏可能至关重要的细节之间摇摆。例如，它还会显示系统中CPU的所有信息：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You probably didn’t know that a simple CPU could have so many details and features,
    did you? But when you file a trouble report that advanced features don’t work,
    a developer might respond by asking whether your CPU has a particular feature.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不知道，简单的CPU竟然有如此多的细节和特性，对吧？但是当您提交故障报告时，指出某些高级特性无法正常工作，开发人员可能会问您的CPU是否具有某个特定的特性。
- en: 'Here’s why I’m not worried about the performance hit caused by the `WITNESS`
    option shown earlier: this box is pretty darn fast ➊ and supports a whole bunch
    of features important to modern CPUs ➋. While I certainly want all the performance
    I paid for, I also want to catch any problems when they happen. I want to be able
    to file good bug reports on those problems, so the developers will listen to my
    problem report. That’s *why* I’m running a development version of FreeBSD that
    ships with WITNESS enabled, after all!'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我不担心之前提到的`WITNESS`选项所导致的性能损失的原因：这台机器相当快➊，并且支持许多对现代CPU来说至关重要的功能➋。虽然我当然希望能够充分利用我所支付的性能，但我也希望在问题发生时能够及时捕捉到。我希望能够针对这些问题提交有效的
    bug 报告，这样开发者才能听到我的问题报告。毕竟，这就是*为什么*我会运行带有 WITNESS 启用的 FreeBSD 开发版本！
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the kernel announces that it’s found all eight CPU cores and is ready
    to manage them. I have CPU power to spare and a fair amount of memory as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内核宣布它已经找到了所有八个 CPU 核心，并准备好管理它们。我有充足的 CPU 和相当多的内存。
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The *real* memory ➊ is the amount of RAM physically installed in the computer,
    while the *avail* memory ➋ is the amount of memory left over after the kernel
    is loaded. I have 31,669MB of RAM ➌ available for real work, which more than suffices
    for the load on this system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际*内存➊是计算机中实际安装的 RAM 数量，而*可用*内存➋是内核加载后剩余的内存。我的系统有 31,669MB 的 RAM ➌ 可供实际使用，这足以应对当前系统的负载。'
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here’s a fairly typical device entry. This device is known as ioapic, and the
    kernel has found that this hardware is version 2.0 and has extra information associated
    with it ➋. What’s more, we’ve found two devices of that type, numbered 0 ➊ and
    1 ➌. (All devices are numbered starting with zero.) You can find out more about
    the device by reading the man page for the device driver. Almost all—but not all—device
    drivers have man pages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当典型的设备条目。这个设备被称为 ioapic，内核已经发现这个硬件是 2.0 版本，并且有额外的信息与之关联➋。更重要的是，我们发现了两个这种类型的设备，编号为
    0 ➊ 和 1 ➌。（所有设备的编号从零开始。）你可以通过阅读设备驱动程序的手册页来了解更多关于这个设备的信息。几乎所有—但并非全部—设备驱动程序都有手册页。
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Not all device drivers print all their information on a single line. Here, we
    have a single device, usbus, that takes up three lines with just a single instance
    of the device. The only way to know that this is a single USB bus rather than
    three separate ones is to check the number of the device. All of these are for
    device number zero, so it’s a single device.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有设备驱动程序都将它们的所有信息打印在一行上。在这里，我们有一个单一设备，usbus，它用三行来表示仅有的一个设备实例。唯一知道这是单一 USB
    总线而非三个独立总线的方法是检查设备的编号。所有这些都属于设备编号零，所以它是一个单一设备。
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: One interesting thing about the boot messages is that they display how your
    computer’s components are attached to one another. Here, we have pci0 ➊, a PCI
    interface directly on the mainboard. Then, there’s pcib8 ➋, PCI bridge number
    eight attached to pci0 ➌. We also find PCI bus pci8 ➍ attached to that PCI bridge
    ➎. As you read on, you’ll find individual devices attached to that bus. You might
    not be equipped to do much with this information now, but you’ll find that having
    it available will be valuable when you have to troubleshoot a problem.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 启动信息的一个有趣之处是，它们展示了计算机各个组件是如何连接在一起的。在这里，我们有 pci0 ➊，一个直接在主板上的 PCI 接口。然后是 pcib8
    ➋，第八号 PCI 桥接器，连接到 pci0 ➌。我们还发现了连接到该 PCI 桥接器的 PCI 总线 pci8 ➍。继续阅读，你会发现连接到该总线的各个设备。现在你可能无法对这些信息做太多事情，但你会发现，当你需要排除故障时，拥有这些信息会非常有价值。
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This entry shows em0, a network card of type em(4) ➊, and indicates that the
    card speaks gigabit Ethernet ➋. We also see all sorts of information about its
    memory address, IRQ, and PCI bus attachment.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目显示了 em0，一个 em(4) 类型的网络卡➊，并指出该卡支持千兆以太网➋。我们还看到关于它的内存地址、IRQ 和 PCI 总线连接等各种信息。
- en: Every device on your computer has one or more entries like these. Taken as a
    whole, they describe your computer’s hardware in reasonable detail. If you boot
    in verbose mode, you’ll see even more detail—probably far more than you want.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你计算机上的每个设备都有一个或多个类似这样的条目。整体来看，它们合理详细地描述了你计算机的硬件。如果你以详细模式启动，你会看到更多的细节—可能比你想要的还要多。
- en: '**THE BOOT MESSAGES FILE**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**启动信息文件**'
- en: While the boot information is handy, chances are it’ll disappear from the screen
    by the time you need it. For future reference, FreeBSD stores boot messages in
    the file */var/run/dmesg.boot*. This means that you can inspect your kernel’s
    hardware messages even after your system has been up and running for months.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管启动信息很有用，但它很可能在你需要时已经从屏幕上消失。为了将来参考，FreeBSD 会将启动消息存储在文件 */var/run/dmesg.boot*
    中。这意味着即使系统已经运行了几个月，你仍然可以查看内核的硬件消息。
- en: One key thing that the kernel displays in the boot messages is the device name
    for each piece of hardware. This is critical information for managing your system.
    Every piece of hardware has a device node name, and to configure it, you’ll need
    to know that name. For example, earlier we saw an entry for an Ethernet card called
    em0\. The card uses the em(4) driver, and the first device controlled by this
    driver has number zero. Your second device of this type would be em1, then em2,
    and so on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 内核在启动消息中显示的一个关键内容是每个硬件设备的设备名称。这对于管理系统至关重要。每个硬件设备都有一个设备节点名称，要配置它，你需要知道这个名称。例如，之前我们看到了一张名为
    em0 的以太网卡。该卡使用 em(4) 驱动程序，第一个由此驱动程序控制的设备编号为零。第二个同类型的设备将是 em1，接着是 em2，以此类推。
- en: Most devices that can be configured or managed have a device node entry somewhere
    under */dev*. For example, the first optical drive is represented by the file
    */dev/cd0*. These files are called *device nodes*, and they’re a convenient way
    to address a particular piece of hardware. Most device nodes can’t be directly
    accessed as a regular file; you can’t cat(1) a device node or copy another file
    to it. However, device nodes are used as arguments to specialized programs. For
    example, the hard drive that showed up at boot as ada4 is the same as the device
    node */dev/ada4*. When you want to mount that hard drive, you can use the device
    node name and be sure you’re getting that exact piece of hardware.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可以配置或管理的设备都会在 */dev* 目录下的某个位置有一个设备节点条目。例如，第一个光驱由文件 */dev/cd0* 表示。这些文件被称为
    *设备节点*，它们是指向特定硬件的便捷方式。大多数设备节点不能像常规文件那样直接访问；你不能对设备节点使用 cat(1) 命令，也不能将另一个文件复制到它上面。然而，设备节点会作为参数传递给专门的程序。例如，启动时出现的硬盘
    ada4 与设备节点 */dev/ada4* 是相同的。当你想挂载这块硬盘时，可以使用设备节点名称，确保你正处理的是那块特定的硬件。
- en: '**Multiuser Startup**'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**多用户启动**'
- en: Beyond single-user mode, you’ll find multiuser mode. This is the standard operating
    mode for a Unix-like OS. If you’re doing real work, your system is in multiuser
    mode.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 超越单用户模式，你将找到多用户模式。这是类似 Unix 的操作系统的标准操作模式。如果你在做实际工作，你的系统处于多用户模式。
- en: When FreeBSD finishes inspecting the hardware and attaching all the device drivers
    appropriately, it runs the shell script */etc/rc*. This script mounts all filesystems,
    brings up the network interfaces, configures device nodes, identifies available
    shared libraries, and does all the other work necessary to make a system ready
    for normal work. Most systems have different startup requirements; while almost
    every server needs to mount a hard drive, a web server’s operating requirements
    are very different from those of a database server, even if it’s running on absolutely
    identical hardware. This means that */etc/rc* must be extremely flexible. It achieves
    flexibility by delegating everything to other shell scripts responsible for specific
    aspects of the system.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当 FreeBSD 完成硬件检测并适当地加载所有设备驱动程序后，它会运行 shell 脚本 */etc/rc*。该脚本挂载所有文件系统，启动网络接口，配置设备节点，识别可用的共享库，并完成其他使系统准备好进行正常工作的任务。大多数系统有不同的启动要求；虽然几乎所有服务器都需要挂载硬盘，但
    Web 服务器的操作要求与数据库服务器的操作要求非常不同，即使它们运行在完全相同的硬件上。这意味着 */etc/rc* 必须非常灵活。它通过将所有任务委派给其他负责系统特定方面的
    shell 脚本来实现灵活性。
- en: The */etc/rc* script is controlled by the files */etc/defaults/rc.conf* and
    */etc/rc.conf*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/rc* 脚本由文件 */etc/defaults/rc.conf* 和 */etc/rc.conf* 控制。'
- en: '***/etc/rc.conf, /etc/rc.conf.d, and /etc/defaults/rc.conf***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***/etc/rc.conf、/etc/rc.conf.d 和 /etc/defaults/rc.conf***'
- en: 'Much like the loader configuration file, the configuration of */etc/rc* is
    split between two files: the default settings file, */etc/defaults/rc.conf*, and
    the local settings file, */etc/rc.conf*. Settings in */etc/rc.conf* override any
    values given in */etc/defaults/rc.conf*, exactly as with the loader.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与加载器配置文件类似，*/etc/rc* 的配置分为两个文件：默认设置文件 */etc/defaults/rc.conf* 和本地设置文件 */etc/rc.conf*。
    */etc/rc.conf* 中的设置会覆盖 */etc/defaults/rc.conf* 中的任何值，正如加载器的配置方式一样。
- en: The */etc/defaults/rc.conf* file is huge and contains quite a few variables,
    frequently called *knobs*, or *tunables*. We aren’t going to discuss all of them,
    not only because knobs are added continually and such a list would be immediately
    obsolete but also because quite a few knobs aren’t commonly used on servers. Almost
    everything in a standard FreeBSD system has one or more *rc.conf* knobs, from
    your keyboard map to TCP/IP behavior. For a complete, up-to-date list, read rc.conf(5).
    To change *rc.conf* settings, you can either use a text editor or sysrc(8).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/defaults/rc.conf* 文件非常庞大，包含许多变量，通常被称为 *knobs* 或 *tunables*。我们不会讨论所有这些变量，不仅因为
    knobs 会不断增加，列出它们会很快过时，还因为很多 knobs 在服务器上并不常用。几乎 FreeBSD 系统中的每个东西都有一个或多个 *rc.conf*
    knobs，从键盘映射到 TCP/IP 行为。要查看完整且最新的列表，请阅读 rc.conf(5)。要更改 *rc.conf* 设置，可以使用文本编辑器或
    sysrc(8)。'
- en: '**sysrc(8)**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**sysrc(8)**'
- en: While editing *rc.conf* by hand works just fine, in this age of cloud computing,
    it’s not sustainable across large numbers of machines. If you must change dozens
    of servers, you need a reliable way to alter the system without either manually
    editing each server’s config or resorting to sed/awk hackery.^([2](footnote.xhtml#ch04fn2))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手动编辑 *rc.conf* 完全可行，但在云计算时代，这种方式在大量机器上不可持续。如果必须修改数十台服务器，你需要一种可靠的方法来修改系统，而不是手动编辑每台服务器的配置或依赖
    sed/awk 的“黑客”方法。^([2](footnote.xhtml#ch04fn2))
- en: FreeBSD includes sysrc(8), a command line program to consistently and safely
    alter */etc/rc.conf* and friends from the command line. Additionally, sysrc(8)
    can display information about your system’s non-default settings.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包括 sysrc(8)，这是一个命令行程序，可以一致且安全地从命令行修改 */etc/rc.conf* 及其相关文件。此外，sysrc(8)
    还可以显示有关系统非默认设置的信息。
- en: Start by using `-a` to ask sysrc(8) what it knows about your host.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-a` 来询问 sysrc(8) 你主机的相关信息。
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You’ll get a list of all non-default */etc/rc.conf* settings.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得所有非默认 */etc/rc.conf* 设置的列表。
- en: To have sysrc(8) enable a service, give it the variable name, an equals sign,
    and the new value.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 sysrc(8) 启用某个服务，提供变量名、等号和新值。
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The variable `rc_startmsgs` is now set to `no`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `rc_startmsgs` 现在被设置为 `no`。
- en: Remember that sysrc(8) is a tool for changing *rc.conf*, not for configuring
    FreeBSD. It does no validity checking. One of my very junior sysadmins really
    doesn’t want Bert logging in, and he took some bad advice on how to prevent that.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，sysrc(8) 是一个用于更改 *rc.conf* 的工具，而不是用来配置 FreeBSD 的工具。它不会进行有效性检查。我一个非常初级的系统管理员不希望
    Bert 登录，他根据一些错误的建议进行了设置。
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While this code sets `bert="no"` in */etc/rc.conf*, this variable doesn’t do
    anything. Remove it with the `-x` flag.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码在 */etc/rc.conf* 中设置了 `bert="no"`，但这个变量并没有任何作用。可以通过 `-x` 参数删除它。
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Many FreeBSD configuration files closely resemble *rc.conf*. You can use sysrc(8)
    to manage them by adding the `-f` flag and the file name.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 FreeBSD 配置文件与 *rc.conf* 类似。你可以通过添加 `-f` 参数和文件名，使用 sysrc(8) 来管理它们。
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Should you edit *rc.conf* or use sysrc(8)? If you’re making manual changes,
    then use whichever you prefer. Automation should err on the side of sysrc(8).
    This book mixes examples of both.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 是否应该编辑 *rc.conf* 或使用 sysrc(8)？如果你是在进行手动修改，那么使用你偏好的方式。如果是自动化操作，应该倾向于使用 sysrc(8)。本书中混合了两者的示例。
- en: '**/etc/rc.conf.d/**'
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/etc/rc.conf.d/**'
- en: If you use a server configuration system such as Puppet or Ansible, you might
    trust copying entire files more than editing them. Use */etc/rc.conf.d/* files
    to enable services through such tools.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用像 Puppet 或 Ansible 这样的服务器配置系统，你可能更信任复制整个文件而不是编辑它们。通过这些工具，使用 */etc/rc.conf.d/*
    文件来启用服务。
- en: To manage a service in */etc/rc.conf.d/*, create a file named after the service.
    That is, to manage bsnmpd(8) you’d create */etc/rc.conf.d/bsnmpd*. Enable or disable
    that service in this file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 */etc/rc.conf.d/* 中管理一个服务，创建一个以服务名称命名的文件。也就是说，要管理 bsnmpd(8)，你需要创建 */etc/rc.conf.d/bsnmpd*。在该文件中启用或禁用该服务。
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I normally use Ansible’s service enabling features that directly alter */etc/rc.conf*
    rather than */etc/rc.conf.d*, but use whatever you prefer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常使用 Ansible 的服务启用功能，直接修改 */etc/rc.conf* 而不是 */etc/rc.conf.d*，但可以根据个人喜好选择使用。
- en: The next few sections illustrate the types of things you can enable and disable
    in */etc/rc.conf*. Each appears in */etc/defaults/rc.conf* and can be overridden
    by an */etc/rc.conf* entry. Each variable appears with its default setting.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节展示了你可以在 */etc/rc.conf* 中启用和禁用的各种内容。每个设置都会出现在 */etc/defaults/rc.conf* 中，并可以通过
    */etc/rc.conf* 条目进行覆盖。每个变量都带有默认设置。
- en: '**Startup Options**'
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**启动选项**'
- en: The following *rc.conf* options control how FreeBSD configures itself and starts
    other programs. These far-reaching settings affect how all other system programs
    and services run.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下*rc.conf*选项控制FreeBSD如何配置自身并启动其他程序。这些深远的设置会影响所有其他系统程序和服务的运行。
- en: If you’re having a problem with the startup scripts themselves, you might enable
    debugging on */etc/rc* and its subordinate scripts. This can provide additional
    information about why a script is or isn’t starting.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到启动脚本本身的问题，您可以在*/etc/rc*及其下属脚本上启用调试功能。这可以提供有关脚本为何未能启动的额外信息。
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you don’t need the full debugging output but would like some additional
    information about the */etc/rc process*, enable informational messages with `rc_info`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要完整的调试输出，但希望获得有关*/etc/rc过程*的额外信息，可以使用`rc_info`启用信息性消息：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the boot process hits multiuser startup, it prints out a message for each
    daemon it starts. Remove those messages with the `rc_startmsgs` option.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动过程进入多用户启动阶段时，它会打印出每个启动的守护进程的消息。使用`rc_startmsgs`选项可以移除这些消息。
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Filesystem Options**'
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**文件系统选项**'
- en: FreeBSD can use memory as a filesystem, as we’ll discuss in [Chapter 13](ch13.xhtml#ch13).
    One common use for this feature is to make */tmp* really fast by using memory
    rather than a hard drive as its backend. Once you’ve read [Chapter 13](ch13.xhtml#ch13),
    you might consider implementing this. Variables in *rc.conf* let you enable a
    memory-backed */tmp* and set its size transparently and painlessly. You can also
    choose the options FreeBSD will use to complete the filesystem. (The impatient
    among you are probably wondering what the `-S` flag means. It means *disable soft
    updates*. If you have no idea what this means, either, wait for [Chapter 11](ch11.xhtml#ch11).)
    If you want to use a memory filesystem */tmp*, set `tmpmfs` to `YES` and set `tmpsize`
    to the desired size of your */tmp*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD可以使用内存作为文件系统，正如我们在[第13章](ch13.xhtml#ch13)中讨论的那样。此功能的一个常见用途是通过使用内存而不是硬盘来加速*/tmp*。在阅读完[第13章](ch13.xhtml#ch13)后，您可能会考虑实现此功能。*rc.conf*中的变量允许您启用内存支持的*/tmp*并透明、轻松地设置其大小。您还可以选择FreeBSD将使用哪些选项来完成文件系统的配置。（那些急切的朋友们可能在想`-S`标志意味着什么。它的意思是*禁用软更新*。如果你不知道这是什么意思，也请等到[第11章](ch11.xhtml#ch11)再来看。）如果您想使用内存文件系统作为*/tmp*，请将`tmpmfs`设置为`YES`，并将`tmpsize`设置为您希望的*/tmp*大小。
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another popular FreeBSD filesystem feature is its integrated encrypted partitions.
    FreeBSD supports two different filesystem encryption systems out of the box: GBDE
    and GELI. *GEOM-Based Disk Encryption (GBDE)* was FreeBSD’s first encrypted filesystem
    designed for military-grade use. GELI is a little more friendly and complies with
    different standards than GBDE. (You definitely want to read [Chapter 23](ch23.xhtml#ch23)
    before enabling either of these!)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的FreeBSD文件系统功能是其集成的加密分区。FreeBSD开箱即用支持两种不同的文件系统加密系统：GBDE和GELI。*基于GEOM的磁盘加密（GBDE）*是FreeBSD设计的第一个加密文件系统，旨在用于军事级别的安全。GELI则更加友好，并且符合与GBDE不同的标准。（在启用这些功能之前，您一定要阅读[第23章](ch23.xhtml#ch23)！）
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By default, FreeBSD mounts the root partition read-write upon achieving multiuser
    mode. If you want to run in read-only mode instead, you can set the following
    variable to `NO`. Many people consider this more secure, but a read-only root
    can interfere with operation of certain software, and it’ll certainly prevent
    you from editing any files on the root partition!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，FreeBSD在进入多用户模式后会以可读写的方式挂载根分区。如果您希望改为以只读模式运行，可以将以下变量设置为`NO`。许多人认为这种方式更安全，但只读根分区可能会干扰某些软件的运行，并且肯定会阻止您编辑根分区上的任何文件！
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When a booting FreeBSD attempts to mount its filesystems, it checks them for
    internal consistency. If the kernel finds major filesystem problems, it can try
    to fix them automatically with `fsck -y`. While this is necessary in certain situations,
    it’s not entirely safe. (Be sure to read [Chapter 11](ch11.xhtml#ch11) very carefully
    before enabling this!)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动中的FreeBSD尝试挂载其文件系统时，它会检查文件系统的内部一致性。如果内核发现文件系统存在重大问题，它可以尝试使用`fsck -y`自动修复这些问题。虽然在某些情况下这是必要的，但并非完全安全。（在启用此功能之前，请务必仔细阅读[第11章](ch11.xhtml#ch11)！）
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The kernel might also find minor filesystem problems, which it resolves on the
    fly using a *background fsck* while the system is running in multiuser mode, as
    discussed in [Chapter 11](ch11.xhtml#ch11). There are legitimate concerns about
    the safety of using this feature in certain circumstances. You can control the
    use of background fsck and set how long the system will wait before beginning
    the background fsck.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 内核可能还会发现一些小的文件系统问题，它会在系统以多用户模式运行时，通过使用*后台 fsck* 自动解决这些问题，正如在[第11章](ch11.xhtml#ch11)中讨论的那样。在某些情况下，使用此功能的安全性存在合理的担忧。你可以控制后台
    fsck 的使用，并设置系统在开始后台 fsck 之前等待多长时间。
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Miscellaneous Network Daemons**'
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**杂项网络守护进程**'
- en: FreeBSD includes many smaller programs, or daemons, that run in the background
    to provide specific services. We’ll cover quite a few of these integrated services
    throughout the book, but here are a few specific ones that’ll be of interest to
    experienced system administrators. One popular daemon is syslogd(8). Logs are
    a Good Thing. Logs are so very, *very* good that large parts of [Chapter 21](ch21.xhtml#ch21)
    are devoted to the topic of logging with, for, by, and on FreeBSD.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包含许多较小的程序或守护进程，它们在后台运行以提供特定的服务。我们将在全书中介绍一些集成服务，但这里有几个对有经验的系统管理员来说特别有用的守护进程。一个流行的守护进程是
    syslogd(8)。日志是好东西。日志是如此*非常*好，以至于[第21章](ch21.xhtml#ch21)的大部分内容都专门讨论了在 FreeBSD 上如何使用、为、通过和在日志记录。
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once you’ve decided to run the logging daemon, you can choose exactly how it’ll
    run by setting command line flags for it. FreeBSD will use these flags when starting
    the daemon. For all the programs included in *rc.conf* that can take command line
    flags, the flags are given in this format:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦决定运行日志守护进程，你可以通过设置命令行标志来精确控制它的运行方式。FreeBSD 在启动守护进程时会使用这些标志。所有可以接受命令行标志的 *rc.conf*
    中的程序，都采用以下格式设置标志：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Another popular daemon is inetd(8), the server for small network services. (We
    cover inetd in [Chapter 20](ch20.xhtml#ch20).)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的守护进程是 inetd(8)，它是用于小型网络服务的服务器。（我们在[第20章](ch20.xhtml#ch20)中介绍 inetd。）
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Most systems use the Secure Shell (SSH) daemon for remote logins. If you want
    to connect to your system remotely over the network, you’ll almost certainly need
    SSH services.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统使用安全外壳（SSH）守护进程进行远程登录。如果你希望通过网络远程连接到你的系统，几乎可以肯定需要 SSH 服务。
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: While the SSH daemon can be configured via the command line, you’re generally
    better off using the configuration files in */etc/ssh/*. See [Chapter 20](ch20.xhtml#ch20)
    for details.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过命令行配置 SSH 守护进程，但通常更好的方法是使用 */etc/ssh/* 中的配置文件。有关详细信息，请参见[第20章](ch20.xhtml#ch20)。
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: FreeBSD also incorporates extensive time-keeping software that functions to
    ensure the system clock remains synchronized with the rest of the world. You’ll
    need to configure this for it to be useful; we’ll cover that in [Chapter 20](ch20.xhtml#ch20).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 还集成了广泛的时间同步软件，确保系统时钟与外部世界同步。你需要配置这些设置才能使其有效；我们将在[第20章](ch20.xhtml#ch20)中详细讨论。
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In addition, FreeBSD includes a small SNMP daemon for use in facilities with
    SNMP-based management tools. We’ll cover configuring SNMP in [Chapter 21](ch21.xhtml#ch21).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，FreeBSD 还包括一个小型的 SNMP 守护进程，用于与基于 SNMP 的管理工具配合使用。我们将在[第21章](ch21.xhtml#ch21)中讨论如何配置
    SNMP。
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Network Options**'
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**网络选项**'
- en: These knobs control how FreeBSD configures its network facilities during boot.
    We’ll discuss networking in [Chapter 7](ch07.xhtml#ch07).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制项决定了 FreeBSD 在启动时如何配置其网络设施。我们将在[第7章](ch07.xhtml#ch07)中讨论网络配置。
- en: Every machine on the internet needs a hostname. The hostname is the fully qualified
    domain name of the system, such as *www.absolutefreebsd.org*. Many programs won’t
    run properly without this.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的每台机器都需要一个主机名。主机名是系统的完全合格域名，例如 *www.absolutefreebsd.org*。没有这个主机名，许多程序将无法正常运行。
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: FreeBSD includes a few different integrated firewall packages. We’re going to
    briefly cover the packet filter (PF) in [Chapter 19](ch19.xhtml#ch19). Enable
    and disable PF in *rc.conf*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包括一些不同的集成防火墙软件包。我们将在[第19章](ch19.xhtml#ch19)中简要介绍包过滤器（PF）。在 *rc.conf*
    中启用和禁用 PF。
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You might be interested in failed attempts to connect to your system over the
    network. This will help detect port scans and network intrusion attempts, but
    it’ll also collect a lot of garbage. It’s interesting to set this for a short
    period of time just to see what really happens on your network. (Then again, knowing
    what’s *really* going on tends to cause heartburn.) Set this to `1` to log failed
    connection attempts.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对网络上尝试连接到你的系统的失败尝试感兴趣。这有助于检测端口扫描和网络入侵尝试，但也会收集大量垃圾数据。短时间内设置它查看网络上真正发生了什么会很有趣。（不过，知道什么是*真正*发生的往往会引起焦虑。）设置为
    `1` 以记录失败的连接尝试。
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Routers use ICMP redirects to inform client machines of the proper network gateways
    for particular routes. While this is completely legitimate, on some networks intruders
    can use this to capture data. If you don’t need ICMP redirects on your network,
    you can set this option for an extremely tiny measure of added security. If you’re
    not sure whether you’re using them, ask your network administrator.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器使用 ICMP 重定向来通知客户端计算机特定路由的正确网络网关。虽然这是完全合法的，但在一些网络中，入侵者可以利用这一点来捕获数据。如果你在网络中不需要
    ICMP 重定向，可以为此选项设置一个极其小的安全措施。如果你不确定是否正在使用它们，可以询问你的网络管理员。
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you *are* the network administrator and you’re not sure whether your network
    uses ICMP redirects, there’s an easy way to find out—just log all redirects received
    by your system to */var/log/messages*.^([3](footnote.xhtml#ch04fn3)) Note that
    if your server is under attack, this can fill your hard drive with redirect logs
    fairly quickly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是网络管理员，并且不确定你的网络是否使用 ICMP 重定向，有一种简单的方法可以找出——只需将系统接收到的所有重定向记录到 */var/log/messages*
    中。^([3](footnote.xhtml#ch04fn3)) 请注意，如果你的服务器正在遭受攻击，这可能会很快填满你的硬盘。
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To get on the network, you’ll need to assign each interface an IP address.
    We’ll discuss this in some detail in [Chapter 8](ch08.xhtml#ch08). You can get
    a list of your network interfaces with the ifconfig(8) command. List each network
    interface on its own line, with its network configuration information in quotes.
    For example, to give your em0 network card an IP address of 172.18.11.3 and a
    netmask of 255.255.254.0, you would use:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到网络，你需要为每个接口分配一个 IP 地址。我们将在[第 8 章](ch08.xhtml#ch08)中详细讨论这一点。你可以使用 ifconfig(8)
    命令获取网络接口的列表。每个网络接口列在其自己的行上，配置的网络信息放在引号中。例如，要为你的 em0 网卡分配一个 IP 地址 172.18.11.3 和子网掩码
    255.255.254.0，你可以使用：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If your network uses DHCP, use the value `dhcp` as an IP address.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网络使用 DHCP，请使用 `dhcp` 作为 IP 地址。
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Similarly, you can assign aliases to a network card. An alias is not the card’s
    actual IP address, but the card answers for that IP address, as discussed in [Chapter
    8](ch08.xhtml#ch08). FreeBSD supports hundreds of aliases on a single card, with
    *rc.conf* entries in the following form:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以为网络卡分配别名。别名不是卡的实际 IP 地址，但卡会响应该 IP 地址，如[第 8 章](ch08.xhtml#ch08)中所述。FreeBSD
    支持在单个网卡上配置数百个别名，形式如下：*rc.conf* 中的条目：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The alias numbers must be continuous, starting with 0\. If there’s a break
    in numbering, aliases above the break won’t be installed at boot time. (This is
    a common problem, and when you see it, check your list of aliases.) For example,
    an alias of 192.168.3.4 would be listed as:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 别名编号必须是连续的，从 0 开始。如果编号中断，编号中断之后的别名将在启动时不会被安装。（这是一个常见问题，当你遇到此问题时，请检查你的别名列表。）例如，192.168.3.4
    的别名将列为：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Network Routing Options**'
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**网络路由选项**'
- en: FreeBSD’s network stack includes many features for routing internet traffic.
    These start with the very basic, such as configuring an IP for your default gateway.
    While assigning a valid IP address to a network interface gets you on the local
    network, a default router will give you access to everything beyond your LAN.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的网络栈包括许多用于路由互联网流量的功能。这些从最基础的配置开始，例如为默认网关配置 IP 地址。虽然为网络接口分配有效的 IP 地址让你能够进入本地网络，但默认路由器将使你可以访问局域网以外的一切。
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Network control devices, such as firewalls, must pass traffic between different
    interfaces. While FreeBSD won’t do this by default, it’s simple to enable. Just
    tell the system that it’s a gateway and it’ll connect multiple networks for you.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 网络控制设备，如防火墙，必须在不同的接口之间传递流量。虽然 FreeBSD 默认不会执行此操作，但启用它非常简单。只需告诉系统它是一个网关，它就会为你连接多个网络。
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Console Options**'
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**控制台选项**'
- en: The console options control how the monitor and keyboard behave. You can change
    the language of your keyboard, the monitor’s font size, or just about anything
    else you like. For example, the keyboard map defaults to the standard US keyboard,
    frequently called *QWERTY*. You’ll find all sorts of keymaps in the directory
    */usr/share/syscons/keymaps*. I prefer the Dvorak keyboard layout, which has an
    entry there as *us.dvorak*. By changing the `keymap` knob to *us.dvorak*, my system
    will use a Dvorak keyboard once it boots to multiuser mode.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台选项控制着显示器和键盘的行为。你可以更改键盘的语言、显示器的字体大小，或者几乎任何你想调整的内容。例如，键盘映射默认使用标准的美国键盘，通常称为
    *QWERTY*。你可以在目录 */usr/share/syscons/keymaps* 中找到各种键盘映射。我个人偏好 Dvorak 键盘布局，它在该目录下的条目为
    *us.dvorak*。将 `keymap` 设置为 *us.dvorak* 后，我的系统将在启动至多用户模式时使用 Dvorak 键盘布局。
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: FreeBSD turns the monitor dark when the keyboard has been idle for a time specified
    in the `blanktime` knob. If you set this to `NO`, FreeBSD won’t dim the screen.
    Mind you, new hardware will dim the monitor after some time as well, to conserve
    power. If your screen goes blank even if you’ve set the `blanktime` knob to `NO`,
    check your BIOS and your monitor manual.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 会在键盘长时间空闲后将显示器调暗，空闲时间由 `blanktime` 设置决定。如果将其设置为 `NO`，FreeBSD 将不会调暗屏幕。不过，新硬件也会在一段时间后调暗显示器，以节省电力。如果你已经将
    `blanktime` 设置为 `NO`，但屏幕仍然变暗，请检查你的 BIOS 设置和显示器手册。
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: FreeBSD can also use a variety of fonts on the console. While the default font
    is fine for servers, you might want a different font on your desktop or laptop.
    My laptop has one of those 17-inch screens proportioned for watching movies, and
    the default fonts look kind of silly at that size. You can choose a new font from
    the directory */usr/share/syscons/fonts*. Try a few to see how they look on your
    systems. The font’s name includes the size, so you can set the appropriate variable.
    For example, the font *swiss-8x8.fnt* is the Swiss font, 8 pixels by 8 pixels.
    To use it, you would set the `font8x8` knob.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 还可以在控制台上使用多种字体。虽然默认字体对于服务器来说足够了，但你可能希望在桌面或笔记本电脑上使用不同的字体。我的笔记本电脑有一个 17
    英寸的屏幕，适合观看电影，而默认字体在这个尺寸下看起来有些不合适。你可以从目录 */usr/share/syscons/fonts* 中选择新字体，试试不同的字体，看看它们在系统上的效果。字体名称包括字体大小，因此你可以设置相应的变量。例如，字体
    *swiss-8x8.fnt* 是瑞士字体，大小为 8 像素 x 8 像素。要使用它，你需要设置 `font8x8` 变量。
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can use a mouse on the console, even without a GUI. By default, FreeBSD
    will try to autodetect your mouse type. If you have a PS/2 or USB mouse, chances
    are that it’ll just work when you enable the mouse daemon, without any special
    configuration. Some older and more unusual types of mice require manual configuration,
    as documented in moused(8).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有图形用户界面，你也可以在控制台上使用鼠标。默认情况下，FreeBSD 会尝试自动检测你的鼠标类型。如果你使用的是 PS/2 或 USB 鼠标，启用鼠标守护进程后，它很可能会自动工作，无需特别配置。一些较旧或不常见的鼠标类型需要手动配置，具体内容请参见
    moused(8)。
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can also change the display on your monitor to fit your needs. If you have
    an odd-sized monitor, you can change the number of lines of text and their length
    to fit, change text colors, change your cursor and cursor behavior, and do all
    sorts of other little tweaks. You can get a full list of different options in
    man vidcontrol(1).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以根据需要调整显示器上的显示内容。如果你的显示器尺寸不寻常，你可以调整文本的行数和长度，使其适配；还可以更改文本颜色、光标及其行为，进行其他各种小调整。你可以在
    man vidcontrol(1) 中查看不同选项的完整列表。
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Similarly, you can adjust your keyboard behavior almost arbitrarily. Everything
    from key repeat speed to the effect of function keys can be configured, as documented
    in kbdcontrol(1).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，你几乎可以任意调整键盘的行为。从按键重复速度到功能键的效果，都可以根据需要进行配置，具体内容请参见 kbdcontrol(1)。
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Other Options**'
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**其他选项**'
- en: This final potpourri of knobs might or might not be useful in any given environment,
    but they’re needed frequently enough to deserve mention. For example, not all
    systems have access to a printer, but those that do will want to run the printing
    daemon lpd(8). We brush up against printer configuration in [Chapter 20](ch20.xhtml#ch20).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最终的选项可能在特定环境下有用，也可能没有，但由于它们经常需要使用，因此值得提及。例如，并非所有系统都有打印机可用，但有打印机的系统会希望运行打印守护进程
    lpd(8)。我们会在[第 20 章](ch20.xhtml#ch20)中提到打印机配置。
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The sendmail(8) daemon manages transmission and receipt of email between systems.
    While almost all systems need to transmit email, most FreeBSD machines don’t need
    to receive email. The `sendmail_enable` knob specifically handles incoming mail,
    while `sendmail_outbound_enable` allows the machine to transmit mail. See [Chapter
    20](ch20.xhtml#ch20) for more details.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: sendmail(8) 守护进程管理系统间邮件的发送和接收。虽然几乎所有的系统都需要发送邮件，但大多数 FreeBSD 机器不需要接收邮件。`sendmail_enable`
    控制接收邮件，而 `sendmail_outbound_enable` 则允许机器发送邮件。有关更多详细信息，请参见[第20章](ch20.xhtml#ch20)。
- en: '[PRE65]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: One of FreeBSD’s more interesting features is its ability to run software built
    for Linux. We discuss this feature in [Chapter 17](ch17.xhtml#ch17). Running Linux
    software isn’t quite as easy as throwing this toggle, so don’t enable Linux compatibility
    modes without reading that chapter first!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的一个更有趣的特点是它能够运行为 Linux 构建的软件。我们在[第17章](ch17.xhtml#ch17)中讨论了这个功能。运行 Linux
    软件并不像打开一个开关那么简单，所以在启用 Linux 兼容模式之前，先阅读那一章！
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: A vital part of any Unix-like operating system is shared libraries. You can
    control where FreeBSD looks for shared libraries. Although the default setting
    is usually adequate, if you find yourself regularly setting the `LD_LIBRARY_PATH`
    environment variable for your users, you should consider adjusting the library
    path instead. See [Chapter 17](ch17.xhtml#ch17) for more advice on the library
    path.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类 Unix 操作系统的一个重要组成部分是共享库。你可以控制 FreeBSD 查找共享库的位置。尽管默认设置通常足够用，但如果你发现自己经常为用户设置
    `LD_LIBRARY_PATH` 环境变量，应该考虑调整库路径。有关库路径的更多建议，请参见[第17章](ch17.xhtml#ch17)。
- en: '[PRE67]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: FreeBSD has a security profile system that allows the administrator to control
    basic system features. You can globally disallow mounting hard disks, accessing
    particular TCP/IP ports, and even changing files. See [Chapter 9](ch09.xhtml#ch09)
    for details on how to use these.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 有一个安全配置文件系统，允许管理员控制基本的系统功能。你可以全局禁止挂载硬盘、访问特定的 TCP/IP 端口，甚至更改文件。有关如何使用这些功能的详细信息，请参见[第9章](ch09.xhtml#ch09)。
- en: '[PRE68]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now that you know a smattering of the configuration knobs FreeBSD supports out
    of the box, let’s see how they’re used.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 FreeBSD 默认支持的一些配置选项，让我们来看一下它们是如何使用的。
- en: '**The rc.d Startup System**'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**rc.d 启动系统**'
- en: FreeBSD bridges the gap between single-user mode and multiuser mode via the
    shell script */etc/rc*. This script reads in the configuration files */etc/defaults/rc.conf*
    and */etc/rc.conf*, and runs a collection of other scripts based on what it finds
    there. For example, if you’ve enabled the network time daemon, */etc/rc* runs
    a script written specifically for starting that daemon. FreeBSD includes scripts
    for starting services, mounting disks, configuring the network, and setting security
    parameters.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 通过 shell 脚本 */etc/rc* 弥补了单用户模式和多用户模式之间的空白。这个脚本读取配置文件 */etc/defaults/rc.conf*
    和 */etc/rc.conf*，并根据这些文件中找到的内容运行一系列其他脚本。例如，如果你启用了网络时间守护进程，*/etc/rc* 会运行一个专门用来启动该守护进程的脚本。FreeBSD
    包含了用于启动服务、挂载磁盘、配置网络和设置安全参数的脚本。
- en: These scripts live in */etc/rc.d* and */usr/local/etc/rc.d*. I’d recommend reading
    a few of them if only to see how the *rc.d* system works.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本位于*/etc/rc.d* 和 */usr/local/etc/rc.d*。我建议你阅读其中的一些脚本，即使只是为了了解 *rc.d* 系统是如何工作的。
- en: Control these scripts with service(8).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 service(8) 来控制这些脚本。
- en: '***The service(8) Command***'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***service(8) 命令***'
- en: All of the *rc.d* scripts are readable, and the way they fit together is pretty
    straightforward. When you have a problem, you can read the scripts to see how
    they work and what they do. But that’s a lot like work, and most sysadmins have
    more interesting work to do. The service(8) command provides a friendly frontend
    to the *rc.d* scripts. You can use service(8) to see which scripts run automatically;
    to stop, start, and restart services; to check the status of a service; and more.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 *rc.d* 脚本都是可读的，它们如何组合在一起是相当直观的。当你遇到问题时，你可以阅读这些脚本，看看它们是如何工作的，做了什么。不过这有点像工作，大多数系统管理员有更有趣的工作要做。service(8)
    命令提供了一个友好的前端来管理 *rc.d* 脚本。你可以使用 service(8) 查看哪些脚本会自动运行；停止、启动和重启服务；检查服务状态；以及更多操作。
- en: '**Listing and Identifying Enabled Services**'
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**列出和识别已启用的服务**'
- en: Use the `-e` flag to service(8) to see the full path of all scripts that’ll
    be run at system boot, in the order they’ll be run.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-e` 标志调用 service(8)，可以查看系统启动时将按顺序运行的所有脚本的完整路径。
- en: '[PRE69]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This tiny host runs 23 scripts at boot.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小型主机在启动时运行 23 个脚本。
- en: One important detail here is the script name. You’ll use the script name in
    other commands, like starting, stopping, and restarting services.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要细节是脚本名称。你将会在其他命令中使用脚本名称，比如启动、停止和重启服务。
- en: '**Managing Services**'
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**管理服务**'
- en: While it’s entirely possible to restart, say, sshd(8) at the command line, a
    production host needs everything to run consistently. Best practice calls for
    using service(8) to manage processes. You’ll need the script name as shown earlier,
    but without the directory path.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然完全可以在命令行中重新启动，例如，sshd(8)，但生产主机需要保持所有服务的一致运行。最佳实践是使用 service(8) 来管理进程。你需要像前面展示的那样使用脚本名称，但不包含目录路径。
- en: '[PRE70]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: For example, suppose I want to restart the sshd(8) service. According to the
    `service -e` output shown earlier, there’s a script */etc/rc.d/sshd*. I strongly
    suspect this script manages sshd(8), but I want to be certain I don’t accidentally
    restart the Stupidly Similarly named Harassment Daemon. This is where the `describe`
    command comes in. Let’s ask service(8) to describe the *sshd* script.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我想重启 sshd(8) 服务。根据之前显示的 `service -e` 输出，有一个脚本 */etc/rc.d/sshd*。我强烈怀疑这个脚本管理着
    sshd(8)，但我想确定自己不会不小心重启 Stupidly Similarly named Harassment Daemon。此时就需要用到 `describe`
    命令。让我们让 service(8) 来描述 *sshd* 脚本。
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It’s the right daemon. Let’s restart it.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 它是正确的守护进程。让我们重新启动它。
- en: '[PRE72]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Restarting a service is a combination of “stop the service” and “start the service.”
    This particular service does more than that, though. It starts by verifying the
    configuration file ➊ and then stopping the daemon ➋. It then reverifies the configuration
    ➌ and starts the daemon ➍. Why?
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 重启服务实际上是“停止服务”和“启动服务”的组合。不过这个特定的服务不仅仅做这些。它首先通过验证配置文件 ➊ 然后停止守护进程 ➋，接着重新验证配置 ➌
    并启动守护进程 ➍。为什么？
- en: SSH handles remote access to this host. If the SSH service breaks, nobody can
    log into the host to fix the SSH service. Yes, you could use a remote KVM or IPMI
    or drive to the colocation facility, but any of these prolongs the outage. It’s
    much better to verify that sshd(8) can *be* restarted before shutting it down.
    Many service scripts include this kind of safety check. If a service complains
    that it can’t stop, read the output carefully to find out why.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 处理此主机的远程访问。如果 SSH 服务出现故障，任何人都无法登录主机来修复 SSH 服务。是的，你可以使用远程 KVM 或 IPMI，或者开车去托管中心，但这些都会延长停机时间。最好在关闭之前验证
    sshd(8) 是否可以*重新启动*。许多服务脚本包括这种安全检查。如果某个服务抱怨无法停止，仔细查看输出，找出原因。
- en: The commands each service supports vary. The easiest way to get the full list
    of commands a particular service supports is to give the service a bogus argument.
    Something like “bert” is pretty bogus.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务支持的命令各不相同。获取特定服务支持的完整命令列表的最简单方法是给服务一个无效参数。像“bert”这样的参数就相当无效。
- en: '[PRE73]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You get a full list of commands this service supports, in two groups.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得此服务支持的完整命令列表，分为两组。
- en: The first group, in square brackets, contains options for the commands. Here
    are the standard options. Use them as prefixes for the commands in the second
    group.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组（用方括号括起来）包含命令的选项。这里是标准选项。将它们作为第二组命令的前缀来使用。
- en: fast Do no checking (used during startup).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: fast 不进行检查（用于启动时）。
- en: force Try harder.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: force 更加努力地尝试。
- en: one Start this service despite not being enabled in *rc.conf*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: one 即使在 *rc.conf* 中未启用，也启动该服务。
- en: quiet Only print service name (used during startup).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: quiet 只打印服务名称（用于启动时）。
- en: 'The second group, in parentheses, contains the following commands:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组（用圆括号括起来）包含以下命令：
- en: start Start the service.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: start 启动服务。
- en: stop Stop the service.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: stop 停止服务。
- en: restart Stop and restart the service.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: restart 停止并重启服务。
- en: rcvar Print the *rc.conf* variables for this service.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: rcvar 打印此服务的*rc.conf*变量。
- en: enabled Return true in shell if enabled (for script use).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: enabled 如果启用则在 shell 中返回 true（用于脚本）。
- en: describe Print service description.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: describe 打印服务描述。
- en: extracommands Show service-specific commands.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: extracommands 显示服务特定的命令。
- en: 'The `extracommands` command is very specific to the service and lists only
    the additional commands this service accepts. By default, the extra commands appear
    after the default commands. Here are some common extra commands:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`extracommands` 命令非常特定于服务，并且仅列出该服务接受的附加命令。默认情况下，附加命令会出现在默认命令之后。这里是一些常见的附加命令：'
- en: configtest Parse the service’s configuration file and stop if there’s an error.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: configtest 解析服务的配置文件，并在出现错误时停止。
- en: reload Perform a soft reload (usually via SIGHUP) rather than a restart.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: reload 执行软重载（通常通过 SIGHUP），而不是重启。
- en: status Determine whether service is running.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: status 确定服务是否正在运行。
- en: To determine exactly what a service’s extra commands do, you need to read the
    service script.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定服务的额外命令到底做了什么，你需要阅读服务脚本。
- en: We’ll look at *rc.d* in more detail in [Chapter 17](ch17.xhtml#ch17), when we
    discuss customizing and writing your own *rc.d* scripts.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第17章](ch17.xhtml#ch17)中详细讨论 *rc.d*，那时我们会讨论如何定制和编写你自己的 *rc.d* 脚本。
- en: '***System Shutdown***'
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***系统关闭***'
- en: FreeBSD makes the *rc.d* startup system do double duty; not only must it handle
    system startup, it must also shut all those programs down when it’s time to power
    down. Something has to unmount all those hard drives, shut down the daemons, and
    clean up after doing all the work. Some programs don’t care whether they’re unceremoniously
    killed when the system closes up for the night—after all, after the system goes
    down, any clients connected over SSH will be knocked off and any half-delivered
    web pages remain incomplete. Database software, however, cares very much about
    how it’s turned off, and unceremoniously killing the process will damage your
    data. Many other programs that manage actual data are just as particular, and
    if you don’t let them clean up after themselves, you’ll regret it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 使得 *rc.d* 启动系统发挥双重作用；它不仅必须处理系统启动，还必须在关机时关闭所有这些程序。必须有某些操作来卸载所有硬盘，关闭守护进程，并在完成所有工作后进行清理。一些程序不在乎它们是否在系统关闭时被无情地终止——毕竟，系统关闭后，通过
    SSH 连接的客户端会被踢掉，任何未完成的网页也会停留在中间。然而，数据库软件非常关心它是如何关闭的，无情地杀死进程会损坏你的数据。许多管理实际数据的其他程序也非常挑剔，如果你不让它们清理自己，你会后悔的。
- en: When you shut down FreeBSD with the shutdown(8), halt(8), or reboot(8) commands,
    the system calls the shell script */etc/rc.shutdown*. This script calls each *rc.d*
    script in turn with the `stop` option, reversing the order they were called during
    startup, thereby allowing server programs to terminate gracefully and disks to
    tidy themselves up before the power dies.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 shutdown(8)、halt(8) 或 reboot(8) 命令关闭 FreeBSD 时，系统会调用 shell 脚本 */etc/rc.shutdown*。该脚本依次调用每个
    *rc.d* 脚本，并传递 `stop` 选项，顺序与启动时相反，从而允许服务器程序优雅地终止，并在断电前清理磁盘。
- en: '**Serial Consoles**'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**串行控制台**'
- en: All this console stuff is nice, but when your FreeBSD system is in a colocation
    facility on the other side of the country or on another continent, you can’t just
    walk up to the keyboard and start typing. Many data centers won’t have room for
    a keyboard or monitor. And how do you reset the machine remotely when it won’t
    respond to the network? Using a serial console to redirect the computer’s keyboard
    and video to the serial port instead of the keyboard and monitor helps with all
    of these problems.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些控制台的东西都很好，但当你的 FreeBSD 系统位于全国另一端或另一个大洲的共置设施中时，你无法走到键盘前开始输入。许多数据中心没有足够的空间放置键盘或显示器。那么，当机器无法响应网络时，如何远程重启它呢？使用串行控制台将计算机的键盘和视频信号重定向到串行端口，而不是键盘和显示器，可以解决这些问题。
- en: Serial consoles can be physical, such as a serial port on the back of a computer.
    By hooking up a standard null modem cable to the serial port and attaching the
    other end to another computer’s serial port, you can access the first system’s
    boot messages from the second computer.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 串行控制台可以是物理的，例如计算机背面的串行端口。通过将标准的空接线调制解调器电缆连接到串行端口，并将另一端连接到另一台计算机的串行端口，你可以通过第二台计算机访问第一台系统的启动信息。
- en: They might also be virtual, as provided by IPMI’s *Serial-over-LAN (SOL)* protocol.
    Rather than a null modem cable, you’ll need to set up the IPMI interface and use
    special software to configure and access the virtual serial port.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以是虚拟的，例如由 IPMI 的 *Serial-over-LAN (SOL)* 协议提供的虚拟控制台。你需要设置 IPMI 接口并使用特殊软件配置和访问虚拟串行端口，而不是使用空接线调制解调器电缆。
- en: Before we set up a port, though, let’s talk about serial port protocol.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在我们设置端口之前，先来了解一下串行端口协议。
- en: '***Serial Protocol***'
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***串行协议***'
- en: Some of the first computer consoles were serial ports connected to teletypes.
    Serial has been around a long time and has evolved over the decades. Unlike modern
    protocols, serial lines do not autonegotiate. You must configure both sides of
    a serial link to the exact same settings. A configuration mismatch will cause
    either a blank screen or gibberish.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最早的计算机控制台是通过串行端口连接到电传打字机的。串行通信已经存在很长时间，并在几十年中不断发展。与现代协议不同，串行线路不会自动协商。你必须将串行连接的两端配置为完全相同的设置。如果配置不匹配，屏幕可能会变成空白，或者显示乱码。
- en: Original serial lines worked at low speeds. Many of the serial cables remain
    basically the same, but we’ve developed better software and hardware to stick
    at each end that allows us to transmit data much faster. Where old serial connections
    ran at 300 bits per second (baud), a whole bunch of modern hardware can run at
    115,200 baud. Across hardware platforms, though, the common standard is 9600 baud,
    which is FreeBSD’s default console speed. A baud rate of 9600 is enough to carry
    whole screens of text at a comfortable speed.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的串行线路工作在低速下。许多串行电缆基本保持不变，但我们已经开发出了更好的软件和硬件，能够在每端连接，使我们能够更快地传输数据。旧的串行连接速度为300比特每秒（波特率），而一大批现代硬件可以运行在115,200波特。尽管如此，在不同的硬件平台之间，常见的标准波特率是9600波特，这是FreeBSD的默认控制台速度。9600波特率足以以舒适的速度传输整屏的文本。
- en: Stick with 9600 baud for physical connections, unless you can’t. Some modern
    hardware doesn’t support 9600 baud. Some claim to support 9600 baud, but don’t.
    I’ve worked with devices hardcoded to 115,200 baud. Anything that fails or flat-out
    refuses to do 9600 baud is busted by design, but we often don’t control the choice
    of hardware. Changing the serial console speed for reasons other than hardware
    limitations makes your connection more fragile, and if you’re using the console,
    you’re in no mood for fragility. When I mention changing the port speed, that’s
    for use only when you have to.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于物理连接，最好坚持使用9600波特率，除非无法做到。某些现代硬件不支持9600波特率。也有一些硬件宣称支持9600波特率，但实际上并不支持。我曾经遇到过硬件被硬编码为115,200波特的设备。任何无法或坚决拒绝使用9600波特率的设备在设计上就是有问题的，但我们通常无法控制硬件的选择。除非是硬件限制，否则更改串口速度会让你的连接变得更加脆弱，而如果你正在使用控制台，你是没有心情面对脆弱性的。当我提到更改端口速度时，那仅仅是当你必须这样做时才使用的建议。
- en: SOL connections aren’t physical wires, so you don’t have to worry about line
    noise. You can safely run them at higher speeds.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: SOL连接不是物理线缆，因此你不需要担心线路噪声。你可以安全地在更高的速度下运行它们。
- en: Serial protocols also include a whole bunch of settings beyond their speed.
    It’s possible to muck with them, but the standard settings of 8 data bits, no
    parity, and 1 stop bit are the most widely used. You can’t change these in FreeBSD
    without recompiling the kernel, so don’t muck with them.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 串行协议还包括许多除了速度之外的设置。你可以修改它们，但8个数据位、无奇偶校验和1个停止位的标准设置是最广泛使用的。你无法在FreeBSD中更改这些设置，除非重新编译内核，因此不要乱动这些设置。
- en: With that in mind, let’s set up a console.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些，我们来设置一个控制台。
- en: '***Physical Serial Console Setup***'
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***物理串行控制台设置***'
- en: No matter what sort of serial console you have, you’ll need to plug into it
    correctly to make it work. You’ll need a null modem cable, available at any computer
    store or from online vendors. While the gold-plated serial cables are not worth
    the money, don’t buy the cheapest cable you can find either; if you have an emergency
    and need the serial console, you’re probably not in the mood to endure line noise!^([4](footnote.xhtml#ch04fn4))
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的是何种串行控制台，你都需要正确地插入连接才能使其工作。你需要一根空调调制解调器电缆，可以在任何计算机商店或在线供应商处购买。虽然镀金串行电缆不值得花钱，但也不要购买你能找到的最便宜的电缆；如果你遇到紧急情况并需要串行控制台，你可能不会心情去忍受线路噪声！^([4](footnote.xhtml#ch04fn4))
- en: Plug one end of the null modem cable into the serial console port on your FreeBSD
    server—by default the first serial port (COM1 or uart0, depending on what operating
    system you’re used to). You can change this with a server.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 将空调调制解调器电缆的一端插入你的FreeBSD服务器上的串行控制台端口——默认情况下是第一个串行端口（COM1或uart0，具体取决于你习惯使用的操作系统）。你可以通过服务器来更改此设置。
- en: Plug the other end of your null modem cable into an open serial port on another
    system. I recommend either another FreeBSD (or other Unix) system or a terminal
    server, but you can use a Windows box if that’s all you have.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 将空调调制解调器电缆的另一端插入另一个系统的空闲串口。我推荐使用另一个FreeBSD（或其他Unix系统）或终端服务器，但如果你只有Windows系统，也可以使用。
- en: If you have two FreeBSD machines at a remote location, make sure that they each
    have two serial ports. Get two null modem cables and plug the first serial port
    on each box into the second serial port of the other machine. That way, you can
    use each machine as the console client for the other. If you have three machines,
    daisy-chain them into a loop. By combining twos and threes, you can get serial
    consoles on any number of systems. I’ve worked data centers with 30 or 40 FreeBSD
    machines, where installing monitors was simply not practical, and we used serial
    consoles to great effect. Once you have a rack or two of servers, however, investing
    in a terminal server is a really good idea. You can find them cheaply on eBay.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在远程位置有两台FreeBSD机器，确保它们每台都有两个串口。准备两根空中调制解调器电缆，并将每台机器的第一个串口连接到另一台机器的第二个串口。这样，你可以将每台机器作为另一台机器的控制台客户端。如果你有三台机器，可以将它们串联成一个环形。通过将两台和三台机器组合在一起，你可以在任何数量的系统上使用串行控制台。我曾在数据中心工作，那里有30或40台FreeBSD机器，安装显示器根本不现实，我们用串行控制台取得了很好的效果。然而，一旦你有了一两个机架的服务器，投资一个终端服务器是一个非常好的主意。你可以在eBay上找到它们，价格便宜。
- en: Another option is to use two DB9-to-RJ45 converters, one standard and one crossover.
    These allow you to run your console connections over a standard CAT5 cable. If
    you have a lights-out data center where human beings are not allowed, you can
    have your serial consoles come out near your desk, in your warm room, or anywhere
    else your standard Ethernet-style patch panels reach. Most modern data facilities
    are better equipped to handle Ethernet than serial cables.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用两台DB9转RJ45转换器，一台标准转换器和一台交叉转换器。这样，你可以通过标准的CAT5电缆连接控制台。如果你有一个禁止人类进入的灯塔数据中心，你可以将串行控制台的连接引到你的桌子旁、温暖的房间或任何其他标准以太网式跳线板可达的地方。大多数现代数据设施更适合处理以太网，而不是串行电缆。
- en: '***IPMI Serial Console Setup***'
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***IPMI 串行控制台设置***'
- en: The *Intelligent Platform Management Interface (IPMI)* is a standard for managing
    computer systems at a hardware level. IPMI runs separately from the operating
    system, using a small device called a *baseboard management controller (BMC)*.
    Essentially, the BMC acts as your remote hands and eyes to control the server.
    To use an IPMI console, you’ll need to configure both the BMC and the host’s BIOS
    or UEFI.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*智能平台管理接口 (IPMI)* 是一种在硬件层面上管理计算机系统的标准。IPMI独立于操作系统运行，使用一个叫做*基板管理控制器 (BMC)* 的小型设备。基本上，BMC就像是你的远程双手和双眼，用来控制服务器。要使用IPMI控制台，你需要同时配置BMC和主机的BIOS或UEFI。'
- en: I’ll try to orient you here, but the best resource for configuring BMC or UEFI
    is your hardware manual.^([5](footnote.xhtml#ch04fn5))
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在这里尝试给你一些方向，但配置BMC或UEFI的最佳资源是你的硬件手册。^([5](footnote.xhtml#ch04fn5))
- en: '**BMC Setup**'
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**BMC 设置**'
- en: A server’s BMC has its own IP address and normally gets a dedicated Ethernet
    port on the mainboard. Each vendor gets to design its own BMC in a way that conforms
    to its own biases. This means that configuring the BMC is way, way beyond the
    scope of this book, but here are a few hints.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的BMC有自己的IP地址，通常会获得主板上的专用以太网端口。每个厂商根据自己的偏好设计自己的BMC。这意味着，配置BMC的内容远远超出了本书的范围，但这里有一些提示。
- en: You configure most BMCs through a web interface. Before you can access the web
    interface, though, the BMC needs an IP address. Set most BMC IP information in
    the BIOS or UEFI firmware’s setup menu. Once you get in the management interface,
    configure a username and password. Remember them.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数BMC配置通过网页界面进行。然而，在你访问网页界面之前，BMC需要一个IP地址。大多数BMC的IP信息可以在BIOS或UEFI固件的设置菜单中进行设置。进入管理界面后，配置用户名和密码。记住它们。
- en: A usual BMC also includes functions such as power cycling the main system, remote
    console access via some sort of downloaded application (often Java), virtual media,
    and more.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的BMC还包括诸如主系统的电源循环、通过某种下载应用程序（通常是Java）进行远程控制台访问、虚拟媒体等功能。
- en: Never forget that the BMC is a small embedded computer running a web server
    and that it was written by some overworked corporate employee charged with building
    the minimum viable product. The BMC wasn’t tested for how it performed after several
    months of uptime. If it gives you even a sneeze of trouble, reboot it. No, you
    don’t have to power cycle the whole computer; there’s usually a “BMC Reset” or
    “Unit Reboot” menu option somewhere in the web interface.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要忘记，BMC是一个运行Web服务器的小型嵌入式计算机，它是由某个超负荷工作的公司员工编写的，目的是建立最小可行产品。BMC并没有经过长时间运行后的性能测试。如果它给你带来任何问题，就重启它。你不需要重启整个计算机；通常在网页界面中会有一个“BMC重置”或“单元重启”的选项。
- en: If the BMC supports an applet-based console, why use a serial console? Because
    the BMC console is applet-based and BMC firmwares are rarely updated. I have quite
    a few BMC consoles that work only with obsolete, insecure^([6](footnote.xhtml#ch04fn6))
    versions of Java. Using them requires overriding security warnings and repeatedly
    clicking the “Yes, I know I’m an idiot, do it anyway” box. I have to keep a virtual
    machine with this insecure Java version specifically to access those consoles.
    The applet-based console doesn’t support copy and paste, and is often very laggy.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果BMC支持基于小程序的控制台，为什么还要使用串口控制台？因为BMC控制台是基于小程序的，而BMC固件很少更新。我有很多BMC控制台，只能使用过时、不安全^([6](footnote.xhtml#ch04fn6))的Java版本。使用它们需要覆盖安全警告并反复点击“是的，我知道我很傻，还是继续做”框。我不得不专门保留一个虚拟机，用这个不安全的Java版本来访问这些控制台。基于小程序的控制台不支持复制粘贴，并且通常延迟很高。
- en: IPMI works better than the Java console applet over slower connections. I can
    copy and paste. Also, I can use the IPMI console from the command line, from any
    modern operating system.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在较慢的连接上，IPMI比Java控制台小程序更好用。我可以复制和粘贴。而且，我可以在任何现代操作系统的命令行中使用IPMI控制台。
- en: While you’re in the BMC setup, locate the option to launch SOL. That brings
    up an applet to connect to the host’s SOL interface, which will help you test
    your serial console configuration.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进入BMC设置时，找到启动SOL的选项。它会启动一个小程序，连接到主机的SOL接口，帮助你测试串口控制台配置。
- en: '**UEFI/BIOS Serial Console Configuration**'
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**UEFI/BIOS串口控制台配置**'
- en: Once your BMC is ready, you must configure the server hardware to direct a serial
    port to the BMC. Go to the hardware’s Setup menu, where you configure your UEFI
    or BIOS. Somewhere in that maze of twisty little options, you’ll find something
    like “Serial Port Console Redirection.”
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦BMC准备好，你必须配置服务器硬件，将串口指向BMC。进入硬件的设置菜单，在那里配置UEFI或BIOS。在那个复杂的小选项迷宫中，你会找到类似“串口控制台重定向”这样的选项。
- en: A vital question here is, how many serial ports does your host have? Maybe it
    has none. Maybe it has several. You can choose to redirect one of those ports
    or add an additional, virtual port. I encourage you to leave your existing serial
    ports alone and add a virtual port dedicated to SOL. It’s probably called something
    like “SOL Console Redirection.” Enable it, and go into the settings for that port.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要问题是，你的主机有多少个串口？可能没有，也可能有好几个。你可以选择重定向其中一个串口，或者添加一个额外的虚拟端口。我建议你保持现有的串口不动，添加一个专门用于SOL的虚拟端口。它可能被称为“SOL控制台重定向”。启用它，然后进入该端口的设置。
- en: 'Here are some settings I find helpful for FreeBSD and SOL:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我认为对FreeBSD和SOL有帮助的设置：
- en: '**Terminal type** vt100'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**终端类型** vt100'
- en: '**Data bits** 8'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据位** 8'
- en: '**Parity** none'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**奇偶校验** 无'
- en: '**Stop bits** 1'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**停止位** 1'
- en: '**Flow control** none'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**流控制** 无'
- en: The tricky part is the baud, speed, or bits-per-second setting. Stick with the
    default speed, but make a note of it. You’ll need the speed to connect.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分是波特率、速度或每秒比特数设置。保持默认速度，但记下它。你将需要这个速度来进行连接。
- en: Now that you have a serial console, set up FreeBSD.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了串口控制台，设置FreeBSD。
- en: '***Configuring FreeBSD’s Serial Console***'
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置FreeBSD的串口控制台***'
- en: As FreeBSD boots, the loader decides where to print console messages and where
    to accept input from. While this defaults to the monitor and keyboard, with a
    few tweaks, you can redirect the console to a serial port. The serial console
    won’t grant BIOS access, but you can tweak the FreeBSD boot itself in almost any
    way. You can configure a serial console in either the first- or second-stage boot
    loader.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当FreeBSD启动时，加载程序决定在哪里打印控制台消息以及从哪里接受输入。虽然默认是从显示器和键盘，但通过一些调整，你可以将控制台重定向到串口。串口控制台不会提供BIOS访问权限，但你几乎可以以任何方式调整FreeBSD启动过程。你可以在第一阶段或第二阶段引导加载器中配置串口控制台。
- en: A first-stage boot loader gets you console access at the earliest possible moment
    but requires you use the first serial port as a console. Changing the port requires
    recompiling the kernel. The first-stage boot loader allows you to perform tasks
    like choose which disk you’re going to load the second-stage loader from—essentially,
    to boot from a disk other than the disk the BIOS or UEFI selected. This is undeniably
    useful, but very few users need this.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 第一级引导加载程序能让你在最早的时候访问控制台，但它要求你使用第一个串口作为控制台。更改端口需要重新编译内核。第一级引导加载程序允许你执行像选择从哪个磁盘加载第二级引导加载程序的任务——本质上是从与BIOS或UEFI选择的磁盘不同的磁盘引导。这无疑很有用，但很少有用户需要这样做。
- en: The second-stage boot loader can use any serial port as a console, but the first
    bit of output you’ll get is the boot menu discussed in “[The Loader Prompt](ch04.xhtml#lev106)”
    on [page 55](ch04.xhtml#page_55). For most of us, that’s perfectly acceptable.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段的引导加载器可以使用任何串口作为控制台，但你首先看到的输出将是[《引导提示》](ch04.xhtml#lev106)中讨论的引导菜单，位于[第55页](ch04.xhtml#page_55)。对我们大多数人来说，这完全可以接受。
- en: '**Console Options**'
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**控制台选项**'
- en: FreeBSD’s default configuration uses the monitor and keyboard as the console.
    You can choose to switch to only the serial console or to use a dual console.
    Choose which with the */boot/loader.conf* option `console`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的默认配置使用显示器和键盘作为控制台。你可以选择切换到仅串口控制台，或者使用双控制台。通过*/boot/loader.conf*选项`console`来选择其中之一。
- en: A serial-only console prevents some random colocation employee from power cycling
    your box, plugging in a monitor, and dinking with the menu. Yes, they could still
    work mayhem from the first-stage loader or boot off of USB, but that requires
    greater skill. Set the *console* variable to `comconsole` to use only the serial
    port as a console.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用串口的控制台可以防止一些随机的共同工作者对你的设备进行断电重启、插入显示器并修改菜单。是的，他们仍然可以通过第一阶段加载器制造混乱，或者从USB启动，但这需要更高的技能。将*console*变量设置为`comconsole`，以仅使用串口作为控制台。
- en: '[PRE74]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For most deployments, I recommend a dual console. Dual consoles show console
    activity on both the serial port and the monitor. You can use either the standard
    or the serial console as needed. Specify a dual-console configuration by listing
    both `comconsole` and `vidconsole`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数部署，我推荐使用双控制台。双控制台会同时在串口和显示器上显示控制台活动。你可以根据需要使用标准控制台或串口控制台。通过列出`comconsole`和`vidconsole`来指定双控制台配置。
- en: '[PRE75]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If you’re in a server-room situation, you might want to switch back and forth
    between a standard console and a serial console. I generally manage large arrays
    of FreeBSD systems via the serial console but leave the video console in place
    in case of trouble.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处在服务器机房环境中，可能会需要在标准控制台和串口控制台之间切换。我通常通过串口控制台管理大量的FreeBSD系统，但如果发生问题，我会保留视频控制台以备不时之需。
- en: The console won’t be effective until after a reboot. You can see whether FreeBSD
    put its console on a serial port by checking the boot messages.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台在重新启动后才会生效。你可以通过查看启动消息来确认FreeBSD是否将其控制台放置在串口上。
- en: '[PRE76]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The second line shows that the serial port uart0 is configured as a console,
    using the default settings. We’ll look at those settings in “[Using Serial Consoles](ch04.xhtml#lev139)”
    on [page 79](ch04.xhtml#page_79).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行显示串口uart0被配置为控制台，使用默认设置。我们将在[《使用串口控制台》](ch04.xhtml#lev139)中查看这些设置，位于[第79页](ch04.xhtml#page_79)。
- en: '**Advanced Console Options**'
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**高级控制台选项**'
- en: In addition to enabling the console, you can adjust the console’s port and the
    speed.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 除了启用控制台外，你还可以调整控制台的端口和速度。
- en: Maybe I need to use the second serial port for the console. Perhaps the first
    serial port has something plugged into it, or maybe the second port is the virtual
    SOL port. Serial ports use the uart(4) device driver. Remember that FreeBSD devices
    start numbering at zero, while COM ports start numbering at 1\. COM1 is uart0,
    COM2 is uart1, and so on. You’ll need the port’s base I/O port, which you can
    get from the system bootup messages.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我需要使用第二个串口作为控制台。也许第一个串口已经插入了某些设备，或者第二个端口是虚拟SOL端口。串口使用uart(4)设备驱动程序。记住，FreeBSD设备的编号从零开始，而COM端口的编号从1开始。COM1是uart0，COM2是uart1，以此类推。你需要知道端口的基础I/O端口，这可以从系统启动消息中获得。
- en: '[PRE77]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The first number after the word port is the base I/O port ➊. The base address
    of COM2, or uart1, is 0x2f8\. Set `comconsole_port` to this value ➋.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 单词port后面的第一个数字是基础I/O端口➊。COM2（或uart1）的基础地址是0x2f8。将`comconsole_port`设置为这个值➋。
- en: '[PRE78]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Your console is now on serial port COM2.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你的控制台现在位于串口COM2。
- en: If my serial connection won’t do 9600 baud, I can change the port speed with
    the `comconsole_speed` option.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我的串行连接无法达到9600波特率，我可以通过`comconsole_speed`选项来更改端口速度。
- en: '[PRE79]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: On a physical port, don’t increase the port speed just because you can.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理端口上，不要仅仅因为可以就增加端口速度。
- en: '***Using Serial Consoles***'
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用串口控制台***'
- en: 'Now that you have both physical and software set up, configure your client
    to access the serial console. The key to using a serial console is to remember
    the following settings:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了物理和软件的设置，接下来配置你的客户端来访问串口控制台。使用串口控制台的关键是记住以下设置：
- en: Speed (9600 baud, or whatever your hardware is set to)
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度（9600波特，或者你硬件设置的其他值）
- en: 8 bits
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8位
- en: No parity
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无奇偶校验
- en: 1 stop bit
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1停止位
- en: The way you access a serial line depends on whether it’s a physical line or
    an IPMI SOL connection.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 访问串行线路的方式取决于它是物理线路还是IPMI SOL连接。
- en: '**Physical Serial Lines**'
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**物理串行线路**'
- en: Connect your client to the other end of the serial line. You can find terminal
    emulators for Microsoft platforms (PuTTY being the most famous), macOS, and almost
    any other operating system. Once upon a time, I used a Palm handheld with a serial
    cable to access serial consoles. Enter the correct value settings into the terminal
    emulator, and the serial console will “just work.”
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的客户端连接到串行线路的另一端。你可以在Microsoft平台（PuTTY是最著名的）、macOS以及几乎任何其他操作系统上找到终端仿真器。曾几何时，我使用过一台Palm掌中宝手持设备，通过串行电缆访问串行控制台。输入正确的设置值到终端仿真器中，串行控制台就会“正常工作”。
- en: 'FreeBSD accesses serial lines with tip(1), a program that allows you to connect
    to remote systems in a manner similar to telnet. To run tip, do this as root:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD通过tip(1)访问串行线路，这是一款让你像telnet一样连接到远程系统的程序。要运行tip，作为root用户执行以下操作：
- en: '[PRE80]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'A port name is shorthand for specifying the serial port number and speed to
    be used on a serial port. The file */etc/remote* contains a list of port names.
    Most of the entries in this file are relics of the eon when UUCP was the major
    data transfer protocol and serial lines were the norm instead of the exception.^([7](footnote.xhtml#ch04fn7))
    At the end of this file, you’ll see a few entries like:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 端口名称是指定要在串行端口上使用的串行端口号和速度的简写。文件*/etc/remote*包含了端口名称的列表。该文件中的大多数条目都是UUCP（Unix-to-Unix复制协议）曾是主要数据传输协议、串行线路曾是常见连接方式的时代遗留下来的遗物。^([7](footnote.xhtml#ch04fn7))
    在文件的末尾，你会看到几个类似的条目：
- en: '[PRE81]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `uart` entries are the standard Unix-type device names, while the `com`
    names were added for the convenience of people who grew up on x86 hardware.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`uart`条目是标准的Unix类型设备名称，而`com`名称是为了方便那些使用过x86硬件的人而添加的。'
- en: 'Assume that you have two FreeBSD boxes wired back-to-back, with each one’s
    serial port 1 null-modemed into serial port 2\. Both machines are configured to
    use a serial console. You’ll want to connect to your local serial port 2 to talk
    to the other system’s serial console:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两台FreeBSD机器，背靠背连接，每台机器的串行端口1通过null-modem电缆连接到串行端口2。两台机器都配置为使用串行控制台。你将需要连接到本地的串行端口2，以与另一台系统的串行控制台通信：
- en: '[PRE82]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: You’re in!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 成功连接！
- en: To disconnect the serial console, press ENTER and then type the disconnect sequence
    “tilde-dot” at any time.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要断开串行控制台，随时按ENTER键，然后输入断开序列“波浪符点”。
- en: '[PRE83]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You’ll be gracefully disconnected. (This also works in the OpenSSH client.)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被优雅地断开连接。（这也适用于OpenSSH客户端。）
- en: The tip(1) program uses the tilde (`~`) as a control character. Read the man
    page for a full list of things you can do with it.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: tip(1)程序使用波浪符号（`~`）作为控制字符。请阅读man页面，查看你可以用它做的所有事情。
- en: '**IPMI SOL Connections**'
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IPMI SOL连接**'
- en: You’ll need a SOL client to connect to your IPMI serial port. The quickest way
    to test your configuration is probably with the SOL client applet included in
    your BMC. While that client has most of the disadvantages of the console applet,
    it’s a good place to test. If the BMC SOL client doesn’t work, check your SOL
    settings and FreeBSD configuration. Verify that the SOL client is set to use the
    same speed you set in the hardware and in FreeBSD. If it doesn’t work but all
    your settings appear to match, reboot the BMC. Once it works, you can use SOL
    from another host.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个SOL客户端来连接到你的IPMI串行端口。测试你的配置的最快方法可能是使用BMC中包含的SOL客户端Applet。尽管该客户端与控制台Applet有许多相同的缺点，但它是一个很好的测试场所。如果BMC的SOL客户端无法工作，请检查你的SOL设置和FreeBSD配置。验证SOL客户端是否设置为使用与你在硬件和FreeBSD中设置的相同速度。如果它不起作用，但所有设置看起来匹配，请重启BMC。一旦它工作，你就可以从另一个主机使用SOL了。
- en: The standard IPMI SOL client is IPMItool (*[https://sourceforge.net/projects/ipmitool/](https://sourceforge.net/projects/ipmitool/)*),
    available as the ipmitool package. ([Chapter 15](ch15.xhtml#ch15) discusses packages.)
    IPMItool can interact with your BMC over the network, granting you all of the
    BMC functions without logging into a clunky web interface. You can reboot the
    host, check hardware alarms and sensors, and more, all from the command line.
    But for the moment, we’ll stick with the SOL console. Use the BMC’s hostname or
    IP, the username, and the password to log into SOL.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的IPMI SOL客户端是IPMItool（*[https://sourceforge.net/projects/ipmitool/](https://sourceforge.net/projects/ipmitool/)*），作为ipmitool软件包提供。（[第15章](ch15.xhtml#ch15)讨论了软件包。）IPMItool可以通过网络与BMC交互，提供所有BMC功能，无需登录到笨重的Web界面。你可以重新启动主机、检查硬件报警和传感器等，所有这些都可以通过命令行完成。但目前，我们将继续使用SOL控制台。使用BMC的主机名或IP地址、用户名和密码登录到SOL。
- en: '[PRE84]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here, I log into my web server’s BMC, with the hostname www-bmc, using the username
    “bert.”
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我以用户名“bert”登录到我的Web服务器的BMC，主机名为www-bmc。
- en: '[PRE85]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Enter the password at the prompt, and the SOL will acknowledge your login.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符下输入密码，SOL会确认你的登录。
- en: '[PRE86]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We have a console. Probably. Let’s do the final test.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有控制台。应该有吧。让我们做最后的测试。
- en: '***Working at the Console***'
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在控制台工作***'
- en: The real test of a serial console is whether or not you can get data across
    it. Once you have your console connected, hit ENTER.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 串行控制台的真正考验在于你是否能够通过它传输数据。一旦你连接了控制台，按下ENTER键。
- en: '[PRE87]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: FreeBSD permits logins on serial consoles by default. Log in to the host and
    reboot it, and you’ll get the usual console messages.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD默认允许通过串行控制台登录。登录主机并重启，它会显示通常的控制台信息。
- en: '[PRE88]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: There will be a long pause while the system runs its BIOS routines and hands
    control over to the serial console. Just about the time you decide that the machine
    is never coming back up, you’ll get the loader menu. Congratulations! You’re using
    a serial console. Press the spacebar to interrupt the boot just as if you were
    at the keyboard.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 系统运行BIOS程序并将控制权交给串行控制台时，会有一段较长的暂停。就在你决定机器再也不会启动时，你会看到引导菜单。恭喜！你正在使用串行控制台。按空格键中断启动，就像你在键盘前一样。
- en: It doesn’t matter how far away the system is; you can change your booting kernel,
    get a verbose boot, bring it up in single-user mode, or manually fsck the hard
    drive—whatever. A software serial console might not show you the BIOS, but chances
    are that’s set up correctly already. Once you’ve used a serial console for a while,
    it won’t matter whether the machine is on the other side of the world or the other
    side of the room; getting out of your chair merely to access the console will
    feel like too much work.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 系统距离有多远并不重要；你可以更改启动内核，获得详细的启动信息，在单用户模式下启动，或者手动运行fsck检查硬盘——都可以。软件串行控制台可能无法显示BIOS，但很有可能它已经正确设置。使用串行控制台一段时间后，机器是否在地球的另一端还是房间的另一边都不再重要；仅仅是为了访问控制台而离开座椅会显得太麻烦。
- en: If a system in a remote location entirely locks up, you can connect to your
    serial console and have the “remote hands” at the colocation facility power-cycle
    the system. It might not be good for your computer, but it’s also not good for
    it to be locked up. With the serial console, you can boot into single-user mode
    and fix the problem by digging through the logs and whatever other troubleshooting
    you feel capable of. We’ll discuss troubleshooting this sort of problem in [Chapter
    24](ch24.xhtml#ch24).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果远程位置的系统完全锁死，你可以连接到串行控制台，并让机房的“远程操作人员”重启系统。这对你的计算机可能不好，但系统被锁死也不好。通过串行控制台，你可以进入单用户模式，并通过查看日志和进行其他故障排除来修复问题。我们将在[第24章](ch24.xhtml#ch24)讨论这种问题的故障排除。
- en: Now that you understand how FreeBSD starts up and shuts down, let’s look at
    some basic tools you can use to ensure that your system will continue to run even
    after you’ve been experimenting with it.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了FreeBSD是如何启动和关闭的，让我们来看一些基本工具，确保即使你在实验过程中，系统仍然能继续运行。
