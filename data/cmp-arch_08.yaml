- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**SIMPLE MACHINES**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**简单机器**'
- en: '![Image](../images/f0135-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0135-01.jpg)'
- en: In mechanical engineering, *simple machines* are a well-known set of standard
    designs including levers, axles, screws, and pulleys that each perform one function
    and can be put together to make larger machines. Analogously, computational simple
    machines are standard designs that are often used as subcomponents of computers.
    For example, the arithmetic logic unit in a modern CPU—exactly as in Babbage’s
    Analytical Engine—is made of many such simple machines that each perform one kind
    of arithmetic, such as addition, multiplication, or shifting.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在机械工程中，*简单机器*是一个众所周知的标准设计集，包括杠杆、轴、螺丝和滑轮等，每种都执行一个功能，并且可以组合在一起形成更大的机器。类比地，计算机的简单机器是一些标准设计，通常作为计算机的子组件。例如，现代CPU中的算术逻辑单元——正如巴贝奇的分析机一样——由许多这样的简单机器组成，每个机器执行一种算术操作，如加法、乘法或移位。
- en: 'This chapter introduces a range of simple machines as the next architecture
    level above logic gates. Then, in the next chapter, we’ll make use of these simple
    machines as components of a CPU. The simple machines we’ll discuss come in two
    main groups: *combinatorial machines*, which can be written as Boolean expressions,
    and *sequential machines*, which require feedback and sequential logic, extending
    Boolean logic with a temporal element. Feedback and sequential logic are needed
    to create memory.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一系列简单机器，作为逻辑门之上的下一个架构级别。然后，在下一章中，我们将利用这些简单机器作为CPU的组成部分。我们将讨论的简单机器分为两大类：*组合机器*，它们可以写成布尔表达式，以及*时序机器*，它们需要反馈和时序逻辑，扩展了布尔逻辑，加入了时间元素。反馈和时序逻辑是创建内存所必需的。
- en: Combinatorial Logic
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合逻辑
- en: '*Combinatorial logic* refers to those digital logic networks that can be described
    by regular Boolean logic, without considering the role of time. In this section,
    we’ll see examples of several combinatorial simple machines, which we’ll later
    rely on as we build up CPU structures.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*组合逻辑*指的是那些可以用常规布尔逻辑描述的数字逻辑网络，而无需考虑时间的作用。在这一节中，我们将看到几种组合简单机器的示例，稍后我们将在构建CPU结构时依赖它们。'
- en: '*Bitwise Logical Operations*'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*按位逻辑操作*'
- en: 'The individual logic gates of the previous chapter act on single bits of data:
    they usually take one or two single-bit inputs and yield a single-bit output.
    It’s simple to arrange multiple copies of a single gate, in parallel, thus creating
    an *array operator*, a simple machine that simultaneously performs the same operation
    on each bit of an input array to give an output array, as in [Figure 6-1](ch06.xhtml#ch06fig1).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章的单独逻辑门作用于单个数据位：它们通常接收一个或两个单比特输入，并生成一个单比特输出。将多个相同的门并联起来非常简单，从而创建一个*数组操作符*，这是一个简单的机器，可以同时对输入数组的每个位执行相同的操作，生成输出数组，如[图6-1](ch06.xhtml#ch06fig1)所示。
- en: '![Image](../images/f0136-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0136-01.jpg)'
- en: '*Figure 6-1: Some bitwise logical operations*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：一些按位逻辑操作*'
- en: Here, the input arrays `x` and `y` (or just `x` in the case of the NOT operation)
    pass through an array of identical gates, producing `z` as the output. These array
    operations are well known to low-level C programmers, as the C language includes
    them and assigns symbols to them. C compilers will ultimately execute these instructions
    using exactly this simple machine, if it’s present in the target CPU.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，输入数组`x`和`y`（或者在NOT操作的情况下仅`x`）通过一系列相同的门，生成`z`作为输出。这些数组操作对于低级C程序员来说非常熟悉，因为C语言中包含了这些操作，并且为它们分配了符号。如果目标CPU中存在这样的简单机器，C编译器最终将使用这种简单机器来执行这些指令。
- en: '*Multi-input Logical Operations*'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*多输入逻辑操作*'
- en: We can create multi-input versions of AND gates from hierarchies of their two-input
    versions, as in the eight-input AND gate shown in [Figure 6-2](ch06.xhtml#ch06fig2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将两个输入版本的与门按层次结构组合来创建多输入版本的与门，如[图6-2](ch06.xhtml#ch06fig2)所示的八输入与门。
- en: '![Image](../images/f0137-01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0137-01.jpg)'
- en: '*Figure 6-2: An eight-input AND gate made from two-input AND gates (left) and
    its symbol (right)*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：由两个输入与门（左）组合而成的八输入与门及其符号（右）*'
- en: This structure will output 1 if and only if all of its inputs are 1\. The same
    structure works to create multi-input OR gates, which will output 1 if one or
    more of its inputs are 1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构将仅在其所有输入都是1时输出1。相同的结构也适用于创建多输入或门，当其一个或多个输入为1时，它将输出1。
- en: '*Shifters*'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*移位器*'
- en: 'In base 10, there’s a fast trick for multiplying integers by 10: just append
    a zero to the end. We can also multiply by a higher natural power of 10, 10^(*^n*),
    by appending *n* zeros. Rather than thinking of it as appending a zero, think
    of it as shifting each digit one place to the left. Then the trick also works
    for multiplying non-integer numbers by powers of 10\. We can similarly do easy
    and fast divides by powers of 10 by shifting the digits to the right. These tricks
    remove the need for the usual slower work of human pen-and-paper multiplication
    involving repeated single-digital multiplications, additions, and carries.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制中，有一个快速的技巧来将整数乘以 10：只需在末尾附加一个零。我们还可以通过附加 *n* 个零来乘以更高的自然幂 10^(*^n*)。与其把它看作是附加一个零，不如把它看作是将每一位数字向左移一位。这样，技巧也适用于将非整数乘以
    10 的幂。我们也可以通过将数字向右移动，来轻松快速地进行 10 的幂除法。这些技巧消除了传统的慢速手工计算中涉及的多次单数字乘法、加法和进位操作。
- en: The same tricks work in binary for fast multiplication and division by integer
    powers of 2\. To multiply or divide a number by 2^(*n*), shift the number’s bits
    *n* places to the left or right.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的技巧也适用于二进制，快速进行整数 2 的幂的乘法和除法。要将数字乘以或除以 2^(*n*)，只需将数字的位移 *n* 位到左边或右边。
- en: '[Figure 6-3](ch06.xhtml#ch06fig3) shows a simple machine that, when enabled,
    performs a left shift, thereby multiplying an input number by 2\. The machine
    is enabled by setting the *S* (shift) input switch to true. If the *S* input isn’t
    enabled, the machine outputs the original input unchanged.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](ch06.xhtml#ch06fig3) 展示了一个简单的机器，当它被启用时，会执行左移操作，从而将输入数字乘以 2。该机器通过将 *S*（移位）输入开关设置为
    true 来启用。如果 *S* 输入没有启用，机器将输出原始输入而不做任何改变。'
- en: '![Image](../images/f0137-02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0137-02.jpg)'
- en: '*Figure 6-3: A left-shifter made from logic gates*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：由逻辑门构成的左移位器*'
- en: The shifter design is based on a sub-machine consisting of two ANDs, one NOT,
    and one OR. Each column (digit) of the number has a copy of this sub-machine,
    which either allows the column’s own bit to pass through unchanged, or takes the
    bit from the column to its right.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 移位器的设计基于一个子机器，它由两个与门（AND）、一个非门（NOT）和一个或门（OR）组成。数字的每一列（每一位）都有一个此子机器的副本，它要么允许该列的位不变地通过，要么将该列的位替换为右边列的位。
- en: When you do multiplication by powers of two with an operation like `x>>2` using
    a high-level language like C, your CPU may contain a dedicated shifter that gets
    activated rather than its usual multiplication digital logic. This makes the multiplication
    operation go faster than one that isn’t by a power of two. This is an example
    of how knowing architecture enables you to write fast programs. You’ll often see
    speed-critical code designed to exploit this trick, such as games and media codecs
    enforcing values to be powers of two.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 C 等高级语言中使用类似 `x>>2` 的操作进行乘法时，你的 CPU 可能包含一个专用的移位器，它会被激活，而不是使用通常的乘法数字逻辑。这使得乘法操作比非二的幂的乘法操作更快。这就是了解架构如何帮助你编写更快程序的一个例子。你会经常看到为了利用这个技巧而设计的速度关键代码，比如游戏和媒体编解码器强制将值设为二的幂。
- en: '**NOTE**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Shifting by more than one place can be done in several ways. You could reuse
    the same shifter network several times, which would save on transistors but take
    longer to run. Or you could use more transistors to implement many different switches
    that request different kinds of shift, and implement them immediately. Deciding
    whether to trade off transistors for speed in this way is a common architectural
    dilemma.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*移动超过一位可以通过几种方式来实现。你可以多次重复使用相同的移位网络，这样可以节省晶体管，但运行时间会更长。或者你可以使用更多的晶体管来实现许多不同的开关，这些开关可以请求不同类型的移位，并立即执行它们。决定是否通过这种方式在晶体管和速度之间做出权衡是一个常见的架构难题。*'
- en: '*Decoders and Encoders*'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解码器和编码器*'
- en: Suppose you have a positive integer *x* represented as an *M*-bit binary number.
    Computers often need to convert this binary representation into an alternative
    1-of-*N* representation, which has *N* = 2*^M* bits, all 0 except for a 1 in the
    *x*th bit. For example, an *M* = 3 bit input such as 101 (coding the number 5[10])
    would be converted to 00000100, which has 2³ = 8 bits with only the fifth one
    high (counting the bits from left to right, starting from 0). A simple machine
    called a *decoder* can perform this conversion. [Figure 6-4](ch06.xhtml#ch06fig4)
    shows a digital logic circuit for a 3-bit decoder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个正整数 *x*，它表示为一个 *M* 位二进制数。计算机通常需要将这种二进制表示转换为另一种1-of-*N*表示法，其中 *N* = 2*^M*
    位，除了 *x* 位是1之外，其他位都是0。例如，一个 *M* = 3 位输入，如101（编码数字5[10]），将被转换为00000100，具有2³ = 8位，只有第五位为高电平（从左到右，从0开始计数）。一种叫做*解码器*的简单机器可以执行这种转换。[图6-4](ch06.xhtml#ch06fig4)展示了一个3位解码器的数字逻辑电路。
- en: '![Image](../images/f0138-01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0138-01.jpg)'
- en: '*Figure 6-4: A 3-bit decoder*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：3位解码器*'
- en: Each input is first copied and inverted. Then a set of AND gates are connected
    to either the uninverted or inverted versions of each input bit in connection
    patterns that model the patterns of binary number codings.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输入首先被复制并反转。然后，一组与门被连接到每个输入位的未反转或反转版本，连接模式模拟二进制数字编码的模式。
- en: 'An *encoder* performs the inverse operation: it takes a 1-of-*N* representation
    as an input and transforms it into a binary number encoding.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*编码器*执行反向操作：它将一个1-of-*N*表示作为输入，并将其转换为一个二进制数字编码。'
- en: '*Multiplexers and Demultiplexers*'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*多路复用器和解多路复用器*'
- en: We’ve seen that the Analytical Engine consisted of many subcomponents that were
    dynamically connected and disconnected as needed to perform computations. Making
    and breaking these connections in the Analytical Engine was done mechanically.
    For example, when we wanted to do some adding, the mechanisms physically brought
    the gears into contact between a register and the arithmetic logic unit (ALU).
    Or when we loaded data from RAM, a mechanism physically connected the desired
    RAM location to the bus. The digital logic version of this idea is multiplexing
    and demultiplexing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，分析机由许多子组件组成，这些子组件根据需要动态地连接和断开以执行计算。在分析机中，这些连接的建立和断开是机械完成的。例如，当我们想要进行加法时，机制会将齿轮物理地接触在寄存器和算术逻辑单元（ALU）之间。或者当我们从RAM加载数据时，机制会物理地将所需的RAM位置连接到总线上。这种思想的数字逻辑版本就是多路复用和解多路复用。
- en: A *multiplexer* enables us to select which one of multiple possible sources
    we wish to connect to a single output. For example, we might have eight registers
    and want to select one of them to connect to an ALU input. [Figure 6-5](ch06.xhtml#ch06fig5)
    shows an eight-source multiplexer. It consists of a decoder together with eight
    data inputs, D[0] through D[7], and additional AND and OR gates.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*多路复用器*使我们能够选择将多个可能的源中的一个连接到单个输出。例如，我们可能有八个寄存器，并希望选择其中一个连接到ALU输入。[图6-5](ch06.xhtml#ch06fig5)展示了一个八源多路复用器。它由一个解码器和八个数据输入D[0]到D[7]组成，还包括额外的与门和或门。'
- en: '![Image](../images/f0139-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0139-01.jpg)'
- en: '*Figure 6-5: A multiplexer*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：多路复用器*'
- en: If we wish to connect a particular source, such as D[3], to the output wire,
    we place its code, 011[2] for 3[10], onto the decoder inputs C[0] to C[2]. The
    decoder sets the third line only to true, which is AND gated together with D[3]
    as a switch. The OR gates then copy D[3] onto the output wire, as all their other
    inputs are false.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望将特定源（如D[3]）连接到输出线，我们将其代码011[2]（对应3[10]）放到解码器输入C[0]到C[2]。解码器仅将第三行设为高电平，并与D[3]通过与门进行逻辑与操作作为开关。然后，或门将D[3]复制到输出线，因为它们的其他输入都是低电平。
- en: A *demultiplexer* performs the opposite function to a multiplexer. It takes
    a single input wire and a code *n*, and sends a copy of the input signal to the
    *n*th of multiple output wires.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*解多路复用器*执行与多路复用器相反的功能。它接受一个输入线和一个代码 *n*，并将输入信号的副本发送到多个输出线中的第 *n* 根。'
- en: Multiplexers and demultiplexers are often used together, so we can choose which
    one of several possible sources to connect to which one of several possible destinations.
    In these cases, the shared wire is known as a *bus*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 多路复用器和解多路复用器通常一起使用，因此我们可以选择将多个可能的源中的一个连接到多个可能的目的地中的一个。在这些情况下，共享的线称为*总线*。
- en: '*Adders*'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*加法器*'
- en: You saw in [Chapter 2](ch02.xhtml) how to represent integers in binary. We can
    construct simple machines that use this representation to perform arithmetic operations,
    such as *adders* for performing addition.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.xhtml) 中，你已经了解了如何在二进制中表示整数。我们可以构建简单的机器，利用这种表示法执行算术运算，例如执行加法的
    *加法器*。
- en: 'Here’s an example of adding two binary numbers, 001100 and 011010:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是加法两个二进制数 001100 和 011010 的例子：
- en: '![Image](../images/f0140-01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0140-01.jpg)'
- en: 'You can perform this addition by hand using the same algorithm as taught to
    children for decimal addition: starting from the rightmost column, compute the
    column sum by adding the digits from the input numbers for that column, writing
    the result underneath as the output sum for that column. If this creates a carry,
    for example from 1 + 1 = 10, write the lower-power column of the result (the 0
    of 10) as the sum and carry the higher-power column of the result (the 1 of 10)
    to the next column, where it needs to be added as a third input. In the example,
    the first three columns (counting from the right) don’t produce carries, but the
    fourth and fifth columns do. (The carries are shown below the final sum.)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动执行这个加法，使用与儿童学习十进制加法时相同的算法：从最右边的列开始，计算该列的列和，将结果写在下方作为该列的输出和。如果出现进位，比如 1
    + 1 = 10，则将结果的低位（10 的 0）作为和，并将高位（10 的 1）进位到下一列，在下一列中将其作为第三个输入进行加法。在这个例子中，从右数的前三列没有产生进位，但第四列和第五列产生了进位。（进位在最终和的下方显示。）
- en: If you look back at the truth tables for AND and XOR in [Figures 5-1](ch05.xhtml#ch05fig1)
    and [5-4](ch05.xhtml#ch05fig4) and compare them to the work done during binary
    addition, you’ll see that as long as there’s no input carry (as is the case for
    the first four columns in the example), the results of XOR are identical to column-wise
    addition, while the results of AND are identical to the carry operation. We could
    thus use one XOR and one AND to form the simple machine known as a *half adder*,
    shown in [Figure 6-6](ch06.xhtml#ch06fig6), to compute the sums for columns when
    there’s no carry coming in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回顾 [图 5-1](ch05.xhtml#ch05fig1) 和 [图 5-4](ch05.xhtml#ch05fig4) 中的与（AND）和异或（XOR）真值表，并将其与二进制加法的过程进行比较，你会发现，只要没有输入进位（如例子中的前四列），XOR
    的结果与列加法完全相同，而 AND 的结果则与进位操作完全相同。因此，我们可以使用一个 XOR 和一个 AND 来构建一个简单的机器，称为 *半加法器*，如
    [图 6-6](ch06.xhtml#ch06fig6) 所示，当没有进位输入时，它可以计算列的和。
- en: '![Image](../images/f0140-02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0140-02.jpg)'
- en: '*Figure 6-6: A half adder*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：半加法器*'
- en: By itself, the half adder isn’t very useful, as we don’t usually know if an
    input carry will also be present. However, if we combine two half adders together
    with an OR gate, as in [Figure 6-7](ch06.xhtml#ch06fig7), we obtain a more useful
    network called a *full adder*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用半加法器并不非常有用，因为我们通常无法知道是否会有进位输入。然而，如果我们将两个半加法器与一个或门（OR gate）结合，如 [图 6-7](ch06.xhtml#ch06fig7)
    所示，就能得到一个更有用的网络，称为 *全加法器*。
- en: '![Image](../images/f0141-01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0141-01.jpg)'
- en: '*Figure 6-7: A full adder made from two half adders and an OR gate*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-7：由两个半加法器和一个或门组成的全加法器*'
- en: The truth table for a full adder is shown in [Table 6-1](ch06.xhtml#ch06tab1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 全加法器的真值表见 [表 6-1](ch06.xhtml#ch06tab1)。
- en: '**Table 6-1:** Full Adder Truth Table'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：** 全加法器真值表'
- en: '| **X** | **Y** | **C[in]** | **Sum** | **C[out]** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **X** | **Y** | **C[in]** | **和** | **C[out]** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 0 | 0 | 0 | 0 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 1 | 0 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | 0 |'
- en: '| 0 | 1 | 0 | 1 | 0 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 0 |'
- en: '| 0 | 1 | 1 | 0 | 1 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | 1 |'
- en: '| 1 | 0 | 0 | 1 | 0 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | 0 |'
- en: '| 1 | 0 | 1 | 0 | 1 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 | 0 | 1 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 1 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 |'
- en: 'The full adder performs two single-bit additions in a row, the first for the
    main inputs (X and Y) and the second for the sum of the main inputs plus the incoming
    carry (C[in]). The net result is a single-column sum, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 完整加法器连续执行两次单比特加法，第一次是对主输入（X 和 Y）的加法，第二次是对主输入加上进位（C[in]）的和进行加法。最终结果是一个单列的和，如下所示：
- en: '![Image](../images/f0141-02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0141-02.jpg)'
- en: This is the full process needed to correctly find the binary digit sum for each
    column of binary addition. As well as adding the two binary digits from that column
    of the two input numbers, it also adds an incoming carried digit whenever it’s
    present. The full adder’s two outputs are the sum for the column (S) and the carry
    out for the column (C[out]).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确找到每一列二进制加法的二进制数字和所需的完整过程。除了加上来自两输入数字该列的两个二进制数字，它还会在有进位数字时加上传入的进位。完整加法器的两个输出是该列的和（S）和该列的进位输出（C[out]）。
- en: The full adder network is often represented by the single symbol shown in [Figure
    6-8](ch06.xhtml#ch06fig8).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的加法器网络通常由[图6-8](ch06.xhtml#ch06fig8)中所示的单个符号表示。
- en: '![Image](../images/f0142-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0142-01.jpg)'
- en: '*Figure 6-8: The adder symbol*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：加法器符号*'
- en: A full adder performs addition of a single column, but to actually add integers
    together we need to add many columns. One way to do this is to create one full
    adder for each column and connect the carry out from each column to the carry
    in of the next. This is known as a *ripple-carry adder*. [Figure 6-9](ch06.xhtml#ch06fig9)
    shows a 3-bit example that calculates Z = X + Y.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的加法器执行单列的加法，但要将整数加在一起，我们需要加许多列。实现这一目标的一种方法是为每一列创建一个完整的加法器，并将每列的进位输出连接到下一列的进位输入。这就是*波纹进位加法器*。
    [图6-9](ch06.xhtml#ch06fig9)展示了一个3位的例子，计算Z = X + Y。
- en: '![Image](../images/f0142-02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0142-02.jpg)'
- en: '*Figure 6-9: A ripple-carry adder computing the 3 bits of Z = X + Y*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：一个波纹进位加法器计算Z = X + Y的3位数*'
- en: The subscripts say which power of 2 the column represents; for example, here
    X[0] is ones (as 2⁰ = 1), X[1] is twos (as 2¹ = 2), and X[2] is fours (as 2² =
    4). There’s an additional output from the final carry to indicate if an overflow
    has occurred. In some cases this would be interpreted as an error. In others it
    might be connected to further systems that together are able to handle larger
    numbers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下标表示该列所代表的2的幂次；例如，这里X[0]表示个位（因为2⁰ = 1），X[1]表示十位（因为2¹ = 2），X[2]表示百位（因为2² = 4）。最后的进位输出还会有额外的输出，用来指示是否发生了溢出。在某些情况下，这会被解读为错误。在其他情况下，它可能会连接到其他系统，这些系统可以共同处理更大的数字。
- en: The adder symbol of [Figure 6-8](ch06.xhtml#ch06fig8) can also be used to denote
    a multibit adder such as a ripple-carry adder, where the input and output lines
    are assumed to denote groups of wires rather than single wires.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-8](ch06.xhtml#ch06fig8)中的加法器符号也可以用于表示多位加法器，例如波纹进位加法器，其中输入和输出线假定表示一组电缆，而不是单根电缆。'
- en: '**RIPPLE-CARRY VS. CARRY-SAVE ADDERS**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**波纹进位加法器与进位保存加法器的比较**'
- en: When you’re taught to do addition at school, you’re taught a serial adding algorithm,
    starting at the right side and moving across, with carry digits moving to the
    next step. The ripple-carry adder is a straight base 2 translation of this idea
    into digital logic.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在学校学习加法时，你会学习到一种串行加法算法，从右边开始加，并移动到左边，同时将进位数字传递到下一步。波纹进位加法器就是这个思想在数字逻辑中的直接二进制翻译。
- en: Think about the efficiency of this process; assuming that both of the inputs
    are *n* digits long, we see that this method of addition will scale linearly with
    *n* as the length of digits increases the addition runs in roughly *O*(*n*) time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想这个过程的效率；假设两个输入都是*n*位长，我们可以看到这种加法方法会随着*n*的增加而线性扩展，随着位数的增加，加法的运行时间大约是 *O*(*n*)。
- en: But addition doesn’t have to be done or taught like this. Imagine that instead
    of teaching kids to add numbers together individually, they’re taught to work
    from the start as a team, each performing a smaller part of the addition. How
    would you get the numbers added together as quickly as possible in parallel? You’d
    probably give each kid one pair of column digits from the addition, have them
    each do their addition at the same time, then have them send their carry along
    to the person on their left. Then they each take the carry from their right and
    add it into their result to update it if needed, and sometimes update their carry
    output and pass it again to their left, until everyone is happy. This is called
    a *carry-save adder*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但加法不一定非得像这样进行或教导。试想一下，不是教孩子们分别将数字加起来，而是教他们从一开始就作为一个团队合作，每个人执行加法的一小部分。怎样才能让这些数字尽可能快地并行加起来？你可能会让每个孩子拿到加法中一对列数字，让他们同时进行加法运算，然后让他们将进位传递给左边的人。接着，每个人从右边接过进位，并将其加到自己的结果中进行更新（如果需要的话），有时还会更新他们的进位输出并再次传递给左边，直到每个人都满意为止。这种方式叫做*进位保存加法器*。
- en: Estimating the number of carry steps that need to be done in this kind of parallel
    addition is quite a challenge. Naively, around one-quarter of initial additions
    will produce a carry. But then you need to think about the probability of a second
    or third subsequent carry step as you later receive incoming carries.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 估算这种并行加法中需要执行的进位步骤数是相当具有挑战性的。粗略估计，大约四分之一的初始加法会产生进位。但接下来，你需要考虑在后续接收到进位时第二次或第三次进位的概率。
- en: To do this properly as a probabilistic estimate, you should take into account
    the distribution of digits involved in the addition. Most natural quantities have
    a lower probability of higher-value digits (5+ in decimal; 1 in binary) than low-value
    digits (up to 4 in decimal; 0 in binary). This is found both in physical and pure
    mathematics quantities (for example, digits of Planck’s constant, *π*, and *e*),
    though the reason why is quite complex.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地进行概率估算，你应该考虑参与加法的数字分布。大多数自然量的高位数字（十进制中的5+，二进制中的1）的概率低于低位数字（十进制中的4以内，二进制中的0）。这一现象在物理量和纯数学量中都有发现（例如普朗克常数、*π*
    和 *e* 的数字），尽管其原因相当复杂。
- en: Carry-save adders can do addition in *O*(log *n*) time. They’re still doing
    the same *O*(*n*) amount of total work as the ripple-carry adder, but performing
    more of the work in parallel, using more silicon. More silicon consumes more space
    and money, but in this case delivers faster performance. Again, trading silicon
    for time is a common architectural dilemma.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 进位保存加法器可以在 *O*(log *n*) 时间内进行加法运算。它们仍然进行与波纹进位加法器相同的 *O*(*n*) 总工作量，但通过并行处理更多的工作，使用了更多的硅片。更多的硅片需要更多的空间和成本，但在这种情况下能提供更快的性能。再一次，使用硅片换取时间是一个常见的架构难题。
- en: 'Carry-save adders are found in modern ALUs. They aren’t a new idea and in fact
    were featured in one of the Analytical Engine designs. This is one of the main
    reasons the machine was never built: Babbage kept going back to improve the efficiency
    of the carry mechanism, to the point of obsession. Had he stuck to one design,
    it may have been completed.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 进位保存加法器被广泛应用于现代算术逻辑单元（ALU）。它们并不是新发明，实际上在分析引擎设计中就有体现。这也是该机器从未被建成的主要原因之一：巴贝奇反复改进进位机制的效率，甚至到了痴迷的程度。如果他坚持某个设计，可能会完成该机器。
- en: '*Negators and Subtractors*'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*取反器和减法器*'
- en: If we use two’s complement data representation for integers, then negating a
    number (that is, multiplying it by –1) can be performed by flipping its bits and
    then adding 1 to the result. A machine that performs this operation is called
    a *negator*. [Figure 6-10](ch06.xhtml#ch06fig10) shows a 3-bit negator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用二的补码数据表示法表示整数，那么取反一个数字（即将其乘以 -1）可以通过翻转其比特位，然后加1来完成。执行此操作的机器称为*取反器*。[图6-10](ch06.xhtml#ch06fig10)展示了一个3位取反器。
- en: '![Image](../images/f0144-01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0144-01.jpg)'
- en: '*Figure 6-10: A 3-bit negator*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：3位取反器*'
- en: The thick wires in this figure are standard notation for bundles of multiple
    individual wires, in this case bundles of three wires. (Another common notation
    for bundles is to draw a diagonal slash through and write the number of wires
    next to it.) The switches in the bottom-left specify the input number, with the
    least significant bit first. The number 1 to add is encoded by power and ground
    inputs, again with the least significant bit first. The adder symbol here indicates
    not just a full adder but a 3-bit adder, such as a ripple-carry adder.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该图中的粗线代表了多个单独导线的束，通常用于表示三根导线的束。 (另一种常见的表示束的符号是画一条斜线并在旁边写上导线数量。) 左下角的开关指定了输入数字，从最低有效位开始。需要加的数字通过电源和地面输入进行编码，同样从最低有效位开始。这里的加法器符号不仅表示一个全加器，还表示一个3位加法器，比如一个波纹进位加法器。
- en: Once we have a negator, we can make a *subtractor*, a machine that subtracts
    one number from another. Single- and multi-bit subtractors are indicated with
    the symbol in [Figure 6-11](ch06.xhtml#ch06fig11).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了取反器，就可以制作一个*减法器*，即从一个数字中减去另一个数字的机器。单比特和多比特减法器使用[图6-11](ch06.xhtml#ch06fig11)中的符号表示。
- en: '![Image](../images/f0144-02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0144-02.jpg)'
- en: '*Figure 6-11: The subtractor symbol*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-11：减法器符号*'
- en: We could make a two’s complement subtractor to calculate *c* = *a* – *b* by
    passing *b* through a negator and then using an adder to add the result to *a*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 *b* 传递给取反器，然后使用加法器将结果加到 *a* 上来制作一个二的补码减法器，从而计算 *c* = *a* – *b*。
- en: From Combinatorial to Sequential Logic
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从组合逻辑到时序逻辑
- en: The combinatorial circuits we’ve seen so far may be viewed as computing instantly.
    Each circuit corresponds exactly to a Boolean logic expression, which has a definite,
    mathematical truth value that corresponds to the output of the circuit. This output
    depends only on the input values, and the input-output pairs can be listed in
    a truth table.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的组合电路可以看作是瞬时计算的。每个电路都精确对应一个布尔逻辑表达式，该表达式具有一个明确的、数学上的真值，表示电路的输出。这个输出仅依赖于输入值，输入和输出的配对可以列出在真值表中。
- en: We’ve seen that Shannon’s combinatorial logic circuits can be used to build
    many simple machines, like multiplexers and adders. Shannon proposed his logic
    gate theory in 1936, the same year as Church’s and Turing’s definitions of computation,
    and you might want to view Shannon’s logic gates as an additional competing model
    of computation from this year, if you’re happy for a “program” to be a set of
    instructions for how to physically connect a bunch of logic gates, in a similar
    manner to programming the pre–virtual machine ENIAC.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，香农的组合逻辑电路可以用来构建许多简单的机器，如多路复用器和加法器。香农在1936年提出了他的逻辑门理论，这一年也是丘奇和图灵提出计算的定义的年份。如果你愿意将“程序”视为一组指示如何物理连接一堆逻辑门的指令，那么你也可以把香农的逻辑门视为这一年的另一个竞争性的计算模型，就像在编程虚拟机ENIAC之前的那种方式。
- en: However, Church computers need to be able to simulate any other machine (given
    enough memory), and we know that some other machines have *memory* for data storage.
    There’s no concept of memory in combinatorial logic circuits because memory means
    storage over time, and there’s no concept of time because these circuits can be
    viewed as acting instantly. Church computers need to have time and memory and
    be able to compute outputs that are functions not only of their current input
    but also of their state as derived from previous inputs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，丘奇计算机需要能够模拟任何其他机器（前提是有足够的内存），而我们知道一些其他机器有*内存*来存储数据。组合逻辑电路中没有内存的概念，因为内存意味着数据随时间的存储，而这些电路可以看作是瞬时作用的，因此没有时间的概念。丘奇计算机需要有时间和内存，并能够计算不仅依赖于当前输入的输出，还依赖于从先前输入中推导出的状态。
- en: We can extend Shannon’s logic gates with these additional concepts if we allow
    logic gate networks whose outputs are fed back into their inputs. Such networks
    weren’t allowed in Shannon’s original combinatorial logic, as they would have
    resulted in paradoxical Boolean expressions. For example, the circuit in [Figure
    6-12](ch06.xhtml#ch06fig12) appears to instantiate the Boolean statement X = NOT
    X. This Boolean statement says that if X is true, then X is false, but if X is
    false then X is true. What do you think this circuit would do in practice if you
    connected it? Perhaps it would oscillate or explode?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们允许逻辑门网络的输出反馈到它们的输入中，我们就可以扩展香农的逻辑门，加入这些额外的概念。香农的原始组合逻辑中是不允许这样的网络的，因为它们会导致自相矛盾的布尔表达式。例如，[图
    6-12](ch06.xhtml#ch06fig12)中的电路似乎实例化了布尔语句 X = NOT X。这个布尔语句表示，如果 X 为真，那么 X 为假；但如果
    X 为假，那么 X 为真。如果你连接这个电路，你觉得它在实践中会发生什么？也许它会振荡或爆炸？
- en: '![Image](../images/f0145-01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0145-01.jpg)'
- en: '*Figure 6-12: A paradoxical circuit*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-12：一个矛盾的电路*'
- en: 'In computer science, feedback is often thought of as evil or paradoxical, something
    to be avoided: many of the theorems in logic and computability theory are about
    how to destroy programs, proofs, and machines by feeding their output or descriptions
    of themselves into their inputs. But feedback is a big idea in computer science
    in general, and learning to control it and use it for good has been a major part
    of our success and our culture. Creating memory is one such positive and controlled
    use of feedback.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，反馈常常被认为是邪恶的或自相矛盾的，是需要避免的：逻辑和可计算性理论中的许多定理都在讲如何通过将程序、证明和机器的输出或它们的描述反馈到输入中来摧毁它们。但是，反馈在计算机科学中是一个重要的概念，学会控制它并将其用于正面用途，是我们成功和文化的重要组成部分。创建记忆就是反馈的一个积极且受控的应用。
- en: Let’s illustrate this idea using the example of a guitarist. Guitarists have
    a more practical worry about feedback, as their guitar strings can vibrate in
    sympathy with the sounds coming from their amplifiers. These vibrations, in turn,
    are amplified, and so on, leading to a terrible (or beautiful, depending on your
    musical point of view) single-frequency screeching sound. Consider exactly *when*
    this happens. It’s possible to put the same guitar in exactly the same place in
    front of the amp, and yet have the system remain completely silent if there’s
    no initial sound. The feedback emerges only if there’s some sound—even a small
    one—to make it begin. We could thus use this guitar-amp system to store 1 bit
    of information. We bring the guitar next to the amp very carefully so no sound
    is made and the system stays silent, representing a 0\. If we later want to store
    a 1, we stroke the strings to begin the feedback, which continues forever, representing
    the 1\. To change it back to 0, we could turn the amp off and on again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用吉他手的例子来说明这个概念。吉他手对反馈有一个更实际的担忧，因为他们的吉他弦可能与从放大器发出的声音产生共鸣。这些共鸣反过来又被放大，形成了恶性循环，从而发出一种可怕的（或者从音乐的角度看，可能是美妙的）单频尖叫声。考虑一下这个过程究竟在*什么时候*发生。你可以将同样的吉他放在放大器前的完全相同的位置，却依然保持系统完全安静，如果没有初始的声音的话。反馈只有在有声音—甚至是微小的声音—的情况下才会出现，启动反馈过程。因此，我们可以用这个吉他-放大器系统来存储1位信息。我们将吉他小心地靠近放大器，使其不发出任何声音，系统保持安静，代表0。如果我们稍后想存储1，我们就拨动琴弦开始反馈，反馈会永远持续下去，代表1。要将其改回0，我们可以将放大器关掉再打开。
- en: The circuit in [Figure 6-13](ch06.xhtml#ch06fig13) is an attempt to make a digital
    logic version of the same idea. If we try to map it to Boolean logic, it seems
    less paradoxical than the circuit from [Figure 6-12](ch06.xhtml#ch06fig12), appearing
    to instantiate the Boolean statement Q = G OR Q. (G is for *guitar*, and Q is
    a traditional symbol for *quiescence*, or system state.) You can just about convince
    yourself that this is stable for G = Q = 0 or for G = Q = 1.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-13](ch06.xhtml#ch06fig13)中的电路是试图将相同的概念做成数字逻辑版本。如果我们尝试将其映射到布尔逻辑，它似乎不像[图6-12](ch06.xhtml#ch06fig12)中的电路那样矛盾，而是似乎实现了布尔表达式Q
    = G OR Q。（G代表*吉他*，Q是传统的*静态*或系统状态符号。）你几乎可以说服自己，当G = Q = 0或G = Q = 1时，这个系统是稳定的。'
- en: '![Image](../images/f0146-01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0146-01.jpg)'
- en: '*Figure 6-13: A guitar-like feedback circuit*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：类似吉他的反馈电路*'
- en: However, this still doesn’t give us the concepts of time or memory, because
    Boolean logic is inherently static. To fully capture these concepts, we need to
    go beyond Boolean logic and Shannon gates, and consider a new type of logic gate
    having different states at different *times*. We need to distinguish states at
    times using *sequential logic*, such as writing *Q*[*t*] ≠ Q[*t*-1] for states
    at time *t* and just before time *t*. This would be foreign to Boole and Shannon,
    and indeed it’s an extension of their theories. It can be used to give meaning
    to digital logic circuits that their theories can’t handle, such as mapping [Figure
    6-12](ch06.xhtml#ch06fig12) to *X*[*t*] = NOT X[*t*-1] and [Figure 6-13](ch06.xhtml#ch06fig13)
    to Q[*t*] = G OR Q[*t*-1]. The latter is now an exact analog of the guitar feedback
    memory, with Q able to sustain a value of 1 copied from G even if G is later lowered
    to 0.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然没有给我们带来时间或记忆的概念，因为布尔逻辑本质上是静态的。为了完全捕捉这些概念，我们需要超越布尔逻辑和香农门，考虑一种新的逻辑门，它在不同的*时间*具有不同的状态。我们需要使用*时序逻辑*来区分不同时间的状态，例如写出*Q*[*t*]
    ≠ Q[*t*-1]来表示时间*t*和时间*t*之前的状态。这对布尔和香农来说是陌生的，事实上，它是他们理论的扩展。它可以用来赋予数字逻辑电路在他们的理论无法处理的意义，例如将[图6-12](ch06.xhtml#ch06fig12)映射为*X*[*t*]
    = NOT X[*t*-1]，并将[图6-13](ch06.xhtml#ch06fig13)映射为Q[*t*] = G OR Q[*t*-1]。后者现在是吉他反馈记忆的准确类比，即使G稍后降到0，Q也能够保持从G复制的1值。
- en: This still isn’t a very useful memory, because once Q has been set high there’s
    no way to reset it to low again. We need to add the equivalent of the amplifier
    power switch, A, as in [Figure 6-14](ch06.xhtml#ch06fig14).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不是一个非常有用的记忆，因为一旦Q被设为高电平，就无法将其重新设置为低电平。我们需要添加一个相当于放大器电源开关A的部分，如[图6-14](ch06.xhtml#ch06fig14)所示。
- en: '![Image](../images/f0146-02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0146-02.jpg)'
- en: '*Figure 6-14: A guitar-and-amp-like feedback circuit*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-14：类似吉他和放大器的反馈电路*'
- en: The *SR flip-flop* of [Figure 6-15](ch06.xhtml#ch06fig15) is a variation on
    this idea made from two NAND gates, the most common universal gate.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-15](ch06.xhtml#ch06fig15)中的*SR触发器*是由两个NAND门构成的变种，NAND门是最常见的通用逻辑门。'
- en: '![Image](../images/f0146-03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0146-03.jpg)'
- en: '*Figure 6-15: An SR flip-flop*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-15：SR触发器*'
- en: S and R stand for *set* and *reset*. When S is high, it sets the output Q to
    1\. When R is high, it resets the output Q to 0\. (This also has the advantage
    of making NOT Q available on the Q^′ output as a free by-product, which is sometimes
    useful.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: S和R代表*置位*和*重置*。当S为高电平时，它将输出Q设置为1；当R为高电平时，它将输出Q重置为0。（这也有一个优点，即可以在Q^′输出端作为副产物获得NOT
    Q，这在某些情况下很有用。）
- en: Clocked Logic
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时钟逻辑
- en: Sequential logic behavior can be unpredictable if we don’t have a clearly defined,
    discrete signal telling us when *t* has changed to *t* + 1\. This can be done
    with a clock signal, traditionally called *clk*, that steadily oscillates between
    0 and 1, as discussed in [Chapter 4](ch04.xhtml).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一个明确定义的离散信号告诉我们何时*t*已经变为*t* + 1，顺序逻辑行为可能会变得不可预测。这可以通过时钟信号来实现，传统上称为*clk*，它在0和1之间稳定振荡，如[第4章](ch04.xhtml)中讨论的那样。
- en: By tradition, the instant of the rising edge of clk is used as the instant that
    *t* increases by one; this is called a *tick*. We then design the temporal parts
    of our circuits to update their state at each tick. Copies of clk can be wired
    into many points across the system to make them all update simultaneously on each
    tick.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传统，clk的上升沿时刻被用作*t*增加1的时刻；这被称为*滴答*。我们随后设计电路的时间部分，以便在每个滴答时更新其状态。clk的副本可以接入系统的多个点，使它们在每个滴答时同步更新。
- en: As with the combinatorial logic section, we’ll now walk through a series of
    clocked logic machines.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与组合逻辑部分类似，我们现在将通过一系列时钟触发逻辑机器进行讲解。
- en: '*Clocked Flip-Flops*'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*时钟触发触发器*'
- en: Most sequential simple machines can be converted to clocked form by adding gates
    that AND their inputs with a clock signal. [Figure 6-16](ch06.xhtml#ch06fig16)
    shows how to extend an SR flip-flop in this way.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数顺序简单机器可以通过添加与时钟信号相与的门将其转换为时钟触发形式。[图6-16](ch06.xhtml#ch06fig16)展示了如何以这种方式扩展一个SR触发器。
- en: '![Image](../images/f0147-01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0147-01.jpg)'
- en: '*Figure 6-16: A clocked SR flip-flop*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-16：时钟触发SR触发器*'
- en: Only a single tick of high signal is needed in S or R to flip the state of the
    memory, which is then retained over time until a new S or R signal is received.
    Changes occur only during a clock tick, as the AND gates on the clock act to disable
    the S and R inputs at other times.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要S或R中的一个高电平脉冲即可翻转存储器的状态，随后该状态将保持，直到接收到新的S或R信号。变化仅在时钟脉冲期间发生，因为时钟上的与门作用是禁用其他时间的S和R输入。
- en: Clocked versions of simple machines are drawn with the clock input marked with
    a triangle, as in [Figure 6-17](ch06.xhtml#ch06fig17).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟触发版的简单机器通过标记为三角形的时钟输入来绘制，如[图6-17](ch06.xhtml#ch06fig17)所示。
- en: '![Image](../images/f0147-02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0147-02.jpg)'
- en: '*Figure 6-17: The symbol for a clocked SR flip-flop*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-17：时钟触发SR触发器符号*'
- en: SR is the simplest type of flip-flop to understand, and for that reason it’s
    generally used to introduce the concept, but SR flip-flops aren’t typically used
    in practice. This is because they have undesirable, undefined behavior in cases
    where both inputs are 1\. The *D-type flip-flop* has a modified design that fixes
    this issue; it’s widely used in practice. Unlike SR, it uses an inherently clock-based
    approach.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: SR是最简单理解的触发器类型，因此通常用于介绍该概念，但SR触发器在实践中并不常用。这是因为当两个输入都为1时，它们会有不希望出现的未定义行为。*D型触发器*有一个修改过的设计，解决了这个问题；它在实践中被广泛使用。与SR不同，它采用了基于时钟的固有方法。
- en: A D-type flip-flop (D for *data*) has only one data input and a clock input.
    At one point of the clock cycle, such as the rising edge, it captures the data
    on the D input. For the rest of the clock cycle, it outputs that value on its
    output Q. This stores the data for only one clock cycle—if you want to keep it
    for longer, you need to arrange external connections so that D[*t* +1] = Q[*t*].
    One of many possible implementations of a D-type flip-flop is shown in [Figure
    6-18](ch06.xhtml#ch06fig18).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: D型触发器（D代表*数据*）只有一个数据输入和一个时钟输入。在时钟周期的某一时刻，例如上升沿，它捕获D输入上的数据。在其余的时钟周期中，它将在输出Q上输出该值。这只存储一个时钟周期的数据——如果你希望保持更长时间，你需要安排外部连接，使得D[*t*
    +1] = Q[*t*]。D型触发器的多种可能实现方式之一如[图6-18](ch06.xhtml#ch06fig18)所示。
- en: '![Image](../images/f0148-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0148-01.jpg)'
- en: '*Figure 6-18: A D-type flip-flop*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-18：D型触发器*'
- en: The standard D-type flip-flop symbol is shown in [Figure 6-19](ch06.xhtml#ch06fig19).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的D型触发器符号如[图6-19](ch06.xhtml#ch06fig19)所示。
- en: '![Image](../images/f0148-02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0148-02.jpg)'
- en: '*Figure 6-19: The D-type flip-flop symbol*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-19：D型触发器符号*'
- en: Here, the standard triangle symbol is used for the clock input, and the negated
    output is shown by a circle, as used in NAND and NOR gate symbols.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，标准的三角形符号用于时钟输入，反相输出通过圆圈表示，正如在 NAND 和 NOR 门符号中所使用的。
- en: '*Counters*'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*计数器*'
- en: A *counter* is a digital logic version of Pascal’s calculator. We use a D-type
    flip-flop to store the value in each column, and wire its output to both its own
    data input (to refresh the storage) and also to the clock input of the *next*
    column’s flip-flop as a carry. This is shown in [Figure 6-20](ch06.xhtml#ch06fig20).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*计数器* 是帕斯卡计算器的数字逻辑版本。我们使用 D 型触发器来存储每列中的值，并将其输出连接到自己的数据输入（以刷新存储）以及下一个列触发器的时钟输入作为进位。这如图
    [Figure 6-20](ch06.xhtml#ch06fig20) 所示。'
- en: '![Image](../images/f0149-01.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0149-01.jpg)'
- en: '*Figure 6-20: A 4-bit binary counter*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 6-20: 一个 4 位二进制计数器*'
- en: If the input to the first column is a clock, then the counter will count the
    number of ticks that have taken place. If you take an output wire from one of
    the columns of the counter, you get a clock divider, which drops the clock frequency
    by a power of two. This is useful when you have a fast clock and want to create
    a slower clock from it, for example to use as a clock for slower pieces of hardware.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个列的输入是时钟信号，则计数器将计算已发生的时钟滴答次数。如果你从计数器的某一列取出输出线，你就得到了一个时钟分频器，它将时钟频率降低到二的幂次。这在你拥有一个快速时钟并想从中创建一个慢时钟时非常有用，例如用作较慢硬件部分的时钟。
- en: Alternatively, the input to the first column can be any arbitrary signal, such
    as a wire from a manual-controlled switch or some other event in a digital circuit,
    in which case the counter will count the number of these events that have taken
    place.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，第一个列的输入可以是任何任意信号，例如来自手动控制开关的线或数字电路中的其他事件，在这种情况下，计数器将计算这些事件发生的次数。
- en: '*Sequencers*'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*序列发生器*'
- en: A *sequencer* is a device that triggers a bunch of other devices at particular
    times. For example, a traffic light sequencer will turn on and off the different
    colored lights in a particular, repeating order. A sequencer can be made from
    a counter and a decoder, as in [Figure 6-21](ch06.xhtml#ch06fig21), which simply
    uses the counter’s output as an input to the decoder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列发生器* 是一种在特定时间触发其他设备的装置。例如，交通灯序列发生器将按照特定的、重复的顺序打开和关闭不同颜色的灯。一个序列发生器可以由计数器和解码器组成，如图
    [Figure 6-21](ch06.xhtml#ch06fig21) 所示，它简单地使用计数器的输出作为解码器的输入。'
- en: '![Image](../images/f0149-02.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0149-02.jpg)'
- en: '*Figure 6-21: An eight-state sequencer using a 3-bit counter and decoder*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 6-21: 一个八状态序列发生器，使用 3 位计数器和解码器*'
- en: '*Random-Access Memory*'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*随机存取存储器*'
- en: '*Random-access memory (RAM)* is memory that consists of addresses, each containing
    a group of bits of data known as a *word*, and in which any address can be read
    and written at equal time cost. Babbage’s Analytical Engine features a mechanical
    RAM; let’s see how to build the same structure from digital logic as a simple
    machine.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机存取存储器 (RAM)* 是由地址组成的存储器，每个地址包含一组数据位，称为 *字*，并且可以在相同的时间成本下读取或写入任何地址。巴贝奇的分析机具有机械式
    RAM；让我们看看如何用数字逻辑构建一个简单机器来实现相同的结构。'
- en: Basic RAM has three groups of wires as its interface. First, *N* address wires
    carry a binary natural number representation specifying which of 2^(*N*) addresses
    is of interest. Each address stores a word of length *M* so, second, a group of
    *M* data wires carry copies of words to or from the specified address of the RAM.
    Finally, a single control wire, called *write*, carries a single bit that controls
    whether the specified address is to be read or written.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 RAM 接口有三组线。首先，*N* 个地址线传输一个二进制自然数表示，指定哪个 2^(*N*) 地址是感兴趣的。每个地址存储一个长度为 *M*
    的字，因此，第二组 *M* 根数据线传输数据到 RAM 指定地址或从该地址读取数据。最后，一根单独的控制线，称为 *write*，传输一个单比特，控制指定地址是进行读取还是写入操作。
- en: '[Figure 6-22](ch06.xhtml#ch06fig22) shows a (toy-sized) RAM with *N* = 2 and
    *M* = 2\. The address wires are labeled A0 and A1, and the data wires D0 and D1.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 6-22](ch06.xhtml#ch06fig22) 显示了一个（玩具大小的）RAM，其中 *N* = 2 且 *M* = 2。地址线标记为
    A0 和 A1，数据线为 D0 和 D1。'
- en: '![Image](../images/f0150-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0150-01.jpg)'
- en: '*Figure 6-22: A simple RAM, with addressed words implemented as flip-flops.
    This toy example has a 2-bit address space of 2-bit words.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 6-22: 一个简单的 RAM，地址字通过触发器实现。这个玩具示例有一个 2 位地址空间，存储 2 位字。*'
- en: Each of the 2² = 4 addresses stores a 2-bit word. Each bit of each word is stored
    by a D-type flip-flop. The selection of address from the address wires is performed
    using a decoder.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个2² = 4个地址存储一个2位字。每个字的每个位由一个D型触发器存储。地址选择是通过解码器从地址线中选择的。
- en: '**HARDWARE DESCRIPTION LANGUAGES**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件描述语言**'
- en: The tools used in this book are focused on LogiSim and simulation. Large-scale
    architecture is, however, usually done via a stack of text-based languages such
    as netlists, Verilog, and Chisel. Let’s take a brief look at these formats in
    case you max out LogiSim and want to explore larger and more complex designs in
    your own projects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的工具主要集中在LogiSim和仿真上。然而，大规模架构通常是通过一系列基于文本的语言，如网表、Verilog和Chisel来完成的。为了防止你在使用LogiSim时受限，接下来我们简要了解这些格式，以便你能够在自己的项目中探索更大、更复杂的设计。
- en: '**Mask Files**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**掩模文件**'
- en: '*Mask files* are the very lowest level of chip description, containing the
    physical locations, sizes, and shapes of components such as transistors and wires.
    These are used to produce the masks needed for fabrication.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*掩模文件*是芯片描述的最低级别，包含了组件如晶体管和导线的物理位置、大小和形状。这些文件用于制造过程中所需的掩模。'
- en: '**Netlist Files**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**网表文件**'
- en: '*Netlist files* contain descriptions of connectivity between physical components
    and wires, but as abstract connectivity rather than a physical layout. You use
    a layout engine program to *place and route* the connections—that is, to transform
    a netlist file into a mask file. (This is an NP-hard problem, so layout programs
    use complex heuristics that were until recently closely guarded commercial secrets.)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*网表文件*包含了物理组件和导线之间连接的描述，但这种连接是抽象的，而非物理布局。你使用布局引擎程序来*布置和连接*这些连接——也就是将网表文件转化为掩模文件。（这是一个NP难度问题，因此布局程序使用复杂的启发式算法，这些算法直到最近还被视为商业机密。）'
- en: '**Verilog and VHDL Files**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**Verilog和VHDL文件**'
- en: '*Verilog* and *VHDL* are text-based hardware description languages for designing
    electronic systems. In their most basic forms, they have a similar function to
    LogiSim, allowing you to instantiate and connect various electronic components.
    But instead of using a GUI, they use text files with a syntax similar to software
    programming languages. Unlike a language like C, however, which is imperative,
    Verilog and VHDL fundamentally describe static objects and relationships between
    them. In this sense, their structure is more like XML or a database, containing
    lists of facts rather than instructions to *do* things. For example, here’s a
    Verilog module representing a full adder:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*Verilog*和*VHDL*是基于文本的硬件描述语言，用于设计电子系统。在它们最基本的形式中，它们与LogiSim的功能相似，可以实例化并连接各种电子组件。但不同的是，它们使用类似软件编程语言的语法的文本文件，而不是图形界面。与像C这样的命令式语言不同，Verilog和VHDL本质上描述的是静态对象及其之间的关系。从这个意义上说，它们的结构更像是XML或数据库，包含事实的列表，而不是去*做*某些事情的指令。例如，这里是一个表示全加器的Verilog模块：'
- en: '[PRE0]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you write a Verilog or VHDL description, a compiler turns it into a netlist.
    This compilation process is called *synthesis* because the logic expressed in
    the source code is synthesized from gates. Software simulators also exist that
    can be used to test Verilog or VHDL hardware designs without actually manufacturing
    the hardware.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写了Verilog或VHDL描述，编译器会将其转化为网表。这个编译过程被称为*综合*，因为源代码中表达的逻辑是通过门电路合成的。也有软件模拟器可以用于在不实际制造硬件的情况下测试Verilog或VHDL硬件设计。
- en: While some people still write Verilog or VHDL by hand to design digital logic,
    it’s becoming more common to use higher-level tools such as LogiSim or Chisel
    (discussed next) that compile into Verilog or VHDL. Verilog also adds higher-level
    language constructions that enable some C-like imperative programming and get
    compiled to digital logic structures. LogiSim Evolution is able to export your
    designs as Verilog or VHDL, which enables you to compile them to netlists and
    use them to make real chips.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然仍有一些人手动编写Verilog或VHDL来设计数字逻辑，但使用更高层次的工具，如LogiSim或Chisel（接下来会讨论），并将其编译成Verilog或VHDL的做法变得更加常见。Verilog还增加了一些高级语言结构，使得一些类似C的命令式编程成为可能，并且可以编译成数字逻辑结构。LogiSim
    Evolution能够将你的设计导出为Verilog或VHDL，这样你就可以将其编译成网表并用来制造实际的芯片。
- en: '**Chisel**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chisel**'
- en: '*Chisel* is a high-level hardware language that was developed for general architecture
    design use. Chisel describes classes of hardware with object orientation; for
    example, you could create a `FullAdder` class to represent the class of full adders,
    which could be abstracted and inherited in the usual high-level object-oriented
    ways:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chisel*是一种为通用架构设计使用而开发的高级硬件语言。Chisel使用面向对象的方式描述硬件类别；例如，你可以创建一个`FullAdder`类来表示全加器的类别，该类别可以像通常的面向对象方式那样被抽象化并继承：'
- en: '[PRE1]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Chisel classes may have parameters for numbers of input and output wires, for
    example, to enable loops to generate *N* full adders to make a ripple adder.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Chisel类可能有输入和输出线数的参数，例如，可以启用循环生成*N*个全加器，从而构建一个波纹加法器。
- en: Chisel is a hardware language, but it’s based closely on the very high-level
    Scala software language. Scala, in turn, is influenced heavily by lambda calculus,
    functional programming, and Java; these kinds of languages are not usually associated
    with hardware design, so bringing them in has enabled Chisel to operate at much
    higher levels than the old days of having to do hardware design in Verilog. You
    may benefit from taking regular Scala tutorials before attempting to work with
    Chisel.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Chisel是一种硬件语言，但它与高级的Scala软件语言紧密相关。Scala又受到λ演算、函数式编程和Java的强烈影响；这些语言通常不与硬件设计相关联，因此引入它们使得Chisel能够在更高层次上运作，而不再局限于过去必须在Verilog中进行硬件设计的时代。在开始使用Chisel之前，定期学习Scala教程可能会对你有所帮助。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Logic gates can be combined into networks to perform more complex functions.
    Simple machines are certain well-known types of networks that tend to appear again
    and again in architecture. Combinatorial logic machines—including shifters, encoders,
    multiplexers, and adders—use Shannon’s original theory, without relying on feedback
    or time. When feedback and clocks are also allowed, additional sequential and
    clocked logic simple machines can be created as well. These are able to retain
    data in memory over time. Flip-flops are simple machines storing 1 bit of memory.
    They can function as subcomponents of counters, sequencers, and RAM.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑门可以组合成网络以执行更复杂的功能。简单机器是某些著名的网络类型，通常会在架构中反复出现。组合逻辑机器——包括移位器、编码器、多路复用器和加法器——使用香农的原始理论，而不依赖于反馈或时序。当允许反馈和时钟时，还可以创建额外的顺序和时钟逻辑简单机器。这些机器能够在一段时间内保持数据存储。触发器是简单的机器，用于存储1位内存。它们可以作为计数器、序列器和RAM的子组件来使用。
- en: Now that we have a collection of simple machines, we can combine them in the
    next chapter to build a digital logic CPU.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了一系列简单机器，我们可以在下一章中将它们组合起来，构建一个数字逻辑CPU。
- en: Exercises
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Building Simple Machines in LogiSim Evolution**'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在LogiSim Evolution中构建简单机器**'
- en: As you work on the following exercises, keep in mind that you can create hierarchies
    of subcircuits in LogiSim. You might do this, for example, so that your shifter
    becomes available as a single component to use in higher-level networks. To create
    a subcircuit, click the **+** button. Then, to use the new component, go back
    to the main circuit and add it like any other component. Use pins for input and
    output inside the subcircuit if you want them to show in the external interface
    in the main circuit.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在做以下练习时，请记住，你可以在LogiSim中创建子电路的层次结构。例如，你可能会这样做，以便将你的移位器作为一个单一组件，用于更高级别的网络。要创建子电路，点击**+**按钮。然后，为了使用这个新组件，返回到主电路并像添加其他组件一样添加它。如果你希望输入和输出在主电路的外部接口中显示，可以在子电路内使用引脚。
- en: Build the left-shifter ([Figure 6-3](ch06.xhtml#ch06fig3)), decoder ([Figure
    6-4](ch06.xhtml#ch06fig4)), and multiplexer ([Figure 6-5](ch06.xhtml#ch06fig5))
    shown earlier in this chapter.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建本章前面显示的左移器（[图6-3](ch06.xhtml#ch06fig3)）、解码器（[图6-4](ch06.xhtml#ch06fig4)）和多路复用器（[图6-5](ch06.xhtml#ch06fig5)）。
- en: Design and build a right-shifter, encoder, and demultiplexer. These perform
    the inverse functions of the left-shifter, decoder, and multiplexer, respectively.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计并构建一个右移器、编码器和解多路复用器。这些分别执行左移器、解码器和多路复用器的逆向功能。
- en: Build and test an 8-bit ripple-carry adder. Use it to perform subtraction and
    addition, using two’s complement.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并测试一个8位的波纹进位加法器。使用它进行减法和加法运算，采用二补码表示。
- en: Build and test unclocked and clocked SR flip-flops, and a D-type flip-flop.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并测试无时钟和有时钟的SR触发器，以及D型触发器。
- en: Build and test a counter, using a clock as its input.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并测试一个计数器，使用时钟作为输入。
- en: 'Build a traffic light sequencer from a 2-bit counter and decoder. Use it to
    light red, amber, and green bulbs in the UK’s standard sequence, which goes: (1)
    red (stop); (2) red and amber together (get ready to go); (3) green (go); (4)
    amber (get ready to stop). This is roughly how the control unit of a CPU works.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 2 位计数器和解码器构建一个交通灯序列器。使用它按照英国标准顺序点亮红灯、黄灯和绿灯，顺序如下：（1）红灯（停止）；（2）红灯和黄灯一起亮（准备前行）；（3）绿灯（前行）；（4）黄灯（准备停车）。这大致就是
    CPU 控制单元的工作方式。
- en: '**Prebuilt LogiSim Modules**'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**预构建的 LogiSim 模块**'
- en: LogiSim has prebuilt modules for many simple machines. For example, there’s
    a prebuilt RAM module found under Memory in the menu, as in [Figure 6-23](ch06.xhtml#ch06fig23).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: LogiSim 提供了许多简单机器的预构建模块。例如，在菜单中的 Memory 下可以找到一个预构建的 RAM 模块，如 [图 6-23](ch06.xhtml#ch06fig23)
    所示。
- en: '![Image](../images/f0153-01.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0153-01.jpg)'
- en: '*Figure 6-23: An eight-address, 2-bit word RAM*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-23：一个八地址、2 位字长的 RAM*'
- en: This version has two control inputs, one for write enable and one for read enable.
    A NOT gate is used in the figure to create both from a single control line.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该版本有两个控制输入，一个用于写使能，另一个用于读使能。图中使用了一个 NOT 门来从单个控制线创建这两个信号。
- en: Explore LogiSim’s prebuilt modules that correspond to the machines you implemented
    in the previous exercises. Check that they give the same results as your own implementations.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索 LogiSim 中的预构建模块，这些模块与您在前面的练习中实现的机器相对应。检查它们是否与您自己的实现结果相同。
- en: Explore the RAM module shown in [Figure 6-23](ch06.xhtml#ch06fig23). Use the
    module options to specify the RAM’s word and address lengths. You can manually
    edit the RAM’s contents with a built-in hex editor by right-clicking and then
    clicking Edit Contents. A splitter, found in the Wiring menu, is used to bundle
    and unbundle groups of wires for data and address. A probe or LEDs can be used
    for output; constants, DIP switches, or pins can be used for input.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索 [图 6-23](ch06.xhtml#ch06fig23) 中显示的 RAM 模块。使用模块选项指定 RAM 的字长和地址长度。您可以通过右键单击并选择“编辑内容”来手动编辑
    RAM 的内容，使用内置的十六进制编辑器。一个分离器（在 Wiring 菜单中）用于捆绑和解捆数据和地址线组。可以使用探针或 LED 来显示输出；常数、DIP
    开关或引脚可以用作输入。
- en: '**Challenging**'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**具有挑战性**'
- en: Design and build a natural number multiplier in LogiSim. This can be done by
    following the usual multiplication algorithm that you were taught at school, but
    in binary. You can use shifters to multiply one of the inputs by all the different
    powers of two, then adders to add together those powers that are present in the
    second number. Use AND gates to enable and disable the relevant powers. As is
    often the case in architecture, you can choose whether to use multiple silicon
    copies of the required structures, or use a single copy plus timing logic to run
    it many times.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 LogiSim 中设计并构建一个自然数乘法器。这可以通过遵循学校里教给您的常规乘法算法来完成，不过是用二进制表示的。您可以使用移位器将其中一个输入乘以所有不同的二的幂，然后使用加法器将第二个数字中存在的幂加起来。使用与门来启用和禁用相关的幂。像在架构设计中经常发生的那样，您可以选择使用多个硅片副本来实现所需结构，或者使用一个副本加上时序逻辑来多次运行它。
- en: Extend your multiplier to work with negative integers, using two’s complement
    data representation.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展您的乘法器，使其能够处理负整数，使用二进制补码数据表示法。
- en: '**More Challenging**'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**更具挑战性**'
- en: Design, build, and test an 8-bit carry-save adder in LogiSim. How much more
    efficient is it than a ripple-carry adder?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LogiSim 中设计、构建并测试一个 8 位的进位保存加法器。与传统的波纹进位加法器相比，它效率提高了多少？
- en: Further Reading
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入阅读
- en: For full details on how to use LogiSim, including advanced features, see George
    Self, *LogiSim Evolution Lab Manual* (July 2019), *[https://www.icochise.com/docs/logisim.pdf](https://www.icochise.com/docs/logisim.pdf)*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用 LogiSim 的完整细节，包括高级功能，请参阅 George Self 的 *LogiSim Evolution Lab Manual*（2019年7月），*
    [https://www.icochise.com/docs/logisim.pdf](https://www.icochise.com/docs/logisim.pdf)
    *。
