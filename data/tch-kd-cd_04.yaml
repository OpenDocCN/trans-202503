- en: Chapter 4. Loops Are Fun (You Can Say That Again)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 循环很有趣（你可以再说一遍）
- en: We’ve used loops since our very first program to draw repeating shapes. Now
    it’s time to learn how to build our own loops from scratch. Whenever we need to
    do something over and over again in a program, loops allow us to repeat those
    steps without having to type each one separately. [Figure 4-1](ch04.html#four-circle_rosette_pattern
    "Figure 4-1. A four-circle rosette pattern") shows a visual example—a rosette
    made up of four circles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们编写第一个程序开始，就一直在使用循环来绘制重复的图形。现在是时候学习如何从头开始构建我们自己的循环了。每当我们需要在程序中做一些重复的事情时，循环可以让我们在不需要单独输入每个步骤的情况下重复这些步骤。[图4-1](ch04.html#four-circle_rosette_pattern
    "图4-1. 四圈花纹图案")展示了一个视觉示例——由四个圆圈组成的花纹。
- en: '![A four-circle rosette pattern](httpatomoreillycomsourcenostarchimages2188850.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![四圈花纹图案](httpatomoreillycomsourcenostarchimages2188850.png.jpg)'
- en: Figure 4-1. A four-circle rosette pattern
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1. 四圈花纹图案
- en: 'Let’s think about how we might write a program to draw four circles overlapping
    as shown. As you saw in [Chapter 2](ch02.html "Chapter 2. Turtle Graphics: Drawing
    with Python"), Turtle’s `circle()` command draws a circle with the radius we specify
    inside its parentheses. Those circles look like they’re at the north, south, east,
    and west of the screen, 90 degrees apart, and we know how to turn left or right
    90 degrees. So we could write four pairs of statements to draw a circle, then
    turn 90 degrees, and then draw another circle, as in the following code. Type
    this into a new window and save it as *Rosette.py*.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下如何编写程序来绘制四个重叠的圆圈，如图所示。正如你在[第二章](ch02.html "第二章. 龟图形：用Python绘图")中看到的，Turtle的`circle()`命令会根据我们在括号中指定的半径绘制一个圆形。这些圆形看起来像是位于屏幕的正北、正南、正东和正西，相距90度，我们知道如何将方向转90度。所以，我们可以编写四对语句来绘制一个圆圈，然后转90度，再绘制另一个圆圈，代码如下。将这段代码输入到一个新窗口，并将其保存为*Rosette.py*。
- en: Rosette.py
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rosette.py
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code works, but doesn’t it feel repetitive? We typed the code to draw a
    circle four times and the code to turn left three times. We know from our spiral
    examples that we should be able to write a chunk of code once and reuse that code
    in a `for` loop. In this chapter, we’re going to learn how to write those loops
    ourselves. Let’s try it now!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以工作，但感觉是不是有点重复呢？我们编写了四次绘制圆形的代码，并且写了三次向左转的代码。通过我们之前的螺旋示例，我们知道应该能够将一段代码写一次，然后在`for`循环中重复使用。在本章中，我们将学习如何自己编写这些循环。现在就来试试吧！
- en: Building Your Own for Loops
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你自己的`for`循环
- en: To build our own loop, we first need to identify the repeated steps. The instructions
    that we’re repeating in the preceding code are `t.circle(100)` to draw a turtle
    circle with a radius of 100 pixels and `t.left(90)` to turn the turtle left 90
    degrees before drawing the next circle. Second, we need to figure out how many
    times to repeat those steps. We want four circles, so let’s start with four.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们自己的循环，首先需要确定重复的步骤。在前面的代码中，我们重复的指令是`t.circle(100)`，用来绘制半径为100像素的龟形圆圈，以及`t.left(90)`，用来在绘制下一个圆圈之前将龟形向左转90度。其次，我们需要弄清楚这些步骤需要重复多少次。我们想要绘制四个圆圈，所以从四开始。
- en: Now that we know the two repeated instructions and the number of times to draw
    the circle, it’s time to build our `for` loop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了两个重复的指令和绘制圆形的次数，是时候构建我们的`for`循环了。
- en: A `for` loop in Python *iterates over* a list of items, or repeats once for
    each item in a list—like the numbers 1 through 100, or 0 through 9\. We want our
    loop to run four times—once for each circle—so we need to set up a list of four
    numbers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`for`循环*遍历*一个项目列表，或者对于列表中的每个项目重复一次——例如数字1到100，或0到9。我们希望我们的循环运行四次——每个圆圈一次——因此我们需要设置一个包含四个数字的列表。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188854.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188854.png.jpg)'
- en: The built-in function `range()` allows us to easily create lists of numbers.
    The simplest command to construct a range of *n* numbers is `range(n)`; this command
    will let us build a list of *n* numbers from 0 to *n* – 1 (from zero to one less
    than our number *n*).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内建函数`range()`让我们能够轻松创建数字列表。构造*n*个数字范围的最简单命令是`range(n)`；这个命令会让我们生成一个从0到*n* –
    1（从零到小于*n*的数字）的数字列表。
- en: 'For example, `range(10)` allows us to create a list of the 10 numbers from
    0 to 9\. Let’s enter a few sample `range()` commands in the IDLE command prompt
    window to see how this works. To see our lists printed out, we’ll need to use
    the `list()` function around our range. At the `>>>` prompt, enter this line of
    code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`range(10)`允许我们创建一个包含从0到9的10个数字的列表。让我们在IDLE命令提示符窗口中输入一些示例`range()`命令，看看它是如何工作的。为了查看我们打印出的列表，我们需要在`range`周围使用`list()`函数。在`>>>`提示符下，输入这一行代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'IDLE will give you the output `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`: a list of 10
    numbers, starting from 0\. To get longer or shorter lists of numbers, you can
    enter different numbers inside the parentheses of the `range()` function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE会给出输出`[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`：一个包含10个数字的列表，从0开始。要获得更长或更短的数字列表，你可以在`range()`函数的括号中输入不同的数字：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, entering `list(range(3))` gives you a list of three numbers
    starting at 0, and entering `list(range(5))` gives you a list of five numbers
    starting at 0.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输入`list(range(3))`会给你一个包含三个数字的列表，从0开始，输入`list(range(5))`则会给你一个包含五个数字的列表，同样从0开始。
- en: Using a for Loop to Make a Rosette with Four Circles
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`for`循环绘制一个四圈花环
- en: 'For our four-circle rosette shape, we need to repeat drawing a circle four
    times, and `range(4)` will help us do that. The syntax, or word order, of our
    `for` loop will look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的四圈花环形状，我们需要重复画四次圆，`range(4)`可以帮助我们做到这一点。我们`for`循环的语法或词序将如下所示：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We start with the keyword `for` and then we give a variable, `x`, that will
    be our counter or *iterator* variable. The `in` keyword tells the `for` loop to
    step `x` through each of the values in the range list, and `range(4)` gives the
    loop a list of the numbers from 0 to 3, `[0,1,2,3]`, to step through. Remember
    that the computer usually starts counting from 0 instead of starting from 1 as
    we do.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从关键字`for`开始，然后指定一个变量`x`，它将作为我们的计数器或*迭代器*变量。`in`关键字告诉`for`循环让`x`遍历范围列表中的每个值，而`range(4)`为循环提供从0到3的数字列表`[0,1,2,3]`，让循环按顺序执行。记住，计算机通常从0开始计数，而不是像我们一样从1开始。
- en: To tell the computer which instructions are supposed to be repeated, we use
    *indentation*; we indent each command that we want to repeat in the loop by pressing
    the TAB key in the new file window. Type this new version of our program and save
    it as *Rosette4.py*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉计算机哪些指令需要重复执行，我们使用*缩进*；我们通过在新文件窗口中按下TAB键来缩进每个需要在循环中重复执行的命令。输入这个新版本的程序并将其保存为*Rosette4.py*。
- en: Rosette4.py
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rosette4.py
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a much shorter version of our *Rosette.py* program, thanks to the `for`
    loop, yet it produces the same four circles as the version without the loop. This
    program loops through lines 3, 4, and 5 a total of four times, generating a rosette
    of four circles on the top, left, bottom, and right sides of our window. Let’s
    take a step-by-step look through the loop as it draws our rosette, one circle
    at a time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们*Rosette.py*程序的一个更简短版本，得益于`for`循环，它仍然产生和没有循环版本一样的四个圆。这个程序总共循环执行第3、4和5行四次，在窗口的顶部、左侧、底部和右侧生成一个四圈花环。让我们逐步回顾这个循环，看看它是如何一次绘制一个圆的。
- en: The first time through the loop, our counter `x` has a starting value of `0`,
    the first value in the range list `[0, 1, 2, 3]`. We draw our first circle at
    the top of the window with `t.circle(100)` and then turn the turtle to the left
    by 90 degrees with `t.left(90)`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一次执行循环时，我们的计数器`x`的初始值是`0`，即`[0, 1, 2, 3]`范围列表中的第一个值。我们使用`t.circle(100)`在窗口的顶部画出第一个圆，然后使用`t.left(90)`将海龟向左转90度。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188857.png.jpg)'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188857.png.jpg)'
- en: Python goes back to the beginning of the loop and sets `x` to `1`, the second
    value in `[0, 1, 2, 3]`. Then it draws the second circle on the left side of the
    window and turns the turtle left by 90 degrees.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python回到循环的开始，将`x`设置为`1`，即`[0, 1, 2, 3]`中的第二个值。然后，它在窗口的左侧画出第二个圆，并将海龟向左转90度。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188859.png.jpg)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188859.png.jpg)'
- en: Python goes back through the loop again, increasing `x` to `2`. It draws the
    third circle at the bottom of the window and turns the turtle left.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python再次回到循环中，将`x`增大到`2`。它在窗口底部画出第三个圆，并将海龟向左转。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188861.png.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188861.png.jpg)'
- en: On the fourth and final time through the loop, Python increases `x` to `3`,
    then runs `t.circle(100)` and `t.left(90)` to draw our fourth circle on the right
    side of the window and turn the turtle. The rosette is now complete.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第四次也是最后一次通过循环时，Python将`x`增加到`3`，然后执行`t.circle(100)`和`t.left(90)`来绘制第四个圆，并使海龟转动。玫瑰图案现在完成了。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188863.png.jpg)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188863.png.jpg)'
- en: Modifying Our for Loop to Make a Rosette with Six Circles
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改我们的for循环，制作六个圆的玫瑰图案
- en: Now that we’ve built our own `for` loop together from scratch, could you modify
    the program on your own to draw something new? What if we wanted to draw a rosette
    with six circles instead of four? What might we need to change in our program?
    Take a moment to think about how you might solve this problem.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经一起从头开始构建了自己的`for`循环，你能自己修改程序绘制一些新东西吗？如果我们想绘制一个有六个圆而不是四个圆的玫瑰图案，我们需要在程序中做什么改变呢？花点时间思考一下你如何解决这个问题。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188865.png.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188865.png.jpg)'
- en: '* * *'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Did you come up with some ideas? Let’s walk through the problem together. First,
    we know that we need six circles this time instead of four, so our range will
    need to change to `range(6)` in our `for` loop. But if we just change that, we’re
    not going to see any difference in our drawing, because we’ll continue to draw
    over the same four circles separated by 90 degrees. If we want six circles around
    the rosette, we’ll need to divide the rosette into six left turns instead of four.
    There are 360 degrees around the center of our drawing: four 90-degree turns took
    us 4 × 90 = 360 degrees all the way around. If we divide 360 by 6 instead of 4,
    we get 360 ÷ 6 = 60 degrees for each turn. So in our `t.left()` command, we need
    to turn left 60 degrees each time through the loop, or `t.left(60)`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你想到了什么点子吗？我们一起走一遍这个问题。首先，这次我们需要六个圆而不是四个，所以我们的`for`循环中的范围需要更改为`range(6)`。但是如果我们仅仅做这个更改，图形上不会看到任何不同，因为我们还是会继续绘制四个相隔90度的圆。如果我们想要六个圆围绕着玫瑰图案，我们需要把玫瑰图案分成六个左转，而不是四个。我们绘图中心周围有360度：四个90度的转弯让我们走了4
    × 90 = 360度一圈。如果我们将360度除以6而不是4，我们得到360 ÷ 6 = 60度每次转弯。所以在我们的`t.left()`命令中，我们需要每次通过循环时左转60度，即`t.left(60)`。
- en: Modify your rosette program and save it as *Rosette6.py*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你的玫瑰图程序，并将其保存为*Rosette6.py*。
- en: Rosette6.py
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rosette6.py
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, the for loop statement in ➊ will step `x` through the list of six
    values from `0` to `5`, so we’ll repeat the indented steps ➋ and ➌ six times each.
    At ➋, we’re still drawing a circle with a radius of `100`. At ➌, though, we’re
    turning only 60 degrees each turn, or one-sixth of 360 degrees, so we get six
    circles around the center of the screen this time, as shown in [Figure 4-2](ch04.html#rosette_of_six_circles
    "Figure 4-2. A rosette of six circles").
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，➊中的for循环语句会让`x`遍历从`0`到`5`的六个值，所以我们将重复缩进部分的步骤➋和➌六次。在➋中，我们仍然绘制一个半径为`100`的圆。然而，在➌中，我们每次只转动60度，或者说是360度的六分之一，所以这次我们将绘制六个圆围绕着屏幕的中心，正如[图4-2](ch04.html#rosette_of_six_circles
    "图4-2。六个圆的玫瑰图案")所示。
- en: '![A rosette of six circles](httpatomoreillycomsourcenostarchimages2188867.png.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![六个圆的玫瑰图案](httpatomoreillycomsourcenostarchimages2188867.png.jpg)'
- en: Figure 4-2. A rosette of six circles
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2。六个圆的玫瑰图案
- en: The rosette with six circles is even prettier than the one with four circles,
    and thanks to our `for` loop, we didn’t have to write any more lines of code to
    get six circles than we did to get four—we just changed two numbers! Because we
    varied those two numbers, you may be tempted to replace them with a variable.
    Let’s give in to that temptation. Let’s give the user the power to draw a rosette
    with *any* number of circles.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 六个圆的玫瑰图案比四个圆的更漂亮，感谢我们的`for`循环，我们无需再写更多的代码行来绘制六个圆——我们只改动了两个数字！由于我们更改了这两个数字，你可能会想用变量来代替它们。让我们顺从一下这个诱惑，给用户提供绘制*任意*数量圆的能力。
- en: Improving Our Rosette Program with User Input
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过用户输入改进我们的玫瑰图程序
- en: 'In this section, we’ll use the `turtle.numinput()` function that we saw in
    [Chapter 3](ch03.html "Chapter 3. Numbers and Variables: Python Does the Math")
    (see [ColorSpiralInput.py](ch03.html#colorspiralinputdotpy "ColorSpiralInput.py"))
    to write a program that asks the user to enter a number and then draws a rosette
    with that number of circles. We’ll set the user’s number as the size of our `range()`
    constructor. Then, all we have to do is divide 360 degrees by that number, and
    we’ll find the number of degrees to turn left each pass through the loop. Type
    and run the following code as *RosetteGoneWild.py*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用我们在[第3章](ch03.html "第3章. 数字与变量：Python做数学")中看到的`turtle.numinput()`函数（见[ColorSpiralInput.py](ch03.html#colorspiralinputdotpy
    "ColorSpiralInput.py")），编写一个程序，要求用户输入一个数字，然后用这个数字的圆圈数绘制玫瑰图案。我们将用户输入的数字作为`range()`构造函数的大小。然后，我们所要做的就是将360度除以这个数字，就能得到每次循环时要左转的度数。键入并运行以下代码，保存为*RosetteGoneWild.py*：
- en: RosetteGoneWild.py
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RosetteGoneWild.py
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At ➊, we assign a variable called `number_of_circles` using a couple of functions
    together. We’re using Turtle’s `numinput()` function to ask the user how many
    circles to draw. The first value, `Number of circles`, is the pop-up window’s
    title; the second, `How many circles in your rosette?`, is the text that will
    appear in the box; and the last, `6`, is a default value in case the user doesn’t
    enter anything. The `int()` function outside `numinput()` turns the user’s number
    into an integer we can use in our `range()` function. We store the user’s number
    as `number_of_circles` to use as the size of the `range()` in our drawing loop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们通过将几个函数组合在一起，给一个变量赋值，名为`number_of_circles`。我们使用Turtle的`numinput()`函数询问用户要绘制多少个圆圈。第一个值`Number
    of circles`是弹出窗口的标题；第二个值`How many circles in your rosette?`是将在输入框中显示的文本；最后，`6`是默认值，以防用户没有输入任何内容。`int()`函数位于`numinput()`外部，将用户输入的数字转化为整数，以便我们可以在`range()`函数中使用。我们将用户输入的数字存储为`number_of_circles`，用于作为绘图循环中`range()`的大小。
- en: The `for` statement at ➋ is our loop. It uses the `number_of_circles` variable
    to loop `x` through a list of that many numbers. The command to draw a circle
    is still the same at ➌ and will draw circles with a radius of 100 pixels. At ➍,
    we’re dividing a full turn of 360 degrees by the number of circles so we can draw
    the circles evenly spaced around the center of the screen. For example, if the
    user enters `30` as the number of circles, 360 ÷ 30 would give us a 12-degree
    turn between each of the 30 circles around our center point, as shown in [Figure 4-3](ch04.html#user-defined_rosette_of_30_circles
    "Figure 4-3. A user-defined rosette of 30 circles").
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ➋处的`for`语句是我们的循环。它使用`number_of_circles`变量让`x`遍历一个包含如此多数字的列表。绘制圆圈的命令在➌处仍然相同，它将绘制半径为100像素的圆圈。在➍处，我们将360度的完整旋转除以圆圈的数量，这样就可以将圆圈均匀地分布在屏幕中心周围。例如，如果用户输入`30`作为圆圈的数量，则360
    ÷ 30将得到每两个圆圈之间的12度角，如[图4-3](ch04.html#user-defined_rosette_of_30_circles "图4-3.
    用户定义的30个圆圈玫瑰图案")所示。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188869.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188869.png.jpg)'
- en: 'Run the program and try your own numbers. You can even make a rosette of 90
    circles, or 200 (but you’ll be waiting a while as Python draws that many circles!).
    Customize the program to make it your own: change the background color or the
    rosette color, make the circles bigger or smaller, or make them bigger *and* smaller!
    Play with your programs as you create them and as you think of fun things you’d
    like them to do. [Figure 4-4](ch04.html#little_imagination_and_a_touch_of_code_c
    "Figure 4-4. A little imagination and a touch of code can turn our rosette program
    into a lot of colorful fun!") shows what my five-year-old son, Alex, dreamed up
    by adding just three extra lines of code to *RosetteGoneWild.py*. Go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    for the source code.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并尝试输入你自己的数字。你甚至可以创建一个包含90个圆圈的玫瑰图案，或者200个（但你可能得等一会儿，因为Python要画这么多圆圈！）。定制程序让它更符合你的需求：更改背景颜色或玫瑰图案的颜色，将圆圈做得更大或更小，或者同时做得更大*和*更小！在创建程序并思考你想要它们做的有趣事情时，尽情地玩弄你的程序。[图4-4](ch04.html#little_imagination_and_a_touch_of_code_c
    "图4-4. 一点想象力和一些代码就能将我们的玫瑰图案程序变成许多五彩斑斓的有趣效果！")展示了我的五岁儿子Alex通过在*RosetteGoneWild.py*中仅增加三行代码所创作的内容。请访问*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*获取源代码。
- en: '![A user-defined rosette of 30 circles](httpatomoreillycomsourcenostarchimages2188871.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![用户定义的30个圆圈玫瑰图案](httpatomoreillycomsourcenostarchimages2188871.png)'
- en: Figure 4-3. A user-defined rosette of 30 circles
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3. 用户定义的30个圆圈玫瑰图案
- en: '![A little imagination and a touch of code can turn our rosette program into
    a lot of colorful fun!](httpatomoreillycomsourcenostarchimages2188873.png.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![稍加想象和一小段代码就能将我们的玫瑰图程序变成五彩斑斓的有趣体验！](httpatomoreillycomsourcenostarchimages2188873.png.jpg)'
- en: Figure 4-4. A little imagination and a touch of code can turn our rosette program
    into a lot of colorful fun!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4。稍加想象和一小段代码就能将我们的玫瑰图程序变成五彩斑斓的有趣体验！
- en: Game Loops and while Loops
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环与`while`循环
- en: The `for` loop is powerful, but there are limits to its power. For instance,
    what if we wanted to stop our loop when some event occurred, instead of going
    all the way through a long list of numbers? Or what if we weren’t sure how many
    times to run our loop?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环很强大，但也有它的局限性。例如，假如我们希望在某个事件发生时停止循环，而不是遍历一个长长的数字列表，或者如果我们不确定要运行多少次循环呢？'
- en: For example, consider a *game loop*—when we write a program, especially a game,
    where the user gets to choose whether to keep playing or to quit. We, as programmers,
    can’t know in advance how many times users will choose to play our game or run
    our program, but we need to give them the ability to play again without having
    to reload and run the program every time. Can you imagine if you had to restart
    an Xbox or PlayStation every time you wanted to play a game again, or if you always
    had to play a game exactly 10 times before moving on to a different one? That
    might make it less fun.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个*游戏循环*——当我们编写程序时，特别是游戏程序，用户可以选择继续玩还是退出。作为程序员，我们无法提前知道用户会选择玩多少次游戏或运行多少次程序，但我们需要给他们一个可以再次玩游戏而无需每次都重新加载和运行程序的能力。你能想象每次想再玩一次游戏时，都得重新启动Xbox或PlayStation，或者每次玩游戏都必须准确玩10次，然后才切换到另一个游戏吗？那样可能会降低乐趣。
- en: 'One way we solve the game loop problem is by using another type of loop, the
    `while` loop. Instead of iterating over a predefined list of values, as the `for`
    loop does, a `while` loop can check for a *condition* or situation and decide
    whether to loop again or end the loop. The syntax of the `while` statement looks
    like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决游戏循环问题的一种方法是使用另一种类型的循环——`while`循环。与`for`循环遍历预定义的值列表不同，`while`循环可以检查一个*条件*或情境，并决定是否继续循环或结束循环。`while`语句的语法如下：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The condition is usually a [*Boolean*](apd.html#gloss01_009) expression, or
    true/false test. One everyday example of a `while` loop is eating and drinking.
    While you are hungry, you eat. When the answer to the question “Am I hungry?”
    is no longer yes, that means the condition “I am hungry” is no longer true, and
    you stop eating. While you are thirsty, you take another drink of water. When
    you stop feeling thirsty, you quit drinking. Hunger and thirst are conditions,
    and when those conditions become false, you exit the eating and drinking “loops.”
    A `while` loop continues repeating the statements in the loop (the indented statements)
    as long as the condition is true.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件通常是一个[*布尔值*](apd.html#gloss01_009)表达式，或是一个真/假测试。`while`循环的一个日常例子是吃饭和喝水。当你饿了，你就吃。当“我饿了吗？”这个问题的答案不再是“是”，这意味着“我饿了”的条件不再成立，你就停止吃饭。当你渴了，你就再喝一口水。当你不再感到渴时，你就停止喝水。饥饿和口渴是条件，当这些条件变为假时，你就退出吃饭和喝水的“循环”。`while`循环会在条件为真时继续重复循环中的语句（缩进的语句）。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188875.png.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188875.png.jpg)'
- en: The true/false conditions in `while` loops often involve comparing values. We
    might say, “Is the value of `x` bigger than 10? As long as it is, run this code.
    When `x` isn’t bigger than 10 anymore, stop running the code.” In other words,
    we run the code [*while*](apd.html#gloss01_050) the condition `x > 10` evaluates
    to `True`. The greater-than symbol (`>`) is a *comparison operator*, a different
    kind of operator from arithmetic operators like `+` (plus) and `–` (minus). Comparison
    operators—such as `>` (greater than), `<` (less than), `==` (equal to), or `!=`
    (not equal to)— let you compare two values to see if one of them is greater or
    less than the other, or if they are equal or not equal. Is `x` less than 7? Yes
    or no? `True` or `False`? Based on the result, `True` or `False`, you can tell
    your program to run different pieces of code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环中的真/假条件通常涉及比较值。我们可能会说：“`x` 的值大于 10 吗？只要大于 10，就运行这段代码。当 `x` 不再大于 10
    时，停止运行代码。”换句话说，当条件 `x > 10` 评估为 `True` 时，我们运行这段代码 [*while*](apd.html#gloss01_050)。大于号（`>`）是一个*比较运算符*，与算术运算符如
    `+`（加号）和 `–`（减号）不同。比较运算符—如 `>`（大于）、`<`（小于）、`==`（等于）或 `!=`（不等于）— 允许你比较两个值，看看一个是否大于或小于另一个，或者它们是否相等或不相等。`x`
    小于 7 吗？是或不是？`True` 还是 `False`？根据结果，`True` 或 `False`，你可以让程序运行不同的代码。'
- en: The `while` loop shares some features with the `for` loop. First, like the `for`
    loop, it repeats a set of statements over and over as needed. Second, with both
    `while` loops and `for` loops, we tell Python which statements to repeat by indenting
    them to the right with the TAB key.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环与 `for` 循环有一些相似之处。首先，像 `for` 循环一样，它会根据需要重复一组语句。其次，使用 `while` 循环和
    `for` 循环时，我们通过使用 TAB 键将语句缩进到右侧来告诉 Python 哪些语句需要重复。'
- en: 'Let’s try a program with a `while` loop to see it in action. Type the following
    code (or download it from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*),
    and run it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个带有 `while` 循环的程序，看看它如何运作。键入以下代码（或从 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    下载它），并运行：
- en: SayOurNames.py
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SayOurNames.py
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We begin the program by asking the user their name at ➊ and storing their answer
    in the variable `name`. We need a name to test as the condition of our `while`
    loop, so we have to ask once *before* the loop starts. Then, at ➋, we start our
    `while` loop, which will run as long as the name the user enters is not an empty
    string (represented by two double quotes with nothing between them: `""`). The
    empty string is what Python sees as the input when the user presses ENTER to quit.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处询问用户的名字并将其存储在变量 `name` 中来开始程序。我们需要一个名字来测试 `while` 循环的条件，所以我们必须在循环开始之前*先*询问一次。然后，在
    ➋ 处，我们启动了 `while` 循环，它会一直运行，直到用户输入的名字不是空字符串（由两个双引号表示，中间没有任何内容：`""`）。空字符串是当用户按下
    ENTER 键以退出时 Python 所看到的输入。
- en: At ➌, we start our `for` loop, which will print the name 100 times, and at ➍,
    we tell the `print()` statement to print a space after the name each time. We’ll
    keep going back to ➌ and checking to see if `x` has reached 100, then printing
    at ➍ until the name fills a few lines of the screen. When our `for` loop has finished
    printing the name 100 times, we print a blank line without a space ➎, moving the
    printout down to the next clear line. Then, it’s time to ask for another name
    ➏.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们开始了 `for` 循环，它将打印名字 100 次，而在 ➍ 处，我们告诉 `print()` 语句每次打印名字后打印一个空格。我们会不断回到
    ➌ 检查 `x` 是否已经达到 100，然后在 ➍ 打印，直到名字填满几行屏幕。当我们的 `for` 循环完成打印名字 100 次后，我们打印一个空白行，且没有空格
    ➎，将输出移到下一行。然后，就该询问另一个名字了 ➏。
- en: Because ➏ is the last line indented under the `while` loop ➋, the new name that
    the user enters is passed back up to ➋ so the `while` loop can check whether it’s
    an empty string. If it’s not empty, our program will start the `for` loop to print
    the new name 100 times. If the name is an empty string, that means the user pressed
    ENTER to end the program, so the `while` loop at ➋ skips down to ➐, and we thank
    the user for playing. [Figure 4-5](ch04.html#my_sons_ran_sayournamesdotpy_and_put_in
    "Figure 4-5. My sons ran SayOurNames.py and put in the names of everyone in our
    family!") shows the output of the program when my sons ran it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ➏ 是最后一行缩进在 `while` 循环 ➋ 下，所以用户输入的新名字会被传回到 ➋，以便 `while` 循环可以检查它是否为空字符串。如果不是空的，我们的程序会启动
    `for` 循环，打印新名字 100 次。如果名字是空字符串，这意味着用户按下了 ENTER 键结束程序，那么 `while` 循环会跳到 ➐，我们会感谢用户的参与。[图
    4-5](ch04.html#my_sons_ran_sayournamesdotpy_and_put_in "图 4-5. 我的儿子们运行了 SayOurNames.py，并输入了我们全家的名字！")
    显示了当我的儿子们运行程序时的输出。
- en: '![My sons ran SayOurNames.py and put in the names of everyone in our family!](httpatomoreillycomsourcenostarchimages2188877.png.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![我的儿子们运行了*SayOurNames.py*并输入了我们全家每个人的姓名！](httpatomoreillycomsourcenostarchimages2188877.png.jpg)'
- en: Figure 4-5. My sons ran *SayOurNames.py* and put in the names of everyone in
    our family!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-5. 我的儿子们运行了*SayOurNames.py*并输入了我们全家每个人的姓名！
- en: The Family Spiral
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 家庭螺旋
- en: 'Now that we can ask for a list of names and print them to the screen, let’s
    combine the name printer loop with one of our programs from [Chapter 3](ch03.html
    "Chapter 3. Numbers and Variables: Python Does the Math"), in [SpiralMyName.py](ch03.html#spiralmynamedotpy
    "SpiralMyName.py"), to create a colorful spiral of our family’s or friends’ names.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以请求姓名列表并将其打印到屏幕上，让我们将姓名打印循环与我们在[第3章](ch03.html "第3章 数字和变量：Python进行数学运算")中的一个程序结合起来，在[SpiralMyName.py](ch03.html#spiralmynamedotpy
    "SpiralMyName.py")中创建一个家庭或朋友姓名的彩色螺旋。
- en: Our new, combined program will be different from the name repeater in *SayOurNames.py*
    in a few ways, but the most important difference is that we can’t just print each
    name one by one; to draw our spiral, we need to have all the names at once so
    that we can draw each name in sequence as we wind around our spiral.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的合并程序与*SayOurNames.py*中的名字重复器有一些不同，但最重要的区别是，我们不能仅仅一个一个地打印姓名；为了绘制我们的螺旋图形，我们需要一次性获取所有的姓名，以便在绘制螺旋时按顺序绘制每个姓名。
- en: 'In *SayOurNames.py*, we were able to ask for one name at a time, but for our
    graphical spiral name program, we’ll need to keep all of the names in a list,
    just as we do with our colors. Then, as we go around the loop, we can change the
    names and colors together at each corner of the spiral. To do this, we’ll set
    up an empty list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在*SayOurNames.py*中，我们能够一次请求一个姓名，但对于我们的图形螺旋姓名程序，我们需要将所有姓名保存在一个列表中，就像我们对待颜色一样。然后，在遍历循环时，我们可以在螺旋的每个角落同时改变姓名和颜色。为此，我们将设置一个空列表：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Whenever we’ve made a list of colors in our programs, we’ve known the color
    names that we wanted to use, like red, yellow, blue, and so on. In our family
    list, though, we have to wait until the user enters the names. We use an empty
    list—a pair of square brackets, `[]`—to let Python know that we’re going to use
    a list called `family` but that we don’t know what will be in the list until the
    program runs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在程序中创建颜色列表时，我们通常知道自己想使用的颜色名称，如红色、黄色、蓝色等等。然而，在我们的家庭名单中，我们必须等到用户输入姓名后才能知道具体内容。我们使用一个空列表——一对方括号`[]`——告诉Python我们将使用一个名为`family`的列表，但在程序运行之前我们并不知道这个列表中会有什么内容。
- en: Once we have an empty list, we can ask for names in a `while` loop like we did
    in *SayOurNames.py*, and we will append those names to the list. To [*append*](apd.html#gloss01_004)
    means to add items to the end of the list. In this program, the first name the
    user enters will be added to the empty list, the second name will be appended
    after the first, and so on. When the user has entered all the names they want
    in their spiral, they will press ENTER to tell the program that they’ve finished
    entering names. Then we’ll use a `for` loop to draw the names on the screen in
    a colorful spiral shape.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个空列表，我们可以像在*SayOurNames.py*中那样通过`while`循环请求姓名，并将这些姓名添加到列表中。[*append*](apd.html#gloss01_004)意味着将项添加到列表的末尾。在这个程序中，用户输入的第一个姓名将被添加到空列表中，第二个姓名将添加到第一个姓名之后，依此类推。当用户输入了他们想要的所有姓名后，他们会按下ENTER键告诉程序他们已经完成了姓名输入。然后，我们将使用`for`循环以彩色螺旋形状在屏幕上绘制这些姓名。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188879.png.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188879.png.jpg)'
- en: 'Type and run the following code to see a `while` loop and a `for` loop do some
    beautiful work together:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输入并运行以下代码，看看`while`循环和`for`循环如何一起完成一些美丽的工作：
- en: SpiralFamily.py
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SpiralFamily.py
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At ➊, we set up an empty list `[]` called `family` that will hold the names
    the user enters. At ➋, we ask for the first name in a `turtle.textinput` window
    and start the `while` loop to gather all the names in the family at ➌. The command
    to add a value to the end of a list is `append()`, shown at ➍. This takes the
    `name` the user entered and appends it to the list called `family`. We then ask
    for another name and keep repeating the `while` loop ➌ until the user presses
    ENTER to let us know they’re finished.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们设置了一个空列表`[]`，名为`family`，用于存储用户输入的姓名。在➋，我们通过`turtle.textinput`窗口请求第一个姓名，并在➌开始`while`循环收集所有的家庭成员姓名。将值添加到列表末尾的命令是`append()`，如在➍所示。该命令将用户输入的`name`添加到名为`family`的列表中。然后我们会请求另一个姓名，并继续重复`while`循环➌，直到用户按下ENTER键告诉我们他们已经完成输入。
- en: Our `for` loop starts out like previous spirals, but we use a new command at
    ➎ to set our pen color. The `len()` command is short for *length* and tells us
    the length of the list of names stored in `family`. For example, if you entered
    four names for your family, `len(family)` would return `4`. We use the modulo
    operator, `%`, with this value to rotate through four colors, one for each name
    in `family`. Larger families would rotate through more colors (up to the 10 colors
    in our list), while smaller families would need fewer colors.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`for`循环与之前的螺旋相似，但在➎位置使用了一个新命令来设置笔的颜色。`len()`命令是*长度*的缩写，它告诉我们`family`列表中名字的数量。例如，如果你输入了四个家庭成员的名字，`len(family)`将返回`4`。我们使用取模运算符`%`和这个值来循环选择四种颜色，每个名字一个颜色。较大的家庭会循环更多的颜色（最多使用我们列表中的10种颜色），而较小的家庭则只需要更少的颜色。
- en: At ➏, we use the `penup()` command to “lift” the turtle’s pen off the screen
    so that when we move forward at ➐, the turtle won’t draw anything; we’ll be drawing
    names at the corners of the spiral, with no lines in between. At ➑, we put the
    turtle’s pen down again so that our names will be drawn.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在➏位置，我们使用`penup()`命令“抬起”海龟的笔，以便在➐位置前进时，海龟不会绘制任何东西；我们将在螺旋的角落绘制名字，而角落之间不会有线条。在➑位置，我们再次将海龟的笔放下，以便绘制我们的名字。
- en: At ➒, we’re doing a lot. First, we tell the turtle which name to draw. Notice
    that `family[x%len(family)]` uses the modulo operator, `%`, to rotate through
    the names the user entered in the `family` list. The program will start with the
    first name entered, `family[0]`, and continue with `family[1]`, `family[2]`, and
    so on until it reaches the final name in the list. The `font =` portion of this
    statement tells the computer we want to use the Arial font, in bold style, for
    our names. It also sets the font size to grow as `x` grows; our font size of `(x+4)/4`
    means that when the loop finishes with `x = 100`, the font size will be (100 +
    4) / 4 = 26-point font—a nice size. You can make the fonts bigger or smaller by
    changing this equation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在➒位置，我们做了很多事情。首先，我们告诉海龟绘制哪个名字。请注意，`family[x%len(family)]`使用了取模运算符`%`，可以在用户输入的`family`列表中的名字之间进行循环。程序将从第一个输入的名字`family[0]`开始，然后依次是`family[1]`、`family[2]`，直到达到列表中的最后一个名字。这个语句中的`font
    =`部分告诉计算机我们想要使用Arial字体，并且采用粗体样式来绘制名字。它还设置了字体大小随着`x`的增长而增大；我们用`(x+4)/4`来计算字体大小，这意味着当循环结束时，`x
    = 100`，字体大小将是(100 + 4) / 4 = 26磅——一个不错的大小。你可以通过修改这个公式来调整字体的大小。
- en: Finally, at ➓, we turn the turtle left by `360/len(family)` degrees plus `2`.
    For a family with four members, we would turn 90 degrees plus 2 for a nice square
    spiral; a family of six would get 60-degree turns plus 2 for a six-sided spiral,
    and so on. The extra 2 degrees make the spiral spin to the left a bit for the
    swirl effect we’ve seen in our other spirals. In [Figure 4-6](ch04.html#payne_family_spiralcomma_including_our_t
    "Figure 4-6. The Payne family spiral, including our two cats, Leo and Rocky"),
    we ran this program and entered our family’s names, including our two cats, Leo
    and Rocky, to get a wonderful family spiral picture.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在➓位置，我们将海龟向左转`360/len(family)`度再加`2`度。对于一个有四个成员的家庭，我们会转90度再加2度，形成漂亮的正方形螺旋；六口之家的话，转60度再加2度，形成六边形螺旋，依此类推。额外的2度让螺旋稍微向左旋转，产生我们在其他螺旋中看到的漩涡效果。在[图4-6](ch04.html#payne_family_spiralcomma_including_our_t
    "图4-6。佩恩家庭螺旋，包括我们的两只猫，Leo和Rocky")中，我们运行了这个程序并输入了我们家庭的名字，包括我们的两只猫Leo和Rocky，得到了一幅精彩的家庭螺旋图。
- en: '![The Payne family spiral, including our two cats, Leo and Rocky](httpatomoreillycomsourcenostarchimages2188881.png.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![佩恩家庭螺旋，包括我们的两只猫Leo和Rocky](httpatomoreillycomsourcenostarchimages2188881.png.jpg)'
- en: Figure 4-6. The Payne family spiral, including our two cats, Leo and Rocky
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-6。佩恩家庭螺旋，包括我们的两只猫Leo和Rocky
- en: 'Putting It All Together: Spiral Goes Viral'
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 综合运用：螺旋走红
- en: 'We’ve seen the power of loops: they take pieces of code and repeat them over
    and over to do repetitive work that we wouldn’t want to do by hand, like typing
    a name 100 times. Let’s take loops one step further and build our own [*nested
    loop*](apd.html#gloss01_034), which is a loop inside another loop (like Russian
    nesting dolls—look inside one doll, and there’s another doll).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了循环的强大功能：它们将一段代码重复执行，以完成我们不想手动做的重复工作，比如打100次名字。让我们进一步深入了解循环，构建我们自己的[*嵌套循环*](apd.html#gloss01_034)，即一个循环内部再包含另一个循环（就像俄罗斯套娃——看一个娃娃，里面还有一个娃娃）。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188883.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![没有说明文字的图片](httpatomoreillycomsourcenostarchimages2188883.png.jpg)'
- en: To explore nested loops, let’s draw a spiral not of names or lines but *of spirals*!
    Instead of drawing a name at every corner of our spiral like we did in [Figure 4-6](ch04.html#payne_family_spiralcomma_including_our_t
    "Figure 4-6. The Payne family spiral, including our two cats, Leo and Rocky"),
    we could draw a smaller spiral. To accomplish that, we need a big loop to draw
    a big spiral on the screen and a little loop inside to draw small spirals around
    the big spiral.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索嵌套循环，让我们绘制一个不仅仅是名字或线条的螺旋，而是 *螺旋的螺旋*！我们可以在螺旋的每个角落画一个小螺旋，而不是像在 [图4-6](ch04.html#payne_family_spiralcomma_including_our_t
    "图4-6. Payne 家族螺旋，包括我们的两只猫，Leo 和 Rocky") 中那样画一个名字。为此，我们需要一个大循环来绘制大螺旋，同时在里面嵌套一个小循环来绘制围绕大螺旋的小螺旋。
- en: 'Before we write a program to do that, let’s learn how to nest a loop inside
    another loop. First, start a loop as usual. Then, inside that loop, press TAB
    once and start a second loop:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序之前，让我们先学习如何将一个循环嵌套到另一个循环中。首先，像往常一样启动一个循环。然后，在该循环内部，按一次 TAB 键并启动第二个循环：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first loop is called the *outer* loop, because it surrounds our nested loop.
    The nested loop is called the *inner* loop, because it sits inside the other loop.
    Notice that in our nested loop, any lines of code that are indented twice (so
    they’re inside the second loop) will be repeated 10 times for `y` and 10 times
    for `x`, or 100 times total.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环称为 *外部* 循环，因为它包围了我们的嵌套循环。嵌套循环称为 *内部* 循环，因为它位于另一个循环内部。注意，在我们的嵌套循环中，任何缩进了两次的代码行（也就是说，它们在第二个循环内）将会重复
    `y` 10 次，`x` 10 次，总共重复 100 次。
- en: Let’s start writing our program, *ViralSpiral.py*. We’ll write it step by step—the
    finished program is shown in [ViralSpiral.py](ch04.html#viralspiraldotpy "ViralSpiral.py").
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写程序 *ViralSpiral.py*。我们将一步步写—完成的程序可以在 [ViralSpiral.py](ch04.html#viralspiraldotpy
    "ViralSpiral.py") 中查看。
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first few lines of our program look like the other spirals we’ve programmed,
    except that we won’t be drawing lines for the big spiral. We plan to replace those
    with smaller spirals, so we have a `t.penup()` at ➊ to lift the turtle’s pen off
    the screen right from the beginning. We then set the background color to black.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的前几行看起来像我们编写的其他螺旋程序，不同之处在于我们不会为大螺旋绘制线条。我们计划用较小的螺旋代替这些线条，因此在 ➊ 我们使用了 `t.penup()`
    来一开始就把乌龟的笔抬离屏幕。然后我们将背景色设置为黑色。
- en: 'Keep typing: we’re not done! Next we’ll ask the user for the number of sides
    they want using `turtle.numinput()`, with a default of 4 if the user doesn’t choose
    something different, and we’ll restrict the range of allowable sides to between
    2 and 6.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 继续输入：我们还没完成！接下来，我们将使用 `turtle.numinput()` 提示用户输入他们想要的边数，默认值为 4，如果用户没有选择其他值，我们将限制允许的边数范围在
    2 到 6 之间。
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `turtle.numinput()` function allows us to specify a title for our input
    dialog; a prompt question; and default, minimum, and maximum values, in that order:
    `turtle.numinput(`*`title`*`,` *`prompt`*`,` *`default`*`,` *`minimum`*`,` *`maximum`*`)`.
    Here, we specify a default value of `4`, a minimum of `2`, and a maximum of `6`.
    (If the user tries to enter `1` or `7`, for example, they’ll get a warning that
    the minimum allowed value is `2` and the maximum allowed value is `6`.) We also
    set up our `colors` list with six colors.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`turtle.numinput()` 函数允许我们为输入对话框指定一个标题、一条提示问题，以及默认值、最小值和最大值，顺序如下：`turtle.numinput(`*`title`*`,`
    *`prompt`*`,` *`default`*`,` *`minimum`*`,` *`maximum`*`)`。在这里，我们指定了默认值 `4`，最小值
    `2` 和最大值 `6`。（例如，如果用户尝试输入 `1` 或 `7`，他们将收到警告，告知最小允许值是 `2`，最大允许值是 `6`。）我们还设置了六种颜色的
    `colors` 列表。'
- en: Next we’ll write our outer spiral loop. The outer loop will position the turtle
    at each corner of the big spiral.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将编写外部螺旋循环。外部循环将把乌龟定位到大螺旋的每个角落。
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our outer loop takes `m` from `0` to `99` for `100` total passes ➋. In our outer
    loop, we move forward just like in our other spiral programs, but when we reach
    each corner of our big spiral, we stop to remember our `position` ➌ and `heading`
    ➍. The *position* is the turtle’s (*x*, *y*) coordinate location on the screen,
    and the *heading* is the direction the turtle is moving in.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的外部循环将 `m` 从 `0` 循环到 `99`，总共循环 `100` 次 ➋。在外部循环中，我们像其他螺旋程序一样前进，但当我们到达大螺旋的每个角落时，我们会停下来记住我们的
    `position` ➌ 和 `heading` ➍。*position* 是乌龟在屏幕上的 (*x*, *y*) 坐标位置，*heading* 是乌龟正在移动的方向。
- en: Our turtle is taking a bit of a detour at every spot along the large spiral
    in order to draw the smaller spirals, so it must return to this position and heading
    after finishing each small spiral in order to maintain the shape of the big spiral.
    If we didn’t remember the location and direction of the turtle before starting
    to draw the small spirals, our turtle would wander all over the screen, starting
    each small spiral relative to where it left off with the last small spiral.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的海龟在大螺旋的每个位置上都会稍作偏离，去绘制小螺旋，因此在完成每个小螺旋后，它必须返回到该位置和朝向，以保持大螺旋的形状。如果我们在开始绘制小螺旋之前没有记住海龟的位置和方向，海龟就会在屏幕上乱窜，每个小螺旋都会从上一个小螺旋的位置出发，而不是按照大螺旋的形状。
- en: The two commands that will tell us the turtle’s location and direction are `t.position()`
    and `t.heading()`. The turtle’s position is accessed through `t.position()`, and
    it consists of both the *x* (horizontal) and *y* (vertical) coordinates of the
    turtle’s location on the screen, just like on a coordinate graph. The direction
    the turtle is heading is available through the command `t.heading()` and is measured
    from 0.0 degrees to 360.0 degrees, with 0.0 degrees pointing up toward the top
    of the screen. We will store these pieces of information in the variables `position`
    and `heading` before we start each small spiral so that we can pick up where we
    left off on the big spiral each time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我们海龟位置和方向的两个命令是 `t.position()` 和 `t.heading()`。海龟的位置通过 `t.position()` 访问，它包括海龟在屏幕上的
    *x*（水平）和 *y*（垂直）坐标，就像坐标图上的点一样。海龟的朝向通过命令 `t.heading()` 获取，方向的角度范围是从 0.0 度到 360.0
    度，0.0 度指向屏幕顶部。我们将在每次开始绘制小螺旋之前，将这些信息存储在变量 `position` 和 `heading` 中，以便每次都能在大螺旋中准确接着上次的地方绘制。
- en: It’s time for the inner loop. We’re indented even farther here. This inner loop
    will draw a small spiral at each corner of the bigger spiral.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是内循环的时间了。我们在这里的缩进更加深入。这个内循环将在大螺旋的每个角落绘制一个小螺旋。
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our inner loop ➎ begins with `n = 0` and stops when `n = m/2`, or one-half of
    `m`, to keep the inner spirals smaller than the outer spiral. The inner spirals
    look like our previous spirals, except that we put the pen down before drawing
    each line and lift it after each line is drawn so that our big spiral stays clean.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内循环 ➎ 从 `n = 0` 开始，在 `n = m/2` 时停止，即 `m` 的一半，以保持内螺旋比外螺旋小。内螺旋看起来与我们之前的螺旋相似，唯一的区别是我们在绘制每一条线之前放下笔，绘制完每条线后抬起笔，这样我们的外螺旋保持干净。
- en: After we draw our inner spiral from ➎, we pick back up at ➏ by setting the horizontal
    position of the turtle to the one we stored at ➌. The horizontal axis is commonly
    called the *x-axis*, so when we set the horizontal location, we use `t.setx()`,
    or set the x-axis position of our turtle’s location on the screen. At ➐, we set
    the y-axis location, or vertical position, that we stored at ➌. At ➑, we turn
    the turtle to the heading we stored at ➍ before going on to the next part of the
    big spiral at ➒.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从 ➎ 绘制内螺旋后，我们通过将海龟的水平位置设置为我们在 ➌ 存储的位置，继续执行到 ➏。水平轴通常称为 *x 轴*，所以当我们设置水平位置时，我们使用
    `t.setx()`，即设置海龟在屏幕上位置的 x 轴坐标。在 ➐，我们设置 y 轴位置，即在 ➌ 存储的垂直位置。在 ➑，我们将海龟转向我们在 ➍ 存储的朝向，然后继续进行大螺旋的下一个部分，直到
    ➒。
- en: When our big loop ends after `m` has gone from `0` to `99`, we will have drawn
    100 small spirals in a big spiral pattern for a nice kaleidoscope effect, as shown
    in [Figure 4-7](ch04.html#square_spiral_with_square_spirals_at_eve "Figure 4-7. A
    square spiral with square spirals at every corner (top) and a five-sided (pentagonal)
    spiral of spirals (bottom) from our ViralSpiral.py program").
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的外循环结束时，`m` 从 `0` 到 `99`，我们将完成 100 个小螺旋，按大螺旋模式排列，形成一个漂亮的万花筒效果，如 [图 4-7](ch04.html#square_spiral_with_square_spirals_at_eve
    "图 4-7。一个正方形螺旋图，顶部是每个角落都有正方形螺旋的图形，底部是一个五边形（五角形）螺旋图，由我们的 *ViralSpiral.py* 程序生成")
    所示。
- en: '![A square spiral with square spirals at every corner (top) and a five-sided
    (pentagonal) spiral of spirals (bottom) from our ViralSpiral.py program](httpatomoreillycomsourcenostarchimages2188885.png.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![一个正方形螺旋图，每个角落都有正方形螺旋（顶部），底部是一个五边形（五角形）螺旋图，由我们的 *ViralSpiral.py* 程序生成](httpatomoreillycomsourcenostarchimages2188885.png.jpg)'
- en: Figure 4-7. A square spiral with square spirals at every corner (top) and a
    five-sided (pentagonal) spiral of spirals (bottom) from our *ViralSpiral.py* program
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-7。一个正方形螺旋图，顶部是每个角落都有正方形螺旋的图形，底部是一个五边形（五角形）螺旋图，由我们的 *ViralSpiral.py* 程序生成
- en: 'You’ll notice the one drawback to nested loops while you’re waiting for this
    program to run: the shapes shown in [Figure 4-7](ch04.html#square_spiral_with_square_spirals_at_eve
    "Figure 4-7. A square spiral with square spirals at every corner (top) and a five-sided
    (pentagonal) spiral of spirals (bottom) from our ViralSpiral.py program") take
    longer to draw than our simple spirals did. That’s because we’re performing so
    many more steps than we did with our simple spirals. In fact, when we draw the
    six-sided version of our *ViralSpiral.py*, the final drawing consists of 2,352
    separate lines! All those drawing commands, plus the turning and setting the pen
    color, add up to a lot of work, even for a fast computer. Nested loops are useful,
    but remember that the extra steps can slow our programs down, so we use nested
    loops only when the effect is worth the wait.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在等待程序运行时，嵌套循环的一个缺点：如图[Figure 4-7](ch04.html#square_spiral_with_square_spirals_at_eve
    "Figure 4-7. A square spiral with square spirals at every corner (top) and a five-sided
    (pentagonal) spiral of spirals (bottom) from our ViralSpiral.py program")所示的形状绘制比我们简单的螺旋要花费更长的时间。这是因为我们执行的步骤比简单螺旋多得多。事实上，当我们绘制六边形版本的*ViralSpiral.py*时，最终的图形由2,352条独立的线条组成！所有这些绘图命令，加上转动和设置画笔颜色，都需要大量的工作，即使是快速的计算机也需要时间。嵌套循环非常有用，但要记住，额外的步骤会拖慢程序的速度，因此只有当效果值得等待时，我们才使用嵌套循环。
- en: Here’s the completed code for *ViralSpiral.py*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*ViralSpiral.py*的完整代码。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188887.png.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188887.png.jpg)'
- en: ViralSpiral.py
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ViralSpiral.py
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What You Learned
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到的内容
- en: In this chapter, you learned to build your own loops by identifying repeated
    steps in a program and moving those repeated steps inside the right kind of loop.
    With a `for` loop, you can run your code a set number of times, like looping 10
    times with `for x in range(10)`. With a `while` loop, you can run your code until
    a condition or event occurs, like the user entering nothing at an input prompt
    with `while name != ""`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了通过识别程序中的重复步骤，并将这些步骤放入正确类型的循环中，来构建自己的循环。通过`for`循环，你可以让代码执行一定次数，例如使用`for
    x in range(10)`循环10次。通过`while`循环，你可以在满足条件或发生事件时运行代码，例如在用户没有输入任何内容时使用`while name
    != ""`。
- en: You learned that the flow of a program is changed by the loops that you create.
    We used the `range()` function to generate lists of values that allow us to control
    the number of times our `for` loops repeat, and we used the modulo operator, `%`,
    to loop through the values in a list to change colors in a list of colors, pick
    names out of a list of names, and more.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你学到，通过你创建的循环可以改变程序的流程。我们使用`range()`函数生成数值列表，帮助我们控制`for`循环的重复次数，并使用模运算符`%`来遍历列表中的值，从而更改颜色列表中的颜色，选择名字列表中的名字，等等。
- en: We used an empty list, `[]`, and the `append()` function to add information
    from the user into a list that we then used in a program. You learned that the
    `len()` function can tell you the length of a list—that is, how many values the
    list contains.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个空列表`[]`和`append()`函数将用户输入的信息添加到列表中，然后在程序中使用这个列表。你学到`len()`函数可以告诉你列表的长度——也就是列表中包含多少个值。
- en: You learned how to remember the turtle’s current position and the direction
    it’s heading with the `t.position()` and `t.heading()` functions, and you learned
    how to get the turtle back to this location and heading with `t.setx()`, `t.sety()`,
    and `t.setheading()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何通过`t.position()`和`t.heading()`函数记住海龟的当前位置和方向，并学会了如何通过`t.setx()`、`t.sety()`和`t.setheading()`将海龟带回该位置和方向。
- en: Finally, you saw how you can use nested loops to repeat one set of instructions
    inside another set, first to print a list of names on a screen and then to create
    spirals of spirals in a kaleidoscope pattern. Along the way, we’ve drawn lines,
    circles, and strings of words or names on the screen.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你看到了如何使用嵌套循环在一个循环内部重复执行另一组指令，首先在屏幕上打印一组名字，然后在万花筒模式中创建螺旋状的螺旋图案。在这个过程中，我们在屏幕上画了线条、圆圈以及一串串的单词或名字。
- en: 'At this point, you should be able to do the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该能够完成以下任务：
- en: Create your own `for` loops to repeat a set of instructions a certain number
    of times.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的`for`循环，将一组指令重复执行指定的次数。
- en: Use the `range()` function to generate lists of values to control your `for`
    loops.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`range()`函数生成数值列表来控制你的`for`循环。
- en: Create empty lists and add to lists using the `append()` function.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`append()`函数创建空列表并向列表中添加元素。
- en: Create your own `while` loops to repeat while a condition is `True` or until
    the condition is `False`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的 `while` 循环，在条件为 `True` 时重复，或直到条件为 `False`。
- en: Explain how each type of loop works and how you code it in Python.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释每种类型的循环是如何工作的，以及如何在 Python 中编写它。
- en: Give examples of situations in which you would use each type of loop.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 举例说明每种类型的循环在什么情况下使用。
- en: Design and modify programs that use nested loops.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计并修改使用嵌套循环的程序。
- en: Programming Challenges
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Try these challenges to practice what you’ve learned in this chapter. (If you
    get stuck, go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    for sample answers.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些挑战，练习你在本章中学到的内容。（如果卡住了，可以访问 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    查找示例答案。）
- en: '**#1: SPIRAL ROSETTES**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1: 螺旋玫瑰**'
- en: 'Think about how you might modify the *ViralSpiral.py* program to replace the
    small spirals with rosettes like those in *Rosette6.py* ([Modifying Our for Loop
    to Make a Rosette with Six Circles](ch04.html#modifying_our_for_loop_to_make_a_rosette
    "Modifying Our for Loop to Make a Rosette with Six Circles")) and *RosetteGoneWild.py*
    ([RosetteGoneWild.py](ch04.html#rosettegonewilddotpy "RosetteGoneWild.py")). Hint:
    first replace the inner loop with an inner loop that will draw a rosette. Then,
    add the code to change the colors and sizes of the circles in each rosette. As
    an added touch, change the width of the pen slightly as your circles get bigger.
    When you finish, save the new program as *SpiralRosettes.py*. [Figure 4-8](ch04.html#spiral_of_rosettes_from_one_solution_to
    "Figure 4-8. A spiral of rosettes from one solution to Programming Challenge #1")
    shows a drawing produced by one solution to this challenge.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你如何修改 *ViralSpiral.py* 程序，将小螺旋替换为像 *Rosette6.py* 中的玫瑰花样（[修改我们的 for 循环来绘制带有六个圆的玫瑰花](ch04.html#modifying_our_for_loop_to_make_a_rosette
    "修改我们的 for 循环来绘制带有六个圆的玫瑰花")）和 *RosetteGoneWild.py*（[RosetteGoneWild.py](ch04.html#rosettegonewilddotpy
    "RosetteGoneWild.py")）。提示：首先用一个内循环替换内层循环，这个内循环将绘制一个玫瑰。然后，添加代码来改变每个玫瑰中圆的颜色和大小。为了增添趣味，当圆变大时，稍微调整画笔的宽度。当完成时，将新程序保存为
    *SpiralRosettes.py*。[图 4-8](ch04.html#spiral_of_rosettes_from_one_solution_to
    "图 4-8。来自一个解决方案的螺旋玫瑰") 显示了一个解决方案绘制的图形。
- en: '![A spiral of rosettes from one solution to Programming Challenge #1](httpatomoreillycomsourcenostarchimages2188889.png.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![来自一个解决方案的螺旋玫瑰，解答编程挑战 #1](httpatomoreillycomsourcenostarchimages2188889.png.jpg)'
- en: 'Figure 4-8. A spiral of rosettes from one solution to Programming Challenge
    #1'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4-8。来自一个解决方案的螺旋玫瑰，解答编程挑战 #1'
- en: '**#2: A SPIRAL OF FAMILY SPIRALS**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**#2: 一螺旋中的多个家庭螺旋**'
- en: Wouldn’t it be cool to draw a spiral of spirals of your family’s names? Take
    a look at *SpiralFamily.py* ([SpiralFamily.py](ch04.html#spiralfamilydotpy "SpiralFamily.py"))
    and then refer back to the code for *ViralSpiral.py*. Create an inner loop inside
    the `for` loop in *SpiralFamily.py* that draws the smaller spiral. Then, modify
    your outer loop to remember the position and heading of the turtle before drawing
    each small spiral, and set it back before continuing to the next big spiral location.
    When you get it right, save the new program as *ViralFamilySpiral.py*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个你家人名字的螺旋螺旋图形，岂不是很酷？看看 *SpiralFamily.py*（[SpiralFamily.py](ch04.html#spiralfamilydotpy
    "SpiralFamily.py")），然后参考 *ViralSpiral.py* 的代码。在 *SpiralFamily.py* 中的 `for` 循环内创建一个内循环，用于绘制较小的螺旋。然后，修改外循环，在绘制每个小螺旋之前记住海龟的位置和朝向，并在继续到下一个大螺旋位置之前恢复它。当你完成后，将新程序保存为
    *ViralFamilySpiral.py*。
