- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SECURITY
    ACCESS TOKENS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">安全访问令牌</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: The *security access token*, or *token* for short, is at the heart of Windows
    security. The SRM uses tokens to represent identities, such as user accounts,
    and then grants or denies them access to resources. Windows represents tokens
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> kernel objects,
    which contain, at a minimum, the specific identity they represent, any security
    groups the identity belongs to, and the special privileges the identity has been
    granted.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全访问令牌*，简称*令牌*，是 Windows 安全性的核心。SRM 使用令牌来表示身份，如用户帐户，并授予或拒绝其对资源的访问。Windows
    使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>内核对象来表示令牌，这些对象至少包含它们所代表的特定身份、该身份所属的任何安全组以及该身份已被授予的特殊权限。'
- en: 'Like other kernel objects, tokens support <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> information system
    calls, which allow the user to inspect the properties of a token and set certain
    properties. Though less commonly used, some Win32 APIs also expose these <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    system calls: for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTokenInformation</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetTokenInformation</samp>.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他内核对象一样，令牌支持<samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Set</samp>信息系统调用，这允许用户检查令牌的属性并设置某些属性。尽管不常使用，一些
    Win32 API 也公开了这些<samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>系统调用：例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">GetTokenInformation</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetTokenInformation</samp>。
- en: 'Let’s start with an overview of the two main types of tokens you’ll encounter
    when analyzing a Windows system’s security: primary and impersonation tokens.
    We’ll then detail many of the important properties a token contains. You’ll need
    to understand these before we can discuss access checking in [Chapter 7](chapter7.xhtml).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从概述开始，了解在分析 Windows 系统安全性时会遇到的两种主要令牌类型：主令牌和模拟令牌。接下来，我们将详细介绍令牌包含的许多重要属性。在我们讨论[第7章](chapter7.xhtml)的访问检查之前，你需要理解这些属性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Primary Tokens</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">主令牌</samp>
- en: Every process has an assigned token that describes its identity for any resource
    access operation. When the SRM performs an access check, it will query the process’s
    token and use it to determine what kind of access to grant. When a token is used
    for a process, it’s called a *primary token*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个分配的令牌，用于描述其在任何资源访问操作中的身份。当 SRM 执行访问检查时，它会查询进程的令牌，并使用该令牌来确定授予何种访问权限。当令牌用于进程时，它被称为*主令牌*。
- en: You can open a process’s token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcessToken</samp>
    system call, which will return a handle that you can use to query token information.
    Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
    is a securable resource, the caller needs to pass an access check to get the handle.
    Note that you also need a handle to the process with <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>
    access to be able to query the token.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcessToken</samp>系统调用打开一个进程的令牌，该调用将返回一个句柄，你可以使用它查询令牌信息。由于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象是一个可安全访问的资源，因此调用者需要通过访问检查才能获取该句柄。请注意，你还需要拥有对进程的句柄，并且需要<samp
    class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>访问权限，才能查询该令牌。
- en: 'When opening a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object,
    you can request the following access rights:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 打开<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象时，你可以请求以下访问权限：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AssignPrimary  </samp>Assigns the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object as a primary
    token
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AssignPrimary  </samp>将<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象分配为主令牌
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Duplicate  </samp>Duplicates the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Duplicate  </samp>复制<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Impersonate</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Impersonates
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Impersonate</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>模拟<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Query  </samp>Queries the properties
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object, such
    as its groups and privileges
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Query  </samp>查询<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象的属性，如其组和权限
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">QuerySource  </samp>Queries the
    source of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">QuerySource  </samp>查询<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象的来源
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustPrivileges  </samp>Adjusts
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s privilege
    list
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustPrivileges  </samp>调整一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象的权限列表
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustGroups  </samp>Adjusts a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s group list
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustGroups  </samp>调整一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象的组列表
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustDefault</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Adjusts
    properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
    not covered by the other access rights
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustDefault</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>调整一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象中其他访问权限未涵盖的属性
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustSessionId  </samp>Adjusts
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s session
    ID
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustSessionId  </samp>调整<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象的会话ID
- en: You can see a list of accessible processes and their tokens by running the PowerShell
    command <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtToken -All</samp>.
    This should open the Token Viewer application, as shown in [Figure 4-1](chapter4.xhtml#fig4-1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行PowerShell命令<samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtToken
    -All</samp>查看可访问的进程及其令牌。这样应该会打开Token Viewer应用程序，如[图4-1](chapter4.xhtml#fig4-1)所示。
- en: '![](../images/Figure4-1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The Token Viewer
    lists all accessible processes and their tokens.</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-1：Token Viewer列出了所有可访问的进程及其令牌。</samp>
- en: The list view provides only a simple overview of the available tokens. If you
    want to see more information, double-click one of the process entries to bring
    up a detailed view of the token, as shown in [Figure 4-2](chapter4.xhtml#fig4-2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表视图只提供可用令牌的简单概览。如果你想查看更多信息，双击其中一个进程条目，会弹出一个详细的令牌视图，如[图4-2](chapter4.xhtml#fig4-2)所示。
- en: '![](../images/Figure4-2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The detailed view
    for a process’s Token object</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-2：进程的Token对象的详细视图</samp>
- en: Let’s highlight a few important pieces of information in this view. At the top
    are the user’s name and SID. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object stores only the SID, but the token view will display the name if it’s available.
    The next field indicates the token’s type. As we’re inspecting a primary token,
    the type is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Primary</samp>.
    The impersonation level (below this) is used only for impersonation tokens, which
    we’ll discuss in the next section. It’s not needed for primary tokens, so it’s
    set to N/A.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这个视图中突出一些重要信息。顶部是用户的名称和SID。<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象只存储SID，但如果有的话，令牌视图会显示名称。下一个字段表示令牌的类型。由于我们正在检查的是主令牌，类型设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Primary</samp>。（此下方）模拟级别仅用于模拟令牌，我们将在下一个章节讨论它。对于主令牌来说并不需要，因此它被设置为N/A。
- en: 'In the middle of the dialog is a list of four 64-bit integer identifiers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话框的中间是四个64位整数标识符的列表：
- en: '**Token ID    **A unique value assigned when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object was created'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**令牌ID    **在创建<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象时分配的唯一值'
- en: '**Authentication ID    **A value that indicates the logon session the token
    belongs to'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证ID    **表示令牌所属的登录会话的值'
- en: '**Origin Login ID    **The authentication identifier of the parent logon session'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**源登录 ID    **父登录会话的身份验证标识符'
- en: '**Modified ID    **A unique value that is updated when certain token values
    are modified'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改 ID    **当某些令牌值被修改时，会更新的唯一值'
- en: LSASS creates a *logon session* when a user authenticates to a Windows machine.
    The logon session tracks authentication-related resources for a user; for example,
    it stores a copy of the user’s credentials so that they can be reused. During
    the logon session creation process, the SRM generates a unique authentication
    identifier value that can be used to reference the session. Therefore, for a given
    logon session, all user tokens will have the same authentication identifier. If
    a user authenticates twice to the same machine, the SRM will generate different
    authentication identifiers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在 Windows 机器上进行身份验证时，LSASS 会创建一个*登录会话*。登录会话跟踪与身份验证相关的用户资源；例如，它会存储用户凭据的副本，以便以后可以重用。在登录会话创建过程中，SRM
    会生成一个唯一的身份验证标识符值，用于引用该会话。因此，对于给定的登录会话，所有用户令牌将具有相同的身份验证标识符。如果用户在同一台机器上进行两次身份验证，SRM
    将生成不同的身份验证标识符。
- en: The origin login identifier indicates who created the token’s logon session.
    If you authenticate a different user on your desktop (by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp>
    API with a username and password, for example), then the origin login identifier
    will serve as the calling token’s authentication identifier. Notice that this
    field in [Figure 4-2](chapter4.xhtml#fig4-2) shows the value <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E7</samp>.
    This is one of four fixed authentication identifiers defined by the SRM, in this
    case indicating the *SYSTEM* logon session. [Table 4-1](chapter4.xhtml#tab4-1)
    shows the four fixed values, along with the SIDs for the user accounts associated
    with the sessions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 起源登录标识符指示了谁创建了令牌的登录会话。如果你在桌面上验证了另一个用户（例如，通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp>
    API并提供用户名和密码），则起源登录标识符将作为调用令牌的身份验证标识符。请注意，在[图 4-2](chapter4.xhtml#fig4-2)中，这个字段显示的值是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E7</samp>。这是 SRM 定义的四个固定身份验证标识符之一，在这种情况下表示*SYSTEM*登录会话。[表
    4-1](chapter4.xhtml#tab4-1)展示了这四个固定值，以及与会话相关联的用户帐户的 SID。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Authentication
    Identifiers and User SIDs for Fixed Logon Sessions</samp>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-1：</samp> <samp class="SANS_Futura_Std_Book_11">固定登录会话的身份验证标识符和用户
    SID</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Authentication identifier</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">User SID</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Logon
    session username</samp> |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">身份验证标识符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">用户
    SID</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">登录会话用户名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E4</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\NETWORK SERVICE</samp> |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E4</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\NETWORK SERVICE</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E5</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-19</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\LOCAL SERVICE</samp> |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E5</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-19</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\LOCAL SERVICE</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E6</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-7</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\ANONYMOUS LOGON</samp> |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E6</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-7</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\ANONYMOUS LOGON</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E7</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-18</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\SYSTEM</samp> |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E7</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-18</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\SYSTEM</samp> |'
- en: After the identifiers in the detail view is a field indicating the *integrity
    level* of the token. Windows Vista first added the integrity level to implement
    a simple *mandatory access control* mechanism, whereby system-wide policies enforce
    access to resources, rather than allowing an individual resource to specify its
    access. We’ll discuss integrity levels in “Token Groups” on page 109.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细视图中的标识符后面，是一个字段，指示令牌的*完整性级别*。Windows Vista首次添加了完整性级别，以实现简单的*强制访问控制*机制，通过该机制，系统范围的策略强制访问资源，而不是允许单个资源指定其访问权限。我们将在第109页的“令牌组”中讨论完整性级别。
- en: This is followed by the session ID, a number assigned to the console session
    the process is attached to. Even though the console session is a property of the
    process, the value is specified in the process’s token.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是会话 ID，这是分配给进程所附加的控制台会话的数字。尽管控制台会话是进程的一个属性，但该值在进程的令牌中指定。
- en: 'The Token Viewer GUI is great if you want to manually inspect a token’s information.
    For programmatic access, you can open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object in PowerShell using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command. Use the following to get the current process’s token:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Token Viewer GUI非常适合你手动检查令牌的信息。对于编程访问，你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>命令在PowerShell中打开一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象。使用以下命令获取当前进程的令牌：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want to open the token for a specific process, you can use this command,
    replacing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><PID></samp>
    with the process ID of the target process:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为特定进程打开令牌，可以使用此命令，将<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><PID></samp>替换为目标进程的进程
    ID：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
    whose properties you can query. For example, you can display the token’s user,
    as shown in [Listing 4-1](chapter4.xhtml#Lis4-1).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>命令的结果是一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象，你可以查询其属性。例如，你可以显示令牌的用户，如[清单
    4-1](chapter4.xhtml#Lis4-1)所示。
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-1: Displaying the user via a Token object’s properties'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-1：通过令牌对象的属性显示用户
- en: Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</samp>
    command to output basic information to the console, as shown in [Listing 4-2](chapter4.xhtml#Lis4-2).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</samp>命令将基本信息输出到控制台，如[清单
    4-2](chapter4.xhtml#Lis4-2)所示。
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 4-2: Displaying properties of a token using Format-NtToken'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-2：使用Format-NtToken显示令牌的属性
- en: You can pass the opened <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object to <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtToken</samp> to
    display the same GUI shown in [Figure 4-2](chapter4.xhtml#fig4-2).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将打开的<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Show-NtToken</samp>，以显示与[图 4-2](chapter4.xhtml#fig4-2)中相同的
    GUI。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Impersonation Tokens</samp>
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11"> impersonation tokens </samp>
- en: The other type of token you’ll encounter is the *impersonation token*. Impersonation
    tokens are most important for system services, as they allow a process with one
    identity to temporarily impersonate another identity for the purposes of an access
    check. For example, a service might need to open a file belonging to another user
    while performing some operation. By allowing that service to impersonate the calling
    user, the system grants it access to the file, even if the service couldn’t open
    the file directly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到的另一种令牌是*模拟令牌*。模拟令牌对于系统服务非常重要，因为它们允许具有某个身份的进程暂时模拟另一个身份以进行访问检查。例如，一个服务可能需要在执行某个操作时打开属于其他用户的文件。通过允许该服务模拟调用用户，系统即使该服务无法直接打开文件，也会授予它访问权限。
- en: 'Impersonation tokens are assigned to threads, not processes. This means that
    only the code running in that thread will take on the impersonated identity. There
    are three ways an impersonation token can be assigned to a thread:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: impersonation 令牌分配给线程，而不是进程。这意味着只有在该线程中运行的代码才会采用模拟身份。模拟令牌可以通过三种方式分配给线程：
- en: By explicitly granting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp> access
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetThreadToken</samp> access
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过显式授予 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象 <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp>
    访问权限和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> 对象 <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadToken</samp>
    访问权限
- en: By explicitly granting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp>
    object <samp class="SANS_TheSansMonoCd_W5Regular_11">DirectImpersonation</samp>
    access
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过显式授予 <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> 对象 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DirectImpersonation</samp> 访问权限
- en: Implicitly, by impersonating an RPC request
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式地，通过冒充 RPC 请求
- en: You’re most likely to encounter implicit token assignment, as it’s the most
    common case for system services, which expose RPC mechanisms. For example, if
    a service creates a named pipe server, it can impersonate clients that connect
    to the pipe using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateNamedPipe</samp>
    API. When a call is made on the named pipe, the kernel captures an *impersonation
    context* based on the calling thread and process. This impersonation context is
    used to assign an impersonation token to the thread that calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateNamedPipe</samp>*.*
    The impersonation context can be based on either an existing impersonation token
    on the thread or a copy of the process’s primary token.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你最有可能遇到隐式令牌分配，因为这是系统服务的最常见情况，系统服务通常暴露 RPC 机制。例如，如果服务创建了一个命名管道服务器，它可以使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateNamedPipe</samp> API 冒充连接到管道的客户端。当在命名管道上进行调用时，内核会基于调用线程和进程捕获一个
    *冒充上下文*。这个冒充上下文用于将冒充令牌分配给调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateNamedPipe</samp>
    的线程。冒充上下文可以基于线程上现有的冒充令牌，也可以基于进程的主令牌的副本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Quality
    of Service</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安全服务质量</samp>
- en: 'What if you don’t want to give the service the ability to impersonate your
    identity? The SRM supports a feature called *Security Quality of Service (SQoS)*
    that enables you to control this. When you open a named pipe using the filesystem
    APIs, you can pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_QUALITY_OF_SERVICE</samp>
    structure in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityQualityOfService</samp>
    field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>
    structure. The SQoS structure contains three configuration values: the impersonation
    level, the context tracking mode, and the effective token mode.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望服务具备冒充你身份的能力，SRM 支持一个叫做 *安全服务质量（SQoS）* 的功能，允许你控制这一点。当你通过文件系统 API 打开命名管道时，你可以在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> 结构的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SecurityQualityOfService</samp> 字段中传递一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_QUALITY_OF_SERVICE</samp>
    结构。SQoS 结构包含三个配置值：冒充级别、上下文跟踪模式和有效令牌模式。
- en: 'The *impersonation level* in the SQoS is the most important field for controlling
    what a service can do with your identity. It defines the level of access granted
    to the service when it implicitly impersonates the caller. The level can be one
    of four values, in ascending order of privilege:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SQoS 中的 *冒充级别* 是控制服务使用你身份的能力的最重要字段。它定义了在服务隐式冒充调用者时授予该服务的访问级别。级别可以是四个值之一，按特权的升序排列：
- en: 1.  **Anonymous:** Prevents the service from opening the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object and querying the user’s identity. This is the lowest level; only a limited
    set of services would function if the caller specified this level.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  **匿名：** 阻止服务打开 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象并查询用户的身份。这是最低级别；如果调用方指定此级别，只有有限的一组服务可以正常工作。
- en: 2.  **Identification:** Allows the service to open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object and query the user’s identity, groups, and privileges. However, the thread
    cannot open any secured resources while impersonating the user.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  **身份识别：** 允许服务打开 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象并查询用户的身份、组和权限。然而，在冒充用户时，线程不能打开任何受保护的资源。
- en: 3.  **Impersonation:** Allows the service to fully exercise the user’s identity
    on the local system. The service can open local resources secured by the user
    and manipulate them. It can also access remote resources for the user if the user
    has locally authenticated to the system. However, if the user authenticated over
    a network connection, such as via the Server Message Block (SMB) protocol, then
    the service can’t use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object to access remote resources.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 3. **模拟：** 允许服务在本地系统上完全行使用户的身份。服务可以打开用户保护的本地资源并对其进行操作。如果用户已经在本地系统上通过身份验证，服务还可以代表用户访问远程资源。然而，如果用户是通过网络连接进行身份验证的，例如通过服务器消息块（SMB）协议，那么服务无法使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象来访问远程资源。
- en: 4.  **Delegation:** Enables the service to open all local and remote resources
    as if they were the user. This is the highest level. To access a remote resource
    from network-authenticated users, however, it’s not enough to have this impersonation
    level. The Windows domain must also be configured to allow it. We’ll discuss this
    impersonation level more in [Chapter 14](chapter14.xhtml), on Kerberos authentication.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 4. **委托：** 允许服务像用户一样打开所有本地和远程资源。这是最高级别。然而，要从网络身份验证的用户访问远程资源，单靠此模拟级别是不够的。Windows
    域还必须配置为允许此操作。我们将在[第14章](chapter14.xhtml)中讨论这个模拟级别，涉及Kerberos身份验证。
- en: You can specify the impersonation level in the SQoS either when calling a service
    or when creating a copy of an existing token. To restrict what a service can do,
    specify the Identification or Anonymous level. This will prevent the service from
    accessing any resources, although at the Identification level the service will
    still be able to access the token and perform operations on the caller’s behalf.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在调用服务时或创建现有令牌的副本时，在SQoS中指定模拟级别。为了限制服务的操作权限，可以指定标识或匿名级别。这样可以防止服务访问任何资源，尽管在标识级别下，服务仍然能够访问令牌并代表调用者执行操作。
- en: Let’s run a test using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-NtToken</samp>
    PowerShell command. In [Listing 4-3](chapter4.xhtml#Lis4-3), we impersonate a
    token at two different levels and attempt to execute a script that opens a secured
    resource. We specify the impersonation level using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonationLevel</samp>
    property.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-NtToken</samp> PowerShell命令进行测试。在[示例
    4-3](chapter4.xhtml#Lis4-3)中，我们模拟了两个不同级别的令牌，并尝试执行一个打开受保护资源的脚本。我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonationLevel</samp>属性来指定模拟级别。
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-3: Impersonating a token at different levels and opening a secured
    resource'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-3：在不同级别上模拟令牌并打开受保护资源
- en: The first command we execute gets a handle to the current process’s primary
    token. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-NtToken</samp>
    to impersonate the token at the Impersonation level and run a script that calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectory</samp> to open the
    root OMNS directory. The open operation succeeds, and we print the directory object
    to the console.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行的第一个命令获取当前进程的主令牌句柄。然后我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-NtToken</samp>以模拟令牌在模拟级别，并运行一个调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectory</samp>的脚本来打开根OMNS目录。打开操作成功，我们将目录对象打印到控制台。
- en: We then attempt to repeat the operation at the Identification level, but this
    time we receive a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BAD_IMPERSONATION_LEVEL</samp>
    error. (If you see this error when developing an application or using the system,
    now you’ll know the reason for it!) Note that the open operation doesn’t return
    an “access denied” error, because the SRM doesn’t get far enough to check whether
    the impersonated user can access the resource.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们尝试在标识级别重复该操作，但这次我们收到一个<samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BAD_IMPERSONATION_LEVEL</samp>错误。（如果你在开发应用程序或使用系统时看到此错误，现在你就知道原因了！）请注意，打开操作不会返回“访问被拒绝”错误，因为SRM没有足够的权限去检查模拟用户是否可以访问该资源。
- en: The other two fields in the SQoS are used less frequently, but they’re still
    important. The *context tracking mode* determines whether to statically capture
    the user’s identity when a connection is made to the service. If the identity
    is not statically captured and the caller then impersonates another user before
    calling the service, the new impersonated identity will become available to the
    service, not to the process identity. Note that the impersonated identity can
    be passed to the service only if it’s at the Impersonation or Delegation level.
    If the impersonated token is at the Identification or Anonymous level, the SRM
    generates a security error and rejects the impersonation operation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: SQoS中的另两个字段使用得较少，但仍然很重要。*上下文跟踪模式*决定了在连接到服务时是否静态捕获用户的身份。如果身份没有静态捕获，而调用者在调用服务之前模拟了另一个用户，则新的模拟身份将传递给服务，而不是进程身份。请注意，只有当模拟令牌处于模拟级别或委托级别时，模拟身份才能传递给服务。如果模拟令牌处于身份验证级别或匿名级别，SRM会生成安全错误并拒绝模拟操作。
- en: '*Effective token mode* changes the token passed to the server in a different
    way. It’s possible to disable groups and privileges before making a call, and
    if effective token mode is disabled, the server can reenable those groups and
    privileges and use them. However, if effective token mode is enabled, the SRM
    will strip out the groups and privileges so that the server can’t reenable them
    or use them.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*有效令牌模式*以不同的方式更改传递给服务器的令牌。可以在调用之前禁用组和权限，如果禁用了有效令牌模式，服务器可以重新启用这些组和权限并使用它们。然而，如果启用了有效令牌模式，SRM将剥离这些组和权限，以便服务器不能重新启用它们或使用它们。'
- en: By default, if no SQoS structure is specified when opening the interprocess
    communication (IPC) channel, the caller’s level is Impersonation with static tracking
    and a noneffective token. If an impersonation context is captured and the caller
    is already impersonating, then the impersonation level of the thread token must
    be greater than or equal to the Impersonation level; otherwise, the capture will
    fail. This is enforced even if the SQoS requests the Identification level. This
    is an important security feature; it prevents a caller at the Identification level
    or below from calling over an RPC channel and pretending to be another user.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果在打开进程间通信（IPC）通道时没有指定SQoS结构，调用者的级别为模拟级别，并且具有静态跟踪和无效令牌。如果捕获了模拟上下文并且调用者已经在模拟中，则线程令牌的模拟级别必须大于或等于模拟级别；否则，捕获将失败。即使SQoS请求的是身份验证级别，这一点也会被强制执行。这是一个重要的安全特性；它防止处于身份验证级别或以下的调用者通过RPC通道调用并冒充另一个用户。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I’ve described how SQoS is specified at the native system call level, as the
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SECURITY _QUALITY_OF_SERVICE</samp>
    structure is not exposed through the Win32 APIs directly. Instead, it’s usually
    specified using additional flags; for example, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CreateFile</samp>
    exposes SQoS by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SECURITY_SQOS_PRESENT</samp>
    flag.*'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我已经描述了如何在本地系统调用级别指定SQoS，因为< samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SECURITY
    _QUALITY_OF_SERVICE</samp>结构没有通过Win32 API直接暴露。相反，它通常通过额外的标志指定；例如，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CreateFile</samp>通过指定<
    samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SECURITY_SQOS_PRESENT</samp>标志来暴露SQoS。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Explicit Token Impersonation</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">显式令牌模拟</samp>
- en: There are two ways to impersonate a token explicitly. If you have an impersonation
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object handle with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp> access, you can
    assign it to a thread using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp>
    system call and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadImpersonationToken</samp>
    information class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显式模拟令牌有两种方式。如果你有一个带有< samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp>访问权限的模拟<
    samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象句柄，你可以使用< samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp>系统调用和<
    samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadImpersonationToken</samp>信息类将其分配给线程。
- en: If instead you have a thread you want to impersonate with <samp class="SANS_TheSansMonoCd_W5Regular_11">Direct
    Impersonation</samp> access, you can use the other mechanism. With the handle
    to a source thread, you can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtImpersonateThread</samp>
    system call and assign an impersonation token to another thread. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtImpersonateThread</samp>
    is a mix between explicit and implicit impersonation. The kernel will capture
    an impersonation context as if the source thread has called over a named pipe.
    You can even specify the SQoS structure to the system call.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用<samp class="SANS_TheSansMonoCd_W5Regular_11">直接假冒</samp>访问来假冒一个线程，可以使用另一种机制。通过源线程的句柄，你可以调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtImpersonateThread</samp>系统调用，并将假冒令牌分配给另一个线程。使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtImpersonateThread</samp>是显式和隐式假冒的结合。内核将捕获一个假冒上下文，仿佛源线程通过命名管道进行了调用。你甚至可以为系统调用指定SQoS结构。
- en: You might be thinking that impersonation opens a giant security backdoor. If
    I set up my own named pipe and convince a privileged process to connect to me,
    and the caller doesn’t set SQoS to limit access, can’t I gain elevated privileges?
    We’ll come back to how this is prevented in “Token Assignment” on page 133.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，假冒操作会打开一个巨大的安全后门。如果我设置了自己的命名管道，并说服一个特权进程连接到我，而调用者没有设置SQoS来限制访问，那我不是可以获得提升的权限吗？我们将在第133页的“令牌分配”部分回到如何防止这种情况。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Converting Between Token Types</samp>
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">令牌类型之间的转换</samp>
- en: You can convert between the two token types using duplication. When you duplicate
    a token, the kernel creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object and makes a deep copy of all the object’s properties. While the token is
    duplicating, you can change its type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用复制在两种令牌类型之间进行转换。当你复制一个令牌时，内核会创建一个新的<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象，并对该对象的所有属性进行深度复制。在令牌复制时，你可以改变它的类型。
- en: This duplication operation differs from the handle duplication we discussed
    in [Chapter 3](chapter3.xhtml), as duplicating a handle to a token would merely
    create a new handle pointing to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object. To duplicate the actual <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object, you need to have <samp class="SANS_TheSansMonoCd_W5Regular_11">Duplicate</samp>
    access rights on the handle.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复制操作与我们在[第3章](chapter3.xhtml)中讨论的句柄复制不同，因为复制一个令牌的句柄只是创建一个新的句柄，指向相同的<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象。要复制实际的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象，你需要拥有句柄上的<samp class="SANS_TheSansMonoCd_W5Regular_11">Duplicate</samp>访问权限。
- en: You can then use either the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateToken</samp>
    system call or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy -NtToken</samp>
    PowerShell command to duplicate the token. For example, to create an impersonation
    token at the Delegation level based on an existing token, use the script in [Listing
    4-4](chapter4.xhtml#Lis4-4).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateToken</samp>系统调用或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy -NtToken</samp>PowerShell命令来复制令牌。例如，要基于现有令牌创建一个在委托级别的假冒令牌，可以使用[列表
    4-4](chapter4.xhtml#Lis4-4)中的脚本。
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-4: Duplicating a token to create an impersonation token'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：复制令牌以创建假冒令牌
- en: You can convert the impersonation token back to a primary token by using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtToken</samp> again, as shown in
    [Listing 4-5](chapter4.xhtml#Lis4-5).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过再次使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtToken</samp>将假冒令牌转换回主令牌，如[列表
    4-5](chapter4.xhtml#Lis4-5)所示。
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-5: Converting an impersonation token to a primary token'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-5：将假冒令牌转换为主令牌
- en: 'Note something interesting in the output: the new primary token has the same
    impersonation level as the original token. This is because the SRM considers only
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenType</samp> property; if
    the token is a primary token, the impersonation level is ignored.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中的一个有趣之处：新的主令牌与原始令牌具有相同的假冒级别。这是因为SRM只考虑<samp class="SANS_TheSansMonoCd_W5Regular_11">TokenType</samp>属性；如果令牌是主令牌，假冒级别将被忽略。
- en: 'Seeing as we can convert an impersonation token back to a primary token, you
    might be wondering: Could we convert an Identification-level or Anonymous-level
    token back to a primary token, create a new process, and bypass the SQoS settings?
    Let’s try it in [Listing 4-6](chapter4.xhtml#Lis4-6).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们可以将模拟令牌转换回主令牌，你可能会想：我们能否将识别级别或匿名级别的令牌转换回主令牌，创建一个新进程，并绕过SQoS设置？我们在[列表 4-6](chapter4.xhtml#Lis4-6)中试试。
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-6: Duplicating an Identification-level token back to a primary token'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-6：将识别级别令牌复制回主令牌
- en: This listing shows that we can’t duplicate an Identification-level token back
    to a primary token. The second line causes an exception, because the operation
    would break a security guarantee of the SRM (specifically, that the SQoS allows
    the caller to control how its identity is used).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表显示我们不能将识别级别的令牌复制回主令牌。第二行会引发异常，因为此操作会破坏SRM的安全保证（具体来说，SQoS允许调用方控制其身份的使用方式）。
- en: 'A final note: if you’re opening a token using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>,
    you can perform the duplication operation in one step by specifying the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Duplicate</samp> parameter.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要注意的是：如果你使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>打开令牌，可以通过指定<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Duplicate</samp>参数一步完成复制操作。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pseudo Token Handles</samp>
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">伪令牌句柄</samp>
- en: 'To access a token, you must open a handle to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object, then remember to close the handle after use. Windows 10 introduced three
    *pseudo handles* that allow you to query token information without opening a full
    handle to a kernel object. Here are those three handles, with their handle values
    in parentheses:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问令牌，必须首先打开一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象的句柄，使用完后记得关闭句柄。Windows
    10引入了三种*伪句柄*，允许你查询令牌信息，而无需打开完全的内核对象句柄。以下是这三种句柄及其句柄值（括号内）：
- en: '**Primary (-4)    **The primary token for the current process'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**主令牌 (-4)    **当前进程的主令牌'
- en: '**Impersonation (-5)    **The impersonation token for the current thread; fails
    if the thread is not impersonating'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟 (-5)    **当前线程的模拟令牌；如果线程没有进行模拟，则失败'
- en: '**Effective (-6)    **The impersonation token for the current thread, if it
    is impersonating; otherwise, the primary token'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效令牌 (-6)    **当前线程的模拟令牌（如果它正在进行模拟）；否则为主令牌'
- en: Unlike the current process and current thread pseudo handles, you can’t duplicate
    these token handles; you can use them for certain limited uses only, such as querying
    information or performing access checks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command can return these handles if you specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    parameter, as shown in [Listing 4-7](chapter4.xhtml#Lis4-7).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与当前进程和当前线程伪句柄不同，不能复制这些令牌句柄；它们只能用于某些有限的用途，如查询信息或执行访问检查。如果你指定了<samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>参数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>命令可以返回这些句柄，如[列表 4-7](chapter4.xhtml#Lis4-7)所示。
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 4-7: Querying pseudo tokens'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-7：查询伪令牌
- en: Here, we query the three types of pseudo tokens while impersonating the anonymous
    user. The first command queries the primary token and extracts its user SID ❶.
    The next command queries the impersonation token, which returns the anonymous
    user’s SID ❷. We then query the effective token, which, as we’re impersonating
    the anonymous user, also returns the anonymous user’s SID ❸. Finally, we query
    the effective token again, this time waiting until after the script block has
    executed to extract the user SID. This operation returns the primary token’s user
    SID ❹, demonstrating that the pseudo token is context sensitive.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在模拟匿名用户时查询三种类型的伪令牌。第一个命令查询主令牌并提取其用户SID ❶。下一个命令查询模拟令牌，返回匿名用户的SID ❷。然后我们查询有效令牌，由于我们模拟的是匿名用户，它也返回匿名用户的SID
    ❸。最后，我们再次查询有效令牌，这次等脚本块执行完毕后提取用户SID。此操作返回主令牌的用户SID ❹，证明伪令牌是上下文敏感的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Token Groups</samp>
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">令牌组</samp>
- en: If administrators had to secure every resource for each possible user, identity
    security would become too unwieldy to manage. *Groups* allow users to share a
    broader security identity. Most of the access control operations on Windows grant
    access to groups rather than individual users.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果管理员必须为每个可能的用户保护每个资源，身份安全将变得难以管理。*组* 允许用户共享更广泛的安全身份。在 Windows 中，大多数访问控制操作是授予组而不是单个用户。
- en: From the SRM’s perspective, a group is just another SID that could potentially
    define access to a resource. We can display the groups in the PowerShell console
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp>
    command, as shown in [Listing 4-8](chapter4.xhtml#Lis4-8).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SRM 的角度来看，组只是另一个 SID，它可能定义对某个资源的访问。我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp>
    命令在 PowerShell 控制台中显示这些组，如 [列表 4-8](chapter4.xhtml#Lis4-8) 所示。
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-8: Querying the current token’s groups'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-8：查询当前令牌的组
- en: We can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp>
    to filter for specific attribute flags by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>
    parameter. [Table 4-2](chapter4.xhtml#tab4-2) shows the possible attribute flags
    we can pass to the command.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp>
    通过指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp> 参数来过滤特定的属性标志。[表
    4-2](chapter4.xhtml#tab4-2) 显示了我们可以传递给命令的所有可能的属性标志。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp> <samp class="SANS_Futura_Std_Book_11">Group
    Attributes in SDK and PowerShell Format</samp>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-2：</samp> <samp class="SANS_Futura_Std_Book_11">SDK
    和 PowerShell 格式中的组属性</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">SDK attribute name</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">PowerShell attribute name</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">SDK 属性名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">PowerShell
    属性名称</samp> |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_ENABLED</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_ENABLED</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">启用</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_ENABLED_BY_DEFAULT</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp> |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_ENABLED_BY_DEFAULT</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">默认启用</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_MANDATORY</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp> |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_MANDATORY</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">强制</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_LOGON_ID</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_LOGON_ID</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">登录ID</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_OWNER</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_OWNER</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">所有者</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_USE_FOR_DENY_ONLY</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_USE_FOR_DENY_ONLY</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">仅用于拒绝</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_INTEGRITY</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_INTEGRITY</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">完整性</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_INTEGRITY_ENABLED</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">IntegrityEnabled</samp> |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_INTEGRITY_ENABLED</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">完整性启用</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_RESOURCE</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Resource</samp> |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_RESOURCE</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">资源</samp> |'
- en: The following sections describe what each of these flags means.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节描述了这些标志的含义。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabled, EnabledByDefault,
    and Mandatory</samp>
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">启用，默认启用，和强制</samp>
- en: The most important flag is <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>.
    When it’s set, the SRM considers the group during the access check process; otherwise,
    it will ignore the group. Any group with the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp>
    attribute set is automatically enabled.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的标志是<samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>。当设置此标志时，SRM会在访问检查过程中考虑该组；否则，它会忽略该组。任何设置了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp>属性的组都会自动启用。
- en: It’s possible to disable a group (excluding it from the access check process)
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustGroupsToken</samp>
    system call if you have <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustGroups</samp>
    access on the token handle; the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtTokenGroup</samp>
    PowerShell command exposes this system call. However, you can’t disable groups
    that have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp> flag
    set. This flag is set for all groups in a normal user’s token, but certain system
    tokens have nonmandatory groups. If a group is disabled when you pass an impersonation
    token over RPC and the effective token mode flag is set in the SQoS, the impersonation
    token will delete the group.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在令牌句柄上拥有<samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustGroups</samp>访问权限，可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustGroupsToken</samp>系统调用禁用某个组（将其排除在访问检查过程之外）；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Set-NtTokenGroup</samp> PowerShell命令会暴露这个系统调用。然而，你无法禁用具有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp>标志的组。这个标志在普通用户的令牌中会被设置，但某些系统令牌中可能有非强制性的组。如果在通过RPC传递模拟令牌时禁用了一个组，并且SQoS中设置了有效令牌模式标志，那么模拟令牌将删除该组。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">LogonId</samp>
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">LogonId</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp> flag identifies
    any SID that is granted to all tokens on the same desktop. For example, if you
    run a process as a different user using the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp>
    utility, the new process’s token will have the same logon SID as the caller, even
    though it’s a different identity. This behavior allows the SRM to grant access
    to session-specific resources, such as the session object directory. The SID is
    always in the format <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-4-4-</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">X</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">X</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp> are the two
    32-bit values of the LUID that was allocated when the authentication session was
    created. We’ll come back to the logon SID and where it applies in the next chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp>标志标识授予所有在同一桌面的令牌的SID。例如，如果你使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">runas</samp>工具以其他用户身份运行一个进程，则新进程的令牌将具有与调用者相同的登录SID，尽管它是不同的身份。这种行为允许SRM授予对特定会话资源的访问权限，例如会话对象目录。SID总是采用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-4-4-</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">X</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp>的格式，其中<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">X</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp>是当身份验证会话创建时分配的LUID的两个32位值。我们将在下一章回到登录SID及其应用场景。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Owner</samp>
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Owner</samp>
- en: 'All securable resources on the system belong to either a group SID or a user
    SID. Tokens have an <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    property that contains a SID to use as the default owner when creating a resource.
    The SRM allows only a specific set of the users’ SIDs to be specified in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> property: either the user’s
    SID or any group SID that is marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    flag.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上的所有可安全访问的资源都属于某个组SID或用户SID。令牌有一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>属性，包含一个SID，用作创建资源时的默认所有者。SRM只允许在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>属性中指定一组特定的用户SID：要么是用户的SID，要么是任何带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>标志的组SID。
- en: You can get or set the token’s current <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    property using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -NtTokenSid</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtTokenSid</samp> command.
    For example, in [Listing 4-9](chapter4.xhtml#Lis4-9) we get the owner SID from
    the current token, then attempt to set the owner.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get -NtTokenSid</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Set-NtTokenSid</samp>命令获取或设置令牌的当前<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>属性。例如，在[Listing 4-9](chapter4.xhtml#Lis4-9)中，我们从当前令牌获取所有者SID，然后尝试设置所有者。
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4-9: Getting and setting the token’s owner SID'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-9：获取和设置令牌的所有者SID
- en: In this case, our attempt to set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    property to the SID <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-2-3-4</samp>
    fails with an exception, as this isn’t our current user SID or in our list of
    groups.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们尝试将<samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>属性设置为SID
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-2-3-4</samp>时，出现异常失败，因为这不是当前用户的SID，也不在我们的组列表中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UseForDenyOnly</samp>
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UseForDenyOnly</samp>
- en: The SRM’s access check either allows or denies access to a SID. But when a SID
    is disabled, it will no longer participate in allow or deny checks, which can
    result in incorrect access checking.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SRM的访问检查要么允许，要么拒绝对SID的访问。但是，当SID被禁用时，它将不再参与允许或拒绝检查，这可能导致访问检查不正确。
- en: Let’s consider a simple example. Imagine there are two groups, *Employee* and
    *Remote Access*. A user creates a document that they want all employees to be
    able to read except for those remotely accessing the system, as the content of
    the document is sensitive and the user doesn’t want it to leak. The document is
    configured to grant all members of the *Employee* group access but to deny access
    to users in the *Remote Access* group.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子。假设有两个组，*员工*和*远程访问*。用户创建了一个文档，希望所有员工都能阅读，但远程访问系统的用户不能访问，因为文档内容敏感，用户不希望泄露。该文档被配置为授予所有*员工*组的成员访问权限，但拒绝*远程访问*组的用户访问。
- en: Now imagine that a user belonging to both of those groups could disable a group
    when accessing a resource. They could simply disable *Remote Access* to be granted
    access to the document based on their membership in the *Employee* group, trivially
    circumventing the access restrictions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设一个同时属于这两个组的用户在访问资源时可以禁用一个组。只需禁用*远程访问*组，就可以基于他们在*员工*组中的成员身份，轻松绕过访问限制，从而获得文档的访问权限。
- en: For this reason, a user will rarely be allowed to disable groups. However, in
    certain cases, such as sandboxing, you’ll want to be able to disable a group so
    that it can’t be used to access a resource. The <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    flag solves this problem. When a SID is marked with this flag, it won’t be considered
    when checking for allow access but will still be considered in deny access checks.
    A user can mark their own groups as <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    by filtering their token and using it to create a new process. We’ll discuss token
    filtering when we consider restricted tokens in “Sandbox Tokens” on page 117.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用户通常不会被允许禁用组。然而，在某些情况下，例如沙盒操作，你可能希望能够禁用某个组，以使其无法用于访问资源。<samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>标志解决了这个问题。当SID被标记为此标志时，它在检查允许访问时不会被考虑，但在拒绝访问检查时仍然会被考虑。用户可以通过过滤其令牌并使用该令牌创建新进程来将自己的组标记为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>。我们将在第117页的“沙盒令牌”部分讨论令牌过滤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integrity and IntegrityEnabled</samp>
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">完整性和完整性启用</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IntegrityEnabled</samp> attribute flags
    indicate that a SID represents the token’s integrity level and is enabled. Group
    SIDs marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp>
    attribute flag store this integrity level as a 32-bit number in their final RID.
    The RID can be any arbitrary value; however, there are seven predefined levels
    in the SDK, as shown in [Table 4-3](chapter4.xhtml#tab4-3). Only the first six
    are in common use and accessible from a user process. To indicate an integrity
    SID the SRM uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">MandatoryLabel</samp>
    security authority (which has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp>).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">完整性</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntegrityEnabled</samp>
    属性标志表示一个 SID 代表令牌的完整性级别，并且已经启用。带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">完整性</samp>
    属性标志的组 SID 在其最终的 RID 中存储此完整性级别，作为一个 32 位数字。RID 可以是任何任意值；然而，SDK 中定义了七个预定义级别，如 [表
    4-3](chapter4.xhtml#tab4-3) 所示。只有前六个级别在用户进程中常用且可访问。为了指示一个完整性 SID，SRM 使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MandatoryLabel</samp> 安全权限（其值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp>）。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp> <samp class="SANS_Futura_Std_Book_11">Predefined
    Integrity Level Values</samp>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-3：</samp> <samp class="SANS_Futura_Std_Book_11">预定义的完整性级别值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Integrity level</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SDK
    name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">PowerShell name</samp>
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">完整性级别</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SDK
    名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">PowerShell 名称</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_UNTRUSTED_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Untrusted</samp> |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_UNTRUSTED_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Untrusted</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4096</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_LOW_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4096</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_LOW_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8192</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_MEDIUM_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8192</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_MEDIUM_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8448</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_MEDIUM_PLUS_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">MediumPlus</samp> |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8448</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_MEDIUM_PLUS_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">MediumPlus</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12288</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_HIGH_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12288</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_HIGH_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">16384</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_SYSTEM_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">16384</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_SYSTEM_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20480</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_PROTECTED_PROCESS_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedProcess</samp> |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20480</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_PROTECTED_PROCESS_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedProcess</samp> |'
- en: The default level for a user is <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>.
    Administrators are usually assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>,
    and services are assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>.
    We can query a token’s integrity SID using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenSid</samp>,
    as shown in [Listing 4-10](chapter4.xhtml#Lis4-10).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的默认级别是 <samp class="SANS_TheSansMonoCd_W5Regular_11">中等</samp>。管理员通常被分配 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">高级</samp>，服务则被分配 <samp class="SANS_TheSansMonoCd_W5Regular_11">系统</samp>。我们可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenSid</samp> 查询令牌的完整性 SID，如
    [清单 4-10](chapter4.xhtml#Lis4-10) 所示。
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-10: Getting a token’s integrity level SID'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-10：获取令牌的完整性级别 SID
- en: We can also set a new token integrity level, provided it’s less than or equal
    to the current value. It’s possible to increase the level too, but this requires
    special privileges and having <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以设置一个新的令牌完整性级别，只要它小于或等于当前值。也可以提升级别，但这需要特权权限，并且需要启用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>。
- en: While you can set the entire SID, it’s usually more convenient to set just the
    value. For example, the script in [Listing 4-11](chapter4.xhtml#Lis4-11) will
    set a token’s integrity level to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    level.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以设置整个 SID，但通常更方便只设置其值。例如，[清单 4-11](chapter4.xhtml#Lis4-11) 中的脚本将令牌的完整性级别设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">低</samp> 级别。
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 4-11: Setting the token integrity level to Low'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-11：将令牌完整性级别设置为低
- en: If you run this script, you might find that you start to get errors in your
    PowerShell console due to blocked file access. We’ll discuss why file access is
    blocked when we cover Mandatory Integrity Control in [Chapter 7](chapter7.xhtml).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本，可能会发现由于文件访问被阻止，你的 PowerShell 控制台开始出现错误。当我们在 [第 7 章](chapter7.xhtml)
    讨论强制完整性控制时，会讨论为什么文件访问会被阻止。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Resource</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">资源</samp>
- en: The final attribute flag deserves only a passing mention. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Resource</samp>
    attribute flag indicates that the group SID is a *domain local SID*. We’ll come
    back to this SID type in [Chapter 10](chapter10.xhtml).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的属性标志只需要简单提及一下。<samp class="SANS_TheSansMonoCd_W5Regular_11">资源</samp> 属性标志表示该组
    SID 是 *域本地 SID*。我们将在 [第 10 章](chapter10.xhtml) 详细讨论这种 SID 类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Device Groups</samp>
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设备组</samp>
- en: A token can also have a separate list of *device groups*. These group SIDs are
    added when a user authenticates to a server over a network in an enterprise environment,
    as shown in [Listing 4-12](chapter4.xhtml#Lis4-12).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌还可以有一个单独的 *设备组* 列表。当用户在企业环境中通过网络认证到服务器时，这些组 SID 会被添加，如 [清单 4-12](chapter4.xhtml#Lis4-12)
    所示。
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 4-12: Displaying device groups using Get-NtTokenGroup'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-12：使用 Get-NtTokenGroup 显示设备组
- en: You can query the groups on the token by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp>
    and passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> parameter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp>
    并传递 <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> 参数，查询令牌上的组。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Privileges</samp>
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">权限</samp>
- en: Groups allow system administrators to control a user’s access to specific resources.
    *Privileges*, in contrast, are granted to a user to allow them to short-circuit
    certain security checks for all types of resources, such as by bypassing an access
    check. A privilege can also apply to certain privileged actions, like changing
    the system’s clock. You can view a token’s privileges in the console using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenPrivilege</samp> ([Listing
    4-13](chapter4.xhtml#Lis4-13)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 组允许系统管理员控制用户对特定资源的访问。*权限*，相反，是授予用户的，允许他们绕过所有类型资源的某些安全检查，比如跳过访问检查。权限还可以应用于某些特权操作，如更改系统时钟。你可以在控制台中使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenPrivilege</samp> 查看令牌的权限（参见
    [清单 4-13](chapter4.xhtml#Lis4-13)）。
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 4-13: Listing token privileges'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-13：列出令牌权限
- en: The output is split into three columns. The first column is the privilege’s
    common name. As with SIDs, the SRM does not use this name directly; instead, it
    uses the privilege’s LUID value, which we can see in the second column. The last
    column indicates whether the privilege is currently enabled. Privileges can be
    in an enabled or disabled state.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出被分为三列。第一列是特权的通用名称。与 SID 一样，SRM 并不直接使用此名称，而是使用特权的 LUID 值，我们可以在第二列中看到。最后一列指示特权当前是否已启用。特权可以处于启用或禁用状态。
- en: Any check for a privilege should make sure that the privilege is enabled and
    not just present. In certain circumstances, such as sandboxing, a token might
    have a privilege listed, but the sandbox restrictions might prevent it from being
    marked as enabled. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    flag is really a set of attribute flags, like the attributes for the group SIDs.
    We can view these attributes by formatting the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenPrivilege</samp>
    as a list ([Listing 4-14](chapter4.xhtml#Lis4-14)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对特权的任何检查都应该确保特权是启用的，而不仅仅是存在。在某些情况下，例如沙箱化，令牌可能列出了特权，但沙箱限制可能会阻止它被标记为启用。<samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    标志实际上是一组属性标志，类似于组 SID 的属性。我们可以通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenPrivilege</samp>
    的输出格式化为列表来查看这些属性（[清单 4-14](chapter4.xhtml#Lis4-14)）。
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 4-14: Displaying all properties of the SeChangeNotifyPrivilege privilege'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-14：显示 SeChangeNotifyPrivilege 特权的所有属性
- en: In the output, we can now see the attributes, which include both <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp>. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp> attribute
    specifies whether the default state of the privilege is to be enabled. We also
    now see an additional <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName</samp>
    property, used to provide additional information to a user.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们现在可以看到属性，其中包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp> 属性指定特权的默认状态是否为启用。我们还可以看到一个额外的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName</samp> 属性，用于向用户提供额外的信息。
- en: To modify the state of a token’s privileges, you need <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustPrivileges</samp>
    access on the token handle; then you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustPrivilegesToken</samp>
    system call to adjust the attributes and enable or disable a privilege. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Enable-NtTokenPrivilege</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Disable-NtTokenPrivilege</samp> PowerShell
    commands expose this system call, as shown in [Listing 4-15](chapter4.xhtml#Lis4-15).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改令牌的特权状态，您需要在令牌句柄上具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustPrivileges</samp>
    访问权限；然后可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustPrivilegesToken</samp>
    系统调用来调整属性并启用或禁用特权。<samp class="SANS_TheSansMonoCd_W5Regular_11">Enable-NtTokenPrivilege</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Disable-NtTokenPrivilege</samp>
    PowerShell 命令暴露了此系统调用，如 [清单 4-15](chapter4.xhtml#Lis4-15) 所示。
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 4-15: Enabling and disabling the SeTimeZonePrivilege privilege'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-15：启用和禁用 SeTimeZonePrivilege 特权
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustPrivilegesToken</samp>
    API, it’s also possible to remove a privilege entirely by specifying the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Remove</samp> attribute, which you can
    accomplish with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtTokenPrivilege</samp>
    PowerShell command. Removing a privilege ensures that the token can never use
    it again. If you only disable the privilege, then it could be reenabled inadvertently.
    [Listing 4-16](chapter4.xhtml#Lis4-16) shows how to remove a privilege.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustPrivilegesToken</samp>
    API，还可以通过指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove</samp> 属性完全移除特权，您可以通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtTokenPrivilege</samp> PowerShell
    命令来实现。移除特权可确保令牌永远无法再次使用该特权。如果只是禁用特权，它可能会被无意中重新启用。[清单 4-16](chapter4.xhtml#Lis4-16)
    展示了如何移除特权。
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 4-16: Removing a privilege from a token'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-16：从令牌中移除特权
- en: To check privileges, a user application can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtPrivilegeCheck</samp>
    system call, while kernel code can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SePrivilegeCheck</samp>
    API. You might be wondering whether you can just manually test whether a privilege
    is enabled rather than using a dedicated system call. In this instance, yes; however,
    it’s always worth using system facilities where possible in case you make a mistake
    in your implementation or haven’t considered some edge case. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp>
    PowerShell command wraps the system call, as shown in [Listing 4-17](chapter4.xhtml#Lis4-17).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查权限，用户应用程序可以调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtPrivilegeCheck</samp>
    系统调用，而内核代码可以调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SePrivilegeCheck</samp>
    API。你可能会想，是否可以直接手动测试某个权限是否启用，而不是使用专用的系统调用。在这种情况下，是的；然而，尽可能使用系统设施总是值得的，以防你在实现中犯错误或没有考虑到某些边缘情况。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp> PowerShell
    命令封装了系统调用，如 [清单 4-17](chapter4.xhtml#Lis4-17) 所示。
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 4-17: Performing privilege checks'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-17：执行权限检查
- en: This listing demonstrates some example privilege checks using <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp>.
    We start by enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    and disabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTimeZonePrivilege</samp>.
    These are common privileges granted to all users, but you might need to change
    the example if your token doesn’t have them. We then test for just <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>;
    it’s enabled, so this test returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    Next, we check for both <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTimeZonePrivilege</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>;
    we can see that we don’t have all the privileges, so <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Finally, we
    run the same command but specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">-PassResult</samp>
    option to return the full check result. We can see in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledPrivileges</samp>
    column that only <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    is enabled.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本清单演示了使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp>
    进行的一些权限检查示例。我们首先启用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    并禁用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTimeZonePrivilege</samp>。这些是授予所有用户的常见权限，但如果你的令牌没有它们，可能需要更改示例。接着，我们仅测试
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>；它被启用，所以该测试返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。然后，我们检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTimeZonePrivilege</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>；我们可以看到我们没有所有的权限，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp> 返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。最后，我们运行相同的命令，但指定 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-PassResult</samp> 选项以返回完整的检查结果。我们可以在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledPrivileges</samp> 列中看到只有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp> 被启用。
- en: 'The following are some of the privileges available on the system:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是系统上可用的一些权限：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeChangeNotifyPrivilege  </samp>This
    privilege’s name is misleading. It allows a user to receive notifications of changes
    to the filesystem or registry, but it’s also used to bypass traversal checking.
    We’ll discuss traversal checking in [Chapter 8](chapter8.xhtml).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeChangeNotifyPrivilege</samp>
    这个权限的名称可能会让人误解。它允许用户接收文件系统或注册表的变化通知，但它也用于绕过遍历检查。我们将在 [第8章](chapter8.xhtml) 中讨论遍历检查。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeAssignPrimaryTokenPrivilege and
    SeImpersonatePrivilege  </samp>These privileges allow the user to bypass the assigning
    primary token and impersonation checks, respectively. Unlike most privileges in
    this list, these must be enabled on the current process’s primary token, not on
    an impersonation token.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeAssignPrimaryTokenPrivilege 和
    SeImpersonatePrivilege</samp>这些权限分别允许用户绕过主令牌分配和 impersonation 检查。与此列表中的大多数权限不同，这些必须在当前进程的主令牌上启用，而不是在
    impersonation 令牌上。
- en: '<samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeBackupPrivilege and SeRestorePrivilege  </samp>These
    privileges allow the user to bypass the access check when opening specific resources,
    like files or registry keys. This lets the user back up and restore resources
    without needing to be granted access to them explicitly. These privileges have
    also been repurposed for other uses: for example, the restore privilege allows
    a user to load arbitrary registry hives.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeBackupPrivilege 和 SeRestorePrivilege  </samp>这些权限允许用户绕过访问检查，从而打开特定资源，如文件或注册表项。这使得用户可以在不显式授予访问权限的情况下备份和恢复资源。这些权限还被重新用于其他用途：例如，恢复权限允许用户加载任意的注册表树。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeSecurityPrivilege and SeAuditPrivilege  </samp>The
    first of these privileges allows a user to be granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access right on a resource. This allows the user to modify the resource’s auditing
    configuration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAuditPrivilege</samp>
    privilege allows a user to generate arbitrary object audit messages from a user
    application. We’ll discuss auditing in [Chapters 5](chapter5.xhtml), [6](chapter6.xhtml),
    and [9](chapter9.xhtml).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeSecurityPrivilege 和 SeAuditPrivilege  </samp>第一个权限允许用户在资源上获得<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>访问权限，从而可以修改资源的审计配置。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeAuditPrivilege</samp>权限允许用户从应用程序生成任意的对象审计消息。我们将在[第5章](chapter5.xhtml)、[第6章](chapter6.xhtml)和[第9章](chapter9.xhtml)中讨论审计相关内容。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeCreateTokenPrivilege  </samp>This
    privilege should be given to only a very select group of users, as it grants the
    ability to craft arbitrary tokens using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>
    system call.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeCreateTokenPrivilege  </samp>该权限应仅授予一小部分用户，因为它允许使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>系统调用创建任意令牌。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeDebugPrivilege  </samp>The name
    of this privilege implies that it’s necessary for debugging processes. However,
    that’s not really the case, as it’s possible to debug a process without it. The
    privilege does allow the user to bypass any access check when opening a process
    or thread object.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeDebugPrivilege  </samp>该权限的名称表明它是调试进程所必需的。然而，事实并非如此，因为即使没有此权限，也可以调试进程。该权限允许用户在打开进程或线程对象时绕过任何访问检查。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeTcbPrivilege  </samp>The name
    of this privilege comes from *trusted computing base (TCB)*, a term used to refer
    to the privileged core of the Windows operating system, including the kernel.
    This is a catch-all for privileged operations not covered by a more specific privilege.
    For example, it allows users to bypass the check for increasing the integrity
    level of a token (up to the limit of the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    level), but also to specify a fallback exception handler for a process, two operations
    that have little in common.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeTcbPrivilege  </samp>该权限的名称来源于*可信计算基础（TCB）*，该术语用来指代Windows操作系统的特权核心，包括内核。这是一个涵盖所有特权操作的权限，适用于那些没有更具体权限的操作。例如，它允许用户绕过增加令牌完整性级别的检查（最高可至<samp
    class="SANS_TheSansMonoCd_W5Regular_11">System</samp>级别），还可以为进程指定一个回退异常处理程序，这两个操作实际上没有太大关联。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeLoadDriverPrivilege  </samp>We
    can load a new kernel driver through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp>
    system call, although it’s more common to use the SCM. This privilege is required
    to successfully execute that system call. Note that having this privilege doesn’t
    allow you to circumvent kernel driver checks such as code signing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeLoadDriverPrivilege  </samp>我们可以通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp>系统调用加载新的内核驱动程序，尽管通常更常用的是使用SCM。成功执行该系统调用需要此权限。需要注意的是，拥有此权限并不能绕过内核驱动检查，例如代码签名检查。
- en: '<samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeTakeOwnershipPrivilege and</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeRelabelPrivilege  </samp>These
    privileges have the same immediate effect: they allow a user to be granted <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access to a resource,
    even if the normal access control wouldn’t allow it. <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
    allows a user to take ownership of a resource, as having <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    is necessary for that purpose. <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    bypasses checks on the mandatory label of a resource; normally, you can only set
    a label to be equal to or lower than the caller’s integrity level. Setting the
    mandatory label also requires <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    access on a handle, as we’ll see in [Chapter 6](chapter6.xhtml).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeTakeOwnershipPrivilege 和</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeRelabelPrivilege</samp> 这两个特权具有相同的直接效果：它们允许用户被授予
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> 访问资源的权限，即使正常的访问控制不允许这样做。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp> 允许用户接管资源的所有权，因为拥有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> 权限是此操作的必要条件。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp> 绕过了对资源强制标签的检查；通常，你只能将标签设置为等于或低于调用者的完整性级别。设置强制标签还需要对句柄具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> 权限，正如我们在[第6章](chapter6.xhtml)中将看到的那样。
- en: We’ll look at specific examples of these privileges’ uses in later chapters,
    when we discuss security descriptors and access checks. For now, let’s turn to
    ways of restricting access through sandboxing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中查看这些特权的具体应用示例，当时我们将讨论安全描述符和访问检查。现在，让我们转向通过沙箱限制访问的方法。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Sandbox Tokens</samp>
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">沙箱令牌</samp>
- en: 'In our connected world, we must process a lot of untrusted data. Attackers
    might craft data for malicious purposes, such as to exploit a security vulnerability
    in a web browser or a document reader. To counter this threat, Windows provides
    a method of restricting the resources a user can access by placing any processes
    of theirs that handle untrusted data into a sandbox. If the process is compromised,
    the attacker will have only a limited view of the system and won’t be able to
    access the user’s sensitive information. Windows implements sandboxes through
    three special token types: restricted tokens, write-restricted tokens, and lowbox
    tokens.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的互联世界中，我们必须处理大量不可信的数据。攻击者可能会构造恶意数据，目的包括利用网页浏览器或文档阅读器中的安全漏洞。为应对这一威胁，Windows
    提供了一种方法，通过将任何处理不可信数据的进程置于沙箱中来限制用户能够访问的资源。如果该进程被攻破，攻击者将只能看到系统的有限视图，并且无法访问用户的敏感信息。Windows
    通过三种特殊的令牌类型来实现沙箱：受限令牌、写保护令牌和低级令牌。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Restricted Tokens</samp>
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">受限令牌</samp>
- en: The *restricted token* type is the oldest sandbox token in Windows. It was introduced
    as a feature in Windows 2000 but not used widely as a sandbox until the introduction
    of the Google Chrome web browser. Other browsers, such as Firefox, have since
    replicated Chrome’s sandbox implementation, as have document readers such as Adobe
    Reader.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*受限令牌* 类型是 Windows 中最早的沙箱令牌。它作为 Windows 2000 中的一个特性引入，但直到 Google Chrome 网络浏览器推出后才被广泛用于沙箱。其他浏览器，如
    Firefox，随后也复制了 Chrome 的沙箱实现，像 Adobe Reader 这样的文档阅读器也是如此。'
- en: You can create a restricted token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    system call or the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRestrictedToken</samp>
    Win32 API, each of which lets you specify a list of restricted SIDs to limit the
    resources the token will be permitted to access. The SIDs do not have to already
    be available in the token. For example, Chrome’s most restrictive sandbox specifies
    the NULL SID (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-0-0</samp>) as
    the only restricted SID. The NULL SID is never granted to a token as a normal
    group.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> 系统调用或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRestrictedToken</samp> Win32
    API 创建一个受限令牌，每个方法都允许你指定一个受限 SID 列表，以限制该令牌可以访问的资源。这些 SID 不必已经存在于令牌中。例如，Chrome 最严格的沙箱指定
    NULL SID (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-0-0</samp>) 作为唯一的受限
    SID。NULL SID 从不作为普通组分配给令牌。
- en: Any access check must allow both the normal list of groups and the list of restricted
    SIDs; otherwise, the user will be denied access, as we’ll discuss in detail in
    [Chapter 7](chapter7.xhtml). The <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    system call can also mark normal groups with the <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    attribute flag and delete privileges. We can combine the ability to filter a token
    with restricted SIDs or use it on its own, to create a lesser-privileged token
    without more comprehensive sandboxing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 任何访问检查都必须同时允许正常组列表和受限 SIDs 列表；否则，用户将被拒绝访问，我们将在[第 7 章](chapter7.xhtml)中详细讨论。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> 系统调用也可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    属性标记正常组并删除权限。我们可以将过滤令牌的能力与受限 SIDs 结合使用，或者单独使用它，来创建一个权限较低的令牌，而不需要更全面的沙盒。
- en: It’s easy to build a restricted token that can’t access any resources. Such
    a restriction produces a good sandbox but also makes it impossible to use the
    token as a process’s primary token, as the process won’t be able to start. This
    puts a serious limitation on how effective a sandbox using restricted tokens can
    be. [Listing 4-18](chapter4.xhtml#Lis4-18) demonstrates how to create a restricted
    token and extract the results.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个无法访问任何资源的受限令牌是很容易的。这样的限制产生了一个很好的沙盒环境，但也使得无法将其用作进程的主要令牌，因为该进程无法启动。这对使用受限令牌的沙盒的有效性带来了严重的限制。[列表
    4-18](chapter4.xhtml#Lis4-18)演示了如何创建受限令牌并提取结果。
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 4-18: Creating a restricted token and displaying groups and privileges'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-18：创建受限令牌并显示组和权限
- en: We start by creating a restricted token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command. We specify one restricted SID, <samp class="SANS_TheSansMonoCd_W5Regular_11">RC</samp>,
    which maps to a special <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\RESTRICTED</samp>
    SID that is commonly configured for system resources to permit read access. We
    also specify that we want to convert the *Everyone* group (<samp class="SANS_TheSansMonoCd_W5Regular_11">WD</samp>)
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>. Finally,
    we specify a flag to disable the maximum number of privileges.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> 命令创建一个受限令牌。我们指定一个受限
    SID，<samp class="SANS_TheSansMonoCd_W5Regular_11">RC</samp>，它映射到一个特殊的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY\RESTRICTED</samp> SID，通常用于系统资源，以允许读取访问。我们还指定希望将 *Everyone* 组 (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WD</samp>) 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>。最后，我们指定一个标志来禁用最大权限。
- en: Next, we display the properties of the token, starting with all normal groups,
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    attribute. The output shows that only the *Everyone* group has the flag set. We
    then display the restricted SIDs list, which shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY\RESTRICTED</samp> SID.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示该令牌的属性，从所有正常的组开始，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    属性。输出显示，只有*Everyone*组设置了该标志。然后我们展示受限的 SIDs 列表，其中显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY\RESTRICTED</samp> SID。
- en: After this, we display the privileges. Note that even though we’ve asked to
    disable the maximum privileges, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    is still there. This privilege is not deleted, as it can become very difficult
    to access resources without it. If you really want to get rid of it, you can specify
    it explicitly to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    or delete it after the token has been created.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示权限。请注意，即使我们要求禁用最大权限，<samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    仍然存在。这个权限不会被删除，因为没有它，访问资源会变得非常困难。如果你真的想去除它，可以明确地将其指定给 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>，或者在令牌创建后删除它。
- en: Finally, we query the token property that indicates whether it’s a restricted
    token.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们查询表示是否为受限令牌的令牌属性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Write-Restricted
    Tokens</samp>
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">写入受限令牌</samp>
- en: A *write-restricted token* prevents write access to a resource but allows read
    and execute access. You can create a write-restricted token by passing the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WRITE_RESTRICTED</samp> flag to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*写限制令牌* 阻止对资源的写入访问，但允许读取和执行访问。你可以通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">WRITE_RESTRICTED</samp>
    标志传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> 来创建一个写限制令牌。'
- en: Windows XP SP2 introduced this token type to harden system services. It’s much
    easier to use as a sandbox than a restricted token, as you don’t need to worry
    about the token not being able to read critical resources such as DLLs. However,
    it creates a less useful sandbox. For example, if you can read files for a user,
    you might be able to steal their private information, such as passwords stored
    by a web browser, without needing to escape the sandbox.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Windows XP SP2 引入了这种令牌类型，以增强系统服务的安全性。它比受限令牌更容易用作沙箱，因为你不需要担心令牌无法读取关键资源，如 DLL
    文件。然而，它创建了一个不太有用的沙箱。例如，如果你可以读取某个用户的文件，你可能会窃取他们的私人信息，比如浏览器存储的密码，而无需逃脱沙箱。
- en: For completeness, let’s create a write-restricted token and view its properties
    ([Listing 4-19](chapter4.xhtml#Lis4-19)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们创建一个写限制令牌并查看其属性（[列表 4-19](chapter4.xhtml#Lis4-19)）。
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 4-19: Creating a write-restricted token'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-19：创建一个写限制令牌
- en: We start by creating the token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command. We specify one restricted SID, <samp class="SANS_TheSansMonoCd_W5Regular_11">WR</samp>,
    which maps to a special <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\WRITE
    RESTRICTED</samp> SID that is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY\RESTRICTED</samp> but assigned to write access on specific system resources.
    We also specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteRestricted</samp>
    flag to make this a write-restricted token rather than a normal restricted token.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> 命令创建令牌。我们指定一个受限
    SID，<samp class="SANS_TheSansMonoCd_W5Regular_11">WR</samp>，它映射到一个特殊的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY\WRITE RESTRICTED</samp> SID，相当于 <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY\RESTRICTED</samp>，但被分配到对特定系统资源的写访问权限。我们还指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteRestricted</samp>
    标志，以使其成为一个写限制令牌，而不是一个普通的受限令牌。
- en: Next, we display the token’s properties. In the list of restricted SIDs, we
    see <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\WRITE RESTRICTED</samp>.
    Displaying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Restricted</samp>
    property shows that the token is considered restricted; however, we can see that
    it’s also marked as <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteRestricted</samp>.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们显示令牌的属性。在受限 SID 列表中，我们看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY\WRITE RESTRICTED</samp>。显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">Restricted</samp>
    属性时，显示该令牌被认为是受限的；然而，我们可以看到它也被标记为 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteRestricted</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AppContainer and
    Lowbox Tokens</samp>
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">应用容器和低盒令牌</samp>
- en: Windows 8 introduced the AppContainer sandbox to protect a new Windows application
    model. AppContainer implements its security using a *lowbox token*. You can create
    a lowbox token from an existing token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateLowBoxToken</samp>
    system call. There is no direct equivalent Win32 API for this system call, but
    you can create an AppContainer process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API. We won’t go into more detail here on how to create a process using this API;
    instead, we’ll focus only on the lowbox token.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8 引入了应用容器沙箱，以保护新的 Windows 应用程序模型。应用容器通过使用 *低盒令牌* 来实现其安全性。你可以通过 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateLowBoxToken</samp> 系统调用，从现有令牌创建低盒令牌。这个系统调用没有直接对应的
    Win32 API，但你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API 创建一个应用容器进程。我们在这里不会详细讨论如何使用这个 API 创建进程，而是专注于低盒令牌。
- en: When creating a lowbox token, you need to specify a package SID and a list of
    capability SIDs. Both SID types are issued by the *application package authority*
    (which has the value of 15). You can distinguish between package SIDs and capability
    SIDs by checking their first RIDs, which should be <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, respectively. The
    package SID works like the user’s SID in the normal token, whereas the capability
    SIDs act like restricted SIDs. We’ll leave the actual details of how these affect
    an access check for [Chapter 7](chapter7.xhtml).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建低权限令牌时，您需要指定一个软件包 SID 和一组功能 SID。这两种 SID 类型都由*应用程序包权限*（其值为 15）发布。通过检查它们的第一个
    RID，您可以区分软件包 SID 和功能 SID，它们分别应该是 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>。软件包 SID 类似于正常令牌中的用户 SID，而功能
    SID 类似于受限 SID。我们将把这些如何影响访问检查的具体细节留到[第 7 章](chapter7.xhtml)中。
- en: 'Capability SIDs modify the access check process, but they can also mean something
    in isolation. For example, there are capabilities to allow network access that
    are handled specially by the Windows Firewall, even though that’s not directly
    related to access checking. There are two types of capability SIDs:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 功能 SID 修改了访问检查过程，但它们也可以单独表示某些意义。例如，Windows 防火墙专门处理允许网络访问的功能，尽管这与访问检查没有直接关系。功能
    SID 有两种类型：
- en: '**Legacy    **A small set of predefined SIDs introduced in Windows 8'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**传统功能** Windows 8 引入的一组预定义的 SID'
- en: '**Named    **The RIDs are derived from a textual name'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名功能** RID 从文本名称派生'
- en: '[Appendix B](appendix-B.xhtml) contains a more comprehensive list of named
    capability SIDs. [Table 4-4](chapter4.xhtml#tab4-4) shows the legacy capabilities.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录 B](appendix-B.xhtml) 包含更全面的命名功能 SID 列表。[表 4-4](chapter4.xhtml#tab4-4) 显示了传统功能。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-4:</samp> <samp class="SANS_Futura_Std_Book_11">Legacy
    Capability SIDs</samp>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-4：</samp> <samp class="SANS_Futura_Std_Book_11">传统功能
    SID</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Capability name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SID</samp>
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">功能名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SID</samp>
    |'
- en: '| --- | --- |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Your internet connection</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-1</samp> |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">您的互联网连接</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-1</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Your internet connection, including
    incoming connections from the internet</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-2</samp>
    |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">您的互联网连接，包括来自互联网的传入连接</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-2</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Your home or work networks</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-3</samp> |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">您的家庭或工作网络</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-3</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Your pictures library</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-4</samp> |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">您的图片库</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-4</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Your videos library</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-5</samp> |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">您的视频库</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-5</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Your music library</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-6</samp>
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">您的音乐库</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-6</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Your documents library</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-7</samp> |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">您的文档库</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-7</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Your Windows credentials</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-8</samp> |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">您的 Windows 凭据</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-8</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Software and hardware certificates
    or a smart card</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-9</samp>
    |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">软件和硬件证书或智能卡</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-9</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Removable storage</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-10</samp>
    |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">可移动存储</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-10</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Your appointments</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-11</samp>
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">您的约会</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-11</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Your contacts</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-12</samp>
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">您的联系人</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-12</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Internet Explorer</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-4096</samp>
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Internet Explorer</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-4096</samp>
    |'
- en: We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> to
    query for package and capability SIDs, as shown in [Listing 4-20](chapter4.xhtml#Lis4-20).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> 来查询包和能力
    SID，如 [列表 4-20](chapter4.xhtml#Lis4-20) 所示。
- en: '[PRE21]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 4-20: Creating package and capability SIDs'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-20：创建包和能力 SID
- en: Here, we create two package SIDs and two capability SIDs. We generate the first
    package SID by specifying its name to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    and receive the resulting SID ❶. This package SID is derived from the lowercase
    form of the name hashed with the SHA256 digest algorithm. The 256-bit digest is
    broken up into seven 32-bit chunks that act as the RIDs. The final 32-bit value
    of the digest is discarded.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个包 SID 和两个能力 SID。我们通过指定名称 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    来生成第一个包 SID，并接收结果 SID ❶。这个包 SID 是通过对名称的小写形式进行 SHA256 摘要算法哈希得到的。256 位的摘要被拆分为七个
    32 位的块，这些块作为 RIDs。摘要的最后一个 32 位值被丢弃。
- en: Windows also supports a restricted package SID, which is designed to allow a
    package to create new secure child packages that can’t interact with each other.
    The classic Edge web browser used this feature to separate internet- and intranet-facing
    children so that if one was compromised, it couldn’t access data in the other.
    To create the child, we use the original package family name plus a child identifier
    ❷. The created SID extends the original package SID with another four RIDs, as
    you can see in the output.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 还支持一个受限的包 SID，它旨在允许一个包创建新的安全子包，这些子包不能相互交互。经典的 Edge 网络浏览器使用此功能来将面向互联网和面向内网的子包分开，这样即使其中一个被攻破，它也无法访问另一个子包的数据。为了创建子包，我们使用原始包的家庭名称加上一个子标识符
    ❷。创建的 SID 扩展了原始包 SID，并增加了四个 RIDs，您可以在输出中看到这些内容。
- en: The first capability SID ❸ is a legacy capability for internet access. Note
    that the resulting SDDL SID has one additional RID value (<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>).
    The second SID is derived from a name, in this case <samp class="SANS_TheSansMonoCd_W5Regular_11">registryRead</samp>
    ❹, which is used to allow read access to a group of system registry keys. As with
    the package SID, the named capability RIDs are generated from the SHA256 hash
    of the lowercase name. To differentiate between legacy and named capability SIDs,
    the second RID is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1024</samp>
    followed by the SHA256 hash. You can generate your own capability SIDs using this
    method, although there’s not much you can do with the capability unless some resource
    is configured to use it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个能力 SID ❸ 是用于互联网访问的遗留能力。请注意，生成的 SDDL SID 具有一个额外的 RID 值（<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>）。第二个
    SID 是从一个名称派生的，在本例中是 <samp class="SANS_TheSansMonoCd_W5Regular_11">registryRead</samp>
    ❹，它用于允许读取一组系统注册表键。与包 SID 一样，命名能力 RIDs 是通过对小写名称进行 SHA256 哈希生成的。为了区分遗留能力 SID 和命名能力
    SID，第二个 RID 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1024</samp>，后面跟着
    SHA256 哈希。您可以使用此方法生成自己的能力 SID，尽管除非某些资源配置为使用它，否则您无法对其进行操作。
- en: Windows also supports a *capability group*, a group SID that can be added to
    the normal list of groups ❺. A capability group sets the first RID to <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>
    and the rest of the RIDs to the same SHA256 hash that was derived from the capability
    name.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 还支持 *能力组*，它是一个可以添加到正常组列表中的组 SID ❺。能力组将第一个 RID 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>，其余的
    RIDs 设置为从能力名称派生的相同 SHA256 哈希。
- en: Now that we’ve got the SIDs, we can create a lowbox token as shown in [Listing
    4-21](chapter4.xhtml#Lis4-21).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了 SID，我们可以创建低箱令牌，如 [列表 4-21](chapter4.xhtml#Lis4-21) 所示。
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 4-21: Creating a lowbox token and listing its properties'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-21：创建低箱令牌并列出其属性
- en: 'First we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>,
    passing it the package name (the SID as SDDL would also work) and the list of
    capabilities to assign to the lowbox token ❶. We can then query for the list of
    capabilities ❷. Notice that the names of the two capability SIDs are different:
    the SID derived from a name is prefixed with <samp class="SANS_TheSansMonoCd_W5Regular_11">NAMED
    CAPABILITIES</samp>. There’s no way of converting a named capability SID back
    to the name it was derived from; the PowerShell module must generate the name
    based on a large list of known capabilities. The second SID is a legacy SID, so
    LSASS can resolve it back to a name.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>，传入包名（SID
    也可以作为 SDDL 使用）和要分配给低权限令牌的能力列表 ❶。然后我们可以查询能力列表 ❷。请注意，两个能力 SID 的名称不同：从名称派生的 SID 以
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NAMED CAPABILITIES</samp> 为前缀。无法将命名能力
    SID 转换回它原本的名称；PowerShell 模块必须根据一个已知能力的大列表来生成名称。第二个 SID 是一个遗留 SID，因此 LSASS 可以将其解析回名称。
- en: Next, we query the package SID ❸. As the package SID is derived from a name
    using SHA256, it’s not possible to resolve it back to the package name. Again,
    the PowerShell module has a list of names that it can use to work out what the
    original name was.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查询包 SID ❸。由于包 SID 是通过 SHA256 从名称派生的，因此无法将其解析回包名。同样，PowerShell 模块拥有一个名称列表，可以用来推算出原始名称。
- en: A lowbox token is always set to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    integrity level ❹. In fact, if a privileged user changes the integrity level to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> or above, all lowbox
    properties, such as package SIDs and capability SIDs, are removed, and the token
    reverts to a non-sandbox token.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 低权限令牌始终设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> 完整性级别 ❹。实际上，如果特权用户将完整性级别更改为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> 或更高，所有低权限令牌属性，如包 SID
    和能力 SID，将被移除，令牌将恢复为非沙盒令牌。
- en: We’ve covered making a user less privileged by converting their token into a
    sandbox token. We’ll now go to the other side and look at what makes a user privileged
    enough to administrate the Windows system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了通过将用户的令牌转换为沙盒令牌来使用户权限降低。接下来，我们将探讨使用户具有足够特权以管理 Windows 系统的因素。
- en: <samp class="SANS_Futura_Std_Bold_B_11">What Makes an Administrator User?</samp>
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">什么使一个用户成为管理员？</samp>
- en: If you come from a Unix background, you’ll know user ID 0 as the administrator
    account, or *root*. As root, you can access any resource and configure the system
    however you’d like. When you install Windows, the first account you configure
    will also be an administrator. However, unlike root, the account won’t have a
    special SID that the system treats differently. So, what makes an administrator
    account on Windows?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自 Unix 背景，你会知道用户 ID 0 是管理员账户，或称为 *root*。作为 root，你可以访问任何资源，并按需配置系统。当你安装 Windows
    时，首先配置的账户也将是管理员账户。然而，与 root 不同，该账户没有特殊的 SID，系统不会特别处理它。那么，Windows 上的管理员账户到底有什么特征呢？
- en: The basic answer is that Windows is configured to give certain groups and privileges
    special access. Administrator access is inherently discretionary, meaning it’s
    possible to be an administrator but still be locked out of resources; there is
    no real equivalent of a root account (although the *SYSTEM* user comes close).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的答案是，Windows 配置了特定的组和权限以提供特殊访问。管理员访问本质上是可自由裁定的，这意味着即使是管理员，也可能被锁定无法访问某些资源；并没有与
    root 账户完全等同的账户（尽管 *SYSTEM* 用户接近这个角色）。
- en: Administrators generally have three characteristics. First, when you configure
    a user to be an administrator, you typically add them to the *BUILTIN\Administrators*
    group, then configure Windows to allow access to the group when performing an
    access check. For example, the system folders, such as *C:\Windows*, are configured
    to allow the group to create new files and directories.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员通常有三个特点。首先，当你将用户配置为管理员时，通常会将他们添加到 *BUILTIN\Administrators* 组中，然后配置 Windows
    在执行访问检查时允许该组访问。例如，系统文件夹，如 *C:\Windows*，会被配置为允许该组创建新的文件和目录。
- en: Second, administrators are granted access to additional privileges, which effectively
    circumvent the system’s security controls. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    allows a user to get full access to any other process or thread on the system,
    no matter what security it has been assigned. With full access to a process, it’s
    possible to inject code into it to gain the privileges of a different user.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，管理员被授予额外的权限，这些权限有效地绕过了系统的安全控制。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    允许用户获取对系统上任何其他进程或线程的完全访问权限，无论其分配了什么安全性。通过对进程的完全访问，能够向其中注入代码，从而获得其他用户的权限。
- en: Third, administrators typically run at the <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>
    integrity level, whereas system services run at the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    level. By increasing the administrator’s integrity level, we make it harder to
    accidentally leave administrator resources (especially processes and threads)
    accessible to non-administrators. Weak access control to resources is a common
    misconfiguration; however, if the resource is also marked with an integrity level
    above <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, then non-administrator
    users won’t be able to write to the resource.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，管理员通常以 <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> 完整性级别运行，而系统服务则以
    <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> 完整性级别运行。通过提高管理员的完整性级别，我们使意外将管理员资源（尤其是进程和线程）暴露给非管理员变得更加困难。资源的弱访问控制是常见的错误配置；然而，如果资源的完整性级别设置为高于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>，非管理员用户将无法写入该资源。
- en: A quick way to verify whether a token is an administrator is to check the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> property on the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object. This property indicates
    whether the token has certain groups and available privileges found in a fixed
    list in the kernel. [Listing 4-22](chapter4.xhtml#Lis4-22) shows an example for
    a non-administrator.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 验证令牌是否为管理员的快速方法是检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象上的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> 属性。此属性指示令牌是否包含内核中固定列表中的某些组和可用权限。[列表
    4-22](chapter4.xhtml#Lis4-22) 显示了一个非管理员的示例。
- en: '[PRE23]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 4-22: The Elevated property for a non-administrator'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-22：非管理员的提升属性
- en: 'If the token has one of the following privileges, it’s automatically considered
    elevated:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果令牌具有以下任一权限，则会自动被视为提升权限：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDelegateSessionUserImpersonatePrivilege</samp>
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDelegateSessionUserImpersonatePrivilege</samp>
- en: The privilege doesn’t have to be enabled, just available in the token.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 该权限不必启用，只需在令牌中可用。
- en: 'For elevated groups, the kernel doesn’t have a fixed list of SIDs; instead,
    it inspects only the last RID of the SID. If the RID is set to one of the following
    values, then the SID is considered elevated: <samp class="SANS_TheSansMonoCd_W5Regular_11">114</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">498</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">512</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">516</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">517</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">518</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">519</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">520</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">521</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">544</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">547</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">548</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">549</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">550</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">551</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">553</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">554</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">556</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">569</samp>.
    For example, the SID of the *BUILTIN\Administrators* group is <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-4-32-544</samp>.
    As <samp class="SANS_TheSansMonoCd_W5Regular_11">544</samp> is in this list, the
    SID is considered elevated. (Note that the SID <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-1-2-3-4-544</samp>
    would also be considered elevated, even though there is nothing special about
    it.)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提升权限的组，内核没有固定的 SID 列表；相反，它只检查 SID 的最后一个 RID。如果 RID 设置为以下值之一，则该 SID 被认为是提升权限的：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">114</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">498</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">512</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">516</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">517</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">518</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">519</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">520</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">521</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">544</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">547</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">548</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">549</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">550</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">551</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">553</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">554</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">556</samp>，或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">569</samp>。例如，*BUILTIN\Administrators*
    组的 SID 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-4-32-544</samp>。由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">544</samp> 在此列表中，因此该 SID 被认为是提升权限的。（请注意，即使
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-1-2-3-4-544</samp> 没有特别之处，它也会被认为是提升权限的。）
- en: <samp class="SANS_Futura_Std_Bold_B_11">User Account Control</samp>
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">用户帐户控制</samp>
- en: I mentioned that when you install a new copy of Windows, the first user you
    create is always an administrator. It’s important to configure the user in this
    way; otherwise, it would be impossible to modify the system and install new software.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过，当你安装一个新的 Windows 副本时，首先创建的用户总是管理员。以这种方式配置用户非常重要，否则将无法修改系统并安装新软件。
- en: However, prior to Windows Vista, this default behavior was a massive security
    liability, because average consumers would install the default account and likely
    never change it. This meant that most people used a full administrator account
    for everyday activities like surfing the web. If a malicious attacker were able
    to exploit a security issue in the user’s browser, the attacker would get full
    control over the Windows machine. In the days prior to widespread sandboxing,
    this threat proved serious.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Windows Vista 之前，这种默认行为是一个巨大的安全隐患，因为普通消费者通常会安装默认帐户，并且很可能从不更改它。这意味着大多数人会使用完整的管理员帐户进行日常活动，比如浏览网页。如果恶意攻击者能够利用用户浏览器中的安全问题，攻击者将能够完全控制
    Windows 计算机。在广泛使用沙箱技术之前，这个威胁是非常严重的。
- en: In Vista, Microsoft changed this default behavior by introducing *User Account
    Control (UAC)* and the split-token administrator. In this model, the default user
    remains an administrator; however, by default, all programs run with a token whose
    administrator groups and privileges have been removed. When a user needs to perform
    an administrative task, the system elevates a process to a full administrator
    and shows a prompt, like the one in [Figure 4-3](chapter4.xhtml#fig4-3), requesting
    the user’s confirmation before continuing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vista中，微软通过引入*用户账户控制（UAC）*和分割令牌管理员改变了这种默认行为。在这种模型中，默认用户仍然是管理员；然而，默认情况下，所有程序都是以删除了管理员组和权限的令牌运行的。当用户需要执行管理任务时，系统会将进程提升为完整的管理员，并显示一个提示框，如[图4-3](chapter4.xhtml#fig4-3)所示，请求用户确认后继续。
- en: '![](../images/Figure4-3.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: The UAC consent
    dialog for privilege elevation</samp>'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-3：用于提升权限的UAC同意对话框</samp>
- en: To make using Windows easier for users, you can configure a program to force
    this elevation when it’s started. A program’s elevation property is stored in
    a manifest XML file embedded in the executable image. Run the example in [Listing
    4-23](chapter4.xhtml#Lis4-23) to get the manifest information for all the executables
    in the *System32* directory.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Windows的使用对用户更便捷，您可以配置程序，在启动时强制提升权限。程序的提升属性存储在嵌入在可执行文件中的清单XML文件中。运行[列表4-23](chapter4.xhtml#Lis4-23)中的示例，以获取*System32*目录下所有可执行文件的清单信息。
- en: '[PRE24]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 4-23: Querying executable manifest information'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-23：查询可执行文件清单信息
- en: 'If it’s a special, Microsoft-approved program, the manifest can specify whether
    the program should be automatically, and silently, elevated (indicated by a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp> value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoElevate</samp>
    column). The manifest also indicates whether the process can run with UI access,
    a topic we''ll discuss later on page 129\. There are three possible values for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecutionLevel</samp> column:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是微软批准的特殊程序，则清单可以指定是否应自动且静默地提升程序权限（通过在<samp class="SANS_TheSansMonoCd_W5Regular_11">AutoElevate</samp>列中设置True值表示）。清单还会指示该进程是否可以在具有UI访问权限的情况下运行，我们将在第129页进一步讨论此话题。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ExecutionLevel</samp>列有三种可能的值：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">asInvoker  </samp>Run the process
    as the user who created it. This is the default setting.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">asInvoker  </samp>以创建该进程的用户身份运行该进程。这是默认设置。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">highestAvailable  </samp>If the
    user is a split-token administrator, then force elevation to the administrator
    token. If not, then run as the user who created the process.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">highestAvailable  </samp>如果用户是分割令牌管理员，则强制提升到管理员令牌。如果不是，则以创建该进程的用户身份运行。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">requireAdministrator</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Force elevation, whether the user
    is a split-token administrator or not. If the user is not an administrator, they’ll
    be prompted for a password for an administrator account.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">requireAdministrator</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>强制提升权限，无论用户是否为分割令牌管理员。如果用户不是管理员，系统将提示输入管理员账户的密码。
- en: 'When something creates an executable with an elevated execution level, the
    shell calls the RPC method <samp class="SANS_TheSansMonoCd_W5Regular_11">RAiLaunchAdminProcess</samp>.
    This method checks the manifest and starts the elevation process, including showing
    the consent dialog. It’s also possible to manually elevate any application by
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp> API,
    introduced in “Shell APIs” on page 89, and requesting the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp>
    operation. PowerShell exposes this behavior using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp>
    command, as shown here:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些操作创建具有提升执行级别的可执行文件时，Shell会调用RPC方法<samp class="SANS_TheSansMonoCd_W5Regular_11">RAiLaunchAdminProcess</samp>。该方法检查清单并启动提升过程，包括显示同意对话框。也可以通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp> API手动提升任何应用程序的权限，此API在第89页的“Shell
    APIs”中有介绍，并请求<samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp>操作。PowerShell使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp>命令暴露此行为，如下所示：
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When you run this command, you should see the UAC prompt. If you click Yes in
    the consent dialog, *notepad.exe* should run as an administrator on the desktop.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此命令时，应该会看到 UAC 提示。如果你在同意对话框中点击“是”，*notepad.exe* 应该会以管理员身份在桌面上运行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linked Tokens and
    Elevation Type</samp>
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">关联令牌和提升类型</samp>
- en: 'When an administrator authenticates to the desktop, the system tracks two tokens
    for the user:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当管理员认证到桌面时，系统会跟踪用户的两个令牌：
- en: '**Limited    **The unelevated token used for most running processes'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限    ** 用于大多数运行进程的未提升令牌'
- en: '**Full    **The full administrator token, used only after elevation'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整    ** 只有在提升后使用的完整管理员令牌'
- en: The name *split-token administrator* comes from these two tokens, as the user’s
    granted access is split between the limited and full tokens.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*分离令牌管理员* 这个名字来源于这两个令牌，因为用户被授予的访问权限在有限令牌和完整令牌之间分配。'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object has a
    field used to link the two tokens together. The linked token can be queried using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationToken</samp>
    system call and the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenLinkedToken</samp>
    information class. In [Listing 4-24](chapter4.xhtml#Lis4-24), we inspect some
    of the properties of these linked tokens using PowerShell.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象有一个字段，用于将两个令牌连接起来。可以通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationToken</samp> 系统调用和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenLinkedToken</samp> 信息类查询关联令牌。在
    [清单 4-24](chapter4.xhtml#Lis4-24) 中，我们使用 PowerShell 检查这些关联令牌的一些属性。
- en: '[PRE26]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 4-24: Displaying properties of the linked token'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-24：显示关联令牌的属性
- en: We access the linked token by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Linked</samp>
    parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -NtToken</samp>,
    ❶ and we format the token to display its groups, privileges, integrity level,
    and token information. In the list of groups, we can see the *BUILTIN\Administrators*
    group enabled ❷. We can also see that the list of privileges contains some high-level
    ones, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    ❸. The combination of groups and privileges confirms that this is an administrator
    token.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Linked</samp> 参数传递给 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get -NtToken</samp> 来访问关联令牌 ❶，然后格式化令牌以显示其组、权限、完整性级别和令牌信息。在组列表中，我们可以看到启用了
    *BUILTIN\Administrators* 组 ❷。我们还可以看到，权限列表包含一些高级权限，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    ❸。组和权限的组合确认了这是一个管理员令牌。
- en: The integrity level of the token is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>
    ❹, which, as we discussed earlier, prevents the token from accidentally leaving
    sensitive resources accessible to non-administrator users. In the token information,
    we can see that there’s an impersonation token at Identification level ❺. To get
    a token that can create a new process, the caller needs the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    privilege, which means only system services, such as the Application Information
    service, can get the token. Finally, we can see that the token is marked as elevated
    ❻ and that the token elevation type indicates this is the full token ❼. Let’s
    compare this with the limited token ([Listing 4-25](chapter4.xhtml#Lis4-25)).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的完整性级别设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">高</samp> ❹，正如我们之前讨论的，这可以防止令牌意外地让敏感资源对非管理员用户可访问。在令牌信息中，我们可以看到在识别级别
    ❺ 有一个模拟令牌。要获得一个可以创建新进程的令牌，调用者需要 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    权限，这意味着只有系统服务，例如应用程序信息服务，才能获得该令牌。最后，我们可以看到该令牌被标记为提升的 ❻，并且令牌提升类型表明这是完整令牌 ❼。我们将此与有限令牌进行比较（[清单
    4-25](chapter4.xhtml#Lis4-25)）。
- en: '[PRE27]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 4-25: Displaying properties of the limited token'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-25：显示有限令牌的属性
- en: We first get a handle to the current token and format it with the same formatting
    we used in [Listing 4-24](chapter4.xhtml#Lis4-24) ❶. In the list of groups, we
    can see that *BUILTIN\Administrators* has been converted to a <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    group ❷. Any other group that would match the elevated RID check would be converted
    in the same way.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取当前令牌，并使用在[列表 4-24](chapter4.xhtml#Lis4-24) ❶中使用的相同格式对其进行格式化。在组列表中，我们可以看到*BUILTIN\Administrators*已经被转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>组 ❷。任何其他符合提升RID检查的组都会以相同方式被转换。
- en: The list of privileges shows only five items ❸. These are the only five privileges
    that the limited token can have. The integrity level of the token is set to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, down from <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>
    in the full token ❹. In the token information, we can see that the token is not
    elevated ❺, and the elevation type indicates that this is the limited token ❻.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 权限列表仅显示五个条目 ❸。这些是受限令牌可以拥有的唯一五个权限。令牌的完整性级别设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>，低于完整令牌中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">High</samp> ❹。在令牌信息中，我们可以看到令牌没有被提升 ❺，而提升类型指示这是受限令牌
    ❻。
- en: Finally, note that the flags contain the value <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp>
    ❼. This flag indicates the token has been filtered using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    system call. This is because, to create the limited token, LSASS will first create
    a new full token so that its authentication ID has a unique value. (If you compare
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Auth ID</samp> values in Listings
    4-24 and 4-25, you’ll notice they are indeed different.) This allows the SRM to
    consider the two tokens to be in separate logon sessions. LSASS then passes the
    token to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp> parameter flag
    to convert any elevated group to <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    and delete all privileges other than the five permitted ones. <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    does not drop the integrity level from <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, though; that must
    be done separately. Lastly, LSASS calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp>
    to link the two tokens together using the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenLinkedToken</samp>
    information class.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意标志包含值<samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp> ❼。此标志表示令牌已经通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>系统调用进行了过滤。这是因为，为了创建受限令牌，LSASS首先会创建一个新的完整令牌，以确保其身份验证ID具有唯一值。（如果你比较列表4-24和4-25中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Auth ID</samp>值，你会注意到它们确实不同。）这使得SRM能够将这两个令牌视为在不同的登录会话中。然后，LSASS将令牌传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp>参数标志，将任何提升的组转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>，并删除除五个允许的特权外的所有特权。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>不会将完整令牌的完整性级别从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">High</samp>降至<samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>，这一操作需要单独进行。最后，LSASS调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp>，通过<samp class="SANS_TheSansMonoCd_W5Regular_11">TokenLinkedToken</samp>信息类将两个令牌链接在一起。
- en: 'There is a third type of elevation, *default*, used for any token not associated
    with a split-token administrator:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有第三种提升类型，*默认*，用于任何未与分离令牌管理员关联的令牌：
- en: '[PRE28]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, the anonymous user is not a split-token administrator, so the
    token has the default elevation type.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，匿名用户不是分离令牌管理员，因此令牌具有默认提升类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UI Access</samp>
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UI 访问</samp>
- en: One of the other security features introduced in Windows Vista is *User Interface
    Privilege Isolation (UIPI)*, which prevents a lower-privileged process from programmatically
    interacting with the user interface of a more privileged process. This is enforced
    using integrity levels, and it’s another reason UAC administrators run at a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">High</samp> integrity level.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Vista 引入的另一个安全特性是*用户界面特权隔离 (UIPI)*，它防止了低特权进程与高特权进程的用户界面进行程序化交互。这是通过完整性级别来强制执行的，也是
    UAC 管理员以 <samp class="SANS_TheSansMonoCd_W5Regular_11">高</samp> 完整性级别运行的另一个原因。
- en: But UIPI presents a problem for applications that are designed to interact with
    the user interface, such as screen readers and touch keyboards. To get around
    this limitation without granting the process too much privilege, a token can set
    a UI access flag. Whether a process is granted UI access depends on the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">UiAccess</samp> setting in the executable’s
    manifest file.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 UIPI 对于设计上需要与用户界面交互的应用程序，如屏幕阅读器和触摸键盘，带来了问题。为了在不赋予进程过多特权的情况下绕过这一限制，可以在令牌上设置
    UI 访问标志。是否授予进程 UI 访问权限取决于可执行文件清单中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">UiAccess</samp>
    设置。
- en: This UI access flag signals to the desktop environment that it should disable
    the UIPI checks. In [Listing 4-26](chapter4.xhtml#Lis4-26), we query for this
    flag in a suitable process, the On-Screen Keyboard (OSK).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 该 UI 访问标志向桌面环境发出信号，表示应该禁用 UIPI 检查。在[清单 4-26](chapter4.xhtml#Lis4-26)中，我们查询了一个合适进程中的此标志，即屏幕键盘（OSK）。
- en: '[PRE29]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 4-26: Querying the UI access flag in the On-Screen Keyboard primary
    token'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-26：查询屏幕键盘主令牌中的 UI 访问标志
- en: We start the OSK and open its <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object to query the UI access flag. To set this flag, the caller needs the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> privilege. The only
    way to create a UI access process as a normal user is to use the UAC service.
    Therefore, any UI access process needs to be started with <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>,
    which is why we used <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp>
    in [Listing 4-26](chapter4.xhtml#Lis4-26). This all happens behind the scenes
    when you create the UI access application.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动 OSK 并打开其 <samp class="SANS_TheSansMonoCd_W5Regular_11">令牌</samp> 对象以查询
    UI 访问标志。要设置此标志，调用者需要 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    权限。作为普通用户创建 UI 访问进程的唯一方法是使用 UAC 服务。因此，任何 UI 访问进程都需要通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>
    启动，这也是为什么我们在[清单 4-26](chapter4.xhtml#Lis4-26)中使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp>。这些操作在你创建
    UI 访问应用程序时都在幕后发生。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Virtualization</samp>
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">虚拟化</samp>
- en: 'Another problem introduced in Vista because of UAC is the question of how to
    handle legacy applications, which expect to be able to write to administrator-only
    locations such as the *Windows* directory or the local machine registry hive.
    Vista implemented a special workaround: if a virtualization flag is enabled on
    the primary token, it will silently redirect writes from these locations to a
    per-user store. This made it seem to the process as if it had successfully added
    resources to secure locations.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 UAC，Vista 引入的另一个问题是如何处理遗留应用程序，这些应用程序期望能够写入仅限管理员的目录，如 *Windows* 目录或本地计算机注册表。Vista
    实现了一个特殊的解决方法：如果在主令牌上启用了虚拟化标志，它会将来自这些位置的写入操作静默地重定向到每个用户的存储。这使得进程似乎已成功将资源添加到安全位置。
- en: By default, the virtualization flag is enabled on legacy applications automatically.
    However, you can specify it manually by setting a property on the primary token.
    Run the commands in [Listing 4-27](chapter4.xhtml#Lis4-27) in a non-administrator
    shell.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，虚拟化标志会自动启用在遗留应用程序上。然而，你也可以通过在主令牌上设置属性手动指定它。在非管理员 shell 中运行[清单 4-27](chapter4.xhtml#Lis4-27)中的命令。
- en: '[PRE30]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 4-27: Enabling virtualization on the Token object and creating a file
    in <samp class="SANS_Futura_Std_Book_11">C:\Windows</samp>'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-27：在令牌对象上启用虚拟化并在 <samp class="SANS_Futura_Std_Book_11">C:\Windows</samp>
    创建文件
- en: In this listing, we first try to create a writable file, *C:\Windows\hello.txt*
    ❶. This operation fails with an access denied exception. We then get the current
    primary token and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualizationEnabled</samp>
    property to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> ❷. When
    we repeat the file creation operation, it now succeeds ❸. If we query the location
    of the file, we find it’s under the user’s directory in a virtual store ❹. Only
    normal, unprivileged tokens can enable virtualization; system service and administrator
    tokens have virtualization disabled. You can learn whether virtualization is permitted
    by querying the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualizationAllowed</samp>
    property on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先尝试创建一个可写文件，*C:\Windows\hello.txt* ❶。此操作因访问被拒绝异常而失败。然后我们获取当前的主令牌，并将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualizationEnabled</samp> 属性设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> ❷。当我们重复文件创建操作时，它现在成功了
    ❸。如果我们查询文件的位置，我们会发现它位于用户目录下的虚拟存储中 ❹。只有普通的、没有特权的令牌可以启用虚拟化；系统服务和管理员令牌禁用了虚拟化。你可以通过查询
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualizationAllowed</samp> 属性来了解是否允许虚拟化，查询的对象是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Security Attributes</samp>
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">安全属性</samp>
- en: 'A token’s *security attributes* are a list of name/value pairs that provide
    arbitrary data. There are three types of security attributes associated with a
    token: *local*, *user claims*, and *device claims*. Each security attribute can
    have one or more values, which must all be of the same type. [Table 4-5](chapter4.xhtml#tab4-5)
    shows the valid types for a security attribute.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一个令牌的 *安全属性* 是一组名称/值对，用于提供任意数据。有三种类型的安全属性与令牌相关联：*本地*、*用户声明* 和 *设备声明*。每个安全属性可以具有一个或多个值，这些值必须是相同类型的。[表
    4-5](chapter4.xhtml#tab4-5) 显示了安全属性的有效类型。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-5:</samp> <samp class="SANS_Futura_Std_Book_11">Security
    Attribute Types</samp>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-5：</samp> <samp class="SANS_Futura_Std_Book_11">安全属性类型</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Type name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">类型名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Int64</samp> | <samp class="SANS_Futura_Std_Book_11">A
    signed 64-bit integer</samp> |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Int64</samp> | <samp class="SANS_Futura_Std_Book_11">一个有符号的
    64 位整数</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt64</samp> | <samp class="SANS_Futura_Std_Book_11">An
    unsigned 64-bit integer</samp> |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt64</samp> | <samp class="SANS_Futura_Std_Book_11">一个无符号的
    64 位整数</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp> | <samp class="SANS_Futura_Std_Book_11">A
    Unicode string</samp> |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp> | <samp class="SANS_Futura_Std_Book_11">一个
    Unicode 字符串</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Fqbn</samp> | <samp class="SANS_Futura_Std_Book_11">A
    fully qualified binary name; contains a version number and a Unicode string</samp>
    |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Fqbn</samp> | <samp class="SANS_Futura_Std_Book_11">一个完全限定的二进制名称；包含版本号和
    Unicode 字符串</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Sid</samp> | <samp class="SANS_Futura_Std_Book_11">A
    SID</samp> |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Sid</samp> | <samp class="SANS_Futura_Std_Book_11">一个
    SID</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp> | <samp class="SANS_Futura_Std_Book_11">A
    true or false value, stored as an</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Int64</samp><samp
    class="SANS_Futura_Std_Book_11">, with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    <samp class="SANS_Futura_Std_Book_11">being false and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_Futura_Std_Book_11">being true</samp> |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp> | <samp class="SANS_Futura_Std_Book_11">一个真或假的值，存储为一个</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Int64</samp><samp class="SANS_Futura_Std_Book_11">，其中</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> <samp class="SANS_Futura_Std_Book_11">表示假，</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_Futura_Std_Book_11">表示真</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OctetString</samp> | <samp
    class="SANS_Futura_Std_Book_11">An arbitrary array of bytes</samp> |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OctetString</samp> | <samp
    class="SANS_Futura_Std_Book_11">一个任意字节数组</samp> |'
- en: A set of flags can be assigned to the security attribute to change aspects of
    its behavior, such as whether new tokens can inherit it. [Table 4-6](chapter4.xhtml#tab4-6)
    shows the defined flags.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一组标志可以分配给安全属性，以改变其行为的某些方面，例如是否允许新的令牌继承它。[表 4-6](chapter4.xhtml#tab4-6)显示了已定义的标志。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-6:</samp> <samp class="SANS_Futura_Std_Book_11">Security
    Attribute Flags</samp>
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-6：</samp> <samp class="SANS_Futura_Std_Book_11">安全属性标志</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">标志名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp> | <samp
    class="SANS_Futura_Std_Book_11">The security attribute can’t be inherited by a
    child process token.</samp> |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp> | <samp
    class="SANS_Futura_Std_Book_11">该安全属性不能被子进程令牌继承。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CaseSensitive</samp> | <samp
    class="SANS_Futura_Std_Book_11">If the security attribute contains a string value,
    the comparison should be case sensitive.</samp> |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CaseSensitive</samp> | <samp
    class="SANS_Futura_Std_Book_11">如果安全属性包含字符串值，比较应区分大小写。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> | <samp
    class="SANS_Futura_Std_Book_11">The security attribute is used only when checking
    for denied access.</samp> |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> | <samp
    class="SANS_Futura_Std_Book_11">该安全属性仅在检查被拒绝的访问时使用。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DisabledByDefault</samp> |
    <samp class="SANS_Futura_Std_Book_11">The security attribute is disabled by default.</samp>
    |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DisabledByDefault</samp> |
    <samp class="SANS_Futura_Std_Book_11">该安全属性默认是禁用的。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Disabled</samp> | <samp class="SANS_Futura_Std_Book_11">The
    security attribute is disabled.</samp> |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Disabled</samp> | <samp class="SANS_Futura_Std_Book_11">该安全属性已禁用。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp> | <samp class="SANS_Futura_Std_Book_11">The
    security attribute is mandatory.</samp> |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp> | <samp class="SANS_Futura_Std_Book_11">该安全属性是强制性的。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unique</samp> | <samp class="SANS_Futura_Std_Book_11">The
    security attribute should be unique on the local system.</samp> |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unique</samp> | <samp class="SANS_Futura_Std_Book_11">该安全属性在本地系统上应该是唯一的。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnce</samp> | <samp
    class="SANS_Futura_Std_Book_11">The security attribute can be inherited once by
    a child, then should be set</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnce</samp> | <samp
    class="SANS_Futura_Std_Book_11">该安全属性可以被子进程继承一次，然后应设置为</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp><samp
    class="SANS_Futura_Std_Book_11">。</samp> |'
- en: Almost every process token has the <samp class="SANS_TheSansMonoCd_W5Regular_11">TSA://ProcUnique</samp>
    security attribute. This security attribute contains a unique LUID allocated during
    process creation. We can display its value for the effective token using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Show-NtTokenEffective</samp>, as shown
    in [Listing 4-28](chapter4.xhtml#Lis4-28).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个进程令牌都有 <samp class="SANS_TheSansMonoCd_W5Regular_11">TSA://ProcUnique</samp>
    安全属性。该安全属性包含在进程创建期间分配的唯一 LUID。我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtTokenEffective</samp>
    显示有效令牌的值，如[清单 4-28](chapter4.xhtml#Lis4-28)所示。
- en: '[PRE31]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 4-28: Querying the security attributes for the current process'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-28：查询当前进程的安全属性
- en: 'From the output, we can see that the name of the attribute is <samp class="SANS_TheSansMonoCd_W5Regular_11">TSA://ProcUnique</samp>.
    It has two <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt64</samp> values,
    which form a LUID when combined. Finally, it has two flags: <samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp>,
    which means the security attribute won’t be passed to new process tokens, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Unique</samp>, which means the kernel
    shouldn’t try to merge the security attribute with any other attribute on the
    system with the same name.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，属性的名称是 <samp class="SANS_TheSansMonoCd_W5Regular_11">TSA://ProcUnique</samp>。它有两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt64</samp> 值，结合起来形成一个 LUID。最后，它有两个标志：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp>，表示该安全属性不会传递到新进程的令牌中，以及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Unique</samp>，表示内核不应尝试将该安全属性与系统中任何其他具有相同名称的属性合并。
- en: To set local security attributes, the caller needs to have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcb
    Privilege</samp> privilege before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp>.
    User and device claims must be set during token creation, which we discuss in
    the next section.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置本地安全属性，调用者需要在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp>
    之前，具备 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcb Privilege</samp> 权限。用户和设备声明必须在令牌创建时设置，详细内容我们将在下一节讨论。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating Tokens</samp>
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建令牌</samp>
- en: Typically, LSASS creates tokens when a user authenticates to the computer. However,
    it can also create tokens for users that don’t exist, such as virtual accounts
    used for services. These tokens might be interactive, for use in a console session,
    or they could be network tokens for use over the local network. A locally authenticated
    user can create another user’s token by calling a Win32 API such as <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp>,
    which calls into LSASS to perform the token creation.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，LSASS 在用户认证到计算机时创建令牌。然而，它也可以为不存在的用户创建令牌，例如用于服务的虚拟帐户。这些令牌可能是交互式的，用于控制台会话，或者是网络令牌，用于通过本地网络访问。一个本地认证的用户可以通过调用
    Win32 API（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp>）来创建另一个用户的令牌，这将调用
    LSASS 来执行令牌创建。
- en: We won’t discuss LSASS at length until [Chapter 10](chapter10.xhtml). However,
    it’s worth understanding how LSASS creates tokens. To do so, LSASS calls the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp> system call. As I
    mentioned earlier, this system call requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
    privilege, which is granted to a limited number of processes. This privilege is
    about as privileged as it gets, as you can use it to create arbitrary tokens with
    any group or user SID and access any resource on the local machine.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在[第10章](chapter10.xhtml)详细讨论 LSASS。不过，理解 LSASS 如何创建令牌是值得的。为此，LSASS 调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp> 系统调用。正如我之前提到的，这个系统调用需要
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp> 权限，而这个权限只授予给有限数量的进程。这个权限非常特权，因为你可以用它创建任意的令牌，指定任何组或用户
    SID，并访问本地计算机上的任何资源。
- en: 'While you won’t often have to call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>
    from PowerShell, you can do so through the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp>
    command so long as you have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
    enabled. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>
    system call takes the following parameters:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不常需要从 PowerShell 调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>，但只要你启用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp> 权限，就可以通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp> 命令来调用。<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>
    系统调用需要以下参数：
- en: '**Token type    **Either primary or impersonation'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**令牌类型    **主要或模拟'
- en: '**Authentication ID    **The LUID authentication ID; can be set to any value
    you’d like'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证 ID    **LUID 认证 ID；可以设置为任何你想要的值'
- en: '**Expiration time    **Allows the token to expire after a set period'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**过期时间    **允许令牌在设定的时间后过期'
- en: '**User    **The user SID'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户    **用户SID'
- en: '**Groups    **The list of group SIDs'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**组    **组 SID 列表'
- en: '**Privileges    **The list of privileges'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**权限    **权限列表'
- en: '**Owner    **The owner SID'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有者    **所有者 SID'
- en: '**Primary group    **The primary group SID'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**主组    **主组SID'
- en: '**Source    **The source information name'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源    **源信息名称'
- en: 'In addition, Windows 8 introduced the following new features to the system
    call, which you can access through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateTokenEx</samp>
    system call:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Windows 8 向系统调用引入了以下新特性，您可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateTokenEx</samp>
    系统调用访问：
- en: '**Device groups    **A list of additional SIDs for the device'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备组    **设备的附加 SID 列表'
- en: '**Device claim attributes    **A list of security attributes to define device
    claims'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备声明属性    **用于定义设备声明的安全属性列表'
- en: '**User claim attributes    **A list of security attributes to define user claims'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户声明属性    **用于定义用户声明的安全属性列表'
- en: '**Mandatory policy    **A set of flags that indicate the token’s mandatory
    integrity policy'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**强制策略    **一组标志，表示令牌的强制完整性策略'
- en: Anything not in these two lists can be configured only by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp>
    after the new token has been created. Depending on what token property is being
    set, you might need a different privilege, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>.
    Let’s demonstrate how to create a new token using the script in [Listing 4-29](chapter4.xhtml#Lis4-29),
    which you must run as an administrator.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不在这两个列表中的内容只能通过在新令牌创建后调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp>
    来配置。根据要设置的令牌属性，您可能需要不同的权限，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>。我们通过运行
    [Listing 4-29](chapter4.xhtml#Lis4-29) 中的脚本来演示如何创建一个新令牌，您必须以管理员身份运行此脚本。
- en: '[PRE32]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 4-29: Creating a new token'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-29: 创建新令牌'
- en: A normal administrator does not have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
    privilege by default. Therefore, we need to borrow a token from another process
    that does. In most cases, the easiest process to borrow from is LSASS. We open
    the LSASS process and its token, duplicating it to an impersonation token ❶. Next,
    we ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
    is enabled on the token ❷. We can then impersonate the token and call <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp>,
    passing it a SID for the user and a single group ❸. Finally, we can print out
    the details for the new token, including its user SID set ❹ and group set ❺. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp> command also
    adds a default system integrity level SID that you can see in the group list.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 普通管理员默认没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
    权限。因此，我们需要从另一个具有该权限的进程借用令牌。在大多数情况下，最容易借用的进程是 LSASS。我们打开 LSASS 进程及其令牌，将其复制为一个模拟令牌
    ❶。接着，我们确保在该令牌上启用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
    权限 ❷。然后，我们可以模拟该令牌并调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp>，传递用户的
    SID 和单一组 ❸。最后，我们可以打印出新令牌的详细信息，包括其用户 SID 集 ❹ 和组集 ❺。<samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp>
    命令还会添加一个默认的系统完整性级别 SID，您可以在组列表中看到它。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Token Assignment</samp>
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">令牌分配</samp>
- en: If a normal user account could assign arbitrary primary or impersonation tokens,
    it could elevate its privileges to access the resources of other users. This would
    be especially problematic when it comes to impersonation, as another user account
    would need only open a named pipe to inadvertently allow the server to get an
    impersonation token.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果普通用户帐户可以分配任意的主令牌或模拟令牌，它就可能提升其权限以访问其他用户的资源。尤其是在模拟的情况下，这将尤其成问题，因为另一个用户帐户只需打开一个命名管道，就会无意中让服务器获取到一个模拟令牌。
- en: For that reason, the SRM imposes limits on what a normal user can do without
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonationPrivilege</samp>
    privileges. Let’s take a look at the criteria that must be met to assign a token
    for a normal user.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SRM 对普通用户在没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonationPrivilege</samp>
    权限的情况下，施加了限制。我们来看一下必须满足的条件，才能为普通用户分配令牌。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning a Primary
    Token</samp>
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分配主令牌</samp>
- en: 'A new process can be assigned a primary token in one of three ways:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 新进程可以通过以下三种方式之一分配主令牌：
- en: It can inherit the token from the parent process.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以继承父进程的令牌。
- en: The token can be assigned during process creation (for example, using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp> API).
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌可以在进程创建时分配（例如，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>
    API）。
- en: The token can be set after process creation using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess</samp>,
    before the process starts.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌可以在进程创建后通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess</samp>
    设置，在进程启动之前。
- en: Inheriting the token from the parent is by far the most common means of token
    assignment. For example, when you start an application from the Windows Start
    menu, the new process will inherit the token from the Explorer process.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 从父进程继承令牌是目前最常见的令牌分配方式。例如，当你从 Windows 开始菜单启动应用程序时，新的进程将从 Explorer 进程继承令牌。
- en: If a process does not inherit a token from its parent, the process will be passed
    the token as a handle that must have the <samp class="SANS_TheSansMonoCd_W5Regular_11">AssignPrimary</samp>
    access right. If the access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object is granted, the SRM imposes further criteria on the token to prevent the
    assignment of a more privileged token (unless the caller’s primary token has <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp> enabled).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程没有从其父进程继承令牌，那么该进程将获得一个令牌句柄，必须具备 <samp class="SANS_TheSansMonoCd_W5Regular_11">AssignPrimary</samp>
    访问权限。如果授予对 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象的访问权限，SRM
    会对令牌施加进一步的标准，以防分配更高权限的令牌（除非调用者的主令牌启用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>）。
- en: 'The kernel function <samp class="SANS_TheSansMonoCd_W5Regular_11">SeIsTokenAssignableToProcess</samp>
    imposes the token criteria. First it checks that the assigned token has an integrity
    level less than or equal to that of the current process’s primary token. If that
    criterion is met, it then checks whether the token meets either of the criteria
    shown in [Figure 4-4](chapter4.xhtml#fig4-4): namely, that the token is either
    a child of the caller’s primary token or a sibling of the primary token.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeIsTokenAssignableToProcess</samp>
    强制执行令牌标准。首先，它会检查分配的令牌的完整性级别是否小于或等于当前进程主令牌的完整性级别。如果满足此标准，它会继续检查令牌是否满足 [图 4-4](chapter4.xhtml#fig4-4)
    中显示的两个标准：即令牌要么是调用者主令牌的子令牌，要么是主令牌的同级令牌。
- en: '![](../images/Figure4-4.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: The SeIsTokenAssignableToProcess
    primary token assignment criteria</samp>'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-4：SeIsTokenAssignableToProcess
    主令牌分配标准</samp>
- en: Let’s first cover the case of a child token. A user process can create a new
    token based on an existing one. When this occurs, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentTokenId</samp>
    property in the new token’s kernel object is set to the ID of the parent token.
    If the new token’s <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentTokenId</samp>
    matches the current primary token’s ID value, then the assignment is granted.
    Restricted tokens are examples of child tokens; when you create a restricted token
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>, the
    new token’s parent token ID is set to the ID of the original token.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论子令牌的情况。用户进程可以基于现有令牌创建一个新的令牌。当发生这种情况时，新的令牌的内核对象中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentTokenId</samp>
    属性会设置为父令牌的 ID。如果新令牌的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentTokenId</samp>
    与当前主令牌的 ID 值匹配，则授予分配权限。受限令牌就是子令牌的例子；当你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    创建受限令牌时，新的令牌的父令牌 ID 会设置为原令牌的 ID。
- en: A *sibling token* is a token created as part of the same authentication session
    as the existing token. To test this criterion, the function compares the parent
    token ID and the authentication IDs of the two tokens. If they’re the same, then
    the token can be assigned. This check also tests whether the authentication sessions
    are special sibling sessions set by the kernel (a rare configuration). Common
    examples of a sibling token include tokens duplicated from the current process
    token and lowbox tokens.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*同级令牌*是与现有令牌属于同一身份验证会话中创建的令牌。为了测试此标准，函数会比较父令牌 ID 和两个令牌的身份验证 ID。如果它们相同，则可以分配该令牌。此检查还会测试身份验证会话是否为由内核设置的特殊同级会话（这是一种罕见的配置）。同级令牌的常见示例包括从当前进程令牌复制的令牌和低箱令牌。'
- en: Note that the function doesn’t check the user that the token represents, and
    if the token matches one of the criteria, it’s possible to assign it to a new
    process. If it doesn’t match the criteria, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT
    _HELD</samp> error will be returned during token assignment.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数不会检查令牌所代表的用户，如果令牌符合某个条件，则可以将其分配给新进程。如果不符合条件，则在令牌分配时会返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT_HELD</samp>
    错误。
- en: How does the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp> utility
    create a new process as a normal user with these restrictions? It uses the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp> API, which
    authenticates a user and starts the process from a system service that has the
    required privileges to bypass these checks.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp> 工具如何在这些限制下以普通用户身份创建新进程？它使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp> API，它对用户进行身份验证，并从具有所需特权的系统服务启动进程，以绕过这些检查。
- en: If we try to assign a process token, we’ll see how easily the operation can
    fail, even when we’re assigning tokens for the same user. Run the code in [Listing
    4-30](chapter4.xhtml#Lis4-30) as a non-administrator user.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试分配进程令牌，就会看到即使我们为同一用户分配令牌，操作也可以轻易失败。以非管理员用户身份运行 [列表 4-30](chapter4.xhtml#Lis4-30)
    中的代码。
- en: '[PRE33]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 4-30: Creating a process using restricted tokens'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-30：使用受限令牌创建进程
- en: Here, we create two restricted tokens and use them to create an instance of
    Notepad. In the first attempt, we create the token based on the current primary
    token ❶. The parent token ID field in the new token is set to the primary token’s
    ID, and when we use the token during process creation, the operation succeeds.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个受限的令牌，并使用它们来创建记事本实例。在第一次尝试中，我们根据当前的主令牌 ❶ 创建了新令牌。新令牌中的父令牌ID字段被设置为主令牌的ID，当我们在创建进程时使用该令牌时，操作成功。
- en: In the second attempt, we create another token but base it on the one we created
    previously ❷. Creating a process with this token fails with a privilege error
    ❸. This is because the second token’s parent token ID is set to the ID of the
    crafted token, not the primary token. As the token doesn’t meet either the child
    or sibling criterion, this operation will fail during assignment.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次尝试中，我们创建了另一个令牌，但它是基于之前创建的令牌 ❷。使用此令牌创建进程失败，并出现特权错误 ❸。这是因为第二个令牌的父令牌ID被设置为工造令牌的ID，而不是主令牌的ID。由于令牌不满足子令牌或同级令牌的条件，因此该操作在分配时会失败。
- en: You can set the token after creating the process by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess</samp>
    system call or <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessAccessToken</samp>,
    which PowerShell exposes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtToken</samp>
    command (demonstrated in [Listing 4-31](chapter4.xhtml#Lis4-31)).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在创建进程后通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess</samp>
    系统调用或 <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessAccessToken</samp>
    来设置令牌，PowerShell通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtToken</samp>
    命令公开此功能（如 [列表 4-31](chapter4.xhtml#Lis4-31) 所示）。
- en: '[PRE34]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 4-31: Setting an access token after a process has started'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-31：进程启动后设置访问令牌
- en: This assignment operation does not circumvent any of the assignment checks we’ve
    discussed. Once the process’s initial thread starts executing, the option to set
    the primary token is disabled, so when we try to set the token on a started process
    we get the <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_UNSUPPORTED</samp>
    error.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 该分配操作不会绕过我们之前讨论的任何分配检查。一旦进程的初始线程开始执行，设置主令牌的选项将被禁用，因此当我们尝试在启动的进程上设置令牌时，会出现 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">STATUS_UNSUPPORTED</samp> 错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning an Impersonation
    Token</samp>
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分配模拟令牌</samp>
- en: As with primary tokens, the SRM requires that an assigned impersonation token
    meet a specific set of criteria; otherwise, it will reject the assignment of the
    token to a thread. Interestingly, the criteria are not the same as those for the
    assignment of primary tokens. This can lead to situations in which it’s possible
    to assign an impersonation token but not a primary token, and vice versa.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 与主令牌一样，SRM要求分配的模拟令牌满足一套特定的条件；否则，它将拒绝将令牌分配给线程。有趣的是，这些条件与主令牌的分配条件不同。这可能导致某些情况，允许分配模拟令牌但不允许分配主令牌，反之亦然。
- en: If the token is specified explicitly, then the handle must have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp>
    access right. If the impersonation happens implicitly, then the kernel is already
    maintaining the token, and it requires no specific access right.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果令牌是显式指定的，则句柄必须具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp>
    访问权限。如果冒充是隐式发生的，则内核已经在维护该令牌，且无需特定访问权限。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTokenCanImpersonate</samp>
    function in the kernel handles the check for the impersonation criteria. As shown
    in [Figure 4-5](chapter4.xhtml#fig4-5), this check is significantly more complex
    than that for assigning primary tokens.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTokenCanImpersonate</samp>
    函数处理冒充条件的检查。如[图 4-5](chapter4.xhtml#fig4-5)所示，这个检查比分配主令牌的检查要复杂得多。
- en: '![](../images/Figure4-5.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: The</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">SeTokenCanImpersonate impersonation
    token checks</samp>'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-5：SeTokenCanImpersonate
    冒充令牌检查</samp>
- en: 'Let’s walk through each check and describe what it considers on both the impersonation
    and the primary token. Note that, because it’s possible to assign an impersonation
    token to a thread in another process (if you have an appropriate handle to that
    thread), the primary token being checked is the one assigned to the process that
    encapsulates the thread, and not the primary token of the calling thread. The
    function performs the following verification steps:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查每个验证步骤，并描述它在冒充令牌和主令牌上的考虑。请注意，由于可以将冒充令牌分配给另一个进程中的线程（如果你拥有该线程的适当句柄），因此被检查的主令牌是分配给封装该线程的进程的令牌，而不是调用线程的主令牌。该函数执行以下验证步骤：
- en: 1.  Check for an Identification or Anonymous impersonation level. If the impersonation
    token has one of these levels, assigning it to the thread isn’t a security risk,
    and the SRM immediately allows the assignment. This check also allows assignment
    if the impersonation token represents the anonymous user based on its authentication
    ID.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 检查是否为身份验证或匿名冒充级别。如果冒充令牌具有其中一个级别，将其分配给线程不会构成安全风险，SRM 会立即允许分配。如果冒充令牌代表匿名用户（基于其身份验证
    ID），此检查也会允许分配。
- en: 2.  Check for the impersonate privilege. If <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    is enabled, the SRM again immediately allows the assignment.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 检查是否具有冒充权限。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>被启用，SRM
    将立即允许分配。
- en: 3.  Compare integrity levels of the primary and impersonation tokens. If the
    primary token’s integrity level is less than that of the impersonation token,
    the assignment is denied. If it’s the same or greater, the checks continue.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 比较主令牌和冒充令牌的完整性级别。如果主令牌的完整性级别低于冒充令牌的级别，则拒绝分配。如果相同或更高，则继续进行检查。
- en: 4.  Check that the authentication ID equals the origin ID. If the origin logon
    identifier of the impersonation token equals the authentication identifier of
    the primary token, the SRM allows the assignment. Otherwise, it continues making
    checks.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 检查身份验证 ID 是否等于源 ID。如果冒充令牌的源登录标识符等于主令牌的身份验证标识符，则 SRM 允许分配。否则，它将继续进行检查。
- en: Note that this check has an interesting consequence. As discussed earlier in
    this chapter, the origin logon identifier of normal user tokens is set to the
    authentication identifier of the *SYSTEM* user. This is because the authenticating
    process runs as the *SYSTEM* user. Therefore, the *SYSTEM* user can impersonate
    any other token on the system if it meets the integrity level requirement, even
    if the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    privilege is not enabled.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个检查有一个有趣的结果。如本章前面所述，正常用户令牌的源登录标识符被设置为*SYSTEM*用户的身份验证标识符。这是因为认证过程是以*SYSTEM*用户身份运行的。因此，*SYSTEM*用户可以冒充系统上的任何其他令牌，只要满足完整性级别要求，即使
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp> 权限未启用。
- en: 5.  Check that the user SIDs are equal. If the primary token’s user SID does
    not equal the impersonation token’s user SID, the SRM denies the assignment. Otherwise,
    it continues making checks. This criterion allows a user to impersonate their
    own user account but blocks them from impersonating another user unless they have
    the other user’s credentials. When authenticating the other user, LSASS returns
    an impersonation token with the origin logon identifier set to the caller’s authentication
    identifier, so the token will pass the previous check and the user SIDs will never
    be compared.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  检查用户SID是否相等。如果主令牌的用户SID与冒充令牌的用户SID不相等，SRM将拒绝分配。否则，它将继续进行其他检查。这个标准允许用户冒充自己的用户帐户，但阻止用户冒充其他用户，除非他们拥有其他用户的凭证。在对其他用户进行身份验证时，LSASS会返回一个冒充令牌，其中源登录标识符设置为调用者的身份验证标识符，因此该令牌会通过之前的检查，且用户SID永远不会被比较。
- en: 6.  Check for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp>
    flag. This check ensures that the caller can’t impersonate a more privileged token
    for the same user. If the impersonation token has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp>
    flag set but the primary token does not, the impersonation will be denied. Versions
    of Windows prior to 10 did not perform this check, so previously it was possible
    to impersonate a UAC administrator token if you first reduced the integrity level.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> 标志。此检查确保调用者无法冒充同一用户的更高权限令牌。如果冒充令牌设置了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> 标志，而主令牌没有设置，则冒充将被拒绝。Windows
    10之前的版本未进行此检查，因此之前如果先降低完整性级别，是有可能冒充UAC管理员令牌的。
- en: 7.  Check for sandboxing. This check ensures that the caller can’t impersonate
    a less-sandboxed token. To impersonate a lowbox token, the new token must either
    match the package SID or be a restricted package SID of the primary token; otherwise,
    impersonation will be denied. No check is made on the list of capabilities. For
    a restricted token, it’s enough that the new token is also a restricted token,
    even if the list of restricted SIDs is different. The same applies to write-restricted
    tokens. The SRM has various hardening mechanisms to make it difficult to get hold
    of a more privileged sandbox token.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  检查沙箱隔离。此检查确保调用者无法冒充一个较低沙箱级别的令牌。要冒充低级令牌，新令牌必须匹配软件包SID，或是主令牌的受限软件包SID；否则，冒充将被拒绝。不会检查能力列表。对于受限令牌，只要新令牌也是受限令牌，即使受限SID列表不同，也足够满足条件。写保护令牌也适用相同的规则。SRM有多种加固机制，旨在使获取更高权限的沙箱令牌变得困难。
- en: 8.  Check the console session. This final step checks whether the console session
    is session 0 or not. This prevents a user from impersonating a token in session
    0, which can grant elevated privileges (such as being able to create global <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  检查控制台会话。最后一步检查控制台会话是否为会话0。这可以防止用户冒充会话0中的令牌，因为会话0可能授予提升的权限（例如能够创建全局的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> 对象）。
- en: You might assume that if the function denies the assignment it will return a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT_HELD</samp>
    error, but that is not the case. Instead, the SRM duplicates the impersonation
    token as an Identification-level token and assigns it. This means that even if
    the impersonation assignment fails, the thread can still inspect the properties
    of the token.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为如果函数拒绝分配，它会返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT_HELD</samp>
    错误，但事实并非如此。相反，SRM将冒充令牌复制为标识级令牌并分配它。这意味着即使冒充分配失败，线程仍然可以检查令牌的属性。
- en: You can check whether you can impersonate a token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test
    -NtTokenImpersonation</samp> PowerShell command. This command impersonates the
    token and reopens it from the thread. It then compares the impersonation level
    of the original token and the reopened token and returns a Boolean result. In
    [Listing 4-32](chapter4.xhtml#Lis4-32), we run through a simple example that would
    fall foul of the integrity level check. Note that it’s best not to run this script
    in a PowerShell process you care about, as you won’t be able to restore the original
    integrity level.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Test -NtTokenImpersonation</samp>
    PowerShell 命令检查是否能够模拟令牌。该命令模拟令牌并从线程中重新打开它。然后，它比较原始令牌和重新打开的令牌的模拟级别，并返回布尔结果。在[列表
    4-32](chapter4.xhtml#Lis4-32)中，我们演示了一个简单的示例，可能会被完整性级别检查识别出问题。请注意，最好不要在你关心的 PowerShell
    进程中运行此脚本，因为你将无法恢复原始的完整性级别。
- en: '[PRE35]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 4-32: Checking token impersonation'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-32：检查令牌 impersonation
- en: These checks are quite simple. First we get a duplicate of the current process
    token and pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenImpersonation</samp>.
    The result is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, indicating
    that we could impersonate the token at Impersonation level. For the next check,
    we lower the integrity level of the current process’s primary token to <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    and run the test again. This time it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    as it’s no longer possible to impersonate the token at the Impersonation level.
    Finally, we check if we can impersonate the token at the Identification level,
    which also returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查非常简单。首先，我们获取当前进程令牌的副本，并将其传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenImpersonation</samp>。结果为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，表示我们可以在模拟级别上模拟该令牌。对于下一个检查，我们将当前进程主令牌的完整性级别降低到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> 并再次运行测试。这次返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，因为在模拟级别上已经无法再模拟该令牌。最后，我们检查是否可以在身份验证级别上模拟该令牌，这也返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">实例演示</samp>
- en: Let’s walk through some worked examples so you can see how to use the various
    commands presented in this chapter for security research or systems analysis.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些实例演示，以便你了解如何使用本章中介绍的各种命令进行安全研究或系统分析。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding UI Access
    Processes</samp>
  id: totrans-427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查找 UI 访问进程</samp>
- en: It’s sometimes useful to enumerate all the processes you can access and check
    the properties of their primary tokens. This can help you find processes running
    as specific users or with certain properties. For example, you could identify
    processes with the UI access flag set. Earlier in this chapter, we discussed how
    to check the UI access flag in isolation. In [Listing 4-33](chapter4.xhtml#Lis4-33),
    we’ll perform the check for all processes we can access.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，列举你可以访问的所有进程并检查它们的主令牌属性是很有用的。这可以帮助你找到以特定用户身份或具有某些属性的进程。例如，你可以识别设置了 UI 访问标志的进程。在本章早些时候，我们讨论了如何单独检查
    UI 访问标志。在[列表 4-33](chapter4.xhtml#Lis4-33)中，我们将对所有可以访问的进程进行检查。
- en: '[PRE36]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 4-33: Finding processes with UI access'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-33：查找具有 UI 访问权限的进程
- en: We start by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    command to open all processes with <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>
    access. We also provide a filter script. If the script returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the command will return the process; otherwise, it will close the handle to the
    process.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp> 命令，打开所有具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp> 访问权限的进程。我们还提供了一个筛选脚本。如果脚本返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，该命令将返回该进程；否则，它将关闭对该进程的句柄。
- en: In the script, we open the process’s token for <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    access and return the <samp class="SANS_TheSansMonoCd_W5Regular_11">UIAccess</samp>
    property. The result filters the process list to only processes running with UI
    access tokens. We display the processes we’ve found.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们以 <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> 访问权限打开进程的令牌，并返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UIAccess</samp> 属性。结果会过滤进程列表，只显示带有
    UI 访问令牌的进程。我们显示已找到的进程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Token Handles
    to Impersonate</samp>
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">寻找可以模拟的令牌句柄</samp>
- en: There are several official ways of getting access to a token to impersonate,
    such as using a remote procedure call or opening the process’s primary token.
    Another approach is to find existing handles to <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    objects that you can duplicate and use for impersonation.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种官方的方法可以获取模拟令牌的访问权限，例如使用远程过程调用或打开进程的主令牌。另一种方法是找到现有的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象句柄，这些句柄可以复制并用于模拟。
- en: This technique can be useful if you’re running as a non-administrator user with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    privilege (as in the case of a service account such as *LOCAL SERVICE*), or to
    evaluate the security of a sandbox to make sure the sandbox can’t open and impersonate
    a more privileged token. You can also use this technique to access another user’s
    resources by waiting for them to connect to the Windows machine, such as over
    the network. If you grab the user’s token, you can reuse their identity without
    needing to know their password. [Listing 4-34](chapter4.xhtml#Lis4-34) shows a
    simple implementation of this idea.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以非管理员用户身份运行，并且具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    权限（例如像 *LOCAL SERVICE* 这样的服务帐户），或者为了评估沙箱的安全性，确保沙箱无法打开并模拟更高权限的令牌时，这种技术会很有用。你也可以使用这种技术，通过等待用户连接到
    Windows 机器（例如通过网络）来访问另一个用户的资源。如果你抓取到用户的令牌，你可以在不需要知道其密码的情况下重用他们的身份。[列表 4-34](chapter4.xhtml#Lis4-34)
    展示了这一思想的简单实现。
- en: '[PRE37]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 4-34: Finding elevated Token handles to impersonate'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-34：寻找可以模拟的提升权限令牌句柄
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ImpersonationTokens</samp>
    function, we get a list of all handles of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp> command
    ❶. Then, for each handle, we try to duplicate the handle to the current process
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtObject</samp> command
    ❷. If this succeeds, we test whether we can successfully impersonate the token;
    if so, we make another copy of the token so it doesn’t get closed ❸.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ImpersonationTokens</samp>
    函数中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp> 命令❶
    获取所有类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 的句柄列表。然后，对于每个句柄，我们尝试使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtObject</samp> 命令❷ 将句柄复制到当前进程中。如果成功，我们测试是否能够成功模拟该令牌；如果成功，我们再复制一份令牌，以防它被关闭❸。
- en: Running the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ImpersonationTokens</samp>
    function returns all accessible token handles that can be impersonated ❹. With
    these <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> objects, we can
    query for properties of interest. For example, we can check whether the token
    is elevated or not ❺, which might indicate that we could use the token to gain
    additional privileged groups through impersonation.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ImpersonationTokens</samp>
    函数会返回所有可模拟的可访问令牌句柄❹。通过这些 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象，我们可以查询感兴趣的属性。例如，我们可以检查令牌是否提升❺，这可能表明我们可以使用该令牌通过模拟获得额外的特权组。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Administrator
    Privileges</samp>
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">移除管理员权限</samp>
- en: One thing you might want to do while running a program as an administrator is
    temporarily drop your privileges so that you can perform some operation without
    damaging the computer, such as accidentally deleting system files. To perform
    the operation, you can use the same approach that UAC uses to create a filtered,
    lower-privileged token. Run the code in [Listing 4-35](chapter4.xhtml#Lis4-35)
    as an administrator.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在以管理员身份运行程序时，您可能希望做的一件事是暂时放弃您的权限，以便执行某些操作，而不会对计算机造成损害，比如意外删除系统文件。为了执行该操作，您可以使用
    UAC 创建过滤过的、较低权限的令牌的相同方法。以管理员身份运行[列表 4-35](chapter4.xhtml#Lis4-35)中的代码。
- en: '[PRE38]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 4-35: Removing administrator privileges'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-35：移除管理员权限
- en: We start by filtering the current token and specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp>
    flag. This flag removes all administrator groups and the additional privileges
    that a limited token is not allowed to have. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp>
    flag does not lower the integrity level of the token, so we must set it to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> manually. We can verify
    the token is no longer considered an administrator by checking that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> property is <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先过滤当前令牌并指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp>
    标志。此标志移除了所有管理员组和有限令牌不允许拥有的额外权限。<samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp>
    标志不会降低令牌的完整性级别，因此我们必须手动将其设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>。我们可以通过检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> 属性是否为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    来验证令牌不再被视为管理员。
- en: To see the effect in action, we can now write a file to an administrator-only
    location, such as the *Windows* directory. When we try this using the current
    process token, the operation succeeds. However, when we try to perform the operation
    while impersonating the token, it fails with an access denied error. You could
    also use the token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    PowerShell command to start a new process with the lower-privileged token.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到实际效果，我们现在可以将文件写入仅限管理员访问的位置，比如 *Windows* 目录。当我们尝试使用当前进程令牌时，操作成功。然而，当我们尝试在模拟令牌时执行此操作时，系统会因访问被拒绝错误而失败。您还可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> PowerShell
    命令使用较低权限的令牌启动新进程。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'This chapter introduced the two main types of tokens: primary tokens, which
    are associated with a process, and impersonation tokens, which are associated
    with a thread and allow a process to temporarily impersonate a different user.
    We looked at the important properties of both types of tokens, such as groups,
    privileges, and integrity levels, and how those properties affect the security
    identity that the token exposes. We then discussed the two types of sandbox tokens
    (restricted and lowbox), which applications such as web browsers and document
    readers use to limit the damage of a potential remote code execution exploit.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种主要类型的令牌：与进程相关联的主令牌，以及与线程相关联的模拟令牌，后者允许进程临时模拟另一个用户。我们查看了这两种类型令牌的重要属性，如组、权限和完整性级别，以及这些属性如何影响令牌暴露的安全身份。接着，我们讨论了两种类型的沙箱令牌（受限和低权限沙箱令牌），这些令牌被应用程序（如网页浏览器和文档阅读器）用来限制潜在远程代码执行漏洞的危害。
- en: Next, we considered how tokens are used to represent administrator privilege,
    including how Windows implements User Account Control and split-token administrators
    for normal desktop users. As part of this discussion, we explored the specifics
    of what the operating system considers to be an administrator or elevated token.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑了令牌如何用来表示管理员权限，包括 Windows 如何实现用户帐户控制（UAC）以及为普通桌面用户提供分离令牌管理员功能。作为此讨论的一部分，我们探讨了操作系统如何定义管理员令牌或提升令牌的具体细节。
- en: Finally, we discussed the steps involved in assigning tokens to processes and
    threads. We defined the specific criteria that need to be met for a normal user
    to assign a token and how the checks for primary tokens and impersonation tokens
    differ.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了将令牌分配给进程和线程的步骤。我们定义了普通用户分配令牌所需满足的具体标准，以及主令牌和模拟令牌的检查方式有何不同。
- en: In the next chapter we’re going to discuss security descriptors. These define
    what access will be granted to a resource based on the identity and groups present
    in the caller’s access token.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论安全描述符。这些描述符定义了基于调用者访问令牌中存在的身份和组，资源将授予什么访问权限。
