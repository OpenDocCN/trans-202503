- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 17 FUNDAMENTALS OF THE FOR COMMAND
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17 `for`命令的基础
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: In this chapter, I’ll introduce the for command, in particular, the for command
    used without any options, which just touches on its overall power. This optionless
    command creates loops, where the input is zero to many values, either simple text
    values or filenames. Some call this the *basic* for command, but I chafe at the
    modifier because there’s nothing basic about the for command, even without the
    options (which I’ll discuss in upcoming chapters).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍`for`命令，特别是没有任何选项的`for`命令，它仅仅展示了该命令的整体功能。这个没有选项的命令创建了循环，其中输入可以是零个到多个值，既可以是简单的文本值，也可以是文件名。有些人称之为*基本*的`for`命令，但我不太喜欢这个修饰词，因为即使没有选项（我将在后续章节中讨论），`for`命令也并不“基本”。
- en: Speaking of modifiers in a totally different context, the syntax for this command
    allows for several *modifiers*, and you’ll learn how to use these modifiers to
    extract a wealth of information about any file, such as its size, last modified
    date and time, attributes, and portions of the path and filename. You’ll also
    see a couple detailed real-world applications of the optionless for command as
    a small demonstration of its power, and I’ll start with suggestions on how to
    build personalized documentation about this important command.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 说到修饰符，在完全不同的上下文中，这个命令的语法允许使用多个*修饰符*，你将学习如何使用这些修饰符提取关于任何文件的丰富信息，比如它的大小、最后修改的日期和时间、属性、以及路径和文件名的部分内容。你还会看到几个没有选项的`for`命令在实际中的应用示例，作为它强大功能的一个小展示，我将从如何构建有关这个重要命令的个性化文档开始。
- en: Creating Personalized Documentation
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建个性化文档
- en: 'Before getting started in earnest, I highly recommend dumping the help documentation
    for the for command into a text file for future reference. As you learned in [Chapter
    12](chapter12.xhtml), you can redirect the output for any command to a file, and
    this is true for the help command:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在正式开始之前，我强烈建议将`for`命令的帮助文档导出到一个文本文件中以备将来参考。正如你在[第12章](chapter12.xhtml)中学到的，你可以将任何命令的输出重定向到文件，这对于`help`命令也是适用的：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the use of this path, the command creates the *ForCommand.txt* file on
    my Windows desktop. You can try it with the *OneDrive\* node removed or write
    it to the folder of your choosing, but the desktop is a handy place for this file.
    (You’ll learn about the userprofile pseudo-environment variable in [Chapter 21](chapter21.xhtml).)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个路径，命令会在我的Windows桌面上创建*ForCommand.txt*文件。你可以尝试删除*OneDrive\*节点，或者将其写入你选择的文件夹，但桌面是一个很方便存放这个文件的地方。（你将在[第21章](chapter21.xhtml)中了解userprofile伪环境变量。）
- en: I haven’t suggested that you do this for any other command, and you’ll always
    be able to find the help information at the command prompt, so you might be curious
    why I’m suggesting it here. It’ll eventually become more *self*-documentation
    (like a digital notebook) than *help*-documentation, as you explore and experiment
    more with the for command. Some of the documentation isn’t the clearest and, as
    you’ll soon see, could really use some annotating. With this file, you can add
    your own comments and amend the stated syntax so that it makes more sense to you.
    You can also add examples of the different forms the command can take and include
    templates that you can retrieve and use later.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有建议你对任何其他命令这样做，而且你总是可以在命令提示符下找到帮助信息，所以你可能会好奇为什么我在这里建议这样做。随着你探索和实验`for`命令，这最终将变得更多是*自我*文档（就像一个数字笔记本）而不是*帮助*文档。部分文档并不十分清晰，正如你很快会看到的，确实需要一些注解。通过这个文件，你可以添加自己的评论并修改语法，使其更符合你的理解。你还可以添加命令可以采用的不同形式的示例，并包括你以后可以提取和使用的模板。
- en: Subtle changes in the syntax of the for command will greatly impact its functionality
    or possibly render it inoperable. As a result, all too often coders will take
    a stab at a for command. If that doesn’t work, they’ll take another stab or several,
    adding a certain keyword, using double quotes around the input, or maybe trying
    single quotes. They’ll eventually find something that works or appears to work.
    A better way is to understand the intricacies of the command’s many forms. Create
    this personalized documentation and you’ll have everything you need to know about
    the command in one place (other than this book, of course).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 命令的语法细微变化会极大影响其功能，甚至可能导致其无法工作。因此，程序员常常会尝试编写 `for` 命令。如果第一次不行，他们会继续尝试，可能会添加某些关键字，给输入加上双引号，或者尝试单引号。最终，他们会找到某个有效的或者看似有效的方案。更好的方法是理解这个命令多种形式的复杂性。创建个性化文档，你将能将关于这个命令的所有信息集中在一个地方（当然除了这本书）。'
- en: The Optionless for Command
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无选项 `for` 命令
- en: 'Let’s start with the optionless for command. The for command can be used with
    (appropriately enough) four options, and I’ll delve into those in the next two
    chapters, but even when used without options, it''s a heavy lifter. The following
    isn’t an actual command but is the general syntax used to execute a loop zero
    to many times, and it’s loosely based on what you’ll find in the help documentation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从没有选项的 `for` 命令开始。`for` 命令可以与（恰如其分地）四个选项一起使用，我将在接下来的两章中详细讲解这些选项，但即便不带选项，它依然是个强力工具。以下不是一个实际的命令，而是用于执行循环零次或多次的通用语法，
    loosely 基于帮助文档中找到的内容：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The words for, in, and do are reserved words and will appear just as shown here
    in your for commands. The parentheses also will appear as shown, but what’s inside
    them is one of the three main components of an optionless for. Those components
    are the for variable (%%variable), the input you are feeding into the command
    (input), and the core logic executed in the loop (command).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关键词 `for`、`in` 和 `do` 是保留字，在你的 `for` 命令中将按此方式出现。括号也会如示例所示出现，但括号中的内容是无选项 `for`
    命令的三个主要组成部分之一。这些组成部分分别是 `for` 变量（%%variable）、你传递给命令的输入（input），以及在循环中执行的核心逻辑（command）。
- en: '**The **for** Variable**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**`for` 变量**'
- en: The for variable is central to this command. If the loop executes multiple times,
    its value changes with each pass. You define the for variable as two percent signs
    followed by a singular character. Numbers and many special characters are valid,
    but most coders use letters of the alphabet pretty much universally. Typically,
    %%i is the variable of choice, where i represents *index*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 变量是这个命令的核心。如果循环执行多次，它的值会在每次迭代时发生变化。你通过两个百分号符号加上一个字符来定义 `for` 变量。数字和许多特殊字符都是有效的，但大多数程序员普遍使用字母。通常，`%%i`
    是最常用的变量，其中 `i` 代表 *索引*。'
- en: Some coders use %%i exclusively as if it was the only allowed for variable,
    but don’t limit yourself. A one-character variable name doesn’t allow for a great
    deal of descriptive potential, but use what’s at your disposal. I often use %%f
    for a *file*, %%c for a *count*, and %%n for a *name* or *number*, although %%#
    also works for *number*. As with other variable names, many coders use uppercase,
    but I use lowercase. Do what makes sense to you, and do it consistently.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有些程序员专门使用 `%%i`，好像它是唯一允许的 `for` 变量，但不要局限于此。一个单字符的变量名没有太多的描述潜力，但可以利用手头的工具。我常用
    `%%f` 表示 *文件*，`%%c` 表示 *计数*，`%%n` 表示 *名称* 或 *数字*，虽然 `%%#` 也可以表示 *数字*。与其他变量名一样，很多程序员使用大写字母，但我使用小写字母。做你认为合理的，并且保持一致。
- en: '**The Input**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**'
- en: The second component of the for command is the input found inside the parentheses
    or the input you’re feeding into the command. It can be a set of filenames, a
    single filename, a file mask, multiple file masks, hardcoded text, or resolved
    variables. It’ll be a while before I can show you all of those, so for now, just
    consider it to be the input, starting with a single file. (The help documentation
    uses set instead of input, as in a *set* of files, but that term is incomplete
    and easily confused with the command of the same name.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 命令的第二个组成部分是括号内的输入，或者说你传递给命令的输入。它可以是一组文件名、单个文件名、文件掩码、多个文件掩码、硬编码文本或已解析的变量。要等一段时间才能给你展示所有这些，因此目前先将其视为输入，从单个文件开始。（帮助文档使用
    set 代替输入，像是文件的 *集合*，但这个术语不完整，且容易与同名的命令混淆。）'
- en: '**The Command**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令**'
- en: 'Finally, the command is the core logic that executes for each pass of the loop,
    which can be zero to many times. It can be a single command or many commands spanning
    several lines of code, and anywhere in that logic you can resolve the for variable
    to its current value, but this variable is quite different from variables you’ve
    seen up to this point. Typically, you resolve variables with percent signs, front
    and back, but you resolve the for variable as it’s defined: prefixed with two
    percent signs. More plainly, if you define the for variable as %%n, you can resolve
    it with %%n as part of the command.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，命令是每次循环执行的核心逻辑，可以执行零次或多次。它可以是单个命令，也可以是跨越多行代码的多个命令，在该逻辑中的任何地方，你都可以将 `for`
    变量解析为它的当前值，但这个变量与之前见过的变量完全不同。通常，你使用百分号符号（前后都有）来解析变量，但你按照定义的方式解析 `for` 变量：前缀是两个百分号符号。更简单地说，如果你将
    `for` 变量定义为 `%%n`，你可以在命令中将其解析为 `%%n`。
- en: Similar to the way Batch accepts parameters, a strategically placed tilde removes
    any double quotes encasing the variable. With for variables, the tilde comes after
    the second percent sign and before the variable name—for example, %%~n. As with
    parameters, if there are no double quotes, the tilde has no effect on the resolution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于批处理接受参数的方式， strategically 放置的波浪号（tilde）可以移除围绕变量的双引号。对于 `for` 变量，波浪号出现在第二个百分号符号之后和变量名之前——例如，`%%~n`。与参数类似，如果没有双引号，波浪号对解析没有任何影响。
- en: In a very surprising twist, the for variable is case-sensitive, which is a notable
    oddity in the world of Batch. Therefore, %%i isn’t the same entity as %%I. In
    yet another twist, in [Chapter 14](chapter14.xhtml) you learned to escape a percent
    sign with another percent sign. This variable also sports double percent signs,
    but the interpreter is smart enough to differentiate. For instance, if %%i turns
    out to be a for variable, the interpreter resolves it to its value; if not, the
    interpreter treats the first character as an escape character and resolves it
    to the text, %i. Let’s put this all together into some examples we can actually
    execute.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个非常令人惊讶的转折中，`for` 变量是区分大小写的，这是批处理世界中的一个显著异常。因此，`%%i` 和 `%%I` 不是同一个实体。在另一个转折中，在[第14章](chapter14.xhtml)你学会了如何用另一个百分号转义百分号符号。这个变量也带有双百分号符号，但解释器足够聪明，能够区分它们。例如，如果
    `%%i` 结果是一个 `for` 变量，解释器会将其解析为其值；如果不是，解释器会将第一个字符视为转义字符，并将其解析为文本 `%i`。让我们将这些内容组合成一些实际可执行的示例。
- en: 'The following for command writes the path and filename to the console:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `for` 命令将路径和文件名写入控制台：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For its three components, I’m choosing %%f for the for variable as shorthand
    for *file* because the input is a file, *C:\Batch\MyInputFile.txt*. The command
    component is a single echo command that writes text to the console.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其三个组件，我选择 `%%f` 作为 `for` 变量的简写，表示*文件*，因为输入是一个文件，*C:\Batch\MyInputFile.txt*。命令组件是一个简单的
    `echo` 命令，用于将文本输出到控制台。
- en: 'Before long you’ll see how the for command can create a loop executing multiple
    times, but this example executes exactly once, with the variable set to the path
    and filename inside the parentheses. Moving to the command after the do reserved
    word, the %%f in the echo command resolves to the input text, which writes the
    following to the console:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不久你就会看到 `for` 命令如何创建一个执行多次的循环，但这个例子只执行一次，变量被设置为括号内的路径和文件名。接下来是 `do` 保留字后的命令，`echo`
    命令中的 `%%f` 会解析为输入文本，并将以下内容写入控制台：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the two instances of %%f in the line of code, one close to the beginning
    and a second at the very end. The first defines the for variable, and the second
    instance uses the variable; that is, the command component resolves it and uses
    its value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码行中两个 `%%f` 实例，一个在行首附近，另一个在行末。第一个定义了 `for` 变量，第二个实例使用了该变量；也就是说，命令组件解析它并使用其值。
- en: 'It’s a bit easier to follow if you add parentheses around the echo command,
    which is also legitimate syntax:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 `echo` 命令周围加上括号，会稍微更容易理解，这也是合法的语法：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the command component contains logic that’s at all complex, it’s best to
    rewrite it on multiple lines for the sake of readability.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令组件包含的逻辑稍微复杂一点，最好将其重写为多行代码，以便于阅读。
- en: 'The following example is functionally equivalent to the two previous examples,
    but the echo command is now on its own line. With multiple line syntax, the parentheses
    are required:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在功能上等同于前两个示例，但 `echo` 命令现在独立成一行。使用多行语法时，括号是必需的：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The open parenthesis must follow the do reserved word on the same line. That’s
    an important stipulation because other languages allow, and even encourage, the
    open parenthesis to be on its own line, lined up with the close parenthesis.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 开括号必须紧跟在 `do` 保留字后面，且与其位于同一行。这是一个重要的规定，因为其他语言允许，甚至鼓励，开括号单独位于新的一行，并与闭括号对齐。
- en: 'This next example demonstrates three additional points about the optionless
    for command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子展示了关于无选项 `for` 命令的三个额外要点：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, notice that multiple commands are more than possible in the code block
    of a for command. Second, I changed the for variable to %%F, just to show that
    I can make it pretty much any character that I desire, as long as I consistently
    use %%F or %%~F in the code block (although you won’t see me use a capital for
    this type of variable again). Third, I’ve encased the input path and filename
    in double quotes. Embedded spaces, parentheses, and even plus signs are in the
    path and name of the Notepad++ 32-bit executable, but the interpreter is unfazed
    because of those double quotes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意到 `for` 命令的代码块中可以包含多个命令。其次，我将 `for` 变量改为 `%%F`，只是为了展示我可以将它设为任何我想要的字符，只要在代码块中一致使用
    `%%F` 或 `%%~F`（尽管你不会再看到我用大写字母来表示这种变量）。第三，我将输入路径和文件名括在双引号中。即使路径和文件名中包含空格、括号，甚至加号，解释器也不会受到影响，因为使用了双引号。
- en: 'To demonstrate that the tilde works as it does with parameters, notice that
    the double quotes are present in the output from the first echo command using
    %%F, but not the second using %%~F:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示波浪号与参数的作用，注意到在第一次使用 `%%F` 的 `echo` 命令输出中有双引号，而在第二次使用 `%%~F` 时没有双引号：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This for command might seem like overkill for a single filename as input because
    it most definitely is overkill. You could’ve written these two lines of text to
    the console far more easily with nothing more than two echo commands. The real
    benefit of this logic becomes apparent when you use filesets and file masks to
    execute the loop multiple times, once for each file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个文件名作为输入，这个 `for` 命令看起来可能有些过度，因为它的确是过度的。你完全可以用两个 `echo` 命令更轻松地将这两行文本输出到控制台。这个逻辑的真正优势在于你可以使用文件集和文件掩码来多次执行循环，每个文件执行一次。
- en: NOTE
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The terms for*command *and for* loop *are largely interchangeable, but there’s
    a subtle difference. Technically, loops can execute zero to many times, but I
    often use the term* loop *when, because of the nature of the input, I’m confident
    that it will execute multiple times. Conversely, I use* command *when I know that
    the logic in the code block will execute exactly once, as in all of the previous
    examples, but I also use it if there’s ambiguity since it’s the more general and
    inclusive term.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*“for”命令*和*for*循环*在很大程度上可以互换使用，但存在一个细微的差别。从技术上讲，循环可以执行零次到多次，但我通常在确定输入的性质使得循环会执行多次时，使用*循环*这个术语。相反，我会在知道代码块中的逻辑只会执行一次时使用*命令*，比如在所有之前的例子中，但如果存在歧义，我也会使用这个术语，因为它是更一般且包含的术语。*'
- en: Filesets, File Masks, and Loops
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件集、文件掩码和循环
- en: 'A *fileset* is, as you might expect, a set of files, and the for command accepts
    a fileset as input as easily as it accepts a single file. Two files delimited
    by a comma and a space are in the input fileset here, but you can include any
    realistic number of files:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件集*，正如你可能预期的那样，是一组文件，而 `for` 命令接受文件集作为输入，像接受单个文件一样简单。这里的输入文件集包含两个由逗号和空格分隔的文件，但你可以包含任意数量的文件：'
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A comma without the space would also delimit the two files, as would a space
    without the comma, but both make the code more readable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有空格，仅使用逗号，也可以分隔这两个文件，空格而不使用逗号也是如此，但两者都能使代码更具可读性。
- en: 'Here’s the output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the first example of a for command transformed into something that executes
    more than once—that is, something more often called a for loop. The interpreter
    executes the code block twice because the fileset contains exactly two files.
    A third file in the fileset would have produced a third line of output.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个例子，展示了一个 `for` 命令如何转变为执行多次的操作——也就是更常见的所谓的 `for` 循环。解释器执行代码块两次，因为文件集包含正好两个文件。如果文件集中的文件数为三个，将会生成第三行输出。
- en: In [Chapter 7](chapter7.xhtml), I introduced file masks using wildcards in the
    context of the xcopy and robocopy commands, and the same rules (and batveats)
    apply when you create a file mask as the input to a for command. The asterisk
    stands in for any number of characters, even no characters at all, and the question
    mark usually represents exactly one character. However, question marks coming
    at the end of the mask or followed by a dot, can also represent no character at
    all.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](chapter7.xhtml)中，我介绍了在xcopy和robocopy命令中使用通配符的文件掩码，创建文件掩码作为for命令输入时，适用相同的规则（以及注意事项）。星号代表任意数量的字符，甚至没有字符，问号通常表示恰好一个字符。然而，问号位于掩码末尾或后面跟着点时，也可以表示没有字符。
- en: 'To demonstrate, I’ll start with a familiar for command, replacing the filename
    with the simplest of all masks, a lone asterisk:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我将从一个熟悉的for命令开始，替换文件名为最简单的掩码，即一个孤立的星号：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instead of writing a single filename to the console, the interpreter now outputs
    every file in the folder, one by one, because every file satisfies the mask. If
    there are 17 files in *C:\Batch\*, all 17 fit the mask, and the interpreter writes
    a message to the console for all 17\. The echo command executes just once if only
    one file exists in the folder, and it doesn’t execute at all if no files exist.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，解释器不会再将单个文件名写入控制台，而是会将文件夹中的每个文件逐一输出，因为每个文件都符合掩码。如果*C:\Batch\*中有17个文件，所有17个文件都符合掩码，解释器会为所有17个文件写一条消息到控制台。如果文件夹中只有一个文件，echo命令只会执行一次，如果没有文件，echo命令则完全不执行。
- en: 'Writing filenames to the console isn’t very satisfying, but you can perform
    far more interesting tasks with file masks. You might rename every file that satisfies
    a mask, or you might call a compiled program once for each file. Whatever the
    task, the basic structure of the for loop won’t change, and if the logic is going
    to be at all complex, it’s best to set it up in an internal routine. Here’s a
    call command invoking just such a routine for each file, passing the path and
    filename of each file as the sole argument:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件名输出到控制台并不是很令人满足，但你可以使用文件掩码执行更有趣的任务。你可以重命名满足掩码条件的每个文件，或者可能为每个文件调用一次编译程序。无论任务是什么，for循环的基本结构都不会改变，如果逻辑会比较复杂，最好将其设置为内部例程。这里是一个调用命令，它为每个文件调用这样的例程，并将每个文件的路径和文件名作为唯一参数传递：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If a dozen files fit this mask, the call command invokes the routine 12 times,
    once for each file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有十几个文件符合此掩码，call命令会调用例程12次，每次针对一个文件。
- en: Batch even accepts a comma-delimited list of file masks as input to a for command.
    That is, you can create a fileset containing multiple files and/or file masks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Batch甚至接受以逗号分隔的文件掩码列表作为for命令的输入。也就是说，你可以创建一个包含多个文件和/或文件掩码的文件集。
- en: Simple Text as Input
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单文本作为输入
- en: 'Another intriguing use of the optionless for command isn’t found in the help.
    You can process a list of values one by one by entering them inside the parentheses
    as the input. The same set of characters that Batch uses for delimiting passed
    arguments also delimits this list, so you can use commas, semicolons, equal signs,
    and tab characters, but a space-delimited list is the norm. The syntax is similar
    to several previous examples, but with the delimited text replacing the filename
    or mask. For example, this for loop sequentially passes each of the five words
    in the parentheses to the code block:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的无选项for命令的用法在帮助文档中找不到。你可以通过将值逐一放入括号内作为输入，处理一个值的列表。Batch用于分隔传递参数的字符集也用于分隔此列表，所以你可以使用逗号、分号、等号和制表符，但空格分隔的列表是常见的做法。语法与之前几个示例类似，但分隔的文本替代了文件名或掩码。例如，这个for循环会依次将括号中的五个单词传递给代码块：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result sees each word written to the console on individual lines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是每个单词都会被逐行写入控制台：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that Batch treats the for inside the parentheses as simple text and not
    as the reserved word that starts the command. I’ve taken some shots at the interpreter,
    but it’s smart enough to recognize the difference contextually.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Batch将括号内的for视为简单文本，而不是作为启动命令的保留字。我曾对解释器提出过一些质疑，但它足够聪明，能够根据上下文区分这些差异。
- en: 'The prior input list is space-delimited, but the interpreter treats anything
    encased in double quotes as a single value, meaning that the following for command
    executes its code block exactly twice:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的输入列表是以空格分隔的，但解释器会将双引号包围的内容视为一个单独的值，这意味着以下for命令会执行两次其代码块：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result is these two lines of output to the console, not seven:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是这两行输出到控制台，而不是七行：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the use of a tilde when resolving the for variable, %%~i, removes
    the double quotes from each string.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用波浪符号 `~` 解析 `for` 变量时，`%%~i` 会去掉每个字符串中的双引号。
- en: These simple examples belie the immense usefulness of the technique. To illustrate,
    I’ll start with a bat file that accepts a single parameter for some sort of processing.
    The process isn’t important here; maybe the passed value is added to a data structure,
    or maybe it’s a filename passed to a called executable. Whatever the process,
    the point is that if I have 17 items to process, I must call the bat file 17 times.
    But with this technique of using a list as input to a for command, I can enhance
    the bat file so that it’ll accept any number of these parameters and process them
    one by one in a single execution.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的示例掩盖了该技巧的巨大实用性。为了说明这一点，我将从一个接受单个参数进行处理的 bat 文件开始。这里的处理过程不重要；也许传递的值会被添加到数据结构中，或者它是一个传递给可执行文件的文件名。无论是什么处理过程，关键在于，如果我有
    17 项需要处理，我必须调用 bat 文件 17 次。但使用这个将列表作为 `for` 命令输入的技巧，我可以增强 bat 文件，使其能够接受任意数量的参数，并在一次执行中逐一处理它们。
- en: 'I’ll start by putting the logic for processing a single parameter into a callable
    routine defined by the :ProcessParm label. Now I can call that routine zero to
    many times with this code at the top of my bat file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先把处理单个参数的逻辑放入一个可调用的例程中，并通过 `:ProcessParm` 标签进行定义。现在，我可以通过在 bat 文件顶部加入以下代码，调用该例程零次或多次：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I’ve entered %* into the parentheses as the input of the for command. (Remember
    from [Chapter 11](chapter11.xhtml) that these two bytes expand to the entire parameter
    list as received by the bat file.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我在括号中输入了 `%*` 作为 `for` 命令的输入。（记住在[第 11 章](chapter11.xhtml)中，`%*` 会扩展为 bat 文件接收到的完整参数列表。）
- en: If there are 99 parameters, all 99 values become the input to the for command,
    and the interpreter executes the body of the loop 99 times. In its first pass,
    %%i resolves to the first parameter in the list and is the argument passed to
    the routine in the call command. After the first pass completes, the second parameter
    becomes the argument for the second pass, and so on, until the interpreter processes
    all 99 parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有 99 个参数，所有 99 个值都会作为 `for` 命令的输入，解释器会执行循环体 99 次。在第一次执行时，`%%i` 解析为列表中的第一个参数，并作为参数传递给调用命令中的例程。第一次执行完后，第二个参数成为第二次执行的参数，以此类推，直到解释器处理完所有
    99 个参数。
- en: Other uses for this technique abound. For instance, you can easily sum up a
    space-delimited list of numbers. I haven’t introduced arrays yet, but this offers
    a great means of adding multiple values to an array.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技巧的其他用途也很多。例如，你可以轻松地对一个空格分隔的数字列表求和。我还没有介绍数组，但这提供了一种很好的方法来将多个值添加到数组中。
- en: Retrieving File Information
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索文件信息
- en: 'The optionless for command has one more awesome feature. It can retrieve copious
    amounts of information and data about a file, such as its size, last modified
    date/time, and much more. Earlier in this chapter, I discussed using the technique
    of passing a filename into a for loop for the unimpressive purpose of simply writing
    the path and filename to the console. For example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 无选项的 `for` 命令还有一个更棒的功能。它可以检索关于文件的大量信息和数据，比如文件大小、最后修改日期/时间等等。在本章前面，我讨论了将文件名传递给
    `for` 循环的技巧，目的是简单地将路径和文件名写入控制台。例如：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let’s turn that into something impressive. Instead of just regurgitating a path
    and filename, the code will retrieve and write out an abundance of information
    about the file. If the file has something to hide, we’ll expose it. The only changes
    I’ll eventually make to the code in the previous example is to the code block
    associated with the for command, but first I must introduce modifiers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个变得更有意义。代码不再只是简单地回显路径和文件名，而是检索并输出关于文件的大量信息。如果文件有什么需要隐藏的，我们就把它暴露出来。我最终对前面示例中的代码所做的唯一修改是与
    `for` 命令相关的代码块，但在此之前，我必须先介绍修饰符。
- en: Modifiers
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修饰符
- en: The tools for extracting this bevy of useful data about a file are called *modifiers*,
    and 9 out of 10 of them are a single alpha character strategically inserted into
    the for variable as it’s being resolved. (I’ll get to the 10th one soon.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 提取文件有用数据的工具被称为 *修饰符*，其中 9 个修饰符都是单个字母字符，巧妙地插入到 `for` 变量中进行解析。（我很快就会介绍第十个修饰符。）
- en: To use a modifier, start with a for variable such as %%f. Then insert a tilde
    and the modifier character after the two percent signs and before the one-character
    variable name. For instance, X is the modifier for retrieving a file’s extension,
    meaning that for the for variable, %%f, the interpreter resolves %%~Xf to the
    extension.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用修饰符，请从一个 for 变量（例如 %%f）开始。然后在两个百分号之间和一个字符变量名之前插入波浪号和修饰符字符。例如，X 是用于检索文件扩展名的修饰符，这意味着对于
    for 变量 %%f，解释器将 %%~Xf 解析为扩展名。
- en: 'The following code block now has 11 echo commands. The first two are nothing
    new; they both display the path and filename, the first with the double quotes
    in place and the second with them removed. The nine other echo commands use a
    specific modifier to, understandably enough, modify the %%f variable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块现在有 11 个 echo 命令。前两个没有什么新意；它们都显示路径和文件名，第一个带双引号，第二个去除了双引号。其他九个 echo 命令使用特定的修饰符来修改
    %%f 变量，这一点很容易理解：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I’ve documented each of the nine modifiers in the code itself.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我在代码中已记录了这九个修饰符。
- en: 'Executing this code might write the following text to the console. Carefully
    examine the impact of each modifier on the output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码可能会将以下文本写入控制台。仔细检查每个修饰符对输出的影响：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s quite a bit of data. Starting with the third line, the F modifier gives
    us the fully qualified pathname. Often, %%~Ff resolves to the same value as %%~f
    as it does here, but not always. If the input consists of a filename and extension
    without a path and if the interpreter finds the file in the current directory,
    then %%~f mimics the input without the path, but %%~Ff resolves to the full path
    and filename.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是相当多的数据。从第三行开始，F 修饰符为我们提供了完全限定的路径名。通常，%%~Ff 解析出的值与 %%~f 相同，正如这里所示，但并非总是如此。如果输入仅由文件名和扩展名组成，没有路径，并且解释器在当前目录中找到了该文件，那么
    %%~f 会模拟输入，省略路径，而 %%~Ff 会解析为完整的路径和文件名。
- en: 'Next, you can see the individual components of this fully qualified pathname
    in the next four modifiers: D (drive letter with the colon), P (path or directory
    without the drive letter), N (bare filename—that is, without the extension), and
    the aforementioned X (file extension, including the preceding dot).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以在接下来的四个修饰符中看到这个完全限定路径名的各个组成部分：D（带冒号的驱动器字母）、P（没有驱动器字母的路径或目录）、N（裸文件名——即没有扩展名）、以及前面提到的
    X（文件扩展名，包括前面的点）。
- en: The S modifier generates the short filename defined by the operating system
    (I promised I’d show you how to find this in [Chapter 7](chapter7.xhtml)), while
    the A modifier generates a list of file attributes. A file has 11 possible attributes,
    and if the file doesn’t have a particular attribute, the corresponding byte is
    a dash. The only attribute that pops in this list is a, meaning that the file
    is archived, but the lack of other values indicates that the file isn’t hidden,
    compressed, read only, or characterized by any of the other possible attributes.
    (I’ll discuss attributes more in [Chapter 30](chapter30.xhtml).)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: S 修饰符生成操作系统定义的短文件名（我答应过会在[第7章](chapter7.xhtml)中展示如何找到这个文件名），而 A 修饰符生成文件属性的列表。一个文件有
    11 种可能的属性，如果文件没有某个特定属性，相应的字节会显示为破折号。此列表中唯一显示的属性是 a，表示文件被归档，但缺少其他值意味着文件不是隐藏的、压缩的、只读的，也不具有其他任何可能的属性。（我将在[第30章](chapter30.xhtml)中进一步讨论属性。）
- en: Finally, the T modifier provides the date and time when the file was last modified,
    and the Z modifier returns the file size in bytes. (Remember that S is taken.)
    The lack of commas makes it hard to read, but you can see from the output that
    the file is nearly 3MB.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，T 修饰符提供了文件最后修改的日期和时间，而 Z 修饰符返回文件大小（以字节为单位）。(记住，S 已被占用。)缺乏逗号使得输出不易读取，但从输出中可以看到文件接近
    3MB。
- en: NOTE
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Unless you’ve jumped directly to this portion of the book, you know that I’m
    not a fan of the overuse of capitalization, but everything has its place. The
    modifiers are case-insensitive, but I use uppercase to make them stand out. The
    lowercase for variable, which in this case is f for* file*, terminates what’s
    to be resolved, but I know that I’m in the minority. Be aware that most coders
    do just the opposite, so you’re more likely to see %%~zI to get the file size
    of %%I than my %%~Zf used to get the size of %%f.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非你直接跳到本书的这一部分，否则你应该知道我并不喜欢过度使用大写字母，但每种方式都有其适用的场合。修饰符不区分大小写，但我使用大写字母来使它们更加显眼。小写字母的变量，在这种情况下是
    *f* 代表文件，终结了需要解析的内容，但我知道我是少数派。请注意，大多数程序员会做相反的操作，所以你更可能看到 %%~zI 来获取 %%I 的文件大小，而不是我用来获取
    %%f 文件大小的 %%~Zf。*'
- en: 'The applications of modifiers are boundless, but one simple use is to execute
    some sort of complex task for a file, but only if the file has data in it. Say
    the Batch code is to process a data file coming from another source. Even if the
    source has no data to report, it’s best for it to create an empty file, because
    no file at all would leave the specter of a failed process. To make this work,
    the bat file needs to determine whether the file is empty or populated. Consider
    this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符的应用几乎是无限的，但一个简单的用途是对文件执行某种复杂的任务，但前提是文件中有数据。假设批处理代码是处理来自其他来源的数据文件。即使来源没有数据可报告，最好也让它创建一个空文件，因为根本没有文件将意味着一个失败的进程。为了使其生效，bat文件需要判断文件是空的还是已填充数据。考虑以下内容：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The if command inside the for command efficiently (and maybe even elegantly)
    verifies that the size of an intermediate data file, %%~Zf, is greater than 0
    bytes before calling a routine and passing it the path and name of the file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: for命令内部的if命令有效地（甚至可能优雅地）验证了中间数据文件%%~Zf的大小是否大于0字节，只有在通过验证后，才会调用一个例程并传递文件的路径和名称。
- en: The path Modifier
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 路径修饰符
- en: I owe you a 10th modifier, and just in case you haven’t found this syntax convoluted
    enough, the syntax for the path modifier is completely different from the other
    nine. But that’s not a problem, because its function is also completely different.
    I’ll explain what it does momentarily, but first understand that this modifier
    is actually an oddly delimited variable. While the other modifiers are each a
    single character, the path modifier is a variable name preceded by a dollar sign
    and trailed by a colon.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我欠你一个第十个修饰符，万一你还没有觉得这个语法足够复杂，路径修饰符的语法与其他九个完全不同。但这并不是问题，因为它的功能也完全不同。我会稍后解释它的作用，但首先要理解的是，这个修饰符实际上是一个奇特的分隔变量。其他修饰符都是单一字符，而路径修饰符是一个以美元符号开头并以冒号结尾的变量名。
- en: 'To set this up, and for reasons that will soon become obvious, let’s use the
    path variable in the modifier (the same variable containing a concatenation of
    semicolon-delimited directories introduced in [Chapter 8](chapter8.xhtml)). The
    variable should already be set on your machine, but you can append and prepend
    additional directories to it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这个，且为了马上就能明白的原因，让我们在修饰符中使用路径变量（与[第8章](chapter8.xhtml)中介绍的包含由分号分隔的目录的连接的相同变量）。这个变量应该已经在你的机器上设置好了，但你可以向其中添加或前置额外的目录：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To see this modifier in action, let’s modify the %%f variable with the %%~$path:f
    syntax. Notice the path variable, sandwiched between the $ and : characters; all
    three pieces make up the modifier. Now we can use it in a for command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个修饰符的实际效果，让我们使用%%~$path:f语法修改%%f变量。注意路径变量夹在$和:字符之间；这三个部分组成了修饰符。现在我们可以在for命令中使用它：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What’s this modifier’s actual function? It instructs the interpreter to traverse
    the path variable, starting from its first listed directory, looking for the first,
    and only the first, file named *FourBrits.txt*. If the file exists in the second
    directory in our path variable, but not the first, the resulting output contains
    the fully qualified path and filename:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修饰符的实际功能是什么？它指示解释器遍历路径变量，从其中列出的第一个目录开始，寻找第一个（并且只有第一个）名为*FourBrits.txt*的文件。如果该文件存在于路径变量的第二个目录中，但不在第一个目录中，结果输出将包含完整的路径和文件名：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the interpreter can’t find a file named *FourBrits.txt* in any of the directories
    defined in the path variable, it simply resolves %%~$path:f to null.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解释器在路径变量定义的任何目录中找不到名为*FourBrits.txt*的文件，它会简单地将%%~$path:f解析为null。
- en: This functionality was clearly designed for the path variable, and the help
    documentation explicitly uses the path variable in its example; only near the
    bottom does it mention that you can replace it with any valid variable, meaning
    any variable containing a list of directories. Even so, this is usually referred
    to simply as the *path* modifier and used nearly exclusively with the path variable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能显然是为路径变量设计的，帮助文档在示例中明确使用了路径变量；只有在文档底部才提到，你可以用任何有效的变量替换它，意味着任何包含目录列表的变量。尽管如此，它通常只是被称为*路径*修饰符，并几乎专门用于路径变量。
- en: Stacked Modifiers
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 堆叠修饰符
- en: 'Used individually the modifiers are very helpful, but their real power becomes
    apparent when you stack multiple modifiers—that is, when used together to resolve
    more than one file characteristic at a time. For instance, you can resolve the
    filename and extension separately and then concatenate them as %%~Nf%%~Xf, but
    that’s a tad bit messy. Instead, %%~NXf sublimely produces the identical result
    more elegantly. Here are three typical examples:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用时，这些修饰符非常有用，但它们的真正威力在于将多个修饰符叠加使用时展现出来——也就是说，当它们一起使用时，可以一次解决多个文件特性。例如，你可以分别解析文件名和扩展名，然后将它们拼接为%%~Nf%%~Xf，但这有点混乱。相反，%%~NXf巧妙地以更优雅的方式产生相同的结果。以下是三个典型的例子：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code might write the following to the console:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能会向控制台输出以下内容：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With stacked modifiers you can easily retrieve the full path of a file without
    the filename, or just the filename and extension without the path. The last example
    might look good on a report with the hardcoded text, bytes, at the end.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用叠加修饰符，你可以轻松获取文件的完整路径而不带文件名，或者仅获取文件名和扩展名而不带路径。最后一个示例可能会在报告中显示，并在结尾添加硬编码的文本“bytes”。
- en: 'Stacked modifiers even work with the path modifier:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 叠加修饰符甚至可以与路径修饰符一起使用：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code writes out the full path, sans the filename and extension, of the
    first file found in the path hierarchy named *FourBrits.txt*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码输出在路径层级中找到的第一个文件的完整路径，不包括文件名和扩展名，该文件名为*FourBrits.txt*。
- en: Parameters with Modifiers
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带修饰符的参数
- en: Before getting into a couple of real-world examples, I’ll return to a discussion
    on parameters from [Chapter 11](chapter11.xhtml). It turns out that the modifiers
    that extract file information in the context of for commands work equally well
    on parameters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入几个实际示例之前，我将回到[第11章](chapter11.xhtml)关于参数的讨论。事实证明，提取文件信息的修饰符在for命令的上下文中同样适用于参数。
- en: 'I had mentioned that you can pass filenames, with or without their paths, as
    arguments to a bat file and that the called bat file can resolve them with %~1,
    %~2, and so on. Also, you can resolve %~0 to the full path and filename of the
    bat file being executed. Well, the same modifiers (and stacked modifiers) just
    discussed also apply to any parameter that represents a file. Assume that the
    following code receives the names of two files as its first two parameters:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾提到过，你可以将带或不带路径的文件名作为参数传递给批处理文件，并且被调用的批处理文件可以通过%~1、%~2等解析它们。此外，你还可以将%~0解析为正在执行的批处理文件的完整路径和文件名。好吧，前面讨论的相同修饰符（以及叠加修饰符）也适用于任何代表文件的参数。假设以下代码接收两个文件名作为前两个参数：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first command writes out the size in bytes of the first file, and the second
    command writes out the last modified date and time of the second file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令输出第一个文件的字节大小，第二个命令输出第二个文件的最后修改日期和时间。
- en: Attach two specific stacked modifiers to the hidden parameter, and %~DP0 resolves
    to the drive letter and path of the bat file being executed. With this information,
    you can create a subdirectory, deposit other files in this or sibling directories,
    or update a logfile associated with the bat file, and you can do this without
    knowing where the bat file will eventually be installed. Maybe it will live on
    multiple servers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个特定的叠加修饰符应用于隐藏参数，%~DP0 解析为正在执行的批处理文件的驱动器字母和路径。凭借这些信息，你可以创建子目录，将其他文件存放在此目录或兄弟目录中，或者更新与批处理文件相关的日志文件，而且不需要知道批处理文件最终将安装在哪里。也许它会部署在多台服务器上。
- en: Modifiers allow you to retrieve a great deal of file information with minimal
    keystrokes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符允许你通过最少的键盘操作检索大量的文件信息。
- en: Real-World Applications
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际应用
- en: Let’s put all of the useful tools that you’ve just learned in this chapter to
    use in two real-world examples.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在两个实际示例中应用你刚刚在本章中学到的所有有用工具。
- en: Renaming Files on a Backup
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 备份中的文件重命名
- en: With the use of a file mask, the optionless for command can generate a list
    of files, and the modifiers can extract the individual components of the path
    and filename of each. Combining both of those features, you can copy a set of
    files to a mirror folder structure on another drive, all while tweaking the target
    filenames.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件掩码，无需选项的for命令可以生成文件列表，而修饰符可以提取每个文件路径和文件名的各个组件。结合这两种功能，你可以将一组文件复制到另一个驱动器上的镜像文件夹结构中，同时调整目标文件名。
- en: 'Assume that I have a folder called *C:\Budget\* that unsurprisingly contains
    budget information. The name certainly suggests a directory that should be backed
    up, perhaps to an external *D:\* drive, but with the exact same folder structure
    so that the files are easy to find and compare. To complicate matters, I’d like
    to prepend the name of every file with Bkup_, because when both folders are open,
    it’s far too easy to work in the wrong one, but not if every file in the backup
    directory starts with this unique and descriptive text. One way to accomplish
    this task is with a single command inside a for loop (although in the real-real-world,
    you’ll want some error handling):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个名为*C:\Budget\*的文件夹，顾名思义，它包含预算信息。这个文件夹的名称显然表示应该进行备份，可能是备份到外部*D:\*驱动器，但保持相同的文件夹结构，以便文件容易找到和比较。更复杂的是，我希望在每个文件名前添加Bkup_，因为当两个文件夹同时打开时，很容易在错误的文件夹中工作，但如果备份目录中的每个文件都以这个独特且具描述性的文本开头，就不容易出错。完成这个任务的一种方法是在`for`循环中使用单个命令（尽管在实际的实际应用中，你可能需要一些错误处理）：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'I’ve encased both the source and destination in double quotes to accommodate
    the possibility of embedded spaces in a filename. The source is the fully qualified
    path and filename, %%~Ff, but the destination is a bit more esoteric. While it
    might look like random keystrokes, it’s really a concatenation of four items that
    become more readable when I bolded the two for variables using modifiers in contrast
    to the constants:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将源路径和目标路径都用双引号括起来，以处理文件名中可能包含空格的情况。源路径是完全限定的路径和文件名，%%~Ff，但目标路径则稍微复杂一些。尽管它看起来像是随机的按键输入，实际上它是四个项目的拼接，当我加粗了两个带修饰符的`for`变量与常量的对比时，它变得更易读：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The destination path starts with the hardcoded drive letter and a colon, D:,
    followed by the path of the source file variable without the drive letter, %%~Pf;
    this mimics the source folder from the original drive. The path starts and ends
    with a backslash, so what comes next, Bkup_, is the start of the filename. To
    complete the target filename, the interpreter finds a second for variable, %%~NXf,
    this one having stacked modifiers for the source filename (N) and file extension
    (X).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 目标路径以硬编码的驱动器字母和冒号D:开头，后跟源文件变量的路径，去掉了驱动器字母%%~Pf；这模仿了源驱动器中的源文件夹。路径的开始和结束都有反斜杠，因此接下来的是文件名的开始部分Bkup_。为了完成目标文件名，解释器找到第二个`for`变量，%%~NXf，这个变量包含了源文件名（N）和文件扩展名（X）的堆叠修饰符。
- en: 'Putting it all together, if the interpreter finds a file named *C:\Budget\Budget.January2023.xlsx*,
    the resulting destination string is:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 综合起来，如果解释器找到一个名为*C:\Budget\Budget.January2023.xlsx*的文件，结果目标字符串是：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Where the variable names start and end can be confusing if you’re used to Batch
    variables that are delimited by percent signs. When the compiler sees %%~, it
    knows that it’s about to resolve a for variable—that’s the start. Because the
    variable defined by this for command is %%f, the interpreter terminates the variable
    when it finds a lowercase f—that’s the end. In between the start and end, the
    interpreter looks for zero to a few valid modifiers. Anything after its termination
    could be constants, a single percent sign starting the resolution of a more traditional
    Batch variable, or another for variable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了由百分号分隔的批处理变量，变量的起始和结束位置可能会让你感到困惑。当编译器看到%%~时，它知道接下来将解析一个`for`变量——那是开始的位置。由于由这个`for`命令定义的变量是%%f，解释器会在看到小写字母f时结束该变量——那是结束的位置。在开始和结束之间，解释器会查找零个或几个有效的修饰符。终止后的部分可能是常量，一个百分号符号开始解析一个更传统的批处理变量，或者是另一个`for`变量。
- en: Each and every file in the source directory matching the mask is copied to the
    backup path on the *D:\* drive with the name of the destination file tweaked.
    This tool is very powerful with a lot going on inside an apparently modest for
    command, but to harness that power, a deep understanding of the syntax is a must.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 源目录中每个符合条件的文件都会被复制到*D:\*驱动器的备份路径，并且目标文件的名称会经过调整。这个工具非常强大，虽然看起来只是一个简单的`for`命令，但要充分利用它的能力，必须对语法有深入的理解。
- en: Processing a Variable Number of Files
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理可变数量的文件
- en: At the end of [Chapter 11](chapter11.xhtml), I introduced the concept of a *wrapper*
    bat file—that is, a bat file that does little more than execute a program designed
    to process a single input file. The bat file is a wrapper around the executable.
    Also in that chapter, I demonstrated how to drag and drop multiple files onto
    a bat file, resulting in one execution of the bat file with multiple arguments.
    As impressive as that is, it’s of little use without a bat file that not only
    can handle all of those parameters but can do so for a variable number of parameters.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](chapter11.xhtml)的末尾，我介绍了*包装器*批处理文件的概念——即一个批处理文件，它所做的几乎只是执行一个处理单个输入文件的程序。这个批处理文件是可执行文件的包装器。在那一章中，我还演示了如何将多个文件拖放到一个批处理文件上，从而使得批处理文件执行一次并带有多个参数。尽管这很令人印象深刻，但如果没有一个能够处理所有这些参数的批处理文件，或者能够处理不同数量参数的批处理文件，这个技巧就几乎没有用处。
- en: In this chapter, I’ve discussed two important concepts that are applicable to
    building such a wrapper bat file. One is the immensely useful technique of using
    modifiers on a parameter to extract file information, and the other is the for
    command’s ability to process a list of values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了两个对于构建此类包装器批处理文件非常重要的概念。一个是使用修饰符提取文件信息的非常有用的技巧，另一个是for命令处理值列表的能力。
- en: 'Now, for the setup. I’ve created a compiled program to convert Java code to
    C# code, and it accepts two arguments: the input file followed by the output file.
    Code conversion programs can help minimize the pain of updating old code to a
    newer language. A module of one language is the input to the program that converts
    much of the original syntax to another language, outputting a file of the same
    name but with a different extension in the same folder. From the perspective of
    the bat file, it accepts one to many *.java* files as parameters, determines the
    path and filename of the corresponding *.cs* output files, and invokes the compiled
    code with those two arguments—and the *.java* files can be in any folder.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来介绍一下设置。我创建了一个已编译的程序，用于将Java代码转换为C#代码，并且它接受两个参数：输入文件和输出文件。代码转换程序可以帮助减少将旧代码更新为新语言时的麻烦。一个语言的模块作为输入传递给程序，该程序将原始语法的大部分转换为另一种语言，并在相同的文件夹中输出一个同名但扩展名不同的文件。从批处理文件的角度来看，它接受一个或多个*.java*文件作为参数，确定相应的*.cs*输出文件的路径和文件名，然后使用这两个参数调用已编译的代码——而这些*.java*文件可以在任何文件夹中。
- en: 'The following bat file, stripped of all error handling and comments, does everything
    desired. The for command accepts the entire list of parameters as %*, passing
    them one by one into the code block as %%f, which in turn is the sole argument
    passed to the :ConvOneFile routine:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个批处理文件，去除了所有错误处理和注释，它完成了所有期望的功能。for命令接受整个参数列表作为%*，将它们一个个传递到代码块中作为%%f，后者则是传递给:ConvOneFile例程的唯一参数：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When invoking *ConvJava2CS.exe*, this Batch code passes it two arguments, the
    input and output files, respectively. I’m retrieving the fully qualified name
    of the input file with %~F1, which is the first parameter with the F modifier.
    The output path and filename, %~DPN1.cs, is more complex. I’m using the same parameter,
    namely, %~1, but with the modifiers for the drive (D), path (P), and filename
    (N)—that is, %~F1 without the extension denoted by the X modifier. Then I tack
    on the new extension with the hardcoded .cs to create the output filename. Notice
    that a single percent sign, not two, is leading these variables, because these
    are parameters, not for variables; I’m calling the executable from inside a routine,
    not inside the for command.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用*ConvJava2CS.exe*时，这段批处理代码将输入文件和输出文件作为两个参数传递给它。我使用%~F1获取输入文件的完整文件名，这是第一个参数加上F修饰符。输出路径和文件名%~DPN1.cs则更为复杂。我使用相同的参数，也就是%~1，但加上了驱动器（D）、路径（P）和文件名（N）的修饰符——也就是说，%~F1去掉扩展名（通过X修饰符表示）。然后，我再加上硬编码的.cs扩展名，形成输出文件名。注意，这些变量前面只有一个百分号，而不是两个，因为这些是参数，不是变量；我在一个例程中调用可执行文件，而不是在for命令中。
- en: A critic (or maybe someone not versed in Batch) might balk at this, arguing
    that it’s better or easier to accept a single parameter into the compiled code
    and do the manipulation of the filename in the program. But this approach is inflexible;
    if someone else wanted to run this process on scores or even hundreds of files,
    they might want the output dropped into a subfolder, or even a folder on another
    server. By manipulating the filenames in the Batch code, dropping the output into
    a subdirectory doesn’t require a change to the compiled code; instead, simply
    change %~DPN1.cs to %~DP1%subDir%\%~N1.cs. You could define a hardcoded subdirectory,
    but here I’m using subDir as the variable for the subdirectory node. You can even
    execute an md command with %~DP1%subDir%\ as its argument to create the subdirectory
    if it doesn’t already exist.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个评论家（或者可能是一个不熟悉批处理的人）可能会对此提出异议，认为接受编译代码中的单个参数并在程序中进行文件名操作更好或更容易。但这种方法缺乏灵活性；如果其他人希望在许多文件甚至数百个文件上运行此过程，则可能希望将输出放入子文件夹，甚至放在另一个服务器上的文件夹中。通过在批处理代码中操作文件名，将输出放入子目录无需更改编译代码；而是简单地将%~DPN1.cs更改为%~DP1%subDir%\%~N1.cs。您可以定义一个硬编码的子目录，但在这里我使用subDir作为子目录节点的变量。如果子目录不存在，甚至可以执行带有%~DP1%subDir%\作为其参数的md命令来创建子目录。
- en: There’s always overhead with changes to compiled code, even simple ones. You
    have to run the compiler and take care to keep the source and executable in sync.
    Whenever possible, coders should make simple changes, such as deriving file connectors
    or filenames, in the Batch code, in my humble opinion at least.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是对编译代码的简单更改，也总会有额外开销。您必须运行编译器并注意保持源代码和可执行文件同步。在可能的情况下，编码人员应该进行简单的更改，例如在批处理代码中获取文件连接器或文件名，至少在我看来是如此。
- en: You can now use this bat file to process multiple files or a single file or
    even no files. If no arguments are passed, the for command has no input, and the
    code block never executes. Once again, just a few lines of code are doing much
    more than first meets the eye.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用此批处理文件处理多个文件或单个文件，甚至不处理任何文件。如果没有传递参数，for命令就没有输入，并且代码块永远不会执行。再次强调，几行代码正在执行比眼前看到的更多的工作。
- en: Resolving Variables in Code Blocks
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在代码块中解析变量
- en: Before moving forward with all of the functionality and power that you can unlock
    from the for command with options, I must mention that up to this point I’ve resolved
    variables for a single use inside of a code block associated with a for command,
    but this is hopelessly simplistic and naive. It’s far more common to assign a
    piece of data to a variable and then use it, and maybe even modify it, all inside
    a complex code block. This is the same type of code block detailed in [Chapter
    16](chapter16.xhtml), and the same rules concerning how to resolve variables apply.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续解锁for命令选项提供的所有功能和强大功能之前，我必须提到，到目前为止，我已经解析了与for命令相关联的代码块内部的单一用途变量，但这太过简单和幼稚。更常见的做法是将数据分配给一个变量，然后在复杂的代码块内使用它，甚至可能修改它。这就是[第16章](chapter16.xhtml)详细描述的同一类型的代码块，解析变量的规则也适用于此。
- en: 'For example, you might want two distinct fields for a file’s date and time,
    but the T modifier resolves them as a single value, and that isn’t an issue at
    all with this code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能希望为文件的日期和时间分别使用两个不同的字段，但T修饰符将它们解析为单个值，而在这段代码中这根本不是问题：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At the top of the code block, I assign the entire string to the filDtTm variable
    and then substring out the date and time on the next two lines, respectively.
    This is a fine yet crucial point: I’m using exclamation marks and delayed expansion
    to resolve the variable just set inside the code block. Percent sign delimiters
    would’ve resolved this to the value of filDtTm prior to the code block, and since
    it’s unlikely to have been set at all, the results probably would’ve been garbage
    (~0,10 and ~11).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块顶部，我将整个字符串分配给filDtTm变量，然后在接下来的两行分别截取日期和时间。这是一个微妙但至关重要的点：我使用感叹号和延迟扩展来解析刚在代码块内设置的变量。百分号分隔符将在代码块之前解析为filDtTm的值，而且由于这个值很可能根本没有被设置，结果可能会是垃圾（~0,10和~11）。
- en: Ultimately, if you assign a value to a variable inside a code block, you must
    use exclamation marks to retrieve its current value. If the logic gets overly
    complex, there are other techniques, and in [Chapter 20](chapter20.xhtml), I’ll
    demonstrate how to make full use of delayed expansion inside these more complex
    code blocks. But as a rule, understand that these variables have two possible
    values and do your best to not overcomplicate the code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，如果你在代码块内为变量赋值，你必须使用感叹号来获取其当前值。如果逻辑变得过于复杂，还有其他技巧，而在[第20章](chapter20.xhtml)中，我将演示如何在这些更复杂的代码块中充分利用延迟扩展。但通常来说，要理解这些变量有两种可能的值，并尽量避免让代码过于复杂。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I detailed the optionless for command, its components, how
    it works with filesets and file masks, and how to retrieve a great deal of file
    information with modifiers. You learned that this command usually accepts a file
    or files as input, but it can also accept a string of text. I hope you found the
    real-world applications interesting and informative and that they encouraged you
    to think about other pertinent uses for this important command. I also included
    some pointers on how to resolve variables defined in the code block of the for
    command.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我详细介绍了不带选项的`for`命令、它的组成部分、如何与文件集和文件掩码一起使用，以及如何通过修饰符检索大量文件信息。你了解到这个命令通常接受文件或多个文件作为输入，但它也可以接受一串文本。我希望你觉得这些实际应用既有趣又富有启发性，并且激发你思考这个重要命令的其他相关用途。我还提供了一些关于如何解析`for`命令代码块中定义的变量的提示。
- en: 'The remaining chapters of [Part II](part2.xhtml) will reveal much more, all
    of which will be needed to appreciate the panorama of the for command. In the
    next chapter, I’ll discuss some functionality that’s opened up with options; one
    enumerates directories instead of files, one traverses subdirectories looking
    for files, and the last implements a crucial bit of functionality: an iterative
    loop.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二部分](part2.xhtml)的剩余章节将揭示更多内容，所有这些内容将有助于全面理解`for`命令的全貌。在下一章中，我将讨论一些通过选项开启的功能；其中一个列举目录而不是文件，另一个遍历子目录寻找文件，最后一个实现了一个至关重要的功能：迭代循环。'
