- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**RECONNAISSANCE WITH PROCESS MONITOR AND PROCESS EXPLORER**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Process Monitor和Process Explorer进行侦察**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: 'Cheat Engine and OllyDbg can help you tear apart a game’s memory and code,
    but you also need to understand how the game interacts with files, registry values,
    network connections, and other processes. To learn how those interactions work,
    you must use two tools that excel at monitoring the external actions of processes:
    Process Monitor and Process Explorer. With these tools, you can track down the
    complete game map, locate save files, identify registry keys used to store settings,
    and enumerate the Internet Protocol (IP) addresses of remote game servers.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Cheat Engine和OllyDbg可以帮助你拆解游戏的内存和代码，但你还需要了解游戏如何与文件、注册表项、网络连接和其他进程交互。为了了解这些交互方式，你必须使用两种工具，它们擅长监控进程的外部操作：Process
    Monitor和Process Explorer。借助这些工具，你可以追踪完整的游戏映射，找到保存文件，识别用于存储设置的注册表键，并列出远程游戏服务器的互联网协议（IP）地址。
- en: In this chapter, I’ll teach you how to use both Process Monitor and Process
    Explorer to log system events and inspect them to see how a game was involved.
    Useful mainly for initial reconnaissance, these tools are amazing at giving a
    clear, verbose picture of exactly how a game interacts with your system. You can
    download both programs from the Windows Sysinternals website (*[https://technet.microsoft.com/en-us/sysinternals/](https://technet.microsoft.com/en-us/sysinternals/)*).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将教你如何使用Process Monitor和Process Explorer来记录系统事件并检查它们，以了解游戏是如何与系统交互的。这些工具主要用于初步侦察，能够清晰且详细地展示游戏如何与系统交互。你可以从Windows
    Sysinternals网站下载这两个程序（* [https://technet.microsoft.com/en-us/sysinternals/](https://technet.microsoft.com/en-us/sysinternals/)*）。
- en: '**Process Monitor**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Process Monitor**'
- en: You can learn a lot about a game simply by exploring how it interacts with the
    registry, filesystem, and network. Process Monitor is a powerful system-monitoring
    tool that logs such events in real time and lets you seamlessly integrate the
    data into a debugging session. This tool provides extensive amounts of useful
    data regarding a game’s interaction with the external environment. With calculated
    review (and sometimes, spontaneous intuition) on your part, this data can reveal
    details about data files, network connections, and registry events that are helpful
    to your ability to see and manipulate how the game functions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过探索游戏如何与注册表、文件系统和网络交互来了解很多游戏的内容。Process Monitor是一个强大的系统监控工具，能够实时记录这些事件，并让你将数据无缝集成到调试会话中。该工具提供大量关于游戏如何与外部环境交互的有用数据。通过你的细致分析（有时也依靠直觉），这些数据可以揭示关于数据文件、网络连接和注册表事件的细节，这些对你理解并操控游戏功能大有帮助。
- en: In this section, I’ll show you how to use Process Monitor to log data, navigate
    it, and make educated guesses about the files a game interacts with. After this
    interface tour, you’ll have a chance to try out Process Monitor for yourself in
    “[Finding a High Score File](ch03.xhtml#ch03sb01)” on [page 55](ch03.xhtml#page_55).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我将向你展示如何使用Process Monitor来记录数据，浏览这些数据，并根据经验判断游戏与哪些文件发生了交互。在这个界面介绍之后，你将有机会在“[查找高分文件](ch03.xhtml#ch03sb01)”中尝试使用Process
    Monitor，位于[第55页](ch03.xhtml#page_55)。
- en: '***Logging In-Game Events***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***记录游戏内事件***'
- en: Process Monitor’s logs can hold all sorts of potentially useful information,
    but their most practical use is to help you figure out where data files, such
    as in-game item definitions, might be stored. When you start Process Monitor,
    the first dialog you see is the Process Monitor Filter, shown in [Figure 3-1](ch03.xhtml#ch3fig1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Process Monitor的日志可以保存各种潜在有用的信息，但它们最实际的用途是帮助你找出数据文件的存储位置，比如游戏中的物品定义。启动Process
    Monitor时，你首先看到的对话框是Process Monitor过滤器，如[图3-1](ch03.xhtml#ch3fig1)所示。
- en: '![image](../images/f03-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f03-01.jpg)'
- en: '*Figure 3-1: Process Monitor Filter dialog*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：Process Monitor过滤器对话框*'
- en: This dialog allows you to show or suppress events based on a number of dynamic
    properties they possess. To start monitoring processes, select **Process Name**
    ▸ **Is** ▸ ***YourGameFilename.exe*** ▸ **Include** and then press **Add**, **Apply**,
    and **OK**. This tells Process Monitor to show events invoked by *YourGameFilename.exe*.
    With the proper filters set, you will be taken to the main window shown in [Figure
    3-2](ch03.xhtml#ch3fig2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对话框允许你根据事件所具备的多个动态属性来显示或抑制事件。要开始监控进程，选择**进程名称** ▸ **是** ▸ ***YourGameFilename.exe***
    ▸ **包含**，然后按**添加**、**应用**和**确定**。这会告诉Process Monitor显示由*YourGameFilename.exe*触发的事件。在正确设置过滤器后，你将进入如[图3-2](ch03.xhtml#ch3fig2)所示的主窗口。
- en: '![image](../images/f03-02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f03-02.jpg)'
- en: '*Figure 3-2: Process Monitor main window*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：进程监视器主窗口*'
- en: To configure the columns displayed in Process Monitor’s log area, right-click
    on the header and choose **Select Columns**. There’s an impressive number of options,
    but I recommend seven.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置进程监视器日志区域中显示的列，右键单击标题并选择 **选择列**。有很多令人印象深刻的选项，但我建议选择七个。
- en: '**Time of Day** Lets you see when actions are happening.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间** 让你看到操作发生的时间。'
- en: '**Process Name** Is useful if you’re monitoring multiple processes, but with
    the single-process filter that is typically used for games; disabling this option
    can save precious space.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程名称** 如果你正在监视多个进程，它是有用的，但对于通常用于游戏的单进程过滤器来说，禁用此选项可以节省宝贵的空间。'
- en: '**Process ID** Is like Process Name, but it shows the ID rather than the name.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程 ID** 类似于进程名称，但它显示的是进程 ID 而不是名称。'
- en: '**Operation** Shows what action was performed; thus, this option is compulsory.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作** 显示执行的操作；因此，此选项是必选的。'
- en: '**Path** Shows the path of the action’s target; also compulsory.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径** 显示操作目标的路径；这是必选的。'
- en: '**Detail** Is useful only in some cases, but enabling it won’t hurt.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细信息** 只有在某些情况下才有用，但启用它不会造成任何问题。'
- en: '**Result** Shows when actions, such as loading files, fail.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果** 显示操作失败时的情况，例如加载文件时失败。'
- en: As you show more columns, the log can get very crowded, but sticking with these
    options should help keep the output succinct.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你显示更多列时，日志可能会变得非常拥挤，但坚持使用这些选项应该能帮助保持输出简洁。
- en: 'Once the monitor is running and you’ve defined the columns you wish to see,
    there are five event class filters, outlined in black in [Figure 3-2](ch03.xhtml#ch3fig2),
    that you can toggle to clean up your logs even further. Event class filters let
    you choose which events to show in the log, based on type. From left to right,
    these filters are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦监视器运行，并且你已定义了希望看到的列，你可以切换五个事件类过滤器（在[图 3-2](ch03.xhtml#ch3fig2)中用黑色标出），进一步清理日志。事件类过滤器允许你根据事件类型选择在日志中显示哪些事件。
    从左到右，这些过滤器如下：
- en: '**Registry** Shows all registry activity. There will be a lot of white noise
    in the registry upon process creation, as games rarely use the registry and Windows
    libraries always use it. Leaving this filter disabled can save a lot of space
    in the log.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注册表** 显示所有注册表活动。进程创建时，注册表中会有很多白噪声，因为游戏很少使用注册表，而 Windows 库总是使用它。禁用此过滤器可以节省日志中的大量空间。'
- en: '**Filesystem** Shows all filesystem activity. This is the most important event
    class filter, since knowing where data files are stored and how they are accessed
    is integral to writing an effective bot.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件系统** 显示所有文件系统活动。这是最重要的事件类过滤器，因为了解数据文件存储的位置及其访问方式对于编写有效的机器人程序至关重要。'
- en: '**Network** Shows all network activity. The call stack on network events can
    be useful in finding network-related code within a game.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络** 显示所有网络活动。网络事件的调用堆栈在查找游戏中的网络相关代码时非常有用。'
- en: '**Process and thread activity** Shows all process and thread actions. The call
    stack on these events can give you insight into how a game’s code handles threads.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程和线程活动** 显示所有进程和线程的操作。对于这些事件的调用堆栈可以让你深入了解游戏代码如何处理线程。'
- en: '**Process profiling** Periodically shows information about the memory and CPU
    usage of each running process; a game hacker will rarely use it.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程分析** 定期显示每个正在运行的进程的内存和 CPU 使用情况；游戏黑客通常不会使用它。'
- en: If class-level event filtering is still not precise enough to filter out unwanted
    pollution in your logs, right-click on specific events for event-level filtering
    options. Once you have your event filtering configured to log only what you need,
    you can begin navigating the log. [Table 3-1](ch03.xhtml#ch3tab1) lists some useful
    hotkeys for controlling the log’s behavior.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类级别的事件过滤仍然不足以精确过滤掉日志中不需要的信息，可以右键单击特定事件进行事件级别的过滤选项。一旦配置了只记录需要的事件的过滤器，你就可以开始浏览日志。[表
    3-1](ch03.xhtml#ch3tab1)列出了控制日志行为的一些有用快捷键。
- en: '**Table 3-1:** Process Monitor Hotkeys'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 进程监视器快捷键'
- en: '| **Hotkey** | **Action** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **快捷键** | **操作** |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| CTRL-E | Toggles logging. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-E | 切换日志记录。 |'
- en: '| CTRL-A | Toggles automatic scrolling of the log. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-A | 切换日志的自动滚动。 |'
- en: '| CTRL-X | Clears the log. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-X | 清除日志。 |'
- en: '| CTRL-L | Displays the Filter dialog. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-L | 显示过滤器对话框。 |'
- en: '| CTRL-H | Displays the Highlight dialog. This dialog looks very similar to
    the Filter dialog, but it is used to indicate which events should be highlighted.
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-H | 显示高亮对话框。该对话框与过滤器对话框非常相似，但用于指示应该高亮显示哪些事件。 |'
- en: '| CTRL-F | Displays the Search dialog. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-F | 显示搜索对话框。 |'
- en: '| CTRL-P | Displays the Event Properties dialog for the selected event. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-P | 显示所选事件的事件属性对话框。 |'
- en: As you navigate the log, you can examine the operations recorded to see the
    fine-grained details of an event.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览日志时，你可以检查记录的操作，查看事件的详细信息。
- en: '***Inspecting Events in the Process Monitor Log***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查进程监视器日志中的事件***'
- en: Process Monitor logs every data point it possibly can about an event, enabling
    you to learn more about these events than just the files they act upon. Carefully
    inspecting data-rich columns, such as Result and Detail, can yield some very interesting
    information.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 进程监视器会记录每个事件的所有数据点，使你能够了解这些事件的更多信息，而不仅仅是它们作用的文件。仔细检查数据丰富的列，如结果和详细信息，可以揭示一些非常有趣的信息。
- en: For example, I’ve found that games sometimes read data structures, element by
    element, directly from files. This behavior is apparent when a log contains a
    large number of reads to the same file, where each read has sequential offsets
    but differing lengths. Consider the hypothetical event log shown in [Table 3-2](ch03.xhtml#ch3tab2).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我发现游戏有时会直接从文件中按元素读取数据结构。当日志中包含大量对同一文件的读取时，且每次读取的偏移量是连续的但长度不同时，这种行为尤为明显。考虑[表3-2](ch03.xhtml#ch3tab2)中的假设事件日志。
- en: '**Table 3-2:** Example Event Log'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-2：** 示例事件日志'
- en: '| **Operation** | **Path** | **Detail** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **路径** | **详细信息** |'
- en: '| --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create File | *C:\file.dat* | Desired Access: Read |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 创建文件 | *C:\file.dat* | 期望访问: 读取 |'
- en: '| Read File | *C:\file.dat* | Offset: 0 Size: 4 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 读取文件 | *C:\file.dat* | 偏移量: 0 大小: 4 |'
- en: '| Read File | *C:\file.dat* | Offset: 4 Size: 2 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 读取文件 | *C:\file.dat* | 偏移量: 4 大小: 2 |'
- en: '| Read File | *C:\file.dat* | Offset: 6 Size: 2 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 读取文件 | *C:\file.dat* | 偏移量: 6 大小: 2 |'
- en: '| Read File | *C:\file.dat* | Offset: 8 Size: 4 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 读取文件 | *C:\file.dat* | 偏移量: 8 大小: 4 |'
- en: '| Read File | *C:\file.dat* | Offset: 12 Size: 4 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 读取文件 | *C:\file.dat* | 偏移量: 12 大小: 4 |'
- en: '| ... | *...* | ...Continues to read chunks of 4 bytes for a while |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ... | *...* | ...继续读取4字节的数据块一段时间 |'
- en: 'This log reveals that the game is reading a structure from the file piece by
    piece, disclosing some hints about what the structure looks like. For example,
    let’s say that these reads reflect the following data file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该日志显示游戏正按部就班地从文件中读取结构，揭示了一些关于该结构的线索。例如，假设这些读取反映了以下数据文件：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Compare the log in [Table 3-2](ch03.xhtml#ch3tab2) with this structure. First,
    the game reads the 4 `header` bytes. Then, it reads two 2-byte values: `effectCount`
    and `itemCount`. It then creates two integer arrays, `effects` and `items`, of
    respective lengths `effectCount` and `itemCount`. The game then fills these arrays
    with data from the file, reading 4 bytes `effectCount + itemCount` times.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志与[表3-2](ch03.xhtml#ch3tab2)中的结构进行比较。首先，游戏读取了4个`header`字节。接着，它读取两个2字节的值：`effectCount`和`itemCount`。然后，它创建了两个整数数组，`effects`和`items`，它们的长度分别为`effectCount`和`itemCount`。游戏随后从文件中读取数据，填充这些数组，读取了`effectCount
    + itemCount`次，每次4个字节。
- en: '**NOTE**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Developers definitely shouldn’t use a process like this to read data from
    a file, but you’d be amazed at how often it happens. Fortunately for you, naïveté
    like this just makes your analysis easier.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*开发者绝对不应该使用这样的过程从文件中读取数据，但你会惊讶于这种情况发生的频率。幸运的是，对于你来说，像这样的天真行为反而让你的分析变得更加容易。*'
- en: In this case, the event log can identify small pieces of information within
    a file. But keep in mind that, while correlating the reads with the known structure
    is easy, it’s much harder to reverse engineer an unknown structure from nothing
    but an event log. Typically, game hackers will use a debugger to get more context
    about each interesting event, and the data from Process Monitor can be seamlessly
    integrated into a debugging session, effectively tying together the two powerful
    reverse engineering paradigms.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，事件日志可以识别文件中的小块信息。但请记住，虽然将读取操作与已知结构关联很容易，但从一个空白的事件日志反向推测一个未知结构则要困难得多。通常，游戏黑客会使用调试器来获取有关每个有趣事件的更多上下文信息，而进程监视器的数据可以无缝地集成到调试会话中，有效地将两种强大的逆向工程范式结合起来。
- en: '***Debugging a Game to Collect More Data***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调试游戏以收集更多数据***'
- en: Let’s step away from this hypothetical file read and look at how Process Monitor
    lets you transition from event logging to debugging. Process Monitor stores a
    complete stack trace for each event, showing the full execution chain that led
    to the event being triggered. You can view these stack traces in the Stack tab
    of the Event Properties window (double-click the event or press CTRL-P), as shown
    in [Figure 3-3](ch03.xhtml#ch3fig3).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时跳出这个假设的文件读取场景，看看 Process Monitor 如何让你从事件日志转到调试。Process Monitor 会为每个事件存储完整的堆栈跟踪，显示导致事件触发的完整执行链。你可以在事件属性窗口的堆栈标签页中查看这些堆栈跟踪（双击事件或按
    CTRL-P），如 [图 3-3](ch03.xhtml#ch3fig3) 所示。
- en: '![image](../images/f03-03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f03-03.jpg)'
- en: '*Figure 3-3: Process Monitor event call stack*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：Process Monitor 事件调用堆栈*'
- en: The stack trace is displayed in a table starting with a Frame column ➊, which
    shows the execution mode and stack frame index. A pink *K* in this column means
    the call happened in kernel mode, while a blue *U* means it happened in user mode.
    Since game hackers typically work in user mode, kernel mode operations are usually
    meaningless.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪以一个表格的形式展示，首先是帧栏 ➊，显示执行模式和堆栈帧索引。该栏中的粉色 *K* 表示调用发生在内核模式，而蓝色 *U* 表示调用发生在用户模式。由于游戏黑客通常在用户模式下工作，因此内核模式操作通常没有意义。
- en: The Module column ➋ shows the executable module where the calling code was located.
    Each module is just the name of the binary that made the call; this makes it easy
    to identify which calls were actually made from within a game binary.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 模块栏 ➋ 显示了调用代码所在的可执行模块。每个模块仅仅是发出调用的二进制文件的名称；这使得我们可以轻松识别哪些调用实际上是从游戏二进制文件内部发出的。
- en: The Location column ➌ shows the name of the function that made each call, as
    well as the call offset. These function names are deduced from the export table
    of the module and will generally not be present for the functions within a game
    binary. When no function names are present, the Location column instead shows
    the module name and the call’s *offset* (how many bytes past the origin address
    the call is in memory) from the module’s base address.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 位置栏 ➌ 显示了发出每个调用的函数名称，以及调用的偏移量。这些函数名是从模块的导出表中推导出来的，通常在游戏二进制文件中的函数不会显示名称。当没有函数名时，位置栏会显示模块名称以及调用的
    *偏移量*（即调用在内存中距离模块基地址的字节数）。
- en: '**NOTE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the context of code, the offset is how many bytes of assembly code are
    between an item and its origin.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*在代码上下文中，偏移量是指从某个项到其源地址之间的汇编代码字节数。*'
- en: The Address column ➍ shows the code address of the call, which is very useful
    because you can jump to the address in the OllyDbg disassembler. Finally, the
    Path column ➎ shows the path to the module that made the call.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 地址栏 ➍ 显示了调用的代码地址，这非常有用，因为你可以在 OllyDbg 反汇编器中跳转到该地址。最后，路径栏 ➎ 显示了发出调用的模块的路径。
- en: In my opinion, the stack trace is, by far, the most powerful feature in Process
    Monitor. It reveals the entire context that led to an event, which can be immensely
    useful when you are debugging a game. You can use it to find the exact code that
    triggered an event, crawl up the call chain to see how it got there, and even
    determine exactly what libraries were used to complete each action.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，堆栈跟踪是 Process Monitor 中最强大的功能。它揭示了导致事件发生的完整上下文，在调试游戏时非常有用。你可以用它找到触发事件的确切代码，沿着调用链向上查看事件是如何发生的，甚至可以确定完成每个操作所使用的库。
- en: Process Monitor’s sister application, Process Explorer, doesn’t have many capabilities
    beyond those in Process Monitor or OllyDbg. But it does expose some of those capabilities
    much more effectively, making it an ideal pick in certain situations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Process Monitor 的姊妹应用程序 Process Explorer 在功能上与 Process Monitor 或 OllyDbg 相比并没有太多额外的功能。但它确实能更有效地展示其中的一些功能，使其在特定情况下成为理想的选择。
- en: '**FINDING A HIGH SCORE FILE**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找高分文件**'
- en: If you’re ready to test your Process Monitor skills, you’ve come to the right
    place. Open the *GameHackingExamples/Chapter3_FindingFiles* directory and execute
    *FindingFiles.exe*. You’ll see that it is a game of Pong, like the one in “[Patching
    an `if()` Statement](ch02.xhtml#ch02sb01)” on [page 46](ch02.xhtml#page_46). Unlike
    in [Chapter 2](ch02.xhtml#ch02), though, now the game is actually playable. It
    also displays your current score and your all-time-high score.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好测试你的 Process Monitor 技能，那么你来对地方了。打开*GameHackingExamples/Chapter3_FindingFiles*目录并执行*FindingFiles.exe*。你会看到这是一个
    Pong 游戏，类似于在“[修改 `if()` 语句](ch02.xhtml#ch02sb01)”中的游戏，位于[第46页](ch02.xhtml#page_46)。不过，与[第2章](ch02.xhtml#ch02)不同的是，现在这个游戏实际上可以玩了。它还会显示你当前的分数和历史最高分数。
- en: Now restart the game, firing up Process Monitor before executing it for the
    second time. Filtering for filesystem activity and creating any other filters
    you see fit, try to locate where the game stores the high-score file. For bonus
    points, try to modify this file to make the game show the highest possible score.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重启游戏，在第二次执行游戏之前启动 Process Monitor。通过过滤文件系统活动并创建你认为合适的其他过滤器，尝试找出游戏存储高分文件的位置。作为额外奖励，尝试修改此文件，使游戏显示最高可能的分数。
- en: '**Process Explorer**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Process Explorer**'
- en: Process Explorer is an advanced task manager (it even has a button you can press
    to make it your default task manager), and it’s very handy when you’re starting
    to understand how a game operates. It provides complex data about running processes,
    such as parent and child processes, CPU usage, memory usage, loaded modules, open
    handles, and command line arguments, and it can manipulate those processes. It
    exceeds at showing you high-level information, such as process trees, memory consumption,
    file access, and process IDs, all of which can be very useful.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Process Explorer 是一个高级任务管理器（它甚至有一个按钮可以让你将其设置为默认的任务管理器），当你开始了解一个游戏如何运行时，它非常方便。它提供关于正在运行的进程的复杂数据，如父子进程、CPU
    使用率、内存使用率、加载的模块、打开的句柄和命令行参数，并且能够操作这些进程。它擅长显示高层次的信息，如进程树、内存消耗、文件访问和进程 ID，这些都非常有用。
- en: Of course, none of this data is specifically useful in isolation. But with a
    keen eye, you can make correlations and draw some useful conclusions about what
    global objects—including files, mutexes, and shared memory segments—a game has
    access to. Additionally, the data shown in Process Explorer can be even more valuable
    when cross-referenced with data gathered in a debugging session.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些数据单独看没有特别大的用处。但通过敏锐的观察，你可以找到关联并得出一些有用的结论，了解游戏访问了哪些全局对象——包括文件、互斥体和共享内存段。此外，当这些数据与调试会话中收集的数据进行交叉引用时，它们的价值将更大。
- en: This section introduces the Process Explorer interface, discusses the properties
    it shows, and describes how you can use this tool to manipulate *handles* (references
    to system resources). After this introduction, use “[Finding and Closing a Mutex](ch03.xhtml#ch03sb02)”
    on [page 60](ch03.xhtml#page_60) to hone your skills.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 Process Explorer 界面，讨论了它显示的属性，并描述了你如何使用这个工具来操作*句柄*（对系统资源的引用）。在这个介绍之后，请使用“[查找并关闭互斥体](ch03.xhtml#ch03sb02)”在[第60页](ch03.xhtml#page_60)来磨练你的技能。
- en: '***Process Explorer’s User Interface and Controls***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Process Explorer 的用户界面和控制***'
- en: When you open Process Explorer, you see a window that is split into three distinct
    sections, as in [Figure 3-4](ch03.xhtml#ch3fig4).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开 Process Explorer 时，你会看到一个分成三个不同部分的窗口，如[图3-4](ch03.xhtml#ch3fig4)所示。
- en: '![image](../images/f03-04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f03-04.jpg)'
- en: '*Figure 3-4: Process Explorer main window*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-4：Process Explorer 主窗口*'
- en: Those three sections are the toolbar ➊, an upper pane ➋, and a lower pane ➌.
    The upper pane shows a list of processes, utilizing a tree structure to display
    their parent/child relationships. Different processes are highlighted with different
    colors; if you don’t like the current colors, click **Options** ▸ **Configure
    Colors** to display a dialog that allows you to view and change them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个部分是工具栏 ➊、上窗格 ➋ 和下窗格 ➌。上窗格显示进程列表，采用树状结构显示它们的父子关系。不同的进程使用不同的颜色高亮显示；如果你不喜欢当前的颜色，点击
    **选项** ▸ **配置颜色**，将弹出一个对话框，让你查看并更改颜色。
- en: Just as in Process Monitor, the display for this table is highly versatile,
    and you can customize it by right-clicking on the table header and choosing Select
    Columns. There are probably more than 100 customization options, but I find that
    the defaults with the addition of the ASLR Enabled column work just fine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在进程监视器中一样，此表格的显示非常灵活，你可以通过右键点击表头并选择“选择列”来定制它。可能有超过100个自定义选项，但我发现默认设置加上“ASLR启用”这一列就已经非常合适了。
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Address Space Layout Randomization (ASLR) *is a Windows security feature that
    allocates executable images at unpredictable locations, and knowing whether it’s
    on is invaluable when you’re trying to alter game state values in memory.*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 地址空间布局随机化（ASLR）*是一项Windows安全功能，它将可执行映像分配到不可预测的位置，知道它是否启用对于你在内存中修改游戏状态值时至关重要。*
- en: 'The lower pane has three possible states: Hidden, DLLs, and Handles. The Hidden
    option hides the pane from view, DLLs displays a list of Dynamic Link Libraries
    loaded within the current process, and Handles shows a list of handles held by
    the process (visible in [Figure 3-4](ch03.xhtml#ch3fig4)). You can hide or unhide
    the entire lower pane by toggling View ▸ Show Lower Pane. When it is visible,
    you can change the information display by selecting either View ▸ Lower Pane View
    ▸ DLLs or View ▸ Lower Pane View ▸ Handles.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下半部分窗格有三种可能的状态：隐藏、DLL 和句柄。隐藏选项会将窗格隐藏，DLL选项显示当前进程中加载的动态链接库（DLL）列表，句柄选项显示进程所持有的句柄列表（见[图
    3-4](ch03.xhtml#ch3fig4)）。你可以通过切换视图 ▸ 显示下半部分窗格来隐藏或显示整个下半部分窗格。当它可见时，你可以通过选择视图 ▸
    下半部分窗格视图 ▸ DLL 或 视图 ▸ 下半部分窗格视图 ▸ 句柄来更改信息显示。
- en: You can also use hotkeys to quickly change between lower pane modes without
    affecting processes in the upper pane. These hotkeys are listed in [Table 3-3](ch03.xhtml#ch3tab3).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用快捷键在下半部分窗格模式之间快速切换，而不影响上半部分窗格中的进程。这些快捷键列在[表 3-3](ch03.xhtml#ch3tab3)中。
- en: '**Table 3-3:** Process Explorer Hotkeys'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-3：** 进程资源管理器快捷键'
- en: '| **Hotkey** | **Action** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **快捷键** | **操作** |'
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| CTRL-F | Search through lower pane data sets for a value. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-F | 在下半部分窗格数据集中搜索某个值。 |'
- en: '| CTRL-L | Toggle the lower pane between hidden and visible. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-L | 切换下半部分窗格的隐藏与显示。 |'
- en: '| CTRL-D | Toggle the lower pane to display DLLs. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-D | 切换下半部分窗格显示DLL。 |'
- en: '| CTRL-H | Toggle the lower pane to display handles. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| CTRL-H | 切换下半部分窗格显示句柄。 |'
- en: '| spacebar | Toggle process list autorefresh. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 空格键 | 切换进程列表的自动刷新。 |'
- en: '| ENTER | Display the Properties dialog for the selected process. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| ENTER | 显示选定进程的属性对话框。 |'
- en: '| DEL | Kill the selected process. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| DEL | 终止选中的进程。 |'
- en: '| SHIFT-DEL | Kill the selected process and all child processes. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| SHIFT-DEL | 终止选中的进程及其所有子进程。 |'
- en: Use the GUI or hotkeys to practice changing modes. When you’re acquainted with
    the main window, we’ll look at another important Process Explorer dialog, called
    Properties.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图形用户界面或快捷键来练习切换模式。当你熟悉主窗口后，我们将查看另一个重要的进程资源管理器对话框，称为属性。
- en: '***Examining Process Properties***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查进程属性***'
- en: Much like Process Monitor, Process Explorer has a very kinetic approach to data
    gathering; the end result is a broad and verbose spectrum of information. In fact,
    if you open the Properties dialog (shown in [Figure 3-5](ch03.xhtml#ch3fig5))
    for a process, you’ll see a massive tab bar containing 10 tabs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与进程监视器类似，进程资源管理器采用了一种非常动态的数据收集方式；最终结果是一个广泛且冗长的信息谱。事实上，如果你打开一个进程的属性对话框（见[图 3-5](ch03.xhtml#ch3fig5)），你会看到一个巨大的标签栏，包含10个标签。
- en: The Image tab, selected by default and shown in [Figure 3-5](ch03.xhtml#ch3fig5),
    displays the executable name, version, build date, and complete path. It also
    displays the current working directory and the Address Space Layout Randomization
    status of the executable. ASLR status is the most important piece of information
    here, because it has a direct effect on how a bot can read the memory from a game.
    I’ll talk about this more in [Chapter 6](ch06.xhtml#ch06).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认选中的“图像”标签（见[图 3-5](ch03.xhtml#ch3fig5)）显示可执行文件的名称、版本、构建日期和完整路径。它还显示当前工作目录以及可执行文件的地址空间布局随机化（ASLR）状态。ASLR状态是这里最重要的信息，因为它直接影响机器人如何从游戏中读取内存。我将在[第6章](ch06.xhtml#ch06)中详细讨论这个问题。
- en: '![image](../images/f03-05.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f03-05.jpg)'
- en: '*Figure 3-5: Process Explorer Properties dialog*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-5：进程资源管理器属性对话框*'
- en: The Performance, Performance Graph, Disk and Network, and GPU Graph tabs display
    a myriad of metrics about the CPU, memory, disk, network, and GPU usage of the
    process. If you create a bot that injects into a game, this information can be
    very useful to determine how much of a performance impact your bot has on the
    game.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 性能、性能图表、磁盘和网络、以及GPU图表选项卡显示了有关进程的CPU、内存、磁盘、网络和GPU使用情况的各种指标。如果你创建了一个注入到游戏中的机器人，这些信息可以帮助你判断你的机器人对游戏性能的影响程度。
- en: The TCP/IP tab displays a list of active TCP connections, which you can use
    to find any game server IP addresses that a game connects to. If you’re trying
    to test connection speed, terminate connections, or research a game’s network
    protocol, this information is critical.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP选项卡显示了一个活动的TCP连接列表，你可以用它来找到游戏连接的任何服务器IP地址。如果你想测试连接速度、终止连接，或者研究游戏的网络协议，这些信息至关重要。
- en: The Strings tab displays a list of strings found in either the binary or the
    memory of the process. Unlike the string list in OllyDbg, which shows only strings
    referenced by assembly code, the list includes any occurrences of three or more
    consecutive readable characters, followed by a null terminator. When a game binary
    is updated, you can use a diffing tool on this list from each game version to
    determine whether there are any new strings that you want to investigate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串选项卡显示了在进程的二进制文件或内存中找到的字符串列表。与OllyDbg中的字符串列表不同，OllyDbg仅显示由汇编代码引用的字符串，而这个列表包括了任何包含三个或更多连续可读字符且后跟空字符的字符串。当游戏二进制文件更新时，你可以使用差异工具对比每个游戏版本中的字符串列表，查看是否有新的字符串值得你进一步研究。
- en: The Threads tab shows you a list of threads running within the process and allows
    you to pause, resume, or kill each thread; the Security tab displays the security
    privileges of the process; and the Environment tab displays any environment variables
    known to or set by the process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 线程选项卡显示了进程内运行的线程列表，并允许你暂停、恢复或终止每个线程；安全选项卡显示了进程的安全权限；环境选项卡显示了进程已知的或设置的任何环境变量。
- en: '**NOTE**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you open the Properties dialog for a .NET process, you’ll notice two additional
    tabs: .NET Assemblies and .NET Performance. The data in these tabs is pretty self-explanatory.
    Please keep in mind that a majority of the techniques in this book won’t work
    with games written in .NET.*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你打开一个.NET进程的属性对话框，你会注意到两个额外的选项卡：.NET程序集和.NET性能。这些选项卡中的数据非常直观易懂。请记住，本书中的大多数技术不能应用于使用.NET编写的游戏。*'
- en: '***Handle Manipulation Options***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***句柄操作选项***'
- en: 'As you’ve seen, Process Explorer can provide you with a wealth of information
    about a process. That’s not all it’s good for, though: it can also manipulate
    certain parts of a process. For example, you can view and manipulate open handles
    from the comfort of Process Explorer’s lower pane (see [Figure 3-4](ch03.xhtml#ch3fig4)).
    This alone makes a strong argument for adding Process Explorer to your toolbox.
    Closing a handle is as simple as right-clicking on it and selecting Close Handle.
    This can come in handy when you want, for instance, to close mutexes, which is
    essential to certain types of hacks.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，进程资源管理器可以为你提供关于进程的大量信息。然而，它不仅仅只有这些功能：它还可以操控进程的某些部分。例如，你可以在进程资源管理器的下方窗格中查看并操作打开的句柄（见[图3-4](ch03.xhtml#ch3fig4)）。这本身就足以证明将进程资源管理器添加到你的工具箱中是有价值的。关闭一个句柄的操作很简单，只需右键点击它并选择“关闭句柄”。例如，当你需要关闭互斥锁时，这非常实用，而互斥锁的关闭对某些类型的黑客攻击至关重要。
- en: '**NOTE**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can right-click on the lower pane header and click Select Columns to customize
    the display. One column you might find particularly useful is Handle Value, which
    can help when you see a handle being passed around in OllyDbg and want to know
    what it does.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以右键点击下方窗格的标题并选择“选择列”来定制显示的内容。你可能会发现特别有用的一列是“句柄值”，当你在OllyDbg中看到一个句柄被传递时，它能帮助你了解该句柄的作用。*'
- en: '**Closing Mutexes**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**关闭互斥锁**'
- en: Games often allow only one client to run at a time; this is called *single-instance
    limitation*. You can implement single-instance limitation in a number of ways,
    but using a system mutex is common because mutexes are sessionwide and can be
    accessed by a simple name. It’s trivial to limit instances with mutexes, and thanks
    to Process Explorer, it’s just as trivial to remove that limit, allowing you to
    run multiple instances of a game at the same time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通常只允许同时运行一个客户端；这称为 *单实例限制*。你可以通过多种方式实现单实例限制，但使用系统互斥量是常见方法，因为互斥量是会话范围的，并且可以通过简单的名称访问。利用互斥量来限制实例非常简单，得益于
    Process Explorer，去除这个限制同样简单，使你能够同时运行多个游戏实例。
- en: 'First, here’s how a game might tackle single-instance limitation with a mutex:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下面是一个游戏如何使用互斥量处理单实例限制的示例：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example code creates a mutex named `onlyoneplease`. Next, the function
    checks `GetLastError()` to see whether the mutex was already created, and if so,
    it closes the game. If the mutex doesn’t already exist, the game creates the first
    instance, thereby blocking any future game clients from running. In this example,
    the game runs normally, and once it finishes, `CloseHandle()` is called to close
    the mutex and allow future game instances to run.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这段示例代码创建了一个名为 `onlyoneplease` 的互斥量。接下来，函数检查 `GetLastError()` 看互斥量是否已存在，如果已存在，则关闭游戏。如果互斥量不存在，游戏会创建第一个实例，从而阻止未来的游戏客户端运行。在这个例子中，游戏正常运行，并在完成后调用
    `CloseHandle()` 关闭互斥量，从而允许将来运行多个游戏实例。
- en: You can use Process Explorer to close instance-limiting mutexes and run many
    game instances simultaneously. To do so, choose the Handles view of the lower
    pane, look for all handles with a type of `Mutant`, determine which one is limiting
    instances of the game, and close that mutex.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Process Explorer 关闭限制实例的互斥量，并同时运行多个游戏实例。为此，选择下方窗格的 Handles 视图，查找所有类型为
    `Mutant` 的句柄，确定哪个互斥量在限制游戏实例，并关闭该互斥量。
- en: '**WARNING**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Mutexes are also used to synchronize data across threads and processes. Close
    one only if you’re sure that its sole purpose is the one you’re trying to subvert!*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*互斥量也用于跨线程和进程同步数据。只有当你确定其唯一目的是你正在尝试颠覆的目的时，才可以关闭它！*'
- en: Multiclient hacks are generally in high demand, so being able to quickly develop
    them for emerging games is crucial to your overall success as a bot developer
    within that market. Since mutexes are one of the most common ways to achieve single-instance
    limitation, Process Explorer is an integral tool for prototyping these kinds of
    hacks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 多客户端黑客通常需求量大，因此能够快速为新兴游戏开发此类黑客程序对你作为该市场内的机器人开发者整体成功至关重要。由于互斥量是实现单实例限制的最常见方法之一，Process
    Explorer 是原型开发这类黑客程序的一个重要工具。
- en: '**Inspecting File Accesses**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查文件访问**'
- en: Unlike Process Monitor, Process Explorer can’t show a list of filesystem calls.
    On the other hand, the Handles view of Process Explorer’s lower pane can show
    all file handles that a game currently has open, revealing exactly what files
    are in continuous use without the need to set up advanced filtering criteria in
    Process Monitor. Just look for handles with a type of `File` to see all files
    the game is currently using.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Process Monitor 不同，Process Explorer 无法显示文件系统调用的列表。另一方面，Process Explorer 窗口下方的
    Handles 视图可以显示游戏当前打开的所有文件句柄，准确揭示哪些文件正在被持续使用，而无需在 Process Monitor 中设置复杂的过滤条件。只需查找类型为
    `File` 的句柄即可查看游戏当前正在使用的所有文件。
- en: This functionality can come in handy if you’re trying to locate logfiles or
    save files. Moreover, you can locate named pipes that are used for interprocess
    communication (IPC); these are files prefixed with *\Device\NamedPipe\*. Seeing
    one of these pipes is often a hint that the game is talking to another process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在你试图定位日志文件或存档文件时非常有用。此外，你还可以定位用于进程间通信（IPC）的命名管道；这些文件的前缀为 *\Device\NamedPipe\*。看到这些管道通常是游戏正在与另一个进程通信的提示。
- en: '**FINDING AND CLOSING A MUTEX**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找并关闭互斥量**'
- en: To put your Process Explorer skills to use, go to the *GameHackingExamples/Chapter3_CloseMutex*
    directory and execute *CloseMutex.exe*. This game plays exactly like the one in
    “[Finding a High Score File](ch03.xhtml#ch03sb01)” on [page 55](ch03.xhtml#page_55),
    but it prevents you from simultaneously running multiple instances. As you might
    have guessed, it does this using a single-instance-limitation mutex. Using Process
    Explorer’s Handles view in the lower pane, find the mutex responsible for this
    limitation and close it. If you succeed, you’ll be able to open a second instance
    of the game.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将你的 Process Explorer 技能付诸实践，进入 *GameHackingExamples/Chapter3_CloseMutex* 目录并执行
    *CloseMutex.exe*。这个游戏的玩法与 “[查找高分文件](ch03.xhtml#ch03sb01)” 中的内容完全相同，[第55页](ch03.xhtml#page_55)也有类似的介绍，但它阻止你同时运行多个实例。正如你可能猜到的，它通过一个单实例限制互斥锁来实现这一点。在
    Process Explorer 的下方窗格中使用 Handles 视图，找到负责这一限制的互斥锁并关闭它。如果你成功了，你将能够打开游戏的第二个实例。
- en: '**Closing Thoughts**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: To be effective when using Process Monitor and Process Explorer, you need, above
    all else, a deep familiarity with the data that these applications display as
    well as the interfaces they use to display it. While this chapter’s overview is
    a good baseline, the intricacies of these applications can be learned only through
    experience, so I encourage you to play around with them on your system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效使用 Process Monitor 和 Process Explorer，首先需要对这些应用程序显示的数据以及它们用来展示数据的接口有深刻的了解。虽然本章的概述是一个很好的基础，但这些应用程序的复杂性只能通过实践来掌握，因此我鼓励你在自己的系统上尝试使用它们。
- en: 'You won’t use these tools on a regular basis, but at some point, they’ll save
    the day: as you struggle to figure out how some code works, you’ll recall an obscure
    piece of information that caught your eye during a previous Process Explorer or
    Process Monitor session. That’s why I consider them useful reconnaissance tools.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会经常使用这些工具，但在某些时候，它们会帮你大忙：当你在努力理解某段代码的工作原理时，你会回忆起在之前使用 Process Explorer 或 Process
    Monitor 时看到的一条不经意间注意到的信息。这就是为什么我认为它们是有用的侦察工具。
