- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9'
- en: SYSTEM DOCUMENTATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 系统文档**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: System documentation specifies system requirements, design, test cases, and
    test procedures. In a large software system, the system documentation is often
    the most expensive part; the Waterfall software development model, for example,
    often produces more documentation than code. In addition, typically you must maintain
    system documentation manually, so if you change a description (such as a requirement)
    in one document, you’ll need to search through the system documentation and update
    every other document that references that description for consistency. This is
    a difficult and costly process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 系统文档指定系统需求、设计、测试用例和测试过程。在大型软件系统中，系统文档通常是最昂贵的部分；例如，瀑布式软件开发模型往往生成比代码更多的文档。此外，通常你必须手动维护系统文档，因此，如果你在某个文档中更改了描述（如需求），你需要搜索整个系统文档并更新每个引用该描述的文档，以确保一致性。这是一个困难且成本高昂的过程。
- en: In this chapter, we’ll look at the common types of system documents, ways to
    enforce consistency within them, and documentation strategies to reduce some of
    the costs associated with development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨常见的系统文档类型，如何在文档中强制执行一致性，以及减少与开发相关的一些成本的文档策略。
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This chapter discusses* system *documentation, not* user *documentation. To
    learn about user documentation in detail, check out “For More Information” on
    [page 184](ch09.xhtml#page_184).*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章讨论的是* 系统 *文档，而非* 用户 *文档。如需详细了解用户文档，请参阅 [第184页](ch09.xhtml#page_184) 的“更多信息”。*'
- en: '**9.1 System Documentation Types**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.1 系统文档类型**'
- en: 'Traditional software engineering generally uses the following system documentation
    types:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的软件工程通常使用以下类型的系统文档：
- en: '**System Requirements Specification (SyRS) document**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统需求规格说明书 (SyRS)**'
- en: The SyRS (see “[The System Requirements Specification Document](ch10.xhtml#lev-10.3)”
    on [page 193](ch10.xhtml#page_193)) is a *system-level* requirements document.
    In addition to software requirements, it might include hardware, business, procedural,
    manual, and other non-software-related requirements. The SyRS is a customer/management/stakeholder-level
    document that eschews detail to present a “big picture” view of the requirements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SyRS（参见 “[系统需求规格说明书](ch10.xhtml#lev-10.3)” 在 [第193页](ch10.xhtml#page_193)）是*系统级别*的需求文档。除了软件需求外，它可能还包括硬件、业务、程序、手册和其他非软件相关的需求。SyRS是面向客户/管理层/利益相关者的文档，避免详细描述，呈现需求的“宏观视图”。
- en: '**Software Requirements Specification (SRS) document**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件需求规格说明书 (SRS)**'
- en: The SRS (see “[The Software Requirements Specification Document](ch10.xhtml#lev-10.4)”
    on [page 194](ch10.xhtml#page_194)) extracts the software requirements^([1](ch19_footnote.xhtml#ch09fn1))
    from the SyRS and drills down on the high-level requirements to introduce new
    requirements at a much finer level of detail (suitable for software engineers).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SRS（参见 “[软件需求规格说明书](ch10.xhtml#lev-10.4)” 在 [第194页](ch10.xhtml#page_194)）从SyRS中提取软件需求^([1](ch19_footnote.xhtml#ch09fn1))，并深入探讨高层需求，介绍更详细的新需求（适合软件工程师）。
- en: '**NOTE**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The SyRS and SRS are* requirements *documents whose content may differ in
    scope and detail. Many organizations produce a single document rather than two
    separate ones, but this book treats them separately because the SyRS deals with
    a wider range of requirements (for example, hardware and business requirements)
    than the SRS.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*SyRS和SRS是* 需求 *文档，其内容在范围和细节上可能有所不同。许多组织会生成一个文档，而不是两个单独的文档，但本书将它们分别讨论，因为SyRS涉及的需求范围更广（例如，硬件和业务需求），而SRS主要集中在软件需求上。*'
- en: '**Software Design Description (SDD) document**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件设计说明书 (SDD)**'
- en: The SDD (see [Chapter 11](ch11.xhtml)) discusses *how* the system will be constructed
    (versus the SyRS and SRS, which describe *what* the system will do). In theory,
    any programmer should be able to use the SDD and write the corresponding code
    to implement the software system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SDD（参见 [第11章](ch11.xhtml)）讨论系统将如何构建（与SyRS和SRS不同，它们描述的是系统将做什么）。理论上，任何程序员都应该能够使用SDD，并编写相应的代码来实现软件系统。
- en: '**Software Test Cases (STC) document**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件测试用例 (STC)**'
- en: The STC (see “[Software Test Case Documentation](ch12.xhtml#lev-12.4)” on [page
    274](ch12.xhtml#page_274)) describes the various test values needed to verify
    that the system incorporates all the requirements, and functions correctly beyond
    the requirements list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: STC（见 “[软件测试用例文档](ch12.xhtml#lev-12.4)” 在 [第274页](ch12.xhtml#page_274)）描述了验证系统是否包含所有需求，并且在需求列表之外正确功能所需的各种测试值。
- en: '**Software Test Procedures (STP) document**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件测试过程（STP）文档**'
- en: The STP (see “[Software Test Procedure Documentation](ch12.xhtml#lev-12.5)”
    on [page 288](ch12.xhtml#page_288)) describes the procedures to efficiently execute
    the software test cases (from the STC) to verify correct system operation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: STP（见 “[软件测试过程文档](ch12.xhtml#lev-12.5)” 在 [第288页](ch12.xhtml#page_288)）描述了高效执行软件测试用例（来自STC）以验证系统正确操作的程序。
- en: '**Requirements (or Reverse) Traceability Matrix (RTM) document**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求（或反向）追溯矩阵（RTM）文档**'
- en: The RTM (see “[The Requirements/Reverse Traceability Matrix](ch09.xhtml#lev-9.2.3)”
    on [page 178](ch09.xhtml#page_178)) links the requirements against the design,
    test cases, and code. Using an RTM, a stakeholder can verify that a requirement
    is implemented in the design and the code, and that the test cases and procedures
    properly check that requirement’s implementation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: RTM（见 “[需求/反向追溯矩阵](ch09.xhtml#lev-9.2.3)” 在 [第178页](ch09.xhtml#page_178)）将需求与设计、测试用例和代码联系起来。使用RTM，利益相关者可以验证需求是否在设计和代码中实现，并且测试用例和程序是否正确检查了该需求的实现。
- en: '**NOTE**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some organizations might also have a* Functional Requirements Specification
    *document; this often refers to the requirements that an external customer provides,
    or it can simply be a synonym for the SRS or SyRS. This book won’t use this term
    further.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*某些组织也可能有一个* 功能需求规格说明 *文档；这通常指的是外部客户提供的需求，或者它也可以仅仅是SRS或SyRS的同义词。本书后续将不再使用此术语。*'
- en: There are many additional types of documents, but these are the basic ones you’d
    expect for any (non-XP, at least) project, and they correspond to the various
    stages of the Waterfall model (see “[The Waterfall Model](ch03.xhtml#lev-3.2.2)”
    on [page 44](ch03.xhtml#page_44)), as shown in [Figure 9-1](ch09.xhtml#ch9fig1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类型的文档，但这些是任何（至少非XP）项目中你所期望的基本文档，它们对应于瀑布模型的不同阶段（见 “[瀑布模型](ch03.xhtml#lev-3.2.2)”
    在 [第44页](ch03.xhtml#page_44)），如[图9-1](ch09.xhtml#ch9fig1)所示。
- en: '![image](Images/fig9-1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig9-1.jpg)'
- en: '*Figure 9-1: System documentation dependencies*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：系统文档依赖关系*'
- en: As you can see, the SRS is constructed from the SyRS. The SDD is constructed
    from the SRS, as is the STC (which, in some cases, is also influenced by the SDD,
    as indicated by the gray arrow^([2](ch19_footnote.xhtml#ch09fn2))). The STP is
    constructed from the STC.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，SRS是从SyRS构建的，SDD是从SRS构建的，STC也是如此（在某些情况下，它也受到SDD的影响，如灰色箭头所示^([2](ch19_footnote.xhtml#ch09fn2)))。STP是从STC构建的。
- en: '**9.2 Traceability**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.2 追溯性**'
- en: Perhaps the greatest logistical issue with system documentation is consistency.
    A requirement typically generates some design item and a test case (which is part
    of a test procedure in the STP). This is an intuitive and natural progression
    when you’re following a strict Waterfall model—writing the SRS first, followed
    by the SDD, the STC, and the SDD. However, problems arise when you have to make
    corrections to documents earlier in this chain. For example, when you change a
    requirement, you might need to change entries in the SDD, STC, and STP documents.
    Best practice is therefore to use *traceability*, which allows you to easily trace
    items from one document to all the other system documents. If you can trace your
    requirements to design elements, test cases, and test procedures, you can rapidly
    locate and change those elements whenever you modify a requirement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 系统文档中可能最大的后勤问题就是一致性。一个需求通常会生成一些设计项和测试用例（这些测试用例是STP中的一部分）。这是在严格的瀑布模型下的直观和自然的进展——首先编写SRS，然后是SDD、STC和SDD。然而，当你需要对这个链中的早期文档进行更改时，问题就出现了。例如，当你更改一个需求时，可能需要更改SDD、STC和STP文档中的条目。因此，最佳实践是使用*追溯性*，它允许你轻松地将一个文档中的项追溯到其他所有系统文档。如果你能将需求追溯到设计元素、测试用例和测试过程，你就可以在修改需求时快速定位和更改这些元素。
- en: '*Reverse traceability* allows you to trace a test procedure back to the corresponding
    test cases, and test cases and design items back to their corresponding requirements.
    For example, you might encounter problems with a test that require changes to
    the test procedure, in which case you can locate the corresponding test cases
    and requirements to ensure that your changes to the test procedure still handle
    all of them. In this way, reverse traceability also helps you determine whether
    you need to make changes to the test cases or requirements.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*反向可追溯性*允许你将测试程序追溯到相应的测试用例，并将测试用例和设计项目追溯到相应的需求。例如，你可能会遇到需要修改测试程序的测试问题，这时可以找到相应的测试用例和需求，以确保你对测试程序的修改能够涵盖所有问题。通过这种方式，反向可追溯性还帮助你判断是否需要修改测试用例或需求。'
- en: '***9.2.1 Ways to Build Traceability into Your Documentation***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.2.1 将可追溯性融入文档的方式***'
- en: There are a couple of ways to accomplish traceability and reverse traceability.
    One approach is to build the traceability into an *identifier*, or *tag*, associated
    with the requirement, design element, test case, or test procedure documentation.
    This tag could be a paragraph (or item) number, a descriptive word, or some other
    set of symbols that uniquely identify the text to reference. Software documents
    that use tags avoid wasting space by directly quoting other documents.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现可追溯性和反向可追溯性。一种方法是将可追溯性内建于与需求、设计元素、测试用例或测试程序文档相关联的*标识符*或*标签*中。该标签可以是段落（或项目）编号、描述性词语或其他能够唯一标识引用文本的符号集合。使用标签的软件文档通过直接引用其他文档来避免浪费空间。
- en: Often authors use paragraph numbers as tags, which is really easy to do in a
    word processing system. However, many word processors don’t support cross-referencing
    across multiple document types. Also, the tagging mechanism or format you want
    to use might not match what the word processor provides.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作者们常常使用段落编号作为标签，在文字处理系统中这样做非常简单。然而，许多文字处理软件并不支持跨多个文档类型的交叉引用。而且，你想要使用的标签机制或格式可能与文字处理软件提供的格式不匹配。
- en: Although it’s possible to write custom software, or use a database application
    to extract and maintain cross-reference information, the most common solution
    is to maintain tags manually. This might sound as though it would require considerable
    effort, but with a little planning, it isn’t very difficult.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以编写自定义软件，或使用数据库应用程序来提取和维护交叉引用信息，但最常见的解决方案是手动维护标签。这听起来可能需要相当大的努力，但只需稍加规划，实际上并不难。
- en: Perhaps the best solution is to create an RTM (see “[The Requirements/Reverse
    Traceability Matrix](ch09.xhtml#lev-9.2.3)” on [page 178](ch09.xhtml#page_178)),
    which tracks the links between the items in your system documentation. Although
    the RTM is yet another document you’ll have to maintain, it provides a complete
    and easy-to-use mechanism for tracking all the components in your system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最好的解决方案是创建RTM（参见[“需求/反向可追溯性矩阵”](ch09.xhtml#lev-9.2.3) 在[第178页](ch09.xhtml#page_178)），它跟踪系统文档中各个项目之间的关联。尽管RTM是你需要维护的又一份文档，但它提供了一种完整且易于使用的机制，用于跟踪系统中所有组件。
- en: We’ll first talk through common tag formats, and then we’ll look into building
    an RTM.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论常见的标签格式，然后再探讨如何构建RTM。
- en: '***9.2.2 Tag Formats***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.2.2 标签格式***'
- en: There is no particular standard for tag syntax; tags can take any form you like
    as long as the syntax is consistent and each tag is unique. For my own purposes
    (and for this book), I’ve created a syntax that incorporates elements of traceability
    directly into the tag. The tag formats that follow are organized by document type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 标签语法没有特定的标准；标签可以采用任何你喜欢的形式，只要语法一致且每个标签唯一。为了自己的需要（以及为了这本书），我创建了一种语法，将可追溯性元素直接融入标签中。以下标签格式按文档类型进行组织。
- en: '**9.2.2.1 SyRS Tags**'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**9.2.2.1 SyRS标签**'
- en: 'For the SyRS, a tag takes the form [*productID*_SYRS_*xxx*] where:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SyRS，标签的格式为[*productID*_SYRS_*xxx*]，其中：
- en: '***productID*** Refers to the product or project. For example, for a swimming
    pool monitor application, *productID* might be “POOL.” You don’t want to use a
    long ID (four to five characters should be the maximum length) because it will
    be typed frequently.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '***productID*** 指代产品或项目。例如，对于游泳池监控应用，*productID* 可能是“POOL”。你不想使用过长的ID（最多四到五个字符），因为它将频繁输入。'
- en: '**SYRS** States that this is a tag from the SyRS document (this is probably
    a system requirements tag).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**SYRS** 表明这是来自SyRS文档的标签（这可能是一个系统需求标签）。'
- en: '***xxx*** Represents one or more numbers, separated by periods if more than
    one integer is used. This numeric sequence uniquely identifies the tag within
    the SyRS.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '***xxx*** 表示一个或多个数字，如果使用多个整数，则用句点分隔。这个数字序列在SyRS中唯一标识该标签。'
- en: In a perfect world, all the SyRS requirements (and other items requiring a tag)
    would be numbered sequentially from 1 with no correlation between the integers
    and the meanings of the text blocks to which they refer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，所有SyRS需求（以及其他需要标签的项目）应从1开始按顺序编号，且数字与它们所指代的文本块的含义无关。
- en: 'Consider the following two requirements in an SyRS document:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在SyRS文档中请考虑以下两个需求：
- en: '**[POOL_SYRS_001]: Pool temperature monitoring**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_001]: 泳池温度监控**'
- en: The system shall monitor the pool temperature.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应监控泳池温度。
- en: '**[POOL_SYRS_002]: Maximum pool temperature**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_002]: 最高泳池温度**'
- en: The system shall turn on the “High Temp” LED if the pool temperature exceeds
    86 degrees Fahrenheit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果泳池温度超过86华氏度，系统应开启“高温”LED指示灯。
- en: Let’s say that 150 additional requirements follow [POOL_SYRS_002].
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在[POOL_SYRS_002]之后有150个额外需求。
- en: 'Now suppose that someone suggests a requirement that the pool heater be turned
    on if the pool temperature drops below 70 degrees Fahrenheit. You could add the
    following requirements:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设有人建议在泳池温度降到70华氏度以下时启动泳池加热器。你可以添加以下需求：
- en: '**[POOL_SYRS_153]: Minimum pool temperature**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_153]: 最低泳池温度**'
- en: The system shall turn on the pool heater if the pool temperature drops below
    70 degrees Fahrenheit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果泳池温度降到70华氏度以下，系统应开启泳池加热器。
- en: '**[POOL_SYRS_154]: Maximum heater on temperature**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_154]: 最高加热器启动温度**'
- en: The system shall turn off the pool heater if the pool temperature exceeds 70
    degrees Fahrenheit.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果泳池温度超过70华氏度，系统应关闭泳池加热器。
- en: In the SyRS, it makes sense to arrange related requirements close to one another,
    so the reader can locate all the pertinent requirements for a given feature at
    one point in the document. You can see why you wouldn’t want to sort the requirements
    by their tags—doing so would push the two new requirements for the pool heater
    to the end of the document, away from the other pool temperature requirements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在SyRS中，将相关需求靠近安排是有意义的，这样读者就能在文档中一个地方找到与某个功能相关的所有需求。你可以理解为什么不应该按标签排序需求——这样做会将泳池加热器的新需求推到文档的末尾，远离其他泳池温度需求。
- en: 'There’s nothing stopping you from moving the requirements together; however,
    it’s somewhat confusing to see a set of requirements like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么可以阻止你将需求移到一起；然而，看到这样的需求集有点令人困惑：
- en: '**[POOL_SYRS_001]: Pool temperature monitoring**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_001]: 泳池温度监控**'
- en: The system shall monitor the pool temperature.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应监控泳池温度。
- en: '**[POOL_SYRS_153]: Minimum pool temperature**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_153]: 最低泳池温度**'
- en: The system shall turn on the pool heater if the pool temperature drops below
    70 degrees Fahrenheit.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果泳池温度降到70华氏度以下，系统应开启泳池加热器。
- en: '**[POOL_SYRS_154]: Maximum heater on temperature**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_154]: 最高加热器启动温度**'
- en: The system shall turn off the pool heater if the pool temperature exceeds 70
    degrees Fahrenheit.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果泳池温度超过70华氏度，系统应关闭泳池加热器。
- en: '**[POOL_SYRS_002]: Maximum pool temperature**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_002]: 最高泳池温度**'
- en: The system shall turn on the “High Temp” LED if the pool temperature exceeds
    86 degrees Fahrenheit.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果泳池温度超过86华氏度，系统应开启“高温”LED指示灯。
- en: 'A better solution is to renumber the tags using *dotted sequences* to expand
    the tag numbers. A dotted sequence consists of two or more integers separated
    by a dot. For example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是使用*点序列*重新编号标签，以扩展标签编号。点序列由两个或更多整数组成，整数之间用点分隔。例如：
- en: '**[POOL_SYRS_001]: Pool temperature monitoring**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_001]: 泳池温度监控**'
- en: The system shall monitor the pool temperature.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应监控泳池温度。
- en: '**[POOL_SYRS_001.1]: Minimum pool temperature**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_001.1]: 最低泳池温度**'
- en: The system shall turn on the pool heater if the pool temperature drops below
    70 degrees Fahrenheit.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果泳池温度降到70华氏度以下，系统应开启泳池加热器。
- en: '**[POOL_SYRS_001.2]: Maximum heater on temperature**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_001.2]: 最高加热器启动温度**'
- en: The system shall turn off the pool heater if the pool temperature exceeds 70
    degrees Fahrenheit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果泳池温度超过70华氏度，系统应关闭泳池加热器。
- en: '**[POOL_SYRS_002]: Maximum pool temperature**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_002]: 最高泳池温度**'
- en: The system shall turn on the “High Temp” LED if the pool temperature exceeds
    86 degrees Fahrenheit.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游泳池温度超过86华氏度，系统应打开“高温”LED指示灯。
- en: This allows you to flow in new requirements or changes anywhere. Note that 001.1
    and 001.10 are not the same. These numbers are not floating-point numeric values;
    they’re two integers separated by a period. The number 001.10 is probably the
    10th value in the sequence 001.1 through 001.10\. Likewise, 001 is not the same
    as 001.0.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以让你在任何地方插入新的需求或变更。请注意，001.1和001.10是不同的。这些数字不是浮动点数字值；它们是两个用句点分隔的整数。数字001.10可能是序列001.1到001.10中的第10个值。同样，001与001.0也不同。
- en: 'If you need to insert a requirement between 001.1 and 001.2, you can simply
    add another period to the end of the sequence, such as 001.1.1\. You can also
    leave gaps between your tag numbers if you expect to insert additional tags in
    the future, like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在001.1和001.2之间插入一个需求，你可以简单地在序列的末尾添加一个句点，如001.1.1。你也可以在标签号之间留空，以便将来插入更多标签，例如：
- en: '**[POOL_SYRS_010]: Pool temperature monitoring**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_010]: 游泳池温度监控**'
- en: The system shall monitor the pool temperature.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应监控游泳池温度。
- en: '**[POOL_SYRS_020]: Maximum pool temperature**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_020]: 最大游泳池温度**'
- en: The system shall turn on the “High Temp” LED if the pool temperature exceeds
    86 degrees Fahrenheit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游泳池温度超过86华氏度，系统应打开“高温”LED指示灯。
- en: 'So when you decide to add the other two requirements, you have:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当你决定添加另外两个要求时，你会有：
- en: '**[POOL_SYRS_010]: Pool temperature monitoring**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_010]: 游泳池温度监控**'
- en: The system shall monitor the pool temperature.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应监控游泳池温度。
- en: '**[POOL_SYRS_013]: Minimum pool temperature**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_013]: 最低游泳池温度**'
- en: The system shall turn on the pool heater if the pool temperature drops below
    70 degrees Fahrenheit.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游泳池温度低于70华氏度，系统应打开游泳池加热器。
- en: '**[POOL_SYRS_017]: Maximum heater on temperature**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_017]: 最大加热器开启温度**'
- en: The system shall turn off the pool heater if the pool temperature exceeds 70
    degrees Fahrenheit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游泳池温度超过70华氏度，系统应关闭游泳池加热器。
- en: '**[POOL_SYRS_020]: Maximum pool temperature**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**[POOL_SYRS_020]: 最大游泳池温度**'
- en: The system shall turn on the “High Temp” LED if the pool temperature exceeds
    86 degrees Fahrenheit.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游泳池温度超过86华氏度，系统应打开“高温”LED指示灯。
- en: Keep in mind that it’s important to make all the tags unique.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，确保所有标签唯一是很重要的。
- en: '**NOTE**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Thus far in this section, tags have been part of a paragraph title, which
    is useful when people want to search for the tags within the document (particularly,
    if the document is not in electronic form). However, you can also place tags within
    paragraphs.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，在本节中，标签一直是段落标题的一部分，这在需要在文档中搜索标签时非常有用（尤其是当文档不是电子版时）。不过，你也可以将标签放置在段落中。*'
- en: '**9.2.2.2 SRS Tags**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**9.2.2.2 SRS标签**'
- en: 'For system document sets that have only the SRS—not an SyRS—as the requirements
    document, “SRS” can simply replace “SYRS” in the tag: [POOL_SRS_010]: Pool temperature
    monitoring.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '对于仅包含SRS而不是SyRS作为需求文档的系统文档集，“SRS”可以简单地替换标签中的“SYRS”：[POOL_SRS_010]: 游泳池温度监控。'
- en: However, when a project’s document set includes both an SyRS and an SRS, this
    book uses a convention that builds reverse traceability from the SRS to the SyRS
    directly into the SRS tag. Such SRS tags have the format [*productID*_SRS_*xxx_yyy*].
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当一个项目的文档集同时包含SyRS和SRS时，本书使用一种约定，将SRS标签中的反向追溯性直接构建到SyRS中。这样的SRS标签格式为[*productID*_SRS_*xxx_yyy*]。
- en: 'The *productID* is the same as for the SyRS tag: SRS denotes a Software Requirements
    Specification tag (versus a System Requirements Specification tag), and *xxx*
    and *yyy* are decimal numbers, where *xxx* is the number of a corresponding SyRS
    tag (see “[SyRS Tags](#lev-9.2.2.1)” on [page 172](ch09.xhtml#page_172)).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*productID*与SyRS标签相同：SRS表示软件需求规格标签（与系统需求规格标签相对），*xxx*和*yyy*是十进制数字，其中*xxx*是对应的SyRS标签的编号（参见“[SyRS标签](#lev-9.2.2.1)”在[第172页](ch09.xhtml#page_172)）。'
- en: Including the tag number of the parent SyRS requirement embeds reverse traceability
    information for an SRS requirement directly into its tag. Because almost all SRS
    requirements are derived from a corresponding SyRS tag, and there is a one-to-many
    relationship between SyRS requirements and SRS requirements, a single SyRS requirement
    can generate one or more SRS requirements, but each SRS requirement can be traced
    back to just one SyRS requirement, as shown in [Figure 9-2](ch09.xhtml#ch9fig2).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 包含父SyRS需求的标签编号将反向可追溯性信息直接嵌入其标签中。因为几乎所有SRS需求都是从相应的SyRS标签派生的，并且SyRS需求和SRS需求之间是一个一对多的关系，一个SyRS需求可以生成一个或多个SRS需求，但每个SRS需求只能追溯到一个SyRS需求，如[图9-2](ch09.xhtml#ch9fig2)所示。
- en: '![image](Images/fig9-2.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig9-2.jpg)'
- en: '*Figure 9-2: An SyRS-to-SRS relationship*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：SyRS到SRS的关系*'
- en: 'The *yyy* component is the SRS tag value. As a general rule (and the convention
    this book follows), *yyy* doesn’t have to be unique among all the SRS tags, but
    the combination *xxx_yyy* must be unique. The following are all valid (and unique)
    SRS tags:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*yyy*组件是SRS标签值。作为一般规则（也是本书遵循的约定），*yyy*不必在所有SRS标签中是唯一的，但*xxx_yyy*的组合必须是唯一的。以下是所有有效（且唯一）的SRS标签：'
- en: '[POOL_SRS_020_001]'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[POOL_SRS_020_001]'
- en: '[POOL_SRS_020_001.5]'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[POOL_SRS_020_001.5]'
- en: '[POOL_SRS_020_002]'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[POOL_SRS_020_002]'
- en: '[POOL_SRS_030.1_005]'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[POOL_SRS_030.1_005]'
- en: '[POOL_SRS_031_003]'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[POOL_SRS_031_003]'
- en: This book also uses the convention of restarting the *yyy* numbering with each
    *xxx* value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本书还采用了在每个*xxx*值中重新开始*yyy*编号的约定。
- en: By constructing SRS tags this way, you build automatic reverse traceability
    from the SRS to the SyRS directly into the tag identifier. To locate the SyRS
    requirement associated with an SRS requirement, just extract the *xxx* value and
    search for the corresponding tag in your SyRS document. It’s also easy to locate
    SRS tags associated with an SyRS tag in the SRS document. For example, to find
    all SRS requirements associated with POOL_SYRS_030, search for all instances of
    “SRS_030” in your SRS document.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式构造SRS标签，你可以将从SRS到SyRS的自动反向可追溯性直接嵌入标签标识符中。要查找与SRS需求相关联的SyRS需求，只需提取*xxx*值并在SyRS文档中搜索相应的标签。也可以轻松地查找与SyRS标签相关联的SRS标签。例如，要找到所有与POOL_SYRS_030相关联的SRS需求，只需在SRS文档中搜索所有“SRS_030”的实例。
- en: It’s possible that an SRS document might produce some brand-new requirements
    that are not based on a specific SyRS requirement. If so, there won’t be an *xxx*
    number to use as part of the SRS tag. This book reserves SyRS tag number 000 (that
    is, there will never be an SyRS tag [*productID*_SYRS_000]), and any new SRS requirement
    that isn’t based on an SyRS requirement will take the form [*productID*_SRS_000_*yyy*].
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能SRS文档会产生一些全新的需求，这些需求并非基于某个特定的SyRS需求。如果是这样，则不会有*xxx*编号作为SRS标签的一部分。本书保留了SyRS标签编号000（即，永远不会有SyRS标签[*productID*_SYRS_000]），任何不基于SyRS需求的全新SRS需求将采用[*productID*_SRS_000_*yyy*]的形式。
- en: '**NOTE**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Another convention this book uses is to substitute an asterisk (*) in place
    of the* 000 *value.*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书使用的另一个约定是用星号（*）代替*000*值。*'
- en: It’s a good idea to include all software-related requirements from the SyRS
    directly in the SRS.^([3](ch19_footnote.xhtml#ch09fn3)) This allows the SRS to
    serve as a stand-alone document for software developers to use. When copying SyRS
    requirements directly into the SRS, we’ll use the syntax [*productID*_SRS_*xxx*_000]
    for the copied requirement tags. That is, a *yyy* value of 000 denotes a copied
    tag.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有与软件相关的SyRS需求直接包含在SRS中是一个好主意。^([3](ch19_footnote.xhtml#ch09fn3)) 这样，SRS就能作为一个独立的文档供软件开发人员使用。当将SyRS需求直接复制到SRS时，我们将使用语法[*productID*_SRS_*xxx*_000]来表示复制的需求标签。也就是说，*yyy*值为000表示这是一个复制的标签。
- en: '**9.2.2.3 SDD Tags**'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**9.2.2.3 SDD标签**'
- en: Unfortunately, there is not a one-to-many relationship between SRS requirements
    and SDD design elements.^([4](ch19_footnote.xhtml#ch09fn4)) That makes it more
    difficult to build reverse traceability from an SDD tag to the corresponding SRS
    tag into the SDD tag syntax. You’ll have to rely on an external RTM document to
    provide the links between the SRS and SDD documents.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，SRS需求和SDD设计元素之间并不是一对多的关系。^([4](ch19_footnote.xhtml#ch09fn4)) 这使得从SDD标签到相应SRS标签的反向可追溯性更难通过SDD标签语法构建。你必须依赖外部的RTM文档来提供SRS和SDD文档之间的链接。
- en: Given that reverse traceability is not practical in the SDD tag, this book uses
    the simplified SDD tag format [*productID*_SDD_*ddd*], where *productID* has the
    usual meaning, and *ddd* is a unique identifier similar to *xxx* in the SyRS tag.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于在SDD标签中反向追踪性并不实用，本书使用简化的SDD标签格式[*productID*_SDD_*ddd*]，其中 *productID* 具有通常的含义，而
    *ddd* 是类似于SyRS标签中 *xxx* 的唯一标识符。
- en: '**9.2.2.4 STC Tags**'
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**9.2.2.4 STC标签**'
- en: There should be a one-to-many relationship between SRS requirements and STC
    test cases, as shown in [Figure 9-3](ch09.xhtml#ch9fig3).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SRS要求与STC测试用例之间应具有一对多的关系，如[图9-3](ch09.xhtml#ch9fig3)所示。
- en: '![image](Images/fig9-3.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig9-3.jpg)'
- en: '*Figure 9-3: An SRS-to-STC tag relationship*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：SRS到STC标签的关系*'
- en: This means you can build reverse traceability from the STC to the SRS into the
    tags, just as you did from the SRS to the SyRS. For STC tags, this book uses the
    syntax [*productID*_STC_*xxx_yyy_zzz*]. If all your *yyy* values were unique (rather
    than the *xxx_yyy* combination being unique), you could drop the *xxx* from the
    tag, but having both *xxx* and *yyy* does provide reverse traceability to both
    the SRS and SyRS, which can be convenient (at the expense of extra typing for
    your STC tags).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以将STC到SRS的反向追踪性编码到标签中，就像你之前从SRS到SyRS那样。对于STC标签，本书使用语法[*productID*_STC_*xxx_yyy_zzz*]。如果所有的
    *yyy* 值都是唯一的（而不是 *xxx_yyy* 的组合唯一），你可以去掉标签中的 *xxx*，但保留 *xxx* 和 *yyy* 组合有助于同时提供对SRS和SyRS的反向追踪性，这在某些情况下很方便（尽管会增加输入STC标签的工作量）。
- en: 'Although it rarely occurs, it’s possible to create a unique test case that
    isn’t based on any SRS requirement.^([5](ch19_footnote.xhtml#ch09fn5)) For example,
    the software engineers using the SDD to implement the code might create test cases
    based on the source code they write. In such situations, this book uses the scheme
    shown previously for SRS requirements that aren’t based on an SyRS requirement:
    we reserve the *xxx*_*yyy* value of 000_000 or *_*, and any new STC tags that
    aren’t based on a requirement tag will use 000 as the tag number suffix. An *xxx*_000
    component means that the test case is based on an SyRS requirement but not any
    underlying SRS requirement (or perhaps it’s based on the SRS tag copied from the
    SyRS using the syntax shown earlier); this is not a stand-alone test case.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种情况很少发生，但确实有可能创建一个不基于任何SRS要求的唯一测试用例。^([5](ch19_footnote.xhtml#ch09fn5)) 例如，使用SDD实现代码的软件工程师可能会根据他们编写的源代码创建测试用例。在这种情况下，本书使用之前为那些不基于SyRS要求的SRS要求所示的方案：我们将
    *xxx*_*yyy* 的值保留为000_000或 *_*，任何不基于要求标签的新STC标签将使用000作为标签编号后缀。一个 *xxx*_000 组件意味着该测试用例是基于SyRS要求，但不是任何基础的SRS要求（或者可能是基于通过前述语法从SyRS复制过来的SRS标签）；这不是一个独立的测试用例。
- en: 'STC tags that have the numeric form 000_000 don’t contain any traceability
    information. In such cases, you’ll need to explicitly provide link information
    to describe the origin of the test case. Here are a few suggestions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数值形式为000_000的STC标签不包含任何追踪性信息。在这种情况下，你需要明确提供链接信息以描述测试用例的来源。以下是一些建议：
- en: Use *:source* after the tag to describe the source of the test case (where *source*
    is the name of the file or other document containing the information producing
    the test case).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签后使用 *:source* 来描述测试用例的来源（其中 *source* 是包含生成测试用例信息的文件或其他文档的名称）。
- en: Use an RTM to provide the source information (see the next section, “The Requirements/Reverse
    Traceability Matrix,” for more details).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RTM提供源信息（请参见下一节，“要求/反向追踪性矩阵”获取更多详细信息）。
- en: Ensure that the document containing the source of the test case contains a comment
    or other link specifying the STC tag.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保包含测试用例来源的文档中有注释或其他链接，明确指定STC标签。
- en: '**9.2.2.5 STP Tags**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**9.2.2.5 STP标签**'
- en: STC test cases have a many-to-one relationship with STP test procedures, as
    shown in [Figure 9-4](ch09.xhtml#ch9fig4).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: STC测试用例与STP测试程序之间具有多对一的关系，如[图9-4](ch09.xhtml#ch9fig4)所示。
- en: '![image](Images/fig9-4.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig9-4.jpg)'
- en: '*Figure 9-4: An STC-to-STP tag relationship*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-4：STC到STP标签的关系*'
- en: This means, as with the SDD, you can’t encode reverse traceability information
    into the STP tags. Therefore, for STP tags this book uses the syntax [*productID*_STP_*ppp*],
    where *productID* has the usual meaning, and *ppp* is a unique STP tag value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，和SDD一样，你不能将反向追踪性信息编码到STP标签中。因此，对于STP标签，本书使用语法[*productID*_STP_*ppp*]，其中
    *productID* 具有通常的含义，*ppp* 是唯一的STP标签值。
- en: '***9.2.3 The Requirements/Reverse Traceability Matrix***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.2.3 要求/反向追踪性矩阵***'
- en: As mentioned, it isn’t possible to build reverse traceability into the SDD and
    STP tags, so you’ll need the Requirements/Reverse Traceability Matrix (RTM).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，无法将反向可追溯性构建到SDD和STP标签中，因此你需要使用需求/反向可追溯性矩阵（RTM）。
- en: 'As its name implies, an RTM is a two-dimensional matrix, or table, wherein:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，RTM是一个二维矩阵或表格，其中：
- en: Each row specifies a link between requirements, design items, test cases, or
    test procedures.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一行指定了需求、设计项、测试用例或测试过程之间的关联。
- en: Each column specifies a particular document (SyRS, SRS, SDD, STC, or STP).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一列指定了一个特定的文档（SyRS、SRS、SDD、STC或STP）。
- en: Each cell contains the tag for the associated document type.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单元格包含与之关联的文档类型的标签。
- en: 'A typical row in the table might contain entries such as the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的一典型行可能包含如下条目：
- en: '![image](Images/page_178.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/page_178.jpg)'
- en: In general, the SyRS or SRS requirement tags drive the RTM, and you’d usually
    organize the table by sorting it via these columns.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，SyRS或SRS需求标签是RTM的驱动因素，你通常会通过这些列对表格进行排序。
- en: 'Because there is a one-to-many relationship between SyRS requirements and SRS
    requirements, you might need to replicate the SyRS requirements across multiple
    rows, as in this example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SyRS需求和SRS需求之间存在一对多的关系，你可能需要在多个行中复制SyRS需求，如以下示例所示：
- en: '![image](Images/page_179_1.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/page_179_1.jpg)'
- en: Rows 1, 2, and 3 share the same SyRS tag with different SRS tags; rows 3 and
    4 share the same SRS tags (and SyRS tags) with differing STC tags.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第1、2和3行共享相同的SyRS标签，但有不同的SRS标签；第3和4行共享相同的SRS标签（以及SyRS标签），但有不同的STC标签。
- en: 'Sometimes, it might be cleaner to omit duplicate SyRS and SRS tags when they
    can be inferred from previous rows, like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当SyRS和SRS标签可以从前面的行推断出来时，省略重复的标签会更简洁，如下所示：
- en: '![image](Images/page_179_2.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/page_179_2.jpg)'
- en: Although you could create an RTM using a word processor (for example, Microsoft
    Word or Apple Pages), a far better solution is to use a spreadsheet program (for
    example, Microsoft Excel or Apple Numbers) or a database application, which allows
    you to easily sort the rows in the table based on your current requirements. This
    book assumes you’re using a spreadsheet program.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用文字处理器（例如Microsoft Word或Apple Pages）创建RTM，但一个更好的解决方案是使用电子表格程序（例如Microsoft
    Excel或Apple Numbers）或数据库应用程序，它们可以让你根据当前需求轻松地对表格中的行进行排序。本书假设你正在使用电子表格程序。
- en: '**9.2.3.1 Adding Extra Columns**'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**9.2.3.1 添加额外的列**'
- en: At a bare minimum, you’ll want one column in the RTM for each system document
    type—SyRS (if present), SRS, SDD, STC, and STP—but you might want to include other
    information in the RTM as well. For example, you might consider a “Description”
    column that can help make sense of all the tags.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，你会希望RTM中为每种系统文档类型设置一列——SyRS（如果有的话）、SRS、SDD、STC和STP——但你可能还希望在RTM中包含其他信息。例如，你可以考虑增加一个“描述”列，帮助理解所有标签的含义。
- en: Or, if you have an SyRS document, an “Allocations” column might be useful to
    specify whether an SyRS item is hardware, software, or other. Note that SRS, SDD,
    STP, and STC (by definition) are always software related, so the Allocations entry
    would be either “N/A” (not applicable) or always “software” for such tags.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你有一个SyRS文档，“分配”列可能会有用，用来指定一个SyRS条目是硬件、软件还是其他。请注意，SRS、SDD、STP和STC（按定义）始终与软件相关，因此这些标签的分配项将是“无”（不适用）或始终为“软件”。
- en: Another useful column might be “Verification,” which describes how a particular
    requirement might be tested (or verified) in the system. Examples of verification
    types might be test (as part of a software test procedure), by review, by inspection,
    by design, by analysis, other, or no test possible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的列可能是“验证”，它描述了如何在系统中测试（或验证）特定需求。验证类型的示例可能是测试（作为软件测试过程的一部分）、审查、检查、设计、分析、其他或无法测试。
- en: One last option is an additional column (or columns) containing some row numbers
    you can use to quickly sort data in different ways. For example, you might add
    a column numbered 1 through *n* (where *n* is the number of rows) that, when sorted,
    lists the rows in order of requirements (SyRS and SRS); another column numbered
    1 through *n* that could order the rows by SDD tag values; and so on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是添加一个额外的列（或多列），包含一些行号，你可以用它们快速地按不同方式对数据进行排序。例如，你可能会添加一个从1到*n*（其中*n*是行数）编号的列，排序后按需求（SyRS和SRS）列出行；另一个从1到*n*编号的列，可以按SDD标签值排序行，依此类推。
- en: '**9.2.3.2 Sorting the RTM**'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**9.2.3.2 排序RTM**'
- en: 'Of course, if you fill in every cell in the matrix, you can sort by column
    values (or multiple column values). For example, suppose you’re using Microsoft
    Excel and the columns are organized as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你填写了矩阵中的每一个单元格，你可以通过列值（或多个列值）进行排序。例如，假设你正在使用 Microsoft Excel，且列按如下方式组织：
- en: 'A: Description'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'A: 描述'
- en: 'B: SyRS tags'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'B: SyRS 标签'
- en: 'C: Allocations'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 'C: 分配'
- en: 'D: SRS tags'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'D: SRS 标签'
- en: 'E: Testing method'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'E: 测试方法'
- en: 'F: SDD tags'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'F: SDD 标签'
- en: 'G: STC tags'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'G: STC 标签'
- en: 'H: STP tags'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'H: STP 标签'
- en: Sorting by column B, then by D, then by G, will sort the document in requirements
    order. Sorting by column F, then by B, then by D, will sort the document in design
    element order. Sorting by column H, then by D, then by G, will sort the document
    in test procedure order.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 按照列 B 排序，然后是列 D，再然后是列 G，将按需求顺序对文档进行排序。按照列 F 排序，然后是列 B，再然后是列 D，将按设计元素顺序对文档进行排序。按照列
    H 排序，然后是列 D，再然后是列 G，将按测试程序顺序对文档进行排序。
- en: To use the RTM to trace from an SyRS or SRS requirement to an SRS requirement,
    SDD design item, STC test case, or STP test procedure, simply sort the matrix
    by requirements order, find the SyRS or SRS tag you’re interested in, and then
    pick out the corresponding tag(s) for the other document(s) from the same row
    as the requirement tag. You can use this same scheme to trace from STC tags to
    the corresponding test procedure (because the requirements sort will also sort
    the test case tags).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 RTM 从 SyRS 或 SRS 需求追溯到 SRS 需求、SDD 设计项、STC 测试用例或 STP 测试程序，只需按照需求顺序对矩阵进行排序，找到你感兴趣的
    SyRS 或 SRS 标签，然后从同一行中挑选出其他文档的对应标签。你可以使用这个方案从 STC 标签追溯到相应的测试程序（因为需求排序也会排序测试用例标签）。
- en: 'Reverse traceability from STC to SRS to SyRS is inherent in the tag syntax,
    so nothing special is needed for this operation. Reverse traceability from the
    SDD to the SRS (or SyRS) and from the STP to the STC/SRS/SyRS is a little more
    involved. First, sort the matrix by SDD tag order or STP tag order. This will
    give you a list of SDD or STP tags all collected together (and sorted in lexicographical
    order). Now all the tags on the rows containing a particular SDD or STP tag will
    be the tags of interest to you. The following example shows the previous RTM examples
    sorted by test procedure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从 STC 到 SRS 再到 SyRS 的反向可追溯性是标签语法的固有特性，因此进行此操作不需要特别的处理。从 SDD 到 SRS（或 SyRS）以及从
    STP 到 STC/SRS/SyRS 的反向可追溯性则稍微复杂一些。首先，按 SDD 标签顺序或 STP 标签顺序对矩阵进行排序。这将给你一个所有 SDD
    或 STP 标签按字典顺序排列的列表。现在，包含特定 SDD 或 STP 标签的行上的所有标签就是你需要关注的标签。以下示例显示了按测试程序排序的前述 RTM
    示例：
- en: '![image](Images/page_180.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/page_180.jpg)'
- en: In this table, you can easily see that test procedure 005 is associated with
    SyRS tag 020 and SRS tags 020_001 and 020_002\. In this simple example, you wouldn’t
    have to sort the data to determine these links. But with a more complex RTM (with
    dozens, hundreds, or even thousands of requirements), it would be significantly
    more work to manually search for these reverse links if the table wasn’t sorted
    by STP tags.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表格中，你可以很容易地看到测试程序 005 与 SyRS 标签 020 和 SRS 标签 020_001 以及 020_002 相关联。在这个简单的例子中，你不需要排序数据就能确定这些链接。但是，如果是更复杂的
    RTM（包含数十、数百甚至上千个需求），如果表格没有按照 STP 标签排序，那么手动查找这些反向链接将会是相当繁琐的工作。
- en: '**9.3 Validation, Verification, and Reviews**'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.3 验证、确认与评审**'
- en: Validation (see “[The Iterative Model](ch03.xhtml#lev-3.2.4)” on [page 46](ch03.xhtml#page_46))
    is the process of showing that the product meets the end users’ needs (that is,
    “Are we building the right product?”), while verification is ensuring that you’ve
    built it to satisfy the project specifications (that is, “Are we building the
    product right?”). While validation takes place at the end of the requirements
    phase(s) and at the end of the entire development cycle (see “[Reducing Costs
    via Validation](ch09.xhtml#lev-9.4.1)” on [page 182](ch09.xhtml#page_182)), verification
    typically occurs at the end of each phase in the software development process
    to ensure that the phase respects all the input requirements. For example, verification
    of the SDD would consist of ensuring that it covers all the requirements in the
    SRS document (the SRS requirements are the input to the SDD stage).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 验证（参见“[迭代模型](ch03.xhtml#lev-3.2.4)”在[第46页](ch03.xhtml#page_46)）是证明产品满足最终用户需求的过程（即，“我们是否在构建正确的产品？”），而验证是确保你已按照项目规范构建它的过程（即，“我们是否在正确地构建产品？”）。验证通常在需求阶段结束时和整个开发周期结束时进行（参见“[通过验证降低成本](ch09.xhtml#lev-9.4.1)”在[第182页](ch09.xhtml#page_182)）。而验证通常发生在软件开发过程的每个阶段结束时，以确保该阶段符合所有输入需求。例如，SDD的验证将包括确保它覆盖了SRS文档中的所有需求（SRS需求是SDD阶段的输入）。
- en: 'The verification steps for each phase are as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段的验证步骤如下：
- en: '**SyRS/SRS** Ensuring that the requirements in the document fully cover all
    the requirements provided by the customer—perhaps from UML use cases (see “[The
    UML Use Case Model](ch04.xhtml#lev-4.2)” on [page 74](ch04.xhtml#page_74)) or
    the customer’s functional specification.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**SyRS/SRS** 确保文档中的需求充分覆盖了客户提供的所有需求——可能来自UML用例（参见“[UML用例模型](ch04.xhtml#lev-4.2)”在[第74页](ch04.xhtml#page_74)）或客户的功能规格。'
- en: '**SDD** Ensuring that the design covers all requirements. The input is the
    requirements from the SRS.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**SDD** 确保设计覆盖了所有需求。输入是来自SRS的需求。'
- en: '**STC** Ensuring that at least one test case exists for each (testable) requirement.
    The inputs are the requirements from the SRS.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**STC** 确保每个（可测试的）需求都有至少一个测试用例。输入是来自SRS的需求。'
- en: '**STP** Ensuring that all the test cases are covered by the test procedures.
    The inputs are the test cases from the STC (and, indirectly, the requirements
    on which the test cases are based).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**STP** 确保所有测试用例都被测试过程涵盖。输入是来自STC的测试用例（间接地，也是基于测试用例的需求）。'
- en: To verify each preceding phase, you’ll need to review the document resulting
    from it. The RTM will prove useful during these reviews. For example, when reviewing
    the SDD, you’d search for each requirement in the SRS, look up the corresponding
    SDD tag, and then verify that the design element implements the specified requirement.
    You’d use the same process to verify that the STC document covers all the requirements
    with test cases.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证每个前置阶段，你需要审查由该阶段生成的文档。在这些审查中，RTM将非常有用。例如，在审查SDD时，你会在SRS中查找每个需求，找到相应的SDD标签，然后验证设计元素是否实现了指定的需求。你将使用相同的过程验证STC文档是否通过测试用例覆盖了所有需求。
- en: When you’re reviewing the code, the safest approach is to go through all the
    inputs to a phase (that is, requirements for the SDD and STC, and test cases for
    the STP) and physically check each input off after verifying that you properly
    handled it. This final list becomes part of the review document for that phase.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查代码时，最安全的方法是逐一检查每个阶段的所有输入（即SDD和STC的需求，以及STP的测试用例），并在验证正确处理后将每个输入标记为已完成。这个最终清单将成为该阶段审查文档的一部分。
- en: In the review process, you should also confirm the correctness of the outputs
    from the phase. For example, when reviewing the SRS, you should check each requirement
    to make sure it’s useful (see “[The Software Requirements Specification Document](ch10.xhtml#lev-10.4)”
    on [page 194](ch10.xhtml#page_194)); when reviewing the SDD, you should make sure
    each design item is correct (for example, you’re using suitable algorithms and
    handling concurrent operations appropriately); when reviewing the STC documentation,
    you should ensure each test case properly tests the associated requirement; and
    when reviewing the STP, you should verify that each test procedure properly tests
    its associated test cases.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查过程中，你还应确认各阶段输出的正确性。例如，在审查SRS时，你应该检查每个需求，确保其有用（参见[《软件需求规格说明书》](ch10.xhtml#lev-10.4)第[194页](ch10.xhtml#page_194)）；在审查SDD时，应该确保每个设计项是正确的（例如，使用了合适的算法并恰当处理了并发操作）；在审查STC文档时，应该确保每个测试用例能够正确测试相关需求；在审查STP时，应该验证每个测试程序能够正确测试其关联的测试用例。
- en: If at all possible, and for the best results, an engineer other than the document
    author should conduct the final, formal review, or a second engineer should participate
    in the review process. The document author is more likely to gloss over an omission,
    because they’re too close to that portion of the project and could mentally fill
    in missing elements during the review. Of course, they should do their own review
    of the document prior to submitting it for formal review.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，为了获得最佳效果，最好由文档作者以外的工程师进行最终的正式审查，或者由另一位工程师参与审查过程。文档作者由于与项目的某一部分过于接近，可能会忽略遗漏的内容，在审查时他们可能会在脑海中补充缺失的元素。因此，文档作者应该在提交正式审查之前，先对文档进行自我审查。
- en: '**9.4 Reducing Development Costs Using Documentation**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.4 使用文档减少开发成本**'
- en: 'Documentation costs are often a major component of a project’s overall cost.
    Part of the reason is that there is so *much* documentation. But another reason
    is that the documents are interdependent, which makes them difficult to update
    and maintain. In *Code Complete* (Microsoft Press, 2004), Steve McConnell reports
    that, compared to the requirements phase, correcting errors is 3 times more expensive
    during the design (architectural) phase, 5 to 10 times more expensive during coding,
    and 10 times more expensive during system testing. There a couple of reasons for
    this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 文档成本通常是项目整体成本的一个主要组成部分。部分原因是文档数量*过多*。但另一个原因是这些文档相互依赖，这使得它们难以更新和维护。在《*Code Complete*》（微软出版社，2004）一书中，Steve
    McConnell报告称，与需求阶段相比，在设计（架构）阶段修正错误的成本是其三倍，在编码阶段是五到十倍，而在系统测试阶段则是十倍。造成这种情况有几个原因：
- en: If you fix a defect early in the development process, you don’t waste time writing
    additional documentation, coding, and testing defective designs. For example,
    it takes time to write the SDD documentation for a requirement, to write code
    to implement that requirement, to write test cases and test procedures for the
    requirement, and to run those tests. If the requirement was wrong to begin with,
    you’ve wasted all that effort.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在开发过程的早期修复缺陷，你就不会浪费时间编写额外的文档、编写代码和测试有缺陷的设计。例如，为了某个需求编写SDD文档、编写实现该需求的代码、编写测试用例和测试程序并执行这些测试，都是需要时间的。如果该需求本身就有问题，那么你就浪费了所有这些努力。
- en: If you discover a defective item in one phase of the system, you have to locate
    and edit anything associated with that defect throughout the rest of the system.
    This can be laborious work, and it’s easy to miss changes, which creates inconsistencies
    and other problems down the line.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在系统的某个阶段发现了缺陷项，你必须找到并编辑所有与该缺陷相关的内容，这项工作可能会很繁琐，且容易遗漏修改，进而导致不一致性和其他后续问题。
- en: '***9.4.1 Reducing Costs via Validation***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.4.1 通过验证减少成本***'
- en: Nowhere is the validation activity more important than in the requirements phase
    (SyRS and SRS development). If you insist that the customer understands and approves
    all requirements before moving on to later phases, you can ensure there are no
    unwanted requirements and that you’re solving the customer’s problems. Few things
    are worse than spending several months documenting, coding, and testing a program’s
    feature only to have the customer say, “This isn’t what we were asking for.” A
    good validation process can help reduce the likelihood of this scenario.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何地方比需求阶段（SyRS和SRS开发）更需要验证活动。如果你坚持要求客户在进入后续阶段之前理解并批准所有需求，你可以确保没有不必要的需求，并且你正在解决客户的问题。没有什么比花费几个月时间记录、编码和测试程序的功能，最终客户却说：“这不是我们要求的”更糟糕了。一个良好的验证过程可以帮助减少这种情况的发生概率。
- en: 'Validation, which should take place at the end of the requirements phase(s)
    and at the end of the development cycle, involves asking the following questions:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 验证应在需求阶段结束和开发周期结束时进行，涉及提出以下问题：
- en: '**SyRS (if present)**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**SyRS（如果存在）**'
- en: Is each existing requirement important? Does the requirement describe some feature
    that the customer wants?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个现有需求是否重要？该需求是否描述了客户想要的某个功能？
- en: Is each requirement correct? Does it precisely state (without ambiguity) exactly
    what the customer wants?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个需求是否正确？它是否明确地（没有歧义）说明了客户的要求？
- en: Are there any missing requirements?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否存在遗漏的需求？
- en: '**SRS**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**SRS**'
- en: Are all software requirements listed in the SyRS (if present) also listed in
    the SRS?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SyRS（如果存在）中列出的所有软件需求是否也列在SRS中？
- en: Is each existing requirement important? Is this feature important to the system
    architect and agreed upon by the customer?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个现有需求是否重要？这个功能是否对系统架构师重要，并且已得到客户的同意？
- en: Is each requirement correct? Does it precisely state (without ambiguity) exactly
    what the software must do to be effective?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个需求是否正确？它是否明确地（没有歧义）说明了软件必须做什么才能有效？
- en: Are there any missing requirements?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否存在遗漏的需求？
- en: During final acceptance testing, the test engineer(s) should have a list of
    all the requirements in the SRS in a checkbox form. They should check off each
    requirement as it’s tested (perhaps when following the test procedures in the
    STP) to ensure that the software implements it correctly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终验收测试过程中，测试工程师应持有SRS中所有需求的清单，并以复选框的形式列出。当每个需求被测试时，他们应勾选该需求（可能是在执行STP中的测试程序时），以确保软件正确地实现了该需求。
- en: '***9.4.2 Reducing Costs via Verification***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.4.2 通过验证减少成本***'
- en: 'As mentioned in “Validation, Verification, and Reviews” on [page 181](ch09.xhtml#page_181),
    verification should occur after each phase of the software development process.
    In particular, there should be a verification step associated with each of the
    system documents after the SRS. Here are some questions you might ask after completing
    each document:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第181页](ch09.xhtml#page_181)的“验证、确认与评审”中提到的，验证应在软件开发过程的每个阶段之后进行。特别是，在SRS之后，每个系统文档都应有一个验证步骤。以下是完成每个文档后你可能会问的一些问题：
- en: '**SDD**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**SDD**'
- en: Do the design components completely cover all the requirements in the SRS?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计组件是否完全覆盖了SRS中的所有需求？
- en: Is there a many-to-one (or one-to-one) relationship between requirements (many)
    and software design elements (one)? Although a design item might satisfy multiple
    requirements, it should not take multiple design elements to satisfy a single
    requirement.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需求（多个）与软件设计元素（一个）之间是否存在多对一（或一对一）的关系？虽然一个设计项可能满足多个需求，但不应需要多个设计元素来满足单一需求。
- en: Does a software design element provide an accurate design that will implement
    the given requirement(s)?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 某个软件设计元素是否提供了一个准确的设计来实现给定的需求？
- en: '**STC**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**STC**'
- en: Is there a one-to-many (or one-to-one) relationship between requirements and
    test cases? (That is, a requirement can have multiple associated test cases, but
    you shouldn’t have multiple requirements sharing the same test case.^([6](ch19_footnote.xhtml#ch09fn6)))
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需求与测试用例之间是否存在一对多（或一对一）的关系？（也就是说，一个需求可以有多个相关的测试用例，但不应有多个需求共享同一个测试用例。^([6](ch19_footnote.xhtml#ch09fn6)))
- en: Does a particular test case accurately test the associated requirement?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 某个特定的测试用例是否准确测试了相关的需求？
- en: Do all the test cases associated with a requirement completely test the correct
    implementation of that requirement?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与某个需求相关的所有测试用例是否完全测试了该需求的正确实现？
- en: '**STP**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**STP**'
- en: Is there a many-to-one relationship between test cases in the STC and test procedures
    in the STP? That is, does a test procedure implement one or more test cases while
    each test case is handled by exactly one test procedure?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试用例在STC与测试程序在STP之间是否存在多对一关系？也就是说，是否一个测试程序实现一个或多个测试用例，而每个测试用例仅由一个测试程序处理？
- en: Does a given test procedure accurately implement all its associated test cases?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定的测试程序是否准确实现了所有关联的测试用例？
- en: '**9.5 For More Information**'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.5 了解更多信息**'
- en: 'Bremer, Michael. *The User Manual Manual: How to Research, Write, Test, Edit,
    and Produce a Software Manual*. Grass Valley, CA: UnTechnical Press, 1999\. A
    sample chapter is available at *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Bremer, Michael. *用户手册手册：如何研究、编写、测试、编辑和制作软件手册*. 草谷，加利福尼亚州：UnTechnical出版社，1999年。样章可在
    *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*
    下载。
- en: 'IEEE. “IEEE Standard 830-1998: IEEE Recommended Practice for Software Requirements
    Specifications.” October 20, 1998\. *[https://doi.org/10.1109/IEEESTD.1998.88286](https://doi.org/10.1109/IEEESTD.1998.88286)*.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE. “IEEE标准830-1998：IEEE软件需求规范推荐实践。” 1998年10月20日。 *[https://doi.org/10.1109/IEEESTD.1998.88286](https://doi.org/10.1109/IEEESTD.1998.88286)*。
- en: 'Leffingwell, Dean, and Don Widrig. *Managing Software Requirements*. Boston:
    Addison-Wesley Professional, 2003.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Leffingwell, Dean, 和 Don Widrig. *管理软件需求*. 波士顿：Addison-Wesley专业出版，2003年。
- en: 'McConnell, Steve. *Code Complete*. 2nd ed. Redmond, WA: Microsoft Press, 2004.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: McConnell, Steve. *代码大全*. 第二版. 雷德蒙德，WA：微软出版社，2004年。
- en: 'Miles, Russ, and Kim Hamilton. *Learning UML 2.0: A Pragmatic Introduction
    to UML*. Sebastopol, CA: O’Reilly Media, 2003.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Miles, Russ, 和 Kim Hamilton. *学习UML 2.0：UML实用入门*. 塞巴斯托波尔，加利福尼亚州：O’Reilly Media，2003年。
- en: 'Pender, Tom. *UML Bible*. Indianapolis: Wiley, 2003.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Pender, Tom. *UML圣经*. 印第安纳波利斯：Wiley出版社，2003年。
- en: 'Roff, Jason T. *UML: A Beginner’s Guide*. Berkeley, CA: McGraw-Hill Education,
    2003.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'Roff, Jason T. *UML: 初学者指南*. 伯克利，加利福尼亚州：麦格劳-希尔教育，2003年。'
- en: 'Wiegers, Karl E. *Software Requirements*. Redmond, WA: Microsoft Press, 2009.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Wiegers, Karl E. *软件需求*. 雷德蒙德，WA：微软出版社，2009年。
- en: '———. “Writing Quality Requirements.” *Software Development* 7, no. 5 (May 1999):
    44–48.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ———. “编写质量需求。” *软件开发* 7，5期（1999年5月）：44–48。
