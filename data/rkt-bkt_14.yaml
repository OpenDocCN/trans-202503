- en: '**12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: 'GAPZ: ADVANCED VBR INFECTION**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**GAPZ：高级 VBR 感染**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'This chapter examines one of the stealthiest bootkits ever seen in the wild:
    the Win32/Gapz bootkit. We’ll cover its technical characteristics and functionality,
    beginning with the dropper and bootkit components and moving on to the user-mode
    payload.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了野外发现的最隐秘的引导病毒之一：Win32/Gapz 引导病毒。我们将讨论其技术特性和功能，从引导程序和引导病毒组件开始，接着讲解用户模式的有效载荷。
- en: In our experience, Gapz is the most complex bootkit ever analyzed. Every feature
    of its design and implementation—its elaborate dropper, advanced bootkit infection,
    and extended rootkit functionality—ensures that Gapz is able to infect and persist
    on victims’ computers and stay under the radar for a long time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，Gapz 是迄今为止分析过的最复杂的引导病毒。它的每一个设计和实现特性——复杂的引导程序、先进的引导病毒感染方法、以及扩展的 rootkit
    功能——都确保了 Gapz 能够感染并持续存在于受害者的计算机中，并长期保持隐蔽。
- en: Gapz is installed onto the victim’s system by a dropper that exploits multiple
    local privilege escalation vulnerabilities and implements an unusual technique
    for bypassing Host Intrusion Prevention Systems (HIPS).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz 是通过一个利用多个本地特权升级漏洞并实施绕过主机入侵防御系统（HIPS）的非同寻常技术的引导程序安装到受害者系统上的。
- en: After successfully penetrating the victim’s system, the dropper installs the
    bootkit, which has a very small footprint and is hard to spot on the infected
    system. The bootkit loads malicious code that implements the Gapz rootkit functionality
    into kernel mode.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功渗透到受害者系统后，引导程序安装了引导病毒，该病毒占用空间非常小，且在感染系统上难以被发现。引导病毒将恶意代码加载到内核模式中，执行 Gapz rootkit
    功能。
- en: The rootkit functionality is very rich, comprising a custom TCP/IP network stack,
    advanced hooking engine, crypto library, and payload injection engine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 其 rootkit 功能非常丰富，包括自定义 TCP/IP 网络栈、先进的钩子引擎、加密库和有效载荷注入引擎。
- en: This chapter takes a deep dive into each of these powerful features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了这些强大功能的每个方面。
- en: '**WHY IS IT CALLED GAPZ?**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么它叫 GAPZ？**'
- en: 'This bootkit gets its name from the string `‘GAPZ’`, which is used throughout
    all the binaries and shellcode as a tag for allocating memory. For example, the
    fragment of kernel-mode code shown here allocates memory by executing the `ExAllocatePoolWithTag`
    routine with the third parameter `‘ZPAG’` ➊ (`‘GAPZ’` in reverse):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该引导病毒的名字来源于字符串`‘GAPZ’`，该字符串在所有二进制文件和 shellcode 中作为分配内存的标记使用。例如，下面这段内核模式代码通过执行
    `ExAllocatePoolWithTag` 函数，并使用第三个参数`‘ZPAG’` ➊（即反向的`‘GAPZ’`）来分配内存：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**The Gapz Dropper**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Gapz 引导程序**'
- en: Gapz is installed onto the target system by an elaborate dropper. There are
    several variations of the Gapz dropper, all containing a similar payload, which
    we’ll cover later in “[Gapz Rootkit Functionality](ch12.xhtml#ch12lev1sec3)” on
    [page 191](ch12.xhtml#page_191). The difference between the droppers lies in the
    bootkit technique and the number of *local privilege escalation (LPE)* vulnerabilities
    they each exploit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz 是通过复杂的引导程序安装到目标系统上的。Gapz 引导程序有多个变种，所有变种都包含一个相似的有效载荷，稍后我们将在[《Gapz Rootkit
    功能》](ch12.xhtml#ch12lev1sec3)章节中详细讨论（第191页）。这些引导程序的区别在于引导病毒技术和它们各自利用的*本地特权升级（LPE）*
    漏洞的数量。
- en: The first instance of Gapz discovered in the wild was Win32/Gapz.C, in April
    2012.^([1](footnotes.xhtml#ch12fn1)) This variation of the dropper employed an
    MBR-based bootkit—the same technique covered in [Chapter 7](ch07.xhtml#ch07) for
    the TDL4 bootkit—to persist on a victim’s computer. What made Win32/Gapz.C remarkable
    was that it contained a lot of verbose strings for debugging and testing and that
    its early distribution was very limited. This suggests that the first versions
    of Gapz weren’t intended for mass distribution but rather were test versions to
    debug the malware’s functionality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个在野外发现的 Gapz 版本是 Win32/Gapz.C，发现时间为2012年4月^([1](footnotes.xhtml#ch12fn1))。这种引导程序变种使用了基于
    MBR 的引导病毒——与第7章中讨论的 TDL4 引导病毒使用的技术相同——来在受害者计算机上保持持久性。Win32/Gapz.C 的显著特点是它包含了大量用于调试和测试的冗长字符串，并且它的早期分发非常有限。这表明
    Gapz 的最早版本并不是为了大规模分发，而是测试版，用于调试恶意软件的功能。
- en: The second variation, Win32/Gapz.B, didn’t install a bootkit on the targeted
    system at all. To persist on the victim’s system, Gapz simply installed a malicious
    kernel-mode driver. However, this approach wouldn’t work on Microsoft Windows
    64-bit platforms due to the lack of a valid digital signature for the kernel-mode
    driver, limiting this modification to Microsoft Windows 32-bit operating systems
    only.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变种Win32/Gapz.B根本没有在目标系统上安装bootkit。为了在受害者系统上保持持久性，Gapz仅安装了一个恶意的内核模式驱动程序。然而，由于缺乏有效的内核模式驱动程序数字签名，这种方法在Microsoft
    Windows 64位平台上无法使用，限制了该修改仅适用于Microsoft Windows 32位操作系统。
- en: The last known and the most interesting iteration of the dropper, Win32/Gapz.A,
    is the version we’ll focus on in this chapter. This version came with a VBR bootkit.
    In the rest of the chapter, we will simply use “Gapz” to refer to Win32/Gapz.A.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个已知且最有趣的投放器版本Win32/Gapz.A，是我们在本章重点讨论的版本。该版本带有VBR bootkit。在本章的其余部分，我们将简化为使用“Gapz”来指代Win32/Gapz.A。
- en: '[Table 12-1](ch12.xhtml#ch12tab01) summarizes the different versions of the
    dropper.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-1](ch12.xhtml#ch12tab01)总结了不同版本的投放器。'
- en: '**Table 12-1:** Versions of the Win32/Gapz Dropper'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-1：** Win32/Gapz投放器的版本'
- en: '| **Detection name** | **Compilation date** | **LPE exploits** | **Bootkit
    technique** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **检测名称** | **编译日期** | **LPE漏洞** | **Bootkit技术** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Win32/Gapz.A | 09/11/201210/30/2012 | CVE-2011-3402CVE-2010-4398COM Elevation
    | VBR |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Win32/Gapz.A | 2012/09/11至2012/10/30 | CVE-2011-3402CVE-2010-4398COM 提权 |
    VBR |'
- en: '| Win32/Gapz.B | 11/06/2012 | CVE-2011-3402COM Elevation | No bootkit |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Win32/Gapz.B | 2012/11/06 | CVE-2011-3402COM 提权 | 无 bootkit |'
- en: '| Win32/Gapz.C | 04/19/2012 | CVE-2010-4398CVE-2011-2005COM Elevation | MBR
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Win32/Gapz.C | 2012/04/19 | CVE-2010-4398CVE-2011-2005COM 提权 | MBR |'
- en: The detection name column lists the Gapz variation adopted by the antivirus
    industry. The entries in the compilation date column are taken from the Gapz droppers’
    PE header, which is believed to be an accurate timestamp. The Bootkit technique
    column shows what kind of bootkit the dropper employs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 检测名称列列出了杀毒行业采用的Gapz变种。编译日期列中的条目来自Gapz投放器的PE头部，据信这是一个准确的时间戳。Bootkit技术列显示了投放器使用的bootkit类型。
- en: Finally, the LPE exploits column lists a number of LPE vulnerabilities exploited
    by Gapz droppers in order to get administrator privileges on the victim systems.
    The COM elevation vulnerability is used to bypass the User Account Control (UAC)
    security feature in order to inject code into a system process that is whitelisted
    for UAC. The CVE-2011-3402 vulnerability relates to the TrueType font–parsing
    functionality implemented in the *win32k.sys* module. The CVE-2010-4398 vulnerability
    is due to a stack-based buffer overflow in the `RtlQueryRegistryValues` routine,
    also located in the *win32k.sys* module. The CVE-2011-2005 vulnerability, located
    in the *afd.sys* (ancillary function driver) module, allows attackers to overwrite
    data in kernel-mode address space.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，LPE漏洞列列出了Gapz投放器利用的多个LPE漏洞，以便在受害者系统上获取管理员权限。COM提权漏洞用于绕过用户帐户控制（UAC）安全功能，以便将代码注入到UAC白名单中的系统进程中。CVE-2011-3402漏洞与*win32k.sys*模块中实现的TrueType字体解析功能有关。CVE-2010-4398漏洞是由于`RtlQueryRegistryValues`例程中的栈溢出，位于*win32k.sys*模块中。CVE-2011-2005漏洞位于*afd.sys*（辅助功能驱动程序）模块中，允许攻击者在内核模式地址空间中覆盖数据。
- en: All of the variations of the Gapz dropper listed in [Table 12-1](ch12.xhtml#ch12tab01)
    contain the same payload.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-1](ch12.xhtml#ch12tab01)中列出的所有Gapz投放器版本都包含相同的有效载荷。'
- en: '***Dropper Algorithm***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***投放器算法***'
- en: Before examining the Gapz dropper more closely, let’s recap what it needs in
    order to silently and successfully install Gapz onto the system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在更详细地检查Gapz投放器之前，我们先回顾一下它需要什么条件才能悄无声息地成功安装Gapz到系统中。
- en: First, the dropper requires administrative privileges to access the hard drive
    and modify MBR/VBR/IPL data. If the dropper’s user account lacks administrator
    privileges, it must raise its privileges by exploiting LPE vulnerabilities in
    the system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，投放器需要管理员权限来访问硬盘并修改MBR/VBR/IPL数据。如果投放器的用户帐户没有管理员权限，它必须通过利用系统中的LPE漏洞来提升权限。
- en: Second, it needs to bypass security software, such as antivirus programs, personal
    firewalls, and Host Intrusion Prevention Systems. To stay under the radar, Gapz
    uses advanced tools and methods, including obfuscation, antidebugging, and antiemulation
    techniques. In addition to these methods, the Gapz dropper employs a unique and
    rather interesting technique to bypass HIPS, as discussed later in the chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它需要绕过安全软件，如防病毒程序、个人防火墙和主机入侵防御系统。为了保持低调，Gapz 使用了先进的工具和方法，包括混淆、反调试和反仿真技术。除了这些方法外，Gapz
    dropper 还使用了一种独特且相当有趣的技术来绕过 HIPS，稍后将在本章中讨论。
- en: '**HOST INTRUSION PREVENTION SYSTEMS**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机入侵防御系统（HIPS）**'
- en: As its name suggests, a Host Intrusion Prevention System, or HIPS, is a computer
    security software package that is intended to prevent an attacker from accessing
    the target system. It employs a combination of methods, including but not limited
    to using signatures and heuristics and monitoring a single host for suspicious
    activity (for example, the creation of new processes in the system, allocation
    of a memory buffer with executable pages in another process, and new network connections).
    Unlike computer antivirus software, which analyzes only executable files, HIPS
    analyzes events to spot deviations from the system’s normal state. If malware
    manages to bypass the computer antivirus software and executes on the computer,
    HIPS may still be able to spot and block the intruder by detecting changes in
    the interactions of different events.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，主机入侵防御系统（Host Intrusion Prevention System，简称 HIPS）是一种计算机安全软件，旨在防止攻击者访问目标系统。它采用多种方法，包括但不限于使用签名和启发式分析，监控单个主机的可疑活动（例如，系统中新进程的创建、在另一个进程中分配具有可执行页面的内存缓冲区，以及新的网络连接）。与仅分析可执行文件的计算机防病毒软件不同，HIPS
    会分析事件以发现系统正常状态的偏差。如果恶意软件设法绕过计算机防病毒软件并在计算机上执行，HIPS 仍然可以通过检测不同事件交互的变化来发现并阻止入侵者。
- en: 'Taking these obstacles into account, these are the steps the Gapz dropper performs
    to successfully infect a system:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些障碍，Gapz dropper 执行以下步骤以成功感染系统：
- en: Inject itself into *explorer.exe* to bypass HIPS (as discussed in “[Bypassing
    HIPS](ch12.xhtml#ch12lev2sec3)” on [page 181](ch12.xhtml#page_181)).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自己注入 *explorer.exe* 以绕过 HIPS（如 “[绕过 HIPS](ch12.xhtml#ch12lev2sec3)” 在 [第 181
    页](ch12.xhtml#page_181) 中讨论的那样）。
- en: Exploit an LPE vulnerability in the targeted system to elevate its user privileges.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用目标系统中的 LPE 漏洞提升其用户权限。
- en: Install the bootkit onto the system.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将引导程序安装到系统中。
- en: '***Dropper Analysis***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Dropper 分析***'
- en: When the unpacked dropper is loaded into the IDA Pro disassembler, its export
    address table will look something like [Figure 12-1](ch12.xhtml#ch12fig01). The
    export address table shows all the symbols exported from the binary and nicely
    sums up the steps in the dropper execution algorithm.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当解包后的 dropper 被加载到 IDA Pro 反汇编器中时，其导出地址表将像 [图 12-1](ch12.xhtml#ch12fig01) 所示。导出地址表显示了二进制文件导出的所有符号，并很好地总结了
    dropper 执行算法中的步骤。
- en: '![image](../images/12fig01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig01.jpg)'
- en: '*Figure 12-1: Export address table of the Gapz dropper*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：Gapz dropper 的导出地址表*'
- en: 'There are three routines exported by the binary: one main entry point and two
    routines with randomly generated names. Each routine has its own purpose:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件导出了三个例程：一个主入口点和两个具有随机生成名称的例程。每个例程都有其特定的目的：
- en: start Injects the dropper into the *explorer.exe* address space
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: start 将 dropper 注入到 *explorer.exe* 地址空间
- en: icmnf Exploits LPE vulnerabilities in the system to elevate privileges
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: icmnf 利用系统中的 LPE 漏洞来提升权限
- en: isyspf Infects the victim’s machine
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: isyspf 感染受害者的机器
- en: '[Figure 12-1](ch12.xhtml#ch12fig01) also shows the exported symbol `gpi`. This
    symbol points to a shared memory in the dropper image, used by the preceding routines
    to inject the dropper into the *explorer.exe* process.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-1](ch12.xhtml#ch12fig01) 还显示了导出的符号 `gpi`。这个符号指向 dropper 映像中的共享内存，由前面的例程用来将
    dropper 注入到 *explorer.exe* 进程中。'
- en: '[Figure 12-2](ch12.xhtml#ch12fig02) depicts these stages. The main entry point
    doesn’t infect the system with the Gapz bookit. Instead it executes the `start`
    routine to inject the dropper into *explorer.exe* in order to bypass detection
    by security software. Once the dropper is injected, it attempts to acquire administrator
    privileges by exploiting LPE vulnerabilities in the system with the `icmnf` routine.
    Once the dropper gains the required privileges, it executes the `isyspf` routine
    to infect the hard drive with the bootkit.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 12-2](ch12.xhtml#ch12fig02) 描述了这些阶段。主要入口点并不会通过 Gapz bootkit 感染系统。相反，它执行
    `start` 例程将投放器注入 *explorer.exe*，以绕过安全软件的检测。一旦投放器被注入，它通过利用系统中的 LPE 漏洞（利用 `icmnf`
    例程）尝试获得管理员权限。投放器获得所需权限后，执行 `isyspf` 例程将 bootkit 注入硬盘。'
- en: '![image](../images/12fig02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig02.jpg)'
- en: '*Figure 12-2: Gapz dropper workflow*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 12-2: Gapz 投放器工作流程*'
- en: Let’s take a closer look at the process of injecting the dropper and bypassing
    HIPS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看注入投放器并绕过 HIPS 的过程。
- en: '***Bypassing HIPS***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绕过 HIPS***'
- en: Computer viruses have many methods of camouflaging themselves as benign software
    to avoid attracting the attention of security software. The TDL3 rootkit we discussed
    in [Chapter 1](ch01.xhtml#ch01) employs another interesting technique for bypassing
    HIPS, which abused `AddPrintProvidor`/`AddPrintProvider` system APIs to stay under
    the radar. These API functions are used to load custom modules into a trusted
    system process, *spoolsvc.exe*, that is responsible for printing support on Windows
    systems. The `AddPrintProvidor` (*sic*) routine, an executable module used to
    install a local print provider onto the system, is frequently excluded from the
    list of items monitored by security software. TDL3 simply creates an executable
    file with malicious code and loads it into *spoolsvc.exe* by running `AddPrintProvidor`.
    Once the routine is executed, the malicious code runs within the trusted system
    process, allowing TDL3 to attack without worrying about being detected.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机病毒有许多方法将自己伪装成良性软件，以避免引起安全软件的注意。我们在 [第 1 章](ch01.xhtml#ch01) 中讨论的 TDL3 rootkit
    就采用了另一种有趣的绕过 HIPS 的技术，它利用 `AddPrintProvidor`/`AddPrintProvider` 系统 API 来避免被发现。这些
    API 函数用于将自定义模块加载到受信任的系统进程 *spoolsvc.exe* 中，该进程负责 Windows 系统中的打印支持。`AddPrintProvidor`（*sic*）例程是一个用于将本地打印提供程序安装到系统中的可执行模块，通常会被排除在安全软件监视的项目列表之外。TDL3
    只是创建一个带有恶意代码的可执行文件，并通过运行 `AddPrintProvidor` 将其加载到 *spoolsvc.exe* 中。一旦该例程执行，恶意代码便在受信任的系统进程中运行，使得
    TDL3 能够在不被检测的情况下进行攻击。
- en: 'Gapz also injects its code into a trusted system process in order to bypass
    HIPS, but it uses an elaborate nonstandard method, the core aim of which is to
    inject shellcode that loads and executes the malicious image into the explorer
    process. These are the steps the dropper takes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz 还将其代码注入到受信任的系统进程中，以绕过 HIPS，但它采用了一种复杂的非标准方法，核心目的是注入 shellcode，将恶意镜像加载并执行到
    explorer 进程中。这些是投放器采取的步骤：
- en: Open one of the shared sections from *\BaseNamedObjects* mapped into the *explorer.exe*
    address space (see [Listing 12-1](ch12.xhtml#ch12list01)) and write shellcode
    into this section. The *\BaseNamedObjects* directory in the Windows Object Manager
    namespace contains names of mutex, event, semaphore, and section objects.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开映射到 *explorer.exe* 地址空间中的 *\BaseNamedObjects* 共享部分之一（见 [Listing 12-1](ch12.xhtml#ch12list01)），并将
    shellcode 写入此部分。Windows 对象管理器命名空间中的 *\BaseNamedObjects* 目录包含互斥锁、事件、信号量和段对象的名称。
- en: After writing the shellcode, search for the window `Shell_TrayWnd`. This window
    corresponds to the Windows taskbar. Gapz targets this window in particular because
    it is created and managed by *explorer.exe* and is very likely available in the
    system.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入 shellcode 后，搜索窗口 `Shell_TrayWnd`。该窗口对应于 Windows 任务栏。Gapz 特别针对这个窗口，因为它是由 *explorer.exe*
    创建和管理的，并且很可能在系统中可用。
- en: Call the Win32 API function `GetWindowLong` to get the address of the routine
    related to the `Shell_TrayWnd` window handler.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 Win32 API 函数 `GetWindowLong` 获取与 `Shell_TrayWnd` 窗口处理程序相关的例程地址。
- en: Call the Win32 API function `SetWindowLong` to modify the address of the routine
    related to the `Shell_TrayWnd` window handler.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 Win32 API 函数 `SetWindowLong` 来修改与 `Shell_TrayWnd` 窗口处理程序相关的例程地址。
- en: Call `SendNotifyMessage` to trigger the execution of the shellcode in the *explorer.exe*
    address space.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `SendNotifyMessage` 触发在 *explorer.exe* 地址空间中执行 shellcode。
- en: The section objects are used to share part of a certain process’s memory with
    other processes; in other words, they represent a section of memory that can be
    shared across the system processes. [Listing 12-1](ch12.xhtml#ch12list01) shows
    the section objects in *\BaseNamedObjects* for which the malware looks in step
    1\. These section objects correspond to system sections—that is, they are created
    by the operating system and contain system data. Gapz iterates through the list
    of section objects and opens them to check whether they exist in the system. If
    a section object exists in the system, the dropper stops iterating and returns
    a handle for the corresponding section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 区段对象用于与其他进程共享某一进程的一部分内存；换句话说，它们代表了可以跨系统进程共享的内存区段。[Listing 12-1](ch12.xhtml#ch12list01)显示了恶意软件在第一步中查找的*\BaseNamedObjects*中的区段对象。这些区段对象对应系统区段——即它们是由操作系统创建的，包含系统数据。Gapz遍历区段对象列表并打开它们，以检查它们是否存在于系统中。如果系统中存在某个区段对象，投放程序将停止遍历，并返回该区段的句柄。
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 12-1: Object names used in the Gapz dropper*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-1：Gapz投放程序中使用的对象名称*'
- en: Once it opens the existing section, the malware proceeds with injecting its
    code into the *explorer.exe* process, as shown in [Listing 12-2](ch12.xhtml#ch12list02).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开现有区段，恶意软件便开始将其代码注入到*explorer.exe*进程中，如[Listing 12-2](ch12.xhtml#ch12list02)所示。
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 12-2: Injecting the Gapz dropper into* explorer.exe'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-2：将Gapz投放程序注入*explorer.exe*'
- en: 'The malware uses 336 (0x150) bytes ➊ of the space at the end of the section
    to write the shellcode. To ensure the shellcode executes correctly, the malware
    also provides the addresses of some API routines used during the injection process:
    `CloseHandle`, `MapViewOfFile`, `OpenFileMappingA`, `CreateThread`, and `SetWindowLongA`
    ➋. The shellcode will use these routines to load the Gapz dropper into the *explorer.exe*
    memory space.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用区段末尾的336个字节（0x150）➊来写入shellcode。为了确保shellcode正确执行，恶意软件还提供了在注入过程中使用的某些API例程的地址：`CloseHandle`、`MapViewOfFile`、`OpenFileMappingA`、`CreateThread`和`SetWindowLongA`
    ➋。shellcode将使用这些例程将Gapz投放程序加载到*explorer.exe*的内存空间中。
- en: Gapz executes the shellcode using the *return-oriented programming (ROP)* technique.
    ROP takes advantage of the fact that in x86 and x64 architectures, the `ret` instruction
    can be used to return control to the parent routine after execution of a child
    subroutine. The `ret` instruction assumes that the address to which control is
    returned is on the top of the stack, so it pops the return address from the stack
    and transfers control to that address. By executing a `ret` instruction to gain
    control of the stack, an attacker can execute arbitrary code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz使用*返回导向编程（ROP）*技术执行shellcode。ROP利用了x86和x64架构中`ret`指令的特性，在执行完子例程后，`ret`指令可以将控制权返回给父例程。`ret`指令假定控制权返回的地址位于栈顶，因此它会从栈中弹出返回地址，并将控制权转移到该地址。通过执行`ret`指令来控制栈，攻击者可以执行任意代码。
- en: The reason Gapz uses the ROP technique to execute its shellcode is that the
    memory corresponding to the shared section object may not be executable, so an
    attempt to execute instructions from there will generate an exception. To overcome
    this limitation, the malware uses a small ROP program that’s executed before the
    shellcode. The ROP program allocates some executable memory inside the target
    process, copies the shellcode into this buffer, and executes it from there.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz使用ROP技术执行shellcode的原因是，部分共享内存对象的内存可能不可执行，因此尝试从中执行指令将引发异常。为了解决这个限制，恶意软件使用了一个小型ROP程序，在shellcode之前执行。该ROP程序在目标进程内部分配了一些可执行内存，将shellcode复制到这个缓冲区中，并从那里执行。
- en: Gapz finds the gadget for triggering the shellcode in the routine `ConstructTargetBuffer`
    ➌. In the case of 32-bit systems, Gapz uses the system routine `ntdll!KiUserApcDispatcher`
    to transfer control to the ROP program.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz在`ConstructTargetBuffer`例程中找到触发shellcode的小工具➌。对于32位系统，Gapz使用系统例程`ntdll!KiUserApcDispatcher`将控制权转移到ROP程序。
- en: '**Modifying the Shell_TrayWnd Procedure**'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**修改Shell_TrayWnd过程**'
- en: 'Once it has written the shellcode to the section object and found all the necessary
    ROP gadgets, the malware proceeds to the next step: modifying the `Shell_TrayWnd`
    window procedure. This procedure is responsible for handling all the events and
    messages that occur and are sent to the window. Whenever the window is resized
    or moved, a button is pressed, and so on, the `Shell_TrayWnd` routine is called
    by the system to notify and update the window. The system specifies the address
    of the window procedure at the time of the window’s creation.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它将shellcode写入节对象并找到所有必要的ROP小工具，恶意软件就进入下一步：修改`Shell_TrayWnd`窗口过程。该过程负责处理所有发生并发送到窗口的事件和消息。每当窗口被调整大小或移动、按钮被按下等，系统都会调用`Shell_TrayWnd`例程以通知并更新窗口。系统在窗口创建时指定窗口过程的地址。
- en: 'The Gapz dropper retrieves the address of the original window procedure, in
    order to return to it after injection, by executing the `GetWindowLongA` ➍ routine.
    This routine is used to get window parameters and takes two arguments: the window
    handle and an index of the parameter to be retrieved. As you can see, Gapz calls
    the routine with the index parameter `0`, indicating the address of the original
    `Shell_TrayWnd` window procedure. The malware stores this value in the memory
    buffer in order to restore the original address after injection.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz掉落程序通过执行`GetWindowLongA` ➍例程来检索原始窗口过程的地址，以便在注入后返回此地址。该例程用于获取窗口参数，并接受两个参数：窗口句柄和要检索的参数索引。如您所见，Gapz调用该例程时传入了索引参数`0`，表示原始`Shell_TrayWnd`窗口过程的地址。恶意软件将此值存储在内存缓冲区中，以便在注入后恢复原始地址。
- en: Next, the malware executes the `SetWindowLongA` routine ➎ to modify the address
    of the `Shell_TrayWnd` window procedure to the address of the `ntdll!KiUserApcDispatcher`
    system routine. By redirecting to an address within the system module and not
    the shellcode itself, Gapz further protects itself against detection by security
    software. At this point, the shellcode is ready to be executed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，恶意软件执行`SetWindowLongA`例程 ➎，将`Shell_TrayWnd`窗口过程的地址修改为`ntdll!KiUserApcDispatcher`系统例程的地址。通过重定向到系统模块中的地址，而非shellcode本身，Gapz进一步保护自己免受安全软件的检测。此时，shellcode已经准备好执行。
- en: '**Executing the Shellcode**'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**执行Shellcode**'
- en: Gapz triggers the execution of the shellcode by using the `SendNotifyMessageA`
    API ➏ to send a message to the `Shell_TrayWnd` window, passing control to the
    window procedure. As explained in the previous section, after the address of the
    window procedure is modified, the new address points to the `KiUserApcDispatcher`
    routine. This eventually results in control being transferred to the shellcode
    mapped within the *explorer.exe* process address space, as shown in [Listing 12-3](ch12.xhtml#ch12list03).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz通过使用`SendNotifyMessageA` API ➏ 向`Shell_TrayWnd`窗口发送消息，触发shellcode的执行，将控制权传递给窗口过程。如前一节所述，在修改了窗口过程的地址后，新的地址指向`KiUserApcDispatcher`例程。这最终导致控制权转移到映射在*explorer.exe*进程地址空间中的shellcode，如[列表12-3](ch12.xhtml#ch12list03)所示。
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 12-3: Mapping the Gapz dropper image into the address space of* explorer.exe'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-3：将Gapz掉落程序映射到explorer.exe的地址空间中*'
- en: You can see the usage of the API routines `OpenFileMapping`, `MapViewOfFile`,
    `CreateThread`, and `CloseHandle`, whose addresses were populated earlier (at
    ➋ in [Listing 12-2](ch12.xhtml#ch12list02)). Using these routines, the shellcode
    maps the view of the file that corresponds to the dropper into the address space
    of *explorer.exe* (➊ and ➋). Then it creates a thread ➌ in the *explorer.exe*
    process to execute the mapped image and restores the original index value that
    was changed by the `SetWindowLongA` WinAPI function ➍. The newly created thread
    runs the next part of the dropper, escalating its privileges. Once the dropper
    obtains sufficient privileges, it attempts to infect the system, which is when
    the bootkit feature comes into play.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`OpenFileMapping`、`MapViewOfFile`、`CreateThread`和`CloseHandle`等API例程的使用，这些例程的地址之前已经填充（在[列表12-2](ch12.xhtml#ch12list02)的➋处）。通过这些例程，shellcode将对应掉落程序的文件映射到*explorer.exe*的地址空间中（➊和➋）。然后，它在*explorer.exe*进程中创建一个线程
    ➌ 来执行映射的镜像，并恢复`SetWindowLongA` WinAPI函数 ➍修改的原始索引值。新创建的线程运行掉落程序的下一部分，提升其权限。一旦掉落程序获得足够的权限，它就会尝试感染系统，这时引导病毒功能就会发挥作用。
- en: '**THE POWER LOADER INFLUENCE**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**Power Loader的影响**'
- en: The injection technique described here isn’t an invention of Gapz developers;
    it previously appeared in the Power Loader malware creation software. Power Loader
    is a special bot builder for creating downloaders for other malware families,
    and it is yet another example of specialization and modularity in malware production.
    The first time Power Loader was detected in the wild was in September 2012\. Starting
    from November 2012, the malware known as Win32/Redyms used Power Loader components
    in its own dropper. At the time of this writing, the Power Loader package—including
    one builder kit with a C&C panel—costs around $500 in the Russian cybercrime market.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的注入技术并不是Gapz开发者的发明，它之前出现在Power Loader恶意软件创建工具中。Power Loader是一种专门用于为其他恶意软件家族创建下载器的机器人构建器，它是恶意软件生产中专业化和模块化的另一个例子。Power
    Loader第一次在野外被发现是在2012年9月。从2012年11月起，名为Win32/Redyms的恶意软件在其自己的投放程序中使用了Power Loader组件。本文撰写时，Power
    Loader套件——包括一个构建工具包和一个C&C面板——在俄罗斯网络犯罪市场上的价格约为500美元。
- en: '**Infecting the System with the Gapz Bootkit**'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用Gapz引导程序感染系统**'
- en: 'Gapz uses two distinct variations of infection technique: one targeting the
    MBR of the bootable hard drive and the other targeting the VBR of the active partition.
    The bootkit functionality of both versions, however, is pretty much the same.
    The MBR version aims to persist on a victim’s computer by modifying MBR code in
    a similar way to the TDL4 bootkit. The VBR version uses subtler and stealthier
    techniques to infect the victim’s system, and as mentioned, that’s the one we’ll
    focus on here.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz使用了两种不同的感染技术：一种针对可启动硬盘的MBR，另一种针对活动分区的VBR。然而，两个版本的引导程序功能基本相同。MBR版本通过类似于TDL4引导程序的方式修改MBR代码，旨在保持在受害者的计算机上。VBR版本则使用更微妙、更隐蔽的技术来感染受害者的系统，正如前面所提到的，这就是我们在这里重点讨论的版本。
- en: We briefly touched on the Gapz bootkit technique in [Chapter 7](ch07.xhtml#ch07),
    and now we’ll elaborate on the implementation details. The infection method Gapz
    uses is one of the stealthiest ever seen in the wild, modifying only a few bytes
    of the VBR and making it very hard for security software to detect it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](ch07.xhtml#ch07)中简要提到过Gapz的引导程序技术，现在我们将详细说明其实现细节。Gapz使用的感染方法是迄今为止在野外见过的最隐蔽的技术之一，只修改了VBR的几个字节，使得安全软件很难检测到它。
- en: '***Reviewing the BIOS Parameter Block***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看BIOS参数块***'
- en: The main target of the malware is the BIOS parameter block (BPB) data structure
    located in the VBR (see [Chapter 5](ch05.xhtml#ch05) for more details). This structure
    contains information about the filesystem volume located on the partition and
    has a crucial role in the boot process. The BPB layout differs across various
    filesystems (FAT, NTFS, and so on), but we will focus on NTFS. The contents of
    the BPB structure for NTFS are shown in [Listing 12-4](ch12.xhtml#ch12list04)
    (this is excerpted from [Listing 5-3](ch05.xhtml#ch05list03) for convenience).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件的主要目标是位于VBR中的BIOS参数块（BPB）数据结构（有关详细信息，请参见[第5章](ch05.xhtml#ch05)）。该结构包含有关分区上文件系统卷的信息，并在引导过程中起着至关重要的作用。不同文件系统（如FAT、NTFS等）的BPB布局有所不同，但我们将专注于NTFS。NTFS的BPB结构内容如[清单12-4](ch12.xhtml#ch12list04)所示（为方便起见，这是从[清单5-3](ch05.xhtml#ch05list03)中摘录的）。
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 12-4: Layout of the `BIOS_PARAMETER_BLOCK` for NTFS*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-4：NTFS的`BIOS_PARAMETER_BLOCK`布局*'
- en: As you may recall from [Chapter 5](ch05.xhtml#ch05), the `HiddenSectors` field
    ➊, located at offset 14 from the beginning of the structure, determines the location
    of the IPL on the hard drive (see [Figure 12-3](ch12.xhtml#ch12fig03)). The VBR
    code uses `HiddenSectors` to find the IPL on the disk and execute it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[第5章](ch05.xhtml#ch05)中所记得的，位于结构开始偏移14的位置的`HiddenSectors`字段➊，确定了硬盘上IPL的位置（见[图12-3](ch12.xhtml#ch12fig03)）。VBR代码使用`HiddenSectors`来查找磁盘上的IPL并执行它。
- en: '![image](../images/12fig03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig03.jpg)'
- en: '*Figure 12-3: Location of IPL on the hard drive*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-3：硬盘上IPL的位置*'
- en: '***Infecting the VBR***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***感染VBR***'
- en: Gapz hijacks the control flow at system bootup by manipulating the `HiddenSectors`
    field value inside the BPB. When infecting a computer, Gapz writes the bootkit
    body before the very first partition if there is enough space or after the last
    partition otherwise, and it modifies the `HiddenSectors` field to point to the
    start of the rootkit body on the hard drive rather than to the legitimate IPL
    code (see [Figure 12-4](ch12.xhtml#ch12fig04)). As a result, during the next bootup,
    the VBR code loads and executes the Gapz bootkit code from the end of the hard
    drive.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz通过在系统启动时操作BPB中的`HiddenSectors`字段值来劫持控制流。在感染计算机时，如果有足够的空间，Gapz会在第一个分区之前写入引导程序主体，否则会在最后一个分区之后写入，并修改`HiddenSectors`字段，使其指向硬盘上根木马主体的起始位置，而不是指向合法的IPL代码（见[图12-4](ch12.xhtml#ch12fig04)）。因此，在下一次启动时，VBR代码会加载并执行位于硬盘末端的Gapz引导程序代码。
- en: '![image](../images/12fig04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig04.jpg)'
- en: '*Figure 12-4: Gapz bootkit infection layout*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-4：Gapz引导程序感染布局*'
- en: What makes this technique particularly clever is that it modifies only 4 bytes
    of the VBR data, considerably less than other bootkits. For instance, TDL4 modifies
    the MBR code, which is 446 bytes; Olmasco changes an entry in the MBR partition
    table, which is 16 bytes; and Rovnix alters IPL code that takes up 15 sectors,
    or 7,680 bytes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这一技术特别巧妙之处在于，它只修改了VBR数据中的4个字节，远少于其他引导程序。例如，TDL4修改了MBR代码（446字节）；Olmasco修改了MBR分区表中的一个条目（16字节）；Rovnix修改了占用15个扇区或7,680字节的IPL代码。
- en: Gapz appeared in 2012, at a time when the security industry had caught up with
    modern bootkits and MBR, VBR, and IPL code monitoring had already become normal
    practice. However, by altering the `HiddenSectors` field of the BPB, Gapz pushed
    bootkit infection techniques one step further and left the security industry behind.
    Before Gapz, it wasn’t common for security software to inspect the BPB’s fields
    for anomalies. It took some time for the security industry to get wise to its
    novel infection method and develop solutions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz出现在2012年，当时安全行业已经赶上了现代引导程序（bootkits），并且MBR、VBR和IPL代码监控已经成为常规做法。然而，通过修改BPB中的`HiddenSectors`字段，Gapz将引导程序感染技术推向了一个新的高度，甩开了安全行业。Gapz出现之前，安全软件通常不会检查BPB字段的异常情况。安全行业花了一些时间才意识到它的新型感染方法并开发出相应的解决方案。
- en: Another thing that sets Gapz apart is that the contents of the field `HiddenSectors`
    aren’t fixed for BPB structures—they can differ from one system to another. The
    value of `HiddenSectors` depends largely on the partition scheme of the hard drive.
    In general, security software cannot determine whether a system is infected or
    not using just the `HiddenSectors` value; it must perform a deeper analysis of
    the actual code located at the offset.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使Gapz与众不同的地方是，`HiddenSectors`字段的内容并非固定不变的—它们可能会因系统而异。`HiddenSectors`的值很大程度上取决于硬盘的分区方案。一般来说，安全软件仅凭`HiddenSectors`值无法判断系统是否感染，需要对偏移处的实际代码进行更深入的分析。
- en: '[Figure 12-5](ch12.xhtml#ch12fig05) displays the contents of the VBR taken
    from a real system infected with Gapz. The BPB is located at offset 11 and the
    `HiddenSectors` field, holding the value 0x00000800, is highlighted.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-5](ch12.xhtml#ch12fig05)展示了从感染了Gapz的真实系统中提取的VBR内容。BPB位于偏移量11处，`HiddenSectors`字段的值为0x00000800，并已突出显示。'
- en: '![image](../images/12fig05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig05.jpg)'
- en: '*Figure 12-5: The `HiddenSectors` value on an infected system*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-5：感染系统上的`HiddenSectors`值*'
- en: To be able to detect Gapz, the security software must analyze the data located
    at offset 0x00000800 from the beginning of the hard drive. This is where the malicious
    bootloader is located.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够检测到Gapz，安全软件必须分析硬盘从起始位置偏移0x00000800处的数据。这就是恶意引导加载程序的位置。
- en: '***Loading the Malicious Kernel-Mode Driver***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加载恶意的内核模式驱动程序***'
- en: As with many modern bootkits, the main purpose of the Gapz bootkit code is to
    compromise the operating system by loading malicious code into kernel-mode address
    space. Once the Gapz bootkit code receives control, it proceeds with the regular
    routine of patching OS boot components, as described in previous chapters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多现代引导程序类似，Gapz引导程序代码的主要目的是通过将恶意代码加载到内核模式地址空间中来破坏操作系统。一旦Gapz引导程序获得控制，它会按之前章节所描述的常规流程修补操作系统的引导组件。
- en: Once executed, the bootkit code hooks the INT 13h handler in order to monitor
    data being read from the hard drive. Then it loads the original IPL code from
    the hard drive and executes it to resume the boot process. [Figure 12-6](ch12.xhtml#ch12fig06)
    shows the boot process in a system infected with Gapz.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行，bootkit 代码会挂钩 INT 13h 处理程序，以监视从硬盘读取的数据。然后，它从硬盘加载原始 IPL 代码并执行，以恢复启动过程。[图
    12-6](ch12.xhtml#ch12fig06) 展示了一个受 Gapz 感染的系统中的启动过程。
- en: After hooking INT 13h ➊, the malware monitors data read from the hard drive
    and looks for the *bootmgr* module, which in turn patches in memory in order to
    hook the `Archx86TransferTo32BitApplicationAsm` (`Archx86TransferTo64BitApplicationAsm`
    for x64 Windows platforms) routine ➋. This routine transfers control from *bootmgr*
    to the entry point of *winload.exe*. The hook is used to patch the *winload.exe*
    module. Once the hook in *bootmgr* is triggered, *winload.exe* is already in memory
    and the malware can patch it. The bootkit hooks the `OslArchTransferToKernel`
    routine ➌ in the *winload.exe* module.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂钩 INT 13h ➊ 后，恶意软件监视从硬盘读取的数据，并寻找 *bootmgr* 模块，进而在内存中打补丁以挂钩 `Archx86TransferTo32BitApplicationAsm`（对于
    x64 Windows 平台为 `Archx86TransferTo64BitApplicationAsm`）例程 ➋。该例程将控制权从 *bootmgr*
    转移到 *winload.exe* 的入口点。这个挂钩用于修补 *winload.exe* 模块。一旦 *bootmgr* 中的挂钩被触发，*winload.exe*
    就已经在内存中，恶意软件可以对其进行打补丁。Bootkit 在 *winload.exe* 模块中挂钩 `OslArchTransferToKernel`
    例程 ➌。
- en: As discussed in the previous chapter, Rovnix also started by hooking the INT
    13h handler, patching *bootmgr*, and hooking `OslArchTransferToKernel`. But, unlike
    Gapz, in the next step Rovnix compromised the kernel by patching the kernel `KiSystemStartup`
    routine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一章所述，Rovnix 也从挂钩 INT 13h 处理程序开始，修补 *bootmgr*，并挂钩 `OslArchTransferToKernel`。但是，与
    Gapz 不同，Rovnix 在下一步通过修补内核的 `KiSystemStartup` 例程来入侵内核。
- en: '![image](../images/12fig06.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig06.jpg)'
- en: '*Figure 12-6: The workflow of the bootkit*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-6：bootkit 的工作流程*'
- en: 'Gapz, on the other hand, hooks another routine in the kernel image: `IoInitSystem`
    ➍. The purpose of this routine is to complete the kernel initialization by initializing
    different OS subsystems and calling the entry points of the boot start drivers.
    Once `IoInitSystem` is executed, the malicious hook is triggered, restoring the
    patched bytes of the `IoInitSystem` routine and overwriting `IoInitSystem`’s return
    address on the stack with an address to the malicious code. The Gapz bootkit then
    releases control back to the `IoInitSystem` routine.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Gapz 会在内核映像中挂钩另一个例程：`IoInitSystem` ➍。这个例程的目的是通过初始化不同的操作系统子系统并调用启动驱动程序的入口点来完成内核初始化。一旦
    `IoInitSystem` 执行，恶意挂钩就会被触发，恢复 `IoInitSystem` 例程的修补字节，并将 `IoInitSystem` 的返回地址覆盖为指向恶意代码的地址。然后，Gapz
    bootkit 会将控制权交还给 `IoInitSystem` 例程。
- en: Upon completion of the routine, control is transferred back to the malicious
    code. After `IoInitSystem` executes, the kernel is properly initialized, and the
    bootkit can use the services it provides to access the hard drive, allocate memory,
    create threads, and more. Next, the malware reads the rest of the bootkit code
    from the hard drive, creates a system thread, and, finally, returns control to
    the kernel. Once the malicious kernel-mode code is executed in the kernel-mode
    address space, the bootkit’s job is finished ➎.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在例程完成后，控制权会返回到恶意代码中。`IoInitSystem` 执行后，内核被正确初始化，bootkit 可以使用它提供的服务来访问硬盘、分配内存、创建线程等。接下来，恶意软件从硬盘读取其余的
    bootkit 代码，创建一个系统线程，最后将控制权交还给内核。一旦恶意的内核模式代码在内核模式地址空间中执行完毕，bootkit 的工作就完成了 ➎。
- en: '**AVOIDING DETECTION BY SECURITY SOFTWARE**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免被安全软件检测到**'
- en: At the very beginning of the boot process, Gapz removes the bootkit infection
    from the infected VBR; it restores the infection later during execution of its
    kernel-mode module. One possible explanation for this might be that some security
    products perform a system checkup when they start, so by removing the evidence
    of infection from the VBR at this point, Gapz is able to go unnoticed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程的最开始，Gapz 会从受感染的 VBR 中移除 bootkit 感染；它在内核模式模块执行期间稍后恢复感染。一个可能的解释是，一些安全产品在启动时会执行系统检查，因此通过在此时从
    VBR 中移除感染证据，Gapz 能够不被察觉。
- en: '**Gapz Rootkit Functionality**'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Gapz Rootkit 功能**'
- en: In this section, we’ll focus on the rootkit functionality of the malware, the
    most interesting aspect of Gapz after its bootkit functionality. We’ll refer to
    the Gapz rootkit functionality as the *kernel-mode module* since it isn’t a valid
    kernel-mode driver, in the sense that it isn’t a PE image at all. Rather, it’s
    laid out as position-independent code consisting of several blocks, each of which
    implements specific functionality of the malware to complete a certain task. The
    purpose of the kernel-mode module is to secretly and silently inject a payload
    into the system processes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点讨论恶意软件的rootkit功能，这是Gapz在其bootkit功能之后最有趣的方面。我们将Gapz的rootkit功能称为*内核模式模块*，因为它不是一个有效的内核模式驱动程序，严格来说，它根本不是一个PE映像。相反，它被布置为位置独立代码，包含多个块，每个块实现恶意软件的特定功能以完成某个任务。内核模式模块的目的是秘密且悄无声息地将有效负载注入系统进程。
- en: One of the most interesting aspects of the Gapz kernel-mode module is that it
    implements a custom TCP/IP network stack to communicate with C&C servers; it uses
    a crypto library with custom implementations of such crypto primitives as RC4,
    MD5, SHA1, AES, and BASE64, to protect its configuration data and C&C communication
    channel. And, as with any other complex threat, it implements hidden storage to
    secretly store its user-mode payload and configuration information. Gapz also
    includes a powerful hooking engine with a built-in disassembler to set up persistent
    and stealthy hooks. In the rest of this section, we will consider these and more
    aspects of the Gapz kernel-mode module in detail.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz内核模式模块最有趣的方面之一是它实现了一个自定义的TCP/IP网络栈，用于与C&C服务器通信；它使用一个加密库，其中包含自定义实现的加密原语，如RC4、MD5、SHA1、AES和BASE64，用于保护其配置数据和C&C通信通道。而且，像其他复杂的威胁一样，它实现了隐藏存储，用于秘密存储其用户模式有效负载和配置信息。Gapz还包括一个强大的钩子引擎，并内置反汇编器，用于设置持久且隐蔽的钩子。在本节的其余部分，我们将详细讨论Gapz内核模式模块的这些以及更多方面。
- en: The Gapz kernel-mode module isn’t a conventional PE image but rather is composed
    of a set of blocks with *position-independent code (PIC)*, which doesn’t use absolute
    addresses to reference data. Therefore, its memory buffer may be located at any
    valid virtual address in a process’s address space. Each block serves a specific
    purpose. A block is preceded by a header describing its size and position in the
    module and some constants used to calculate the addresses of the routines implemented
    within that block. The layout of the header is shown in [Listing 12-5](ch12.xhtml#ch12list05).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz内核模式模块不是传统的PE映像，而是由一组位置独立代码（*PIC*）的块组成，这些块不使用绝对地址来引用数据。因此，它的内存缓冲区可以位于进程地址空间中的任何有效虚拟地址。每个块都有特定的用途。每个块前面都有一个头部，描述其在模块中的大小和位置，以及用于计算该块中实现的例程地址的一些常量。头部的布局如[列表12-5](ch12.xhtml#ch12list05)所示。
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 12-5: Gapz kernel-mode module block header*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-5：Gapz内核模式模块块头部*'
- en: The header starts with the integer constant `ProcBase` ➊, used to calculate
    the offsets of the routines implemented in a basic block. `NextBlockOffset` ➋
    specifies the offset of the next block within the module, allowing Gapz to enumerate
    all the blocks in the kernel-mode module. `BlockInitialization` ➌ contains the
    offset from the beginning of the block to the block initialization routine, executed
    at the kernel-mode module initialization. This routine initializes all the necessary
    data structures specific to the corresponding block and should be executed before
    any other function implemented in the block.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 头部以整数常量`ProcBase` ➊开始，用于计算基本块中实现的例程的偏移量。`NextBlockOffset` ➋指定模块中下一个块的偏移量，允许Gapz枚举内核模式模块中的所有块。`BlockInitialization`
    ➌包含从块开始到块初始化例程的偏移量，该例程在内核模式模块初始化时执行。此例程初始化与相应块相关的所有必要数据结构，并应在块中实现的任何其他功能之前执行。
- en: 'Gapz uses a global structure that holds all the data related to its kernel-mode
    code: addresses of the implemented routines, pointers to allocated buffers, and
    so on. This structure allows Gapz to determine the addresses of all the routines
    implemented in the position-independent code blocks and then execute them.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz使用一个全局结构，保存所有与其内核模式代码相关的数据：实现的例程的地址、分配的缓冲区的指针等。该结构使Gapz能够确定所有在位置独立代码块中实现的例程的地址，然后执行它们。
- en: The position-independent code references the global structure using the hexadecimal
    constant 0xBBBBBBBB (for an x86 module). At the very beginning of the malicious
    kernel-mode code execution, Gapz allocates a memory buffer for the global structure.
    Then it uses the `BlockInitialization` routine to run through the code implemented
    in each block and substitute a pointer to the global structure for every occurrence
    of 0xBBBBBBBB.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 无关位置的代码通过十六进制常量 0xBBBBBBBB（适用于 x86 模块）引用全局结构。在恶意内核模式代码执行的最初阶段，Gapz 为全局结构分配一个内存缓冲区。然后，它使用
    `BlockInitialization` 例程遍历每个代码块中实现的代码，并将 0xBBBBBBBB 的每次出现替换为全局结构的指针。
- en: The disassembly of the `OpenRegKey` routine implemented in the kernel-mode module
    looks something like [Listing 12-6](ch12.xhtml#ch12list06). Again, the constant
    0xBBBBBBBB is used to refer to the address of the global context, but during execution,
    this constant is replaced with the actual address of the global structure in memory
    so that the code will execute correctly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核模式模块中实现的 `OpenRegKey` 例程的反汇编代码类似于 [清单 12-6](ch12.xhtml#ch12list06)。再次强调，常量
    0xBBBBBBBB 用来引用全局上下文的地址，但在执行过程中，这个常量会被内存中全局结构的实际地址替换，从而确保代码正确执行。
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 12-6: Using global context in Gapz kernel-mode code*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-6：在 Gapz 内核模式代码中使用全局上下文*'
- en: In total, Gapz implements 12 code blocks in the kernel-mode module, listed in
    [Table 12-2](ch12.xhtml#ch12tab02). The last block implements the main routine
    of the kernel-mode module that starts the execution of the module, initializes
    the other code blocks, sets up hooks, and initiates communication with C&C servers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Gapz 在内核模式模块中实现了 12 个代码块，列在 [表 12-2](ch12.xhtml#ch12tab02) 中。最后一个代码块实现了内核模式模块的主例程，该例程启动模块的执行，初始化其他代码块，设置挂钩并启动与
    C&C 服务器的通信。
- en: '**Table 12-2:** Gapz Kernel-Mode Code Blocks'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-2：** Gapz 内核模式代码块'
- en: '| **Block number** | **Implemented functionality** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **代码块编号** | **实现功能** |'
- en: '| --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | General API, gathering information on the hard drives, CRT string routines,
    and so on |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 一般 API，收集硬盘上的信息，CRT 字符串例程等 |'
- en: '| 2 | Cryptographic library: RC4, MD5, SHA1, AES, BASE64, and so forth |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 加密库：RC4，MD5，SHA1，AES，BASE64 等 |'
- en: '| 3 | Hooking engine, disassembler engine |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 挂钩引擎，反汇编引擎 |'
- en: '| 4 | Hidden storage implementation |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 隐藏存储实现 |'
- en: '| 5 | Hard disk driver hooks, self-defense |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 硬盘驱动程序挂钩，自我防御 |'
- en: '| 6 | Payload manager |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 有效载荷管理器 |'
- en: '| 7 | Payload injector into processes’ user-mode address space |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 注入有效载荷到进程的用户模式地址空间 |'
- en: '| 8 | Network communication: data link layer |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 网络通信：数据链路层 |'
- en: '| 9 | Network communication: transport layer |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 网络通信：传输层 |'
- en: '| 10 | Network communication: protocol layer |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 网络通信：协议层 |'
- en: '| 11 | Payload communication interface |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 有效载荷通信接口 |'
- en: '| 12 | Main routine |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 主例程 |'
- en: '**Hidden Storage**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**隐藏存储**'
- en: 'Like most bootkits, Gapz implements hidden storage to store its payload and
    configuration information securely. The image of the hidden filesystem is located
    in a file on the hard drive at *\??\C:\System Volume Information\<XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX>*
    where *X* signifies hexadecimal numbers generated based on configuration information.
    The layout of the hidden storage is a FAT32 filesystem. [Figure 12-7](ch12.xhtml#ch12fig07)
    shows an example of the content of the *\usr\overlord* hidden storage directory.
    You can see three files stored in the directory: *overlord32.dll*, *overlord64.dll*,
    and *conf.z*. The first two files correspond to the user-mode payload to be injected
    into system processes. The third file, *conf.z*, contains configuration data.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数启动工具一样，Gapz 实现了隐藏存储，以安全地存储其有效载荷和配置信息。隐藏文件系统的映像位于硬盘上的一个文件中，路径为 *\??\C:\System
    Volume Information\<XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX>*，其中 *X* 表示基于配置信息生成的十六进制数字。隐藏存储的布局采用
    FAT32 文件系统。[图 12-7](ch12.xhtml#ch12fig07) 显示了 *\usr\overlord* 隐藏存储目录的内容示例。你可以看到该目录中存储了三个文件：*overlord32.dll*、*overlord64.dll*
    和 *conf.z*。前两个文件对应用户模式有效载荷，将被注入到系统进程中。第三个文件 *conf.z* 包含配置数据。
- en: '![image](../images/12fig07.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig07.jpg)'
- en: '*Figure 12-7: Contents of the hidden storage* \usr\overlord *directory*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-7：隐藏存储的内容* \usr\overlord *目录*'
- en: To keep the information stored within the hidden filesystem secret, its content
    is encrypted, as shown in [Listing 12-7](ch12.xhtml#ch12list07).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持隐藏文件系统中存储的信息的机密性，其内容被加密，如 [清单 12-7](ch12.xhtml#ch12list07) 所示。
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 12-7: Encryption of sectors in the hidden storage*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-7：隐藏存储中扇区的加密*'
- en: To encrypt and decrypt each sector of the hidden storage, Gapz utilizes a custom
    implementation of the Advanced Encryption Standard algorithm with a key length
    of 256 bits in *cipher block chaining (CBC)* mode. Gapz uses the number of the
    first sector ➊ being encrypted or decrypted as the initialization value (IV) for
    CBC mode, as shown in [Listing 12-7](ch12.xhtml#ch12list07). Then the IV for every
    sector that follows is incremented by 1 ➋. Even though the same key is used to
    encrypt every sector of the hard drive, using different IVs for different sectors
    results in different ciphertexts each time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加密和解密隐藏存储的每个扇区，Gapz采用了自定义实现的高级加密标准（AES）算法，密钥长度为256位，并以*密码块链接（CBC）*模式工作。Gapz将第一个被加密或解密的扇区的编号➊作为CBC模式的初始化值（IV），如[Listing
    12-7](ch12.xhtml#ch12list07)所示。然后，每个后续扇区的IV都会递增1➋。尽管使用相同的密钥加密硬盘的每个扇区，但由于对不同扇区使用不同的IV，每次生成的密文都是不同的。
- en: '***Self-Defense Against Antimalware Software***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***针对反恶意软件软件的自我防御***'
- en: 'To protect itself from being removed from the system, Gapz hooks two routines
    on the hard disk miniport driver: `IRP_MJ_INTERNAL_DEVICE_CONTROL` and `IRP_MJ_DEVICE_CONTROL`.
    In the hooks the malware is interested only in the following requests.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止自己被从系统中移除，Gapz在硬盘迷你端口驱动程序上钩住了两个例程：`IRP_MJ_INTERNAL_DEVICE_CONTROL`和`IRP_MJ_DEVICE_CONTROL`。在这些钩子中，恶意软件只对以下请求感兴趣。
- en: '`IOCTL_SCSI_PASS_THROUGH`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOCTL_SCSI_PASS_THROUGH`'
- en: '`IOCTL_SCSI_PASS_THROUGH_DIRECT`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOCTL_SCSI_PASS_THROUGH_DIRECT`'
- en: '`IOCTL_ATA_PASS_THROUGH`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOCTL_ATA_PASS_THROUGH`'
- en: '`IOCTL_ATA_PASS_THROUGH_DIRECT`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOCTL_ATA_PASS_THROUGH_DIRECT`'
- en: These hooks protect the infected VBR or MBR and the Gapz image on the hard drive
    from being read and overwritten.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些钩子保护了被感染的VBR或MBR以及硬盘上的Gapz映像，避免它们被读取或覆盖。
- en: 'Unlike TDL4, Olmasco, and Rovnix, which overwrite the pointer to the handlers
    in the `DRIVER_OBJECT` structure, Gapz uses splicing: that is, it patches the
    handlers’ code itself. In [Listing 12-8](ch12.xhtml#ch12list08), you can see the
    hooked routine of the *scsiport.sys* driver image in memory. In this example,
    *scsiport.sys* is a disk miniport driver that implements the `IOCTL_SCSI_`XXX
    and `IOCTL_ATA_`XXX request handlers, and it is the main target of the Gapz hooks.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与TDL4、Olmasco和Rovnix不同，后者通过覆盖`DRIVER_OBJECT`结构中的处理程序指针，Gapz使用拼接技术：即它直接修补处理程序的代码。在[Listing
    12-8](ch12.xhtml#ch12list08)中，你可以看到内存中*scsiport.sys*驱动程序映像的钩子例程。在这个例子中，*scsiport.sys*是一个磁盘迷你端口驱动程序，负责实现`IOCTL_SCSI_`XXX和`IOCTL_ATA_`XXX请求处理程序，它是Gapz钩子的主要目标。
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 12-8: Hook of the `scsiport!ScsiPortGlobalDispatch` routine*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-8: `scsiport!ScsiPortGlobalDispatch`例程的钩子*'
- en: Notice that Gapz doesn’t patch the routine at the very beginning (at 0xf84ce44c)
    ➊ as is so often the case with other malware. In [Listing 12-9](ch12.xhtml#ch12list09),
    you can see that that it skips some instructions at the beginning of the routine
    being hooked (for example, `nop` and `mov edi, edi`).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Gapz并没有像其他恶意软件那样在例程的最开始（0xf84ce44c）处打补丁➊。[Listing 12-9](ch12.xhtml#ch12list09)中可以看到，它跳过了被钩住的例程的前几条指令（例如，`nop`和`mov
    edi, edi`）。
- en: One possible reason for this is to increase the stability and stealthiness of
    the kernel-mode module. Some security software checks only the first few bytes
    for modifications to detect patched or hooked routines, so skipping the first
    few instructions before hooking gives Gapz a chance to bypass security checks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个可能的原因是为了提高内核模式模块的稳定性和隐蔽性。一些安全软件只检查前几个字节的修改，以检测是否有补丁或钩子程序，因此跳过钩子前的几条指令让Gapz有机会绕过安全检查。
- en: Skipping the first few instructions of the hooked routine also prevents Gapz
    from interfering with the legitimate hooks already placed on the routines. For
    instance, in “hot-patchable” executable images for Windows, the compiler inserts
    the `mov edi, edi` instructions at the very beginning of the functions (as you
    can see in [Listing 12-8](ch12.xhtml#ch12list08)). This instruction is a placeholder
    for a legitimate hook that the OS may set up. Skipping this instruction ensures
    that Gapz doesn’t break the OS code-patching capabilities.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过钩子例程的前几条指令还防止Gapz干扰已经放置在例程上的合法钩子。例如，在Windows的“热补丁”可执行映像中，编译器会在函数的最开始插入`mov
    edi, edi`指令（如[Listing 12-8](ch12.xhtml#ch12list08)所示）。这条指令是OS可能设置的合法钩子的占位符。跳过这条指令可以确保Gapz不会破坏操作系统的代码修补功能。
- en: The snippet in [Listing 12-9](ch12.xhtml#ch12list09) shows code from the hooking
    routine that analyzes the instructions of the handler to find the best location
    to set up the hook. It checks the operation codes of the instructions 0x90 (corresponding
    to `nop`) and 0x8B/0x89 (corresponding to `mov edi, edi`). These instructions
    may signify that the target routine belongs to a hot-patchable image and thus
    may be potentially patched by the OS. This way, the malware knows to skip these
    instructions when placing the hook.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单12-9](ch12.xhtml#ch12list09)中的代码片段显示了钩子例程的代码，该例程分析处理程序的指令，以找到设置钩子的最佳位置。它检查指令的操作码0x90（对应于`nop`）和0x8B/0x89（对应于`mov
    edi, edi`）。这些指令可能表明目标例程属于一个可热补丁的镜像，因此可能会被操作系统潜在地补丁。这样，恶意软件就知道在设置钩子时跳过这些指令。'
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 12-9: Gapz using a disassembler to skip the first bytes of hooked
    routines*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-9：Gapz使用反汇编器跳过钩子例程的前几个字节*'
- en: To perform this analysis, Gapz implements the *hacker disassembler engine*,
    which is available for both x86 and x64 platforms. This allows the malware to
    obtain not only the length of the instructions but also other features, such as
    the operation code of the instruction and its operands.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行此分析，Gapz实现了*黑客反汇编引擎*，该引擎可用于x86和x64平台。这使得恶意软件不仅能够获取指令的长度，还能获取其他特性，如指令的操作码及其操作数。
- en: '**HACKER DISASSEMBLER ENGINE**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑客反汇编引擎**'
- en: The hacker disassembler engine (HDE) is a small, simple, easy-to-use disassembler
    engine intended for x86 and x64 code analysis. It provides the length of the command,
    operation code, and other instruction parameters such as the prefixes ModR/M and
    SIB. HDE is frequently used by malware to disassemble the prologue of the routines
    to set up malicious hooks (as in the case just described) or to detect and remove
    hooks installed by security software.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客反汇编引擎（HDE）是一个小型、简单、易于使用的反汇编引擎，旨在用于x86和x64代码分析。它提供命令的长度、操作码以及其他指令参数，如前缀ModR/M和SIB。HDE常被恶意软件用于反汇编例程的序言，以设置恶意钩子（如上文所述的情况）或检测并移除安全软件安装的钩子。
- en: '***Payload Injection***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***有效负载注入***'
- en: 'The Gapz kernel-mode module injects the payload into the user-mode address
    space as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz内核模式模块将有效负载注入到用户模式地址空间，如下所示：
- en: Read the configuration information to determine which payload modules should
    be injected into specific processes and then read those modules from hidden storage.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取配置文件信息，以确定应将哪些有效负载模块注入到特定进程中，然后从隐藏存储中读取这些模块。
- en: Allocate a memory buffer in the address space of the target process in which
    to keep the payload image.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标进程的地址空间中分配一个内存缓冲区，用于存储有效负载镜像。
- en: Create and run a thread in the target process to run the loader code; the thread
    maps the payload image, initializes the IAT, and fixes relocations.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标进程中创建并运行一个线程，执行加载器代码；该线程映射有效负载镜像，初始化IAT，并修复重定位。
- en: The *\sys* directory within the hidden filesystem contains a configuration file
    specifying which payload modules should be injected into specific processes. The
    name of the configuration file is derived from the hidden filesystem AES encryption
    key via a SHA1 hashing algorithm. The configuration file consists of a header
    and a number of entries, each of which describes a target process, as shown in
    [Figure 12-8](ch12.xhtml#ch12fig08).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏文件系统中的*\sys*目录包含一个配置文件，该文件指定了应注入到特定进程中的有效负载模块。配置文件的名称是通过SHA1哈希算法，从隐藏文件系统的AES加密密钥推导而来。配置文件由一个头部和多个条目组成，每个条目描述了一个目标进程，如[图12-8](ch12.xhtml#ch12fig08)所示。
- en: '![image](../images/12fig08.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig08.jpg)'
- en: '*Figure 12-8: Layout of the configuration file for payload injection*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-8：有效负载注入配置文件的布局*'
- en: Each process entry has the layout shown in [Listing 12-10](ch12.xhtml#ch12list10).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程条目具有[清单12-10](ch12.xhtml#ch12list10)所示的布局。
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 12-10: Layout of a payload configuration entry in the configuration
    file*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-10：配置文件中有效负载配置条目的布局*'
- en: The `TargetProcess` field ➊ contains the name of the process into which to inject
    the payload. The `LoadOptions` field ➋ specifies whether the payload module is
    a 32- or 64-bit image, depending on the infected system. The `PayloadType` field
    ➌ signifies whether the module to be injected is an “overlord” module or any other
    payload.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`TargetProcess`字段➊包含要注入有效负载的进程名称。`LoadOptions`字段➋指定有效负载模块是32位镜像还是64位镜像，具体取决于受感染的系统。`PayloadType`字段➌表示要注入的模块是“上级”模块还是其他有效负载。'
- en: 'The module *overlord32.dll* (*overlord64.dll* for 64-bit process) is injected
    into the *svchost.exe* processes in the system. The purpose of the *overlord32.dll*
    module is to execute the Gapz commands issued by the malicious kernel-mode code.
    These executed commands might perform the following tasks:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 模块*overlord32.dll*（64位进程为*overlord64.dll*）被注入到系统中的*svchost.exe*进程中。*overlord32.dll*模块的目的是执行恶意内核模式代码发出的Gapz命令。这些执行的命令可能会执行以下任务：
- en: Gather information about all the network adapters installed in the system and
    their properties.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集系统中所有网络适配器及其属性的信息。
- en: Gather information on the presence of particular software in the system.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集系统中特定软件的存在信息。
- en: Check the internet connection by trying to reach *[http://www.update.microsoft.com](http://www.update.microsoft.com)*.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过尝试访问* [http://www.update.microsoft.com](http://www.update.microsoft.com) *来检查互联网连接。
- en: Send and receive data from a remote host using Windows sockets.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Windows套接字发送和接收远程主机的数据。
- en: Get the system time from *http://www.time.windows.com*.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*http://www.time.windows.com*获取系统时间。
- en: Get the host IP address when given its domain name (via Win32 API `gethostbyname`).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定域名时，通过Win32 API `gethostbyname`获取主机的IP地址。
- en: Get the Windows shell (by means of querying the “shell” value of the *Software\Microsoft\Windows
    NT\CurrentVersion\Winlogon* registry key).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取Windows Shell（通过查询*Software\Microsoft\Windows NT\CurrentVersion\Winlogon*注册表项的“shell”值）。
- en: The results of those commands are then transmitted back to the kernel mode.
    [Figure 12-9](ch12.xhtml#ch12fig09) shows an example of some configuration information
    extracted from the hidden storage on the infected system.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些命令的结果会传回内核模式。[图12-9](ch12.xhtml#ch12fig09)显示了从受感染系统的隐藏存储中提取的一些配置信息示例。
- en: '![image](../images/12fig09.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig09.jpg)'
- en: '*Figure 12-9: An example of a payload configuration file*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-9：有效负载配置文件的示例*'
- en: You can see the two modules—*overlord32.dll* and *overlord64.dll*—intended for
    injection into the *svchost.exe* processes on x86- and x64-bit systems, respectively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到两个模块—*overlord32.dll*和*overlord64.dll*—分别用于注入到x86和x64位系统中的*svchost.exe*进程。
- en: Once a payload module and a target process have been identified, Gapz allocates
    a memory buffer in the target process address space and copies the payload module
    into it. Then the malware creates a thread in the target process to run the loader
    code. If the operating system is Windows Vista or higher, Gapz can create a new
    thread by simply executing the system routine `NtCreateThreadEx`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有效负载模块和目标进程被识别，Gapz会在目标进程的地址空间中分配一个内存缓冲区，并将有效负载模块复制到其中。然后，恶意软件在目标进程中创建一个线程来运行加载器代码。如果操作系统是Windows
    Vista或更高版本，Gapz可以通过简单地执行系统例程`NtCreateThreadEx`来创建新线程。
- en: 'In pre-Vista operating systems (such as Windows XP or Server 2003), things
    are a bit more complicated because the `NtCreateThreadEx` routine is not exported
    by the OS kernel. In these cases, Gapz reimplements some of the `NtCreateThreadEx`
    functionality in the kernel-mode module and follows these steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vista之前的操作系统（如Windows XP或Server 2003）中，事情会更加复杂，因为操作系统内核并未导出`NtCreateThreadEx`例程。在这些情况下，Gapz会重新实现`NtCreateThreadEx`的一部分功能，并遵循以下步骤：
- en: Manually allocate the stack that will hold the new thread.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动分配将保存新线程的堆栈。
- en: Initialize the thread’s context and thread environment block (TEB).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化线程的上下文和线程环境块（TEB）。
- en: Create a thread structure by executing the undocumented routine `NtCreateThread`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行未记录的例程`NtCreateThread`来创建一个线程结构。
- en: Register a newly created thread in the client/server runtime subsystem (CSRSS)
    if necessary.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，在客户端/服务器运行时子系统（CSRSS）中注册新创建的线程。
- en: Execute the new thread.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行新线程。
- en: 'The loader code is responsible for mapping the payload into a process’s address
    space and is executed in user mode. Depending on the payload type, there are different
    implementations for the loader code, as shown in [Figure 12-10](ch12.xhtml#ch12fig10).
    For payload modules implemented as DLL libraries, there are two loaders: a DLL
    loader and a command executer. For payload modules implemented as EXE modules,
    there are also two loaders.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器代码负责将有效负载映射到进程的地址空间，并在用户模式下执行。根据有效负载类型，加载器代码有不同的实现，如[图12-10](ch12.xhtml#ch12fig10)所示。对于作为DLL库实现的有效负载模块，有两个加载器：DLL加载器和命令执行器。对于作为EXE模块实现的有效负载模块，也有两个加载器。
- en: '![image](../images/12fig10.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig10.jpg)'
- en: '*Figure 12-10: Gapz injection capabilities*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-10：Gapz注入能力*'
- en: We’ll look at each loader now.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看每个加载器。
- en: '**DLL Loader Code**'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**DLL加载器代码**'
- en: 'The Gapz DLL loader routine is responsible for loading and unloading DLLs.
    It maps an executable image into the user-mode address space of the target process,
    initializes its IAT, fixes relocations, and executes the following export routines
    depending on whether the payload is loaded or unloaded:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz DLL加载器例程负责加载和卸载DLL。它将可执行图像映射到目标进程的用户模式地址空间，初始化其IAT，修复重定位，并根据有效载荷是否加载或卸载，执行以下导出例程：
- en: '**Export routine #1 (loading payload)** Initializes the loaded payload'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**导出例程 #1（加载有效载荷）** 初始化加载的有效载荷'
- en: '**Export routine #2 (unloading payload)** Deinitializes the loaded payload'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**导出例程 #2（卸载有效载荷）** 取消初始化已加载的有效载荷'
- en: '[Figure 12-11](ch12.xhtml#ch12fig11) shows the payload module *overlord32.dll*.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-11](ch12.xhtml#ch12fig11)展示了有效载荷模块*overlord32.dll*。'
- en: '![image](../images/12fig11.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig11.jpg)'
- en: '*Figure 12-11: Export address table of the Gapz payload*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-11：Gapz有效载荷的导出地址表*'
- en: '[Figure 12-12](ch12.xhtml#ch12fig12) illustrates the routine. When unloading
    the payload, Gapz executes export routine #2 and frees memory used to hold the
    payload image. When loading the payload, Gapz performs all the necessary steps
    to map the image into the address space of the process and then execute export
    routine #1.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-12](ch12.xhtml#ch12fig12)展示了该例程。当卸载有效载荷时，Gapz执行导出例程 #2并释放用于保存有效载荷图像的内存。当加载有效载荷时，Gapz执行所有必要的步骤，将图像映射到进程的地址空间中，然后执行导出例程
    #1。'
- en: '![image](../images/12fig12.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig12.jpg)'
- en: '*Figure 12-12: Gapz DLL payload-loading algorithm*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-12：Gapz DLL有效载荷加载算法*'
- en: '**Command Executer Code**'
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**命令执行器代码**'
- en: 'The command executor routine is responsible for executing commands as instructed
    by the loaded payload DLL module. This routine merely calls export routine #3
    ([Figure 12-11](ch12.xhtml#ch12fig11)) of the payload and passes all the necessary
    parameters to its handler.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '命令执行器例程负责按照加载的有效载荷DLL模块的指令执行命令。该例程仅调用有效载荷的导出例程 #3（[图12-11](ch12.xhtml#ch12fig11)），并将所有必要的参数传递给其处理程序。'
- en: '**EXE Loader Code**'
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**EXE加载器代码**'
- en: 'The two remaining loader routines are used to run downloaded executables in
    the infected system. The first implementation runs the executable payload from
    the *TEMP* directory: the image is saved into the *TEMP* directory and the `CreateProcess`
    API is executed, as indicated in [Figure 12-13](ch12.xhtml#ch12fig13).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个加载器例程用于在感染的系统中运行下载的可执行文件。第一个实现从*TEMP*目录运行可执行有效载荷：图像被保存到*TEMP*目录，并执行`CreateProcess`
    API，如[图12-13](ch12.xhtml#ch12fig13)所示。
- en: '![image](../images/12fig13.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig13.jpg)'
- en: '*Figure 12-13: Gapz EXE payload-running algorithm via `CreateProcess`*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-13：通过`CreateProcess`运行Gapz EXE有效载荷的算法*'
- en: The second implementation runs the payload by creating a suspended legitimate
    process, then overwriting the legitimate process image with the malicious image;
    after that, the process is resumed, as illustrated in [Figure 12-14](ch12.xhtml#ch12fig14).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种实现通过创建一个挂起的合法进程来运行有效载荷，然后用恶意图像覆盖合法进程图像；之后，进程恢复运行，如[图12-14](ch12.xhtml#ch12fig14)所示。
- en: '![image](../images/12fig14.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig14.jpg)'
- en: '*Figure 12-14: Gapz EXE payload-running algorithm via `CreateProcessAsUser`*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-14：通过`CreateProcessAsUser`运行Gapz EXE有效载荷的算法*'
- en: The second method of loading the executable payload is stealthier and less prone
    to detection than the first. While the first method simply runs the payload without
    any precautions, the second method creates a process with a legitimate executable
    first and only then replaces the original image with the malicious payload. This
    may trick the security software into allowing the payload to execute.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种加载可执行有效载荷的方法比第一种更隐蔽且不易被检测。虽然第一种方法只是直接运行有效载荷而不加任何预防，但第二种方法首先创建一个合法的可执行进程，然后才用恶意有效载荷替换原始图像。这可能会欺骗安全软件，使其允许有效载荷执行。
- en: '***Payload Communication Interface***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***有效载荷通信接口***'
- en: 'In order to communicate with the injected payload, Gapz implements a specific
    interface in quite an unusual way: by impersonating the handler of the payload
    requests in the *null.sys* driver. This technique is shown in [Figure 12-15](ch12.xhtml#ch12fig15).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与注入的有效载荷进行通信，Gapz以一种相当不寻常的方式实现了特定接口：通过伪装成*null.sys*驱动程序中有效载荷请求的处理程序。此技术在[图12-15](ch12.xhtml#ch12fig15)中展示。
- en: '![image](../images/12fig15.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig15.jpg)'
- en: '*Figure 12-15: Gapz payload interface architecture*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-15：Gapz有效载荷接口架构*'
- en: The malware first sets the `DriverUnload` field ➊ of the `DRIVER_OBJECT` structure
    corresponding to the *\Device\Null* device object to `0` (storing a pointer to
    the handler that will be executed when the OS unloads the driver) and hooks the
    original `DriverUnload` routine. Then it overwrites the address of the `IRP_MJ_DEVICE_CONTROL`
    handler in the `DRIVER_OBJECT` with the address of the hooked `DriverUnload` routine
    ➋.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先将对应于 *\Device\Null* 设备对象的 `DRIVER_OBJECT` 结构中的 `DriverUnload` 字段 ➊ 设置为
    `0`（存储当操作系统卸载驱动程序时将执行的处理程序的指针），并钩住原始的 `DriverUnload` 例程。然后，它将 `DRIVER_OBJECT`
    中 `IRP_MJ_DEVICE_CONTROL` 处理程序的地址替换为钩住的 `DriverUnload` 例程的地址 ➋。
- en: The hook checks the parameters of the `IRP_MJ_DEVICE_CONTROL` request to determine
    whether the request was initiated by the payload. If so, the payload interface
    handler is called instead of the original `IRP_MJ_DEVICE_CONTROL` handler ➌.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子检查 `IRP_MJ_DEVICE_CONTROL` 请求的参数，以确定请求是否由有效负载发起。如果是，则调用有效负载接口处理程序，而不是原始的 `IRP_MJ_DEVICE_CONTROL`
    处理程序 ➌。
- en: '**DRIVER UNLOAD ROUTINE**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动卸载例程**'
- en: Before unloading a kernel-mode driver, the operating system kernel executes
    the special routine `DriverUnload`. This optional routine, implemented by the
    kernel-mode driver to be unloaded, is used to perform any operations that are
    necessary before the system unloads the driver. The pointer to the routine is
    stored in the `DriverUnload` field of the corresponding `DRIVER_OBJECT` structure.
    If this routine isn’t implemented, the `DriverUnload` field contains `NULL` and
    the driver cannot be unloaded.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在卸载内核模式驱动程序之前，操作系统内核会执行特殊的 `DriverUnload` 例程。这个由要卸载的内核模式驱动程序实现的可选例程，用于执行系统卸载驱动程序之前所需的任何操作。该例程的指针存储在对应
    `DRIVER_OBJECT` 结构的 `DriverUnload` 字段中。如果该例程未实现，`DriverUnload` 字段将包含 `NULL`，此时驱动程序无法卸载。
- en: A snippet of the `DriverUnload` hook is shown in [Listing 12-11](ch12.xhtml#ch12list11).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`DriverUnload` 钩子的代码片段显示在 [示例 12-11](ch12.xhtml#ch12list11) 中。'
- en: '[PRE11]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 12-11: Hook of `DriverUnload` of* null.sys'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-11：`DriverUnload` 钩子代码摘录自* null.sys'
- en: Gapz checks at ➊ if the request is coming from the payload. If so, it decrypts
    the request using the RC4 cipher ➋ and executes the corresponding handler ➌. Once
    the request is handled, Gapz encrypts the result ➍ and sends it back to the payload.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz 在➊处检查请求是否来自有效负载。如果是，它使用 RC4 加密算法 ➋ 解密请求并执行相应的处理程序 ➌。请求处理完毕后，Gapz 将结果加密
    ➍ 并返回给有效负载。
- en: The payload can send requests to the Gapz kernel-mode module using the code
    in [Listing 12-12](ch12.xhtml#ch12list12).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有效负载可以使用 [示例 12-12](ch12.xhtml#ch12list12) 中的代码向 Gapz 内核模式模块发送请求。
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 12-12: Sending a request from the user-mode payload to the kernel-mode
    module*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-12：从用户模式有效负载向内核模式模块发送请求*'
- en: The payload opens a handle to the `NULL` device ➊. This is a system device,
    so the operation shouldn’t draw the attention of any security software. Once the
    payload obtains the handle, it communicates with the kernel-mode module using
    the `DeviceIoControl` system API ➋.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有效负载打开 `NULL` 设备的句柄 ➊。这是一个系统设备，因此该操作不会引起任何安全软件的注意。一旦有效负载获得句柄，它便使用 `DeviceIoControl`
    系统 API ➋ 与内核模式模块进行通信。
- en: '***Custom Network Protocol Stack***'
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自定义网络协议栈***'
- en: The bootkit communicates with C&C servers over the HTTP protocol, whose main
    purpose is to request and download the payload and report back the bot status.
    The malware enforces encryption to protect the confidentiality of the messages
    being exchanged and to check the authenticity of the message source in order to
    prevent subversion by commands from fake C&C servers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 引导木马通过 HTTP 协议与 C&C 服务器通信，其主要目的是请求并下载有效负载并报告机器人状态。恶意软件强制执行加密，以保护交换消息的机密性，并验证消息来源的真实性，以防止来自伪造
    C&C 服务器的指令破坏。
- en: 'The most striking feature of the network communication is the way in which
    it is implemented. There are two ways the malware sends a message to the C&C server:
    by using the user-mode payload module (*overlord32.dll* or *overlord64.dll*) or
    using a custom kernel-mode TCP/IP protocol stack implementation. This network
    communication scheme is shown in [Figure 12-16](ch12.xhtml#ch12fig16).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通信最引人注目的特点是其实现方式。恶意软件通过两种方式向 C&C 服务器发送消息：使用用户模式有效负载模块（*overlord32.dll* 或 *overlord64.dll*）或使用自定义的内核模式
    TCP/IP 协议栈实现。这种网络通信方案如图 [12-16](ch12.xhtml#ch12fig16) 所示。
- en: The user-mode payload, *overlord32.dll* or *overlord64.dll*, sends the message
    to the C&C server using a Windows socket implementation. The custom implementation
    of the TCP/IP protocol stack relies on the miniport adapter driver. Normally,
    network communication requests pass through the network driver stack, and at different
    layers of the stack they may be inspected by security software drivers. According
    to Microsoft’s Network Driver Interface Specification (NDIS), the miniport driver
    is the lowest driver in the network driver stack, so by sending network I/O packets
    directly to the miniport device object, Gapz can bypass all the intermediate drivers
    and avoid inspection (see [Figure 12-17](ch12.xhtml#ch12fig17)).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模式的有效载荷，*overlord32.dll* 或 *overlord64.dll*，通过 Windows 套接字实现将消息发送到 C&C 服务器。自定义实现的
    TCP/IP 协议栈依赖于迷你端口适配器驱动程序。通常，网络通信请求会通过网络驱动程序栈，而在栈的不同层级，安全软件驱动程序可能会对其进行检查。根据微软的网络驱动接口规范（NDIS），迷你端口驱动程序是网络驱动栈中的最低级驱动程序，因此通过将网络
    I/O 数据包直接发送到迷你端口设备对象，Gapz 可以绕过所有中间驱动程序，避免被检查（见[图 12-17](ch12.xhtml#ch12fig17)）。
- en: '![image](../images/12fig16.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig16.jpg)'
- en: '*Figure 12-16: Gapz network communication scheme*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-16: Gapz 网络通信方案*'
- en: '![image](../images/12fig17.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig17.jpg)'
- en: '*Figure 12-17: Gapz custom network implementation*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-17: Gapz 自定义网络实现*'
- en: 'Gapz obtains a pointer to the structure describing the miniport adapter by
    manually inspecting the NDIS library (*ndis.sys*) code. The routine responsible
    for handling NDIS miniport adapters is implemented in block #8 of the kernel-mode
    module.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Gapz 通过手动检查 NDIS 库（*ndis.sys*）代码，获取描述迷你端口适配器的结构体指针。负责处理 NDIS 迷你端口适配器的例程在内核模式模块的第
    8 块中实现。
- en: This approach allows Gapz to use the socket interface to communicate with the
    C&C server without being noticed. The architecture of the Gapz network subsystem
    is summarized in [Figure 12-18](ch12.xhtml#ch12fig18).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使得 Gapz 能够通过套接字接口与 C&C 服务器通信，而不被发现。Gapz 网络子系统的架构概述见[图 12-18](ch12.xhtml#ch12fig18)。
- en: '![image](../images/12fig18.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig18.jpg)'
- en: '*Figure 12-18: Gapz network architecture*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-18: Gapz 网络架构*'
- en: 'As you can see, the Gapz network architecture implements most layers of the
    Open Systems Interconnection (OSI) model: data link, transport, and application.
    To send and receive network packets to and from the physical device object that
    represents the network interface card, Gapz uses a corresponding interface available
    in the system (provided by the network card driver). However, all the work related
    to creating and parsing network frames is entirely implemented in the malware’s
    custom network stack.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Gapz 网络架构实现了开放系统互联（OSI）模型的大部分层级：数据链路层、传输层和应用层。为了将网络数据包发送到并接收自代表网络接口卡的物理设备对象，Gapz
    使用系统中可用的相应接口（由网络卡驱动提供）。然而，所有与创建和解析网络帧相关的工作完全由恶意软件的自定义网络栈实现。
- en: '**Conclusion**'
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: As you’ve seen, Gapz is complex malware with a very elaborate implementation
    and one of the most remarkably covert bootkits due to its VBR infection technique.
    No previously known bootkit can boast such a simultaneously elegant and subtle
    infection approach. Its discovery forced the security industry to step up its
    bootkit detection approaches and dig deeper into MBR/VBR scanning, looking not
    only at MBR/VBR code modifications but also at parameters and data structures
    that were previously considered out of scope.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Gapz 是一种复杂的恶意软件，具有非常精密的实现，并且由于其 VBR 感染技术，它是最为隐蔽的引导病毒之一。没有任何已知的引导病毒能够拥有如此优雅和微妙的感染方式。它的发现迫使安全行业提升了对引导病毒的检测方法，并深入挖掘
    MBR/VBR 扫描，不仅关注 MBR/VBR 代码修改，还关注以前被认为不在范围内的参数和数据结构。
