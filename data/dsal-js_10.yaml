- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 8 SHUFFLING AND SAMPLING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8 洗牌与采样
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Consider this chapter to be a complement of the two previous chapters, but instead
    of sorting values into some kind of order, you want to shuffle them into a random,
    disordered sequence (as for a card game). And rather than select a value at a
    given position, you want to choose a set of values randomly (as for statistical
    sampling algorithms). [Chapters 6](chapter6.xhtml) and [7](chapter7.xhtml) revolved
    around order and consistency, but this chapter works with disorder and randomness
    instead.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可以看作是对前两章的补充，但与其将值排序为某种顺序，你希望将它们洗牌成一个随机、无序的序列（就像扑克牌游戏一样）。与其选择一个给定位置的值，你希望随机选择一组值（就像统计抽样算法一样）。[第6章](chapter6.xhtml)和[第7章](chapter7.xhtml)围绕顺序和一致性展开，而本章则处理无序和随机性。
- en: '### Choosing Numbers Randomly'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### 随机选择数字'
- en: 'First, consider a basic function that you’ll need to use throughout this chapter:
    generating a random number in a given interval. JavaScript already provides Math.random(),
    which produces a pseudorandom number *r* such that 0 ≤ *r* < 1\. (For more information,
    see *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random.).*)
    The distribution of the numbers this function produces is *uniform*, which means
    that each value is equally possible, and no value is more likely than another.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑一个你将在本章中需要使用的基本函数：在给定区间内生成一个随机数。JavaScript 已经提供了 Math.random()，它会生成一个伪随机数
    *r*，使得 0 ≤ *r* < 1。（更多信息，请参见 *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random).*）这个函数生成的数字的分布是
    *均匀的*，意味着每个值的可能性是相等的，没有任何一个值比另一个值更可能。
- en: NOTE
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Why is it pseudorandom? The random numbers are actually produced by an algorithm
    in such a way that the properties of the generated sequence are approximately
    that of a sequence of truly random numbers. However, the fact that the numbers
    are generated by a procedure automatically means that they aren’t truly random;
    they just look like they are. For the sake of simplicity, though, in this chapter
    we’ll consider the produced numbers to be random.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么它是伪随机的？这些随机数实际上是由算法生成的，生成的序列的特性大致与真正的随机数序列相似。然而，事实是这些数字是通过某个过程生成的，这自动意味着它们并不是真正的随机数；它们只是看起来像是随机的。不过，为了简单起见，在本章中我们将把生成的数字视为随机数。*'
- en: 'Using this function, you can scale its results to produce numbers in any given
    range. The following functions will come in handy for the rest of the chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，你可以将结果扩展到任意给定的范围。接下来的函数将在本章其余部分派上用场：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first function is useful when you want to decide between two alternatives
    randomly, as if simulating a coin toss. If a random number is less than 0.5 (0
    to 0.4999 ...), you return false (heads), and you return true (tails) otherwise
    (0.5 to 0.9999 ...). Given a range of values from *a* to *b* (not necessarily
    integers, but *a* < *b*), the second function produces a random floating-point
    number *r* such that *a* < *r* < *b*. This is easily verified by noting that (b
    - a)*Math.random() is greater than or equal to zero but strictly less than (b
    - a). The last function is meant to be called with integer arguments, and it produces
    a random integer *r* such that *a* < *r* < *b*. You can also write it as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数在你想随机决定两个选项之间的选择时非常有用，就像模拟抛硬币一样。如果随机数小于 0.5（0 到 0.4999 ...），则返回 false（正面），否则返回
    true（反面）（0.5 到 0.9999 ...）。给定一个从 *a* 到 *b* 的值范围（不一定是整数，但 *a* < *b*），第二个函数会生成一个随机浮动数
    *r*，使得 *a* < *r* < *b*。通过注意到 (b - a)*Math.random() 大于或等于零，但严格小于 (b - a)，这可以很容易地验证。最后一个函数旨在传入整数参数，并生成一个随机整数
    *r*，使得 *a* < *r* < *b*。你也可以这样写：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some people have difficulty with randomInt(...). For instance, to simulate
    rolling a die, they might write randomInt(1,6), but that won’t work: randomInt(1,7)
    does the job. (See question 8.2 for another take on this.) You could obviously
    rewrite randomInt(...) to do it another way, but you’re following JavaScript’s
    lead as in the array.slice(start,end) method, whose parameters work exactly as
    these do, taking elements from start up to (but not including) end.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人对于 randomInt(...) 感到困惑。例如，为了模拟掷骰子，他们可能会写 randomInt(1,6)，但这行不通：randomInt(1,7)
    才是正确的做法。（有关这个问题的其他见解，请参见第 8.2 问题。）显然，你可以重写 randomInt(...) 以用其他方式实现，但你是按照 JavaScript
    中的 array.slice(start,end) 方法来做的，该方法的参数与这些相同，表示从 start 开始，直到 end（不包括 end）为止取出元素。
- en: 'With these basic tools, let’s turn to the problems of shuffling and sampling,
    both of which will be based on random numbers in one way or another.  ### Shuffling'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '有了这些基本工具，让我们来讨论洗牌和抽样问题，这两者都以某种方式基于随机数。  ### 洗牌'
- en: The first problem we’ll consider is *shuffling* an array of values in order
    to produce a random sequence of values—or to use a mathematical term, a permutation.
    This is equivalent to shuffling a deck of cards before playing a game to start
    anew with a different sequence of cards every time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先考虑*洗牌*一个值的数组，以产生一个随机值序列——用数学术语来说，就是排列。这相当于在玩游戏前洗牌，每次都用不同的卡牌顺序开始。
- en: 'An important requisite is that every possible permutation should be equally
    likely, which presents a thorny problem: How can you make sure that the shuffling
    code ran correctly? For instance, when sorting an array, you can check that the
    sorted array is actually in order and that its elements are the same before and
    after sorting. Similarly, for selection algorithms, you can check that it worked
    by sorting the array separately and then checking whether the selected value is
    correct. Shuffling is harder to check.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的前提是，每个可能的排列应该具有相同的概率，这就提出了一个棘手的问题：如何确保洗牌代码正确运行？例如，在排序一个数组时，你可以检查排序后的数组是否确实按顺序排列，并且排序前后的元素相同。类似地，对于选择算法，你可以通过单独排序数组来检查它是否正确，然后检查选中的值是否正确。洗牌则更难检查。
- en: First, you should prove (somehow) that the logic is correct so that all results
    are equally probable. However, what if you implement the algorithm badly, with
    some bug? (Don’t ask me how I know.) An empirical suggestion is to run the algorithm
    many times with a known input sequence and test statistically whether the observed
    outcomes suggest a uniform distribution; we’ll leave the mathematical aspects
    of this solution to the textbooks and instead try an easier way (see question
    8.1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该（以某种方式）证明逻辑是正确的，以确保所有结果的概率相等。然而，如果你错误地实现了算法，导致有 bug，怎么办？（别问我怎么知道的。）一种经验性的建议是，使用已知的输入序列多次运行该算法，并通过统计方法测试观察到的结果是否表明其符合均匀分布；我们将这些数学方面的内容留给教科书，改为尝试一种更简单的方法（参见问题
    8.1）。
- en: Shuffling by Sorting
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过排序洗牌
- en: We’ll start with a sorting-based algorithm. It doesn’t have the best performance,
    but it’s the simplest implementation. In order to shuffle a set of values, you
    associate a random number with each value, sort the set on that random value,
    and the result will be a totally random shuffle (see [Figure 8-1](chapter8.xhtml#fig8-1)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从基于排序的算法开始。它的性能不是最优的，但实现最简单。为了洗牌一组值，你将一个随机数与每个值关联，然后根据这个随机值对数组进行排序，最终的结果就是完全随机的洗牌（见[图
    8-1](chapter8.xhtml#fig8-1)）。
- en: '![](../images/Figure8-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-1.jpg)'
- en: 'Figure 8-1: Sorting an array by a randomly assigned key produces a totally
    random shuffle.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：通过随机分配的键对数组进行排序，生成完全随机的洗牌。
- en: 'You can implement this solution with any of the algorithms discussed in [Chapter
    6](chapter6.xhtml). Let’s go the simplest possible direction and use JavaScript’s
    own .sort(...) method. The shuffle code ends up being a single line, even though
    more lines are used here to show it clearly:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用[第 6 章](chapter6.xhtml)中讨论的任何算法来实现这个解决方案。我们选择最简单的方向，使用 JavaScript 自带的 .sort(...)
    方法。虽然为了清晰展示，代码使用了更多行，但最终的洗牌代码是一行：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code directly matches the steps in [Figure 8-1](chapter8.xhtml#fig8-1).
    Given the array of values, create a new array where objects have the original
    value in val and a random value in key ❶. Then sort it by this random key ❷ and
    produce a new array with only the values ❸.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码直接对应[图 8-1](chapter8.xhtml#fig8-1)中的步骤。给定一个值的数组，创建一个新数组，其中对象的原始值保存在 val 中，而一个随机值保存在
    key ❶ 中。然后按这个随机键 ❷ 对数组进行排序，并生成一个只包含值的新数组 ❸。
- en: This algorithm is probably the shortest one in the book, and it produces a shuffled
    list of values easily. However, it’s easy to make a mistake when implementing
    random sorting (see question 8.3 for an example).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可能是本书中最简短的一个，它能够轻松地生成一个洗牌后的值列表。然而，实现随机排序时容易出错（见问题 8.3 示例）。
- en: The performance of this code is *O*(*n* log *n*), but you can do better. First,
    however, we’ll consider something you could have designed based on an interesting
    mix of concepts from [Chapters 5](chapter5.xhtml) and [6](chapter6.xhtml).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的性能是 *O*(*n* log *n*)，但你可以做得更好。不过，我们首先考虑一种基于[第 5 章](chapter5.xhtml)和[第 6
    章](chapter6.xhtml)中有趣的概念混合设计的方案。
- en: Shuffling by Coin Tossing
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 硬币抛掷法洗牌
- en: Let’s explore other ways to shuffle a set of values. Imagine a divide-and-conquer
    procedure where you split a set in two (using a simulated coin toss to decide
    what goes where), recursively shuffle each part, and join them back together.
    Empty sets or sets with only one element would need no shuffling. You can shuffle
    a set with exactly two elements by randomly deciding (again, tossing a coin) which
    elements will be first and last. For sets with more than two elements, apply the
    recursive procedure illustrated in [Figure 8-2](chapter8.xhtml#fig8-2).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索其他洗牌值集合的方法。假设你有一个分治过程，将集合分成两部分（使用模拟的硬币抛掷来决定元素的去向），递归地洗牌每部分，然后将它们合并回去。空集合或只有一个元素的集合不需要洗牌。你可以通过随机决定（同样抛硬币）哪两个元素将是首尾，来洗牌恰好包含两个元素的集合。对于包含超过两个元素的集合，应用[图
    8-2](chapter8.xhtml#fig8-2)所示的递归过程。
- en: '![](../images/Figure8-2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-2.jpg)'
- en: 'Figure 8-2: Randomly splitting an array, shuffling each part, and joining the
    results produces a shuffle that’s reminiscent of merge sort.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：随机拆分数组，对每部分进行洗牌，并将结果合并，产生一种类似于归并排序的洗牌效果。
- en: The first split at the top separates the array into two parts with five and
    three elements. The subsequent steps follow moving downward. The five-element
    array splits into arrays with one and four elements. The single element doesn’t
    need any further shuffling, and the array with elements splits into two parts.
    Of those two parts, one is left as is (12, 60), and the other is swapped. The
    joined pairs create a random shuffle of the original four-element array, which
    then joins with the single element (22) to produce a random shuffle of the initial
    five-element array. A similar process occurs on the right side of the array, and
    the final result is at the bottom.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的第一次拆分将数组分成了五个元素和三个元素两部分。随后步骤依次向下进行。五个元素的数组拆分成了包含一个和四个元素的数组。单个元素无需进一步洗牌，包含多个元素的数组被拆分成两部分。两部分中，一部分保持不变（12，60），另一部分则交换位置。合并后的数组创造了原始四元素数组的随机洗牌，接着与单个元素（22）合并，形成最初五个元素数组的随机洗牌。右侧数组执行类似的过程，最终结果见底部。
- en: 'Here’s the implementation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现方法：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The parameters for shuffling functions will be an array arr and the portion
    of it (from, to) you are shuffling ❶. If the length of the array is less than
    2 ❷, nothing needs to be done. If the array has exactly two elements ❸, flip a
    coin to decide whether to leave it be or swap the two elements. If the array has
    more than two elements ❹, apply a logic reminiscent of partitioning in quicksort:
    flip coins to decide where each value goes. If the coin flip is true, the value
    goes into the ind1 to to section, and if the coin flip is false, the value goes
    in the from to ind0 section. After moving every element to its place (at which
    time ind0 and ind1 will point to positions next to each other), use recursion
    to shuffle the elements that received a false bit ❺ and those that got a true
    bit ❻. Finally, return the shuffled-in-place array ❼.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 洗牌函数的参数将是一个数组 arr 以及其要洗牌的部分（from，to）❶。如果数组的长度小于 2 ❷，则无需做任何操作。如果数组恰好有两个元素 ❸，则通过抛硬币决定是保持原样还是交换两个元素的位置。如果数组有超过两个元素
    ❹，则应用类似于快速排序中分区的逻辑：通过抛硬币决定每个值应该放在哪个位置。如果抛硬币结果为真，值将放入 ind1 到 to 区间；如果为假，则放入 from
    到 ind0 区间。在将每个元素移动到它应该去的位置后（此时 ind0 和 ind1 会指向相邻的位置），使用递归来洗牌那些得到了假位（false bit）的元素❺和得到了真位（true
    bit）的元素❻。最后，返回已洗牌的数组❼。
- en: This algorithm can be proven to have an average *O*(*n* log *n*) performance
    with a worst case of *O*(*n*²). [Figure 8-2](chapter8.xhtml#fig8-2) should remind
    you of merge sort and quicksort, algorithms with similar workings, so you haven’t
    really done better than with sorting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可以证明具有平均*O*(*n* log *n*)性能，最坏情况下是*O*(*n*²)。 [图8-2](chapter8.xhtml#fig8-2)应该会让你想起归并排序和快速排序，这些算法的工作方式相似，因此你并没有比排序更好。
- en: '#### Shuffling in Linear Time'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 线性时间洗牌'
- en: How fast can we shuffle? The best possible result with shuffling is *O*(*n*),
    where you access each element in the array once. All the methods in the previous
    section had worse performance (although for small values of *n* they may be quite
    suitable), so now you’re going to consider linear time shuffling algorithms. And
    to better match what we did in [Chapter 6](chapter6.xhtml), we’ll shuffle just
    a portion of an array.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有多快的洗牌速度？洗牌的最佳可能结果是*O*(*n*)，其中你仅访问数组中的每个元素一次。前一节中的所有方法都表现较差（尽管对于较小的*n*值，它们可能非常合适），所以现在你将考虑线性时间的洗牌算法。为了更好地与我们在[第6章](chapter6.xhtml)中所做的相匹配，我们将仅对数组的一部分进行洗牌。
- en: Floyd’s Shuffle
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Floyd的洗牌
- en: 'Robert Floyd’s linear time shuffling algorithm has some interesting ideas.
    The process has two steps: first, it generates a random permutation of numbers
    0 to *n* – 1, and then it uses that generated permutation to shuffle the original
    array. (You’ll also see this technique in Floyd’s sampling algorithm, later in
    this chapter.) Start by generating the permutation, which is similar to an insertion
    sort (see [Figure 8-3](chapter8.xhtml#fig8-3)).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·弗洛伊德的线性时间洗牌算法有一些有趣的思想。该过程分为两个步骤：首先，它生成从0到*n* – 1的随机排列数字，然后使用该生成的排列来洗牌原始数组。（你将在本章后面看到这种技术在Floyd的抽样算法中的应用。）首先生成排列，这类似于插入排序（见[图8-3](chapter8.xhtml#fig8-3)）。
- en: '![](../images/Figure8-3.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-3.jpg)'
- en: 'Figure 8-3: Floyd’s algorithm produces a shuffle by randomly inserting new
    values into the previously shuffled ones.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-3：Floyd的算法通过随机插入新值到之前已洗牌的值中来产生洗牌。
- en: The algorithm works the same way as arranging playing cards by hand. You pick
    the first card, and that’s it. Then you pick the second card and place it to the
    left or to the right of the previous one. Then pick the third card and place it
    to the left, in the middle, or to the right of the previous two cards. Each new
    card goes somewhere among the previous cards, in a random place.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的工作方式与手动排列扑克牌相同。你先挑出第一张牌，然后就这样。接着挑出第二张牌，将其放在前一张牌的左侧或右侧。然后挑出第三张牌，将其放在前两张牌的左侧、中间或右侧。每一张新牌都会随机地放置在之前的牌之间。
- en: 'Here’s the code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For a simple implementation ❶, you can use an array for the generated shuffle.
    First loop n times starting at 0 ❷, and each time you generate a random position
    ❸ where you insert the new number among the previous ones ❹ by using the very
    handy .splice(...) method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的实现❶，你可以使用一个数组来存储生成的洗牌。首先从0开始循环n次❷，每次生成一个随机位置❸，将新数字插入到前面的数字中❹，可以使用非常方便的.splice(...)方法。
- en: But how do you get from this permutation to a shuffle of the original array?
    [Figure 8-4](chapter8.xhtml#fig8-4) shows how to use the previous result to finish
    the task.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何从这个排列得到原始数组的洗牌呢？[图8-4](chapter8.xhtml#fig8-4)展示了如何使用之前的结果完成任务。
- en: '![](../images/Figure8-4.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-4.jpg)'
- en: 'Figure 8-4: A random permutation of numbers is used to shuffle an array.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4：使用随机排列的数字来洗牌数组。
- en: 'Each element of the original array gets moved to a different place, according
    to the corresponding value that floydShuffleN(...) produces. Implementing the
    moves requires an extra array. Having generated a shuffled list of numbers from
    0 to *n* – 1, here’s the code to finish shuffling:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数组中的每个元素都根据floydShuffleN(...)生成的相应值移动到不同的位置。实现这些移动需要一个额外的数组。生成从0到*n* – 1的洗牌数字列表后，以下是完成洗牌的代码：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First generate a sample of numbers the same size as the portion of the array
    that you want to shuffle ❶, and then take the values in the input array ❷ and
    replace them according to the method ❸ shown in [Figure 8-3](chapter8.xhtml#fig8-3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先生成一个与你想要洗牌的数组部分相同大小的数字样本❶，然后取输入数组中的值❷，并根据[图8-3](chapter8.xhtml#fig8-3)所示的方法❸进行替换。
- en: How the code performs depends on what data structure you choose for the sample.
    Using an array as shown here means that insertion .splice(...) is *O*(*n*), so
    the whole algorithm becomes *O*(*n*²). You’ll see appropriate data structures
    in future chapters, but Floyd suggests using a hash table of size 2*n*, with entries
    forming a linked list, for an expected average O(*n*) performance, or a balanced
    ordered tree with linked nodes, for O(*n* log *n*) assured performance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的执行效果取决于你为样本选择的数据结构。如这里所示，使用数组意味着插入操作 .splice(...) 的时间复杂度是 *O*(*n*)，因此整个算法的时间复杂度变为
    *O*(*n*²)。你将在未来的章节中看到适合的数据结构，但 Floyd 建议使用大小为 2*n* 的哈希表，条目形成链表，以期望的平均 *O*(*n*)
    性能，或者使用平衡有序树和带链接节点的结构，以确保 *O*(*n* log *n*) 性能。
- en: Robson’s Algorithm
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Robson 算法
- en: Here’s a different take on how to generate a permutation. With an array of *n*
    elements, there are *n*! possible shuffling outcomes. The idea in Robson’s algorithm
    is to randomly select a number between 0 and *n*! – 1 inclusive and use that number
    to generate a permutation, so each different number produces a different shuffle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是生成排列的另一种方法。对于一个包含 *n* 元素的数组，有 *n*! 种可能的洗牌结果。Robson 算法的思路是随机选择一个在 0 和 *n*!
    – 1 之间的数字（包括0和*n*!），然后利用该数字生成一个排列，这样每个不同的数字都会产生不同的洗牌结果。
- en: NOTE
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*This method is related to a mathematical concept called the Lehmer code, which
    is a way to encode each possible permutation of n numbers, but we won’t go into
    that here.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种方法与一个叫做 Lehmer 码的数学概念相关，它是一种编码 n 个数字所有可能排列的方式，但我们在这里不深入探讨。*'
- en: If you want to shuffle an array with four elements to produce a random permutation
    out of the 24 (= 4!) possible ones, you’d start with a random number between 0
    and 23 inclusive. Then divide that number by 4\. The quotient will be a number
    between 0 and 5, and the remainder will be between 0 and 3\. (An important detail
    is that all possible combinations of quotient and remainder are equally probable.
    Can you verify that?)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想洗牌一个包含四个元素的数组，以产生 24 (= 4!) 种可能的随机排列之一，你需要从 0 到 23 之间的随机数开始。然后将该数字除以 4。商会是
    0 到 5 之间的数字，而余数会在 0 到 3 之间。（一个重要的细节是，商和余数的所有可能组合具有相同的概率。你能验证这一点吗？）
- en: 'Use the remainder to choose one of the four elements in the array, set it aside,
    and keep working with the other three. Consider the quotient: it’s a random value
    between 0 and 5.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用余数选择数组中的四个元素之一，将其取出并继续操作其余三个元素。考虑商：它是一个在 0 到 5 之间的随机值。
- en: This time, divide by 3\. The new quotient will be 0 or 1, and the remainder
    will be 0, 1, or 2, which you can use to choose one of the three remaining numbers.
    Consider the quotient, which is either 0 or 1\. If you divide the quotient you
    had by 2, you’ll get a quotient of 0 (no more work to be done). You can use the
    remainder (0 or 1) to choose one of the two remaining numbers, and you’ll have
    your desired shuffle. (After you’ve chosen 3 out of 4, the complete shuffle is
    implied.) [Figure 8-5](chapter8.xhtml#fig8-5) shows the algorithm if you had drawn
    14 as the random number.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，除以 3。新的商会是 0 或 1，余数会是 0、1 或 2，你可以使用余数来选择剩下的三个数字中的一个。考虑商，它是 0 或 1。如果你将商除以
    2，你将得到商为 0（不再需要做更多操作）。你可以使用余数（0 或 1）来选择剩下的两个数字之一，这样你就得到了你想要的洗牌结果。（当你从四个元素中选择了三个后，完整的洗牌结果就已经隐含在其中了。）[图
    8-5](chapter8.xhtml#fig8-5) 显示了如果你选择了 14 作为随机数，算法的样子。
- en: '![](../images/Figure8-5.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-5.jpg)'
- en: 'Figure 8-5: Robson’s shuffling algorithm is also based on transforming the
    original array depending on a randomly chosen permutation.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5：Robson 的洗牌算法也基于根据随机选择的排列转换原始数组。
- en: Start with values ABCD in the four positions of the array, from 0 to 3\. In
    the first step, divide 14 by 4, getting a quotient of 3 and a remainder of 2\.
    Then swap the element in position 2 of the array with the last, getting ABDC.
    The second step divides 3 (the previous quotient) by 3, producing quotient 1 and
    remainder 0\. Then swap the element in position 0 with the next-to-last element,
    resulting in DBAC. Then, divide 1 (the latest quotient) by 2, which gives quotient
    0 and remainder 1\. You don’t need to swap, because you’d swap the element at
    position 1 with itself, and you’d still have DBAC. After having shuffled three
    of the elements of the array, the fourth is also in place, and you’re done.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组中的四个位置 ABCD 开始，位置从 0 到 3。在第一步，将 14 除以 4，得到商 3 和余数 2。然后交换数组中位置 2 的元素与最后一个元素，得到
    ABDC。第二步，将 3（上一步的商）除以 3，得到商 1 和余数 0。然后交换位置 0 和倒数第二个位置的元素，结果为 DBAC。接着，将 1（最新的商）除以
    2，得到商 0 和余数 1。你不需要交换，因为你会将位置 1 的元素与自身交换，结果仍然是 DBAC。经过三次交换，数组中的三个元素已被洗牌，第四个元素也就自然就位，过程完成。
- en: 'Here’s the logic:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是逻辑：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The number of elements to shuffle is n ❶. You generate a random number ❷ between
    0 and *n*! – 1 using the factorial function developed in [Chapter 5](chapter5.xhtml).
    You then loop through the array from right to left ❸: calculate q ❹, use it to
    swap elements ❺, and find r to loop again ❻.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 需要洗牌的元素数量是 n ❶。你使用 [第 5 章](chapter5.xhtml) 中开发的阶乘函数生成一个在 0 到 *n*! – 1 之间的随机数
    ❷。然后从右到左循环遍历数组 ❸：计算 q ❹，用它交换元素 ❺，并找到 r 来再次循环 ❻。
- en: The algorithm is obviously *O*(*n*), as it follows from its single loop. However,
    as is, the algorithm has a problem. You wouldn’t be able to use it for large arrays,
    because calculating a factorial may exceed the available precision of JavaScript
    (see question 8.5). Fortunately, there’s a way out.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法显然是 *O*(*n*)，因为它遵循一个单一的循环。然而，按原样，算法存在问题。你不能用于较大的数组，因为计算阶乘可能超出了 JavaScript
    的可用精度（见第 8.5 问题）。幸运的是，还是有解决办法的。
- en: The Fisher-Yates Algorithm
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Fisher-Yates 算法
- en: The problem with Robson’s algorithm is the need to calculate *n*! to get a random
    number with which to proceed. But if you consider it carefully, you don’t really
    need the factorial. The key to that algorithm was the series of remainders, and
    you can generate those by using a random function. The first remainder was in
    the range 0 to *n* – 1, and it was used to choose the initial value of the permutation;
    the second remainder was in the range 0 to *n* – 2, and it was used to choose
    the second value of the permutation, and so on. It follows that you just need
    to generate random values at proper times in Robson’s algorithm, and that’s the
    Fisher-Yates algorithm.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Robson 算法的问题在于需要计算 *n*! 来获得一个随机数以继续。但如果仔细考虑，你实际上并不需要阶乘。该算法的关键在于一系列的余数，你可以通过使用随机函数来生成这些余数。第一个余数在
    0 到 *n* – 1 之间，用来选择排列的初始值；第二个余数在 0 到 *n* – 2 之间，用来选择排列的第二个值，依此类推。因此，你只需要在 Robson
    算法的合适时刻生成随机值，这就是 Fisher-Yates 算法。
- en: 'Thus, you can write this alternative to Robson’s code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以编写这个替代方案来替代 Robson 的代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As in Robson’s shuffle, loop from right to left ❶, and at each pass calculate
    a random number ❷ that you use to decide what elements to swap ❸. Basically, any
    element in positions from to i could be chosen for the swap.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Robson 的洗牌方法一样，从右到左循环 ❶，每次迭代计算一个随机数 ❷，用来决定交换哪些元素 ❸。基本上，从位置到 i 之间的任何元素都可以选择进行交换。
- en: 'The Fisher-Yates algorithm is frequently written to shuffle from left to right,
    which is basically the same idea:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Fisher-Yates 算法通常被写成从左到右洗牌，基本上是同样的思路：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code is the same ❶ except that the generated permutation starts from left
    to right, and any element in positions i to to ❷ may be chosen for swapping ❸.
    This algorithm is quite efficient, and it’s often used for shuffling. Be careful,
    though, because it’s easy to mess up; see question 8.4.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是相同的 ❶，只是生成的排列从左到右开始，任何位置从 i 到 ❷ 的元素都可以选择交换 ❸。这个算法非常高效，常用于洗牌。不过要小心，因为它很容易出错；见第
    8.4 问题。
- en: Sampling
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 采样
- en: 'Sampling is a technique frequently used in statistics. Basically, out of a
    set of values (an array), you want to pick a random, smaller set, which is called
    a *sample*. There are two kinds of sampling procedures: sampling with repetition,
    in which elements may be chosen more than once, and sampling without repetition,
    in which no element may be chosen two times or more. In mathematical terms, the
    latter procedure is called selecting a *combination* of elements. (In the first
    case, sampling with repetition, the number of chosen elements can be anything.
    In the second case, the number is limited by the number of elements in the original
    set.) Don’t worry about the order in which the elements are selected.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 抽样是统计学中经常使用的技术。基本上，从一组值（一个数组）中，你想选择一个随机的较小集合，这个较小的集合称为*样本*。抽样过程有两种：带重复抽样，允许元素被选中多次；和不带重复抽样，元素不能被选择超过一次。用数学术语来说，后一种过程叫做选择一个*组合*的元素。（在第一种情况下，即带重复的抽样，选择的元素数量可以是任何数字；而在第二种情况下，数量则受原始集合中元素数量的限制。）不用担心选择元素的顺序。
- en: We’ll first consider sampling with repetition, for which we just need a couple
    of short, optimally efficient algorithms, and then we’ll dedicate most of the
    rest of the chapter to sampling without repetition, which requires more complex
    logic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先考虑带重复的抽样，对于这种方法，我们只需要几个简短、最优高效的算法，然后将大部分章节的内容用于没有重复的抽样，这需要更复杂的逻辑。
- en: Sampling with Repetition
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带重复的抽样
- en: Sampling with repetition is a simple algorithm, and you’ll start by selecting
    just a single value. Choosing a larger sample will simply be a matter of choosing
    a value over and over again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 带重复的抽样是一个简单的算法，你将从选择一个单一值开始。选择更大的样本只需要反复选择值即可。
- en: Choosing Only One Value
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择单个值
- en: 'Choosing a single value is the simplest kind of sampling, and all you need
    is a random number in the appropriate range. You can use the randomInt(...) function,
    and for an element of an array, the following works:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 选择单个值是最简单的抽样方式，你只需要一个位于合适范围内的随机数。你可以使用randomInt(...)函数，若要从数组中选择一个元素，以下代码可以实现：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To select an element between the from and to positions (both included), you
    produce a random number in that range and return the corresponding element.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择一个位于从位置到到位置（包括两者）的元素，你生成该范围内的随机数并返回对应的元素。
- en: 'Of course, if you always want to choose values from the whole array (as you’ll
    do in the rest of the chapter), simpler code does the job:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你总是希望从整个数组中选择值（就像在本章的其余部分一样），更简单的代码就可以完成任务：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is equivalent to setting from = 0 and to = arr.length - 1, so this new
    function works in the same way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于将from = 0 和 to = arr.length - 1，因此这个新函数的工作方式与之相同。
- en: Choosing Several Values with Repetition
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择多个值（带重复）
- en: 'As mentioned, to make multiple selections from a set (maybe to simulate a series
    of roulette wheel turns, or create a strategy for a game of rock/paper/scissors,
    or implement the lazy select median-finding algorithm from [Chapter 7](chapter7.xhtml)),
    doing several single selections is enough:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，要从一组数据中进行多次选择（也许是模拟一系列轮盘赌转动，或者为剪刀石头布游戏创建策略，或者实现[第7章](chapter7.xhtml)中的懒选择中位数查找算法），做几次单次选择就足够了：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The logic is simple: first loop k times ❶, randomly choosing elements one by
    one ❷. Again, as with choosing a single value, to make selections from an entire
    array, the code is simpler, and you can reuse the singlePickAll code from the
    previous section as well:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑很简单：首先循环k次 ❶，每次随机选择一个元素 ❷。与选择单个值时一样，要从整个数组中进行选择，代码更简单，而且你还可以复用前一部分的singlePickAll代码：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For a related coding challenge, see question 8.7\. Next, take a look at sampling
    without repetition, which has the restrictions of not allowing you to choose any
    element more than once and doing so in an efficient way.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个相关的编程挑战，参见第 8.7 题。接下来，看看没有重复的抽样，它的限制是不允许你多次选择同一个元素，并且要高效地进行。
- en: Sampling Without Repetition
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不带重复的抽样
- en: 'This process is equivalent to what’s used in Powerball-style lottery drawings:
    numbers are removed from (but not returned to) an urn, guaranteeing that all selected
    numbers are different.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程等同于 Powerball 风格的彩票抽奖：数字从（但不返回到）一个抽签箱中被移除，保证所有被选中的数字都是不同的。
- en: For the algorithms in this section, assume you have an array with *n* elements,
    from which you want to pick a combination of *k* elements. It must be *k* < *n*—if
    *k* were equal to *n*, no algorithm would be needed, and *k* cannot be greater
    than *n* if no repetitions are allowed. Algorithms will be faster the fewer elements
    that you want, so for a cheap optimization, you can assume that *k >*= *n*/2;
    indeed, if *k* ≥ *n*/2, instead of selecting *k* elements, you could select *n*
    – *k* ones and discard them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节中的算法，假设你有一个包含*n*个元素的数组，你希望从中挑选出*k*个元素的组合。*k*必须小于*n*——如果*k*等于*n*，则无需任何算法，而且如果不允许重复，*k*不能大于*n*。当你希望的元素越少时，算法会越快，因此为了便于优化，你可以假设*k*
    >= *n*/2；事实上，如果*k* ≥ *n*/2，实际上你可以选择*n* – *k*个元素并将其丢弃。
- en: Sampling by Sorting or Shuffling
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过排序或洗牌进行抽样
- en: The first idea is inspired by the “Shuffling by Sorting” section on page 139,
    plus the selection algorithm explored in [Chapter 7](chapter7.xhtml). You can
    assign random keys to all elements, sort them, and then get the elements with
    the lowest *k* keys. You’ve already considered all the necessary code to implement
    this method, so leave actual development to question 8.8.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个想法受到第139页“通过排序进行洗牌”部分的启发，并结合了在[第7章](chapter7.xhtml)中探讨的选择算法。你可以给所有元素分配随机键，将它们排序，然后获取具有最低*k*键的元素。你已经考虑了实现这种方法所需的所有代码，所以实际的开发留给问题8.8去解决。
- en: A second idea you could try is based on the fact that you already know how to
    generate a random permutation of a set. Given this, an obvious way to generate
    a sample could easily be to shuffle the set and then take its first *k* elements.
    That works, but you can get the desired sample with more efficient logic without
    having to shuffle (similar to what you found with selection algorithms, when you
    saw better ways of selecting that didn’t require a previous sort). You won’t see
    the code for this procedure either, as it’s derived from what you’ve already done.
    Let’s move on to new algorithms instead.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试的第二个想法是基于你已经知道如何生成一个集合的随机排列这一事实。鉴于此，生成样本的显而易见方法是洗牌该集合，然后取其前*k*个元素。这样也能实现，但你可以通过更高效的逻辑得到所需的样本，而不必进行洗牌（类似于你在选择算法中发现的，当你看到不需要先排序的更好的选择方法时）。你也不会看到这个过程的代码，因为它是从你已经做过的事情派生出来的。让我们转向新的算法。
- en: Floyd’s Algorithm
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 弗洛伊德算法
- en: Often you just need a sample of *k* integers between 0 (included) and *n* (excluded).
    Robert Floyd’s floydSampleKofN(...) algorithm produces an array with a combination
    of *k* such numbers, which is interesting in itself and will help you write a
    more general sampling algorithm. If you need a sample from the original array,
    you can use the selected numbers produced by floydSampleKofN() for that task,
    as in [Figure 8-6](chapter8.xhtml#fig8-6).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你只需要从0（包括）到*n*（不包括）之间的*k*个整数样本。罗伯特·弗洛伊德的floydSampleKofN(...)算法生成一个包含*k*个此类数字的数组，这本身就很有趣，并将帮助你编写一个更通用的抽样算法。如果你需要从原始数组中抽样，可以使用floydSampleKofN()生成的选定数字，如[图8-6](chapter8.xhtml#fig8-6)所示。
- en: '![](../images/Figure8-6.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-6.jpg)'
- en: 'Figure 8-6: A random selection of numbers from 0 to n – 1 produces a random
    sample.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6：从0到n – 1的随机数字选择生成一个随机样本。
- en: You can choose values from the original input array using the sample’s values
    as indices, as shown in [Figure 8-6](chapter8.xhtml#fig8-6). The input array is
    at the top, the sample produced by Floyd’s code is [5, 2, 3], and the final result
    is shaded in gray.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用样本的值作为索引，从原始输入数组中选择值，如[图8-6](chapter8.xhtml#fig8-6)所示。输入数组位于顶部，弗洛伊德代码生成的样本是[5,
    2, 3]，最终结果用灰色标出。
- en: 'Here’s the code that uses the (yet unseen) floydSampleKofN() function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用（尚未展示的）floydSampleKofN()函数的代码：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You generate a random combination of k values out of n ❶ and use those numbers
    as indices to get values from the original input array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你从*n*中生成一个*k*个值的随机组合❶，并使用这些数字作为索引，从原始输入数组中获取值。
- en: 'Let’s return to generating the combination and finally see floydSampleKofN().
    The recursive version is the following, and recursion helps you understand how
    and why the algorithm works:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到生成组合的部分，最后看看floydSampleKofN()。递归版本如下，递归帮助你理解算法的工作原理：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You want a combination of k distinct values between 0 and n - 1 inclusive ❶.
    If k is 0 ❷, you return an empty sample. Otherwise, you use recursion first to
    choose a combination of k - 1 values up to n - 2 ❸. Then decide what value to
    add to that sample ❹. At the end ❺, you return the created sample.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要选择一个包含从 0 到 n - 1（包括 n - 1）之间 k 个不同值的组合 ❶。如果 k 为 0 ❷，则返回一个空样本。否则，首先使用递归选择一个包含
    k - 1 个值的组合，范围是从 0 到 n - 2 ❸。然后决定要将哪个值添加到该样本中 ❹。最后 ❺，返回创建的样本。
- en: 'Now examine how to add a new value to the sample, working with getting a sample
    of three values out of eight, as in [Figure 8-6](chapter8.xhtml#fig8-6). Suppose
    you already have a sample of two values out of the set 0 to 6: should you add
    a 7 value to produce the sample of three values? A possibility (1/8) is that the
    random number j is exactly 7\. It can’t be in the previous sample, so it will
    be added.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来看看如何将一个新值添加到样本中，假设从 8 个值中抽取 3 个样本，如[图 8-6](chapter8.xhtml#fig8-6)所示。假设你已经从
    0 到 6 的集合中选择了两个值：如果你要加入 7，来生成一个包含 3 个值的样本，应该如何操作？有一种可能性（1/8）是随机数 j 正好为 7。它不在先前的样本中，因此将被添加进去。
- en: The other way to add 7 is if j was one of the two numbers already in the sample
    (2/8). Thus, the probability that 7 will end up included in the sample of 3 out
    of 8 is 1/8 + 2/8, which is exactly 3/8 as you needed. You can apply this argument
    systematically and find that each of the *n* values has a probability of *k/n*
    of being in the final sample, so the algorithm really produces a correct sample.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 7 的另一种方式是，如果 j 已经是样本中两个数字之一（2/8）。因此，7 最终被包含在 3 个值的样本中的概率是 1/8 + 2/8，恰好是 3/8，正是你需要的结果。你可以系统地应用这个论证，发现每个
    *n* 值有 *k/n* 的概率被包含在最终样本中，因此该算法确实生成了一个正确的样本。
- en: 'Since recursion always happens at the beginning of each pass, you can turn
    the code into an iterative equivalent version (see question 8.9):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于递归总是在每次循环开始时发生，你可以将代码转化为等效的迭代版本（见问题 8.9）：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, create an array to return the chosen sample ❶, and you’ll return this
    at the end ❺. A loop executes k times ❷. In each pass choose a random number ❸
    and use the same logic (checking whether the randomly selected number was already
    selected) to decide what to add ❹. The argument to prove that this algorithm works
    correctly is along the same lines as for the recursive version, so it won’t be
    repeated here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个数组来返回选择的样本 ❶，并在最后返回它 ❺。一个循环执行 k 次 ❷。每次循环中选择一个随机数 ❸，并使用相同的逻辑（检查随机选择的数字是否已经被选择过）来决定添加什么
    ❹。证明这个算法正确性的论证与递归版本相同，因此这里不再赘述。
- en: The key to performance for Floyd’s algorithm is how it adds a value to the sample
    and checks whether a given value is already in the sample. In other words, it
    needs an efficient implementation of a set. You also could use a bitmap as in
    [Chapters 6](chapter6.xhtml) and [7](chapter7.xhtml) (we’ll leave this for now
    and consider such options in [Chapter 13](chapter13.xhtml)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Floyd 算法的性能关键在于如何将一个值添加到样本中并检查给定值是否已经在样本中。换句话说，它需要一个高效的集合实现。你也可以使用位图，正如在[第 6
    章](chapter6.xhtml)和[第 7 章](chapter7.xhtml)中所提到的（我们暂时先不讨论这一点，稍后在[第 13 章](chapter13.xhtml)中会考虑这些选项）。
- en: Lottery Drawing
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 彩票抽奖
- en: Another method to consider implies actually replicating a lottery drawing. You
    choose a random element of the set, place it somewhere else, and do it again and
    again until you get the complete sample. [Figure 8-7](chapter8.xhtml#fig8-7) shows
    the process. The set of values is on the left, the selected sample is on the right,
    and the triangle marks the randomly chosen element at each stage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是考虑实际模拟一次彩票抽奖。你选择集合中的一个随机元素，将它放到其他地方，然后一次又一次地进行，直到得到完整的样本。[图 8-7](chapter8.xhtml#fig8-7)展示了这个过程。值的集合在左侧，选中的样本在右侧，三角形标记了每个阶段随机选择的元素。
- en: '![](../images/Figure8-7.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-7.jpg)'
- en: 'Figure 8-7: A simulated lottery drawing produces a random sample.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7：一个模拟的彩票抽奖生成一个随机样本。
- en: When you remove an element, you swap it with the one in the last place of the
    array to avoid having to shift the whole array, which would slow the code’s performance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移除一个元素时，你将它与数组最后一个位置的元素交换，以避免必须移动整个数组，这样可以提高代码的性能。
- en: 'Here’s a simple implementation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实现：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Start by creating the array that will get the sample ❶. Loop k times ❷, generating
    a random position ❸ among the first n - i elements of the array, because the already
    sampled elements will go to the end of the array ❹. The chosen element is added
    to the sample array, and it’s swapped so it won’t be considered again in other
    selections ❺. Finally, return the produced sample ❻.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个将获取样本的数组 ❶。循环 k 次 ❷，在数组的前 n - i 个元素中生成一个随机位置 ❸，因为已经选中的元素将移到数组的末尾 ❹。将选中的元素添加到样本数组，并进行交换，这样它就不会在其他选择中再次被考虑
    ❺。最后，返回生成的样本 ❻。
- en: This algorithm is simple enough, and it has *O*(*k*) performance that cannot
    be improved upon. After all, you want a sample with *k* elements. However, you
    can get a bit more speed if you notice that there’s no actual need for a separate
    sample array.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法足够简单，并且它的*O*(*k*)性能无法再改进。毕竟，你想要一个包含 *k* 个元素的样本。然而，如果你注意到其实不需要一个单独的样本数组，你可以稍微提高一些速度。
- en: Fisher-Yates Sampling
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Fisher-Yates 抽样
- en: In the previous lottery sampling algorithm, at any time each element of the
    array is either chosen or not, so you don’t need two arrays. The original one
    will do. [Figure 8-8](chapter8.xhtml#fig8-8) illustrates this idea; the shaded
    numbers are the chosen ones.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的抽奖抽样算法中，每次数组的每个元素要么被选中，要么不被选中，所以你不需要两个数组，原始数组就可以。[图 8-8](chapter8.xhtml#fig8-8)
    展示了这一思想；阴影部分的数字是被选中的元素。
- en: '![](../images/Figure8-8.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-8.jpg)'
- en: 'Figure 8-8: The lottery sampling algorithm can work in place, without extra
    memory.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8：抽奖抽样算法可以就地工作，无需额外的内存。
- en: 'Every time an element is chosen, move it to the front of the array, so all
    of its first elements are in the sample and the rest are the nonchosen ones. This
    algorithm is a variation of the Fisher-Yates shuffling method (the same logic
    but applied fewer times, because you don’t want to randomize the whole array;
    only k elements), and you can code it as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每次选择一个元素时，将其移动到数组的前面，这样它的所有前面元素都在样本中，其余的则是未选择的元素。这个算法是 Fisher-Yates 洗牌方法的一种变体（逻辑相同，但应用的次数较少，因为你不想随机化整个数组；只需要
    k 个元素），你可以按如下方式编写代码：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this algorithm, the i variable points to the corresponding sampled element.
    You loop k times ❶, choosing a random position among the yet-unchosen elements
    ❷, and you do a swap to change the selected element from the unchosen part to
    the chosen one ❸. After completing the loop ❹, return the initial slice (k elements
    long) of the original array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，i 变量指向对应的样本元素。你循环 k 次 ❶，从尚未被选择的元素中随机选择一个位置 ❷，然后进行交换，将选中的元素从未选择的部分移到已选择部分
    ❸。完成循环 ❹ 后，返回原数组的初始切片（长度为 k 的元素）。
- en: The Fisher-Yates sampling algorithm is also *O*(*k*); the only difference is
    where the sample is stored.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Fisher-Yates 抽样算法也是 *O*(*k*)；唯一的区别在于样本的存储位置。
- en: Knuth’s Algorithm
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Knuth 的算法
- en: Donald Knuth’s algorithm has the interesting characteristic that the values
    in the sample keep their relative order as in the original array. The algorithm
    is based on probabilities, which directly proves its correctness.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Donald Knuth 的算法有一个有趣的特点，即样本中的元素保持与原数组相同的相对顺序。该算法基于概率，直接证明了它的正确性。
- en: To understand how it works, suppose you want to choose three elements out of
    eight. The probability that the first element will be included is 3/8\. The probability
    that the second element will be chosen depends on whether the first element was
    chosen. If it was, the probability of choosing the second is 2/7 (because having
    selected one of the eight, now you choose two out of the remaining seven), but
    if skipped, the probability of choosing the second is 3/7 (because now you have
    to choose three elements out of the remaining seven).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解它是如何工作的，假设你想从八个元素中选择三个。第一个元素被选中的概率是 3/8。第二个元素是否被选中取决于第一个元素是否被选中。如果第一个被选中了，第二个被选中的概率是
    2/7（因为从八个中选中了一个，剩下七个中选择两个）；如果第一个没被选中，第二个被选中的概率是 3/7（因为现在需要从剩下的七个中选择三个）。
- en: 'The algorithm chooses or skips elements based on random numbers and probabilities,
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法基于随机数和概率选择或跳过元素，具体如下：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you want to choose an empty sample ❶, an empty array is returned; this is
    the base case for the recursion. Otherwise, you get a random number and compare
    it with the probability: if it’s smaller ❷, you include the first element of the
    array followed by a k – 1 sized sample of the rest. If it’s greater ❸, you select
    all k elements out of the rest of the array.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想选择一个空样本 ❶，将返回一个空数组；这是递归的基本情况。否则，你会得到一个随机数，并与概率进行比较：如果它较小 ❷，你将包含数组中的第一个元素，并从剩下的元素中选择一个大小为k
    – 1的样本。如果它较大 ❸，你从剩下的数组中选择所有k个元素。
- en: 'A better implementation avoids recursion and all the destructuring and slicing
    of arrays as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的实现方式避免了递归以及数组的拆解和切片，方法如下：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As in other algorithms, sample is the array that will be produced ❶. The variables
    toSelect ❷ and toConsider ❸ will keep count of how many values you still have
    to select out of the values not yet considered. You loop until there are no more
    values to choose ❹. Each time, you decide whether to choose or ignore a value,
    according to the probabilistic method described. If the test comes out true ❺,
    add the value to the sample array and decrease the count of pending values to
    select by 1\. Every pass through the loop, we decrease the number of values to
    yet consider ❻.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其他算法一样，sample是将要生成的数组 ❶。变量toSelect ❷和toConsider ❸将记录你还需要从未考虑的值中选择的数量。你将不断循环，直到没有更多的值可以选择
    ❹。每次，你根据描述的概率方法决定是否选择或忽略一个值。如果测试结果为真 ❺，则将该值添加到样本数组中，并将待选值的数量减去1。每次循环，我们都会减少待考虑值的数量
    ❻。
- en: 'You can also write it in a more compact way:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用更简洁的方式写出来：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The difference is that you’ll use k ❶ instead of a toSelect variable ❸, and
    you’ll calculate how many yet-unseen values there are ❷; otherwise, the algorithm
    is the same.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于你将使用k ❶代替a toSelect变量 ❸，并且你将计算仍然未见的值的数量 ❷；否则，算法是相同的。
- en: Reservoir Sampling
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 水库抽样
- en: The final algorithm we’ll consider was created by Alan Waterman, and it’s interesting
    because it can work in an online mode, without needing the whole array of elements
    beforehand. All the other algorithms in this chapter work in offline mode. The
    code goes through the input data, maintaining a suitable random sample at all
    times; it can be stopped at any moment and would have a proper random sample of
    the elements seen so far. This algorithm is quite suitable for large streams,
    where it might be impossible to store all values in memory and then apply one
    of the previous algorithms considered in this chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的最终算法是由Alan Waterman创建的，它的有趣之处在于它可以在在线模式下工作，无需事先获取整个元素数组。本章中所有其他算法都在离线模式下工作。该代码遍历输入数据，在任何时候都保持一个合适的随机样本；它可以随时停止，并且会有一个合适的随机样本，包含到目前为止看到的元素。这个算法非常适合处理大规模数据流，在这种情况下，可能无法将所有值存储在内存中，然后应用本章中考虑的任何一个先前算法。
- en: 'Consider a simple case first: choosing just one element out of a sequence of
    undetermined length. (If you knew the length of the sequence, using randomInt(...)
    would be the quickest way to pick an element.) The solution to this problem works
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑一个简单的情况：从一个未知长度的序列中选择一个元素。（如果你知道序列的长度，使用randomInt(...)将是选择一个元素的最快方式。）这个问题的解决方法如下：
- en: Choose the first element of the sequence and place it in a reservoir.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择序列中的第一个元素，并将其放入水库中。
- en: For the *i*th element in the sequence after the first, use it to replace the
    reservoir value with probability of 1/*i.*
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于序列中第*i*个元素（从第二个元素开始），以1/*i*的概率用它来替换水库中的值。
- en: Suppose the sequence had 1,000 elements. What’s the probability of choosing
    the very last element? Obviously, it’s 1/1,000\. If you didn’t choose it, when
    you have 999 elements, what’s the probability of choosing the 999th? It would
    be 1/999\. As more and more elements are processed, the probability of choosing
    the *i*th one is always 1/*i*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设序列有1000个元素。那么选择最后一个元素的概率是多少？显然，它是1/1000。如果你没有选择它，当你有999个元素时，选择第999个元素的概率是多少？它将是1/999。随着越来越多的元素被处理，选择第*i*个元素的概率始终是1/*i*。
- en: 'You can expand this example to choose a sample of *k* elements; the process
    is quite similar:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以扩展这个例子来选择*k*个元素的样本；过程非常相似：
- en: Choose the first *k* elements of the sequence and place them in a reservoir.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择序列中的前*k*个元素，并将它们放入水库中。
- en: For the *i*th element in the sequence after those *k*, add it to the reservoir
    value with a probability of *k*/*i* by replacing a randomly selected value of
    the reservoir.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于序列中第*i*个元素（在前*k*个元素之后），以*k*/*i*的概率将其添加到储存区值中，通过替换一个随机选择的储存区值。
- en: 'You can code this as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按以下方式编写代码：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We won’t work with a stream, but the changes for that are straightforward. Here,
    to know when the sequence is ended you’ll use variable n ❶, and the sample reservoir
    is initialized with the first k elements of the sequence ❷. You loop through the
    data ❸ and do a random test ❹ to see whether the number should go into the array;
    the j variable is used both for the test and to randomly decide what reservoir
    element to replace ❺.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用流，但对此进行修改是很直接的。在这里，要知道何时序列结束，你将使用变量n ❶，并且样本储存区初始化为序列的前k个元素 ❷。你将循环遍历数据
    ❸，并进行随机测试 ❹，以判断某个数字是否应该进入数组；变量j既用于测试，也用于随机决定替换储存区中的哪个元素 ❺。
- en: 'If you modify the input array (using its first *k* positions for the reservoir),
    the algorithm looks like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改输入数组（使用其前*k*个位置作为储存区），算法看起来是这样的：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The differences are how you swap a chosen value into the reservoir ❶ and how
    you return the chosen sample ❷; otherwise, it functions exactly the same way.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于你如何将选定的值交换到储存区 ❶ 和如何返回选定的样本 ❷；除此之外，其余功能完全相同。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter we’ve considered algorithms for generating randomized permutations
    and combinations of an array, methods that are quite useful for several areas
    like gaming or statistics, among others. In the next chapter, we’ll turn to another
    common and important task: searching efficiently for a value.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经考虑了生成数组的随机排列和组合的算法，这些方法在多个领域非常有用，如游戏或统计学等。在下一章中，我们将转向另一个常见且重要的任务：高效地搜索一个值。
- en: Questions
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: '**8.1  Good Enough Shuffling**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.1  足够好的洗牌**'
- en: Implement a logging function that takes a shuffling function as input and runs
    many tests, counting how often each possible permutation is produced, and then
    draw a histogram to visualize its results.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个日志记录函数，接受一个洗牌函数作为输入并运行多次测试，统计每种可能的排列出现的次数，然后绘制直方图以可视化其结果。
- en: '[Figure 8-9](chapter8.xhtml#fig8-9) shows the output from my own tests with
    good results for a shuffle of an array of four elements.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-9](chapter8.xhtml#fig8-9)显示了我自己测试的结果，显示四个元素的数组洗牌效果良好。'
- en: '![](../images/Figure8-9.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-9.jpg)'
- en: 'Figure 8-9: A histogram showing that a certain shuffling algorithm produces
    all possible outcomes with similar frequencies'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-9：一个直方图，显示某个洗牌算法以相似的频率生成所有可能的结果
- en: After 48,000 random tries, all permutations (24 = 4!) were generated, and the
    results seem similar enough. Although this assertion isn’t really valid in a statistical
    way; a χ² (that’s the Greek letter chi) goodness-of-fit test would be required
    for that.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在48,000次随机尝试后，所有排列（24 = 4!）都被生成出来，结果看起来足够相似。尽管这一说法从统计学角度并不完全有效；需要进行χ²（即希腊字母“chi”）拟合优度检验才能确认这一点。
- en: '**8.2  Random Roll**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.2  随机投掷**'
- en: 'Suppose you have to generate a uniform random triple option: instead of true/false,
    say high/medium/low. Using Math.random(), it’s easy to do, as seen in the randomNum(...)
    function, but can you do this using only randomBit()? Along the same lines, how
    can you generate a uniform die roll (1–6) using randomBit()? Or a 1 to 20 roll
    for a *Dungeons & Dragons* type of game? (This last question is trickier.)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要生成一个均匀的随机三选项：不是是/否，而是高/中/低。使用Math.random()很容易实现，如randomNum(...)函数所示，但你能仅使用randomBit()来做吗？类似地，你如何使用randomBit()生成一个均匀的骰子投掷（1-6）？或者在*龙与地下城*类型的游戏中进行1到20的投掷？（最后一个问题更复杂。）
- en: '**8.3  Not-So-Random Shuffling**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.3  不那么随机的洗牌**'
- en: 'After reading the description for random shuffling, a programmer decides to
    make it simpler: instead of bothering to assign random keys and sorting by them,
    the programmer took a sorting algorithm (bubble sort, in this case) and changed
    the comparisons among keys to use a random bit:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完随机洗牌的描述后，某个程序员决定让它更简单：不再麻烦地分配随机键并按键排序，而是直接使用排序算法（此处为冒泡排序），并将键之间的比较改为使用一个随机位：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The logic is that of bubble sort (see [Chapter 6](chapter6.xhtml)) but with
    a single change ❶. Why is this a bad shuffle generator? Where did the programmer
    go wrong?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑类似于冒泡排序（参见[第6章](chapter6.xhtml)），但有一个变化 ❶。为什么这不是一个好的洗牌生成器？程序员哪里出错了？
- en: '**8.4  Bad Swapping Shuffle**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.4  糟糕的交换洗牌**'
- en: 'A developer messed up when implementing the Fisher-Yates shuffling code and
    wrote the following, which seems good enough at first:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一位开发者在实现 Fisher-Yates 洗牌代码时出错，写出了如下代码，乍看之下似乎足够好：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The difference is in the line in bold. You always choose a random place from
    the complete array. What’s wrong with this code?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于加粗的那一行。你总是从完整的数组中选择一个随机位置。这个代码有什么问题？
- en: '**8.5  Robson’s Top?**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.5  罗布森的顶端？**'
- en: What’s the maximum length of array that you can shuffle using Robson’s algorithm?
    Be careful; the answer is tricky.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用罗布森算法，最大可以洗牌的数组长度是多少？小心，这个问题的答案有点复杂。
- en: '**8.6  Sampling Testing**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.6  采样测试**'
- en: Can you develop something to visually validate sampling functions, along the
    lines of what was required in question 8.1?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你能开发一个视觉验证采样函数的工具吗，类似于问题 8.1 中所要求的内容？
- en: '**8.7  Single-Line Repeater**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.7  单行重复器**'
- en: A reviewer of the draft for this chapter mentioned that repeatedPick(...), as
    shown in the “Choosing Several Values with Repetition” section on page 147, could
    be written as a single line, in just one statement. What would it be?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章草稿的审阅者提到，像第147页“带重复选择若干值”部分所展示的 repeatedPick(...)，可以写成一行，只需一个语句。那会是什么？
- en: '**8.8  Sort to Sample**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.8  排序采样**'
- en: Implement the algorithm described in the section “Sampling by Sorting or Shuffling”
    on page 148.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实现“通过排序或洗牌进行采样”部分在第148页中描述的算法。
- en: '**8.9  Iterate, Don’t Recurse**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.9  迭代，而非递归**'
- en: A recursive function along the lines of
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似于以下递归函数的代码：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'can be written equivalently in an iterative fashion as the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以等效地以迭代方式写成如下：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Explain why this works. Also, try this conversion for the factorial(...) function
    from [Chapter 5](chapter5.xhtml) and adapt it for Floyd’s sampleKofN(...) algorithm
    (which will be trickier) to verify what was shown in the text.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 解释一下为什么这个方法可行。还有，尝试将此转换应用到 [第5章](chapter5.xhtml) 的 factorial(...) 函数，并将其调整到
    Floyd 的 sampleKofN(...) 算法（这会更复杂），以验证文中所示内容。
- en: '**8.10  No Limits?**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.10  没有限制？**'
- en: In Knuth’s sample code, there’s no check to see whether i goes out of bounds;
    why isn’t it needed?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Knuth 的示例代码中，没有检查 i 是否超出边界；为什么不需要做这一步？
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
