- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: COMMUNICATIONS BREAKDOWN**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通信中断**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Computers don’t compute just for the thrill of it. They take in input from various
    sources, do their computations, and produce output for use by a huge range of
    devices. Computers might be communicating with people, talking to each other,
    or running factories. Let’s explore this a bit more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机并不是为了纯粹的娱乐而进行计算的。它们从各种来源接收输入，进行计算，然后输出结果供各种设备使用。计算机可能在与人沟通、相互交流，或者运行工厂。让我们进一步探讨一下。
- en: I briefly mentioned input and output (I/O) in “[Input and Output](ch04.xhtml#ch04lev1sec2)”
    on [page 96](ch04.xhtml#page_96), referring to getting things into and out of
    the processor core. Doing that isn’t all that difficult; all we need are some
    *latches* (see “[Latches](ch03.xhtml#ch03lev2sec3)” on [page 71](ch03.xhtml#page_71))
    for output and *tri-state buffers* (refer to [Figure 2-38](ch02.xhtml#ch02fig38))
    for input. It used to be that each and every aspect of an I/O device would be
    hooked up to some bit on a latch or buffer, and the computer would be the puppeteer
    responsible for the articulation of every limb.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 “[输入与输出](ch04.xhtml#ch04lev1sec2)” 中简要提到了输入和输出（I/O），指的是将数据传入和传出处理器核心。在这方面并不难；我们所需要的只是一些*锁存器*（参见
    “[锁存器](ch03.xhtml#ch03lev2sec3)” 在 [第71页](ch03.xhtml#page_71)）用于输出，以及*三态缓冲器*（参见
    [图2-38](ch02.xhtml#ch02fig38)）用于输入。过去，每个I/O设备的每个方面都要连接到锁存器或缓冲器的某个位，而计算机则是负责控制每个“肢体”的木偶操纵者。
- en: Processor cost reduction has changed that. Many formerly complex I/O devices
    now include their own microprocessors. For example, you can purchase a three-axis
    accelerometer or temperature sensor that provides a nice digital output for a
    few dollars. I won’t bother talking about devices like those because they’re not
    interesting from a programming standpoint—the interface is just reading and writing
    bytes as described in the device specification. But that doesn’t get you off the
    hook. You might work on the code for a device with an integrated processor. If
    you’re designing the next internet-connected hairbrush, you’ll likely bristle
    at its hairy control algorithm.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器成本的降低改变了这一点。许多以前复杂的I/O设备现在都包含了自己的微处理器。例如，你可以购买一个三轴加速度计或温度传感器，几美元就能得到一个不错的数字输出。我不会多谈这种设备，因为它们在编程角度上并不有趣——接口就是按照设备规格描述来读取和写入字节。但这并不意味着你可以完全置身事外。你可能会为一个集成处理器的设备编写代码。如果你正在设计一个下一个互联网连接的发刷，你可能会对它毛发般复杂的控制算法感到头疼。
- en: This chapter examines techniques for interacting with some of the I/O devices
    that are still interesting from a programming standpoint. It also covers *sampling*,
    because that’s how we convert real-world analog data into a digital form usable
    by computers and vice versa.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了与一些仍然在编程角度上有趣的I/O设备进行交互的技术。它还涵盖了*采样*，因为这是将现实世界的模拟数据转换为计算机可用的数字形式，反之亦然。
- en: '**Low-Level I/O**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**低级I/O**'
- en: The simplest forms of I/O involve connecting things to bits that can be read
    and written by the CPU. These forms began evolving into more complicated devices
    when they started getting used a lot. This section looks at a few examples.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的I/O形式涉及将设备连接到CPU可以读取和写入的位。当这些形式被广泛使用时，它们开始发展为更复杂的设备。本节将探讨几个例子。
- en: '***I/O Ports***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***I/O端口***'
- en: The easiest way to get a computer to talk to something is to hook it up to an
    I/O *port*. For example, Atmel makes the AVR family of small processors. They
    include a large number of built-in I/O devices. In [Figure 6-1](ch06.xhtml#ch06fig01),
    we’re hooking some things up to *port B*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让计算机与其他设备进行通信的最简单方法是将它连接到I/O*端口*。例如，Atmel生产AVR系列小型处理器，它们包括大量内建的I/O设备。在[图6-1](ch06.xhtml#ch06fig01)中，我们将一些设备连接到*B端口*。
- en: '![Image](../images/06fig01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig01.jpg)'
- en: '*Figure 6-1: Light and switch on port B*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：端口B上的灯光和开关*'
- en: 'You should recognize the switch in [Figure 6-1](ch06.xhtml#ch06fig01) from
    [Chapter 2](ch02.xhtml#ch02). The *LED* is a light-emitting diode. A *diode* is
    a semiconductor device that works like an amusement park turnstile: it lets electricity
    through only in one direction, indicated by the direction of the hollow arrow.
    LEDs have the nice side effect that they glow.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从[图6-1](ch06.xhtml#ch06fig01)中认出这个开关，它来自[第2章](ch02.xhtml#ch02)。*LED*是发光二极管。*二极管*是一种半导体设备，它像游乐园的旋转门一样，只允许电流朝一个方向流动，方向由空心箭头指示。LED有一个很好的副作用，就是它们会发光。
- en: Note the resistor in series with the LED. It’s there to limit the amount of
    current that flows through the LED so that neither it nor PB[0] burns up. You
    can calculate the resistor value using Ohm’s law, introduced in [Chapter 2](ch02.xhtml#ch02).
    Let’s say that *V* is 5 volts. One of the characteristics of the silicon sandwiches
    discussed in “[Transistors](ch02.xhtml#ch02lev2sec10)” on [page 51](ch02.xhtml#page_51)
    is that the voltage across one is 0.7 volts. The AVR processor’s datasheet says
    that the output voltage for a logic 1 when *V* is 5 volts is 4.2 volts. We want
    to limit the current to 10 mA (0.01 A) because that’s what the LED expects; the
    AVR is capable of 20 mA. Ohm’s law says that resistance is voltage divided by
    current, so (4.2 – 0.7) ÷ 0.01 = 350Ω. As you can see, PB[7] can be switched between
    the voltages for 0 and 1\. No electricity flows through PB[0] when it’s set to
    0\. Electricity flows through the LED when PB[0] is 1, making it glow. Make sure
    that you read the datasheet for any LED or other component that you use, because
    characteristics such as the voltage drop may be different.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与 LED 串联的电阻器。它的作用是限制通过 LED 的电流，以防止 LED 或 PB[0] 被烧坏。你可以使用欧姆定律来计算电阻值，欧姆定律在[第二章](ch02.xhtml#ch02)中介绍。假设*V*为
    5 伏特。正如在[第 51 页](ch02.xhtml#page_51)中提到的“[晶体管](ch02.xhtml#ch02lev2sec10)”一节，硅三明治的特点之一是其电压降为
    0.7 伏特。AVR 处理器的数据表指出，当*V*为 5 伏特时，逻辑 1 的输出电压为 4.2 伏特。我们希望将电流限制为 10 毫安（0.01 安），因为这是
    LED 所期望的；而 AVR 能承受的最大电流为 20 毫安。根据欧姆定律，电阻等于电压除以电流，因此（4.2 – 0.7）÷ 0.01 = 350Ω。正如你所见，PB[7]
    可以在 0 和 1 的电压之间切换。当 PB[0] 设置为 0 时，不会有电流流过；而当 PB[0] 设置为 1 时，电流流经 LED，使其发光。确保你阅读所有使用的
    LED 或其他组件的数据表，因为电压降等特性可能会有所不同。
- en: Port B is controlled by three registers, as shown in [Figure 6-2](ch06.xhtml#ch06fig02).
    *DDRB*, the data direction register, determines whether each pin is an input or
    an output. *PORTB* is a latch that holds the output data. *PINB* reads the values
    of the pins.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Port B 由三个寄存器控制，如[图 6-2](ch06.xhtml#ch06fig02)所示。*DDRB* 是数据方向寄存器，用于确定每个引脚是输入还是输出。*PORTB*
    是一个锁存器，用于保持输出数据。*PINB* 用于读取引脚的值。
- en: '![Image](../images/06fig02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig02.jpg)'
- en: '*Figure 6-2: AVR PORTB registers*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：AVR PORTB 寄存器*'
- en: 'This may appear really complicated, but as you can see in [Figure 6-3](ch06.xhtml#ch06fig03),
    it’s just another arrangement of our standard building blocks: demultiplexers,
    flip-flops, and tri-state buffers.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能很复杂，但正如你在[图 6-3](ch06.xhtml#ch06fig03)中看到的，它只是我们标准构建模块的另一种组合：解复用器、触发器和三态缓冲器。
- en: '![Image](../images/06fig03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig03.jpg)'
- en: '*Figure 6-3: AVR port B construction*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：AVR Port B 构造*'
- en: DDRB is the data direction register for port B. Putting a 1 in any bit turns
    the associated pin into an output; if set to 0, it’s an input. PORTB is the output
    part of the port. Writing a 0 or a 1 into any bit makes the associated output
    a low voltage or a high voltage. Reading PINB supplies the state of the associated
    pins, so if pins 6 and 0 are pulled high and the rest are pulled low, it’ll read
    01000001, or 0x41.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: DDRB 是 Port B 的数据方向寄存器。将任何位设置为 1 会将相关引脚设置为输出；如果设置为 0，则为输入。PORTB 是端口的输出部分。向任何位写入
    0 或 1 会将相关输出设置为低电压或高电压。读取 PINB 可提供相关引脚的状态，因此，如果引脚 6 和 0 被拉高，其余引脚被拉低，则读取值为 01000001，或
    0x41。
- en: As you can see, it’s pretty easy to get data in and out of the chip. You can
    read the switch by looking at PINB[7] in the PINB register. You can turn the LED
    on and off by writing to PORTB[0] in the PORTB register. You could write a simple
    program to blink the LED for the perpetual entertainment of yourself and all your
    friends.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，将数据输入和输出到芯片是相当简单的。你可以通过查看 PINB[7] 来读取开关的状态，该值存在于 PINB 寄存器中。你可以通过写入 PORTB[0]
    来控制 LED 的开关。你甚至可以编写一个简单的程序，让 LED 闪烁，以便你和你所有的朋友享受永久的娱乐。
- en: '***Push My Buttons***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***按我的按钮***'
- en: Lots of devices have buttons or switches of some sort. They’re not as easy for
    a computer to read as you might think because of the way they’re designed. A simple
    push button consists of a pair of electrical contacts and a piece of metal that
    connects them when the button is pressed. Take a look at the circuit in [Figure
    6-4](ch06.xhtml#ch06fig04).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 很多设备都有某种按钮或开关。它们并不像你想象的那样容易被计算机读取，这与它们的设计方式有关。一个简单的按钮由一对电接触和一块金属组成，当按钮被按下时，金属连接两者。请看看[图
    6-4](ch06.xhtml#ch06fig04)中的电路。
- en: '![Image](../images/06fig04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig04.jpg)'
- en: '*Figure 6-4: Simple push-button circuit*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：简单的按钮电路*'
- en: '*R* is what’s called a *pull-up* resistor, just like we saw earlier in [Figure
    2-37](ch02.xhtml#ch02fig37). When the button is not pushed, the resistor pulls
    the voltage on the processor *interrupt request (IRQ)* pin up to the voltage supplied
    by *V*, making it a logic 1\. When the button is pressed, the resistor limits
    the current from *V* so that it doesn’t burn up, allowing a logic 0 to be presented
    to IRQ.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*R* 是所谓的*上拉*电阻，就像我们之前在[图 2-37](ch02.xhtml#ch02fig37)中看到的那样。当按钮没有被按下时，电阻将处理器的*中断请求（IRQ）*引脚上的电压拉升至由*V*提供的电压，使其成为逻辑
    1。当按钮被按下时，电阻限制来自*V*的电流，防止烧坏，从而将逻辑 0呈现给 IRQ。'
- en: Seems simple, but [Figure 6-5](ch06.xhtml#ch06fig05) shows that it isn’t. You
    would think that when you pushed and released the button, the signal at IRQ would
    look like the picture on the left, but it actually looks more like the one on
    the right.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，但[图 6-5](ch06.xhtml#ch06fig05)显示事实并非如此。你可能认为，当你按下并释放按钮时，IRQ上的信号应该像左边的图那样，但实际上它更像右边的图。
- en: '![Image](../images/06fig05.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig05.jpg)'
- en: '*Figure 6-5: Button bounce*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：按钮弹跳*'
- en: What’s going on here? When the piece of metal connected to the button hits the
    contacts, it *bounces* and comes off the contacts for a short time. It might bounce
    several times before settling down. Since we connected the button to an interrupt-generating
    pin on the processor, we might get several interrupts from a single button push,
    which is probably not what we want. We need to *debounce* the button. (You can
    get bounce-free buttons, but they often cost more.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？当连接到按钮的金属片接触到触点时，它会*弹跳*并从触点上弹开一小段时间。它可能会弹跳几次才稳定下来。由于我们将按钮连接到了处理器的中断生成引脚，因此一次按钮按下可能会触发多个中断，这可能不是我们想要的。我们需要对按钮进行*去抖动*。（你可以购买无弹跳的按钮，但它们通常更贵。）
- en: 'A simple way to debounce is to have the interrupt handler set a timer, and
    then you test the state of the button after the timer expires, as [Figure 6-6](ch06.xhtml#ch06fig06)
    illustrates. We can approach this in two different ways: setting a timer on the
    first interrupt or replacing an existing timer with a new one on each interrupt.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的去抖动方法是让中断处理程序设置一个定时器，然后在定时器到期后测试按钮的状态，如[图 6-6](ch06.xhtml#ch06fig06)所示。我们可以通过两种不同的方式来实现：在第一次中断时设置定时器，或者在每次中断时用一个新的定时器替代现有的定时器。
- en: '![Image](../images/06fig06.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig06.jpg)'
- en: '*Figure 6-6: Button debounce timer*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：按钮去抖动定时器*'
- en: This approach works but isn’t necessarily the best one. It’s hard to choose
    a timer value because button bounce time can change over time due to mechanical
    wear. You’ve probably had a reviled alarm clock where the buttons were worn to
    the point that setting the time was difficult. Also, most devices have more than
    one button, and it’s unlikely that a processor has enough interrupt pins to go
    around. We could build circuitry to share interrupts, but we’d rather do it cheaply
    in software. Most systems have some sort of timer that can generate periodic interrupts.
    We can piggyback on that interrupt for button debouncing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效，但不一定是最佳的。选择定时器值很难，因为按钮的弹跳时间会随着时间的推移由于机械磨损而变化。你可能曾经遇到过令人讨厌的闹钟，按钮磨损到设置时间变得非常困难。而且，大多数设备有多个按钮，处理器不太可能有足够的中断引脚可用。我们可以设计电路共享中断，但我们更倾向于通过软件以较低成本实现。大多数系统都有某种定时器，可以生成周期性的中断。我们可以利用这个中断来进行按钮的去抖动。
- en: Let’s assume that we have eight buttons hooked up to some I/O port, such as
    we saw in [Figure 6-1](ch06.xhtml#ch06fig01), and that the state of the I/O port
    is available in a variable named `INB` that is an 8-bit `unsigned char`. We can
    construct a *finite impulse response (FIR)* filter out of an array, as shown in
    [Figure 6-7](ch06.xhtml#ch06fig07). A FIR is a queue; on each timer tick, we discard
    the oldest element and shift in a new one. We or the array elements together to
    form the `current` state as part of a two-element queue; `current` is moved to
    `previous` before we calculate the new `current`. All we have to do now is XOR
    the `current` and `previous` states to find out which buttons have changed state.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有八个按钮连接到某个 I/O 端口，就像我们在[图 6-1](ch06.xhtml#ch06fig01)中看到的那样，并且 I/O 端口的状态保存在一个名为`INB`的变量中，它是一个
    8 位的`unsigned char`。我们可以用一个数组构造一个*有限脉冲响应（FIR）*滤波器，如[图 6-7](ch06.xhtml#ch06fig07)所示。FIR
    是一个队列；每当定时器时钟滴答时，我们丢弃最旧的元素，并将一个新的元素移入队列。我们将数组元素做“或”运算，形成`current`状态作为双元素队列的一部分；在计算新的`current`之前，`current`会被移到`previous`。现在，我们只需要对`current`和`previous`状态做异或运算，以找出哪些按钮的状态发生了变化。
- en: '![Image](../images/06fig07.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig07.jpg)'
- en: '*Figure 6-7: FIR filter button debouncer*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：FIR滤波器按钮去抖动器*'
- en: It’s a pretty simple piece of code, as shown in the C programming language in
    [Listing 6-1](ch06.xhtml#ch06list01).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简单，如[C语言中的清单6-1](ch06.xhtml#ch06list01)所示。
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: FIR button debouncer*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-1：FIR按钮去抖动器*'
- en: '`FILTER_SIZE` is the number of elements in the filter, the choice of which
    depends on how noisy the buttons are and the timer interrupt rate.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`FILTER_SIZE`是滤波器中元素的数量，选择这个值时要考虑按钮的噪声大小和定时器中断的频率。'
- en: '***Let There Be Lights***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***让灯光亮起***'
- en: Many widgets have some sort of display. I’m not talking about things with computer
    screens here—more like alarm clocks and dishwashers. There are often several indicator
    lights and possibly some simple numeric displays.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 很多小部件都配有某种显示器。我指的不是计算机屏幕那类设备，而是像闹钟和洗碗机这种东西。通常会有几个指示灯，也许还会有一些简单的数字显示。
- en: A common type of simple indicator is the seven-segment display shown in [Figure
    6-8](ch06.xhtml#ch06fig08). These displays have seven LEDs arranged in a figure-8
    pattern plus maybe an additional decimal point.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的简单指示器是[图6-8](ch06.xhtml#ch06fig08)中显示的七段显示器。这些显示器有七个LED，按8字形排列，可能还包括一个额外的小数点。
- en: '![Image](../images/06fig08.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig08.jpg)'
- en: '*Figure 6-8: Seven-segment display*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：七段显示器*'
- en: The eight LEDs in a display require 16 electrical connections (pins). But that’s
    not how they’re typically constructed; there’s a pin for one end of each LED and
    a common connection for the other. Since we only need to control one end to turn
    an LED on or off, this common connection saves on pins, which reduces cost. [Figure
    6-8](ch06.xhtml#ch06fig08) shows a *common cathode* display in which the cathodes
    are all tied together and the anodes each have their own pins.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显示器中的八个LED需要16个电气连接（引脚）。但通常它们并不是这样构造的；每个LED有一个引脚连接在一端，另一端有一个公共连接。由于我们只需要控制一端来开关LED，因此这个公共连接节省了引脚，降低了成本。[图6-8](ch06.xhtml#ch06fig08)显示了一个*共阴极*显示器，其中所有阴极连接在一起，阳极则各自有单独的引脚。
- en: We could just hook up the anodes to output pins on a processor and the cathodes
    to the *ground* or negative end of the voltage source or *power supply*. A high
    (1) voltage on a pin would light up the corresponding LED. In practice, most processors
    don’t supply enough current for that to work, so an additional driver circuit
    is used. Open-collector outputs (shown back in [Figure 2-36](ch02.xhtml#ch02fig36))
    are often used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将阳极直接连接到处理器的输出引脚，将阴极连接到*地*或电源的负端，或者*电源*。如果引脚上有高电压（1），则相应的LED会亮起。实际上，大多数处理器提供的电流不足以直接驱动LED，所以需要额外的驱动电路。通常使用开漏输出（如[图2-36](ch02.xhtml#ch02fig36)中所示）。
- en: The software to drive one of these displays is pretty simple. All we need is
    a table that maps numbers (and maybe letters) to the appropriate segments to light.
    But it should come as no surprise that there are complications. We rarely have
    a single display; for example, an alarm clock has four. Though we could hook each
    display up to its own I/O port, it’s unlikely that there are that many ports.
    The solution is to *multiplex* the displays by connecting the anodes to port A
    and the cathodes to port B, as shown in [Figure 6-9](ch06.xhtml#ch06fig09).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动这些显示器的软件非常简单。我们只需要一个表格，将数字（或许还包括字母）映射到适当的段上来点亮它们。不过，事情并不总是这么简单，通常我们不会只有一个显示器。例如，一个闹钟就有四个显示器。虽然我们可以将每个显示器连接到自己的I/O端口，但这种端口数量通常不够。解决方法是通过连接阳极到端口A、阴极到端口B来对显示器进行*多路复用*，如[图6-9](ch06.xhtml#ch06fig09)所示。
- en: '![Image](../images/06fig09.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig09.jpg)'
- en: '*Figure 6-9: Multiplexed displays*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：多路复用显示器*'
- en: The display anodes are wired in parallel; all of the A segments are connected
    together, all of the B segments are connected together, and so on. The cathode
    connection for each display is connected to its own output pin. A display segment
    can light up only if its anode is a 1 and its cathode a 0\. You might wonder why,
    for example, segments A and B wouldn’t light up if A were a 1 and B were a 0\.
    Remember that the *D* in *LED* stands for *diode*, and diodes are one-way streets
    for electricity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 显示器的阳极是并联接线的；所有A段连接在一起，所有B段连接在一起，以此类推。每个显示器的阴极连接到它自己的输出引脚。只有当一个显示段的阳极为1且阴极为0时，该显示段才能点亮。你可能会好奇，例如，如果A为1而B为0，为什么A段和B段不会点亮？请记住，*LED*中的*D*代表*二极管*，二极管是电流的单向通道。
- en: We take advantage of the human *persistence of vision* to make the displays
    work. A display doesn’t have to be on all the time for us to perceive it as lit.
    Our eyes and brain will tell us that it’s lit if it’s on for as little as 1/24
    of a second. This is the same effect that makes movies and video work. All we
    have to do is switch which display is on by setting the associated cathode pin
    to 0 and the segment anodes to whatever we want to display. We can switch displays
    in a timer interrupt handler similar to the one we used in the earlier push-button
    example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用人眼的*视觉持久性*来让显示屏工作。显示屏并不需要一直亮着才能让我们感觉它在亮。我们的眼睛和大脑会告诉我们，当显示屏亮起时间短至1/24秒时，我们已经感知到它亮了。这和电影和视频的原理是一样的。我们所要做的，就是通过将相关的阴极引脚设置为0，并将段阳极设置为我们想要显示的内容来切换显示屏。我们可以像在之前的按键示例中那样，在定时器中断处理程序中切换显示屏。
- en: '***Lights, Action, . . .***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***灯光，行动，。。。***'
- en: It’s common for devices to include both buttons and displays. As it turns out,
    we can save some pins by multiplexing the buttons as well as the displays. Let’s
    say we have a 12-button telephone-style keypad in addition to our four displays,
    as shown in [Figure 6-10](ch06.xhtml#ch06fig10).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设备通常包括按钮和显示屏。事实证明，我们可以通过多路复用按钮和显示屏来节省一些引脚。假设除了四个显示屏外，我们还有一个12键电话式键盘，如[图6-10](ch06.xhtml#ch06fig10)所示。
- en: '![Image](../images/06fig10.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig10.jpg)'
- en: '*Figure 6-10: Multiplexed buttons and displays*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：多路复用按钮和显示屏*'
- en: What have we accomplished with all this complexity? We’ve only had to use three
    additional pins for the 12 push-buttons instead of 12\. All the push-buttons are
    pulled up to logic 1s by the pull-up resistors. Pushing a button has no effect
    if no displays are selected, because the B outputs are also all 1s. When the leftmost
    display is selected, B[0] is low, and pushing any button in the top row will cause
    the associated C input to go low, and so on. Since the display and push buttons
    are scanned with the same set of signals, the code that does the scanning can
    be combined in the timer interrupt handler.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过所有这些复杂性取得了什么成就？我们只需为12个按键额外使用三个引脚，而不是12个引脚。所有的按键都通过上拉电阻拉至逻辑1。当没有选择显示屏时，按下按钮不会有任何效果，因为B输出也是全为1。当选择最左边的显示屏时，B[0]为低，按下上排的任何按钮都会使相应的C输入变为低，依此类推。由于显示屏和按键是通过相同的信号集合进行扫描的，进行扫描的代码可以与定时器中断处理程序结合。
- en: Note that [Figure 6-10](ch06.xhtml#ch06fig10) is a simplified diagram. In practice,
    the B pins would need to be open-collector or *open-drain* (see “[Output Variations](ch02.xhtml#ch02lev2sec15)”
    on [page 58](ch02.xhtml#page_58)) devices; otherwise, if two buttons in different
    rows but the same columns were pushed, we’d be connecting a 1 to a 0, which might
    damage the parts. However, it’s not normally implemented that way, since the aforementioned
    display driver circuitry handles that for us.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[图6-10](ch06.xhtml#ch06fig10)是一个简化的图示。实际上，B引脚需要是开集电极或*开漏*（参见 “[输出变化](ch02.xhtml#ch02lev2sec15)”
    [第58页](ch02.xhtml#page_58)）设备；否则，如果按下了位于不同排但同一列的两个按钮，我们将把1和0连接在一起，这可能会损坏部件。不过，通常不会以这种方式实现，因为前面提到的显示驱动电路会为我们处理这个问题。
- en: You can find out whether some device is constructed in a manner similar to [Figure
    6-10](ch06.xhtml#ch06fig10) by pushing multiple buttons at the same time and watching
    the displays. The displays will look strange. Think about why.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过同时按下多个按钮并观察显示屏，来判断某个设备是否采用了类似于[图6-10](ch06.xhtml#ch06fig10)的结构。显示屏会显得很奇怪。思考一下为什么会这样。
- en: '***Bright Ideas***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***亮点创意***'
- en: Your alarm clock might have a brightness adjustment for the display. How does
    that work? By varying the *duty cycle* of the display, illustrated in [Figure
    6-11](ch06.xhtml#ch06fig11).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你的闹钟可能有显示屏亮度调节功能。那是如何工作的呢？通过调节显示屏的*占空比*，如[图6-11](ch06.xhtml#ch06fig11)所示。
- en: '![Image](../images/06fig11.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig11.jpg)'
- en: '*Figure 6-11: Duty cycle*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-11：占空比*'
- en: Each display is lit one-quarter of the time in the left part of [Figure 6-11](ch06.xhtml#ch06fig11).
    The right part shows each display lit only one-eighth of the time; no displays
    are lit half of the time. The result is that the displays on the right appear
    approximately half as bright as those on the left. The “brightness” is related
    to the average time that the display is on. Note that the relationship between
    duty cycle and perceived brightness is unlikely to be linear.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-11](ch06.xhtml#ch06fig11)的左侧部分，每个显示器每次亮起四分之一的时间。右侧部分则显示每个显示器每次亮起八分之一的时间；没有显示器每次亮起一半的时间。结果是，右侧的显示器看起来大约只有左侧的一半亮度。“亮度”与显示器开启的平均时间有关。请注意，占空比与感知亮度之间的关系可能并非线性。
- en: '***2^n Shades of Gray***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2^n种灰度***'
- en: A common sensor task is to determine the position of a rotating shaft—think
    motors, wheels, and knobs. We could determine the position by using switches on
    the shaft or by using black and white spots that could be read with a photosensor.
    Whatever approach we take, we’d encode each shaft position as a binary number.
    The encoder might look like [Figure 6-12](ch06.xhtml#ch06fig12) if we cared about
    eight different positions. If the white sectors are 0s and the black sectors are
    1s, then you can see how we can read the position value. The radial lines are
    not part of the encoder; they’re just there to make the diagram easier to understand.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的传感器任务是确定旋转轴的位置——比如电动机、车轮和旋钮。我们可以通过轴上的开关或通过黑白相间的点，利用光电传感器读取这些点，来确定位置。不管我们采用哪种方法，我们都会将每个轴的位置编码为一个二进制数。如果我们关心八个不同的位置，编码器可能像[图
    6-12](ch06.xhtml#ch06fig12)那样。如果白色区域是0，黑色区域是1，那么你就能理解如何读取位置值。径向线并不是编码器的一部分，它们只是为了让图示更易理解。
- en: '![Image](../images/06fig12.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig12.jpg)'
- en: '*Figure 6-12: Binary rotary encoder*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-12：二进制旋转编码器*'
- en: As usual, this seems simple, but it isn’t. In this case, the problem is mechanical
    tolerances. Note that even with a perfectly aligned encoder, we’d still have issues
    resulting from propagation delay differences in the circuitry reading each bit.
    What happens if the encoder isn’t perfectly aligned, as in [Figure 6-13](ch06.xhtml#ch06fig13)?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，这看起来很简单，但实际上并不如此。在这个例子中，问题出在机械公差上。即使编码器对准得非常完美，我们仍然会遇到由于电路在读取每一位时传播延迟差异而产生的问题。如果编码器没有完美对准，就像在[图
    6-13](ch06.xhtml#ch06fig13)中那样，会发生什么情况？
- en: '![Image](../images/06fig13.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig13.jpg)'
- en: '*Figure 6-13: Binary rotary encoder alignment error*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-13：二进制旋转编码器对准误差*'
- en: Rather than reading 01234567 as we’d expect, we get 201023645467\. American
    physicist Frank Gray (1887–1969) at Bell Telephone Laboratories took a look at
    this problem and came up with a different encoding in which only the value of
    a single bit changes for each position. For the 3-bit encoder we’ve been looking
    at, the eponymous *Gray code* is 000, 001, 011, 010, 110, 111, 101, 100\. The
    code can easily be translated to binary using a small table. [Figure 6-14](ch06.xhtml#ch06fig14)
    shows a Gray code version of our encoder wheel.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本来期望读取01234567，但实际上得到的是201023645467。美国物理学家弗兰克·格雷（Frank Gray，1887–1969）在贝尔电话实验室研究了这个问题，提出了一种不同的编码方式，其中每个位置只有一个位的值发生变化。对于我们正在查看的3位编码器，名字命名为*格雷码*，其顺序是000、001、011、010、110、111、101、100。这个编码可以通过一个小表格轻松转换为二进制。[图
    6-14](ch06.xhtml#ch06fig14)展示了我们编码器轮盘的格雷码版本。
- en: '![Image](../images/06fig14.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig14.jpg)'
- en: '*Figure 6-14: Gray code rotary encoder*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-14：格雷码旋转编码器*'
- en: '***Quadrature***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***正交编码***'
- en: There’s a twist on 2-bit Gray codes we can use when we don’t really need to
    know the absolute position of something, but need to know when the position changes
    and in which direction. Some of the knobs on your car dashboard, such as the volume
    control on the stereo, are likely to work this way. A good indicator is if turning
    a knob while the ignition is off has no effect once the car is started. The twist
    is called *quadrature encoding* because there are four states. The 2-bit Gray
    code pattern is repeated multiple times. For example, there are cheap quadrature
    encoders that are good to 1/4,096 of a revolution. Quadrature takes only two sensors,
    one for each bit. An absolute 4,096-position encoder would take 12 sensors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在不需要知道物体的绝对位置，而只需要知道位置何时变化以及变化方向时，我们可以使用2位格雷码的变体。你车上的一些旋钮，比如音响的音量控制，可能就采用这种方式。如果你在熄火时转动旋钮，启动后却没有任何效果，那是一个很好的指示。这个变体叫做*正交编码*，因为它有四个状态。2位格雷码模式会重复多次。例如，有些便宜的正交编码器可以精确到1/4,096转。正交编码只需要两个传感器，每个位一个。一个绝对位置为4,096的编码器需要12个传感器。
- en: The quadrature waveform is shown in [Figure 6-15](ch06.xhtml#ch06fig15).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正交波形如 [图 6-15](ch06.xhtml#ch06fig15) 所示。
- en: '![Image](../images/06fig15.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig15.jpg)'
- en: '*Figure 6-15: Quadrature waveform*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-15：正交波形*'
- en: As you can see, when the shaft is rotated clockwise, it produces the sequence
    0132; counterclockwise yields 2310\. We can form a 4-bit number out of the current
    position and the previous position. This number tells us the direction of rotation,
    as [Table 6-1](ch06.xhtml#ch06tab01) shows.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当轴顺时针旋转时，产生的序列为 0132；逆时针旋转则产生 2310。我们可以通过当前位置信息和前一位置组合形成一个 4 位数字，这个数字告诉我们旋转的方向，如
    [表 6-1](ch06.xhtml#ch06tab01) 所示。
- en: '**Table 6-1:** Quadrature Rotation Detection'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：正交旋转检测**'
- en: '| **Current** | **Previous** | **Combined** | **Meaning** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **当前** | **先前** | **组合** | **意义** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `00` | `00` | 0 | Illegal |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `00` | `00` | 0 | 非法 |'
- en: '| `00` | `01` | 1 | Clockwise |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `00` | `01` | 1 | 顺时针 |'
- en: '| `00` | `10` | 2 | Counterclockwise |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `00` | `10` | 2 | 逆时针 |'
- en: '| `00` | `11` | 3 | Illegal |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `00` | `11` | 3 | 非法 |'
- en: '| `01` | `00` | 4 | Counterclockwise |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `01` | `00` | 4 | 逆时针 |'
- en: '| `01` | `01` | 5 | Illegal |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `01` | `01` | 5 | 非法 |'
- en: '| `01` | `10` | 6 | Illegal |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `01` | `10` | 6 | 非法 |'
- en: '| `01` | `11` | 7 | Clockwise |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `01` | `11` | 7 | 顺时针 |'
- en: '| `10` | `00` | 8 | Clockwise |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `10` | `00` | 8 | 顺时针 |'
- en: '| `10` | `01` | 9 | Illegal |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `10` | `01` | 9 | 非法 |'
- en: '| `10` | `10` | a | Illegal |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `10` | `10` | a | 非法 |'
- en: '| `10` | `11` | b | Counterclockwise |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `10` | `11` | b | 逆时针 |'
- en: '| `11` | `00` | c | Illegal |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `11` | `00` | c | 非法 |'
- en: '| `11` | `01` | d | Counterclockwise |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `11` | `01` | d | 逆时针 |'
- en: '| `11` | `10` | e | Clockwise |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `11` | `10` | e | 顺时针 |'
- en: '| `11` | `11` | f | Illegal |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `11` | `11` | f | 非法 |'
- en: Note that this is a state machine, where the combined value is the state.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个状态机，其中组合值表示状态。
- en: What do you get when you take a pair of quadrature encoders, orient them at
    90 degrees from each other, and stick a rubber ball in the middle? A computer
    mouse.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拿一对正交编码器，将它们相互旋转 90 度，并在中间放入一个橡胶球时，结果是什么？一只计算机鼠标。
- en: '***Parallel Communication***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***并行通信***'
- en: Parallel communication is an extension of what we saw earlier when lighting
    up LEDs. We could hook up eight LEDs to port B and flash ASCII character codes.
    *Parallel* means we have a wire for each component and can control them all at
    the same time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 并行通信是我们之前在点亮 LED 时看到的功能的扩展。我们可以将八个 LED 连接到 B 端口，闪烁 ASCII 字符编码。*并行* 意味着我们为每个组件都有一根电缆，并可以同时控制它们。
- en: You may have an IEEE 1284 *parallel port* on your computer if it’s an old model.
    These were commonly used for printers and scanners before *Universal Serial Bus
    (USB)* came along. And yes, there were eight data lines on the parallel port so
    you could send ASCII character codes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电脑是旧款，可能配有 IEEE 1284 *并行端口*。在 *通用串行总线（USB）* 出现之前，这些端口通常用于打印机和扫描仪。没错，并行端口上有八条数据线，这样你就可以发送
    ASCII 字符编码。
- en: 'There’s a problem with all of this, though: how do you know when the data is
    valid? Let’s say you send the characters *ABC*. How do you know when it’s the
    next character? You can’t just look for some change, because it could be *AABC*.
    One way is to have another “look at me” signal. IEEE 1284 had a *strobe* signal
    for this purpose. In [Figure 6-16](ch06.xhtml#ch06fig16), the data on bits 0 through
    7 is valid whenever the strobe is low or 0.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一切存在一个问题：你如何知道数据是否有效？假设你发送字符 *ABC*。你怎么知道它什么时候是下一个字符？你不能仅仅通过变化来判断，因为可能是 *AABC*。一种方法是使用另一个“看着我”的信号。IEEE
    1284 就有一个 *触发* 信号用于此目的。在 [图 6-16](ch06.xhtml#ch06fig16) 中，当触发信号为低或 0 时，位 0 到 7
    上的数据是有效的。
- en: '![Image](../images/06fig16.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig16.jpg)'
- en: '*Figure 6-16: Parallel data strobe timing*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-16：并行数据触发时序*'
- en: Another parallel interface that has pretty much gone by the wayside is *IDE*.
    This is what’s used to communicate with older disk drives.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个已经基本被淘汰的并行接口是 *IDE*。它用于与较旧的磁盘驱动器进行通信。
- en: Parallel interfaces are expensive because they require many I/O pins, connector
    pins, and wires. The parallel port had a 25-pin connector and a big fat cable.
    IDE had 40 wires. There’s a limit to how fast a signal can be sent down a wire,
    and when that’s exceeded, multiple wires are needed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 并行接口成本较高，因为它们需要许多 I/O 引脚、连接器引脚和电缆。并行端口有一个 25 针连接器和一条粗大的电缆。IDE 有 40 根电缆。信号传输的速度是有限的，超过这个速度时，就需要多条电缆。
- en: '***Serial Communication***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***串行通信***'
- en: It would be nice to be able to communicate using fewer wires because wires cost
    money, which adds up, especially when you’re talking about long distances. Two
    wires is the minimum number required because we need a return signal path for
    the electricity, as you learned in [Chapter 2](ch02.xhtml#ch02). We’re not going
    to show that return path in the diagrams for simplicity.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用更少的电缆进行通信会很不错，因为电缆是需要花费金钱的，尤其是在长距离通信时，成本更高。两根电缆是最少需要的数量，因为我们需要一个电流的返回信号路径，正如你在[第二章](ch02.xhtml#ch02)中学到的那样。为了简便起见，我们在图示中不会展示这个返回路径。
- en: How could we send the eight signals over a single wire? We can get a hint by
    looking at the timing diagram in [Figure 6-16](ch06.xhtml#ch06fig16). Even though
    each bit is on its own wire, the characters are spaced out in time. We can space
    out the bits in time too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何通过一根电缆传送八个信号呢？我们可以通过查看[图6-16](ch06.xhtml#ch06fig16)中的时序图来获得一些线索。即使每个比特都有自己的电缆，字符之间仍然是按时间间隔排列的。我们也可以按时间间隔发送这些比特。
- en: I talked about shift registers in “[Shiftiness](ch04.xhtml#ch04lev2sec2)” on
    [page 99](ch04.xhtml#page_99). On the transmitting end, the strobe or *clock*
    signal shifts all the bits over one position and sends the bit that falls off
    the end out on the wire. On the receiving end, the clock shifts all the bits over
    by one position and puts the state of the data line into the newly vacated position,
    as shown in [Figure 6-17](ch06.xhtml#ch06fig17).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我在“[Shiftiness](ch04.xhtml#ch04lev2sec2)”一文中讲到过移位寄存器，在[第99页](ch04.xhtml#page_99)中有详细介绍。在发送端，时钟信号将所有位向右移动一位，并将溢出端的位发送到线路上。在接收端，时钟信号将所有位向右移动一位，并将数据线的状态放入新的空位中，如[图6-17](ch06.xhtml#ch06fig17)所示。
- en: '![Image](../images/06fig17.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig17.jpg)'
- en: '*Figure 6-17: Serial communications using shift registers*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-17：使用移位寄存器的串行通信*'
- en: We’d use a counter to tell us whenever we get to 8 bits, and then we could do
    something with the value. This approach takes two wires, not one, and it’s pretty
    error-prone. It requires that the transmitter and receiver be synchronized, or
    *in sync*—which has nothing to do with the boy band. All we’d have to do is miss
    one clock, and everything would be garbled. We could add a third wire that said
    when we were starting a new character, but our goal is to minimize the number
    of wires.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会使用一个计数器来告诉我们何时到达8位，然后我们就可以处理这个值。这个方法需要两根电缆，而不是一根，并且容易出错。它要求发送端和接收端必须同步，或称*同步*——这与男孩乐队无关。只要错过一个时钟信号，所有信息就会乱掉。我们可以增加第三根电缆，表示我们何时开始传送一个新的字符，但我们的目标是尽量减少电缆数量。
- en: A long time ago (in the early 1900s), the telegraph was married to the typewriter
    to make the *teletype*, a machine that allowed typing to a printer far away. Teletype
    machines were initially used to allow stock market information to be sent over
    telegraph wires.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前（20世纪初），电报与打字机结合，形成了*电传打字机*，这是一种能够将打字内容传送到远距离打印机的设备。电传打字机最初被用于通过电报线路发送股市信息。
- en: The data was sent using a serial *protocol* (set of rules) that worked using
    just one wire in addition to the return path. The clever thing about this protocol
    is that it worked sort of like the timers at a swim meet. Everybody starts their
    individual timers when the starting gun goes off, and they’re close enough that
    it works. [Figure 6-18](ch06.xhtml#ch06fig18) illustrates the protocol.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是通过一种串行*协议*（一套规则）发送的，它仅使用一根电缆，外加返回路径。这种协议的巧妙之处在于，它的工作方式类似于游泳比赛中的计时器。每个人在起跑枪响时启动自己的计时器，并且它们足够接近，所以能够正常工作。[图6-18](ch06.xhtml#ch06fig18)展示了这一协议。
- en: '![Image](../images/06fig18.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig18.jpg)'
- en: '*Figure 6-18: Mark-space signaling*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-18：标志-空白信号*'
- en: The line here is in a 1, or *high*, state when nothing is happening. The high
    state is called *mark*, and the low state is called *space*, after the way early
    telegraph equipment either made a mark or left a space on a strip of paper. The
    line going low in [Figure 6-18](ch06.xhtml#ch06fig18) is the starting gun, and
    it’s called the *start bit*. Following the start bit, the 8 bits of data are sent.
    The character ends with a pair of high *stop bits*. Each bit is allotted the same
    amount of time. Synchronization errors can occur, but all the transmitter has
    to do is to be quiet for a *character time* and the receiver will sync up. We’re
    dividing up time so that we have a slot for each bit and then multiplexing the
    data onto the single wire. This technique, called *time division multiplexing*,
    can be implemented using a selector (see “[Building Selectors](ch02.xhtml#ch02lev2sec19)”
    on [page 65](ch02.xhtml#page_65)) instead of a shift register. The speed in bits
    per second, by the way, is known as the *Baud rate*, named after French engineer
    Émile Baudot (1845–1903).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当没有任何事情发生时，线路处于1或*高*电平状态。高电平状态叫做*标记*，低电平状态叫做*空格*，这个名称源自早期电报设备，它们通过在纸带上留下标记或空白来表示信息。[图6-18](ch06.xhtml#ch06fig18)中，线路降到低电平就是启动信号，它被称为*起始位*。在起始位之后，发送8个数据位。字符以一对高电平的*停止位*结束。每个位都分配了相同的时间。可能会发生同步错误，但发射端只需保持静默一个*字符时间*，接收端就会重新同步。我们在划分时间，使每个位都有一个时间槽，然后将数据复用到单根线上。这种技术叫做*时分复用*，它可以使用选择器（参见[“构建选择器”](ch02.xhtml#ch02lev2sec19)第[65页](ch02.xhtml#page_65)）而非移位寄存器来实现。顺便提一下，位每秒的传输速率被称为*波特率*，以法国工程师埃米尔·波多（Émile
    Baudot，1845–1903）的名字命名。
- en: Teletypes were awesome machines. They didn’t contain any electronics and worked
    by having a motor spin a shaft. An electromagnet released the shaft when a start
    bit came in so it could spin. At each place in the rotation for the bit position,
    all sorts of cams and levers and pushrods would move around, ultimately whacking
    a metal character onto an inked ribbon and then onto a piece of paper. You knew
    that a message was coming in when stuff started rattling off the shelves. The
    keyboard worked in a similar fashion. Pressing a key started a shaft spinning
    that would move an electrical contact, depending on which keys were pressed, to
    generate an ASCII code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 电传打字机是很棒的机器。它们不包含任何电子元件，通过一个马达转动轴来工作。当开始位到来时，一个电磁铁释放了轴，使其能够旋转。在旋转的每一个位置，所有的凸轮、杠杆和推杆会运动，最终将一个金属字符击打到有墨带的色带上，然后转印到纸上。当东西开始从架子上发出叮当声时，你就知道有信息正在传入。键盘的工作方式也类似。按下一个键会启动一个轴的旋转，这个旋转会根据按下的键位，移动一个电接点，生成一个ASCII码。
- en: Another cool trick, called a *half-duplex* connection, is where a transmitter
    and a receiver on each end share the same wire. Only one can talk at a time, or
    gibberish results. That’s why radio operators said things like “over.” You know
    all about half-duplex communications if you’ve ever used a walkie-talkie. A *collision*
    results when more than one transmitter is active at the same time, garbling the
    data. A *full-duplex* connection is when there are two wires, one going in each
    direction.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个酷的技巧叫做*半双工*连接，其中每端的发射器和接收器共享同一根电缆。每次只能一个设备传输，否则会出现乱码。这就是无线电操作员说“完毕”的原因。如果你曾经使用过对讲机，你一定了解半双工通信。当多个发射器同时处于工作状态时，会发生*冲突*，导致数据混乱。*全双工*连接则是当有两根电缆时，每根电缆分别传输不同方向的数据。
- en: All of the circuitry to implement this eventually became available in a single
    integrated circuit called a *UART*, which stands for *Universal Asynchronous Receiver-Transmitter*.
    Software can also implement a UART with an approach called *bit-banging*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一切的电路最终被集成到一个名为*UART*的集成电路中，*UART*代表的是*通用异步接收发送器*。软件也可以通过一种叫做*位碰撞*的方法来实现UART。
- en: A standard called RS-232 defined the voltage levels used for mark and space
    on old serial ports, as well as many additional control signals. It’s pretty much
    been replaced by USB now, although a variant called *RS-485*, which uses differential
    signaling (refer back to [Figure 2-32](ch02.xhtml#ch02fig32)) for greater noise
    immunity, is used in industrial environments. The parallel IDE interface to disks
    has been replaced by *SATA*, the serial equivalent. Electronics are now fast enough
    that we can do many things serially that we used to have to do in parallel. Also,
    wires remain expensive. The world is running low on copper extractable from the
    earth, which is what’s used for the conductor in wires. Recycling existing copper
    products is now a major source of copper. Chips are mostly silicon, which is found
    in sand and very abundant.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为RS-232的标准定义了旧串行端口上用于标记和空格的电压水平，以及许多附加的控制信号。它现在几乎已被USB替代，尽管一种叫做*RS-485*的变种（使用差分信号传输，参见[图
    2-32](ch02.xhtml#ch02fig32)，以增强抗干扰能力）在工业环境中仍在使用。并行的IDE硬盘接口已经被* SATA*，串行接口所取代。如今，电子设备的速度足够快，许多以前需要并行处理的任务现在可以串行处理。此外，电线仍然很贵。世界上从地球中提取的铜资源正在减少，而铜是电线中的导体材料。回收现有的铜产品现在成为了铜的主要来源。芯片大多数是硅制的，硅存在于沙子中，资源非常丰富。
- en: There are a number of serial interfaces designed for connecting peripherals
    up to small microcomputers. These include *SPI*, *I2C*, *TWI*, and *OneWire*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多串行接口用于将外设连接到小型微型计算机。这些接口包括*SPI*、*I2C*、*TWI* 和 *OneWire*。
- en: '***Catch a Wave***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***捕捉波浪***'
- en: There’s a big problem with mark-space signaling, which is that it’s not good
    for very long distances. It doesn’t work over telephone lines for reasons that
    are beyond the scope of this book. That was a big deal because once the telegraph
    was replaced by better technologies, the only remaining long-distance communication
    technologies were telephone and radio. This mark-space signaling problem is solved
    with the same trick that makes radio work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 标记-空格信号传输存在一个大问题，那就是它不适合用于长距离通信。它无法通过电话线传输，这个原因超出了本书的讨论范围。这是一个大问题，因为一旦电报被更好的技术所替代，唯一剩下的远程通信技术就是电话和无线电。这一标记-空格信号传输问题通过与无线电相同的技巧得以解决。
- en: The universe contains all kinds of different waves. There are waves in the ocean,
    sound waves, light waves, microwaves, and all sorts of stuff in between. The fundamental
    wave is a *sine wave*. All other wave shapes can be made from combinations of
    sine waves. You get a sine wave by plotting the height of a point on a circle
    versus the angle. It looks like [Figure 6-19](ch06.xhtml#ch06fig19).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 宇宙中包含各种不同的波。海洋中有波浪，声波，光波，微波，以及所有其他介于其中的东西。基本的波是*正弦波*。所有其他的波形都可以通过正弦波的组合来构造。你可以通过绘制圆上某一点的高度与角度的关系来得到正弦波。它看起来像[图
    6-19](ch06.xhtml#ch06fig19)。
- en: '![Image](../images/06fig19.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig19.jpg)'
- en: '*Figure 6-19: Sine wave*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-19：正弦波*'
- en: 'The height of the sine wave is the *amplitude*. The number of same-direction
    zero crossings per second is the *frequency*, measured in *Hertz*, after German
    physicist Heinrich Hertz (1857–1894). Hertz is abbreviated *Hz* and is synonymous
    with *cycles per second*. The distance between two same-direction zero crossings
    is the *wavelength*. They’re related as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦波的高度是*振幅*。每秒钟同向零交叉的次数是*频率*，单位为*赫兹*，以德国物理学家海因里希·赫兹（Heinrich Hertz，1857–1894）命名。赫兹的缩写是*Hz*，它与*每秒周期数*同义。两个同向零交叉之间的距离是*波长*。它们之间的关系如下：
- en: '![Image](../images/eq155-01.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/eq155-01.jpg)'
- en: In this equation, λ is the wavelength in meters, *f* is the frequency in Hertz,
    and *v* is the speed of the wave in the medium in which it’s traveling. That’s
    the speed of light for radio waves. The higher the frequency, the shorter the
    wavelength. Just as a reference point, middle C is about 261 Hz these days.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，λ是波长，单位为米，*f*是频率，单位为赫兹（Hertz），*v*是波在介质中的传播速度。对于无线电波来说，速度就是光速。频率越高，波长越短。作为参考点，中音C大约是261
    Hz。
- en: If you stop to think about it, you’ll realize that different waves have different
    properties. Sound waves don’t travel very far and are stopped by a vacuum but
    go around corners. Light waves go a very long way but are stopped by a wall. Some
    frequencies of radio waves go through walls, but others don’t. There’s a lot of
    variation in between.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你停下来思考一下，你会意识到不同的波具有不同的特性。声波传播的距离不远，且在真空中无法传播，但它能绕过障碍物。光波可以传播很远，但会被墙壁阻挡。某些频率的无线电波能穿透墙壁，而其他频率则无法。介于它们之间，有很多不同的变化。
- en: Time to surf. Let’s find a wave that does what we want and hitch a ride. We’ll
    call this wave the *carrier*, and what we want to do is *modulate* or change it
    based on the signal we care about, such as our mark-space *waveform*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候冲浪了。让我们找到一波符合我们需求的浪，并搭乘它。我们将这波浪称为*载波*，而我们想要做的就是基于我们关心的信号，如标记-空白*波形*，对其进行*调制*或改变。
- en: AT&T introduced the Bell 103A data set in the early 1960s. It provided full
    duplex communications at a whopping 300 Baud over a telephone line by using four
    audio frequencies; each end of the connection got its own pair of mark and space
    tones. This is called *frequency shift keying (FSK)* because the frequency shifts
    with the marks and spaces. You can see it in [Figure 6-20](ch06.xhtml#ch06fig20).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: AT&T 在1960年代初推出了 Bell 103A 数据集。它通过四个音频频率，在电话线上提供了高达300 Baud的全双工通信；每端连接都有自己的一对标记和空白音调。这就是*频移键控（FSK）*，因为频率随着标记和空白而变化。你可以在[图
    6-20](ch06.xhtml#ch06fig20)中看到它。
- en: '![Image](../images/06fig20.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig20.jpg)'
- en: '*Figure 6-20: Frequency shift keying—ASCII letter A*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-20：频移键控——ASCII 字母 A*'
- en: The receiving end has to turn the audio back into marks and spaces, called *demodulation*,
    the opposite of modulation. Devices that do this are called *modems*. The weird
    noises you hear when someone uses a dial-up connection to the internet or sends
    a fax in a cheesy movie are the frequencies used by modems.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接收端必须将音频转回标记和空白，这个过程叫做*解调*，是调制的反向过程。执行这一操作的设备叫做*调制解调器*。你在电影里看到某人用拨号上网或者发送传真时听到的奇怪噪音，就是调制解调器使用的频率。
- en: '***Universal Serial Bus***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Universal Serial Bus***'
- en: USB is not all that interesting, but it’s worth a mention because it’s so common.
    It features more incompatible and hard-to-use connectors than any other standard
    and is arguably more important for device charging than for data transfer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: USB 本身可能不太引人注目，但值得一提的是它如此普遍。它比任何其他标准都拥有更多不兼容和难以使用的连接器，而且可以说它在设备充电方面比在数据传输方面更为重要。
- en: USB replaced many of the bulky connectors that were proliferating on computers
    in the mid-1990s, such as the PS/2, RS-232, and parallel ports with a single four-wire
    connector. There were two power wires and a twisted pair for data using differential
    signaling. USB repeats the pattern we’ll see more of soon of “can’t stop there,”
    so now USB Type-C is up to 24 wires, just shy of the old parallel port.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: USB 替代了1990年代中期计算机上大量增长的笨重连接器，如 PS/2、RS-232 和并行端口，采用了一个四线连接器。这个连接器有两根电源线和一对扭曲的传输数据线，用于差分信号。USB重复了我们很快就会看到的“不能止步于此”的模式，所以现在的
    USB Type-C 已经有24根线，接近旧版并行端口的水平。
- en: 'USB is not a free-for-all. There is a *controller* that is in charge of all
    of the *endpoints*, as opposed to everything having equal footing. The data transfer
    is structured; it’s not just shoveling uninterpreted bits around. It uses a common
    technique: data is transferred in *packets*, which are equivalent to packages
    sent through the mail. Packets contain a *header* and optional *payload*. The
    header is essentially the information that you’d find on the outside of a package—where
    it came from, where it’s going, the class of postage, and so on. The payload is
    the contents of the package.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: USB 不是一个完全开放的系统。它有一个*控制器*，负责管理所有的*端点*，与每个设备拥有平等地位不同。数据传输是有结构的；它不仅仅是将未解释的比特数据随意传输。它使用了一种常见的技术：数据以*数据包*的形式传输，这些数据包就像通过邮件发送的包裹一样。数据包包含一个*头部*和可选的*有效载荷*。头部本质上是你在包裹外面看到的信息——它来自哪里，要去哪里，邮寄类别等等。有效载荷是包裹的内容。
- en: USB handles audio and video via *isochronous transfers*. An endpoint can ask
    to reserve a certain amount of the *bandwidth* (data transfer rate), yielding
    a guarantee that data can be transferred. The controller refuses the request if
    there isn’t enough bandwidth.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: USB 通过*同步传输*处理音频和视频。一个端点可以请求保留一定量的*带宽*（数据传输速率），从而保证数据可以被传输。如果带宽不足，控制器会拒绝该请求。
- en: '**Networking**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络**'
- en: It’s difficult to get a clear picture of the modern world of networking without
    knowing its origins. It drives me crazy when my daughter says, “The Wi-Fi is down”
    or, “The internet isn’t working,” because they’re not the same thing. Attempts
    to explain this to her are met with the patented teenage eye roll and hair toss.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不了解现代网络的起源，就很难清楚地看到它的全貌。每当我女儿说“Wi-Fi坏了”或者“互联网不能用了”时，我就觉得很疯狂，因为它们根本不是同一回事。尝试向她解释这些差异时，总是会收到她标志性的青少年翻白眼和甩头反应。
- en: Two general classifications are used to describe networks. A *local area network
    (LAN)* is a network that covers a small geographic area such as a home or an office.
    A *wide area network (WAN)* covers a large geographic area. These terms are somewhat
    fuzzy since there is no exact definition of *small* and *large*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 描述网络时，通常使用两种分类。一种是*局域网（LAN）*，它覆盖一个小的地理区域，如家庭或办公室。另一种是*广域网（WAN）*，它覆盖较大的地理区域。这些术语有些模糊，因为*小*和*大*没有精确的定义。
- en: The original network was the telegraph network, which evolved into the telephone
    network. It didn’t start as a computer network because computers didn’t exist
    at the time. The original telephone network was a *circuit-switched* network.
    When a call was made between parties, their wires were effectively connected together,
    forming a circuit. It was *switched* because that connection existed only for
    the duration of the conversation. Once a call was completed, new circuits could
    be created.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的网络是电报网络，后来发展成电话网络。它最初并不是一个计算机网络，因为在那时计算机并不存在。最初的电话网络是一个*电路交换*网络。当两方之间拨打电话时，它们的电线实际上连接在一起，形成一个电路。之所以称其为*交换*，是因为这种连接只存在于通话期间。一旦通话结束，新的电路就可以被建立。
- en: With a few exceptions, such as the remaining landlines, the phone system is
    now a *packet-switched* network. I mentioned packets in the last section. Communications
    are divided up into packets that include sender and recipient addresses. Packets
    can share wires using time division multiplexing (covered earlier in “[Serial
    Communication](ch06.xhtml#ch06lev2sec9)” on [page 152](ch06.xhtml#page_152)),
    which allows for more efficient use of circuits; this became possible when the
    amount of data that could be sent over a wire became more than was needed just
    for voice.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除少数例外（如剩余的固定电话线路）外，电话系统现在是一个*分组交换*网络。我在上一节提到过分组。通信被分割成包含发送方和接收方地址的分组。通过时分复用（在[《串行通信》](ch06.xhtml#ch06lev2sec9)中第[152页](ch06.xhtml#page_152)有详细介绍），分组可以共享电线，从而更有效地使用电路；这一切在可以通过电线发送的数据量超过仅仅为语音服务所需的量时才成为可能。
- en: One of the earliest computer networks was part of *Semi-Automatic Ground Environment
    (SAGE)*, a Cold War–era defense system. It used modems on the telephone network
    for communications between sites.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最早的计算机网络之一是*半自动地面环境（SAGE）*的一部分，这是冷战时期的防御系统。它使用电话网络上的调制解调器进行站点间的通信。
- en: Many organizations started experimenting with LANs in the late 1960s. For example,
    my lab at Bell was developing graphics terminals that were connected to our department’s
    Honeywell DDP-516 computer using a LAN called the *ring*. At the time, peripherals
    such as tape drives and printers were very expensive, and most departments didn’t
    have their own. But they were available in the main computer center. Our computer
    was connected to a modem, and when it needed something it didn’t have, it would
    just call up the computer center. It was effectively a WAN. Not only could we
    send things off to be printed, we could also send programs that would be run,
    and the computer center would call our machine back with the results.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织在20世纪60年代末开始尝试局域网。例如，我在贝尔实验室的实验室正在开发图形终端，这些终端通过一种叫做*环网*（ring）的局域网连接到我们部门的Honeywell
    DDP-516计算机。当时，外部设备如磁带驱动器和打印机非常昂贵，大多数部门并没有自己的外设。但这些设备在主计算机中心是有的。我们的计算机通过调制解调器连接，当它需要的东西在本地没有时，它就会拨打计算机中心的电话。它实际上是一个广域网（WAN）。我们不仅可以将东西发送去打印，还可以发送程序让计算机中心运行，计算机中心会把结果通过回拨传送给我们。
- en: Similar activity was occurring at many research labs and companies. Many different
    LANs were invented. Each was its own private universe, though—they couldn’t talk
    to each other. Modems and phone lines were the basis for wide-area communications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的活动正在许多研究实验室和公司中进行。许多不同的局域网（LAN）被发明出来。尽管每个局域网都是一个独立的私有宇宙，但它们无法相互通信。调制解调器和电话线构成了广域通信的基础。
- en: A set of computer programs developed at Bell Labs called *UUCP* (for *UNIX-to-UNIX
    copy*) was released to the outside world in 1979\. UUCP allowed computers to call
    each other to transfer data or run programs remotely. It formed the basis for
    early email and news systems such as USENET. These systems were an interesting
    hack. If you wanted to send data across the country, it would hop from machine
    to machine until it got to its destination. This usually allowed long-distance
    phone charges to be avoided.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 贝尔实验室开发的一套计算机程序称为*UUCP*（即*UNIX到UNIX复制*），于1979年发布到外部世界。UUCP允许计算机彼此呼叫，以传输数据或远程运行程序。它为早期的电子邮件和新闻系统（如USENET）奠定了基础。这些系统是一个有趣的黑客手段。如果你想将数据发送到全国范围，它将从一台机器跳到另一台机器，直到到达目的地。这通常能避免长途电话费用。
- en: Meanwhile, ARPA, the Advanced Research Projects Agency of the US Department
    of Defense, was funding the development of the ARPANET, a packet-switched WAN.
    The ARPANET evolved into the internet in the 1990s. Most people take the internet
    for granted today, and like my daughter, they probably think it’s synonymous with
    networking. But its real nature is indicated right there in the name. It’s a contraction
    of *inter* and *net*. The internet is a network of networks—it’s the WAN that
    connects the LANs together.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，美国国防部的高级研究计划局（ARPA）资助了ARPANET的开发，ARPANET是一个分组交换广域网（WAN）。ARPANET在1990年代发展成了互联网。如今，大多数人认为互联网是理所当然的，像我的女儿一样，他们可能认为它与网络就是同义词。但它的真正性质正如名字所示。它是*inter*和*net*的缩写。互联网是一个网络的网络——它是连接局域网（LAN）的广域网（WAN）。
- en: '***Modern LANs***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***现代局域网（LAN）***'
- en: A lot of other stuff that we take for granted these days was invented at the
    Xerox Palo Alto Research Center (PARC) in the mid-1970s. For example, an American
    electrical engineer by the name of Bob Metcalfe invented *Ethernet*, which is
    a LAN because it’s not designed to go very far.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 许多我们今天认为理所当然的东西，都是在1970年代中期的施乐帕洛阿尔托研究中心（PARC）发明的。例如，一位名叫Bob Metcalfe的美国电气工程师发明了*以太网*，它是一个局域网（LAN），因为它并不设计用于长距离传输。
- en: '**NOTE**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Check out Adele Goldberg’s book* A History of Personal Workstations *(Addison-Wesley,
    1988) for more about the history of PARC.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*查看阿黛尔·戈德堡的书籍*《个人工作站的历史》（*Addison-Wesley, 1988*），了解更多有关PARC历史的信息。'
- en: The original Ethernet was a half-duplex system. Every computer was connected
    to the same wire. Each computer network interface had a unique 48-bit address
    called a *Media Access Control (MAC)* address, and that’s still the case today.
    Data is organized into packets, called *frames*, of about 1,500 bytes. Frames
    have a *header* that includes the sender address, the recipient address, and some
    error checks (for example, cyclic redundancy checks, or CRCs, as discussed in
    “[Error Detection and Correction](ch03.xhtml#ch03lev1sec5)” on [page 88](ch03.xhtml#page_88))
    along with the data payload.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的以太网是一个半双工系统。每台计算机都连接到同一根电缆上。每台计算机的网络接口都有一个唯一的48位地址，称为*媒体访问控制（MAC）*地址，这一点至今依然如此。数据被组织成数据包，称为*帧*，大约为1,500字节。帧有一个*头部*，其中包括发送者地址、接收者地址，以及一些错误检测（例如，“[错误检测与纠正](ch03.xhtml#ch03lev1sec5)”一节在[第88页](ch03.xhtml#page_88)讨论的循环冗余校验（CRC））以及数据有效负载。
- en: Normally, one computer would talk, and the others would listen. Computers that
    didn’t match the recipient’s MAC address would ignore the data. Each machine listened
    to what was going on and didn’t transmit if someone else was transmitting. When
    machines did start transmitting at the same time, the collision resulted in garbled
    packets, just like the half-duplex collisions described earlier. Metcalfe used
    *random back-off-and-retry*, an innovation pioneered by ALOHAnet, a packet-switched
    radio network developed at the University of Hawaii. Each machine that was trying
    to talk would wait a random amount of time and then try to resend.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一台计算机会发话，其他计算机会监听。那些与接收者MAC地址不匹配的计算机会忽略数据。每台计算机都在监听发生的事情，并且如果有其他计算机正在传输，它不会发射数据。当计算机同时开始传输时，碰撞会导致数据包损坏，就像之前描述的半双工碰撞一样。Metcalfe使用了*随机回退重试*，这是一项由ALOHA网络首创的创新技术，ALOHA网络是夏威夷大学开发的一个分组交换无线网络。每台尝试发话的计算机会等待一段随机时间，然后再尝试重新发送。
- en: Ethernet is still in use today, though not the half-duplex version. Now machines
    are connected to *routers* that keep track of which machine is at which connection
    and routes packets to the right places. Collisions no longer happen. Wi-Fi is
    essentially a version of Ethernet that uses radio instead of wires. Bluetooth
    is another popular LAN system. Think of it as a version of USB that ditches the
    wires for radio.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网至今仍在使用，不过不是半双工版本。现在，机器连接到*路由器*，路由器跟踪每台机器的位置，并将数据包路由到正确的位置。碰撞问题已经不再发生。Wi-Fi本质上是以太网的一个版本，它使用无线电而非电缆。蓝牙是另一种流行的局域网系统。可以把它看作是去除了电缆而使用无线电的USB版本。
- en: '***The Internet***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***互联网***'
- en: As you now know, the internet is not actually a physical network; it’s a set
    of layered protocols. It’s designed in such a way that the lower layers specifying
    the physical network can be replaced without affecting the upper layers. That
    design allows the internet to function over wires, radio, optical fibers, and
    whatever new technologies come along.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，互联网其实并不是一个物理网络；它是由一组层次化的协议组成。其设计方式使得指定物理网络的下层可以在不影响上层的情况下被替换。这种设计使得互联网可以通过电线、无线电、光纤以及未来的新技术运行。
- en: '**TCP/IP**'
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**TCP/IP**'
- en: '*Transmission Control Protocol/Internet Protocol (TCP/IP)* is the pair of protocols
    on which the internet is built. IP gets packets from place to place. These packets,
    called *datagrams*, are like telegrams for computers. As with real telegrams,
    the sender doesn’t know when or even whether the recipient got the message. TCP
    is built on top of IP and makes sure that packets get reliably delivered. This
    is a pretty complicated job, because large messages span many packets that may
    not arrive in order since they may have taken different routes—not much different
    from ordering some stuff and having it shipped in multiple boxes that may not
    all arrive on the same day or even be sent via the same carrier.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*传输控制协议/互联网协议 (TCP/IP)* 是互联网的基础协议对。IP负责将数据包从一个地方传送到另一个地方。这些数据包被称为*数据报*，就像是计算机的电报。与真实的电报一样，发送方并不知道接收方是否在某个时刻收到消息。TCP建立在IP之上，确保数据包能够可靠地传送。这是一项相当复杂的工作，因为大的消息需要通过多个数据包传输，而这些数据包可能不会按顺序到达，因为它们可能走了不同的路径——这就像你订购物品，货物被分装成多个箱子，可能不会在同一天到达，甚至可能通过不同的运输公司送达。'
- en: '**IP Addresses**'
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IP地址**'
- en: Each computer on the internet has a unique address known as its *IP address*.
    Unlike MAC addresses, IP addresses aren’t tied to the hardware and can change.
    The IP address system is a hierarchical system in which someone gives out blocks
    of addresses, who in turn give out blocks of addresses, and so on until it gets
    down to whoever gives your machine its address.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每台计算机在互联网上都有一个唯一的地址，称为*IP地址*。与MAC地址不同，IP地址不与硬件绑定，可以更改。IP地址系统是一个层次化的系统，某人分配出一块地址，接着再有人分配一块地址，依此类推，直到最后给到你的设备分配地址。
- en: The internet pretty much runs on *IPv4*, version 4 of IP, which uses 32 bits
    of address. Addresses are written in *octet* notation of *xxx.xxx.xxx.xxx*, where
    each *xxx* is 8 of the 32 bits written in decimal. That’s over 4 billion addresses,
    yet that’s not enough. Now that everyone has an address for their desktop, their
    laptop, their tablet, their cell phone, and their other gadgets, there are no
    more addresses to give out. Hence, the world has been slowly migrating to *IPv6*,
    which has 128-bit addresses.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网几乎完全依赖于*IPv4*，即IP的第4版，使用32位地址。地址以*八位字节*表示，格式为*xxx.xxx.xxx.xxx*，其中每个*xxx*表示32位中的8位，以十进制形式表示。这意味着有超过40亿个地址，但这还不够。现在每个人都有一个桌面电脑、笔记本电脑、平板电脑、手机和其他设备的地址，但地址已经用完了。因此，全球正在慢慢过渡到*IPv6*，它有128位的地址。
- en: '**Domain Name System**'
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**域名系统**'
- en: How can you be found if your address can change? That’s handled by the *Domain
    Name System (DNS)*, which is like a phone book, for those who remember what those
    are. DNS maps names to addresses. It knows that *whitehouse.gov* has the IP address
    23.1.225.229 at the time that I’m writing this. It’s sort of like the address
    book in your phone, except you have to keep that up-to-date; DNS takes care of
    everything whenever anybody moves.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的地址可以变化，怎么找到你呢？这个问题由*域名系统 (DNS)* 解决，它就像是一本电话簿，给那些还记得电话簿的人。DNS将名字映射到地址。它知道*whitehouse.gov*的IP地址是23.1.225.229，在我写这篇文章时就是这个地址。它有点像你手机里的通讯录，只不过你需要保持更新；而DNS会在任何人更换地址时自动处理这一切。
- en: '**The World Wide Web**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**万维网**'
- en: Many other protocols are built on top of TCP/IP, such as the *Simple Mail Transfer
    Protocol (SMTP)* that makes email work. One of the most used protocols is *HTTP*,
    short for *HyperText Transfer Protocol*, which is used for web pages, along with
    *HTTPS* where the *S* stands for *secure*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他协议都是建立在TCP/IP之上的，比如使电子邮件工作的*简单邮件传输协议（SMTP）*。最常用的协议之一是*HTTP*，即*超文本传输协议*，它用于网页传输，以及*HTTPS*，其中*S*代表*安全*。
- en: Hypertext is just text with links. American engineer Vannevar Bush (1890–1974)
    came up with the idea in 1945\. It didn’t really take off until Tim Berners-Lee,
    a scientist at CERN (the European Organization for Nuclear Research), invented
    the World Wide Web so that physicists could share information.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本只是带有链接的文本。美国工程师范内瓦·布什（Vannevar Bush，1890-1974）在1945年提出了这一概念。直到欧洲核子研究组织（CERN）的科学家蒂姆·伯纳斯-李（Tim
    Berners-Lee）发明了万维网，物理学家们才得以分享信息，这一概念才真正起飞。
- en: The HTTP standard defines how *web browsers* interact with *web servers*. Web
    browsers are what you use to view web pages. Web servers send you those pages
    upon request. Web pages are found and fetched by a *Uniform Resource Locator (URL)*,
    the website address in the address bar of your browser. It’s how you locate the
    information you want and includes the domain name of a machine on the internet
    and a description of where to find the information on that machine.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP标准定义了*网页浏览器*与*网页服务器*的交互方式。网页浏览器是你用来查看网页的工具。网页服务器在请求时将这些页面发送给你。网页是通过*统一资源定位符（URL）*找到并获取的，即浏览器地址栏中的网站地址。它是你定位所需信息的方式，包括互联网上机器的域名和描述该机器上信息存放位置的内容。
- en: Web pages typically start their lives as *HTML* (short for *HyperText Markup
    Language*), the most common language in which web pages are written. HTML has
    gotten a lot of stuff stuck onto it over time and is now a pretty complicated
    mess. More on this in [Chapter 9](ch09.xhtml#ch09).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 网页通常以*HTML*（即*超文本标记语言*）的形式开始，它是编写网页最常用的语言。随着时间的推移，HTML上增加了许多内容，现在已经变得相当复杂。更多内容请参见[第9章](ch09.xhtml#ch09)。
- en: '**Analog in the Digital World**'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数字世界中的模拟**'
- en: Computers are in lots of entertainment devices, from audio players to televisions.
    You may have noticed that digital photos don’t look very good when they’re magnified
    beyond a certain point. Our real-world experience of sound and light is continuous,
    but computers have no way to store continuous things. The data must be *sampled*,
    which means we have to take readings at points in time and/or space. An analog
    (continuous) signal must then be reconstructed from those samples for playback.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机出现在许多娱乐设备中，从音频播放器到电视机。你可能已经注意到，数字照片在放大到某个程度后看起来并不好。我们对声音和光的现实世界体验是连续的，但计算机无法存储连续的东西。数据必须进行*采样*，这意味着我们必须在时间和/或空间的某些点进行读取。然后，必须根据这些采样点重建一个模拟（连续）信号以进行播放。
- en: '**NOTE**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There’s a good video called “Episode 1: A Digital Media Primer for Geeks”
    that you can find online that is a good introduction to sampling. There’s a second
    episode, which is also good, but it’s very misleading. While everything said is
    technically correct, it only applies to mono, not stereo. The presenter implies
    that it’s good for stereo, but it isn’t.*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*有一个很好的视频，叫做“第1集：极客的数字媒体入门”，你可以在网上找到，它是采样的一个很好的入门教程。还有第二集，也是不错的，但它非常具有误导性。尽管所说的一切在技术上都是正确的，但它只适用于单声道，而非立体声。讲解者暗示它适用于立体声，但其实并不是。*'
- en: Sampling isn’t a new thing; even back in the days of silent movies, the scene
    was sampled at about 16 frames per second. There’s an entire field called *discrete
    mathematics* that deals with sampling. Discreetly, of course.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 采样并不是新事物；早在无声电影时代，场景的采样率就大约是每秒16帧。实际上有一个领域叫做*离散数学*，专门研究采样。当然，采样是以离散的方式进行的。
- en: We talked about the differences between analog and digital way back in [Chapter
    2](ch02.xhtml#ch02). This book is about digital computers, and many real-world
    applications require computers to generate analog signals, interpret analog signals,
    or both. The following sections discuss how computers accomplish this.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.xhtml#ch02)中讨论过模拟与数字之间的差异。本书主要讲数字计算机，而许多现实世界的应用需要计算机生成模拟信号、解释模拟信号或两者兼而有之。接下来的章节将讨论计算机如何完成这些任务。
- en: '***Digital-to-Analog Conversion***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字到模拟转换***'
- en: 'How might we generate an analog voltage based on a digital number? The blithe
    and correct answer is: by using a digital-to-analog converter. How would we construct
    one of these?'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何基于数字数值生成模拟电压？简单且正确的回答是：通过使用数字到模拟转换器。我们如何构建一个这样的设备呢？
- en: Let’s go back to [Figure 6-1](ch06.xhtml#ch06fig01), where we have an LED connected
    to an I/O port. In [Figure 6-21](ch06.xhtml#ch06fig21), we hook an LED to each
    of the eight pins of port B.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[图6-1](ch06.xhtml#ch06fig01)，在这里我们将LED连接到I/O端口。在[图6-21](ch06.xhtml#ch06fig21)中，我们将一个LED连接到端口B的每个引脚。
- en: '![Image](../images/06fig21.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig21.jpg)'
- en: '*Figure 6-21: Digital-to-analog converter using LEDs*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-21：使用LED的数字转模拟转换器*'
- en: Now we can generate nine different light levels—from no LEDs on to eight LEDs
    on. But nine levels from 8 bits isn’t a very good use of bits; with 8 bits, we
    should be able to get 256 different levels. How? Just like we do with numbers.
    [Figure 6-22](ch06.xhtml#ch06fig22) hooks one LED to bit 0, two to bit 1, four
    to bit 2, and so on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以生成九个不同的光照级别——从没有LED亮起到八个LED亮起。但8位产生9个级别并不是一个很好的位数利用方式；使用8位，我们应该能够获得256个不同的级别。怎么做到呢？就像我们处理数字一样。[图6-22](ch06.xhtml#ch06fig22)将一个LED连接到位0，两个LED连接到位1，四个LED连接到位2，以此类推。
- en: '![Image](../images/06fig22.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig22.jpg)'
- en: '*Figure 6-22: Better digital-to-analog converter using LEDs*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-22：使用LED的更好的数字转模拟转换器*'
- en: That’s a whole lotta LEDs. You could hang this circuit from a balloon to make
    a LED zeppelin. Moving on, you can see that this mirrors our binary representation
    of numbers. Bit 1 produces twice as much light as bit 0, bit 2 four times as much,
    and so on.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 那真是好多LED啊。你可以将这个电路挂在气球上，制作一个LED飞艇。接下来，你可以看到这与我们二进制表示数字的方式相似。位1产生的光是位0的两倍，位2产生的光是位0的四倍，以此类推。
- en: We used the LED example to illuminate the workings of a digital-to-analog converter.
    A real digital-to-analog converter (D/A or DAC) produces a voltage instead of
    light. The term *resolution* is loosely used to describe the number of “steps”
    a DAC can produce. I say “loosely” because it’s common to say that a DAC has,
    for example, 10 bits of resolution, which really means that it has a resolution
    of 1 part in 2^(10). To be completely correct, the resolution is the maximum voltage
    that the DAC can produce divided by the number of steps. For example, if a 10-bit
    DAC could produce 5V maximum, then it has a resolution of approximately 0.005V.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用LED示例来说明数字转模拟转换器的工作原理。一个真实的数字转模拟转换器（D/A或DAC）产生的是电压而不是光。术语*分辨率*通常用来描述DAC能产生的“步数”。我说“通常”是因为通常会说一个DAC具有10位分辨率，这实际上意味着它的分辨率是2^(10)中的1个部分。严格来说，分辨率是DAC能够产生的最大电压除以步数。例如，如果一个10位的DAC能产生5V的最大电压，那么它的分辨率大约是0.005V。
- en: '[Figure 6-23](ch06.xhtml#ch06fig23) shows the symbol used for a DAC.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-23](ch06.xhtml#ch06fig23)展示了DAC的符号。'
- en: '![Image](../images/06fig23.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig23.jpg)'
- en: '*Figure 6-23: DAC schematic symbol*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-23：DAC示意符号*'
- en: We can generate analog waveforms using a DAC. This is how audio players and
    music synthesizers work. All we need to do is to change the DAC inputs at a regular
    rate. For example, if we had an 8-bit DAC connected to port B, we could generate
    the sawtooth wave shown in [Figure 6-24](ch06.xhtml#ch06fig24).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用DAC生成模拟波形。这就是音频播放器和音乐合成器的工作原理。我们只需要按规律改变DAC的输入。例如，如果我们有一个连接到端口B的8位DAC，我们就可以生成[图6-24](ch06.xhtml#ch06fig24)所示的锯齿波形。
- en: '![Image](../images/06fig24.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig24.jpg)'
- en: '*Figure 6-24: Synthesized sawtooth wave*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-24：合成的锯齿波*'
- en: For more complex waveforms, devices usually incorporate memory that can be written
    with the data, which is then read out by additional circuitry. This ensures a
    constant data rate that is independent of whatever else the CPU is doing. A typical
    way of implementing this is by creating a *FIFO* (“first in, first out”) configuration,
    as shown in [Figure 6-25](ch06.xhtml#ch06fig25). Note that a FIFO is the same
    thing as a software queue.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的波形，设备通常会包含可以写入数据的内存，然后通过额外的电路读取数据。这确保了一个恒定的数据速率，与CPU正在做的其他操作无关。实现这一点的典型方法是创建一个*FIFO*（先进先出）配置，如[图6-25](ch06.xhtml#ch06fig25)所示。请注意，FIFO与软件队列是一样的。
- en: '![Image](../images/06fig25.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig25.jpg)'
- en: '*Figure 6-25: FIFO with high- and low-water marks*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-25：具有高水位和低水位标记的FIFO*'
- en: 'Two triggers are associated with the FIFO memory: a *high-water mark* and a
    *low-water mark*, which borrow their terminology from tides. The low-water mark
    triggers an interrupt when the FIFO is close to empty; the high-water mark triggers
    when it’s close to full. This way, higher-level software can keep the memory filled
    so that the output is continuous. Though it’s not exactly a FIFO because newly
    added water mixes with the old, this is how water towers work; when the water
    is below the low-water mark, the pump turns on to fill the tank; when the high-water
    mark is reached, the pump turns off. FIFOs are really handy for connecting things
    that operate at different speeds.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO 存储器与两个触发器相关：*高水位线*和*低水位线*，它们借用了潮汐的术语。低水位线在 FIFO 快要空时触发中断；高水位线在 FIFO 快要满时触发。这样，高层软件就可以保持内存填充，从而保证输出是连续的。虽然它不完全是
    FIFO，因为新加的水会与旧水混合，但这就是水塔的工作原理；当水位低于低水位线时，水泵启动来填充水箱；当达到高水位线时，水泵关闭。FIFO 对于连接不同速度的设备非常有用。
- en: '***Analog-to-Digital Conversion***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟到数字转换***'
- en: Analog-to-digital conversion, the opposite process, is done using an A/D, or
    ADC, which is more complicated than a DAC. The first problem that arises is getting
    the analog signal to hold still, because we can’t measure it if it’s wiggling
    around. (You know the problem if you’ve ever tried to take a little kid’s temperature.)
    In [Figure 6-26](ch06.xhtml#ch06fig26), we need to take a *sample* of the input
    waveform—more than one if we want our digitized version to resemble the analog
    original. We do this using a circuit called a *sample and hold*, which is the
    analog equivalent of a digital latch (see “[Latches](ch03.xhtml#ch03lev2sec3)”
    on [page 71](ch03.xhtml#page_71)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟到数字转换，即相反的过程，是使用 A/D 或 ADC 完成的，这比 DAC 更为复杂。出现的第一个问题是让模拟信号保持静止，因为如果信号在晃动，我们就无法测量它。（如果你曾试图给小孩量体温，你就会知道这个问题。）在[图
    6-26](ch06.xhtml#ch06fig26)中，我们需要对输入波形进行*采样*——如果我们希望数字化版本接近模拟原始信号，就需要多次采样。我们通过使用一个叫做*采样和保持*的电路来做到这一点，它是数字锁存器的模拟等效物（见第[3章](ch03.xhtml#ch03lev2sec3)第[71页](ch03.xhtml#page_71)的“锁存器”部分）。
- en: '![Image](../images/06fig26.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig26.jpg)'
- en: '*Figure 6-26: Sample and hold*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-26：采样和保持*'
- en: When we take a sample by closing the switch, the current value of the analog
    signal is stored in the holding tank. Now that we have a stable signal in the
    holding tank, we need to measure it so we can generate a digital value. We need
    something that compares the signal to a threshold similar to what we saw in the
    right half of [Figure 2-7](ch02.xhtml#ch02fig07), back in [Chapter 2](ch02.xhtml#ch02).
    Fortunately, an analog circuit called a *comparator* can tell us when one voltage
    is greater than another. It’s just like a logic gate except that we can choose
    the threshold.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过闭合开关来采样时，模拟信号的电流值被存储在保持池中。现在我们已经在保持池中获得了稳定的信号，我们需要对其进行测量，以便生成数字值。我们需要一些东西来将信号与阈值进行比较，类似于我们在[图
    2-7](ch02.xhtml#ch02fig07)的右半部分所看到的，回到[第 2 章](ch02.xhtml#ch02)。幸运的是，一个叫做*比较器*的模拟电路可以告诉我们一个电压是否大于另一个电压。它就像一个逻辑门，只不过我们可以选择阈值。
- en: The schematic symbol for a comparator is shown in [Figure 6-27](ch06.xhtml#ch06fig27).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 比较器的电路符号如[图 6-27](ch06.xhtml#ch06fig27)所示。
- en: '![Image](../images/06fig27.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig27.jpg)'
- en: '*Figure 6-27: Analog comparator*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-27：模拟比较器*'
- en: The output is 1 if the signal on the + input is greater than or equal to the
    signal on the – input.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果+输入的信号大于或等于-输入的信号，则输出为 1。
- en: We can use a stack of comparators with different *reference voltages* on the
    – inputs to build a *flash converter*, as shown in [Figure 6-28](ch06.xhtml#ch06fig28).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一堆具有不同*参考电压*的比较器，将其连接到负输入端，以构建一个*闪光转换器*，如[图 6-28](ch06.xhtml#ch06fig28)所示。
- en: '![Image](../images/06fig28.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig28.jpg)'
- en: '*Figure 6-28: Flash converter*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-28：闪光转换器*'
- en: 'It’s called a flash converter because it generates results quickly, in a flash.
    As you can see, the outputs are 00000000 for a voltage less than 0.125V, 000000001
    for a voltage between 0.125V and 0.250V, 00000011 for a voltage between 0.250V
    and 0.375V, and so on. This works, but it has the same problem as our DAC in [Figure
    6-25](ch06.xhtml#ch06fig25): it doesn’t use the bits very efficiently. Flash converters
    are also relatively expensive parts due to the number of comparators, but they’re
    the way to go when extreme speed is required. How might we construct a cheaper
    ADC that better utilizes the bits?'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为闪烁转换器，因为它生成结果很快，眨眼间就完成。如你所见，当电压小于0.125V时，输出为00000000；当电压在0.125V和0.250V之间时，输出为00000001；当电压在0.250V和0.375V之间时，输出为00000011，依此类推。这个方法有效，但它和我们在[图6-25](ch06.xhtml#ch06fig25)中的DAC有相同的问题：它没有高效使用位。闪烁转换器也因比较器数量较多而相对昂贵，但当需要极高速度时，它们是理想选择。那么，我们如何构建一个更便宜且能更好利用位的ADC呢？
- en: Our flash converter used a set of fixed reference voltages, one for each comparator.
    We could use a single comparator if we had an adjustable reference voltage. Where
    might we get one of those? With a DAC!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的闪烁转换器使用了一组固定的参考电压，每个比较器有一个参考电压。如果我们有一个可调参考电压，我们可以使用单个比较器。那我们可以从哪里得到这种参考电压呢？通过一个DAC！
- en: In [Figure 6-29](ch06.xhtml#ch06fig29), you can see that we’re using a comparator
    to test the sampled value in the holding tank against the value of the DAC. Once
    cleared, the counter counts up until the DAC value hits the sampled value, at
    which time the counter is disabled and we’re done. The counter contains the digitized
    value of the sample.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-29](ch06.xhtml#ch06fig29)中，你可以看到我们正在使用比较器测试保持池中采样值与DAC值的关系。一旦清除，计数器开始递增，直到DAC值达到采样值，此时计数器被禁用，转换完成。计数器包含了样本的数字化值。
- en: '![Image](../images/06fig29.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/06fig29.jpg)'
- en: '*Figure 6-29: Analog-to-digital converter*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-29：模数转换器*'
- en: Once cleared, the counter counts up until the DAC value hits the sampled value,
    at which time the counter is disabled and we’re done. The counter contains the
    digitized value of the sample.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清除，计数器会递增，直到DAC值达到采样值，此时计数器被禁用，转换完成。计数器包含了样本的数字化值。
- en: You can see how this works in [Figure 6-30](ch06.xhtml#ch06fig30). The analog
    signal wiggles around, but the output of the holding tank is stable once a sample
    is taken. The counter is then cleared, and it counts up until the DAC output hits
    the sampled value, at which time the counter stops and we’re done.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图6-30](ch06.xhtml#ch06fig30)中看到它是如何工作的。模拟信号会在一定范围内波动，但一旦采样完成，保持池的输出就会稳定。然后清除计数器，计数器开始递增，直到DAC输出达到采样值，此时计数器停止，转换完成。
- en: '![Image](../images/06fig30.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/06fig30.jpg)'
- en: '*Figure 6-30: ADC in operation*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-30：ADC操作示意图*'
- en: This ADC is called a *ramp converter* because of the way in which the DAC output
    generates a ramp. One of the problems with a ramp converter is that it can take
    a long time since the conversion time is a linear function of the sampled signal
    value. If the sampled signal is at its maximum value and we have an *n*-bit ADC,
    conversion can take 2^(*n*) clocks.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ADC被称为*ramp转换器*，因为DAC输出生成一个斜坡。ramp转换器的一个问题是，它可能需要很长时间，因为转换时间是采样信号值的线性函数。如果采样信号达到最大值，并且我们有一个*n*位的ADC，转换可能需要2^(*n*)个时钟周期。
- en: One way around this is to use a *successive approximation* converter, which
    performs a *binary search* in hardware, as you can see in [Figure 6-31](ch06.xhtml#ch06fig31).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方法是使用*逐次逼近*转换器，它在硬件中执行*二分查找*，正如你在[图6-31](ch06.xhtml#ch06fig31)中看到的那样。
- en: '![Image](../images/06fig31.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/06fig31.jpg)'
- en: '*Figure 6-31: Successive approximation ADC in operation*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-31：逐次逼近ADC操作示意图*'
- en: The first clock sets the DAC to one-half of the full range. Since that’s less
    than the sampled signal, it’s adjusted upward by one-quarter of the full range.
    That’s too much, so next it’s adjusted downward by one-eighth of the full range.
    That’s too low, so it’s adjusted up by one-sixteenth of the full range, and we’re
    there. Worst case, it takes log[2] *n* clocks. That’s quite an improvement.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个时钟将DAC设置为全范围的一半。由于这小于采样信号，它会按全范围的四分之一向上调整。调整过头了，因此接下来会按全范围的八分之一向下调整。还不够低，因此它再按全范围的十六分之一向上调整，直到匹配。这是最坏情况，它需要log[2]
    *n*个时钟。这是一个相当大的改进。
- en: The term *resolution* is used for ADCs in a manner similar to how it’s used
    for DACs. The schematic symbol is shown in [Figure 6-32](ch06.xhtml#ch06fig32).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: “分辨率”这个术语用于ADC的方式与用于DAC时相似。原理图符号如[图6-32](ch06.xhtml#ch06fig32)所示。
- en: '![Image](../images/06fig32.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig32.jpg)'
- en: '*Figure 6-32: ADC schematic symbol*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-32：ADC 原理图符号*'
- en: '***Digital Audio***'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字音频***'
- en: Audio involves *sampling* in one dimension—that is, measuring the *amplitude*
    or height of the signal at points in time. Look at the sine wave in [Figure 6-33](ch06.xhtml#ch06fig33).
    We have a *square wave* with some *sampling frequency*, and we record the height
    of the signal on each *rising edge* using an A/D.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 音频涉及*采样*，即在时间点上测量信号的*振幅*或高度。看看[图 6-33](ch06.xhtml#ch06fig33)中的正弦波。我们有一个*方波*，具有一定的*采样频率*，我们使用
    A/D 转换器记录信号在每个*上升沿*时的高度。
- en: '![Image](../images/06fig33.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig33.jpg)'
- en: '*Figure 6-33: Sampling a sine wave*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-33：采样正弦波*'
- en: Now that we have a set of samples, we should be able to reconstruct the original
    signal by feeding them to a D/A. Let’s give it a try, as shown in [Figure 6-34](ch06.xhtml#ch06fig34).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一组样本，应该可以通过将它们输入到 D/A 转换器中来重建原始信号。让我们试试看，如[图 6-34](ch06.xhtml#ch06fig34)所示。
- en: '![Image](../images/06fig34.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig34.jpg)'
- en: '*Figure 6-34: Reconstructed sine wave from samples*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-34：从样本重建的正弦波*'
- en: Wow, that looks terribly distorted. Looks like we’d need a lot more samples
    to improve the result so that it looked more like [Figure 6-35](ch06.xhtml#ch06fig35).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这看起来完全扭曲了。看起来我们需要更多的样本来改善结果，让它看起来更像[图 6-35](ch06.xhtml#ch06fig35)。
- en: '![Image](../images/06fig35.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig35.jpg)'
- en: '*Figure 6-35: Higher-frequency sampling and reconstruction*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-35：高频采样与重建*'
- en: 'But we don’t need to. The sampling and reconstruction in [Figures 6-33](ch06.xhtml#ch06fig33)
    and [6-34](ch06.xhtml#ch06fig34) is actually okay. I’m about to tell you why,
    but be warned: there’s some heavy theory ahead.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不需要这么做。[图 6-33](ch06.xhtml#ch06fig33)和[图 6-34](ch06.xhtml#ch06fig34)中的采样和重建实际上是可以的。我将告诉你原因，但请注意，接下来有一些深奥的理论。
- en: A sine wave is relatively easy to describe, as mentioned in “[Catch a Wave](ch06.xhtml#ch06lev2sec10)”
    on [page 154](ch06.xhtml#page_154). But we need a way to describe more complicated
    waveforms, such as the one in [Figure 6-31](ch06.xhtml#ch06fig31).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦波相对容易描述，正如在“[捕捉波形](ch06.xhtml#ch06lev2sec10)”中所提到的，位于[第 154 页](ch06.xhtml#page_154)。但我们需要一种方法来描述更复杂的波形，例如[图
    6-31](ch06.xhtml#ch06fig31)中的波形。
- en: The graphs so far plot amplitude against time, but we can look at it in other
    ways. Take a look at the musical score in [Figure 6-36](ch06.xhtml#ch06fig36).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，图表是绘制振幅与时间的关系，但我们也可以从其他角度来看待它。看看[图 6-36](ch06.xhtml#ch06fig36)中的乐谱。
- en: '![Image](../images/06fig36.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig36.jpg)'
- en: '*Figure 6-36: A musical score*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-36：乐谱*'
- en: 'You can see that the score plots musical notes against time, but there’s more
    happening. We don’t just have notes at each point in time; we have *chords*, which
    are constructed from multiple notes. Let’s look at the first chord, which contains
    the notes G[4] (400 Hz), B[4] (494 Hz), and D[5] (587 Hz). Pretend we’re playing
    the chord on a synthesizer that can generate sine waves for the notes. You can
    see in [Figure 6-37](ch06.xhtml#ch06fig37) that although each note is a sine wave,
    the chord itself is a more complex waveform, being the sum of the three notes.
    It turns out that any waveform can be represented as the weighted (multiplied
    by some scale factor) sum of a set of sine waves. For example, if the square wave
    in [Figure 6-33](ch06.xhtml#ch06fig33) has a frequency of *f*, it can be represented
    as the sum of sine waves:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，乐谱将音符与时间进行绘制，但还有更多内容。我们不仅在每个时间点都有音符；我们还有*和弦*，它们是由多个音符构成的。让我们来看一下第一个和弦，它包含了音符
    G[4]（400 Hz）、B[4]（494 Hz）和 D[5]（587 Hz）。假设我们正在使用合成器弹奏这个和弦，合成器能为这些音符生成正弦波。你可以在[图
    6-37](ch06.xhtml#ch06fig37)中看到，尽管每个音符都是正弦波，但和弦本身是一个更复杂的波形，它是这三个音符的总和。事实证明，任何波形都可以表示为一组正弦波的加权和（每个正弦波乘以一个比例因子）。例如，如果[图
    6-33](ch06.xhtml#ch06fig33)中的方波频率为*f*，它可以表示为正弦波的总和：
- en: '![Image](../images/eq167-01.jpg)![Image](../images/06fig37.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq167-01.jpg)![Image](../images/06fig37.jpg)'
- en: '*Figure 6-37: G major chord waveform*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-37：G 大调和弦波形*'
- en: If you have a good ear, you can listen to a chord like this and pick out the
    component notes. Tone-deaf people have to rely on some mathematical acrobatics
    called the *Fourier transform*, invented by French mathematician and physicist
    Jean-Baptiste Joseph Fourier (1768–1830), who also discovered the greenhouse effect.
    All the graphs we’ve seen in this section so far plot amplitude against time.
    The Fourier transform allows us to plot amplitude against frequency. It’s a different
    way of looking at things. The Fourier transform of our G major chord would look
    like [Figure 6-38](ch06.xhtml#ch06fig38).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一副好耳朵，你可以听到像这样的和弦，并分辨出其中的组成音符。音盲的人则不得不依赖一种叫做*傅里叶变换*的数学技巧，这一方法由法国数学家和物理学家让-巴蒂斯特·约瑟夫·傅里叶（1768–1830）发明，他也发现了温室效应。到目前为止，我们在这一节中看到的所有图表都是将振幅与时间作图。傅里叶变换允许我们将振幅与频率作图。这是一种不同的观察事物的方式。我们
    G 大调和弦的傅里叶变换图会像[图 6-38](ch06.xhtml#ch06fig38)一样。
- en: '![Image](../images/06fig38.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/06fig38.jpg)'
- en: '*Figure 6-38: G major chord Fourier transform plot*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-38：G 大调和弦傅里叶变换图*'
- en: You’ve probably seen this sort of thing before without knowing it. Many media
    players have spectrum analyzer eye candy that displays the volume in different
    frequency bands using the Fourier transform. Spectrum analyzers originated as
    complicated pieces of electronic equipment. Now they can be implemented on computers
    using the *Fast Fourier Transform (FFT)* algorithm. One of the coolest applications
    of Fourier analysis is the Hammond B-3 organ.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能以前见过这种东西，只是你没意识到。许多媒体播放器都有频谱分析器的炫酷效果，显示不同频率带的音量，这就是傅里叶变换的应用。频谱分析器最初是复杂的电子设备，现在可以通过*快速傅里叶变换（FFT）*算法在计算机上实现。傅里叶分析的一个最酷的应用就是哈蒙德
    B-3 风琴。
- en: THE HAMMOND B-3 ORGAN
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 哈蒙德 B-3 风琴
- en: The Hammond B-3 is an amazing application of electromagnetics and Fourier analysis.
    The way it works is that a motor drives a shaft on which 91 “tone wheels” are
    mounted. Each tone wheel has an associated pickup, similar to what’s used on electric
    guitars, that generates a specific frequency as determined by the bumps on the
    tone wheels. Since all of the tone wheels are mounted on the same shaft, they
    can’t get out of tune with each other.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 哈蒙德 B-3 是电磁学和傅里叶分析的惊人应用。它的工作原理是，一个电动机驱动一根轴，上面装有91个“音轮”。每个音轮都有一个关联的拾音器，类似于电吉他上的拾音器，它根据音轮上的凸起产生特定的频率。由于所有音轮都装在同一根轴上，它们之间无法失去音准。
- en: Pressing a key on a B-3 doesn’t just generate the frequency produced by a tone
    wheel. There are nine eight-position “drawbars” that are used to mix the signal
    produced by the “fundamental” tone (the note being played) with signals from other
    tone wheels. The drawbars set the level of the sub-octave, fifth, fundamental,
    8th, 12th, 15th, 17th, 19th, and 22nd harmonics.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 B-3 上的一个键，不仅仅是生成由音轮产生的频率。它有九个八位“拉杆”，用于将“基音”（正在演奏的音符）产生的信号与其他音轮的信号混合。拉杆设置了子八度、五度、基音、第八度、第十二度、第十五度、第十七度、第十九度和第二十二度谐波的音量。
- en: The sound produced is the weighted sum of these nine signals as set by the drawbars
    in a manner similar to how we produced our G major chord in [Figure 6-37](ch06.xhtml#ch06fig37).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的声音是这九个信号的加权和，这些信号的设置方式类似于我们在[图 6-37](ch06.xhtml#ch06fig37)中生成 G 大调和弦的方式。
- en: 'Another feature of many media players is the *graphic equalizer*, which lets
    you adjust the sound to your taste. A graphic equalizer is a set of adjustable
    *filters*, devices that include or exclude certain frequencies. They’re akin to
    the transfer functions that we saw in “[Digital in an Analog World](ch02.xhtml#ch02lev2sec4)”
    on [page 38](ch02.xhtml#page_38), but for frequency instead of voltage or light.
    There are two main types of filters: *low pass*, which pass everything below a
    certain frequency, and *high pass*, which pass everything above a certain frequency.
    They can be combined to make *bandpass* filters that include everything between
    a low and high frequency, or *notch* filters that exclude a particular frequency.
    You can see in [Figure 6-39](ch06.xhtml#ch06fig39) that the filter edges are not
    sharp; they *roll off*. Perfect filters don’t exist. Note that the button debouncer
    in [Figure 6-7](ch06.xhtml#ch06fig07) is a low-pass filter.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 许多媒体播放器的另一个特性是*图形均衡器*，它让你根据个人喜好调整音效。图形均衡器是一组可调节的*滤波器*，这些设备可以包括或排除某些频率。它们类似于我们在《[模拟世界中的数字](ch02.xhtml#ch02lev2sec4)》中看到的传递函数，区别在于它们是处理频率，而不是电压或光。滤波器主要有两种类型：*低通*，通过所有低于某一频率的信号；*高通*，通过所有高于某一频率的信号。它们可以组合成*带通*滤波器，允许通过低频和高频之间的所有信号，或者*陷波*滤波器，排除某一特定频率。你可以在[图
    6-39](ch06.xhtml#ch06fig39)中看到，滤波器的边缘并不锋利，它们会*逐渐衰减*。完美的滤波器是不存在的。请注意，[图 6-7](ch06.xhtml#ch06fig07)中的按钮去抖动器就是一个低通滤波器。
- en: '![Image](../images/06fig39.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig39.jpg)'
- en: '*Figure 6-39: Filters*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-39: 滤波器*'
- en: We could, for example, apply a low-pass filter to our G major chord, as seen
    in [Figure 6-40](ch06.xhtml#ch06fig40). Applying a filter effectively multiplies
    the curves; the filter adjusts the sound level at different frequencies.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，我们可以对我们的 G 大调和弦应用一个低通滤波器，如[图 6-40](ch06.xhtml#ch06fig40)所示。应用滤波器实际上是对曲线进行乘法运算；滤波器调整不同频率下的声音水平。
- en: '![Image](../images/06fig40.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig40.jpg)'
- en: '*Figure 6-40: Low-pass filtered G major chord Fourier transform plot*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-40: 低通滤波的 G 大调和弦傅里叶变换图*'
- en: As you can imagine, it no longer sounds the same. The B[4] is slightly quieter,
    and the D[5] is all but gone.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，它听起来不再一样了。B[4] 稍微安静了些，D[5] 几乎消失了。
- en: Why does all this matter? [Figure 6-41](ch06.xhtml#ch06fig41) shows the Fourier
    transform of our reconstructed sine wave from [Figure 6-34](ch06.xhtml#ch06fig34).
    I didn’t completely specify everything in that figure, so let’s assume that it’s
    a 400 Hz sine wave sampled at 3 kHz.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这一切很重要？[图 6-41](ch06.xhtml#ch06fig41)展示了我们从[图 6-34](ch06.xhtml#ch06fig34)重建的正弦波的傅里叶变换。我在那个图中没有完全指定所有内容，所以我们假设它是一个
    400 Hz 的正弦波，以 3 kHz 采样。
- en: '![Image](../images/06fig41.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig41.jpg)'
- en: '*Figure 6-41: Reconstructed sine wave Fourier transform plot*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-41: 重建正弦波傅里叶变换图*'
- en: Note that the x-axis goes on to infinity with frequencies at every multiple
    of the sampling frequency, plus or minus the frequency of the sampled signal.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，x 轴延伸到无穷远，频率以采样频率的倍数为单位加减采样信号的频率。
- en: What happens if we take that reconstructed sine wave and apply a low-pass filter,
    as shown in [Figure 6-42](ch06.xhtml#ch06fig42)?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对那个重建的正弦波应用低通滤波器，如[图 6-42](ch06.xhtml#ch06fig42)所示，会发生什么呢？
- en: '![Image](../images/06fig42.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig42.jpg)'
- en: '*Figure 6-42: Low-pass filtered reconstructed sine wave Fourier transform plot*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-42: 低通滤波的重建正弦波傅里叶变换图*'
- en: All the distortion disappears; what’s left is our 400 Hz sine wave. It appears
    that sampling works, as long as we have appropriate filtering. How do we choose
    a sample rate and filter?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的失真消失了；剩下的就是我们的 400 Hz 正弦波。看起来采样是有效的，只要我们有适当的滤波。我们该如何选择采样率和滤波器呢？
- en: Harry Nyquist (1889–1976), a Swedish electronic engineer, came up with a theorem
    that says you have to sample at a rate at least twice the highest frequency if
    you want to be able to faithfully capture the signal. It’s a nice theory, but
    because electronics doesn’t follow ideal mathematics, it helps to sample faster
    than that in order to have the result sound good. The human hearing range is something
    like 20 to 20,000 Hz.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 哈里·奈奎斯特（1889–1976），一位瑞典电子工程师，提出了一个定理，认为如果你想准确捕捉信号，必须至少以最高频率的两倍速率进行采样。这是一个很好的理论，但由于电子学并不遵循理想数学，所以最好以更快的速度采样，这样结果听起来才好。人类的听觉范围大约是
    20 到 20,000 Hz。
- en: Based on all that, we should be able to capture anything that we can hear with
    a 40 kHz sampling rate. What if we accidentally get a 21 kHz sound, which is *undersampled*
    according to Nyquist’s theorem? In that case, we get *folding* or *aliasing*.
    Imagine that the sampling frequency is a mirror and any information greater than
    that frequency is reflected. Looking back at [Figure 6-41](ch06.xhtml#ch06fig41),
    you can see that there are *artifacts* at the sampling frequency plus or minus
    the sampled frequency. Because the sampling frequency is much greater than the
    sampled frequency, these artifacts are far away. A 21 kHz input sampled at 40
    kHz would produce an artifact at 19 kHz (40–21). This false signal is called an
    *alias*. We don’t get out what we put in. A low-pass filter must be applied before
    sampling to avoid aliasing.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些，我们应该能够以 40 kHz 的采样率捕捉到我们能听到的任何声音。如果我们不小心获得了 21 kHz 的声音，根据奈奎斯特定理，这属于*欠采样*。在这种情况下，我们会得到*折叠*或*混叠*。假设采样频率是一面镜子，任何超过该频率的信息都会被反射。回到[图
    6-41](ch06.xhtml#ch06fig41)，你可以看到在采样频率的正负范围内存在*伪影*。由于采样频率远大于被采样频率，这些伪影距离很远。一个
    21 kHz 的输入以 40 kHz 采样会产生一个 19 kHz 的伪影（40–21）。这个错误信号被称为*混叠*。我们得到的输出与输入不一致。为了避免混叠，必须在采样之前应用低通滤波器。
- en: Compact discs take 16-bit samples at 44,100 Hz—times 2, of course, because it’s
    stereo. That produces a little more than 175KB/second. That’s a lot of data. Some
    standard audio-sampling rates are 44.1 kHz, 48 kHz, 96 kHz, and 192 kHz. Why would
    we bother to sample at the higher rates, since doing so would generate a lot more
    data and Nyquist says it’s not necessary?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩光盘以 44,100 Hz 的采样率采集 16 位样本——当然，是双倍采样，因为是立体声。这样每秒产生超过 175KB 的数据。这是大量的数据。一些标准的音频采样率包括
    44.1 kHz、48 kHz、96 kHz 和 192 kHz。既然采样率越高产生的数据就越多，而奈奎斯特定理认为没有必要这样做，那我们为什么还要使用更高的采样率呢？
- en: Although the frequency and amplitude of a signal sampled near the Nyquist rate
    can be reconstructed, the *phase* cannot. Another new term! Think of the phase
    as a small shifting in time. You can see in [Figure 6-43](ch06.xhtml#ch06fig43)
    that the fatter signal *lags* (as opposed to *leads*) the skinnier signal by 45
    degrees, making it slightly later in time.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以重建接近奈奎斯特频率的信号的频率和振幅，但*相位*是无法重建的。又一个新词！把相位看作是时间上的微小偏移。你可以在[图 6-43](ch06.xhtml#ch06fig43)中看到，较胖的信号相对于较细的信号*滞后*
    45 度（而不是*提前*），使得它稍微滞后一些。
- en: '![Image](../images/06fig43.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig43.jpg)'
- en: '*Figure 6-43: Phase difference in signals*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-43：信号的相位差*'
- en: Why does this matter? Well, it doesn’t except for stereo. The *phase difference*
    causes a time delay between a signal hitting your left and right ears that tells
    you where it is in space, as illustrated in [Figure 6-44](ch06.xhtml#ch06fig44).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要呢？嗯，除了立体声外，它并不重要。*相位差*在信号到达你左右耳之间造成了时间延迟，从而帮助你判断声音在空间中的位置，如[图 6-44](ch06.xhtml#ch06fig44)所示。
- en: '![Image](../images/06fig44.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig44.jpg)'
- en: '*Figure 6-44: Phase difference in real life*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-44：现实生活中的相位差*'
- en: 'You do a better job with high frequencies because they have shorter wavelengths
    relative to the thickness of your head. If your head were so narrow that your
    ears were in the same place, then there would be no time delay. Fat-headed people
    get better stereo! That’s one of the reasons why you can get away with a single
    subwoofer: you can’t really tell where the sound is coming from because the wavelength
    is so long compared to the thickness of your head that the phase difference is
    undetectable.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 高频信号能更好地处理，因为它们的波长相对于头部的厚度较短。如果你的头部狭窄到耳朵位置相同，那么就不会有时间延迟。大脑袋的人更适合听立体声！这也是你能只用一个低音炮的原因之一：因为波长相比头部厚度较长，导致相位差无法被感知，你无法准确判断声音来自哪里。
- en: When you’re listening to stereo sound, the phase difference between sounds coming
    out of the speakers creates the *image*, the ability to “see” where the musicians
    are in space. The image is “muddy” without accurate phase. Thus, the rationale
    for higher sampling rates is better reproduction of phase and stereo imaging.
    You may never notice this if your listening experience involves cheap earbuds
    on a cell phone.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当你听立体声音时，扬声器发出的声音之间的相位差产生了*图像*，也就是能“看到”音乐人在空间中的位置。如果没有准确的相位，图像就会变得“模糊”。因此，更高采样率的理论基础是更好的相位和立体声图像重现。如果你的听音体验是用手机上的廉价耳塞来实现的，你可能永远不会注意到这一点。
- en: SAMPLING AND FILTERING FOR FM STEREO
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: FM 立体声的采样与滤波
- en: FM stereo is an interesting application of sampling and filtering. It’s also
    a great example of how new functionality was wedged into a system that was never
    designed for it in a backward-compatible way, meaning that the old system still
    worked fine.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: FM立体声是采样和滤波的一个有趣应用。它也是一个很好的例子，展示了如何将新功能嵌入一个原本没有为此设计的系统中，同时保持向后兼容性，也就是说，旧系统仍然能够正常工作。
- en: Back in [Figure 6-20](ch06.xhtml#ch06fig20), you saw how bits could be used
    to modulate a frequency. FM stands for *frequency modulation*. FM radio works
    by modulating a carrier frequency by an analog signal instead of a digital one.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-20](ch06.xhtml#ch06fig20)中，你看到了如何利用比特来调制频率。FM代表*频率调制*。FM广播通过模拟信号而不是数字信号调制载波频率。
- en: Carrier frequencies for FM radio stations are allocated every 100 kHz. You saw
    in [Figure 6-41](ch06.xhtml#ch06fig41) that sampling generates additional frequencies
    up to infinity; the same thing happens with modulation. As a result, a low-pass
    filter has to be applied to the modulated signal or there will be interference
    with other stations. You saw filter rolloff in [Figure 6-39](ch06.xhtml#ch06fig39).
    The steeper the rolloff, the more the filter perturbs the phase, which has a negative
    effect on the sound. This is shown in part of the radio spectrum in [Figure 6-45](ch06.xhtml#ch06fig45).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: FM广播电台的载波频率每100 kHz分配一次。你在[图6-41](ch06.xhtml#ch06fig41)中看到过，采样会生成额外的频率，直到无限大；调制也会发生同样的情况。因此，必须对调制信号应用低通滤波器，否则会与其他电台发生干扰。你在[图6-39](ch06.xhtml#ch06fig39)中看到了滤波器的衰减。衰减越陡峭，滤波器对相位的干扰越大，这对声音有负面影响。这在[图6-45](ch06.xhtml#ch06fig45)中的一部分无线电频谱中得到了体现。
- en: '![Image](../images/06fig45.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig45.jpg)'
- en: '*Figure 6-45: Radio spectrum*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-45：无线电频谱*'
- en: Before stereo, the audio information in a monaural FM signal occupied approximately
    15 kHz above the carrier frequency. A receiver removed the carrier, resulting
    in the original audio. This characteristic had to be preserved in the move to
    stereo; otherwise, all existing receivers would have stopped working.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在立体声出现之前，单声道FM信号中的音频信息占据了载波频率之上的大约15 kHz。接收器移除了载波，恢复了原始音频。这个特性在向立体声过渡时必须保留，否则所有现有接收器将无法工作。
- en: '[Figure 6-46](ch06.xhtml#ch06fig46) gives an overview of how FM stereo works.
    A 38 kHz square wave is used to take alternate samples of the left and right channels.
    A 19 kHz pilot tone is generated that’s synchronized with the sampling square
    wave. The pilot tone is mixed at a low level that’s hard to hear over music and
    combined with the samples to make a composite signal that’s broadcast.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-46](ch06.xhtml#ch06fig46)概述了FM立体声的工作原理。使用38 kHz方波来交替采样左、右声道。生成一个19 kHz的引导音，与采样方波同步。引导音的混合级别很低，几乎无法在音乐中听到，并与样本信号合成，形成复合信号进行广播。'
- en: '![Image](../images/06fig46.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig46.jpg)'
- en: '*Figure 6-46: FM signal generation*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-46：FM信号生成*'
- en: The clever part is that if we look at the Fourier analysis result in [Figure
    6-47](ch06.xhtml#ch06fig47), the first set of frequencies on the left is the sum
    of the left and right channels—just what we want for mono. Not a problem for old
    receivers. The next set of frequencies is the difference between the left and
    right channels, which would not be picked up on an old mono receiver. However,
    a stereo receiver can use some simple arithmetic to separate out the left and
    right channels producing stereo.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明之处在于，如果我们查看[图6-47](ch06.xhtml#ch06fig47)中的傅里叶分析结果，左侧的第一组频率是左声道和右声道的总和——这正是我们所需要的单声道效果。对于旧接收器没有问题。接下来的频率组是左声道和右声道之间的差异，这些差异不会被旧的单声道接收器接收。然而，立体声接收器可以利用简单的算术将左、右声道分开，从而产生立体声。
- en: '![Image](../images/06fig47.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig47.jpg)'
- en: '*Figure 6-47: FM stereo spectrum*'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-47：FM立体声频谱*'
- en: 'I mentioned earlier that audio involves a lot of data. It would be nice to
    be able to compress that data so that it takes up less space. There are two classes
    of compression: *lossless* and *lossy*. Lossless compression preserves all the
    original data. As a result, it can compress things only to about half of their
    original size. The most popular lossless compression today is *FLAC*, short for
    *Free Lossless Audio Codec*. A *codec* is a coder-decoder, which is sort of like
    a modem that knows how to translate things from one coding system to another.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，音频涉及大量数据。如果能够压缩这些数据，让它占用更少的空间，那就太好了。压缩有两种类别：*无损压缩*和*有损压缩*。无损压缩保留所有原始数据。因此，它只能将数据压缩到原始大小的约一半。目前最流行的无损压缩格式是*FLAC*，即*自由无损音频编码*。*编码器-解码器*（*codec*）类似于一种调制解调器，能够将一种编码系统的内容转换为另一种编码系统。
- en: '*MP3*, *AAC*, *Ogg*, and their ilk are lossy compression codecs. Some fidelity
    is lost. They work on psychoacoustic principles. People who have studied the workings
    of the ear and brain have decided that there are certain things that you can’t
    hear, like something quiet that happens right after a loud drum beat. These codecs
    work by removing these sounds, and that gives them a much better compression ratio
    than FLAC. But not everybody’s ears are the same. I think MP3s sound horrible.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*MP3*、*AAC*、*Ogg*及类似格式是有损压缩编解码器。一些音质会丢失。它们基于心理声学原理。研究耳朵和大脑工作机制的人们认为，有些声音是无法听到的，比如在大鼓一击后发生的微弱声音。这些编解码器通过去除这些声音来工作，这使得它们比
    FLAC 具有更好的压缩比。但并不是每个人的听力都一样。我认为 MP3 的音质很糟糕。'
- en: '***Digital Images***'
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字图像***'
- en: Visual images are more complicated than audio because we need to sample a two-dimensional
    space. Digital images are represented as rectangular arrays of picture elements,
    or *pixels*. Each pixel in a color image is a triad of red, green, and blue lights.
    Common displays available today have 8 bits each of red, green, and blue. We saw
    a commonly used representation back in [Figure 1-20](ch01.xhtml#ch01fig20).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图像比音频更复杂，因为我们需要对二维空间进行采样。数字图像通过矩形阵列的像素（*pixels*）来表示。每个彩色图像的像素由红、绿、蓝三种光组成。如今常见的显示器每种颜色有
    8 位。我们在[图 1-20](ch01.xhtml#ch01fig20)中看到过一种常用的表示方式。
- en: Computer displays use the *additive* color system, which can produce almost
    any color by combining (or adding, hence the name) different amounts of the red,
    green, and blue *primaries*. This differs from the *subtractive* color system
    used for printing, which makes colors by mixing different amounts of the cyan,
    magenta, and yellow primaries.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机显示器使用*加法*色彩系统，通过组合（或加法，因此得名）红、绿和蓝三种*基色*，几乎可以产生任何颜色。这与用于印刷的*减法*色彩系统不同，后者通过混合不同量的青色、品红和黄色基色来生成颜色。
- en: Sampling an image is akin to placing a window screen over the image and recording
    the color in each square. It’s somewhat more complicated because of *point sampling*,
    which means we don’t record the entire square, just a point in the center of each
    one. [Figure 6-48](ch06.xhtml#ch06fig48) shows an image sampled using three screens
    of different resolutions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对图像进行采样就像在图像上放一块窗户网，并记录每个方格中的颜色。由于*点采样*的存在，这个过程稍微复杂一些，意味着我们并不记录整个方格，只记录每个方格中心的一个点。[图
    6-48](ch06.xhtml#ch06fig48)展示了使用三种不同分辨率的屏幕进行采样的图像。
- en: '![Image](../images/06fig48.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig48.jpg)'
- en: '*Figure 6-48: Sampling an image at different resolutions*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-48：以不同分辨率采样图像*'
- en: You can see that the sampled image looks better with finer, higher-resolution
    screens, but of course that greatly increases the amount of data. Even with a
    high-resolution screen, however, we still get jaggy edges. This is due to undersampling
    and aliasing as per Nyquist, although the math for it is too advanced for this
    book. As with audio, maybe filtering helps. One way we can filter is by *supersampling*,
    or taking multiple samples per square and averaging them together, as shown in
    [Figure 6-49](ch06.xhtml#ch06fig49).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，使用更精细、更高分辨率的屏幕，采样后的图像看起来更好，但这当然会大大增加数据量。然而，即使是高分辨率的屏幕，我们仍然会看到锯齿状的边缘。这是由于欠采样和混叠现象所致，按照奈奎斯特定理，尽管这个数学原理对于本书来说过于复杂。就像音频一样，或许过滤可以有所帮助。我们可以通过*超采样*来进行过滤，即每个方格进行多次采样并将其平均，如[图
    6-49](ch06.xhtml#ch06fig49)所示。
- en: '![Image](../images/06fig49.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig49.jpg)'
- en: '*Figure 6-49: Supersampling*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-49：超采样*'
- en: This doesn’t look great all blown up, but if you hold it far away from your
    face, you’ll see that it doesn’t look too bad. If you think about it, supersampling
    is equivalent to upping the sampling rate, as we saw for audio in [Figure 6-35](ch06.xhtml#ch06fig35).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果把它放大来看并不太好，但如果把它从脸部远离一些，你会发现它看起来不那么糟糕。如果你仔细想想，超采样相当于提高采样率，就像我们在[图 6-35](ch06.xhtml#ch06fig35)中看到的音频一样。
- en: Images are getting bigger and bigger and take up a lot of space. It’s not clear
    if enough storage will ever exist for the world’s cat photos and videos. As with
    audio, we’d like images to take less space so we can fit more of them in the same
    amount of memory and so they’re faster to transmit over a network. This is addressed,
    once again, by compression.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图像越来越大，占用了大量空间。目前尚不清楚是否会有足够的存储来容纳全球的猫咪照片和视频。与音频类似，我们希望图像占用更少的空间，这样就能在相同的内存中存储更多图像，并且它们通过网络传输时也会更快。这一问题通过压缩再次得以解决。
- en: The most common image compression right now is *JPEG*, a standard by the Joint
    Photographic Experts Group. It involves a lot of mathematical heavy lifting that
    I’m not going to cover here. A rough approximation of how JPEG works is that it
    looks for adjacent pixels that are pretty close to the same color and stores a
    description of that area instead of the individual pixels that it contains. You
    may have a camera that includes an image quality setting; this setting adjusts
    the definition of “pretty close.” It’s a color version of our example from “[Stacks](ch05.xhtml#ch05lev1sec3)”
    on [page 122](ch05.xhtml#page_122).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最常见的图像压缩格式是*JPEG*，这是由联合图像专家组制定的标准。它涉及大量复杂的数学运算，这里我不打算详细讨论。JPEG的工作原理粗略地说，就是它会寻找相邻像素的颜色非常接近的区域，并存储该区域的描述，而不是存储这些像素本身。你可能会发现相机有一个图像质量设置；该设置会调整“非常接近”这个定义的标准。这是我们在[《堆栈》](ch05.xhtml#ch05lev1sec3)中示例的颜色版本，出现在[第122页](ch05.xhtml#page_122)。
- en: JPEG uses knowledge about human perception in a manner similar to lossy audio
    codecs. For example, it takes advantage of the fact that our brains are more sensitive
    to changes in brightness than to changes in color.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG使用关于人类感知的知识，方式与有损音频编解码器类似。例如，它利用了我们的大脑对亮度变化比对颜色变化更敏感的事实。
- en: '***Video***'
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***视频***'
- en: Yet another step up in multidimensional space, video is a sequence of two-dimensional
    images sampled at regular time intervals. The time interval is a function of the
    human visual system. Old movies got by with 24 frames per second (fps); the average
    person today is pretty happy with 48 fps.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在多维空间中的又一步，视频是一系列按固定时间间隔采样的二维图像。时间间隔是根据人类视觉系统的需求来确定的。旧电影每秒24帧（fps）就能勉强应付；如今大多数人对于每秒48帧的视频已经相当满意。
- en: Sampling video isn’t much different than sampling images, except that different
    artifacts are visually annoying and therefore need to be minimized. The problem
    is that the sampling artifacts along edges, which we saw in [Figure 6-48](ch06.xhtml#ch06fig48),
    don’t stay still when objects are moving.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 采样视频与采样图像没有太大区别，唯一的不同是不同的伪影在视觉上令人不悦，因此需要尽量减少。问题在于沿边缘的采样伪影，如我们在[图 6-48](ch06.xhtml#ch06fig48)中看到的那样，当物体移动时，这些伪影并不会静止。
- en: To understand this better, take a look at [Figure 6-50](ch06.xhtml#ch06fig50),
    which shows a diagonal line that is moving from left to right over time. It’s
    only moving a fraction of a pixel per frame, which means it doesn’t get sampled
    the same every time. It still looks like an approximation of a line, but each
    one is a different approximation. This makes edges “swim,” which is visually disturbing.
    Filtering using supersampling is one way to reduce such unpleasant visual artifacts.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，看看[图 6-50](ch06.xhtml#ch06fig50)，它展示了一条对角线随时间从左到右移动。它每帧只移动一个像素的极小部分，这意味着它每次的采样结果都不完全相同。它看起来依然像是线的近似，但每一条都是不同的近似。这使得边缘看起来在“游动”，视觉上令人困扰。使用超采样进行滤波是减少这种不愉快视觉伪影的一种方式。
- en: '![Image](../images/06fig50.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig50.jpg)'
- en: '*Figure 6-50: Swimming edges*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-50：游动的边缘*'
- en: Video produces a lot more data than images or audio. UHD video has a resolution
    of 3,840×2,160 pixels. Multiply that by 3 bytes per pixel and 60 frames per second,
    and you end up with a whopping 1,492,992,000 bytes per second! Obviously compression
    is very important.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 视频产生的数据量远远超过图像或音频。超高清（UHD）视频的分辨率为3,840×2,160像素。乘以每个像素3个字节，再乘以每秒60帧，你得到的结果是每秒1,492,992,000字节！显然，压缩非常重要。
- en: The observation that only part of the image normally changes from frame to frame
    is the key to video compression. Look at [Figure 6-51](ch06.xhtml#ch06fig51),
    in which Mr. Sigma is on his way to pick up a package.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 帧与帧之间通常只有部分图像发生变化的观察结果是视频压缩的关键。看一下[图6-51](ch06.xhtml#ch06fig51)，其中西格玛先生正前往取包裹的路上。
- en: '![Image](../images/06fig51.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig51.jpg)'
- en: '*Figure 6-51: Interframe motion*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-51：帧间运动*'
- en: As you can see, very little of the image changes between frames. Much less data
    needs to be stored or transmitted if we only need the data from the area of change.
    This technique is called *motion compression*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，帧与帧之间的图像变化非常少。如果我们只需要变更区域的数据，所需存储或传输的数据将大大减少。这种技术称为*运动压缩*。
- en: One of the problems with representing video as a set of changes from an original
    image is that sometimes data can get garbled. You’ve probably seen some blocky
    artifacts on digital TV or when playing a damaged video disc.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 将视频表示为从原始图像的变化集合有一个问题，那就是有时数据会被损坏。你可能在数字电视或播放损坏的视频光盘时见过一些块状伪影。
- en: We need some way to recover the data. This is done by regularly including *keyframes*
    in the data. A keyframe is a complete image, so even if damage accumulates due
    to corrupted change data, recovery takes place when the next keyframe is encountered.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来恢复数据。这是通过定期在数据中包含*关键帧*来实现的。关键帧是完整的图像，因此即使由于损坏的变更数据导致积累了损坏，当遇到下一个关键帧时，恢复过程也会发生。
- en: The algorithms to detect differences between frames are complicated and very
    compute intensive. Newer compression standards such as MPEG4 include support for
    *layering*, which takes advantage of the fact that a lot of video is now computer
    generated. Layering works just like the old hand-drawn cel animation that we discussed
    in [Chapter 1](ch01.xhtml#ch01), where objects painted on transparencies were
    moved over a stationary background image.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 检测帧之间差异的算法非常复杂且计算密集。像MPEG4这样的新压缩标准支持*分层*，这利用了这样一个事实：如今许多视频是计算机生成的。分层就像我们在[第1章](ch01.xhtml#ch01)讨论过的传统手绘动画，透明纸上画的物体被移到静态的背景图像上。
- en: '**Human Interface Devices**'
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**人机接口设备**'
- en: Computers are a lot like teenagers with cell phones. They spend most of their
    time messaging each other but occasionally have time to talk to people. This section
    covers some of how computers interact with people.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机很像拿着手机的青少年。它们大部分时间都在互相发消息，但偶尔也有时间与人交流。本节内容涵盖了计算机与人互动的某些方式。
- en: '***Terminals***'
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***终端***'
- en: Not that long ago, the keyboard, mouse, and display or touchscreen you’re so
    used to were unimaginable luxuries.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，你习惯使用的键盘、鼠标、显示器或触摸屏曾是不可想象的奢侈品。
- en: There was a time when the way you interacted with a computer was to write a
    program or data down on paper using special coding forms. You’d hand those to
    someone who would use a keypunch to turn the forms into a stack of punched cards
    (refer back [Figure 3-25](ch03.xhtml#ch03fig25)). You’d take those cards, being
    careful not to drop them, and give them to a computer operator who would put them
    into a card reader, which would read them into the computer and run the program.
    This approach, known as *batch processing*, was used because computers were really
    slow and expensive, making computer time really valuable, so while your cards
    were being punched, somebody else’s program was being run.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，你与计算机的交互方式是将程序或数据写在纸上，使用特殊的编码表单。你会把这些交给别人，别人会用打孔机将这些表单转化成一堆穿孔卡片（参见[图3-25](ch03.xhtml#ch03fig25)）。你小心地拿着这些卡片，确保不要掉落，然后交给计算机操作员，操作员将它们放入卡片读取器，读取器会将卡片内容读入计算机并运行程序。这种方法被称为*批处理*，之所以使用它，是因为计算机速度非常慢且昂贵，使得计算机时间非常宝贵，因此在你打卡片的时候，其他人的程序也在运行。
- en: Computers got faster, smaller, and cheaper. By the late 1960s, it was possible
    to have a small computer for your company or department. Small as an RV. Computer
    time became a bit less scarce. The obvious thing happened, which is that people
    started hooking them up to *teletypes*. Teletypes were called *terminals* because
    they were at the end of the line. A particularly popular model, the Teletype ASR-33,
    had a keyboard, printer, paper tape ([Figure 3-26](ch03.xhtml#ch03fig26)) punch,
    and a paper tape reader. The paper tape was the equivalent of a USB memory stick.
    An ASR-33 was good for a jaw-dropping *10 characters per second*! The term tty
    is still with us today as an abbreviation for teletype.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机变得更快、更小、更便宜。到了1960年代末期，企业或部门可以拥有一台小型计算机。它小得像一辆房车。计算机时间变得不那么稀缺。显而易见的事情发生了，人们开始将它们连接到*电传打字机*上。电传打字机被称为*终端*，因为它们位于线路的末端。一款特别受欢迎的型号，Teletype
    ASR-33，配有键盘、打印机、纸带([Figure 3-26](ch03.xhtml#ch03fig26))打孔机和纸带阅读器。纸带相当于一个USB记忆棒。ASR-33的速度令人吃惊，能够达到*每秒10个字符*！tty这个术语至今仍在使用，代表电传打字机。
- en: '*Time-sharing* systems were invented to keep these smaller computers busy.
    Yes, they really were like time-share vacation rentals. You can pretend that it’s
    your place, and it *is* your place while you’re there, but other people use it
    when it’s not your turn.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*分时*系统的发明就是为了让这些小型计算机保持忙碌。是的，它们真的像分时度假租赁。你可以假装它是你的地方，在你使用时它确实是你的，但当轮到别人时，他们也会使用它。'
- en: A time-sharing system has an *operating system* program that runs on the computer.
    The OS program is like the booking agent for a time-share rental. Its job is to
    allocate the various resources of the computer to each user. When it was your
    turn to use the machine, the other user’s programs would get swapped out to disk,
    and yours would be loaded into memory and would run for a while. This all happened
    fast enough that you’d think that you had the machine to yourself, at least until
    things got busy. At some point, things would start to *thrash*, as the operating
    system spent more time swapping things in and out than it did running users’ programs.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 分时系统有一个*操作系统*程序在计算机上运行。操作系统程序就像分时租赁的预定代理人。它的工作是将计算机的各种资源分配给每个用户。当轮到你使用计算机时，其他用户的程序会被交换到磁盘上，而你的程序会被加载到内存中并运行一段时间。所有这些操作发生得足够快，你会觉得自己拥有了计算机，至少在事情变得忙碌之前是这样。到了某个时刻，操作系统会花费更多的时间在交换数据而不是运行用户程序上，情况开始变得*抖动*。
- en: Thrashing made time-sharing systems pretty slow when there were a lot of users.
    Programmers started working late at night because they could have the machines
    to themselves after everybody else went home.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户数量很多时，抖动（Thrashing）使得分时系统的运行变得相当缓慢。程序员开始在深夜工作，因为在其他人都下班后，他们可以独占计算机资源。
- en: Time-sharing systems are *multitasking* in that the computer is presenting the
    illusion that it’s doing more than one thing at a time. All of a sudden, lots
    of terminals were connected to the same machine. And the concept of a *user* appeared
    so that machines could tell what belonged to whom.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 分时系统是*多任务*的，因为计算机给人一种它同时做多件事情的错觉。突然间，许多终端连接到了同一台计算机上。于是出现了*用户*的概念，计算机可以知道哪些资源属于谁。
- en: Time marched on, and better versions of teletype-like things appeared, and each
    generation was faster and quieter. But they were still printing things on paper,
    or *hard copy*. And they were pretty much only good for text. The Teletype model
    37 added Greek characters so that scientists could print math. IBM Selectric terminals
    had interchangeable *typeballs* that allowed the user to change fonts. This included
    a font with dots in different positions that enabled graph drawing.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 时间推移，类似电传打字机的更好版本出现了，每一代都更快、更安静。但它们仍然是在纸上打印东西，或者*硬拷贝*。而且它们基本上只适合用于文本打印。Teletype
    37型增加了希腊字符，以便科学家打印数学公式。IBM Selectric终端具有可互换的*键球*，允许用户更换字体。包括一种带有不同位置点阵的字体，能够绘制图表。
- en: '***Graphics Terminals***'
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***图形终端***'
- en: There were a lot of reasons to move away from hard-copy terminals, including
    speed, reliability, and noise. Screens existed for things like radar and television;
    it was time to make them work with computers. This happened slowly due to the
    evolution of electronics. Memory was just too expensive and slow.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 移开硬拷贝终端有很多原因，包括速度、可靠性和噪音。屏幕已经存在于雷达和电视等设备上；现在是时候让它们与计算机一起工作了。由于电子技术的不断发展，这一过程进展缓慢，因为内存当时既昂贵又慢。
- en: Graphics terminals were originally built around a variation of the vacuum tube
    (see “[Vacuum Tubes](ch02.xhtml#ch02lev2sec9)” on [page 50](ch02.xhtml#page_50))
    called a *cathode ray tube (CRT)*. The inside of the glass is coated with a chemical
    phosphor, which glows when it’s hit by electrons. By having more than one grid
    or *deflection plate*, it’s possible to draw pictures on the phosphor. It’s like
    having a really talented batter who can hit any target with a ball.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图形终端最初是围绕一种真空管的变种构建的（参见“[真空管](ch02.xhtml#ch02lev2sec9)”第[50页](ch02.xhtml#page_50)），这种变种被称为*阴极射线管（CRT）*。玻璃内部涂有化学磷光体，当电子射线击中它时会发光。通过使用多个网格或*偏转板*，就可以在磷光体上绘制图像。这就像是拥有一个非常有才华的击球手，能够用球击中任何目标。
- en: There are actually two ways to make this display work. The deflection plate
    version, called *electrostatic deflection*, uses the same principle that gives
    you the dreaded static cling. The other option is the electromagnet version, called
    *electromagnetic deflection*. In either case, bits need to be translated into
    voltages, which is yet another application for our D/A building block.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 其实有两种方式可以让这个显示工作。偏转板版本，叫做*静电偏转*，使用与让你讨厌的静电吸附相同的原理。另一种选择是电磁版本，叫做*电磁偏转*。无论哪种方式，信息都需要转换成电压，这又是我们D/A构建模块的一个应用。
- en: Today the CRT is mostly a relic that has been replaced by the *liquid crystal
    display (LCD)*. Liquid crystals are substances that can change their light transmission
    properties when electricity is applied. A typical flat-screen display is much
    like a CRT in that there are three blobs of liquid crystal at every raster point
    with red, green, and blue filters and a light that shines through from the back.
    We still talk to LCD devices as if they’re CRTs, but that’s just a historical
    artifact. LCDs are now ubiquitous and have replaced CRTs in most applications;
    LCDs have made cell phones, laptops, and flat-screen TVs possible.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，CRT大多已经成为遗物，被*液晶显示（LCD）*所取代。液晶是能够在施加电压时改变其光传输特性的物质。典型的平面显示屏与CRT非常相似，在每个光栅点上都有三块液晶，分别带有红色、绿色和蓝色滤光片，并且背面有光源通过它们照射。我们仍然像对待CRT那样与LCD设备沟通，但这仅仅是历史遗物。LCD现在无处不在，并且已经取代了大多数应用中的CRT；LCD使得手机、笔记本电脑和平板电视成为可能。
- en: Early screen-based terminals were called *glass ttys* because they could display
    only text. These terminals displayed 24 rows of 80 characters each, for a total
    of 1,920 characters. Since a character fit into a byte, that was less than 2 KiB
    of memory, which was affordable at the time. Over time, more features got added,
    such as on-screen editing and cursor motion, which were eventually standardized
    as part of ANSI X3.64.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的基于屏幕的终端被称为*玻璃tty*，因为它们只能显示文本。这些终端显示24行，每行80个字符，总共1,920个字符。由于每个字符占用一个字节，这相当于不到2
    KiB的内存，在当时是可以负担得起的。随着时间的推移，增加了更多的功能，如屏幕编辑和光标移动，这些功能最终被标准化为ANSI X3.64的一部分。
- en: '***Vector Graphics***'
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***矢量图形***'
- en: A CRT works pretty much like a piece of graph paper. An electron beam moves
    to some point based on the x- and y-axis voltages. There’s also a z-axis that
    determines the brightness. Originally there was no color, so these were black-and-white,
    or *grayscale*, displays. The number of coordinate locations per inch is called
    the *resolution*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: CRT的工作原理非常像一张图表纸。电子束根据x轴和y轴的电压移动到某个点。还有一个z轴决定亮度。最初没有颜色，因此这些显示器是黑白的，或*灰度*显示。每英寸的坐标位置数被称为*分辨率*。
- en: '*Vector graphics* is all about drawing lines, or *vectors*. You make a picture
    by drawing a set of lines from here to there. The skinny arrows in [Figure 6-52](ch06.xhtml#ch06fig52)
    are drawn with the brightness all the way down or off.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '*矢量图形*完全是关于绘制线条，或*矢量*。你通过从这里到那里画一组线来制作一幅图。图6-52中的细箭头是通过将亮度调到最低或关闭来绘制的。'
- en: '![Image](../images/06fig52.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig52.jpg)'
- en: '*Figure 6-52: House of vector graphics*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-52：矢量图形的家*'
- en: The white arrow with the black outline is drawn twice, once with the brightness
    on and then again with the brightness off. Drawing the same line twice with the
    brightness on makes it twice as bright, which we don’t want to do just because
    we’re changing position.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 那个有黑色轮廓的白色箭头被画了两次，一次是亮度打开时，再次是亮度关闭时。亮度打开时画同一条线两次会使它变得更亮两倍，但我们并不希望仅仅因为改变位置就这样做。
- en: The house in [Figure 6-52](ch06.xhtml#ch06fig52) is drawn from a *display list*,
    which is a list of drawing instructions. It looks like [Figure 6-53](ch06.xhtml#ch06fig53).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-52](ch06.xhtml#ch06fig52)中的房子是从*显示列表*中绘制的，显示列表是绘图指令的列表。它看起来像[图 6-53](ch06.xhtml#ch06fig53)。'
- en: '![Image](../images/06fig53.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig53.jpg)'
- en: '*Figure 6-53: Display list*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-53: 显示列表*'
- en: Note the last instruction. We start over again because the image on the screen
    fades pretty quickly. This works only because of the *persistence* of the CRT
    phosphor, which is how long it stays lit once the beam moves away, and the slow
    response of the human eye. We have to keep doing this over and over to keep the
    image displayed on the screen.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一条指令。我们重新开始，因为屏幕上的图像会很快褪色。之所以能这样做，是因为CRT荧光粉的*持久性*，即当光束移开后，荧光粉能持续发光的时间，以及人眼的慢反应速度。我们必须不断重复这一过程，才能保持图像在屏幕上显示。
- en: There’s more to this instruction, however. There’s a lot of 60 Hz radiation
    around us because that’s the frequency of American alternating current electric
    power (it’s 50 Hz in some other countries). Despite our best attempts at shielding,
    this radiation affects our display and makes it wiggle. Thus, graphics terminals
    like the *GLANCE G* developed at Bell Telephone Laboratories had a “restart at
    step 1 after the next time the power line crosses 0 from the positive to the negative”
    instruction. This synchronized the drawing to the interference so that it always
    wiggled exactly the same and therefore wasn’t noticeable.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个指令还有更多内容。因为美国交流电的频率是60Hz（在一些国家是50Hz），所以我们周围有很多60Hz的辐射。尽管我们尽力屏蔽这些辐射，但它仍然影响我们的显示，使其产生波动。因此，像贝尔电话实验室开发的*GLANCE
    G*图形终端，具有“在下次电力线从正到负穿过0时，从第1步重新开始”的指令。这使得绘图与干扰同步，以便它总是以完全相同的方式波动，因此不易察觉。
- en: Drawing the image took time, a nasty side effect of which was that everything
    looked fine until the display list got long enough that it couldn’t be drawn in
    one-sixtieth of a second. It suddenly got very flickery when it drew only once
    every one-thirtieth of a second.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制图像需要时间，而一个不太好的副作用是，所有东西看起来都很好，直到显示列表变长，以至于它无法在1/60秒内完成绘制。当绘制每1/30秒一次时，它会突然变得非常闪烁。
- en: A company called Tektronix had an interesting solution to the flicker problem,
    called the *storage tube*. This was the electronic equivalent of an *Etch-a-Sketch*.
    You could draw very complicated images, but you had to electronically shake it
    up to erase it. It was very hard to draw solid images on a Glance G because it
    took huge numbers of vectors and ended up with display flicker. Storage tubes
    could handle solid images since there was no limit to the number of vectors, but
    the centers of the solid areas tended to fade. You could erase a single line on
    a Glance G by removing it from the display list. That wasn’t possible on a storage
    tube. It gave off a bright green flash when the screen was erased, which has been
    burned into many an aging programmer’s eyeballs.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 一家公司叫Tektronix，提出了一种有趣的解决闪烁问题的方法，称为*存储管*。这相当于电子版的*电子画板*。你可以绘制非常复杂的图像，但你必须通过电子方式摇晃它来擦除图像。由于需要大量的矢量，且会导致显示闪烁，在Glance
    G上绘制稳定的图像非常困难。存储管可以处理稳定图像，因为矢量数量没有限制，但实心区域的中心往往会褪色。在Glance G上，你可以通过从显示列表中删除单一的线条来擦除它。这在存储管上是不可能的。当屏幕被擦除时，存储管会发出明亮的绿色闪光，这已经被许多年老的程序员深深烙印在眼睛里。
- en: '***Raster Graphics***'
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***光栅图形***'
- en: '*Raster graphics* is a completely different approach than vector graphics.
    It’s how television originally worked. The raster is a continually drawn pattern,
    as shown in [Figure 6-54](ch06.xhtml#ch06fig54).'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*光栅图形*与矢量图形完全不同。这是电视最初的工作原理。光栅是一种持续绘制的图案，如[图 6-54](ch06.xhtml#ch06fig54)所示。'
- en: '![Image](../images/06fig54.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig54.jpg)'
- en: '*Figure 6-54: A raster*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-54: 光栅*'
- en: The raster starts at the upper left and goes across the screen. Then a *horizontal
    retrace* takes it down to the start of the next line. Finally, a *vertical retrace*
    takes it back to the beginning once the last line is drawn.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅从屏幕的左上角开始，沿着屏幕横向绘制。然后，*水平重绘*将其带回到下一行的起始位置。最后，*垂直重绘*在绘制完最后一行后将其带回到起始位置。
- en: This works very much like the starting-gun analogy I used earlier when discussing
    serial communications. Once the raster is off and running, all you have to do
    is to change the brightness at exactly the right time to get the image you want,
    as you can see in [Figure 6-55](ch06.xhtml#ch06fig55).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我在讨论串行通信时用的起跑枪类比非常相似。一旦光栅启动并运行，你所要做的就是在正确的时机调整亮度，就能得到你想要的图像，正如你在[图 6-55](ch06.xhtml#ch06fig55)中看到的那样。
- en: '![Image](../images/06fig55.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig55.jpg)'
- en: '*Figure 6-55: House of raster graphics*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-55: 光栅图形之家*'
- en: I also used the analogy of a window screen back in “[Digital Images](ch06.xhtml#ch06lev2sec17)”
    on [page 173](ch06.xhtml#page_173). A raster display is an *actual* screen, which
    means we can’t draw between the dots. This can result in unpleasant visual artifacts,
    such as the roof not looking quite right. That’s because the resolution of a typical
    raster display is fairly low—on the order of 100 dots per inch. The low resolution
    results in undersampling and aliasing similar to what we saw for digital images.
    Sufficient compute power now exists to make *anti-aliasing* commonplace using
    techniques such as supersampling.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在《[数字图像](ch06.xhtml#ch06lev2sec17)》中使用了窗纱的类比，在[第 173 页](ch06.xhtml#page_173)上提到过。光栅显示是一个*实际*的屏幕，这意味着我们不能在点与点之间进行绘制。这可能会导致不愉快的视觉伪影，例如屋顶看起来不太对劲。那是因为典型的光栅显示的分辨率相对较低——大约每英寸
    100 个点。低分辨率会导致欠采样和类似数字图像中的别名效应。现在，足够的计算能力使得使用超采样等技术让*抗锯齿*成为常见做法。
- en: Raster scanning is also used for things like fax machines, laser printers, and
    scanners. Pull up the lid of a scanner and watch it go. Wear sunglasses. Back
    when printers had more moving parts and were louder, people figured out how to
    play *raster music* on them by carefully choosing what to print.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅扫描也用于传真机、激光打印机和扫描仪等设备。打开扫描仪的盖子，看它的运作。记得戴上太阳镜。以前打印机有更多活动部件，声音也更大，人们通过精心选择打印内容，发明了如何在打印机上播放*光栅音乐*的技巧。
- en: Raster displays don’t use display lists, although display lists are still used
    behind raster displays. As we’ll see later, web pages are display lists. The OpenGL
    graphics language includes display lists, and support for the language is often
    included in graphics hardware. Monochrome displays use a piece of memory with
    1 bit for each position on the raster. This was a huge amount of memory back in
    the day; now, it’s not such a big deal. Of course, that memory could get big fast.
    If you wanted a raster display that could do 256 different levels of gray, you’d
    need 8 bits of memory for each raster position.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅显示器不使用显示列表，尽管显示列表仍然在光栅显示器的背后使用。正如我们稍后将看到的，网页就是显示列表。OpenGL图形语言包含显示列表，且通常在图形硬件中支持该语言。单色显示器使用一块内存，每个光栅位置对应
    1 位。这在当时是一个巨大的内存量；现在，它已经不算什么大事了。当然，这块内存也能快速变得非常大。如果你想要一个能够显示 256 种不同灰度的光栅显示，你就需要为每个光栅位置准备
    8 位内存。
- en: 'Color was discovered in the Land of Oz and quickly made it onto the screen.
    Monochrome or grayscale displays were easy: all you had to do was to coat the
    inside of the screen with a layer of phosphor. Color displays needed three different
    color dots at each location on the raster—red, green, and blue—and three electron
    beams that could hit these spots with great precision. This meant you needed three
    times the display memory for a typical display.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色是在奥兹国发现的，并迅速进入了屏幕显示。单色或灰度显示很简单：你只需要在屏幕内部涂上一层磷光物质。彩色显示需要每个位置上都有三种不同的颜色点——红色、绿色和蓝色——以及三束能够精准打击这些位置的电子束。这意味着你需要为一个典型的显示器准备三倍的显示内存。
- en: '***Keyboard and Mouse***'
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***键盘与鼠标***'
- en: Terminals have a way for you to input data in addition to the display that outputs
    data to you. You know them as the keyboard and mouse, the touchpad on your laptop,
    and the touchscreen on your phone and tablet.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 终端不仅有显示功能，还可以输入数据。你所知道的键盘和鼠标、笔记本上的触控板、手机和平板电脑上的触摸屏，都是其中的一部分。
- en: Keyboards are pretty easy. They’re just a bunch of switches and some logic.
    A common way to build a keyboard is to put the key switches on a grid, multiplexing
    them kind of like in [Figure 6-10](ch06.xhtml#ch06fig10). Power is sequentially
    applied to the rows of the grid, and the values of the columns are read out.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘相当简单。它们只是一些开关和一些逻辑。构建键盘的常见方式是将按键开关放置在一个网格上，通过多路复用的方式进行操作，就像在[图 6-10](ch06.xhtml#ch06fig10)中那样。电源依次施加到网格的行上，列的值被读取出来。
- en: The mouse as we know it was invented by American engineer Douglas Engelbart
    (1925–2013) at the Stanford Research Institute. I mentioned in “[Quadrature](ch06.xhtml#ch06lev2sec7)”
    on [page 150](ch06.xhtml#page_150) that you can make a mouse using a pair of quadrature
    encoders, one each for the *x* and *y* directions.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所知道的鼠标是由美国工程师道格拉斯·恩格尔巴特（1925-2013）在斯坦福研究所发明的。我在“[正交](ch06.xhtml#ch06lev2sec7)”中提到过，在[第150页](ch06.xhtml#page_150)，你可以使用一对正交编码器来制作鼠标，每个编码器分别用于
    *x* 和 *y* 方向。
- en: There are a lot of touchpad and touchscreen technologies. The main difference
    is that touchscreens have to be transparent so that the display can be seen. Touch
    devices are row- and column-scanning devices, like keyboards but on a much finer
    scale.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多触摸板和触摸屏技术。主要区别在于，触摸屏必须是透明的，以便显示内容可以被看到。触摸设备是行列扫描设备，就像键盘一样，只是规模要精细得多。
- en: '**Summary**'
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned about the interrupt system that allows processors
    to handle I/O efficiently. We talked about how various types of I/O devices work
    and how they interact with computers. We also discussed the complex area of sampling
    analog data so that it can be processed using digital computers. At this point,
    you know enough about how computers work, so starting with the next chapter, we’ll
    look at the relationship between hardware and software with the goal of learning
    how to write software that runs well on the hardware.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了中断系统，它允许处理器高效地处理输入/输出操作。我们讨论了各种类型的输入/输出设备如何工作以及它们如何与计算机互动。我们还讨论了采样模拟数据这一复杂领域，以便它可以通过数字计算机进行处理。到此为止，你已经了解了足够的计算机工作原理，因此从下一章开始，我们将探讨硬件与软件之间的关系，目的是学习如何编写在硬件上运行良好的软件。
