- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: 'Bench Time: Simple Power Analysis'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面时间：简单的功率分析
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we’ll introduce a simple laboratory environment that allows
    you to experiment with some code samples. Rather than attack devices we know nothing
    about, we’ll start attacking real devices we have on hand in our lab with specific
    algorithms of our choosing. This practice will allow us to gain experience on
    these kinds of attacks rather than having to do a lot of guessing of what a “closed”
    device is up to. First, we’ll walk through the generics of building the simple
    power analysis (SPA) setup, and then we’ll program an Arduino with an SPA-vulnerable
    password verification and see whether we can extract the password. Finally, we’ll
    perform the same experiment with the ChipWhisperer-Nano. Consider this chapter
    to be like cracking your knuckles to warm up before actually playing the piano.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一个简单的实验室环境，允许你尝试一些代码样本。我们不会攻击那些我们一无所知的设备，而是从实验室里已有的真实设备开始，使用我们选择的特定算法进行攻击。这个实践将帮助我们积累对这些类型攻击的经验，而不必去猜测“封闭”设备的行为。首先，我们将介绍如何搭建简单的功率分析（SPA）实验环境，然后我们会为Arduino编程一个具有SPA漏洞的密码验证程序，看看能否提取出密码。最后，我们将使用ChipWhisperer-Nano进行同样的实验。可以将本章视为在真正演奏钢琴之前热身的练习。
- en: The Home Lab
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 家庭实验室
- en: To build a simple SPA lab, you need a tool to measure power traces, a target
    device on a power-measurement-enabled circuit board, and a computer that instructs
    the target to perform an operation while recording the device’s power traces and
    input/output.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个简单的SPA实验室，你需要一个用于测量功率轨迹的工具，一个带有功率测量功能的电路板上的目标设备，以及一台指示目标执行操作并记录设备功率轨迹和输入/输出的计算机。
- en: Building a Basic Hardware Setup
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建基本的硬件设置
- en: Your lab doesn’t need to be expensive or complicated, as [Figure 9-1](#figure9-1)
    shows.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你的实验室不需要昂贵或复杂，正如[图9-1](#figure9-1)所示。
- en: '![f09001](image_fi/278748c09/f09001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](image_fi/278748c09/f09001.png)'
- en: 'Figure 9-1: A homemade experimental platform'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：自制实验平台
- en: This simple home-built lab consists of a USB-connected oscilloscope 1, a target
    device on a breadboard with some electronics enabling measurement 2, and a standard
    computer with a USB-serial adapter 3. The ATmega328P microcontroller, as used
    in an Arduino, is mounted on a special board with a current measurement resistor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的自制实验室由一个USB连接的示波器1、一个带有一些电子元件用于测量的面包板上的目标设备2，以及一台配有USB-串口适配器的标准计算机3组成。ATmega328P微控制器，如Arduino中使用的微控制器，被安装在一个带有电流测量电阻的特殊电路板上。
- en: Basic Oscilloscopes
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本示波器
- en: When using a regular oscilloscope, the most important requirement is that it’s
    capable of sampling at 100 MS/s (mega-samples per second) or higher on two channels.
    Many oscilloscopes specify a maximum sample rate that you can get only on a single
    channel. If you use two channels, the sample rate on each channel is half of that
    maximum, which means a 100 MS/s scope can sample only at 50 MS/s if you want to
    measure two inputs at once. For these experiments, we’ll use the second channel
    as a trigger only. Your scope may have an external trigger (which still allows
    you to get the maximum sample rate from one channel), but if not, be sure you
    can sample on two channels simultaneously at 100 MS/s or better. Attacking more
    advanced implementations, such as hardware AES, will require much faster sampling
    rates—sometimes 1 GS/s or higher.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常规示波器时，最重要的要求是它必须能够在两个通道上以100 MS/s（百万样本每秒）或更高的速率进行采样。许多示波器规定了一个最大采样率，但只有在单通道上才可以达到。如果使用两个通道，则每个通道的采样率是该最大值的一半，这意味着如果你想同时测量两个输入，100
    MS/s的示波器只能在50 MS/s下采样。对于这些实验，我们将只将第二通道用作触发器。你的示波器可能有外部触发器（这仍然允许你从一个通道获得最大采样率），但如果没有，确保你能在两个通道上同时以100
    MS/s或更高的速度进行采样。要进行更先进的实现（例如硬件AES攻击），则需要更快的采样率——有时需要1 GS/s或更高。
- en: Very low-cost generic oscilloscopes may not have a useful computer interface.
    For example, you will find USB-connected oscilloscopes that lack an API to allow
    you to interface with the device. When purchasing an oscilloscope for side-channel
    analysis, make sure you can control the device from your computer and that you
    can quickly download data from the oscilloscope.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 低成本的普通示波器可能没有有用的计算机接口。例如，你会发现一些USB连接的示波器缺乏API，无法与设备进行交互。当购买用于旁路分析的示波器时，确保你能够通过计算机控制该设备，并且可以快速地从示波器下载数据。
- en: Also, pay attention to the sample size buffer. Low-cost devices have a small
    buffer of, say, only 15,000 samples, which will make your work much more difficult.
    This is because you’ll need to trigger the capture at the exact moment of the
    sensitive operation; otherwise, you’ll overflow the oscilloscope’s memory buffer.
    You’ll also be unable to perform certain work, such as simple power analysis on
    longer public-key algorithms that would require a much larger buffer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要注意样本大小缓冲区。低成本设备通常只有小容量缓冲区，比如仅有15,000个样本，这将使你的工作变得更加困难。这是因为你需要在敏感操作的确切时刻触发采样，否则你会溢出示波器的内存缓冲区。你还将无法执行某些任务，比如对需要更大缓冲区的长时间公钥算法进行简单的功率分析。
- en: Special-purpose sampling devices that allow synchronous sampling can reduce
    your sample rate requirements by keeping a relationship between the device clock
    and your sample clock (like the ChipWhisperer does). See Appendix A for more information
    on oscilloscopes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 专用的同步采样设备（如 ChipWhisperer）可以通过保持设备时钟和采样时钟之间的关系，减少你的采样率要求。有关示波器的更多信息，请参见附录 A。
- en: Choosing a Microcontroller
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择微控制器
- en: Select a microcontroller that you can program directly and that isn’t running
    any operating system. The Arduino is a perfect choice. Don’t begin your side-channel
    career by attempting to use a target such as a Raspberry Pi or BeagleBone. Those
    products have too many complicating factors, such as the difficulty of getting
    a reliable trigger, high clock speeds, and their operating systems. We’re building
    a skill, so let’s start in easy mode.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个可以直接编程且没有运行操作系统的微控制器。Arduino 是一个完美的选择。不要通过尝试使用 Raspberry Pi 或 BeagleBone
    这样的目标来开始你的侧信道事业。这些产品有太多复杂的因素，比如触发信号的可靠性问题、高时钟速度以及操作系统的干扰。我们是在构建一项技能，所以让我们从简单模式开始。
- en: Building a Target Board
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建目标板
- en: The first thing we need to build is a microcontroller target board that has
    a shunt resistor inserted into the power line. *Shunt resistor* is a generic term
    we give to a resistor that we insert into a circuit’s path to measure current.
    Current flow through that resistor will cause a voltage to be developed across
    it, and we can measure that voltage using an oscilloscope.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建的第一个组件是一个微控制器目标板，在电源线上插入一个分流电阻。*分流电阻*是我们用来插入电路路径以测量电流的电阻的通用术语。电流流过该电阻时，会在电阻两端产生电压，我们可以使用示波器测量这个电压。
- en: '[Figure 9-1](#figure9-1) shows an example of a test target. [Figure 9-2](#figure9-2)
    details the insertion of a shunt resistor, where the low side of the shunt resistor
    goes to the oscilloscope channel. Ohm’s law tells us that a voltage “developed”
    across a resistor is equal to the resistance multiplied by the current (*V* =
    *I* × *R*). The voltage polarity will be such that a lower voltage is present
    on the low side. If the high side was 3.3 V, and the low side was 2.8 V, this
    means that 0.5 V (3.3 – 2.8) was developed across the resistor.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](#figure9-1)显示了一个测试目标的例子。[图 9-2](#figure9-2)详细说明了分流电阻的插入过程，其中分流电阻的低端连接到示波器通道。欧姆定律告诉我们，电阻两端“产生”的电压等于电阻值乘以电流（*V*
    = *I* × *R*）。电压极性将使得低端的电压较低。如果高端是3.3 V，低端是2.8 V，这意味着在电阻上产生了0.5 V（3.3 - 2.8）。'
- en: '![f09002](image_fi/278748c09/f09002.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](image_fi/278748c09/f09002.png)'
- en: 'Figure 9-2: A shunt resistor makes it easy to measure power consumption.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：分流电阻使得测量功耗变得更加容易。
- en: If we wanted to measure only the voltage across the shunt resistor, we could
    use an instrument called a *differential probe*. With a differential probe, we’ll
    get only the exact voltage across the shunt resistor itself, which should provide
    the most accurate measurement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想测量分流电阻两端的电压，我们可以使用一种叫做*差分探头*的仪器。使用差分探头，我们只会得到分流电阻本身两端的精确电压，这将提供最准确的测量值。
- en: An easier method that doesn’t require additional gear (and how we’ll work in
    this lab) is to assume the high side of the shunt resistor is connected to a clean
    and constant voltage power supply, which means any noise on the high side of the
    shunt resistor will add to measurement noise on the low side. We’ll measure power
    consumption across this shunt resistor simply by measuring the voltage on the
    low side, which will be the value of our constant “high side” voltage minus the
    drop on the shunt resistor. As the current increases in the shunt, the voltage
    drop across the shunt increases as well, and thus the “low side” voltage becomes
    smaller.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不需要额外设备的方法（也是我们在本实验室中使用的方法）是假设分流电阻的高端连接到一个干净且恒定的电压电源，这意味着分流电阻高端的任何噪声都会加到低端的测量噪声上。我们通过简单地测量低端的电压来测量分流电阻两端的功耗，这个低端电压将是我们的恒定“高端”电压减去分流电阻上的压降。随着分流中的电流增大，分流电阻两端的压降也会增加，从而“低端”电压变小。
- en: The resistance value you’ll need for your shunt resistor depends on the current
    power consumption of your target device. Using Ohm’s law, *V* = *I* × *R*, you
    can calculate reasonable resistance values. Most oscilloscopes have good voltage
    resolution of 50 mV to 5 V. The current (*I*) is determined by the device, but
    it will range from dozens of mA for microcontrollers to several A for large System-on-Chips
    (SoCs). For example, if your target is a small microcontroller at 50 mA, you should
    be able to use a resistance of 10 Ω to 50 Ω, but a field-programmable gate array
    (FPGA) with 5 A consumption might require 0.05 Ω to 0.5 Ω. Higher value resistors
    produce a larger voltage drop that provides a strong signal for your oscilloscope,
    but that may reduce the device voltage to such a low point that it stops operating.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的分流电阻的电阻值取决于目标设备的当前功耗。使用欧姆定律，*V* = *I* × *R*，你可以计算出合理的电阻值。大多数示波器的电压分辨率为50
    mV至5 V。电流（*I*）由设备决定，但它的范围从微控制器的几十毫安到大型系统级芯片（SoC）的几个安培。例如，如果你的目标是一个50 mA的小型微控制器，你可以使用10
    Ω到50 Ω的电阻，而一个功耗为5 A的现场可编程门阵列（FPGA）可能需要0.05 Ω到0.5 Ω的电阻。较高电阻值的电阻会产生更大的电压降，从而为示波器提供更强的信号，但这可能会将设备电压降到如此低的水平，以至于它停止工作。
- en: '[Figure 9-3](#figure9-3) shows a schematic of the target board 2 from [Figure
    9-1](#figure9-1).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3](#figure9-3) 显示了来自[图 9-1](#figure9-1)的目标板 2的示意图。'
- en: '![f09003](image_fi/278748c09/f09003.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](image_fi/278748c09/f09003.png)'
- en: 'Figure 9-3: A schematic of the target board'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：目标板的示意图
- en: The ATmega328P microcontroller runs the target code, a resistor (R2) allows
    us to take power measurements, and noise filtering of the input voltage source
    is done with C1, C2, C3, and R1\. An external USB-TTL serial adapter is connected
    to the RX and TX line. Note that the digital power supply has *no* decoupling
    capacitors; they would filter out details of the power consumption that contain
    potentially interesting information. You can easily modify this circuit to use
    other microcontrollers if you prefer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ATmega328P微控制器运行目标代码，电阻（R2）使我们能够进行功率测量，输入电压源的噪声过滤由C1、C2、C3和R1完成。一个外部USB-TTL串口适配器连接到RX和TX线路。请注意，数字电源没有*去耦*电容；这些电容会滤除包含潜在有趣信息的功耗细节。如果你愿意，可以轻松修改此电路以使用其他微控制器。
- en: You’ll need to be able to program the microcontroller with your target code,
    which might mean moving the physical chip between the target breadboard and the
    Arduino. An Arduino Uno uses the same ATmega328P microcontroller we mentioned
    before, so whenever we say “Arduino,” we just mean a board that can be used to
    program the microcontroller.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要能够用目标代码编程微控制器，这可能意味着需要在目标面包板和Arduino之间移动物理芯片。Arduino Uno使用我们之前提到的ATmega328P微控制器，所以当我们说“Arduino”时，我们指的是一个可以用来编程微控制器的开发板。
- en: Buying a Setup
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 购买设备
- en: If you’d rather not build your own lab for side-channel analysis, you can purchase
    one. The ChipWhisperer-Nano (shown in [Figure 9-4](#figure9-4)) or the ChipWhisperer-Lite
    (shown in [Figure 9-5](#figure9-5)) replaces all the hardware shown in [Figure
    9-1](#figure9-1) for about US$50 or US$250, respectively.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想自己搭建侧信道分析实验室，可以购买现成的。ChipWhisperer-Nano（见[图 9-4](#figure9-4)）或ChipWhisperer-Lite（见[图
    9-5](#figure9-5)）可以分别替代[图 9-1](#figure9-1)中显示的所有硬件，价格大约为50美元或250美元。
- en: '![f09004](image_fi/278748c09/f09004.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![f09004](image_fi/278748c09/f09004.png)'
- en: 'Figure 9-4: The ChipWhisperer-Nano'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：ChipWhisperer-Nano
- en: The ChipWhisperer-Nano is a device that allows you to program the included STM32F0
    with various algorithms and perform power analysis. You can break off the included
    target to look at other devices. The glitching functionality is very limited compared
    to the ChipWhisperer-Lite.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ChipWhisperer-Nano 是一个设备，允许你使用各种算法为附带的 STM32F0 编程并执行功耗分析。你可以拆下附带的目标，查看其他设备。与
    ChipWhisperer-Lite 相比，其故障功能非常有限。
- en: '![f09005](image_fi/278748c09/f09005.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![f09005](image_fi/278748c09/f09005.png)'
- en: 'Figure 9-5: The ChipWhisperer-Lite'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：ChipWhisperer-Lite
- en: The ChipWhisperer-Lite provides capture hardware along with a sample target
    board. The included target is available as either an Atmel XMEGA or STM32F303
    ARM. Beyond side-channel analysis, this device also allows you to perform experiments
    of clock and voltage glitching. Again, you can break off the included target to
    look at more advanced devices. These devices include both the target and the capture
    hardware all on one board. The ChipWhisperer-Lite is an open source design, so
    you can also build it yourself. Alternatively, commercial tools like Riscure’s
    Inspector or CRI’s DPA Workstation are available; they’re developed for higher
    complexity and higher security targets but are outside the average hardware hacker’s
    budget.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ChipWhisperer-Lite 提供了捕获硬件和一个示例目标板。所附的目标可以是 Atmel XMEGA 或 STM32F303 ARM。除了旁道分析外，这个设备还允许你进行时钟和电压故障实验。同样，你可以拆下附带的目标，查看更高级的设备。这些设备包括目标和捕获硬件，都集成在一个板上。ChipWhisperer-Lite
    是一个开源设计，所以你也可以自己构建它。另有像 Riscure 的 Inspector 或 CRI 的 DPA 工作站这样的商业工具可供选择；它们为更复杂和更高安全性的目标开发，但超出了普通硬件黑客的预算。
- en: Preparing the Target Code
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备目标代码
- en: We’ll assume an Arduino as the target for now and afterward demonstrate the
    same attack on a ChipWhisperer-Nano. Regardless of your choice of hardware, you’ll
    need to program the microcontroller to perform the encryption or password check
    algorithm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时假设使用 Arduino 作为目标，之后将展示在 ChipWhisperer-Nano 上执行相同的攻击。无论你选择什么硬件，你都需要编程微控制器来执行加密或密码检查算法。
- en: '[Listing 9-1](#listing9-1) shows an example of the firmware code you need to
    program into your target.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-1](#listing9-1) 显示了你需要编程到目标中的固件代码示例。'
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: Sample microcontroller firmware using Arduino for performing a
    simple operation with a trigger'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-1：使用 Arduino 执行简单操作并触发的示例微控制器固件
- en: The target first reads in a password from the user. Then the target compares
    that password with the stored password 2 (in this case, the hardcoded password
    is `ilovecheese`). A specific I/O line is set high during the password comparison
    operation, allowing you to trigger your oscilloscope into measuring the signal
    during this operation 1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 目标首先从用户读取密码。然后，目标将该密码与存储的密码 2（在此案例中，硬编码密码为`ilovecheese`）进行比较。在密码比较操作期间，某个特定的
    I/O 行会被设置为高电平，允许你触发示波器在此操作过程中进行信号测量 1。
- en: This firmware has a trick up its sleeve. Even though it uses a leaky string
    comparison 2 (like in our introduction on timing attacks in Listing 8-1), it makes
    timing attacks difficult by doing a random wait of up to 500ms at the end of the
    operation 3, making it ripe for an SPA attack.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这款固件有一个小技巧。尽管它使用了一个泄漏的字符串比较 2（如我们在列表 8-1 中介绍的时序攻击），它通过在操作结束时随机等待最多 500 毫秒，增加了时序攻击的难度
    3，使其成为适合进行 SPA 攻击的目标。
- en: Building the Setup
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建设置
- en: 'On the computer side, your work will involve the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机端，你的工作将涉及以下内容：
- en: Communicating with the target device (sending commands and data and receiving
    a response)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与目标设备通信（发送命令和数据并接收响应）
- en: Setting up the oscilloscope as appropriate (channels, triggers, and scales)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当设置示波器（通道、触发器和刻度）
- en: Downloading data from the oscilloscope to the computer
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从示波器下载数据到计算机
- en: Storing the power trace and data sent to the device in a database or file
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功率跟踪和发送到设备的数据存储在数据库或文件中
- en: We’ll look at the requirements for each of these steps in the next few sections.
    The end objective is to measure the power consumption of a microcontroller while
    executing a simple program, as shown in [Listing 9-1](#listing9-1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几个章节中查看这些步骤的要求。最终目标是测量微控制器在执行一个简单程序时的功耗，如[列表 9-1](#listing9-1)所示。
- en: Communicating with the Target Device
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与目标设备通信
- en: 'Since you’re targeting a device that you program yourself, you can define your
    own communications protocol. In [Listing 9-1](#listing9-1), it’s simply a serial
    interface that reads a password. For simplicity, the “correct” password is hardcoded
    in the program, but in general, it’s good to allow configuration of the “sensitive
    information” (such as the password). This practice allows you to experiment more
    easily (for example, with a longer and shorter password). When you start targeting
    crypto, this practice also holds: configuration of the key material from the computer
    enables experimentation.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在定位一个自己编程的设备，你可以定义自己的通信协议。在[列表9-1](#listing9-1)中，它只是一个读取密码的串行接口。为了简化，“正确”的密码是硬编码在程序中的，但通常，最好允许配置“敏感信息”（例如密码）。这种做法使得你可以更轻松地进行实验（例如，尝试更长或更短的密码）。当你开始针对加密进行实验时，这种做法同样适用：从计算机配置密钥材料可以进行实验。
- en: The other part of communication is triggering the oscilloscope. While the target
    device is running the task with the “sensitive operation,” you need to monitor
    the device’s power consumption. [Listing 9-1](#listing9-1) shows triggering, where
    we put a trigger line high right before the comparison occurs and pull it back
    low after the comparison.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一部分通信是触发示波器。在目标设备运行带有“敏感操作”的任务时，你需要监控设备的功耗。[列表9-1](#listing9-1)展示了触发过程，我们在比较发生之前将触发线拉高，在比较后将其拉低。
- en: The Shunt Resistor
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分流电阻
- en: The shunt resistor’s output signal is fairly strong, and it should be able to
    drive your oscilloscope directly. Connect the signal directly to your oscilloscope
    using the BNC connector input, rather than feed it through the probes, which might
    introduce noise through the ground connection. Also, if your oscilloscope has
    only fixed 10:1 probes, you’ll be reducing the peak-to-peak voltage. After doing
    this, your scope can measure the voltage differentials caused by varying power
    consumption of the target.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 分流电阻的输出信号相当强大，应该能够直接驱动你的示波器。使用BNC连接器输入将信号直接连接到示波器，而不是通过探头传输信号，因为探头可能通过接地连接引入噪声。此外，如果你的示波器只有固定的10:1探头，信号的峰峰值电压将会降低。完成这些操作后，你的示波器可以测量目标设备因功耗变化所引起的电压差异。
- en: Oscilloscope Settings
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示波器设置
- en: 'You’ll need to get a few settings on your scope in the right ballpark: the
    voltage range, coupling, and sampling rate. This is “Oscilloscope 101,” so we’ll
    give only a few brief tips on specifics when doing side-channel captures. More
    details on using scopes can be found in the section “Digital Oscilloscope” in
    Chapter 2. If you need to purchase an oscilloscope, see the section “Viewing Analog
    Waveforms (Oscilloscopes)” in Appendix A.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在示波器上正确设置一些参数：电压范围、耦合和采样率。这是“示波器101”，因此我们将在进行侧信道捕获时只提供一些简短的具体技巧。有关使用示波器的更多细节，请参见第2章“数字示波器”部分。如果你需要购买示波器，请参阅附录A中的“查看模拟波形（示波器）”部分。
- en: The *voltage range* should be selected high enough such that the captured signal
    doesn’t clip. For instance, when you have a 1.3 V signal but your range is set
    to 1.0 V, you’ll lose all information above 1.0 V. On the other hand, it needs
    to be selected low enough so as not to cause quantization errors. This means if
    your range is set to 5 V, but you have a 1.3 V signal, you’ve wasted 3.7 V of
    range. If your scope gives you a choice between 1 V and 2 V, for the 1.3 V signal,
    you’d pick 2 V.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*电压范围*应该选择足够高，以确保捕获的信号不会发生削波。例如，当你有一个1.3 V的信号，但范围设置为1.0 V时，1.0 V以上的所有信息都会丢失。另一方面，电压范围也需要选择得足够低，以避免量化误差。这意味着，如果你的范围设置为5
    V，但你有一个1.3 V的信号，你就浪费了3.7 V的范围。如果你的示波器提供了1 V和2 V的选择，对于1.3 V的信号，你应该选择2 V。'
- en: Your scope’s *input coupling* mode isn’t typically too critical. Unless you
    have a good reason not to, just use AC-coupled mode, as it centers the signal
    around the 0 V level. You can use DC-coupled mode and adjust the offset as well
    to achieve the same results. The advantage of AC-coupled mode is that it eliminates
    any gradual shift in voltage or very low-frequency noise that might complicate
    measurements if, for example, the output of your voltage regulator drifts as the
    system warms up. It will also compensate for the DC offset introduced if you are
    using a shunt on the VCC side, as we showed in [Figure 9-2](#figure9-2). DC offsets
    do not typically carry side-channel information.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你的示波器的*输入耦合*模式通常并不太重要。除非你有充分的理由不使用它，否则最好使用AC耦合模式，因为它将信号围绕0 V电平居中。你也可以使用DC耦合模式并调整偏移量来达到相同的效果。AC耦合模式的优点在于它消除了电压的逐渐漂移或非常低频的噪声，这些噪声可能会使测量变得复杂，比如如果电压调节器的输出随着系统升温而漂移。如果你正在使用VCC侧的分流器，AC耦合模式还会补偿由于偏置电压引起的DC偏移，正如我们在[图9-2](#figure9-2)中所示。DC偏移通常不会携带旁路信道信息。
- en: For the *sampling rate*, the trade-off is increased processing time but better
    capture quality at a higher rate versus faster processing but at a lower quality
    at a lower rate. When getting started, use the rule of thumb that you sample at
    one to five times your target’s clock speed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*采样率*，其权衡在于增加处理时间但在更高的采样率下能获得更好的捕获质量，而在较低的采样率下则是更快的处理速度但质量较差。在开始时，可以使用这样一个经验法则：采样率为目标时钟频率的1到5倍。
- en: Your scope might have other useful features too, such as a 20 MHz *bandwidth
    limit* that can reduce high-frequency noise. You can also introduce analog lowpass
    filters with the same effect. If you were attacking lower-frequency devices, this
    reduction in high-frequency noise would prove useful, but if you were attacking
    a very fast device, you might require data from the higher-frequency components.
    A good practice is to put a bandwidth limiter at about five times your sampling
    rate. For example, a 5 MHz target can be sampled at 10 MS/s and bandwidth limited
    at 50 MHz.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你的示波器可能还有其他有用的功能，比如20 MHz的*带宽限制*，能够减少高频噪声。你还可以引入模拟低通滤波器来达到相同的效果。如果你在攻击低频设备，这种高频噪声的减少会很有帮助，但如果你在攻击非常快速的设备，你可能需要获取来自更高频率部分的数据。一个好的做法是将带宽限制设置为采样率的大约五倍。例如，5
    MHz的目标可以以10 MS/s的速度进行采样，并在50 MHz时进行带宽限制。
- en: Be sure to experiment to determine the best measurement setup for any given
    device and algorithm. It’s a good learning experience and will teach you how settings
    affect quality and acquisition speed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要进行实验，以确定适合特定设备和算法的最佳测量设置。这是一次很好的学习经验，并且能教会你设置如何影响质量和采集速度。
- en: Communicating with the Scope
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与示波器的通信
- en: To actually perform the attack, you’ll need some way to download trace data
    to the computer. For simple power analysis attacks, you might be able to do it
    by inspecting the oscilloscope display visually. Any of the more advanced attacks
    will require you to download data from the oscilloscope to the computer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行攻击，你需要一种方法将跟踪数据下载到计算机上。对于简单的功耗分析攻击，你可能通过直观地检查示波器显示屏就能做到。任何更高级的攻击都需要将数据从示波器下载到计算机。
- en: The method of communicating with your oscilloscope will depend almost entirely
    on the oscilloscope’s vendor. Some vendors have their own library with language
    bindings to use that library in languages such as C and Python. Many other vendors
    rely instead on the *Virtual Instrument Software Architecture (VISA)*, an industry
    standard for communications between test equipment. If your scope supports VISA,
    you should be able to find high-level libraries in almost all languages to help
    you interface with it, such as PyVISA for Python. You’ll need to implement specific
    commands or options for your oscilloscope, but the vendor should provide some
    instruction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与示波器的通信方式几乎完全取决于示波器的供应商。一些供应商提供自己的库，并为C和Python等语言提供语言绑定来使用该库。许多其他供应商则依赖于*虚拟仪器软件架构（VISA）*，这是一种测试设备之间通信的行业标准。如果你的示波器支持VISA，你应该能在几乎所有语言中找到高层库来帮助你与示波器接口，例如Python的PyVISA。你需要实现特定的命令或选项以适应你的示波器，但供应商通常会提供一些说明。
- en: Data Storage
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据存储
- en: How you store your traces depends almost entirely on your planned analysis platform.
    If you’re planning on doing the analysis entirely in Python, you might look for
    the storage format that works with the popular NumPy library. If using MATLAB,
    you would take advantage of the native MATLAB file format. If you plan on experimenting
    with distributed computing, you’ll need to investigate the preferred filesystem
    for your cluster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何存储跟踪数据几乎完全取决于你计划使用的分析平台。如果你打算完全在 Python 中进行分析，你可以寻找与流行的 NumPy 库兼容的存储格式。如果使用
    MATLAB，你则可以利用 MATLAB 本机的文件格式。如果你计划尝试分布式计算，你需要调查适合你集群的文件系统。
- en: When working with really large trace sets, the storage format will matter, and
    you’ll want to optimize it for fast linear access. In professional labs, sets
    of 1TB are no exception. On the other hand, for your initial work and investigation,
    your data storage requirements should be fairly small. Attacking a software implementation
    on an 8-bit microcontroller may take only 10 or 20 power measurements, so almost
    anything better than copy/pasting the data out of a spreadsheet will work!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理非常大的跟踪数据集时，存储格式变得尤为重要，你需要优化它以便快速线性访问。在专业实验室中，1TB 级别的数据集并不罕见。另一方面，针对你最初的工作和调查，你的数据存储需求应该相对较小。在
    8 位微控制器上攻击软件实现可能只需要 10 或 20 次功率测量，所以几乎任何比从电子表格中复制粘贴数据更好的方法都能奏效！
- en: 'Pulling It Together: An SPA Attack'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 综合起来：SPA 攻击
- en: With our fresh setup, let’s perform the actual SPA attack, working with the
    code from [Listing 9-1](#listing9-1). As mentioned previously, this code has a
    leaky password comparison. The random wait at the end of the code hides the timing
    leak, so it’s not directly exploitable through timing. We’ll have to look closer,
    using SPA on traces, to see whether we can identify the individual character comparisons.
    If the traces give away which character is incorrect, we can do a very limited
    brute-force attack to recover the password, exactly like we did in the pure timing
    attacks in Chapter 8.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新的设置，接下来让我们执行实际的 SPA 攻击，使用[清单 9-1](#listing9-1)中的代码。如前所述，这段代码有一个泄漏的密码比较。代码末尾的随机等待掩盖了时间泄漏，因此无法通过时间直接利用它。我们需要更仔细地查看，通过使用
    SPA 对跟踪数据进行分析，看看能否识别出各个字符比较的结果。如果跟踪数据揭示了哪个字符是错误的，我们可以进行一个非常有限的暴力破解攻击来恢复密码，正如我们在第
    8 章的纯时间攻击中所做的那样。
- en: First, we’ll need to do a bit of additional preparation on our Arduino. Then,
    we’ll measure power traces when we provide correct, partially correct, and incorrect
    passwords. If these traces reveal the index of the first wrong character, we can
    brute-force the rest to recover the correct password.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对 Arduino 做一些额外的准备。然后，我们将测量当我们提供正确、部分正确和错误的密码时的功率跟踪数据。如果这些跟踪数据揭示了第一个错误字符的索引，我们就可以暴力破解其余部分，恢复正确的密码。
- en: Preparing the Target
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备目标
- en: To demonstrate a no-soldering approach to capturing traces, we need to extend
    the setup shown in [Figure 9-1](#figure9-1). We basically take an Arduino Uno
    and simply move the ATmega328P microcontroller onto a breadboard (see [Figure
    9-6](#figure9-6)). As mentioned earlier, we need the current shunt in the VCC
    pin, which is why we can’t just use a regular Arduino board (at least without
    doing some soldering).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一种不需要焊接的捕获跟踪数据方法，我们需要扩展[图 9-1](#figure9-1)中展示的设置。我们基本上是将 Arduino Uno 拿出来，然后将
    ATmega328P 微控制器移到面包板上（见[图 9-6](#figure9-6)）。如前所述，我们需要在 VCC 引脚上加一个电流分流器，这就是为什么我们不能仅仅使用普通的
    Arduino 板（至少不进行一些焊接）。
- en: '![f09006](image_fi/278748c09/f09006.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![f09006](image_fi/278748c09/f09006.png)'
- en: 'Figure 9-6: The humble Arduino used as a side-channel analysis attack target'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6：用作旁道分析攻击目标的简易 Arduino
- en: '[Figure 9-7](#figure9-7) shows details of the required wiring for the Arduino
    Uno.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-7](#figure9-7)显示了 Arduino Uno 所需接线的详细信息。'
- en: '![f09007](image_fi/278748c09/f09007.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![f09007](image_fi/278748c09/f09007.png)'
- en: 'Figure 9-7: Details of the required wiring for the Arduino Uno (this image
    was created with Fritzing).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-7：Arduino Uno 所需接线的详细信息（此图使用 Fritzing 创建）。
- en: Pins 9 and 10 are wired from the empty integrated circuit (IC) socket, where
    the microcontroller used to be, onto the breadboard. These jumper wires bring
    the crystal frequency from the board as needed by the microcontroller IC. The
    wires should be as short as possible. It’s not a great idea to wire these sensitive
    lines outside the board like we’ve done, but in practice, it tends to work. If
    you have trouble getting the system operating, it might be that these lines are
    too long.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚 9 和 10 从空的集成电路（IC）插座中接出，那里曾经是微控制器，将其连接到面包板上。这些跳线将所需的晶体频率从电路板传递给微控制器 IC。跳线应该尽可能短。将这些敏感的线路接出板外并不是一个好主意，尽管实践中通常可行。如果你在使系统正常工作时遇到问题，可能是这些线路太长了。
- en: The value of resistors and capacitors is not critical. The resistors here are
    100 Ω, but anything from 22–100 Ω should work. Capacitors in the range of 100μF
    to 330μF will work. (The schematic in [Figure 9-3](#figure9-3) shows some details.
    Note that Y1, C5, and C6 shown in [Figure 9-3](#figure9-3) are not required here
    as those parts are on the Arduino baseboard instead.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻和电容的值并不是至关重要的。这里使用的电阻是 100 Ω，但 22 Ω 到 100 Ω 之间的任何电阻都可以使用。电容范围是 100μF 到 330μF
    之间也可以使用。（[图 9-3](#figure9-3)中的原理图展示了一些细节。注意，[图 9-3](#figure9-3)中显示的 Y1、C5 和 C6
    在这里不需要，因为这些元件已经集成在 Arduino 主板上。）
- en: Now that the Arduino has been modded for power measurements, we program the
    code from [Listing 9-1](#listing9-1). After connecting with a serial terminal,
    you should have a prompt where you can enter your password (see [Figure 9-8](#figure9-8)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Arduino 已经被改装用于功率测量，我们从[清单 9-1](#listing9-1)编写代码。连接到串口终端后，你应该会看到一个提示符，可以在其中输入密码（见[图
    9-8](#figure9-8)）。
- en: Be sure to test that the code behaves correctly for both a valid and an invalid
    password. You can do so by typing in a password manually or making a test program
    that communicates with the target code directly. At this point, you are ready
    for an attack!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要测试代码在有效密码和无效密码下的行为是否正确。你可以通过手动输入密码或者编写一个与目标代码直接通信的测试程序来进行测试。此时，你已准备好进行攻击！
- en: '![f09008](image_fi/278748c09/f09008.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![f09008](image_fi/278748c09/f09008.png)'
- en: 'Figure 9-8: Serial output from the programmed Arduino'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-8：编程后的 Arduino 的串口输出
- en: Preparing the Oscilloscope
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备示波器
- en: Set your oscilloscope to trigger on the digital I/O line in use. We use “Digital
    IO 2,” which is pin 4 on the ATmega328P chip. The code on the target pulls the
    line high just before the sensitive operation (in this case, the password comparison).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 设置示波器以触发正在使用的数字 I/O 线路。我们使用的是“数字 I/O 2”，它是 ATmega328P 芯片上的引脚 4。目标代码在敏感操作之前（在这种情况下，是密码比较）将该线路拉高。
- en: First, experiment by sending the same password repeatedly. You should get very
    similar looking traces. If not, go debug your setup. Your trigger may not be caught
    by the oscilloscope, or maybe your test program isn’t running correctly. The trace
    captures left of the dotted line in the upcoming [Figure 9-9](#figure9-9) provide
    an idea of how similar the traces should look.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试重复发送相同的密码。你应该得到非常相似的波形。如果没有，那就去调试你的设置。你的触发器可能没有被示波器捕捉到，或者测试程序可能没有正确运行。即将在[图
    9-9](#figure9-9)中看到的虚线左侧的波形捕捉提供了一个关于波形应该如何相似的参考。
- en: Once you’re convinced that the measurement setup is working, experiment with
    various oscilloscope settings, heeding our advice from the previous section. An
    Arduino Uno runs at 16 MHz, so set your oscilloscope to anything between 20 MS/s
    and 100 MS/s. Tune your scope range to fit the signal snugly without clipping.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确信测量设置正常工作，便可以尝试各种示波器设置，参考上一节中的建议。Arduino Uno 的工作频率为 16 MHz，所以将示波器设置为 20
    MS/s 到 100 MS/s 之间的任何值。调节示波器的范围，使其能够精准地显示信号而不发生截断。
- en: For ease of build, we’ve used oscilloscope probes. As mentioned earlier, this
    will produce some signal loss compared to feeding a BNC-connected wire into the
    scope directly. On this target, there’s plenty of signal, so it’s not a big deal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便搭建，我们使用了示波器探头。如前所述，与直接将 BNC 连接的线缆接入示波器相比，这会导致一些信号损失。由于目标上有足够的信号，因此这不是一个大问题。
- en: If you have oscilloscope probes that are switchable between 10× and 1×, you
    may find they work much better in the 1× position. The 1× position provides less
    noise, but with a greatly reduced bandwidth. For this specific case, the lower
    bandwidth is actually helpful, so we prefer to use the 1× setting. If your oscilloscope
    has a bandwidth limit (many have a 20 MHz bandwidth limit option), enable it to
    see whether the signal becomes clearer. If you are looking at picking up an oscilloscope
    for this, we’ll cover what sort of options you might need in Appendix A.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的示波器探头可以在10×和1×之间切换，你可能会发现它们在1×位置工作得更好。1×位置提供较少的噪声，但带宽大大降低。在这个特定的情况下，较低的带宽实际上是有帮助的，因此我们更倾向于使用1×设置。如果你的示波器有带宽限制（许多示波器提供20
    MHz带宽限制选项），可以启用它，看看信号是否变得更清晰。如果你正在考虑购买示波器，我们将在附录A中介绍你可能需要的选项。
- en: Analysis of the Signal
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号分析
- en: 'Now you can start to experiment with different passwords; you should see a
    noticeable difference when sending the correct and incorrect passwords. [Figure
    9-9](#figure9-9) shows an example of the power measurement recorded with different
    passwords when running: the power traces for the correct password (top, `ilovecheese`),
    a fully incorrect password (bottom, `test`), and a partially correct password
    (middle, `iloveaaaaaa`).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始尝试不同的密码了；在发送正确和错误密码时，你应该能看到明显的差异。[图9-9](#figure9-9)展示了在运行时用不同密码记录的功率测量例子：正确密码（顶部，`ilovecheese`）、完全错误的密码（底部，`test`）和部分正确的密码（中间，`iloveaaaaaa`）。
- en: '![f09009](image_fi/278748c09/f09009.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![f09009](image_fi/278748c09/f09009.png)'
- en: 'Figure 9-9: Power traces are shown for correct, partially correct, and incorrect
    passwords; arrows indicate character-comparison operation. The black signal overlaying
    each trace is the trigger signal.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-9：展示了正确、部分正确和错误密码的功率轨迹；箭头指示字符比较操作。覆盖在每条轨迹上的黑色信号是触发信号。
- en: A clear difference is visible between the top two traces and the bottom trace.
    The string comparison function more quickly detects if the number of characters
    differs—the bottom trace shows a shorter trigger signal. The more interesting
    area is where the same number of characters is compared but with incorrect values,
    as shown in the top and middle traces. For those traces, the power signature is
    the same up until the dashed line, after which the character comparisons start.
    By carefully inspecting the correct password, you can see about 11 repeated segments,
    indicated by the arrows, which perfectly match the 11 characters of `ilovecheese`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部的两条轨迹和底部的轨迹之间可以明显看到差异。字符串比较函数更快地检测字符数是否不同——底部轨迹显示了较短的触发信号。更有趣的地方是，相同字符数但值不正确的情况，如顶部和中间的轨迹所示。对于这些轨迹，功率特征在虚线之前是相同的，之后才开始进行字符比较。仔细检查正确密码，你可以看到大约11个重复的片段，这些片段由箭头标示，完美匹配`ilovecheese`的11个字符。
- en: Now by looking at the `iloveaaaaaa` password trace in the middle, you can see
    only five such segments. Each “segment” means a single iteration through some
    comparison loop, so the number of these segments corresponds to the length of
    the correct password prefix. As with the timing attack in Chapter 8, that means
    we only must guess each possible input character, one at a time, and that means
    we can guess the password very quickly (assuming we write a script to do this).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过查看中间的`iloveaaaaaa`密码轨迹，你可以看到只有五个这样的片段。每个“片段”表示通过某个比较循环的一次迭代，因此这些片段的数量对应于正确密码前缀的长度。与第8章中的时间攻击相似，这意味着我们只需一次猜测每个可能的输入字符，也就意味着我们可以非常快速地猜测密码（前提是我们编写一个脚本来实现这一点）。
- en: Scripting the Communication and Analysis
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本化通信和分析
- en: You’ll want to have interfaced both the oscilloscope and target to some programming
    environment for this section. This interface will allow you to write a script
    to send arbitrary passwords while noting the power measurement. We will use this
    script to determine how many initial characters were accepted.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将示波器和目标设备都与某个编程环境连接，以便进行本节的操作。这个接口将允许你编写脚本，发送任意的密码，同时记录功率测量值。我们将使用这个脚本来确定接受了多少个初始字符。
- en: The specifics of this script will depend a lot on what system you’re using to
    download data from an oscilloscope. [Listing 9-2](#listing9-2) shows a script
    that works with a PicoScope USB device and the Arduino password-checking code.
    You’ll need to tweak the settings for your specific target; it’s not just a copy-paste-run
    task.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的具体内容将取决于你用来从示波器下载数据的系统。[清单 9-2](#listing9-2)展示了一个与PicoScope USB设备以及Arduino密码检查代码一起使用的脚本。你需要根据你的具体目标调整设置；这不仅仅是一个复制-粘贴-运行的任务。
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: A sample script to connect a computer to a PicoScope 2000 series
    along with its Arduino target'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-2：连接计算机到PicoScope 2000系列及其Arduino目标的示例脚本
- en: The Python script in [Listing 9-2](#listing9-2) will display a diagram like
    the one shown in [Figure 9-10](#figure9-10). Note that the markers in this diagram
    were added with additional code not shown in [Listing 9-2](#listing9-2). If you
    want to see the exact marker generation code, look at the companion repository,
    which includes the code used to generate [Figure 9-10](#figure9-10).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-2](#listing9-2)中的Python脚本将显示如[图 9-10](#figure9-10)所示的图表。请注意，这张图中的标记是通过额外的代码添加的，而这些代码在[清单
    9-2](#listing9-2)中没有显示。如果你想查看确切的标记生成代码，可以查看伴随的代码库，其中包含了生成[图 9-10](#figure9-10)的代码。'
- en: '![f09010](image_fi/278748c09/f09010.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![f09010](image_fi/278748c09/f09010.png)'
- en: 'Figure 9-10: Two power traces of two different password guesses (correct marked
    with circles; incorrect marked with squares)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-10：两个不同密码猜测的功率曲线（正确的用圆圈标记；错误的用方块标记）
- en: '[Figure 9-10](#figure9-10) is zoomed in compared to [Figure 9-9](#figure9-9),
    with the comparison starting at sample 148\. The solid line is for the correct
    password; the partially correct password is shown with dashes. You can observe
    that every 25 samples, starting at sample number 148, a pattern is repeated—seemingly
    one pattern per comparison. The lines overlap for five of the comparisons. Notice
    at sample number 273 the correct password and partially correct password have
    diverged, which coincides with the idea that the first five characters (`ilove`)
    are the same between both password guesses. To emphasize this, we’ve marked the
    value of the correct password power trace with circles every 25 samples, and the
    value of the incorrect password power trace with squares every 25 samples. Notice
    the square and circle are close to each other for the first five marked locations,
    but on the sixth location, it is noticeably different.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与[图 9-9](#figure9-9)相比，[图 9-10](#figure9-10)进行了放大，比较从样本148开始。实线表示正确的密码；部分正确的密码用破折号表示。你可以观察到，从样本148开始，每25个样本就会重复一个模式——似乎每次比较都有一个模式。五次比较的线条是重叠的。注意，在样本273处，正确的密码和部分正确的密码已经分开，这与前五个字符（`ilove`）在两次密码猜测中相同这一观点一致。为了强调这一点，我们在每25个样本处用圆圈标记了正确密码的功率曲线值，用方块标记了错误密码的功率曲线值。注意，前五个标记的位置，圆圈和方块非常接近，但在第六个位置，它们的差异变得明显。
- en: In order to script this attack, we can compare the sample value of the power
    trace every 25 samples, starting at sample 148\. Taking the markers from [Figure
    9-10](#figure9-10), we can see that there is some threshold voltage around 1.2
    V that could be used to separate the good and bad iterations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写这个攻击脚本，我们可以从样本148开始，每25个样本比较一次功率曲线的样本值。通过[图 9-10](#figure9-10)的标记，我们可以看到大约1.2V的阈值电压，可以用来区分好的和不好的迭代。
- en: How did we know the comparison started at sample point 148? You can determine
    the start of the comparison by using the “fully incorrect” password, which should
    show divergence as soon as the comparison starts. To do this, you’ll have to add
    to the list of guessed passwords a third option that sends a fully incorrect password,
    such as `aaaaaaaaaaa`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么知道比较是从样本点148开始的？你可以通过使用“完全错误”的密码来确定比较的开始，这将在比较开始时就显示出分歧。为了做到这一点，你需要在猜测密码列表中添加一个完全错误的密码选项，比如`aaaaaaaaaaa`。
- en: Scripting the Attack
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 攻击脚本
- en: 'We’ve used the “squint at traces” technique to identify the segments, which
    is the usual starting point for SPA, but in order to script this, we need to be
    a bit more accurate. We need a *distinguisher* that tells a script whether there
    is a segment. With that in mind, we devised the following rule: a character comparison
    segment index *i* is detected as being successful if there is a peak *larger*
    than 1.2 V at sample 148 + 25*i*. You’ll notice in [Figure 9-10](#figure9-10)
    the incorrect password diverged at sample 273, and at that time the incorrect
    password trace had a value of about 1.06 V. Note traces can be noisy and may require
    you to add filtering onto the signal or to check a few times to confirm your results
    match.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了“眯眼看迹线”技术来识别片段，这通常是 SPA 的起点，但为了编写脚本，我们需要更加精确。我们需要一个*区分器*，它能够告诉脚本是否存在一个片段。考虑到这一点，我们制定了以下规则：如果在样本
    148 + 25*i* 处有一个大于 1.2 V 的峰值，则字符比较片段索引 *i* 被判定为成功。你会在 [图 9-10](#figure9-10) 中注意到，不正确的密码在样本
    273 处发生了偏差，此时不正确密码的迹线值约为 1.06 V。请注意，迹线可能会很嘈杂，可能需要你对信号进行滤波或多次检查，以确认结果是否一致。
- en: You also need to use a search on an area around the sample by ± 1 samples because
    the oscilloscope may have some jitter. A quick check in [Figure 9-10](#figure9-10)
    shows that this should work. With that knowledge, we can build the Python script
    in [Listing 9-3](#listing9-3), which automatically guesses the correct password.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在样本附近 ± 1 个样本的范围内进行搜索，因为示波器可能会有一些抖动。[图 9-10](#figure9-10)中的快速检查表明这应该是有效的。通过这些知识，我们可以构建
    [列表 9-3](#listing9-3) 中的 Python 脚本，它会自动猜测正确的密码。
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-3: A sample script to exploit the leakage discovered and guess a
    password'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-3：一个示例脚本，利用发现的泄漏并猜测密码
- en: 'This script implements the basic SPA attack: it captures a password check,
    uses the height of the peak at 148 + 25*i* to determine if character *i* is correct,
    and simply loops through all characters until the full password is found:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本脚本实现了基本的 SPA 攻击：它捕获密码检查，通过在 148 + 25*i* 处的峰值高度来判断字符 *i* 是否正确，然后简单地遍历所有字符直到找到完整的密码：
- en: '`****FOUND PASSWORD = ilovecheese`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`****FOUND PASSWORD = ilovecheese`'
- en: This script is a bit slow to keep things simple. There are two areas for improvement.
    First, the timeout in the `serial.read()` function is set always to wait for 500ms.
    We could instead look for the newline (`\n`) and stop trying to read more data.
    Second, the password-checker firmware in the Arduino has a delay when a wrong
    password is entered. We could use an I/O line to reset the Arduino chip after
    every attempt to skip that delay. We’ll leave those improvements as an exercise
    for the reader.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本为了保持简单运行得有点慢。有两个改进的空间。首先，`serial.read()` 函数中的超时设置为始终等待 500 毫秒。我们可以改为查找换行符（`\n`），并停止尝试读取更多数据。其次，当输入错误密码时，Arduino
    中的密码检查固件会有一个延迟。我们可以使用 I/O 线路在每次尝试后重置 Arduino 芯片，跳过该延迟。我们将把这些改进留给读者作为练习。
- en: When looking at your traces, you will need to very carefully scrutinize the
    power traces. Depending on where you position your distinguisher, you may need
    to flip the sign of the comparison for this example to work. There will be multiple
    locations showing the leakage, so minor adjustments in the code may change your
    results.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看你的迹线时，你需要非常仔细地审查功率迹线。根据你放置区分器的位置，你可能需要翻转比较的符号才能使这个示例正常工作。会有多个位置显示泄漏，因此代码中的小调整可能会改变你的结果。
- en: If you would like to see this example running on known hardware, the companion
    notebook (see [https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/))
    shows how to use a ChipWhisperer-Nano or ChipWhisperer-Lite to communicate with
    the Arduino target. In addition, the companion notebook includes “pre-recorded”
    power traces so you can run this example without hardware. However, we can make
    this attack more consistent by targeting one of the built-in targets instead of
    the Arduino you built, which we’ll look at next. In addition, we’ll work to make
    a more automated attack that doesn’t require us to manually determine the location
    and value of the distinguisher.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在已知硬件上看到这个示例的运行，配套的笔记本（参见 [https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/)）展示了如何使用
    ChipWhisperer-Nano 或 ChipWhisperer-Lite 与 Arduino 目标进行通信。此外，配套笔记本还包括“预录制”的功率迹线，这样你就可以在没有硬件的情况下运行此示例。然而，通过瞄准内置的目标而不是你构建的
    Arduino，我们可以使这个攻击更加一致，接下来我们会讨论这一点。此外，我们还将努力使攻击更加自动化，而不需要手动确定区分器的位置和值。
- en: ChipWhisperer-Nano Example
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ChipWhisperer-Nano 示例
- en: Now let’s examine a similar attack on the ChipWhisperer-Nano that includes the
    target, programmer, oscilloscope, and serial port all in one package, which means
    we can concentrate on the sample code and automate the attack. As in other chapters,
    you’ll use a companion notebook ([https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/));
    open that up if you have a ChipWhisperer-Nano.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看对ChipWhisperer-Nano的类似攻击，该设备将目标、编程器、示波器和串口集成在一个包中，这意味着我们可以集中精力处理示例代码并自动化攻击。像其他章节一样，你将使用一个配套的笔记本([https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/))；如果你有ChipWhisperer-Nano，可以打开它。
- en: Building and Loading Firmware
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建并加载固件
- en: First, you need to build the sample software (similar to [Listing 9-1](#listing9-1))
    for the STM32F0 microcontroller target. You don’t need to write your own code,
    as you’ll use the source code that’s part of the ChipWhisperer project. Building
    the firmware simply requires calling `make` from the notebook with the appropriate
    platform specified, as shown in [Listing 9-4](#listing9-4).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为STM32F0微控制器目标构建示例软件（类似于[Listing 9-1](#listing9-1)）。你不需要编写自己的代码，因为你将使用ChipWhisperer项目中的源代码。构建固件只需在笔记本中调用`make`并指定适当的平台，如[Listing
    9-4](#listing9-4)所示。
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-4: Building the `basic-passwdcheck` firmware, similar to [Listing
    9-1](#listing9-1)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-4：构建`basic-passwdcheck`固件，类似于[Listing 9-1](#listing9-1)
- en: You can then connect to the target and program the onboard STM32F0 with the
    notebook code in [Listing 9-5](#listing9-5).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以连接到目标并使用[Listing 9-5](#listing9-5)中的笔记本代码对板载STM32F0进行编程。
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 9-5: Initial setup and programming the included target with our custom
    firmware'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-5：初始化设置并使用我们的自定义固件编程包含的目标
- en: This code creates some default settings for performing the power analysis and
    then programs the firmware hex file built in [Listing 9-4](#listing9-4).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一些执行功率分析的默认设置，并随后编程[Listing 9-4](#listing9-4)中构建的固件hex文件。
- en: A First Glance at the Communication
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初步查看通信
- en: Next, let’s look at what boot messages the device is printing on reset. The
    notebook environment has a function called `reset_target()` that toggles the `nRST`
    line to perform a target reset, after which we can record the serial data coming
    in. To do this, we’ll run the code from [Listing 9-6](#listing9-6).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看设备在重置时打印的启动信息。笔记本环境中有一个名为`reset_target()`的函数，它通过切换`nRST`线来执行目标重置，重置后我们可以记录接收到的串行数据。为此，我们将运行[Listing
    9-6](#listing9-6)中的代码。
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 9-6: Resetting the device and reading the boot messages'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-6：重置设备并读取启动信息
- en: This reset results in the boot messages shown in [Listing 9-7](#listing9-7).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此次重置导致显示[Listing 9-7](#listing9-7)中的启动信息。
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-7: The boot messages from the demo password check code'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-7：演示密码检查代码的启动信息
- en: Looks like some serious boot security . . . but perhaps we can use SPA to attack
    the password comparison. Let’s see what’s actually implemented.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来启动安全性非常强。。。但或许我们可以利用SPA攻击密码比较。让我们看看实际上实现了什么。
- en: Capturing a Trace
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获一个追踪
- en: Because the ChipWhisperer integrates everything into one platform, it’s much
    easier to build a function that performs a power capture on the password comparison.
    The code in [Listing 9-8](#listing9-8) defines a function that captures the power
    trace with a given test password. Most of this code is actually just waiting for
    the boot messages to end, after which the target is waiting for a password to
    be input.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为ChipWhisperer将所有功能集成到一个平台中，所以构建一个执行密码比较功率捕获的功能要容易得多。 [Listing 9-8](#listing9-8)中的代码定义了一个函数，用于使用给定的测试密码捕获功率轨迹。实际上，这段代码大部分时间只是等待启动信息结束，之后目标等待输入密码。
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-8: Function to record the power trace of the target processing any
    arbitrary password'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-8：记录目标处理任意密码的功率轨迹的函数
- en: Next, we simply use `scope.arm()` to tell the ChipWhisperer to wait for the
    trigger event. We send the password to the target, at which point the target will
    perform the password check. Our cooperative target is telling ChipWhisperer the
    moment the comparison is starting through the trigger (in this case, a GPIO pin
    going high, which is the little bit of a cheat we added to the target firmware).
    Finally, we record the power trace and pass it back to the caller.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需使用`scope.arm()`告诉ChipWhisperer等待触发事件。我们将密码发送到目标，目标会执行密码检查。我们的协作目标通过触发器（在这种情况下，是GPIO引脚变高，这是我们在目标固件中添加的小作弊）告诉ChipWhisperer密码比较开始的时刻。最后，我们记录功率轨迹并将其返回给调用者。
- en: With that function defined, we could run [Listing 9-9](#listing9-9) to capture
    the trace.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了该功能后，我们可以运行[清单 9-9](#listing9-9)来捕获跟踪。
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-9: Capturing the trace for a particular password'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-9：捕获特定密码的跟踪
- en: That code should generate the power trace shown in [Figure 9-11](#figure9-11).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码应生成[图 9-11](#figure9-11)所示的功率跟踪。
- en: '![f09011](image_fi/278748c09/f09011.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![f09011](image_fi/278748c09/f09011.png)'
- en: 'Figure 9-11: The power consumption of the device as it is processing a particular
    password'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-11：设备处理特定密码时的功耗
- en: Now that we have the ability to take a power trace for a particular password,
    let’s see if we can turn it into an attack.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够为特定密码捕获功率跟踪，让我们看看是否可以将其转化为攻击。
- en: From Trace to Attack
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从跟踪到攻击
- en: 'As before, the first step is simply sending several different passwords and
    seeing whether we notice a difference between them. The code in [Listing 9-10](#listing9-10)
    sends five different single-character passwords: `0`, `a`, `b`, `c`, or `h`. It
    then generates a plot of the power traces during processing of those passwords.
    (In this case, we’ve cheated, as we know the correct password starts with `h`,
    but we want to make the resulting figures reasonably visible. In reality, you
    may have to look at multiple figures to find the outlier—for example, by grouping
    initial characters `a`–`h`, `i`–`p`, `q`–`x`, and `y`–`z` into separate plots.)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，第一步是简单地发送几个不同的密码，并观察它们之间是否存在差异。代码在[清单 9-10](#listing9-10)中发送了五个不同的单字符密码：`0`、`a`、`b`、`c`或`h`。然后它会生成处理这些密码时的功率跟踪图。（在这种情况下，我们有所偏袒，因为我们知道正确的密码以`h`开头，但我们希望使得结果图形足够明显。实际上，你可能需要查看多个图形才能找到异常值——例如，通过将初始字符`a`–`h`、`i`–`p`、`q`–`x`和`y`–`z`分成不同的图来进行分析。）
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 9-10: A simple test of five password first characters'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-10：五个密码初始字符的简单测试
- en: 'The resulting traces are plotted in [Figure 9-12](#figure9-12), which shows
    the first 100 samples of the power consumption as the device processes two of
    the five different password first characters. One of the characters is the correct
    start to the password. Around sample 18, the power consumption of different characters
    starts to deviate. This is due to the timing leak: if the loop exits early (because
    the first character is wrong), the resulting code execution follows a different
    path from when the first character is correct.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的跟踪图绘制在[图 9-12](#figure9-12)中，显示了设备处理五个不同密码初始字符时前100个样本的功耗。其中一个字符是密码的正确起始字符。在第18个样本附近，不同字符的功耗开始出现偏差。这是由于时间泄漏：如果循环提前退出（因为第一个字符错误），那么接下来的代码执行路径将与第一个字符正确时的路径不同。
- en: '![f09012](image_fi/278748c09/f09012.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![f09012](image_fi/278748c09/f09012.png)'
- en: 'Figure 9-12: Power consumption for five different initial characters'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-12：五个不同初始字符的功耗
- en: If we were to zoom in on [Figure 9-12](#figure9-12) and plot all five power
    traces, we would see that four characters have pretty much the same power trace,
    and one is the clear outlier. We would guess that the outlier is the correct first
    character, as only one character can be correct. We then build up a guess using
    the correct first character and do the same analysis for the unknown second character.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放大[图 9-12](#figure9-12)，并绘制所有五个功率跟踪，我们会发现四个字符的功率跟踪几乎相同，只有一个明显的异常值。我们可以推测异常值是正确的第一个字符，因为只有一个字符是正确的。然后我们根据正确的第一个字符进行猜测，并对未知的第二个字符进行相同的分析。
- en: Using SAD to Find the Password (and Become Happy)
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用SAD来找到密码（并变得开心）
- en: Rather than fine-tune the timing of particular peaks as we did earlier in this
    chapter, we could try to be a bit cleverer and possibly more generic. First, we
    could assume we know a password that will always fail the first character comparison.
    We’ll make an “invalid password template power trace” and compare each following
    trace to the template. In this case, we’ll use a single character set to hex 0x00
    as an invalid password. If we see a major difference between the template and
    the power trace of the device processing a particular character, it suggests that
    that particular character is correct.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在本章前面所做的精细调节特定峰值的时机不同，我们可以尝试更聪明一些，甚至可能更具通用性。首先，我们可以假设我们知道一个密码，它总是会在第一次字符比较时失败。我们将制作一个“无效密码模板功率跟踪”，并将每个后续跟踪与该模板进行比较。在这种情况下，我们将使用一个字符集设置为十六进制`0x00`作为无效密码。如果我们看到模板和设备处理特定字符时的功率跟踪之间有重大差异，那么就意味着这个特定字符是正确的。
- en: A simple method of comparing two arrays is a *sum of absolute difference (SAD)*.
    To calculate the SAD, we find the difference between each point in two traces,
    turn it into an absolute number, then sum up those points. The SAD is a measure
    of how alike two traces are, where 0 means they are exactly the same, and higher
    numbers mean traces are less alike (see [Figure 9-13](#figure9-13)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个数组的一个简单方法是*绝对差和 (SAD)*。计算SAD时，我们找到两个轨迹中每个点的差值，将其转化为绝对值，然后将这些点的值求和。SAD是衡量两个轨迹相似度的标准，其中0表示完全相同，较大的数字表示轨迹之间的差异较大（参见[图
    9-13](#figure9-13)）。
- en: If we don’t sum up the points and look only at the absolute difference, we can
    see some interesting patterns. In [Figure 9-13](#figure9-13), we’ve taken the
    invalid password trace and calculated the absolute difference with two traces.
    One trace was taken using a password with the wrong first character (such as `e`),
    shown as the bottom line with peak far above 0.1\. The other trace was taken with
    a password with the correct first character (`h`), shown as the top noisy line
    that hovers just above 0\. The difference at each point is much larger for the
    correct password. We can now sum up all those points, effectively calculating
    the SAD. We should get a large value for the incorrect character and a much smaller
    value for the correct character.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不将所有点求和，只看绝对差值，我们可以看到一些有趣的模式。在[图 9-13](#figure9-13)中，我们采用了无效密码的轨迹，并计算了它与两个轨迹的绝对差值。一个轨迹是用错误的第一个字符（例如`e`）的密码拍摄的，如下方的线，峰值远高于0.1。另一个轨迹是用正确的第一个字符（`h`）的密码拍摄的，显示为顶部的噪声线，徘徊在0之上。对于正确的密码，每个点的差异要大得多。我们现在可以将所有这些点相加，实际上是在计算SAD。对于错误字符，我们应该得到一个较大的值，对于正确字符，应该得到一个较小的值。
- en: '![f09013](image_fi/278748c09/f09013.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![f09013](image_fi/278748c09/f09013.png)'
- en: 'Figure 9-13: Absolute differences in traces for a correct (top) and incorrect
    (bottom) first password character'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-13：正确（上）和错误（下）第一个密码字符的轨迹绝对差
- en: A Single-Character Attack
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单字符攻击
- en: Because we now have a “goodness” metric in the form of SAD, we can automate
    the attack for the first character. The code in [Listing 9-11](#listing9-11) shows
    a script that runs through a guess list (in this case, lowercase letters and numbers)
    and checks whether any of them results in an obviously different code path. If
    so, it flags that as a likely correct password character.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在我们有了以SAD形式表示的“优度”指标，我们可以自动化攻击第一个字符。[清单 9-11](#listing9-11)中的代码显示了一个脚本，该脚本遍历猜测列表（在这种情况下是小写字母和数字），并检查其中是否有任何一个会导致明显不同的代码路径。如果是，它会将其标记为可能正确的密码字符。
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 9-11: Testing a single character against a known-bad password.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-11：针对已知错误密码测试单个字符。
- en: You’ll need to adjust the threshold for your setup at 2, which is most easily
    done by uncommenting the `print` statement at 1 and checking what differences
    look like for good and bad passwords.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在2处调整阈值，最简单的方法是取消注释1处的`print`语句，然后检查正确和错误密码的差异是什么样的。
- en: A Full Password Recovery
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完整的密码恢复
- en: Building this into a full attack requires only slightly more effort, as implemented
    in [Listing 9-12](#listing9-12). As mentioned previously, our template is built
    using a single-character bad password. Now that we’ve used that template to guess
    the first character, we need another template that represents “first character
    correct, second character wrong.” We do that by capturing a new template from
    the power consumption of the guessed first password character, plus another 0x00.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将其构建为完整的攻击仅需要稍微多一点的工作，正如[清单 9-12](#listing9-12)中所实现的那样。如前所述，我们的模板是使用单个字符的错误密码构建的。现在我们已经使用这个模板猜测了第一个字符，我们需要另一个模板来表示“第一个字符正确，第二个字符错误”。我们通过从猜测的第一个密码字符的功耗中捕获一个新模板，再加上一个0x00来实现这一点。
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 9-12: A full attack script that automatically discovers the password'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-12：一个自动发现密码的完整攻击脚本
- en: We’ve built in a mechanism to validate that the new template is representative.
    The captures can sometimes be noisy, and a noisy reference trace will generate
    false positives. So, a new template is created by grabbing two power traces with
    the same (invalid) password and making sure that the SAD is below some threshold
    at 1. You’ll have to tune this threshold for your setup as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个机制来验证新模板是否具有代表性。捕获数据有时会受到噪声干扰，而噪声较大的参考轨迹会产生误报。因此，通过捕获两条具有相同（无效）密码的功耗轨迹并确保SAD低于某个阈值来创建新模板。你需要根据你的设置调整这个阈值。
- en: A more robust solution would be to average several traces or to detect a trace
    that is an outlier from the full set automatically. The two magic numbers `50`
    and `80` in [Listing 9-12](#listing9-12), however, are the shortest way to accomplish
    the goal.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 更稳健的解决方案是对多个跟踪进行平均，或者自动检测出一个偏离完整数据集的异常跟踪。然而，[列表9-12](#listing9-12)中的两个魔法数字`50`和`80`是实现这一目标的最简便方式。
- en: Running this code should print the full password of `h0px3`. That’s an SPA timing
    attack in just a handful of Python lines.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码应该会打印出完整的`h0px3`密码。这就是一个仅用几行Python代码实现的SPA时序攻击。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter concentrated on how to perform a simple timing attack using power
    analysis. You can use the methods described here for all sorts of attacks on real
    systems. The only way to get a good handle on them is through hands-on experimentation.
    When it comes time to attacking real systems, you’ll also learn that the first
    step is almost always to characterize the system. These characterizations take
    the same form as the experiments you did here, such as simply measuring what sort
    of leakage you can find.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讲解了如何通过功耗分析执行简单的时序攻击。你可以将这里描述的方法用于对真实系统的各种攻击。获得对这些方法的深入理解的唯一途径就是通过动手实验。在进行真实系统攻击时，你还将学到，第一步几乎总是对系统进行特征分析。这些特征分析与你在这里做的实验类似，例如简单地测量你能找到的泄漏类型。
- en: If you want to try public-key cryptography for the SPA examples, you could use
    an open source library like avr-crypto-lib. You’ll even find ports of this library
    to Arduino.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在SPA示例中尝试公钥密码学，可以使用像avr-crypto-lib这样的开源库。你甚至会发现这个库的Arduino移植版。
- en: The ChipWhisperer platform helps abstract away some of the dirty low-level hardware
    details, so you can concentrate on the more interesting high-level aspects of
    the attack. The ChipWhisperer site includes tutorials and Python-based sample
    code to interface to a variety of devices, including various oscilloscopes, serial
    port drivers, and smartcard readers. Not all targets are part of the ChipWhisperer
    platform, so for that reason, it can be beneficial to implement “bare-metal” attacks
    yourself.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ChipWhisperer平台有助于抽象掉一些脏乱的底层硬件细节，帮助你专注于攻击的更有趣的高层次方面。ChipWhisperer网站包括教程和基于Python的示例代码，用于与各种设备接口，包括各种示波器、串口驱动程序和智能卡读卡器。并非所有目标都属于ChipWhisperer平台，因此，自己实现“裸机”攻击可能会有所帮助。
- en: Next, we’ll expand on this simple attack to read data out of a device under
    test. Doing so means not only seeing what sort of program flow is occurring, but
    also actually determining the secret data being used.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展这个简单的攻击，读取被测设备中的数据。这样做不仅是查看程序流程，还要实际确定正在使用的秘密数据。
