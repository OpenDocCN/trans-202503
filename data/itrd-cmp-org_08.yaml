- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: MEMORY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内存**
- en: '![Image](../images/pg23_Image_2.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg23_Image_2.jpg)'
- en: In the previous three chapters, you learned about some of the hardware used
    to implement logical functions. Now, we’ll look at how this functionality can
    be used to implement the subsystems that make up a computer, starting with memory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的三章中，你已经学习了用于实现逻辑功能的一些硬件。现在，我们将探讨如何利用这些功能来实现构成计算机的子系统，从内存开始。
- en: Every computer user wants lots of memory and fast computing. However, faster
    memory costs more money, so there are some trade-offs. I’ll begin this chapter
    with a discussion of how different types of memory are used to provide a reasonable
    compromise between speed and cost. Then, I’ll describe a few different ways of
    implementing memory in hardware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个计算机用户都希望拥有大量内存和快速计算。然而，速度更快的内存价格更高，因此必须做出一定的权衡。本章将以不同类型内存如何平衡速度与成本的使用方式开始。然后，我将描述几种实现内存硬件的不同方法。
- en: '**The Memory Hierarchy**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内存层次结构**'
- en: In general, the closer memory is to the CPU, the faster and more expensive it
    is. The slowest memory is memory in the cloud. It’s also the least expensive.
    My email account provides 15GB of storage in the cloud and doesn’t cost me any
    money (if I ignore the “cost” of seeing a few advertisements), but its speed is
    limited by my internet connection. At the other extreme, the memory within the
    CPU runs at the same speed as the CPU but is relatively expensive. The Raspberry
    Pi has a little over 500 bytes of memory in the CPU available for us to use in
    our programs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，内存距离CPU越近，它的速度就越快，成本也越高。最慢的内存是云端内存，成本也最低。我的电子邮件账户在云端提供15GB的存储空间，并且不收费（如果忽略看到一些广告的“成本”），但其速度受限于我的互联网连接。而在另一端，CPU内部的内存与CPU运行速度相同，但相对较贵。树莓派的CPU中大约有500字节的内存可以供我们在程序中使用。
- en: '[Figure 8-1](ch08.xhtml#ch8fig1) shows this general hierarchy. As we get closer
    to the CPU (at the top of the figure), memory is faster and costs more money,
    so there’s less of it.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-1](ch08.xhtml#ch8fig1)展示了这种内存层次结构。随着我们接近CPU（图中的顶部），内存速度更快，成本也更高，因此内存的数量较少。'
- en: '![Image](../images/pg180_Image_230.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg180_Image_230.jpg)'
- en: '*Figure 8-1: The computer memory hierarchy*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-1：计算机内存层次结构*'
- en: The top three layers in [Figure 8-1](ch08.xhtml#ch8fig1) are typically included
    in the CPU chip in modern computers. There may be one or two more levels of cache
    before getting to main memory. Main memory and a disk or solid-state drive (SSD),
    or both, are usually within the same enclosure as the CPU.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-1](ch08.xhtml#ch8fig1)中的前三层通常包括在现代计算机的CPU芯片中。在到达主内存之前，可能还有一到两层缓存。主内存和磁盘或固态硬盘（SSD），或两者，通常与CPU在同一机箱内。'
- en: The next layer away from the CPU represents offline data storage devices, of
    which DVDs and memory sticks are only two examples. You may also have an external
    USB disk, a tape drive, and so forth. To make these devices available to the computer,
    you usually need to take some physical action, such as inserting a DVD in the
    drive or plugging a memory stick into a USB port.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 离CPU最远的下一层代表离线数据存储设备，其中DVD和U盘只是两个例子。你可能还有外部USB磁盘、磁带驱动器等。为了使这些设备对计算机可用，通常需要采取一些物理操作，例如将DVD插入驱动器或将U盘插入USB端口。
- en: The final layer in this hierarchy is storage in the cloud. Although most of
    us set up our computers to log on to the cloud automatically, it may not always
    be available.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层次结构的最后一层是云端存储。虽然我们大多数人将计算机设置为自动登录云端，但它并不总是可用的。
- en: In this chapter, I’ll start with the two layers just above the cloud layer,
    offline storage and disk/SSD, and work toward the CPU registers. Then, I’ll describe
    the hardware used to build registers and work back out toward main memory. We’ll
    leave discussion of implementation of the three outermost layers to other books.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将从云层之上的两层开始，分别是离线存储和磁盘/SSD，并向CPU寄存器推进。然后，我将描述构建寄存器所使用的硬件，并逐步讲解向主内存扩展的过程。我们将把最外层三层的实现讨论留给其他书籍。
- en: '***Mass Storage***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***大容量存储***'
- en: Collectively, the two layers above the cloud layer in [Figure 8-1](ch08.xhtml#ch8fig1)
    are known as *mass storage*. Mass storage devices store large amounts of data,
    and the data persists when the power to the device is turned off.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图8-1](ch08.xhtml#ch8fig1)中，云层之上的两层统称为*大容量存储*。大容量存储设备存储大量数据，而且当设备断电时数据仍然会保留。
- en: Let’s take another look at the major subsystems of a computer, introduced in
    [Chapter 1](ch01.xhtml). As shown in [Figure 8-2](ch08.xhtml#ch8fig2), the three
    subsystems communicate with one another via the data, control, and address buses.
    In addition, the input/output (I/O) block includes specialized circuitry that
    interfaces with mass storage devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下计算机的主要子系统，在[第1章](ch01.xhtml)中介绍过。正如[图8-2](ch08.xhtml#ch8fig2)所示，三个子系统通过数据、控制和地址总线相互通信。此外，输入/输出（I/O）块包括与大容量存储设备接口的专用电路。
- en: '![Image](../images/pg181_Image_231.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg181_Image_231.jpg)'
- en: '*Figure 8-2: The subsystems of a computer*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-2：计算机的子系统*'
- en: The Raspberry Pi, for example, has circuitry that implements the SD bus protocol
    and uses a micro SD card as its SSD. The operating system includes software (a
    *device driver*) that applications call to access the data and applications on
    the micro SD card through the SD port. I’ll discuss I/O programming in [Chapter
    20](ch20.xhtml), but the specifics of device drivers are beyond the scope of this
    book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，树莓派有电路实现了SD总线协议，并使用micro SD卡作为其SSD。操作系统包括软件（*设备驱动程序*），应用程序通过该软件访问micro SD卡上的数据和应用程序。我将在[第20章](ch20.xhtml)中讨论I/O编程，但设备驱动程序的具体内容超出了本书的范围。
- en: In the rest of this chapter, I’ll cover *volatile memory*, which loses its contents
    when the power is turned off.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我将介绍*易失性内存*，当电源关闭时其内容会丢失。
- en: '***Main Memory***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***主内存***'
- en: '*Main memory* is the random-access memory (RAM) that you see in the specifications
    when you buy a computer. Main memory is synchronized in the hardware with the
    CPU via the bus interface, which I’ll discuss in [Chapters 9](ch09.xhtml) and
    [20](ch20.xhtml). Thus, a programmer can access items in memory by simply specifying
    the address and whether to load the item from memory or to store a new value there.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*主内存*是你在购买计算机时在规格中看到的随机存取内存（RAM）。主内存在硬件中通过总线接口与CPU同步，我将在[第9章](ch09.xhtml)和[第20章](ch20.xhtml)中讨论。因此，程序员只需指定地址以及是从内存加载项还是存储新值，就可以访问内存中的项目。'
- en: The amount of memory in your Raspberry Pi depends on the model. The Raspberry
    Pi 3 A+ has 512MB and the 3 B and 3 B+ each have 1GB. The Raspberry Pi 4 B can
    have 2, 4, or 8GB. The Raspberry Pi 5 can have 4 or 8GB. Other memory configurations
    may be available.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你的树莓派内存大小取决于型号。树莓派3 A+有512MB，3 B和3 B+每个有1GB。树莓派4 B可以有2GB、4GB或8GB。树莓派5可以有4GB或8GB。其他内存配置可能也有。
- en: Usually, the entire program and dataset are not loaded into main memory. Instead,
    the operating system loads only the portion currently being worked on from mass
    storage into main memory. Most mass storage devices in modern computers can be
    accessed only in *blocks* of predetermined size. For example, the Raspberry Pi
    OS uses a disk block size of 4KB. When a needed instruction or data item is loaded
    into main memory, the computer loads the whole block of instructions or data that
    includes the needed item. The chances are good that the nearby parts of the program
    (instructions or data) will be needed soon. Since they’re already in main memory,
    the operating system doesn’t need to access the mass storage device again, thus
    speeding up program execution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，整个程序和数据集不会加载到主内存中。相反，操作系统只将当前正在处理的部分从大容量存储加载到主内存中。现代计算机中的大多数大容量存储设备只能按预定大小的*块*进行访问。例如，树莓派操作系统使用4KB的磁盘块大小。当需要的指令或数据项被加载到主内存时，计算机会加载包含所需项目的整个指令或数据块。程序中附近的部分（指令或数据）很可能很快会被需要。由于它们已经在主内存中，操作系统无需再次访问大容量存储设备，从而加快了程序执行速度。
- en: The most common organization of main memory is to store both the program instructions
    and data in main memory. This is referred to as the *von Neumann architecture*
    as it was initially described by John von Neumann (“First Draft of a Report on
    the EDVAC,” Moore School of Electrical Engineering, University of Pennsylvania,
    1945), although other computer science pioneers of the day were working on the
    same concepts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 主内存最常见的组织方式是将程序指令和数据都存储在主内存中。这被称为*冯·诺依曼架构*，最初由约翰·冯·诺依曼描述（《EDVAC报告初稿》，宾夕法尼亚大学摩尔电气工程学院，1945年），尽管当时其他计算机科学先驱也在研究相同的概念。
- en: 'One downside of the von Neumann architecture is that if an instruction calls
    for reading data from (or writing data to) memory, the next instruction in the
    program sequence cannot be read from (or written to) memory over the same bus
    until the current instruction has completed the data transfer. This is known as
    the *von Neumann bottleneck*. This conflict slows program execution, and it gave
    rise to another stored program architecture: the *Harvard architecture*, in which
    the program and data are stored in different memories, each with its own bus connected
    to the CPU. This makes it possible for the CPU to access program instructions
    and data simultaneously. This specialization reduces memory usage flexibility,
    which generally increases the total amount of memory needed. It also requires
    additional memory access hardware. The additional memory and access hardware increase
    the cost. It’s common for the Level 1 cache to have a Harvard architecture, thus
    providing separate paths to the CPU for the instructions and the data.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 冯·诺依曼架构的一个缺点是，如果一条指令要求从内存中读取数据（或写入数据），程序序列中的下一条指令在当前指令完成数据传输之前无法通过同一总线从内存中读取（或写入）。这被称为
    *冯·诺依曼瓶颈*。这种冲突会减慢程序执行速度，并催生了另一种存储程序架构：*哈佛架构*，其中程序和数据存储在不同的内存中，每个内存都有各自的总线连接到 CPU。这使得
    CPU 可以同时访问程序指令和数据。这种专业化减少了内存使用的灵活性，通常会增加所需的总内存量。它还需要额外的内存访问硬件。这些额外的内存和访问硬件增加了成本。Level
    1 缓存通常采用哈佛架构，从而为指令和数据提供单独的路径连接到 CPU。
- en: Another downside of the von Neumann architecture is that a program can be written
    to view itself as data, thus enabling self-modification, which is generally a
    bad idea. Linux, like most modern, general-purpose operating systems, prohibits
    applications from modifying themselves.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 冯·诺依曼架构的另一个缺点是，程序可以被编写成将自身视为数据，从而启用自我修改，这通常是个坏主意。像大多数现代通用操作系统一样，Linux 禁止应用程序自我修改。
- en: '***Cache Memory***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓存内存***'
- en: Most of the programs I use take up tens or hundreds of megabytes in main memory,
    but most of the execution time is taken up by loops, which execute the same few
    instructions repeatedly, access the same few variables, and occupy only tens or
    hundreds of bytes. Most modern computers include very fast *cache memory* between
    the main memory and the CPU, which provides a much faster location for the instructions
    and variables currently being processed by the program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的大多数程序占用主内存的几十或几百兆字节，但大多数执行时间被循环占用，这些循环反复执行相同的几条指令，访问相同的几个变量，占用的内存只有几十或几百字节。大多数现代计算机在主内存和
    CPU 之间包括非常快速的 *缓存内存*，它为当前正在处理的程序指令和变量提供了一个更快的位置。
- en: Cache memory is organized in levels, with Level 1 being the closest to the CPU
    and also the smallest. Cache sizes of the Raspberry Pi vary, as shown in [Table
    8-1](ch08.xhtml#ch8tab1).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存内存按层次组织，Level 1 最靠近 CPU，也是最小的。树莓派的缓存大小各不相同，如 [表 8-1](ch08.xhtml#ch8tab1) 所示。
- en: '**Table 8-1:** The Raspberry Pi’s Cache Sizes'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1:** 树莓派的缓存大小'
- en: '|  | **Level 1** | **Level 2** | **Level 3** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  | **Level 1** | **Level 2** | **Level 3** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Model** | **Instruction** | **Data** | **Unified** | **Unified** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **型号** | **指令** | **数据** | **统一** | **统一** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 3 A+, B, B+ | 4 *×* 32KB | 4 *×* 32KB | 512KB | n/a |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 3 A+, B, B+ | 4 *×* 32KB | 4 *×* 32KB | 512KB | n/a |'
- en: '| 4 B | 4 *×* 48KB | 4 *×* 32KB | 1MB | n/a |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 4 B | 4 *×* 48KB | 4 *×* 32KB | 1MB | n/a |'
- en: '| 5 | 4 *×* 64KB | 4 *×* 64KB | 4 *×* 512KB | 2MB |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 4 *×* 64KB | 4 *×* 64KB | 4 *×* 512KB | 2MB |'
- en: '**NOTE**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I have seen conflicting information about cache sizes on the various Raspberry
    Pi models, so I don’t guarantee the accuracy of the sizes in [Table 8-1](ch08.xhtml#ch8tab1),
    but they are close enough to illustrate how caches work.*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*我见过关于不同树莓派型号的缓存大小的不同信息，所以我不能保证 [表 8-1](ch08.xhtml#ch8tab1) 中的缓存大小的准确性，但它们足够接近，可以说明缓存的工作原理。*'
- en: The portion of the CPU that performs the computations is called the *processor
    core*, or simply the *core*. The CPUs in all the Raspberry Pi models in [Table
    8-1](ch08.xhtml#ch8tab1) have four processor cores. The notation 4 × prefacing
    a memory size in this table means that each processor core has that amount of
    cache memory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行计算的 CPU 部分称为 *处理器核心*，或简称 *核心*。所有树莓派型号中的 CPU，如 [表 8-1](ch08.xhtml#ch8tab1)
    中所示，均具有四个处理器核心。表格中前缀为 4 × 的内存大小表示每个处理器核心都拥有该量的缓存内存。
- en: The Raspberry Pi 3 and 4 have two cache levels, and the Raspberry Pi 5 has three.
    Level 1 on all models uses a Harvard architecture. The Level 2 and 3 caches are
    all unified caches that hold both instructions and data. Cache memory in the Raspberry
    Pi is organized in 64-byte blocks called *lines*. Instructions and data are transferred
    to and from main memory one line at a time on a 64-byte address boundary.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 3和4具有两个缓存级别，而Raspberry Pi 5有三个。所有型号的一级缓存都使用哈佛架构。二级和三级缓存都是统一缓存，存储指令和数据。Raspberry
    Pi中的缓存内存按64字节块组织，称为*行*。指令和数据通过64字节的地址边界，一次一行地从主内存传输到缓存，反之亦然。
- en: When a program needs to access an instruction or data item, the hardware first
    checks to see if it’s located in the Level 1 cache. If not, it checks the Level
    2 cache. If it’s in the Level 2 cache, the hardware copies the cache line that
    includes the needed instruction or data into the Level 1 cache and then into the
    CPU, where it stays until the program needs it again or the Level 1 cache needs
    to reuse that location for other instructions or data from the Level 2 cache.
    The hardware continues this process to subsequent cache levels until it either
    finds the needed item in a cache or reaches main memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序需要访问指令或数据项时，硬件首先检查它是否位于一级缓存中。如果没有，它会检查二级缓存。如果数据在二级缓存中，硬件将包含所需指令或数据的缓存行复制到一级缓存，然后再传送到CPU，在程序再次需要该数据或一级缓存需要为来自二级缓存的其他指令或数据重新使用该位置之前，数据将一直保留在那里。硬件继续这个过程，直到它在某个缓存中找到所需项，或者到达主内存。
- en: When data is written to main memory, it’s first written to the Level 1 cache,
    then the next cache levels. There are many schemes for using caches, which can
    become rather complex. I’ll leave further discussion of caches for more advanced
    treatments, such as the Wikibooks article on microprocessor design and caches
    at *[https://en.wikibooks.org/wiki/Microprocessor_Design/Cache](https://en.wikibooks.org/wiki/Microprocessor_Design/Cache)*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据被写入主内存时，它首先被写入一级缓存，然后是下一级缓存。使用缓存有许多方案，它们可能变得相当复杂。我将把进一步讨论缓存的内容留给更高级的内容，例如*
    [https://en.wikibooks.org/wiki/Microprocessor_Design/Cache](https://en.wikibooks.org/wiki/Microprocessor_Design/Cache)
    *上的微处理器设计和缓存的维基书文章。
- en: The time taken to access the Level 1 cache is close to the speed of the CPU.
    Level 2 is about 10 times slower, Level 3 about 100 times slower, and main memory
    about 1,000 times slower. These values are approximate and differ widely among
    implementations. Modern processors include cache memory in the same chip as the
    CPU, and some have more than three levels of cache.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 访问一级缓存的时间接近CPU的速度。二级缓存大约慢10倍，三级缓存大约慢100倍，主内存大约慢1000倍。这些值是近似的，并且在不同的实现中差异很大。现代处理器将缓存内存集成在与CPU相同的芯片中，有些处理器甚至具有超过三个级别的缓存。
- en: Computer performance is usually limited by the time it takes for the CPU to
    read instructions and data into the CPU, not by the speed of the CPU itself. Having
    the instructions and data in the Level 1 cache reduces this time. Of course, if
    they are not in the Level 1 cache and the hardware needs to copy other instructions
    or data from Level 2 or Level 3, or from main memory into Level 3, then Level
    2, and finally Level 1, access will take longer than simply getting the instructions
    or data directly from main memory. The effectiveness of caches depends on the
    *locality of reference*, which is the tendency of a program to reference nearby
    memory addresses in a short period of time. This is one of the reasons good programmers
    break a program, especially repetitive sections, into small units. A small program
    unit is more likely to fit within a few lines of a cache, where it will be available
    for successive repetitions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的性能通常受到CPU读取指令和数据到CPU所需时间的限制，而不是CPU本身的速度。将指令和数据放入一级缓存可以减少这一时间。当然，如果它们不在一级缓存中，硬件需要从二级或三级缓存中，或从主内存复制其他指令或数据到三级缓存，再到二级缓存，最终到达一级缓存，那么访问将比直接从主内存获取指令或数据花费更长的时间。缓存的有效性取决于*局部性原理*，即程序在短时间内倾向于访问附近的内存地址。这也是为什么优秀程序员将程序，特别是重复的部分，拆分成小单元的原因。一个小的程序单元更有可能完全装入缓存中的几行，从而在连续重复时能够迅速访问。
- en: '**YOUR TURN**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 8.1     Determine the cache size(s) on your Raspberry Pi. The `lscpu` command
    will show you the model name of your CPU.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 8.1    确定你的Raspberry Pi的缓存大小。`lscpu`命令将显示你的CPU型号名称。
- en: 8.2     Determine the line size of each of the caches on your Raspberry Pi.
    You can use the `getconf -a| grep CACHE` command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 8.2 确定您的树莓派上每个缓存的行大小。您可以使用`getconf -a| grep CACHE`命令。
- en: '***Registers***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***寄存器***'
- en: 'The fastest memory is within the CPU itself: the *registers*. Registers typically
    provide a few hundred bytes of storage and are accessed at the same speed as the
    CPU. They’re mainly used for numerical computations, logical operations, temporary
    data storage, holding addresses, and similar short-term operations—somewhat like
    how we use scratch paper when doing computations by hand.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最快的内存是在CPU内部：*寄存器*。寄存器通常提供几百字节的存储，并以与CPU相同的速度访问。它们主要用于数值计算、逻辑运算、临时数据存储、保存地址以及类似的短期操作——有点像我们在手动计算时使用的草稿纸。
- en: Many registers are directly accessible by the programmer, while others are hidden.
    Some are used in the hardware that serves to interface between the CPU and I/O
    devices. The organization of registers in the CPU is specific to the particular
    CPU architecture, and it’s one of the most important aspects of programming a
    computer at the assembly language level.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 许多寄存器可以直接由程序员访问，而其他寄存器则是隐藏的。一些寄存器用于硬件中，起到CPU与I/O设备之间的接口作用。CPU中的寄存器组织方式特定于特定的CPU架构，这是在汇编语言级别编程计算机时最重要的方面之一。
- en: In the next chapter, you’ll learn about the main registers in the ARM CPU that
    we’ll be using for our programming in this book. But before we get to that, let’s
    look at how memory can be implemented in hardware using the logic devices discussed
    in previous chapters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解我们将在本书编程中使用的ARM CPU中的主要寄存器。但在进入这一部分之前，让我们先看看如何使用前几章讨论的逻辑设备在硬件中实现内存。
- en: '**Implementing Memory in Hardware**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在硬件中实现内存**'
- en: Starting at the top of the hierarchy shown in [Figure 8-1](ch08.xhtml#ch8fig1),
    we’ll first see how we can implement the memory in the CPU registers. We will
    then work our way back down from the CPU, and you’ll see some of the limitations
    that arise when applying these designs to larger memory systems, such as cache
    and main memory. We’ll explore designs for the memory in these larger systems,
    but I won’t cover the implementation of mass storage systems in this book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图8-1](ch08.xhtml#ch8fig1)中显示的层次结构的顶部开始，我们将首先看到如何在CPU寄存器中实现内存。然后，我们将从CPU开始，逐步向下探讨，您将看到在将这些设计应用于更大内存系统时出现的一些限制，例如缓存和主内存。我们将探索这些更大系统中内存的设计，但本书中不会涉及大容量存储系统的实现。
- en: '***Four-Bit Registers***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***四位寄存器***'
- en: Let’s begin with a design for a simple *4-bit register*, which might be found
    in inexpensive CPUs used in price-sensitive consumer products, such as coffee
    makers and remote controls. [Figure 8-3](ch08.xhtml#ch8fig3) shows a design for
    implementing a 4-bit register using a D flip-flop for each bit. Each time the
    clock does a positive transition, the state (contents) of the register, *r* =
    *r*[3]*r*[2]*r*[1]*r*[0], is set to the input, *d* = *d*[3]*d*[2]*d*[1]*d*[0].
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的*4位寄存器*设计开始，这种寄存器可能出现在用于价格敏感型消费品（如咖啡机和遥控器）的廉价CPU中。[图8-3](ch08.xhtml#ch8fig3)展示了一个使用D触发器实现4位寄存器的设计。每当时钟进行正向跳变时，寄存器的状态（内容）*r*
    = *r*[3]*r*[2]*r*[1]*r*[0]被设置为输入*d* = *d*[3]*d*[2]*d*[1]*d*[0]。
- en: '![Image](../images/pg185_Image_232.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg185_Image_232.jpg)'
- en: '*Figure 8-3: A 4-bit register using a D flip-flop for each bit*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-3：每个位使用D触发器的4位寄存器*'
- en: The problem with this circuit is that any changes in any *d[i]* will change
    the state of the corresponding stored bit, *r[i]*, in the next clock cycle, so
    the contents of the register are essentially valid for only one clock cycle. One-cycle
    buffering of a bit pattern is fine for some applications, but we also need registers
    that will store a value until it is explicitly changed, perhaps billions of clock
    cycles later. Let’s add a *Store* signal and feedback from the output, *r[i]*,
    of each bit. We want each *r[i]* to remain unchanged when *Store* = `0` and to
    follow the input, *d[i]*, when *Store* = `1`, as shown in [Table 8-2](ch08.xhtml#ch8tab2).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个电路的问题在于，任何*d[i]*的变化都会改变下一个时钟周期中相应存储位*r[i]*的状态，因此寄存器的内容实际上只有一个时钟周期内是有效的。一位模式的单周期缓冲对于某些应用是可以的，但我们还需要能够存储值，直到它被显式更改，可能是在数十亿个时钟周期后。让我们添加一个*Store*信号，并从每个位的输出*r[i]*反馈。当*Store*
    = `0`时，我们希望每个*r[i]*保持不变，当*Store* = `1`时，它跟随输入*d[i]*，如[表8-2](ch08.xhtml#ch8tab2)所示。
- en: '**Table 8-2:** Storing One Bit in a D Flip-Flop'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-2：** 在D触发器中存储一位'
- en: '| ***Store*** | ***d******[i]*** | ***r****[i]*** | ***Q*** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| ***存储*** | ***d******[i]*** | ***r****[i]*** | ***Q*** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `1` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `1` |'
- en: '| `0` | `1` | `0` | `0` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` |'
- en: '| `0` | `1` | `1` | `1` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` |'
- en: '| `1` | `0` | `0` | `0` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` |'
- en: '| `1` | `0` | `1` | `0` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `0` |'
- en: '| `1` | `1` | `0` | `1` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` |'
- en: '| `1` | `1` | `1` | `1` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` |'
- en: '[Table 8-2](ch08.xhtml#ch8tab2) leads to the Boolean equation for *Q*, the
    new output of each D flip-flop:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-2](ch08.xhtml#ch8tab2)导出了*Q*的布尔方程，这是每个D触发器的新输出：'
- en: '![Image](../images/pg186_Image_233.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg186_Image_233.jpg)'
- en: This equation can be implemented with three NAND gates at the input of each
    D flip-flop, as shown in [Figure 8-4](ch08.xhtml#ch8fig4).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程可以通过在每个D触发器的输入端使用三个NAND门来实现，如[图 8-4](ch08.xhtml#ch8fig4)所示。
- en: '![Image](../images/pg186_Image_234.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg186_Image_234.jpg)'
- en: '*Figure 8-4: A 4-bit register with* Store *signal*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：带有存储*信号*的4位寄存器*'
- en: There’s another important feature of this design that follows from the primary/secondary
    property of the D flip-flops. The state of the secondary portion does not change
    until the second half of the clock cycle. So, the circuit connected to the output
    of this register can read the current state during the first half of the clock
    cycle, while the primary portion is preparing to possibly change the state to
    the new contents.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计还有另一个重要特性，源自D触发器的主从特性。从部分的状态在时钟周期的后半段才会改变。因此，连接到该寄存器输出的电路可以在时钟周期的前半段读取当前状态，而主部分则准备可能将状态更改为新内容。
- en: We now have a way to store, for example, the results from an adder circuit.
    The output from the register could be used as the input to another circuit that
    performs arithmetic or logical operations on the data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种方法来存储，例如，加法器电路的结果。寄存器的输出可以作为另一个电路的输入，该电路对数据执行算术或逻辑操作。
- en: Registers can also be designed to perform simple operations on the data stored
    in them. Next, we’ll look at a register design that can convert serial data to
    a parallel format.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器还可以被设计用来对存储在其中的数据执行简单的操作。接下来，我们将看到一个寄存器设计，它可以将串行数据转换为并行格式。
- en: '***Shift Registers***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移位寄存器***'
- en: A *shift register* uses a sequence of D flip-flops, like the simple storage
    register in [Figure 8-4](ch08.xhtml#ch8fig4), but the output of each flip-flop
    is connected to the input of the next flip-flop in the sequence, as shown in [Figure
    8-5](ch08.xhtml#ch8fig5). We can use a shift register as a *serial-in parallel-out
    (SIPO)* device.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*移位寄存器*使用一系列D触发器，就像[图 8-4](ch08.xhtml#ch8fig4)中的简单存储寄存器一样，但每个触发器的输出都连接到下一个触发器的输入端，如[图
    8-5](ch08.xhtml#ch8fig5)所示。我们可以将移位寄存器用作*串行输入并行输出（SIPO）*设备。
- en: '![Image](../images/pg187_Image_235.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg187_Image_235.jpg)'
- en: '*Figure 8-5: A 4-bit serial-to-parallel shift register*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：一个4位串行到并行移位寄存器*'
- en: In the shift register in [Figure 8-5](ch08.xhtml#ch8fig5), a serial stream of
    bits is input at *s[i]*. At each clock tick, the output of Q0 is applied to the
    input of Q1, thus copying the previous value of *r*[0] to the new *r*[1]. The
    state of Q0 changes to the value of the new *s[i]*, thus copying this to be the
    new value of *r*[0]. The serial stream of bits continues to ripple through the
    4 bits of the shift register. At any time, the last 4 bits in the serial stream
    are available in parallel at the four outputs, *r*[3], *r*[2], *r*[1], *r*[0],
    with *r*[3] being the oldest in time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 8-5](ch08.xhtml#ch8fig5)中的移位寄存器中，一串串行比特流输入到*s[i]*。每当时钟跳动一次，Q0的输出会被应用到Q1的输入端，从而将*r*[0]的前一个值复制到新的*r*[1]。Q0的状态会变为新的*s[i]*的值，从而将此值复制为新的*r*[0]。串行比特流继续在移位寄存器的4个位中传播。在任何时刻，串行流中的最后4位可以并行显示在四个输出端，即*r*[3]、*r*[2]、*r*[1]、*r*[0]，其中*r*[3]是最早的。
- en: The same circuit could be used to provide a time delay of four clock ticks in
    a serial bit stream; simply use *r*[3] as the serial output.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的电路可以用来提供一个四个时钟周期的时间延迟，在串行比特流中；只需将*r*[3]作为串行输出。
- en: '#### ***The Register File***'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***寄存器文件***'
- en: The registers in the CPU that are used for similar operations are grouped together
    into a *register file*. For example, as you’ll see in the next chapter, the CPU
    in the Raspberry Pi we’ll be programming includes 31 64-bit general-purpose registers
    that are used for integer computations, temporary storage of addresses, and so
    forth. We need a mechanism for addressing each of the registers in the register
    file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 中用于类似操作的寄存器被组合成一个 *寄存器文件*。例如，正如你将在下一章中看到的，我们要编程的 Raspberry Pi 的 CPU 包含 31
    个 64 位通用寄存器，用于整数运算、地址的临时存储等。我们需要一种机制来寻址寄存器文件中的每个寄存器。
- en: Consider a register file composed of eight of the 4-bit registers shown in [Figure
    8-4](ch08.xhtml#ch8fig4). We’ll name the outputs from the eight registers *r*0
    through *r*7\. Thus, the *i*th bits from the eight registers are *r*0*[i]* through
    *r*7*[i]*. To read the 4 bits of data in one of these eight registers (for example,
    *r*5[3], *r*5[2], *r*5[1], and *r*5[0] in register *r*5), we need to specify one
    of the eight registers using 3 bits. You learned in [Chapter 6](ch06.xhtml) that
    a multiplexer can select one of several inputs. We can connect an 8 × 1 multiplexer
    to each corresponding bit of the eight registers, as shown in [Figure 8-6](ch08.xhtml#ch8fig6).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个由八个 4 位寄存器组成的寄存器文件，如[图 8-4](ch08.xhtml#ch8fig4)所示。我们将八个寄存器的输出命名为 *r*0 到
    *r*7。因此，来自八个寄存器的 *i* 位分别是 *r*0*[i]* 到 *r*7*[i]*。要读取其中一个寄存器的 4 位数据（例如，寄存器 *r*5
    中的 *r*5[3]、*r*5[2]、*r*5[1] 和 *r*5[0]），我们需要使用 3 位来指定其中一个寄存器。你在[第六章](ch06.xhtml)学到过，
    multiplexer（多路复用器）可以选择多个输入中的一个。我们可以将一个 8 × 1 的多路复用器连接到这八个寄存器的每一位，如[图 8-6](ch08.xhtml#ch8fig6)所示。
- en: '![Image](../images/pg188_Image_236.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg188_Image_236.jpg)'
- en: '*Figure 8-6: An eight-way multiplexer used to select the output of the register
    file*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：用于选择寄存器文件输出的八路多路复用器*'
- en: The inputs to the multiplexer, *r*0*[i]*–*r*7*[i]*, are the *i*th bits from
    each of eight registers, *r*0–*r*7\. The slash through the *RegSel* line with
    a 3 next to it is the notation used to show there are three lines here.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 多路复用器的输入，*r*0*[i]*–*r*7*[i]*，是来自八个寄存器 *r*0–*r*7 的 *i* 位。*RegSel* 线上的斜杠和旁边的 3
    是用来表示这里有三条线路的符号。
- en: '[Figure 8-6](ch08.xhtml#ch8fig6) shows only the output of the *i*th bit; *n*
    multiplexers are required for *n*-bit registers, so a 4-bit register would need
    four of these multiplexer output circuits. The same *RegSel* would be applied
    simultaneously to all four multiplexers to output all 4 bits of the same register.
    Larger registers would require correspondingly more multiplexers.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-6](ch08.xhtml#ch8fig6)只显示了 *i* 位的输出；对于 *n* 位寄存器，需要 *n* 个多路复用器，因此一个 4 位寄存器需要四个这样的多路复用器输出电路。同一个
    *RegSel* 会同时应用于所有四个多路复用器，以输出同一寄存器的所有 4 位。更大的寄存器则需要相应更多的多路复用器。'
- en: '***Read/Write Memory***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***读/写内存***'
- en: You saw how to build a 4-bit register to store values from D flip-flops in [Figure
    8-3](ch08.xhtml#ch8fig3). We now need to be able to select when to read the value
    that’s stored in the register and disconnect the output when we’re not reading
    it. A tristate buffer (introduced in [Chapter 6](ch06.xhtml)) allows us to do
    that, as shown in [Figure 8-7](ch08.xhtml#ch8fig7). This circuit is for only one
    4-bit register. We need one of these for each register in the computer. The addr
    *[j]* line comes from a decoder and selects one of the registers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在[图 8-3](ch08.xhtml#ch8fig3)中看到过如何构建一个 4 位寄存器来存储来自 D 触发器的值。现在，我们需要能够选择何时读取寄存器中存储的值，并在不读取时断开输出。一个三态缓冲器（在[第六章](ch06.xhtml)中介绍）可以实现这一点，如[图
    8-7](ch08.xhtml#ch8fig7)所示。该电路仅适用于一个 4 位寄存器。我们需要为计算机中的每个寄存器配备一个这样的电路。addr *[j]*
    线来自解码器，用于选择一个寄存器。
- en: '![Image](../images/pg189_Image_237.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg189_Image_237.jpg)'
- en: '*Figure 8-7: A 4-bit read/write register*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-7：一个 4 位读/写寄存器*'
- en: '*Write* = `1` causes the 4-bit data *d*[3]*d*[2]*d*[1]*d*[0] to be stored in
    the D flip-flops Q3, Q2, Q1, and Q0\. The 4-bit output, *r*[3]*r*[2]*r*[1]*r*[0],
    remains disconnected from the D flip-flops when *Read* = `0`. Setting *Read* =
    `1` connects the outputs.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*Write* = `1` 会使 4 位数据 *d*[3]*d*[2]*d*[1]*d*[0] 存储到 D 触发器 Q3、Q2、Q1 和 Q0 中。当
    *Read* = `0` 时，4 位输出 *r*[3]*r*[2]*r*[1]*r*[0] 将与 D 触发器断开连接。将 *Read* = `1` 设置为
    `1` 时，会连接输出。'
- en: Let’s continue down the memory hierarchy in [Figure 8-1](ch08.xhtml#ch8fig1)
    to cache memory, which is typically constructed from flip-flops, similar to a
    register file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续沿着[图 8-1](ch08.xhtml#ch8fig1)中的内存层级往下看，缓存内存通常由类似于寄存器文件的触发器构成。
- en: '***Static Random-Access Memory***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***静态随机存储器***'
- en: The memory we have been discussing that uses flip-flops is called *static random-access
    memory (SRAM)*. It’s called *static* because it maintains its values as long as
    power is maintained. As you learned in [Chapter 2](ch02.xhtml), it’s called *random*
    because it takes the same amount of time to access any (random) byte in this memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的使用触发器的内存被称为*静态随机存取内存（SRAM）*。之所以叫做*静态*，是因为只要电源保持，它就会保持其值。正如你在[第2章](ch02.xhtml)中所学的那样，它被称为*随机*，因为在此内存中访问任何（随机）字节所需的时间是相同的。
- en: SRAM is commonly used for cache memory. As shown in [Table 8-1](ch08.xhtml#ch8tab1),
    the cache on a Raspberry Pi can range in size from 32KB to 2MB. Each bit in SRAM
    requires about six transistors to implement.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: SRAM 通常用于缓存内存。如[表 8-1](ch08.xhtml#ch8tab1)所示，Raspberry Pi 上的缓存大小可以从 32KB 到 2MB
    不等。每个 SRAM 位大约需要六个晶体管来实现。
- en: Continuing down the memory hierarchy, we get to main memory, the largest memory
    unit that is internal to the computer. The amount of main memory in a Raspberry
    Pi ranges from 1GB to 8GB, depending on the model, so using SRAM for main memory
    would be quite expensive. Next, we’ll look at a less expensive type of memory
    that’s suitable for large main memory systems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 继续向下查看内存层次结构，我们到达了主内存，这是计算机内部最大的内存单元。Raspberry Pi 的主内存大小从 1GB 到 8GB 不等，具体取决于型号，因此将
    SRAM 用作主内存会非常昂贵。接下来，我们将看看一种适用于大型主内存系统的较便宜类型的内存。
- en: '***Dynamic Random-Access Memory***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动态随机存取内存***'
- en: '*Dynamic random-access memory (DRAM)* is commonly implemented by charging a
    capacitor to one of two voltages for storing one bit. The circuit requires only
    one transistor to charge the capacitor, as shown in [Figure 8-8](ch08.xhtml#ch8fig8).
    These circuits are arranged in a rectangular array.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态随机存取内存（DRAM）*通常通过将电容器充电至两种电压之一来存储一个位。该电路只需要一个晶体管来给电容器充电，如[图 8-8](ch08.xhtml#ch8fig8)所示。这些电路以矩形阵列的方式排列。'
- en: '![Image](../images/pg190_Image_238.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg190_Image_238.jpg)'
- en: '*Figure 8-8: One DRAM bit*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-8：一个 DRAM 位*'
- en: When the *row select* line is set to `1`, all the transistors in that row are
    turned on, thus connecting the respective capacitor to the sense amplifier/ latch.
    The value stored in the capacitor—high voltage or low voltage—is amplified and
    stored in the latch. There, it’s available to be read. Since this action tends
    to discharge the capacitors, they must be refreshed from the values stored in
    the latch. Separate circuitry is provided to do the refresh.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当*行选择*线设置为`1`时，该行中的所有晶体管都会被打开，从而将相应的电容器连接到感应放大器/锁存器。存储在电容器中的值——高电压或低电压——会被放大并存储在锁存器中。这样，它就可以被读取。由于这一操作会使电容器放电，因此必须从锁存器中存储的值中刷新它们。提供了单独的电路来执行刷新操作。
- en: When data is to be stored in DRAM, the new bit value, `0` or `1`, is first stored
    in the latch. *Row select* is then set to `1`, and the sense amplifier/latch circuitry
    applies the voltage corresponding to the logical `0` or `1` to the capacitor.
    The capacitor is either charged or discharged appropriately.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当要将数据存储在 DRAM 中时，新的位值`0`或`1`首先存储在锁存器中。然后，将*行选择*设置为`1`，感应放大器/锁存器电路将与逻辑`0`或`1`对应的电压应用到电容器上。电容器将适当地充电或放电。
- en: These operations take more time than simply switching flip-flops, so DRAM is
    appreciably slower than SRAM. In addition, each row of capacitors must be read
    and refreshed on the order of every 60 ms. This further slows memory access.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作比单纯地切换触发器需要更多时间，因此 DRAM 的速度明显比 SRAM 慢。此外，每一行电容器必须大约每 60 毫秒进行一次读取和刷新。这进一步降低了内存访问速度。
- en: In addition to the memory itself, the amount of hardware required to address
    the individual bytes in a large memory system can be substantial. Let’s look at
    a way to reduce the number of gates needed for addressing memory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内存本身外，访问大型内存系统中各个字节所需的硬件量可能相当可观。让我们来看一种减少寻址内存所需门数的方法。
- en: As an example, selecting 1 byte in 1MB of memory requires a 20-bit address.
    This in turn requires a 20×2^(20) address decoder, as shown in [Figure 8-9](ch08.xhtml#ch8fig9).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，在 1MB 内存中选择 1 字节需要一个 20 位的地址。这反过来需要一个 20×2^(20) 的地址解码器，如[图 8-9](ch08.xhtml#ch8fig9)所示。
- en: '![Image](../images/pg191_Image_239.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg191_Image_239.jpg)'
- en: '*Figure 8-9: Addressing 1MB of memory with one 20 ×2^(20) address decoder*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-9：使用一个 20 × 2^(20) 地址解码器访问 1MB 内存*'
- en: Recall that an *n*×2*^n* decoder requires 2*^n* AND gates. So, a 20×2^(20) decoder
    requires 1,048,576 AND gates. We can simplify the circuitry by organizing memory
    into a grid of 1,024 rows and 1,024 columns, as shown in [Figure 8-10](ch08.xhtml#ch8fig10).
    We can then select a byte by selecting a row and a column, each using a 10×2^(10)
    decoder.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，*n*×2*^n*解码器需要2*^n*个与门。因此，一个20×2^(20)的解码器需要1,048,576个与门。我们可以通过将内存组织成1,024行和1,024列的网格来简化电路，如[图8-10](ch08.xhtml#ch8fig10)所示。然后，我们可以通过选择一行和一列来选择一个字节，每个解码器使用10×2^(10)解码器。
- en: Although two decoders are required, each requires only 2^(10) AND gates, for
    a total of 2×2^(10) = 2,048 AND gates for each of the two decoders. Of course,
    accessing individual bytes in memory is slightly more complex, and some complexity
    is added to split the 20-bit address into two 10-bit portions. Still, this example
    should give you an idea of how engineers can simplify designs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然需要两个解码器，但每个解码器只需要2^(10)个与门，因此每个解码器的总共需要2×2^(10) = 2,048个与门。当然，访问内存中的单个字节稍微复杂一些，且将20位地址拆分成两个10位部分会增加一些复杂性。不过，这个例子应该能让你大致了解工程师如何简化设计。
- en: '![Image](../images/pg192_Image_240.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg192_Image_240.jpg)'
- en: '*Figure 8-10: Addressing 1MB of memory with two 10* × *2*^(10) *address decoders*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-10：使用两个10×2^(10)地址解码器寻址1MB内存*'
- en: You now have a clear picture of how the hierarchical arrangement of memory in
    a modern computer allows fast program execution while keeping hardware costs at
    a reasonable level. Although DRAM is much slower than the CPU, its low cost per
    bit makes it a good choice for main memory. As we move closer to the CPU in the
    memory hierarchy, the much faster SRAM is used for the cache(s). Since cache memory
    is much smaller than main memory, the higher cost per bit of SRAM is tolerable
    here, and since the instructions and data needed by the program being executed
    by the CPU are often in the cache, we see the benefits of the higher speed of
    SRAM in program execution.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对现代计算机中内存的层级结构有了清晰的了解，它使得程序能够快速执行，同时保持硬件成本在合理范围内。尽管DRAM比CPU慢，但其每位的低成本使其成为主内存的理想选择。当我们靠近内存层次结构中的CPU时，更快速的SRAM被用于缓存。由于缓存内存远小于主内存，因此SRAM每位的较高成本在这里是可以接受的，且由于CPU执行的程序通常需要的指令和数据都在缓存中，我们可以看到SRAM的高速在程序执行中的好处。
- en: '**YOUR TURN**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 8.3     Derive the equation for *D(Store, d[i], r[i])* from [Table 8-2](ch08.xhtml#ch8tab2).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 8.3    从[表8-2](ch08.xhtml#ch8tab2)推导出*D(Store, d[i], r[i])*的公式。
- en: '**What You’ve Learned**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你所学到的**'
- en: '**Memory hierarchy**   Computer storage is organized such that smaller amounts
    of faster, more costly memory are located closer to the CPU. Smaller amounts of
    program instructions and data are copied to the successively faster memory levels
    as a program executes. This works because there is a very high probability that
    the next memory location needed by a program will be at an address close to the
    current one.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存层次结构**  计算机存储是这样组织的：更小、更快速、成本更高的内存靠近CPU。随着程序执行，较小量的程序指令和数据会被复制到逐级更快的内存层级。这种做法之所以有效，是因为程序需要的下一个内存位置很可能与当前内存位置相邻。'
- en: '**Registers**   A few thousand bytes of memory located in the CPU that are
    accessed at the same speed as the CPU. Implemented in flip-flops.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**寄存器**  位于CPU中的几千字节的内存，以与CPU相同的速度访问。由触发器实现。'
- en: '**Cache**   Thousands to millions of bytes of memory outside the CPU, but often
    on the same chip. Cache memory is slower than the CPU but is synchronized with
    it. It is often organized in levels, with faster, smaller amounts closer to the
    CPU. The cache is usually implemented using SRAM.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**  数千到数百万字节的内存，位于CPU外部，但通常在同一芯片上。缓存内存比CPU慢，但与CPU同步。缓存通常按层次组织，越靠近CPU的内存层次越小且越快。缓存通常使用SRAM实现。'
- en: '**Main memory**   Hundreds of millions to billions of bytes of memory separate
    from the CPU. Main memory is much slower than the CPU but is synchronized with
    it. It is usually implemented using DRAM.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**主内存**  数亿到数十亿字节的内存，独立于CPU。主内存比CPU慢，但与CPU同步。通常使用DRAM实现。'
- en: '**Static random-access memory (SRAM)**   Uses flip-flops to store bits. SRAM
    is fast but expensive.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态随机存取内存 (SRAM)**  使用触发器存储位。SRAM速度快，但成本高。'
- en: '**Dynamic random-access memory (DRAM)**   Uses capacitors to store bits. DRAM
    is slow but has a much lower cost than SRAM.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态随机存取内存 (DRAM)**  使用电容器存储位。DRAM速度较慢，但其成本远低于SRAM。'
- en: In the next chapter, you will learn how the CPU in the Raspberry Pi is organized
    from a programmer’s point of view.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将从程序员的角度学习树莓派中 CPU 的组织结构。
