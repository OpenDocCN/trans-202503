- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**PSEUDO-CLASSES AND PSEUDO-ELEMENTS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪类和伪元素**'
- en: '![Image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/common-01.jpg)'
- en: 'The very first CSS specification, CSS1, introduced the concepts of *pseudo-classes*
    and *pseudo-elements*. These are selectors that act on information about elements
    that extends (or sits outside of) the document tree. A pseudo-class differentiates
    among an element’s different states or types; these include—but are not limited
    to—those that provide information about link states: `:hover`, `:visited`, `:active`,
    and so on. A pseudo-element provides access to an element’s subpart, which includes
    those pseudo-elements that select portions of text nodes; for instance, `:first-line`
    and `:first-letter`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一版 CSS 规范（CSS1）引入了 *伪类* 和 *伪元素* 的概念。这些选择器作用于扩展（或超出）文档树的信息。伪类用于区分元素的不同状态或类型；这些状态包括——但不限于——提供链接状态信息的伪类：`:hover`、`:visited`、`:active`
    等等。伪元素则提供了访问元素子部分的能力，包括那些选择文本节点部分的伪元素；例如，`:first-line` 和 `:first-letter`。
- en: The selectors just mentioned have been around since the first CSS specification,
    but a handful more were added in CSS2.1—although pseudo-element support has not
    been well implemented until relatively recently. CSS3 builds on these foundations
    with an expanded range of pseudo-classes, as well as a (slightly) tweaked syntax
    to differentiate pseudo-elements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上述选择器自第一版 CSS 规范以来就存在，但在 CSS2.1 中加入了更多选择器——尽管伪元素的支持直到最近才得到较好的实现。CSS3 在这些基础上进行了扩展，增加了更多的伪类选择器，并且对语法做了（轻微的）调整，以区分伪元素。
- en: 'The advantage of having more methods for traversing documents should be clear:
    Fewer styling hooks are required. You are most likely familiar with markup like
    this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有更多遍历文档的方法的优势应该很明显：需要的样式挂钩更少。你可能已经熟悉这样的标记：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The markup contains class names to describe each element’s position in the
    document tree: `first` (➊) and `last` (➍) show that the `li` elements are the
    first and last children of the `ul` element, and `odd` (➋) is used for the oddnumbered
    `li` elements. An extra `span` (➌) is included around the first letter of the
    initial `li` element.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 该标记包含类名，用于描述每个元素在文档树中的位置：`first` (➊) 和 `last` (➍) 显示 `li` 元素是 `ul` 元素的第一个和最后一个子元素，`odd`
    (➋) 用于标记编号为奇数的 `li` 元素。第一个 `li` 元素的首字母周围包含了一个额外的 `span` (➌)。
- en: You mark up code like this when you want to add styles to alternating elements,
    set different values on the first and last elements, or add special formatting
    to the first letter of a text node. This markup detracts from the clarity and
    semantic meaning of your code, but in many cases you need it to provide the hooks
    to hang your styles on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想为交替元素添加样式、为第一个和最后一个元素设置不同的值，或者为文本节点的首字母添加特殊格式时，可以使用这样的标记。这种标记可能会削弱代码的清晰度和语义性，但在许多情况下，你需要它来为样式提供挂钩。
- en: 'CSS3’s new methods allow you to achieve the same visual results without muddying
    the markup with unnecessary classes and nonsemantic elements, making for cleaner
    and more maintainable code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3 的新方法允许你在不使用多余类和非语义元素污染标记的情况下，达到相同的视觉效果，从而使代码更加简洁和可维护：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The other major advantage of the new selectors is that if new elements are
    added to the markup, class names don’t have to be updated to accommodate them
    while still keeping order. This change takes CSS a big step closer to achieving
    its stated goal: the separation of content and presentation.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 新选择器的另一个主要优势是，如果添加了新元素到标记中，类名无需更新以适应这些新元素，同时仍能保持顺序。这一变化使得 CSS 更接近其目标：内容与表现的分离。
- en: '**Structural Pseudo-classes**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结构性伪类**'
- en: As I stated in the introduction to this chapter, a pseudo-class provides a way
    to select an element based on information that is not specified in the document
    tree. Various subtypes are available, the most common of which is the *structural
    pseudo-class*. These subtypes are used to select elements that are not accessible
    using simple selectors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章引言中所述，伪类提供了一种根据文档树中未指定的信息选择元素的方法。有各种子类型，其中最常见的是 *结构性伪类*。这些子类型用于选择那些无法通过简单选择器访问的元素。
- en: 'Take, for example, the following markup:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下标记：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first of the two `p` elements is the first child of the `div` element.
    That’s obvious from the document tree, but the document tree doesn’t provide any
    information that would allow you to apply a rule only to that element. CSS2 introduced
    the `:first-child` pseudo-class for exactly that reason:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`p`元素中的第一个是`div`元素的第一个子元素。从文档树中可以明显看出这一点，但文档树并没有提供任何可以仅对该元素应用规则的信息。正因如此，CSS2引入了`:first-child`伪类：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This pseudo-class allows you to make a selection based on information that exists
    but isn’t provided as an attribute of the element—the exact purpose of a pseudo-class.
    Since `:first-child` was introduced in CSS2, it has been the only pseudo-class
    of its type. But CSS3 extends the range greatly with the introduction of 11 new
    structural pseudo-classes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪类允许你根据存在但未作为元素属性提供的信息进行选择——这正是伪类的作用。自从` :first-child`在CSS2中引入以来，它一直是唯一一个这种类型的伪类。但是，CSS3通过引入11个新的结构性伪类大大扩展了这一范围。
- en: '***The :nth-* Pseudo-classes***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***:nth-* 伪类***'
- en: Four of the new pseudo-classes are based on a count value used to find an element’s
    position in the document tree; for this count, you use the syntax `:nth-*`. Note
    that I’ve used the asterisk here in place of a number of different values, each
    of which I’ll introduce throughout the rest of this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 新的四个伪类是基于一个计数值，用于查找元素在文档树中的位置；对于这个计数，你可以使用语法`:nth-*`。注意，我在这里使用了星号代替多个不同的值，我将在本章的其余部分逐一介绍这些值。
- en: 'The basic syntax of the `:nth-*` pseudo-classes is quite straightforward. By
    default, `n` represents a number that begins at 0 and increments by 1 (1, 2, 3,
    etc.). Another integer can be passed into it as a multiplier. For example, `2n`
    is every multiple of 2 (2, 4, 6, etc.), `3n` is every multiple of 3 (3, 6, 9,
    etc.), and so on:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`:nth-*`伪类的基本语法非常简单。默认情况下，`n`表示从0开始并按1递增的数字（1、2、3等）。另一个整数可以作为乘数传递给它。例如，`2n`表示每个2的倍数（2、4、6等），`3n`表示每个3的倍数（3、6、9等），依此类推：'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first example uses the default value `n`, so all elements of type `*E*`
    would be selected; in practice, this is the same as using a simple element selector.
    The next example selects every other `*E*` element, and the final example selects
    every third element of type `*E*`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例使用默认值`n`，因此将选择所有类型为`*E*`的元素；在实际应用中，这与使用简单的元素选择器相同。下一个示例选择每隔一个的`*E*`元素，最后一个示例选择每隔三个的`*E*`元素。
- en: 'You may also use the mathematical operators for plus (+) and minus (−). So
    `2n+1` selects every multiple of two plus one (1, 3, 5, etc.), and `3n-1` selects
    every multiple of three minus one (2, 5, 8, etc.):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用加法（+）和减法（−）的数学运算符。因此，`2n+1`选择每隔两个加一个的元素（1、3、5等），而`3n-1`选择每隔三个减一个的元素（2、5、8等）：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first example selects every element of type `*E*` except for the first instance;
    the count for this would be 2, 3, 4, 5, and so on. The next example selects every
    odd-numbered `*E*` element (1, 3, 5, and so on). The final example, as just mentioned,
    selects elements in the sequence 2, 5, 8, and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例选择除了第一个实例之外的所有`*E*`元素；这些计数将是2、3、4、5，依此类推。下一个示例选择每个奇数编号的`*E*`元素（1、3、5等）。最后一个示例，如前所述，选择序列中的元素：2、5、8等。
- en: 'Two special keyword values, `even` and `odd`, are also available; you can use
    these to replace `2n` and `2n+1`, respectively:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个特殊的关键字值，`even`和`odd`，你可以用它们分别替换`2n`和`2n+1`：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, it’s also acceptable to use `0n` (that’s zero) as a value. It has
    no use of itself but is very useful when combined with a mathematical operator,
    as it allows you to pinpoint a single element without any recurrence. In fact,
    for brevity, you can supply only the value after the mathematical operator. For
    example, to select only the third element in a selector list, both of these values
    are valid:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`0n`（即零）作为值也是可以的。它本身没有用途，但与数学运算符结合使用时非常有用，因为它允许你精确定位一个没有重复的单一元素。事实上，为了简洁起见，你只需要在数学运算符后提供值。例如，若要仅选择选择器列表中的第三个元素，以下两个值都是有效的：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the basic syntax out of the way, let’s move on to the pseudo-classes themselves.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本语法讲解完毕后，让我们继续讨论这些伪类本身。
- en: '**:nth-child() and :nth-of-type()**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**:nth-child() 和 :nth-of-type()**'
- en: Most of the new structural pseudo-classes allow you to select elements based
    on either their position in the document tree in relation to their parent element
    (`-child`) or their classification (`-of-type`). Often these definitions overlap,
    but there are crucial differences between them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数新的结构伪类允许你根据元素在文档树中的位置（相对于其父元素的 `-child`）或其分类（`-of-type`）来选择元素。这些定义经常会有重叠，但它们之间也存在至关重要的区别。
- en: The simplest examples of these pseudo-classes are `:nth-child()` and `:nth-of-type()`.
    The first, `:nth-child()`, selects an element based on its position in a count
    of the total number of children in its parent element; `:nth-of-type()` bases
    its count not on the total children, but only on those of the specified element
    type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些伪类的最简单示例是 `:nth-child()` 和 `:nth-of-type()`。第一个，`:nth-child()`，根据元素在其父元素中所有子元素的总数中的位置来选择元素；`:nth-of-type()`
    的计数则不基于所有子元素，而仅基于指定类型的元素。
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, rules ➊ and ➋ are equivalent because the count value (`n`)
    is left at the default; both of these simply select all child elements of type
    `*E*`. The difference reveals itself in the later examples: in ➌, `:nth-child(2n)`
    selects all elements of type `*E*` from a count that includes all its siblings
    but only where those elements are even-numbered. In ➍, by comparison, `:nth-of-type(2n)`
    selects all even-numbered elements of type `*E*` from a count that includes only
    those elements.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，规则 ➊ 和 ➋ 是等效的，因为计数值（`n`）保持为默认值；这两者都仅选择类型为 `*E*` 的所有子元素。差异在后面的示例中得以显现：在
    ➌ 中，`:nth-child(2n)` 选择所有类型为 `*E*` 的元素，计数包括所有同级元素，但仅限于那些偶数编号的元素。而在 ➍ 中，相比之下，`:nth-of-type(2n)`
    仅从那些元素中选择偶数编号的类型为 `*E*` 的元素。
- en: 'These rules are much easier to demonstrate than they are to explain. I’ll demonstrate
    the difference between them with the following example (text has been truncated
    for clarity):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则比起解释来，演示起来要容易得多。我将通过以下示例演示它们之间的区别（为了清晰起见，文本已被截断）：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And in my style sheet I’ll use these two rules:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的样式表中，我将使用这两条规则：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see the differing result of the two rules in [Figure 4-1](ch04.html#ch04fig1).
    In the example markup, the `div` element has a total of four child elements: one
    `h2` and three `p`. The `:nth-child(2n)` selector in rule ➊ makes bold every second
    child (the first and third paragraphs), as seen in the box on the left. Compare
    that to the box on the right, which has rule ➋ applied; the `:nth-of-type(2n)`
    selector ignores the `h2` and applies a bold weight to every second instance of
    the three elements of type `p`—that is, only the second paragraph.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 4-1](ch04.html#ch04fig1)中看到这两条规则的不同结果。在示例标记中，`div` 元素总共有四个子元素：一个 `h2`
    和三个 `p`。规则 ➊ 中的 `:nth-child(2n)` 选择器将每第二个子元素（第一个和第三个段落）设为粗体，正如左边的框中所看到的那样。与右侧框中的规则
    ➋ 应用效果进行比较；`:nth-of-type(2n)` 选择器忽略 `h2` 元素，并仅对三个类型为 `p` 的元素中的每第二个实例应用粗体样式——即，仅对第二个段落生效。
- en: '![Image](graphics/f04-01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f04-01.jpg)'
- en: '*Figure 4-1: Comparing the result of using the* `*:nth-child()*` *selector
    (left) with* `*:nth-of-type()*` *(right)*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：比较使用* `*:nth-child()*` *选择器（左）与* `*:nth-of-type()*` *(右)的效果*'
- en: As I mentioned before, and as you can no doubt deduce from the previous examples,
    `:nth-child()` and `:nth-of-type()` have a fair bit of overlap, and you can often
    use them interchangeably, as I do in the following example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所提到的，且你无疑能从之前的例子中推测出，`:nth-child()` 和 `:nth-of-type()` 有不少重叠之处，通常可以互换使用，正如我在下面的示例中所做的那样。
- en: The table on the left of [Figure 4-2](ch04.html#ch04fig2) shows the five-day
    weather forecast for London (so temperatures are given in degrees Celsius—0°C
    equals 32°F). These figures were taken in January—it’s not *always* this cold
    here! All of the information I want to convey is in the table, but without any
    definition of rows, I find the table difficult to read.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](ch04.html#ch04fig2)左侧的表格显示了伦敦的五天天气预报（温度单位为摄氏度—0°C 等于 32°F）。这些数据是在一月采集的—这里并非
    *总是* 这么冷！我想传达的所有信息都在表格中，但如果没有行的定义，我发现表格很难读取。'
- en: Now compare this table to the one on the right in the same [Figure 4-2](ch04.html#ch04fig2).
    Here, I used the technique known as *zebra striping* to aid the eye along the
    row, making the data much more readable to me.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这个表格与右侧的表格进行比较，见同一[图 4-2](ch04.html#ch04fig2)。在这里，我使用了被称为 *斑马条纹* 的技巧来帮助眼睛沿着行移动，这使得数据对我来说更易读。
- en: '![Image](graphics/f04-02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f04-02.jpg)'
- en: '*Figure 4-2: Weather forecast table (left) and better formatted for readability
    (right). Weather data from* [http://bbc.co.uk/weather/](http://bbc.co.uk/weather/)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：天气预报表（左）和优化格式化以提高可读性（右）。天气数据来自* [http://bbc.co.uk/weather/](http://bbc.co.uk/weather/)'
- en: 'I achieved this technique with a single CSS3 declaration:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过一个简单的 CSS3 声明实现了这个技巧：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, I could have used `:nth-child()` instead, as in the markup
    all of the child elements of `tbody` are of the same type: `tr`. Where every child
    is of the same type, `:nth-child()` and `:nth-of-type()` are interchangeable.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我本可以使用 `:nth-child()`，因为在标记中，`tbody` 的所有子元素都是相同类型的：`tr`。当每个子元素都是相同类型时，`:nth-child()`
    和 `:nth-of-type()` 是可以互换使用的。
- en: '**:nth-last-child() and :nth-last-of-type()**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**:nth-last-child() 和 :nth-last-of-type()**'
- en: The `:nth-last-child()` and `:nth-last-of-type()` pseudo-classes accept the
    same arguments as `:nth-child()` and `:nth-of-type()`, except they are counted
    from the last element, working in reverse. For example, say I want to use some
    visual shorthand to show in my weather table that the forecasts for days four
    and five are less certain than for the preceding days. You can see how this would
    look in [Figure 4-3](ch04.html#ch04fig3).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`:nth-last-child()` 和 `:nth-last-of-type()` 伪类接受与 `:nth-child()` 和 `:nth-of-type()`
    相同的参数，只不过它们是从最后一个元素开始倒着计数，起到了反向计数的作用。例如，假设我想使用一些视觉简写，在我的天气表格中显示出第四天和第五天的预报比前几天更不确定。你可以在
    [图 4-3](ch04.html#ch04fig3) 中看到这种效果。'
- en: '![Image](graphics/f04-03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f04-03.jpg)'
- en: '*Figure 4-3: Extra formatting using* `*:nth-last-child()*`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：使用 `*:nth-last-child()*` 进行额外格式化*'
- en: 'Here I italicized the characters in the last two rows by using the `:nth-last-child()`
    pseudo-class (although, once again, `:nth-last-of-type()` would serve just as
    well in this example), passing an argument of `-n+2`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我在最后两行的字符上使用了 `:nth-last-child()` 伪类进行斜体处理（尽管再次强调，`:nth-last-of-type()` 在这个例子中同样适用），并传递了
    `-n+2` 作为参数：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I used the negative value (`-n`) to increment the count negatively, which has
    the effect of acting in reverse. Because `:nth-last-child()` and `:nth-last-of-type()`
    count backward through the tree, using a negative value here makes the count go
    forward! The count starts at the last `tr` element in the table and counts up
    in reverse order, so the last and penultimate lines are the first two counted
    and are, therefore, italicized. This may seem counterintuitive, but it’ll become
    second nature as you traverse the document tree.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了负值（`-n`）来递减计数，这样就能实现反向操作。由于 `:nth-last-child()` 和 `:nth-last-of-type()`
    是从树的末端开始倒着计数，所以在这里使用负值使得计数向前进行！计数从表格中的最后一个 `tr` 元素开始，按倒序进行，因此倒数第一和倒数第二行是首先被计数的，因此被设置为斜体。这个过程可能看起来不太直观，但随着你深入遍历文档树，便会逐渐习惯。
- en: '***:first-of-type, :last-child, and :last-of-type***'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '***:first-of-type, :last-child 和 :last-of-type***'
- en: If you take a look at the tables in [Figure 4-2](ch04.html#ch04fig2), you’ll
    notice that the text in the Weather column is left-aligned, whereas the other
    columns are center-aligned. I did this using the `:first-of-type` pseudo-class,
    which is similar to the `:first-child` selector introduced in CSS2, but with the
    same difference in type and child that you’ve seen so far in this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 [图 4-2](ch04.html#ch04fig2) 中的表格，你会注意到天气列的文本是左对齐的，而其他列是居中对齐的。我是通过使用 `:first-of-type`
    伪类实现的，它类似于 CSS2 中引入的 `:first-child` 选择器，但在本章中你已经看到，它的类型和子元素的区别。
- en: As you’re no doubt aware, the `:first-child` pseudo-class is a selector used
    to apply rules to an element that is the first child of its parent. As with `:nth-of-type()`,
    however, `:first-of-type` is more specific, applying only to the element that
    is the first child of the named type of its parent. A pair of counterpart pseudo-classes
    is also available, `:last-child` and `:last-of-type`, which—as you might have
    guessed—select the last child element or the last child element of that type,
    respectively, of the parent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`:first-child` 伪类是一个选择器，用来应用规则到其父元素的第一个子元素。然而，与 `:nth-of-type()` 一样，`:first-of-type`
    更为具体，它仅应用于父元素中属于特定类型的第一个子元素。还有一对对应的伪类，`:last-child` 和 `:last-of-type`，正如你可能猜到的，它们分别选择父元素中的最后一个子元素或该类型的最后一个子元素。
- en: 'In the weather table examples in the previous section, the markup for each
    row in the table body is structured like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的天气表格示例中，表格主体中每一行的标记结构如下所示：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'I want to left-align the content of the second column, so I can’t use `:first-child`
    here as the first child is a `th`. Instead, I use the `:first-of-type` selector:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我想将第二列的内容左对齐，因此不能在这里使用 `:first-child`，因为第一个子元素是一个 `th`。相反，我使用 `:first-of-type`
    选择器：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I’ll show two more examples to demonstrate the difference clearly. I’ll apply
    both of the examples to the same chunk of markup (I’ve truncated the text for
    clarity):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示两个额外的例子，以清楚地说明它们之间的区别。我将这两个例子应用到相同的标记片段（为了清晰起见，我已截断文本）：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the first example, I use `:first-child` and `:last-child`, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我使用了 `:first-child` 和 `:last-child`，如下所示：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result is shown in [Figure 4-4](ch04.html#ch04fig4). The `h2` element is
    the first child of the `div`, so it has an underline applied to it. The last child
    of the `div` is the `h3` element, so that is italicized. All quite straightforward.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如[图 4-4](ch04.html#ch04fig4)所示。`h2` 元素是 `div` 的第一个子元素，因此应用了下划线样式。`div` 的最后一个子元素是
    `h3` 元素，因此它被斜体化。所有这一切都很直接。
- en: '![Image](graphics/f04-04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f04-04.jpg)'
- en: '*Figure 4-4: Applying the* `*:first-child*` *and* `*:last-child*` *selectors*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：应用* `*:first-child*` *和* `*:last-child*` *选择器*'
- en: 'Now let’s see the difference when we use the `:first-of-type` and `:last-of-type`
    selectors:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用 `:first-of-type` 和 `:last-of-type` 选择器时的区别：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Take a look at the result in [Figure 4-5](ch04.html#ch04fig5). You’ll notice
    that three elements—`h2`, `h3`, and the first `p`—are underlined. This is because
    they are the first instance of that element type. Likewise, the `h2`, `h3`, and
    last `p` are all italicized. Again, this is because they are all the last element
    of that type; the `h2` and `h3` are both the first and last of their type, and
    so both rules are applied to them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图 4-5](ch04.html#ch04fig5)中的结果。你会注意到三个元素——`h2`、`h3` 和第一个 `p`——都带有下划线。这是因为它们是该元素类型的第一个实例。同样，`h2`、`h3`
    和最后一个 `p` 都被斜体化。这是因为它们都是该类型的最后一个元素；`h2` 和 `h3` 都是其类型的第一个和最后一个，因此两个规则都适用于它们。
- en: '![Image](graphics/f04-05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f04-05.jpg)'
- en: '*Figure 4-5: Applying the* `*:first-of-type*` *and* `*:last-of-type*` *selectors*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：应用* `*:first-of-type*` *和* `*:last-of-type*` *选择器*'
- en: As with all of the `*-type` and `*-child` pseudo-classes, the distinction is
    subtle, and sometimes the last child element is also the last of its type, so
    the selectors are interchangeable. But as I’ve just shown, at times, they have
    different applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有 `*-type` 和 `*-child` 伪类一样，它们之间的区别是微妙的，有时最后一个子元素也可能是其类型的最后一个，因此这些选择器可以互换使用。但正如我刚才所示，它们有时会有不同的应用场景。
- en: '***:only-child and :only-of-type***'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '***:only-child 和 :only-of-type***'
- en: 'These two pseudo-classes are used to select elements in the document tree that
    have a parent but either no sibling elements (`:only-child`) or no siblings of
    the same type (`:only-of-type`). As with many of the previous pseudo-classes,
    these two overlap substantially in function, but this next example illustrates
    the difference between them. Take the following style rules:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个伪类用于选择文档树中具有父元素但没有兄弟元素（`:only-child`）或没有相同类型兄弟元素（`:only-of-type`）的元素。与许多之前的伪类一样，这两个伪类的功能有很多重叠，但下面这个例子说明了它们之间的区别。请看以下样式规则：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'and then apply them to this markup:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将它们应用到这个标记中：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see the result in [Figure 4-6](ch04.html#ch04fig6).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 4-6](ch04.html#ch04fig6)中看到结果。
- en: '![Image](graphics/f04-06.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f04-06.jpg)'
- en: '*Figure 4-6: Comparing* `*:only-child*` *and* `*:only-of-type*`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：比较* `*:only-child*` *和* `*:only-of-type*`'
- en: Both `p` elements are the only elements of their type in their level of the
    document tree, so the `:only-of-type` rule selects both and italicizes them. The
    `p` element inside the blockquote, however, is also the only child in its level,
    so it’s also subject to the `:only-child` rule that applies the underline.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `p` 元素是其类型在文档树中的唯一元素，因此 `:only-of-type` 规则选择它们并将其斜体化。然而，`blockquote` 内的 `p`
    元素也是其层级中的唯一子元素，因此它也适用于 `:only-child` 规则，应用了下划线样式。
- en: Using `:only-of-type` allows you to pick an element from among others, whereas
    `:only-child` requires the element to sit alone.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `:only-of-type` 允许你从其他元素中挑选出一个元素，而 `:only-child` 则要求该元素是孤立的。
- en: '**Other Pseudo-classes**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**其他伪类**'
- en: In addition to the structural pseudo-classes discussed so far in this chapter,
    CSS3 introduces a number of pseudo-classes that allow you to select elements based
    on other criteria. These include link destinations, user interface elements, and
    even an inverse selector that permits selection based on what an element *isn’t*!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章中讨论的结构性伪类外，CSS3还引入了许多伪类，允许你根据其他标准选择元素。这些包括链接目标、用户界面元素，甚至是一个逆选择器，允许你根据元素“不是”什么来选择它！
- en: '***:target***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***:target***'
- en: 'On the Web, sites don’t just link between pages but also provide internal links
    to specific elements. A URI can contain a reference to a unique ID or a named
    anchor. For example, if you had this markup in a page:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web上，站点不仅仅是页面之间的链接，还提供指向特定元素的内部链接。一个URI可以包含对唯一ID或命名锚点的引用。例如，如果你在页面中有如下标记：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'you could refer to it with this link:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过这个链接引用它：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `:target` pseudo-class allows you to apply styles to the element when the
    referring URI has been followed. In this example, if you want to apply styles
    to the `h4` element when the URI is followed, you use:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`:target`伪类允许你在引用的URI被跟随时应用样式。在这个例子中，如果你想在URI被跟随时对`h4`元素应用样式，你可以使用：'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A popular practice is to highlight the subject of an internal link visually
    to provide a clear cue to the user. Consider, for example, the standard pattern
    for blog comments, which are somewhat like this simplified markup:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一种流行的做法是直观地高亮显示内部链接的主题，以便为用户提供明确的提示。例如，考虑一下博客评论的标准模式，其简化的标记大致如下：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And another fairly common pattern is to include links to individual comments:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相当常见的模式是包括指向单个评论的链接：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using the `:target` pseudo-class, you can easily highlight the comment that
    the user wants to read:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`:target`伪类，你可以轻松高亮用户希望阅读的评论：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Figure 4-7](ch04.html#ch04fig7) shows a list of comments in two states: on
    the left, as they appear before the referring link has been clicked, and on the
    right, as they appear after the link has been clicked—with the element that the
    link refers to showing a different background color thanks to the `:target` selector.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7](ch04.html#ch04fig7)显示了评论的两种状态：左侧是点击引用链接之前的显示状态，右侧是点击链接后的显示状态——链接所指向的元素由于`:target`选择器而显示不同的背景颜色。'
- en: '![Image](graphics/f04-07.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f04-07.jpg)'
- en: '*Figure 4-7: Highlighting applied with the* `*:target*` *pseudo-class*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7：使用`*:target*`伪类应用的高亮效果*'
- en: '***:empty***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***:empty***'
- en: 'The `:empty` pseudo-class selects an element that has no children, including
    text nodes. Consider this markup:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`:empty`伪类选择没有子元素的元素，包括文本节点。考虑这个标记：'
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you apply this CSS rule:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你应用这个CSS规则：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: the rule is only applied to the first `td` element, as the other two contain
    a text node and a child element, respectively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 规则仅应用于第一个`td`元素，因为另外两个分别包含文本节点和子元素。
- en: '***:root***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***:root***'
- en: 'The `:root` pseudo-class selects the first element in a document tree, which
    is only really handy if you’re adding a style sheet to XML documents—in HTML,
    the root will always be the `html` element. One small advantage of using `:root`
    in HTML is that you can use it to give a higher specificity to the `html` element,
    which could be useful if you need to override the simple type selector:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`:root`伪类选择文档树中的第一个元素，这只有在你为XML文档添加样式表时才特别有用——在HTML中，根元素将始终是`html`元素。使用`:root`在HTML中的一个小优点是，你可以通过它赋予`html`元素更高的特异性，这在你需要覆盖简单类型选择器时可能会很有用：'
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s say you’re creating a base style sheet and want to set a property on
    the `html` element, which shouldn’t be altered. In this case, you would use something
    like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在创建一个基础样式表，并希望在`html`元素上设置一个不应被修改的属性。在这种情况下，你可以使用类似如下的代码：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The higher specificity gives precedence to this rule over any other rules applied
    to the `html` element, meaning the following is ignored:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 更高的特异性使得这条规则优先于应用于`html`元素的其他规则，意味着以下规则将被忽略：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But it’s unlikely that you’ll need to use this in most situations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但在大多数情况下，你不太可能需要在大多数情况下使用这个。
- en: '***:not()***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***:not()***'
- en: 'The negation pseudo-class `:not()` selects all elements *except* those that
    are given as the value of an argument:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 否定伪类`:not()`选择所有元素，*除了*那些作为参数值提供的元素：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This rule selects all children of element `*E*` except for those of type `*F*`.
    For example, to color all the immediate child elements of a `div`, except for
    `p` elements, you use this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则选择元素`*E*`的所有子元素，除了类型为`*F*`的元素。例如，要为`div`的所有直接子元素上色，除了`p`元素，你可以使用：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To see how useful `:not()` is, consider a situation where you have the following
    markup:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看 `:not()` 的有用性，假设你有以下标记：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now imagine you want to italicize all of the child `p` elements except for the
    first one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想让所有子 `p` 元素都呈斜体，除了第一个。
- en: 'To do this with CSS2, you applied a style to all the `p` elements and then
    applied a further style to reset the first element back to its previous state:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 CSS2 实现这一点，你将样式应用于所有的 `p` 元素，然后再应用一个额外的样式将第一个元素重置回其先前的状态：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With `:not()`, you can reduce that to a single rule:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `:not()`，你可以将其简化为一个规则：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The argument passed into `:not()` must be a simple selector—therefore combinators
    (such as `+` and `>`) and pseudo-elements (which I discuss in “[Pseudo-elements](ch04.html#ch04leve1sec47)”
    on [page 45](ch04.html#page_45)) are not valid values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `:not()` 的参数必须是简单选择器——因此，组合符（如 `+` 和 `>`）和伪元素（我在 “[伪元素](ch04.html#ch04leve1sec47)”
    中讨论过，它出现在[第 45 页](ch04.html#page_45)）不是有效值。
- en: '***UI Element States***'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '***UI 元素状态***'
- en: 'Elements relating to forms and user input can have various states; they can
    be disabled or checked, for example, by setting attribute values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与表单和用户输入相关的元素可以具有不同的状态；例如，它们可以被禁用或选中，可以通过设置属性值来实现：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'CSS3 has three UI state pseudo-class selectors, which allow you to apply rules
    to elements based on their current state:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3 有三个 UI 状态伪类选择器，可以让你根据元素的当前状态应用规则：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**NOTE**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*HTML has no* `*enabled*` *attribute; elements that are not disabled are, by
    definition, enabled.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTML 没有* `*enabled*` *属性；未被禁用的元素按定义是启用的。*'
- en: 'To see the effect of these pseudo-class selectors, consider the following style
    rules:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这些伪类选择器的效果，考虑以下样式规则：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'I’ll apply these rules to a form that has two text `input` elements, one of
    which has a `disabled` attribute (the form isn’t well-structured as I don’t have
    labels for the inputs, but I’ve left them out for clarity):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这些规则应用于一个包含两个文本 `input` 元素的表单，其中一个有 `disabled` 属性（表单结构不太规范，因为没有为输入框添加标签，但为了清晰起见，我将标签省略了）：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can see the results in [Figure 4-8](ch04.html#ch04fig8).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 4-8](ch04.html#ch04fig8)中看到结果。
- en: '![Image](graphics/f04-08.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f04-08.jpg)'
- en: '*Figure 4-8: Disabled and enabled element states*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：禁用和启用元素状态*'
- en: As you can see, the disabled form element has grayed-out text (which is done
    automatically by the browser) and a gray dotted border (which I set in the style
    sheet). I set a solid black border around the enabled element.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，禁用的表单元素具有灰色文本（这是浏览器自动完成的）和灰色虚线边框（这是我在样式表中设置的）。我为启用的元素设置了一个实心黑色边框。
- en: I’m not giving a demonstration of the `checked` state here, as most browsers
    have different interpretations of which style rules can be applied to `checkbox`
    inputs. For a comprehensive overview of cross-browser styling of form elements,
    I highly recommend “Styling Form Controls with CSS” from the blog 456 Berea Street
    (*[http://www.456bereastreet.com/lab/styling-form-controls-revisited/](http://www.456bereastreet.com/lab/styling-form-controls-revisited/)*).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里没有演示 `checked` 状态，因为大多数浏览器对 `checkbox` 输入框可以应用的样式规则有不同的解释。关于跨浏览器表单元素样式的全面概述，我强烈推荐来自
    456 Berea Street 博客的《使用 CSS 样式化表单控件》(*[http://www.456bereastreet.com/lab/styling-form-controls-revisited/](http://www.456bereastreet.com/lab/styling-form-controls-revisited/)*)
- en: There is a fourth UI element state, `indeterminate`, which is used in a limited
    set of circumstances; for example, a radio button input in a group where no input
    has been checked would be classed as indeterminate, as would a `progress` element
    with no value supplied. Although implemented in some browsers, however, it hasn’t
    yet been fully defined, and its status is indeterminate (ha!).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个第四种 UI 元素状态，`indeterminate`，它在某些情况下使用；例如，一个单选按钮输入框所在的组中，如果没有选择任何输入项，它就会被视为不确定状态，`progress`
    元素如果没有值也会被视为不确定状态。尽管某些浏览器已实现这一功能，但它尚未完全定义，其状态依然是不确定的（哈！）。
- en: '***Constraint Validation Pseudo-classes***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***约束验证伪类***'
- en: HTML5 introduced a new API for client-side validation of forms, known as the
    *constraint validation API*, which can be used to determine if certain requirements
    are met before the form contents are sent to the server. The constraint validation
    API brings along with it an associated range of new pseudo-classes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 引入了一个新的客户端验证表单的 API，称为 *约束验证 API*，它可以在表单内容提交到服务器之前，确定是否满足某些要求。约束验证 API
    带来了与之相关的一系列新伪类。
- en: '**NOTE**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Mozilla Developer Network (MDN) has an excellent introduction to the Constraint
    Validation API at* [https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation/](https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mozilla 开发者网络 (MDN) 提供了一个关于约束验证 API 的优秀介绍，链接为* [https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation/](https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation/)。'
- en: 'Under constraint validation, a form field can be made mandatory through use
    of the new `required` attribute:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在约束验证下，可以通过使用新的 `required` 属性将表单字段设置为必填：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can style elements depending on whether they’re required or optional by
    using their namesake pseudo-classes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据表单字段是否为必填或可选，使用它们的伪类来设置样式：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Each form field can be in one of two states of validation: either valid or
    invalid. If no specific constraints are applied, either by the browser or the
    author, a form field is valid by default. As before, each state has a namesake
    pseudo-class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表单字段可以处于两种验证状态之一：有效或无效。如果没有应用任何特定的约束（无论是浏览器还是作者设定的），则表单字段默认为有效。如前所述，每个状态都有一个相应的伪类：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**WARNING**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*In a form with which the user has yet to interact, fields with constraints
    that aren’t met—such as being required—will have rules set with the* `*:invalid*`
    *pseudo-class applied already.*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*在用户尚未与表单互动的情况下，未满足约束条件的字段——例如，必填字段——将已经应用* `*:invalid*` *伪类规则。*'
- en: 'Finally, some HTML5 elements can have a permitted range of values, set by using
    the `min` and `max` attributes. You can style these elements depending on whether
    the current value is in or out of range by using, once again, a pair of namesake
    pseudo-classes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些 HTML5 元素可以设置允许的值范围，可以通过使用 `min` 和 `max` 属性来实现。你可以根据当前值是否在范围内来设置这些元素的样式，使用的仍然是成对的伪类：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Pseudo-elements**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**伪元素**'
- en: Like pseudo-classes, pseudo-elements provide information that is not specified
    in the document tree. But where pseudo-classes use “phantom” conditions such as
    an element’s position in the tree or its state, pseudo-elements go further and
    allow you to apply styles to elements that don’t exist in the tree at all.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 像伪类一样，伪元素提供了文档树中未指定的信息。但与伪类使用像元素在树中的位置或状态这样的“虚拟”条件不同，伪元素更进一步，允许你对文档树中根本不存在的元素应用样式。
- en: 'In CSS2, the four pseudo-elements are `:first-line` and `:first-letter`, which
    select subelements in text nodes, and `:after` and `:before`, which allow you
    to apply styles at the beginning and end of existing elements. CSS3 doesn’t introduce
    any new pseudo-elements, but it refines the definitions slightly and introduces
    a new syntax to differentiate them from pseudoclasses. In CSS3, pseudo-elements
    are prefixed with a double colon (`::`), like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CSS2 中，四个伪元素是 `:first-line` 和 `:first-letter`，它们用于选择文本节点中的子元素，以及 `:after`
    和 `:before`，它们允许你在现有元素的开始和结束位置应用样式。CSS3 并没有引入新的伪元素，但它稍微调整了定义，并引入了一种新的语法，以便将它们与伪类区分开来。在
    CSS3 中，伪元素的前缀是双冒号 (`::`)，如下所示：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**NOTE**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The single colon syntax is still accepted for reasons of backward compatibility,
    although it is deprecated and you shouldn’t use it going forward.*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*单冒号语法仍然被接受，原因是为了向后兼容，尽管它已被弃用，今后不应该再使用。*'
- en: '***The ::selection Pseudo-element***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***::selection 伪元素***'
- en: 'Early versions of the CSS3 Selectors module included the definition of a `::selection`
    pseudo-element. Although formally removed from the module, it has been well implemented
    across desktop browsers (less so in mobile browsers). `::selection` is used to
    apply rules to an element that the user has selected in the browser (for example,
    a portion of a text node):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3 选择器模块的早期版本包括了 `::selection` 伪元素的定义。尽管它已被正式从该模块中移除，但它在桌面浏览器中得到了很好的实现（在移动浏览器中则较少实现）。`::selection`
    用于对用户在浏览器中选择的元素应用规则（例如，选择文本节点的一部分）：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Only a limited number of properties can be applied with `::selection`: `color`,
    `background-color`, and the `background` shorthand (although not `background-image`).
    Using `::selection`, you can do something like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 只有有限数量的属性可以通过 `::selection` 应用：`color`、`background-color` 和 `background` 简写（但不能使用
    `background-image`）。使用 `::selection`，你可以像这样进行样式设置：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[Figure 4-9](ch04.html#ch04fig9) shows a comparison of the system-native `::selection`
    colors (top) and the colors I’ve applied with the `::selection` pseudo-element
    (bottom).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-9](ch04.html#ch04fig9) 显示了系统本地的 `::selection` 颜色（上方）与我使用 `::selection`
    伪元素应用的颜色（下方）的对比。'
- en: '![Image](graphics/f04-09.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f04-09.jpg)'
- en: '*Figure 4-9: Custom colors applied with the* `*::selection*` *pseudo-element*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：通过* `*::selection*` *伪元素应用的自定义颜色*'
- en: The `::selection` pseudo-element is implemented in Chrome, Safari, and IE9+
    without a prefix, and in Firefox with the `-moz-` prefix—so despite it no longer
    being part of the CSS3 specification, you can use it with confidence.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`::selection` 伪元素在 Chrome、Safari 和 IE9+ 中实现，无需前缀，在 Firefox 中则需要使用 `-moz-` 前缀——因此，尽管它不再是
    CSS3 规范的一部分，你依然可以放心使用它。'
- en: '**Summary**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The new range of pseudo-classes (and any pseudo-elements that may be defined
    in the future) makes document traversal far more flexible and powerful with CSS3
    than it ever was with its predecessors, and allows for much leaner and more maintainable
    markup.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 新一系列的伪类（以及未来可能定义的任何伪元素）使得通过 CSS3 进行文档遍历比以往任何时候都更加灵活和强大，而且可以实现更加简洁和易于维护的标记。
- en: The increased number of pseudo-classes based on the state of UI and form validation
    also gives users a much broader range of feedback, without relying on JavaScript.
    This is exceptionally useful for HTML5, with its increased focus on web applications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 UI 状态和表单验证的伪类数量的增加，极大地扩展了用户反馈的范围，无需依赖 JavaScript。这对于 HTML5 来说尤为重要，因为它更加关注
    Web 应用程序。
- en: '**DOM and Attribute Selectors: Browser Support**'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**DOM 和属性选择器：浏览器支持情况**'
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
- en: '| Structural pseudo-classes | Yes | Yes | Yes | Yes |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 结构伪类 | 是 | 是 | 是 | 是 |'
- en: '| `:target` | Yes | Yes | Yes | Yes |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `:target` | 是 | 是 | 是 | 是 |'
- en: '| `:empty` | Yes | Yes | Yes | Yes |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `:empty` | 是 | 是 | 是 | 是 |'
- en: '| `:root` | Yes | Yes | Yes | Yes |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `:root` | 是 | 是 | 是 | 是 |'
- en: '| `:not()` | Yes | Yes | Yes | Yes |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `:not()` | 是 | 是 | 是 | 是 |'
- en: '| Pseudo-elements (`::` syntax) | Yes | Yes | Yes | Yes |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 伪元素（`::` 语法） | 是 | 是 | 是 | 是 |'
- en: '| UI element states | Yes | Yes | Yes | Yes |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| UI 元素状态 | 是 | 是 | 是 | 是 |'
- en: '| Constraint validation | Yes | Yes | Yes | IE10^([*](ch04.html#footnote20a))
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 约束验证 | 是 | 是 | 是 | IE10^([*](ch04.html#footnote20a)) |'
- en: '| `::selection` | Yes | Yes | Yes | Yes |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `::selection` | 是 | 是 | 是 | 是 |'
- en: '[*](ch04.html#footnote_20a) Does not support :in-range, :out-of-range'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[*](ch04.html#footnote_20a) 不支持 :in-range, :out-of-range'
