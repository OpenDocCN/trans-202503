- en: '**19**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**19**'
- en: '**RECEIVING FILE INPUT AND OUTPUT**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收文件输入与输出**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: The programs you’ve written so far in this book took input from the keyboard
    and sent output to the screen. But what if you wanted to create a virtual phone
    book and use thousands of lines of data in the program? Working with that much
    data could make it difficult to write and maintain your program. You’d have to
    input every name and phone number each time you ran the program!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书中写的程序到目前为止都是从键盘获取输入，并将输出显示在屏幕上。但是，如果你想创建一个虚拟电话簿并在程序中使用成千上万行数据呢？处理这么多数据可能会使你很难编写和维护程序。每次运行程序时，你都得输入每个名字和电话号码！
- en: Fortunately, a program can also receive input from a file and send its output
    to a file, and both files can be saved on your computer. So all the phone book
    information could be neatly tucked away in a file, and you’d only have to input
    the data once. Today, many programs process data that is stored in files.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，程序不仅可以从文件接收输入，还可以将输出发送到文件，这些文件都可以保存在你的计算机上。所以，所有的电话簿信息都可以整齐地保存在一个文件中，你只需输入一次数据。如今，许多程序都处理保存在文件中的数据。
- en: In most programming languages, working with files is an advanced topic, but
    Small Basic makes file handling super simple. In this chapter, you’ll learn about
    the `File` object and how it makes working with files a breeze!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，处理文件是一个高级话题，但 Small Basic 使得文件处理变得非常简单。在本章中，你将学习 `File` 对象以及它是如何让文件处理变得轻松的！
- en: '**The Case for Files**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文件的重要性**'
- en: 'In your programs, you’ve used variables and arrays to store data. But data
    stored in variables and arrays is temporary: all that data is lost when the program
    ends or when you turn off your computer. When you run your program again, it won’t
    remember the input you entered the last time it ran. If you want to permanently
    store the data created in a program, you need to save that data in a file. Data
    stored in files is called *persistent data* because it’s retained even after you
    turn off your computer. It’s as persistent as a squirrel caching acorns.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中，你已经使用了变量和数组来存储数据。但是，存储在变量和数组中的数据是临时的：当程序结束或你关闭计算机时，所有数据都会丢失。当你再次运行程序时，它不会记得你上次输入的数据。如果你想永久存储程序中创建的数据，你需要将这些数据保存在文件中。存储在文件中的数据被称为*持久数据*，因为即使在你关闭计算机后它仍然保留。这就像松鼠储存橡果一样持久。
- en: Files provide a convenient way to handle large amounts of data. If your program
    requires lots of data (like the names of your friends), you can’t ask a user to
    input that data each time they run the program. Most likely, they will get annoyed
    and stop using the program. If a program can read its input data from a file,
    a user won’t need to enter data by hand and might want to run the program many
    times. When programs use files, a user could even customize the application by
    changing the data file. For example, if you write a spelling game that reads its
    input from a file, the user can set the game’s difficulty by changing the input
    file. For example, they could use short words for an easy game and long words
    for a more difficult game.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 文件提供了一种方便的方式来处理大量数据。如果你的程序需要大量数据（比如你朋友的名字），你不可能每次都要求用户手动输入这些数据。很可能，他们会因此感到烦躁并停止使用程序。如果程序可以从文件中读取输入数据，用户就不需要手动输入数据，并且可能会多次运行程序。当程序使用文件时，用户甚至可以通过更改数据文件来定制应用程序。例如，如果你写了一个拼写游戏，它从文件中读取输入，用户可以通过更改输入文件来设置游戏的难度。例如，他们可以使用短单词来进行简单的游戏，用长单词来进行更困难的游戏。
- en: Getting data from a file is called *reading the file*, and the files a program
    reads are generally called *input files*. Similarly, sending data to a file is
    called *writing to the file*, and the files a program writes to (or creates) are
    called *output files*. Storing data to (and reading data from) files on disk is
    called *file access*. Working with files is called *file I/O*, which is short
    for input/output.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中获取数据叫做*读取文件*，程序读取的文件通常称为*输入文件*。类似地，将数据写入文件叫做*写入文件*，程序写入（或创建）的文件称为*输出文件*。将数据存储到文件（并从文件中读取数据）叫做*文件访问*。处理文件被称为*文件
    I/O*，即输入/输出的缩写。
- en: Before we start working with files in programs, let’s look at filenames and
    how files are saved on your computer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在程序中处理文件之前，先来看看文件名以及文件是如何保存在计算机上的。
- en: '***Naming Files***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件命名***'
- en: When you create a new file, you give it a name. You can call it *Fred* or *DontOpenMe*
    if you want, but it’s usually best to name it more specifically, such as *myFriends*
    or *myLoveStory*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新文件时，你为它起一个名字。你可以随便命名，比如*Fred*或*DontOpenMe*，但通常最好更具体一些，比如*myFriends*或*myLoveStory*。
- en: The Windows operating system is case insensitive and doesn’t see any difference
    between uppercase and lowercase letters in filenames, so *myFile*, *Myfile*, and
    *MYFILE* would all refer to the same file. Windows also supports filenames with
    two parts that are separated by a period, such as *myFile.dat*. The part following
    the period (*dat* in this example) is called the *file extension*. The file extension
    usually indicates what kind of file it is (such as a photo or text file). [Table
    19-1](ch19.html#ch19table1) lists some of the most common file extensions and
    their meanings. File extensions are usually added automatically by the programs
    you use. For example, the Small Basic IDE adds an *.sb* extension to source code
    files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Windows操作系统对文件名大小写不敏感，因此在文件名中大写字母和小写字母没有区别，所以*myFile*、*Myfile*和*MYFILE*都会指向同一个文件。Windows还支持由句点分隔的两部分文件名，例如*myFile.dat*。句点后面的部分（在这个例子中是*dat*）叫做*文件扩展名*。文件扩展名通常指示文件类型（例如照片或文本文件）。[表19-1](ch19.html#ch19table1)列出了常见的文件扩展名及其含义。文件扩展名通常由你使用的程序自动添加。例如，Small
    Basic IDE会为源代码文件添加*.sb*扩展名。
- en: '**Table 19-1:** Common File Extensions'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**表19-1：** 常见文件扩展名'
- en: '| **Extension** | **File type** | **Used for** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名** | **文件类型** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *.dat* | General data file | Storing information about a specific application
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| *.dat* | 一般数据文件 | 存储特定应用程序的信息 |'
- en: '| *.exe* | Executable file | Applications |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| *.exe* | 可执行文件 | 应用程序 |'
- en: '| *.gif* | Graphic Interchange Format | Website images |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| *.gif* | 图形交换格式 | 网站图片 |'
- en: '| *.html* | Hypertext Markup Language website file | Web pages |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| *.html* | 超文本标记语言网站文件 | 网页 |'
- en: '| *.jpg* | An image encoded with the JPEG standard | Photos from a digital
    camera |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| *.jpg* | 使用JPEG标准编码的图像 | 数码相机拍摄的照片 |'
- en: '| *.mp3* | Music encoded in MPEG layer 3 audio format | Audio files |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| *.mp3* | 采用MPEG层3音频格式编码的音乐 | 音频文件 |'
- en: '| *.pdf* | Portable Document Format file for reading | Ebooks |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| *.pdf* | 可携带文档格式文件用于阅读 | 电子书 |'
- en: '| *.txt* | General text file | Notes you might write in Notepad |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| *.txt* | 一般文本文件 | 你可能在记事本中写的笔记 |'
- en: You’ll be working with text (*.txt*) files in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用文本（*.txt*）文件。
- en: '***File Organization***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件组织***'
- en: Imagine dozens of books organized in a cabinet with several shelves. Each shelf
    has a different label (such as Science, Math, Novels, Dr. Seuss, and so on) and
    is filled with books in that category. Each shelf serves as a container that groups
    related books together. Similarly, files on a computer are stored in containers
    called *directories* (or *folders*). A directory can contain files as well as
    other directories. A directory within a directory is called a *subdirectory*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，数十本书被组织在一个有多个架子的柜子里。每个架子都有不同的标签（例如科学、数学、小说、苏斯博士等），并且架子上放满了该类别的书籍。每个架子就像一个容器，将相关的书籍组合在一起。类似地，计算机上的文件存储在称为*目录*（或*文件夹*）的容器中。一个目录可以包含文件以及其他目录。一个目录中的目录被称为*子目录*。
- en: The *filesystem* is the part of the operating system that is responsible for
    organizing files and directories on a computer and providing ways to manage them.
    When you call a file-related method from your Small Basic program (to create,
    delete, read from, or write to a file), the operating system’s filesystem handles
    all the low-level details for you, so you don’t have to worry whether the actual
    files are stored on a hard drive, flash memory, a CD, a DVD, and so on. The Small
    Basic library talks to the operating system to access files stored on various
    media, as illustrated in [Figure 19-1](ch19.html#ch19fig1).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件系统*是操作系统的一部分，负责组织计算机上的文件和目录，并提供管理它们的方法。当你从Small Basic程序调用与文件相关的方法（如创建、删除、读取或写入文件）时，操作系统的文件系统会处理所有底层细节，因此你不需要担心文件是存储在硬盘、闪存、CD、DVD等介质上的。Small
    Basic库与操作系统交互，以访问存储在各种介质上的文件，正如[图19-1](ch19.html#ch19fig1)所示。'
- en: '![image](graphics/f19-01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f19-01.jpg)'
- en: '*Figure 19-1: How the filesystem lets you access files on different media*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-1：文件系统如何让你访问不同介质上的文件*'
- en: The filesystem has a tree structure, like the one shown in [Figure 19-2](ch19.html#ch19fig2).
    The top of the tree is called the *root directory* (the drive letter *D:* in this
    figure). The root directory has a number of files and other directories under
    it. Each of these directories might contain other files and subdirectories.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统具有树形结构，如[图19-2](ch19.html#ch19fig2)所示。树的顶部称为*根目录*（在此图中是驱动器字母*D:*）。根目录下有许多文件和其他目录。这些目录中可能包含其他文件和子目录。
- en: You can locate any file by following a path from the root directory down the
    tree until you reach that file. The sequence of directories you follow makes up
    the *pathname* for the file. For example, to find the last file in [Figure 19-2](ch19.html#ch19fig2),
    you would look in the root directory *D:*, then in *Book*, and then in *Chapter03*
    to locate the file. If you write the path using a backslash (\) to separate each
    directory, the pathname is *D:\Book\Chapter03\Ch03.docx*. You can locate each
    file on the system using its pathname.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从根目录沿着树形结构查找路径，直到到达目标文件，从而找到任何文件。你遵循的目录序列构成了该文件的*路径名*。例如，要查找[图19-2](ch19.html#ch19fig2)中的最后一个文件，你需要首先在根目录*D:*中查找，然后进入*Book*目录，再进入*Chapter03*目录以定位该文件。如果你使用反斜杠（\）将每个目录分隔开来，那么路径名就是*D:\Book\Chapter03\Ch03.docx*。你可以通过路径名定位系统上的每一个文件。
- en: '![image](graphics/f19-02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f19-02.jpg)'
- en: '*Figure 19-2: The filesystem as a tree*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-2：文件系统的树形结构*'
- en: To access a file from a Small Basic program, you need to specify the file’s
    pathname. To learn how, look at the executable file *Test.exe* in [Figure 19-2](ch19.html#ch19fig2).
    When you run this file, the running program knows its *current directory* (which
    is *D:\Book\Chapter01\Examples* in this case). If you want *Test.exe* to access
    a data file (such as *Test1.dat* or *Test2.dat*), you need to specify the pathname—the
    sequence of folders, starting from the root, that the program needs to navigate
    to reach the file. This is also called the *absolute path*. In [Figure 19-2](ch19.html#ch19fig2),
    the absolute path for *Test1.dat* is *D:\Book\Chapter01\Examples\Test1.dat*, and
    the absolute path for *Test2.dat* is *D:\Book\Chapter01\Examples\Data\Test2.dat*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个Small Basic程序访问文件，你需要指定文件的路径名。要了解如何做，查看[图19-2](ch19.html#ch19fig2)中的可执行文件*Test.exe*。当你运行这个文件时，运行中的程序知道它的*当前目录*（在这个例子中是*D:\Book\Chapter01\Examples*）。如果你希望*Test.exe*访问一个数据文件（比如*Test1.dat*或*Test2.dat*），你需要指定路径名——从根目录开始，程序需要导航的文件夹序列，直到到达目标文件。这也叫做*绝对路径*。[图19-2](ch19.html#ch19fig2)中，*Test1.dat*的绝对路径是*D:\Book\Chapter01\Examples\Test1.dat*，而*Test2.dat*的绝对路径是*D:\Book\Chapter01\Examples\Data\Test2.dat*。
- en: 'If you write a program that only you will use, you can save the data files
    needed by this program anywhere you like and access these files using absolute
    paths hardcoded in your program. For example, you can write this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写的程序只有你自己使用，你可以将该程序需要的所有数据文件保存在任何你喜欢的地方，并使用在程序中硬编码的绝对路径访问这些文件。例如，你可以这样写：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But if you give this program to a friend to try, it will fail unless your friend
    has the same file tree as you. A better solution is to build the desired path(s)
    in your program at runtime, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你将这个程序交给朋友试用，除非你的朋友拥有与您相同的文件树，否则程序会失败。一个更好的解决方案是在程序运行时动态构建所需的路径，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now the program will add *Test1.dat* to the end of its current directory, which
    means it will look for *Test1.dat* in the same folder that the program is in.
    Then your friend only needs to place *Test.exe* and *Test1.dat* in the same folder;
    the absolute path will no longer matter. You can just zip your program’s folder
    (right-click the folder, click Send to, and click Compressed (zipped) folder)
    and send that ZIP file to your friend. Your friend can save the files contained
    in the ZIP file under *C:\*, *D:\*, *C:\Temp*, or any other folder of their choice,
    and your program will work as you designed it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序将会将*Test1.dat*添加到当前目录的末尾，这意味着它会在程序所在的同一文件夹中查找*Test1.dat*。然后，你的朋友只需要将*Test.exe*和*Test1.dat*放在同一个文件夹中；绝对路径就不再重要。你可以将程序的文件夹压缩成ZIP文件（右键点击文件夹，选择“发送到”，然后点击“压缩（zipped）文件夹”），然后将ZIP文件发送给你的朋友。你的朋友可以将ZIP文件中的文件保存到*C:\*、*D:\*、*C:\Temp*或任何他们选择的文件夹中，你的程序依然能按设计正常运行。
- en: With an understanding of files and pathnames, you’re ready to learn about the
    `File` object and how to use its methods to read data from files, write data to
    files, and perform other file management operations. Let’s go single file!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解文件和路径名，你已经准备好学习`File`对象及其方法，如何从文件中读取数据、向文件写入数据，并执行其他文件管理操作。让我们开始学习单文件操作吧！
- en: '**The File Object**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文件对象**'
- en: Small Basic’s `File` object includes all the methods that handle reading and
    writing file data, deleting and copying files, and listing directory contents.
    Because this object supports many methods, this section is divided into two parts.
    First, we’ll explore the methods related to reading from and writing to files.
    Second, we’ll look at the methods related to file management.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Small Basic 的`File`对象包括所有处理文件数据读取和写入、删除和复制文件以及列出目录内容的方法。由于此对象支持许多方法，因此本节分为两部分。首先，我们将探索与读取和写入文件相关的方法。其次，我们将看看与文件管理相关的方法。
- en: '***File I/O Methods***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件输入输出方法***'
- en: The `File` object’s most frequently used methods are those used to write data
    to files and read data from files. Let’s explore these methods in detail.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`对象中最常用的方法是那些用于将数据写入文件和从文件中读取数据的方法。让我们详细了解这些方法。'
- en: To start, open Notepad and type some words in the editor so it looks like [Figure
    19-3](ch19.html#ch19fig3). Make sure that you don’t press ENTER after the last
    line.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开记事本并在编辑器中输入一些单词，使其看起来像[图 19-3](ch19.html#ch19fig3)。确保在最后一行之后不要按 ENTER 键。
- en: '![image](graphics/f19-03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f19-03.jpg)'
- en: '*Figure 19-3: An example text file*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-3：一个示例文本文件*'
- en: Save the file as *Test1.txt* in *C:\Temp* so its absolute pathname is *C:\Temp\Test1.txt*.
    If you don’t want to create the file, you can find it in this chapter’s folder;
    just copy it to *C:\Temp*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为*Test1.txt*，并放在*C:\Temp*目录下，这样它的绝对路径就是*C:\Temp\Test1.txt*。如果不想创建文件，你可以在本章的文件夹中找到它，直接将其复制到*C:\Temp*。
- en: '**Reading from a File**'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从文件中读取**'
- en: Now let’s try reading the contents of *Test1.txt*. You can use the `File` object’s
    `ReadContents()` method to read the entire contents of a file at once. This method
    opens a file, reads it, and returns its entire contents as a string. Enter and
    run the program in [Listing 19-1](ch19.html#ch19ex1) to see how this method works.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试读取*Test1.txt*的内容。你可以使用`File`对象的`ReadContents()`方法一次性读取文件的全部内容。此方法打开文件，读取文件，并将其全部内容作为字符串返回。输入并运行[Listing
    19-1](ch19.html#ch19ex1)中的程序，查看该方法是如何工作的。
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 19-1: Demonstrating the* `ReadContents()` *method*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-1：演示* `ReadContents()` *方法*'
- en: 'Here is the output of this program:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该程序的输出：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Line 2 sets the file’s absolute path. Line 3 reads the entire contents of the
    file and saves the returned string in a variable named `str` using the `ReadContents()`
    method. `ReadContents()` takes one argument: the pathname of the file you want
    to read. Line 4 gets the length of the string and saves it in a variable named
    `len`. Lines 5–6 display the `str` and `len` variables.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 行设置了文件的绝对路径。第 3 行读取文件的全部内容，并使用`ReadContents()`方法将返回的字符串保存到名为`str`的变量中。`ReadContents()`方法接受一个参数：要读取的文件的路径名。第
    4 行获取字符串的长度，并将其保存到名为`len`的变量中。第 5 行和第 6 行显示了`str`和`len`变量的值。
- en: 'But why does `GetLength()` output 19 characters for the string’s length when
    the string `"This is a Test."` contains only 15? To understand what’s going on,
    you need to examine the actual characters that make up the `str` variable. Remember
    from [Chapter 18](ch18.html#ch18) that characters are encoded in a format (such
    as ASCII or Unicode). Add the following code to the end of [Listing 19-1](ch19.html#ch19ex1),
    and run the program again:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为什么`GetLength()`方法会输出字符串长度为 19，尽管字符串 `"This is a Test."` 只有 15 个字符呢？要理解发生了什么，你需要检查构成`str`变量的实际字符。记住，[第
    18 章](ch18.html#ch18)提到字符是以某种格式（如 ASCII 或 Unicode）编码的。将以下代码添加到[Listing 19-1](ch19.html#ch19ex1)的末尾，再次运行程序：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code shows that the `str` variable has 19 characters. [Figure 19-4](ch19.html#ch19fig4)
    breaks down what the program is doing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示了`str`变量包含 19 个字符。[图 19-4](ch19.html#ch19fig4)详细解释了程序的工作原理。
- en: '![image](graphics/f19-04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f19-04.jpg)'
- en: '*Figure 19-4: The 19 characters of the* `str` *variable in [Listing 19-1](ch19.html#ch19ex1)*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-4：在 [Listing 19-1](ch19.html#ch19ex1) 中的 `str` 变量的 19 个字符*'
- en: Notepad inserts two special characters (called *carriage return* and *line feed*,
    whose ASCII codes are 13 and 10) to mark the end of each line. Think of the *newline*
    (or end-of-line) marker as a pair of characters produced when you press ENTER
    on the keyboard. Without these characters, the lines in the file would run together
    in one long line. The newline characters are *control characters*; they only control
    the position of the cursor on the screen or the printer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记事本插入了两个特殊字符（称为*回车符*和*换行符*，它们的 ASCII 码分别是 13 和 10）来标记每行的结束。可以将*换行符*（或行尾标记）看作是按下键盘上的
    ENTER 键时产生的字符对。没有这些字符，文件中的所有行会连在一起，成为一长行。换行符是*控制字符*；它们只控制光标在屏幕或打印机上的位置。
- en: The `ReadContents()` method returns the entire contents of the file as a single
    string, including newline characters between lines in the file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadContents()` 方法将文件的所有内容作为一个字符串返回，包括文件中各行之间的换行符。'
- en: '**Writing to a File**'
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**写入文件**'
- en: The `WriteContents()` method lets you save the contents of a string in a program
    to a file of your choice. If you want to create multiple lines of text, you need
    to insert the newline characters manually. For example, let’s write a program
    that reads text input from the keyboard and writes it back to a file. The program
    is shown in [Listing 19-2](ch19.html#ch19ex2).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteContents()` 方法让你将程序中字符串的内容保存到你选择的文件中。如果你想创建多行文本，你需要手动插入换行符。例如，让我们编写一个程序，从键盘读取文本输入并将其写回到文件。该程序在
    [清单 19-2](ch19.html#ch19ex2) 中显示。'
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 19-2: Demonstrating the* `WriteContents()` *method*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-2：演示* `WriteContents()` *方法*'
- en: 'Here’s a sample run of this program showing the user input:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该程序的一个示例运行，显示了用户输入：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now open the output file *C:\Temp\Out.txt* in Notepad and check its contents.
    The file contains what the user entered in the text window. Pretty cool, huh?
    You wrote all of that text without using Notepad!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在记事本中打开输出文件 *C:\Temp\Out.txt* 并检查其内容。该文件包含了用户在文本窗口中输入的内容。很酷吧？你在没有使用记事本的情况下就写下了这些文字！
- en: Here’s how the program works. We define the codes for the carriage return and
    the line feed characters in lines 2–3 and define the output file’s path in line
    4\. We then start a loop to get the user’s text (line 8–14). In each iteration
    of the loop, we prompt the user to enter any text they want (line 9) and read
    the input text into a variable named `strIn` (line 10). If the user enters any
    text other than `exit` (line 11), we append that text followed by a carriage return
    and line feed to the `strOut` string (line 12). When the user enters `exit`, the
    loop ends, and we call `WriteContents()` to write `strOut` to the output file
    (line 16). If the file doesn’t exist, `WriteContents()` automatically creates
    it. If the file does exist, `WriteContents()` overwrites its contents with whatever
    is in the `strOut` variable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的工作方式如下。我们在第2到第3行定义回车符和换行符，并在第4行定义输出文件的路径。接下来我们开始一个循环来获取用户的文本（第8到第14行）。在每次循环迭代中，我们提示用户输入他们想要的任何文本（第9行），并将输入的文本读取到名为
    `strIn` 的变量中（第10行）。如果用户输入的文本不是 `exit`（第11行），我们将该文本以及回车符和换行符附加到 `strOut` 字符串中（第12行）。当用户输入
    `exit` 时，循环结束，我们调用 `WriteContents()` 将 `strOut` 写入输出文件（第16行）。如果文件不存在，`WriteContents()`
    会自动创建它。如果文件已存在，`WriteContents()` 会用 `strOut` 中的内容覆盖文件的原有内容。
- en: '**TRY IT OUT 19-1**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 19-1**'
- en: Write a program that reads an input text file, converts the text to lowercase,
    and then saves the result to a new output file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，读取输入文本文件，将文本转换为小写字母，然后将结果保存到新的输出文件中。
- en: '**Checking for Errors**'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查错误**'
- en: Similar to when you work with user input, you can’t control what the user saves
    in a file that your program reads. Sometimes the data in a file might be incorrect
    due to human error. Many things can go wrong (as you’ll see in a moment), and
    your programs need to be ready to handle these errors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与处理用户输入时一样，你无法控制用户在你的程序读取的文件中保存的内容。由于人为错误，文件中的数据有时可能是错误的。许多事情可能出错（如你稍后将看到的），因此你的程序需要准备好处理这些错误。
- en: Fortunately, Small Basic is always prepared! A call to `WriteContents()` returns
    `"SUCCESS"` or `"FAILED"` automatically based on whether the operation was successful.
    A well-written program checks the returned string and takes action in case of
    failure. Let’s update [Listing 19-2](ch19.html#ch19ex2) to check the return value
    of `WriteContents()`. Replace the statement on line 16 with the code in [Listing
    19-3](ch19.html#ch19ex3).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Small Basic 总是做好了准备！调用 `WriteContents()` 会自动返回 `"SUCCESS"` 或 `"FAILED"`，取决于操作是否成功。一个写得好的程序会检查返回的字符串，并在失败时采取相应的措施。让我们更新
    [清单 19-2](ch19.html#ch19ex2)，检查 `WriteContents()` 的返回值。将第16行的语句替换为 [清单 19-3](ch19.html#ch19ex3)
    中的代码。
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 19-3: Checking the return value of* `WriteContents()`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-3：检查* `WriteContents()` *的返回值*'
- en: First, we save the return of `WriteContents()` in a variable named `result`
    (line 1), and then we check the method’s return value. If the method succeeds
    (line 2), we inform the user that the output has been saved successfully (line
    3). If the operation fails (line 4), we tell the user that the program failed
    to write to the output file (line 5), and then we display the reason for the failure
    using the `File` object’s `LastError` property (line 6). This property is automatically
    updated by `WriteContents()` if writing to a file fails.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `WriteContents()` 的返回值保存在名为 `result` 的变量中（第1行），然后检查该方法的返回值。如果方法成功（第2行），我们会通知用户输出已成功保存（第3行）。如果操作失败（第4行），我们会告诉用户程序未能写入输出文件（第5行），并使用
    `File` 对象的 `LastError` 属性显示失败的原因（第6行）。如果写入文件失败，`WriteContents()` 会自动更新该属性。
- en: 'After writing the code to handle the failure case, we need to test the code
    by making it fail on purpose. Here are some things that can cause `WriteContents()`
    to fail:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码处理失败情况后，我们需要通过故意使其失败来测试代码。以下是一些可能导致 `WriteContents()` 失败的情况：
- en: The path of the output file doesn’t exist.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出文件的路径不存在。
- en: The output file is already open in another program.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出文件已经在另一个程序中打开。
- en: There is not enough space to save the file.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有足够的空间保存文件。
- en: Let’s experiment with the first possibility to see what happens.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试第一个可能性，看看会发生什么。
- en: '**Path Doesn’t Exist**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**路径不存在**'
- en: Run the short program in [Listing 19-4](ch19.html#ch19ex4).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 [Listing 19-4](ch19.html#ch19ex4) 中的简短程序。
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 19-4: Writing to a file when the path doesn’t exist*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-4：路径不存在时写入文件*'
- en: 'You should see this output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The program attempts to write the string `"Hello"` to an output file (lines
    2–3). The directory *Temp* exists, but the subdirectory *Folder1* doesn’t exist,
    so `WriteContents()` fails.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 程序尝试将字符串 `"Hello"` 写入输出文件（第2–3行）。目录 *Temp* 存在，但子目录 *Folder1* 不存在，因此 `WriteContents()`
    失败。
- en: '**Appending to a File**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**向文件追加内容**'
- en: 'The `AppendContents()` method opens the specified file and adds data to the
    end of the file without erasing its original contents. `AppendContents()` takes
    two arguments: the pathname of the output file and the string you want to append
    to the end of the file. If the operation is successful, the method returns `"SUCCESS"`;
    otherwise, it returns `"FAILED"`. If the file you pass to `AppendContents()` doesn’t
    exist, it’s created for you, and the string is written to it. If the file already
    exists, the string is appended to its end.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppendContents()` 方法打开指定的文件，并将数据添加到文件末尾，而不覆盖原有内容。`AppendContents()` 接受两个参数：输出文件的路径名和你希望添加到文件末尾的字符串。如果操作成功，方法返回
    `"SUCCESS"`；否则，返回 `"FAILED"`。如果你传递给 `AppendContents()` 的文件不存在，它会为你创建该文件，并将字符串写入其中。如果文件已存在，字符串将被追加到文件末尾。'
- en: To see the `AppendContents()` method in use, let’s say you need to maintain
    a log file that records actions, errors, and other events in your program. To
    keep the program simple, let’s just record the times when your program is executed.
    Every time your program runs, you add a record to a log file that includes the
    date and time. The complete program is shown in [Listing 19-5](ch19.html#ch19ex5).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `AppendContents()` 方法的使用，假设你需要维护一个记录程序中动作、错误和其他事件的日志文件。为了简化程序，我们仅记录程序执行的时间。每次程序运行时，你都会向日志文件中添加一条记录，包括日期和时间。完整的程序在
    [Listing 19-5](ch19.html#ch19ex5) 中展示。
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 19-5: Demonstrating the* `AppendContents()` *method*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-5：演示* `AppendContents()` *方法*'
- en: When you run this program, it creates a log string that contains the current
    day of the week, date, and time (line 4), and it appends this string to the end
    of a log file named *Log.txt* that is in the program’s directory (line 5). If
    writing to the file fails, the program displays an error message explaining the
    cause of the failure (lines 7–8). Then the program displays a message (line 11)
    and ends.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，它会创建一个包含当前星期几、日期和时间的日志字符串（第4行），并将这个字符串追加到名为 *Log.txt* 的日志文件末尾，该文件位于程序的目录中（第5行）。如果写入文件失败，程序会显示一条错误信息，解释失败的原因（第7–8行）。然后，程序会显示一条消息（第11行）并结束。
- en: 'Each time you run this program, a new line is appended to the end of the *Log.txt*
    file. Here’s the output of *Log.txt* after running the program three times:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行此程序时，都会向 *Log.txt* 文件末尾添加一行。以下是运行程序三次后的 *Log.txt* 输出：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**ReadLine(), WriteLine(), and InsertLine()**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**ReadLine(), WriteLine(), 和 InsertLine()**'
- en: The `ReadContents()` and `WriteContents()` methods let you read and write the
    entire contents of a file at once. Sometimes this is just what you need. But in
    other situations, reading or writing one line at a time might be better.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadContents()` 和 `WriteContents()` 方法允许你一次性读取和写入文件的全部内容。有时这正是你需要的，但在其他情况下，一次读取或写入一行可能更合适。'
- en: 'The `File` object provides the `ReadLine()` method for reading a single line
    of text from a file. A line of text consists of a string of characters that ends
    with a carriage return and line feed pair. `ReadLine()` reads all the text on
    that line up to (but not including) the carriage return character. This method
    takes two arguments: the path of the file and the line number of the text to be
    read. The first line of a file is line number 1, the second line is 2, and so
    on. If the file contains the specified line number, the method returns the text
    at that line. Otherwise, it returns an empty string.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 对象提供了 `ReadLine()` 方法，用于从文件中读取一行文本。一行文本由一串字符组成，末尾带有回车符和换行符。`ReadLine()`
    会读取该行所有文本，直到（但不包括）回车符。该方法接受两个参数：文件路径和要读取的行号。文件的第一行是第 1 行，第二行是第 2 行，以此类推。如果文件包含指定的行号，方法将返回该行的文本；否则，返回空字符串。'
- en: 'The `File` object also provides the `WriteLine()` method for outputting a line
    of text to a file. This method takes three arguments: the path of the file, the
    line number to write text to, and the text to write. Keep the following information
    in mind when you’re using this method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 对象还提供了 `WriteLine()` 方法，用于将一行文本输出到文件。该方法接受三个参数：文件路径、要写入文本的行号以及要写入的文本。使用该方法时，需注意以下几点：'
- en: If the file doesn’t exist, `WriteLine()` creates it.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在，`WriteLine()` 会创建该文件。
- en: If the file contains the specified line number, `WriteLine()` overwrites that
    line.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件包含指定的行号，`WriteLine()` 会覆盖该行。
- en: If the specified line number is larger than the number of lines in the file,
    the specified text is appended to the end of the file. For example, if the file
    contains three lines and you ask `WriteLine()` to write new text at line 100,
    the specified text is written at line 4.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指定的行号大于文件中的行数，指定的文本将被附加到文件末尾。例如，如果文件包含三行，而你要求 `WriteLine()` 在第 100 行写入新文本，指定的文本将写入第
    4 行。
- en: '`WriteLine()` automatically writes a carriage return and line feed at the end
    of the passed text. This means you don’t have to append these characters to your
    strings manually.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WriteLine()` 会自动在传入的文本末尾写入回车符和换行符。这意味着你不需要手动在字符串中追加这些字符。'
- en: If the operation is successful, `WriteLine()` returns `"SUCCESS"`; otherwise,
    it returns `"FAILED"`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果操作成功，`WriteLine()` 返回 `"SUCCESS"`；否则，返回 `"FAILED"`。
- en: 'In addition to `ReadLine()` and `WriteLine()`, the `File` object provides the
    `InsertLine()` method for you to insert a line of text into a file, at a specified
    line number. As with the `WriteLine()` method, this method takes three arguments:
    the path of the file, the line number where you want the new text to be inserted,
    and the text you want to insert. `InsertLine()` won’t overwrite any existing content
    at the specified line. If the operation is successful, `InsertLine()` returns
    `"SUCCESS"`; otherwise, it returns `"FAILED"`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `ReadLine()` 和 `WriteLine()`，`File` 对象还提供了 `InsertLine()` 方法，允许你在指定的行号插入一行文本。与
    `WriteLine()` 方法类似，`InsertLine()` 方法接受三个参数：文件路径、要插入新文本的行号以及要插入的文本。`InsertLine()`
    不会覆盖指定行的现有内容。如果操作成功，`InsertLine()` 返回 `"SUCCESS"`；否则，返回 `"FAILED"`。
- en: As an example, let’s write a simple program that creates login names from the
    first and last names of users. The program will read an input file that contains
    the first and last names of users, and it will create an output file that contains
    the login names for these users. The login name for a user is composed of the
    first letter of the user’s first name and up to five characters from their last
    name. For example, if the user’s name is Jack Skellington, his login name is *jskell*.
    If the user’s name is Stan Lee (three-letter last name), his login name will be
    *slee*. The complete program is shown in [Listing 19-6](ch19.html#ch19ex6).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们可以写一个简单的程序，用用户的名字和姓氏生成登录名。该程序会读取一个输入文件，文件中包含用户的名字和姓氏，并创建一个包含这些用户登录名的输出文件。用户的登录名由名字的首字母和姓氏中的最多五个字符组成。例如，如果用户的名字是
    Jack Skellington，他的登录名是 *jskell*。如果用户的名字是 Stan Lee（姓氏为三个字母），他的登录名将是 *slee*。完整的程序请参考
    [Listing 19-6](ch19.html#ch19ex6)。
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 19-6: Creating login names from first and last names*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-6：从名字和姓氏创建登录名*'
- en: We start by giving the paths for the input and output files (lines 2–3). We
    then start a loop to read the contents of the input file, one line at a time (lines
    6–19). After reading a line (line 7), we check whether that line is empty, and
    if it is (line 8), we set `N` equal to 0 to end the loop (line 9). Otherwise,
    we process the user’s name that is read from the input file to create the lowercase
    login name (lines 11–15). First, we find the space between the first name and
    the last name (line 11). Next, we get the first letter of the first name (line
    12) and the first five letters of the last name (line 13), combine them to create
    the login name (line 14), and convert the login name to lowercase (line 15). Then
    we write the login name to the output file (line 16) and increment `N` by 1 to
    read the next line in the input file (line 17).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先给出输入文件和输出文件的路径（第2-3行）。然后开始一个循环，每次读取输入文件的一行（第6-19行）。读取一行后（第7行），我们检查该行是否为空，如果是（第8行），则将`N`设为0以结束循环（第9行）。否则，我们处理从输入文件读取的用户姓名，以创建小写的登录名（第11-15行）。首先，我们找到名字和姓氏之间的空格（第11行）。接着，我们获取名字的第一个字母（第12行）和姓氏的前五个字母（第13行），将它们结合起来创建登录名（第14行），并将登录名转换为小写（第15行）。然后我们将登录名写入输出文件（第16行），并将`N`加1以读取输入文件中的下一行（第17行）。
- en: 'To keep the code simple, we didn’t add error-checking code. We also assumed
    that the input file was properly formatted: each line contained a user’s first
    and last names separated by a single space. [Table 19-2](ch19.html#ch19table2)
    shows an example input file for this program and the output file.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码简洁，我们没有添加错误检查代码。我们还假设输入文件的格式正确：每行包含用户的名字和姓氏，二者之间由一个空格分隔。[表 19-2](ch19.html#ch19table2)展示了该程序的一个输入文件示例及其输出文件。
- en: '**Table 19-2:** Creating Login Names'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 19-2：** 创建登录名'
- en: '| **User’s name** | **Login name** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **用户姓名** | **登录名** |'
- en: '| --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Tina Fey | *tfey* |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| Tina Fey | *tfey* |'
- en: '| Jimmy Fallon | *jfallo* |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| Jimmy Fallon | *jfallo* |'
- en: '| David Letterman | *dlette* |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| David Letterman | *dlette* |'
- en: '| Jay Leno | *jleno* |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| Jay Leno | *jleno* |'
- en: '| Amy Poehler | *apoehl* |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| Amy Poehler | *apoehl* |'
- en: '**TRY IT OUT 19-2**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手试一试 19-2**'
- en: Write a program that reads an input file and counts the number of lines, characters,
    and spaces it contains.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，读取一个输入文件并统计其中的行数、字符数和空格数。
- en: '***File Management***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件管理***'
- en: In addition to the methods that let you perform file I/O, the `File` object
    also provides a couple of methods related to file and directory management. Using
    these methods, you can copy and delete files, create and delete directories, and
    list files and directories from your program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让你执行文件 I/O 的方法外，`File`对象还提供了几个与文件和目录管理相关的方法。使用这些方法，你可以复制和删除文件，创建和删除目录，并从程序中列出文件和目录。
- en: '**Copying and Deleting Files**'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复制和删除文件**'
- en: You can use the `CopyFile()` method to create a copy of an existing file. This
    method takes the pathnames of the source file and the destination file as arguments.
    The source file isn’t affected by this operation. If the operation is successful,
    the method returns `"SUCCESS"`. Otherwise, it returns `"FAILED"`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `CopyFile()` 方法创建一个现有文件的副本。此方法将源文件和目标文件的路径作为参数传递。源文件不会受到此操作的影响。如果操作成功，方法将返回
    `"SUCCESS"`。否则，它将返回 `"FAILED"`。
- en: 'If the destination path points to a location that doesn’t exist, the method
    attempts to create it automatically. For example, look at the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标路径指向一个不存在的位置，该方法会尝试自动创建该位置。例如，查看以下代码：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the subfolders *Temp*, *Temp1*, and *Temp2* don’t exist, `CopyFile()` attempts
    to create all the directories in the destination path, beginning with the root.
    When you run this code, you’ll have two copies of the *Test1.txt* file: the original
    source file and the duplicate file under *C:\Temp\Temp1\Temp2*.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子文件夹*Temp*、*Temp1* 和 *Temp2* 不存在，`CopyFile()`会尝试从根目录开始创建目标路径中的所有目录。当你运行这段代码时，你将有两个
    *Test1.txt* 文件的副本：一个是原始源文件，另一个是位于 *C:\Temp\Temp1\Temp2* 下的副本。
- en: '**WARNING**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*If the destination path points to an existing file, that file will be overwritten.
    So be careful when you use the* `CopyFile()` *method, because you might overwrite
    some of your files!*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果目标路径指向一个已存在的文件，该文件将被覆盖。所以使用* `CopyFile()` *方法时要小心，因为你可能会覆盖某些文件！*'
- en: 'If you want to delete a file, use the `DeleteFile()` method. This method takes
    one argument: the pathname of the file you want to delete. If the operation is
    successful, the method returns `"SUCCESS"`. Otherwise, it returns `"FAILED"`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除文件，请使用 `DeleteFile()` 方法。该方法接收一个参数：你想删除的文件路径。如果操作成功，方法返回 `"SUCCESS"`。否则，返回
    `"FAILED"`。
- en: '**WARNING**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The deleted file doesn’t go to the recycle bin; instead, it’s completely deleted
    from your system. So be extra careful when you use the* `DeleteFile()` *method!*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*被删除的文件不会进入回收站；相反，它会被完全从系统中删除。所以在使用* `DeleteFile()` *方法时一定要格外小心！*'
- en: Using `CopyFile()` and `DeleteFile()`, you can create your own subroutines for
    moving and renaming files. To move a file to a new location, copy the file to
    the new location and then delete the original file. To rename a file, make a copy
    of the file, give the copy a new name, and then delete the original file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CopyFile()` 和 `DeleteFile()` 方法，你可以创建自己的子程序来移动和重命名文件。要将文件移动到新位置，先将文件复制到新位置，然后删除原始文件。要重命名文件，先复制文件，给副本起个新名字，然后删除原始文件。
- en: '**Creating and Deleting Directories**'
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建和删除目录**'
- en: 'You can easily create or delete a directory. The `CreateDirectory()` method
    takes a single argument: the pathname of the directory you want to create. If
    the directories don’t exist, the method attempts to create all the directories
    in the path, beginning with the root. If the operation is successful, the method
    returns `"SUCCESS"`. Otherwise, it returns `"FAILED"`. Here’s an example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地创建或删除目录。`CreateDirectory()` 方法接收一个参数：你想创建的目录路径。如果目录不存在，方法会尝试创建路径中的所有目录，从根目录开始。如果操作成功，方法返回
    `"SUCCESS"`。否则，返回 `"FAILED"`。以下是一个示例：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the directories *C:\Temp*, *C:\Temp\Temp1*, and *C:\Temp\Temp1\Temp2* don’t
    exist, `CreateDirectory()` creates them. If the directory path already exists,
    the function does nothing and returns `"SUCCESS"`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录 *C:\Temp*、*C:\Temp\Temp1* 和 *C:\Temp\Temp1\Temp2* 不存在，`CreateDirectory()`
    会创建它们。如果目录路径已经存在，函数不会做任何事情，直接返回 `"SUCCESS"`。
- en: 'The `DeleteDirectory()` method also takes a single argument: the pathname of
    the directory you want to delete. All files and folders under the path are deleted.
    If the operation is successful, the method returns `"SUCCESS"`. Otherwise, it
    returns `"FAILED"`. [Figure 19-5](ch19.html#ch19fig5) shows an example of `DeleteDirectory()`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteDirectory()` 方法也接收一个参数：你想删除的目录路径。路径下的所有文件和文件夹都会被删除。如果操作成功，方法返回 `"SUCCESS"`。否则，返回
    `"FAILED"`。[图 19-5](ch19.html#ch19fig5) 显示了 `DeleteDirectory()` 的示例。'
- en: '![image](graphics/f19-05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f19-05.jpg)'
- en: '*Figure 19-5: Demonstrating the* `DeleteDirectory()` *method*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-5：演示* `DeleteDirectory()` *方法*'
- en: '**WARNING**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*When you call* `DeleteDirectory()`, *all the files and folders under the pathname
    are deleted. So make sure you don’t have any files tucked away that you don’t
    want to delete!*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你调用* `DeleteDirectory()`，*路径下的所有文件和文件夹都会被删除。所以请确保你没有不想删除的文件！*'
- en: '**List Files and Directories**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**列出文件和目录**'
- en: The `File` object includes the `GetFiles()` method, which lets you list all
    the files in a directory. This method takes the path of the target directory as
    its argument. The example in [Listing 19-7](ch19.html#ch19ex7) shows you how to
    use this method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 对象包括 `GetFiles()` 方法，允许你列出目录中的所有文件。该方法以目标目录的路径作为参数。示例代码在[示例 19-7](ch19.html#ch19ex7)中展示了如何使用此方法。'
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 19-7: Demonstrating the* `GetFiles()` *method*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 19-7：演示* `GetFiles()` *方法*'
- en: 'Here is the output after running this program (change the `path` variable in
    line 2 to a directory on your computer):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该程序后的输出如下（将第2行中的 `path` 变量更改为你计算机上的一个目录）：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by specifying the path of the directory we want to list (line 2). Next,
    we call `GetFiles()` with the desired path (line 3). This method creates an array
    that contains the pathnames of all the files in the directory; we save the identifier
    of the returned array in `fileArray`. Then we call `GetItemCount()` to find out
    the number of elements in the returned array (line 4) and use a `For` loop to
    display its elements (lines 6–8).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先指定要列出的目录路径（第2行）。接下来，我们调用 `GetFiles()` 方法，并传入所需的路径（第3行）。该方法会创建一个包含目录中所有文件路径的数组；我们将返回数组的标识符保存在
    `fileArray` 中。然后，我们调用 `GetItemCount()` 来查找返回数组中的元素数量（第4行），并使用 `For` 循环来显示它的元素（第6–8行）。
- en: '**NOTE**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If* `GetFiles()` *fails, then* `fileArray` *stores the string* `"FAILED"`*.
    In this case, the call to* `Array.GetItemCount(fileArray)` *returns* `0`*. So
    you might not need to perform an extra check on the return of* `GetFiles()`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果* `GetFiles()` *失败，则* `fileArray` *存储字符串* `"FAILED"`*。在这种情况下，调用* `Array.GetItemCount(fileArray)`
    *将返回* `0`*。因此，你可能不需要对* `GetFiles()` *的返回值执行额外的检查。'
- en: The `GetDirectories()` method lets you list all the subdirectories in a given
    directory. [Listing 19-8](ch19.html#ch19ex8) shows an example of this method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetDirectories()` 方法允许你列出给定目录中的所有子目录。[列表19-8](ch19.html#ch19ex8)展示了该方法的一个示例。'
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 19-8: Demonstrating the* `GetDirectories()` *method*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表19-8：演示* `GetDirectories()` *方法*'
- en: 'Here is the output after running this program:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行该程序后的输出：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But your output will probably look different, depending on what your *Temp*
    directory looks like. This program is similar to [Listing 19-7](ch19.html#ch19ex7).
    We start by storing the path we’re interested in (line 2). Next, we call `GetDirectories()`
    with the path (line 3). This method creates an array that contains the pathnames
    of all the directories in the specified path; we save the identifier of the returned
    array in `dirArray`. Then we call `GetItemCount()` to find out the number of elements
    in the returned array (line 4) and use a `For` loop to display its elements (lines
    6–8). Try changing line 2 to access a different directory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你的输出可能看起来不同，这取决于你的*Temp*目录的内容。这个程序类似于[列表19-7](ch19.html#ch19ex7)。我们首先存储我们感兴趣的路径（第2行）。接下来，我们用该路径调用`GetDirectories()`（第3行）。这个方法创建一个包含指定路径下所有目录路径名的数组；我们将返回数组的标识符保存在`dirArray`中。然后，我们调用`GetItemCount()`来找出返回数组中的元素数量（第4行），并使用`For`循环来显示其元素（第6到第8行）。试着修改第2行，访问不同的目录。
- en: At this point, we’ve covered everything you need to know about the `File` object.
    Let’s put some of this newfound knowledge to work to create some cool applications!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了关于`File`对象的所有内容。让我们将这些新获得的知识付诸实践，创建一些有趣的应用程序！
- en: '**Practical Programs**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实用程序**'
- en: We’ll present two programs intended to highlight different aspects of file I/O
    and give you some ideas and new techniques that you can use in your own creations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示两个程序，旨在突出文件 I/O 的不同方面，并为你提供一些可以应用于自己创作的想法和新技术。
- en: '***The Poet***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***诗人***'
- en: In this example, we’ll modify the Poet program we created in [Chapter 16](ch16.html#ch16)
    so it reads its input from files instead of hardcoding the word lists into the
    program. By doing so, your program will be more awesome and concise, and it will
    be easy to add words to!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将修改我们在[第16章](ch16.html#ch16)创建的诗人程序，使其从文件中读取输入，而不是将单词列表硬编码到程序中。通过这样做，你的程序将变得更加简洁和强大，而且添加单词也会变得更加容易！
- en: 'The program uses five input files: *article.txt*, *adjective.txt*, *noun.txt*,
    *verb.txt*, and *preposition.txt*. The *article.txt* file contains a list of articles
    and qualifiers; the *adjective.txt* file contains a list of adjectives, and so
    on. To take advantage of the way Small Basic handles arrays, each of the five
    files is formatted to make it easy to be read into an array in your program.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用五个输入文件：*article.txt*、*adjective.txt*、*noun.txt*、*verb.txt* 和 *preposition.txt*。*article.txt*
    文件包含冠词和限定词的列表；*adjective.txt* 文件包含形容词的列表，依此类推。为了利用 Small Basic 处理数组的方式，每个文件都经过格式化，便于在程序中读取到数组中。
- en: 'Look at this statement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个语句：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We automatically load the contents of the *article.txt* file into an array named
    `art` that contains the five elements shown in [Figure 19-6](ch19.html#ch19fig6).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*article.txt*文件的内容自动加载到名为`art`的数组中，该数组包含[图19-6](ch19.html#ch19fig6)中显示的五个元素。
- en: '![image](graphics/f19-06.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f19-06.jpg)'
- en: '*Figure 19-6: Reading the contents of* article.txt *into an array named* `art`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-6：将* article.txt *文件的内容读取到名为* `art` *的数组中*'
- en: Open the file *Poet_Incomplete.sb* from this chapter’s folder, which also contains
    the background image and the five input files we’ll need. The file has an empty
    placeholder for the `CreateLists()` subroutine, which you’ll add now. This subroutine
    is shown in [Listing 19-9](ch19.html#ch19ex9).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的 *Poet_Incomplete.sb* 文件，该文件还包含背景图像和我们需要的五个输入文件。该文件中有一个空的占位符，用于存放`CreateLists()`子例程，现在你需要添加它。这个子例程显示在[列表19-9](ch19.html#ch19ex9)中。
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 19-9: The* `CreateLists()` *subroutine*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表19-9：* `CreateLists()` *子例程*'
- en: 'Run this program. It should work the same way as before but with an advantage:
    the user can now change the input files to create their own custom poems.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序，它应该与之前的程序相同，但有一个优势：用户现在可以更改输入文件，创建自己的自定义诗歌。
- en: '***Math Wizard***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数学奇才***'
- en: 'In this example, we’ll create a program featuring a wizard who seems to know
    a lot about math. The wizard isn’t Merlin, Gandalf, or Harry Potter: welcome to
    the world of the Math Wizard! The wizard starts by asking the user to think of
    a *secret* number. He then requests that the user perform some mathematical operations
    on that number (such as doubling the number, subtracting 2, dividing the answer
    by 10, and so on). At the end, the wizard uses his magical powers to tell the
    user the resulting number after performing these operations (although he doesn’t
    know the user’s secret number)!'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个程序，主角是一个似乎对数学了解很多的巫师。这个巫师不是梅林、甘道夫或哈利·波特：欢迎来到数学巫师的世界！巫师首先要求用户想一个*秘密*数字。接着，他请求用户对这个数字进行一些数学操作（例如将数字翻倍、减去
    2、将结果除以 10 等等）。最后，巫师利用他的魔法力量告诉用户经过这些操作后得到的数字（尽管他并不知道用户的秘密数字！）
- en: The idea of the program is very simple. We’ll save each math puzzle in a text
    file that has the format shown in [Figure 19-7](ch19.html#ch19fig7). The first
    line contains the puzzle’s answer, and the remaining lines contain the instructions
    that the wizard asks the user to perform. This program includes 11 puzzles saved
    in *Puzzle01.txt*, *Puzzle02.txt*, *..., Puzzle11.txt*. You can add more puzzles
    by creating additional puzzle files (follow the format shown in [Figure 19-7](ch19.html#ch19fig7)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的思路非常简单。我们将每个数学谜题保存为一个文本文件，文件格式如 [图 19-7](ch19.html#ch19fig7) 所示。第一行包含谜题的答案，剩下的行包含巫师要求用户执行的指令。该程序包含
    11 个谜题，分别保存在 *Puzzle01.txt*、*Puzzle02.txt*、*...* 和 *Puzzle11.txt* 中。你可以通过创建更多的谜题文件来添加新的谜题（遵循
    [图 19-7](ch19.html#ch19fig7) 所示的格式）。
- en: '![image](graphics/f19-07.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f19-07.jpg)'
- en: '*Figure 19-7: The format of a puzzle file*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-7：谜题文件的格式*'
- en: 'The strategy for developing this program is outlined as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 开发此程序的策略概述如下：
- en: When the program starts, we’ll list the files in the program’s directory to
    get the pathnames of the puzzle files.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序启动时，我们将列出程序目录中的文件，以获取谜题文件的路径名。
- en: For each round of the program, we’ll select one of the available puzzles.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每一轮程序，我们将选择一个可用的谜题。
- en: We read the first line of the selected puzzle’s file and interpret it as the
    puzzle’s answer. The remaining lines represent the instructions the wizard displays.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们读取选定谜题文件的第一行，并将其解释为谜题的答案。其余的行代表巫师展示的指令。
- en: The wizard displays the puzzle’s instructions one by one until the program reaches
    an empty line. The wizard asks the user to press ENTER after each instruction.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 巫师一一展示谜题的说明，直到程序遇到空行。每个指令后，巫师要求用户按 ENTER 键。
- en: The wizard displays the puzzle’s answer.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 巫师展示谜题的答案。
- en: Open the *Wizard_Incomplete.sb* file from this chapter’s folder. This file contains
    the program’s main code, shown in [Listing 19-10](ch19.html#ch19ex10), and empty
    placeholders for the `DoPuzzle()` subroutine that you’ll add. The folder also
    contains the text files for the 11 premade puzzles.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的 *Wizard_Incomplete.sb* 文件。此文件包含程序的主要代码，如 [清单 19-10](ch19.html#ch19ex10)
    所示，并且为你将要添加的 `DoPuzzle()` 子程序预留了空白占位符。该文件夹还包含 11 个预制谜题的文本文件。
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 19-10: The main code of the Math Wizard program*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-10：数学巫师程序的主要代码*'
- en: After displaying the program’s title and its instructions (lines 2–6), we call
    `GetFiles()` to get a list of all the files in the program’s directory, and we
    save the identifier of the returned array in the `puzzle` variable (line 8). We
    then start a loop to process the files we found (lines 10–15). In each iteration,
    we get one pathname from the `puzzle` array (line 11) and check whether it has
    a *.txt* extension (line 12). If the file has a *.txt* extension (which means
    it contains a puzzle), we call `DoPuzzle()` to show that puzzle to the user (line
    13). The program ends with a message from the Math Wizard (lines 16–17).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示程序的标题和说明（第 2–6 行）后，我们调用 `GetFiles()` 获取程序目录中所有文件的列表，并将返回的数组标识符保存在 `puzzle`
    变量中（第 8 行）。接着，我们开始一个循环来处理找到的文件（第 10–15 行）。在每次迭代中，我们从 `puzzle` 数组中获取一个路径名（第 11
    行），并检查它是否具有 *.txt* 扩展名（第 12 行）。如果文件具有 *.txt* 扩展名（即它包含一个谜题），我们调用 `DoPuzzle()` 将该谜题展示给用户（第
    13 行）。程序以数学巫师的一条消息结束（第 16–17 行）。
- en: Add the `DoPuzzle()` subroutine shown in [Listing 19-11](ch19.html#ch19ex11)
    to the bottom of the *Wizard_Incomplete.sb* program.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [清单 19-11](ch19.html#ch19ex11) 中所示的 `DoPuzzle()` 子程序添加到 *Wizard_Incomplete.sb*
    程序的底部。
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 19-11: The* `DoPuzzle()` *subroutine*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-11：* `DoPuzzle()` *子程序*'
- en: We read the first line from the file and save it in `puzzleAns` (line 2). Next,
    we set `N` to 2 to read the second line of the file and set the `line` string
    to `"?"` to enter the `While` loop (lines 3–4). In each iteration of the loop,
    we read one line from the puzzle’s file (line 6) and check whether the program
    reached the last instruction. If `line` is not empty (line 7), we display the
    instruction the program just read (line 8) and wait for the user to press any
    key (line 9). When the player presses any key, we increment `N` to read the next
    instruction in the file (line 11). When the program reads an empty line, the `While`
    loop ends, and the program moves to line 14, where we display the puzzle’s answer
    followed by an empty line (lines 14–15).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从文件中读取第一行并将其保存在`puzzleAns`中（第2行）。接下来，我们将`N`设置为2，以读取文件的第二行，并将`line`字符串设置为`"?"`以进入`While`循环（第3–4行）。在循环的每次迭代中，我们从谜题的文件中读取一行（第6行），并检查程序是否已到达最后一条指令。如果`line`不为空（第7行），我们显示程序刚刚读取的指令（第8行），并等待用户按下任意键（第9行）。当玩家按下任意键时，我们将`N`递增，以读取文件中的下一条指令（第11行）。当程序读取到空行时，`While`循环结束，程序跳转到第14行，在那里我们显示谜题的答案，后跟一个空行（第14–15行）。
- en: '[Figure 19-8](ch19.html#ch19fig8) shows a sample run of the program.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 19-8](ch19.html#ch19fig8) 显示了程序的示例运行。'
- en: '![image](graphics/f19-08.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f19-08.jpg)'
- en: '*Figure 19-8: Sample output of the Math Wizard program*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-8：Math Wizard 程序的示例输出*'
- en: '**TRY IT OUT 19-3**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 19-3**'
- en: Think of ways to improve the Math Wizard program, and try to implement them.
    For example, add some colors to make the output look fancier or draw something
    after each puzzle.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 想想如何改进 Math Wizard 程序，并尝试实现它们。例如，添加一些颜色，使输出看起来更花哨，或者在每个谜题后画一些东西。
- en: '**Programming Challenges**'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: If you get stuck, check out *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*
    for the solutions and for more resources and review questions for teachers and
    students.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你卡住了，可以查看 *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*
    获取解决方案以及更多资源和教师和学生的复习题。
- en: 'Let’s write a spelling quiz game using homonyms. Homonyms are words that sound
    the same but have different meanings. Use Notepad to create the following text
    file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用同音词编写一个拼写测验游戏。同音词是发音相同但意思不同的单词。使用记事本创建以下文本文件：
- en: '[PRE23]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each line in this file contains three fields separated by semicolons. The first
    field is the hint you’ll show the player, such as `In your math class`. The second
    field is the two possible answers that your player will choose from, such as `ad/add`.
    The third field is the correct answer, such as `add`.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该文件中的每一行包含三个由分号分隔的字段。第一个字段是你将展示给玩家的提示，例如`In your math class`。第二个字段是玩家将从中选择的两个可能答案，例如`ad/add`。第三个字段是正确答案，例如`add`。
- en: In each round, have the program display the hint and the two possible answers
    to the player, and then wait for them to enter their answer. Have the program
    compare the user’s answer with the correct answer, and then let them know whether
    their answer is correct.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每一轮中，让程序显示提示和两个可能的答案给玩家，然后等待他们输入答案。让程序将用户的答案与正确答案进行比较，然后告知他们答案是否正确。
- en: 'Write a science quiz that tests the student’s knowledge of the animal kingdom.
    First, use Notepad to create the following text file:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试学生动物王国知识的科学测验。首先，使用记事本创建以下文本文件：
- en: '[PRE24]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first line contains the possible classifications. Each of the remaining
    lines contains an animal’s name and its correct classification. Display an animal’s
    name to the player, and then ask them to classify that animal by entering the
    number of the correct class. Then process the player’s answer and let them know
    whether their answer is correct; if their answer is incorrect, display the correct
    classification.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一行包含可能的分类。其余的每一行包含一个动物的名称及其正确的分类。将动物名称显示给玩家，然后要求他们通过输入正确分类的编号来分类该动物。然后处理玩家的答案，并告知他们答案是否正确；如果他们的答案不正确，显示正确的分类。
