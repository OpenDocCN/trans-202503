- en: '**21'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**21**'
- en: SYSTEM PERFORMANCE AND MONITORING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统性能与监控**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Even if “it’s slow!” isn’t the most dreaded phrase a system administrator can
    hear, it’s pretty far up on the list. The user doesn’t know why the system is
    slow and probably can’t even quantify or qualify the problem any further than
    that. It just *feels* slow. Usually there’s no test case, no set of reproducible
    steps, and nothing particularly wrong. A slowness complaint can cause hours of
    work as you dig through the system trying to find problems that might or might
    not even exist.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使“它很慢！”不是系统管理员最害怕听到的话，它也排在列表的前面。用户不知道系统为什么慢，可能连问题到底是如何造成的都无法进一步量化或描述。它就是*感觉*慢。通常没有测试用例，也没有一组可重现的步骤，问题似乎也没什么特别的地方。慢速投诉可能导致几个小时的工作时间，因为你需要在系统中挖掘，寻找可能根本不存在的问题。
- en: 'One phrase is more dreadful still, especially after you’ve invested those hours
    of work: “it’s still slow.”'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有一句话更让人恐惧，尤其是在你已经投入了大量工作时间之后：“它仍然很慢。”
- en: An inexperienced sysadmin accelerates slow systems by buying faster hardware.
    This exchanges “speed problems” for costly parts and even more expensive time.
    Upgrades just let you conceal problems without actually using the hardware you
    already own, and sometimes they don’t even solve the problem at all.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个缺乏经验的系统管理员通过购买更快的硬件来加速慢速系统。这将“速度问题”换成了昂贵的部件和更加昂贵的时间。升级只是让你掩盖问题，而没有真正利用你已经拥有的硬件，有时它们甚至根本无法解决问题。
- en: You can frequently solve performance problems by tweaking the software that’s
    causing the problems. Your WordPress site is slow? Investigate running PHP under
    memcached or another PHP accelerator. FreeBSD is only one layer of your application
    stack, so be sure to give the other layers proper attention.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调整导致问题的软件来解决性能问题。你的网站在WordPress下很慢？可以考虑在memcached或其他PHP加速器下运行PHP。FreeBSD只是你的应用堆栈中的一层，所以一定要对其他层也给予适当关注。
- en: FreeBSD includes many tools designed to help you examine system performance
    and provide the information necessary to learn what’s actually slowing things
    down. Some of them, such as dtrace(1), are highly complicated and require extensive
    knowledge of the system, the software, and a book of their own. Once you understand
    where a problem is, identifying the solution to the problem becomes much simpler.
    You might actually need faster hardware, but sometimes shifting system load or
    reconfiguring software might solve the problem at much less expense. In either
    case, the first step is understanding the problem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD包含了许多旨在帮助你检查系统性能并提供必要信息的工具，帮助你找出真正导致系统变慢的原因。它们中的一些，例如dtrace(1)，非常复杂，要求对系统、软件有深入了解，甚至需要一本专门的书籍。一旦你明白了问题所在，找到问题的解决方案就变得简单多了。你可能确实需要更快的硬件，但有时候调整系统负载或重新配置软件可能会以更低的成本解决问题。在任何情况下，第一步都是理解问题。
- en: '**Computer Resources**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计算机资源**'
- en: Performance problems are usually caused by running more tasks than the computer
    can handle. That seems obvious, but think about it a moment. What does that really
    mean?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题通常是由于运行的任务超过了计算机能够处理的能力。这个看起来很显而易见，但请想一想，这到底意味着什么？
- en: 'A computer has four basic resources: input/output, network bandwidth, memory,
    and CPU. If any one of them is filled to capacity, the others can’t be used to
    their maximum. For example, your CPU might very well be waiting for a disk to
    deliver data or for a network packet to arrive. If you upgrade your CPU to make
    your system faster, you’ll be disappointed. Buying a whole new server might fix
    the problem, but only by expanding the existing bottleneck. The new system probably
    has more memory, faster disks, a better network card, and faster processors than
    the old one. You have deferred the problem until the performance reaches some
    new limit. However, by identifying where your system falls short and addressing
    that particular need, you can stretch your existing hardware much further. After
    all, why purchase a whole new system when a few gigabytes of relatively inexpensive
    memory would fix the problem? (Of course, if your goal is to retire this “slow”
    system to make it your new desktop, that’s another matter.)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一台计算机有四种基本资源：输入/输出、网络带宽、内存和 CPU。如果其中任何一项达到容量限制，其他资源就无法发挥最大效能。例如，你的 CPU 可能在等待磁盘交付数据或等待网络数据包到达。如果你升级
    CPU 以提高系统速度，可能会失望。购买一台全新的服务器或许能解决问题，但只是扩大了现有瓶颈。新系统可能比旧系统有更多内存、更快的磁盘、更好的网络卡和更快的处理器，你只是将问题推迟到性能达到新的极限。然而，通过识别系统中的短板并针对特定需求进行优化，你可以大大提升现有硬件的性能。毕竟，为什么要购买一整套新系统，如果几
    GB 价格相对便宜的内存就能解决问题呢？（当然，如果你的目标是将这台“慢”系统退役并转做新的桌面，那又是另当别论了。）
- en: Input/output is a common bottleneck. System busses have a maximum throughput,
    and while you might not be pushing your disk or your network to their limits,
    you might be saturating the bus by continually bombarding both.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出是一个常见的瓶颈。系统总线有最大吞吐量，虽然你可能没有把磁盘或网络推到极限，但如果不断地同时对它们进行大量操作，你可能会饱和总线。
- en: One common cause of system slowdowns is running multiple large programs simultaneously.
    Not only does disk I/O become saturated, but the processors might spend the majority
    of their time waiting to swap data between the on-CPU cache and the memory. For
    example, I once thoughtlessly scheduled a massive database log rotation that moved
    and compressed gigabytes of data at the same time as the daily periodic(8) run.
    Since the job required shutting down the main database and caused application
    downtime, speed was crucial. Both the database job and the periodic(8) run slowed
    unbearably. Rescheduling one of them made both jobs go more quickly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 系统变慢的一个常见原因是同时运行多个大型程序。磁盘 I/O 不仅会被饱和，处理器可能会花费大部分时间等待在 CPU 缓存和内存之间交换数据。例如，我曾经不小心安排了一个庞大的数据库日志轮换任务，同时移动和压缩几
    GB 的数据，并且与每日的 periodic(8) 任务重叠。由于这个任务需要关闭主数据库并导致应用程序停机，速度变得至关重要。数据库任务和 periodic(8)
    任务都变得无法忍受地慢。重新调度其中一个任务，使得两个任务都能更快速地完成。
- en: FreeBSD has some features that improve performance. Doing lots of cryptographic
    operations? Use the aesni(4) kernel module. Database is disk bound? Consider the
    filesystem block size. ZFS pool slow? Maybe you need an add-on cache. Identifying
    what you should change requires a hard look at the system, however.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 有一些可以提高性能的特性。如果你需要进行大量的加密操作，可以使用 aesni(4) 内核模块。数据库受限于磁盘性能？考虑文件系统的块大小。ZFS
    池速度慢？也许你需要一个附加缓存。然而，确定应该更改什么需要对系统进行仔细的检查。
- en: We’re going to look at several FreeBSD tools for examining system performance.
    Armed with that information, we’ll consider how to fix performance issues. Each
    potential bottleneck can be evaluated with the proper tools. FreeBSD changes continually,
    so later systems might have new tuning options and performance features. Read
    tuning(7) on your system for current performance tips.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍几个 FreeBSD 工具，用于检查系统性能。掌握这些信息后，我们将考虑如何解决性能问题。每个潜在的瓶颈都可以通过合适的工具进行评估。FreeBSD
    不断变化，因此较新的系统可能会有新的调优选项和性能特性。请查阅系统中的 tuning(7) 手册，了解当前的性能优化建议。
- en: '**WHAT IS NORMAL?**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是正常的？**'
- en: One word you’ll keep tripping over in this chapter is *abnormal*. As the sysadmin,
    you’re supposed to know what’s normal for your system. It’s somewhat like art;
    you might not be able to define *normal*, but you need to recognize *abnormal*
    when you see it. Use these tools regularly when the system is behaving itself
    so you can have a good idea of which results are out of whack during system slowdowns.
    Pay attention to your hardware!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你会不断碰到一个词：*异常*。作为系统管理员，你应该了解你的系统的正常状态。它有点像艺术；你可能无法定义*正常*，但你需要在看到*异常*时能够识别它。经常使用这些工具，当系统运行正常时，你就能对系统减速时的异常结果有一个良好的认识。注意你的硬件！
- en: '**Checking the Network**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**检查网络**'
- en: If you’re concerned about network performance, measure it. Consult `net``stat`
    `-m` and `netstat -s`, and look for errors or places where you’re out of memory
    or buffers. These are instantaneous snapshots, but for the network, you really
    need to evaluate congestion and latency over minutes, hours, and even days. The
    network team probably has a tool like Cacti, Zabbix, or Graphite to observe long-term
    performance.^([1](footnote.xhtml#ch21fn1)) Ask them for information. Combine what
    these tools provide with your instantaneous snapshots. If the average throughput
    per minute on your 10-gig Ethernet is only 5 gigabit a second, but your instantaneous
    measurements show frequent spikes up to the full 10 gigabit, you probably have
    really bursty connectivity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心网络性能，测量它。查阅`net``stat` `-m`和`netstat -s`，查看是否有错误或内存或缓冲区不足的地方。这些是瞬时快照，但对于网络，你实际上需要评估几分钟、几小时甚至几天的拥塞和延迟。网络团队可能有像Cacti、Zabbix或Graphite这样的工具来观察长期性能。^([1](footnote.xhtml#ch21fn1))向他们索取信息。将这些工具提供的数据与瞬时快照结合起来。如果你10吉比特以太网的每分钟平均吞吐量只有5吉比特每秒，但你的瞬时测量显示频繁的峰值达到满载的10吉比特，你可能面临非常突发的连接问题。
- en: Some network cards can better handle a full network in *polling mode*. Polling
    tells the network card to stop sending frames up to the operating system as they
    arrive and instead let the operating system visit every so often to collect the
    frames. Check your network card’s man page to see whether it supports polling.
    Enable and disable polling with ifconfig(8).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网卡在*轮询模式*下可以更好地处理满负载网络。轮询指示网卡停止将帧发送到操作系统，而是让操作系统定期访问收集这些帧。查阅网卡的手册页，查看它是否支持轮询。使用ifconfig(8)启用和禁用轮询。
- en: A heavily loaded network might benefit from a different congestion control algorithm.
    FreeBSD provides several TCP congestion control algorithms. Look for files beginning
    with *cc_* in */boot/kernel*; these are congestion control modules. Each has a
    man page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网络负载较重时，可能需要使用不同的拥塞控制算法。FreeBSD提供了几种TCP拥塞控制算法。查找以*cc_*开头的文件，它们位于*/boot/kernel*目录中；这些是拥塞控制模块，每个模块都有一个手册页。
- en: View the currently loaded congestion control algorithms with the sysctl `net.inet.tcp.cc.available`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用sysctl `net.inet.tcp.cc.available`查看当前加载的拥塞控制算法。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: New Reno is the traditional congestion control algorithm. The congestion control
    kernel modules on this system include CDG, CHD, CUBIC, DCTCP, HD, H-TCP, and Vegas.
    The H-TCP algorithm is specifically designed for long-distance, high-bandwidth
    applications. Let’s enable it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Reno是传统的拥塞控制算法。该系统上的拥塞控制内核模块包括CDG、CHD、CUBIC、DCTCP、HD、H-TCP和Vegas。H-TCP算法专为长距离、高带宽应用设计。让我们启用它。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We now have H-TCP available in the kernel. Enable it with the `net.inet.tcp.cc.algorithm`
    sysctl.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在内核中可以使用H-TCP。通过`net.inet.tcp.cc.algorithm` sysctl来启用它。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ultimately, you can’t fit 10 pounds of bandwidth in a 5-pound circuit. If your
    saturated Ethernet is crippling your applications, turn off unnecessary network
    services or add more bandwidth.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你无法将10磅带宽放入一个5磅的电路中。如果你的饱和以太网正在拖慢应用程序的速度，关闭不必要的网络服务或增加更多带宽。
- en: Other system conditions are much more complicated. Start by checking where the
    problem lies with vmstat(8).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其他系统条件则要复杂得多。首先通过vmstat(8)检查问题所在。
- en: '**General Bottleneck Analysis with vmstat(8)**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用vmstat(8)进行一般瓶颈分析**'
- en: FreeBSD includes several programs for examining system performance. Among these
    are vmstat(8), iostat(8), and systat(1). We’ll discuss vmstat(8) because I find
    it most helpful; iostat(8) is similar to vmstat(8), and systat(1) provides the
    same information in an ASCII graphical format.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD包含多个用于检查系统性能的程序。其中包括vmstat(8)、iostat(8)和systat(1)。我们将讨论vmstat(8)，因为我发现它最有用；iostat(8)与vmstat(8)相似，而systat(1)则以ASCII图形格式提供相同的信息。
- en: Use vmstat(8) to see the system’s current virtual memory statistics. While the
    output takes getting used to, vmstat(8) is very good at showing large amounts
    of data in a small space. Type vmstat at the command prompt and follow along.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用vmstat(8)查看系统当前的虚拟内存统计数据。虽然输出结果需要一些时间来适应，但vmstat(8)非常适合在小空间内展示大量数据。你可以在命令行输入vmstat并跟随进行。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The vmstat divides its display into six sections: process (`procs`), `memory`,
    paging (`page`), `disks`, `faults`, and `cpu`. We’ll look at all of them quickly
    and then discuss in detail those parts that are the most important for investigating
    performance issues. This single line represents the average values for the whole
    time the system has been running. We’ll get more real-time data in the next section.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: vmstat将显示分为六个部分：进程（`procs`）、`memory`、分页（`page`）、磁盘（`disks`）、故障（`faults`）和CPU（`cpu`）。我们将快速浏览一下这些部分，然后详细讨论对于调查性能问题最重要的部分。这一行代表系统运行期间的平均值。在接下来的部分，我们会获取更多实时数据。
- en: '***Processes***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***进程***'
- en: vmstat(8) has three columns under the `procs` heading. Technically, vmstat counts
    threads rather than processes. Unthreaded applications have one thread per process,
    but your multithreaded application could have far, far more.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: vmstat(8)在`procs`标题下有三列。严格来说，vmstat统计的是线程而不是进程。没有线程的应用程序每个进程有一个线程，但你的多线程应用程序可能会有更多的线程。
- en: r The number of runnable threads that are waiting for CPU time, including all
    running processes. One thread per CPU is fine; it means your hardware is fully
    utilized. More than that means your CPU is a bottleneck. Some programs demand
    all the processor the host has and more, though; check that you’re not running
    such a remorseless compute suck.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: r 正在等待CPU时间的可运行线程数，包括所有运行中的进程。每个CPU一个线程是正常的，这意味着你的硬件得到了充分利用。如果超过这个数量，说明CPU成了瓶颈。不过，有些程序会要求主机的处理器全部投入，甚至更多；检查一下是否有这样的“计算黑洞”程序在运行。
- en: b The number of threads that are blocked waiting for system input or output—generally,
    waiting for disk access. These threads will run as soon as they get their data.
    If this number is high, your disk is the bottleneck.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: b 正在等待系统输入或输出的阻塞线程数——通常是等待磁盘访问的线程。这些线程会在获取到数据后运行。如果这个数字很高，说明磁盘是瓶颈。
- en: w The number of threads that are runnable but are entirely swapped out. If you
    regularly have processes swapped out, the system’s memory is inadequate for the
    host’s workload.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: w 可运行但完全交换出的线程数。如果你经常有进程被交换出去，说明系统的内存无法满足主机的工作负载。
- en: This host has averaged eight runnable threads since boot, but zero waiting on
    I/O or memory. If you’re getting complaints that this host is slow, the first
    place to check is processor utilization. Is someone, say, building FreeBSD from
    source just to generate interesting output for a book’s performance chapter, while
    real people are attempting to do their jobs on the same system?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这台主机自启动以来平均有8个可运行线程，但没有等待I/O或内存。如果你收到该主机运行缓慢的抱怨，首先需要检查的就是处理器的利用率。是否有某个人在编译FreeBSD源代码，以生成书中性能章节的有趣输出，而真实用户却在同一系统上做着工作？
- en: '***Memory***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存***'
- en: FreeBSD breaks memory up into uniform-sized chunks called *pages*. When a program
    requests memory, it gets assigned a number of pages. The size of a page is hardware-
    and OS-dependent but appears in the `hw.pagesize` sysctl. On FreeBSD’s i386 and
    amd64 platforms, a page is 4KB. The system treats each page as a whole—if FreeBSD
    must shift memory into swap, for example, it does that on a page-by-page basis.
    The kernel thread that manages memory is called the *pagedaemon*. The `memory`
    section has two columns.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD将内存分成大小均匀的块，称为*页面*。当程序请求内存时，会分配若干页面。页面的大小依赖于硬件和操作系统，但可以在`hw.pagesize`的sysctl中查看。在FreeBSD的i386和amd64平台上，页面大小是4KB。系统将每个页面视为一个整体——例如，如果FreeBSD必须将内存换出，它会按页面逐一进行。管理内存的内核线程被称为*分页守护进程*。`memory`部分有两列。
- en: avm The average number of pages of virtual memory that are in use. If this value
    is abnormally high or increasing, your system is actively consuming swap space.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: avm 正在使用的虚拟内存页面的平均数。如果这个值异常高或正在增加，说明系统正在积极消耗交换空间。
- en: fre The number of memory pages available for use. If this value is abnormally
    low, you have a memory shortage.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: fre 可供使用的内存页面数。如果这个值异常低，说明你的系统内存不足。
- en: Our sample output is using 1.3GB of RAM and has 26GB free. Memory isn’t an issue.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例输出使用了1.3GB的RAM，剩余26GB可用。内存不是问题。
- en: '***Paging***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分页***'
- en: The `page` section shows how hard the virtual memory system is working. The
    inner workings of the virtual memory system are an arcane science that I won’t
    describe in detail here.^([2](footnote.xhtml#ch21fn2))
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`page` 部分显示了虚拟内存系统的工作负载。虚拟内存系统的内部工作原理是一门晦涩的学问，我在这里不会详细描述。^([2](footnote.xhtml#ch21fn2))'
- en: flt The number of page faults, where information needed wasn’t in real memory
    and had to be fetched from swap space or disk.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: flt 页面故障的数量，其中需要的信息不在真实内存中，必须从交换空间或磁盘中获取。
- en: re The number of pages that have been reclaimed or reused from cache.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: re 从缓存中回收或重用的页面数量。
- en: pi Short for *pages in*; this is the number of pages being moved from real memory
    to swap.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: pi 缩写自 *pages in*；表示从真实内存移动到交换区的页面数量。
- en: po Short for *pages out*; this is the number of pages being moved from swap
    to real memory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: po 缩写自 *pages out*；表示从交换区移动到真实内存的页面数量。
- en: fr How many pages are freed per second.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: fr 每秒释放的页面数量。
- en: sr How many pages are scanned per second.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: sr 每秒扫描的页面数量。
- en: Moving memory into swap isn’t bad, but consistently recovering paged-out memory
    indicates a memory shortage. Having high `fr` and `flt` values can indicate lots
    of short-lived processes—for example, a script that starts many other processes
    or a cron job scheduled too frequently. Or perhaps someone’s been running `make
    -j16 buildworld`. A high `sr` probably means you don’t have enough memory, as
    the pagedaemon is constantly trying to free memory. The paging daemon normally
    runs once a minute or so, but a high `sr` count means you’re probably trying to
    do more work than your RAM can hold.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存移入交换区并不坏，但如果不断地恢复已分页的内存，则表明存在内存不足的情况。高 `fr` 和 `flt` 值可能意味着有大量短命的进程——例如，启动许多其他进程的脚本，或者调度过于频繁的
    cron 作业。或者可能是有人在运行 `make -j16 buildworld`。高 `sr` 值可能意味着你的内存不足，因为分页守护进程不断尝试释放内存。分页守护进程通常每分钟运行一次，但高
    `sr` 值表示你可能正在尝试做的工作超出了你的 RAM 能承载的范围。
- en: '***Disks***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***磁盘***'
- en: The `disks` section shows each of your disks by device name. The number shown
    is the number of disk operations per second, a valuable clue to determining how
    well your disks are handling their load. You should divide your disk operations
    between different disks whenever possible and arrange them on different buses
    when you can. If one disk is obviously busier than the others, and the system
    has operations waiting for disk access, consider moving some frequently accessed
    files from one disk to another. One common cause of high disk load is a coredumping
    program that can restart itself. For example, a faulty CGI script that dumps core
    every time someone clicks on a link will greatly increase your disk load.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`disks` 部分显示每个磁盘的设备名称。显示的数字是每秒磁盘操作次数，这是判断磁盘负载情况的有价值线索。你应该尽可能将磁盘操作分配到不同的磁盘上，并在可能的情况下将它们安排到不同的总线上。如果某个磁盘显然比其他磁盘忙，并且系统有等待磁盘访问的操作，考虑将一些频繁访问的文件从一个磁盘移动到另一个磁盘。磁盘负载高的一个常见原因是会自我重启的核心转储程序。例如，每当有人点击链接时就会转储核心的故障
    CGI 脚本会大大增加磁盘负载。'
- en: If you have a lot of disks, you might notice that they don’t all appear on the
    vmstat display. Designed for an 80-column display, vmstat(8) can’t list every
    disk on a large system. If, however, you have a wider display and don’t mind exceeding
    the 80-column limit, use the `-n` flag to set the number of drives you want to
    display.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多磁盘，可能会发现它们并不都出现在 vmstat 显示中。由于设计时考虑了 80 列显示，vmstat(8) 无法列出大型系统中的所有磁盘。不过，如果你有更宽的显示器，并且不介意超过
    80 列的限制，可以使用 `-n` 标志来设置你希望显示的磁盘数量。
- en: '***Faults***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***故障***'
- en: Faults aren’t inherently bad; they’re just received system traps and interrupts.
    An abnormally large number of faults is bad, of course—but before you tackle this
    problem, you need to know what’s normal for your system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 故障本身并不坏；它们只是系统收到的陷阱和中断。当然，异常大量的故障是坏的——但在解决这个问题之前，你需要了解什么是你系统的正常情况。
- en: The first line of vmstat output shows the average faults per second since system
    boot.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: vmstat 输出的第一行显示自系统启动以来的平均故障数每秒。
- en: in The number of system interrupts (IRQ requests) received
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: in 接收到的系统中断（IRQ 请求）的数量。
- en: sy The number of system calls
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: sy 系统调用的数量。
- en: cs The number of context switches in the last second, or a per-second average
    since the last update. (For example, if you have vmstat update its display every
    five seconds, this column displays the average number of context switches per
    second over the last five seconds.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: cs 是上秒的上下文切换次数，或者自上次更新以来的每秒平均值。（例如，如果你让 vmstat 每五秒更新一次显示，这一列就会显示过去五秒钟内每秒的上下文切换平均数。）
- en: This host has averages 12 system calls and 212 context switches per second since
    boot. How does that compare to what you saw when the system was working normally?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该主机自启动以来，每秒平均执行 12 次系统调用和 212 次上下文切换。与系统正常工作时看到的数据相比如何？
- en: '***CPU***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***CPU***'
- en: Finally, the `cpu` section shows how much time the system spent doing user tasks
    (`us`), system tasks (`sy`), and how much time it spent idle (`id`). top(1) presents
    this same information in a friendlier format, but only for the current time, whereas
    vmstat lets you view system utilization over time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`cpu` 部分显示了系统在执行用户任务（`us`）、系统任务（`sy`）以及空闲时间（`id`）的花费时间。top(1) 以更友好的格式呈现这些相同的信息，但仅显示当前时刻的数据，而
    vmstat 允许你查看系统利用率的变化情况。
- en: '***Using vmstat***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 vmstat***'
- en: So, how do you use all this information? Start by checking the first three columns
    to see what the system is waiting for. If you’re waiting for CPU access (the `r`
    column), then you’re short on CPU horsepower. If you’re waiting for disk access
    (the `b` column), then your disks are the bottleneck. If you’re swapping (the
    `w` column), you’re short on memory. Use the other columns to explore these three
    types of shortages in more detail.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何利用这些信息呢？首先检查前三列，看看系统在等待什么。如果你正在等待 CPU 访问（`r` 列），那说明你的 CPU 性能不足。如果你在等待磁盘访问（`b`
    列），那说明你的磁盘成为了瓶颈。如果你在交换（`w` 列），说明你的内存不足。使用其他列来更详细地探讨这三种资源短缺情况。
- en: '***Continuous vmstat***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***持续 vmstat***'
- en: 'You’re probably more interested in what’s happening over time, rather than
    in a brief snapshot of system performance. Use the `-w` flag and a number to run
    it as an ongoing display updating every so many seconds. FreeBSD shows average
    values since the last update, updating counters continuously:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更关心的是随时间变化的系统情况，而不是简短的系统性能快照。使用 `-w` 标志和数字来以持续更新的方式运行它，每隔一定秒数更新一次。FreeBSD
    会显示自上次更新以来的平均值，持续更新计数器：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line still shows the averages since boot. Every five seconds, however,
    an updated line appears at the end. You can sit there and watch how your system’s
    performance changes when scheduled jobs kick off or when you start particular
    programs. Hit CTRL-C when you’re done. In this example, processes are always waiting
    for CPU time (as shown by the stack of `8`s in the `r` column), and we frequently
    have something waiting for disk access.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行仍然显示自启动以来的平均值。然而，每五秒钟，系统会在末尾更新一行。你可以坐在那里观看系统性能如何随着计划任务的启动或特定程序的运行而变化。完成后按
    CTRL-C 停止。在这个例子中，进程总是在等待 CPU 时间（如 `r` 列中一堆 `8` 所示），并且我们经常会看到等待磁盘访问的情况。
- en: An occasional wait for a system resource doesn’t mean you must upgrade your
    hardware; if performance is acceptable, don’t worry about it. Otherwise, however,
    you must look further. The most common culprit is the storage system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔等待系统资源并不意味着你必须升级硬件；如果性能是可以接受的，就不用担心。但如果不行，必须进一步检查。最常见的原因是存储系统。
- en: '**Disk I/O**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**磁盘 I/O**'
- en: Disk speed is a common performance bottleneck, especially with spinning disks,
    but even flash-based storage can get slow. Programs that must repeatedly wait
    for disk activity to complete run more slowly. This is commonly called *blocking
    on disk*, meaning that the disk is preventing program activity. The only real
    solution for this is to use faster disks, install more disks, or reschedule the
    load.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘速度是常见的性能瓶颈，尤其是旋转磁盘，但即便是基于闪存的存储也可能变慢。必须反复等待磁盘活动完成的程序运行会变得更慢。这通常被称为*磁盘阻塞*，意味着磁盘在阻止程序的活动。解决这个问题的唯一方法是使用更快的磁盘、安装更多的磁盘，或者重新调度负载。
- en: While FreeBSD provides several tools to check disk activity, my favorite is
    gstat(8), so we’ll use that. You can run `gstat` without arguments for a display
    of all of your disks and partitions that updates every second or so. If you have
    many disks this can generate a whole bunch of zeros, though. I always use the
    `-a` flag, so that gstat(8) displays only disks with activity. The `-p` flag is
    also useful, to view entire disks, but I prefer a per-partition view.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FreeBSD 提供了多种工具来检查磁盘活动，但我最喜欢的是 gstat(8)，所以我们将使用这个工具。你可以运行 `gstat` 不带任何参数，以显示所有磁盘和分区的状态，更新频率大约每秒一次。如果你的磁盘较多，这可能会显示一大堆零。我总是使用
    `-a` 标志，这样 gstat(8) 只会显示有活动的磁盘。`-p` 标志也很有用，可以查看整个磁盘，但我更喜欢按分区查看。
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We get a line for each disk device, slice, and partition, and various information
    for each. gstat(8) shows all sorts of good stuff, such as the number of reads
    per second (`r/s`), writes per second (`w/s`), the kilobytes per second of reading
    and writing, as well as a friendly-looking `%busy` column.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个磁盘设备、切片和分区获取一行信息，并为每个设备显示各种信息。gstat(8)展示了各种有用的内容，如每秒读取次数（`r/s`）、每秒写入次数（`w/s`）、每秒读取和写入的千字节数，以及一个友好的`%busy`列。
- en: Ignore most of these. Some of these, such as the percent busy column, use sloppy
    measuring methods. The FreeBSD developers chose disk performance over accuracy
    of statistical measurements. What does matter, however, are the ms/r (milliseconds
    per read) ➊ and ms/w (milliseconds per write) ➋. These numbers are accurate. Measure
    and monitor them. If one disk has really high activity, but another is idle, consider
    dividing what’s on that disk between multiple disks or using striped storage.
    Or, if it’s your laptop, consider accepting that this is as fast as your storage
    system gets.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略这些大部分内容。有些内容，比如忙碌百分比列，采用了不太准确的测量方法。FreeBSD 开发人员选择了磁盘性能，而不是统计测量的精确度。然而，真正重要的是
    ms/r（每次读取的毫秒数）➊ 和 ms/w（每次写入的毫秒数）➋。这些数字是准确的。请测量并监控它们。如果一个磁盘的活动非常高，而另一个处于空闲状态，可以考虑将磁盘上的数据分散到多个磁盘上，或者使用条带化存储。或者，如果是你的笔记本电脑，可能需要接受这就是你存储系统的最大速度。
- en: Once you identify the scarce system resource, you need to figure out what program’s
    draining that resource. We’ll need other tools for that.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了稀缺的系统资源，你需要找出哪个程序正在消耗这些资源。我们将需要其他工具来帮助诊断。
- en: '**CPU, Memory, and I/O with top(1)**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**CPU、内存和 I/O 使用 top(1)**'
- en: The top(1) tool provides a decent overview of system status, displaying information
    about CPU, memory, and disk usage. Just type `top` to get a full-screen display
    of system performance data. The display updates every two seconds, so you have
    a close to real-time system view. Even if you update the update interval to one
    second, you can still miss short-lived, resource-sucking processes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: top(1) 工具提供了一个系统状态的良好概览，显示了有关 CPU、内存和磁盘使用的信息。只需输入 `top`，即可获得系统性能数据的全屏显示。该显示每两秒更新一次，因此你可以获得接近实时的系统视图。即使你将更新间隔设置为一秒，你也可能错过一些短暂的、高资源消耗的进程。
- en: The output of top(1) is split into two halves. The upper portion gives basic
    system information, while the bottom gives per-process data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: top(1) 的输出分为上下两部分。上半部分提供基本的系统信息，而下半部分提供每个进程的数据。
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Very tightly packed, isn’t it? The top(1) tool crams as much data as possible
    into a standard 80 × 25 terminal window or X terminal. Let’s take this apart and
    learn how to read it. We’ll start with the upper part, which can look a little
    different depending on whether you’re using UFS or ZFS.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 非常紧凑，对吧？top(1) 工具将尽可能多的数据塞入一个标准的 80 × 25 终端窗口或 X 终端。我们来拆解它，学习如何阅读。我们从上半部分开始，这部分内容在使用
    UFS 或 ZFS 时可能会有所不同。
- en: '***UFS and top(1)***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***UFS 和 top(1)***'
- en: The per-host information at in the upper part of top(1) varies slightly between
    ZFS and UFS hosts, but we’ll start with UFS and then explain the differences.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: top(1) 的主机信息在 ZFS 和 UFS 主机之间稍有不同，但我们将从 UFS 开始，然后解释它们的差异。
- en: '**PID Values**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**PID 值**'
- en: Every process on a Unix machine has a unique process ID (PID). Whenever a new
    process starts, the kernel assigns it a PID one greater than the previous process.
    The last PID value is the last process ID assigned by the system. In the previous
    example, our last PID is 84,111 ➊. The next process created will be 84,112, then
    84,113, and so on. Watch this number to see how fast the system changes. If the
    system is running through PIDs more quickly than usual, it might indicate a process
    forking beyond control or something crashing and restarting.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Unix 系统上的进程都有一个唯一的进程 ID（PID）。每当一个新进程启动时，内核会为它分配一个比前一个进程 PID 大一的值。最后的 PID
    值是系统分配的最后一个进程 ID。在前面的示例中，我们的最后一个 PID 是 84,111 ➊。下一个创建的进程将是 84,112，然后是 84,113，依此类推。观察这个数字可以了解系统变化的速度。如果系统以比平常更快的速度分配
    PID，可能表示某个进程的分叉失控，或者有某个进程崩溃并重新启动。
- en: '**Load Average**'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**负载平均值**'
- en: The *load average* ➋ is a somewhat vague number that offers a rough impression
    of the amount of CPU load on the system. The load average is the average number
    of threads waiting for CPU time. (Other operating systems have different load
    average calculation methods.) An acceptable load average depends on your system.
    If the numbers are abnormally high, you need to investigate. Some hosts feel bogged
    down at a load average of 3, while some modern systems are still snappy with what
    look like ridiculously high load averages. Again, what’s normal for *this* host?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*负载平均值* ➋ 是一个相对模糊的数字，它提供了系统 CPU 负载的大致情况。负载平均值是等待 CPU 时间的线程的平均数量。（其他操作系统可能有不同的负载平均值计算方法。）一个可接受的负载平均值取决于你的系统。如果数字异常偏高，您需要调查一下。某些主机在负载平均值为
    3 时可能会感到滞后，而某些现代系统即使负载平均值看起来非常高，仍然运行得很流畅。再说一次，*这个*主机的正常负载是多少？'
- en: You’ll see three load averages. The first (0.09 here) is the load average over
    the last minute, the second (0.21) is for the last five minutes, and the last
    (0.20) is for the last 15 minutes. If your 15-minute load average is high, but
    the 1-minute average is low, you had a major activity spike that has since subsided.
    On the other hand, if the 15-minute value is low but the 1-minute average is high,
    something happened within the last 60 seconds and might still be going on now.
    If all of the load averages are high, the condition has persisted for at least
    15 minutes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到三个负载平均值。第一个（这里是 0.09）表示过去一分钟的负载平均值，第二个（0.21）表示过去五分钟的负载，最后一个（0.20）表示过去十五分钟的负载。如果你的十五分钟负载平均值很高，但一分钟负载平均值很低，说明你有一次重要的活动峰值，之后已经平息。另一方面，如果十五分钟负载低，但一分钟负载很高，说明在过去的
    60 秒内发生了某些事情，可能仍在继续。如果所有负载平均值都很高，说明这种情况已经持续了至少 15 分钟。
- en: '**Uptime**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行时间**'
- en: The last entry on the first line is the *uptime* ➌, or how long the system has
    been running. This system has been running for 7 days, 7 hours, and 58 minutes,
    and the current time is 14:41:09\. I’ll leave it up to you to calculate what time
    I booted this system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的最后一项是 *运行时间* ➌，即系统已运行的时间。此系统已运行了 7 天、7 小时和 58 分钟，当前时间是 14:41:09。计算系统启动的时间就留给你了。
- en: '**Process Counts**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**进程计数**'
- en: On the second line, you’ll find information about the processes currently running
    on the system ➍. Running processes are actually doing work—they’re answering user
    requests, processing mail, or doing whatever your system does. Sleeping processes
    are waiting for input from one source or another; they’re just fine. You should
    expect a fairly large number of sleeping processes at any time. Processes in other
    states are usually waiting for a resource to become available or are hung in some
    way. Large numbers of nonsleeping, nonrunning processes hint at trouble. The ps(1)
    command can show the state of all processes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，你将看到关于系统当前正在运行的进程的信息 ➍。正在运行的进程实际上在执行任务——它们在响应用户请求、处理邮件，或者执行你的系统所需的其他操作。处于休眠状态的进程则在等待某个来源的输入；它们没问题。你应该预期任何时候都会有相当数量的休眠进程。处于其他状态的进程通常是在等待某个资源的可用，或者以某种方式挂起。大量非休眠、非运行的进程可能表示系统出现了问题。ps(1)
    命令可以显示所有进程的状态。
- en: '**Process Types**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**进程类型**'
- en: 'The `CPU states` line ➎ indicates what percentage of available CPU time the
    system spends handling different types of processes. It shows five different process
    types: `user`, `nice`, `system`, `interrupt`, and `idle`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`CPU 状态` 行 ➎ 显示了系统在处理不同类型的进程时所花费的 CPU 时间百分比。它显示了五种不同的进程类型：`用户`、`nice`、`系统`、`中断`
    和 `空闲`。'
- en: The `user` processes are average everyday programs—perhaps daemons run by root,
    or commands run by regular users, or whatever. If it shows up in `ps -ax`, it’s
    a user process.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`user`进程是普通的日常程序——可能是由root运行的守护进程，或者是普通用户运行的命令，等等。如果它出现在`ps -ax`中，它就是一个用户进程。'
- en: The `nice` processes are user processes whose priority has been deliberately
    manipulated. We’ll look at this in detail in “[Reprioritizing with Niceness](ch21.xhtml#lev977)”
    on [page 543](ch21.xhtml#page_543).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`nice`进程是优先级被故意调整的用户进程。我们将在《[使用Niceness重新调整优先级](ch21.xhtml#lev977)》的[第543页](ch21.xhtml#page_543)详细讨论这一点。'
- en: The `system` value gives the total percentage of CPU time spent by FreeBSD running
    kernel processes and the userland processes in the kernel. These include things
    such as virtual memory handling, networking, writing to disk, debugging with INVARIANTS
    and WITNESS, and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`system`值显示FreeBSD用于运行内核进程和内核中的用户进程所花费的CPU时间百分比。这些包括虚拟内存处理、网络、写入磁盘、使用INVARIANTS和WITNESS进行调试等。'
- en: The `interrupt` value shows how much time the system spends handling interrupt
    requests (IRQs).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`interrupt`值显示系统处理中断请求（IRQ）所花费的时间。'
- en: Last, the `idle` entry shows how much time the system spends doing nothing.
    If your CPU regularly has a very low idle time, you might want to think about
    rescheduling jobs or getting a faster processor.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`idle`项显示系统处于空闲状态的时间。如果你的CPU经常出现非常低的空闲时间，可能需要考虑重新调度任务或更换更快的处理器。
- en: '**TOP AND SMP**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**TOP和SMP**'
- en: On an SMP system, top(1) displays the average use among all the processors.
    You might have one processor completely tied up compiling something, but if the
    other processor is idle, top(1) shows the CPU usage of only 50 percent. Use the
    `-p` flag to view per-CPU stats.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在SMP系统中，top(1)显示所有处理器的平均使用情况。你可能有一个处理器完全占用在编译某个东西，但如果另一个处理器处于空闲状态，top(1)显示的CPU使用率可能只有50%。使用`-p`标志查看每个CPU的统计信息。
- en: '**Memory**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内存**'
- en: The `Mem` line ➏ represents the usage of physical RAM. FreeBSD breaks memory
    usage into several different categories.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mem`行➏表示物理RAM的使用情况。FreeBSD将内存使用分为多个不同的类别。'
- en: '*Active memory* is the total amount of memory in use by user processes. When
    a program ends, the memory it had used is placed into *inactive memory*. If the
    system runs this program again, it can retrieve the software from memory instead
    of disk.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*活动内存*是用户进程正在使用的内存总量。当一个程序结束时，它所使用的内存会被放入*非活动内存*中。如果系统再次运行这个程序，它可以从内存中检索软件，而不是从磁盘加载。'
- en: '*Free memory* is totally unused. It might be memory that has never been accessed,
    or it might be memory released by a process. This system has 17MB of free RAM.
    If you have a server that’s been up for months, and it still has free memory,
    you might consider putting some of that RAM in a machine that’s hurting for memory.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*空闲内存*完全未被使用。它可能是从未被访问的内存，也可能是某个进程释放的内存。该系统有17MB的空闲RAM。如果你的服务器已经运行了几个月，仍然有空闲内存，你可以考虑将一些RAM转移到内存不足的机器上。'
- en: Memory in the *Laundry* is queued to be synchronized with other storage, such
    as disk.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*洗衣*中的内存排队等待与其他存储同步，如磁盘。'
- en: FreeBSD 11 shuffles memory between the inactive, laundry, and free categories
    as needed to maintain a pool of available memory. Memory in the inactive is most
    easily transferred to the free pool. When cache memory gets low and FreeBSD needs
    still more free memory, it picks pages from the inactive pool, verifies that it
    can use them as free memory, and moves them to the free pool. FreeBSD tries to
    keep the total number of free pages above the sysctl `vm.v_free_target`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 11根据需要在非活动、洗衣和空闲类别之间调度内存，以维持可用内存池。非活动内存最容易转移到空闲池。当缓存内存不足且FreeBSD仍然需要更多空闲内存时，它会从非活动池中选择页面，验证是否可以将其用作空闲内存，然后将其移入空闲池。FreeBSD尽量保持空闲页面的总数高于sysctl
    `vm.v_free_target`。
- en: FreeBSD 12 has no cache and handles low memory situations a little differently.
    When free memory gets low, the pagedaemon picks pages from the inactive pool.
    If that inactive page needs to be synced to disk, it’s placed on the laundry queue,
    and the pagedaemon tries another inactive page. One way to test whether a host
    needs more RAM is if the pagedaemon is accumulating CPU time from all this testing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 12没有缓存，处理低内存情况的方式略有不同。当空闲内存不足时，页面守护进程会从非活动池中选择页面。如果该非活动页面需要同步到磁盘，它会被放入洗衣队列，页面守护进程则会尝试另一个非活动页面。测试主机是否需要更多RAM的一种方式是，如果页面守护进程因所有这些测试而积累了CPU时间。
- en: On either FreeBSD version, having free memory doesn’t mean that your system
    has enough memory. If vmstat(8) shows that you’re swapping at all, you’re using
    more physical memory than you have. You might have a program that releases memory
    on a regular basis. Also, FreeBSD will move some pages from inactive to free in
    an effort to maintain a certain level of free memory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在任一 FreeBSD 版本中，空闲内存并不意味着系统内存充足。如果 vmstat(8) 显示你正在进行交换操作，那么说明你使用的物理内存超过了系统的实际内存。你可能有一个定期释放内存的程序。此外，FreeBSD
    会将一些从非活动状态的页面移到空闲状态，以保持一定的空闲内存。
- en: FreeBSD uses *wired* memory for in-kernel data structures, as well as for system
    calls that must have a particular piece of memory immediately available. Wired
    memory is never swapped or paged. All memory used by ZFS is wired.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 使用 *wired* 内存来存储内核数据结构，以及必须立即获取某块内存的系统调用。wired 内存永远不会被交换或分页。所有 ZFS 使用的内存都是
    wired 内存。
- en: '**Swap**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**交换区**'
- en: The `Swap` line ➐ gives the total swap available on the system and how much
    is in use. Swapping is using the disk drive as additional memory. We’ll look at
    swap in more detail later in the chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swap` 行 ➐ 显示了系统上可用的交换空间总量以及当前使用量。交换区是使用磁盘驱动器作为额外内存。我们将在本章后面更详细地讨论交换区。'
- en: '***ZFS and top(1)***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ZFS 与 top(1)***'
- en: The output of top(1) on a ZFS system looks superficially different, but the
    per-host handling of memory has important differences.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ZFS 系统上，top(1) 的输出看起来表面上有所不同，但每个主机对内存的处理有重要的差异。
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Mem section ➊ lists `Active`, `Inactive`, `Laundry`, `Wired`, and `Free`
    memory familiar from UFS output.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Mem 部分 ➊ 列出了 `Active`、`Inactive`、`Laundry`、`Wired` 和 `Free` 内存，这些是从 UFS 输出中熟悉的字段。
- en: The ARC line ➋ represents ZFS’s *Advanced Replacement Cache*. The `Total` field
    shows the amount of memory the entire ARC uses. Within the 2,312MB used by the
    cache, 458MB are in the Most Frequently Used (`MFU`) cache, while 1,626MB are
    in the Most Recently Used (`MRU`) cache. You’ll also see much smaller entries
    for ZFS internal data structures, such as anonymous buffers (`Anon`), ZFS headers
    (`Header`), and the ever-useful `Other`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ARC 行 ➋ 表示 ZFS 的 *高级替换缓存*。`Total` 字段显示整个 ARC 使用的内存量。在缓存使用的 2,312MB 中，458MB 在最常用（`MFU`）缓存中，而
    1,626MB 在最近使用（`MRU`）缓存中。你还会看到一些更小的条目，用于表示 ZFS 内部数据结构，如匿名缓冲区（`Anon`）、ZFS 头（`Header`）以及非常有用的
    `Other`。
- en: ZFS compresses the ARC ➌, exchanging plentiful CPU time for scarce memory. You
    can see the amount of space used by compressed and uncompressed cached data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ZFS 压缩了 ARC ➌，通过大量的 CPU 时间来换取稀缺的内存。你可以看到压缩和未压缩缓存数据所使用的空间量。
- en: ZFS is greedy for memory, provided nothing else wants it. ZFS aggressively caches
    data read from and written to disk. This host has 4,096MB of RAM, and ZFS has
    claimed 2,312MB of that. You’ll see that this host has only 137MB free. If a program
    requests memory and the system doesn’t have it available, ZFS will release some
    of its cache back to the system. If you see a high wired memory level, remind
    yourself that all memory claimed by ZFS goes into the “wired” bucket.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ZFS 对内存的需求很大，前提是没有其他进程需要它。ZFS 会积极缓存从磁盘读写的数据。该主机有 4,096MB 的内存，而 ZFS 已经占用了其中的
    2,312MB。你会看到该主机只剩下 137MB 的空闲内存。如果某个程序请求内存，而系统没有足够的内存可用，ZFS 会将一些缓存释放回系统。如果你看到较高的“Wired”内存水平，记住所有由
    ZFS 占用的内存都会进入“wired”类别。
- en: This is a long-winded way of saying, “Don’t let apparent high ZFS memory usage
    worry you.” Worry only if the host starts paging and swapping.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种啰嗦的方式在说：“不要被表面上看起来较高的 ZFS 内存使用量所困扰。” 只有在主机开始分页和交换时才需要担心。
- en: More interesting is the list of processes that are using that memory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是使用这些内存的进程列表。
- en: '***Process List***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***进程列表***'
- en: Finally, top(1) lists the processes on the system and their basic characteristics.
    The table format is designed to present as much information as possible in as
    little space as possible. Every process has its own line.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，top(1) 列出了系统上的进程及其基本特征。表格格式旨在尽可能少的空间中展示尽可能多的信息。每个进程占用一行。
- en: '**PID** First, we have the process ID number, or PID. Every running process
    has its own unique PID. When you use kill(1), specify the process by its PID.
    (If you don’t know the PID of a process, you can use pkill(1) to kill the process
    by its name.)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**PID** 首先，我们有进程 ID 号，或 PID。每个运行中的进程都有一个唯一的 PID。当你使用 kill(1) 时，通过 PID 来指定进程。（如果你不知道某个进程的
    PID，可以使用 pkill(1) 通过进程名称来杀死该进程。）'
- en: '**Username** Next is the username of the user running the process. If multiple
    processes consume large amounts of CPU or memory, and they’re all owned by the
    same user, you know whom to talk to.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户名** 接下来是运行该进程的用户的用户名。如果多个进程占用了大量 CPU 或内存，并且它们都由同一个用户拥有，那么你就知道该找谁谈话。'
- en: '**Priority and niceness** The `PRI` (priority) and `NICE` columns are interrelated
    and indicate how much precedence the system gives each process. We’ll talk about
    priority and niceness a little later in this chapter.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先级和亲和度** `PRI`（优先级）和 `NICE` 列是相互关联的，表示系统给予每个进程的优先级。我们将在本章稍后讨论优先级和亲和度。'
- en: '**Size** `SIZE` gives the amount of memory that the process has requested.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小** `SIZE` 显示进程请求的内存量。'
- en: '**Resident memory** The `RES` column shows how much of a program is actually
    in memory at the moment. A program might request a huge amount of memory but use
    only a small fraction of that at any time. The kernel is smart enough to give
    programs what they need rather than what they ask for.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**常驻内存** `RES` 列显示程序当前实际在内存中的部分。一个程序可能请求大量的内存，但在任何时候只使用其中的一小部分。内核足够智能，可以根据程序的实际需求分配内存，而不是按请求分配。'
- en: '**State** The `STATE` column shows what a process is doing at the moment. A
    process can be in a variety of states—waiting for input, sleeping until something
    wakes it, actively running, and so on. You can see the name of the event a process
    is waiting on, such as `select`, `pause`, or `ttyin`. On an SMP system, when a
    process runs, you’ll see the CPU it’s running on.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态** `STATE` 列显示进程当前正在做什么。进程可能处于各种状态——等待输入、处于睡眠状态直到某个事件唤醒它、正在积极运行等等。你可以看到进程正在等待的事件名称，例如
    `select`、`pause` 或 `ttyin`。在 SMP 系统上，当进程运行时，你会看到它所运行的 CPU。'
- en: '**Time** The `TIME` column shows the total amount of CPU time the process has
    consumed.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间** `TIME` 列显示该进程已消耗的总 CPU 时间。'
- en: '**WCPU** The weighted CPU (WCPU) usage shows the percentage of CPU time that
    the process uses, adjusted for the process’s priority and niceness.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**加权 CPU** 加权 CPU（WCPU）使用量显示该进程使用的 CPU 时间百分比，已根据进程的优先级和亲和度进行了调整。'
- en: '**Command** Finally, we have the name of the program that’s running.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令** 最后，我们有正在运行的程序的名称。'
- en: Looking at top(1)’s output gives you an idea of where the system is spending
    its time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 top(1) 的输出可以让你了解系统花费时间的地方。
- en: Not every process on a host is actively engaged in work. You might have dozens
    or hundreds of daemons sitting idle. Enter i on a running top(1) display to toggle
    displaying idle processes, or use the -i command line flag. To show individual
    threads, either toggle `H` or add the `-H` flag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不是每个主机上的进程都在积极工作。你可能有几十个或上百个空闲的守护进程。按 i 键切换显示空闲进程，或者使用 -i 命令行标志。要显示单独的线程，可以切换
    `H` 或添加 `-H` 标志。
- en: By default, top sorts its output by weighted CPU usage. You can also sort output
    by priority, size, and resident memory. Enter o at a running top display. Enter
    the name of the column you want to sort by. This will help identify self-important
    programs or those using too much memory.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，top 按加权 CPU 使用量对输出进行排序。你也可以按优先级、大小和常驻内存对输出进行排序。在运行的 top 显示中，按 o 键，然后输入你想排序的列名。这有助于识别那些自命不凡或使用过多内存的程序。
- en: '***top(1) and I/O***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***top(1) 和 I/O***'
- en: In addition to the standard CPU display, top(1) has an I/O mode that displays
    which processes are using the disk most actively. While top(1) is running, hit
    m to enter the I/O mode. The upper portion of the display still shows memory,
    swap, and CPU status, but the lower portion changes considerably.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的 CPU 显示，top(1) 还有一个 I/O 模式，显示哪些进程正在最活跃地使用磁盘。运行 top(1) 时，按 m 进入 I/O 模式。显示的上半部分仍然显示内存、交换区和
    CPU 状态，但下半部分会发生显著变化。
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `PID` is the process ID, of course, and the `USERNAME` column shows who
    is running the process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`PID` 是进程 ID，当然，`USERNAME` 列显示的是谁在运行这个进程。'
- en: '`VCSW` stands for *voluntary context switches*; this is the number of times
    this process has surrendered the system to other processes. `IVCSW` means *involuntary
    context switches* and shows how often the kernel has told the process, “You’re
    done now. It’s time to let someone else run for a while.”'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`VCSW` 代表 *自愿上下文切换*；这是该进程已经将系统交给其他进程的次数。`IVCSW` 代表 *非自愿上下文切换*，显示内核告诉进程“你完成了，现在该让别人运行一会儿”的次数。'
- en: Similarly, `READ` and `WRITE` show how many times the system has read from disk
    and written to disk. The `FAULT` column shows how often this process has had to
    pull memory pages from disk, which makes for another sort of disk read. These
    last three columns are aggregated in the `TOTAL` column.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`READ`和`WRITE`显示系统从磁盘读取和写入的次数。`FAULT`列显示该进程需要从磁盘拉取内存页的次数，这也是另一种磁盘读取。这最后三列的汇总显示在`TOTAL`列中。
- en: The `PERCENT` column shows what percent of disk activity this process is using.
    Unlike gstat(8), top(1) displays each process’s utilization as a percentage of
    the actual disk activity, rather than the possible disk activity. If you have
    only one process accessing the disk, top(1) displays that process as using 100
    percent of disk activity, even if it’s sending only a trickle of data. While gstat(8)
    tells you how busy the disk is, top(1) tells you what’s generating that disk activity
    and where to place the blame. Here, we see that process ID 3064 is generating
    all of our disk activity. It’s a tcsh(1) process, also known as “some user’s shell.”
    Let’s track down the miscreant.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`PERCENT`列显示该进程使用的磁盘活动的百分比。与gstat(8)不同，top(1)显示的是每个进程的实际磁盘活动占比，而不是可能的磁盘活动。如果只有一个进程在访问磁盘，top(1)会显示该进程使用了100%的磁盘活动，即使它仅仅是发送了一点点数据。gstat(8)告诉你磁盘有多忙，而top(1)则告诉你是什么产生了磁盘活动，并指出责任。这里，我们看到进程ID
    3064正在产生所有磁盘活动。它是一个tcsh(1)进程，也叫做“某个用户的shell”。让我们追踪一下这个罪魁祸首。'
- en: '**MORE TOP FEATURES**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多顶级功能**'
- en: The top(1) tool can alter its display in many ways. You can view processes for
    a particular user, include or exclude kernel threads, exclude idle processes,
    and so on. Read the man page for details.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: top(1)工具可以以多种方式改变显示方式。你可以查看特定用户的进程，包含或排除内核线程，排除空闲进程等等。有关详细信息，请阅读手册页。
- en: '**Following Processes**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**后续进程**'
- en: On any Unix-like system, every userland process has a parent-child relationship
    with other processes. When FreeBSD boots, it creates a single process by starting
    init(8) and assigning it PID 1\. This process starts other processes, such as
    the */etc/rc* startup script and the getty(8) program that handles your login
    request. These processes are children of process ID 1\. When you log in, getty(8)
    starts login(8), which fires up a new shell for you, making your shell a child
    of the login(8) process. Commands you run are either children of your shell process
    or part of your shell. You can view these parent-child relationships with ps(1)
    using the `-ajx` flags (among others).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何类Unix系统上，每个用户空间进程都有与其他进程的父子关系。当FreeBSD启动时，它通过启动init(8)并将其分配PID 1来创建一个单一进程。这个进程会启动其他进程，比如*/etc/rc*启动脚本和处理你登录请求的getty(8)程序。这些进程是进程ID
    1的子进程。当你登录时，getty(8)会启动login(8)，然后启动一个新的shell，使得你的shell成为login(8)进程的子进程。你运行的命令要么是你shell进程的子进程，要么是你shell的一部分。你可以使用ps(1)并通过`-ajx`标志（以及其他标志）查看这些父子关系。
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At the far left, we have the username of the process owner and then the `PID`
    and parent PID (`PPID`) of the process. This is the most useful thing we see here,
    but we’ll briefly cover the other fields.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在最左边，我们可以看到进程拥有者的用户名，然后是该进程的`PID`和父进程PID（`PPID`）。这是我们在这里看到的最有用的信息，但我们将简要介绍其他字段。
- en: The `PGID` is the process group ID number, which is normally inherited from
    its parent process. A program can start a new process group, and that new process
    group will have a PGID equal to the process ID. Process groups are used for signal
    processing and job control. A session ID, or `SID`, is a grouping of PGIDs, usually
    started by a single user or daemon. Processes may not migrate from one SID to
    another. `JOBC` gives the job control count, indicating whether the process is
    running under job control (that is, in the background).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`PGID`是进程组ID号，通常由其父进程继承。程序可以启动一个新的进程组，该新进程组将拥有与进程ID相等的PGID。进程组用于信号处理和作业控制。会话ID，或`SID`，是PGID的一个分组，通常由单一用户或守护进程启动。进程不能从一个SID迁移到另一个SID。`JOBC`给出作业控制计数，指示进程是否在作业控制下运行（即在后台）。'
- en: '`STAT` shows the process state—exactly what the process is doing at the moment
    you run ps(1). Process state is very useful as it tells you whether a process
    is idle, what it’s waiting for, and so on. I highly recommend reading the section
    on process state from ps(1).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`STAT`显示进程状态——即你运行ps(1)时，进程当前正在做什么。进程状态非常有用，它告诉你进程是否处于空闲状态，正在等待什么等等。我强烈建议阅读ps(1)中关于进程状态的章节。'
- en: '`TT` lists the process’s controlling terminal. This column shows only the end
    of the terminal name, such as `v0` for `ttyv0` or `p0` for `ttyp0`. Processes
    without a controlling terminal are indicated by `??`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`TT`列列出进程的控制终端。此列仅显示终端名称的最后部分，例如`v0`表示`ttyv0`，`p0`表示`ttyp0`。没有控制终端的进程显示为`??`。'
- en: The `TIME` column shows how much processor time the process has used, both in
    userland and in the kernel.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIME`列显示了进程使用的处理器时间，包括用户态和内核态的时间。'
- en: Finally, we see the `COMMAND` name, as it was called by the parent process.
    Processes in square brackets are actually kernel threads, not real processes.
    FreeBSD runs a whole bunch of kernel threads.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到`COMMAND`名称，这是父进程调用的名称。方括号中的进程实际上是内核线程，而非真正的进程。FreeBSD运行了大量的内核线程。
- en: 'So, how can this help us track a questionable process? In our top(1) I/O example,
    we saw that process 3064 was generating almost all of our disk activity. Run ps
    -ajx to look for this process:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何利用这一点来追踪一个可疑进程呢？在我们top(1)的I/O示例中，我们看到进程3064几乎产生了我们所有的磁盘活动。运行`ps -ajx`来查找这个进程：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our process of interest is owned by root and is a tcsh(1) instance ➍, just as
    top’s I/O mode said. The command is running under su(1), however. Check this process’s
    parent process ID with the PPID column, and you’ll see that process 3064 is a
    child of process 2990 ➌, which is a child of process 2989 ➋, both of which are
    owned by root. Process 2989 is a child of 2981 ➊, however, which is a shell run
    by a real user. You might also note that these processes are all parts of session
    2981, showing that they’re probably all run in the same login session. The `TT`
    column shows `p1`, which means that the user is logged in on */dev/ttyp1*, the
    second virtual terminal on this machine. Investigating that SID would illuminate
    just what Bert thought he was doing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的进程由root拥有，是一个tcsh(1)实例➍，正如top的I/O模式所显示的那样。然而，命令是以su(1)身份运行的。检查这个进程的父进程ID，通过PPID列，你会看到进程3064是进程2990
    ➌的子进程，进程2990又是进程2989 ➋的子进程，后者由root拥有。然而，进程2989是由2981 ➊这个shell进程创建的，2981是由一个真实用户启动的。你可能还会注意到，这些进程都属于会话2981，显示它们可能都在同一个登录会话中运行。`TT`列显示为`p1`，这意味着用户在该机器的第二个虚拟终端（*/dev/ttyp1*）上登录。调查这个会话ID可以揭示Bert认为他在做什么。
- en: Now that you know how process parent-child operations work, you can cheat. Add
    the `-d` flag, as in, `ps -ajxd`, to present processes arranged in a tree with
    their parents. You’ll want a wide terminal.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了进程的父子操作是如何工作的，你可以进行一些作弊操作。添加`-d`标志，例如`ps -ajxd`，可以以树状结构显示进程及其父进程。你可能需要一个宽的终端。
- en: It’s normal for a system to experience brief periods of total utilization. If
    nobody else is using the system and nobody’s complaining about performance, why
    not let this user run his job? If this process is causing problems for other users,
    however, we can either deprioritize it, use our root privileges to kill the job,
    or show up at the user’s cubicle with a baseball bat.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 系统经历短时间的完全占用是正常的。如果没有其他人使用系统，而且没有人抱怨性能问题，为什么不让这个用户运行他的任务呢？然而，如果这个进程影响了其他用户，我们可以选择降低其优先级，使用我们的根权限杀死这个任务，或者拿着棒球棒出现在用户的工位前。
- en: '**Paging and Swapping**'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分页与交换**'
- en: Using swap space isn’t bad in and of itself. Swap space is much slower than
    chip memory, but it does work, and many programs don’t need to have everything
    in RAM in order to run. The old rule of thumb says that a typical program spends
    80 percent of its time running 20 percent of its code. Much of the rest of its
    code covers startup and shutdown, error handling, and so on. You can safely let
    those bits go out of RAM with minimal performance impact.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交换空间本身并不算坏。交换空间比内存慢得多，但它确实能工作，许多程序不需要将所有内容都保存在RAM中才能运行。旧的经验法则说，一个典型的程序80%的时间用于运行20%的代码，其余的时间则用来启动和关闭、错误处理等。你可以放心地让这些部分从RAM中移出，几乎不会影响性能。
- en: Swap caches data that it has handled. Once a process uses swap, that swap remains
    in use until the process either exits or calls the memory back from swap.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 交换缓存了它已经处理过的数据。一旦一个进程使用了交换空间，直到该进程退出或从交换空间中调用内存回来之前，这块交换空间将一直在使用。
- en: Swap usage occurs through *paging* and *swapping*. Paging is all right; swapping
    is not so good, but it’s better than crashing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 交换的使用通过*分页*和*交换*实现。分页是没问题的；交换则不太好，但总比崩溃强。
- en: '***Paging***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分页***'
- en: '*Paging* occurs when FreeBSD moves a portion of a running program into swap
    space. Paging can actually improve performance on a heavily loaded system because
    unused bits can be stored on disk until they’re needed—if ever. FreeBSD can then
    use the real memory for actual running code. Does it really matter whether your
    system puts your database startup code to swap once the database is up and running?'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*分页*发生在 FreeBSD 将正在运行的程序的部分内容移到交换空间时。分页实际上可以提高系统负载很重时的性能，因为未使用的部分可以存储在磁盘上，直到需要时再取出——如果真的需要的话。FreeBSD
    可以将实际的内存用来运行真正的代码。系统是否将数据库启动代码移到交换区，一旦数据库启动并运行，真的很重要吗？'
- en: '***Swapping***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***交换***'
- en: If the computer doesn’t have enough physical memory to store a process that
    isn’t being run at that particular microsecond, the system can move the entire
    process to swap. When the scheduler starts that process again, FreeBSD fetches
    the entire process from swap and runs it, probably consigning some other process
    to swap.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算机没有足够的物理内存来存储在某一微秒内未运行的进程，系统可以将整个进程移动到交换空间。当调度器再次启动该进程时，FreeBSD 会从交换区取回整个进程并运行它，可能还会把其他进程送到交换区。
- en: The problem with swapping is that disk I/O activity goes through the roof and
    performance drops dramatically. Since requests take longer to handle, there are
    more requests on the system at any one time. Logging in to check the problem only
    makes the situation worse because your login is just one more process. Some systems
    can handle certain amounts of swapping, while on others, the situation quickly
    degenerates into a death spiral.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 交换的主要问题是磁盘 I/O 活动暴增，性能急剧下降。由于请求处理时间更长，系统中任何时刻的请求也会增加。登录检查问题只会让情况变得更糟，因为你的登录只是又一个进程。一些系统能够处理一定量的交换，而在其他系统上，情况很快会恶化成死循环。
- en: When your CPU is overloaded, the system is slow. When your disks are a bottleneck,
    the system is slow. Memory shortages can actually crash your computer. If you’re
    swapping, you *must* buy more memory or resign yourself to appalling performance.
    If you’re trapped into this hardware and can’t buy more memory, you might get
    a really fast SSD and use it for swap.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CPU 过载时，系统会变慢。当磁盘成为瓶颈时，系统也会变慢。内存不足实际上可能导致计算机崩溃。如果你在进行交换操作，你*必须*购买更多的内存，否则只能忍受糟糕的性能。如果你被困在这款硬件上无法购买更多内存，可以考虑购买一块非常快速的
    SSD 用作交换空间。
- en: The output of vmstat(8) shows the number of processes swapped out at any one
    time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: vmstat(8) 的输出显示了在任何时刻被交换出去的进程数量。
- en: '**Performance Tuning**'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**性能调优**'
- en: FreeBSD caches recently accessed data in memory because a surprising amount
    of information is read from the disk time and time again. Information cached in
    physical memory can be accessed very quickly. If the system needs more memory,
    it dumps the oldest cached chunks in favor of new data. UFS and ZFS use different
    methods to decide what to cache, but the principle generally applies.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 会将最近访问的数据缓存到内存中，因为有很多信息会被反复从磁盘中读取。缓存到物理内存中的信息可以非常快速地访问。如果系统需要更多内存，它会丢弃最旧的缓存数据以腾出空间给新的数据。UFS
    和 ZFS 使用不同的方法来决定缓存哪些数据，但这个原则通常适用。
- en: When I booted my desktop this morning, I started Firefox so I could check my
    RSS feeds. The disk worked for a moment or two to read in the program. I then
    shut the browser off so I could focus on my work, but FreeBSD left Firefox in
    the cache. If I restart Firefox, FreeBSD will pull it from memory instead of troubling
    the disk, which dramatically reduces its startup time. Had I started a process
    that demanded a whole bunch of memory, though, FreeBSD would have dumped the web
    browser from the cache to support the new program.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 今天早晨启动我的桌面时，我打开了 Firefox 以便查看我的 RSS 订阅。磁盘运行了一两秒钟来加载程序。然后我关闭了浏览器，以便集中精力工作，但 FreeBSD
    将 Firefox 保留在缓存中。如果我重新启动 Firefox，FreeBSD 将直接从内存中提取它，而不是再去访问磁盘，从而大大减少了启动时间。如果我启动了一个需要大量内存的进程，FreeBSD
    则会将网页浏览器从缓存中清除，以支持新进程。
- en: 'If your system is operating well, you’ll have at least a few megabytes of free
    memory. The sysctls `vm.v_free_target` and `hw.pagesize` tell you how much free
    memory FreeBSD thinks it needs on your system. If you consistently have more free
    memory than these two sysctls multiplied, your system isn’t being used to its
    full potential. For example, on my mail server I have:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统运行正常，至少应该有几兆字节的空闲内存。sysctl 参数`vm.v_free_target`和`hw.pagesize`告诉你 FreeBSD
    认为系统中需要多少空闲内存。如果你总是拥有比这两个 sysctl 参数相乘的值更多的空闲内存，那么你的系统没有得到充分的利用。例如，在我的邮件服务器上，我有：
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: My system wants to have at least 5,350 × 4,096 = 21,913,600 bytes, or about
    22MB, of free memory. I could lose a gigabyte of RAM from my desktop without flinching,
    if it wasn’t for the fact that I suffer deep-seated emotional trauma about insufficient
    RAM.^([3](footnote.xhtml#ch21fn3))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我的系统至少需要拥有5,350 × 4,096 = 21,913,600字节，约22MB的空闲内存。如果不是因为我对不足的RAM有深层次的情感创伤，我完全可以毫不犹豫地从我的桌面丢掉1GB的RAM。^([3](footnote.xhtml#ch21fn3))
- en: '***Memory Usage***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存使用***'
- en: If a host has a lot of memory in cache or buffer, or the ARC has eaten all its
    RAM, it doesn’t have a memory shortage. You might make good use of more memory,
    but it isn’t strictly necessary. If you have low free memory, but a lot of active
    and non-ZFS wired memory, your system is devouring RAM. Adding memory would let
    you take advantage of the buffer cache.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机的缓存或缓冲区中有大量内存，或者ARC已经占用了所有RAM，那么它并不意味着内存不足。你可能会更好地利用更多的内存，但并不是严格必要的。如果你有较少的空闲内存，但大量活跃且非ZFS固定的内存，那么你的系统正在消耗RAM。增加内存会让你更好地利用缓冲区缓存。
- en: If the pagedaemon keeps running, incrementing the sr field in your vmstat output,
    the kernel is working hard to provide memory. The host might well have a memory
    shortage. Once the host start to use swap, though, this memory shortage is no
    longer hypothetical. It might not be bad, but it’s not theoretical.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页面守护进程持续运行，并且在你的vmstat输出中递增sr字段，说明内核正在努力提供内存。主机可能确实存在内存不足的情况。然而，一旦主机开始使用交换空间，这种内存不足就不再是假设的情况。虽然这不一定很糟糕，但也不是理论上的问题。
- en: '***Swap Space Usage***'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***交换空间使用***'
- en: Swap space helps briefly cover RAM shortages. For example, if you’re untarring
    a huge file you might easily consume all of your physical memory and start using
    virtual memory. It’s not worth buying more RAM for such occasional tasks when
    swap suffices. If a memory-starved server runs a daemon that doesn’t ever get
    called, that daemon will eventually get mostly or entirely swapped out in favor
    of processes that are performing work.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 交换空间可以帮助暂时弥补RAM的不足。例如，如果你在解压一个巨大的文件，可能会轻易消耗掉所有的物理内存，并开始使用虚拟内存。对于这种偶尔的任务，购买更多的RAM并不值得，因为交换空间已经足够。如果一台内存不足的服务器运行着一个从未被调用的守护进程，那么这个守护进程最终会被完全或大部分交换掉，以优先考虑执行工作的进程。
- en: Only worry about swap space use when the system constantly pages data in and
    out of swap.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在系统持续频繁地将数据从交换空间中交换进出时，才需要担心交换空间的使用。
- en: In short, swap space is like wine. A glass or two now and then won’t hurt you
    and might even be a good choice. Hitting the bottle constantly is a problem. If
    you have to swap constantly, consider a really fast but durable SSD.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，交换空间就像酒。偶尔喝一两杯不会伤害你，甚至可能是一个不错的选择。但如果你总是依赖交换空间，那就成问题了。如果你不得不频繁使用交换空间，可以考虑使用一个非常快速且耐用的SSD。
- en: '***CPU Usage***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***CPU使用***'
- en: A processor can do only so many things a second. If you run more tasks than
    your CPU can handle, requests will start to back up, you’ll develop a processor
    backlog, and the system will slow down. That’s CPU usage in a nutshell. If performance
    is unacceptable and top(1) shows your CPU hovering around 100 percent all the
    time, CPU utilization is probably your problem. While new hardware is certainly
    an option, you do have other choices. For example, investigate the processes running
    on your system to see whether they’re all necessary. Did some junior sysadmin
    install a SETI@Home client to hunt for aliens with your spare CPU cycles? How
    about a Bitcoin miner? Is anything running that was important at one time, but
    not any longer? Find and shut down those unnecessary processes, and make sure
    that they won’t start the next time the system boots.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器每秒钟能处理的事情是有限的。如果你运行的任务超过了CPU的承载能力，请求会开始积压，你将出现处理器积压，系统也会变慢。这就是CPU使用的核心概念。如果性能不可接受，并且top(1)显示你的CPU一直处于接近100%的状态，那么CPU利用率可能就是你的问题所在。虽然新硬件确实是一个选择，但你还有其他的选择。例如，检查系统中运行的进程，看看它们是否都必要。是不是某个初级系统管理员安装了SETI@Home客户端来用你的空闲CPU周期寻找外星人？比特币挖矿程序呢？是否有一些曾经重要的程序现在已经不再需要了？找出并关闭这些不必要的进程，并确保它们在下次系统启动时不会再运行。
- en: If you have very specific needs, such as dedicating certain processors to specific
    tasks, consider cpuset(1). It’s overkill for most users, but a high-performance
    application might make good use of dedicated processors.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有非常具体的需求，比如将某些处理器专门分配给特定任务，考虑使用cpuset(1)。对于大多数用户来说，这是过度的，但高性能应用可能会很好地利用专用的处理器。
- en: Once that’s done, evaluate your system performance again. If you still have
    problems, try rescheduling or reprioritizing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，再次评估你的系统性能。如果问题仍然存在，尝试重新调度或调整优先级。
- en: '***Rescheduling***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重新调度***'
- en: Rescheduling is easier than reprioritizing; it’s a relatively simple way to
    balance system processes so that they don’t monopolize system resources. As discussed
    in [Chapter 20](ch20.xhtml#ch20), you and your users can schedule programs to
    run at specific times with cron(8). If you have users who are running massive
    jobs at particular times, you might consider using cron(1) to run them in off
    hours. Frequently, jobs such as the monthly billing database search can run between
    6 PM and 6 AM and nobody will care—Finance just wants the data on hand at 8 AM
    on the first day of the month so they can close out last month’s accounting. Similarly,
    you can schedule your `make buildworld && make buildkernel` at 1 AM.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重新调度比重新排序更简单；它是一种相对简单的方法，旨在平衡系统进程，以免它们垄断系统资源。如[第20章](ch20.xhtml#ch20)所讨论，你和你的用户可以使用
    cron(8) 在特定时间安排程序运行。如果你的用户在特定时间运行大量任务，你可以考虑使用 cron(1) 在非高峰时段运行它们。通常像每月账单数据库查询这类任务可以在晚上
    6 点到早上 6 点之间运行，没人会介意——财务部门只需要在每月第一天早上 8 点时拿到数据，以便完成上个月的账务结算。类似地，你可以在凌晨 1 点安排你的
    `make buildworld && make buildkernel`。
- en: '***Reprioritizing with Niceness***'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用友好性重新排序***'
- en: If rescheduling won’t work, you’re left with reprioritizing, which can be a
    little trickier. When reprioritizing, you tell FreeBSD to change the importance
    of a given process. For example, you can have a program run during busy hours,
    but only when nothing else wants to run. You’ve just told that program to be *nice*
    and step aside for other programs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新调度不可行，那么你就需要进行重新排序，这可能会稍微复杂一些。在重新排序时，你告诉 FreeBSD 改变给定进程的优先级。例如，你可以让一个程序在繁忙时段运行，但只有在没有其他程序需要运行时才运行。你刚刚告诉那个程序要*友好*，并让出位置给其他程序。
- en: The nicer a process is, the less CPU time it demands. The default niceness is
    `0`, but niceness runs from `20` (very nice) to `-20` (not nice at all). This
    might seem backward; you could argue that a higher number should mean a higher
    priority. That would lead to a language problem, however; calling this factor
    “selfishness” or “crankiness” instead of “niceness” didn’t seem like a good idea
    at the time.^([4](footnote.xhtml#ch21fn4))
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 进程越“友好”，它所需的 CPU 时间就越少。默认的友好性是 `0`，但友好性范围从 `20`（非常友好）到 `-20`（一点也不友好）。这看起来可能有些反直觉；你可能会认为较高的数值应该意味着更高的优先级。然而，这会导致语言上的问题；将这个因素称为“自私”或“暴躁”而不是“友好性”当时似乎不是一个好主意。^([4](footnote.xhtml#ch21fn4))
- en: The top(1) tool displays a `PRI` column for process priority. FreeBSD calculates
    a process’s priority from a variety of factors, including niceness, and runs high-priority
    processes first whenever possible. Niceness affects priority, but you can’t directly
    edit priority.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: top(1) 工具会显示一个 `PRI` 列，表示进程优先级。FreeBSD 会根据多种因素计算进程的优先级，包括友好性，并尽可能先运行高优先级的进程。友好性会影响优先级，但你不能直接编辑优先级。
- en: 'If you know that your system is running at or near capacity, you can choose
    to run a command with nice(1) to assign the process a niceness. Specify niceness
    with `nice -n` and the nice value in front of the command. For example, to start
    a very selfish `make buildworld` at nice 15, you’d run:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道系统的负载接近或达到了容量上限，你可以选择使用 nice(1) 命令运行某个命令并为该进程指定友好性。通过 `nice -n` 和命令前的友好性值来指定友好性。例如，要以
    nice 15 启动一个非常自私的 `make buildworld`，你可以运行：
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Only root can assign a negative niceness to a program, as in `nice -n -5`.
    For example, if you want to abuse your superuser privileges to make a compile
    finish as quickly as possible, use a negative niceness:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 root 用户可以为程序分配负的友好性值，比如 `nice -n -5`。例如，如果你想滥用超级用户权限使编译尽可能快地完成，可以使用负的友好性：
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**NICE VS. TCSH**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**NICE 与 TCSH**'
- en: The tcsh(1) shell has a nice command built in. That built-in nice uses the renice(8)
    syntax, which is different from nice(1). I’m sure there’s a reason for that other
    than annoying tcsh users, but that rationale escapes me at the moment. To use
    nice(1), use the full path */usr/bin/nice*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: tcsh(1) shell 内置了一个 nice 命令。这个内置的 nice 使用的是 renice(8) 语法，与 nice(1) 不同。我相信这么做除了让
    tcsh 用户不高兴之外是有原因的，但现在我想不起来了。要使用 nice(1)，请使用完整路径 */usr/bin/nice*。
- en: Usually, you don’t have the luxury of telling a command to be nice when you
    start it but instead have to change its niceness when you learn that it’s absorbing
    all of your system capacity. You can use renice(8) to reprioritize running processes
    by their process IDs or owners. To change the niceness of a process, run `renice`
    with the new niceness and the PID as arguments.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你没有足够的时间在启动命令时就让它变得友好，而是必须在发现它占用了系统所有资源时改变其友好性。你可以使用 renice(8) 通过进程 ID 或所有者来重新排序正在运行的进程。要改变进程的友好性，运行
    `renice` 并指定新的友好性值和 PID 作为参数。
- en: 'In my career, I’ve run several logging hosts. In addition to general syslog
    services, they usually also run several instances of flow-capture, Nagios, and
    other critical network awareness systems. I’ll often use a web interface to all
    of this and allow other people to access my logs. If I find that intermittent
    load on the web server is interfering with my network monitoring or my syslogd(8)
    server, I must take action. Renicing the web server makes clients run more slowly,
    but that’s better than slowing down monitoring. Use pgrep(1) to find the web server’s
    PID:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我曾运行过几个日志主机。除了常规的syslog服务外，它们通常还会运行几个flow-capture、Nagios和其他关键的网络感知系统。我通常会使用一个web界面来管理所有这些，并允许其他人访问我的日志。如果我发现web服务器上的间歇性负载干扰了我的网络监控或syslogd(8)服务器，我必须采取行动。将web服务器的优先级调整低会让客户端运行得更慢，但这比让监控变慢要好。使用pgrep(1)找到web服务器的PID：
- en: '[PRE14]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Boom! FreeBSD now serves web requests after other processes. This greatly annoys
    the users of that service, but since it’s my server and I’m already annoyed, that’s
    all right.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 轰！FreeBSD现在在其他进程之后处理web请求。这大大惹恼了该服务的用户，但既然是我的服务器，我已经很烦了，那也没关系。
- en: 'To renice every process owned by a user, use the `-u` flag. For example, to
    make my processes more important than anyone else’s, I could do this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新调整用户拥有的每个进程的优先级，可以使用`-u`标志。例如，若要使我的进程优先级高于其他任何人的，我可以这样做：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `1001` is my user ID on this system. Again, presumably I have a very good
    reason for doing this, beyond my need for personal power.^([5](footnote.xhtml#ch21fn5))
    Similarly, if that user who gobbled up all my processor time insists on being
    difficult, I could make his processes very, very nice, which would probably solve
    other users’ complaints. If you have a big background database job, having the
    user running that job run nicely can let the foreground work proceed normally.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`1001`是我在此系统上的用户ID。同样，可以推测，我这么做有非常充分的理由，而不仅仅是为了个人的权力需求。^([5](footnote.xhtml#ch21fn5))
    同样，如果那个吃掉我所有处理器时间的用户坚持要为难我，我可以将他的进程设置为非常、非常低的优先级，这可能会解决其他用户的抱怨。如果你有一个大的后台数据库任务，让运行该任务的用户优先级较低可以让前台工作正常进行。'
- en: Niceness only affects CPU usage. It has no impact on disk or network activity.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Niceness仅影响CPU使用率， 对磁盘或网络活动没有影响。
- en: '**THE BOTTLENECK SHUFFLE**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**瓶颈交替**'
- en: Every system has bottlenecks. If you eliminate one bottleneck, performance will
    increase until another bottleneck is hit. The system’s performance is bound by
    the slowest component in the computer. For example, a web server is frequently
    network-bound because the slowest part of the system is the internet connection.
    If you upgrade your gigabit uplink to a 2.4Gb/s OC-48, the system will hand out
    its sites as fast as its other components allow. The hypothetical “eliminating
    bottlenecks” that management often demands is really a case of “eliminating bottlenecks
    that interfere with your usual workload.”
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都有瓶颈。如果消除了一个瓶颈，性能会提升，直到遇到另一个瓶颈。系统的性能受限于计算机中最慢的组件。例如，web服务器通常会受到网络限制，因为系统中最慢的部分是互联网连接。如果你将千兆上传带宽升级到2.4Gb/s的OC-48，系统将以其他组件的速度提供站点。管理层经常要求的“消除瓶颈”实际上是“消除干扰你常规工作负载的瓶颈”。
- en: Now that you can look at system problems, let’s learn how to hear what the system
    is trying to tell you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以查看系统问题了，让我们来学习如何听懂系统试图告诉你的内容。
- en: '**Status Mail**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**状态邮件**'
- en: FreeBSD runs maintenance jobs every day, week, and month, via periodic(8). These
    jobs perform basic system checks and notify the administrators of changes, items
    requiring attention, and potential security issues. The output of each scheduled
    job is mailed daily to the root account on the local system. The simplest way
    to find out what your system is doing is to read this mail; many very busy sysadmins
    just like you have collaborated to make these messages useful. While you might
    get a lot of these messages, with a little experience, you’ll learn how to skim
    the reports looking for critical or unusual changes only.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD每天、每周和每月通过periodic(8)运行维护任务。这些任务进行基本的系统检查，并通知管理员有关变化、需要关注的项目和潜在的安全问题。每个计划任务的输出每天都会发送到本地系统上的root账户。了解系统正在做什么的最简单方法是阅读这些邮件；许多像你一样非常忙碌的系统管理员已经合作，使这些信息变得非常有用。虽然你可能会收到很多这些邮件，但通过一点经验，你会学会如何快速浏览报告，只关注关键或异常的变化。
- en: The configuration of the daily, weekly, and monthly reports is controlled in
    *periodic.conf*, as discussed in [Chapter 20](ch20.xhtml#ch20).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 每日、每周和每月报告的配置在*periodic.conf*中进行控制，如[第20章](ch20.xhtml#ch20)所述。
- en: You probably don’t want to log in as root on all of your servers every day just
    to read email, so forward root’s mail from every server to a centralized mailbox.
    Make this change in */etc/mail/aliases*, as discussed in [Chapter 20](ch20.xhtml#ch20).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想每天都以 root 用户身份登录到所有服务器以读取邮件，因此将每台服务器的 root 邮件转发到一个集中式邮箱。在 */etc/mail/aliases*
    中进行此更改，如 [第 20 章](ch20.xhtml#ch20) 所讨论。
- en: The only place where I recommend disabling these jobs is on embedded systems,
    which should be managed and monitored through some other means, such as your network
    monitoring system. On such a system, disable the periodic(8) checks in */etc/crontab*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议只在嵌入式系统上禁用这些任务，因为嵌入式系统应该通过其他方式进行管理和监控，例如通过你的网络监控系统。在这样的系统上，禁用 */etc/crontab*
    中的 periodic(8) 检查。
- en: While these daily reports are useful, they don’t tell the whole story. Logs
    give a much more complete picture.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些日常报告很有用，但它们并没有讲述全部情况。日志提供了更为完整的视图。
- en: '**Logging with syslogd**'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 syslogd 进行日志记录**'
- en: The FreeBSD logging system is terribly useful. Any Unix-like operating system
    allows you to log almost anything at almost any level of detail. While you’ll
    find default system logging hooks for the most common system resources, you can
    choose a logging configuration that meets your needs. Almost all programs integrate
    with the logging daemon, syslogd(8).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 日志系统非常有用。任何类 Unix 操作系统几乎都可以记录几乎任何内容，并且可以设置详细的记录级别。虽然你会发现默认的系统日志挂钩用于最常见的系统资源，但你可以选择符合需求的日志配置。几乎所有程序都与日志守护进程
    syslogd(8) 集成。
- en: The syslog protocol works through messages. Programs send individual messages,
    which the syslog daemon syslogd(8) catches and processes. syslogd(8) handles each
    message according to its facility and priority level, both of which client programs
    assign to messages. You must understand both facilities and levels to manage system
    logs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: syslog 协议通过消息工作。程序发送单个消息，syslog 守护进程 syslogd(8) 捕获并处理这些消息。syslogd(8) 根据消息的设施和优先级处理每个消息，这些都是客户端程序为消息指定的。你必须理解设施和优先级才能管理系统日志。
- en: '***Facilities***'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设施***'
- en: A *facility* is a tag indicating the source of a log entry. This is an arbitrary
    label, just a text string used to sort one program from another. In most cases,
    each program that needs a unique log uses a unique facility. Many programs or
    protocols have facilities dedicated to them—for example, FTP is such a common
    protocol that syslogd(8) has a special facility just for it. syslogd also supports
    a variety of generic facilities that you can assign to any program.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*设施* 是表示日志条目来源的标签。这是一个任意的标签，仅是用来区分不同程序的文本字符串。在大多数情况下，每个需要唯一日志的程序都会使用一个独特的设施。许多程序或协议都有专门的设施——例如，FTP
    是一种常见协议，以至于 syslogd(8) 为它专门设置了一个设施。syslogd 还支持各种通用设施，你可以将它们分配给任何程序。'
- en: Here are the standard facilities and the types of information they’re used for.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是标准设施及其用途的信息类型。
- en: auth Public information about user authorization, such as when people logged
    in or used su(1).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: auth 关于用户授权的公共信息，例如人们登录或使用 su(1) 时的情况。
- en: authpriv Private information about user authorization, accessible only to root.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: authpriv 关于用户授权的私人信息，仅 root 用户可访问。
- en: console Messages normally printed to the system console.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: console 正常打印到系统控制台的消息。
- en: cron Messages from the system process scheduler.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: cron 来自系统进程调度器的消息。
- en: daemon A catch-all for all system daemons without other explicit handlers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: daemon 用于所有没有其他明确处理程序的系统守护进程的捕获设施。
- en: ftp Messages from FTP and TFTP servers.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ftp 来自 FTP 和 TFTP 服务器的消息。
- en: kern Messages from the kernel.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: kern 来自内核的消息。
- en: lpr Messages from the printing system.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: lpr 打印系统的消息。
- en: mail Mail system messages.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: mail 邮件系统消息。
- en: mark This facility puts an entry into the log every 20 minutes. This is useful
    when combined with another log.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: mark 该设施每 20 分钟在日志中插入一条记录。与其他日志结合使用时非常有用。
- en: news Messages from the Usenet News daemons.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: news 来自 Usenet News 守护进程的消息。
- en: ntp Network Time Protocol messages.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ntp 网络时间协议消息。
- en: security Messages from security programs, such as pfctl(8).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: security 来自安全程序的消息，例如 pfctl(8)。
- en: syslog Messages from the log system about the log system itself. Don’t log when
    you log, however, as that just makes you dizzy.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: syslog 来自日志系统本身的消息。注意，不要在日志时再记录日志，这样只会让你头晕。
- en: user The catch-all message facility. If a userland program doesn’t specify a
    logging facility, it uses this.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: user 捕获所有消息的设施。如果用户程序没有指定日志设施，则使用此设施。
- en: uucp Messages from the Unix-to-Unix Copy Protocol. This is a piece of pre-internet
    Unix history that you’ll probably never encounter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: uucp 来自 Unix 到 Unix 复制协议的消息。这是互联网前时代的 Unix 历史，你可能永远不会遇到。
- en: local0 **through** local7 These are provided for the sysadmin. Many programs
    have an option to set a logging facility; choose one of these if at all possible.
    For example, you might tell your customer service system to log to `local0`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: local0 **到** local7 这些是为系统管理员提供的。许多程序都有设置日志设施的选项；如果可能，选择这些之一。例如，你可能会告诉客户服务系统将日志记录到
    `local0`。
- en: While most programs have sensible defaults, it’s your job as the sysadmin to
    manage which programs log to which facility.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数程序都有合理的默认设置，但作为系统管理员，你的职责是管理哪些程序记录到哪些设施。
- en: '***Levels***'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***级别***'
- en: A log message’s *level* represents its relative importance. While programs send
    all of their logging data to syslogd, most systems record only the important stuff
    that syslogd receives and discard the rest. Of course, one person’s trivia is
    another’s vital data, and that’s where levels come in.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息的*级别*代表其相对重要性。虽然程序将所有日志数据发送到 syslogd，但大多数系统仅记录 syslogd 接收到的重要内容，丢弃其余的内容。当然，一个人认为无关紧要的事物，可能对另一个人来说是至关重要的，这就是级别的作用所在。
- en: 'The syslog protocol offers eight levels. Use these levels to tell syslogd what
    to record and what to discard. The levels are, in order from most to least important:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: syslog 协议提供了八个级别。使用这些级别来告诉 syslogd 记录什么内容，丢弃什么内容。这些级别按照重要性从高到低的顺序排列：
- en: emerg System panic. Messages flash on every terminal. The computer is basically
    hosed. You don’t even have to reboot—the system is doing it for you.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: emerg 系统崩溃。消息会在每个终端上闪烁。计算机基本上已经无法使用。你甚至不需要重启——系统会自动为你重启。
- en: crit Critical errors include things such as bad blocks on a hard drive or serious
    software issues. You can continue to run as is, if you’re brave.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: crit 严重错误包括硬盘上的坏块或严重的软件问题。如果你足够勇敢，你可以继续运行，照常使用。
- en: alert This is bad, but not an emergency. The system can continue to function,
    but this error should be attended to immediately.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: alert 这很糟糕，但不是紧急情况。系统仍然可以继续运行，但这个错误应该立即处理。
- en: err These are errors that require attention at some point, but they won’t destroy
    the system.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: err 这些是需要某个时候关注的错误，但不会摧毁系统。
- en: warning These are miscellaneous warnings that probably won’t stop the program
    that issued them from working just as it always has.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: warning 这些是杂项警告，可能不会阻止发出警告的程序照常工作。
- en: notice This includes general information that probably doesn’t require action
    on your part, such as daemon startup and shutdown.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: notice 包括一般信息，通常不需要你采取行动，比如守护进程的启动和关闭。
- en: info This includes program information, such as individual transactions in a
    mail server.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: info 包括程序信息，如邮件服务器中的个别事务。
- en: debug This level is usually only of use to programmers and occasionally to sysadmins
    who are trying to figure out why a program behaves as it does. Debugging logs
    can contain whatever information the programmer considered necessary to debug
    the code, which might include information that violates user privacy.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: debug 该级别通常仅对程序员有用，偶尔也对试图弄清楚程序为何按某种方式运行的系统管理员有用。调试日志可能包含程序员认为调试代码所需的任何信息，其中可能包括违反用户隐私的信息。
- en: none This means, “Don’t log anything from this facility.” It’s most commonly
    used to exclude information from wildcard entries, as we’ll see shortly.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: none 这意味着，“不要从这个设施记录任何内容。”它最常用于排除通配符条目的信息，稍后我们会看到。
- en: By combining level with priority, you can categorize messages quite narrowly
    and treat each according to your needs.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将级别与优先级结合使用，你可以非常精确地分类消息，并根据需要处理每条消息。
- en: '***Processing Messages with syslogd(8)***'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 syslogd(8) 处理消息***'
- en: 'The syslogd(8) daemon catches messages from the network and compares them with
    entries in */etc/syslog.conf* or files in */etc/syslog.d/*. Files in */etc/syslog.d/*
    are for your own entries and add-on programs, while */etc/syslog.conf* is for
    integrated system programs. Syslogd only reads */etc/syslog.d/* files ending in
    *.conf*. Both files have the same format, but I’ll refer to */etc/syslog.conf*
    for clarity. That file has two columns; the first describes the log message, either
    by facility and level, or by program name. The second tells syslogd(8) what to
    do when a log message matches the description. For example, look at this entry
    from the default *syslog.conf*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: syslogd(8)守护进程从网络中捕获消息，并将它们与*/etc/syslog.conf*或*/etc/syslog.d/*中的条目进行比较。*/etc/syslog.d/*中的文件用于你的自定义条目和附加程序，而*/etc/syslog.conf*用于集成的系统程序。syslogd只读取以*.conf*结尾的*/etc/syslog.d/*文件。这两个文件格式相同，但为了清晰起见，我将参考*/etc/syslog.conf*。该文件有两列；第一列描述日志消息，可能是通过设施和级别，或者通过程序名称。第二列告诉syslogd(8)当日志消息与描述匹配时应该做什么。例如，看看这个来自默认*syslog.conf*的条目：
- en: '[PRE16]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This tells syslogd(8) that when it receives a message from the `mail` facility
    with a level of `info` or higher, the message should be appended to */var/log/maillog*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉syslogd(8)，当它接收到来自`mail`设施且级别为`info`或更高的消息时，该消息应该附加到*/var/log/maillog*中。
- en: The logger won’t log to a nonexistent file. Use touch(1) to create the log file
    before restarting syslogd(8).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志文件不存在，logger将无法记录日志。在重新启动syslogd(8)之前，请使用touch(1)创建日志文件。
- en: '**Wildcards**'
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通配符**'
- en: 'You can also use wildcards as an information source. For example, this line
    logs every message from the `mail` facility:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用通配符作为信息来源。例如，这一行记录来自`mail`设施的每条消息：
- en: '[PRE17]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To log everything from everywhere, uncomment the `all.log` entry and create
    the file */var/log/all.log*:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要记录来自所有地方的所有内容，请取消注释`all.log`条目，并创建文件*/var/log/all.log*：
- en: '[PRE18]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This works, but I find it too informative to be of any real use. You’ll find
    yourself using complex grep(1) statements daisy-chained together to find even
    the simplest information. Also, this would include all sorts of private data.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这能工作，但我发现它提供的信息过于冗杂，实际使用时并不方便。你会发现自己需要使用复杂的grep(1)语句将多个命令串联起来才能找到即使是最简单的信息。此外，这还会包含各种私人数据。
- en: '**Excluding Information**'
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**排除信息**'
- en: 'Use the `none` level to exclude information from a log. For example, here,
    we exclude `authpriv` information from our all-inclusive log. The semicolon allows
    you to combine entries on a single line:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`none`级别可以从日志中排除信息。例如，在这里，我们将`authpriv`信息从我们的全包含日志中排除。分号允许你将多个条目合并到同一行：
- en: '[PRE19]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Comparison**'
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**比较**'
- en: 'You can also use the comparison operators `<` (less than), `=` (equal), and
    `>` (greater than) in *syslog.conf* rules. While syslogd defaults to recording
    all messages at the specified level or above, you might want to include only a
    range of levels. For example, you could log everything of `info` level and above
    to the main log file while logging the rest to the debug file:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在*syslog.conf*规则中使用比较操作符`<`（小于）、`=`（等于）和`>`（大于）。虽然syslogd默认记录指定级别或以上的所有消息，但你可能只想包括一个级别范围。例如，你可以将所有`info`级别及以上的日志记录到主日志文件中，同时将其余的日志记录到调试文件中：
- en: '[PRE20]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `mail.info` entry matches all log messages sent to the `mail` facility at
    `info` level and above. The second line matches only the messages that have a
    level of precisely `debug`. You can’t use a simple `mail.debug` because the debugging
    log will then duplicate the content of the previous log. This way, you don’t have
    to sort through debugging information for basic mail logs, and you don’t have
    to sort through mail transmission information to get your debugging output.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`mail.info`条目匹配所有发送到`mail`设施且级别为`info`及以上的日志消息。第二行只匹配级别恰好为`debug`的消息。你不能简单地使用`mail.debug`，因为那样调试日志会重复前一个日志的内容。这样，你就不需要为基本的邮件日志筛选调试信息，也不需要为获取调试输出而筛选邮件传输信息。'
- en: '**Local Facilities**'
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**本地设施**'
- en: 'Many programs offer to log via syslog. Most of these can be set to a facility
    of your choice. The various `local` facilities are reserved for these programs.
    For example, by default, dhcpd(8) (see [Chapter 20](ch20.xhtml#ch20)) logs to
    the facility `local7`. Here, we catch these messages and send them to their own
    file:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序提供通过syslog记录日志的功能。大多数这些程序可以设置为你选择的设施。各种`local`设施是为这些程序保留的。例如，默认情况下，dhcpd(8)（参见[第20章](ch20.xhtml#ch20)）将日志记录到`local7`设施中。在这里，我们捕获这些消息并将它们发送到自己的文件：
- en: '[PRE21]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you run out of `local` facilities, you can use other facilities that the
    system isn’t using. For example, I’ve once used the `uucp` facility on a busy
    log server on a network that had no `uucp` services.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`local`设施用完了，你可以使用系统未使用的其他设施。例如，我曾在一个没有`uucp`服务的繁忙日志服务器上使用过`uucp`设施。
- en: '**Logging by Program Name**'
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**按程序名称记录日志**'
- en: 'If you’re out of facilities, you can use the program’s name as a matching term.
    An entry for a name requires two lines: the first line contains the program name
    with a leading exclamation mark and the second line sets up logging. For example,
    FreeBSD uses this to log ppp(8) information:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设施已满，你可以使用程序的名称作为匹配条件。对于一个名称的条目，需要两行：第一行包含带有前导感叹号的程序名称，第二行设置日志记录。例如，FreeBSD使用此方法记录ppp(8)的信息：
- en: '[PRE22]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line specifies the program name and the second one uses wildcards
    to tell syslogd(8) to append absolutely everything to a file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行指定程序名称，第二行使用通配符告诉syslogd(8)将所有内容附加到一个文件中。
- en: The `!`programname syntax affects all lines after it, so you must put it last
    in *syslogd.conf*. You can safely use it in an */etc/syslog.d* file without worrying
    about affecting other entries.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`programname语法会影响其后的所有行，因此你必须将其放在*syslogd.conf*的最后。你可以放心地在*/etc/syslog.d*文件中使用它，而不必担心影响到其他条目。'
- en: '**Logging to User Sessions**'
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**记录到用户会话**'
- en: 'When you log to a user, any messages that arrive appear on that user’s screen.
    To log to a user session, list usernames separated by commas as the destination.
    To write a message to all users’ terminals, use an asterisk (`*`). For example,
    the default *syslog.conf* includes this line:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将日志记录到用户时，任何到达的消息都会显示在该用户的屏幕上。要将消息记录到用户会话中，请列出以逗号分隔的用户名作为目标。要将消息写入所有用户的终端，使用星号（`*`）。例如，默认的*syslog.conf*文件包括这一行：
- en: '[PRE23]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This says that any message of emergency level will appear on all users’ terminals.
    Since these messages usually say “goodbye” in one way or another, that’s appropriate.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示任何紧急级别的消息都会出现在所有用户的终端上。由于这些消息通常会以某种方式说“再见”，因此这是合适的。
- en: '**Sending Log Messages to Programs**'
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将日志消息发送到程序**'
- en: 'To direct log messages to a program, use a pipe symbol (|):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要将日志消息定向到程序，使用管道符号（|）：
- en: '[PRE24]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Logging to a Logging Host**'
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**记录到日志主机**'
- en: My networks habitually have a single logging host that handles not only the
    FreeBSD boxes but also Cisco routers and switches, other Unix boxes, and any syslog-speaking
    appliances. This greatly reduces system maintenance and saves disk space. Each
    log message includes the hostname, so you can easily sort them out later.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我的网络通常有一个单独的日志主机，处理的不仅是FreeBSD主机，还有Cisco路由器和交换机、其他Unix主机以及任何支持syslog的设备。这大大减少了系统维护并节省了磁盘空间。每条日志消息都包含主机名，因此你可以轻松地在之后进行分类。
- en: 'Use the *at* symbol (`@`) to send messages to another host. For example, the
    following line dumps everything your local syslog receives to the logging host
    on my network:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*at*符号（`@`）将消息发送到另一台主机。例如，以下这一行将你本地syslog接收到的所有内容转发到我网络上的日志主机：
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The *syslog.conf* on the destination host determines the final destination for
    those messages.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 目标主机上的*syslog.conf*文件决定了这些消息的最终目的地。
- en: 'On the logging host, you can separate logs by the host where the log message
    originated. Use the plus (`+`) symbol and the hostname to indicate that the rules
    that follow apply to this host:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志主机上，你可以通过日志消息的来源主机来分隔日志。使用加号（`+`）符号和主机名来表示接下来的规则适用于此主机：
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Put your generic rules at the top of *syslog.conf*. Per-host rules should go
    near the bottom or in separate *syslog.d* files.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的通用规则放在*syslog.conf*的顶部。每个主机的规则应该放在底部或单独的*syslog.d*文件中。
- en: '**Logging Overlap**'
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**日志重叠**'
- en: The logging daemon doesn’t log on a first-match or last-match basis; instead,
    it logs according to every matching rule. This means you can easily have one log
    message in several different logs. Consider the following snippet of log configuration.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 日志守护进程不是基于首次匹配或最后匹配的方式进行日志记录；相反，它根据每个匹配规则进行记录。这意味着你可以轻松地将一条日志消息记录到多个不同的日志中。考虑以下日志配置片段。
- en: '[PRE27]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Almost every message of level `notice` or more is logged to */var/log/messages*.
    Anything with a facility of `authpriv` is deliberately excluded from this log,
    though. We have our DHCP server logging to */var/log/dhcp*. This means that any
    DHCP messages of `notice` level or above will be logged to both */var/log/messages*
    and */var/log/dhcpd*. I don’t like this; I want my DHCP messages only in */var/log/dhcpd*.
    I can follow the `authpriv` example to deliberately exclude DHCP messages from
    */var/log/messages* by using the `none` facility:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每条 `notice` 级别或更高的消息都会被记录到 */var/log/messages*。然而，任何具有 `authpriv` 设施的消息都会故意从此日志中排除。我们让我们的
    DHCP 服务器记录到 */var/log/dhcp*。这意味着任何 `notice` 级别或更高的 DHCP 消息都会同时记录到 */var/log/messages*
    和 */var/log/dhcpd*。我不喜欢这样，我希望我的 DHCP 消息只出现在 */var/log/dhcpd* 中。我可以通过遵循 `authpriv`
    示例，使用 `none` 设施故意将 DHCP 消息从 */var/log/messages* 中排除：
- en: '[PRE28]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: My */var/log/messages* syslog configuration frequently grows quite long as I
    incrementally exclude every local facility from it, but that’s all right.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 */var/log/messages* syslog 配置经常随着我逐步排除每个本地设施而变得相当长，但这没关系。
- en: '**SPACES AND TABS**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格与制表符**'
- en: Traditional Unix-like operating systems require tabs between the columns in
    *syslog.conf*, but FreeBSD permits you to use spaces. Be sure to use only tabs
    if you share the same *syslog.conf* between different operating systems.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的类 Unix 操作系统要求在 *syslog.conf* 中的列之间使用制表符（tabs），但 FreeBSD 允许使用空格。如果你在不同的操作系统之间共享相同的
    *syslog.conf*，请确保只使用制表符。
- en: '***syslogd Customization***'
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***syslogd 自定义***'
- en: FreeBSD runs syslogd by default, and out of the box it can be used as a logging
    host. You can customize how it works through the use of command line flags. You
    can specify flags either on the command line or in *rc.conf* as `syslogd_flags`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 默认运行 syslogd，开箱即用，它可以作为日志主机使用。你可以通过使用命令行标志来定制它的工作方式。你可以在命令行或在 *rc.conf*
    中指定标志，形式为 `syslogd_flags`。
- en: '**Allowed Log Senders**'
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**允许的日志发送者**'
- en: 'You can specify exactly which hosts syslogd(8) accepts log messages from. This
    can be useful so you don’t wind up accepting logs from random people on the internet.
    While sending you lots of logs could be used to fill your hard drive as a preparation
    for an attack, it’s more likely to be the result of a misconfiguration. Your log
    server should be protected by a firewall in any case. Use the `-a` flag to specify
    either the IP addresses or the network of hosts that can send you log messages,
    as these two (mutually exclusive) examples show:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定 syslogd(8) 接受来自哪些主机的日志消息。这可以防止你接受来自互联网上随机人的日志。虽然发送大量日志可以用来填满硬盘，作为攻击的前期准备，但更有可能是配置错误的结果。无论如何，你的日志服务器应该通过防火墙进行保护。使用
    `-a` 标志来指定可以向你发送日志消息的主机的 IP 地址或网络，以下两个（互斥）示例展示了这一点：
- en: '[PRE29]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While syslogd(8) would also accept DNS hostnames and domain names for this restriction,
    DNS is a completely unsuitable access control mechanism.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 syslogd(8) 也接受 DNS 主机名和域名作为这一限制，但 DNS 是一个完全不适合用作访问控制机制的工具。
- en: You can entirely disable accepting messages from remote hosts by specifying
    the `-s` flag, FreeBSD’s default. If you use `-ss` instead, syslogd(8) also disables
    sending log messages to remote hosts. Using `-ss` removes syslogd(8) from the
    list of network-aware processes that show up in sockstat(1) and netstat(1). While
    this half-open UDP socket is harmless, some people feel better if syslogd(8) doesn’t
    appear attached to the network at all.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过指定 `-s` 标志来完全禁用接受远程主机的消息，这是 FreeBSD 的默认设置。如果你改用 `-ss`，syslogd(8) 还会禁用向远程主机发送日志消息。使用
    `-ss` 会将 syslogd(8) 从 sockstat(1) 和 netstat(1) 显示的网络感知进程列表中移除。尽管这个半开放的 UDP 套接字无害，但有些人更喜欢
    syslogd(8) 完全不显示在网络上。
- en: '**Attach to a Single Address**'
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绑定到单一地址**'
- en: 'syslogd(8) defaults to attaching to UDP port 514 on every IP address the system
    has. Your jail server needs syslogd, but a jail machine can run only daemons that
    bind to a single address. Use the `-b` flag to force syslogd(8) to attach to a
    single IP:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: syslogd(8) 默认绑定到系统所有 IP 地址上的 UDP 514 端口。你的监狱服务器需要 syslogd，但监狱机器只能运行绑定到单一地址的守护进程。使用
    `-b` 标志强制 syslogd(8) 绑定到单一 IP 地址：
- en: '[PRE30]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Additional Log Sockets**'
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加日志套接字**'
- en: 'syslogd(8) can accept log messages via Unix domain sockets as well as over
    the network. The standard location for this is */var/run/log*. No chrooted processes
    on your system can access this location, however. If you want those chrooted processes
    to run, you must either configure them to log over the network or provide an additional
    logging socket for them. Use the `-l` flag for this and specify the full path
    to the additional logging socket:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: syslogd(8)可以通过Unix域套接字以及通过网络接受日志消息。标准位置是*/var/run/log*。然而，系统上没有任何chroot进程可以访问这个位置。如果你希望这些chroot进程能够运行，你必须配置它们通过网络进行日志记录，或者为它们提供一个额外的日志套接字。使用`-l`标志来实现这一点，并指定额外日志套接字的完整路径：
- en: '[PRE31]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The named(8) and ntpd(8) programs come with FreeBSD and are commonly chrooted.
    The */etc/rc.d/syslogd* is smart enough to add the appropriate syslogd sockets
    if you chroot these programs through *rc.conf*.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: named(8)和ntpd(8)程序是FreeBSD的一部分，通常会被chroot。*/etc/rc.d/syslogd*足够智能，可以在你通过*rc.conf*配置这些程序的chroot时，自动添加适当的syslogd套接字。
- en: '**Verbose Logging**'
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**详细日志记录**'
- en: 'Logging with verbose mode (`-v`) prints the numeric facility and level of each
    message written in the local log. Using doubly verbose logging prints the name
    of the facility and level instead of the number:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用详细模式记录日志（`-v`）会打印本地日志中每条消息的数字设施和级别。使用双重详细日志记录会打印设施和级别的名称，而不是数字：
- en: '[PRE32]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These are the flags I consider most commonly. Read syslogd(8) for the complete
    list of options.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我认为最常用的标志。有关完整的选项列表，请参阅syslogd(8)。
- en: '**Log File Management**'
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**日志文件管理**'
- en: Log files grow, and you must decide how large they can grow before you trim
    them. The standard way to do this is through *log rotation*. When logs are rotated,
    the oldest log is deleted, the current log file is closed up and given a new name,
    and a new log file is created for new data. FreeBSD includes a basic log file
    processor, newsyslog(8), which also compresses files, restarts daemons, and in
    general handles all the routine tasks of log file shuffling. cron(1) runs newsyslog(8)
    once per hour.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件会增长，你必须决定它们可以增长到什么大小后进行修剪。标准的方法是通过*日志轮换*。当日志被轮换时，最旧的日志会被删除，当前日志文件会关闭并重新命名，并为新的数据创建一个新的日志文件。FreeBSD包含一个基本的日志文件处理器newsyslog(8)，它还会压缩文件、重启守护进程，并一般处理所有常规的日志文件操作。cron(1)每小时运行一次newsyslog(8)。
- en: 'When newsyslog(8) runs, it reads */etc/newsyslog.conf* and the files in */etc/newsyslog.conf.d/*.
    The */etc/newsyslog.conf* file is for core system functions, while files in */etc/newsyslog.conf.d/*
    are for add-on software. The newsyslog program attempts to parse any files in
    */etc/newsyslog.conf.d/* as newsyslog configurations. Both use the same format,
    so we’ll refer to *newsyslog.conf* for clarity. Each line in *newsyslog.conf*
    gives the condition for rotating one log file. If the conditions for rotating
    the log are met, the log is rotated and other actions are taken as appropriate.
    */etc/newsyslog.conf* uses one line per log file; each line has seven fields,
    like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当newsyslog(8)运行时，它会读取*/etc/newsyslog.conf*和*/etc/newsyslog.conf.d/*中的文件。*/etc/newsyslog.conf*文件用于核心系统功能，而*/etc/newsyslog.conf.d/*中的文件用于附加软件。newsyslog程序尝试将*/etc/newsyslog.conf.d/*中的任何文件解析为newsyslog配置文件。两者使用相同的格式，因此为了清晰起见，我们将参考*newsyslog.conf*。*newsyslog.conf*中的每一行给出了轮换一个日志文件的条件。如果满足轮换日志的条件，日志会被轮换，并根据需要执行其他操作。*/etc/newsyslog.conf*每个日志文件使用一行；每一行有七个字段，如下所示：
- en: '[PRE33]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let’s examine each field in turn.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个检查每个字段。
- en: '***Log File Path***'
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***日志文件路径***'
- en: The first entry on each line (`/var/log/ppp.log` in the example) is the full
    path to the log file to be processed.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的第一个条目（例如示例中的`/var/log/ppp.log`）是要处理的日志文件的完整路径。
- en: '***Owner and Group***'
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***所有者和组***'
- en: The second field (`root:network` in our example) lists the rotated file’s owner
    and group, separated by a colon. This field is optional and isn’t present in many
    of the standard entries.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段（在我们的示例中为`root:network`）列出了轮换文件的所有者和组，它们由冒号分隔。这个字段是可选的，并且在许多标准条目中并不存在。
- en: newsyslog(8) can change the owner and group of old log files. By default, log
    files are owned by the root user and the wheel group. While it’s not common to
    change the owner, you might need this ability on multiuser machines.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: newsyslog(8)可以更改旧日志文件的所有者和组。默认情况下，日志文件由root用户和wheel组拥有。虽然更改所有者并不常见，但在多用户机器上你可能需要此功能。
- en: You can also choose to change only the owner or only the group. In these cases,
    you use a colon with a name on only one side of it. For example, `:www` changes
    the group to www, while `mwlucas:` gives me ownership of the file.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择只更改所有者或仅更改组。在这种情况下，你可以在冒号的两侧只使用一个名称。例如，`:www`将组更改为www，而`mwlucas:`则将文件的所有权转给我。
- en: '***Permissions***'
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***权限***'
- en: The third field (`640` in our example) gives the permissions mode in standard
    Unix three-digit notation.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个字段（在我们的示例中是`640`）给出了标准Unix三位数字表示法中的权限模式。
- en: '***Count***'
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计数***'
- en: 'This field specifies the oldest rotated log file that newsyslog(8) should keep.
    newsyslog(8) numbers archived logs from newest to oldest, starting with the newest
    as log 0\. For example, with the default `count` of `5` for */var/log/messages*,
    you’ll find the following message logs:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段指定newsyslog(8)应保留的最旧旋转日志文件。newsyslog(8)按从最新到最旧的顺序编号存档日志，从最新的日志为日志0。例如，使用默认的`count`为`5`，对于*/var/log/messages*，你将看到以下日志消息：
- en: '[PRE34]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Those of you who can count will recognize that this makes six archives, not
    five, plus the current log file, for a week of logs. As a rule, it’s better to
    have too many logs than too few; however, if you’re tight on disk space, deleting
    an extra log or two might buy you time.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 会算数的人会意识到，这样会有六个归档文件，而不是五个，加上当前的日志文件，共有一周的日志。通常来说，日志文件太多总比太少好；但是，如果磁盘空间紧张，删除一个或两个额外的日志文件可能会为你争取一些时间。
- en: '***Size***'
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***大小***'
- en: The fifth field (`100` in our example) is the file size in kilobytes. When newsyslog(8)
    runs, it compares the size listed here with the size of the file. If the file
    is larger than the size given here, newsyslog(8) rotates the file. If you don’t
    want the file size to affect when the file is rotated, put an asterisk here.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个字段（在我们的示例中是`100`）表示文件的大小，以千字节为单位。当newsyslog(8)运行时，它会将此处列出的大小与文件的实际大小进行比较。如果文件大于此处给定的大小，newsyslog(8)会旋转该文件。如果你不希望文件大小影响文件何时旋转，可以在这里放置一个星号。
- en: '***Time***'
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***时间***'
- en: 'So far this seems easy, right? The sixth field, rotation time, changes that.
    The time field has four different legitimate types of value: an asterisk, a number,
    and two different date formats.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这似乎很简单，对吧？第六个字段，旋转时间，改变了这一点。时间字段有四种不同的合法值类型：星号、数字和两种日期格式。
- en: If you rotate based on log size rather than age, put an asterisk here.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望基于日志大小而非年龄进行旋转，请在这里放置一个星号。
- en: If you put a plain naked number in this field, newsyslog(8) rotates the log
    after that many hours have passed. For example, if you want the log to rotate
    every 24 hours but don’t care about the exact time when that happens, put `24`
    here.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在此字段中填写一个普通的数字，newsyslog(8)将在经过该小时数后旋转日志。例如，如果你希望日志每24小时旋转一次，但不关心具体的时间，可以在这里填写`24`。
- en: The date formats are a little more complicated.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 日期格式稍微复杂一些。
- en: '**ISO 8601 Time Format**'
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**ISO 8601 时间格式**'
- en: Any entry beginning with an `@` symbol is in the restricted ISO 8601 time format.
    This is a standard used by newsyslog(8) on most Unix-like systems; it was the
    time format used in MIT’s primordial newsyslog(8). Restricted ISO 8601 is a bit
    obtuse, but every Unix-like operating system supports it.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以`@`符号开头的条目都采用限制版ISO 8601时间格式。这是newsyslog(8)在大多数类Unix系统上使用的标准格式；它也是MIT最初版本的newsyslog(8)所采用的时间格式。限制版ISO
    8601稍显晦涩，但每个类Unix操作系统都支持它。
- en: A full date in the restricted ISO 8601 format is 14 digits with a `T` in the
    middle. The first four digits are the year, the next two the month, the next two
    the day of the month. The `T` is inserted in the middle as a sort of decimal point,
    separating whole days from fractions of a day. The next two digits are hours,
    the next two minutes, the last two seconds. For example, the date of March 2,
    2008, 9:15 and 8 seconds PM is expressed in restricted ISO 8601 as `20080302T211508`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 限制版ISO 8601格式的完整日期是14位数字，中间有一个`T`。前四位是年份，接下来的两位是月份，再接下来的两位是日期。`T`作为一种十进制点插入在中间，将整天与部分天数分开。接下来的两位是小时，接下来的两位是分钟，最后两位是秒数。例如，2008年3月2日晚上9:15:08的日期在限制版ISO
    8601中表示为`20080302T211508`。
- en: While complete dates in restricted ISO 8601 are fairly straightforward, confusion
    arises when you don’t list the entire date. You can choose to specify only fields
    near the `T`, leaving fields further away as blank. Blank fields are wildcards.
    For example, `1T` matches the 1st day of every month. `4T00` matches midnight
    of the 4th day of every month. `T23` matches the 23rd hour, or 11 PM, of every
    day. With a *newsyslog.conf* time of `@T23`, the log rotates every day at 11 PM.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的受限 ISO 8601 日期格式比较简单，但当你没有列出完整日期时，容易产生混淆。你可以选择仅指定靠近 `T` 的字段，其他字段留空。空字段是通配符。例如，`1T`
    匹配每个月的第 1 天。`4T00` 匹配每个月第 4 天的午夜。`T23` 匹配每天的第 23 小时，即晚上 11 点。使用 *newsyslog.conf*
    配置的 `@T23`，日志会在每天晚上 11 点旋转。
- en: As with cron(1), you must specify time units in detail. For example, `@7T`,
    the seventh day of the month, rotates the log once an hour, every hour, on the
    seventh day of the month. After all, it matches all day long! A time of `@7T01`
    would rotate the log at 1 AM on the 7th day of the month, which is probably more
    desirable. You don’t need more detail than an hour, however, as newsyslog(8) runs
    only once an hour.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 与 cron(1) 一样，你必须详细指定时间单位。例如，`@7T`，表示每月第七天，日志每小时旋转一次，持续整天。毕竟，它匹配整天！`@7T01` 会在每月第七天的凌晨
    1 点旋转日志，这通常是更理想的设置。然而，你不需要更精确的细节，因为 newsyslog(8) 只每小时运行一次。
- en: '**FreeBSD-Specific Time**'
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**FreeBSD 特有时间**'
- en: The restricted ISO 8601 time system doesn’t allow you to easily designate weekly
    jobs, and it’s impossible to specify the last day of the month. That’s why FreeBSD
    includes a time format that lets you easily perform these common tasks. Any entry
    with a leading cash sign (`$`) is written in the FreeBSD-specific *month week
    day* format.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 受限 ISO 8601 时间系统不允许你轻松指定每周任务，也无法指定每月的最后一天。因此，FreeBSD 提供了一种时间格式，让你能够轻松执行这些常见任务。任何以美元符号（`$`）开头的条目，都是采用
    FreeBSD 特有的 *月周日* 格式编写的。
- en: 'This format uses three identifiers: `M` (day of month), `W` (day of week),
    and `H` (hour of day). Each identifier is followed by a number indicating a particular
    time. Hours range from 0 to 23, while days run from 0 (Sunday) to 6 (Saturday).
    Days of the month start at 1 and go up, with `L` representing the last day of
    the month. For example, to rotate a log on the fifth of each month at noon I could
    use `$M5H12`. To start the month-end log accounting at 10 PM on the last day of
    the month, use `$MLH22`.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 该格式使用三个标识符：`M`（月份的日期），`W`（星期几），和 `H`（一天中的小时）。每个标识符后跟一个数字，表示特定的时间。小时数从 0 到 23，星期几从
    0（星期天）到 6（星期六）。月份的日期从 1 开始，直到月末，`L` 表示每月的最后一天。例如，要在每个月的第 5 天中午进行日志旋转，我可以使用 `$M5H12`。要在每个月的最后一天晚上
    10 点开始月末日志统计，可以使用 `$MLH22`。
- en: '**ROTATING ON SIZE AND TIME**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**按大小和时间旋转**'
- en: You can rotate logs at a given time, when they reach a certain size, or both.
    If you specify both size and time, the log rotates whenever either condition is
    met.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在特定时间、达到某个大小时，或两者都满足时旋转日志。如果你同时指定大小和时间，日志将在满足任一条件时旋转。
- en: '***Flags***'
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***标志***'
- en: The `flags` field dictates any special actions to be taken when the log is rotated.
    This most commonly tells newsyslog(8) how to compress the log file, but you can
    also signal processes when their log is rotated out from under them.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags` 字段指定日志旋转时要执行的任何特殊操作。这通常告诉 newsyslog(8) 如何压缩日志文件，但你也可以在日志被旋转时通知进程。'
- en: '**Log File Format and Compression**'
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**日志文件格式和压缩**'
- en: Logs can be either text or binary files.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 日志可以是文本文件或二进制文件。
- en: Binary files can be written to only in a very specific manner. newsyslog(8)
    starts each new log with a “logfile turned over” message, but adding this text
    to a binary file would damage it. The `B` flag tells newsyslog(8) that this is
    a binary file and that it doesn’t need this header.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件只能以非常特定的方式写入。newsyslog(8) 每次创建新的日志时，都会添加“日志文件已翻转”的信息，但将此文本添加到二进制文件会损坏它。`B`
    标志告诉 newsyslog(8)，这是一个二进制文件，不需要此头信息。
- en: Other log files are written in plain old ASCII text, and newsyslog(8) can and
    should add a timestamped message to the top of the file indicating when the log
    was rotated. If you’re using UFS, compressing old log files can save considerable
    space. The `-J` flag tells newsyslog(8) to compress archives with bzip(1); the
    `-Z` flag specifies gzip compression; the `-X` flag, xz(1); and the `-Y` flag,
    the new hotness in compression, zstd(1).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 其他日志文件以普通 ASCII 文本形式写入，newsyslog(8) 可以并且应该在文件顶部添加一个时间戳消息，指示日志何时被旋转。如果你使用 UFS，压缩旧日志文件可以节省大量空间。`-J`
    标志告诉 newsyslog(8) 使用 bzip(1) 压缩归档文件；`-Z` 标志指定 gzip 压缩；`-X` 标志表示 xz(1) 压缩；`-Y`
    标志表示新兴的 zstd(1) 压缩方式。
- en: If you’re using ZFS, though, text log files get compressed at the dataset layer
    along with every other compressible file. You can compress the log files in the
    traditional manner anyway, but there’s no advantage to doing so. Plus, you’ll
    need to manually decompress the files before you can view them. Let ZFS handle
    compression for you.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用 ZFS，文本日志文件会在数据集层与其他可压缩文件一起被压缩。你仍然可以按传统方式压缩日志文件，但这样做没有任何优势。此外，在查看文件之前，你需要手动解压它们。让
    ZFS 为你处理压缩。
- en: '**Special Log File Handling**'
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**特殊日志文件处理**'
- en: When it creates and rotates log files, newsyslog(8) can perform a few special
    tasks. Here are the most common; you can read about the others in newsyslog.conf(5).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当它创建并旋转日志文件时，newsyslog(8) 可以执行一些特殊任务。以下是最常见的任务；你可以在 newsyslog.conf(5) 中阅读关于其他任务的内容。
- en: Perhaps you have many similar log files that you want to treat identically.
    The `-G` flag tells newsyslog that the log file name at the beginning of the line
    is actually a shell glob, and that all log files that match the expression are
    to be rotated in this manner. To learn about shell expressions, read glob(3).
    Bring aspirin.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你有许多类似的日志文件，想要以相同方式处理。`-G` 标志告诉 newsyslog，行首的日志文件名实际上是一个 shell 通配符，并且所有匹配该表达式的日志文件都应按这种方式旋转。要了解
    shell 表达式，请阅读 glob(3)。准备好带上止痛药。
- en: You might want newsyslog to create a file if it doesn’t exist. Use the `-C`
    flag for this. The syslogd program won’t log to a nonexistent file.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望 newsyslog 在文件不存在时创建一个文件。为此，请使用 `-C` 标志。syslogd 程序不会记录到不存在的文件。
- en: The `-N` flag explicitly tells newsyslog not to send a signal when rotating
    this log.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`-N` 标志明确告诉 newsyslog 在旋转此日志时不要发送信号。'
- en: Finally, use a hyphen (`-`) as a placeholder when you don’t need any of these
    flags. It creates a column here so that you can have, say, a pidfile path.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你不需要使用这些标志时，使用短横线（`-`）作为占位符。它在此处创建一列，以便你可以放置比如 pidfile 路径。
- en: '***Pidfile***'
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Pidfile***'
- en: The next field is a pidfile path (not shown in our example, but look at */etc/newsyslog.conf*
    for a couple of samples). A pidfile records a program’s process ID so that other
    programs can easily view it. If you list the full path to a pidfile, newsyslog(8)
    sends a `kill -HUP` to that program when it rotates the log. This signals the
    process to close its logfiles and restart itself. Not all processes have pidfiles,
    and not all programs need this sort of special care when rotating their logs.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字段是一个 pidfile 路径（在我们的示例中未显示，但请查看 */etc/newsyslog.conf* 以了解几个示例）。pidfile 记录程序的进程
    ID，以便其他程序可以轻松查看它。如果你列出 pidfile 的完整路径，newsyslog(8) 会在旋转日志时向该程序发送 `kill -HUP` 信号。这会通知该进程关闭其日志文件并重新启动自己。并非所有进程都有
    pidfile，也并非所有程序在旋转日志时都需要这种特殊处理。
- en: '***Signal***'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***信号***'
- en: Most programs perform logfile rotation on a `SIGHUP`, but some programs need
    a specific signal when their logs are rotated. You can list the exact signal necessary
    in the last field, after the pidfile.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序在收到 `SIGHUP` 信号时会执行日志文件旋转，但一些程序在日志旋转时需要特定的信号。你可以在最后一个字段（pidfile 后）列出所需的确切信号。
- en: '***Sample newsyslog.conf Entry***'
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 newsyslog.conf 条目***'
- en: 'Let’s slap all this together into a worst-case, you’ve-*got*-to-be-kidding
    example. A database log file needs rotation at 11 PM on the last day of the month.
    The database documentation says that you must send the server an interrupt signal
    (`SIGINT`, or signal number 2) on rotation. You want the archived logs to be owned
    by the user *dbadmin* and viewable only to that user. You need six months of logs.
    What’s more, the logs are binary files. Your *newsyslog.conf* line would look
    like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有这些组合起来，形成一个最糟糕的、你绝对不会相信的示例。一个数据库日志文件需要在每个月的最后一天的晚上 11 点进行旋转。数据库文档说明，在旋转日志时，必须向服务器发送一个中断信号（`SIGINT`，即信号编号
    2）。你希望归档日志文件的所有权属于用户 *dbadmin*，且仅该用户可以查看。你需要保留六个月的日志。更重要的是，这些日志是二进制文件。你的 *newsyslog.conf*
    条目看起来将是这样的：
- en: '[PRE35]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is a deliberately vile example; in most cases, you just slap in the filename
    and the rotation condition, and you’re done.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个故意设计的恶劣示例；在大多数情况下，你只需要输入文件名和轮换条件，就能完成。
- en: '**FreeBSD and SNMP**'
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**FreeBSD与SNMP**'
- en: Emailed reports are nice but general, and logs are difficult to analyze for
    long-term trends. The industry standard for network, server, and service management
    is *Simple Network Management Protocol (SNMP)*. Many different vendors support
    SNMP as a protocol for gathering information from many different devices across
    the network. FreeBSD includes an SNMP agent, bsnmpd(8), that not only provides
    standard SNMP functions but also gives visibility to FreeBSD-specific features.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 通过电子邮件发送的报告很好，但比较笼统，日志也很难分析长期趋势。网络、服务器和服务管理的行业标准是*简单网络管理协议（SNMP）*。许多不同的厂商支持SNMP作为一种协议，用于从网络上许多不同的设备收集信息。FreeBSD包括一个SNMP代理bsnmpd(8)，不仅提供标准的SNMP功能，还能展示FreeBSD特有的功能。
- en: FreeBSD’s *bsnmpd* (short for *Begemot SNMPD*) is a minimalist SNMP agent specifically
    designed to be extensible. All actual functionality is provided via external modules.
    FreeBSD includes the bsnmpd modules for standard network SNMP functions and modules
    for specific FreeBSD features, such as PF and netgraph(4). Rather than trying
    to be all things to all people, bsnmpd(8) offers a foundation where everyone can
    build an SNMP implementation that does only what they need, no more and no less.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的*bsnmpd*（*Begemot SNMPD*的缩写）是一个极简主义的SNMP代理，专为可扩展性设计。所有实际功能通过外部模块提供。FreeBSD包括用于标准网络SNMP功能的bsnmpd模块以及用于FreeBSD特定功能的模块，如PF和netgraph(4)。bsnmpd(8)并不是想做所有事情，而是提供一个基础，使每个人都可以构建只做他们所需的功能的SNMP实现，既不多也不少。
- en: '***SNMP 101***'
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SNMP 101***'
- en: SNMP works on a classic client-server model. The SNMP client, usually some kind
    of management workstation or monitoring server, sends a request across the network
    to an SNMP server. The SNMP server, also called an *agent*, gathers information
    from the local system and returns it to the client. FreeBSD’s SNMP agent is bsnmpd(8).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP工作在经典的客户端-服务器模型上。SNMP客户端，通常是某种管理工作站或监控服务器，向SNMP服务器发送请求。SNMP服务器，也称为*代理*，从本地系统收集信息并将其返回给客户端。FreeBSD的SNMP代理是bsnmpd(8)。
- en: An SNMP agent can also send a request to make changes to the SNMP server. If
    the system is properly (or improperly, depending on your point of view) configured,
    you can issue commands via SNMP. This “write” configuration is most commonly used
    in routers, switches, and other embedded network devices. Most Unix-like operating
    systems have a command line management system and don’t usually accept instruction
    via SNMP. Writing system configuration or issuing commands via SNMP requires careful
    setup and raises all sorts of security issues; it’s an excellent topic for an
    entire book. No sysadmin I know is comfortable managing their system via SNMP.
    With all of this in mind, we’re going to focus specifically on read-only SNMP.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP代理还可以发送请求以对SNMP服务器进行更改。如果系统正确（或不正确，取决于你的观点）配置，你可以通过SNMP发出命令。这个“写”配置通常用于路由器、交换机和其他嵌入式网络设备。大多数类Unix操作系统有命令行管理系统，通常不接受通过SNMP发出的指令。通过SNMP写入系统配置或发出命令需要仔细的设置，并会引发各种安全问题；这本身就是一本书的好话题。我认识的没有哪位系统管理员会通过SNMP管理他们的系统。考虑到这一点，我们将专注于只读SNMP。
- en: In addition to having an SNMP server answer requests from an SNMP client, the
    client can transmit SNMP *traps* to a trap receiver elsewhere on the network.
    An SNMP agent generates these traps in response to particular events on the server.
    SNMP traps are much like syslogd(8) messages, except that they follow the very
    specific format required by SNMP. FreeBSD doesn’t include an SNMP trap receiver
    at this time; if you need one, check out snmptrapd(8) from net-snmp (*net-mgmt/net-snmp*).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让SNMP服务器响应来自SNMP客户端的请求外，客户端还可以向网络上其他地方的陷阱接收器发送SNMP*陷阱*。SNMP代理会在服务器发生特定事件时生成这些陷阱。SNMP陷阱很像syslogd(8)消息，只是它们遵循SNMP所要求的非常具体的格式。FreeBSD目前不包括SNMP陷阱接收器；如果需要，可以查看来自net-snmp的snmptrapd(8)（*net-mgmt/net-snmp*）。
- en: '**SNMP MIBs**'
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SNMP MIBs**'
- en: 'SNMP manages information via a management information base (MIB), a tree-like
    structure containing hierarchical information in ASN.1 format. We’ve seen an example
    of an MIB tree before: the sysctl(8) interface discussed in [Chapter 6](ch06.xhtml#ch06).'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP通过管理信息库（MIB）来管理信息，MIB是一个树状结构，包含以ASN.1格式表示的层级信息。我们之前见过一个MIB树的例子：在[第6章](ch06.xhtml#ch06)中讨论的sysctl(8)接口。
- en: 'Each SNMP server has a list of information it can extract from the local computer.
    The server arranges these bits of information into a hierarchical tree. Each SNMP
    MIB tree has very general main categories: network, physical, programs, and so
    on, with more specific subdivisions in each. Think of the tree as a well-organized
    filing cabinet, where individual drawers hold specific information and files within
    drawers hold particular facts. Similarly, the uppermost MIB contains a list of
    MIBs beneath it.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 SNMP 服务器都有一个它可以从本地计算机中提取信息的列表。服务器将这些信息按层次结构排列成一棵树。每个 SNMP MIB 树都有一些非常通用的主要类别：网络、物理、程序等，每个类别下有更具体的子分类。可以把这棵树想象成一个组织良好的文件柜，其中每个抽屉存放着特定的信息，而抽屉中的文件则存放着具体的事实。类似地，最上层的
    MIB 包含了它下属的 MIB 列表。
- en: 'MIBs can be referred to by name or by number. For example, here’s an MIB pulled
    off a sample system:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: MIB 可以通过名称或数字来引用。例如，下面是从一个示例系统中提取的 MIB：
- en: '[PRE36]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first term in this MIB, `interfaces`, shows us that we’re looking at this
    machine’s network interfaces. If this machine had no interfaces, this first category
    wouldn’t even exist. The `ifTable` is the interface table, or a list of all the
    interfaces on the system. `ifEntry` shows one particular interface, and `ifDescr`
    means that we’re looking at a description of this interface. This MIB can be summarized
    as, “Interface number 1 on this machine is called em0.”
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 MIB 中的第一个术语 `interfaces` 告诉我们，我们正在查看这台机器的网络接口。如果这台机器没有接口，第一类甚至不会存在。`ifTable`
    是接口表，或者说是系统上所有接口的列表。`ifEntry` 显示某个特定接口，`ifDescr` 表示我们正在查看该接口的描述。这个 MIB 可以总结为：“这台机器上的接口
    1 叫做 em0。”
- en: 'MIBs can be expressed as numbers, and most SNMP tools do their work natively
    in numerical MIBs. Most people prefer words, but your poor brain must be capable
    of working with either. An MIB browser can translate between the numerical and
    word forms of an SNMP MIB for you, or you could install *net-mgmt/net-snmp* and
    use snmptranslate(1), but for now, just trust me. The preceding example can be
    translated to:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: MIB 可以用数字表示，大多数 SNMP 工具本地使用数字 MIB 进行工作。大多数人喜欢使用文字，但你的大脑必须能够处理任意一种方式。MIB 浏览器可以帮助你在数字形式和文字形式的
    SNMP MIB 之间进行转换，或者你可以安装 *net-mgmt/net-snmp* 并使用 snmptranslate(1)，但现在，暂时相信我。前面的示例可以转换为：
- en: '[PRE37]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Expressed in words, this MIB has 5 terms separated by dots. Expressed in numbers,
    the MIB has 11 parts. That doesn’t look quite right if they’re supposed to be
    the same thing. What gives?
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 用文字表示时，这个 MIB 由 5 个以点分隔的术语组成。用数字表示时，这个 MIB 有 11 个部分。如果它们应该是同一个东西，那么这看起来就不太对劲了。怎么回事？
- en: The numerical MIB is longer because it includes the default `.1.3.6.1.2.1`,
    which means *.iso.org.dod.internet.mgmt.mib-2*. This is the standard subset of
    MIBs used on the internet. The vast majority of SNMP MIBs (but not all) have this
    leading string in front of them, so nobody bothers writing it down any more.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 数字表示的 MIB 更长，因为它包含了默认的 `.1.3.6.1.2.1`，它表示 *iso.org.dod.internet.mgmt.mib-2*。这是互联网上使用的标准
    MIB 子集。绝大多数 SNMP MIB（但不是全部）都有这个前缀，因此大家通常不再写它。
- en: 'If you’re in one of those difficult moods, you can even mix words and numbers:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处于那种难以抑制的情绪中，你甚至可以混合使用文字和数字：
- en: '[PRE38]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point, international treaties permit your coworkers to drive you from
    the building with pitchforks and flaming torches. Pick one method of expressing
    MIBs and stick to it.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，国际条约允许你的同事们用火把和叉子把你赶出大楼。选择一种表示 MIB 的方式并坚持使用它。
- en: '**MIB Definitions and MIB Browsers**'
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MIB 定义和 MIB 浏览器**'
- en: MIBs are defined according to a very strict syntax and are documented in *MIB
    files*. Every SNMP agent has its own MIB files; bsnmpd’s are in */usr/share/snmp*.
    These files are very formal plaintext. While you can read and interpret them with
    nothing more than your brain, I highly recommend copying them to a workstation
    and installing an MIB browser so that you can comprehend them more easily.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: MIB 是根据非常严格的语法定义的，并且记录在 *MIB 文件* 中。每个 SNMP 代理都有自己的 MIB 文件；bsnmpd 的 MIB 文件位于
    */usr/share/snmp*。这些文件是非常正式的纯文本格式。尽管你可以仅凭大脑阅读和理解它们，但我强烈建议将它们复制到工作站并安装一个 MIB 浏览器，以便更容易地理解它们。
- en: '*MIB browsers* interpret MIB files and present them in their full tree-like
    glory, complete with definitions of each part of the tree and descriptions of
    each individual MIB. Generally speaking, an MIB browser lets you enter a particular
    MIB and displays both the numerical and word definitions of that MIB, along with
    querying an SNMP agent for the status of that MIB.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '*MIB浏览器*解释MIB文件，并以完整的树形结构呈现它们，包括每个树的定义和每个MIB的描述。一般来说，MIB浏览器让你输入一个特定的MIB，并显示该MIB的数字和文字定义，同时查询SNMP代理以获取该MIB的状态。'
- en: If you have FreeBSD (or a lesser Unix) on your workstation, use mbrowse (*net-mgmt/mbrowse*)
    for MIB browsing. If you don’t want to use a graphical interface for SNMP work,
    check out net-snmp (*net-mgmt/net-snmp*) for a full assortment of command line
    SNMP client tools.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的工作站上运行FreeBSD（或其他较小的Unix系统），可以使用mbrowse（*net-mgmt/mbrowse*）进行MIB浏览。如果你不想使用图形界面来进行SNMP操作，可以查看net-snmp（*net-mgmt/net-snmp*），它提供了一整套命令行SNMP客户端工具。
- en: '**SNMP Security**'
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SNMP 安全性**'
- en: 'Many security experts state that SNMP really stands for “Security: Not My Problem!”
    This is rather unkind but very true. SNMP needs to be used only behind firewalls
    on trusted networks. If you must use SNMP on the naked internet, use packet filtering
    to keep the public from querying your SNMP service. SNMP agents run on UDP port
    161.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 许多安全专家表示，SNMP实际上代表着“安全：不是我的问题！”这虽然有些刻薄，但确实很真实。SNMP应该只在受信任的网络上的防火墙后使用。如果你必须在裸露的互联网中使用SNMP，请使用数据包过滤来防止公众查询你的SNMP服务。SNMP代理运行在UDP端口161上。
- en: The more common SNMP versions, 1 and 2c, provide no encryption. This means that
    anyone with a packet sniffer can capture your SNMP community name, so be absolutely
    certain you’re using SNMP only on a private network. Making unencrypted SNMP queries
    over an untrusted network is a great way to have strangers poking at your system
    management. SNMP version 3 uses encryption to protect data on the wire.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的SNMP版本1和2c不提供加密。这意味着任何拥有数据包嗅探器的人都可以捕获你的SNMP社区名，所以一定要确保只在私有网络上使用SNMP。在不受信任的网络上发起未加密的SNMP查询，是让陌生人窥探你系统管理的好方法。SNMP版本3使用加密来保护数据传输。
- en: 'SNMP provides basic security through *communities*. If you go looking around,
    you’ll find all sorts of explanations for why a community isn’t the same thing
    as a password, but a community *is* a password. Most SNMP agents have two communities
    by default: public (read-only access) and private (read-write access). Yes, there’s
    a default that provides read-write access. Your first task whenever you provision
    an SNMP agent on any host, on any OS, is to disable those default community names
    and replace them with ones that haven’t been widely documented for decades.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP通过*社区*提供基本的安全性。如果你去查找相关内容，你会发现各种解释，说明为什么社区与密码不同，但社区*就是*密码。大多数SNMP代理默认有两个社区：public（只读访问）和private（读写访问）。是的，默认有一个提供读写访问的社区。每当你为任何主机上的任何操作系统配置SNMP代理时，首先要做的就是禁用这些默认的社区名称，并用那些几十年来未被广泛记录的名称来替代。
- en: FreeBSD’s bsnmpd(8) defaults to SNMPv2c but can do SNMPv3\. SNMPv3 is a more
    complicated protocol, so we’re not going to cover it here. If you understand the
    SNMPv3 protocol and the basics of configuring FreeBSD’s bsnmpd, you won’t have
    any trouble enabling SNMPv3 in bsnmpd.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的bsnmpd(8)默认使用SNMPv2c，但也可以使用SNMPv3。SNMPv3是一个更复杂的协议，所以我们在这里不讨论它。如果你理解SNMPv3协议和配置FreeBSD的bsnmpd的基础知识，那么启用SNMPv3将不会有任何问题。
- en: '***Configuring bsnmpd***'
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置bsnmpd***'
- en: Before you can use SNMP to monitor your system, you must configure the SNMP
    daemon. Configure bsnmpd(8) in */etc/snmpd.config*. In addition to including the
    default communities of public and private, the default configuration doesn’t enable
    any of the FreeBSD-specific features that make bsnmpd(8) desirable.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以使用SNMP来监控系统之前，必须配置SNMP守护进程。配置bsnmpd(8)文件位于*/etc/snmpd.config*。除了包含公共(public)和私有(private)的默认社区外，默认配置不会启用任何使得bsnmpd(8)具有吸引力的FreeBSD特定功能。
- en: '**bsnmpd Variables**'
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**bsnmpd 变量**'
- en: 'bsnmpd uses variables to assign values to configuration statements. Most high-visibility
    variables are set at the top of the configuration file, as you’ll see here:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: bsnmpd使用变量为配置语句赋值。大多数高可见性的变量在配置文件的顶部设置，正如你在这里看到的：
- en: '[PRE39]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These top variables define values for MIBs that should be set on every SNMP
    agent. The location describes the physical location of the machine. Every system
    needs a legitimate email contact. bsnmpd(8) runs on operating systems other than
    FreeBSD, so you have the option of setting a particular operating system here.
    Lastly, if you have a trap host, you can set the server name and port here.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这些顶部的变量定义了应该在每个SNMP代理上设置的MIB值。位置描述了机器的物理位置。每个系统都需要一个合法的电子邮件联系方式。bsnmpd(8)也运行在FreeBSD以外的操作系统上，因此你可以选择在这里设置特定的操作系统。最后，如果你有陷阱主机，你可以在这里设置服务器名称和端口。
- en: 'Further down the file, you can set the SNMP community names:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的下方，你可以设置SNMP社区名称：
- en: '[PRE40]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `read` string defines the read-only community of this SNMP agent. The default
    configuration file advises you to change it. Take that advice. The `write` string
    is the read-write community name, which is disabled by default further down in
    the configuration file. You can also set the community name for SNMP traps sent
    by this agent.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`字符串定义了该SNMP代理的只读社区。默认配置文件建议你更改它。听取这个建议。`write`字符串是读写社区名称，默认在配置文件的下方被禁用。你还可以设置该代理发送的SNMP陷阱的社区名称。'
- en: With only this configuration, bsnmpd(8) will start, run, and provide basic SNMP
    data for your network management system. Just set `bsnmpd``_enable="YES"` in */etc/rc.conf*
    to start bsnmpd at boot. You won’t get any special FreeBSD functionality, however.
    Let’s go on and see how to manage this.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭这一配置，bsnmpd(8)将启动、运行并为你的网络管理系统提供基本的SNMP数据。只需在*/etc/rc.conf*中设置`bsnmpd``_enable="YES"`，以便在启动时启动bsnmpd。然而，你不会获得任何特别的FreeBSD功能。让我们继续，看看如何管理这个。
- en: '**Detailed bsnmpd Configuration**'
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**详细的bsnmpd配置**'
- en: 'bsnmpd(8) uses the variables you set at the top of the configuration file to
    assign values to different MIBs later in the configuration. For example, at the
    top of the file you set the variable `read` to `public`. Later in the configuration
    file, you’ll find this statement:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: bsnmpd(8)使用你在配置文件顶部设置的变量，稍后在配置中为不同的MIB分配值。例如，在文件的顶部你将变量`read`设置为`public`。稍后在配置文件中，你会看到如下语句：
- en: '[PRE41]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This sets the MIB `begemotSnmpdCommunityString.0.1` equal to the value of the
    `read` variable.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这将MIB `begemotSnmpdCommunityString.0.1`设置为`read`变量的值。
- en: Why not just set these values directly? bsnmpd(8) is specifically designed to
    be extensible and configurable. Setting a few variables at the top of the file
    is much easier than directly editing the rules further down the file.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接设置这些值呢？bsnmpd(8)被专门设计为可扩展和可配置的。在文件顶部设置几个变量比直接编辑文件下方的规则要容易得多。
- en: Let’s go back to this `begemotSnmpdCommunityString` MIB set here. Why are we
    setting this? Search for the string in your MIB browser, and you’ll see that this
    is the MIB that defines an SNMP community name. You probably could have guessed
    that from the assignment of the `read` variable, but it’s nice to confirm that.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到这里设置的`begemotSnmpdCommunityString` MIB。我们为什么要设置这个？在MIB浏览器中搜索这个字符串，你会看到这是定义SNMP社区名称的MIB。你可能已经从`read`变量的赋值中猜到这一点，但确认一下也不错。
- en: 'Similarly, you’ll find an entry like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你会找到类似这样的条目：
- en: '[PRE42]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Checking the MIB browser shows that this dictates the IP address and the UDP
    port that bsnmpd(8) binds to (in this case, all available addresses, on port 161).
    All MIB configuration is done in this manner.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 检查MIB浏览器显示，这决定了bsnmpd(8)绑定的IP地址和UDP端口（在本例中，所有可用地址，端口为161）。所有MIB配置都是以这种方式完成的。
- en: '**Loading bsnmpd Modules**'
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加载bsnmpd模块**'
- en: 'Most interesting bsnmpd(8) features are configured through modules. Enable
    modules in the configuration file by giving the `begemotSnmpdModulePath` MIB a
    class that the module handles and the full path to the shared library that implements
    support for that feature. For example, in the default configuration, you’ll see
    a commented-out entry for the PF bsnmpd(8) module:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数有趣的bsnmpd(8)功能是通过模块配置的。通过在配置文件中为`begemotSnmpdModulePath` MIB指定模块处理的类和实现该功能的共享库的完整路径来启用模块。例如，在默认配置中，你会看到PF
    bsnmpd(8)模块的注释掉的条目：
- en: '[PRE43]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This enables support for PF MIBs. Your network management software will be able
    to see directly into PF when you enable this, letting you track everything from
    dropped packets to the size of the state table.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这启用了PF MIB的支持。当你启用此选项时，你的网络管理软件将能够直接查看PF，允许你跟踪从丢失的包到状态表大小的所有信息。
- en: As of this writing, FreeBSD’s bsnmpd(8) ships with the following modules included
    but disabled. Some are FreeBSD-specific, while others support industry standards.
    Enable these by uncommenting their configuration file entries and restarting bsnmpd.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，FreeBSD 的 bsnmpd(8) 包含了以下模块，默认禁用。有些模块是 FreeBSD 特有的，而另一些支持行业标准。通过取消注释它们的配置文件条目并重新启动
    bsnmpd 来启用这些模块。
- en: lm75 Provides data from the lm75(4) temperature sensor via SNMP.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: lm75 通过 SNMP 提供来自 lm75(4) 温度传感器的数据。
- en: Netgraph Provides visibility into all Netgraph-based network features, documented
    in snmp_netgraph(3).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: Netgraph 提供了所有基于 Netgraph 的网络功能的可视化，详细信息见 snmp_netgraph(3)。
- en: PF Provides visibility into the PF packet filter.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: PF 提供了 PF 包过滤器的可视化。
- en: Hostres Implements the Host Resources SNMP MIB, snmp_hostres(3).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Hostres 实现了主机资源 SNMP MIB，见 snmp_hostres(3)。
- en: bridge Provides visibility into bridging functions, documented in snmp_bridge(3).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: bridge 提供了桥接功能的可视化，详细信息见 snmp_bridge(3)。
- en: wlan Accesses information on wireless networking.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: wlan 访问有关无线网络的信息。
- en: Restart bsnmpd(8) after enabling any of these in the configuration file. If
    the program won’t start, check */var/log/messages* for errors.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 启用这些模块后，重新启动 bsnmpd(8)。如果程序无法启动，请检查 */var/log/messages* 中的错误信息。
- en: With bsnmpd(8), syslogd(8), status emails, and a wide variety of performance
    analysis tools, you can make your FreeBSD system the best-monitored device on
    the network. Now that you can see everything your system offers, grab a flashlight
    as we explore a few of FreeBSD’s darker corners.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 bsnmpd(8)、syslogd(8)、状态邮件和各种性能分析工具，你可以让你的 FreeBSD 系统成为网络中监控最强的设备。现在你已经可以看到系统的所有功能了，让我们拿起手电筒，探索一下
    FreeBSD 的一些隐秘角落。
