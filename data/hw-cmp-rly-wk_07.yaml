- en: '## **7'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **7'
- en: COMPUTER HARDWARE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机硬件**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'The preceding chapters covered the foundational elements of computing—binary,
    digital circuits, memory. Let’s now examine how these elements come together in
    a computer, a device that’s more than the sum of its parts. In this chapter, I
    first provide an overview of computer hardware. Then we dive deeper into three
    parts of a computer: main memory, the processor, and input/output.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章介绍了计算的基础元素——二进制、数字电路、内存。现在让我们看看这些元素如何在计算机中结合起来，计算机是一个超越其各个部分的设备。在本章中，我首先提供计算机硬件的概述。然后我们将深入探讨计算机的三个部分：主内存、处理器以及输入/输出。
- en: '**Computer Hardware Overview**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计算机硬件概述**'
- en: Let’s begin with an overview of what makes a computer different from other electronic
    devices. Previously, we’ve seen how we can use logic circuits and memory devices
    to build circuits that perform useful tasks. The circuits we’ve built with logic
    gates have a set of features hard-wired into their design. If we want to add or
    modify a feature, we have to change the physical design of our circuit. On a breadboard
    that’s possible, but for a device that has been manufactured and sent to customers,
    changing hardware isn’t usually an option. Defining the features of a device in
    hardware alone limits our ability to quickly innovate and improve a design.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从计算机与其他电子设备的区别概述开始。此前，我们已经看到如何使用逻辑电路和内存设备构建执行有用任务的电路。我们使用逻辑门构建的电路具有一些硬接入的特性。如果我们想添加或修改某个特性，就必须更改电路的物理设计。在面包板上这是可能的，但对于已制造并交付给客户的设备来说，通常无法更改硬件。仅通过硬件定义设备的特性限制了我们快速创新和改进设计的能力。
- en: 'The circuits we’ve built so far give us a glimpse into how computers work,
    but we’re missing one critical element of computers: *programmability*. That is,
    a computer must be able to perform new tasks *without* changing hardware. To accomplish
    such a feat, a computer must be able to accept a set of instructions (a *program*)
    and perform the actions specified in those instructions. It must therefore have
    hardware that can perform a variety of operations in the order specified in a
    program. Programmability is a key differentiator between a device that is a computer
    and one that is not. In this chapter we cover computer *hardware*, the physical
    elements of a computer. This is in contrast to *software*, the instructions that
    tell a computer what to do, which we’ll cover in the next chapter.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们构建的电路让我们初步了解了计算机是如何工作的，但我们还缺少计算机的一个关键元素：*可编程性*。也就是说，计算机必须能够执行新的任务，*无需*改变硬件。为了实现这一目标，计算机必须能够接受一组指令（*程序*），并执行这些指令中指定的操作。因此，它必须拥有能够按照程序指定的顺序执行各种操作的硬件。可编程性是区分计算机与非计算机设备的关键特征。在本章中，我们将讨论计算机的*硬件*，即计算机的物理元素。与此相对的是*软件*，即告诉计算机该做什么的指令，我们将在下一章讨论软件。
- en: The ability to run software distinguishes a computer from a fixed-purpose device.
    That said, software still needs hardware, so what kind of hardware do we need
    to implement a general-purpose computer? First, we need memory. We’ve already
    covered single-bit memory devices such as latches and flip-flops; the type of
    memory used in a computer is a conceptual extension of those simple memory devices.
    The primary memory used in a computer is known as *main memory*, but often it’s
    referred to as just memory or *random access memory (RAM)*. It’s *volatile*, meaning
    it only retains data while powered. The “random access” part of RAM means that
    any arbitrary memory location can be accessed in roughly the same amount of time
    as any other location.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 运行软件的能力将计算机与固定用途设备区分开来。也就是说，软件仍然需要硬件，那么我们需要什么样的硬件来实现通用计算机呢？首先，我们需要内存。我们已经介绍了诸如锁存器和触发器之类的单比特内存设备；计算机中使用的内存是这些简单内存设备的概念扩展。计算机中使用的主要内存被称为*主内存*，但通常简称为内存或*随机存取内存（RAM）*。它是*易失性的*，意味着它只在电源开启时保持数据。RAM中的“随机存取”意味着任何任意的内存位置都可以在大致相同的时间内访问，和其他位置一样。
- en: The second key component we need is a *central processing unit*, or *CPU*. Often
    simply called a *processor*, this component carries out the instructions specified
    in software. The CPU can directly access main memory. Most processors today are
    *microprocessors*, CPUs on a single integrated circuit. A processor built on a
    single integrated circuit has the benefits of lower cost, improved reliability,
    and increased performance. A CPU is a conceptual extension of the digital logic
    circuits we covered previously.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第二个关键组件是 *中央处理单元*，或称 *CPU*。通常简称为 *处理器*，这个组件执行软件中指定的指令。CPU可以直接访问主内存。今天的大多数处理器都是*微处理器*，即集成电路上的CPU。单芯片集成的处理器具有成本较低、可靠性更高和性能更强的优点。CPU是我们之前讨论过的数字逻辑电路的概念性扩展。
- en: Although main memory and a CPU are the minimum hardware requirements for a computer,
    in practice most computing devices need to interact with the outside world, and
    they do so through input/output (I/O) devices. In this chapter, we cover main
    memory, the CPU, and I/O in more detail. These three elements are illustrated
    in [Figure 7-1](ch07.xhtml#ch7fig1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然主内存和CPU是计算机的最低硬件要求，但实际上，大多数计算设备都需要与外部世界进行交互，这些交互通过输入/输出（I/O）设备实现。在本章中，我们将更详细地讨论主内存、CPU和I/O。这三个元素在[图7-1](ch07.xhtml#ch7fig1)中有示意。
- en: '![image](../images/fig7-1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-1.jpg)'
- en: '*Figure 7-1: The hardware elements of a computer*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：计算机硬件元素*'
- en: '**Main Memory**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**主内存**'
- en: While executing a program, a computer needs a place to store the program’s instructions
    and related data. For example, when a computer runs a word processor for editing
    documents, the computer needs a place to hold the program itself, the contents
    of the document, and the state of editing—what part of the document is visible,
    the location of the cursor, and so forth. All of this data is ultimately a series
    of bits that the CPU needs to be able to access. Main memory handles the task
    of storing these 1s and 0s.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行程序时，计算机需要一个地方来存储程序的指令和相关数据。例如，当计算机运行文字处理器来编辑文档时，计算机需要一个地方来保存程序本身、文档的内容以及编辑状态——文档的哪一部分是可见的、光标的位置等等。所有这些数据最终都是一系列位，CPU需要能够访问它们。主内存负责存储这些1和0。
- en: 'Let’s explore how main memory works in a computer. There are two common types
    of computer memory: *static random access memory (SRAM)* and *dynamic random access
    memory (DRAM)*. In both types, the basic unit of memory storage is a *memory cell*,
    a circuit that can store a single bit. In SRAM, memory cells are a type of flip-flop.
    SRAM is static because its flip-flop memory cells retain their bit values while
    power is applied. On the other hand, DRAM memory cells are implemented using a
    transistor and a capacitor. The capacitor’s charge leaks over time, so data must
    be periodically rewritten to the cells. This refreshing of the memory cells is
    what makes DRAM dynamic. Today, DRAM is commonly used for main memory due to its
    relatively low price. SRAM is faster but more expensive, so it’s used in scenarios
    where speed is critical, such as in cache memory, which we’ll cover later. An
    example “stick” of RAM is shown in [Figure 7-2](ch07.xhtml#ch7fig2).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索计算机中主内存是如何工作的。计算机内存有两种常见类型：*静态随机存取内存 (SRAM)* 和 *动态随机存取内存 (DRAM)*。在这两种类型中，内存存储的基本单位是
    *存储单元*，它是一个能够存储单个位的电路。在SRAM中，存储单元是一种触发器。SRAM是静态的，因为其触发器存储单元在电源持续供电时会保留其位值。另一方面，DRAM存储单元是通过晶体管和电容器实现的。电容器的电荷会随着时间的推移而泄漏，因此数据必须定期重新写入单元。这种对内存单元的刷新使得DRAM成为动态内存。今天，DRAM由于其相对较低的价格，通常被用于主内存。SRAM虽然更快，但成本较高，因此通常用于对速度要求极高的场景，例如缓存内存，我们稍后会讨论到。一个RAM“条”示例如[图7-2](ch07.xhtml#ch7fig2)所示。
- en: '![image](../images/fig7-2.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-2.jpg)'
- en: '*Figure 7-2: Random access memory*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：随机存取内存*'
- en: As a generalization, you can think of the internals of RAM as grids of memory
    cells. Each single-bit cell in a grid can be identified using two-dimensional
    coordinates, the location of that cell in its grid. Accessing a single bit at
    a time isn’t very efficient, so RAM accesses multiple grids of 1-bit memory cells
    in parallel, allowing for reads or writes of multiple bits at once—a whole byte,
    for example. The location of a set of bits in memory is known as a *memory address*,
    a numeric value that identifies a memory location. It’s common for memory to be
    *byte-addressable*, meaning a single memory address refers to 8 bits of data.
    The internal details of the arrangement of memory or the implementation of the
    memory cells aren’t required knowledge for a CPU (or a programmer!). The main
    thing to understand is that computers assign numeric addresses to bytes of memory,
    and the CPU can read or write to those addresses, as illustrated in [Figure 7-3](ch07.xhtml#ch7fig3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你可以把 RAM 的内部结构看作是由内存单元组成的网格。网格中的每一个单比特单元都可以通过二维坐标来标识，即它在网格中的位置。一次访问一个比特并不是非常高效，因此
    RAM 会并行访问多个 1 比特内存单元的网格，从而实现一次读取或写入多个比特——例如，一个完整的字节。内存中一组比特的位置被称为 *内存地址*，它是一个数字值，用于标识一个内存位置。内存通常是
    *按字节寻址* 的，这意味着一个内存地址对应 8 位数据。内存的内部布局或内存单元的实现对于 CPU（或程序员）来说并不是必须知道的知识！关键点是，计算机会给内存的字节分配数字地址，CPU
    可以读取或写入这些地址，正如 [图 7-3](ch07.xhtml#ch7fig3) 所示。
- en: '![image](../images/fig7-3.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-3.jpg)'
- en: '*Figure 7-3: A CPU reads a byte from a memory address.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：CPU 从内存地址读取一个字节。*'
- en: Let’s consider a fictitious computer system that can address up to 64KB of memory.
    By today’s standards, that’s a tiny amount of memory for a computer, but it’s
    still useful for us as an example. Let’s also imagine that our fictitious computer’s
    memory is byte-addressable; each memory address represents a single byte. That
    means that we need one unique address for each byte of memory, and since 64KB
    is 64 × 1024 = 65,536 bytes, we need 65,536 unique addresses. Each address is
    just a number, and memory addresses usually start with 0, so our range of addresses
    is 0 to 65,535 (or 0xFFFF).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个假设的计算机系统，它最多可以寻址 64KB 的内存。以今天的标准来看，这对一台计算机来说是一个非常小的内存，但它仍然对我们作为示例很有用。我们还假设这台假设的计算机的内存是按字节寻址的；每个内存地址代表一个字节。这意味着我们需要为每个字节分配一个唯一的地址，并且由于
    64KB 等于 64 × 1024 = 65,536 字节，我们需要 65,536 个唯一的地址。每个地址只是一个数字，内存地址通常从 0 开始，因此我们的地址范围是
    0 到 65,535（或者 0xFFFF）。
- en: Since our fictitious 64KB computer is a digital device, memory addresses are
    ultimately represented in binary. How many bits do we need to represent a memory
    address on this system? The number of unique values that can be represented by
    a binary number with *n* bits is equal to 2^(*n*). So we want to know the value
    of *n* for 2^(*n*) = 65,536\. The inverse of raising 2 to a certain power is the
    base-2 logarithm. Therefore log[2](2^(*n*)) = *n* and log[2](65,536) = 16\. Stated
    another way, 2^(16) = 65,536\. Therefore, a 16-bit memory address is needed to
    address 65,536 bytes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的假设 64KB 计算机是数字设备，内存地址最终以二进制表示。那么我们需要多少位来表示这个系统的内存地址呢？一个二进制数可以表示的唯一值的数量为
    2^(*n*)，其中 *n* 为位数。所以我们想知道 *n* 的值，使得 2^(*n*) = 65,536。2 的某个指数的反运算是以 2 为底的对数。因此
    log[2](2^(*n*)) = *n*，而 log[2](65,536) = 16。所以换句话说，2^(16) = 65,536。因此，表示 65,536
    字节需要 16 位的内存地址。
- en: Or, more simply, since we already know that our highest numbered memory address
    is 0xFFFF, and we know that each hexadecimal symbol represents 4 bits, we can
    see that 16 bits are required (4 hex symbols × 4 bits per symbol). Again, our
    fictitious computer is able to address 65,536 bytes, and each byte is assigned
    a 16-bit memory address. [Table 7-1](ch07.xhtml#ch7tab1) shows a 16-bit memory
    layout with some example data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简单地说，既然我们已经知道我们最高的内存地址是 0xFFFF，并且知道每个十六进制符号代表 4 位，我们可以看出需要 16 位（4 个十六进制符号
    × 每个符号 4 位）。再次说明，我们的假设计算机能够寻址 65,536 字节，每个字节被分配一个 16 位的内存地址。[表 7-1](ch07.xhtml#ch7tab1)
    显示了一个 16 位内存布局，包含一些示例数据。
- en: '**Table 7-1:** A 16-Bit Memory Address Layout, Skipping Middle Addresses, with
    Example Data'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 一个 16 位内存地址布局，跳过中间地址，包含示例数据'
- en: '| **Memory address (as binary)** | **Memory address (as hex)** | **Example
    data** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **内存地址（以二进制表示）** | **内存地址（以十六进制表示）** | **示例数据** |'
- en: '| --- | --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0000000000000000` | `0000` | `23` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `0000000000000000` | `0000` | `23` |'
- en: '| `0000000000000001` | `0001` | `51` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `0000000000000001` | `0001` | `51` |'
- en: '| `0000000000000010` | `0002` | `4A` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `0000000000000010` | `0002` | `4A` |'
- en: '| `----------------` | `----` | `--` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `----------------` | `----` | `--` |'
- en: '| `1111111111111101` | `FFFD` | `03` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `1111111111111101` | `FFFD` | `03` |'
- en: '| `1111111111111110` | `FFFE` | `94` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `1111111111111110` | `FFFE` | `94` |'
- en: '| `1111111111111111` | `FFFF` | `82` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `1111111111111111` | `FFFF` | `82` |'
- en: Why does the number of bits matter? The number of bits used to represent a memory
    address is a key part of a computer system’s design. It limits the amount of memory
    that a computer can access, and it impacts how programs deal with memory at a
    low level.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么位数很重要？用于表示内存地址的位数是计算机系统设计的关键部分。它限制了计算机可以访问的内存量，并且影响程序在底层如何处理内存。
- en: Let’s now imagine that our fictitious computer has stored the ASCII string “Hello”
    starting at memory address 0x0002\. Since ASCII characters each require 1 byte,
    storing “Hello” requires 5 bytes. When examining memory, it’s common to use hexadecimal
    to represent both memory addresses and the contents of those memory addresses.
    [Table 7-2](ch07.xhtml#ch7tab2) provides a visual look at “Hello” stored in memory,
    starting at address 0x0002.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们假设我们的虚拟计算机已经从内存地址0x0002开始存储ASCII字符串“Hello”。由于每个ASCII字符都需要1个字节，因此存储“Hello”需要5个字节。查看内存时，通常会使用十六进制来表示内存地址以及这些内存地址的内容。[表格7-2](ch07.xhtml#ch7tab2)提供了从地址0x0002开始存储的“Hello”在内存中的可视化表示。
- en: '**Table 7-2:** “Hello” Stored in Memory'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 7-2：** “Hello” 存储在内存中'
- en: '| **Memory address** | **Data byte** | **Data as ASCII** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **内存地址** | **数据字节** | **数据（ASCII）** |'
- en: '| --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0000` | `00` |  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `0000` | `00` |  |'
- en: '| `0001` | `00` |  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `0001` | `00` |  |'
- en: '| `0002` | `48` | `H` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `0002` | `48` | `H` |'
- en: '| `0003` | `65` | `e` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `0003` | `65` | `e` |'
- en: '| `0004` | `6C` | `l` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `0004` | `6C` | `l` |'
- en: '| `0005` | `6C` | `l` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `0005` | `6C` | `l` |'
- en: '| `0006` | `6F` | `o` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `0006` | `6F` | `o` |'
- en: '| `0007` | `00` |  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `0007` | `00` |  |'
- en: '| `----` | `--` |  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `----` | `--` |  |'
- en: '| `FFFF` | `00` |  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `FFFF` | `00` |  |'
- en: Using this format makes it clear that each address only stores 1 byte, so storing
    all 5 ASCII characters requires addresses 0x0002 through 0x0006\. Note that the
    table shows a value of 00 for other memory addresses, but in practice, it isn’t
    safe to assume that a random address will hold 0; it could be anything. That said,
    in some programming languages it’s standard practice to end a text string with
    a null terminator (a byte equal to 0), and in that case, we’d actually expect
    to see 00 at address 0x0007.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种格式可以清楚地看出，每个地址只存储1个字节，因此存储所有5个ASCII字符需要地址从0x0002到0x0006。请注意，表格中显示其他内存地址的值为00，但实际上不能假设随机地址会存储0；它可以是任何值。不过，在某些编程语言中，通常会以空字符（字节值为0）结束文本字符串，在这种情况下，我们确实会期望在地址0x0007看到00。
- en: Applications that allow inspection of computer memory commonly represent the
    contents of memory in a format similar to what is shown in [Figure 7-4](ch07.xhtml#ch7fig4).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 允许查看计算机内存的应用程序通常会将内存内容表示为类似[图7-4](ch07.xhtml#ch7fig4)所示的格式。
- en: '![image](../images/fig7-4.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-4.jpg)'
- en: '*Figure 7-4: A typical view of memory bytes*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：内存字节的典型视图*'
- en: The leftmost column in [Figure 7-4](ch07.xhtml#ch7fig4) is a memory address
    in hexadecimal, and the following 16 values represent the bytes at that address
    and the 15 subsequent addresses. This approach is more compact than [Table 7-2](ch07.xhtml#ch7tab2),
    but it means that each address isn’t uniquely called out. In this figure, we again
    see the ASCII string “Hello” stored starting at address 0x0002.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-4](ch07.xhtml#ch7fig4)中的最左列是以十六进制表示的内存地址，接下来的16个值表示该地址及其后15个地址的字节。这种方法比[表格7-2](ch07.xhtml#ch7tab2)更紧凑，但这意味着每个地址没有被单独标出。在此图中，我们再次看到从地址0x0002开始存储的ASCII字符串“Hello”。'
- en: Our hypothetical computer with 64KB of RAM is useful as an example, but modern
    computing devices tend to have a much larger amount of memory. As of 2020, smartphones
    commonly have at least 1GB of memory, and laptop computers usually have at least
    4GB.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的假设计算机具有64KB的RAM，作为示例非常有用，但现代计算设备通常具有更大的内存。到2020年为止，智能手机通常至少有1GB内存，而笔记本电脑通常至少有4GB。
- en: '**EXERCISE 7-1: CALCULATE THE REQUIRED NUMBER OF BITS**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习7-1：计算所需的位数**'
- en: Using the techniques just described, determine the number of bits required for
    addressing 4GB of memory. You’ll want to look back at [Table 1-3](ch01.xhtml#ch1tab3)
    for a reference on SI prefixes. Remember that each byte is assigned a unique address,
    which is just a number. The answer is in [Appendix A](appa.xhtml).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用刚才描述的技术，确定寻址4GB内存所需的位数。你需要回头查看[表格 1-3](ch01.xhtml#ch1tab3)，参考一下国际单位制（SI）前缀。记住，每个字节都有一个唯一的地址，这只是一个数字。答案在[附录
    A](appa.xhtml)中。
- en: '**Central Processing Unit (CPU)**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**中央处理单元（CPU）**'
- en: Memory gives the computer a place to store data and program instructions, but
    it’s the CPU, or processor, that carries out those instructions. It’s the processor
    that allows a computer to have the flexibility to run programs that weren’t even
    conceived of at the time the processor was designed. A processor implements a
    set of instructions that programmers can then use to construct meaningful software.
    Each instruction is simple, but these basic instructions are the building blocks
    for all software.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 内存为计算机提供了一个存储数据和程序指令的地方，但执行这些指令的是CPU或处理器。正是处理器使得计算机能够运行在设计处理器时尚未构想到的程序。处理器实现了一组指令，程序员可以利用这些指令来构建有意义的软件。每条指令都很简单，但这些基本指令是所有软件的构建块。
- en: 'Here are some examples of types of instructions that CPUs support:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是CPU支持的一些指令类型示例：
- en: '**Memory access**   read, write (to memory)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存访问**   读取、写入（到内存）'
- en: '**Arithmetic**   add, subtract, multiply, divide, increment'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**算术**   加法、减法、乘法、除法、自增'
- en: '**Logic**   AND, OR, NOT'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑**   与、或、非'
- en: '**Program flow**   jump (to a specific part of a program), call (a subroutine)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序流程**   跳转（到程序的特定部分）、调用（子程序）'
- en: We’ll go into specific CPU instructions in [Chapter 8](ch08.xhtml), but for
    now, it’s important to understand that CPU instructions are just operations that
    the processor can perform. They are fairly simple (add two numbers, read from
    a memory address, perform a logical AND, and so forth). Programs consist of ordered
    sets of these instructions. To use a cooking analogy, the CPU is the cook, a program
    is a recipe, and each instruction in the program is a step of the recipe that
    the cook knows how to perform.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](ch08.xhtml)中详细介绍具体的CPU指令，但现在重要的是要理解，CPU指令只是处理器可以执行的操作。它们相对简单（加两个数字、从内存地址读取、执行逻辑与等）。程序由这些指令的有序集合组成。用做饭的类比，CPU就是厨师，程序是食谱，程序中的每条指令就是厨师知道如何执行的食谱步骤。
- en: Program instructions reside in memory. The CPU reads these instructions so it
    can run the program. [Figure 7-5](ch07.xhtml#ch7fig5) illustrates a simple program
    that’s read from memory by the CPU.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 程序指令驻留在内存中。CPU读取这些指令以便运行程序。[图7-5](ch07.xhtml#ch7fig5)展示了一个简单的程序，CPU从内存中读取该程序。
- en: '![image](../images/fig7-5.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-5.jpg)'
- en: '*Figure 7-5: An example program is read from memory and runs on the CPU.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：一个示例程序从内存中读取并在CPU上运行。*'
- en: The example program in [Figure 7-5](ch07.xhtml#ch7fig5) is written in *pseudocode*,
    a human-readable description of a program that’s not written in a real programming
    language. The steps in the program fall into the categories just described (memory
    access, arithmetic, logic, and program flow). In the first step, the program reads
    a number stored at a certain address in memory. The program then adds 3 to that
    number. It then performs a logical AND of two conditions. If the logical result
    is true, then the program does “this”; otherwise, it does “that.” Believe it or
    not, all programs are, in essence, simply various combinations of these types
    of fundamental operations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-5](ch07.xhtml#ch7fig5)中的示例程序是用*伪代码*编写的，这是一种人类可读的程序描述，但并不是用真实的编程语言编写的。程序中的步骤属于刚才描述的几类（内存访问、算术、逻辑和程序流程）。在第一步中，程序从内存中的某个地址读取一个数字。然后程序将3加到这个数字上。接着，它执行两个条件的逻辑与操作。如果逻辑结果为真，则程序执行“这个”；否则，执行“那个”。信不信由你，所有程序本质上只是这些基本操作的各种组合。'
- en: '***Instruction Set Architectures***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指令集架构***'
- en: 'Although all CPUs implement these types of instructions, the specific instructions
    available on different processors vary. Some instructions that exist for one type
    of CPU simply don’t exist on other types of CPUs. Even instructions that do exist
    on nearly all CPUs aren’t implemented in the same way. For example, the specific
    binary sequence used to mean “add two numbers” is not the same across processor
    types. A family of CPUs that use the same instructions are said to share an *instruction
    set architecture (ISA)*, or just *architecture*, a model of how a CPU works. Software
    that’s built for a certain ISA works on any CPU that implements that ISA. It’s
    possible for multiple processor models, even those from different manufacturers,
    to implement the same architecture. Such processors may work very differently
    internally, but by adhering to the same ISA, they can run the same software. Today,
    there are two prevalent instruction set architectures: x86 and ARM.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有 CPU 都实现了这些类型的指令，不同处理器上可用的具体指令是不同的。有些指令在某一类型的 CPU 上存在，但在其他类型的 CPU 上根本不存在。即使是几乎所有
    CPU 都有的指令，也不是以相同的方式实现的。例如，用于表示“加两个数字”的特定二进制序列，在不同的处理器类型之间并不相同。使用相同指令的 CPU 家族被称为共享
    *指令集架构（ISA）*，或者简称 *架构*，它是描述 CPU 如何工作的模型。为某个特定 ISA 开发的软件可以在任何实现该 ISA 的 CPU 上运行。多个处理器型号，即使来自不同的制造商，也有可能实现相同的架构。这些处理器可能在内部工作方式上有很大不同，但通过遵循相同的
    ISA，它们可以运行相同的软件。如今，存在两种流行的指令集架构：x86 和 ARM。
- en: The majority of desktop computers, laptops, and servers use x86 CPUs. The name
    comes from Intel Corporation’s naming convention for its processors (each ending
    in 86), beginning with the 8086 released in 1978, and continuing with the 80186,
    80286, 80386, and 80486\. After the 80486 (or more simply the 486), Intel began
    branding its CPUs with names such as Pentium and Celeron; these processors are
    still x86 CPUs despite the name change. Other companies besides Intel also produce
    x86 processors, notably Advanced Micro Devices, Inc. (AMD).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数桌面计算机、笔记本电脑和服务器都使用 x86 CPU。这个名字源自英特尔公司为其处理器制定的命名惯例（每个处理器型号都以 86 结尾），从 1978
    年发布的 8086 开始，一直到 80186、80286、80386 和 80486。继 80486（或者更简单地说是 486）之后，英特尔开始使用 Pentium
    和 Celeron 等品牌命名其 CPU；这些处理器尽管更名，但仍然是 x86 CPU。除了英特尔，其他公司也生产 x86 处理器，尤其是超威半导体公司（AMD）。
- en: The term *x86* refers to a set of related architectures. Over time, new instructions
    have been added to the x86 architecture, but each generation has tried to retain
    backward compatibility. This generally means that software developed for an older
    x86 CPU runs on a newer x86 CPU, but software built for a newer x86 CPU that takes
    advantage of new x86 instructions won’t be able to run on older x86 CPUs that
    don’t understand the new instructions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*x86* 这个术语指的是一组相关的架构。随着时间的推移，新的指令被加入到 x86 架构中，但每一代都试图保持向后兼容性。这通常意味着为较旧的 x86
    CPU 开发的软件可以在较新的 x86 CPU 上运行，但针对较新的 x86 CPU 开发的，利用新 x86 指令的软件将无法在不支持这些新指令的旧 x86
    CPU 上运行。'
- en: 'The x86 architecture includes three major generations of processors: 16-bit,
    32-bit, and 64-bit. Let’s pause to examine what we mean when we say that a CPU
    is a 16-bit, 32-bit, or 64-bit processor. The number of bits associated with a
    processor, also known as its *bitness* or *word size*, refers to the number of
    bits it can deal with at a time. So a 32-bit CPU can operate on values that are
    32 bits in length. More specifically, this means that the computer architecture
    has 32-bit registers, a 32-bit address bus, or a 32-bit data bus. Or all three
    may be 32-bit. We’ll cover more details on registers, data buses, and address
    buses later.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: x86 架构包括三代主要的处理器：16 位、32 位和 64 位。让我们停下来仔细分析一下，当我们说一个 CPU 是 16 位、32 位还是 64 位处理器时是什么意思。与处理器相关的位数，也称为
    *位宽* 或 *字长*，指的是处理器一次可以处理的位数。因此，一个 32 位的 CPU 可以处理 32 位长度的值。更具体地说，这意味着计算机架构有 32
    位寄存器、32 位地址总线或 32 位数据总线，或者这三者都是 32 位。我们稍后会详细讨论寄存器、数据总线和地址总线。
- en: Going back to x86 and its generations of processors, the original 8086 processor,
    released in 1978, was a 16-bit processor. Encouraged by the success of the 8086,
    Intel continued producing compatible processors. Intel’s subsequent x86 processors
    were also 16-bit until the 80386 processor was released in 1985, bringing with
    it a new 32-bit version of the x86 architecture. This 32-bit version of x86 is
    sometimes called IA-32\. Thanks to backward compatibility, modern x86 processors
    still fully support IA-32\. An example x86 processor is shown in [Figure 7-6](ch07.xhtml#ch7fig6).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 回到x86及其各代处理器，最初的8086处理器于1978年发布，是一款16位处理器。受到8086成功的鼓舞，Intel继续生产兼容的处理器。Intel后续的x86处理器也是16位，直到1985年发布80386处理器，这款处理器引入了新的32位x86架构。这个32位版本的x86有时被称为IA-32。得益于向后兼容性，现代x86处理器仍完全支持IA-32。一个x86处理器的例子见[图7-6](ch07.xhtml#ch7fig6)。
- en: Interestingly, it was AMD, and not Intel, that brought x86 into the 64-bit era.
    In the late 1990s, Intel’s 64-bit focus was on a new CPU architecture called IA-64
    or Itanium, which was *not* an x86 ISA, and ended up as a niche product for servers.
    With Intel focused on Itanium, AMD seized the opportunity to extend the x86 architecture.
    In 2003, AMD released the Opteron processor, the first 64-bit x86 CPU. AMD’s architecture
    was originally known as *AMD64*, and later Intel adopted this architecture and
    called its implementation *Intel 64*. The two implementations are mostly functionally
    identical, and today 64-bit x86 is generally referred to as *x64* or *x86-64*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，带领x86进入64位时代的是AMD，而非Intel。1990年代末，Intel的64位重点放在一种新CPU架构上，名为IA-64或Itanium，这种架构*并非*x86指令集架构（ISA），最终成为仅限服务器使用的小众产品。Intel专注于Itanium时，AMD抓住机会扩展了x86架构。2003年，AMD发布了Opteron处理器，这是第一个64位x86
    CPU。AMD的架构最初被称为*AMD64*，后来Intel也采用了这一架构，并将其实现命名为*Intel 64*。这两种实现大体上功能相同，如今64位x86通常被称为*x64*或*x86-64*。
- en: '![image](../images/fig7-6.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-6.jpg)'
- en: '*Figure 7-6: An Intel 486 SX, a 32-bit x86 processor*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：一款Intel 486 SX，32位x86处理器*'
- en: Although x86 rules the personal computer and server world, ARM processors command
    the realm of mobile devices like smartphones and tablets. Multiple companies manufacture
    ARM processors. A company called ARM Holdings develops the ARM architecture and
    licenses their designs to other companies to implement. It’s common for ARM CPUs
    to be used in *system-on-chip (SoC)* designs, where a single integrated circuit
    contains not only a CPU, but also memory and other hardware. The ARM architecture
    originated in the 1980s as a 32-bit ISA. A 64-bit version of the ARM architecture
    was introduced in 2011\. ARM processors are favored in mobile devices due to their
    reduced power consumption and lower cost as compared to x86 processors. ARM processors
    can be used in PCs as well, but that market largely remains focused on x86, to
    retain backward compatibility with existing x86 PC software. However, in 2020,
    Apple announced their intention to move macOS computers from x86 to ARM CPUs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管x86在个人计算机和服务器领域占据主导地位，ARM处理器却统治着智能手机和平板等移动设备的领域。多家公司生产ARM处理器。一家公司名为ARM Holdings，开发ARM架构并将其设计授权给其他公司实现。ARM
    CPU常被用于*系统级芯片（SoC）*设计中，其中一个集成电路不仅包含CPU，还包含内存和其他硬件。ARM架构起源于1980年代，是一个32位的指令集架构（ISA）。2011年，ARM架构推出了64位版本。由于ARM处理器在移动设备中相较于x86处理器具有更低的功耗和成本，因此更受青睐。ARM处理器也可以用于PC，但这一市场仍然主要集中在x86上，以保持与现有x86
    PC软件的向后兼容性。然而，2020年，苹果宣布将把其macOS电脑从x86转移到ARM CPU。
- en: '***CPU Internals***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***CPU内部结构***'
- en: 'Internally, a CPU consists of multiple components that work together to execute
    instructions. We’ll focus on three fundamental components: the processor registers,
    the arithmetic logic unit, and the control unit. *Processor registers* are locations
    within the CPU that hold data during processing. The *arithmetic logic unit (ALU)*
    performs logical and mathematical operations. The processor *control unit* directs
    the CPU, communicating with the processor registers, the ALU, and main memory.
    [Figure 7-7](ch07.xhtml#ch7fig7) shows a simplified view of CPU architecture.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，CPU由多个组件组成，这些组件共同工作以执行指令。我们将重点介绍三个基本组件：处理器寄存器、算术逻辑单元和控制单元。*处理器寄存器*是CPU内部存储数据的位置，数据在处理过程中保存在这里。*算术逻辑单元（ALU）*执行逻辑和数学运算。处理器的*控制单元*指挥CPU，负责与处理器寄存器、算术逻辑单元和主存进行通信。[图7-7](ch07.xhtml#ch7fig7)展示了CPU架构的简化视图。
- en: '![image](../images/fig7-7.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-7.jpg)'
- en: '*Figure 7-7: A greatly simplified view of CPU architecture*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：CPU 架构的一个大大简化的视图*'
- en: Let’s look at processor registers. Main memory holds data for an executing program.
    However, when a program needs to operate on a piece of data, the CPU needs a temporary
    place to store the data within the processor hardware. To accomplish this, CPUs
    have small internal storage locations known as processor registers, or just registers.
    Compared to accessing main memory, accessing registers is a very fast operation
    for a CPU, but registers can only hold very small amounts of data. We measure
    the size of an individual register in bits, not bytes, because registers are so
    small. As an example, a 32-bit CPU usually has registers that are 32 bits “wide,”
    meaning each register can hold 32 bits of data. The registers are implemented
    in a component known as the *register file* (not to be confused with a data file,
    such as a document or photo). The memory cells used in the register file are typically
    a type of SRAM.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下处理器寄存器。主内存存储正在执行程序的数据。然而，当程序需要对一块数据进行操作时，CPU 需要在处理器硬件中为数据提供一个临时存储位置。为此，CPU
    具有称为处理器寄存器的小型内部存储位置，或简称寄存器。与访问主内存相比，访问寄存器是 CPU 的一种非常快速的操作，但寄存器只能容纳非常少量的数据。我们用位而不是字节来衡量单个寄存器的大小，因为寄存器非常小。例如，一个
    32 位 CPU 通常具有 32 位“宽”的寄存器，这意味着每个寄存器可以容纳 32 位数据。这些寄存器由一个称为*寄存器文件*的组件实现（不要与数据文件，如文档或照片混淆）。寄存器文件中使用的存储单元通常是某种类型的
    SRAM。
- en: The ALU handles logic and math operations within the CPU. We previously covered
    combinational logic circuits, circuits in which the output is a function of the
    input. A processor’s ALU is just a complex combinational logic circuit. The ALU’s
    inputs are values called *operands*, and a code indicating what operation to perform
    on those operands. The ALU outputs the result of the operation along with a status
    that provides more detail on execution of the operation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ALU 负责 CPU 内部的逻辑和数学运算。我们之前讲解过组合逻辑电路，这些电路的输出是输入的一个函数。处理器的 ALU 就是一个复杂的组合逻辑电路。ALU
    的输入是称为*操作数*的值和一个表示要对这些操作数执行什么操作的代码。ALU 输出操作结果及一个状态，提供执行操作的更多细节。
- en: 'The control unit acts as the coordinator of the CPU. It works on a repeating
    cycle: fetch an instruction from memory, decode it, and execute it. Since a running
    program is stored in memory, the control unit needs to know which memory address
    to read in order to fetch the next instruction. The control unit determines this
    by looking at a register known as the *program counter (PC)*, also known as the
    *instruction pointer* on x86\. The program counter holds the memory address of
    the next instruction to execute. The control unit reads the instruction from the
    specified memory address, stores the instruction in a register called the *instruction
    register*, and updates the program counter to point to the next instruction. The
    control unit then decodes the current instruction, making sense of the 1s and
    0s that represent an instruction. Once decoded, the control unit executes the
    instruction, which may require coordinating with other components in the CPU.
    For example, execution of an addition operation requires the control unit to instruct
    the ALU to perform the needed math. Once an instruction has completed, the control
    unit repeats the cycle: fetch, decode, execute.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 控制单元充当 CPU 的协调者。它以一个循环重复执行：从内存中获取指令，解码指令，然后执行指令。由于正在运行的程序存储在内存中，控制单元需要知道读取哪个内存地址才能获取下一条指令。控制单元通过查看一个称为*程序计数器（PC）*的寄存器来确定这一点，在
    x86 架构上也叫做*指令指针*。程序计数器保存下一条要执行的指令的内存地址。控制单元从指定的内存地址读取指令，将指令存储到一个称为*指令寄存器*的寄存器中，并更新程序计数器以指向下一条指令。然后，控制单元解码当前指令，理解表示指令的
    1 和 0。一旦解码完成，控制单元执行该指令，这可能需要与 CPU 中的其他组件协调。例如，执行加法操作时，控制单元需要指示 ALU 执行所需的数学运算。指令执行完毕后，控制单元重复这一循环：获取、解码、执行。
- en: '***Clock, Cores, and Cache***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***时钟、核心与缓存***'
- en: Since CPUs execute ordered sets of instructions, you may wonder what causes
    a CPU to progress from one instruction to the next. We previously demonstrated
    how a clock signal can be used to move a circuit from one state to another, such
    as in a counter circuit. The same principle applies here. A CPU takes an input
    clock signal, as illustrated in [Figure 7-8](ch07.xhtml#ch7fig8), and a clock
    pulse acts as a signal to the CPU to transition between states.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CPU执行的是有序的指令集，你可能会想知道是什么导致CPU从一条指令跳转到下一条指令。我们之前已经演示了如何利用时钟信号使电路从一个状态转换到另一个状态，比如在计数器电路中。相同的原理也适用于这里。CPU接收输入的时钟信号，如[图
    7-8](ch07.xhtml#ch7fig8)所示，时钟脉冲作为信号，指示CPU在状态之间进行转换。
- en: '![image](../images/fig7-8.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-8.jpg)'
- en: '*Figure 7-8: A clock provides an oscillating signal to the CPU.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：时钟为CPU提供震荡信号。*'
- en: It’s an oversimplification to think that a CPU executes exactly one instruction
    per clock cycle. Some instructions take multiple cycles to complete. Also, modern
    CPUs use an approach called *pipelining* to divide instructions into smaller steps
    so that portions of multiple instructions can be run in parallel by a single processor.
    For example, one instruction can be fetched while another is decoded and yet another
    is executed. Still, it can be helpful to think of each pulse of the clock as a
    signal to the CPU to move forward with executing a program. Modern CPUs have clock
    speeds measured in *gigahertz (GHz)*. For example, a 2GHz CPU has a clock that
    oscillates at 2 *billion* cycles per second!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 认为CPU每个时钟周期执行恰好一条指令是一种过于简单化的看法。有些指令需要多个周期才能完成。此外，现代CPU采用了一种叫做*pipelining（流水线技术）*的方法，将指令分解成更小的步骤，这样多个指令的部分可以由单个处理器并行执行。例如，当一条指令正在解码时，另一条指令可以被获取，而第三条指令可以被执行。尽管如此，考虑到每个时钟脉冲都可以作为指示CPU向前执行程序的信号，依然是有帮助的。现代CPU的时钟频率以*吉赫兹（GHz）*为单位。例如，一颗2GHz的CPU时钟每秒会震荡2*十亿*次！
- en: Increasing the frequency of the clock allows a CPU to perform more instructions
    per second. Unfortunately, we can’t just run a CPU at an arbitrarily high clock
    rate. CPUs have a practical upper limit on their input clock frequency, and pushing
    a CPU beyond that limit leads to excessive heat generation. Also, the CPU’s logic
    gates may not be able to keep up, causing unexpected errors and crashes. For many
    years, the computer industry saw steady increases in the upper limit of clock
    rates for CPUs. This clock rate increase was largely due to regular improvements
    in manufacturing processes that led to increased transistor density, which allowed
    for CPUs with higher clock rates but roughly the same power consumption. In 1978,
    the Intel 8086 ran at 5MHz, and by 1999, the Intel Pentium III had a 500MHz clock,
    a 100x increase in only about 20 years! CPU clock rates continued to increase
    rapidly until the 3GHz threshold was crossed in the early 2000s. Since then, despite
    continued growth in transistor count, physical limitations associated with diminutive
    transistor sizes have made significant increases to clock rate impractical.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 增加时钟频率可以让CPU每秒执行更多的指令。不幸的是，我们不能让CPU在任意高的时钟频率下运行。CPU对输入时钟频率有实际的上限，超过该限制会导致过多的热量产生。而且，CPU的逻辑门可能无法跟上，导致意外的错误和崩溃。多年来，计算机行业见证了CPU时钟频率上限的稳步提升。这一增长主要得益于制造工艺的持续改进，提升了晶体管的密度，使得CPU能够在功耗几乎不变的情况下，提供更高的时钟频率。1978年，英特尔8086的时钟频率为5MHz，而到了1999年，英特尔奔腾III的时钟频率达到了500MHz，20年内增长了100倍！直到2000年代初，CPU时钟频率持续快速增长，突破了3GHz的门槛。从那时起，尽管晶体管数量继续增长，但与微小晶体管尺寸相关的物理限制使得时钟频率的大幅提升变得不再实际。
- en: With clock rates stagnant, the processor industry turned to a new approach for
    getting more work out of a CPU. Rather than focusing on increasing clock frequency,
    CPU design began to focus on execution of multiple instructions in parallel. The
    idea of a *multicore* CPU was introduced, a CPU with multiple processing units
    called *cores*. A *CPU core* is effectively an independent processor that resides
    alongside other independent processors in a single CPU package, as illustrated
    in [Figure 7-9](ch07.xhtml#ch7fig9).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于时钟频率停滞不前，处理器行业转向了一种新方法来提高CPU的工作效率。与其专注于增加时钟频率，CPU设计开始聚焦于并行执行多条指令。*多核*CPU的概念应运而生，这是一种拥有多个处理单元，称为*核心*的CPU。*CPU核心*实际上是一个独立的处理器，和其他独立的处理器共同存在于单一的CPU封装中，如[图
    7-9](ch07.xhtml#ch7fig9)所示。
- en: '![image](../images/fig7-9.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-9.jpg)'
- en: '*Figure 7-9: A four-core CPU—each core has its own registers, ALU, and control
    unit*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：四核 CPU——每个核心都有自己的寄存器、算术逻辑单元和控制单元*'
- en: Note that multiple cores running in parallel is not the same as pipelining.
    The parallelism of multicore means that each core works on a different task, a
    separate set of instructions. In contrast, pipelining happens *within* each core,
    allowing portions of multiple instructions to be executed in parallel by a single
    core.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，多个核心并行运行不同于流水线处理。多核并行意味着每个核心处理不同的任务，即一组独立的指令。与此不同，流水线处理发生在*每个*核心内部，允许多个指令的部分在同一个核心上并行执行。
- en: Each core added to a processor opens the door to a computer running additional
    instructions in parallel. That said, adding multiple cores to a computer’s CPU
    doesn’t mean all applications benefit immediately or equally. Software must be
    written to take advantage of parallel processing of instructions to get the maximum
    benefit of multicore hardware. However, even if individual programs aren’t designed
    with parallelism in mind, a computer system as a whole can benefit, since modern
    operating systems run multiple programs at once.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每增加一个核心到处理器，就意味着计算机可以并行运行更多指令。也就是说，向计算机的 CPU 添加多个核心并不意味着所有应用程序都会立即或均等地受益。软件必须被编写以充分利用指令的并行处理，才能最大限度地发挥多核硬件的优势。然而，即使单个程序没有针对并行性进行设计，计算机系统整体也能受益，因为现代操作系统会同时运行多个程序。
- en: I’ve previously described how CPUs load data from main memory into registers
    for processing and then store that data back from registers to memory for later
    use. It turns out that programs tend to access the same memory locations over
    and over. As you might expect, going back to main memory multiple times to access
    the same data is inefficient! To avoid this inefficiency, a small amount of memory
    resides within the CPU that holds a copy of data frequently accessed from main
    memory. This memory is known as a *CPU cache*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前描述过 CPU 如何从主存储器加载数据到寄存器中进行处理，然后再将数据从寄存器存回内存以备后用。事实证明，程序往往会反复访问相同的内存位置。正如你可能预料的那样，多次从主存取回相同的数据是低效的！为了避免这种低效，在
    CPU 内部有一小块内存，用于存储频繁访问的主存数据副本。这块内存被称为*CPU 缓存*。
- en: The processor checks the cache to see if data it wishes to access is there.
    If so, the processor can speed things up by reading or writing to the cache rather
    than to main memory. When needed data is not in the cache, the processor can move
    that data into cache once it has been read from main memory. It’s common for processors
    to have multiple cache levels, often three. We refer to these cache levels as
    L1 cache, L2 cache, and L3 cache. A CPU first checks L1 for the needed data, then
    L2, then L3, before finally going to main memory, as illustrated in [Figure 7-10](ch07.xhtml#ch7fig10).
    L1 cache is the fastest to access, but it’s also the smallest. L2 is slower and
    larger, and L3 is slower and larger still. Remember that even with these progressively
    slower levels of cache, it is still slower to access main memory than any level
    of cache.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器检查缓存，以查看它希望访问的数据是否已经在其中。如果是这样，处理器可以通过读取或写入缓存来加速操作，而不是直接访问主存。当所需数据不在缓存中时，处理器可以在从主存读取数据后，将其移动到缓存中。现代处理器通常具有多个缓存级别，通常有三级。我们将这些缓存级别分别称为
    L1 缓存、L2 缓存和 L3 缓存。CPU 首先检查 L1 缓存是否有所需的数据，然后是 L2，再是 L3，最后才是主存，如[图 7-10](ch07.xhtml#ch7fig10)所示。L1
    缓存访问速度最快，但也最小。L2 缓存较慢且较大，而 L3 缓存则更慢且更大。请记住，即使是这些逐渐变慢的缓存级别，访问主存的速度仍然比访问任何缓存级别都要慢。
- en: '![image](../images/fig7-10.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-10.jpg)'
- en: '*Figure 7-10: A single-core CPU with three levels of cache*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：具有三级缓存的单核 CPU*'
- en: In multicore CPUs, some caches are specific to each core, whereas others are
    shared among the cores. For example, each core may have its own L1 cache, whereas
    the L2 and L3 caches are shared, as shown in [Figure 7-11](ch07.xhtml#ch7fig11).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在多核 CPU 中，一些缓存是每个核心特有的，而另一些则在各个核心之间共享。例如，每个核心可能有自己的 L1 缓存，而 L2 和 L3 缓存是共享的，如[图
    7-11](ch07.xhtml#ch7fig11)所示。
- en: '![image](../images/fig7-11.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-11.jpg)'
- en: '*Figure 7-11: A two-core CPU with cache. Each core has its own L1 cache, whereas
    L2 and L3 caches are shared.*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-11：具有缓存的双核 CPU。每个核心都有自己的 L1 缓存，而 L2 和 L3 缓存是共享的。*'
- en: '**Beyond Memory and Processor**'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**超越内存和处理器**'
- en: 'I have outlined the two fundamental components required for a computer: memory
    and a processor. However, a device that consists of only memory and a processor
    has a couple of gaps that need to be filled if we want a useful device. The first
    gap is that both memory and CPUs are volatile; they lose state when power is removed.
    The second gap is that a computer with only memory and a processor has no way
    of interacting with the outside world. Let’s now see how secondary storage and
    I/O devices fill these gaps.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经概述了计算机所需的两个基本组件：内存和处理器。然而，如果一台设备仅由内存和处理器组成，仍然存在一些需要填补的空白，以便我们能够得到一台实用的设备。第一个空白是内存和CPU都是易失性的；当电源断开时，它们会丧失状态。第二个空白是，仅有内存和处理器的计算机无法与外界进行交互。现在让我们来看一下辅助存储和I/O设备如何填补这些空白。
- en: '***Secondary Storage***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***辅助存储***'
- en: If a computer only included memory and a processor, then every time that device
    was powered down, it would lose all its data! To emphasize that point, *data*
    here means not only a user’s files and settings, but also any installed applications,
    and even the operating system itself. This rather inconvenient computer would
    require someone to load the OS and any applications every time it was powered
    on. That might discourage users from ever turning it off. Believe it or not, computers
    in previous generations did work this way, but fortunately that isn’t the case
    today.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算机仅包含内存和处理器，那么每次设备断电时，它都会丢失所有数据！为了强调这一点，这里的*数据*不仅仅指用户的文件和设置，还包括任何已安装的应用程序，甚至操作系统本身。这样一台相当不便的计算机会要求每次开机时都需要加载操作系统和任何应用程序。这可能会让用户不愿意关闭设备。信不信由你，过去几代计算机确实是这样工作的，但幸运的是，今天的计算机不再如此。
- en: To address this problem, computers have secondary storage. *Secondary storage*
    is nonvolatile and therefore remembers data even when the system is powered down.
    Unlike RAM, secondary storage is not directly addressable by the CPU. Such storage
    is usually much cheaper per byte than RAM, allowing for a large capacity of storage
    as compared to main memory. However, secondary storage is also considerably slower
    than RAM; it isn’t a suitable replacement for main memory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，计算机使用辅助存储。*辅助存储*是非易失性的，因此即使系统断电，它也能记住数据。与RAM不同，辅助存储不能直接被CPU寻址。这类存储通常比RAM便宜得多，每字节的价格较低，使得与主内存相比，辅助存储可以提供更大的容量。然而，辅助存储的速度也比RAM慢得多；它不能作为主内存的替代品。
- en: In modern computing devices, hard disk drives and solid-state drives are the
    most common secondary storage devices. A *hard disk drive (HDD)* stores data using
    magnetism on a rapidly spinning platter, whereas a *solid-state drive (SSD)* stores
    data using electrical charges in nonvolatile memory cells. Compared to HDDs, SSDs
    are faster, quieter, and more resistant to mechanical failure, since SSDs have
    no moving parts. [Figure 7-12](ch07.xhtml#ch7fig12) is a photo of a couple of
    secondary storage devices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算设备中，硬盘驱动器和固态硬盘是最常见的辅助存储设备。*硬盘驱动器（HDD）*通过在快速旋转的盘片上利用磁性存储数据，而*固态硬盘（SSD）*则通过在非易失性存储单元中利用电荷存储数据。与HDD相比，SSD速度更快、更安静、且对机械故障更具抵抗力，因为SSD没有任何活动部件。[图
    7-12](ch07.xhtml#ch7fig12)是几种辅助存储设备的照片。
- en: With a secondary storage device in place, a computer can load data on demand.
    When a computer is powered on, the operating system loads from secondary storage
    into main memory; any applications that are set to run at startup also load. After
    startup, when an application is launched, program code loads from secondary storage
    into main memory. The same goes for any user data (documents, music, settings,
    and so on) stored locally; it must load from secondary storage into main memory
    before it can be used. In common usage, secondary storage is often referred to
    simply as storage, while primary storage/main memory is just called memory or
    RAM.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有了辅助存储设备，计算机可以按需加载数据。当计算机开机时，操作系统从辅助存储加载到主内存；任何设置为在启动时运行的应用程序也会加载。启动后，当应用程序被启动时，程序代码会从辅助存储加载到主内存。任何本地存储的用户数据（如文档、音乐、设置等）也是如此；它必须从辅助存储加载到主内存才能使用。在常见用法中，辅助存储通常简称为存储，而主存储/主内存则直接称为内存或RAM。
- en: '![image](../images/fig7-12.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-12.jpg)'
- en: '*Figure 7-12: A 4GB hard disk drive from 1997 beside a modern 32GB microSD
    card, a type of solid-state storage*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：1997年款的4GB硬盘驱动器与现代32GB microSD卡（固态存储的一种类型）并排展示*'
- en: '***Input/Output***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***输入/输出***'
- en: Even with secondary storage in place, our hypothetical computer still has a
    problem. A computer consisting of a processor, memory, and storage doesn’t have
    any way of interacting with the outside world! This is where input/output devices
    come in. An *input/output (I/O) device* is a component that allows a computer
    to receive input from the outside world (keyboard, mouse), send data to the outside
    world (monitor, printer), or both (touchscreen). Human interaction with a computer
    requires going through I/O. Computer-to-computer interaction also requires going
    through I/O, often in the form of a computer network, such as the internet. Secondary
    storage devices are actually a type of I/O device. You may not think of accessing
    internal storage as I/O, but from the perspective of the CPU, reading or writing
    to storage is just another I/O operation. Reading from the storage device is input,
    while writing to the storage device is output. [Figure 7-13](ch07.xhtml#ch7fig13)
    provides some examples of input and output.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了二级存储，我们假设的计算机仍然存在问题。一个由处理器、内存和存储组成的计算机并没有与外部世界进行交互的方式！这就是输入/输出设备的作用。*输入/输出（I/O）设备*是一个组件，允许计算机接收来自外部世界的输入（键盘、鼠标）、向外部世界发送数据（显示器、打印机），或者两者都做（触摸屏）。人类与计算机的交互需要通过I/O。计算机之间的交互也需要通过I/O，通常是通过计算机网络，如互联网。二级存储设备实际上是一种I/O设备。你可能不会认为访问内部存储是I/O操作，但从CPU的角度来看，读写存储只是另一个I/O操作。从存储设备读取数据是输入，而写入存储设备则是输出。[图
    7-13](ch07.xhtml#ch7fig13)提供了一些输入和输出的示例。
- en: '![image](../images/fig7-13.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-13.jpg)'
- en: '*Figure 7-13: Common types of input and output*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：常见的输入和输出类型*'
- en: So how does a CPU go about communicating with I/O devices? A computer can have
    a wide variety of I/O devices attached to it, and the CPU needs a standard way
    to communicate with any such device. To understand this, we need to first discuss
    *physical address space*, the range of hardware memory addresses available to
    a computer. Earlier in this chapter, in the section entitled “Main Memory” on
    [page 119](ch07.xhtml#page_119), we covered how bytes of memory are assigned an
    address. All memory addresses on a given computer system will be represented with
    a certain number of bits. That number of bits determines not only the size of
    each memory address, but also the range of addresses available for the computer
    hardware to use—the physical address space. Address space is often larger than
    the amount of RAM installed on a computer, leaving some physical memory addresses
    unused.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，CPU是如何与I/O设备进行通信的呢？计算机可以连接多种多样的I/O设备，而CPU需要一种标准的方式与这些设备进行通信。要理解这一点，我们首先需要讨论*物理地址空间*，即计算机可用的硬件内存地址范围。在本章的“主存储器”一节中，[第119页](ch07.xhtml#page_119)介绍了内存字节如何分配地址。计算机系统上的所有内存地址将使用一定数量的位来表示。这个位数不仅决定了每个内存地址的大小，还决定了计算机硬件可用地址的范围——物理地址空间。地址空间通常比计算机上安装的RAM容量大，因此会有一些物理内存地址未被使用。
- en: To give an example, in the case of a computer with a 32-bit physical address
    space, the physical address range is from 0x00000000 to 0xFFFFFFFF (the largest
    address that can be represented with a 32-bit number). That’s approximately 4
    billion addresses, each representing a single byte, or 4GB of address space. Let’s
    say that this computer has 3GB of RAM, so 75 percent of the available physical
    memory addresses are assigned to bytes of RAM.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，对于一台具有32位物理地址空间的计算机，其物理地址范围是从0x00000000到0xFFFFFFFF（这是用32位数字表示的最大地址）。这大约是40亿个地址，每个地址表示一个字节，或者4GB的地址空间。假设这台计算机有3GB的RAM，那么可用的物理内存地址的75%被分配给了RAM字节。
- en: Now let’s return to the question of how CPUs communicate with I/O devices. Addresses
    in physical address space don’t always refer to bytes of memory; they can also
    refer to an I/O device. When physical address space is mapped to an I/O device,
    the CPU can communicate with that device just by reading or writing to its assigned
    memory address(es); this is called *memory-mapped I/O (MMIO)* and is illustrated
    in [Figure 7-14](ch07.xhtml#ch7fig14). When a computer treats the memory of I/O
    devices just like main memory, its CPU does not need any special instructions
    for I/O operations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到CPU如何与I/O设备通信的问题。物理地址空间中的地址并不总是指向内存字节；它们也可以指向I/O设备。当物理地址空间映射到I/O设备时，CPU可以通过读取或写入其分配的内存地址来与该设备通信；这称为*内存映射I/O
    (MMIO)*，如[图7-14](ch07.xhtml#ch7fig14)所示。当计算机像对待主内存一样对待I/O设备的内存时，CPU无需任何特殊指令进行I/O操作。
- en: However, some CPU families, notably x86, do include special instructions for
    accessing I/O devices. When computers use this approach, rather than mapping I/O
    devices to a physical memory address, devices are assigned an *I/O port*. A port
    is like a memory address, but instead of referring to a location in memory, the
    port number refers to an I/O device. You can think of the set of I/O ports as
    just another address space, distinct from memory addresses. This means that port
    0x378 does not refer to the same thing as physical memory address 0x378\. Accessing
    I/O devices through a separate port address space is known as *port-mapped I/O
    (PMIO)*. Today’s x86 CPUs support both port-mapped and memory-mapped I/O.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些CPU家族，特别是x86，确实包括用于访问I/O设备的特殊指令。当计算机采用这种方法时，设备不会映射到物理内存地址，而是分配一个*I/O端口*。端口就像内存地址，但它不是指向内存中的某个位置，而是指向I/O设备。你可以将I/O端口的集合视为一个与内存地址不同的地址空间。这意味着端口0x378并不指向物理内存地址0x378。通过单独的端口地址空间访问I/O设备被称为*端口映射I/O
    (PMIO)*。今天的x86 CPU支持端口映射I/O和内存映射I/O两种方式。
- en: I/O ports and memory-mapped I/O addresses generally refer to a device controller
    rather than directly to data stored on the device. For example, in the case of
    a hard disk drive, the bytes of the disk aren’t directly mapped into address space.
    Instead, a hard drive controller presents an interface, accessible through I/O
    ports or memory-mapped I/O addresses, that allows the CPU to request read or write
    operations to locations on the disk.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: I/O端口和内存映射I/O地址通常指的是设备控制器，而不是直接指向存储在设备上的数据。例如，在硬盘驱动器的情况下，磁盘的字节并不是直接映射到地址空间中的。相反，硬盘控制器提供了一个接口，可以通过I/O端口或内存映射I/O地址访问，该接口允许CPU请求对磁盘上的位置进行读写操作。
- en: '![image](../images/fig7-14.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-14.jpg)'
- en: '*Figure 7-14: Memory-mapped I/O*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-14：内存映射I/O*'
- en: '**EXERCISE 7-2: GET TO KNOW THE HARDWARE DEVICES IN YOUR LIFE**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习7-2：了解你生活中的硬件设备**'
- en: Choose a couple of computing devices that you own or use—say a laptop, smartphone,
    or game console. Answer the following questions about each device. You may be
    able to find the answers by looking at the settings on the device itself, or you
    may have to do some research online.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你拥有或使用的几台计算设备——比如笔记本电脑、智能手机或游戏机。回答以下关于每台设备的问题。你可以通过查看设备本身的设置来找到答案，或者可能需要在线进行一些研究。
- en: What kind of CPU does the device have?
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该设备使用的是什么类型的CPU？
- en: Is the CPU 32-bit or 64-bit (or something else)?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU是32位还是64位（或其他）？
- en: What’s the CPU clock frequency?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU的时钟频率是多少？
- en: Does the CPU have L1, L2, or L3 cache? If so, how much?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU是否有L1、L2或L3缓存？如果有，是多少？
- en: Which instruction set architecture does the CPU use?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU使用哪种指令集架构？
- en: How many cores does the CPU have?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU有多少个核心？
- en: How much and what kind of main memory does the device have?
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该设备有多少内存？是什么类型的主内存？
- en: How much and what kind of secondary storage does the device have?
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该设备拥有多少存储空间，是什么类型的二级存储？
- en: What I/O devices does the device have?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该设备有哪些I/O设备？
- en: '**Bus Communication**'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总线通信**'
- en: At this point, we’ve covered the roles of memory, the CPU, and I/O devices in
    a computer. We’ve also touched on the CPU’s communication with both memory and
    I/O devices through memory address space. Let’s take a closer look at how the
    CPU communicates with memory and I/O devices.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讲解了内存、CPU和I/O设备在计算机中的作用。我们还讨论了CPU如何通过内存地址空间与内存和I/O设备通信。接下来，让我们更深入地看看CPU如何与内存和I/O设备进行通信。
- en: A *bus* is a hardware communication system used by computer components. There
    are multiple bus implementations, but in the early days of computers, a bus was
    simply a set of parallel wires, each carrying an electrical signal. This allowed
    multiple bits of data to be transferred in parallel; the voltage on each wire
    represented a single bit. Today’s bus designs aren’t always that simple, but the
    intent is similar.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*总线*是计算机组件之间用于硬件通信的系统。总线有多种实现方式，但在计算机早期，总线只是由一组并行电线组成，每根电线传输一个电信号。这使得多个数据位可以并行传输；每根电线上的电压代表一个单独的位。今天的总线设计不总是那么简单，但其目的依然相似。'
- en: There are three common bus types used in communication between the CPU, memory,
    and I/O devices. An *address bus* acts as a selector for the memory address that
    the CPU wishes to access. For example, if a program wishes to write to address
    0x2FE, the CPU writes 0x2FE to the address bus. The *data bus* transmits a value
    read from memory or a value to be written to memory. So if the CPU wishes to write
    the value 25 to memory, then 25 is written to the data bus. Or if the CPU is reading
    data from memory, the CPU reads the value from the data bus. Finally, a *control
    bus* manages the operations happening over the other two buses. As examples, the
    CPU uses the control bus to indicate that a write operation is about to happen,
    or the control bus can carry a signal indicating the status of an operation. [Figure
    7-15](ch07.xhtml#ch7fig15) illustrates how a CPU uses the address bus, data bus,
    and control bus to read memory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPU、内存和I/O设备之间的通信中，有三种常见的总线类型。*地址总线*作为CPU希望访问的内存地址的选择器。例如，如果程序希望写入地址0x2FE，CPU会将0x2FE写入地址总线。*数据总线*传输从内存读取的值或要写入内存的值。因此，如果CPU希望将值25写入内存，那么25将被写入数据总线。或者如果CPU正在从内存中读取数据，CPU则从数据总线上读取该值。最后，*控制总线*管理其他两个总线上的操作。例如，CPU使用控制总线来指示即将进行写入操作，或者控制总线可以传输指示操作状态的信号。[图7-15](ch07.xhtml#ch7fig15)展示了CPU如何使用地址总线、数据总线和控制总线来读取内存。
- en: '![image](../images/fig7-15.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7-15.jpg)'
- en: '*Figure 7-15: The CPU requests a read of the value at address 3F4, and the
    value of 84 is returned.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-15：CPU请求读取地址3F4处的值，返回的值是84。*'
- en: In the example shown in [Figure 7-15](ch07.xhtml#ch7fig15), the CPU needs to
    read the value stored at memory address 000003F4\. To do this, the CPU writes
    000003F4 to the address bus. The CPU also sets a certain value on the control
    bus, indicating that it wishes to perform a read operation. These bus updates
    act as inputs to the memory controller (the circuit that manages interactions
    with main memory), telling it that the CPU wishes to read the value stored at
    address 000003F4 in main memory. In response, the memory controller retrieves
    the value stored at address 000003F4 (84 in this example) and writes it to the
    data bus, which the CPU can then read.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-15](ch07.xhtml#ch7fig15)中显示的示例中，CPU需要读取存储在内存地址000003F4处的值。为此，CPU将000003F4写入地址总线。CPU还会在控制总线上设置一个特定的值，表示它希望执行读取操作。这些总线更新作为输入传递给内存控制器（管理与主内存交互的电路），告诉它CPU希望读取主内存中地址000003F4处存储的值。作为响应，内存控制器从地址000003F4处检索存储的值（在此示例中为84），并将其写入数据总线，CPU可以从数据总线上读取这个值。
- en: '**Summary**'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this chapter, we covered computer hardware: a central processing unit (CPU)
    to execute instructions, random access memory (RAM) that stores instructions and
    data while powered, and input/output (I/O) devices that interact with the outside
    world. You learned that memory is composed of single-bit memory cells, implemented
    with a type of flip-flop in SRAM, and with a transistor and capacitor in DRAM.
    We covered how memory addressing works, where each address refers to a byte of
    memory. You learned about CPU architectures, including x86 and ARM. We explored
    how CPUs work internally, looking at registers, the ALU, and the control unit.
    We covered secondary storage and other types of I/O, and finally, we looked at
    bus communication.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容涵盖了计算机硬件：中央处理单元（CPU）用于执行指令，随机存取存储器（RAM）在通电时存储指令和数据，输入/输出（I/O）设备与外界交互。你学到了内存由单一比特的内存单元组成，这些单元在SRAM中通过一种触发器实现，在DRAM中通过晶体管和电容实现。我们讲解了内存寻址的工作原理，其中每个地址指向一个字节的内存。你了解了CPU架构，包括x86和ARM架构。我们探索了CPU内部的工作方式，查看了寄存器、算术逻辑单元（ALU）和控制单元。我们还讨论了二级存储和其他类型的I/O，最后，我们讲解了总线通信。
- en: In the next chapter, we’ll move beyond hardware to the thing that makes computers
    unique among devices—software. We’ll examine the low-level instructions that processors
    execute, and we’ll see how those instructions can be combined to perform useful
    operations. You’ll have the opportunity to write software in assembly language
    and use a debugger to explore machine code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将超越硬件，探讨使计算机在各种设备中独具特色的东西——软件。我们将研究处理器执行的低级指令，并且看到这些指令如何组合以执行有用的操作。你将有机会使用汇编语言编写软件，并使用调试器探索机器代码。
