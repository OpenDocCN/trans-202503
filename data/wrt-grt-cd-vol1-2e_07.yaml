- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: BOOLEAN LOGIC AND DIGITAL DESIGN**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔逻辑与数字设计**
- en: '![Image](../images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/comm1.jpg)'
- en: Boolean logic is the basis of computation in modern computer systems. You can
    represent any algorithm, or any electronic computer circuit, using a system of
    Boolean equations. To fully understand how software operates, then, you need to
    understand basic Boolean logic and digital design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔逻辑是现代计算机系统中计算的基础。你可以使用布尔方程系统表示任何算法或任何电子计算机电路。因此，要充分理解软件如何运作，你需要理解基本的布尔逻辑和数字设计。
- en: This material is especially important to those who want to design electronic
    circuits or write software that controls them. Even if you don’t plan to do this,
    you can use your knowledge of Boolean logic to optimize your software. Many high-level
    languages process Boolean expressions, such as those that control an `if` statement
    or `while` loop. Understanding Boolean logic provides the tools you need to optimize
    your Boolean expressions and improve the performance of HLL code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容对那些想设计电子电路或编写控制它们的软件的人尤其重要。即使你不打算做这些，你仍然可以利用布尔逻辑的知识来优化你的软件。许多高级语言处理布尔表达式，如控制
    `if` 语句或 `while` 循环的表达式。理解布尔逻辑为你提供了优化布尔表达式并提高HLL代码性能所需的工具。
- en: 'This chapter covers the following subjects, which will aid you when you attempt
    to optimize Boolean expressions:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容，这些内容将帮助你在优化布尔表达式时提供帮助：
- en: Boolean algebra, Boolean operators, and Boolean functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔代数、布尔运算符和布尔函数
- en: An introduction to Boolean postulates and theorems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔公理与定理的介绍
- en: Truth tables and Boolean function optimization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真值表与布尔函数优化
- en: Canonical forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范形式
- en: Electronic circuits and their Boolean function counterparts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子电路及其布尔函数对照
- en: Although a detailed knowledge of Boolean algebra and digital circuit design
    isn’t necessary if you simply want to write typical programs, familiarity with
    these topics will help answer why CPU manufacturers implement instructions in
    certain ways—questions that will undoubtedly arise as we begin looking at the
    CPU’s low-level implementation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果你只是想编写典型的程序，布尔代数和数字电路设计的详细知识并非必需，但熟悉这些主题将有助于回答为什么CPU制造商以某种方式实现指令的问题——这些问题无疑会在我们开始研究CPU的低级实现时出现。
- en: '**8.1 Boolean Algebra**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**8.1 布尔代数**'
- en: Boolean algebra is a deductive mathematical system. A *binary operator* (°)
    accepts a pair of Boolean inputs and produces a single Boolean value. For example,
    the Boolean AND operator accepts two Boolean inputs and produces a single Boolean
    output (the logical AND of the two inputs).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数是一个演绎的数学系统。*二元运算符*（°）接受一对布尔输入并生成一个布尔输出。例如，布尔与运算符接受两个布尔输入并生成一个布尔输出（两个输入的逻辑与运算）。
- en: '***8.1.1 The Boolean Operators***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***8.1.1 布尔运算符***'
- en: 'For our purposes, we will base Boolean algebra on the following set of values
    and operators:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们将布尔代数基于以下一组值和运算符：
- en: The two possible values in the Boolean system are 0 and 1\. Often, we call these
    values `false` and `true`, respectively.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔系统中的两个可能的值是0和1。通常，我们分别称这些值为`false`和`true`。
- en: The • symbol represents the logical AND operation. *A* • *B* is the operation
    of logically ANDing the Boolean values *A* and *B*, also known as the *product*
    of *A* and *B*. For single-letter variable names, this text drops the • symbol;
    therefore, *AB* also represents the logical AND of the variables *A* and *B*.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 符号表示逻辑与运算。*A* • *B* 是对布尔值 *A* 和 *B* 进行逻辑与运算的操作，也称为 *A* 和 *B* 的 *积*。对于单字母变量名，本文省略了•符号；因此，*AB*
    也表示变量 *A* 和 *B* 的逻辑与。
- en: The + (plus sign) represents the logical OR operation. *A* + *B* is the result
    of logically ORing the Boolean values *A* and *B*. We also call this the *sum*
    of *A* and *B*.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +（加号）表示逻辑或运算。*A* + *B* 是对布尔值 *A* 和 *B* 进行逻辑或运算的结果。我们也称之为 *A* 和 *B* 的 *和*。
- en: Logical complement, logical negation, and NOT are all names for the same unary
    operator. This chapter will use the ' (prime symbol) to denote logical negation.
    *A'* denotes the logical NOT of *A*.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑补数、逻辑否定和NOT是同一个一元运算符的不同名称。本章将使用'（撇号符号）来表示逻辑否定。*A'* 表示 *A* 的逻辑非。
- en: '***8.1.2 Boolean Postulates***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***8.1.2 布尔公理***'
- en: 'Every algebraic system follows a certain set of initial assumptions, or *[postulates](gloss01.xhtml#gloss01_198)*.
    You can deduce additional rules, theorems, and other properties of the system
    from this basic set of postulates. Boolean algebra employs the following postulates:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代数系统都遵循一组特定的初始假设，或 *[公理](gloss01.xhtml#gloss01_198)*。你可以从这一基本公理集中推导出额外的规则、定理和其他系统特性。布尔代数采用以下公理：
- en: '**Closure** A Boolean system is *closed* with respect to a particular binary
    operator if, for every pair of Boolean values, it produces only a Boolean result.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭包** 如果对于每一对布尔值，布尔系统在特定的二元运算符下只产生布尔结果，则该布尔系统对该运算符是 *闭包* 的。'
- en: '**Commutativity** A binary operator ° is *commutative* if *A* ° *B* = *B* °
    *A* for all possible Boolean values *A* and *B*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**交换律** 如果对于所有可能的布尔值 *A* 和 *B*，*A* ° *B* = *B* ° *A*，则二元运算符 ° 是 *交换律* 的。'
- en: '**Associativity** A binary operator ° is *associative* if (*A* ° *B*) ° *C*
    = *A* ° (*B* ° *C*) for all Boolean values *A*, *B*, and *C*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**结合律** 如果对于所有布尔值 *A*、*B* 和 *C*，(*A* ° *B*) ° *C* = *A* ° (*B* ° *C*)，则二元运算符
    ° 是 *结合律* 的。'
- en: '**Distribution** Two binary operators ° and % are *[distributive](gloss01.xhtml#gloss01_77)*
    if *A* ° (*B* % *C*) = (*A* ° *B*) % (*A* ° *C*) for all Boolean values *A*, *B*,
    and *C*.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**分配律** 两个二元运算符 ° 和 % 是 *[分配律](gloss01.xhtml#gloss01_77)* 的，如果对于所有布尔值 *A*、*B*
    和 *C*，*A* ° (*B* % *C*) = (*A* ° *B*) % (*A* ° *C*)。'
- en: '**Identity** A Boolean value *I* is said to be the *identity element* with
    respect to some binary operator ° if *A* ° *I* = *A* for all Boolean values *A*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**单位元素** 如果对于所有布尔值 *A*，*A* ° *I* = *A*，则布尔值 *I* 被称为某个二元运算符 ° 的 *单位元素*。'
- en: '**Inverse** A Boolean value *I* is said to be the *inverse element* with respect
    to some binary operator ° if *A* ° *I* = *B* and *B* ° *A* (that is, *B* is the
    opposite value of *A* in a Boolean system) for all Boolean values *A* and *B*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆元** 如果对于所有布尔值 *A* 和 *B*，*A* ° *I* = *B* 且 *B* ° *A*（即 *B* 是 *A* 在布尔系统中的对立值），则布尔值
    *I* 被称为关于某个二元运算符 ° 的 *逆元*。'
- en: 'When applied to the Boolean operators, the preceding postulates produce the
    following set of *Boolean postulates*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于布尔运算符时，上述公理产生以下一组 *布尔公理*：
- en: '**P1**   Boolean algebra is closed under the AND, OR, and NOT operations.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**P1**   布尔代数在与 AND、OR 和 NOT 操作下是封闭的。'
- en: '**P2**   The identity element of AND (•) is 1, and the identity element of
    OR (+) is 0\. There’s no identity element for logical NOT ('').'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**P2**   AND（•）的单位元素是 1，OR（+）的单位元素是 0。逻辑非（''）没有单位元素。'
- en: '**P3**   The • and + operators are commutative.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**P3**   • 和 + 运算符是交换律的。'
- en: '**P4**   • and + are distributive with respect to each other. That is, *A*
    • (*B* + *C*) = (*A* • *B*) + (*A* • *C*) and *A* + (*B* • *C*) = (*A* + *B*)
    • (*A* + *C*).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**P4**   • 和 + 在彼此之间是分配律的。即，*A* • (*B* + *C*) = (*A* • *B*) + (*A* • *C*) 和
    *A* + (*B* • *C*) = (*A* + *B*) • (*A* + *C*)。'
- en: '**P5**   • and + are both associative. That is, (*A* • *B*) • *C* = *A* • (*B*
    • *C*) and (*A* + *B*) + *C* = *A* + (*B* + *C*).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**P5**   • 和 + 都是结合律的。即，(*A* • *B*) • *C* = *A* • (*B* • *C*) 和 (*A* + *B*)
    + *C* = *A* + (*B* + *C*)。'
- en: '**P6**   For every value *A* there exists a value *A''* such that *A* • *A''*
    = 0 and *A* + *A''* = 1\. This value is the logical complement (or NOT) of *A*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**P6**   对于每个值 *A*，都存在一个值 *A''*，使得 *A* • *A''* = 0 和 *A* + *A''* = 1。这个值是 *A*
    的逻辑补码（或 NOT）。'
- en: 'You can prove all other theorems in Boolean algebra using this set of Boolean
    postulates. This chapter won’t go into the formal proofs of the following theorems,
    but familiarity with them will be useful:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这一组布尔公理证明所有其他的布尔代数定理。本章不会深入讨论以下定理的正式证明，但对它们的熟悉将是有用的：
- en: '**Th1**   *A* + *A* = *A*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th1**   *A* + *A* = *A*'
- en: '**Th2**   *A* • *A* = *A*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th2**   *A* • *A* = *A*'
- en: '**Th3**   *A* + 0 = *A*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th3**   *A* + 0 = *A*'
- en: '**Th4**   *A* • 1 = *A*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th4**   *A* • 1 = *A*'
- en: '**Th5**   *A* • 0 = 0'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th5**   *A* • 0 = 0'
- en: '**Th6**   *A* + 1 = 1'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th6**   *A* + 1 = 1'
- en: '**Th7**   (*A* + *B*)*'' = A''* • *B''*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th7**   (*A* + *B*)*'' = A''* • *B''*'
- en: '**Th8**   (*A* • *B*)*''* = *A''* + *B''*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th8**   (*A* • *B*)*'' = *A''* + *B''*'
- en: '**Th9**   *A* + *A* • *B* = *A*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th9**   *A* + *A* • *B* = *A*'
- en: '**Th10**   *A* • (*A* + *B* ) = *A*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th10**   *A* • (*A* + *B*) = *A*'
- en: '**Th11**   *A* + *A''B* = *A* + *B*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th11**   *A* + *A''B* = *A* + *B*'
- en: '**Th12**   *A''* • (*A* + *B''*) = *A''B''*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th12**   *A''* • (*A* + *B''*) = *A''B''*'
- en: '**Th13**   *AB* + *AB''* = *A*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th13**   *AB* + *AB''* = *A*'
- en: '**Th14**   (*A''* + *B''* ) • (*A''* + *B*) = *A''*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th14**   (*A''* + *B''* ) • (*A''* + *B*) = *A''*'
- en: '**Th15**   *A* + *A''* = 1'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th15**   *A* + *A''* = 1'
- en: '**Th16**   *A* • *A''* = 0'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**Th16**   *A* • *A''* = 0'
- en: '**NOTE**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Theorems 7 and 8 are called* DeMorgan’s Theorems *after the mathematician
    who discovered them.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*定理 7 和 8 被称为* 德摩根定理 *，得名于发现这些定理的数学家。*'
- en: An important principle in the Boolean algebra system is *duality*. Each pair,
    theorems 1 and 2, theorems 3 and 4, and so on, forms a *dual*. Any valid expression
    you can create using the postulates and theorems of Boolean algebra remains valid
    if you interchange the operators and constants appearing in the expression. Specifically,
    if you exchange the • and + operators and swap the 0 and 1 values in an expression,
    the resulting expression will obey all the rules of Boolean algebra. *This does
    not mean the dual expression computes the same values*, only that both expressions
    are legal in the Boolean algebra system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数系统中的一个重要原则是*对偶性*。每一对定理（定理1和2，定理3和4，等等）形成一个*对偶*。你可以通过交换表达式中的运算符和常数，创造出任何有效的布尔代数表达式，结果仍然有效。具体来说，如果交换•和+运算符并且交换表达式中的0和1值，得到的表达式将遵循布尔代数的所有规则。*这并不意味着对偶表达式计算相同的值*，仅仅表示两者在布尔代数系统中都是合法的。
- en: '***8.1.3 Boolean Operator Precedence***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***8.1.3 布尔运算符优先级***'
- en: 'If several different Boolean operators appear within a single Boolean expression,
    the result of the expression depends on the *[precedence](gloss01.xhtml#gloss01_201)*
    of the operators. The following Boolean operators are ordered from highest precedence
    to lowest:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在一个布尔表达式中出现多个不同的布尔运算符，表达式的结果取决于运算符的*[优先级](gloss01.xhtml#gloss01_201)*。以下布尔运算符按从高到低的优先级排序：
- en: Parentheses
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号
- en: Logical NOT
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑非
- en: Logical AND
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑与
- en: Logical OR
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑或
- en: The logical AND and OR operators are *left associative*. This means that if
    two operators with the same precedence appear between three operands, you must
    evaluate the expressions from left to right. The logical NOT operation is *right
    associative*, although it would produce the same result using either left or right
    associativity because it is a unary operator having only a single operand.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与和或运算符是*左结合的*。这意味着如果两个运算符具有相同的优先级出现在三个操作数之间，你必须从左到右评估表达式。逻辑非运算是*右结合的*，虽然无论使用左结合还是右结合，它都会产生相同的结果，因为它是一个一元运算符，只有一个操作数。
- en: '**8.2 Boolean Functions and Truth Tables**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**8.2 布尔函数与真值表**'
- en: 'A Boolean *expression* is a sequence of 0s, 1s, and literals separated by Boolean
    operators. A Boolean *literal* is a primed (negated) or unprimed variable name,
    and all variable names are a single alphabetic character. A Boolean function is
    a specific Boolean expression; we generally give Boolean functions the name *F*
    with a possible subscript. For example, consider the following Boolean function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个布尔*表达式*是由0、1和字面量通过布尔运算符连接而成的序列。布尔*字面量*是带有否定符号（取反）或不带否定符号的变量名，所有的变量名都是单个字母字符。布尔函数是特定的布尔表达式；我们通常将布尔函数命名为*F*，并可能带有下标。例如，考虑以下布尔函数：
- en: '*F*[0] = *AB* + *C*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*[0] = *AB* + *C*'
- en: This function computes the logical AND of *A* and *B* and then logically ORs
    this result with *C*. If *A* = 1, *B* = 0, and *C* = 1, then *F*[0] returns 1
    (1 • 0 + 1 = 1).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数计算*A*和*B*的逻辑与，并将这个结果与*C*进行逻辑或运算。如果*A* = 1，*B* = 0，*C* = 1，那么*F*[0]返回1（1
    • 0 + 1 = 1）。
- en: You can also represent a Boolean function with a *truth table*. The truth tables
    for the logical AND and OR functions are shown in [Tables 8-1](ch08.xhtml#ch08tab01)
    and [8-2](ch08.xhtml#ch08tab02), respectively.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用*真值表*表示布尔函数。逻辑与和或函数的真值表分别显示在[表8-1](ch08.xhtml#ch08tab01)和[8-2](ch08.xhtml#ch08tab02)中。
- en: '**Table 8-1:** AND Truth Table'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-1：** 与运算真值表'
- en: '| **AND** | **0** | **1** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **与** | **0** | **1** |'
- en: '| 0 | 0 | 0 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '**Table 8-2:** OR Truth Table'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-2：** 或运算真值表'
- en: '| **OR** | **0** | **1** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **或** | **0** | **1** |'
- en: '| 0 | 0 | 1 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: For binary operators and two input variables, this truth table format is very
    intuitive and convenient. However, for functions involving more than two variables,
    it doesn’t work well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二元运算符和两个输入变量，这种真值表格式非常直观和方便。然而，对于涉及多个变量的函数，它并不适用。
- en: '[Table 8-3](ch08.xhtml#ch08tab03) shows another way to represent truth tables.
    This format has several advantages—it is easier to fill in the table, it supports
    three or more variables, and it provides a compact representation for two or more
    functions.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[表8-3](ch08.xhtml#ch08tab03)展示了另一种表示真值表的方式。这种格式有几个优点——它更容易填写表格，支持三个或更多变量，并且为两个或更多函数提供了紧凑的表示。'
- en: '**Table 8-3:** Truth Table Format for a Function of Three Variables'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-3：** 三变量函数的真值表格式'
- en: '| ***C*** | ***B*** | ***A*** | ***F = ABC*** | ***F = AB + C*** | ***F = A
    + BC*** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| ***C*** | ***B*** | ***A*** | ***F = ABC*** | ***F = AB + C*** | ***F = A
    + BC*** |'
- en: '| 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 0 | 0 | 1 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 0 | 1 |'
- en: '| 0 | 1 | 0 | 0 | 0 | 0 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 1 | 1 | 0 | 1 | 1 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | 1 | 1 |'
- en: '| 1 | 0 | 0 | 0 | 1 | 0 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 | 1 | 0 |'
- en: '| 1 | 0 | 1 | 0 | 1 | 1 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 1 | 1 |'
- en: '| 1 | 1 | 0 | 0 | 1 | 1 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 1 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 |'
- en: Although you can create an infinite variety of Boolean functions, they are not
    all unique. For example, *F* = *A* and *F* = *AA* are two different functions.
    By theorem 2, however, it’s easy to show that these two functions produce exactly
    the same result no matter what input value you supply for *A*. As it turns out,
    if you fix the number of input variables, there’s a finite number of unique Boolean
    functions possible. For example, there are 16 unique Boolean functions with two
    input variables, and there are 256 possible Boolean functions with three input
    variables. Given *n* input variables, there are 2^(2^(*n*)) unique Boolean functions
    (2 raised to 2 raised to the *n*th power). With two input variables, there are
    2²² or 16 different functions. With three input variables, there are 2²³ or 256
    possible functions. Four input variables have 2²⁴ or 2^(16) or 65,536 unique Boolean
    functions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以创建无限多种布尔函数，但它们并非都唯一。例如，*F* = *A* 和 *F* = *AA* 是两个不同的函数。然而，依据定理2，可以轻松证明无论你为
    *A* 提供何种输入值，这两个函数的结果完全相同。事实证明，如果你固定输入变量的数量，那么可能的唯一布尔函数数量是有限的。例如，两个输入变量的布尔函数有 16
    种唯一可能，三个输入变量的布尔函数有 256 种可能。给定 *n* 个输入变量，存在 2^(2^(*n*)) 种唯一布尔函数（2 的 2 的 *n* 次方）。对于两个输入变量，有
    2²² 或 16 种不同的函数；对于三个输入变量，有 2²³ 或 256 种可能的函数；四个输入变量有 2²⁴ 或 2^(16) 或 65,536 种唯一布尔函数。
- en: When working with only 16 Boolean functions (two input variables), we can name
    each unique function (see [Table 8-4](ch08.xhtml#ch08tab04)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当只处理 16 个布尔函数（两个输入变量）时，我们可以为每个唯一函数命名（见 [表 8-4](ch08.xhtml#ch08tab04)）。
- en: '**Table 8-4:** Common Names for Boolean Functions of Two Variables'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-4：** 两个变量的布尔函数常见名称'
- en: '| Function number^([1](footnotes.xhtml#fn8_1a)) | **Function name** | **Description**
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 函数编号^([1](footnotes.xhtml#fn8_1a)) | **函数名称** | **描述** |'
- en: '| 0 | Zero (clear) | Always returns 0 regardless of *A* and *B* input values.
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 零（清除） | 无论 *A* 和 *B* 的输入值如何，始终返回 0。 |'
- en: '| 1 | Logical NOR | (NOT (*A* OR *B*)) = (*A* + *B*)*''* |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 逻辑非或 | (NOT (*A* OR *B*)) = (*A* + *B*)*''* |'
- en: '| 2 | Inhibition (*AB*'') | Inhibition = *AB**''* (*A* AND not *B*). Also equivalent
    to *A* > *B* or *B* < *A*. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 抑制 (*AB*'') | 抑制 = *AB**''* (*A* AND not *B*)。也等同于 *A* > *B* 或 *B* <
    *A*。 |'
- en: '| 3 | NOT *B* | Ignores *A* and returns *B**''*. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 非 *B* | 忽略 *A*，返回 *B**''*. |'
- en: '| 4 | Inhibition (*BA**''*) | Inhibition = *BA**''* (*B* AND not *A*). Also
    equivalent to *B* > *A* or *A* < *B*. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 抑制 (*BA**''*) | 抑制 = *BA**''* (*B* AND not *A*)。也等同于 *B* > *A* 或 *A*
    < *B*。 |'
- en: '| 5 | NOT *A* | Returns *A**''* and ignores *B*. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 非 *A* | 返回 *A**''* 并忽略 *B*。 |'
- en: '| 6 | Exclusive-OR (XOR) | *A* ⊕ *B*. Equivalent to *A* ≠ *B*. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 异或（XOR） | *A* ⊕ *B*。等同于 *A* ≠ *B*。 |'
- en: '| 7 | Logical NAND | (NOT (*A* AND *B*)) = (*A* • *B*)*''* |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 逻辑与非 | (NOT (*A* AND *B*)) = (*A* • *B*)*''* |'
- en: '| 8 | Logical AND | *A* • *B* = (*A* AND *B*) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 逻辑与 | *A* • *B* = (*A* AND *B*) |'
- en: '| 9 | Equivalence (exclusive-NOR) | (*A* = *B*). Also known as exclusive-NOR
    (not exclusive-OR). |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 等价（异或非） | (*A* = *B*)。也称为异或非（不是异或）。 |'
- en: '| 10 | *A* | Copy *A*. Returns the value of *A* and ignores *B*’s value. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 10 | *A* | 复制 *A*。返回 *A* 的值，忽略 *B* 的值。 |'
- en: '| 11 | Implication, *B* implies *A* | *A* + *B**''*. (If *B* then *A*.) Equivalent
    to *B* ≥ *A*. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 蕴涵，*B* 蕴涵 *A* | *A* + *B**''*.（如果 *B* 则 *A*。）等价于 *B* ≥ *A*。 |'
- en: '| 12 | *B* | Copy *B*. Returns the value of *B* and ignores *A*’s value. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 12 | *B* | 复制 *B*。返回 *B* 的值，忽略 *A* 的值。 |'
- en: '| 13 | Implication, *A* implies *B* | *B* + *A**''*. (If *A* then *B*.) Equivalent
    to *A* ≥ *B*. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 蕴涵，*A* 蕴涵 *B* | *B* + *A**''*.（如果 *A* 则 *B*。）等价于 *A* ≥ *B*。 |'
- en: '| 14 | Logical OR | *A* + *B*. Returns *A* OR *B*. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 逻辑或 | *A* + *B*。返回 *A* 或 *B*。 |'
- en: '| 15 | One (set) | Always returns 1 regardless of *A* and *B* input values.
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 一（集合） | 无论 *A* 和 *B* 的输入值如何，始终返回 1。 |'
- en: '**8.3 Function Numbers**'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**8.3 函数编号**'
- en: Beyond two input variables, there are too many functions to provide a specific
    name for each. Even when referring to functions with two input variables, we’ll
    refer to the function’s number rather than its name. For example, *F*[8] denotes
    the logical AND of *A* and *B* for a two-input function, and *F*[14] denotes the
    logical OR operation. Of course, for functions with more than two input variables,
    the question is, “How do we determine a function’s number?” For example, what
    is the corresponding number for the function *F* = *AB* + *C* ? We compute the
    answer by looking at the function’s truth table. If we treat the values for *A*,
    *B*, and *C* as bits in a binary number with *C* being the HO bit and *A* being
    the LO bit, they produce the binary strings that correspond to numbers in the
    range 0 through 7\. Associated with each of these binary strings is the function
    result, either 0 or 1\. If we construct a binary number by placing the function
    result of each combination of the *A*, *B*, and *C* input values into the bit
    position specified by the binary string of the *A*, *B*, and *C* bits, the resulting
    binary number will be the corresponding function number. If this doesn’t make
    sense, an example will help clear it up. Consider the truth table for *F* = *AB*
    + *C* (see [Table 8-5](ch08.xhtml#ch08tab05)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个输入变量以上的情况，函数的种类太多，以至于无法为每一个函数提供具体的名称。即使是针对两个输入变量的函数，我们也通常引用函数的编号而不是其名称。例如，*F*[8]表示两个输入函数的逻辑与操作（*A*和*B*的与），而*F*[14]表示逻辑或操作。当然，对于超过两个输入变量的函数，问题是：“我们如何确定一个函数的编号？”例如，函数*F*
    = *AB* + *C*对应的编号是多少？我们通过查看该函数的真值表来计算答案。如果我们将*A*、*B*和*C*的值视为一个二进制数中的位，其中*C*是高位，*A*是低位，它们会产生对应于0到7范围内的二进制字符串。每个二进制字符串关联的函数结果要么是0，要么是1。如果我们通过将每个组合的*A*、*B*和*C*输入值的函数结果放置到由*A*、*B*和*C*的二进制字符串指定的位位置中，最终得到的二进制数将是相应的函数编号。如果这个理解不清楚，下面的例子会帮助你理清楚。考虑*F*
    = *AB* + *C*的真值表（见[表8-5](ch08.xhtml#ch08tab05)）。
- en: '**Table 8-5:** Truth Table for *F* = *AB* + *C*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-5：** *F* = *AB* + *C* 的真值表'
- en: '| ***C*** | ***B*** | ***A*** | ***F = AB + C*** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| ***C*** | ***B*** | ***A*** | ***F = AB + C*** |'
- en: '| 0 | 0 | 0 | 0 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 0 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 |'
- en: '| 0 | 1 | 0 | 0 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 |'
- en: '| 0 | 1 | 1 | 1 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 |'
- en: '| 1 | 0 | 0 | 1 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 |'
- en: '| 1 | 0 | 1 | 1 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 |'
- en: '| 1 | 1 | 0 | 1 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 1 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 |'
- en: 'The input variables *C*, *B*, and *A* combine to form binary number sequences
    in the range `%000` through `%111` (0 through 7). If we use these values to denote
    bit numbers in an 8-bit value (*CBA* = `%111` specifies bit 7, *CBA* = `%110`
    specifies bit 6, and so on), we can determine the function number by placing at
    each of these bit positions the result of *F* = *AB* + *C*, for the corresponding
    combination of *C*, *B*, and *A* values:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量*C*、*B*和*A*结合形成二进制数序列，范围从`%000`到`%111`（即从0到7）。如果我们用这些值表示一个8位值中的位编号（*CBA*
    = `%111`表示位7，*CBA* = `%110`表示位6，以此类推），我们可以通过将每个对应的*C*、*B*和*A*值组合的*F* = *AB* +
    *C*的结果放入每个位位置来确定函数编号：
- en: '[PRE0]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we treat this bit string as a binary number, it produces the function
    number `$F8`, or 248\. We usually denote function numbers in decimal. This also
    provides insight into why there are 2^(2^(*n*)) different functions given *n*
    input variables: if you have *n* input variables, there are 2^(*n*) different
    variable value combinations, and thus 2^(*n*) bits in the function’s binary number.
    If you have *m* bits, there are 2^(*m*) different possible arrangements of those
    bits. Therefore, for *n* input variables there are *m* = 2^(*n*) possible bits
    and 2^(*m*) or 2^(2^(*n*)) possible functions.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将这个比特串视为一个二进制数，它会产生函数编号`$F8`，即248。我们通常使用十进制表示函数编号。这也为为什么存在2^(2^(*n*))个不同的函数提供了洞察力：如果你有*n*个输入变量，那么有2^(*n*)种不同的变量值组合，因此在函数的二进制数中有2^(*n*)位。如果你有*m*位，那么这些位有2^(*m*)种不同的排列方式。因此，对于*n*个输入变量，存在*m*
    = 2^(*n*)个可能的位和2^(*m*)或2^(2^(*n*))个可能的函数。
- en: '**8.4 Algebraic Manipulation of Boolean Expressions**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**8.4 布尔表达式的代数运算**'
- en: You can transform one Boolean expression into an equivalent expression by applying
    the postulates and theorems of Boolean algebra. This is important if you want
    to convert a given expression to a canonical form (see the next section) or if
    you want to minimize the number of literals or terms in an expression. (A *literal*
    is a primed or unprimed variable, and a *term* is a variable or a product—logical
    AND—of several different literals.) Electrical circuits often consist of individual
    components that implement each literal or term, so minimizing the number of literals
    and terms in an expression allows a circuit designer to use fewer electrical components
    and, therefore, to reduce the monetary cost of the system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过应用布尔代数的公理和定理，将一个布尔表达式转换为等效表达式。如果你想将给定表达式转换为规范形式（参见下一节），或如果你希望最小化表达式中的文字或项的数量，这一点非常重要。（*文字*是一个带或不带撇号的变量，*项*是一个变量或多个不同文字的积——逻辑与运算。）电路通常由实现每个文字或项的单独组件组成，因此，最小化表达式中的文字和项的数量，可以让电路设计师使用更少的电气组件，从而减少系统的成本。
- en: 'Unfortunately, there are no fixed rules you can apply to optimize a given expression.
    Much like constructing mathematical proofs, an individual’s ability to easily
    do these transformations is usually a matter of experience. Nevertheless, a few
    examples show the possibilities:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有固定的规则可以应用于优化给定的表达式。就像构造数学证明一样，个人轻松完成这些转换的能力通常是经验问题。尽管如此，几个例子展示了其可能性：
- en: '[PRE1]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**8.5 Canonical Forms**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**8.5 规范形式**'
- en: Each Boolean function has an infinite number of equivalent logic expressions.
    To help eliminate confusion, logic designers generally specify a Boolean function
    using a *canonical*, or standardized, form. For each different Boolean function,
    we can choose a single canonical representation from a defined set.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个布尔函数都有无数个等效的逻辑表达式。为了帮助消除混淆，逻辑设计师通常使用*规范*或标准化的形式来指定布尔函数。对于每个不同的布尔函数，我们可以从定义的集合中选择一个规范表示。
- en: There are several ways to define a set of canonical representations for all
    the possible Boolean functions of *n* variables. Within each canonical set, a
    single expression describes each Boolean function in the system so all of the
    functions in the set are unique. We’ll discuss two canonical systems in this chapter—the
    *sum of minterms* and the *product of maxterms*—but we’ll employ only the first.
    Using the duality principle, we can convert between these two systems.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以为所有可能的 *n* 个变量的布尔函数定义一组规范表示。在每个规范集合中，单个表达式描述系统中的每个布尔函数，因此集合中的所有函数都是唯一的。本章将讨论两种规范系统——*最小项和合项的和*（sum
    of minterms）和*最大项和的积*（product of maxterms），但我们只会使用第一个。利用对偶原理，我们可以在这两个系统之间进行转换。
- en: 'As mentioned earlier, a term is either a single literal or a product (logical
    AND) of several different literals. For example, if you have two variables, *A*
    and *B*, there are eight possible terms: *A*, *B*, *A''*, *B''*, *A''B''*, *A''B*,
    *AB''*, and *AB*. For three variables, we have 26 different terms: *A*, *B*, *C*,
    *A''*, *B''*, *C''*, *A''B''*, *A''B*, *AB''*, *AB*, *A''C''*, *A''C*, *AC''*,
    *AC*, *B''C''*, *B''C*, *BC''*, *BC*, *A''B''C''*, *AB''C''*, *A''BC''*, *ABC''*,
    *A''B''C*, *AB''C*, *A''BC*, and *ABC*. As the number of variables increases,
    the number of terms increases dramatically. A *minterm* is a product containing
    exactly *n* literals, where *n* is the number of input variables. For example,
    the minterms for the two variables *A* and *B* are *A''B''*, *AB''*, *A''B*, and
    *AB*. Likewise, the minterms for three variables *A*, *B*, and *C* are *A''B''C''*,
    *AB''C''*, *A''BC''*, *ABC''*, *A''B''C*, *AB''C*, *A''BC*, and *ABC*. In general,
    there are 2^(*n*) minterms for *n* variables. The set of possible minterms is
    easy to generate because they correspond to the sequence of binary numbers (see
    [Table 8-6](ch08.xhtml#ch08tab06)).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，项是单一文字或多个不同文字的积（逻辑与）。例如，如果你有两个变量，*A* 和 *B*，则有八个可能的项：*A*、*B*、*A'*、*B'*、*A'B'*、*A'B*、*AB'*
    和 *AB*。对于三个变量，我们有26个不同的项：*A*、*B*、*C*、*A'*、*B'*、*C'*、*A'B'*、*A'B*、*AB'*、*AB*、*A'C'*、*A'C*、*AC'*、*AC*、*B'C'*、*B'C*、*BC'*、*BC*、*A'B'C'*、*AB'C'*、*A'BC'*、*ABC'*、*A'B'C*、*AB'C*、*A'BC*
    和 *ABC*。随着变量数量的增加，项的数量会急剧增加。*最小项*是一个包含恰好 *n* 个文字的积，其中 *n* 是输入变量的数量。例如，两个变量 *A*
    和 *B* 的最小项是 *A'B'*、*AB'*、*A'B* 和 *AB*。同样，三个变量 *A*、*B* 和 *C* 的最小项是 *A'B'C'*、*AB'C'*、*A'BC'*、*ABC'*、*A'B'C*、*AB'C*、*A'BC*
    和 *ABC*。一般来说，对于 *n* 个变量，有 2^(*n*) 个最小项。最小项的集合很容易生成，因为它们对应于二进制数的序列（见 [表 8-6](ch08.xhtml#ch08tab06)）。
- en: '**Table 8-6:** Generating Minterms from Binary Numbers'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-6：** 从二进制数生成最小项'
- en: '| **Binary equivalent (**CBA**)** | **Minterm** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **二进制等价（**CBA**）** | **最小项** |'
- en: '| 000 | *A''B''C''* |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 000 | *A''B''C''* |'
- en: '| 001 | *AB''C''* |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 001 | *AB''C''* |'
- en: '| 010 | *A''BC''* |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 010 | *A''BC''* |'
- en: '| 011 | *ABC''* |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 011 | *ABC''* |'
- en: '| 100 | *A''B''C* |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 100 | *A''B''C* |'
- en: '| 101 | *AB''C* |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 101 | *AB''C* |'
- en: '| 110 | *A''BC* |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 110 | *A''BC* |'
- en: '| 111 | *ABC* |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 111 | *ABC* |'
- en: 'We can derive the canonical form for *any* Boolean function using a sum (logical
    OR) of minterms. Given *F*[248] = *AB* + *C*, the equivalent canonical form is
    *ABC* + *A''BC* + *AB''C* + *A''B''C* + *ABC''*. Algebraically, we can show that
    the canonical form is equivalent to *AB* + *C* as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将最小项之和（逻辑“或”）来推导出 *任何* 布尔函数的标准形式。给定 *F*[248] = *AB* + *C*，其等效的标准形式为 *ABC*
    + *A'BC* + *AB'C* + *A'B'C* + *ABC'*。从代数角度，我们可以如下展示标准形式等价于 *AB* + *C*：
- en: '[PRE2]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Obviously, the canonical form is not optimal. However, it’s very easy to generate
    the truth table for a function from the canonical form. It’s also very easy to
    generate the sum-of-minterms canonical form equation from the truth table.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，标准形式并不是最优的。然而，从标准形式生成函数的真值表非常容易。从真值表生成最小项之和的标准形式方程也非常容易。
- en: '***8.5.1 Sum-of-Minterms Canonical Form and Truth Tables***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***8.5.1 最小项之和的标准形式与真值表***'
- en: 'To build the truth table from the sum-of-minterms canonical form, follow these
    steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从最小项之和的标准形式构建真值表，请按照以下步骤操作：
- en: 'Convert minterms to binary equivalents by substituting a 1 for unprimed variables
    and a 0 for primed variables, like so:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最小项转换为二进制等价物，通过将未加撇号的变量替换为1，将加撇号的变量替换为0，如下所示：
- en: '[PRE3]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Place a 1 in the function column for the appropriate minterm entries:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数列中为适当的最小项条目放置1：
- en: '| ***C*** | ***B*** | ***A*** | ***F = AB +* *C*** |'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ***C*** | ***B*** | ***A*** | ***F = AB +* *C*** |'
- en: '| 0 | 0 | 0 |  |'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |  |'
- en: '| 0 | 0 | 1 |  |'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |  |'
- en: '| 0 | 1 | 0 |  |'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 1 | 0 |  |'
- en: '| 0 | 1 | 1 | 1 |'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 |'
- en: '| 1 | 0 | 0 | 1 |'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 |'
- en: '| 1 | 0 | 1 | 1 |'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 |'
- en: '| 1 | 1 | 0 | 1 |'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 1 |'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 |'
- en: 'Finally, place the number 0 in the function column for the remaining entries:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为剩余的条目在函数列中放置数字0：
- en: '| ***C*** | ***B*** | ***A*** | ***F =* *AB + C*** |'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ***C*** | ***B*** | ***A*** | ***F =* *AB + C*** |'
- en: '| 0 | 0 | 0 | 0 |'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 0 |'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 |'
- en: '| 0 | 1 | 0 | 0 |'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 |'
- en: '| 0 | 1 | 1 | 1 |'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 |'
- en: '| 1 | 0 | 0 | 1 |'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 |'
- en: '| 1 | 0 | 1 | 1 |'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 |'
- en: '| 1 | 1 | 0 | 1 |'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 1 |'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 |'
- en: 'Going in the other direction, to generate a logic function from a truth table,
    follow these steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个方向出发，要从真值表生成逻辑函数，请按照以下步骤操作：
- en: Locate all the entries in the truth table with a function result of 1\. In this
    table, these are the last five entries. The number of table entries containing
    1s determines the number of minterms in the canonical equation.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到真值表中函数结果为1的所有条目。在此表中，这些条目是最后五个条目。包含1的表格条目数量决定了标准方程中的最小项数量。
- en: Generate the individual minterms by substituting *A*, *B*, or *C* for 1s and
    *A'*, *B'*, or *C'* for 0s. In this example, the result of *F*[248] is 1 when
    *CBA* equals 111, 110, 101, 100, or 011\. Therefore, *F*[248] *= CBA* + *CBA'*
    + *CB'A* + *CB'A'* + *C'AB*.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 *A*、*B* 或 *C* 替换为1，将 *A'*、*B'* 或 *C'* 替换为0，生成单独的最小项。在此示例中，当 *CBA* 等于111、110、101、100或011时，*F*[248]
    的结果为1。因此，*F*[248] = *CBA* + *CBA'* + *CB'A* + *CB'A'* + *C'AB*。
- en: Optionally rearrange the terms within the minterms, and rearrange the minterms
    within the overall function. This works because the logical OR and logical AND
    operations are both commutative.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以选择重新排列最小项内的项，并重新排列整个函数中的最小项。这是可行的，因为逻辑“或”和逻辑“与”运算都具有交换性。
- en: This process works equally well for any number of variables, as with the truth
    table in [Table 8-7](ch08.xhtml#ch08tab07) for the function *F*[53,504] = *ABCD*
    + *A'BCD* + *A'B'CD* + *A'B'C'D*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程同样适用于任何数量的变量，就像在[表8-7](ch08.xhtml#ch08tab07)中所示的函数 *F*[53,504] = *ABCD*
    + *A'BCD* + *A'B'CD* + *A'B'C'D*。
- en: '**Table 8-7:** Truth Table for F[53,504]'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-7：** *F*[53,504] 的真值表'
- en: '| ***D*** | ***C*** | ***B*** | ***A*** | ***F = ABCD + A''BCD + A''B''CD +
    A''B''C''D*** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| ***D*** | ***C*** | ***B*** | ***A*** | ***F = ABCD + A''BCD + A''B''CD +
    A''B''C''D*** |'
- en: '| 0 | 0 | 0 | 0 | 0 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 0 | 1 | 0 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 1 | 0 |'
- en: '| 0 | 0 | 1 | 0 | 0 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 1 | 0 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | 0 |'
- en: '| 0 | 1 | 0 | 0 | 0 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 | 0 |'
- en: '| 0 | 1 | 0 | 1 | 0 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 0 |'
- en: '| 0 | 1 | 1 | 0 | 0 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | 0 |'
- en: '| 0 | 1 | 1 | 1 | 0 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 | 0 |'
- en: '| 1 | 0 | 0 | 0 | 1 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 | 1 |'
- en: '| 1 | 0 | 0 | 1 | 0 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | 0 |'
- en: '| 1 | 0 | 1 | 0 | 0 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 0 |'
- en: '| 1 | 0 | 1 | 1 | 0 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 | 0 |'
- en: '| 1 | 1 | 0 | 0 | 1 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 1 |'
- en: '| 1 | 1 | 0 | 1 | 0 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 | 0 |'
- en: '| 1 | 1 | 1 | 0 | 1 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 1 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 |'
- en: Perhaps the easiest way to generate the canonical form of a Boolean function
    is to first generate the truth table for it and then build the canonical form
    from the truth table. In fact, we’ll use this technique when converting between
    the two canonical forms.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 也许生成布尔函数的标准形式最简单的方法是首先生成它的真值表，然后从真值表构建标准形式。实际上，我们将在两种标准形式之间转换时使用这种技术。
- en: '***8.5.2 Algebraically Derived Sum-of-Minterms Canonical Form***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***8.5.2 代数推导的最小项和标准形式***'
- en: 'To generate the sum-of-minterms canonical form algebraically, we use the distributive
    law and theorem 15 (*A* + *A''* = 1). Consider *F*[248] = *AB* + *C*. This function
    contains two terms, *AB* and *C*, but they are not minterms. We can convert the
    first term to a sum of minterms as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了代数地生成最小项和的标准形式，我们使用分配律和定理15（*A* + *A'* = 1）。考虑*F*[248] = *AB* + *C*。该函数包含两个项，*AB*和*C*，但它们不是最小项。我们可以将第一个项转换为最小项和，如下所示：
- en: '[PRE4]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, we can convert the second term in *F*[248] to a sum of minterms
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以将*F*[248]中的第二项转换为最小项和的形式，如下所示：
- en: '[PRE5]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last step (rearranging the terms) in these two conversions is optional.
    To obtain the final canonical form for *F*[248], we sum the results from these
    two conversions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个转换中的最后一步（重新排列项）是可选的。为了得到*F*[248]的最终标准形式，我们将这两个转换的结果求和：
- en: '[PRE6]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***8.5.3 Product-of-Maxterms Canonical Form***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***8.5.3 最大项积标准形式***'
- en: 'Another canonical form is the *products of maxterms*. A maxterm is the sum
    (logical OR) of all input variables, primed or unprimed. For example, consider
    the following logic function, *G*, of three variables in product-of-maxterms form:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种标准形式是*最大项积*。最大项是所有输入变量的和（逻辑或），无论是否加上取反符号。例如，考虑以下三个变量的逻辑函数，*G*，其为最大项积形式：
- en: '[PRE7]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As with the sum-of-minterms form, there’s exactly one product of maxterms for
    each possible logic function. For every product-of-maxterms form, there’s an equivalent
    sum-of-minterms form. In fact, the function *G* in this example is equivalent
    to the earlier sum-of-minterms form of *F*[248]:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与最小项和的形式一样，每个可能的逻辑函数都有一个唯一的最大项积。每个最大项积形式都有一个等效的最小项和形式。事实上，示例中的函数*G*等价于之前*F*[248]的最小项和形式：
- en: '[PRE8]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To generate a truth table from the product of maxterms, you use the duality
    principle; that is, swap AND for OR and 0s for 1s (and vice versa). Therefore,
    to build the truth table, you’d first swap primed and nonprimed literals. In *G*,
    this would yield:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从最大项积生成真值表，你可以使用对偶原理；即，交换AND为OR，0为1（反之亦然）。因此，构建真值表时，你首先要交换取反和非取反的字面量。在*G*中，这将得到：
- en: '[PRE9]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next step is to swap the logical OR and logical AND operators, which produces
    the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是交换逻辑或（OR）和逻辑与（AND）运算符，得到以下结果：
- en: '[PRE10]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, you need to swap all 0s and 1s. This means that for each of the minterms
    listed previously, you need to store 0s into the function column of the truth
    table, and then fill in the rest of the truth table’s function column with 1s.
    This will place a 0 in rows 0, 1, and 2 in the truth table. Filling the remaining
    entries with 1s produces *F*[248].
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要交换所有的0和1。这意味着，对于之前列出的每个最小项，你需要将0存入真值表的函数列，然后将真值表的其余函数列填入1。这将会在真值表的第0、1、2行放入0，剩余项填入1，从而得到*F*[248]。
- en: You can easily convert between these two canonical forms by generating the truth
    table for one form and working backward to produce the other form. Consider the
    function of two variables, *F*[7] = *A* + *B*. The sum-of-minterms form is *F*[7]
    = *A'B* + *AB'* + *AB*. The truth table is shown in [Table 8-8](ch08.xhtml#ch08tab08).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过生成其中一个形式的真值表并反向操作来轻松转换这两种标准形式。考虑两个变量的函数，*F*[7] = *A* + *B*。其最小项和形式为*F*[7]
    = *A'B* + *AB'* + *AB*。真值表见[表 8-8](ch08.xhtml#ch08tab08)。
- en: '**Table 8-8:** OR Truth Table for Two Variables'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-8：** 两变量的OR真值表'
- en: '| ***A*** | ***B*** | ***F***7 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| ***A*** | ***B*** | ***F***7 |'
- en: '| 0 | 0 | 0 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '| 0 | 1 | 1 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: Working backward to get the product of maxterms, we first locate all entries
    in the truth table that have a 0 result. The entry with *A* and *B* both equal
    to 0 is the only entry with a 0 result. This gives us the first step of *G* =
    *A' B'*. However, we still need to invert all the variables to obtain *G* = *AB*.
    By the duality principle, we also need to swap the logical OR and logical AND
    operators, obtaining *G* = *A* + *B*. This is the canonical *product of maxterms*
    form.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从后向前推导出最大项的积，我们首先定位真值表中所有结果为0的条目。*A*和*B*都等于0的条目是唯一一个结果为0的条目。这给了我们*G* = *A' B'*的第一步。然而，我们仍然需要将所有变量取反，得到*G*
    = *AB*。根据对偶性原则，我们还需要交换逻辑或（OR）和逻辑与（AND）运算符，得到*G* = *A* + *B*。这就是典型的*最大项积*形式。
- en: '**8.6 Simplification of Boolean Functions**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**8.6 布尔函数的简化**'
- en: Because there’s an infinite variety of Boolean functions of *n* variables, but
    a finite number of unique ones, you might wonder if there is some method that
    will simplify a given Boolean function to produce the optimal form—that is, the
    expression containing the fewest number of operators. An optimal form must exist
    for all logic functions, but we don’t use it for the canonical form for two reasons.
    First, although it’s easy to convert between the truth table forms and the canonical
    form, it’s not as easy to generate the optimal form from a truth table. Second,
    there may be several optimal forms for a single function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于布尔函数的变量数是无限多样的，但唯一的布尔函数数量是有限的，你可能会想是否有某种方法能够简化给定的布尔函数，从而得到最优形式——即包含最少运算符的表达式。对于所有逻辑函数，都必定存在最优形式，但我们不会在规范形式中使用它，原因有二。首先，虽然在真值表形式和规范形式之间转换很容易，但从真值表生成最优形式并不那么容易。其次，对于一个函数，可能会有多个最优形式。
- en: 'You can attempt to produce the optimal form using algebraic transformations,
    but there’s no guarantee you’ll arrive at the best result. There are two methods
    that will *always* reduce a given Boolean function to its optimal form: the *mapping*
    method and the *prime implicants* method. This book covers the mapping method.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试使用代数变换来产生最优形式，但不能保证你会得到最佳结果。有两种方法*总是*将给定的布尔函数简化为最优形式：*映射*方法和*最小因子*方法。本书介绍的是映射方法。
- en: Using the mapping method to manually optimize Boolean functions is practical
    only for functions of two, three, or four variables. It’s doable but cumbersome
    for functions of five or six variables. For more than six variables, you should
    write a program.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用映射方法手动优化布尔函数对于二、三、四个变量的函数是可行的，但对于五个或六个变量的函数来说，它是可行但繁琐的。对于超过六个变量的函数，你应该编写程序。
- en: The first step in the mapping method is to build a special two-dimensional truth
    table for the function (see [Figure 8-1](ch08.xhtml#ch08fig01)). *Take a careful
    look at these truth tables*. They do not use the same forms shown earlier in this
    chapter. In particular, the progression of the 2-bit values is 00, 01, 11, 10,
    not 00, 01, 10, 11\. This is very important! If you organize the truth tables
    in a binary sequence, the mapping optimization method will not work properly.
    We’ll call this a *truth map* to distinguish it from the standard truth table.^([2](footnotes.xhtml#fn8_2a))
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 映射方法的第一步是为该函数构建一个特殊的二维真值表（参见[图 8-1](ch08.xhtml#ch08fig01)）。*仔细观察这些真值表*。它们并没有使用本章前面展示的相同形式。特别地，2位值的进展顺序是00、01、11、10，而不是00、01、10、11。这一点非常重要！如果你按二进制顺序组织真值表，映射优化方法将无法正常工作。我们将此称为*真值映射*，以便与标准真值表区分开来。^([2](footnotes.xhtml#fn8_2a))
- en: '![image](../images/08fig01.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig01.jpg)'
- en: '*Figure 8-1: Two-, three-, and four-variable truth maps*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：二、三、四变量真值映射*'
- en: Assuming your Boolean function is already in sum-of-minterms canonical form,
    insert 1s for each of the truth map cells corresponding to one of the minterms
    in the function. Place 0s everywhere else. For example, consider the function
    of three variables *F* = *C'B'A* + *C'BA'* + *C'BA* + *CB'A'* + *CB'A* + *CBA'*
    + *CBA*. [Figure 8-2](ch08.xhtml#ch08fig02) shows the truth map for this function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的布尔函数已经是最小项和式的规范形式，则为与该函数的每个最小项相对应的真值映射单元插入1。其他地方插入0。例如，考虑三变量函数*F* = *C'B'A*
    + *C'BA'* + *C'BA* + *CB'A'* + *CB'A* + *CBA'* + *CBA*。[图 8-2](ch08.xhtml#ch08fig02)展示了该函数的真值映射。
- en: '![image](../images/08fig02.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig02.jpg)'
- en: '*Figure 8-2: A truth map for* F = C''B''A + C''BA'' + C''BA + CB''A'' + CB''A
    + CBA'' + CBA'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：* F = C''B''A + C''BA'' + C''BA + CB''A'' + CB''A + CBA'' + CBA 的真值映射'
- en: The next step is to draw outlines around rectangular groups of 1s. The rectangles
    you enclose must have sides whose lengths are powers of 2\. For functions with
    three variables, the rectangles can have sides whose lengths are 1, 2, and 4\.
    The set of rectangles you draw must surround all cells containing 1s in the truth
    map. The trick is to draw all possible rectangles unless a rectangle would be
    completely enclosed within another, but also draw the fewest number of rectangles.
    Note that the rectangles may overlap as long as one rectangle does not completely
    enclose the other. In the truth map in [Figure 8-3](ch08.xhtml#ch08fig03), there
    are three such rectangles.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是围绕1的矩形组画出轮廓。你围起来的矩形必须是边长为2的幂。对于三个变量的布尔函数，矩形的边长可以是1、2和4。你画出的矩形集合必须围绕真值图中所有包含1的单元格。诀窍是画出所有可能的矩形，除非一个矩形完全被另一个矩形包围，但同时要画出尽可能少的矩形。请注意，矩形可以重叠，只要一个矩形没有完全包含另一个矩形。在[图
    8-3](ch08.xhtml#ch08fig03)的真值图中，有三个这样的矩形。
- en: '![image](../images/08fig03.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig03.jpg)'
- en: '*Figure 8-3: Surrounding rectangular groups of 1s in a truth map*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：在真值图中围绕1的矩形组*'
- en: Each rectangle represents a term in the simplified Boolean function. Therefore,
    the simplified Boolean function will contain only three terms. You build each
    term by eliminating any variables whose primed and unprimed forms both appear
    within the rectangle (because the positive and negative variants cancel each other
    out). The long skinny rectangle in [Figure 8-3](ch08.xhtml#ch08fig03) is sitting
    in the row where *C* = 1 contains both *A* and *B* in primed and unprimed forms.
    Therefore, we can eliminate both *A* and *B* from the term. Because the rectangle
    sits in the *C* = 1 region, this rectangle represents the single literal *C*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个矩形代表简化后的布尔函数中的一个项。因此，简化后的布尔函数将只包含三个项。你可以通过去除矩形内同时出现正负形式的变量来构建每个项（因为正负形式会相互抵消）。在[图
    8-3](ch08.xhtml#ch08fig03)中，那个长条形矩形位于*C* = 1的行，其中同时包含*A*和*B*的正负形式。因此，我们可以从该项中去除*A*和*B*。由于该矩形位于*C*
    = 1区域，它代表的是单一项*C*。
- en: The light gray square in [Figure 8-3](ch08.xhtml#ch08fig03) includes *C*, *C'*,
    *B*, *B'*, and *A*. Therefore, it represents the single term *A*. Likewise, the
    dark gray square in [Figure 8-3](ch08.xhtml#ch08fig03) contains *C*, *C'*, *A*,
    *A'*, and *B*, so it represents the single term *B*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](ch08.xhtml#ch08fig03)中的浅灰色方块包含*C*、*C''*、*B*、*B''*和*A*。因此，它代表单一项*A*。同样，[图
    8-3](ch08.xhtml#ch08fig03)中的深灰色方块包含*C*、*C''*、*A*、*A''*和*B*，因此它代表单一项*B*。'
- en: The final, optimal, function is the sum (logical OR) of the terms represented
    by the three squares, or *F* = *A* + *B* + *C*. You do not have to consider the
    remaining squares containing 0s.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的最优函数是由三个方块所代表的项的总和（逻辑或），即*F* = *A* + *B* + *C*。你无需考虑剩余的包含0的方块。
- en: A truth map forms a *torus* (a doughnut shape). The right edge of the map wraps
    around to the left edge, and vice versa. Likewise, the top edge wraps around to
    the bottom edge. This introduces additional possibilities for drawing rectangles
    around groups of 1s in a map. Consider the Boolean function *F* = *C'B'A'* + *C'BA'*
    + *CB'A'* + *CBA'*. [Figure 8-4](ch08.xhtml#ch08fig04) shows the truth map for
    this function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 真值图形成了一个*环面*（类似甜甜圈的形状）。图的右边缘连接到左边缘，反之亦然。同样，顶部边缘连接到底部边缘。这为在真值图中围绕1的组画出矩形提供了更多可能性。考虑布尔函数*F*
    = *C'B'A'* + *C'BA'* + *CB'A'* + *CBA'*。该函数的真值图如[图 8-4](ch08.xhtml#ch08fig04)所示。
- en: '![image](../images/08fig04.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig04.jpg)'
- en: '*Figure 8-4: Truth map for F = C''B''A'' + C''BA'' + CB''A + CBA''*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：F = C''B''A'' + C''BA'' + CB''A + CBA'' 的真值图*'
- en: At first glance, you might think that the minimum number of rectangles is two,
    as shown in [Figure 8-5](ch08.xhtml#ch08fig05).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你可能认为最小的矩形数量是两个，如[图 8-5](ch08.xhtml#ch08fig05)所示。
- en: '![image](../images/08fig05.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig05.jpg)'
- en: '*Figure 8-5: First attempt at surrounding rectangles formed by 1s*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：首次尝试围绕由1形成的矩形*'
- en: However, because the truth map is a continuous object with the right side and
    left sides connected, we can actually form a single, square rectangle, as [Figure
    8-6](ch08.xhtml#ch08fig06) shows.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于真值图是一个连续的对象，右侧和左侧相连接，因此我们实际上可以形成一个单一的正方形矩形，如[图 8-6](ch08.xhtml#ch08fig06)所示。
- en: '![image](../images/08fig06.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig06.jpg)'
- en: '*Figure 8-6: Correct rectangle for the function*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：函数的正确矩形*'
- en: Why does it matter if we have one rectangle or two in the truth map? The larger
    the rectangles are, the more terms they will eliminate. The fewer rectangles that
    we have, then, the fewer terms will appear in the final Boolean function.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在真值图中我们有一个矩形或两个矩形很重要呢？矩形越大，它们能够消去的项就越多。因此，矩形越少，最终布尔函数中出现的项就越少。
- en: The example in [Figure 8-5](ch08.xhtml#ch08fig05) with two rectangles generates
    a function with two terms. The rectangle on the left eliminates the *C* variable,
    leaving *A'B'* as its term. The rectangle on the right also eliminates the *C*
    variable, leaving the term *BA'*. Therefore, this truth map would produce the
    equation *F* = *A'B'* + *A'B*. We know this is not optimal (see theorem 13).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-5](ch08.xhtml#ch08fig05)中的两个矩形示例生成了一个包含两个项的函数。左侧的矩形消除了*C*变量，留下了*A''B''*作为它的项。右侧的矩形也消除了*C*变量，留下了项*BA''*。因此，这个真值图将产生方程*F*
    = *A''B''* + *A''B*。我们知道这是不最优的（参见定理13）。'
- en: Now consider the truth map in [Figure 8-6](ch08.xhtml#ch08fig06). Here we have
    a single rectangle, so our Boolean function will have only a single term. Because
    this rectangle includes both *C* and *C'*, and also *B* and *B'*, the only term
    left is *A'*. This Boolean function, therefore, reduces to *F = A'*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑[图8-6](ch08.xhtml#ch08fig06)中的真值图。这里我们只有一个矩形，所以我们的布尔函数将只有一个项。因为这个矩形包括了*C*和*C'*，还包括了*B*和*B'*，所以剩下的唯一项就是*A'*。因此，这个布尔函数简化为*F
    = A'*。
- en: 'There are only two types of truth maps that the mapping method cannot handle
    properly: a truth map that contains all 0s or a truth map that contains all 1s.
    These two cases correspond to the Boolean functions *F* = 0 and *F* = 1 (that
    is, the function number is 0 or 2^(*n*) – 1). When you see either of these truth
    maps, you’ll know how to optimally represent the function.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 映射方法不能正确处理的真值图只有两种类型：包含所有0的真值图或包含所有1的真值图。这两种情况对应于布尔函数*F* = 0和*F* = 1（即函数编号为0或2^(*n*)
    – 1）。当你遇到这两种真值图时，你就知道如何最优化地表示该函数。
- en: When optimizing Boolean functions using the mapping method, remember that you
    always want to pick the largest rectangles whose sides’ lengths are powers of
    2\. You must do this even for overlapping rectangles (unless one rectangle encloses
    another). Consider the Boolean function *F* = *C'B'A'* + *C'BA'* + *CB'A'* + *C'AB*
    + *CBA'* + *CBA*. This produces the truth map in [Figure 8-7](ch08.xhtml#ch08fig07).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用映射方法优化布尔函数时，请记住你总是要选择边长是2的幂的最大矩形。即使是重叠的矩形也必须这样做（除非一个矩形完全包含另一个矩形）。考虑布尔函数*F*
    = *C'B'A'* + *C'BA'* + *CB'A'* + *C'AB* + *CBA'* + *CBA*。这将生成[图8-7](ch08.xhtml#ch08fig07)中的真值图。
- en: '![image](../images/08fig07.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig07.jpg)'
- en: '*Figure 8-7: Truth map for F = C''B''A'' + C''BA'' + CB''A'' + C''AB + CBA''
    + CBA*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-7：F = C''B''A'' + C''BA'' + CB''A'' + C''AB + CBA'' + CBA的真值图*'
- en: The initial temptation is to create one of the sets of rectangles found in [Figure
    8-8](ch08.xhtml#ch08fig08). However, the correct mapping appears in [Figure 8-9](ch08.xhtml#ch08fig09).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 初步的诱惑是创建[图8-8](ch08.xhtml#ch08fig08)中找到的矩形集合。然而，正确的映射出现在[图8-9](ch08.xhtml#ch08fig09)中。
- en: '![image](../images/08fig08.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig08.jpg)'
- en: '*Figure 8-8: Obvious choices for rectangles*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-8：矩形的显而易见选择*'
- en: '![image](../images/08fig09.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig09.jpg)'
- en: '*Figure 8-9: Correct set of rectangles for F = C''B''A'' + C''BA'' + CB''A''
    + C''AB + CBA'' + CBA*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-9：F = C''B''A'' + C''BA'' + CB''A'' + C''AB + CBA'' + CBA的矩形集合*'
- en: All three mappings will produce a Boolean function with two terms. However,
    the first two will produce the expressions *F* = *B* + *A'B'* and *F* = *AB* +
    *A'*. The third form produces *F* = *B* + *A'*. This last form is the optimized
    one (see theorems 11 and 12).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种映射都会生成一个包含两个项的布尔函数。然而，前两种会生成表达式*F* = *B* + *A'B'*和*F* = *AB* + *A'*。第三种形式生成*F*
    = *B* + *A'*。最后这种形式是最优化的（参见定理11和12）。
- en: Truth maps you create for functions of four variables are even trickier; there
    are many places rectangles can hide from you along the edges, as you can see in
    [Figure 8-10](ch08.xhtml#ch08fig10). This list of patterns doesn’t even begin
    to cover all of them! For example, the diagrams in [Figure 8-10](ch08.xhtml#ch08fig10)
    show none of the 1×2 rectangles.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为四个变量的函数创建的真值图更加复杂；你会发现许多矩形可能隐藏在边缘，这在[图8-10](ch08.xhtml#ch08fig10)中可以看到。这个模式列表甚至没有涵盖所有的矩形！例如，[图8-10](ch08.xhtml#ch08fig10)中的图示就没有显示任何1×2的矩形。
- en: '![image](../images/08fig10.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig10.jpg)'
- en: '*Figure 8-10: Partial pattern list for a 4×4 truth map*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-10：4×4真值图的部分模式列表*'
- en: This final example demonstrates optimizing a function of four variables. The
    function is *F* = *D'C'B'A'* + *D'C'B'A* + *D'C'BA* + *D'C'BA'* + *D'CB'A* + *D'CBA*
    + *DCB'A* + *DCBA* + *DC'B'A'* + *DC'BA'*, and its truth map appears in [Figure
    8-11](ch08.xhtml#ch08fig11).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的例子展示了如何优化一个四变量的函数。该函数是 *F* = *D'C'B'A'* + *D'C'B'A* + *D'C'BA* + *D'C'BA'*
    + *D'CB'A* + *D'CBA* + *DCB'A* + *DCBA* + *DC'B'A'* + *DC'BA'*，其真值表见于[图8-11](ch08.xhtml#ch08fig11)。
- en: '![image](../images/08fig11.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig11.jpg)'
- en: '*Figure 8-11: Truth map for F = D''C''B''A'' + D''C''B''A + D''C''BA + D''C''BA''
    + D''CB''A + D''CBA + DCB''A + DCBA + DC''B''A'' + DC''BA''*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-11：F = D''C''B''A'' + D''C''B''A + D''C''BA + D''C''BA'' + D''CB''A + D''CBA
    + DCB''A + DCBA + DC''B''A'' + DC''BA''* 的真值图*'
- en: '[Figure 8-12](ch08.xhtml#ch08fig12) shows the two possible sets of maximal
    rectangles for this function, each producing three terms.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-12](ch08.xhtml#ch08fig12)展示了该函数的两个可能的最大矩形集合，每个集合生成三个项。'
- en: '![image](../images/08fig12.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig12.jpg)'
- en: '*Figure 8-12: Two combinations yielding three terms*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-12：两种组合生成三项*'
- en: The rectangle formed by the four corners, common to both maps in [Figure 8-12](ch08.xhtml#ch08fig12),
    contains *B*, *B'*, *D*, and *D'*, so we can eliminate those terms. The remaining
    terms contained within the rectangle are *C'* and *A'*, so this rectangle represents
    the term *C'A'*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由四个角形成的矩形，两个图中都有，包含 *B*、*B'*、*D* 和 *D'*，因此我们可以去掉这些项。矩形内剩下的项是 *C'* 和 *A'*，所以这个矩形表示项
    *C'A'*。
- en: The rectangle formed by the middle four squares, also in both combinations,
    includes the terms *A*, *B*, *B'*, *C*, *D*, and *D'*. Eliminating *B*, *B'*,
    *D*, and *D'*, we obtain *CA*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由中间四个方格形成的矩形，在两种组合中也都有，包含了* A*、*B*、*B'*、*C*、*D* 和 *D'* 等项。去掉 *B*、*B'*、*D* 和
    *D'*，我们得到 *CA*。
- en: Combination 1 has a third term represented by the top row. This term includes
    the variables *A*, *A'*, *B*, *B'*, *C',* and *D'*. We can eliminate *A*, *A'*,
    *B*, and *B'*. This leaves the term *C'D'*. Therefore, the function represented
    by the upper truth map is *F* = *C'A'* + *CA* + *C'D'*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 组合1有第三项，由顶行表示。这个项包含了变量 *A*、*A'*、*B*、*B'*、*C'* 和 *D'*。我们可以去掉 *A*、*A'*、*B* 和 *B'*。剩下的项是
    *C'D'*。因此，上方真值表所表示的函数是 *F* = *C'A'* + *CA* + *C'D'*。
- en: Combination 2 has a third term represented by the top/middle four squares. This
    rectangle subsumes the variables *A*, *B*, *B'*, *C*, *C'*, and *D'*. We can eliminate
    *B*, *B'*, *C*, and *C'*, leaving the term *AD*. Therefore, the function represented
    by the lower truth map is *F* = *C'A'* + *CA* + *AD'*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 组合2有第三项，由顶部/中间的四个方格表示。这个矩形包含了变量 *A*、*B*、*B'*、*C*、*C'* 和 *D'*。我们可以去掉 *B*、*B'*、*C*
    和 *C'*，剩下的项是 *AD*。因此，下方真值表所表示的函数是 *F* = *C'A'* + *CA* + *AD'*。
- en: 'Both functions are equivalent; both are optimal (remember, there’s no guarantee
    of a unique optimal solution). Either will suffice for our purposes: implementing
    Boolean functions using the fewest circuit components.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数是等价的；两个都是最优的（记住，没有保证唯一的最优解）。其中任何一个都足够满足我们的需求：使用最少的电路组件实现布尔函数。
- en: '**8.7 What Does This Have to Do with Computers, Anyway?**'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**8.7 这和计算机有什么关系？**'
- en: Any program you can write, you can also specify as a sequence of Boolean equations.
    This means that any algorithm you can implement in software, you can also implement
    directly in hardware—there is a one-to-one relationship between the set of all
    Boolean functions and the set of all electronic circuits. Electrical engineers,
    who design CPUs and other computer-related circuits, have to be intimately familiar
    with this material.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何你编写的程序，也可以指定为一系列布尔方程。这意味着你可以将任何在软件中实现的算法，也能直接在硬件中实现——所有布尔函数集合与所有电子电路集合之间存在一一对应的关系。设计CPU和其他与计算机相关电路的电气工程师，必须对这些内容非常熟悉。
- en: Because it’s easier to specify a solution to a programming problem using languages
    like Pascal, C, or even assembly language than it is to specify the solution using
    Boolean equations, it’s unlikely that you would ever implement an entire program
    using a set of state machines and other logic circuitry. However, a hardware solution
    can be orders of magnitude faster than an equivalent software solution, and some
    time-critical operations require a hardware solution.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用像 Pascal、C 甚至汇编语言这样的语言来指定编程问题的解决方案，比使用布尔方程来指定解决方案要容易，所以你不太可能使用一组状态机和其他逻辑电路来实现整个程序。然而，硬件解决方案可能比等效的软件解决方案快几个数量级，而且一些时间关键的操作需要硬件解决方案。
- en: It is also possible to implement all hardware functions in software. This is
    important, because many operations you’d normally implement in hardware are much
    cheaper to implement using software on a microprocessor. Indeed, one of the primary
    uses of assembly language on modern systems is to inexpensively replace a complex
    electronic circuit. Often, you can replace many tens or hundreds of dollars of
    electronic components with a single $2 microcomputer chip programmed to perform
    the equivalent function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在软件中实现所有硬件功能。这一点非常重要，因为你通常在硬件中实现的许多操作，使用微处理器的软件实现要便宜得多。事实上，在现代系统中，汇编语言的主要用途之一就是以低成本替代复杂的电子电路。通常，你可以用一个单价为2美元的微计算机芯片，通过编程来执行等效的功能，从而替代价值数十或数百美元的电子元件。
- en: The whole field of *embedded systems* (computer systems embedded in other products)
    deals with this problem. For example, most microwave ovens, TV sets, video games,
    CD players, and other consumer devices contain one or more complete computer systems
    whose sole purpose is to replace a complex hardware design. Engineers use computers
    for this purpose because they are less expensive and easier to design with than
    traditional electronic circuitry.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 整个*嵌入式系统*（嵌入到其他产品中的计算机系统）领域都涉及这个问题。例如，大多数微波炉、电视机、视频游戏、CD播放器和其他消费电子设备都包含一个或多个完整的计算机系统，其唯一目的是替代复杂的硬件设计。工程师使用计算机来完成这个任务，因为它们比传统电子电路更便宜、更容易设计。
- en: To write software that reads switches (input variables) and turns on motors,
    LEDs, or lights, or that locks or unlocks a door, you need to understand Boolean
    functions and how to implement them in software.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写能够读取开关（输入变量）并启动电动机、LED灯或灯具，或锁定或解锁门的软件，你需要理解布尔函数以及如何在软件中实现它们。
- en: '***8.7.1 Correspondence Between Electronic Circuits and Boolean Functions***'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***8.7.1 电子电路与布尔函数之间的对应关系***'
- en: For any Boolean function, you can design an equivalent electronic circuit and
    vice versa. We can construct any electronic circuit using the AND, OR, and NOT
    Boolean operators, which correspond to the AND, OR, and inverter (NOT) circuits
    (see [Figure 8-13](ch08.xhtml#ch08fig13)). These symbols are standard electronic
    symbols appearing in *schematic diagrams*. (To learn more about electronic schematic
    diagrams, check out any book on electronic design.)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何布尔函数，你都可以设计一个等效的电子电路，反之亦然。我们可以使用与、或和非布尔运算符构造任何电子电路，它们分别对应与门、或门和反相器（非门）电路（参见[图8-13](ch08.xhtml#ch08fig13)）。这些符号是*原理图*中标准的电子符号。（要了解更多关于电子原理图的内容，可以查阅任何一本电子设计书籍。）
- en: '![image](../images/08fig13.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig13.jpg)'
- en: '*Figure 8-13: AND, OR, and inverter (NOT) gates*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-13：与门、或门和反相器（非门）*'
- en: The lines to the left of each gate, with the *A* and *B* labels, correspond
    to a logic function input; the line to the right of each diagram corresponds to
    the function’s output.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每个门左侧的带有*A*和*B*标签的线路对应逻辑功能的输入；每个图示右侧的线路则对应该功能的输出。
- en: An *electronic circuit* is a combination of gates that implement some set of
    Boolean functions. Consider the Boolean function *F* = *AB* + *B*. You can implement
    this function using an AND gate and an OR gate. Simply connect the two input variables
    (*A* and *B*) to the inputs of the AND gate, connect the output of the AND gate
    to one of the inputs of the OR gate, and connect the *B* input variable to the
    other OR input. Now you have an electronic (hardware) circuit that implements
    this function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*电子电路*是由多个门组合而成，能够实现某些布尔函数。考虑布尔函数*F* = *AB* + *B*。你可以使用与门和或门来实现这个函数。只需将两个输入变量（*A*和*B*）连接到与门的输入，将与门的输出连接到或门的一个输入，将*B*输入变量连接到另一个或门输入。现在你就有了一个实现该函数的电子（硬件）电路。
- en: However, you actually need only a single gate type—the NAND (NOT AND) gate—to
    implement *any* electronic circuit (see [Figure 8-14](ch08.xhtml#ch08fig14)).
    The NAND gate tests its two inputs (*A* and *B*) and outputs `false` if both inputs
    are `true`; it outputs `true` if both inputs are `false`. You could construct
    the NAND circuit from an AND gate and an inverter. However, from a transistor/hardware
    perspective, the NAND gate is actually simpler to construct than an AND gate;
    therefore, NAND gates (such as the 7400 IC) are very common.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你实际上只需要一个单一的门类型——NAND（非与）门，就能实现*任何*电子电路（参见[图8-14](ch08.xhtml#ch08fig14)）。NAND门测试其两个输入（*A*和*B*），如果两个输入均为`true`，则输出`false`；如果两个输入均为`false`，则输出`true`。你可以通过一个与门和一个反相器来构建NAND电路。然而，从晶体管/硬件的角度来看，NAND门实际上比与门更容易构建；因此，NAND门（例如7400集成电路）非常常见。
- en: '![image](../images/08fig14.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig14.jpg)'
- en: '*Figure 8-14: The NAND gate*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-14：NAND门*'
- en: We can construct any Boolean function using only NAND gates because we can build
    an inverter (NOT), an AND gate, and an OR gate from NAND gates.^([3](footnotes.xhtml#fn8_3a))
    Building an inverter is easy; just connect the two inputs together (see [Figure
    8-15](ch08.xhtml#ch08fig15)).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仅使用NAND门构造任何布尔函数，因为我们可以从NAND门构建反相器（NOT）、与门和或门。^([3](footnotes.xhtml#fn8_3a))
    构建反相器很简单；只需将两个输入连接在一起（见[图 8-15](ch08.xhtml#ch08fig15)）。
- en: '![image](../images/08fig15.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig15.jpg)'
- en: '*Figure 8-15: Inverter built from a NAND gate*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-15：由NAND门构建的反相器*'
- en: After building an inverter, we can build an AND gate by inverting the output
    of a NAND gate, because NOT (NOT (*A* AND *B*)) is equivalent to *A* AND *B* (see
    [Figure 8-16](ch08.xhtml#ch08fig16)). It takes two NAND gates to construct a single
    AND gate (no one said that circuits constructed only with NAND gates are optimal,
    only that they’re possible).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了反相器之后，我们可以通过反转NAND门的输出，来构建一个与门，因为NOT（NOT（*A* AND *B*））等同于*A* AND *B*（见[图
    8-16](ch08.xhtml#ch08fig16)）。构建一个与门需要两个NAND门（没有人说仅用NAND门构建的电路是最优的，只是说它们是可能的）。
- en: '![image](../images/08fig16.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig16.jpg)'
- en: '*Figure 8-16: Constructing an AND gate from two NAND gates*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-16：从两个NAND门构建AND门*'
- en: The remaining gate is the logical-OR gate. We can construct an OR gate from
    NAND gates by applying DeMorgan’s Theorems.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的门是逻辑“或”门。我们可以通过应用德摩根定律，从NAND门构建一个或门。
- en: '[PRE11]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Applying these transformations produces the circuit shown in [Figure 8-17](ch08.xhtml#ch08fig17).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这些变换产生了[图 8-17](ch08.xhtml#ch08fig17)中显示的电路。
- en: '![image](../images/08fig17.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig17.jpg)'
- en: '*Figure 8-17: Constructing an OR gate from NAND gates*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-17：从NAND门构建OR门*'
- en: NAND gates are generally less expensive to build than other gates, and it’s
    much easier to build up complex circuits from the same basic building blocks than
    it is to construct an integrated circuit using different basic gates.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他门相比，NAND门通常更便宜，且从相同的基本构建模块构建复杂电路比使用不同基本门构建集成电路要容易得多。
- en: '***8.7.2 Combinatorial Circuits***'
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***8.7.2 组合电路***'
- en: A computer’s CPU is built from *combinatorial circuits*, which are systems containing
    basic Boolean operations (AND, OR, NOT), some inputs, and a set of outputs. A
    combinatorial circuit often implements several different Boolean functions, with
    each output corresponding to an individual logic function.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的CPU是由*组合电路*构建的，这些电路包含基本的布尔运算（与、或、非）、一些输入和一组输出。组合电路通常实现多个不同的布尔函数，每个输出对应一个独立的逻辑功能。
- en: '**NOTE**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It is very important that you remember that* each output represents a different
    Boolean function.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*非常重要的是，你要记住* 每个输出代表一个不同的布尔函数。'
- en: '**8.7.2.1 Combining Addition Circuits**'
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.7.2.1 组合加法电路**'
- en: 'You can implement addition using Boolean functions. Suppose you have two 1-bit
    numbers, *A* and *B*. You can produce the 1-bit sum and the 1-bit carry of this
    addition using these two Boolean functions:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用布尔函数实现加法。假设你有两个1比特数字，*A*和*B*。你可以使用这两个布尔函数产生这次加法的1比特和与1比特进位：
- en: '[PRE12]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These two Boolean functions implement a *half adder*, so called because it adds
    2 bits together but cannot add in a carry from a previous operation. Note that
    *S* = 1 if *A* or *B* is 1, *S* = 0 if *A* and *B* are both 0 or 1 (both 1 produces
    a carry, which is what the *C* = *AB* expression produces).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个布尔函数实现了一个*半加法器*，之所以叫半加法器，是因为它能将两个比特加在一起，但不能加上来自先前运算的进位。注意，如果*A*或*B*为1，则*S*
    = 1；如果*A*和*B*都为0或1（两个1会产生进位，这是*C* = *AB*表达式的作用），则*S* = 0。
- en: 'A *full adder* adds three 1-bit inputs (2 bits plus a carry from a previous
    addition) and produces two outputs: the sum and the carry. These are the two logic
    equations for a full adder:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*全加法器*加三个1比特输入（两个比特加一个来自先前加法的进位），并产生两个输出：和与进位。以下是全加法器的两个逻辑方程：
- en: '[PRE13]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although these equations produce only a single-bit result (plus a carry), it’s
    easy to construct an *n*-bit sum by combining adder circuits (see [Figure 8-18](ch08.xhtml#ch08fig18)).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些方程只产生单比特结果（加上进位），但通过组合加法器电路，构造一个*n*比特和是很容易的（见[图 8-18](ch08.xhtml#ch08fig18)）。
- en: '![image](../images/08fig18.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig18.jpg)'
- en: '*Figure 8-18: Building an n-bit adder using half and full adders*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-18：使用半加法器和全加法器构建n比特加法器*'
- en: The two *n*-bit inputs, *A* and *B*, are passed into the adder bit-by-bit, with
    the LO bits input as *A*[0] and *B*[0], and so on up to HO bits *A*[*n*][–1] and
    *B*[*n*][–1]. *S*[0] is the LO bit of the sum, up to *S*[*n*][–1], and the final
    carry indicates whether the addition overflowed *n* bits.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 两个*n*位输入，*A*和*B*，逐位传入加法器，LO位输入为*A*[0]和*B*[0]，依此类推直到HO位*A*[*n*][–1]和*B*[*n*][–1]。*S*[0]是和的LO位，一直到*S*[*n*][–1]，最终进位表示加法是否溢出了*n*位。
- en: '**8.7.2.2 Using Seven-Segment LED Decoders**'
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.7.2.2 使用七段LED解码器**'
- en: Another common combinatorial circuit is the *seven-segment decoder*. Among the
    more important circuits in computer system design, decoder circuits enable the
    computer to recognize (or *decode*) a string of bits.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的组合电路是*七段解码器*。在计算机系统设计中，解码器电路使计算机能够识别（或*解码*）一串比特。
- en: The seven-segment decoder circuit accepts an input of 4 bits and determines
    which segments to illuminate on a seven-segment LED display. Because a seven-segment
    display contains seven output values (one for each segment), there are seven logic
    functions associated with it (segments 0 through 6). See [Figure 8-19](ch08.xhtml#ch08fig19)
    for the segment assignments. [Figure 8-20](ch08.xhtml#ch08fig20) shows the active
    segments for each of the 10 decimal values.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 七段解码器电路接受4位输入，并确定在七段LED显示器上点亮哪些段。由于七段显示器包含七个输出值（每个段一个），因此与之相关联有七个逻辑函数（段0至段6）。请参见[图8-19](ch08.xhtml#ch08fig19)了解段的分配。[图8-20](ch08.xhtml#ch08fig20)展示了每个十进制值的活跃段。
- en: '![image](../images/08fig19.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig19.jpg)'
- en: '*Figure 8-19: Seven-segment display*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-19：七段显示器*'
- en: '![image](../images/08fig20.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig20.jpg)'
- en: '*Figure 8-20: Seven-segment values for 0 through 9*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-20：0至9的七段值*'
- en: 'The four inputs to each of these seven Boolean functions are the 4 bits from
    a binary number in the range 0 through 9\. Let *D* be the HO bit of this number
    and *A* be the LO bit. Each segment’s logic function should produce a `1` (segment
    on) for all binary number inputs that have that segment illuminated in [Figure
    8-20](ch08.xhtml#ch08fig20). For example, *S*[4] (segment 4) should be illuminated
    for numbers 0, 2, 6, and 8, which correspond to the binary values 0000, 0010,
    0110, and 1000\. For each of the binary values that illuminates a segment, you
    will have one minterm in the logic equation:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 每个七个布尔函数的四个输入是从范围为0到9的二进制数字中提取的4位。设*D*为该数字的最高位（HO位），*A*为最低位（LO位）。每个段的逻辑函数应为所有在[图8-20](ch08.xhtml#ch08fig20)中该段被点亮的二进制数字输入产生`1`（段点亮）。例如，*S*[4]（段4）应在数字0、2、6和8时点亮，这些数字对应的二进制值分别为0000、0010、0110和1000。对于每一个点亮段的二进制值，你将有一个最小项在逻辑方程中：
- en: '[PRE14]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*S*[0] (segment 0), as a second example, is on for the numbers 0, 2, 3, 5,
    6, 7, 8, and 9, which correspond to the binary values 0000, 0010, 0011, 0101,
    0110, 0111, 1000, and 1001\. Therefore, the logic function for *S*[0] is as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*S*[0]（段0），作为第二个例子，对于数字0、2、3、5、6、7、8和9点亮，这些数字对应的二进制值为0000、0010、0011、0101、0110、0111、1000和1001。因此，*S*[0]的逻辑函数如下：'
- en: '[PRE15]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**8.7.2.3 Decoding Memory Addresses**'
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.7.2.3 解码内存地址**'
- en: A decoder is also commonly used in memory expansion. For example, suppose a
    system designer wishes to install four (identical) 256MB memory modules in a system
    to bring the total to 1GB of RAM. Each of these 256MB memory modules has 28 address
    lines (*A*[0]..*A*[27]), assuming each memory module is 8 bits wide (2^(28) ×
    8 bits is 256MB).^([4](footnotes.xhtml#fn8_4a))
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 解码器在内存扩展中也常被使用。例如，假设系统设计师希望在系统中安装四个（相同的）256MB内存模块，以使总内存达到1GB。每个256MB的内存模块有28条地址线（*A*[0]..*A*[27]），假设每个内存模块宽度为8位（2^(28)
    × 8位即为256MB）。^([4](footnotes.xhtml#fn8_4a))
- en: Unfortunately, if the system designer hooked up those four memory modules to
    the CPU’s address bus, each module would respond to the same addresses on the
    bus. Pandemonium would result. To correct this problem, each memory module needs
    to respond to a different set of addresses appearing on the full address bus (with
    a module address appearing on the LO 28 bits of the address bus). By adding a
    chip-select line to each of the memory modules, and using a two-input, four-output
    decoder circuit, we can use the chip select lines *A*[28] and *A*[29] to specify
    the HO 2 bits of the (now effectively 30-bit) memory address. See [Figure 8-21](ch08.xhtml#ch08fig21)
    for the details.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果系统设计者将这四个内存模块连接到 CPU 的地址总线上，每个模块都会响应总线上相同的地址。这将导致混乱。为了解决这个问题，每个内存模块需要响应出现在完整地址总线上的不同地址集合（地址总线的低
    28 位上会显示模块地址）。通过为每个内存模块添加一个芯片选择线，并使用一个两输入、四输出的解码电路，我们可以使用芯片选择线 *A*[28] 和 *A*[29]
    来指定（现在有效的 30 位）内存地址的高 2 位。详情请参见[图 8-21](ch08.xhtml#ch08fig21)。
- en: '![image](../images/08fig21.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig21.jpg)'
- en: '*Figure 8-21: Adding four 256MB memory modules to a system*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-21：向系统添加四个 256MB 内存模块*'
- en: 'The two- to four-line decoder circuit in [Figure 8-21](ch08.xhtml#ch08fig21)
    incorporates four different logic functions: one function for each of the outputs.
    Each combination of the input bits will activate a single chip-select line, and
    deactivate the other three. Assuming the inputs are *A* and *B* (*A* = *A*[28]
    and *B* = *A*[29]), the four output functions are as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-21](ch08.xhtml#ch08fig21)中的两到四线解码器电路包含四种不同的逻辑功能：每个输出一个功能。每种输入位的组合将激活单一的芯片选择线，并禁用其他三个。假设输入为
    *A* 和 *B*（*A* = *A*[28]，*B* = *A*[29]），四个输出功能如下：'
- en: '[PRE16]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Following standard electronic circuit notation, these equations use *Q* to denote
    an output.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 根据标准电子电路符号，这些方程使用 *Q* 来表示输出。
- en: 'Note that most circuit designers use *active low logic* for decoders and chip
    enables. This means that they enable a circuit when a low-input value (`0`) is
    supplied and disable the circuit when a high-input value (`1`) is supplied. Real-world
    decoding circuits would likely use the following sums of maxterms functions:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数电路设计师为解码器和芯片使能使用 *低电平有效逻辑*。这意味着当输入值为低电平（`0`）时，电路被启用；当输入值为高电平（`1`）时，电路被禁用。实际的解码电路可能会使用以下最大项函数的和：
- en: '[PRE17]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**8.7.2.4 Decoding Machine Instructions**'
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.7.2.4 解码机器指令**'
- en: Decoding circuits are also used to decode machine instructions. We’ll cover
    this subject in much greater depth in [Chapters 9](ch09.xhtml#ch09) and [10](ch10.xhtml#ch10),
    but a simple example is in order here.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 解码电路也用于解码机器指令。我们将在[第9章](ch09.xhtml#ch09)和[第10章](ch10.xhtml#ch10)中更深入地探讨这一主题，但这里我们先介绍一个简单的例子。
- en: Most modern computer systems represent machine instructions using binary values
    in memory. To execute an instruction, the CPU fetches the instruction’s binary
    value from memory, decodes it using decoder circuitry, and then does the appropriate
    work. To see how this is done, let’s create a fictional CPU with a very simple
    instruction set. [Figure 8-22](ch08.xhtml#ch08fig22) provides the instruction
    format (all the numeric codes that correspond to the various instructions) for
    our CPU. Within the 1-byte operation code (opcode), 3 bits (`iii`) represent the
    instruction, 2 bits (`ss`) the source operand, and 2 bits the destination operand
    (`dd`).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机系统使用内存中的二进制值来表示机器指令。为了执行指令，CPU 从内存中获取指令的二进制值，使用解码电路对其进行解码，然后执行相应的工作。为了了解这一过程，我们将创建一个具有非常简单指令集的虚构
    CPU。[图 8-22](ch08.xhtml#ch08fig22)提供了我们 CPU 的指令格式（所有对应各种指令的数字代码）。在 1 字节的操作码（opcode）中，3
    位（`iii`）表示指令，2 位（`ss`）表示源操作数，2 位表示目标操作数（`dd`）。
- en: '![image](../images/08fig22.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig22.jpg)'
- en: '*Figure 8-22: Instruction (opcode) format for a very simple CPU*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-22：一个非常简单的 CPU 的指令（操作码）格式*'
- en: To determine the 8-bit opcode for a given instruction, look up each component
    of the instruction in the tables in [Figure 8-22](ch08.xhtml#ch08fig22) and substitute
    the corresponding bit values.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定给定指令的 8 位操作码，可以在[图 8-22](ch08.xhtml#ch08fig22)的表格中查找指令的每个组成部分，并替换相应的位值。
- en: 'Let’s pick `mov(eax, ebx);` as our simple example. To convert this instruction
    to its numeric equivalent, `mov` is encoded as `000`, `eax` is encoded as `00`,
    and `ebx` is encoded as `01`. Assemble these three fields into the opcode byte
    (a packed data type), to obtain the bit value: `%00000001`. Therefore, the numeric
    value `$1` is the value for the `mov(eax, ebx);` instruction (see [Figure 8-23](ch08.xhtml#ch08fig23)).'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择`mov(eax, ebx);`作为我们的简单示例。为了将这条指令转换为其数值等效，`mov`被编码为`000`，`eax`被编码为`00`，`ebx`被编码为`01`。将这三个字段组装成操作码字节（一种压缩数据类型），得到比特值：`%00000001`。因此，数值`$1`是`mov(eax,
    ebx);`指令的值（见[图 8-23](ch08.xhtml#ch08fig23)）。
- en: '![image](../images/08fig23.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig23.jpg)'
- en: '*Figure 8-23: Encoding the `mov(eax, ebx);` instruction*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-23：编码`mov(eax, ebx);`指令*'
- en: A typical decoder circuit for this example appears in [Figure 8-24](ch08.xhtml#ch08fig24).
    The circuit uses three separate decoders to decode the individual fields of the
    opcode. This is much less complex than creating a single 7- to 128-line decoder
    to decode the entire opcode.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的典型解码器电路见[图 8-24](ch08.xhtml#ch08fig24)。该电路使用三个独立的解码器来解码操作码的各个字段。这比创建一个单一的7到128线解码器来解码整个操作码要简单得多。
- en: '![image](../images/08fig24.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig24.jpg)'
- en: '*Figure 8-24: Decoding simple machine instructions*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-24：解码简单的机器指令*'
- en: The circuit in [Figure 8-24](ch08.xhtml#ch08fig24) tells you which instruction
    and what operands a given opcode specifies. To actually execute this instruction,
    you must supply additional circuitry to select the source and destination operands
    from an array of registers and act accordingly upon those operands. Such circuitry
    is beyond the scope of this chapter, so we’ll save the juicy details for later.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-24](ch08.xhtml#ch08fig24)中的电路告诉你给定的操作码指定了哪条指令以及哪些操作数。要实际执行这条指令，你必须提供额外的电路来从一组寄存器中选择源操作数和目标操作数，并相应地对这些操作数进行处理。这样的电路超出了本章的范围，因此我们将把详细内容留到后面再讲。'
- en: '***8.7.3 Sequential and Clocked Logic***'
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***8.7.3 顺序和时钟逻辑***'
- en: One major problem with combinatorial logic is that it is *memoryless*. In theory,
    all logic function outputs depend only on the current inputs. Any change in the
    input values immediately appears on the outputs.^([5](footnotes.xhtml#fn8_5a))
    Unfortunately, computers need the ability to *remember* the results of past computations.
    This is the domain of sequential, or clocked, logic.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 组合逻辑的一个主要问题是它是*无记忆*的。从理论上讲，所有逻辑函数的输出仅依赖于当前输入。输入值的任何变化都会立即反映在输出上。^([5](footnotes.xhtml#fn8_5a))
    不幸的是，计算机需要能够*记住*过去计算的结果。这就是顺序逻辑或时钟逻辑的领域。
- en: '**8.7.3.1 The Set/Reset Flip-Flop**'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.7.3.1 置/复位触发器**'
- en: A *memory cell* is an electronic circuit that remembers an input value after
    the removal of that input value. The most basic memory unit is the *set/reset
    (S/R) flip-flop*. You can construct an S/R flip-flop memory cell using two NAND
    gates, as shown in [Figure 8-25](ch08.xhtml#ch08fig25). In this diagram, the outputs
    of the two NAND gates are recirculated to one of the inputs of the other NAND
    gate.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*存储单元*是一个电子电路，能够在去除输入值后仍然记住该输入值。最基本的存储单元是*置/复位（S/R）触发器*。你可以使用两个NAND门构建一个S/R触发器存储单元，如[图
    8-25](ch08.xhtml#ch08fig25)所示。在该图中，两个NAND门的输出被反馈到另一个NAND门的输入之一。'
- en: '![image](../images/08fig25.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig25.jpg)'
- en: '*Figure 8-25: Set/reset flip-flop constructed from NAND gates*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-25：由NAND门构建的置/复位触发器*'
- en: The *S* and *R* inputs are normally high, or `1`. If you toggle the *S* input
    by *temporarily* setting its value to `0` and then bringing it back to `1`, the
    *Q* output is set to `1`. Likewise, if you toggle the *R* input from `1` to `0`
    and back to `1`, this resets the *Q* output to `0`. *Q'* outputs the opposite
    of *Q*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*S*和*R*输入通常为高电平，即`1`。如果你通过*暂时*将*S*输入的值设置为`0`，然后再将其恢复为`1`，则*Q*输出被设置为`1`。同样，如果你将*R*输入从`1`切换到`0`，然后再切换回`1`，则将*Q*输出重置为`0`。*Q''*输出与*Q*相反。'
- en: If both *S* and *R* are `1`, then the *Q* output depends upon the original value
    of *Q* itself. That is, whatever *Q* happens to be, the top NAND gate continues
    to output that same value. If *Q* was originally `1`, then the bottom NAND gate
    receives two inputs of `1` (both *Q* and *R*), and the bottom NAND gate produces
    an output of `0` (*Q'*). As a result, the two inputs to the top NAND gate are
    `0` and `1`, and the top NAND gate produces an output of `1`, matching the original
    value for *Q*.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *S* 和 *R* 都为 `1`，则 *Q* 输出取决于 *Q* 的原始值。也就是说，不论 *Q* 是什么，顶端 NAND 门将继续输出相同的值。如果
    *Q* 最初为 `1`，则底部 NAND 门接收到两个输入为 `1`（*Q* 和 *R*），底部 NAND 门将输出 `0` (*Q'*)。因此，顶端 NAND
    门的两个输入为 `0` 和 `1`，顶端 NAND 门输出 `1`，与 *Q* 的原始值相匹配。
- en: On the other hand, if the original value of *Q* was `0`, then the inputs to
    the bottom NAND gate are *Q* = `0` and *R* = `1`, and the output of this bottom
    NAND gate is `1`. As a result, the inputs to the top NAND gate are *S =* `1` and
    *Q' =* `1`. This produces a `0` output, the original value of *Q*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果 *Q* 的原始值为 `0`，则底部 NAND 门的输入为 *Q* = `0` 和 *R* = `1`，该底部 NAND 门的输出为 `1`。因此，顶端
    NAND 门的输入为 *S =* `1` 和 *Q' =* `1`。这将产生一个 `0` 输出，即 *Q* 的原始值。
- en: Now suppose *Q* is `0`, *S* is `0`, and *R* is `1`. This sets the two inputs
    to the top NAND gate to `1` and `0`, forcing the output (*Q*) to `1`. Returning
    *S* to the high state does not change the output at all, because the value of
    *Q'* is `1`. You will obtain this same result if *Q* is `1`, *S* is `0`, and *R*
    is `1`. Again, this produces a *Q* output value of `1`, and again this value remains
    `1` even when *S* switches from `0` to `1`. To overcome this and produce a *Q*
    output of `1`, you must toggle the *S* input. The same idea applies to the *R*
    input, except that toggling it forces the *Q* output to `0` rather than to `1`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *Q* 为 `0`，*S* 为 `0`，*R* 为 `1`。这将把顶端 NAND 门的两个输入设置为 `1` 和 `0`，强制输出 (*Q*) 为
    `1`。将 *S* 恢复到高电平状态不会改变输出，因为 *Q'* 的值为 `1`。如果 *Q* 为 `1`，*S* 为 `0`，*R* 为 `1`，你也会得到相同的结果。同样，这会产生一个
    *Q* 输出值为 `1`，即使 *S* 从 `0` 切换到 `1`，这个值仍然保持为 `1`。为了克服这个问题并使 *Q* 输出为 `1`，你必须切换 *S*
    输入。同样的思想适用于 *R* 输入，不过切换它会将 *Q* 输出强制为 `0`，而不是 `1`。
- en: There is one catch to this circuit. It does not operate properly if you set
    both the *S* and *R* inputs to `0` simultaneously. This forces both the *Q* and
    *Q'* outputs to `1` (which is logically inconsistent). Whichever input remains
    `0` the longest determines the final state of the flip-flop. A flip-flop operating
    in this mode is said to be *unstable*.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个电路有一个陷阱。如果你同时将 *S* 和 *R* 输入都设置为 `0`，它将无法正常工作。这将强制 *Q* 和 *Q'* 输出都为 `1`（这在逻辑上是不一致的）。哪个输入保持
    `0` 的时间最长，就决定了触发器的最终状态。以这种方式操作的触发器被称为 *不稳定*。
- en: '[Table 8-9](ch08.xhtml#ch08tab09) lists all the output configurations for an
    S/R flip-flop based on the current inputs and the previous output values.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-9](ch08.xhtml#ch08tab09) 列出了基于当前输入和先前输出值的所有 S/R 触发器输出配置。'
- en: '**Table 8-9:** S/R Flip-Flop Output States Based on Current Inputs and Previous
    Outputs'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-9：** 基于当前输入和先前输出的 S/R 触发器输出状态'
- en: '| **Previous Q** | **Previous Q’** | **S input** | **R input** | **Q output**
    | **Q’ output** |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **前一个 Q** | **前一个 Q''** | **S 输入** | **R 输入** | **Q 输出** | **Q'' 输出** |'
- en: '| x^([6](footnotes.xhtml#fn8_6a)) | x | `0` (`1` > `0` > `1`) | `1` | `1` |
    `0` |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| x^([6](footnotes.xhtml#fn8_6a)) | x | `0` (`1` > `0` > `1`) | `1` | `1` |
    `0` |'
- en: '| x | x | `1` | `0` (`1` > `0` > `1`) | `0` | `1` |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| x | x | `1` | `0` (`1` > `0` > `1`) | `0` | `1` |'
- en: '| x | x | `0` | `0` | `1` | `1`^([7](footnotes.xhtml#fn8_7a)) |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| x | x | `0` | `0` | `1` | `1`^([7](footnotes.xhtml#fn8_7a)) |'
- en: '| `0` | `1` | `1` | `1` | `0` | `1` |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | `0` | `1` |'
- en: '| `1` | `0` | `1` | `1` | `1` | `0` |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | `1` | `0` |'
- en: '**8.7.3.2 The D Flip-Flop**'
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.7.3.2 D 触发器**'
- en: The only problem with the S/R flip-flop is that to be able to remember either
    a `0` or a `1` value, you must have two different inputs. A memory cell would
    be more valuable to us if we could specify the data value to remember with one
    input value and supply a second *clock input* value to *latch* the data input
    value.^([8](footnotes.xhtml#fn8_8a)) This type of flip-flop, the D flip-flop (*D*
    stands for *data*), uses the circuit in [Figure 8-26](ch08.xhtml#ch08fig26).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: S/R 触发器唯一的问题是，为了能够记住 `0` 或 `1` 的值，你必须有两个不同的输入。如果我们能够通过一个输入值来指定要记住的数据值，并且提供第二个
    *时钟输入* 来 *锁存* 数据输入值，那么存储单元对我们来说将更有价值。此类型的触发器，即 D 触发器（*D* 代表 *数据*），使用的是 [图 8-26](ch08.xhtml#ch08fig26)
    中的电路。
- en: '![image](../images/08fig26.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig26.jpg)'
- en: '*Figure 8-26: Implementing a D flip-flop with NAND gates*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-26：使用 NAND 门实现 D 触发器*'
- en: Assuming you fix the *Q* and *Q'* outputs to either `0`/`1` or `1`/`0`, sending
    a *clock pulse* that goes from `0` to `1` and back to `0` will copy the *D* input
    to the *Q* output (and set *Q'* to the inverse of *Q*). To see how this works,
    note that the right half of the circuit diagram in [Figure 8-26](ch08.xhtml#ch08fig26)
    is an S/R flip-flop. If the data input is `1` while the clock line is high, this
    places a `0` on the *S* input of the S/R flip-flop (and a `1` on the *R* input).
    Conversely, if the data input is `0` while the clock line is high, this places
    a `0` on the *R* input (and a `1` on the *S* input) of the S/R flip-flop, thus
    clearing the S/R flip-flop’s output. Whenever the clock input is low, both the
    *S* and *R* input are high, and the outputs of the S/R flip-flop do not change.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将*Q*和*Q'*输出固定为`0`/`1`或`1`/`0`，发送一个从`0`到`1`再到`0`的*时钟脉冲*，将把*D*输入复制到*Q*输出（并将*Q'*设置为*Q*的反值）。要了解它是如何工作的，注意到[图8-26](ch08.xhtml#ch08fig26)中电路图的右半部分是一个S/R触发器。如果数据输入为`1`，而时钟线为高电平，这会将`0`置于S/R触发器的*S*输入端（并将`1`置于*R*输入端）。相反，如果数据输入为`0`，而时钟线为高电平，这会将`0`置于S/R触发器的*R*输入端（并将`1`置于*S*输入端），从而清除S/R触发器的输出。每当时钟输入为低电平时，*S*和*R*输入都为高电平，S/R触发器的输出不会改变。
- en: Although remembering a single bit is often important, in most computer systems
    you want to remember a *group* of bits. You can do this by combining several D
    flip-flops in parallel. Concatenating flip-flops to store an *n*-bit value forms
    a *register.* The electronic schematic in [Figure 8-27](ch08.xhtml#ch08fig27)
    shows how to build an 8-bit register from a set of D flip-flops.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管记住一个单独的比特通常很重要，但在大多数计算机系统中，你需要记住一*组*比特。你可以通过将多个D触发器并联来实现这一点。将触发器串联以存储*n*位值形成一个*寄存器*。[图8-27](ch08.xhtml#ch08fig27)中的电子原理图展示了如何从一组D触发器构建一个8位寄存器。
- en: '![image](../images/08fig27.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig27.jpg)'
- en: '*Figure 8-27: An 8-bit register implemented with eight D flip-flops*'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-27：由八个D触发器实现的8位寄存器*'
- en: Note that the eight D flip-flops in [Figure 8-27](ch08.xhtml#ch08fig27) use
    a common clock line. This diagram does not show the *Q'* outputs on the flip-flops
    because they are rarely required in a register.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[图8-27](ch08.xhtml#ch08fig27)中的八个D触发器使用一个公共时钟线。该图没有显示触发器上的*Q'*输出，因为在寄存器中它们很少被需要。
- en: D flip-flops are useful for building many sequential circuits beyond simple
    registers. For example, you can build a *shift register* that shifts the bits
    one position to the left on each clock pulse. A 4-bit shift register appears in
    [Figure 8-28](ch08.xhtml#ch08fig28).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: D触发器在构建许多顺序电路时非常有用，超越了简单的寄存器。例如，你可以构建一个*移位寄存器*，它在每次时钟脉冲时将位向左移动一个位置。一个4位移位寄存器如[图8-28](ch08.xhtml#ch08fig28)所示。
- en: '![image](../images/08fig28.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig28.jpg)'
- en: '*Figure 8-28: A 4-bit shift register built from D flip-flops*'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-28：由D触发器构建的4位移位寄存器*'
- en: You can even build a *counter* that counts the number of times the clock toggles
    from `1` to `0` and back to `1` using flip-flops. The circuit in [Figure 8-29](ch08.xhtml#ch08fig29)
    implements a 4-bit counter using D flip-flops.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用触发器构建一个*计数器*，它计算时钟从`1`到`0`再回到`1`的切换次数。[图8-29](ch08.xhtml#ch08fig29)中的电路使用D触发器实现了一个4位计数器。
- en: '![image](../images/08fig29.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig29.jpg)'
- en: '*Figure 8-29: A 4-bit counter built from D flip-flops*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-29：由D触发器构建的4位计数器*'
- en: Surprisingly, you can build an entire CPU with combinatorial circuits and only
    a few additional sequential circuits. For example, you can build a simple state
    machine known as a *sequencer* by combining a counter and a decoder, as shown
    in [Figure 8-30](ch08.xhtml#ch08fig30).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 出乎意料的是，你可以用组合电路和少数额外的顺序电路构建一个完整的CPU。例如，你可以通过将计数器和解码器结合来构建一个简单的状态机，称为*序列器*，如[图8-30](ch08.xhtml#ch08fig30)所示。
- en: '![image](../images/08fig30.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig30.jpg)'
- en: '*Figure 8-30: A simple 16-state sequencer*'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-30：一个简单的16状态序列器*'
- en: For each cycle of the clock in [Figure 8-30](ch08.xhtml#ch08fig30), this sequencer
    activates one of its output lines. Those lines, in turn, may control other circuits.
    By “firing” those other circuits on each of the 16 output lines of the decoder,
    we can control the order in which the circuits accomplish their tasks. This is
    essential in a CPU, as we often need to control the sequence of various operations.
    For example, it wouldn’t be a good thing if the `add(eax, ebx);` instruction stored
    the result into EBX before fetching the source operand from EAX (or EBX). A simple
    sequencer can tell the CPU when to fetch the first operand, when to fetch the
    second operand, when to add them together, and when to store the result. However,
    we’re getting a little ahead of ourselves—we’ll discuss this in detail in the
    next two chapters.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[图 8-30](ch08.xhtml#ch08fig30)中的每一个时钟周期，这个序列发生器都会激活它的一个输出线。这些输出线反过来可能控制其他电路。通过在解码器的16条输出线上的“触发”这些其他电路，我们可以控制电路完成任务的顺序。这对于CPU至关重要，因为我们经常需要控制各种操作的顺序。例如，如果`add(eax,
    ebx);`指令在从EAX（或EBX）获取源操作数之前就把结果存储到EBX中，那就不好了。一个简单的序列发生器可以告诉CPU何时获取第一个操作数，何时获取第二个操作数，何时将它们相加，何时存储结果。然而，我们现在有些超前了——我们将在接下来的两章中详细讨论这个问题。
- en: '**8.8 For More Information**'
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**8.8 更多信息**'
- en: 'Horowitz, Paul, and Winfield Hill. *The Art of Electronics*. 3rd ed. Cambridge,
    UK: Cambridge University Press, 2015.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Horowitz, Paul, 和 Winfield Hill. *《电子艺术》*. 第3版. 英国剑桥：剑桥大学出版社, 2015.
- en: '**NOTE**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This chapter is not, by any means, a complete treatment of Boolean algebra
    and digital design. If you’re interested in learning more, consult one of the
    dozens of books on this subject.*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章并非全面讨论布尔代数和数字设计。如果你有兴趣深入了解，可以查阅该领域的众多书籍。*'
