- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: APPLICATION AND SYSTEM PROGRAMMING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序与系统编程**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: '[Chapter 9](ch09.xhtml#ch09) covered how web browsers work. You learned that
    browsers are complex application programs that provide software-implemented “computers”
    that support very high-level “instructions.” In this chapter, we’ll write a program
    that runs in a browser, followed by a similar program that doesn’t use the browser.
    The structure of the two programs is shown in [Figure 10-1](ch10.xhtml#ch10fig01).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.xhtml#ch09)介绍了网页浏览器是如何工作的。你了解到浏览器是复杂的应用程序，提供了软件实现的“计算机”，支持非常高级的“指令”。在本章中，我们将编写一个在浏览器中运行的程序，接着是一个不使用浏览器的类似程序。这两个程序的结构如[图10-1](ch10.xhtml#ch10fig01)所示。'
- en: The operating system hides much of the I/O device complexity from user programs.
    In a similar manner, a complex user program such as a browser hides much of the
    complexity of dealing with operating systems from application programs that are
    built on top of them. This is fine if you’re going to limit yourself to being
    a high-level application writer. But you need to know more if you’re going to
    be a system programmer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统隐藏了大部分I/O设备的复杂性，不让用户程序感知。同样，像浏览器这样的复杂用户程序，也将大部分操作系统的复杂性隐藏在其上构建的应用程序面前。如果你只打算做一个高级应用程序开发者，这没问题。但如果你想成为系统程序员，你需要了解更多。
- en: '![Image](../images/10fig01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig01.jpg)'
- en: '*Figure 10-1: Two program scenarios*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：两种程序场景*'
- en: This chapter includes lengthier JavaScript and C code examples than you’ve seen
    before. Don’t worry if you’re not fluent in these languages—you don’t need to
    know all the details to follow along.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含比你之前见过的更长的JavaScript和C代码示例。如果你对这些语言不熟悉，不用担心——你无需掌握所有细节就能跟上。
- en: Let’s look at a game in which the computer asks the user a series of questions
    to try to guess an animal. New animals and questions that distinguish them are
    added to the program as needed. The program “learns” by constructing a binary
    tree of knowledge.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个游戏，其中计算机向用户提出一系列问题，试图猜测一个动物。根据需要，新的动物和用于区分它们的问题会被添加到程序中。程序通过构建一个知识的二叉树来“学习”。
- en: 'The interaction between the *computer* (the `literal` text) and the *user*
    (the literal bold text) looks something like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机*（`literal`文本）与*用户*（粗体文字）之间的互动大致如下：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure 10-2](ch10.xhtml#ch10fig02) shows the implementation plan.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-2](ch10.xhtml#ch10fig02)显示了实现计划。'
- en: '![Image](../images/10fig02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig02.jpg)'
- en: '*Figure 10-2: Guess the Animal flowchart*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：猜动物流程图*'
- en: As you can see, we ask questions that guide our descent through the tree of
    knowledge. We congratulate ourselves when we guess correctly. Otherwise, we ask
    the user to supply the answer and a question, add them to the tree, and start
    over.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们提出问题，指导我们沿着知识树下降。当我们猜对时，我们会自我庆祝。否则，我们会要求用户提供答案和一个问题，将它们加入树中，然后重新开始。
- en: The program follows a path down the tree of knowledge on the left side. When
    it reaches the end of the path on the right, it either brags or adds to the knowledge
    base.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 程序沿着知识树的左侧路径前进。当它到达右侧路径的末端时，它要么炫耀，要么添加到知识库中。
- en: '**Guess the Animal Version 1: HTML and JavaScript**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**猜动物版本1：HTML和JavaScript**'
- en: On to the program. We’ll go about this in a way that, although convenient, will
    upset some of my colleagues. This is a *clever hack*—something that works but
    is a bit twisted and ugly. As you saw in the previous chapter, the DOM is a tree
    that is a subset of a DAG—same with a binary tree. We’re going to build the binary
    tree of knowledge in the DOM as a set of nested, invisible `<div>`s. We could
    create a data structure in JavaScript, but the browser already has something easy
    that works. As [Figure 10-3](ch10.xhtml#ch10fig03) shows, our program starts off
    with an initial question and two answers in the knowledge tree.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 进入程序部分。我们将以一种方便但可能让我的一些同事感到不满的方式进行。这是一个*巧妙的黑客技术*——虽然能工作，但有点曲折且不美观。正如你在前一章中看到的，DOM是一个树形结构，是DAG的一个子集——与二叉树相同。我们将在DOM中构建一个知识的二叉树，作为一组嵌套的、不可见的`<div>`元素。我们可以在JavaScript中创建一个数据结构，但浏览器已经有了一个简单可用的解决方案。如[图10-3](ch10.xhtml#ch10fig03)所示，我们的程序从一个初始问题和两个答案开始，位于知识树中。
- en: '![Image](../images/10fig03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig03.jpg)'
- en: '*Figure 10-3: Initial knowledge tree*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：初始知识树*'
- en: Let’s play the game. We answer `yes` in response to `Does it bark?` and when
    the program guesses `Is it a dog?` we answer `no`. The program then asks `What
    is it?` and we respond with `giant purple snorklewhacker`. The program then asks
    us what question would distinguish a giant purple snorklewhacker from a dog and
    uses our response of `Does it live in an anxiety closet?` to modify the knowledge
    tree, as shown in [Figure 10-4](ch10.xhtml#ch10fig04).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始玩这个游戏。当程序问`Does it bark?`时，我们回答`yes`，当程序猜到`Is it a dog?`时，我们回答`no`。接着程序问`What
    is it?`，我们回答`giant purple snorklewhacker`。然后，程序问我们，什么问题能区分巨型紫色潜水鱼与狗，我们用`Does it
    live in an anxiety closet?`作为答案，程序根据我们的回答修改了知识树，具体如下所示[Figure 10-4](ch10.xhtml#ch10fig04)。
- en: '![Image](../images/10fig04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig04.jpg)'
- en: '*Figure 10-4: Modified knowledge tree*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 10-4: 修改后的知识树*'
- en: '***Application-Level Skeleton***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用层骨架***'
- en: '[Listing 10-1](ch10.xhtml#ch10list01) shows the web page skeleton into which
    we’ll add the code. Purists would be very upset at this because it combines HTML,
    CSS, and JavaScript into a single file. But we’re building a simple program, not
    a website, so it’s convenient to have everything in one place.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 10-1](ch10.xhtml#ch10list01)展示了我们将添加代码的网页骨架。纯粹主义者可能会对此感到非常不满，因为它将HTML、CSS和JavaScript结合在一个文件中。但我们正在构建一个简单的程序，而不是一个网站，因此将所有内容集中在一个地方非常方便。'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-1: Web page skeleton*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-1: 网页骨架*'
- en: You can change the `title` to something like `Guess the Animal` yourself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自行将`title`更改为例如`猜猜是什么动物`之类的内容。
- en: You learned about web browser components in the last chapter (see [Figure 9-9](ch09.xhtml#ch09fig09)).
    Now we’ll put some of them to use.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章你了解了网页浏览器的组成部分（参见[Figure 9-9](ch09.xhtml#ch09fig09)）。现在我们将实际使用其中的一些。
- en: '***Web Page Body***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***网页主体***'
- en: Let’s start by looking at the `<body>` of the program in [Listing 10-2](ch10.xhtml#ch10list02).
    This replaces the `<!-- HTML goes here -->` from line 24 of [Listing 10-1](ch10.xhtml#ch10list01).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[Listing 10-2](ch10.xhtml#ch10list02)中查看程序的`<body>`部分。这部分代码替换了[Listing 10-1](ch10.xhtml#ch10list01)第24行中的`<!--
    HTML goes here -->`。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-2: Guess the Animal HTML*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-2: 猜猜是什么动物 HTML*'
- en: You can see in lines 3 through 8 that the knowledge tree is preloaded with an
    initial question and answers. The `string` attribute is the question, except for
    leaf nodes where it is the animal name. The question contains two `<div>`s, the
    first being for the `yes` answer and the second for the `no`. The tree is wrapped
    in a `<div>` styled so that it’s never visible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到第3到8行，知识树已预加载了一个初始问题和答案。`string`属性是问题，除了叶子节点外，它是动物名称。问题包含两个`<div>`，第一个用于`yes`答案，第二个用于`no`答案。整个树被包裹在一个`<div>`中，样式设置为不可见。
- en: The `dialog` in lines 10 through 12 holds the conversation between the computer
    and the player. Then `what-is-it` (lines 16–19) contains a text field for the
    name of a new animal and a button the player presses when done. After that, `new-question`
    (lines 23–28) contains a text field for the new question and a button the player
    presses when done. The yes and no buttons are in `yesno` (lines 32–35). The three
    user input `<div>`s (lines 16, 23, and 32) have a `start-hidden` class that is
    used to make these values invisible at the beginning of a game.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第10到12行的`dialog`包含计算机与玩家之间的对话。接着`what-is-it`（第16到19行）包含一个文本框，用于输入新动物的名称，并且有一个按钮，玩家点击完成后即可提交。之后，`new-question`（第23到28行）包含一个文本框，用于输入新问题，并且有一个按钮，玩家点击完成后即可提交。`yesno`（第32到35行）包含“是”和“否”按钮。三个用户输入的`<div>`（第16、23、32行）都有一个`start-hidden`类，用于在游戏开始时将这些元素设为不可见。
- en: '***The JavaScript***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***JavaScript***'
- en: Let’s move on to the actual JavaScript. The first part is shown in [Listing
    10-3](ch10.xhtml#ch10list03).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入实际的JavaScript部分。第一部分显示在[Listing 10-3](ch10.xhtml#ch10list03)中。
- en: The first thing we do is declare the variable `node` where the skeleton says
    `<!-- JavaScript goes here -->` on line 14 of [Listing 10-1](ch10.xhtml#ch10list01).
    Although it could go inside the document ready function, putting it outside makes
    it easier to access using the browser developer console. We also declare two functions
    outside of the document ready function since they don’t rely on the page being
    loaded.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个变量`node`，它位于[Listing 10-1](ch10.xhtml#ch10list01)第14行的骨架中，内容为`<!-- JavaScript
    goes here -->`。虽然它可以放在文档就绪函数内部，但将其放在外部可以更方便地通过浏览器开发者工具访问。我们还在文档就绪函数外声明了两个函数，因为它们不依赖于页面是否加载完成。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-3: Guess the Animal JavaScript variable and functions*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-3: 猜猜是什么动物 JavaScript 变量与函数*'
- en: Next, the `<!-- JavaScript to run when document ready -->` from line 17 of [Listing
    10-1](ch10.xhtml#ch10list01) gets the five things shown in [Listing 10-4](ch10.xhtml#ch10list04).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[Listing 10-1](ch10.xhtml#ch10list01)第17行中的`<!-- JavaScript to run when
    document ready -->`会获取[Listing 10-4](ch10.xhtml#ch10list04)中显示的五个元素。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-4: Guess the Animal document ready function JavaScript*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-4: 猜动物文档就绪函数 JavaScript*'
- en: We invoke the `restart` function (line 1) to start the game. The other four
    things are *event handlers*, the JavaScript equivalent of the interrupt handlers
    introduced in [Chapter 5](ch05.xhtml#ch05). There is one event handler for each
    of the four `button` elements. Each handler calls an anonymous function (an inline
    function that doesn’t have a name) when the associated button is pressed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`restart`函数（第1行）来启动游戏。其他四个是*事件处理程序*，它们是[第5章](ch05.xhtml#ch05)中介绍的中断处理程序的
    JavaScript 等效物。每个`button`元素都有一个事件处理程序。每个处理程序在关联的按钮被按下时调用一个匿名函数（一个没有名称的内联函数）。
- en: Practice your text-editing skills by typing in the program. Save the results
    in a file named something like *gta.html* and then open the file in your browser.
    Play the game. Open up the developer tools in your browser and find the HTML inspector;
    this allows you to look at the HTML that makes up the web page. Watch the tree
    of knowledge get built as you play.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入程序来练习你的文本编辑技能。将结果保存在一个名为*gta.html*的文件中，然后在浏览器中打开该文件。玩这个游戏。打开浏览器中的开发者工具，找到
    HTML 检查器；它允许你查看构成网页的 HTML。随着游戏进行，观察知识树是如何建立的。
- en: '***The CSS***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***CSS***'
- en: 'As we touched on in [Chapter 9](ch09.xhtml#ch09), classes give us a way to
    label elements so that they can be easily selected. CSS is primarily used for
    static declarations of properties; it becomes dynamic mostly via programmatic
    manipulation. The HTML in [Listing 10-2](ch10.xhtml#ch10list02) has two CSS classes:
    `start-hidden` is dynamic, and `invisible` is static.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第9章](ch09.xhtml#ch09)中提到的，类给我们提供了一种为元素打标签的方式，以便可以轻松选择它们。CSS 主要用于声明属性的静态声明；它通过编程操作变得动态。[Listing
    10-2](ch10.xhtml#ch10list02)中的 HTML 有两个 CSS 类：`start-hidden`是动态的，`invisible`是静态的。
- en: The `class` attribute is used to make several of the HTML elements in [Listing
    10-5](ch10.xhtml#ch10list05) members of the `start-hidden` class. This isn’t just
    to make our program classy; it’s to give us a way to locate all of these elements
    with a simple selector. These elements are made invisible whenever the program
    is started or restarted. They’re made visible as the program runs, and `start-hidden`
    allows us to reset everything simply.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`属性用于将[Listing 10-5](ch10.xhtml#ch10list05)中多个 HTML 元素归类为`start-hidden`类。这不仅是为了让我们的程序看起来更有格调；它是为了给我们一种通过简单的选择器来定位这些元素的方式。这些元素在程序启动或重启时被隐藏。当程序运行时，它们变得可见，而`start-hidden`允许我们简单地重置所有内容。'
- en: The element with the `invisible` class is always invisible, as it’s the tree
    of knowledge. Thus, the CSS shown in [Listing 10-5](ch10.xhtml#ch10list05) replaces
    the `<!-- CSS goes here -->` in line 9 of [Listing 10-1](ch10.xhtml#ch10list01).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`invisible`类的元素始终不可见，因为它代表了知识树。因此，[Listing 10-5](ch10.xhtml#ch10list05)中显示的
    CSS 会替换[Listing 10-1](ch10.xhtml#ch10list01)第9行中的`<!-- CSS goes here -->`。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-5: Guess the Animal CSS*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-5: 猜动物 CSS*'
- en: 'Note that you can use *inline style* for simple CSS instead, because of course
    there has to be more than one way to do things in a browser. Writing line 3 of
    [Listing 10-2](ch10.xhtml#ch10list02) as `<div id="root" style="display: none">`
    would have the same effect.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，你可以使用*内联样式*来代替简单的 CSS，因为浏览器中当然必须有不止一种方法来完成同一任务。将[Listing 10-2](ch10.xhtml#ch10list02)的第3行写成`<div
    id="root" style="display: none">`也会产生相同的效果。'
- en: '**Guess the Animal Version 2: C**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**猜动物版本 2：C**'
- en: As I’ve mentioned, browsers are high-level virtual machines—all their functionality
    is implemented in software. This enables us to quickly and easily construct our
    program in part by hiding some of the important underpinnings. Let’s rewrite the
    program in C so that more of the primitive actions that browsers hide are exposed.
    This discussion assumes a UNIX-derived operating system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，浏览器是高级虚拟机——它们的所有功能都是通过软件实现的。这使我们能够通过隐藏一些重要的底层实现，快速而轻松地构建程序。我们可以用 C
    语言重写程序，以便更多浏览器隐藏的原始操作能够暴露出来。这个讨论假设使用的是类 UNIX 操作系统。
- en: '***Terminals and the Command Line***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***终端和命令行***'
- en: Our C program is going to be extremely retro in that it’s not going to have
    any fancy buttons or graphics. It will use the command line in a manner similar
    to the ancient game of *Adventure*. This is a great opportunity to learn more
    about how input and output work rather than relying on the fancy widgets built
    into browsers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 C 程序将非常复古，因为它不会有任何花哨的按钮或图形界面。它将以类似于古老游戏*冒险*的方式使用命令行。这是一个学习输入输出工作原理的绝佳机会，而不是依赖浏览器内置的花哨小部件。
- en: What do I mean by “retro” and “command line”? As [Chapter 1](ch01.xhtml#ch01)
    mentions, human language likely started as sounds and gestures, with writing being
    invented *much* later. Computer language is the opposite. While interaction did
    start with pushing buttons and flipping switches when computers still had front
    panels, it quickly evolved to written language, with gesture and sound recognition
    coming later. Humans would type and computers would “type back” on terminals (see
    “[Terminals](ch06.xhtml#ch06lev2sec19)” on [page 176](ch06.xhtml#page_176)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的“复古”和“命令行”是什么意思？正如[第 1 章](ch01.xhtml#ch01)中提到的，人类语言可能最初是通过声音和手势开始的，书写是在*很久*以后才发明的。计算机语言则恰恰相反。虽然最初与计算机的互动是通过按按钮和拨动开关来进行的，当时计算机还有前面板，但它迅速演变为书面语言，手势和声音识别则是在之后才出现的。人类通过键盘输入，计算机则在终端上“回键”（见[第
    6 章](ch06.xhtml#ch06lev2sec19)的[终端](ch06.xhtml#ch06)部分，[第 176 页](ch06.xhtml#page_176)）。
- en: You probably use a *graphical user interface (GUI)* to communicate with your
    computer. It’s actually pretty Stone Age if you think about it. *“Ugh! Look! Button!
    Press! Friend! Cat video! Like! Tweet Tweet Tweet!”* GUIs mostly use gestural
    language, which works well for casual computer users because it doesn’t rely too
    much on users’ memories—or at least it didn’t in the days before all the icons
    were changed to be universally unrecognizable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能使用*图形用户界面（GUI）*与计算机进行交流。如果你仔细想想，它其实挺原始的。*“呃！看！按钮！按！朋友！猫视频！点赞！发推！发推！”* GUI
    主要使用手势语言，这对普通计算机用户来说非常有效，因为它不太依赖于用户的记忆——至少在所有图标都改成了普遍无法识别之前是这样的。
- en: Most computer systems still support a written command line interface behind
    all the fancy graphics. Terminals are now implemented in software instead of being
    a piece of hardware external to the computer. You’ll get a *command prompt* if
    you open up the terminal application on your computer; you can type in it, and
    it will respond.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机系统仍然支持在所有花哨的图形背后使用书面命令行接口。现在，终端是通过软件实现的，而不再是计算机外部的硬件组件。如果你打开计算机上的终端应用程序，你会看到一个*命令提示符*；你可以在里面输入命令，它会作出响应。
- en: Instead of using buttons for yes and no, the C version of our program expects
    the player to type `y` or `n` into the terminal program, followed by the ENTER,
    RETURN, or ↵ key (depending on keyboard). The player similarly types in new animal
    names and questions. The program also accepts `q` to quit.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的 C 版本并不使用按钮来表示是与否，而是要求玩家在终端程序中键入 `y` 或 `n`，然后按下 ENTER、RETURN 或 ↵ 键（取决于键盘）。玩家同样键入新的动物名称和问题。程序还接受
    `q` 退出。
- en: '***Building the Program***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建程序***'
- en: Because C is a compiled language, we can’t just “run” the source code like we
    could with the interpreted JavaScript version. We have to convert it into machine
    language first. We can do this pretty easily using the command line. If the source
    is in a file named, for example, *gta.c*, you can generate a machine language
    file called *gta* by typing the command shown in [Figure 10-5](ch10.xhtml#ch10fig05)
    into your terminal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 C 是一种编译语言，我们不能像运行解释型的 JavaScript 那样直接“运行”源代码。我们必须先将其转换为机器语言。我们可以通过命令行轻松完成这一过程。如果源代码保存在一个名为
    *gta.c* 的文件中，你可以通过在终端中输入[图 10-5](ch10.xhtml#ch10fig05)所示的命令，生成一个名为 *gta* 的机器语言文件。
- en: '![Image](../images/10fig05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig05.jpg)'
- en: '*Figure 10-5: Building the program*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：构建程序*'
- en: Once you have the output file, you can typically just type its name to run it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有了输出文件，你通常只需要键入文件名来运行它。
- en: '***Terminals and Device Drivers***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***终端与设备驱动程序***'
- en: A terminal is an I/O device, and—as mentioned in “[System and User Space](ch05.xhtml#ch05lev1sec8)”
    on [page 133](ch05.xhtml#page_133)—user programs don’t talk to I/O devices directly;
    the operating system mediates, as shown in [Figure 10-6](ch10.xhtml#ch10fig06).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 终端是一个输入输出设备，正如在[第 5 章](ch05.xhtml#ch05lev1sec8)的[“系统与用户空间”](ch05.xhtml#ch05)部分中提到的，用户程序并不直接与输入输出设备通信；操作系统充当中介，正如[图
    10-6](ch10.xhtml#ch10fig06)所示。
- en: '![Image](../images/10fig06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig06.jpg)'
- en: '*Figure 10-6: I/O device mediation*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：输入输出设备中介*'
- en: Back when terminals were separate devices, the computer and the terminal were
    connected through an RS-232 serial connection (see “[Serial Communication](ch06.xhtml#ch06lev2sec9)”
    on [page 152](ch06.xhtml#page_152)). There were physical wires connecting terminals
    and computers. Operating systems still pretend that this type of connection exists
    today, mimicking it in software so that legacy programs continue to work unmodified.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端曾是独立设备的时代，计算机和终端通过RS-232串行连接相连（参见[《串行通信》](ch06.xhtml#ch06lev2sec9)，见[第152页](ch06.xhtml#page_152)）。终端和计算机之间有物理连接的电缆。操作系统至今仍假装这种连接方式存在，通过软件模拟它，以便老旧程序可以继续正常工作。
- en: '***Context Switching***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***上下文切换***'
- en: The device driver is more complicated than it seems because a primary reason
    we have operating systems is so that more than one user program can run at the
    same time. Because the computer has only one set of registers, the OS must save
    and restore their contents when switching between user programs. There’s actually
    a lot of stuff that needs to be saved and restored other than the CPU registers,
    including the MMU registers and state of any I/O. The whole pile is called the
    *process context*, or just *context*. We don’t want to do *context switching*
    frivolously because the size of the context makes it comparatively expensive.
    The system call process is shown in [Figure 10-7](ch10.xhtml#ch10fig07).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序比看起来更复杂，因为操作系统的一个主要作用就是让多个用户程序能够同时运行。由于计算机只有一组寄存器，操作系统在切换用户程序时必须保存并恢复这些寄存器的内容。实际上，还有很多内容需要保存和恢复，不仅仅是CPU寄存器，包括MMU寄存器和任何I/O的状态。这些内容统称为*进程上下文*，或简称*上下文*。我们不想轻率地进行*上下文切换*，因为上下文的大小使得切换代价较高。[图
    10-7](ch10.xhtml#ch10fig07)展示了系统调用过程。
- en: '![Image](../images/10fig07.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig07.jpg)'
- en: '*Figure 10-7: Context switching*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：上下文切换*'
- en: As you can see, a lot of work happens behind the scenes when a system call is
    made. And, as mentioned back in “[Relative Addressing](ch05.xhtml#ch05lev1sec5)”
    on [page 128](ch05.xhtml#page_128), sometimes the OS will *sleep* a user program,
    even when it can fulfill a request, in order to give another user program a chance
    to run.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在进行系统调用时，后台发生了很多工作。而正如在[《相对寻址》](ch05.xhtml#ch05lev1sec5)中提到的那样，系统有时会*挂起*用户程序，即使它能够满足请求，也会挂起，以便给其他用户程序提供执行机会。
- en: We don’t want to do a context switch every time a user presses a key. One way
    to minimize context switching in this case is to realize we usually don’t care
    what the user is typing until they hit ENTER. The user program uses a system call
    to indicate that it wants to *read* from the terminal. This puts the user program
    to sleep, because it can’t do anything while it’s waiting, which allows the OS
    to perform some other operation, such as switching to run another program. The
    *device driver* that handles the idiosyncrasies of the physical device can save
    characters from the terminal in a *buffer* and *wake up* the user program only
    when the user hits ENTER instead of on every keypress.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望每次用户按下一个键时都进行上下文切换。在这种情况下，减少上下文切换的一种方式是意识到，通常我们并不关心用户正在输入什么，直到他们按下ENTER键。用户程序通过系统调用表明它希望*从终端读取*数据。这样用户程序就会被挂起，因为在等待期间它无法做任何事情，这使得操作系统可以执行其他操作，比如切换到运行另一个程序。处理物理设备特性的*设备驱动程序*可以将字符保存在一个*缓冲区*中，并且只有在用户按下ENTER时才*唤醒*用户程序，而不是在每次按键时都唤醒。
- en: What’s a buffer? We saw one back in [Figure 6-25](ch06.xhtml#ch06fig25); it’s
    a *first-in, first-out (FIFO)* data structure, at least in software land. (In
    hardware land, a buffer is often a circuit used to protect delicate components
    from buffoons.) [Figure 10-8](ch10.xhtml#ch10fig08) depicts a FIFO, also known
    as a *queue*, which is similar to being in line at the grocery store. As with
    stacks, a FIFO can overflow by running out of space and underflow by fetching
    from an empty queue.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是缓冲区？我们在[图 6-25](ch06.xhtml#ch06fig25)中看到过一个；它是一个*先进先出（FIFO）*的数据结构，至少在软件领域是这样的。（在硬件领域，缓冲区通常是用来保护精密组件免受愚蠢操作影响的电路。）[图
    10-8](ch10.xhtml#ch10fig08)展示了一个FIFO，也称为*队列*，这类似于在超市排队。与栈一样，FIFO也可能会因空间不足而溢出，或因从空队列取数据而发生下溢。
- en: '![Image](../images/10fig08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig08.jpg)'
- en: '*Figure 10-8: Dog in queue*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：排队中的狗*'
- en: Terminals usually operate in full-duplex mode (see “[Serial Communication](ch06.xhtml#ch06lev2sec9)”
    on [page 152](ch06.xhtml#page_152)), which means there is no direct connection
    between the keyboard and the display; the keyboard sends data to the computer,
    and the display receives data from the computer. Originally, as mentioned earlier,
    there were separate physical wires for each direction. It’s not enough, then,
    for the terminal device driver to buffer up the input because the user will get
    confused unless what they type is *echoed* so they can see it. And terminals are
    often slower than programs that write to them, so an *output buffer* is used in
    addition to the *input buffer*. A program is put to sleep if it tries to write
    to a full output buffer. The driver might provide the user some feedback, such
    as beeping if the input buffer becomes full. The part of the driver that we’ve
    been discussing looks like [Figure 10-9](ch10.xhtml#ch10fig09).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 终端通常以全双工模式工作（参见[“串行通信”](ch06.xhtml#ch06lev2sec9)，[第152页](ch06.xhtml#page_152)），这意味着键盘和显示器之间没有直接连接；键盘将数据发送到计算机，显示器从计算机接收数据。如前所述，最初每个方向都有单独的物理线路。那么，终端设备驱动程序仅仅缓存输入是不够的，因为如果用户输入的内容没有被*回显*，他们将会感到困惑，这样他们才能看到自己输入了什么。而且终端的速度通常比写入它们的程序要慢，因此除了*输入缓冲区*，还会使用*输出缓冲区*。如果程序尝试向已满的输出缓冲区写入数据，它会被挂起。如果输入缓冲区已满，驱动程序可能会向用户提供一些反馈，例如发出哔声。我们讨论的这部分驱动程序看起来像是[图
    10-9](ch10.xhtml#ch10fig09)。
- en: '![Image](../images/10fig09.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig09.jpg)'
- en: '*Figure 10-9: Terminal device driver buffering and echoing*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9：终端设备驱动程序的缓冲和回显*'
- en: Real device drivers are more complicated. Additional system calls are used to
    modify the driver settings. Echoing can be turned on and off. Buffering can be
    turned off, which is known as *raw* mode, whereas turning it on is known, of course,
    as *cooked* mode. The key(s) that wake up the user program can be set, along with
    much more, such as which key erases characters (usually BACKSPACE or DELETE).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的设备驱动程序要复杂得多。需要使用额外的系统调用来修改驱动程序设置。回显功能可以开启或关闭。缓冲功能可以关闭，这被称为*原始模式*，而开启缓冲则被称为*烹饪模式*。还可以设置唤醒用户程序的按键，以及更多内容，比如哪个键用于删除字符（通常是BACKSPACE或DELETE）。
- en: '***Standard I/O***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***标准输入/输出***'
- en: Buffering in the device driver solves only part of the problem. User programs
    have similar issues. It doesn’t do any good to have the device driver buffer up
    input just to have a user program make a system call for each character. The output
    buffer doesn’t help too much if the user program makes a system call to write
    each character. This is a common enough situation that it prompted the creation
    of the *standard input/output* library (`stdio`), which contains buffered I/O
    functions for user programs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序中的缓冲只解决了问题的一部分。用户程序也有类似的问题。仅仅让设备驱动程序缓存输入，而用户程序每次为每个字符进行系统调用，是没有用的。如果用户程序每次为每个字符进行系统调用来写入输出缓冲区，那么输出缓冲区也帮助不大。这种情况足够常见，因此促成了*标准输入/输出*库（`stdio`）的创建，该库为用户程序提供了缓冲输入输出功能。
- en: The `stdio` library supports buffered input, in which as much input as possible
    is read from the device driver in a single system call and placed into a buffer.
    The user program gets characters from the buffer until it’s empty, then tries
    to get more. On the output side, characters are buffered until either the buffer
    is full or an important character such as a newline occurs. Together it looks
    like [Figure 10-10](ch10.xhtml#ch10fig10).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio` 库支持缓冲输入，其中尽可能多的输入通过一次系统调用从设备驱动程序读取并放入缓冲区。用户程序从缓冲区获取字符，直到缓冲区为空，然后尝试获取更多字符。在输出方面，字符会被缓冲，直到缓冲区满或出现重要字符（如换行符）。合起来看像是[图
    10-10](ch10.xhtml#ch10fig10)。'
- en: '![Image](../images/10fig10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig10.jpg)'
- en: '*Figure 10-10: User program with stdio buffering*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-10：带有 stdio 缓冲的用户程序*'
- en: Seems like a lot of work just to make things run efficiently! And we’re not
    done yet. How does the user program get connected to the terminal device driver?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来要做很多工作才能让事情高效运行！而我们还没有完成呢。用户程序是如何连接到终端设备驱动程序的呢？
- en: It’s way easier to reference someone by their name than it is to provide their
    complete description, and operating systems take a similar approach to access
    files. The `open` system call converts a filename into a *handle* or *file descriptor*
    that can be used to reference the file until it is closed via the `close` system
    call. This is akin to getting a claim ticket when you check your backpack in a
    museum. The `stdio` library includes analogous `fopen` and `fclose` functions
    that use the system calls but also set up and tear down the buffering system.
    Because the UNIX abstractions treat devices just like files, you can open a special
    file such as */dev/tty* to access a terminal device.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 引用某人的名字比提供他们的完整描述要容易得多，操作系统在访问文件时采取了类似的方式。`open` 系统调用将文件名转换为一个 *句柄* 或 *文件描述符*，可以在文件关闭前通过
    `close` 系统调用引用该文件。这类似于你在博物馆存放背包时获得一个领取票。`stdio` 库包含类似的 `fopen` 和 `fclose` 函数，它们使用系统调用，并且还设置和销毁缓冲系统。由于
    UNIX 的抽象方式将设备视为文件，因此你可以打开类似 */dev/tty* 的特殊文件来访问终端设备。
- en: '***Circular Buffers***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***循环缓冲区***'
- en: Earlier I said queues are like being in line at a grocery store. Although they
    do have that outward appearance, that’s not how buffers such as the `stdio` output
    buffer in [Figure 10-10](ch10.xhtml#ch10fig10) are actually implemented.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，队列就像是在杂货店排队。虽然它们确实有这种外观，但像 `stdio` 输出缓冲区（见[图 10-10](ch10.xhtml#ch10fig10)）这样的缓冲区，实际上并不是这样实现的。
- en: Think about what happens in a grocery line. When the person in front is done,
    everybody else in line must move forward one position. Let’s queue up a `frog`,
    as shown in [Figure 10-11](ch10.xhtml#ch10fig11). As you can see, we need to keep
    track of the end of the line so we know where to insert things.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 想想在杂货店排队时会发生什么。当前面的人排完队，其他人都必须往前移动一个位置。让我们排一个 `frog`，如[图 10-11](ch10.xhtml#ch10fig11)所示。正如你所看到的，我们需要跟踪队列的末尾，以便知道在哪里插入新的元素。
- en: '![Image](../images/10fig11.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig11.jpg)'
- en: '*Figure 10-11: Inserting into a queue*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：向队列中插入*'
- en: Now let’s look at what happens when the `frog` is removed from the queue ([Figure
    10-12](ch10.xhtml#ch10fig12)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看当 `frog` 从队列中移除时会发生什么（见[图 10-12](ch10.xhtml#ch10fig12)）。
- en: '![Image](../images/10fig12.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig12.jpg)'
- en: '*Figure 10-12: Removing from a queue*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12：从队列中移除*'
- en: As you can see, a lot of work is involved. When the `f` is removed, the `r`
    must be copied to where the `f` was, then the `o` to where the `r` was, and so
    on. Let’s try a different approach. Rather than everyone in the line moving, let’s
    have the checker get some exercise in [Figure 10-13](ch10.xhtml#ch10fig13).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这需要做很多工作。当 `f` 被移除时，`r` 必须复制到 `f` 的位置，然后 `o` 复制到 `r` 的位置，依此类推。让我们试试另一种方法。与其让队列中的每个人都移动，不如让检查器在[图
    10-13](ch10.xhtml#ch10fig13)中做些运动。
- en: '![Image](../images/10fig13.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig13.jpg)'
- en: '*Figure 10-13: Removing from a queue by moving the checker*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-13：通过移动检查器从队列中移除*'
- en: This is a lot less work, except for the checker. But it causes a new problem.
    At some point, the line backs up to the door even though there’s space at the
    front. Nobody else can get in line.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这要轻松得多，除了检查器之外。但它也带来了一个新问题。某一时刻，队列会排到门口，尽管前面还有空间。此时，其他人无法再加入队列。
- en: What we need is some way to funnel new people into the space at the front of
    the line. We can do this by bending the line so that it’s circular, as shown in
    [Figure 10-14](ch10.xhtml#ch10fig14).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一种方法，将新的人引导到队列前端的空间中。我们可以通过将队列弯曲成一个循环的方式来实现这一点，如[图 10-14](ch10.xhtml#ch10fig14)所示。
- en: '![Image](../images/10fig14.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig14.jpg)'
- en: '*Figure 10-14: Circular buffer*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-14：循环缓冲区*'
- en: As you can see, data can be added to the queue as long as the *in* arrow is
    clockwise from the *out* arrow. Likewise, data in the queue can be removed as
    long as the out arrow is counterclockwise from the in arrow. A bit of arithmetic
    is needed to wrap around from the end of the buffer to the beginning. The next
    location is the current one plus 1, modulo the buffer size.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，数据可以按顺时针方向加入队列，只要 *入队* 箭头位于 *出队* 箭头的顺时针方向。同样，数据可以按逆时针方向从队列中移除，只要出队箭头位于入队箭头的逆时针方向。为了从缓冲区的末尾回绕到开头，需要做一些算术运算。下一个位置是当前的位置加
    1，取模缓冲区大小。
- en: These structures have many names, including *circular buffers*, *circular queues*,
    and *ring buffers*. They’re a pretty standard approach, and not just in `stdio`
    or device drivers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构有很多名字，包括 *循环缓冲区*、*循环队列* 和 *环形缓冲区*。它们是一种相当标准的方法，不仅在 `stdio` 或设备驱动中使用。
- en: '***Better Code Through Good Abstractions***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过良好的抽象实现更好的代码***'
- en: Every time we play the Guess the Animal game, we start over from scratch with
    a program that knows only about cats and dogs. It would be nice if we could remember
    our game and continue where we left off. That’s easy to do in our C program; it’s
    a side benefit that results from the file abstraction.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们玩猜动物游戏时，我们都从一个只知道猫和狗的程序开始。如果我们能记住我们的游戏进度并从中断的地方继续，那该多好。对于 C 程序来说，这是很容易做到的；它是文件抽象带来的附带好处。
- en: Adding such a feature to the JavaScript version is much more difficult. [Figure
    10-15](ch10.xhtml#ch10fig15) illustrates why.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 向 JavaScript 版本添加这样的功能要困难得多。[图 10-15](ch10.xhtml#ch10fig15) 说明了为什么。
- en: '![Image](../images/10fig15.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig15.jpg)'
- en: '*Figure 10-15: Browser and operating system interfaces*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-15：浏览器和操作系统接口*'
- en: You can see that the OS has a single interface that works for both devices and
    files. This interface is used both by the browser on the left and by the C version
    of the program on the right. That means the C program, like the browser, can use
    the same code to read input from a file as it does to read user input from a device.
    But the browser doesn’t pass this abstraction on to the JavaScript programmer.
    Instead, a completely separate piece of code using a completely different interface
    would be needed to add the new feature there. The choice of interface can have
    a big impact on both the ease of programming and the clarity of the result.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到操作系统有一个单一的接口，既适用于设备，也适用于文件。左侧的浏览器和右侧的 C 版本程序都使用这个接口。这意味着 C 程序像浏览器一样，可以使用相同的代码从文件中读取输入，就像从设备中读取用户输入一样。但浏览器并没有将这一抽象传递给
    JavaScript 程序员。相反，要在浏览器中添加这个新功能，需要一段完全独立的代码，使用一个完全不同的接口。接口的选择会对编程的难易程度和结果的清晰度产生巨大影响。
- en: '***Some Mechanics***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一些机制***'
- en: Back to our C program. Getting a C program ready to run requires compiling it
    and then *linking* it to other code that it uses, such as the `stdio` library.
    The section “[Running Programs](ch05.xhtml#ch05lev1sec12)” on [page 137](ch05.xhtml#page_137)
    mentions that a runtime library is also included; the C version is often named
    `crt0`. It’s responsible for tasks like setting up the stack and the heap so they’re
    ready to use. It also opens up a pair of files that are connected to the terminal
    device driver by default, one for input and one for output.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 C 程序。准备好 C 程序运行需要先编译它，然后将它与其他代码（例如 `stdio` 库） *链接* 在一起。[第 137 页](ch05.xhtml#page_137)
    的 “[运行程序](ch05.xhtml#ch05lev1sec12)” 章节提到，运行时库也包含其中；C 版本通常命名为 `crt0`。它负责一些任务，比如设置栈和堆以便它们可以使用。它还会打开一对文件，这些文件默认与终端设备驱动程序相连接，一个用于输入，一个用于输出。
- en: 'The `stdio` library maps the system file descriptors into *file pointers*,
    addresses that reference the data structures that it uses for buffering and bookkeeping.
    It starts with three: `stdin` (standard input), `stdout` (standard output), and
    `stderr` (standard error). The intent is for things that are important to go to
    `stderr` instead of `stdout`; they both go to the same place, but `stderr` is
    unbuffered and `stdout` is buffered. If you use `stdout` for error messages, they
    get buffered, and you may never see them if your program crashes. The file pointers
    `stdout` and `stderr` share the same file descriptor, as shown in [Figure 10-16](ch10.xhtml#ch10fig16),
    unless changed.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio` 库将系统文件描述符映射到 *文件指针*，这些地址引用了它用于缓冲和记录的相关数据结构。它一开始有三个：`stdin`（标准输入）、`stdout`（标准输出）和
    `stderr`（标准错误）。其目的是将重要的信息发送到 `stderr` 而不是 `stdout`；虽然它们都指向同一个地方，但 `stderr` 是无缓冲的，而
    `stdout` 是有缓冲的。如果你将错误消息发送到 `stdout`，它们会被缓冲，且如果程序崩溃，你可能永远也看不到这些消息。文件指针 `stdout`
    和 `stderr` 共享相同的文件描述符，如 [图 10-16](ch10.xhtml#ch10fig16) 所示，除非被更改。'
- en: '![Image](../images/10fig16.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig16.jpg)'
- en: '*Figure 10-16: The file pointers stdin, stdout, and stderr*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-16：文件指针 stdin、stdout 和 stderr*'
- en: Invention is often sparked by strange events. According to Steve Johnson, `stderr`
    was not part of the original `stdio` library; it was added as a side effect of
    the development of the first computer typesetting software (`troff`, written by
    Joseph Ossanna, 1928–1977) for the C/A/T photoypesetter. You take laser and inkjet
    printing for granted, but this beast projected images onto silver photographic
    paper, which then had to be developed. That became very expensive when the Hunt
    brothers cornered the silver market, and folks were asked to cut down on phototypesetter
    use. It was not uncommon to send a job to the typesetter only to get back a beautifully
    formatted page containing a `cannot open file` error message. The `stderr` file
    pointer was born so that error messages could go to the terminal instead of to
    the typesetter in order to save money.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 发明通常源于一些奇怪的事件。根据Steve Johnson的说法，`stderr`并不是`stdio`库的原始部分；它是在开发第一款计算机排版软件（`troff`，由Joseph
    Ossanna编写，1928–1977年）时，作为副作用被添加到C/A/T排版机中。你可能理所当然地认为激光和喷墨打印已经很普及，但这台机器将图像投射到银色的摄影纸上，然后再进行显影。当Hunt兄弟控制了银市时，打印费用变得非常昂贵，因此人们被要求减少排版机的使用。将作业送去排版机后，经常收到一页漂亮的格式化页面，上面写着`无法打开文件`的错误信息。为了节省开支，`stderr`文件指针应运而生，使得错误信息可以输出到终端，而不是排版机。
- en: '***Buffer Overflow***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓冲区溢出***'
- en: As long as we’re on the subject of `stdio`, let’s talk about a class of very
    serious system programming errors called *buffer overflow*. When `stdio` was originally
    written, it included a function called `gets` that read a string up to the next
    newline character from `stdin` into a user-supplied buffer. We could use it as
    shown in [Listing 10-6](ch10.xhtml#ch10list06) to read the `y`, `n`, or `q` response;
    there’s room in `buffer` for the character and a NUL terminator.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们提到了`stdio`，那么就来谈谈一种非常严重的系统编程错误——*缓冲区溢出*。当`stdio`最初被编写时，它包含了一个名为`gets`的函数，用来从`stdin`读取一个字符串，直到遇到下一个换行符，并将其存储到用户提供的缓冲区中。我们可以像[清单
    10-6](ch10.xhtml#ch10list06)中所示，使用它来读取`y`、`n`或`q`的响应；`buffer`中为字符和NUL终止符提供了足够的空间。
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-6: Using gets to read input*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6：使用gets读取输入*'
- en: Why might this be a problem? Because `gets` doesn’t check to make sure that
    the input doesn’t run off the end of the buffer. Say we have a more serious program
    that also has a variable named `launch_missiles`, which just happens to be the
    next thing in memory ([Figure 10-17](ch10.xhtml#ch10fig17)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这会是一个问题呢？因为`gets`没有检查输入是否超出了缓冲区的末尾。假设我们有一个更复杂的程序，其中也有一个名为`launch_missiles`的变量，而它恰好是内存中的下一个位置（见[图
    10-17](ch10.xhtml#ch10fig17)）。
- en: '![Image](../images/10fig17.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig17.jpg)'
- en: '*Figure 10-17: Buffer overflow in memory*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-17：内存中的缓冲区溢出*'
- en: A malicious user might discover that answering `yyy` would store a `y` in `launch_missiles`,
    which for all intents and purposes is the same as the nonexistent `buffer[2]`.
    That could get really ugly. As a matter of fact, it has. A very large number of
    discovered security issues result from exactly this sort of buffer overflow bug.
    This was fixed in `stdio` by the addition of an `fgets` function that checks bounds.
    But be careful—there are many, many ways in which buffer overflow bugs can occur.
    *Never, ever assume that buffer sizes are big enough!* There’s more detail about
    buffer overflows in [Chapter 13](ch13.xhtml#ch13).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意用户可能会发现，回答`yyy`会将一个`y`存储到`launch_missiles`中，这实际上就相当于不存在的`buffer[2]`。这可能会引发严重问题。事实上，很多被发现的安全问题正是由这种缓冲区溢出漏洞引起的。这一问题通过在`stdio`中添加`fgets`函数进行了解决，`fgets`会检查缓冲区边界。但是要小心——缓冲区溢出漏洞有很多种发生方式。*永远不要假设缓冲区大小足够大！*关于缓冲区溢出的更多细节请参见[第13章](ch13.xhtml#ch13)。
- en: '***The C Program***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C程序***'
- en: There are many C libraries in addition to `stdio`. The `string` library, for
    example, includes functions for comparing and copying strings, and the catchall
    standard library `stdlib` includes functions for memory management.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`stdio`，还有许多其他C语言库。例如，`string`库包括用于比较和复制字符串的函数，而通用的标准库`stdlib`则包括用于内存管理的函数。
- en: '[Listing 10-7](ch10.xhtml#ch10list07) shows the C program for our game’s prologue.
    The first part brings in the library information we need (lines 1–3). Next, a
    node structure is declared (lines 5–9) that contains pointers to two leaves and
    a placeholder for the question or animal string. Note that we didn’t have to do
    something like this in our JavaScript version because we took advantage of the
    existing HTML `<div>`; had we not done that, there would have been a JavaScript
    equivalent. Notice that the node structure is defined such that we can allocate
    the node and string together, as in “[More Efficient Memory Allocation](ch07.xhtml#ch07lev1sec8)”
    on [page 196](ch07.xhtml#page_196).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-7](ch10.xhtml#ch10list07) 显示了我们游戏的前言部分的 C 语言程序。第一部分引入了我们需要的库信息（第 1 到
    3 行）。接下来，声明了一个节点结构体（第 5 到 9 行），其中包含指向两个叶子节点的指针以及一个占位符，用于存储问题或动物的字符串。请注意，我们在 JavaScript
    版本中不需要做这样的事，因为我们利用了现有的 HTML `<div>`；如果我们没有这样做，JavaScript 中也会有等效的方式。注意，节点结构体的定义使我们可以将节点和字符串一起分配内存，就像在
    [《更高效的内存分配》](ch07.xhtml#ch07lev1sec8) 中的 [第 196 页](ch07.xhtml#page_196) 所示那样。'
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-7: Guess the Animal in C: prologue*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-7：用 C 语言猜动物：前言*'
- en: Next, we define a function to help with memory allocation ([Listing 10-8](ch10.xhtml#ch10list08)).
    Although memory allocation is no big deal, we need to do it in several places,
    and it gets tedious to check for errors each time. More recent languages include
    exception-handling constructs that make this sort of thing simpler.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个帮助进行内存分配的函数（[清单 10-8](ch10.xhtml#ch10list08)）。虽然内存分配并不复杂，但我们需要在多个地方进行内存分配，每次都检查错误会变得很繁琐。更新的编程语言包括异常处理构造，使得这种操作变得更简单。
- en: Since the only time that we need to allocate memory is when making a new `node`,
    we use a function that takes the `string` to install in the `node`. In addition
    to allocating memory, the `string` is copied into the `node`, and the `yes` and
    `no` pointers are initialized.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只在创建新 `node` 时需要分配内存，因此我们使用一个函数，该函数接受要安装到 `node` 中的 `string`。除了分配内存外，`string`
    还会被复制到 `node` 中，并初始化 `yes` 和 `no` 指针。
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10-8: Guess the Animal in C: memory allocator*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-8：用 C 语言猜动物：内存分配器*'
- en: We use the `fprintf` function in `stdio` for our error message because, as discussed
    earlier, things sent to `stderr` are unbuffered, which gives us a better chance
    of seeing the message if the program fails unexpectedly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `stdio` 中使用 `fprintf` 函数来输出错误信息，因为如前所述，发送到 `stderr` 的内容是无缓冲的，这使得我们在程序意外失败时更有可能看到该信息。
- en: Note that the cast operator is used to cast the `fprintf` as `void` on line
    16\. When `fprintf` returns a value that we’re ignoring, the cast tells the compiler
    that we’re doing it deliberately, instead of forgetting to check something, so
    that it doesn’t generate warning messages. It also informs someone reading the
    code that the return value is being deliberately ignored, so it’s not a mistake.
    Recent changes to some compilers eliminate these warnings unless explicitly requested.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第 16 行使用了类型转换运算符将 `fprintf` 转换为 `void`。当 `fprintf` 返回一个我们忽略的值时，类型转换告诉编译器我们是故意这么做的，而不是忘记检查某个东西，这样它就不会生成警告信息。它还告诉阅读代码的人，返回值是故意被忽略的，因此这不是一个错误。最近一些编译器的更新消除了这些警告，除非明确要求。
- en: The call to `exit` on line 17 terminates the program. That’s the only reasonable
    option when there isn’t enough memory available to continue running the program.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第 17 行对 `exit` 的调用终止了程序。当没有足够的内存可供程序继续运行时，这是唯一合理的选择。
- en: The `printf` (*print formatted*) function is part of `stdio` and has made its
    way into many other languages. The first argument is a *format string* that determines
    the interpretation of the remainder of the arguments. A `%` followed by a code
    means “replace me with the next argument according to the code.” In this case,
    `%s` means “treat the next argument as a string.”
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`（*格式化输出*）函数是 `stdio` 的一部分，并且已经进入了许多其他语言。第一个参数是一个 *格式字符串*，它决定了其余参数的解释方式。一个
    `%` 后面跟着一个代码表示“用下一个参数根据该代码替换我”。在这种情况下，`%s` 表示“将下一个参数视为字符串”。'
- en: The rest of the program is shown in [Listing 10-9](ch10.xhtml#ch10list09).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分显示在 [清单 10-9](ch10.xhtml#ch10list09) 中。
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-9: Guess the Animal in C: mainline*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-9：用 C 语言猜动物：主程序*'
- en: There’s nothing particularly interesting about this code except the memory management,
    as the program does pretty much the same thing as the JavaScript version. Lines
    28 through 37 declare variables. Lines 74 through 76 create the initial nodes
    depicted in [Figure 10-18](ch10.xhtml#ch10fig18). Note that all the strings are
    NUL-terminated (`'\0'`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有什么特别之处，除了内存管理，因为它与 JavaScript 版本几乎做了相同的事情。第 28 到 37 行声明了变量。第 74 到 76 行创建了
    [图 10-18](ch10.xhtml#ch10fig18) 中所示的初始节点。请注意，所有字符串都是以 NUL 终止（`'\0'`）。
- en: '![Image](../images/10fig18.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig18.jpg)'
- en: '*Figure 10-18: Guess the Animal in C: initial nodes*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-18：用 C 语言猜动物：初始节点*'
- en: 'Let’s play the game as we did earlier in “[Guess the Animal Version 1: HTML
    and JavaScript](ch10.xhtml#ch10lev1sec1)” on [page 262](ch10.xhtml#page_262).
    After the player supplies a new question, a new node is allocated for it. There
    are a couple of points of interest here. Be careful getting the length of a string
    using the `strlen` (*string length*) function. It returns the actual length of
    the string, not the amount of memory used, which is 1 byte more to account for
    the NUL terminator. But notice that we don’t add 1 when allocating memory for
    strings because of the way we’re allocating memory for the node, which already
    includes the extra byte.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像之前在 “[猜动物版本 1：HTML 和 JavaScript](ch10.xhtml#ch10lev1sec1)” 中一样玩这个游戏，位于 [第
    262 页](ch10.xhtml#page_262)。当玩家提供一个新问题后，会为其分配一个新节点。这里有几点值得注意。使用 `strlen` (*字符串长度*)
    函数时要小心。它返回的是字符串的实际长度，而不是占用的内存量，后者多了一个字节来表示 NUL 终止符。但请注意，在为字符串分配内存时，我们没有加 1，因为我们是以分配节点的方式来分配内存的，这已经包括了额外的字节。
- en: Whenever we descend the tree in response to a yes or no answer, we keep a `current`
    pointer to make it easy to insert the new question node. We need to detach either
    the `yes` or `no`, which we do by having `current` point to whatever node pointer
    is being replaced. Because `current` points to a node pointer, it’s a pointer
    to a pointer. When we say `*current = new;` we’re dereferencing the pointer and
    saying “replace whatever the pointer is pointing to.” In [Figure 10-19](ch10.xhtml#ch10fig19),
    the `no` pointer in the `new` node is set to `current`, which is the old answer,
    and `current` points to the `yes` pointer in the `root` node, which gets replaced
    with the pointer to the `new` node.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们根据是或否的回答下降到树的下一级时，我们会保持一个 `current` 指针，以便轻松插入新的问题节点。我们需要分离 `yes` 或 `no`，我们通过让
    `current` 指向正在被替换的节点指针来做到这一点。因为 `current` 指向一个节点指针，它是指向指针的指针。当我们说 `*current =
    new;` 时，我们正在解引用指针，并表示“替换指针所指向的内容。”在 [图 10-19](ch10.xhtml#ch10fig19) 中，`new` 节点中的
    `no` 指针被设置为 `current`，这是旧的答案，而 `current` 指向 `root` 节点中的 `yes` 指针，后者被替换为指向 `new`
    节点的指针。
- en: '![Image](../images/10fig19.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig19.jpg)'
- en: '*Figure 10-19: Guess the Animal in C: adding new nodes*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-19：用 C 语言猜动物：添加新节点*'
- en: '***Training***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***训练***'
- en: 'Recall that our C program can be run with command line options for reading
    and writing training data. We can run the program as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们的 C 程序可以通过命令行选项来读取和写入训练数据。我们可以如下运行程序：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, if you look in the `training` file, you’ll see that it contains exactly
    what you typed:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看 `training` 文件，你会看到它包含了你输入的内容：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we rerun the program as:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行程序，如下所示：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: the contents of the `training` file will get read in so that the program starts
    where we left off.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`training` 文件的内容将被读取，以便程序从我们上次停止的地方继续。'
- en: Way back in “[What Is Computer Programming?](intro.xhtml#introlev1sec6)” on
    [page xxix](intro.xhtml#page_xxix), I mentioned that you need to know a lot about
    everything in order to be a good programmer. Our program isn’t very good grammatically.
    It works fine if the animal is a dog, because it will ask `Is it a dog?`. But
    what if it’s an elephant? It’s not grammatically correct to ask `Is it a elephant?`.
    What are the rules for making sure the grammar is correct? Can you modify the
    code to make it grammatically more better?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，在 “[什么是计算机编程？](intro.xhtml#introlev1sec6)” 中的 [第 xxix 页](intro.xhtml#page_xxix)，我提到过，要成为一名优秀的程序员，你需要了解很多东西。我们的程序在语法上并不完美。如果动物是狗，它会正常工作，因为它会问
    `Is it a dog?`。但如果是大象呢？问 `Is it a elephant?` 在语法上是错误的。那么，如何确保语法正确呢？你能修改代码让它在语法上更正确吗？
- en: '**Summary**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this chapter, you’ve seen a program written in two ways: once as a high-level
    application and once as a lower-level system program. On one hand, writing high-level
    application programs can be easier because many small details are handled automatically.
    On the other hand, some features, such as recording and playback, are much more
    difficult to implement in environments that don’t include uniform interfaces.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到了两种编写程序的方式：一次是作为高层应用程序，一次是作为低层系统程序。一方面，编写高层应用程序可能更简单，因为许多小细节会自动处理。另一方面，某些功能，如录制和回放，在不包含统一接口的环境中实现起来要困难得多。
- en: Furthermore, using very complex application environments for simple applications
    increases the likelihood of bugs. The probability of bugs is the sum of your application
    code and the code for the environment in which it runs. How many times has your
    browser begun running very slowly and needed to be restarted, usually due to internal
    memory management errors? How often has your browser just crashed?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用非常复杂的应用环境来处理简单应用程序会增加错误的可能性。错误的概率是应用程序代码和运行环境代码的总和。你的浏览器有多少次开始变得非常慢并且需要重启，通常是由于内部内存管理错误？你的浏览器又有多少次直接崩溃了？
- en: 'You’ve seen that system programming involves much more attention to detail,
    such as the management of strings, memory, and buffers. But these details are
    important when the goal is to craft code that is concise and secure. In the next
    chapter, we’ll look at a different type of detail: structuring problems so that
    they’re easier to solve.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，系统编程涉及更多的细节管理，如字符串、内存和缓冲区的管理。但这些细节在目标是编写简洁且安全的代码时非常重要。在下一章中，我们将探讨另一种类型的细节：如何构建问题，使其更容易解决。
