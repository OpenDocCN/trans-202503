- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BIPARTITE
    GRAPH MATCHING</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">二分图匹配</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Many problems in business and logistics consist of matching items from two different
    sets. We might want to match people with jobs, conferences with locations, vehicles
    with routes, or adopted pets with homes. In each case, we must ask which item
    from one set is compatible with which item from the second set. This chapter explores
    this problem, called *bipartite graph matching*, in detail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多商业和物流问题都涉及到从两个不同集合中匹配项目。我们可能需要将人匹配到工作、会议匹配到地点、车辆匹配到路线，或将被收养的宠物匹配到家庭。在每一种情况下，我们都必须询问哪个集合中的项目与第二个集合中的哪个项目兼容。本章将详细探讨这个问题，称为*二分图匹配*。
- en: 'A *bipartite graph* is a graph consisting of two disjoint sets of nodes where
    each edge always has one end in each set. This graph naturally lends itself to
    the matching problem: each set of nodes represents one of the sets of items that
    we want to match, while edges indicate compatibility between the items.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*二分图*是一个由两个不相交的节点集合组成的图，其中每条边的两端总是分别位于这两个集合中。这个图自然地适用于匹配问题：每个节点集合代表我们想要匹配的项目集，而边则表示项目之间的兼容性。'
- en: This chapter begins by discussing the broader concept of matching on a graph
    before formally introducing undirected bipartite graphs and bipartite matching
    algorithms, showing along the way how graph matching encompasses a rich set of
    problems, from assigning partners for group work to scheduling jobs in a data
    center, and technical challenges.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先讨论图上匹配的更广泛概念，然后正式介绍无向二分图及其二分匹配算法，并展示图匹配涵盖了从为小组工作分配伙伴到数据中心作业调度等一系列问题，以及相关的技术挑战。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Matching</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">匹配</samp>
- en: A *matching* on an undirected graph is a set of edges that do not share any
    nodes. In other words, each edge in the matching connects two different nodes,
    and each node is adjacent to at most one edge. We can visualize matchings via
    pairing up students for project work using their friendship connections. Each
    edge in the matching represents two friends (the edge’s two nodes) who will collaborate
    on the project. As a natural consequence of this pairwise assignment, we pair
    up only students with existing social connections and do not guarantee that all
    students will find a partner.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在无向图上，*匹配*是指一组边，其中每条边的两个节点不共享任何节点。换句话说，匹配中的每条边连接两个不同的节点，每个节点最多只能与一条边相邻。我们可以通过使用学生之间的友谊关系来可视化匹配。在这种情况下，每条边代表两位朋友（边的两个节点），他们将合作完成项目。作为这种配对分配的自然结果，我们只会配对那些已经有社交关系的学生，且不能保证所有学生都能找到配对。
- en: The general concept of matching opens up a range of problems we can solve. As
    concrete examples for this chapter, let’s examine two particularly useful matching
    problems. First, finding a *maximum-cardinality matching* (sometimes shortened
    to *maximum matching*) consists of finding a matching with the most edges. This
    corresponds to finding an assignment of students to pairs that creates the most
    groups. Second, a *maximal matching* is any matching where no additional edges
    can be added without breaking the matching property. While a maximum-cardinality
    matching is always a maximal matching, the converse is not true.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配的基本概念为我们提供了解决一系列问题的可能性。作为本章的具体示例，下面我们将讨论两个特别有用的匹配问题。首先，寻找一个*最大基数匹配*（有时缩写为*最大匹配*）的任务是找到一个具有最多边的匹配。这相当于为学生分配配对，创建最多的组。其次，*极大匹配*是指任何一个匹配，在这个匹配中没有额外的边可以加入而不破坏匹配属性。虽然最大基数匹配总是一个极大匹配，但反之则不成立。
- en: '[Figure 15-1](#fig15-1) shows examples of these two matching types. We cannot
    add any more edges to the maximal matching in [Figure 15-1(a)](#fig15-1), represented
    by the bold edges, without reusing a node. Meanwhile, [Figure 15-1(b)](#fig15-1)
    is both a maximal matching and a maximum-cardinality matching: we cannot create
    a matching for this graph with more than three edges.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-1](#fig15-1)展示了这两种匹配类型的示例。我们不能再向[图 15-1(a)](#fig15-1)中的极大匹配中添加任何边（由粗体边表示），否则就会重用一个节点。同时，[图
    15-1(b)](#fig15-1)既是极大匹配，也是最大基数匹配：我们无法为该图创建一个超过三条边的匹配。'
- en: '![A graph with undirected edges (0,1), (0,3), (1, 2), (1, 4), (1, 5), (2, 5)
    and (4, 5). (A) has edges (0, 3) and (1, 5) bolded. (B) has edges (0, 3), (1,
    2), and (4, 5) bolded.](../images/f15001.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含无向边的图（0,1）、（0,3）、（1, 2）、（1, 4）、（1, 5）、（2, 5）和（4, 5）。(A) 中，边（0, 3）和（1,
    5）加粗。(B) 中，边（0, 3）、（1, 2）和（4, 5）加粗。](../images/f15001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: Maximal (a) and
    maximum-cardinality (b) matching</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-1：最大匹配（a）和最大基数匹配（b）</samp>
- en: The problem of finding a *maximum-weight matching* consists of finding the matching
    in a weighted graph that maximizes the sum of the edge weights. This corresponds
    to prioritizing the strength of the students’ friendships when allocating the
    groups. While this approach is useful in the context of maximizing a reward function
    such as student happiness, it does not necessarily lead to a maximum-cardinality
    matching. For example, [Figure 15-2](#fig15-2) shows a maximum-weight matching
    that is not a maximum-cardinality matching. Two pairs of nodes {0, 1} and {2,
    5} are matched, while nodes 3 and 4 are left out.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找*最大权重匹配*的问题是指在加权图中找到最大化边权总和的匹配。这对应于在分配小组时优先考虑学生之间的友谊强度。尽管这种方法在最大化奖励函数（如学生幸福感）的背景下是有用的，但它不一定会导致最大基数匹配。例如，[图
    15-2](#fig15-2)展示了一个最大权重匹配，但它不是最大基数匹配。两个节点对{0, 1}和{2, 5}被匹配，而节点3和4被遗漏。
- en: '![A graph with undirected, weighted edges. Edge (0,1) has weight 10\. Edge
    (0,3) has weight 1\. Edge (1, 2) has weight 3\. Edge (1, 4) has weight 5\. Edge
    (1, 5) has weight 1\. Edge (2, 5) has weight 19\. Edge (4, 5) has weight 4\. The
    edges (0, 1) and (2, 5) are bolded.](../images/f15002.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含无向加权边的图。边（0,1）的权重为10，边（0,3）的权重为1，边（1,2）的权重为3，边（1,4）的权重为5，边（1,5）的权重为1，边（2,5）的权重为19，边（4,5）的权重为4。边（0,1）和（2,5）加粗。](../images/f15002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: The maximum- weight
    matching on a graph</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-2：图上的最大权重匹配</samp>
- en: The list of possible matching problems continues beyond these initial examples.
    We could ask whether a graph has a *perfect matching*, where every node is included
    exactly once; find a maximum-cardinality matching that minimizes the sum of the
    edge weights; or find a matching that maximizes the weight while keeping below
    a given number of edges. Throughout the rest of the chapter, we will focus primarily
    on maximum-cardinality matching, one of the simplest and most broadly applicable
    formulations, in the context of a specific graph type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可匹配问题的列表远不止这些初始示例。我们可以问一个图是否存在*完美匹配*，其中每个节点恰好被包含一次；找到一个最大基数匹配，最小化边权的总和；或者找到一个匹配，在保持边数不超过给定数量的情况下，最大化权重。在本章的其余部分，我们将主要集中于最大基数匹配，这是最简单且应用最广泛的形式之一，适用于特定图类型的背景。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bipartite Graphs</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">二分图</samp>
- en: As noted earlier, a *bipartite graph* can be partitioned into two disjoint sets
    of nodes such that no edge connects two nodes in the same set. Bipartite graphs
    are often visualized as two parallel lines of nodes, as shown in [Figure 15-3](#fig15-3).
    The left and right columns define the two sets of nodes. Every edge in the graph
    spans the columns.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*二分图*可以被划分为两个不相交的节点集，以至于没有边连接同一集中的两个节点。二分图通常被可视化为两行并行的节点，如[图 15-3](#fig15-3)所示。左列和右列定义了两个节点集。图中的每一条边都横跨这两列。
- en: '![A graph with seven nodes and undirected edges (0, 3), (0, 5), (2, 1), (2,
    5), (4, 3), (4, 5) and (6, 1). The even nodes are in a column on the left and
    the odd nodes are in a column on the right. All edges go between two columns.](../images/f15003.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含七个节点和无向边的图（0, 3）、（0, 5）、（2, 1）、（2, 5）、（4, 3）、（4, 5）和（6, 1）。偶数节点在左侧的一列，奇数节点在右侧的一列。所有边都连接两个列之间的节点。](../images/f15003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-3: A bipartite graph
    with seven nodes</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-3：一个包含七个节点的二分图</samp>
- en: Bipartite graphs provide a natural model for pairwise matching problems. In
    a canonical example, the items on the left represent people and the ones on the
    right represent the jobs for which they are qualified, summarizing a complex set
    of constraints in a simple graph.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 二分图为配对匹配问题提供了一个自然模型。在一个典型的例子中，左侧的项代表人，而右侧的项代表他们有资格胜任的工作，这在一个简单的图中总结了复杂的约束条件。
- en: Although matching is the focus of this chapter, the usefulness of bipartite
    graphs does not end there. Bipartite graphs can model a range of phenomena, from
    physical bridges crossing a river to spies watching each other at a party.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然匹配是本章的重点，但二分图的实用性远不止于此。二分图可以模拟许多现象，从跨越河流的物理桥梁到在聚会中互相监视的间谍。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bipartite Labeling</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">二分图标记</samp>
- en: Given an undirected graph, we can ask whether it is a bipartite graph and, if
    so, which node is part of which set. We can use the properties of a bipartite
    graph to perform both this check and the labeling of which nodes are in which
    set. We know that any path through an undirected bipartite graph must zigzag between
    the two sets, and a node can never have a neighbor within its own set. We use
    a simple search, either breadth-first or depth-first, to traverse the undirected
    graph and assign labels to nodes. The key is that we arbitrarily assign the first
    node one label and then alternate labels each time we cross an edge. If we ever
    find two neighbors with the same label, we know the graph is not bipartite.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个无向图，我们可以询问它是否是二分图，如果是的话，哪个节点属于哪个集合。我们可以利用二分图的特性来进行这项检查，并标记哪些节点属于哪个集合。我们知道，任何通过无向二分图的路径都必须在两个集合之间交替，而一个节点不能有来自其所在集合的邻居。我们使用简单的搜索方法，无论是广度优先还是深度优先，遍历无向图并给节点分配标签。关键是，我们先任意为第一个节点分配一个标签，然后每当穿越一条边时，交替分配标签。如果我们发现两个邻居有相同的标签，我们就知道这个图不是二分图。
- en: We can picture the algorithm in the context of competing spy agencies at a cocktail
    party. The agencies consist of disjoint sets of spies, represented as nodes. Each
    edge signifies the connection between two people who are watching each other.
    The spies are well trained and can each keep an eye on multiple people at once—Spy
    A might be watching Spy B, Spy C, and Spy D!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个算法想象成在一个鸡尾酒会上，多个间谍机构在竞争。各个间谍机构由不相交的间谍集合组成，表示为节点。每条边代表两个人互相监视的关系。这些间谍训练有素，每个间谍可以同时监视多个人——间谍A可能在监视间谍B、间谍C和间谍D！
- en: A bored waiter, unaware of the true identities of anyone in the ballroom, uses
    the opportunity to determine which spies work together. They start by picking
    one spy at random and assigning them to the green team. They determine all the
    people that spy is watching and assign each of them to the yellow team. Then,
    for each of the newly discovered yellow members, the waiter determines who they
    are watching and assigns those people being watched to the green team. The process
    bounces back and forth, uncovering the affiliations of each person as the waiter
    serves various appetizers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一位无聊的服务员，无法识别舞厅里每个人的真实身份，利用这个机会来确定哪些间谍是合作的。他们首先随机挑选一名间谍并将其分配到绿色队伍。然后，他们确定这个间谍监视的所有人，并将这些人分配到黄色队伍。接下来，对于每个新发现的黄色成员，服务员会确定他们正在监视谁，并将被监视的人分配到绿色队伍。这个过程来回跳动，随着服务员递送各种开胃菜，揭示出每个人的归属。
- en: Of course, if the waiter ever finds a spy watching a member of their own team,
    they know they do not have a bipartite graph. Maybe the agencies sent internal
    affairs or there is a double agent. Regardless, the situation is no longer as
    clear as yellow versus green and probably is not something with which the waiter
    wants to be involved.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果服务员发现有间谍监视自己队伍中的成员，他们就知道这个图不是二分图。也许间谍机构派来了内务人员，或者有双重间谍。不管怎样，情况不再是简单的黄色与绿色对立，服务员可能不想卷入其中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: The code for bipartite graph labeling in [Listing 15-1](#list15-1) uses a breadth-first
    search to iteratively explore the graph and label nodes as belonging to either
    the right or left side.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 15-1](#list15-1)中的二分图标记代码使用广度优先搜索（BFS）迭代地遍历图，并将节点标记为属于右侧或左侧。'
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: Labeling nodes
    according to which side of the bipartite graph they occupy</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: 根据节点在二分图中的位置对其进行标记</samp>'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_labeling()</samp>
    function maintains a list mapping each node index to one of three states (unlabeled
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>, right = <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    or left = <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>) using a combination
    of Boolean and <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> values.
    The code starts by setting up the list of labels (<samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>)
    and a queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>), which
    requires us to import Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    library. Each label is initialized to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>,
    indicating that the algorithm has not yet seen a node and given it a label. This
    list will serve the roles of both tracking the seen nodes in breadth-first search
    and storing the labels.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_labeling()</samp> 函数维护一个列表，将每个节点索引映射到三种状态之一（未标记
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>，右侧 = <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，或左侧
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>），通过布尔值和 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    值的组合。代码通过设置标签列表（<samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>）和队列（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>）开始，这要求我们导入 Python 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">queue</samp> 库。每个标签被初始化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>，表示算法尚未看到该节点并为其分配标签。此列表将既用于在广度优先搜索中跟踪已访问的节点，也用于存储标签。
- en: The main body of the code is a repeated breadth-first search where an outer
    loop starts a new search on any unvisited node ❶. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop checks whether each potential starting node has already been seen by a previous
    search. If so (the node’s label is not <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>),
    the code skips it ❷. If the node has not been seen, the code adds it to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pending</samp> queue for the breadth-first
    search, marks it as belonging to the left-hand side (label of <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>),
    and starts a new breadth-first search from that node ❸.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的主体是一个重复的广度优先搜索，其中外部循环从任何未访问的节点开始新的搜索❶。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环检查每个潜在的起始节点是否已被之前的搜索访问过。如果是（节点的标签不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>），则代码跳过它❷。如果节点尚未被访问，代码将其添加到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp> 队列中进行广度优先搜索，标记其属于左侧（标签为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>），并从该节点开始新的广度优先搜索❸。
- en: During each step of the breadth-first search, the code gets the current node
    being explored and uses its label to determine that of its neighbors ❹. That is,
    the current node’s neighbors must all have the opposite label; otherwise, the
    graph is not bipartite. The code iterates over the node’s edges and checks each
    neighbor. If the neighbor has not been seen (label is <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>)
    ❺, the code sets the label (marking it seen) and adds it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>
    queue. If the node has been seen, the code takes the opportunity to check the
    validity of its label ❻. If the label does not match what is expected, the graph
    has two connected nodes on the same side and therefore is not bipartite. It immediately
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to indicate
    the problem.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步广度优先搜索中，代码获取当前正在探索的节点，并使用其标签来确定其邻居的标签❹。也就是说，当前节点的邻居必须具有相反的标签；否则，图不是二分图。代码遍历节点的边，并检查每个邻居。如果邻居尚未被访问（标签为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>）❺，代码会设置标签（标记为已访问），并将其添加到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp> 队列中。如果该节点已被访问，代码将利用此机会检查其标签的有效性❻。如果标签与预期不符，则图中存在两个连接的节点在同一侧，因此不是二分图。它会立即返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> 来指示问题。
- en: If the code successfully finishes the series of breadth-first searches needed
    to explore every node, it returns a list of node labels as <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> values. Otherwise,
    it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to indicate
    the graph is not bipartite. As with other examples throughout the book, we need
    to import <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from Python’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library to support
    type hints for these multiple return values.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码成功完成了探索每个节点所需的一系列广度优先搜索，它将返回一个节点标签列表，包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> 值。否则，它会返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    来表示图不是二分图。和书中的其他示例一样，我们需要从 Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp>
    库中导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> 来支持这些多个返回值的类型提示。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: '[Figure 15-4](#fig15-4) shows the steps of the bipartite labeling algorithm
    working on an example seven-node graph. In [Figure 15-4(a)](#fig15-4), an arbitrary
    node (0) is chosen, given the first label (<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>),
    and added to the queue to explore. This corresponds to the waiter selecting the
    first spy to watch and assigning them to the green team.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-4](#fig15-4) 显示了二分图标签算法在一个七节点图上的应用步骤。在 [图 15-4(a)](#fig15-4) 中，选择了一个任意节点（0），赋予第一个标签（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>），并将其加入队列进行探索。这相当于服务员选择了第一个间谍并将其分配到绿色队。'
- en: After exploring node 0, the algorithm finds two neighbors, as shown in [Figure
    15-4(b)](#fig15-4). It gives nodes 3 and 5 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    labels to indicate they are in the opposite set from node 0\. Both nodes are also
    added to the queue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索节点 0 后，算法发现了两个邻居，如 [图 15-4(b)](#fig15-4) 所示。它给节点 3 和 5 赋予 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    标签，表示它们与节点 0 在不同的集合中。两个节点也被加入到队列中。
- en: '[Figure 15-4(c)](#fig15-4) shows the search’s state after exploring node 3
    and discovering just one new neighbor, node 4\. Since node 3 had a label of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, the search gives node 4
    a label of <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. The algorithm
    also checks all previously seen nodes, in this case node 0, to confirm their labels
    match the expected value. For the bored waiter, this step corresponds to watching
    the first person identified as a member of the yellow team. The waiter shifts
    behind a potted plant and notes that person 3 is watching person 0 back, as must
    be expected of any good spy. After a moment, the waiter notes that person 3 is
    also watching person 4\. The waiter has found another member of the green team
    and notes this on a cocktail napkin.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-4(c)](#fig15-4) 显示了在探索节点 3 并发现一个新邻居节点 4 后，搜索的状态。由于节点 3 的标签为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，搜索为节点
    4 赋予了 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> 标签。算法还检查了所有先前看到的节点，在本例中是节点
    0，以确认它们的标签是否与预期值匹配。对于无聊的服务员来说，这一步相当于观察到第一个被认定为黄色队成员的人。服务员躲到一盆植物后面，注意到那个人 3 正在看着人
    0，这符合任何好间谍的预期。片刻之后，服务员注意到人 3 也在看着人 4。服务员发现了绿色队的另一个成员，并在鸡尾酒纸巾上做了记录。'
- en: The search continues through the graph one node at a time. At each step, the
    algorithm examines the full set of neighbors, labeling new ones and adding them
    to the queue as well as checking known neighbors’ labels for consistency. The
    search ends in [Figure 15-4(h)](#fig15-4) after every node has been checked.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索继续在图中逐个节点进行。在每一步，算法检查完整的邻居集合，为新的邻居赋标签并将其加入队列，同时检查已知邻居的标签是否一致。搜索在 [图 15-4(h)](#fig15-4)
    中结束，所有节点都已检查完毕。
- en: '![Each subfigure shows the graph from Fig. 15-3 with seven nodes and undirected
    edges (0, 3), (0, 5), (2, 1), (2, 5), (4, 3), (4, 5) and (6, 1). In subfigure
    B, node 0 is circled and the label list reads [T, /, /, F, /, F, /]](../images/f15004.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图显示了来自图 15-3 的图形，包含七个节点和无向边（0, 3）、（0, 5）、（2, 1）、（2, 5）、（4, 3）、（4, 5）和（6,
    1）。在子图 B 中，节点 0 被圈出，标签列表显示为 [T, /, /, F, /, F, /]](../images/f15004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-4: The steps of a
    successful bipartite graph check</samp>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-4：成功的二分图检查步骤</samp>
- en: We can also use this same algorithm to identify non-bipartite graphs. [Figure
    15-5](#fig15-5) shows the same algorithm on a non-bipartite graph, formed by adding
    a single additional edge to the graph in [Figure 15-4](#fig15-4). For the first
    few steps, the search progresses similarly to that in [Figure 15-4](#fig15-4).
    An arbitrary initial node is chosen in [Figure 15-5(a)](#fig15-5) and explored
    in [Figure 15-5(b)](#fig15-5). The first hint of trouble occurs in [Figure 15-5(c)](#fig15-5),
    where node 1 is labeled as occurring on the left-hand side because it is a neighbor
    of node 3\. We can easily tell this is a mistake from the visual representation,
    but the algorithm does not have that information yet. From its perspective, node
    1 could very well be on the left-hand side. The algorithm will not see the problem
    until it proceeds further.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用相同的算法来识别非二分图。[图 15-5](#fig15-5)展示了在一个非二分图上应用相同的算法，该图通过在[图 15-4](#fig15-4)中的图上添加一条额外的边来形成。在前几个步骤中，搜索的过程与[图
    15-4](#fig15-4)中的类似。在[图 15-5(a)](#fig15-5)中选择了一个任意的初始节点，并在[图 15-5(b)](#fig15-5)中进行探索。问题的第一个迹象出现在[图
    15-5(c)](#fig15-5)中，节点 1 被标记为出现在左侧，因为它是节点 3 的邻居。我们可以通过视觉表示轻松地看出这是一个错误，但算法尚未获得这类信息。从它的角度来看，节点
    1 完全可能位于左侧。直到算法进一步执行，它才会发现问题。
- en: '![A similar set of graphs to Figure 15-4 with an additional edge (1, 3). In
    subfigure E, node 1 is circled and the label array has an X through the entry
    for node 2.](../images/f15005.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![与图 15-4 类似的一组图，添加了一条边（1，3）。在子图 E 中，节点 1 被圈出，标签数组中节点 2 的条目被标记为 X。](../images/f15005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-5: The steps of an
    unsuccessful bipartite graph check</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-5：一次失败的二分图检查步骤</samp>
- en: The algorithm finally notices the problem in [Figure 15-5(e)](#fig15-5), when
    it explores node 1\. Since node 1’s own label is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    it expects its neighbors to be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    This fails as soon as it checks node 2\. Node 2 was previously labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    while exploring node 5, but node 2 cannot be both <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. The graph is not
    bipartite.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 算法最终在[图 15-5(e)](#fig15-5)中发现了问题，当它探索节点 1 时。由于节点 1 自身的标签是<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，它期望其邻居是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。当它检查节点 2 时就失败了。节点 2 在探索节点
    5 时曾被标记为<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，但节点 2 不能同时是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。因此，这个图不是二分图。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用案例</samp>
- en: The *bipartite matching problem* consists of solving the matching problem on
    a bipartite graph and can be used to solve a number of real-world optimization
    and assignment problems. Due to the structure of the bipartite graph, each selected
    edge will join a single node from the left side with a single node from the right
    side. Depending on the task, the problem might be trying to maximize different
    criteria, such as the number of matches or the sum of the used edge weights. This
    formulation encompasses a wide range of real-world problems that we might not
    normally consider in the graph context, from job scheduling to planning office
    building organization to matching heroes with monsters in a magical dungeon.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*二分匹配问题*涉及在二分图上解决匹配问题，并可以用来解决许多现实世界中的优化和分配问题。由于二分图的结构，每条被选中的边将把左侧的一个节点与右侧的一个节点连接起来。根据任务的不同，问题可能是在尝试最大化不同的标准，比如匹配的数量或使用的边权重之和。这个模型涵盖了许多现实世界的问题，这些问题通常我们不会在图的上下文中考虑，从作业调度到规划办公室大楼的组织，再到在魔法地下城中匹配英雄与怪物。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Scheduling Jobs</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">作业调度</samp>
- en: Suppose a physics laboratory wants to maximize the number of concurrent simulations
    run on its machines. The machines vary in capability, but each can run only a
    single program at a time. The scientists each submit a program to the human scheduler
    and urge the scheduler to prioritize their own work first. Yet each program comes
    with its own requirements, such as high memory or a GPU. The scheduler must respect
    these constraints, limiting the number of valid assignments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个物理实验室希望最大化其机器上同时运行的仿真数量。这些机器的能力各不相同，但每台机器一次只能运行一个程序。科学家们将每个程序提交给人类调度员，并催促调度员优先处理他们自己的工作。然而，每个程序都有自己的要求，如高内存或GPU。调度员必须遵守这些约束，从而限制有效分配的数量。
- en: The scheduler, sensing the perfect opportunity to employ a bipartite matching
    algorithm, models the allocations as an undirected graph. They list the scientists’
    jobs in the left column and the computers in the right, then draw an edge from
    a program to a machine if the job can run on that machine. The jobs requiring
    high memory have edges to the high-memory machines, the jobs requiring GPUs have
    edges to the machines with GPUs, and so forth. Satisfied at their representation,
    they set about finding the maximum number of jobs that they can schedule at one
    time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调度员敏锐地察觉到这是运用二分匹配算法的最佳时机，于是将分配建模为一个无向图。他们将科学家的工作列在左侧，将计算机列在右侧，然后如果某个程序可以在某台计算机上运行，就从程序到计算机画一条边。需要高内存的工作与高内存计算机之间有边，要求GPU的工作与带GPU的计算机之间有边，以此类推。在确认他们的表示方式后，他们开始寻找能同时安排的最大数量的工作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Office
    Space</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分配办公室空间</samp>
- en: The Happy Data Structures corporation is looking to move into a new office.
    While most teams are counting down to move-in day with anticipation of the new
    space, the planners are worrying about how to assign each team to a work area
    in the new building. Each workspace has constraints based on the properties of
    the area, including natural light, access to resources, and size.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 快乐数据结构公司正在寻找新办公室。虽然大多数团队都在期待搬迁日的到来，憧憬着新的工作空间，规划人员却在担心如何将每个团队分配到新大楼的工作区。每个工作区都有基于区域属性的约束，包括自然光、资源访问和面积。
- en: After days of collecting long lists of requirements, the planners decide to
    model the problem as a bipartite-graph-matching problem. One set of nodes represents
    the teams and the other represents the workspaces. Spaces that are compatible
    with a team’s needs are joined by an edge. Each team can be assigned only to a
    single space, and each space can have only a single team. The planners use bipartite
    graph matching between the teams and spaces to find an assignment of all teams
    to spaces that satisfy their constraints.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集了几天的长长需求清单后，规划人员决定将这个问题建模为二分图匹配问题。一组节点代表团队，另一组代表工作空间。与某个团队需求兼容的空间通过边连接。每个团队只能分配到一个空间，每个空间只能容纳一个团队。规划人员使用团队与空间之间的二分图匹配来找到一个满足所有约束条件的团队与空间的分配方案。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning Quest Battles</samp>
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">规划任务战斗</samp>
- en: 'An adventuring party is exploring a magical dungeon when they stumble upon
    a room full of monsters. Each adventurer agrees to take on a single monster, but
    the group needs to (quickly) make the assignments. Some assignments are invalid:
    the wizard cannot fight the magic-resistant lizard, and the sword master cannot
    challenge the cloud of vapor.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一支冒险小队正在探索一个神秘的地下城时，偶然闯入了一个满是怪物的房间。每个冒险者同意与一只怪物单独作战，但小队需要（快速地）进行分配。一些分配是无效的：巫师不能与抗魔的蜥蜴作战，剑术大师不能挑战蒸汽云。
- en: In a twist on the canonical job allocation problem, the party models the problem
    as a bipartite graph assignment. They use one set of nodes to represent the adventurers
    and the other to represent the monsters. Compatible enemies are linked with an
    edge. Now they just need to efficiently match each adventurer with an enemy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的作业分配问题上，团队将该问题建模为一个二分图分配。他们使用一组节点表示冒险者，另一组节点表示怪物。兼容的敌人通过边连接。现在，他们只需要高效地将每个冒险者与一个敌人匹配。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Exhaustive Algorithms</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">穷举算法</samp>
- en: One straightforward approach to finding a variety of matchings, including maximum
    cardinality and maximum weight, is to simply try every combination of edges. We
    could enumerate all 2^|*^E*^| possible sets of used edges, throw away ones that
    use any node more than once, and score the rest based on our metric of interest.
    In this section, we briefly consider an algorithm based on depth-first search
    that performs this *exhaustive search*. This algorithm provides a baseline to
    which to compare more computationally efficient approaches.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 找到各种匹配方式（包括最大基数匹配和最大权重匹配）的一个简单方法是尝试每一种边的组合。我们可以枚举所有2^|*^E*^|个可能的边集，丢弃那些使用任何节点超过一次的集合，然后根据我们的评分标准对其余的集合进行评分。在本节中，我们简要地考虑了一种基于深度优先搜索的算法，执行这种*详尽搜索*。该算法提供了一个基准，用于与更高效的计算方法进行比较。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Matching Data</samp>
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">匹配数据</samp>
- en: 'To simplify and generalize the code in this section, we employ a wrapper data
    structure around the matching assignments that track both the assignments and
    the current score. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp>
    object holds three pieces of information about the current matching:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化和通用化本节的代码，我们围绕匹配分配创建了一个包装数据结构，跟踪匹配和当前评分。<samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp>对象保存关于当前匹配的三条信息：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the total number of nodes in the graph
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **存储图中的节点总数
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">assignments</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores
    a mapping of each node to its partner or <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    if the node is unmatched
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">assignments</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **存储每个节点到其配对节点的映射，如果节点没有配对，则为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">score</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **Stores
    the matching’s score
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">score</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **存储匹配的得分
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments</samp> list is
    bidirectional and stores the partners for both sides of the bipartite graph. For
    example, the inclusion of edge (0, 4) would result in <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments[0]=4</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments[4]=0</samp>.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments</samp>列表是双向的，存储二分图两侧的配对。例如，包含边(0,
    4)时，将导致<samp class="SANS_TheSansMonoCd_W5Regular_11">assignments[0]=4</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">assignments[4]=0</samp>。
- en: 'To implement this wrapper data structure, we define a constructor to create
    an empty matching and provide functions adding and removing edges from the matching:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个包装数据结构，我们定义了一个构造函数来创建一个空的匹配，并提供了添加和移除匹配边的函数：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To simplify the example, neither the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp>
    nor <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp> functions
    check node validity or whether a node is currently assigned. In real-world production
    software, you’ll often want to add checks that no node is used twice and that
    the added edge exists within the graph using similar checks to those in [Chapter
    1](chapter1.xhtml).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化示例，<samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp>函数都没有检查节点的有效性或节点是否已分配。在实际生产软件中，你通常需要添加检查，确保没有节点被重复使用，并且所添加的边存在于图中，可以使用类似[第1章](chapter1.xhtml)中的检查方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exhaustive Scoring</samp>
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">详尽评分</samp>
- en: We use an approach based on recursive depth-first search to enumerate which
    edges are used. Instead of exploring depth-first over the nodes, we explore over
    node assignments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用基于递归深度优先搜索的方法来列举使用的边。我们不是在节点上进行深度优先搜索，而是在节点分配上进行探索。
- en: 'For example, consider the bipartite graph in [Figure 15-6](#fig15-6). Node
    0 has three options for matching: nothing, node 1, or node 3\. The same applies
    to node 2.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑[图15-6](#fig15-6)中的二分图。节点0有三种匹配选择：无匹配、节点1或节点3，同样适用于节点2。
- en: '![A graph with four nodes and edges (0, 1), (0, 3), (2, 1) and (2, 3). The
    even nodes are in a single column on the left while the odd nodes are in a single
    column on the right.](../images/f15006.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含四个节点和边（0, 1）、（0, 3）、（2, 1）和（2, 3）的图。偶数节点在左侧的单列中，奇数节点在右侧的单列中。](../images/f15006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-6: A bipartite graph
    with four nodes</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-6：包含四个节点的二分图</samp>
- en: We can visualize the space of potential matchings for the graph in [Figure 15-6](#fig15-6)
    as a tree where each level indicates the assignment of one of the left-hand nodes.
    This tree is shown in [Figure 15-7](#fig15-7). The first level of the tree splits
    into three scenarios based on the three different options for node 0\. The left
    branch represents the options if we leave node 0 unpaired. The central branch
    represents the options with node 0 paired to node 1\. The right branch represents
    the options with node 0 paired to node 3\. We limit the search space by considering
    only potential matches that correspond to edges in the graph.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将图中的潜在匹配空间在[图 15-6](#fig15-6)中可视化为一棵树，每一层表示左侧节点的某个匹配分配。此树如[图 15-7](#fig15-7)所示。树的第一层根据节点0的三种不同选择分成三种情况。左分支代表如果我们不配对节点0的选项。中间分支代表将节点0与节点1配对的选项。右分支代表将节点0与节点3配对的选项。我们通过只考虑与图中的边对应的潜在匹配来限制搜索空间。
- en: '![A tree showing potential matches. Each node is a vector of matches for each
    node. The root node is [–1, –1, –1, 1] while the rightmost bottom node is [3,
    2, 1, 0].](../images/f15007.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![一棵展示潜在匹配的树。每个节点是每个节点的匹配向量。根节点是[–1, –1, –1, 1]，而最右下角的节点是[3, 2, 1, 0]。](../images/f15007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-7: A search tree
    over the potential node-matching assignments</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-7：潜在节点匹配分配的搜索树</samp>
- en: The second level of the tree in [Figure 15-7](#fig15-7) shows similar splits
    for the assignment of node 2\. Since node 0 is already assigned in two of the
    three branches, those branches can split only into two sub-options.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-7](#fig15-7)中的第二层树展示了类似的节点2分配的拆分。由于节点0在三个分支中的两个分支中已被分配，因此这些分支只能再分成两个子选项。'
- en: Since this approach is performing an exhaustive search, it will work for a variety
    of bipartite matching problems, including maximum cardinality and maximum weight.
    As we will see, the only factor that changes is how we compute the matching’s
    score.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种方法执行的是穷举搜索，它可以解决各种二分匹配问题，包括最大基数匹配和最大权重匹配。正如我们所看到的，唯一变化的因素是我们如何计算匹配的得分。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'We implement a search for the maximum-weight matching over this tree using
    a recursive algorithm:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用递归算法实现对这棵树的最大权重匹配搜索：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The outer wrapper function <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_matching_exh()</samp>
    labels the sides of the graph ❶ and sets up the <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp>
    data structure. It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    if the graph is not bipartite (again necessitating the inclusion of <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    Union</samp> to support the type hints for multiple return values). It then calls
    the recursive function to do the matching ❷.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 外部包装函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_matching_exh()</samp>
    标记图的两侧 ❶ 并设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp> 数据结构。如果图不是二分图，它返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>（这再次需要包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    Union</samp> 来支持多个返回值的类型提示）。然后，它调用递归函数进行匹配 ❷。
- en: The recursive function <samp class="SANS_TheSansMonoCd_W5Regular_11">matching_recursive()</samp>
    starts by checking whether it has hit the bottom of the search ❸, where everything
    on the left-hand side has been assigned (even if to <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>).
    If there are no more nodes to assign, it returns a copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp>
    as the best assignments found down this branch using the <samp class="SANS_TheSansMonoCd_W5Regular_11">deepcopy()</samp>
    function from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    library. The code performs the copy to effectively snapshot this match and separate
    it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> object
    that it will continue to modify during the rest of the search. The use of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">deepcopy()</samp> requires the inclusion
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">import copy</samp> at the top
    of the file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">matching_recursive()</samp>
    首先检查是否已到达搜索的底部 ❸，即左侧的所有内容都已被分配（即使是分配了 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>）。如果没有更多的节点可以分配，它会返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp> 的副本，作为在这一分支下找到的最佳分配，使用
    Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">deepcopy()</samp> 函数，该函数来自
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> 库。代码执行副本操作是为了有效地捕捉这一匹配，并将其与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> 对象分开，因为后者将在搜索的剩余过程中继续被修改。使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">deepcopy()</samp> 需要在文件顶部包含 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">import copy</samp>。
- en: The code then checks whether this node is on the left-hand side of the graph
    ❹. Since the code makes assignments only from the left nodes, we skip the right
    ones by calling the recursive function with the current matching at the next index.
    While the code could be modified to test both sides, assigning the right-side
    nodes is unnecessary. Each edge can be used only once and is guaranteed to be
    adjacent to a left-side node.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码检查此节点是否位于图的左侧 ❹。由于代码只从左侧节点进行分配，我们通过在下一个索引处使用当前匹配调用递归函数，跳过右侧的节点。尽管代码可以修改为同时测试左右两侧，但为右侧节点分配是不必要的。每条边只能使用一次，并且保证与左侧节点相邻。
- en: The code then checks each available option for a match to the current node and
    saves the best one, starting with the choice of leaving the current node (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">index</samp>) unassigned by calling the
    recursive function with the current matching at the next index ❺. The code saves
    the best matching down this branch for later comparison as <samp class="SANS_TheSansMonoCd_W5Regular_11">best</samp>.
    It then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to
    iterate through each of the current node’s neighbors, checking the current matching
    assignments so it can skip nodes that are already assigned to others ❻. The code
    adds each viable neighbor to the matching, uses the recursive function to get
    the best matching down that path, updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">best</samp>
    matching if necessary, and removes the edge from the matching. Finally, it returns
    the best matching down this entire branch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码检查每个可用的匹配选项与当前节点的匹配情况，并保存最佳匹配，从选择将当前节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>）保持未分配开始，通过递归函数以当前匹配在下一个索引
    ❺ 处进行调用。代码将此分支下的最佳匹配保存为 <samp class="SANS_TheSansMonoCd_W5Regular_11">best</samp>，以供稍后比较。接着，它使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历当前节点的每一个邻居，检查当前的匹配分配，从而跳过已经分配给其他节点的节点
    ❻。代码将每一个可行的邻居加入匹配中，使用递归函数获取该路径下的最佳匹配，必要时更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">best</samp>
    匹配，并从匹配中移除该边。最后，它返回整个分支下的最佳匹配。
- en: We can change the implementation from the maximum-weight matching in the code
    to a maximum-cardinality matching by changing the score passed to the matching.
    That is, we swap <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">edge.weight</samp> when adding or
    removing edges. With this change, the search selects matchings with the higher
    number of assigned edges instead of the greater total weight.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改传递给匹配的分数，将代码中的最大权重匹配更改为最大基数匹配。也就是说，我们在添加或移除边时，用 <samp class="SANS_TheSansMonoCd_W5Regular_11">edge.weight</samp>
    替换 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>。通过此更改，搜索将选择分配更多边的匹配，而不是选择总权重较大的匹配。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">示例</samp>
- en: We can visualize this function by looking at the state of the current matching
    each time the algorithm hits the bottom of the recursion. [Figure 15-8](#fig15-8)
    shows the first nine times the algorithm hits the end of the recursion on an example
    graph.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过观察每次算法到达递归底部时当前匹配的状态来可视化此函数。[图 15-8](#fig15-8) 显示了算法在一个示例图上达到递归结束的前九次情况。
- en: Since the algorithm tests the no-assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>)
    branch first, the recursion encounters the full assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">[-1,-1,-1,-1]</samp>
    in [Figure 15-8(a)](#fig15-8). After evaluating this empty matching, the search
    backtracks and tests alternate assignments for node 4 while keeping the assignments
    for nodes 0 and 2 from previous decisions fixed. This produces the matchings in
    [Figures 15-8(b)](#fig15-8), [15-8(c)](#fig15-8), and [15-8(d)](#fig15-8). It
    is not until [Figure 15-8(f)](#fig15-8) that the algorithm evaluates a matching
    with two edges used.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该算法首先测试无分配（<samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>）分支，因此递归首先遇到完全分配
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[-1,-1,-1,-1]</samp>，如[图 15-8(a)](#fig15-8)所示。在评估这个空匹配之后，搜索回溯并测试节点
    4 的其他分配，同时保持节点 0 和 2 的分配不变。这产生了[图 15-8(b)](#fig15-8)、[15-8(c)](#fig15-8) 和 [15-8(d)](#fig15-8)
    中的匹配。直到[图 15-8(f)](#fig15-8)，算法才评估了一个使用了两条边的匹配。
- en: '![Each subgraph shows a six-node bipartite graph with zero or more edges bolded.
    The score is the sum of the weights of the bolded edges.](../images/f15008.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图显示一个六节点二分图，其中一个或多个边被加粗。得分是加粗边的权重总和。](../images/f15008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-8: The first nine
    steps of the exhaustive search algorithm</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-8：穷举搜索算法的前九个步骤</samp>
- en: While the exhaustive algorithm is both complete and generalizable, it is far
    from efficient, especially on large graphs. Even the search of the six-node graph
    in [Figure 15-8](#fig15-8) explores 34 different assignments. The next section
    introduces one of the specialized algorithms that exist to efficiently solve individual
    matching problems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管穷举算法是完整的并且具有可推广性，但它效率低下，特别是在大图上。即使是在[图 15-8](#fig15-8)中的六节点图，搜索也需要探索 34 种不同的分配。下一节介绍了几种专门的算法，它们可以高效地解决单一匹配问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Solving the Maximum-Cardinality Bipartite
    Problem</samp>
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解决最大基数二分图问题</samp>
- en: This section shows how to use the max-flow algorithms from the previous chapter
    to solve the maximum-cardinality bipartite problem efficiently. We can transform
    the maximum-cardinality bipartite problem directly into a maximum-flow problem
    by transforming the bipartite graph into a flow network with directed edges and
    unit weights. [Figure 15-9(a)](#fig15-9) shows a bipartite graph and [Figure 15-9(b)](#fig15-9)
    shows the result of this transformation. We add a single source node *s* that
    feeds all the nodes in the left column. We add a single sink node *t* to accept
    flow from the nodes in the right column. Each edge in the graph is directed from
    left to right and has a capacity of 1\. (To reduce clutter, the illustration does
    not include the capacity of the edges.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何使用上一章中的最大流算法高效地解决最大基数二分图问题。我们可以通过将二分图转换为带有有向边和单位权重的流网络，直接将最大基数二分图问题转化为最大流问题。[图
    15-9(a)](#fig15-9) 显示了一个二分图，[图 15-9(b)](#fig15-9) 显示了该转换的结果。我们添加了一个单一的源节点 *s*，它向左列的所有节点提供流量。我们添加了一个单一的汇节点
    *t*，它接受右列节点的流量。图中的每条边都从左向右有向，并且容量为 1。（为了减少杂乱，插图中未显示边的容量。）
- en: '![(A) shows a bipartite graph with five nodes on the left and four on the right.
    The graph has edges (0, 1), (0, 5), (0, 7), (2, 1), (4, 3), (4, 7), (6, 1), and
    (8, 3). (B) shows an expanded graph with an additional source node feeding the
    left-hand nodes and a sink node fed by the right-hand nodes.](../images/f15009.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示一个二分图，左边有五个节点，右边有四个节点。图中有边 (0, 1)，(0, 5)，(0, 7)，(2, 1)，(4, 3)，(4, 7)，(6,
    1)，和 (8, 3)。(B) 显示一个扩展后的图，添加了一个源节点，该源节点向左侧节点提供流量，同时一个汇节点接受右侧节点提供的流量。](../images/f15009.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-9: A bipartite graph
    (a) and its flow network version (b)</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-9：一个二分图 (a) 和其流网络版本 (b)</samp>
- en: Using this setup, the source node can supply each of the left-hand nodes with
    up to a single unit of flow. Similarly, each node in the right-hand column can
    provide at most 1 unit of flow to the sink. Given the constraint that the flow
    into a node must equal the flow out of it, each node on the left can send flow
    to at most 1 unit of flow to a node on the right. Each node on the right can accept
    at most 1 unit of flow from a node on the left. The maximum flow is equal to the
    maximum number of pairs we can assign.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此设置，源节点可以为每个左侧节点提供最多一个单位的流量。类似地，右侧列中的每个节点最多可以向汇节点提供1个单位的流量。考虑到流入一个节点的流量必须等于流出该节点的流量，左侧的每个节点最多可以向右侧的一个节点发送1个单位的流量。右侧的每个节点最多可以接受左侧节点发送的1个单位的流量。最大流量等于我们可以分配的最大配对数。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>'
- en: 'The code for performing maximum-cardinality bipartite matching with the max-flow
    algorithm reuses the Edmonds-Karp implementation from [Chapter 14](chapter14.xhtml)
    to do all the heavy lifting. Much of the wrapper function itself transforms the
    graph by adding a source and sink node, then later pruning the unneeded edges:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 执行最大基数二分匹配的代码使用了 [第14章](chapter14.xhtml) 中的 Edmonds-Karp 实现来完成所有繁重的工作。包装函数本身的主要任务是通过添加源节点和汇节点来转换图形，之后再修剪掉不需要的边：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_matching_max_flow()</samp>
    function returns either a list of assignments (in the same bidirectional format
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp> class’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">assignments</samp> list) or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    if the graph is not bipartite.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_matching_max_flow()</samp>
    函数返回一个分配列表（格式与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp> 类的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments</samp> 列表相同），或者如果图不是二分图，则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。
- en: To build the augmented graph, the code first must know which nodes are on which
    side of the bipartite graph. It reuses the <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_labeling()</samp>
    function from [Listing 15-1](#list15-1), taking the opportunity to also check
    for non-bipartite graphs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建增强图，代码首先必须知道哪些节点在二分图的哪一侧。它重用了来自 [清单15-1](#list15-1) 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_labeling()</samp>
    函数，并借此机会检查是否为非二分图。
- en: The code then builds an augmented graph. First, it creates a new (directed)
    graph with two extra nodes for the source and sink ❶. Second, it adds directed
    edges, each with a capacity of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    going from the left column to the right column, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">labeling</samp>
    list to determine in which column a node belongs. Finally, the code connects the
    source and sink ❷. It adds edges from the source to each of the original graph’s
    left-hand nodes and edges from each of the original graph’s right-hand nodes to
    the sink.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码接着构建一个增强图。首先，它创建一个新的（有向）图，并为源节点和汇节点添加两个额外的节点❶。其次，它添加有向边，每条边的容量为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，并从左列指向右列，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">labeling</samp> 列表来确定每个节点所在的列。最后，代码连接源节点和汇节点❷。它从源节点到原图的每个左侧节点添加边，从原图的每个右侧节点到汇节点添加边。
- en: The code runs the Edmonds-Karp algorithm on the graph to find the maximum flow
    through it ❸. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    in the resulting graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">residual</samp>)
    that has used flow are connected. However, the overall graph also still contains
    the source node, the sink node, and all their corresponding edges. The code iterates
    through the edges and fills in the assignments for each <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> is greater than
    zero, the origin is not the source node, and the destination is not the sink node
    ❹.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在图上运行 Edmonds-Karp 算法，以找到最大流量 ❸。结果图（<samp class="SANS_TheSansMonoCd_W5Regular_11">residual</samp>）中每个已使用流量的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> 都是连接的。然而，整个图仍然包含源节点、汇节点及其对应的所有边。代码遍历这些边，并为每个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> 填充分配信息，前提是其
    <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> 大于零，且起始节点不是源节点，目标节点不是汇节点❹。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">示例</samp>
- en: '[Figure 15-10](#fig15-10) shows the steps the maximum-flow algorithm takes
    as it identifies a matching on the example bipartite graph in [Figure 15-9](#fig15-9).
    Edges at capacity (<samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> equals
    1) after each step of the algorithm are bolded.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-10](#fig15-10) 显示了最大流算法在 [图 15-9](#fig15-9) 中的示例二分图上识别匹配的步骤。每次算法执行后，容量已满的边（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">used</samp> 等于 1）会被加粗。'
- en: We can picture this algorithm in the context of the job-scheduling algorithm
    introduced in “Use Cases” on [page 263](chapter15.xhtml#pg_263). Job 0 (node 0)
    is the most flexible job, with the ability to run on three of the four machines.
    In contrast, jobs 2, 6, and 8 are limited to running on specific machines.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个算法与在“用例”中介绍的作业调度算法相结合，参见 [第 263 页](chapter15.xhtml#pg_263)。工作 0（节点 0）是最灵活的作业，能够在四台机器中的三台上运行。相比之下，工作
    2、6 和 8 仅限于在特定机器上运行。
- en: '[Figure 15-10(a)](#fig15-10) shows the initial state where the algorithm has
    added the source node, the sink node, and all the corresponding edges. No edges
    carry any flow yet. This corresponds to starting in an empty state with no jobs
    scheduled to run on any machine.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-10(a)](#fig15-10) 显示了算法添加了源节点、汇节点和所有相应边的初始状态。此时没有边携带任何流量。这对应于开始时没有作业在任何机器上调度的空状态。'
- en: '[Figures 15-10(b)](#fig15-10) and [15-10(c)](#fig15-10) show the state of assignments
    after the code finds the first two augmenting paths. During the first round, it
    discovers that the unassigned job 0 can run on the unused machine 1 and makes
    that assignment. In the second round, it does the same with job 4 and machine
    3.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-10(b)](#fig15-10) 和 [15-10(c)](#fig15-10) 展示了代码找到前两个增广路径后分配的状态。在第一轮中，它发现未分配的工作
    0 可以在未使用的机器 1 上运行，并做出了相应的分配。在第二轮中，它对工作 4 和机器 3 执行了相同的操作。'
- en: 'Things get interesting at this point, as shown in [Figure 15-10(d)](#fig15-10).
    By assigning job 0 to machine 1, the algorithm has blocked both jobs 2 and 6,
    as both can only run on machine 1\. Luckily, the algorithm can handle this by
    finding a new augmenting path: (*s*, 2), (2, 1), (1, 0), (0, 5), (5, *t*). In
    doing so, it pushes flow backward along the edge (0, 1), unassigning job 0 from
    machine 1\. The result is an assignment with one more job scheduled.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事情在此时变得有趣，如 [图 15-10(d)](#fig15-10) 所示。通过将工作 0 分配给机器 1，算法阻塞了工作 2 和工作 6，因为这两个作业只能在机器
    1 上运行。幸运的是，算法可以通过找到一个新的增广路径来解决此问题：（*s*，2）、（2，1）、（1，0）、（0，5）、（5，*t*）。这样做时，它沿着边（0，1）反向推送流量，从机器
    1 上解分配工作 0。最终结果是，调度了一个新的作业。
- en: '[Figure 15-10(e)](#fig15-10) shows a similar multi-step augmenting path. This
    new path consists of edges (*s*, 8), (8, 3), (3, 4), (4, 7), and (7, *t*). The
    code unassigns job 4 from machine 3 and then assigns job 4 to machine 7 and job
    8 to machine 3.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-10(e)](#fig15-10) 显示了一个类似的多步增广路径。这个新路径由边（*s*，8）、（8，3）、（3，4）、（4，7）和（7，*t*）组成。代码首先将工作
    4 从机器 3 上解分配，然后将工作 4 分配给机器 7，并将工作 8 分配给机器 3。'
- en: '![Each subfigure shows the same graph with different edges bolded to indicate
    the used paths. (B) has a single path (s, 0), (0, 1), (1, t) bolded.](../images/f15010.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图展示了相同的图形，但不同的边被加粗以指示使用的路径。（B）有一条路径（s，0），（0，1），（1，t）被加粗。](../images/f15010.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-10: The max-flow
    algorithm operating on an augmented bipartite graph</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-10：最大流算法在增广二分图上的操作</samp>
- en: After the maximum-flow algorithm completes, it has produced the graph in [Figure
    15-10(e)](#fig15-10). To produce the matching list, it then walks the edges of
    the residual graph. It skips all edges connected to either the source node *s*
    or the sink node *t*, since those were not part of the original bipartite graph.
    It saves all connections with nonzero flow. The result with matched edges (0,
    5), (2, 1), (4, 7), and (8, 3) is shown in [Figure 15-11](#fig15-11). The unused
    connections in the original bipartite graph are shown in thin gray lines for reference.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在最大流算法完成后，生成了 [图 15-10(e)](#fig15-10) 中的图形。为了生成匹配列表，算法接着遍历残余图的边。它跳过与源节点 *s*
    或汇节点 *t* 相连的所有边，因为这些边不属于原始的二分图。它保存所有具有非零流量的连接。匹配的边（0, 5）、（2, 1）、（4, 7）和（8, 3）结果显示在
    [图 15-11](#fig15-11) 中。原始二分图中的未使用连接以细灰线表示以供参考。
- en: '![A bipartite graph with five nodes on the left and four on the right. The
    graph has edges (0, 1), (0, 5), (0, 7), (2, 1), (4, 3), (4, 7), (6, 1), and (8,
    3). The edges (0, 5), (2, 1), (4, 7), and (8, 3) are bolded.](../images/f15011.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![一个二分图，左侧有五个节点，右侧有四个节点。图中有边 (0, 1)，(0, 5)，(0, 7)，(2, 1)，(4, 3)，(4, 7)，(6,
    1)，(8, 3)。其中，(0, 5)，(2, 1)，(4, 7)，(8, 3) 这些边是加粗的。](../images/f15011.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-11: A bipartite graph
    with edges in the maximum-cardinality matching bolded</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-11：一个二分图，最大匹配中的边加粗显示</samp>
- en: The maximum-flow algorithm will only find a single maximum-cardinality matching
    that is not necessarily unique. In [Figure 15-11](#fig15-11), for example, alternative
    matchings are possible. Instead of including the edge (2, 1), we could have included
    the edge (6, 1).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最大流算法只会找到一个单一的最大匹配，该匹配不一定是唯一的。例如，在[图15-11](#fig15-11)中，可能存在其他的匹配方式。我们可以选择包括边
    (6, 1) 而不是边 (2, 1)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: Bipartite graphs enable us to translate a range of assignment problems to equivalent
    graph algorithms, allowing access to a wealth of powerful graph algorithms. In
    doing so, we can solve problems that we might not initially think of as graph-based.
    A clear example of this flexibility is the maximum-cardinality matching problem,
    which transforms the problem of matching items from two disjoint sets into a graph
    problem that we can solve with maximum-flow algorithms.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 二分图使我们能够将一系列分配问题转化为等价的图算法，从而利用大量强大的图算法。通过这种方式，我们可以解决一些最初可能不会认为是图形问题的问题。最大匹配问题就是这种灵活性的一个明确示例，它将从两个不相交集合中匹配项的问题转化为一个图问题，我们可以用最大流算法来解决。
- en: In the next section of the book, we switch topics and consider a variety of
    computationally challenging problems on graphs. [Chapter 16](chapter16.xhtml)
    introduces the problem of assigning colors to graph nodes such that no two neighbors
    share a color. [Chapter 17](chapter17.xhtml) considers a variety of other useful
    node assignment problems. Finally, [Chapter 18](chapter18.xhtml) extends the examination
    of challenging problems to that of finding specific types of paths through graphs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一节，我们切换话题，考虑一些在图形上计算上具有挑战性的问题。[第16章](chapter16.xhtml)介绍了为图的节点分配颜色的问题，要求相邻的节点不能共享颜色。[第17章](chapter17.xhtml)考虑了其他一些有用的节点分配问题。最后，[第18章](chapter18.xhtml)将挑战性问题的讨论扩展到在图中寻找特定类型路径的问题。
