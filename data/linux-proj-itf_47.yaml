- en: Chapter 47. System V Semaphores
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第47章 系统V信号量
- en: This chapter describes System V semaphores. Unlike the IPC mechanisms described
    in previous chapters, System V semaphores are not used to transfer data between
    processes. Instead, they allow processes to synchronize their actions. One common
    use of a semaphore is to synchronize access to a block of shared memory, in order
    to prevent one process from accessing the shared memory at the same time as another
    process is updating it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了系统V信号量。与前几章介绍的IPC机制不同，系统V信号量并不用于进程间数据传输。相反，它们允许进程同步其操作。信号量的一个常见用途是同步对共享内存块的访问，以防止一个进程在另一个进程更新共享内存时同时访问它。
- en: 'A semaphore is a kernel-maintained integer whose value is restricted to being
    greater than or equal to 0\. Various operations (i.e., system calls) can be performed
    on a semaphore, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是一个由内核维护的整数，其值被限制为大于或等于0。可以对信号量执行各种操作（即系统调用），包括以下操作：
- en: setting the semaphore to an absolute value;
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将信号量设置为一个绝对值；
- en: adding a number to the current value of the semaphore;
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向当前信号量值中加上一个数；
- en: subtracting a number from the current value of the semaphore; and
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从当前信号量值中减去一个数；
- en: waiting for the semaphore value to be equal to 0.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待信号量值等于0。
- en: The last two of these operations may cause the calling process to block. When
    lowering a semaphore value, the kernel blocks any attempt to decrease the value
    below 0. Similarly, waiting for a semaphore to equal 0 blocks the calling process
    if the semaphore value is not currently 0\. In both cases, the calling process
    remains blocked until some other process alters the semaphore to a value that
    allows the operation to proceed, at which point the kernel wakes the blocked process.
    [Figure 47-1](ch47.html#using_a_semaphore_to_synchronize_two_pro "Figure 47-1. Using
    a semaphore to synchronize two processes") shows the use of a semaphore to synchronize
    the actions of two processes that alternately move the semaphore value between
    0 and 1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最后两个操作可能导致调用进程阻塞。当降低信号量的值时，内核会阻止任何尝试将其值降低到0以下的操作。同样，如果信号量的值当前不是0，等待信号量等于0会阻塞调用进程。在这两种情况下，调用进程将保持阻塞状态，直到其他进程修改信号量为允许操作进行的值，此时内核会唤醒被阻塞的进程。[图47-1](ch47.html#using_a_semaphore_to_synchronize_two_pro
    "图47-1. 使用信号量同步两个进程")展示了使用信号量同步两个进程的操作，它们交替将信号量值在0和1之间切换。
- en: '![Using a semaphore to synchronize two processes](figs/web/47-1_SVSEM-sems.png.jpg)Figure 47-1. Using
    a semaphore to synchronize two processes'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用信号量同步两个进程](figs/web/47-1_SVSEM-sems.png.jpg) 图47-1. 使用信号量同步两个进程'
- en: In terms of controlling the actions of a process, a semaphore has no meaning
    in and of itself. Its meaning is determined only by the associations given to
    it by the processes using the semaphore. Typically, processes agree on a convention
    that associates a semaphore with a shared resource, such as a region of shared
    memory. Other uses of semaphores are also possible, such as synchronization between
    parent and child processes after *fork()*. (In [Avoiding Race Conditions by Synchronizing
    with Signals](ch24.html#avoiding_race_conditions_by_synchronizin "Avoiding Race
    Conditions by Synchronizing with Signals"), we looked at the use of signals to
    accomplish the same task.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就控制进程的操作而言，信号量本身没有意义。其意义仅由使用信号量的进程赋予它的关联来决定。通常，进程会就某个约定达成一致，关联一个信号量与一个共享资源，如共享内存区域。信号量的其他用途也是可能的，例如在*fork()*之后实现父子进程之间的同步。（在[通过信号同步避免竞争条件](ch24.html#avoiding_race_conditions_by_synchronizin)一章中，我们探讨了使用信号来实现相同任务的方式。）
- en: Overview
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'The general steps for using a System V semaphore are the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用系统V信号量的基本步骤如下：
- en: Create or open a semaphore set using *semget()*.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*semget()*创建或打开一个信号量集合。
- en: Initialize the semaphores in the set using the *semctl()* `SETVAL` or `SETALL`
    operation. (Only one process should do this.)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*semctl()* `SETVAL`或`SETALL`操作初始化信号量集合。（通常只由一个进程执行此操作。）
- en: Perform operations on semaphore values using *semop()*. The processes using
    the semaphore typically use these operations to indicate acquisition and release
    of a shared resource.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*semop()*对信号量值执行操作。使用信号量的进程通常使用这些操作来指示共享资源的获取和释放。
- en: When all processes have finished using the semaphore set, remove the set using
    the *semctl()* `IPC_RMID` operation. (Only one process should do this.)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有进程都完成使用信号量集时，使用 *semctl()* 的 `IPC_RMID` 操作删除该集。（只有一个进程应该执行此操作。）
- en: Most operating systems provide some type of semaphore primitive for use in application
    programs. However, System V semaphores are rendered unusually complex by the fact
    that they are allocated in groups called *semaphore sets*. The number of semaphores
    in a set is specified when the set is created using the *semget()* system call.
    While it is common to operate on a single semaphore at a time, the *semop()* system
    call allows us to atomically perform a group of operations on multiple semaphores
    in the same set.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统为应用程序提供某种类型的信号量原语。然而，System V 信号量由于以名为 *信号量集* 的组形式分配而变得异常复杂。信号量集中的信号量数量在使用
    *semget()* 系统调用创建集时指定。尽管通常一次操作一个信号量，*semop()* 系统调用允许我们原子性地对同一信号量集中的多个信号量执行一组操作。
- en: Because System V semaphores are created and initialized in separate steps, race
    conditions can result if two processes try to perform these steps at the same
    time. Describing this race condition and how to avoid it requires that we describe
    *semctl()* before describing *semop()*, which means that there is quite a lot
    of material to cover before we have all of the details required to fully understand
    semaphores.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 System V 信号量是在不同步骤中创建和初始化的，如果两个进程尝试同时执行这些步骤，就会导致竞争条件。在描述这种竞争条件以及如何避免它时，需要先描述
    *semctl()*，再描述 *semop()*，这意味着在完全理解信号量所需的所有细节之前，我们需要覆盖相当多的内容。
- en: 'In the meantime, we provide [Example 47-1](ch47.html#creating_and_operating_on_system_v_semap
    "Example 47-1. Creating and operating on System V semaphores") as a simple example
    of the use of the various semaphore system calls. This program operates in two
    modes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们提供 [示例 47-1](ch47.html#creating_and_operating_on_system_v_semap "示例 47-1.
    创建和操作 System V 信号量") 作为使用各种信号量系统调用的简单示例。该程序有两种模式：
- en: Given a single integer command-line argument, the program creates a new semaphore
    set containing a single semaphore, and initializes the semaphore to the value
    supplied in the command-line argument. The program displays the identifier of
    the new semaphore set.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个整数命令行参数，程序创建一个包含单个信号量的新信号量集，并将信号量初始化为命令行参数中提供的值。程序显示新信号量集的标识符。
- en: Given two command-line arguments, the program interprets them as (in order)
    the identifier of an existing semaphore set and a value to be added to the first
    semaphore (numbered 0) in that set. The program carries out the specified operation
    on that semaphore. To enable us to monitor the semaphore operation, the program
    prints messages before and after the operation. Each of these messages begins
    with the process ID, so that we can distinguish the output of multiple instances
    of the program.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定两个命令行参数，程序将其解释为（按顺序）现有信号量集的标识符和要添加到该集中的第一个信号量（编号为 0）的值。程序对该信号量执行指定的操作。为了让我们能够监控信号量操作，程序在操作前后打印消息。每条消息的开头都有进程
    ID，以便我们能够区分程序多个实例的输出。
- en: 'The following shell session log demonstrates the use of the program in [Example 47-1](ch47.html#creating_and_operating_on_system_v_semap
    "Example 47-1. Creating and operating on System V semaphores"). We begin by creating
    a semaphore that is initialized to 0:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 [示例 47-1](ch47.html#creating_and_operating_on_system_v_semap "示例 47-1. 创建和操作
    System V 信号量") 中程序使用的 shell 会话日志。我们首先创建一个信号量，并将其初始化为 0：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then execute a background command that tries to decrease the semaphore value
    by 2:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行一个后台命令，尝试将信号量值减少 2：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command blocked, because the value of the semaphore can’t be decreased
    below 0\. Now, we execute a command that adds 3 to the semaphore value:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令被阻塞了，因为信号量的值不能低于 0。现在，我们执行一个命令，将信号量的值增加 3：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The semaphore increment operation succeeded immediately, and caused the semaphore
    decrement operation in the background command to proceed, since that operation
    could now be performed without leaving the semaphore’s value below 0.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量增量操作立即成功，并导致后台命令中的信号量减量操作继续执行，因为该操作现在可以在不使信号量的值低于 0 的情况下执行。
- en: Example 47-1. Creating and operating on System V semaphores
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 47-1. 创建和操作 System V 信号量
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating or Opening a Semaphore Set
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建或打开信号量集
- en: The *semget()* system call creates a new semaphore set or obtains the identifier
    of an existing set.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*semget()* 系统调用用于创建新的信号量集或获取现有信号量集的标识符。'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns semaphore set identifier on success, or -1 on error
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回信号量集标识符，错误时返回 -1
- en: The *key* argument is a key generated using one of the methods described in
    [IPC Keys](ch45.html#ipc_keys "IPC Keys") (i.e., usually the value `IPC_PRIVATE`
    or a key returned by *ftok()*).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*key* 参数是使用[IPC 密钥](ch45.html#ipc_keys "IPC 密钥")中描述的方法生成的密钥（通常是值 `IPC_PRIVATE`
    或由 *ftok()* 返回的密钥）。'
- en: If we are using *semget()* to create a new semaphore set, then *nsems* specifies
    the number of semaphores in that set, and must be greater than 0\. If we are using
    *semget()* to obtain the identifier of an existing set, then *nsems* must be less
    than or equal to the size of the set (or the error `EINVAL` results). It is not
    possible to change the number of semaphores in an existing set.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 *semget()* 创建一个新的信号量集，那么 *nsems* 指定该集中的信号量数量，并且必须大于 0。如果我们使用 *semget()*
    获取现有集的标识符，那么 *nsems* 必须小于或等于该集的大小（否则将导致错误 `EINVAL`）。无法更改现有信号量集中的信号量数量。
- en: 'The *semflg* argument is a bit mask specifying the permissions to be placed
    on a new semaphore set or checked against an existing set. These permissions are
    specified in the same manner as for files ([Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Regular
    Files](ch15.html#permissions_on_regular_files "Permissions on Regular Files")).
    In addition, zero or more of the following flags can be ORed (|) in *semflg* to
    control the operation of *semget()*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*semflg* 参数是一个位掩码，用于指定新信号量集的权限，或用于检查现有信号量集的权限。这些权限的指定方式与文件相同（见[表 15-4](ch15.html#constants_for_file_permission_bits
    "表 15-4. 文件权限常量")，以及[常规文件的权限](ch15.html#permissions_on_regular_files "常规文件的权限")）。此外，*semflg*
    中可以通过按位或（|）指定零个或多个以下标志，以控制 *semget()* 的操作：'
- en: '`IPC_CREAT`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_CREAT`'
- en: If no semaphore set with the specified *key* exists, create a new set.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的 *key* 没有对应的信号量集，则创建一个新集。
- en: '`IPC_EXCL`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_EXCL`'
- en: If `IPC_CREAT` was also specified, and a semaphore set with the specified *key*
    already exists, fail with the error `EEXIST`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还指定了 `IPC_CREAT`，并且具有指定 *key* 的信号量集已经存在，则返回错误 `EEXIST`。
- en: These flags are described in more detail in Section 45.1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志在第 45.1 节中有更详细的描述。
- en: On success, *semget()* returns the identifier for the new or existing semaphore
    set. Subsequent system calls referring to individual semaphores must specify both
    the semaphore set identifier and the number of the semaphore within that set.
    The semaphores within a set are numbered starting at 0.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功时，*semget()* 返回新创建或已存在信号量集的标识符。后续的系统调用引用单个信号量时，必须同时指定信号量集标识符和该集内信号量的编号。信号量集中的信号量从
    0 开始编号。
- en: Semaphore Control Operations
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量控制操作
- en: The *semctl()* system call performs a variety of control operations on a semaphore
    set or on an individual semaphore within a set.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*semctl()* 系统调用执行各种信号量集或信号量集内单个信号量的控制操作。'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns nonnegative integer on success (see text); returns -1 on error
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回非负整数（参见正文）；错误时返回 -1
- en: The *semid* argument is the identifier of the semaphore set on which the operation
    is to be performed. For those operations performed on a single semaphore, the
    *semnum* argument identifies a particular semaphore within the set. For other
    operations, this argument is ignored, and we can specify it as 0\. The cmd argument
    specifies the operation to be performed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*semid* 参数是操作要执行的信号量集的标识符。对于在单个信号量上执行的操作，*semnum* 参数标识信号量集内的特定信号量。对于其他操作，此参数被忽略，可以将其指定为
    0。*cmd* 参数指定要执行的操作。'
- en: Certain operations require a fourth argument to *semctl()*, which we refer to
    by the name *arg* in the remainder of this section. This argument is a union defined
    as shown in [Example 47-2](ch47.html#definition_of_the_semun_union "Example 47-2. Definition
    of the semun union"). We must explicitly define this union in our programs. We
    do this in our example programs by including the header file in [Example 47-2](ch47.html#definition_of_the_semun_union
    "Example 47-2. Definition of the semun union").
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 某些操作需要给 *semctl()* 提供第四个参数，我们在本节余下部分中称其为 *arg*。该参数是一个联合体，定义如[示例 47-2](ch47.html#definition_of_the_semun_union
    "示例 47-2. semun 联合体的定义")所示。我们必须在程序中显式定义此联合体。在我们的示例程序中，我们通过包含[示例 47-2](ch47.html#definition_of_the_semun_union
    "示例 47-2. semun 联合体的定义")中的头文件来实现这一点。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although placing the definition of the *semun* union in a standard header file
    would be sensible, SUSv3 requires the programmer to explicitly define it instead.
    Nevertheless, some UNIX implementations do provide this definition in `<sys/sem.h>`.
    Older versions of *glibc* (up to and including version 2.0) also provided this
    definition. In conformance with SUSv3, more recent versions of *glibc* do not,
    and the macro `_SEM_SEMUN_UNDEFINED` is defined with the value 1 in `<sys/sem.h>`
    to indicate this fact (i.e., an application compiled against *glibc* can test
    this macro to determine if the program must itself define the *semun* union).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将 *semun* 联合体的定义放在标准头文件中是明智的，但 SUSv3 要求程序员显式地定义它。然而，一些 UNIX 实现确实在 `<sys/sem.h>`
    中提供了此定义。较旧版本的 *glibc*（包括 2.0 版本及之前）也提供了此定义。为了符合 SUSv3，*glibc* 的较新版本没有提供此定义，并且在
    `<sys/sem.h>` 中定义了宏 `_SEM_SEMUN_UNDEFINED`，其值为 1，以表示这一事实（即，针对 *glibc* 编译的应用程序可以测试此宏，以确定程序是否需要自己定义
    *semun* 联合体）。
- en: Example 47-2. Definition of the *semun* union
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 47-2. *semun* 联合体的定义
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'SUSv2 and SUSv3 specify that the final argument to *semctl()* is optional.
    However, a few (mainly older) UNIX implementations (and older versions of *glibc*)
    prototyped *semctl()* as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv2 和 SUSv3 规定 *semctl()* 的最终参数是可选的。然而，一些（主要是较旧的）UNIX 实现（以及较旧版本的 *glibc*）的
    *semctl()* 原型如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This meant that the fourth argument was required even in the cases where it
    is not actually used (e.g., the `IPC_RMID` and `GETVAL` operations described below).
    For full portability, we specify a dummy final argument to *semctl()* in those
    calls where it is not required.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着即使在实际上不使用的情况下（例如，下面描述的 `IPC_RMID` 和 `GETVAL` 操作），第四个参数也是必需的。为了完全兼容，我们在那些不需要的调用中为
    *semctl()* 指定一个虚拟的最终参数。
- en: In the remainder of this section, we consider the various control operations
    that can be specified for *cmd*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将讨论可以为 *cmd* 指定的各种控制操作。
- en: Generic control operations
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通用控制操作
- en: The following operations are the same ones that can be applied to other types
    of System V IPC objects. In each case, the *semnum* argument is ignored. Further
    details about these operations, including the privileges and permissions required
    by the calling process, are provided in Section 45.3.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作与可以应用于其他类型的 System V IPC 对象的操作相同。在每种情况下，*semnum* 参数被忽略。关于这些操作的更多细节，包括调用进程所需的权限和权限，见第
    45.3 节。
- en: '`IPC_RMID`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_RMID`'
- en: Immediately remove the semaphore set and its associated *semid_ds* data structure.
    Any processes blocked in *semop()* calls waiting on semaphores in this set are
    immediately awakened, with *semop()* reporting the error `EIDRM`. The *arg* argument
    is not required.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 立即删除信号量集合及其相关的 *semid_ds* 数据结构。任何因等待该集合中的信号量而在 *semop()* 调用中被阻塞的进程将立即被唤醒，并且
    *semop()* 会报告错误 `EIDRM`。*arg* 参数不是必需的。
- en: '`IPC_STAT`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_STAT`'
- en: Place a copy of the *semid_ds* data structure associated with this semaphore
    set in the buffer pointed to by *arg.buf*. We describe the *semid_ds* structure
    in Section 47.4.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将与此信号量集合相关的 *semid_ds* 数据结构的副本放入 *arg.buf* 指向的缓冲区中。我们将在第 47.4 节中描述 *semid_ds*
    结构。
- en: '`IPC_SET`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_SET`'
- en: Update selected fields of the *semid_ds* data structure associated with this
    semaphore set using values in the buffer pointed to by *arg.buf*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *arg.buf* 指向的缓冲区中的值更新与此信号量集合相关的 *semid_ds* 数据结构的选定字段。
- en: Retrieving and initializing semaphore values
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检索和初始化信号量值
- en: The following operations retrieve or initialize the value(s) of an individual
    semaphore or of all semaphores in a set. Retrieving a semaphore value requires
    read permission on the semaphore, while initializing the value requires alter
    (write) permission.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作用于检索或初始化单个信号量或集合中所有信号量的值。检索信号量值需要对该信号量的读取权限，而初始化值需要修改（写入）权限。
- en: '`GETVAL`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`GETVAL`'
- en: As its function result, *semctl()* returns the value of the *semnum*-th semaphore
    in the semaphore set specified by *semid*. The *arg* argument is not required.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其功能结果，*semctl()* 返回由 *semid* 指定的信号量集合中第 *semnum* 个信号量的值。*arg* 参数不是必需的。
- en: '`SETVAL`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`SETVAL`'
- en: The value of the *semnum*-th semaphore in the set referred to by *semid* is
    initialized to the value specified in *arg.val*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由 *semid* 引用的信号量集合中第 *semnum* 个信号量的值被初始化为 *arg.val* 中指定的值。
- en: '`GETALL`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`GETALL`'
- en: Retrieve the values of all of the semaphores in the set referred to by *semid*,
    placing them in the array pointed to by *arg.array*. The programmer must ensure
    that this array is of sufficient size. (The number of semaphores in a set can
    be obtained from the *sem_nsems* field of the *semid_ds* data structure retrieved
    by an `IPC_STAT` operation.) The *semnum* argument is ignored. An example of the
    use of the `GETALL` operation is provided in [Example 47-3](ch47.html#a_semaphore_monitoring_program
    "Example 47-3. A semaphore monitoring program").
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 检索由*semid*引用的信号量集中的所有信号量的值，并将它们放入`arg.array`指向的数组中。程序员必须确保该数组具有足够的大小。（信号量集中的信号量数量可以从通过`IPC_STAT`操作检索到的`semid_ds`数据结构中的`sem_nsems`字段获取。）`semnum`参数被忽略。[示例
    47-3](ch47.html#a_semaphore_monitoring_program "示例 47-3. 信号量监控程序")中提供了`GETALL`操作的使用示例。
- en: '`SETALL`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`SETALL`'
- en: Initialize all semaphores in the set referred to by *semid*, using the values
    supplied in the array pointed to by *arg.array*. The *semnum* argument is ignored.
    [Example 47-4](ch47.html#using_the_setall_operation_to_initialize "Example 47-4. Using
    the SETALL operation to initialize a System V semaphore set") demonstrates the
    use of the `SETALL` operation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`arg.array`指向的数组中提供的值初始化由*semid*引用的信号量集中的所有信号量。`semnum`参数被忽略。[示例 47-4](ch47.html#using_the_setall_operation_to_initialize
    "示例 47-4. 使用SETALL操作初始化一个System V信号量集")演示了`SETALL`操作的使用。
- en: If another process is waiting to perform an operation on the semaphore(s) modified
    by the `SETVAL` or `SETALL` operations, and the change(s) made would permit that
    operation to proceed, then the kernel wakes up that process.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个进程正在等待对由`SETVAL`或`SETALL`操作修改的信号量执行某个操作，并且所做的更改允许该操作继续执行，那么内核将唤醒该进程。
- en: Changing the value of a semaphore with `SETVAL` or `SETALL` clears the undo
    entries for that semaphore in all processes. We describe semaphore undo entries
    in Section 47.8.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SETVAL`或`SETALL`更改信号量的值会清除所有进程中该信号量的撤销条目。我们在第47.8节中描述了信号量的撤销条目。
- en: Note that the information returned by `GETVAL` and `GETALL` may already be out
    of date by the time the calling process comes to use it. Any program that depends
    on the information returned by these operations being unchanged may be subject
    to time-of-check, time-of-use race conditions ([Beware of Signals and Race Conditions](ch38.html#beware_of_signals_and_race_conditions
    "Beware of Signals and Race Conditions")).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`GETVAL`和`GETALL`返回的信息在调用进程使用时可能已经过时。任何依赖于这些操作返回的信息不变的程序，可能会受到检查时与使用时的竞态条件影响（[警惕信号和竞态条件](ch38.html#beware_of_signals_and_race_conditions
    "警惕信号和竞态条件")）。
- en: Retrieving per-semaphore information
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检索每个信号量的信息
- en: The following operations return (via the function result value) information
    about the *semnum*-th semaphore of the set referred to by *semid*. For all of
    these operations, read permission is required on the semaphore set, and the *arg*
    argument is not required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作通过函数返回值返回关于由*semid*引用的信号量集中的*semnum*信号量的信息。对于所有这些操作，都需要对信号量集具有读取权限，并且不需要`*arg*`参数。
- en: '`GETPID`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`GETPID`'
- en: Return the process ID of the last process to perform a *semop()* on this semaphore;
    this is referred to as the *sempid* value. If no process has yet performed a *semop()*
    on this semaphore, 0 is returned.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 返回最后一个执行`semop()`操作的进程的进程ID；这被称为*sempid*值。如果没有进程执行过该信号量的`semop()`操作，则返回0。
- en: '`GETNCNT`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`GETNCNT`'
- en: Return the number of processes currently waiting for the value of this semaphore
    to increase; this is referred to as the *semncnt* value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前等待该信号量值增加的进程数量；这被称为*semncnt*值。
- en: '`GETZCNT`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`GETZCNT`'
- en: Return the number of processes currently waiting for the value of this semaphore
    to become 0; this is referred to as the *semzcnt* value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前等待该信号量值变为0的进程数量；这被称为*semzcnt*值。
- en: As with the `GETVAL` and `GETALL` operations described above, the information
    returned by the `GETPID`, `GETNCNT`, and `GETZCNT` operations may already be out
    of date by the time the calling process comes to use it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述描述的`GETVAL`和`GETALL`操作一样，`GETPID`、`GETNCNT`和`GETZCNT`操作返回的信息在调用进程使用时可能已经过时。
- en: '[Example 47-3](ch47.html#a_semaphore_monitoring_program "Example 47-3. A semaphore
    monitoring program") demonstrates the use of these three operations.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 47-3](ch47.html#a_semaphore_monitoring_program "示例 47-3. 信号量监控程序")演示了这三个操作的使用。'
- en: Semaphore Associated Data Structure
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量相关数据结构
- en: 'Each semaphore set has an associated *semid_ds* data structure of the following
    form:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个信号量集合都有一个与之关联的*semid_ds*数据结构，形式如下：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 requires all of the fields that we show in the *semid_ds* structure. Some
    other UNIX implementations include additional nonstandard fields. On Linux 2.4
    and later, the *sem_nsems* field is typed as *unsigned long*. SUSv3 specifies
    the type of this field as *unsigned short*, and it is so defined in Linux 2.2
    and on most other UNIX implementations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3要求我们在*semid_ds*结构中展示的所有字段。其他一些UNIX实现可能包括额外的非标准字段。在Linux 2.4及更高版本中，*sem_nsems*字段的类型为*unsigned
    long*。SUSv3规定该字段的类型为*unsigned short*，并且在Linux 2.2及大多数其他UNIX实现中也如此定义。
- en: 'The fields of the *semid_ds* structure are implicitly updated by various semaphore
    system calls, and certain subfields of the *sem_perm* field can be explicitly
    updated using the *semctl()* `IPC_SET` operation. The details are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*semid_ds*结构的字段通过各种信号量系统调用隐式更新，*sem_perm*字段的某些子字段可以通过*semctl()*的`IPC_SET`操作显式更新。具体细节如下：'
- en: '*sem_perm*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_perm*'
- en: When the semaphore set is created, the fields of this substructure are initialized
    as described in Section 45.3\. The *uid*, *gid*, and *mode* subfields can be updated
    via `IPC_SET`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当信号量集合创建时，该子结构的字段按照第45.3节所述初始化。*uid*、*gid*和*mode*子字段可以通过`IPC_SET`进行更新。
- en: '*sem_otime*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_otime*'
- en: This field is set to 0 when the semaphore set is created, and then set to the
    current time on each successful *semop()*, or when the semaphore value is modified
    as a consequence of a `SEM_UNDO` operation ([Semaphore Undo Values](ch47.html#semaphore_undo_values
    "Semaphore Undo Values")). This field and *sem_ctime* are typed as *time_t*, and
    store time in seconds since the Epoch.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当信号量集合创建时，该字段被设置为0，并在每次成功的*semop()*操作后，或在因`SEM_UNDO`操作（[信号量撤销值](ch47.html#semaphore_undo_values
    "Semaphore Undo Values")）导致信号量值修改时，设置为当前时间。此字段和*sem_ctime*的类型为*time_t*，并存储自纪元以来的秒数。
- en: '*sem_ctime*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_ctime*'
- en: This field is set to the current time when the semaphore set is created and
    on each successful `IPC_SET`, `SETALL`, or `SETVAL` operation. (On some UNIX implementations,
    the `SETALL` and `SETVAL` operations don’t modify *sem_ctime*.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当信号量集合创建时，并在每次成功的`IPC_SET`、`SETALL`或`SETVAL`操作时，此字段被设置为当前时间。（在某些UNIX实现中，`SETALL`和`SETVAL`操作不会修改*sem_ctime*。）
- en: '*sem_nsems*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_nsems*'
- en: When the set is created, this field is initialized to the number of semaphores
    in the set.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合被创建时，该字段被初始化为集合中信号量的数量。
- en: In the remainder of this section, we show two example programs that make use
    of the *semid_ds* data structure and some of the *semctl()* operations described
    in Section 47.3\. We demonstrate the use of both of these programs in Section
    47.6.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的剩余部分展示了两个示例程序，这些程序利用了*semid_ds*数据结构和第47.3节中描述的部分*semctl()*操作。我们将在第47.6节中演示这两个程序的使用。
- en: Monitoring a semaphore set
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 监视一个信号量集合
- en: The program in [Example 47-3](ch47.html#a_semaphore_monitoring_program "Example 47-3. A
    semaphore monitoring program") makes use of various *semctl()* operations to display
    information about the existing semaphore set whose identifier is provided as its
    command-line argument. The program first displays the time fields from the *semid_ds*
    data structure. Then, for each semaphore in the set, the program displays the
    semaphore’s current value, as well as its *sempid*, *semncnt*, and *semzcnt* values.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例47-3](ch47.html#a_semaphore_monitoring_program "示例47-3. 信号量监视程序")中的程序使用了各种*semctl()*操作来显示有关现有信号量集合的信息，其标识符作为命令行参数提供。程序首先显示*semid_ds*数据结构中的时间字段。然后，对于集合中的每个信号量，程序显示该信号量的当前值，以及其*sempid*、*semncnt*和*semzcnt*值。'
- en: Example 47-3. A semaphore monitoring program
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 示例47-3。信号量监视程序
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Initializing all semaphores in a set
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化一个信号量集合中的所有信号量
- en: The program in [Example 47-4](ch47.html#using_the_setall_operation_to_initialize
    "Example 47-4. Using the SETALL operation to initialize a System V semaphore set")
    provides a command-line interface for initializing all of the semaphores in an
    existing set. The first command-line argument is the identifier of the semaphore
    set to be initialized. The remaining command-line arguments specify the values
    to which the semaphores are to be initialized (there must be as many of these
    arguments as there are semaphores in the set).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 47-4](ch47.html#using_the_setall_operation_to_initialize "示例 47-4. 使用SETALL操作初始化System
    V信号量集合")中的程序提供了一个命令行界面，用于初始化现有信号量集合中的所有信号量。第一个命令行参数是要初始化的信号量集合的标识符。其余的命令行参数指定信号量应初始化为的值（这些参数的数量必须与集合中的信号量数量相同）。'
- en: Example 47-4. Using the `SETALL` operation to initialize a System V semaphore
    set
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 47-4. 使用`SETALL`操作初始化System V信号量集合
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Semaphore Initialization
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量初始化
- en: According to SUSv3, an implementation is not required to initialize the values
    of the semaphores in a set created by *semget()*. Instead, the programmer must
    explicitly initialize the semaphores using the *semctl()* system call. (On Linux,
    the semaphores returned by *semget()* are in fact initialized to 0, but we can’t
    portably rely on this.) As stated earlier, the fact that semaphore creation and
    initialization must be performed by separate system calls, instead of in a single
    atomic step, leads to possible race conditions when initializing a semaphore.
    In this section, we detail the nature of the race and look at a method of avoiding
    it based on an idea described in [Stevens, 1999].
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SUSv3的规定，*semget()*创建的信号量集合的值不需要初始化。相反，程序员必须通过*semctl()*系统调用显式初始化信号量。（在Linux中，*semget()*返回的信号量实际上会被初始化为0，但我们不能依赖这一点来保证可移植性。）如前所述，信号量的创建和初始化必须通过单独的系统调用来完成，而不是通过单个原子操作，这就可能导致初始化信号量时出现竞争条件。在本节中，我们将详细说明竞争的性质，并根据[Stevens,
    1999]中描述的一个方法，探讨避免这种问题的方案。
- en: Suppose that we have an application consisting of multiple peer processes employing
    a semaphore to coordinate their actions. Since no single process is guaranteed
    to be the first to use the semaphore (this is what is meant by the term *peer*),
    each process must be prepared to create and initialize the semaphore if it doesn’t
    already exist. For this purpose, we might consider employing the code shown in
    [Example 47-5](ch47.html#incorrectly_initializing_a_system_v_sema "Example 47-5. Incorrectly
    initializing a System V semaphore").
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个由多个对等进程组成的应用程序，这些进程使用信号量来协调它们的操作。由于没有任何进程能够保证首先使用信号量（这就是*对等*一词的含义），每个进程必须准备好在信号量不存在时创建并初始化它。为此，我们可以考虑使用[示例 47-5](ch47.html#incorrectly_initializing_a_system_v_sema
    "示例 47-5. 错误地初始化System V信号量")中显示的代码。
- en: Example 47-5. Incorrectly initializing a System V semaphore
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 47-5. 错误地初始化System V信号量
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The problem with the code in [Example 47-5](ch47.html#incorrectly_initializing_a_system_v_sema
    "Example 47-5. Incorrectly initializing a System V semaphore") is that if two
    processes execute it at the same time, then the sequence shown in [Figure 47-2](ch47.html#two_processes_racing_to_initialize_the_s
    "Figure 47-2. Two processes racing to initialize the same semaphore") could occur,
    if the first process’s time slice happens to expire at the point marked `XXXX`
    in the code. This sequence is problematic for two reasons. First, process B performs
    a *semop()* on an uninitialized semaphore (i.e., one whose value is arbitrary).
    Second, the *semctl()* call in process A overwrites the changes made by process
    B.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 47-5](ch47.html#incorrectly_initializing_a_system_v_sema "示例 47-5. 错误地初始化System
    V信号量")中代码的问题在于，如果两个进程同时执行该代码，那么如果第一个进程的时间片恰好在代码中标记为`XXXX`的位置到期，就可能发生[图 47-2](ch47.html#two_processes_racing_to_initialize_the_s
    "图 47-2. 两个进程竞争初始化同一个信号量")所示的序列。这个序列存在两个问题。首先，进程B在一个未初始化的信号量上执行*semop()*（即其值是任意的）。其次，进程A中的*semctl()*调用覆盖了进程B所做的更改。'
- en: The solution to this problem relies on a historical, and now standardized, feature
    of the initialization of the *sem_otime* field in the *semid_ds* data structure
    associated with the semaphore set. When a semaphore set is first created, the
    *sem_otime* field is initialized to 0, and it is changed only by a subsequent
    *semop()* call. We can exploit this feature to eliminate the race condition described
    above. We do this by inserting extra code to force the second process (i.e., the
    one that does not create the semaphore) to wait until the first process has both
    initialized the semaphore *and* executed a *semop()* call that updates the *sem_otime*
    field, but does not modify the semaphore’s value. The modified code is shown in
    [Example 47-6](ch47.html#initializing_a_system_v_semaphore "Example 47-6. Initializing
    a System V semaphore").
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案依赖于一种历史性的、现在已标准化的特性，即与信号量集关联的*semid_ds*数据结构中*sem_otime*字段的初始化。当信号量集首次创建时，*sem_otime*字段会被初始化为0，并且仅通过后续的*semop()*调用进行更改。我们可以利用这一特性消除上面描述的竞态条件。我们通过插入额外的代码，迫使第二个进程（即未创建信号量的那个进程）等待，直到第一个进程既初始化了信号量*并且*执行了一个更新*sem_otime*字段的*semop()*调用，但不修改信号量的值。修改后的代码如[示例 47-6](ch47.html#initializing_a_system_v_semaphore
    "示例 47-6. 初始化一个System V信号量")所示。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, the solution to the initialization problem described in the main
    text doesn’t work on all UNIX implementations. In some versions of the modern
    BSD derivatives, *semop()* doesn’t update the *sem_otime* field.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，主文中描述的初始化问题解决方案并不适用于所有UNIX实现。在一些现代BSD衍生版本中，*semop()*不会更新*sem_otime*字段。
- en: Example 47-6. Initializing a System V semaphore
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 47-6. 初始化一个System V信号量
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can use variations of the technique shown in [Example 47-6](ch47.html#initializing_a_system_v_semaphore
    "Example 47-6. Initializing a System V semaphore") to ensure that multiple semaphores
    in a set are correctly initialized, or that a semaphore is initialized to a nonzero
    value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[示例 47-6](ch47.html#initializing_a_system_v_semaphore "示例 47-6. 初始化一个System
    V信号量")中展示的技术变体，确保信号量集中的多个信号量被正确初始化，或者确保某个信号量被初始化为非零值。
- en: This rather complex solution to the race problem is not required in all applications.
    We don’t need it if one process is guaranteed to be able to create and initialize
    the semaphore before any other processes attempt to use it. This would be the
    case, for example, if a parent creates and initializes the semaphore before creating
    child processes with which it shares the semaphore. In such cases, it is sufficient
    for the first process to follow its *semget()* call by a *semctl()* `SETVAL` or
    `SETALL` operation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种较为复杂的竞态问题解决方案并非所有应用都需要。如果可以确保一个进程能够在任何其他进程尝试使用信号量之前创建并初始化它，那么我们就不需要这个方案。例如，如果父进程在创建共享信号量的子进程之前创建并初始化了信号量，那么就是这种情况。在这种情况下，足够的做法是让第一个进程在*semget()*调用后执行一个*semctl()*
    `SETVAL`或`SETALL`操作。
- en: '![Two processes racing to initialize the same semaphore](figs/web/47-2_SVSEM-init-race.png.jpg)Figure 47-2. Two
    processes racing to initialize the same semaphore'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![两个进程竞相初始化同一个信号量](figs/web/47-2_SVSEM-init-race.png.jpg)图 47-2. 两个进程竞相初始化同一个信号量'
- en: Semaphore Operations
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量操作
- en: The *semop()* system call performs one or more operations on the semaphores
    in the semaphore set identified by *semid*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*semop()*系统调用在由*semid*标识的信号量集中的一个或多个信号量上执行操作。'
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'The *sops* argument is a pointer to an array that contains the operations to
    be performed, and *nsops* gives the size of this array (which must contain at
    least one element). The operations are performed atomically and in array order.
    The elements of the *sops* array are structures of the following form:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*sops*参数是一个指向包含要执行操作的数组的指针，*nsops*给出该数组的大小（必须至少包含一个元素）。操作是原子执行的，并按数组顺序执行。*sops*数组的元素是以下形式的结构：'
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The *sem_num* field identifies the semaphore within the set upon which the
    operation is to be performed. The *sem_op* field specifies the operation to be
    performed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_num*字段标识将在信号量集内执行操作的信号量。*sem_op*字段指定要执行的操作：'
- en: If *sem_op* is greater than 0, the value of *sem_op* is added to the semaphore
    value. As a result, other processes waiting to decrease the semaphore value may
    be awakened and perform their operations. The calling process must have alter
    (write) permission on the semaphore.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *sem_op* 大于 0，则将 *sem_op* 的值加到信号量的值上。结果，其他等待减少信号量值的进程可能会被唤醒并执行它们的操作。调用进程必须对信号量具有修改（写入）权限。
- en: If *sem_op* equals 0, the value of the semaphore is checked to see whether it
    currently equals 0\. If it does, the operation completes immediately; otherwise,
    *semop()* blocks until the semaphore value becomes 0\. The calling process must
    have read permission on the semaphore.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *sem_op* 等于 0，则会检查信号量的值是否当前等于 0。如果是，操作将立即完成；否则，*semop()* 会阻塞，直到信号量的值变为 0。调用进程必须具有对该信号量的读取权限。
- en: If *sem_op* is less than 0, decrease the value of the semaphore by the amount
    specified in *sem_op*. If the current value of the semaphore is greater than or
    equal to the absolute value of *sem_op*, the operation completes immediately.
    Otherwise, *semop()* blocks until the semaphore value has been increased to a
    level that permits the operation to be performed without resulting in a negative
    value. The calling process must have alter permission on the semaphore.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *sem_op* 小于 0，则将信号量的值减少 *sem_op* 指定的数量。如果信号量的当前值大于或等于 *sem_op* 的绝对值，操作将立即完成。否则，*semop()*
    将阻塞，直到信号量的值增加到一个允许操作执行的水平，而不会导致负值。调用进程必须对信号量具有修改权限。
- en: Semantically, increasing the value of a semaphore corresponds to making a resource
    available so that others can use it, while decreasing the value of a semaphore
    corresponds to reserving a resource for (exclusive) use by this process. When
    decreasing the value of a semaphore, the operation is blocked if the semaphore
    value is too low—that is, if some other process has already reserved the resource.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，增加信号量的值对应于使一个资源可用，以便其他进程使用，而减少信号量的值对应于为（独占）使用该资源保留一个资源。当减少信号量的值时，如果信号量的值太低，操作将被阻塞——也就是说，如果其他进程已经预留了该资源。
- en: 'When a *semop()* call blocks, the process remains blocked until one of the
    following occurs:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *semop()* 调用被阻塞时，进程将保持阻塞状态，直到发生以下情况之一：
- en: Another process modifies the value of the semaphore such that the requested
    operation can proceed.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个进程修改了信号量的值，使得请求的操作能够继续。
- en: A signal interrupts the *semop()* call. In this case, the error `EINTR` results.
    (As noted in [Interruption and Restarting of System Calls](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls"), *semop()* is never automatically
    restarted after being interrupted by a signal handler.)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个信号中断了 *semop()* 调用。在这种情况下，会产生错误 `EINTR`。（正如在[系统调用的中断与重启](ch21.html#interruption_and_restarting_of_system_ca
    "系统调用的中断与重启")中所指出的，*semop()* 在被信号处理程序中断后不会自动重启。）
- en: Another process deletes the semaphore referred to by *semid*. In this case,
    *semop()* fails with the error `EIDRM`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个进程删除了 *semid* 所指向的信号量。在这种情况下，*semop()* 会因错误 `EIDRM` 失败。
- en: We can prevent *semop()* from blocking when performing an operation on a particular
    semaphore by specifying the `IPC_NOWAIT` flag in the corresponding *sem_flg* field.
    In this case, if *semop()* would have blocked, it instead fails with the error
    `EAGAIN`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在相应的 *sem_flg* 字段中指定 `IPC_NOWAIT` 标志来防止 *semop()* 在执行某个信号量的操作时阻塞。在这种情况下，如果
    *semop()* 本应阻塞，它将失败并返回错误 `EAGAIN`。
- en: While it is usual to operate on a single semaphore at a time, it is possible
    to make a *semop()* call that performs operations on multiple semaphores in a
    set. The key point to note is that this group of operations is performed atomically;
    that is, *semop()* either performs all of the operations immediately, if possible,
    or blocks until it would be possible to perform all of the operations simultaneously.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常一次只操作一个信号量，但也可以执行一个 *semop()* 调用，针对一个信号量集合中的多个信号量执行操作。需要注意的关键点是，这组操作是原子的；也就是说，*semop()*
    要么立即执行所有操作（如果可能），要么阻塞，直到能够同时执行所有操作为止。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Few systems document the fact that *semop()* performs operations in array order,
    although all systems known to the author do so, and a few applications depend
    on this behavior. SUSv4 adds text that explicitly requires this behavior.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有系统文档记录 *semop()* 按数组顺序执行操作，尽管作者已知的所有系统都这样做，而且一些应用依赖于这种行为。SUSv4 增加了明确要求此行为的文字。
- en: '[Example 47-7](ch47.html#using_semop_open_parenthesis_close_paren "Example 47-7. Using
    semop() to perform operations on multiple System V semaphores") demonstrates the
    use of *semop()* to perform operations on three semaphores in a set. The operations
    on semaphores 0 and 2 may not be able to proceed immediately, depending on the
    current values of the semaphores. If the operation on semaphore 0 can’t be performed
    immediately, then none of the requested operations is performed, and *semop()*
    blocks. On the other hand, if the operation on semaphore 0 could be performed
    immediately, but the operation on semaphore 2 could not, then—because the `IPC_NOWAIT`
    flag was specified—none of the requested operations is performed, and *semop()*
    returns immediately with the error `EAGAIN`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 47-7](ch47.html#using_semop_open_parenthesis_close_paren "示例 47-7. 使用 semop()
    对多个 System V 信号量执行操作") 展示了如何使用 *semop()* 对信号量集中的三个信号量执行操作。信号量 0 和信号量 2 的操作可能无法立即进行，这取决于信号量的当前值。如果信号量
    0 的操作不能立即执行，那么请求的所有操作都不会执行，且 *semop()* 会阻塞。另一方面，如果信号量 0 的操作可以立即执行，但信号量 2 的操作不能，那么——由于指定了
    `IPC_NOWAIT` 标志——请求的所有操作都不会执行，且 *semop()* 会立即返回错误 `EAGAIN`。'
- en: The *semtimedop()* system call performs the same task as *semop()*, except that
    the *timeout* argument specifies an upper limit on the time for which the call
    will block.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*semtimedop()* 系统调用执行与 *semop()* 相同的任务，不同之处在于 *timeout* 参数指定了调用阻塞的最大时间限制。'
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: 'The *timeout* argument is a pointer to a *timespec* structure ([High-Resolution
    Sleeping: *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep "High-Resolution
    Sleeping: nanosleep()")), which allows a time interval to be expressed as a number
    of seconds and nanoseconds. If the specified time interval expires before it is
    possible to complete the semaphore operation, *semtimedop()* fails with the error
    `EAGAIN`. If *timeout* is specified as `NULL`, *semtimedop()* is exactly the same
    as *semop()*.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*timeout* 参数是指向 *timespec* 结构的指针（[高精度睡眠：*nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep
    "高精度睡眠：nanosleep()")），该结构允许将时间间隔表示为秒和纳秒的数量。如果在信号量操作完成之前指定的时间间隔已过，*semtimedop()*
    将失败并返回错误 `EAGAIN`。如果 *timeout* 被指定为 `NULL`，则 *semtimedop()* 的行为与 *semop()* 完全相同。'
- en: The *semtimedop()* system call is provided as a more efficient method of setting
    a timeout on a semaphore operation than using *setitimer()* plus *semop()*. The
    small performance benefit that this confers is significant for certain applications
    (notably, some database systems) that need to frequently perform such operations.
    However, *semtimedop()* is not specified in SUSv3 and is present on only a few
    other UNIX implementations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*semtimedop()* 系统调用提供了一种比使用 *setitimer()* 加 *semop()* 更高效的设置信号量操作超时的方法。这个小的性能提升对于某些需要频繁执行此类操作的应用（特别是一些数据库系统）来说非常重要。然而，*semtimedop()*
    并没有在 SUSv3 中规定，仅在少数其他 UNIX 实现中存在。'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *semtimedop()* system call appeared as a new feature in Linux 2.6 and was
    subsequently back-ported into Linux 2.4, starting with kernel 2.4.22.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*semtimedop()* 系统调用作为 Linux 2.6 中的新特性出现，随后被回移植到 Linux 2.4，从内核 2.4.22 开始。'
- en: Example 47-7. Using *semop()* to perform operations on multiple System V semaphores
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 47-7. 使用 *semop()* 对多个 System V 信号量执行操作
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Example program
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The program in [Example 47-8](ch47.html#performing_system_v_semaphore_operations
    "Example 47-8. Performing System V semaphore operations with semop()") provides
    a command-line interface to the *semop()* system call. The first argument to this
    program is the identifier of the semaphore set upon which operations are to be
    performed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 47-8](ch47.html#performing_system_v_semaphore_operations "示例 47-8. 使用 semop()
    执行 System V 信号量操作") 中的程序提供了一个命令行界面来调用 *semop()* 系统调用。该程序的第一个参数是要执行操作的信号量集的标识符。'
- en: 'Each of the remaining command-line arguments specifies a group of semaphore
    operations to be performed in a single *semop()* call. The operations within a
    single command-line argument are delimited by commas. Each operation has one of
    the following forms:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 其余每个命令行参数指定了在单个 *semop()* 调用中要执行的一组信号量操作。单个命令行参数中的操作由逗号分隔。每个操作具有以下形式之一：
- en: '*semnum*`+`*value*: add *value* to semaphore *semnum*.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*semnum*`+`*value*：将 *value* 添加到信号量 *semnum*。'
- en: '*semnum*`-`*value*: subtract *value* from semaphore *semnum*.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*semnum*`-`*value*：从信号量 *semnum* 中减去 *value*。'
- en: '*semnum*`=0`: test semaphore *semnum* to see if it equals 0.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*semnum*`=0`：测试信号量 *semnum* 是否等于 0。'
- en: At the end of each operation, we can optionally include an *n*, a *u*, or both.
    The letter *n* means include `IPC_NOWAIT` in the *sem_flg* value for this operation.
    The letter *u* means include `SEM_UNDO` in *sem_flg*. (We describe the `SEM_UNDO`
    flag in Section 47.8.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次操作结束时，我们可以选择性地包括一个*n*、一个*u*，或两者。字母*n*表示在此操作的*sem_flg*值中包含`IPC_NOWAIT`。字母*u*表示在*sem_flg*中包含`SEM_UNDO`。（我们在第47.8节中描述了`SEM_UNDO`标志。）
- en: 'The following command line specifies two *semop()* calls on the semaphore set
    whose identifier is 0:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令行指定对信号量集的两个*semop()*调用，该信号量集的标识符为0：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first command-line argument specifies a *semop()* call that waits until
    semaphore zero equals 0\. The second argument specifies a *semop()* call that
    subtracts 1 from semaphore 0, and subtracts 2 from semaphore 1\. For the operation
    on semaphore 0, *sem_flg* is 0; for the operation on semaphore 1, *sem_flg* is
    `IPC_NOWAIT`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令行参数指定一个*semop()*调用，该调用会等待直到信号量0的值等于0。第二个参数指定一个*semop()*调用，该调用会从信号量0中减去1，并从信号量1中减去2。对于信号量0的操作，*sem_flg*为0；对于信号量1的操作，*sem_flg*为`IPC_NOWAIT`。
- en: Example 47-8. Performing System V semaphore operations with *semop()*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 示例47-8. 使用*semop()*执行System V信号量操作
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using the program in [Example 47-8](ch47.html#performing_system_v_semaphore_operations
    "Example 47-8. Performing System V semaphore operations with semop()"), along
    with various others shown in this chapter, we can study the operation of System
    V semaphores, as demonstrated in the following shell session. We begin by using
    a program that creates a semaphore set containing two semaphores, which we initialize
    to 1 and 0:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[示例47-8](ch47.html#performing_system_v_semaphore_operations "示例47-8. 使用semop()执行System
    V信号量操作")中的程序，以及本章中展示的其他程序，我们可以研究System V信号量的操作，如下所示的shell会话。我们从使用一个创建包含两个信号量的信号量集的程序开始，这两个信号量被初始化为1和0：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t show the code of the `svsem/svsem_create.c` program in this chapter,
    but it is provided in the source code distribution for this book. This program
    performs the same function for semaphores as the program in [Example 46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "Example 46-1. Using msgget()") (in [Creating or Opening a Message Queue](ch46.html#creating_or_opening_a_message_queue
    "Creating or Opening a Message Queue")) performs for message queues; that is,
    it creates a semaphore set. The only notable difference is that `svsem_create.c`
    takes an additional argument specifying the size of the semaphore set to be created.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章未展示`svsem/svsem_create.c`程序的代码，但它已包含在本书的源代码分发中。该程序执行的功能与[示例46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "示例46-1. 使用msgget()")（在[创建或打开消息队列](ch46.html#creating_or_opening_a_message_queue
    "创建或打开消息队列")中）为消息队列执行的功能相同；也就是说，它创建一个信号量集。唯一显著的不同是，`svsem_create.c`接受一个额外的参数，用来指定要创建的信号量集的大小。
- en: 'Next, we start three background instances of the program in [Example 47-8](ch47.html#performing_system_v_semaphore_operations
    "Example 47-8. Performing System V semaphore operations with semop()") to perform
    *semop()* operations on the semaphore set. The program prints messages before
    and after each semaphore operation. These messages include the time, so that we
    can see when each operation starts and when it completes, and the process ID,
    so that we can track the operation of multiple instances of the program. The first
    command makes a request to decrease both semaphores by 1:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启动三个[示例47-8](ch47.html#performing_system_v_semaphore_operations "示例47-8.
    使用semop()执行System V信号量操作")程序的后台实例，以在信号量集上执行*semop()*操作。程序在每次信号量操作前后打印消息。这些消息包括时间，以便我们可以看到每个操作何时开始以及何时完成，还有进程ID，以便我们可以追踪多个程序实例的操作。第一个命令请求将两个信号量都减少1：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the above output, we see that the program printed a message saying that the
    *semop()* operation is about to be performed, but did not print any further messages,
    because the *semop()* call blocks. The call blocks because semaphore 1 has the
    value 0.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，我们看到程序打印了一条消息，说明即将执行*semop()*操作，但没有打印进一步的消息，因为*semop()*调用会阻塞。调用会阻塞，因为信号量1的值为0。
- en: 'Next, we execute a command that makes a request to decrease semaphore 1 by
    1:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行一个命令，要求将信号量1减少1：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command also blocks. Next, we execute a command that waits for the value
    of semaphore 0 to equal 0:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令也会阻塞。接下来，我们执行一个命令，等待信号量0的值等于0：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, this command blocks, in this case because the value of semaphore 0 is
    currently 1.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个命令会阻塞，这次是因为信号量0的值当前为1。
- en: 'Now, we use the program in [Example 47-3](ch47.html#a_semaphore_monitoring_program
    "Example 47-3. A semaphore monitoring program") to inspect the semaphore set:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用 [示例 47-3](ch47.html#a_semaphore_monitoring_program "示例 47-3. 一个信号量监控程序")
    中的程序来检查信号量集：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When a semaphore set is created, the *sem_otime* field of the associated *semid_ds*
    data structure is initialized to 0\. A calendar time value of 0 corresponds to
    the Epoch ([Calendar Time](ch10.html#calendar_time "Calendar Time")), and *ctime()*
    displays this as 1 AM, 1 January 1970, since the local timezone is Central Europe,
    one hour ahead of UTC.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当信号量集被创建时，相关的 *semid_ds* 数据结构中的 *sem_otime* 字段会被初始化为 0。0 的日历时间值对应于纪元（[日历时间](ch10.html#calendar_time
    "日历时间")），而 *ctime()* 将其显示为 1970 年 1 月 1 日上午 1 点，因为当地时区是中欧时间，比 UTC 快一个小时。
- en: Examining the output further, we can see that, for semaphore 0, the *semncnt*
    value is 1 because operation 1 is waiting to decrease the semaphore value, and
    *semzcnt* is 1 because operation 3 is waiting for this semaphore to equal 0\.
    For semaphore 1, the semncnt value of 2 reflects the fact that operation 1 and
    operation 2 are waiting to decrease the semaphore value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步检查输出，我们可以看到，对于信号量 0，*semncnt* 的值为 1，因为操作 1 正在等待减少信号量的值，*semzcnt* 的值为 1，因为操作
    3 正在等待该信号量的值变为 0。对于信号量 1，*semncnt* 的值为 2，反映了操作 1 和操作 2 正在等待减少信号量的值。
- en: 'Next, we try a nonblocking operation on the semaphore set. This operation waits
    for semaphore 0 to equal 0\. Since this operation can’t be immediately performed,
    *semop()* fails with the error `EAGAIN`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试对信号量集进行非阻塞操作。该操作等待信号量 0 的值为 0。由于此操作无法立即执行，*semop()* 会返回错误 `EAGAIN`：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we add 1 to semaphore 1\. This causes two of the earlier blocked operations
    (1 and 3) to unblock:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将 1 加到信号量 1。这会导致之前被阻塞的两个操作（操作 1 和操作 3）解除阻塞：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we use our monitoring program to inspect the state of the semaphore set,
    we see that the *sem_otime* field of the associated *semid_ds* data structure
    has been updated, and the *sempid* values of both semaphores have been updated.
    We also see that the *semncnt* value for semaphore 1 is 1, since operation 2 is
    still blocked, waiting to decrease the value of this semaphore:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用我们的监控程序检查信号量集的状态时，我们看到相关的 *semid_ds* 数据结构中的 *sem_otime* 字段已被更新，并且两个信号量的
    *sempid* 值也已更新。我们还看到信号量 1 的 *semncnt* 值为 1，因为操作 2 仍然被阻塞，等待减少该信号量的值：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: From the above output, we see that the *sem_otime* value has been updated. We
    also see that semaphore 0 was last operated on by process ID 3661 (operation 3)
    and semaphore 1 was last operated on by process ID 3659 (operation 1).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，我们可以看到 *sem_otime* 的值已经更新。我们还看到信号量 0 最后由进程 ID 3661（操作 3）操作，而信号量 1 最后由进程
    ID 3659（操作 1）操作。
- en: 'Finally, we remove the semaphore set. This causes the still blocked operation
    2 to fail with the error `EIDRM`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们移除信号量集。这会导致仍然被阻塞的操作 2 失败并返回错误 `EIDRM`：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t show the source code for the `svsem/svsem_rm.c` program in this chapter,
    but it is provided in the source code distribution for this book. This program
    removes the semaphore set identified by its command-line argument.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章未展示 `svsem/svsem_rm.c` 程序的源代码，但该程序包含在本书的源代码分发中。该程序移除由命令行参数指定的信号量集。
- en: Handling of Multiple Blocked Semaphore Operations
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多个阻塞的信号量操作
- en: If multiple processes are blocked trying to decrease the value of a semaphore
    by the same amount, then it is indeterminate which process will be permitted to
    perform the operation first when it becomes possible (i.e., which process is able
    to perform the operation will depend on vagaries of the kernel process scheduling
    algorithm).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个进程被阻塞，试图通过相同的量减少信号量的值，那么当条件允许时，哪个进程将被允许首先执行操作是不确定的（即，哪个进程能够执行操作将取决于内核进程调度算法的变化）。
- en: On the other hand, if processes are blocked trying to decrease a semaphore value
    by different amounts, then the requests are served in the order in which they
    become possible. Suppose that a semaphore currently has the value 0, and process
    A requests to decrease the semaphore’s value by 2, and then process B requests
    to decrease the value by 1\. If a third process then adds 1 to the semaphore,
    process B would be the first to unblock and perform its operation, even though
    process A was the first to request an operation against the semaphore. In poorly
    designed applications, such scenarios can lead to *starvation*, whereby a process
    remains blocked forever because the state of the semaphore is never such that
    the requested operation proceeds. Continuing our example, we can envisage scenarios
    where multiple processes adjust the semaphore in such a way that its value is
    never more than 1, with the result that process A remains blocked forever.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果多个进程在试图减少信号量值时，减少的量不同，那么请求会按它们变得可能的顺序进行处理。假设当前信号量值为0，进程A请求将信号量值减少2，接着进程B请求将值减少1。如果第三个进程然后增加1到信号量，那么进程B将是第一个解除阻塞并执行其操作的进程，即便进程A是第一个请求对信号量进行操作的进程。在设计不良的应用程序中，这种情况可能会导致*饥饿*，即某个进程永远被阻塞，因为信号量的状态从未达到能够执行请求的操作。继续我们的示例，我们可以想象出这样的情况：多个进程调整信号量，以至于它的值始终不超过1，导致进程A永远被阻塞。
- en: 'Starvation can also occur if a process is blocked trying to perform operations
    on multiple semaphores. Consider the following scenario, performed on a pair of
    semaphores, both of which initially have the value 0:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程在试图对多个信号量执行操作时被阻塞，也可能发生饥饿现象。考虑以下场景，该场景在一对信号量上执行，这两个信号量最初的值均为0：
- en: Process A makes a request to subtract 1 from semaphores 0 and 1 (*blocks*).
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程A请求从信号量0和1中各减去1（*阻塞*）。
- en: Process B makes a request to subtract 1 from semaphore 0 (*blocks*).
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程B请求从信号量0中减去1（*阻塞*）。
- en: Process C adds 1 to semaphore 0.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程C将1加到信号量0。
- en: At this point, process B unblocks and completes its request, even though it
    placed its request later than process A. Again, it is possible to devise scenarios
    in which process A is starved while other processes adjust and block on the values
    of the individual semaphores.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，进程B解除阻塞并完成其请求，尽管它的请求比进程A晚。再次强调，我们可以设计出进程A被饥饿的场景，而其他进程则在个别信号量的值上进行调整和阻塞。
- en: Semaphore Undo Values
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量撤销值
- en: Suppose that, having adjusted the value of a semaphore (e.g., decreased the
    semaphore value so that it is now 0), a process then terminates, either deliberately
    or accidentally. By default, the semaphore’s value is left unchanged. This may
    constitute a problem for other processes using the semaphore, since they may be
    blocked waiting on that semaphore—that is, waiting for the now-terminated process
    to undo the change it made.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，在调整了信号量的值（例如，将信号量的值减少，使其变为0）后，进程终止，无论是故意的还是意外的。默认情况下，信号量的值保持不变。这可能会对使用该信号量的其他进程造成问题，因为它们可能被阻塞，等待该信号量——即，等待现在已经终止的进程撤销其所做的更改。
- en: To avoid such problems, we can employ the `SEM_UNDO` flag when changing the
    value of a semaphore via *semop()*. When this flag is specified, the kernel records
    the effect of the semaphore operation, and then undoes the operation if the process
    terminates. The undo happens regardless of whether the process terminates normally
    or abnormally.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免此类问题，我们可以在通过*semop()*更改信号量值时使用`SEM_UNDO`标志。当指定该标志时，内核会记录信号量操作的效果，然后在进程终止时撤销该操作。无论进程是正常终止还是异常终止，撤销操作都会发生。
- en: The kernel doesn’t need to keep a record of all operations performed using `SEM_UNDO`.
    It suffices to record the *sum* of all of the semaphore adjustments performed
    using `SEM_UNDO` in a per-semaphore, per-process integer total called the *semadj*
    (semaphore adjustment) value. When the process terminates, all that is necessary
    is to subtract this total from the semaphore’s current value.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 内核不需要记录所有使用`SEM_UNDO`执行的操作。只需记录每个信号量调整的*总和*，即每个信号量、每个进程的整数总和，称为*semadj*（信号量调整）值。当进程终止时，只需要从信号量的当前值中减去这个总和。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since Linux 2.6, processes (threads) created using *clone()* share *semadj*
    values if the `CLONE_SYSVSEM` flag is employed. Such sharing is required for a
    conforming implementation of POSIX threads. The NPTL threading implementation
    employs `CLONE_SYSVSEM` for the implementation of *pthread_create()*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 自Linux 2.6以来，使用*clone()*创建的进程（线程）如果使用了`CLONE_SYSVSEM`标志，则共享*semadj*值。此类共享是符合POSIX线程实现要求的。NPTL线程实现通过`CLONE_SYSVSEM`来实现*pthread_create()*。
- en: When a semaphore value is set using the *semctl()* `SETVAL` or `SETALL` operation,
    the corresponding *semadj* values are cleared (i.e., set to 0) in all processes
    using the semaphore. This makes sense, since absolutely setting the value of a
    semaphore destroys the value associated with the historical record maintained
    in the *semadj* total.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用*semctl()*的`SETVAL`或`SETALL`操作设置信号量值时，所有使用该信号量的进程中相应的*semadj*值都会被清除（即设置为0）。这是有道理的，因为绝对设置信号量的值会破坏与*semadj*总记录相关联的历史记录中的值。
- en: A child created via *fork()* doesn’t inherit its parent’s *semadj* values; it
    doesn’t make sense for a child to undo its parent’s semaphore operations. On the
    other hand, *semadj* values are preserved across an *exec()*. This permits us
    to adjust a semaphore value using `SEM_UNDO`, and then *exec()* a program that
    performs no operation on the semaphore, but does automatically adjust the semaphore
    on process termination. (This can be used as a technique that allows another process
    to discover when this process terminates.)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*fork()*创建的子进程不会继承父进程的*semadj*值；让子进程撤销父进程的信号量操作是没有意义的。另一方面，*semadj*值会在*exec()*之间被保留。这允许我们使用`SEM_UNDO`调整信号量值，然后*exec()*一个不对信号量执行任何操作但会在进程终止时自动调整信号量的程序。（这可以作为一种技术，允许另一个进程发现该进程何时终止。）
- en: Example of the effect of `SEM_UNDO`
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`SEM_UNDO`的效果示例'
- en: 'The following shell session log shows the effect of performing operations on
    two semaphores: one operation with the `SEM_UNDO` flag and one without. We begin
    by creating a set containing two semaphores:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的Shell会话日志显示了对两个信号量执行操作的效果：一个操作带有`SEM_UNDO`标志，另一个则没有。我们首先创建一个包含两个信号量的集合：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we execute a command that adds 1 to both semaphores and then terminates.
    The operation on semaphore 0 specifies the `SEM_UNDO` flag:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行一个命令，该命令向两个信号量都加1，然后终止。信号量0上的操作指定了`SEM_UNDO`标志：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we use the program in [Example 47-3](ch47.html#a_semaphore_monitoring_program
    "Example 47-3. A semaphore monitoring program") to check the state of the semaphores:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用[示例47-3](ch47.html#a_semaphore_monitoring_program "示例47-3. 一个信号量监控程序")中的程序来检查信号量的状态：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Looking at the semaphore values in the last two lines of the above output, we
    can see that the operation on semaphore 0 was undone, but the operation on semaphore
    1 was not undone.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看上述输出最后两行的信号量值，我们可以看到信号量0上的操作被撤销了，但信号量1上的操作没有被撤销。
- en: Limitations of `SEM_UNDO`
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`SEM_UNDO`的限制'
- en: We conclude by noting that the `SEM_UNDO` flag is less useful than it first
    appears, for two reasons. One is that because modifying a semaphore typically
    corresponds to acquiring or releasing some shared resource, the use of `SEM_UNDO`
    on its own may be insufficient to allow a multiprocess application to recover
    in the event that a process unexpectedly terminates. Unless process termination
    also automatically returns the shared resource state to a consistent state (unlikely
    in many scenarios), undoing a semaphore operation is probably insufficient to
    allow the application to recover.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们总结到，`SEM_UNDO`标志比它最初看起来的效果要小，原因有两个。其一是，由于修改信号量通常对应于获取或释放某些共享资源，单独使用`SEM_UNDO`可能不足以让多进程应用在进程意外终止时恢复。除非进程终止时也自动将共享资源的状态恢复到一致状态（在许多场景下不太可能），否则撤销信号量操作可能不足以使应用恢复。
- en: 'The second factor limiting the utility of `SEM_UNDO` is that, in some cases,
    it is not possible to perform semaphore adjustments when a process terminates.
    Consider the following scenario, applied to a semaphore whose initial value is
    0:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 限制`SEM_UNDO`效用的第二个因素是，在某些情况下，当进程终止时，无法执行信号量调整。考虑以下场景，假设信号量的初始值为0：
- en: Process A increases the value of a semaphore by 2, specifying the `SEM_UNDO`
    flag for the operation.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程A将信号量的值加2，指定了`SEM_UNDO`标志。
- en: Process B decreases the value of the semaphore by 1, so that it has the value
    1.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程B将信号量的值减1，使其值变为1。
- en: Process A terminates.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程A终止。
- en: 'At this point, it is impossible to completely undo the effect of process A’s
    operation in step 1, since the value of the semaphore is too low. There are three
    possible ways to resolve this situation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，无法完全撤销步骤1中进程A操作的影响，因为信号量的值太低。有三种可能的解决方案：
- en: Force the process to block until the semaphore adjustment is possible.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制进程阻塞，直到信号量调整变得可能。
- en: Decrease the semaphore value as far as possible (i.e., to 0) and exit.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能减小信号量的值（即，降至0）并退出。
- en: Exit without performing any semaphore adjustment.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不进行任何信号量调整的情况下退出。
- en: The first solution is infeasible since it might force a terminating process
    to block forever. Linux adopts the second solution. Some other UNIX implementations
    adopt the third solution. SUSv3 is silent on what an implementation should do
    in this situation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案是不可行的，因为它可能会强制一个终止的进程永久阻塞。Linux采用了第二个解决方案，其他一些UNIX实现采用了第三个解决方案。SUSv3没有说明在这种情况下实现应该如何操作。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An undo operation that attempts to raise a semaphore’s value above its permitted
    maximum value of 32,767 (the `SEMVMX` limit, described [Semaphore Limits](ch47.html#semaphore_limits
    "Semaphore Limits")) also causes anomalous behavior. In this case, the kernel
    always performs the adjustment, thus (illegitimately) raising the semaphore’s
    value above `SEMVMX`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一种撤销操作，如果尝试将信号量的值提高到其允许的最大值 32,767 以上（即`SEMVMX`限制，详见[信号量限制](ch47.html#semaphore_limits
    "信号量限制")），也会导致异常行为。在这种情况下，内核总是会执行调整，从而（不合法地）将信号量的值提高到超过`SEMVMX`。
- en: Implementing a Binary Semaphores Protocol
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现二进制信号量协议
- en: The API for System V semaphores is complex, both because semaphore values can
    be adjusted by arbitrary amounts, and because semaphores are allocated and operated
    upon in sets. Both of these features provide more functionality than is typically
    needed within applications, and so it is useful to implement some simpler protocols
    (APIs) on top of System V semaphores.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: System V信号量的API非常复杂，既因为信号量的值可以调整任意数量，又因为信号量是以集合的形式分配和操作的。这两个特性提供了比应用程序通常需要的更多功能，因此在System
    V信号量之上实现一些更简单的协议（API）是有用的。
- en: 'One commonly used protocol is binary semaphores. A binary semaphore has two
    values: *available* (free) and *reserved* (in use). Two operations are defined
    for binary semaphores:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常用的协议是二进制信号量。二进制信号量有两个值：*可用*（空闲）和*已保留*（正在使用）。为二进制信号量定义了两种操作：
- en: '*Reserve*: Attempt to reserve this semaphore for exclusive use. If the semaphore
    is already reserved by another process, then block until the semaphore is released.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保留*：尝试保留此信号量以供独占使用。如果信号量已被另一个进程保留，则阻塞直到信号量被释放。'
- en: '*Release*: Free a currently reserved semaphore, so that it can be reserved
    by another process.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放*：释放当前已保留的信号量，以便其他进程可以保留它。'
- en: Note
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In academic computer science, these two operations often go by the names *P*
    and *V*, the first letters of the Dutch terms for these operations. This nomenclature
    was coined by the late Dutch computer scientist Edsger Dijkstra, who produced
    much of the early theoretical work on semaphores. The terms *down* (decrement
    the semaphore) and *up* (increment the semaphore) are also used. POSIX terms the
    two operations *wait* and *post*.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在学术计算机科学中，这两种操作通常以*P*和*V*命名，这是这些操作的荷兰语术语的首字母。这个命名法是已故荷兰计算机科学家Edsger Dijkstra提出的，他进行了大量关于信号量的早期理论研究。也使用*down*（减少信号量）和*up*（增加信号量）这两个术语。POSIX将这两个操作称为*wait*和*post*。
- en: 'A third operation is also sometimes defined:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有时还定义了第三种操作：
- en: '*Reserve conditionally*: Make a nonblocking attempt to reserve this semaphore
    for exclusive use. If the semaphore is already reserved, then immediately return
    a status indicating that the semaphore is unavailable.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*条件保留*：尝试非阻塞地保留此信号量以供独占使用。如果信号量已经被保留，则立即返回表示信号量不可用的状态。'
- en: In implementing binary semaphores, we must choose how to represent the *available*
    and *reserved* states, and how to implement the above operations. A moment’s reflection
    leads us to realize that the best way to represent the states is to use the value
    1 for *free* and the value 0 for *reserved*, with the *reserve* and *release*
    operations decrementing and incrementing the semaphore value by one.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现二进制信号量时，我们必须选择如何表示*可用*和*已保留*状态，以及如何实现上述操作。稍作反思，我们意识到表示这些状态的最佳方式是使用值1表示*空闲*，使用值0表示*已保留*，并且*保留*和*释放*操作分别使信号量的值递减和递增1。
- en: '[Example 47-9](ch47.html#header_file_for_binary_underscore_sems.c "Example 47-9. Header
    file for binary_sems.c") and [Example 47-10](ch47.html#implementing_binary_semaphores_using_sys
    "Example 47-10. Implementing binary semaphores using System V semaphores") provide
    an implementation of binary semaphores using System V semaphores. As well as providing
    the prototypes of the functions in the implementation, the header file in [Example 47-9](ch47.html#header_file_for_binary_underscore_sems.c
    "Example 47-9. Header file for binary_sems.c") declares two global Boolean variables
    exposed by the implementation. The *bsUseSemUndo* variable controls whether the
    implementation uses the `SEM_UNDO` flag in *semop()* calls. The *bsRetryOnEintr*
    variable controls whether the implementation restarts *semop()* calls that are
    interrupted by signals.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 47-9](ch47.html#header_file_for_binary_underscore_sems.c "示例 47-9. binary_sems.c
    的头文件") 和 [示例 47-10](ch47.html#implementing_binary_semaphores_using_sys "示例 47-10.
    使用 System V 信号量实现二进制信号量") 提供了使用 System V 信号量实现二进制信号量的示例。除了提供实现中的函数原型外，[示例 47-9](ch47.html#header_file_for_binary_underscore_sems.c
    "示例 47-9. binary_sems.c 的头文件") 中的头文件还声明了两个由实现暴露的全局布尔变量。*bsUseSemUndo* 变量控制实现是否在
    *semop()* 调用中使用 `SEM_UNDO` 标志。*bsRetryOnEintr* 变量控制实现是否在信号中断时重新启动 *semop()* 调用。'
- en: Example 47-9. Header file for `binary_sems.c`
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 47-9. `binary_sems.c` 的头文件
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Example 47-10](ch47.html#implementing_binary_semaphores_using_sys "Example 47-10. Implementing
    binary semaphores using System V semaphores") shows the implementation of the
    binary semaphore functions. Each function in this implementation takes two arguments,
    which identify a semaphore set and the number of a semaphore within that set.
    (These functions don’t deal with the creation and deletion of semaphore sets;
    nor do they handle the race condition described in Section 47.5.) We employ these
    functions in the example programs shown in Section 48.4.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 47-10](ch47.html#implementing_binary_semaphores_using_sys "示例 47-10. 使用
    System V 信号量实现二进制信号量") 显示了二进制信号量函数的实现。此实现中的每个函数都接受两个参数，用于标识一个信号量集以及该集中的一个信号量编号。（这些函数不处理信号量集的创建和删除，也不处理第
    47.5 节中描述的竞态条件。）我们在第 48.4 节中展示的示例程序中使用了这些函数。'
- en: Example 47-10. Implementing binary semaphores using System V semaphores
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 47-10. 使用 System V 信号量实现二进制信号量
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Semaphore Limits
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量限制
- en: Most UNIX implementations impose various limits on the operation of System V
    semaphores. The following is a list of the Linux semaphore limits. The system
    call affected by the limit and the error that results if the limit is reached
    are noted in parentheses.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 UNIX 实现对 System V 信号量的操作施加了各种限制。以下是 Linux 信号量的限制。受限制的系统调用及其达到限制时导致的错误在括号中注明。
- en: '`SEMAEM`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEMAEM`'
- en: This is the maximum value that can be recorded in a *semadj* total. `SEMAEM`
    is defined to have the same value as `SEMVMX` (described below). (*semop()*, `ERANGE`)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以记录在 *semadj* 总数中的最大值。`SEMAEM` 被定义为与 `SEMVMX`（如下所述）具有相同的值。 (*semop()*, `ERANGE`)
- en: '`SEMMNI`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEMMNI`'
- en: This is a system-wide limit on the number of semaphore identifiers (in other
    words, semaphore sets) that can be created. (*semget()*, `ENOSPC`)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是系统范围内对可创建的信号量标识符数量（换句话说，信号量集）的限制。 (*semget()*, `ENOSPC`)
- en: '`SEMMSL`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEMMSL`'
- en: This is the maximum number of semaphores that can be allocated in a semaphore
    set. (*semget()*, `EINVAL`)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是信号量集内可分配的信号量的最大数量。 (*semget()*, `EINVAL`)
- en: '`SEMMNS`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEMMNS`'
- en: This is a system-wide limit on the number of semaphores in all semaphore sets.
    The number of semaphores on the system is also limited by `SEMMNI` and `SEMMSL`;
    in fact, the default value for `SEMMNS` is the product of the defaults for these
    two limits. (*semget()*, `ENOSPC`)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是系统范围内对所有信号量集中的信号量数量的限制。系统中信号量的数量也受到 `SEMMNI` 和 `SEMMSL` 的限制；事实上，`SEMMNS` 的默认值是这两个限制默认值的乘积。
    (*semget()*, `ENOSPC`)
- en: '`SEMOPM`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEMOPM`'
- en: This is the maximum number of operations per *semop()* call. (*semop()*, `E2BIG`)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每次 *semop()* 调用的最大操作次数。 (*semop()*, `E2BIG`)
- en: '`SEMVMX`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEMVMX`'
- en: This is the maximum value for a semaphore. (*semop()*, `ERANGE`)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是信号量的最大值。 (*semop()*, `ERANGE`)
- en: 'The limits above appear on most UNIX implementations. Some UNIX implementations
    (but not Linux) impose the following additional limits relating to semaphore undo
    operations ([Semaphore Undo Values](ch47.html#semaphore_undo_values "Semaphore
    Undo Values")):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上述限制出现在大多数 UNIX 实现中。一些 UNIX 实现（但不是 Linux）施加了以下与信号量撤销操作相关的附加限制（[信号量撤销值](ch47.html#semaphore_undo_values
    "信号量撤销值")）：
- en: '`SEMMNU`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEMMNU`'
- en: This is a system-wide limit on the total number of semaphore undo structures.
    Undo structures are allocated to store *semadj* values.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是系统范围内的信号量撤销结构总数的限制。撤销结构用于存储*semadj*值。
- en: '`SEMUME`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEMUME`'
- en: This is the maximum number of undo entries per semaphore undo structure.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个信号量撤销结构的最大撤销条目数。
- en: 'At system startup, the semaphore limits are set to default values. These defaults
    may vary across kernel versions. (Some distributors’ kernels set different defaults
    from those provided by vanilla kernels.) Some of these limits can be modified
    by changing the values stored in the Linux-specific `/proc/sys/kernel/sem` file.
    This file contains four space-delimited numbers defining, in order, the limits
    `SEMMSL`, `SEMMNS`, `SEMOPM`, and `SEMMNI`. (The `SEMVMX` and `SEMAEM` limits
    can’t be changed; both are fixed at 32,767.) As an example, here are the default
    limits that we see for Linux 2.6.31 on one x86-32 system:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统启动时，信号量的限制会被设置为默认值。这些默认值可能因内核版本不同而有所变化。（一些发行版的内核设置的默认值与原生内核提供的不同。）这些限制中的一些可以通过修改存储在
    Linux 特有的`/proc/sys/kernel/sem`文件中的值来进行修改。该文件包含四个由空格分隔的数字，按顺序定义`SEMMSL`、`SEMMNS`、`SEMOPM`
    和 `SEMMNI` 的限制。（`SEMVMX` 和 `SEMAEM` 限制无法更改；它们的值固定为 32,767。）例如，以下是我们在一台 x86-32
    系统上看到的 Linux 2.6.31 的默认限制：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The formats employed in the Linux `/proc` file system are inconsistent for the
    three System V IPC mechanisms. For message queues and shared memory, each configurable
    limit is controlled by a separate file. For semaphores, one file holds all configurable
    limits. This is a historical accident that occurred during the development of
    these APIs and is difficult to rectify for compatibility reasons.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux `/proc` 文件系统中，三个 System V IPC 机制所采用的格式不一致。对于消息队列和共享内存，每个可配置的限制由一个单独的文件控制。对于信号量，所有可配置的限制存储在一个文件中。这是开发这些
    API 过程中发生的历史性事故，出于兼容性原因很难纠正。
- en: '[Table 47-1](ch47.html#system_v_semaphore_limits "Table 47-1. System V semaphore
    limits") shows the maximum value to which each limit can be raised on the x86-32
    architecture. Note the following supplementary information to this table:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 47-1](ch47.html#system_v_semaphore_limits "表 47-1. System V 信号量限制")展示了在
    x86-32 架构上每个限制可以提升到的最大值。请注意以下对该表的补充说明：'
- en: It is possible to raise `SEMMSL` to values larger than 65,536, and create semaphore
    sets up to that larger size. However, it isn’t possible to use *semop()* to adjust
    semaphores in the set beyond the 65,536th element.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将`SEMMSL`提升到大于 65,536 的值，并创建更大规模的信号量集。但是，无法使用*semop()*调整集中的信号量，超出第 65,536
    个元素。
- en: Note
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because of certain limitations in the current implementation, the practical
    recommended upper limit on the size of a semaphore set is around 8000.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于当前实现的某些限制，建议的信号量集大小的实际上限约为 8000。
- en: The practical ceiling for the `SEMMNS` limit is governed by the amount of RAM
    available on the system.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEMMNS`限制的实际上限由系统中可用的 RAM 大小决定。'
- en: The ceiling value for the `SEMOPM` limit is determined by memory allocation
    primitives used within the kernel. The recommended maximum is 1000\. In practical
    usage, it is rarely useful to perform more than a few operations in a single *semop()*
    call.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEMOPM`限制的上限值由内核中使用的内存分配原语决定。推荐的最大值为 1000。在实际使用中，很少需要在单个*semop()*调用中执行超过几次操作。'
- en: Table 47-1. System V semaphore limits
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 表 47-1. System V 信号量限制
- en: '| Limit | Ceiling value (x86-32) |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 限制 | 上限值（x86-32） |'
- en: '| --- | --- |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SEMMNI` | `32768 (IPCMNI)` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `SEMMNI` | `32768 (IPCMNI)` |'
- en: '| `SEMMSL` | `65536` |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `SEMMSL` | `65536` |'
- en: '| `SEMMNS` | `2147483647 (INT_MAX)` |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `SEMMNS` | `2147483647 (INT_MAX)` |'
- en: '| `SEMOPM` | See text |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `SEMOPM` | 见正文 |'
- en: 'The Linux-specific *semctl()* `IPC_INFO` operation retrieves a structure of
    type *seminfo*, which contains the values of the various semaphore limits:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 特有的*semctl()* `IPC_INFO`操作检索一个*seminfo*类型的结构，其中包含各种信号量限制的值：
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A related Linux-specific operation, `SEM_INFO`, retrieves a *seminfo* structure
    that contains information about actual resources used for semaphore objects. An
    example of the use of `SEM_INFO` is provided in the file `svsem/svsem_info.c`
    in the source code distribution for this book.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与 Linux 特定的操作，`SEM_INFO`，检索一个包含有关实际用于信号量对象的资源信息的*seminfo*结构。`SEM_INFO`的使用示例可以在本书的源代码分发中的文件`svsem/svsem_info.c`中找到。
- en: Details about `IPC_INFO`, `SEM_INFO`, and the *seminfo* structure can be found
    in the *semctl(2)* manual page.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`IPC_INFO`、`SEM_INFO`和*seminfo*结构的详细信息可以在*semctl(2)*手册页中找到。
- en: Disadvantages of System V Semaphores
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: System V 信号量的缺点
- en: 'System V semaphores have many of the same disadvantages as message queues ([Disadvantages
    of System V Message Queues](ch46.html#disadvantages_of_system_v_message_queues
    "Disadvantages of System V Message Queues")), including the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: System V信号量具有与消息队列相同的许多缺点（[System V消息队列的缺点](ch46.html#disadvantages_of_system_v_message_queues
    "System V消息队列的缺点")），包括以下几点：
- en: Semaphores are referred to by identifiers, rather than the file descriptors
    used by most other UNIX I/O and IPC mechanisms. This makes it difficult to perform
    operations such as simultaneously waiting both on a semaphore and on input from
    a file descriptor. (It is possible to resolve this difficulty by creating a child
    process or thread that operates on the semaphore and writes messages to a pipe
    monitored, along with other file descriptors, using one of the methods described
    in [Chapter 63](ch63.html "Chapter 63. Alternative I/O Models").)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号量是通过标识符来引用的，而不是像大多数其他UNIX I/O和IPC机制那样使用文件描述符。这使得执行诸如同时等待信号量和等待文件描述符输入等操作变得困难。（通过创建一个子进程或线程来操作信号量，并将消息写入一个由管道监控的文件描述符集合，可以解决这个问题，具体方法可参考[第63章](ch63.html
    "第63章. 替代I/O模型")。）
- en: The use of keys, rather than filenames, to identify semaphores results in additional
    programming complexity.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键而不是文件名来标识信号量，会导致额外的编程复杂性。
- en: The use of separate system calls for creating and initializing semaphores means
    that, in some cases, we must do extra programming work to avoid race conditions
    when initializing a semaphore.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单独的系统调用来创建和初始化信号量意味着，在某些情况下，我们必须做额外的编程工作，以避免在初始化信号量时发生竞争条件。
- en: The kernel doesn’t maintain a count of the number of processes referring to
    a semaphore set. This complicates the decision about when it is appropriate to
    delete a semaphore set and makes it difficult to ensure that an unused set is
    deleted.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核不会维护引用信号量集的进程数量。这使得确定何时删除信号量集变得复杂，并且难以确保未使用的信号量集被删除。
- en: The programming interface provided by System V is overly complex. In the common
    case, a program operates on a single semaphore. The ability to simultaneously
    operate on multiple semaphores in a set is unnecessary.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: System V提供的编程接口过于复杂。在常见情况下，一个程序只操作一个信号量。能够同时操作信号量集中的多个信号量是不必要的。
- en: There are various limits on the operation of semaphores. These limits are configurable,
    but if an application operates outside the range of the default limits, this nevertheless
    requires extra work when installing the application.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对信号量操作有各种限制。这些限制是可配置的，但如果应用程序的操作超出了默认限制范围，仍然需要在安装应用程序时额外处理。
- en: However, unlike the situation with message queues, there are fewer alternatives
    to System V semaphores, and consequently there are more situations in which we
    may choose to employ them. One alternative to the use of semaphores is record
    locking, which we describe in [Chapter 55](ch55.html "Chapter 55. File Locking").
    Also, from kernel 2.6 onward, Linux supports the use of POSIX semaphores for process
    synchronization. We describe POSIX semaphores in [Chapter 53](ch53.html "Chapter 53. POSIX
    Semaphores").
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与消息队列的情况不同，System V信号量的替代方案较少，因此在更多情况下我们可能选择使用它们。信号量的一种替代方案是记录锁定，我们在[第55章](ch55.html
    "第55章. 文件锁定")中对此进行了描述。此外，从内核2.6开始，Linux支持使用POSIX信号量进行进程同步。我们在[第53章](ch53.html
    "第53章. POSIX信号量")中描述了POSIX信号量。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: System V semaphores allow processes to synchronize their actions. This is useful
    when a process must gain exclusive access to some shared resource, such as a region
    of shared memory.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: System V信号量允许进程同步其操作。这在进程必须获得对某些共享资源的独占访问时非常有用，例如共享内存区域。
- en: Semaphores are created and operated upon in sets containing one or more semaphores.
    Each semaphore within a set is an integer whose value is always greater than or
    equal to 0\. The *semop()* system call allows the caller to add an integer to
    a semaphore, subtract an integer from a semaphore, or wait for a semaphore to
    equal 0\. The last two of these operations may cause the caller to block.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是以包含一个或多个信号量的集合形式创建和操作的。集合中的每个信号量都是一个整数，其值始终大于或等于0。*semop()*系统调用允许调用者向信号量添加整数、从信号量中减去整数或等待信号量等于0。这两种操作可能导致调用者阻塞。
- en: A semaphore implementation is not required to initialize the members of a new
    semaphore set, so an application must initialize the set after creating it. When
    any of a number of peer processes may try to create and initialize the semaphore,
    special care must be taken to avoid the race condition that results from the fact
    that these two steps are performed via separate system calls.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量实现不要求初始化新信号量集的成员，因此应用程序在创建信号量集后必须进行初始化。当多个同行进程可能尝试创建并初始化信号量时，必须特别小心，避免因这两步操作是通过不同的系统调用执行而导致的竞态条件。
- en: Where multiple processes are trying to decrease a semaphore by the same amount,
    it is indeterminate which process will actually be permitted to perform the operation
    first. However, where different processes are trying to decrease a semaphore by
    different amounts, the operations complete in the order in which they become possible,
    and we may need to take care to avoid scenarios where a process is starved because
    the semaphore value never reaches a level that would allow the process’s operation
    to proceed.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个进程尝试以相同的数量减少一个信号量时，无法确定哪个进程将首先被允许执行该操作。然而，当不同的进程尝试以不同的数量减少信号量时，操作按它们变得可能的顺序完成，我们可能需要小心避免某个进程因为信号量的值永远未达到可以让该进程的操作执行的水平而被饿死。
- en: The `SEM_UNDO` flag allows a process’s semaphore operations to be automatically
    undone on process termination. This can be useful to avoid scenarios where a process
    accidentally terminates, leaving a semaphore in a state that causes other processes
    to block indefinitely waiting for the semaphore’s value to be changed by the terminated
    process.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEM_UNDO`标志允许进程的信号量操作在进程终止时自动撤销。这在避免进程意外终止时非常有用，因为进程终止后信号量可能处于一种状态，导致其他进程无限期阻塞，等待该进程改变信号量的值。'
- en: System V semaphores are allocated and operated upon in sets, and can be increased
    and decreased by arbitrary amounts. This provides more functionality than is needed
    by most applications. A common requirement is for individual binary semaphores,
    which take on only the values 0 and 1\. We showed how to implement binary semaphores
    on top of System V semaphores.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: System V 信号量是按集合分配和操作的，可以增加或减少任意数量。这提供了比大多数应用所需的更多功能。一个常见的需求是单个二进制信号量，它只取 0
    和 1 两个值。我们展示了如何在 System V 信号量的基础上实现二进制信号量。
- en: Further information
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: '[Bovet & Cesati, 2005] and [Maxwell, 1999] provide some background on the implementation
    of semaphores on Linux. [Dijkstra, 1968] is a classic early paper on semaphore
    theory.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[Bovet & Cesati, 2005] 和 [Maxwell, 1999] 提供了关于 Linux 上信号量实现的一些背景资料。[Dijkstra,
    1968] 是一篇关于信号量理论的经典早期论文。'
- en: Exercises
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Experiment with the program in [Example 47-8](ch47.html#performing_system_v_semaphore_operations
    "Example 47-8. Performing System V semaphore operations with semop()") (`svsem_op.c`)
    to confirm your understanding of the *semop()* system call.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过[示例 47-8](ch47.html#performing_system_v_semaphore_operations "Example 47-8.
    Performing System V semaphore operations with semop()")（`svsem_op.c`）实验，确认你对*semop()*系统调用的理解。
- en: Modify the program in [Example 24-6](ch24.html#using_signals_to_synchronize_process_act
    "Example 24-6. Using signals to synchronize process actions") (`fork_sig_sync.c`,
    in [Avoiding Race Conditions by Synchronizing with Signals](ch24.html#avoiding_race_conditions_by_synchronizin
    "Avoiding Race Conditions by Synchronizing with Signals")) to use semaphores instead
    of signals to synchronize the parent and child processes.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例 24-6](ch24.html#using_signals_to_synchronize_process_act "Example 24-6.
    Using signals to synchronize process actions")（`fork_sig_sync.c`，参见[通过信号同步避免竞态条件](ch24.html#avoiding_race_conditions_by_synchronizin
    "Avoiding Race Conditions by Synchronizing with Signals")）中的程序，使用信号量替代信号来同步父子进程。
- en: Experiment with the program in [Example 47-8](ch47.html#performing_system_v_semaphore_operations
    "Example 47-8. Performing System V semaphore operations with semop()") (`svsem_op.c`)
    and the other semaphore programs provided in this chapter to see what happens
    to the *sempid* value if an exiting process performs a `SEM_UNDO` adjustment to
    a semaphore.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过[示例 47-8](ch47.html#performing_system_v_semaphore_operations "Example 47-8.
    Performing System V semaphore operations with semop()")（`svsem_op.c`）和本章提供的其他信号量程序进行实验，查看如果一个退出的进程对信号量执行`SEM_UNDO`调整时，*sempid*值会发生什么变化。
- en: Add a *reserveSemNB()* function to the code in [Example 47-10](ch47.html#implementing_binary_semaphores_using_sys
    "Example 47-10. Implementing binary semaphores using System V semaphores") (`binary_sems.c`)
    to implement the *reserve conditionally* operation, using the `IPC_NOWAIT` flag.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中添加一个 *reserveSemNB()* 函数，参考[示例 47-10](ch47.html#implementing_binary_semaphores_using_sys
    "示例 47-10. 使用 System V 信号量实现二进制信号量")（`binary_sems.c`），实现 *有条件预留* 操作，使用 `IPC_NOWAIT`
    标志。
- en: 'For the VMS operating system, Digital provided a synchronization method similar
    to a binary semaphore, called an *event flag*. An event flag has two possible
    values, *clear* and *set*, and the following four operations can be performed:
    *setEventFlag*, to set the flag; *clearEventFlag*, to clear the flag; *waitForEventFlag*,
    to block until the flag is set; and *getFlagState*, to obtain the current state
    of the flag. Devise an implementation of event flags using System V semaphores.
    This implementation will require two arguments for each of the functions above:
    a semaphore identifier and a semaphore number. (Consideration of the *waitForEventFlag*
    operation will lead you to realize that the values chosen for *clear* and *set*
    are not the obvious choices.)'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 VMS 操作系统，数字公司提供了一种类似于二进制信号量的同步方法，称为*事件标志*。事件标志有两个可能的值，*清除*和*设置*，并且可以执行以下四个操作：*setEventFlag*，设置标志；*clearEventFlag*，清除标志；*waitForEventFlag*，阻塞直到标志被设置；*getFlagState*，获取标志的当前状态。设计一个使用
    System V 信号量实现事件标志的方法。此实现将需要上述每个函数的两个参数：一个信号量标识符和一个信号量编号。（考虑到 *waitForEventFlag*
    操作，你会意识到为 *清除* 和 *设置* 选择的值并非显而易见的选择。）
- en: Implement a binary semaphores protocol using named pipes. Provide functions
    to reserve, release, and conditionally reserve the semaphore.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命名管道实现二进制信号量协议。提供函数来预留、释放以及有条件预留信号量。
- en: Write a program, analogous to the program in [Example 46-6](ch46.html#displaying_all_system_v_message_queues_o
    "Example 46-6. Displaying all System V message queues on the system") (`svmsg_ls.c`,
    in [Client-Server Programming with Message Queues](ch46.html#client-server_programming_with_message_q
    "Client-Server Programming with Message Queues")), that uses the *semctl()* `SEM_INFO`
    and `SEM_STAT` operations to obtain and display a list of all semaphore sets on
    the system.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，类似于[示例 46-6](ch46.html#displaying_all_system_v_message_queues_o "示例 46-6.
    显示系统上所有 System V 消息队列")（`svmsg_ls.c`，参见[使用消息队列的客户端-服务器编程](ch46.html#client-server_programming_with_message_q
    "使用消息队列的客户端-服务器编程")），使用 *semctl()* `SEM_INFO` 和 `SEM_STAT` 操作来获取并显示系统上所有信号量集的列表。
