- en: '3'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: FUZZING SOAP ENDPOINTS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试 SOAP 端点
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: As a penetration tester, you may run into applications or servers that offer
    programmatic API access via SOAP endpoints. SOAP, or Simple Object Access Protocol,
    is a common enterprise technology that enables language-agnostic access to programming
    APIs. Generally speaking, SOAP is used over the HTTP protocol, and it uses XML
    to organize the data sent to and from the SOAP server. The Web Service Description
    Language (WSDL) describes the methods and functionality exposed through SOAP endpoints.
    By default, SOAP endpoints expose WSDL XML documents that clients can easily parse
    so that they can interface with the SOAP endpoints, and C# has several classes
    that make this possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试员，你可能会遇到提供程序化 API 访问的应用程序或服务器，这些 API 通过 SOAP 端点提供。SOAP（简单对象访问协议）是一种常见的企业技术，允许以语言无关的方式访问编程
    API。一般来说，SOAP 是通过 HTTP 协议使用的，并且它使用 XML 来组织发送到 SOAP 服务器的数据。Web 服务描述语言（WSDL）描述了通过
    SOAP 端点公开的方法和功能。默认情况下，SOAP 端点公开 WSDL XML 文档，客户端可以轻松解析这些文档，以便与 SOAP 端点进行交互，C# 有多个类使得这成为可能。
- en: This chapter builds on your knowledge of how to programmatically craft HTTP
    requests to detect XSS and SQL injection vulnerabilities, except that it focuses
    on SOAP XML instead. This chapter also shows you how to write a small fuzzer to
    download and parse the WSDL file exposed by a SOAP endpoint and then use the information
    in the WSDL file to generate HTTP requests for the SOAP service. Ultimately, you’ll
    be able to systematically and automatically look for possible SQL injection vulnerabilities
    in SOAP methods.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章建立在你如何通过编程方式构造 HTTP 请求来检测 XSS 和 SQL 注入漏洞的基础知识之上，只不过这次我们关注的是 SOAP XML。此章还会展示如何编写一个小型模糊测试器来下载和解析
    SOAP 端点公开的 WSDL 文件，然后使用 WSDL 文件中的信息生成 SOAP 服务的 HTTP 请求。最终，你将能够系统化并自动化地查找 SOAP
    方法中的 SQL 注入漏洞。
- en: Setting Up the Vulnerable Endpoint
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 设置脆弱的端点
- en: For this chapter, you’ll use a vulnerable endpoint in a preconfigured virtual
    appliance called CsharpVulnSoap (which should have a file extension of .ova) available
    on the VulnHub website ([http://www.vulnhub.com/](http://www.vulnhub.com/)). After
    downloading the appliance, you can import it into VirtualBox or VMware on most
    operating systems by double-clicking the file. Once the appliance is installed,
    log in with a password of password or use a Guest session to open a terminal.
    From there, enter ifconfig to find the virtual appliance’s IP address. By default,
    this appliance will be listening on a host-only interface, unlike in previous
    chapters where we bridged the network interfaces.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将使用一个名为 CsharpVulnSoap 的预配置虚拟设备中的脆弱端点（该文件应具有 .ova 扩展名），该设备可在 VulnHub 网站上找到（[http://www.vulnhub.com/](http://www.vulnhub.com/)）。下载虚拟设备后，你可以通过双击文件将其导入到
    VirtualBox 或 VMware 中，支持大多数操作系统。一旦安装完成，使用密码 password 登录，或者使用访客会话打开终端。接着，输入 ifconfig
    查找虚拟设备的 IP 地址。默认情况下，该设备将通过仅主机接口进行监听，而与之前章节中的网络接口桥接不同。
- en: After bringing the endpoint up in a web browser, as shown in [Figure 3-1](#filepos246543),
    you can use the menu items on the left side of the screen (AddUser, ListUsers,
    GetUser, and DeleteUser) to see what the functions exposed by the SOAP endpoint
    return when used. Navigating to http://<ip>/Vulnerable.asmx?WSDL should present
    you with the WSDL document describing the available functions in a parseable XML
    file. Let’s dig into the structure of this document.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器中打开端点，如[图 3-1](#filepos246543)所示，你可以使用屏幕左侧的菜单项（AddUser、ListUsers、GetUser
    和 DeleteUser）查看 SOAP 端点公开的功能在使用时的返回结果。导航到 http://<ip>/Vulnerable.asmx?WSDL 应该会展示一个
    WSDL 文档，该文档描述了可以解析的 XML 文件中的可用函数。让我们深入研究该文档的结构。
- en: '![](images/00030.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00030.jpg)'
- en: 'Figure 3-1: The vulnerable endpoint as seen from Firefox'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：从 Firefox 查看脆弱的端点
- en: Parsing the WSDL
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 WSDL
- en: WSDL XML documents are a bit complicated. Even a simple WSDL document like the
    one we’ll parse is not trivial. However, because C# has excellent classes for
    parsing and consuming XML files, getting the WSDL parsed correctly and into a
    state that lets us interact with the SOAP services in an object-oriented fashion
    is pretty bearable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WSDL XML 文档有点复杂。即使是我们要解析的简单 WSDL 文档也并不简单。然而，由于 C# 提供了出色的类来解析和使用 XML 文件，正确解析
    WSDL 并使其处于一个可以面向对象地与 SOAP 服务交互的状态是相当容易的。
- en: A WSDL document is essentially a bunch of XML elements that relate to one another
    in a logical way, from the bottom of the document to the top. At the bottom of
    the document, you interact with the service to make a request to the endpoint.
    From the service, you have the notion of ports. These ports point to a binding,
    which in turn points to a port type. The port type contains the operations (or
    methods) available on that endpoint. The operations contain an input and an output,
    which both point to a message. The message points to a type, and the type contains
    the parameters required to call the method. [Figure 3-2](#filepos248062) explains
    this concept visually.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 WSDL 文档本质上是一些 XML 元素，这些元素彼此之间以逻辑方式相关，从文档底部到顶部。文档底部，你与服务交互，向端点发出请求。从服务开始，你有了端口的概念。这些端口指向绑定，而绑定又指向端口类型。端口类型包含该端点上可用的操作（或方法）。操作包含输入和输出，二者都指向一个消息。消息指向一个类型，而该类型包含调用方法所需的参数。[图
    3-2](#filepos248062) 直观地解释了这一概念。
- en: '![](images/00011.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00011.jpg)'
- en: 'Figure 3-2: The basic logical layout of a WSDL document'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3-2: WSDL 文档的基本逻辑布局'
- en: Our WSDL class constructor will work in reverse order. First, we’ll create the
    constructor, and then we’ll create a class to handle parsing each part of the
    WSDL document, from types to services.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 WSDL 类构造函数将按相反顺序工作。首先，我们创建构造函数，然后我们将创建一个类来处理 WSDL 文档每个部分的解析，从类型到服务。
- en: Creating a Class for the WSDL Document
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为 WSDL 文档创建一个类
- en: When you’re parsing WSDL programmatically, it’s easiest to start at the top
    of the document with the SOAP types and work your way down the document. Let’s
    create a class called WSDL that encompasses the WSDL document. The constructor
    is relatively simple, as shown in [Listing 3-1](#filepos249737).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过编程解析 WSDL 时，最简单的方法是从文档的顶部开始，处理 SOAP 类型，然后逐步向下解析文档。让我们创建一个名为 WSDL 的类，它包含
    WSDL 文档。构造函数相对简单，如[清单 3-1](#filepos249737)所示。
- en: public WSDL (XmlDocument doc)
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public WSDL (XmlDocument doc)
- en: '{'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: XmlNamespaceManager nsManager = new ➊XmlNamespaceManager(doc.NameTable);
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XmlNamespaceManager nsManager = new ➊XmlNamespaceManager(doc.NameTable);
- en: nsManager.➋AddNamespace("wsdl", doc.DocumentElement.NamespaceURI);
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: nsManager.➋AddNamespace("wsdl", doc.DocumentElement.NamespaceURI);
- en: nsManager.AddNamespace("xs", "http://www.w3.org/2001/XMLSchema");
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: nsManager.AddNamespace("xs", "http://www.w3.org/2001/XMLSchema");
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ParseTypes(doc, nsManager);
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ParseTypes(doc, nsManager);
- en: ParseMessages(doc, nsManager);
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ParseMessages(doc, nsManager);
- en: ParsePortTypes(doc, nsManager);
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ParsePortTypes(doc, nsManager);
- en: ParseBindings(doc, nsManager);
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ParseBindings(doc, nsManager);
- en: ParseServices(doc, nsManager);
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ParseServices(doc, nsManager);
- en: '}'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-1: The  WSDL  class constructor'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-1: WSDL 类构造函数'
- en: 'The constructor of our WSDL class calls just a handful of methods (which we’ll
    write next), and it expects the retrieved XML document that contains all the definitions
    of the web service as a parameter. The first thing we need to do is define the
    XML namespaces we’ll be referencing while using XPath queries (which are covered
    in [Listing 3-3](#filepos253495) and later listings) when we implement the parsing
    methods. To do this, we create a new XmlNamespaceManager ➊ and use the AddNamespace()
    method ➋ to add two namespaces, wsdl and xs. Then we call the methods that will
    parse the elements of the WSDL document, starting with types and working our way
    down to services. Each method takes two arguments: the WSDL document and the namespace
    manager.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 WSDL 类的构造函数只调用了少数几个方法（我们稍后会编写），并且它期望获取包含所有 Web 服务定义的 XML 文档作为参数。我们需要做的第一件事是定义在实现解析方法时使用
    XPath 查询时所引用的 XML 命名空间（这些内容在[清单 3-3](#filepos253495)及后续清单中有所介绍）。为此，我们创建一个新的 XmlNamespaceManager
    ➊，并使用 AddNamespace() 方法 ➋ 添加两个命名空间：wsdl 和 xs。然后，我们调用将解析 WSDL 文档元素的方法，从类型开始，一直到服务。每个方法接受两个参数：WSDL
    文档和命名空间管理器。
- en: We also need access to a few properties of the WSDL class that correspond to
    the methods called in the constructor. Add the properties shown in [Listing 3-2](#filepos251619)
    to the WSDL class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要访问 WSDL 类中的一些属性，这些属性与构造函数中调用的方法相对应。将[清单 3-2](#filepos251619)中显示的属性添加到 WSDL
    类中。
- en: public List<SoapType> Types { get; set; }
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapType> Types { get; set; }
- en: public List<SoapMessage> Messages { get; set; }
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapMessage> Messages { get; set; }
- en: public List<SoapPortType> PortTypes { get; set; }
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapPortType> PortTypes { get; set; }
- en: public List<SoapBinding> Bindings { get; set; }
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapBinding> Bindings { get; set; }
- en: public List<SoapService> Services { get; set; }
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapService> Services { get; set; }
- en: 'Listing 3-2: Public properties of the  WSDL  class'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-2: WSDL 类的公共属性'
- en: These properties of the WSDL class are consumed by the fuzzer (which is why
    they are public) and by the methods called in the constructor. The properties
    are lists of the SOAP classes we’ll implement in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: WSDL类的这些属性由模糊测试工具（因此它们是public的）和构造函数中调用的方法使用。它们是我们在本章中将实现的SOAP类的列表。
- en: Writing the Initial Parsing Methods
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编写初始解析方法
- en: First, we’ll write the methods that are called in [Listing 3-1](#filepos249737).
    Once we have those methods implemented, we’ll move on to create the classes each
    method relies on. This is going to be a bit of work, but we’ll get through it
    together!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写在[Listing 3-1](#filepos249737)中调用的方法。一旦这些方法实现完成，我们将继续创建每个方法依赖的类。这会有点工作量，但我们会一起完成的！
- en: We’ll start by implementing the first method called in [Listing 3-1](#filepos249737),
    ParseTypes(). All the methods called from the constructor are relatively simple
    and will look similar to [Listing 3-3](#filepos253495).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实现[Listing 3-1](#filepos249737)中调用的第一个方法`ParseTypes()`开始。构造函数中调用的所有方法相对简单，看起来都与[Listing
    3-3](#filepos253495)类似。
- en: private void ParseTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ParseTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)
- en: '{'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Types = new List<SoapType>();
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Types = new List<SoapType>();
- en: string xpath = ➊"/wsdl:definitions/wsdl:types/xs:schema/xs:element";
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string xpath = ➊"/wsdl:definitions/wsdl:types/xs:schema/xs:element";
- en: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
- en: foreach (XmlNode type in nodes)
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode type in nodes)
- en: this.Types.Add(new SoapType(type));
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Types.Add(new SoapType(type));
- en: '}'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-3: The  ParseTypes()  method called in the  WSDL  class constructor'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-3: WSDL类构造函数中调用的`ParseTypes()`方法'
- en: Because these methods are only called internally in the WSDL constructor, we
    use the private keyword so that only the WSDL class can access them. The ParseTypes()
    method accepts a WSDL document and the namespace manager (used to resolve namespaces
    in the WSDL document) as arguments. Next, we instantiate a new List object and
    assign it to the Types property. We then iterate over the XML elements in the
    WSDL using the XPath facilities available to XML documents in C#. XPath lets a
    programmer traverse and consume an XML document based on node paths within the
    document. In this example, we use an XPath query ➊ to enumerate all the SOAP type
    nodes from the document using the SelectNodes() method. Then we iterate over those
    SOAP types and pass each node to the SoapType class constructor, which is one
    of the classes we’ll implement after entering the initial parsing methods. Finally,
    we add the newly instantiated SoapType objects to the SoapType list property of
    the WSDL class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些方法仅在WSDL构造函数内部调用，所以我们使用`private`关键字，这样只有WSDL类才能访问它们。`ParseTypes()`方法接受一个WSDL文档和命名空间管理器（用于解析WSDL文档中的命名空间）作为参数。接下来，我们实例化一个新的List对象，并将其分配给Types属性。然后，我们使用C#中XML文档的XPath功能，遍历WSDL中的XML元素。XPath允许程序员根据文档中的节点路径遍历和使用XML文档。在这个示例中，我们使用XPath查询➊来枚举文档中的所有SOAP类型节点，使用`SelectNodes()`方法。然后，我们遍历这些SOAP类型，并将每个节点传递给`SoapType`类构造函数，这是我们在进入初始解析方法后将实现的类之一。最后，我们将新实例化的`SoapType`对象添加到WSDL类的SoapType列表属性中。
- en: Easy enough, right? We’ll employ this pattern of using an XPath query to iterate
    over specific nodes a few more times to consume a few other types of nodes we
    need from the WSDL document. XPath is quite powerful and is great for working
    with the C# language in general.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？我们将采用这种使用XPath查询遍历特定节点的模式，再做几次，以便从WSDL文档中获取其他几种我们需要的节点类型。XPath非常强大，对于C#语言的使用也非常合适。
- en: Now we’ll implement the next method called in the WSDL constructor to parse
    the WSDL document, ParseMessages(), as detailed in [Listing 3-4](#filepos256350).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现WSDL构造函数中调用的下一个方法来解析WSDL文档，即`ParseMessages()`，如[Listing 3-4](#filepos256350)所示。
- en: private void ParseMessages(XmlDocument wsdl, XmlNamespaceManager nsManager)
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ParseMessages(XmlDocument wsdl, XmlNamespaceManager nsManager)
- en: '{'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Messages = new List<SoapMessage>();
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Messages = new List<SoapMessage>();
- en: string xpath = ➊"/wsdl:definitions/wsdl:message";
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string xpath = ➊"/wsdl:definitions/wsdl:message";
- en: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
- en: foreach (XmlNode node in nodes)
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode node in nodes)
- en: this.Messages.Add(new SoapMessage(node));
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Messages.Add(new SoapMessage(node));
- en: '}'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-4: The  ParseMessages()  method called in the WSDL class constructor'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-4: WSDL类构造函数中调用的`ParseMessages()`方法'
- en: First, we need to instantiate and assign a new List to hold the SoapMessage
    objects. (SoapMessage is a class we’ll implement in “[Creating the SoapMessage
    Class to Define Sent Data](#filepos270075)” on [page 60](#filepos243384).) Using
    an XPath query ➊ to select the message nodes from the WSDL document, we iterate
    over the nodes returned by the SelectNodes() method and pass them to the SoapMessage
    constructor. These newly instantiated objects are added to the Messages property
    of the WSDL class for later consumption.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要实例化并分配一个新的List来保存SoapMessage对象。（SoapMessage是我们将在[“创建SoapMessage类来定义发送的数据”](#filepos270075)一节中实现的类，见[第60页](#filepos243384)。）使用XPath查询➊从WSDL文档中选择消息节点，我们遍历SelectNodes()方法返回的节点，并将它们传递给SoapMessage构造函数。这些新实例化的对象将被添加到WSDL类的Messages属性中，以便稍后使用。
- en: The next few methods called from the WSDL class are similar to the previous
    two. By now, they should seem relatively straightforward to you, given how the
    previous two methods have worked. These methods are all detailed in [Listing 3-5](#filepos259460).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从WSDL类调用的接下来几个方法与前面两个类似。到现在为止，鉴于前面两个方法的工作方式，它们应该对你来说相对直接。这些方法的详细信息请见[清单 3-5](#filepos259460)。
- en: private void ParsePortTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ParsePortTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)
- en: '{'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.PortTypes = new List<SoapPortType>();
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.PortTypes = new List<SoapPortType>();
- en: string xpath = "/wsdl:definitions/wsdl:portType";
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string xpath = "/wsdl:definitions/wsdl:portType";
- en: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
- en: foreach (XmlNode node in nodes)
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode node in nodes)
- en: this.PortTypes.Add(new SoapPortType(node));
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.PortTypes.Add(new SoapPortType(node));
- en: '}'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void ParseBindings(XmlDocument wsdl, XmlNamespaceManager nsManager)
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ParseBindings(XmlDocument wsdl, XmlNamespaceManager nsManager)
- en: '{'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Bindings = new List<SoapBinding>();
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Bindings = new List<SoapBinding>();
- en: string xpath = "/wsdl:definitions/wsdl:binding";
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string xpath = "/wsdl:definitions/wsdl:binding";
- en: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
- en: foreach (XmlNode node in nodes)
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode node in nodes)
- en: this.Bindings.Add(new SoapBinding(node));
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Bindings.Add(new SoapBinding(node));
- en: '}'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void ParseServices(XmlDocument wsdl, XmlNamespaceManager nsManager)
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ParseServices(XmlDocument wsdl, XmlNamespaceManager nsManager)
- en: '{'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Services = new List<SoapService>();
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Services = new List<SoapService>();
- en: string xpath = "/wsdl:definitions/wsdl:service";
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string xpath = "/wsdl:definitions/wsdl:service";
- en: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
- en: foreach (XmlNode node in nodes)
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode node in nodes)
- en: this.Services.Add(new SoapService(node));
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Services.Add(new SoapService(node));
- en: '}'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-5: The rest of the initial parsing methods in the  WSDL  class'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-5：WSDL类中其余的初始解析方法
- en: To fill the PortTypes, Bindings, and Services properties, we use XPath queries
    to find and iterate over the relevant nodes; then we instantiate specific SOAP
    classes, which we’ll implement next, and add them to the lists so that we can
    access them later when we need to build the WSDL fuzzer logic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充PortTypes、Bindings和Services属性，我们使用XPath查询来查找并遍历相关节点；然后我们实例化特定的SOAP类（接下来将实现这些类），并将它们添加到列表中，以便在稍后需要构建WSDL模糊测试逻辑时使用。
- en: That’s it for the WSDL class. A constructor, a handful of properties to store
    data relevant to the WSDL class, and some methods to parse out a WSDL document
    are all that you need to get started. Now we need to implement the supporting
    classes. Within the parsing methods, we used some classes that haven’t yet been
    implemented (SoapType, SoapMessage, SoapPortType, SoapBinding, and SoapService).
    We’ll start with the SoapType class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是WSDL类的全部内容。一个构造函数，几个存储与WSDL类相关数据的属性，以及一些解析WSDL文档的方法，这些就是你开始工作的全部内容。接下来我们需要实现支持类。在解析方法中，我们使用了一些尚未实现的类（SoapType、SoapMessage、SoapPortType、SoapBinding和SoapService）。我们将从SoapType类开始。
- en: Writing a Class for the SOAP Type and Parameters
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为SOAP类型和参数编写一个类
- en: To complete the ParseTypes() method, we need to implement the SoapType class.
    The SoapType class is a relatively simple one. All it needs is a constructor and
    a couple of properties, as shown in [Listing 3-6](#filepos262263).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成ParseTypes()方法，我们需要实现SoapType类。SoapType类是一个相对简单的类。它只需要一个构造函数和几个属性，如[清单 3-6](#filepos262263)所示。
- en: public class SoapType
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapType
- en: '{'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapType(XmlNode type)
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapType(XmlNode type)
- en: '{'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = type.➊Attributes["name"].Value;
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = type.➊Attributes["name"].Value;
- en: this.Parameters = new List<SoapTypeParameter>();
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Parameters = new List<SoapTypeParameter>();
- en: if (type.➋HasChildNodes && type.FirstChild.HasChildNodes)
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (type.➋HasChildNodes && type.FirstChild.HasChildNodes)
- en: '{'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (XmlNode node in type.➌FirstChild.FirstChild.➍ChildNodes)
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode node in type.➌FirstChild.FirstChild.➍ChildNodes)
- en: this.Parameters.Add(new SoapTypeParameter(node));
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Parameters.Add(new SoapTypeParameter(node));
- en: '}'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Name { get; set; }
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public List<SoapTypeParameter> Parameters { get; set; }
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapTypeParameter> Parameters { get; set; }
- en: '}'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-6: The  SoapType  class used in the WSDL fuzzer'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-6：在 WSDL 模糊测试中使用的 `SoapType` 类
- en: The logic in the SoapType constructor is similar to that in the previous parsing
    methods (in [Listings 3-4](#filepos256350) and [3-5](#filepos259460)), except
    we’re not using XPath to enumerate the nodes we’re iterating over. We could have,
    but I wanted to show you another way of iterating over XML nodes. Usually, when
    you’re parsing XML, XPath is the way to go, but XPath can be computationally expensive.
    In this case, we’ll write an if statement to check whether we have to iterate
    over the child nodes. Iterating over the child nodes using a foreach loop to find
    the relevant XML element involves slightly less code than using XPath in this
    particular instance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoapType` 构造函数中的逻辑与前面解析方法中的逻辑类似（见 [清单 3-4](#filepos256350) 和 [3-5](#filepos259460)），不同之处在于我们没有使用
    XPath 来枚举我们正在遍历的节点。我们本可以使用 XPath，但我想展示另一种遍历 XML 节点的方式。通常，当你解析 XML 时，XPath 是首选方法，但
    XPath 可能会计算量较大。在这种情况下，我们将写一个 `if` 语句来检查是否需要遍历子节点。在这个特定实例中，使用 `foreach` 循环遍历子节点来找到相关的
    XML 元素，比使用 XPath 的代码要少一些。'
- en: 'The SoapType class has two properties: a Name property, which is a string,
    and a list of parameters (the SoapTypeParameter class, which we’ll implement shortly).
    Both of these properties are used in the SoapType constructor and are public so
    that they can be consumed outside the class later on.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoapType` 类有两个属性：一个是 `Name` 属性，类型为字符串，另一个是参数列表（`SoapTypeParameter` 类，稍后我们会实现）。这两个属性都在
    `SoapType` 构造函数中使用，并且是公有的，以便稍后在类外部使用。'
- en: We use the Attributes property ➊ on the node passed into the constructor arguments
    to retrieve the node’s name attribute. The value of the name attribute is assigned
    to the Name property of the SoapType class. We also instantiate the SoapTypeParameter
    list and assign the new object to the Parameters property. Once this is done,
    we use an if statement to determine whether we need to iterate over child nodes
    in the first place, since we’re not using XPath to iterate over any child nodes.
    Using the HasChildNodes property ➋, which returns a Boolean value, we can determine
    whether we have to iterate over the child nodes. If the node has child nodes,
    and if the first child of that node also has child nodes, we’ll iterate over them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用传入构造函数参数的节点的 `Attributes` 属性 ➊ 来检索节点的 `name` 属性。`name` 属性的值被赋给 `SoapType`
    类的 `Name` 属性。我们还实例化了 `SoapTypeParameter` 列表，并将新对象赋给 `Parameters` 属性。完成这一步后，我们使用
    `if` 语句判断是否需要遍历子节点，因为我们没有使用 XPath 来遍历任何子节点。通过使用 `HasChildNodes` 属性 ➋，它返回一个布尔值，我们可以判断是否需要遍历子节点。如果节点有子节点，且该节点的第一个子节点也有子节点，我们就会遍历它们。
- en: Every XmlNode class has a FirstChild property and a ChildNodes property ➍ that
    returns an enumerable list of the child nodes available. In the foreach loop,
    we use a chain of FirstChild properties ➌ to iterate over the child nodes of the
    first child of the first child of the node passed in.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `XmlNode` 类都有一个 `FirstChild` 属性和一个 `ChildNodes` 属性 ➊，返回可遍历的子节点列表。在 `foreach`
    循环中，我们使用一系列 `FirstChild` 属性 ➌ 来遍历传入节点的第一个子节点的第一个子节点的子节点。
- en: An example of an XML node that would be passed to the SoapType constructor is
    shown in [Listing 3-7](#filepos266373).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `SoapType` 构造函数的 XML 节点示例如 [清单 3-7](#filepos266373) 中所示。
- en: After iterating over the relevant child nodes in the SoapType node that’s passed
    in, we instantiate a new SoapTypeParameter class by passing the current child
    node into the SoapTypeParameter constructor. The new object is stored in the Parameters
    list for access later on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历传入的 `SoapType` 节点的相关子节点之后，我们通过将当前子节点传入 `SoapTypeParameter` 构造函数来实例化一个新的 `SoapTypeParameter`
    类。新对象被存储在 `Parameters` 列表中，以便以后访问。
- en: <xs:element name="AddUser">
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <xs:element name="AddUser">
- en: <xs:complexType>
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <xs:complexType>
- en: <xs:sequence>
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <xs:sequence>
- en: <xs:element minOccurs="0" maxOccurs="1" name="username" type="xs:string"/>
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <xs:element minOccurs="0" maxOccurs="1" name="username" type="xs:string"/>
- en: <xs:element minOccurs="0" maxOccurs="1" name="password" type="xs:string"/>
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <xs:element minOccurs="0" maxOccurs="1" name="password" type="xs:string"/>
- en: </xs:sequence>
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </xs:sequence>
- en: </xs:complexType>
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </xs:complexType>
- en: '</xs:element> Listing 3-7: Sample  SoapType  XML'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '</xs:element> Listing 3-7: 示例 SoapType XML'
- en: Now let’s create the SoapTypeParameter class. The SoapTypeParameter class is
    also relatively simple. In fact, no iteration over child nodes is required, just
    basic information gathering, as [Listing 3-8](#filepos268034) shows.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建 SoapTypeParameter 类。SoapTypeParameter 类也相对简单。事实上，不需要对子节点进行迭代，只需进行基本的信息收集，正如
    [Listing 3-8](#filepos268034) 所示。
- en: public class SoapTypeParameter
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapTypeParameter
- en: '{'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapTypeParameter(XmlNode node)
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapTypeParameter(XmlNode node)
- en: '{'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➊if (node.Attributes["maxOccurs"].Value == "unbounded")
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊如果 (node.Attributes["maxOccurs"].Value == "unbounded")
- en: this.MaximumOccurrence = int.MaxValue;
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.MaximumOccurrence = int.MaxValue;
- en: else
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: this.MaximumOccurrence = int.Parse(node.Attributes["maxOccurs"].Value);
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.MaximumOccurrence = int.Parse(node.Attributes["maxOccurs"].Value);
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.MinimumOccurrence = int.Parse(node.Attributes["minOccurs"].Value);
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.MinimumOccurrence = int.Parse(node.Attributes["minOccurs"].Value);
- en: this.Name = node.Attributes["name"].Value;
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = node.Attributes["name"].Value;
- en: this.Type = node.Attributes["type"].Value;
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Type = node.Attributes["type"].Value;
- en: '}'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public int MinimumOccurrence { get; set; }
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int MinimumOccurrence { get; set; }
- en: public int MaximumOccurrence { get; set; }
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int MaximumOccurrence { get; set; }
- en: public string Name { get; set; }
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public string Type { get; set; }
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Type { get; set; }
- en: '}'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-8: The  SoapTypeParameter  class'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-8: SoapTypeParameter 类'
- en: An example of an XML node passed to the SoapTypeParameter constructor is shown
    in [Listing 3-9](#filepos268593).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 SoapTypeParameter 构造函数的 XML 节点示例如 [Listing 3-9](#filepos268593) 所示。
- en: '<xs:element minOccurs="0" maxOccurs="1" name="username" type="xs:string"/>
    Listing 3-9: Sample XML node passed to the  SoapTypeParameter  constructor'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '<xs:element minOccurs="0" maxOccurs="1" name="username" type="xs:string"/>
    Listing 3-9: 传递给 SoapTypeParameter 构造函数的示例 XML 节点'
- en: Given an XML node like this, we can expect a few things to happen in our method.
    First, this is a very basic WSDL parameter that defines a parameter named username
    that is of type string. It can occur at a minimum zero times and at most once.
    Look closely at the code in [Listing 3-8](#filepos268034), and you’ll notice that
    there’s an if statement ➊ that checks the value of maxOccurs. Unlike minOccurs,
    maxOccurs can be either an integer or the string value unbounded, so we have to
    check the maxOccurs value before passing it to the int.Parse() method to see what
    the value is.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个像这样的 XML 节点，我们可以预期在我们的方法中发生一些事情。首先，这是一个非常基本的 WSDL 参数，定义了一个名为 username 的参数，其类型为
    string。它至少可以出现零次，最多一次。仔细查看 [Listing 3-8](#filepos268034) 中的代码，你会注意到有一个 if 语句 ➊
    检查 maxOccurs 的值。与 minOccurs 不同，maxOccurs 可以是一个整数或字符串值 unbounded，因此我们需要在将其传递给 int.Parse()
    方法之前检查 maxOccurs 的值，以确认它的具体值。
- en: Within our SoapTypeParameter constructor, we first assign the MaximumOccurrence
    property based on the node’s maxOccurs attribute. We then assign the MinimumOccurrence,
    Name, and Type properties based on the corresponding node attributes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 SoapTypeParameter 构造函数中，我们首先根据节点的 maxOccurs 属性赋值 MaximumOccurrence 属性。然后根据相应的节点属性赋值
    MinimumOccurrence、Name 和 Type 属性。
- en: Creating the SoapMessage Class to Define Sent Data
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 SoapMessage 类以定义发送数据
- en: A SOAP message defines a set of data that the web service either expects or
    responds with for a given operation. It references the SOAP types and parameters
    previously parsed to present data to or consume data from the client application
    and is made up of parts, which is the technical term. An example of a SOAP 1.1
    message XML element is provided in [Listing 3-10](#filepos270966).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP 消息定义了一组数据，Web 服务为某个操作预期接收或响应这些数据。它引用了之前解析的 SOAP 类型和参数，以向客户端应用程序呈现数据或从中获取数据，并由多个部分组成，这个“部分”是技术术语。SOAP
    1.1 消息 XML 元素的示例如 [Listing 3-10](#filepos270966) 所示。
- en: <message name="AddUserHttpGetIn">
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <message name="AddUserHttpGetIn">
- en: <part name="username" type="s:string"/>
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <part name="username" type="s:string"/>
- en: <part name="password" type="s:string"/>
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <part name="password" type="s:string"/>
- en: '</message> Listing 3-10: Sample SOAP message XML element'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '</message> Listing 3-10: 示例 SOAP 消息 XML 元素'
- en: Our SoapMessage class, which consumes an XML element like the one in [Listing
    3-10](#filepos270966), is detailed in [Listing 3-11](#filepos272170).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 SoapMessage 类，它消费像 [Listing 3-10](#filepos270966) 中的 XML 元素，详见 [Listing
    3-11](#filepos272170)。
- en: public class SoapMessage
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapMessage
- en: '{'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapMessage(XmlNode node)
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapMessage(XmlNode node)
- en: '{'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊node.Attributes["name"].Value;
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊node.Attributes["name"].Value;
- en: this.Parts = new List<SoapMessagePart>();
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Parts = new List<SoapMessagePart>();
- en: if (node.HasChildNodes)
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 (node.HasChildNodes)
- en: '{'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: foreach (XmlNode part in node.ChildNodes)
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode part in node.ChildNodes)
- en: this.Parts.Add(new SoapMessagePart(part));
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Parts.Add(new SoapMessagePart(part));
- en: '}'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public List<SoapMessagePart> Parts { get; set; }
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapMessagePart> Parts { get; set; }
- en: '}'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-11: The  SoapMessage  class'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-11：SoapMessage 类
- en: First, we assign the name of the message to the Name property ➊ of the SoapMessage
    class. We then instantiate a new List of parts called SoapMessagePart and iterate
    over each <part> element, passing the element to the SoapMessagePart constructor
    and saving the new SoapMessagePart for later use by adding it to the Parts list.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将消息的名称分配给 SoapMessage 类的 Name 属性 ➊。然后，我们实例化一个新的名为 SoapMessagePart 的部分列表，并遍历每个
    <part> 元素，将元素传递给 SoapMessagePart 构造函数，并通过将其添加到 Parts 列表中来保存新创建的 SoapMessagePart，以备后续使用。
- en: Implementing a Class for Message Parts
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为消息部分实现一个类
- en: Like the previous SOAP classes we have implemented, the SoapMessagePart class
    is a simple class, as [Listing 3-12](#filepos274368) shows.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们之前实现的 SOAP 类一样，SoapMessagePart 类是一个简单的类，如[清单 3-12](#filepos274368)所示。
- en: public class SoapMessagePart
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapMessagePart
- en: '{'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapMessagePart(XmlNode part)
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapMessagePart(XmlNode part)
- en: '{'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊part.Attributes["name"].Value;
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊part.Attributes["name"].Value;
- en: if (➋part.Attributes["element"] != null)
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (➋part.Attributes["element"] != null)
- en: this.Element = part.Attributes["element"].Value;
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Element = part.Attributes["element"].Value;
- en: else if ( part.Attributes["type"].Value != null)
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if ( part.Attributes["type"].Value != null)
- en: this.Type = part.Attributes["type"].Value;
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Type = part.Attributes["type"].Value;
- en: else
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: throw new ArgumentException("Neither element nor type is set.", "part");
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new ArgumentException("Neither element nor type is set.", "part");
- en: '}'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public string Element { get; set; }
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Element { get; set; }
- en: public string Type { get; set; }
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Type { get; set; }
- en: '}'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-12: The  SoapMessagePart  class'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-12：SoapMessagePart 类
- en: 'The SoapMessagePart class constructor takes a single argument, XmlNode, that
    contains the name and the type or element of the part within the SoapMessage.
    The SoapMessagePart class defines three public properties: the part’s Name, Type,
    and Element, all of which are strings. First, we store the name of the part in
    the Name property ➊. Then, if we have an attribute called element ➋, we assign
    the value of the element attribute to the Element property. If the element attribute
    doesn’t exist, the type attribute must exist, so we assign the value of the type
    attribute to the Type property. Only two of these properties will be set for any
    given SOAP part—a SOAP part always has a Name and either a Type or Element. The
    Type or Element will be set depending on whether the part is a simple type (such
    as a string or integer) or a complex type encompassed by another XML element within
    the WSDL. We have to create a class for each kind of parameter, and we’ll start
    by implementing the Type class.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: SoapMessagePart 类的构造函数接受一个 XmlNode 类型的单一参数，该参数包含了 SoapMessage 中部分的名称、类型或元素。SoapMessagePart
    类定义了三个公共属性：部分的 Name、Type 和 Element，都是字符串类型。首先，我们将部分的名称存储在 Name 属性中 ➊。然后，如果存在名为
    element 的属性 ➋，我们将 element 属性的值赋给 Element 属性。如果 element 属性不存在，则必须存在 type 属性，此时我们将
    type 属性的值赋给 Type 属性。这三个属性中，只会为任何给定的 SOAP 部分设置其中的两个——SOAP 部分总是具有 Name 属性，并且有一个
    Type 或 Element 属性。Type 或 Element 会根据部分是简单类型（如字符串或整数）还是由另一个 XML 元素包裹的复杂类型来决定。我们需要为每种类型的参数创建一个类，我们将从实现
    Type 类开始。
- en: Defining Port Operations with the SoapPortType Class
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SoapPortType 类定义端口操作
- en: With the SoapMessage and SoapMessagePart classes defined to complete the ParseMessages()
    method from [Listing 3-4](#filepos256350), we move on to create the SoapPortType
    class, which will complete the ParsePortTypes() method. The SOAP port type defines
    the operations available on a given port (not to be confused with a network port),
    and parsing it is detailed in [Listing 3-13](#filepos277536).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 SoapMessage 和 SoapMessagePart 类以完成 [清单 3-4](#filepos256350) 中的 ParseMessages()
    方法之后，我们继续创建 SoapPortType 类，它将完成 ParsePortTypes() 方法。SOAP 端口类型定义了在给定端口上可用的操作（不要与网络端口混淆），其解析过程在[清单
    3-13](#filepos277536)中详细介绍。
- en: public class SoapPortType
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapPortType
- en: '{'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapPortType(XmlNode node)
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapPortType(XmlNode node)
- en: '{'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊node.Attributes["name"].Value;
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊node.Attributes["name"].Value;
- en: this.Operations = new List<SoapOperation>();
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Operations = new List<SoapOperation>();
- en: foreach (XmlNode op in node.ChildNodes)
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode op in node.ChildNodes)
- en: this.Operations.Add(new SoapOperation(op));
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Operations.Add(new SoapOperation(op));
- en: '}'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public List<SoapOperation> Operations { get; set; }
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapOperation> Operations { get; set; }
- en: '}'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-13: The  SoapPortType  class used in the  ParsePortTypes()  method'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-13：在 ParsePortTypes() 方法中使用的 SoapPortType 类
- en: 'The pattern of how these SOAP classes work continues: the SoapPortType class
    in [Listing 3-13](#filepos277536) defines a small constructor that accepts an
    XmlNode from the WSDL document. It requires two public properties: a SoapOperation
    list and a Name string. Within the SoapPortType constructor, we first assign the
    Name property ➊ to the XML name attribute. We then create a new SoapOperation
    list and iterate over each of the child nodes in the portType element. As we iterate,
    we pass the child node to the SoapOperation constructor (which we build in the
    next section) and store the resulting SoapOperation in our list. An example of
    an XML node from the WSDL document that would be passed to the SoapPortType class
    constructor is shown in [Listing 3-14](#filepos280223).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 SOAP 类如何工作的模式是延续的：在[示例 3-13](#filepos277536)中的 SoapPortType 类定义了一个小的构造函数，该构造函数接受来自
    WSDL 文档的 XmlNode。它需要两个公共属性：一个 SoapOperation 列表和一个 Name 字符串。在 SoapPortType 构造函数中，我们首先将
    Name 属性 ➊ 分配给 XML 的 name 属性。然后，我们创建一个新的 SoapOperation 列表，并遍历 portType 元素中的每个子节点。我们在遍历时，将子节点传递给
    SoapOperation 构造函数（在下一节中我们将构建这个构造函数），并将生成的 SoapOperation 存储在我们的列表中。一个来自 WSDL 文档的
    XML 节点示例，它将传递给 SoapPortType 类构造函数，如[示例 3-14](#filepos280223)所示。
- en: <portType name="VulnerableServiceSoap">
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <portType name="VulnerableServiceSoap">
- en: <operation name="AddUser">
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <operation name="AddUser">
- en: <input message="s0:AddUserSoapIn"/>
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <input message="s0:AddUserSoapIn"/>
- en: <output message="s0:AddUserSoapOut"/>
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <output message="s0:AddUserSoapOut"/>
- en: </operation>
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </operation>
- en: <operation name="ListUsers">
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <operation name="ListUsers">
- en: <input message="s0:ListUsersSoapIn"/>
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <input message="s0:ListUsersSoapIn"/>
- en: <output message="s0:ListUsersSoapOut"/>
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <output message="s0:ListUsersSoapOut"/>
- en: </operation>
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </operation>
- en: <operation name="GetUser">
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <operation name="GetUser">
- en: <input message="s0:GetUserSoapIn"/>
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <input message="s0:GetUserSoapIn"/>
- en: <output message="s0:GetUserSoapOut"/>
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <output message="s0:GetUserSoapOut"/>
- en: </operation>
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </operation>
- en: <operation name="DeleteUser">
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <operation name="DeleteUser">
- en: <input message="s0:DeleteUserSoapIn"/>
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <input message="s0:DeleteUserSoapIn"/>
- en: <output message="s0:DeleteUserSoapOut"/>
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <output message="s0:DeleteUserSoapOut"/>
- en: </operation>
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </operation>
- en: '</portType> Listing 3-14: Sample  portType  XML node passed to the  SoapPortType  class
    constructor'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </portType> 示例 3-14：传递给 SoapPortType 类构造函数的 portType XML 节点示例
- en: As you can see, the portType element contains the operations we’ll be able to
    perform, such as listing, creating, and deleting users. Each of the operations
    maps to a given message, which we parsed in [Listing 3-11](#filepos272170).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，portType 元素包含我们将能够执行的操作，例如列出、创建和删除用户。每个操作都映射到一个特定的消息，我们在[示例 3-11](#filepos272170)中进行了解析。
- en: Implementing a Class for Port Operations
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为端口操作实现一个类
- en: In order to use the operations from the SoapPortType class constructor, we need
    to create the SoapOperation class, as shown in [Listing 3-15](#filepos282268).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用来自 SoapPortType 类构造函数的操作，我们需要创建 SoapOperation 类，如[示例 3-15](#filepos282268)所示。
- en: public class SoapOperation
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapOperation
- en: '{'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapOperation(XmlNode op)
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapOperation(XmlNode op)
- en: '{'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊op.Attributes["name"].Value;
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊op.Attributes["name"].Value;
- en: foreach (XmlNode message in op.ChildNodes)
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode message in op.ChildNodes)
- en: '{'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (message.Name.EndsWith("input"))
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (message.Name.EndsWith("input"))
- en: this.Input = message.Attributes["message"].Value;
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Input = message.Attributes["message"].Value;
- en: else if (message.Name.EndsWith("output"))
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if (message.Name.EndsWith("output"))
- en: this.Output = message.Attributes["message"].Value;
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Output = message.Attributes["message"].Value;
- en: '}'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public string Input { get; set; }
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Input { get; set; }
- en: public string Output { get; set; }
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Output { get; set; }
- en: '}'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-15: The  SoapOperation  class'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-15：SoapOperation 类
- en: The SoapOperation constructor accepts an XmlNode as the single argument. The
    first thing we do is assign a property of the SoapOperation class called Name
    ➊ to the name attribute of the operation XML element passed to the constructor.
    We then iterate over each of the child nodes, checking whether the name of the
    element ends with either "input" or "output". If the name of the child node ends
    with "input", we assign the Input property to the name of the input element. Otherwise,
    we assign the Output property to the name of the output element. Now that the
    SoapOperation class has been implemented, we can move on to the classes we need
    to finish up the ParseBindings() method.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: SoapOperation 构造函数接受一个 XmlNode 作为唯一的参数。我们做的第一件事是将 SoapOperation 类中的一个属性 Name
    ➊ 分配给传递给构造函数的操作 XML 元素的 name 属性。然后，我们遍历每个子节点，检查元素的名称是否以 "input" 或 "output" 结尾。如果子节点的名称以
    "input" 结尾，我们将 Input 属性分配给输入元素的名称。否则，我们将 Output 属性分配给输出元素的名称。现在，SoapOperation
    类已经实现，我们可以继续完成 ParseBindings() 方法所需的类。
- en: Defining Protocols Used in SOAP Bindings
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 SOAP 绑定中使用的协议
- en: The two general types of bindings are HTTP and SOAP. It seems redundant, but
    the HTTP bindings transport data over the general HTTP protocol, using an HTTP
    query string or POST parameters. SOAP bindings use either the SOAP 1.0 or SOAP
    1.1 protocol over simple TCP sockets or named pipes, which encompass the data
    flowing to and from the server in XML. The SoapBinding class lets you decide how
    to communicate with a given SOAP port depending on the binding.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定的两种常见类型是 HTTP 和 SOAP。看似冗余，但 HTTP 绑定通过通用的 HTTP 协议传输数据，使用 HTTP 查询字符串或 POST 参数。SOAP
    绑定则使用 SOAP 1.0 或 SOAP 1.1 协议，通过简单的 TCP 套接字或命名管道进行数据传输，数据以 XML 格式流动到达服务器。SoapBinding
    类允许你根据绑定类型选择如何与给定的 SOAP 端口进行通信。
- en: A sample binding node from the WSDL is shown in [Listing 3-16](#filepos285096).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从 WSDL 中显示的一个示例绑定节点见 [清单 3-16](#filepos285096)。
- en: <binding name="VulnerableServiceSoap" type="s0:VulnerableServiceSoap">
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <binding name="VulnerableServiceSoap" type="s0:VulnerableServiceSoap">
- en: <soap:binding transport="http://schemas.xmlsoap.org/soap/http"/>
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <soap:binding transport="http://schemas.xmlsoap.org/soap/http"/>
- en: <operation name="AddUser">
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <operation name="AddUser">
- en: <soap:operation soapAction="http://tempuri.org/AddUser" style="document"/>
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <soap:operation soapAction="http://tempuri.org/AddUser" style="document"/>
- en: <input>
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <input>
- en: <soap:body use="literal"/>
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <soap:body use="literal"/>
- en: </input>
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </input>
- en: <output>
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <output>
- en: <soap:body use="literal"/>
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <soap:body use="literal"/>
- en: </output>
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </output>
- en: </operation>
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </operation>
- en: '</binding> Listing 3-16: Sample binding XML node from the WSDL'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </binding> 清单 3-16：来自 WSDL 的示例绑定 XML 节点
- en: In order to parse this XML node, our class needs to pull some key information
    out of the binding node, as shown in [Listing 3-17](#filepos286958).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析这个 XML 节点，我们的类需要从绑定节点中提取一些关键信息，如 [清单 3-17](#filepos286958) 所示。
- en: public class SoapBinding
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapBinding
- en: '{'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapBinding(XmlNode node)
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapBinding(XmlNode node)
- en: '{'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊node.Attributes["name"].Value;
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊node.Attributes["name"].Value;
- en: this.Type = ➋node.Attributes["type"].Value;
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Type = ➋node.Attributes["type"].Value;
- en: this.IsHTTP = false;
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.IsHTTP = false;
- en: this.Operations = new List<SoapBindingOperation>();
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Operations = new List<SoapBindingOperation>();
- en: foreach (XmlNode op in node.ChildNodes)
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode op in node.ChildNodes)
- en: '{'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (➌op.Name.EndsWith("operation"))
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (➌op.Name.EndsWith("operation"))
- en: '{'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Operations.Add(new SoapBindingOperation(op));
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Operations.Add(new SoapBindingOperation(op));
- en: '}'
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: else if (op.Name == "http:binding")
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if (op.Name == "http:binding")
- en: '{'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Verb = op.Attributes["verb"].Value;
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Verb = op.Attributes["verb"].Value;
- en: this.IsHTTP = true;
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.IsHTTP = true;
- en: '}'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public List<SoapBindingOperation> Operations { get; set; }
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapBindingOperation> Operations { get; set; }
- en: public bool IsHTTP { get; set; }
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public bool IsHTTP { get; set; }
- en: public string Verb { get; set; }
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Verb { get; set; }
- en: public string Type { get; set; }
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Type { get; set; }
- en: '}'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-17: The  SoapBinding  class'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-17：SoapBinding 类
- en: After accepting an XmlNode as the argument to the SoapBinding constructor, we
    first assign the values of the name and type attributes of the node to the Name
    ➊ and Type ➋ properties of the SoapBinding class. By default, we set the IsHTTP
    Boolean property to false. The IsHTTP property helps us determine how to send
    the data we want to fuzz, using either HTTP parameters or SOAP XML.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 XmlNode 作为参数传递给 SoapBinding 构造函数后，我们首先将节点的 name 和 type 属性的值分别赋给 SoapBinding
    类的 Name ➊ 和 Type ➋ 属性。默认情况下，我们将 IsHTTP 布尔属性设置为 false。IsHTTP 属性帮助我们确定如何发送我们要模糊测试的数据，可以使用
    HTTP 参数或 SOAP XML。
- en: As we iterate over the child nodes, we test whether each child node’s name ends
    with "operation" ➌, and, if so, we add the operation to the SoapBindingOperation
    list. If the child node’s name does not end with "operation", the node should
    be an HTTP binding. We ensure this is the case with an else if statement, and
    we set the HTTP Verb property to the value of the verb attribute of the child
    node. We also set IsHTTP to true. The Verb property should contain either GET
    or POST, which tells us whether the data sent to the SOAP endpoint will be in
    query string (GET) parameters or POST parameters.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历子节点时，我们会测试每个子节点的名称是否以 "operation" ➌ 结尾。如果是，我们将该操作添加到 SoapBindingOperation
    列表中。如果子节点的名称不以 "operation" 结尾，则该节点应该是一个 HTTP 绑定。我们通过 else if 语句确保这一点，并将 HTTP Verb
    属性设置为子节点的 verb 属性值。我们还将 IsHTTP 设置为 true。Verb 属性应包含 GET 或 POST，这告诉我们数据是否会以查询字符串（GET）参数或
    POST 参数的形式发送到 SOAP 端点。
- en: Next, we’ll implement the SoapBindingOperation class.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 SoapBindingOperation 类。
- en: Compiling a List of Operation Child Nodes
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 编译操作子节点列表
- en: The SoapBindingOperation class is a small class consumed in the SoapBinding
    class constructor. It defines a few string properties that will be assigned values
    based on the operation node passed to the constructor, as shown in [Listing 3-18](#filepos290356).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: SoapBindingOperation 类是一个小类，在 SoapBinding 类构造函数中被使用。它定义了几个字符串属性，这些属性将根据传递给构造函数的操作节点赋值，如
    [Listing 3-18](#filepos290356) 所示。
- en: public class SoapBindingOperation
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapBindingOperation
- en: '{'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapBindingOperation(XmlNode op)
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapBindingOperation(XmlNode op)
- en: '{'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊op.Attributes["name"].Value;
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊op.Attributes["name"].Value;
- en: foreach (XmlNode node in op.ChildNodes)
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode node in op.ChildNodes)
- en: '{'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (➋node.Name == "http:operation")
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (➋node.Name == "http:operation")
- en: this.Location = node.Attributes["location"].Value;
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Location = node.Attributes["location"].Value;
- en: else if (node.Name == "soap:operation" || node.Name == "soap12:operation")
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if (node.Name == "soap:operation" || node.Name == "soap12:operation")
- en: this.SoapAction = node.Attributes["soapAction"].Value;
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.SoapAction = node.Attributes["soapAction"].Value;
- en: '}'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public string Location { get; set; }
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Location { get; set; }
- en: public string SoapAction { get; set; }
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string SoapAction { get; set; }
- en: '}'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-18: The  SoapBindingOperation  class'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-18: SoapBindingOperation 类'
- en: 'Using the XmlNode that’s passed to the constructor, we first assign the Name
    property ➊ to the value of the name attribute on the XML node. The operation node
    contains a few child nodes, but we only really care about three specific nodes:
    http:operation, soap:operation, and soap12:operation. As we iterate over the child
    nodes to find a node we care about, we check whether the operation is an HTTP
    operation or a SOAP operation. If it is an HTTP operation ➋, we store the location
    of the endpoint for the operation, which is a relative URI such as /AddUser. If
    it’s a SOAP operation, we store the SoapAction, which is used in a specific HTTP
    header when making SOAP calls against the SOAP endpoint. When we write the fuzzing
    logic, this information will be used to send the data to the correct endpoint.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传递给构造函数的 XmlNode，我们首先将 Name 属性 ➊ 设置为 XML 节点上的 name 属性值。操作节点包含几个子节点，但我们只关心三个特定的节点：http:operation、soap:operation
    和 soap12:operation。当我们遍历子节点以找到我们关心的节点时，我们检查操作是否为 HTTP 操作。如果是 HTTP 操作 ➋，我们会存储该操作的端点位置，它是一个相对
    URI，例如 /AddUser。如果是 SOAP 操作，我们会存储 SoapAction，它在对 SOAP 端点进行 SOAP 调用时会在特定的 HTTP
    头中使用。当我们编写模糊测试逻辑时，这些信息将用于将数据发送到正确的端点。
- en: Finding the SOAP Services on Ports
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找端口上的 SOAP 服务
- en: Before we can begin fuzzing, we need to finish parsing the WSDL. We’ll implement
    two more small classes that encompass the SOAP services available and the SOAP
    ports on those services. We must implement the SoapService class first, as shown
    in [Listing 3-19](#filepos292818).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始模糊测试之前，我们需要完成 WSDL 的解析。我们将实现另外两个小类，分别包含可用的 SOAP 服务和这些服务上的 SOAP 端口。我们必须首先实现
    SoapService 类，如 [Listing 3-19](#filepos292818) 所示。
- en: public class SoapService
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapService
- en: '{'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapService(XmlNode node)
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapService(XmlNode node)
- en: '{'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊node.Attributes["name"].Value;
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊node.Attributes["name"].Value;
- en: this.Ports = new List<SoapPort>();
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Ports = new List<SoapPort>();
- en: foreach (XmlNode port in node.ChildNodes)
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode port in node.ChildNodes)
- en: this.Ports.Add(new SoapPort(port));
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Ports.Add(new SoapPort(port));
- en: '}'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public List<SoapPort> Ports { get; set; }
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapPort> Ports { get; set; }
- en: '}'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-19: The  SoapService  class'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-19: SoapService 类'
- en: The SoapService class takes an XML node as the only argument to the constructor.
    We first assign the name of the service to the Name property of the class ➊ and
    then create a new list of ports, called SoapPort. As we iterate over the child
    nodes in the service node, we use each child node to create a new SoapPort and
    add the new object to the SoapPort list for later reference.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: SoapService 类只接受一个 XML 节点作为构造函数的参数。我们首先将服务的名称分配给类的 Name 属性 ➊，然后创建一个新的端口列表，称为
    SoapPort。当我们遍历服务节点中的子节点时，我们使用每个子节点创建一个新的 SoapPort 并将该新对象添加到 SoapPort 列表中以供后续引用。
- en: A sample service XML node with four child port nodes from a WSDL document is
    shown in [Listing 3-20](#filepos294942).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含四个子端口节点的服务 XML 节点来自一个 WSDL 文档，如 [Listing 3-20](#filepos294942) 所示。
- en: <service name="VulnerableService">
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <service name="VulnerableService">
- en: <port name="VulnerableServiceSoap" binding="s0:VulnerableServiceSoap">
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <port name="VulnerableServiceSoap" binding="s0:VulnerableServiceSoap">
- en: <soap:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <soap:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
- en: </port>
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </port>
- en: <port name="VulnerableServiceSoap12" binding="s0:VulnerableServiceSoap12">
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <port name="VulnerableServiceSoap12" binding="s0:VulnerableServiceSoap12">
- en: <soap12:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <soap12:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
- en: </port>
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </port>
- en: <port name="VulnerableServiceHttpGet" binding="s0:VulnerableServiceHttpGet">
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <port name="VulnerableServiceHttpGet" binding="s0:VulnerableServiceHttpGet">
- en: <http:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <http:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
- en: </port>
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </port>
- en: <port name="VulnerableServiceHttpPost" binding="s0:VulnerableServiceHttpPost">
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <port name="VulnerableServiceHttpPost" binding="s0:VulnerableServiceHttpPost">
- en: <http:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <http:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
- en: </port>
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </port>
- en: '</service> Listing 3-20: A sample service node from a WSDL document'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '</service> 列表 3-20: WSDL文档中的示例服务节点'
- en: The last thing to do is implement the SoapPort class to complete the ParseServices()
    method and then finish parsing the WSDL for fuzzing. The SoapPort class is shown
    in [Listing 3-21](#filepos296261).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是实现SoapPort类，完成ParseServices()方法，然后完成WSDL的解析以进行模糊测试。SoapPort类在[列表 3-21](#filepos296261)中展示。
- en: public class SoapPort
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapPort
- en: '{'
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapPort(XmlNode port)
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapPort(XmlNode port)
- en: '{'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊port.Attributes["name"].Value;
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊port.Attributes["name"].Value;
- en: this.Binding = port.Attributes["binding"].Value;
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Binding = port.Attributes["binding"].Value;
- en: this.ElementType = port.➋FirstChild.Name;
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ElementType = port.➋FirstChild.Name;
- en: this.Location = port.FirstChild.Attributes["location"].Value;
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Location = port.FirstChild.Attributes["location"].Value;
- en: '}'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public string Binding { get; set; }
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Binding { get; set; }
- en: public string ElementType { get; set; }
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ElementType { get; set; }
- en: public string Location { get; set; }
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Location { get; set; }
- en: '}'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-21: The  SoapPort  class'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-21: SoapPort 类'
- en: To finish parsing the WSDL document, we grab a few attributes from the port
    node passed to the SoapPort constructor. We first store the name of the port in
    the Name property ➊ and the binding in the Binding property. Then, referencing
    the port node’s only child node with the FirstChild property ➋, we store the name
    and location data of the child node in the ElementType and Location properties,
    respectively.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成WSDL文档的解析，我们从传递给SoapPort构造函数的port节点中获取一些属性。我们首先将端口的名称存储在Name属性中 ➊，将绑定信息存储在Binding属性中。然后，通过FirstChild属性
    ➋引用端口节点的唯一子节点，我们将该子节点的名称和位置数据分别存储在ElementType和Location属性中。
- en: Finally, we have broken apart the WSDL document into manageable pieces that
    will allow us to easily write a fuzzer to find potential SQL injections. With
    the various parts of the WSDL described as classes, we can programmatically drive
    automatic vulnerability detection and reporting.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将WSDL文档拆分为可管理的片段，这将使我们能够轻松编写一个模糊测试器来发现潜在的SQL注入漏洞。通过将WSDL的各个部分描述为类，我们可以以编程方式驱动自动化漏洞检测和报告。
- en: Automatically Fuzzing the SOAP Endpoint for SQL Injection Vulnerabilities
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化模糊测试SOAP端点以检测SQL注入漏洞
- en: Now that the building blocks for the WSDL fuzzer have been built, we can start
    doing some real fun tool development. Using the WSDL class, we can interact with
    the data in the WSDL in an object-oriented manner, which makes fuzzing the SOAP
    endpoint much easier. We start by writing a new Main() method that accepts a single
    argument (the URL to the SOAP endpoint), which can be created in its own file
    inside of its own Fuzzer class, as shown in [Listing 3-22](#filepos299332).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，WSDL模糊测试器的构建模块已经完成，我们可以开始进行真正的工具开发。使用WSDL类，我们可以以面向对象的方式与WSDL中的数据交互，这使得对SOAP端点的模糊测试变得更加容易。我们从编写一个新的Main()方法开始，该方法接受一个参数（SOAP端点的URL），可以在其自己的Fuzzer类中的文件中创建，如[列表
    3-22](#filepos299332)所示。
- en: private static ➊WSDL _wsdl = null;
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private static ➊WSDL _wsdl = null;
- en: private static ➋string _endpoint = null;
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private static ➋string _endpoint = null;
- en: public static void Main(string[] args)
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _endpoint = ➌args[0];
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _endpoint = ➌args[0];
- en: 'Console.WriteLine("Fetching the WSDL for service: " + _endpoint);'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("正在获取服务的WSDL: " + _endpoint);'
- en: HttpWebRequest req = (HttpWebRequest)WebRequest.Create(_endpoint + "?WSDL");
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest req = (HttpWebRequest)WebRequest.Create(_endpoint + "?WSDL");
- en: XmlDocument wsdlDoc = new XmlDocument();
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XmlDocument wsdlDoc = new XmlDocument();
- en: using (WebResponse resp = req.GetResponse())
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (WebResponse resp = req.GetResponse())
- en: using (Stream respStream = resp.GetResponseStream())
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (Stream respStream = resp.GetResponseStream())
- en: wsdlDoc.➍Load(respStream);
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: wsdlDoc.➍Load(respStream);
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _wsdl = new WSDL(wsdlDoc);
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _wsdl = new WSDL(wsdlDoc);
- en: Console.WriteLine("Fetched and loaded the web service description.");
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("已获取并加载Web服务描述。");
- en: ''
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapService service in _wsdl.Services)
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (SoapService service in _wsdl.Services)
- en: FuzzService(service);
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FuzzService(service);
- en: '}'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-22: The  Main()  method of the SOAP endpoint fuzzer'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-22：SOAP端点模糊测试器的Main()方法
- en: We first declare a couple of static variables at the class level before the
    Main() method. These variables will be used throughout methods we write. The first
    variable is the WSDL class ➊, and the second stores the URL to the SOAP endpoint
    ➋.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在Main()方法之前声明一些静态变量。这些变量将在我们编写的方法中使用。第一个变量是WSDL类 ➊，第二个变量存储SOAP端点的URL ➋。
- en: Within the Main() method, we assign the _endpoint variable to the value of the
    first argument passed to the fuzzer ➌. Then we print a friendly message alerting
    the user that we are going to fetch the WSDL for the SOAP service.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在Main()方法中，我们将_endpoint变量赋值为传递给模糊测试器的第一个参数 ➌。然后我们打印一条友好的消息，提醒用户我们将获取SOAP服务的WSDL。
- en: After storing the URL to the endpoint, we create a new HttpWebRequest to retrieve
    the WSDL from the SOAP service by appending ?WSDL to the end of the endpoint URL.
    We also create a temporary XmlDocument to store the WSDL and to pass to the WSDL
    class constructor. Passing the HTTP response stream to the XmlDocument Load()
    method ➍, we load the XML returned by the HTTP request into the XML document.
    We then pass the resulting XML document to the WSDL class constructor to create
    a new WSDL object. Now we can iterate over each of the SOAP endpoint services
    and fuzz the service. A foreach loop iterates over the objects in the WSDL class
    Services property and passes each service to the FuzzService() method, which we’ll
    write in the next section.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储端点的URL后，我们创建一个新的HttpWebRequest，通过在端点URL末尾附加?WSDL来检索SOAP服务的WSDL。我们还创建一个临时的XmlDocument来存储WSDL并传递给WSDL类构造函数。将HTTP响应流传递给XmlDocument的Load()方法
    ➍，我们将HTTP请求返回的XML加载到XML文档中。然后我们将生成的XML文档传递给WSDL类构造函数以创建一个新的WSDL对象。现在我们可以遍历每个SOAP端点服务并对其进行模糊测试。foreach循环遍历WSDL类Services属性中的对象，并将每个服务传递给FuzzService()方法，我们将在下一节中编写该方法。
- en: Fuzzing Individual SOAP Services
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试单个SOAP服务
- en: The FuzzService() method takes a SoapService as an argument and then determines
    whether we need to fuzz the service using SOAP or HTTP parameters, as shown in
    [Listing 3-23](#filepos302490).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: FuzzService()方法接受一个SoapService作为参数，然后决定我们是否需要使用SOAP或HTTP参数对服务进行模糊测试，如[列表 3-23](#filepos302490)所示。
- en: static void FuzzService(SoapService service)
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static void FuzzService(SoapService service)
- en: '{'
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.WriteLine("Fuzzing service: " + service.Name);'
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("正在模糊测试服务: " + service.Name);'
- en: ''
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapPort port in service.Ports)
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (SoapPort port in service.Ports)
- en: '{'
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.WriteLine("Fuzzing " + port.ElementType.Split('':'')[0] + " port: "
    + port.Name);'
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("正在模糊测试 " + port.ElementType.Split('':'')[0] + " 端口: " +
    port.Name);'
- en: SoapBinding binding = _wsdl.Bindings.➊Single(b => b.Name == port.Binding.Split(':')[1]);
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SoapBinding binding = _wsdl.Bindings.➊Single(b => b.Name == port.Binding.Split(':')[1]);
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (binding.➋IsHTTP)
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (binding.➋IsHTTP)
- en: FuzzHttpPort(binding);
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FuzzHttpPort(binding);
- en: else
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: FuzzSoapPort(binding);
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FuzzSoapPort(binding);
- en: '}'
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-23: The  FuzzService()  method used to determine how to fuzz a given  SoapService'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-23：用于确定如何对给定的SoapService进行模糊测试的FuzzService()方法
- en: After printing the current service we’ll be fuzzing, we iterate over each SOAP
    port in the Ports service property. Using the Language-Integrated Query (LINQ)
    Single() method ➊, we select a single SoapBinding that corresponds to the current
    port. Then we test whether the binding is plain HTTP or XML-based SOAP. If the
    binding is an HTTP binding ➋, we pass it to the FuzzHttpPort() method to fuzz.
    Otherwise, we assume the binding is a SOAP binding and pass it to the FuzzSoapPort()
    method.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印出我们将进行模糊测试的当前服务后，我们遍历服务的Ports属性中的每个SOAP端口。使用语言集成查询（LINQ）Single()方法 ➊，我们选择与当前端口对应的单个SoapBinding。然后我们测试该绑定是否为普通的HTTP或基于XML的SOAP。如果绑定是HTTP绑定
    ➋，我们将其传递给FuzzHttpPort()方法进行模糊测试。否则，我们假设绑定是SOAP绑定，并将其传递给FuzzSoapPort()方法。
- en: Now let’s implement the FuzzHttpPort() method. The two types of possible HTTP
    ports when you’re dealing with SOAP are GET and POST. The FuzzHttpPort() method
    determines which HTTP verb will be used when sending the HTTP requests during
    fuzzing, as shown in [Listing 3-24](#filepos304406).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现FuzzHttpPort()方法。在处理SOAP时，可能的HTTP端口有两种：GET和POST。FuzzHttpPort()方法决定了在模糊测试期间发送HTTP请求时将使用哪种HTTP动词，如[列表
    3-24](#filepos304406)所示。
- en: static void FuzzHttpPort(SoapBinding binding)
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static void FuzzHttpPort(SoapBinding binding)
- en: '{'
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (binding.Verb == "GET")
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (binding.Verb == "GET")
- en: FuzzHttpGetPort(binding);
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FuzzHttpGetPort(binding);
- en: else if (binding.Verb == "POST")
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if (binding.Verb == "POST")
- en: FuzzHttpPostPort(binding);
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FuzzHttpPostPort(binding);
- en: else
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: 'throw new Exception("Don''t know verb: " + binding.Verb);'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'throw new Exception("无法识别的 verb: " + binding.Verb);'
- en: '}'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-24: The  FuzzHttpPort()  method'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-24：FuzzHttpPort() 方法
- en: The FuzzHttpPort() method is very simple. It tests whether the SoapBinding property
    Verb equals GET or POST and then passes the binding to the appropriate method—FuzzHttpGetPort()
    or FuzzHttpPostPort(), respectively. If the Verb property does not equal either
    GET or POST, an exception is thrown to alert the user that we don’t know how to
    handle the given HTTP verb.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: FuzzHttpPort() 方法非常简单。它测试 SoapBinding 属性 Verb 是否等于 GET 或 POST，然后将绑定传递给相应的方法—FuzzHttpGetPort()
    或 FuzzHttpPostPort()。如果 Verb 属性既不等于 GET 也不等于 POST，则会抛出异常，提醒用户我们不知道如何处理给定的 HTTP
    动词。
- en: Now that we’ve created the FuzzHttpPort() method, we’ll implement the FuzzHttpGetPort()
    method.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 FuzzHttpPort() 方法，接下来实现 FuzzHttpGetPort() 方法。
- en: Creating the URL to Fuzz
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Fuzz 的 URL
- en: Both of the HTTP fuzzing methods are a bit more complex than the previous methods
    in the fuzzer. The first half of the FuzzHttpGetPort() method, covered in [Listing
    3-25](#filepos307580), builds the initial URL to fuzz.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 HTTP 模糊测试方法比之前的模糊器方法要复杂一些。FuzzHttpGetPort() 方法的前半部分（在[示例 3-25](#filepos307580)中介绍）构建了初始的
    fuzz URL。
- en: static void FuzzHttpGetPort(SoapBinding binding)
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static void FuzzHttpGetPort(SoapBinding binding)
- en: '{'
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: SoapPortType portType = _wsdl.PortTypes.➊Single(pt => pt.Name == binding.Type.Split(':')[1]);
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SoapPortType portType = _wsdl.PortTypes.➊Single(pt => pt.Name == binding.Type.Split(':')[1]);
- en: foreach (SoapBindingOperation op in binding.Operations)
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (SoapBindingOperation op in binding.Operations)
- en: '{'
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.WriteLine("Fuzzing operation: " + op.Name);'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("正在模糊操作: " + op.Name);'
- en: string url = ➋_endpoint + op.Location;
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string url = ➋_endpoint + op.Location;
- en: SoapOperation po = portType.Operations.Single(p => p.Name == op.Name);
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SoapOperation po = portType.Operations.Single(p => p.Name == op.Name);
- en: SoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split(':')[1]);
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split(':')[1]);
- en: Dictionary<string, string> parameters = new Dictionary<string, string>();
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dictionary<string, string> parameters = new Dictionary<string, string>();
- en: ''
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapMessagePart part in input.Parts)
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (SoapMessagePart part in input.Parts)
- en: parameters.Add(part.Name, part.Type);
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: parameters.Add(part.Name, part.Type);
- en: ''
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bool ➌first = true;
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bool ➌first = true;
- en: List<Guid> guidList = new List<Guid>();
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: List<Guid> guidList = new List<Guid>();
- en: foreach (var param in parameters)
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (var param in parameters)
- en: '{'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (param.Value.EndsWith("string"))
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (param.Value.EndsWith("string"))
- en: '{'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Guid guid = Guid.NewGuid();
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guid guid = Guid.NewGuid();
- en: guidList.Add(guid);
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: guidList.Add(guid);
- en: 'url ➍+= (first ?➎ "?" : "&") + param.Key + "=" + guid.ToString();'
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'url ➍+= (first ?➎ "?" : "&") + param.Key + "=" + guid.ToString();'
- en: '}'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: first = false;
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: first = false;
- en: '}'
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-25: The first half of the  FuzzHttpGetPort()  method, where we build
    the initial URL to fuzz'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-25：FuzzHttpGetPort() 方法的前半部分，我们构建了初始的 fuzz URL
- en: The first thing we do in the FuzzHttpGetPort() method is use LINQ ➊ to select
    the port type from our WSDL class that corresponds to the current SOAP binding.
    We then iterate over the current binding’s Operations property, which contains
    information regarding each operation we can call and how to call the given operation.
    As we iterate, we print which operation we are going to fuzz. We then create the
    URL that we’ll use to make the HTTP request for the given operation by appending
    the Location property of the current operation to the _endpoint variable we set
    at the very beginning of the Main() method ➋. We select the current SoapOperation
    (not to be confused with the SoapBindingOperation!) from the Operations property
    of the portType using the LINQ method Single(). We also select the SoapMessage
    used as the input for the current operation using the same LINQ method, which
    tells us what information the current operation is expecting when called.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FuzzHttpGetPort() 方法中，我们首先使用 LINQ ➊ 从 WSDL 类中选择与当前 SOAP 绑定对应的端口类型。接着，我们遍历当前绑定的
    Operations 属性，该属性包含了有关我们可以调用的每个操作及其调用方式的信息。在遍历时，我们会打印出将要进行 fuzz 的操作。然后，我们通过将当前操作的
    Location 属性附加到我们在 Main() 方法开始时设置的 _endpoint 变量上，创建我们将用于 HTTP 请求的 URL。我们使用 LINQ
    方法 Single() 从 portType 的 Operations 属性中选择当前的 SoapOperation（不要与 SoapBindingOperation
    混淆！）。我们还使用相同的 LINQ 方法选择作为当前操作输入的 SoapMessage，这告诉我们当前操作在被调用时期望什么样的信息。
- en: Once we have the information we need to set up the GET URL, we create a dictionary
    to hold the HTTP parameter names and the parameter types we’ll be sending. We
    iterate over each of the input parts using a foreach loop. As we iterate, we add
    the name of each parameter and the type, which in this case will always be a string,
    to the dictionary. After we have all of our parameter names and their respective
    types stored alongside each other, we can build the initial URL to fuzz.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了设置 GET URL 所需的信息，我们创建一个字典来存储将要发送的 HTTP 参数名称和参数类型。我们通过 foreach 循环遍历每个输入部分。在遍历过程中，我们将每个参数的名称和类型（在这种情况下始终为字符串）添加到字典中。当我们将所有的参数名称和其相应类型存储在一起后，我们可以构建最初的
    URL 进行模糊测试。
- en: To begin, we define a Boolean called first ➌, which we’ll use to determine whether
    the parameter that’s appended to the operation’s URL is the first parameter. This
    is important because the first query string parameter is always separated from
    the base URL by a question mark (?), and subsequent parameters are separated with
    an ampersand (&), so we need to be sure of the distinction. Then, we create a
    Guid list, which will hold unique values that we send along with the parameters
    so we can reference them in the second half of the FuzzHttpGetPort() method.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个名为 first ➌ 的布尔值，用于确定附加到操作 URL 的参数是否为第一个参数。这一点非常重要，因为第一个查询字符串参数总是通过问号
    (?) 与基本 URL 分隔，而后续参数则通过与号 (&) 分隔，因此我们需要确保区分清楚。接着，我们创建一个 Guid 列表，用于存储我们与参数一起发送的唯一值，以便在
    FuzzHttpGetPort() 方法的后半部分引用它们。
- en: Next, we iterate over the parameters dictionary using a foreach loop. In this
    foreach loop, first we test whether the current parameter’s type is a string.
    If it’s a string, we create a new Guid that will be used as the parameter’s value;
    then we add the new Guid to the list we created so we can reference it later.
    We then use the += operator ➍ to append the parameter and the new value to the
    current URL. Using a ternary operation ➎, we determine whether we should prefix
    the parameter with a question mark or ampersand. This is how the HTTP query string
    parameters must be defined per the HTTP protocol. If the current parameter is
    the first parameter, it is prepended with a question mark. Otherwise, it is prepended
    with an ampersand. Finally, we set the parameter to false so that subsequent parameters
    will be prepended with the correct separating character.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 foreach 循环遍历参数字典。在这个 foreach 循环中，我们首先测试当前参数的类型是否为字符串。如果是字符串，我们创建一个新的
    Guid，用作参数的值；然后我们将新的 Guid 添加到我们创建的列表中，以便稍后引用它。接着，我们使用 += 操作符 ➍将参数和新值附加到当前 URL。通过三元操作符
    ➎，我们决定是否应为参数添加问号或与号前缀。这是根据 HTTP 协议定义的 HTTP 查询字符串参数的方式。如果当前参数是第一个参数，它将以问号作为前缀，否则它将以与号作为前缀。最后，我们将参数设置为
    false，以便后续参数将使用正确的分隔符。
- en: Fuzzing the Created URL
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊化已创建的 URL
- en: After creating the URL with query string parameters, we can make HTTP requests
    while systematically replacing parameter values with tainted values that could
    induce a SQL error from the server, as shown in [Listing 3-26](#filepos313361).
    This second half of the code completes the FuzzHttpGetPort() method.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用查询字符串参数创建 URL 后，我们可以发送 HTTP 请求，同时有系统地将参数值替换为可能引发 SQL 错误的污染值，如[清单 3-26](#filepos313361)所示。代码的后半部分完成了
    FuzzHttpGetPort() 方法。
- en: 'Console.WriteLine("Fuzzing full url: " + url);'
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("正在模糊化完整 URL：" + url);
- en: int k = 0;
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int k = 0;
- en: foreach(Guid guid in guidList)
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach(Guid guid in guidList)
- en: '{'
  id: totrans-464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string testUrl = url.➊Replace(guid.ToString(), "fd'sa");
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string testUrl = url.➊Replace(guid.ToString(), "fd'sa");
- en: HttpWebRequest req = (HttpWebRequest)WebRequest.Create(testUrl);
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest req = (HttpWebRequest)WebRequest.Create(testUrl);
- en: string resp = string.Empty;
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string resp = string.Empty;
- en: try
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (StreamReader rdr = new ➋StreamReader(req.GetResponse().GetResponseStream()))
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (StreamReader rdr = new ➋StreamReader(req.GetResponse().GetResponseStream()))
- en: resp = rdr.ReadToEnd();
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = rdr.ReadToEnd();
- en: '}'
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ➌catch (WebException ex)
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌catch (WebException ex)
- en: '{'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))
- en: resp = rdr.ReadToEnd();
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = rdr.ReadToEnd();
- en: ''
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (resp.Contains("syntax error"))
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (resp.Contains("syntax error"))
- en: 'Console.WriteLine("Possible SQL injection vector in parameter: " + input.➍Parts[k].Name);'
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("可能的 SQL 注入向量在参数：" + input.➍Parts[k].Name);
- en: '}'
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: k++;
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: k++;
- en: '}'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-26: The second half of the  FuzzHttpGetPort()  method, sending the
    HTTP requests'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-26：FuzzHttpGetPort() 方法的后半部分，发送 HTTP 请求
- en: Now that we have the full URL that we’ll be fuzzing, we print it for the user
    to see. We also declare an integer, k, that will be incremented as we iterate
    over the parameter values in the URL to keep track of potentially vulnerable parameters.
    Then, using a foreach loop, we iterate over the Guid list we used as the values
    for our parameters. Within the foreach loop, the first thing we do is replace
    the current Guid in the URL with the string "fd'sa" using the Replace() method
    ➊, which should taint any SQL queries using the value without proper sanitization.
    We then create a new HTTP request with the modified URL and declare an empty string
    called resp that will hold the HTTP response.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了要进行模糊测试的完整URL，我们将其打印出来供用户查看。我们还声明了一个整数k，在遍历URL中的参数值时会递增，以便跟踪可能存在漏洞的参数。接着，使用foreach循环，我们遍历用作参数值的Guid列表。在foreach循环内，我们首先做的是使用Replace()方法将当前的Guid替换为字符串"fd'sa"
    ➊，这应该会污染任何使用该值而未进行适当清理的SQL查询。然后，我们使用修改后的URL创建一个新的HTTP请求，并声明一个名为resp的空字符串，用于存放HTTP响应。
- en: Within a try/catch block, we attempt to read the response of the HTTP request
    from the server using a StreamReader ➋. Reading the response will cause an exception
    if the server returns a 500 error (which would happen if a SQL exception occurred
    on the server side). If an exception is thrown, we catch the exception in the
    catch block ➌ and attempt to read the response from the server again. If the response
    contains the string syntax error, we print a message alerting the user that the
    current HTTP parameter could be vulnerable to a SQL injection. In order to tell
    the user precisely which parameter could be vulnerable, we use the integer k as
    the index of the Parts list ➍ and retrieve the Name of the current property. When
    all is said and done, we increment the integer k by 1 and start back at the beginning
    of the foreach loop with a new value to test.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个try/catch块中，我们尝试使用StreamReader ➋读取来自服务器的HTTP请求响应。如果服务器返回500错误（当服务器端发生SQL异常时会发生此情况），读取响应将导致异常。如果抛出异常，我们将在catch块中捕获异常
    ➌，并再次尝试从服务器读取响应。如果响应包含字符串语法错误，我们将打印一条消息，提醒用户当前的HTTP参数可能容易受到SQL注入攻击。为了精确告诉用户哪个参数可能存在漏洞，我们使用整数k作为Parts列表的索引
    ➍，并检索当前属性的Name。当一切完成后，我们将整数k递增1，并用新值重新开始foreach循环进行测试。
- en: That’s the full method for fuzzing HTTP GET SOAP ports. Next, we need to implement
    FuzzHttpPostPort() to fuzz POST SOAP ports.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是进行HTTP GET SOAP端口模糊测试的完整方法。接下来，我们需要实现FuzzHttpPostPort()来对POST SOAP端口进行模糊测试。
- en: Fuzzing the HTTP POST SOAP Port
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 对HTTP POST SOAP端口进行模糊测试
- en: Fuzzing the HTTP POST SOAP port for a given SOAP service is very similar to
    fuzzing the GET SOAP port. The only difference is that the data is sent as HTTP
    POST parameters instead of query-string parameters. When passing the SoapBinding
    for the HTTP POST port to the FuzzHttpPostPort() method, we need to iterate over
    each operation and systematically taint values sent to the operations to induce
    SQL errors from the web server. [Listing 3-27](#filepos317685) shows the first
    half of the FuzzHttpPostPort() method.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定的SOAP服务进行HTTP POST SOAP端口模糊测试与进行GET SOAP端口模糊测试非常相似。唯一的区别是数据作为HTTP POST参数而非查询字符串参数发送。当将HTTP
    POST端口的SoapBinding传递给FuzzHttpPostPort()方法时，我们需要遍历每个操作，并系统地污染发送到操作的数据，以引发Web服务器的SQL错误。[列表
    3-27](#filepos317685)显示了FuzzHttpPostPort()方法的前半部分。
- en: static void FuzzHttpPostPort(SoapBinding binding)
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static void FuzzHttpPostPort(SoapBinding binding)
- en: '{'
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➊SoapPortType portType = _wsdl.PortTypes.Single(pt => pt.Name == binding.Type.Split(':')[1]);
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊SoapPortType portType = _wsdl.PortTypes.Single(pt => pt.Name == binding.Type.Split(':')[1]);
- en: foreach (SoapBindingOperation op in binding.Operations)
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (SoapBindingOperation op in binding.Operations)
- en: '{'
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.WriteLine("Fuzzing operation: " + op.Name);'
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("模糊测试操作：" + op.Name);
- en: string url = _endpoint + op.Location;
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string url = _endpoint + op.Location;
- en: ➋SoapOperation po = portType.Operations.Single(p => p.Name == op.Name);
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋SoapOperation po = portType.Operations.Single(p => p.Name == op.Name);
- en: SoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split(':')[1]);
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split(':')[1]);
- en: Dictionary<string, string> parameters = new ➌Dictionary<string, string>();
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dictionary<string, string> parameters = new ➌Dictionary<string, string>();
- en: ''
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapMessagePart part in input.Parts)
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (SoapMessagePart part in input.Parts)
- en: 'parameters.Add(part.Name, part.Type); Listing 3-27: Determining the operation
    and parameters to fuzz within the  FuzzHttpPostPort()  method'
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: parameters.Add(part.Name, part.Type); 列表 3-27：在FuzzHttpPostPort()方法中确定要进行模糊测试的操作和参数
- en: First we select the SoapPortType ➊ that corresponds to the SoapBinding passed
    to the method. We then iterate over each SoapBindingOperation to determine the
    current SoapBinding using a foreach loop. As we iterate, we print a message that
    specifies which operation we are currently fuzzing, and then we build the URL
    to send the data we are fuzzing to. We also select the corresponding SoapOperation
    ➋ for the portType variable so that we can find the SoapMessage we need, which
    contains the HTTP parameters we need to send to the web server. Once we have all
    the information we need to build and make valid requests to the SOAP service,
    we build a small dictionary ➌ containing the parameter names and their types to
    iterate over later.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择与传递给方法的 SoapBinding 对应的 SoapPortType ➊。然后，我们遍历每个 SoapBindingOperation，以使用
    `foreach` 循环确定当前的 SoapBinding。在遍历过程中，我们打印出一条消息，指定当前正在 fuzzing 的操作，然后构建要发送 fuzzing
    数据的 URL。我们还为 portType 变量选择对应的 SoapOperation ➋，以便我们能找到需要的 SoapMessage，其中包含我们需要发送给
    Web 服务器的 HTTP 参数。获得所有构建和有效请求 SOAP 服务所需的信息后，我们构建一个小的字典 ➌，包含参数名及其类型，供后续遍历。
- en: Now we can build the HTTP parameters we’ll send to the SOAP service, as shown
    in [Listing 3-28](#filepos319979). Continue entering this code into the FuzzHttpPostPort()
    method.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建将发送到 SOAP 服务的 HTTP 参数，如 [Listing 3-28](#filepos319979) 所示。继续将这段代码输入到
    FuzzHttpPostPort() 方法中。
- en: string postParams = string.Empty;
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string postParams = string.Empty;
- en: bool first = true;
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bool first = true;
- en: List<Guid> guids = new List<Guid>();
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: List<Guid> guids = new List<Guid>();
- en: foreach (var param in parameters)
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (var param in parameters)
- en: '{'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (param.Value.➊EndsWith("string"))
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (param.Value.➊EndsWith("string"))
- en: '{'
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Guid guid = Guid.NewGuid();
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guid guid = Guid.NewGuid();
- en: 'postParams += (first ➋? "" : "&") + param.Key + "=" + guid.ToString();'
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'postParams += (first ➋? "" : "&") + param.Key + "=" + guid.ToString();'
- en: guids.Add(guid);
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: guids.Add(guid);
- en: '}'
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: if (first)
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (first)
- en: first = ➌false;
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: first = ➌false;
- en: '}'
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-28: Building the POST parameters to be sent to the POST HTTP SOAP
    port'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-28: 构建要发送到 POST HTTP SOAP 端口的 POST 参数'
- en: We now have all the data we need to build the POST requests. We declare a string
    to hold the POST parameters, and we declare a Boolean, which will determine whether
    the parameter will be prefixed with an ampersand, to delineate the POST parameters.
    We also declare a Guid list so that we can store the values we add to the HTTP
    parameters for use later in the method.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了构建 POST 请求所需的所有数据。我们声明一个字符串来保存 POST 参数，并声明一个布尔值来决定是否在参数前添加一个 "&" 符号，以分隔
    POST 参数。我们还声明了一个 Guid 列表，以便后续在方法中使用时存储我们添加到 HTTP 参数中的值。
- en: Now we can iterate over each of the HTTP parameters using a foreach loop and
    build the parameters string that we’ll send in the POST request body. As we iterate,
    first we check whether the parameter type ends with string ➊. If it does, we create
    a string for a parameter value. To track which string values we use and to ensure
    each value is unique, we create a new Guid and use this as the parameter’s value.
    Using a ternary operation ➋, we determine whether we should prefix the parameter
    with an ampersand. We then store the Guid in the Guid list. Once we have appended
    the parameter and value to the POST parameters string, we check the Boolean value
    and, if it is true, set it to false ➌ so that later POST parameters will be delineated
    with an ampersand.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `foreach` 循环遍历每一个 HTTP 参数，并构建我们将在 POST 请求体中发送的参数字符串。在遍历时，首先检查参数类型是否以字符串
    ➊ 结尾。如果是，我们为参数值创建一个字符串。为了跟踪我们使用的字符串值，并确保每个值都是唯一的，我们创建一个新的 Guid 并将其作为参数的值。通过三元操作符
    ➋，我们判断是否应该在参数前面加上一个 "&" 符号。然后我们将 Guid 存储到 Guid 列表中。一旦我们将参数和值追加到 POST 参数字符串中，我们检查布尔值，如果它为
    true，则将其设置为 false ➌，以便后续的 POST 参数将用 "&" 符号分隔。
- en: Next, we need to send the POST parameters to the server and then read the response
    and check for any errors, as [Listing 3-29](#filepos323372) shows.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 POST 参数发送到服务器，然后读取响应并检查是否有错误，如 [Listing 3-29](#filepos323372) 所示。
- en: int k = 0;
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int k = 0;
- en: foreach (Guid guid in guids)
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (Guid guid in guids)
- en: '{'
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string testParams = postParams.➊Replace(guid.ToString(), "fd'sa");
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string testParams = postParams.➊Replace(guid.ToString(), "fd'sa");
- en: byte[] data = System.Text.Encoding.ASCII.GetBytes(testParams);
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] data = System.Text.Encoding.ASCII.GetBytes(testParams);
- en: ''
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest req = ➋(HttpWebRequest) WebRequest.Create(url);
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest req = ➋(HttpWebRequest) WebRequest.Create(url);
- en: req.Method = "POST";
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.Method = "POST";
- en: req.ContentType = "application/x-www-form-urlencoded";
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.ContentType = "application/x-www-form-urlencoded";
- en: req.ContentLength = data.Length;
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.ContentLength = data.Length;
- en: req.GetRequestStream().➌Write(data, 0, data.Length);
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.GetRequestStream().➌Write(data, 0, data.Length);
- en: ''
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string resp = string.Empty;
- en: try
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试
- en: '{'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用（StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream())）
- en: resp = rdr.➍ReadToEnd();
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = rdr.➍ReadToEnd();
- en: '} catch (WebException ex)'
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '} catch (WebException ex)'
- en: '{'
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用（StreamReader rdr = new StreamReader(ex.Response.GetResponseStream())）
- en: resp = rdr.ReadToEnd();
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = rdr.ReadToEnd();
- en: ''
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (resp.➎Contains("syntax error"))
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (resp.➎Contains("syntax error"))
- en: 'Console.WriteLine("Possible SQL injection vector in parameter: " + input.Parts[k].Name);'
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("参数中可能存在SQL注入漏洞：" + input.Parts[k].Name);
- en: '}'
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: k++;
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: k++;
- en: '}'
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-29: Sending the POST parameters to the SOAP service and checking
    for server errors'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-29：将POST参数发送到SOAP服务并检查服务器错误
- en: To start off, we declare an integer named k, which will be incremented and used
    throughout the fuzzing to keep track of potentially vulnerable parameters, and
    we assign k a value of 0\. Then we iterate over the Guid list using a foreach
    loop. As we iterate, the first thing we do is create a new POST parameter string
    by replacing the current Guid with a tainted value using the Replace() method
    ➊. Because each Guid is unique, when we replace the Guid, it will only change
    a single parameter’s value. This lets us determine exactly which parameter has
    a potential vulnerability. Next, we send the POST request and read the response.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，我们声明一个名为k的整数变量，k会在整个模糊测试中递增并用来跟踪潜在的易受攻击参数，我们将k的初始值设置为0。然后，我们使用foreach循环遍历Guid列表。在遍历过程中，我们首先做的是通过使用Replace()方法➊将当前的Guid替换为一个带有恶意值的新POST参数字符串。由于每个Guid都是唯一的，当我们替换Guid时，只会更改单个参数的值。这让我们能够精确确定哪个参数可能存在漏洞。接下来，我们发送POST请求并读取响应。
- en: Once we have the new POST parameter string to send to the SOAP service, we convert
    the string to an array of bytes using the GetBytes() method that will be written
    to the HTTP stream. We then build the HttpWebRequest ➋ to send the bytes to the
    server and set the HttpWebRequest’s Method property to "POST", the ContentType
    property to application/x-www-form-urlencoded, and the ContentLength property
    to the size of the byte array. Once this is built, we write the byte array to
    the request stream by passing the byte array, the index of the array to begin
    writing from (0), and the number of bytes to write to the Write() method ➌.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了要发送到SOAP服务的新POST参数字符串，我们通过GetBytes()方法将该字符串转换为字节数组，然后将字节数组写入HTTP流中。接着，我们构建HttpWebRequest➋以将字节发送到服务器，并将HttpWebRequest的Method属性设置为“POST”，ContentType属性设置为application/x-www-form-urlencoded，ContentLength属性设置为字节数组的大小。一旦构建完成，我们通过将字节数组、数组开始写入的索引（0）以及要写入的字节数传递给Write()方法➌，将字节数组写入请求流中。
- en: After the POST parameters have been written to the request stream, we need to
    read the response from the server. After declaring an empty string to hold the
    HTTP response, we use a try/catch block to catch any exceptions thrown while reading
    from the HTTP response stream. Creating a StreamReader in the context of a using
    statement, we attempt to read the entire response with the ReadToEnd() method
    ➍ and assign the response to an empty string. If the server responds with an HTTP
    code of 50x (which means an error occurred on the server side), we catch the exception,
    attempt to read the response again, and reassign the response string to the empty
    string to update it. If the response contains the phrase syntax error ➎, we print
    a message alerting the user that the current HTTP parameter could be vulnerable
    to a SQL injection. To determine which parameter was vulnerable, we use the integer
    k as the index of the parameter list to get the current parameter’s Name. Finally,
    we increment the k integer by 1 so that the next parameter will be referenced
    in the next iteration, and then we start the process over again for the next POST
    parameter.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在将POST参数写入请求流之后，我们需要读取服务器的响应。在声明一个空字符串用于保存HTTP响应后，我们使用try/catch块来捕获从HTTP响应流读取时抛出的任何异常。在using语句的上下文中创建一个StreamReader，我们尝试使用ReadToEnd()方法➍读取整个响应并将响应赋值给空字符串。如果服务器响应的HTTP状态码为50x（表示服务器端发生错误），我们捕获该异常，尝试再次读取响应，并将响应字符串重新赋值为空字符串以更新它。如果响应中包含语法错误➎这一短语，我们会打印一条消息，提醒用户当前的HTTP参数可能存在SQL注入漏洞。为了确定哪个参数存在漏洞，我们使用整数k作为参数列表的索引来获取当前参数的名称。最后，我们将k整数增加1，以便在下一个迭代中引用下一个参数，然后我们开始为下一个POST参数重新执行这个过程。
- en: That completes the FuzzHttpGetPort() and FuzzHttpPostPort() methods. Next, we’ll
    write the FuzzSoapPort() method to fuzz the SOAP XML port.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 FuzzHttpGetPort() 和 FuzzHttpPostPort() 方法的实现。接下来，我们将编写 FuzzSoapPort() 方法来模糊测试
    SOAP XML 端口。
- en: Fuzzing the SOAP XML Port
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试 SOAP XML 端口
- en: In order to fuzz the SOAP XML port, we need to dynamically build XML to send
    to the server, which is slightly more difficult than building HTTP parameters
    to send in a GET or POST request. Starting off, though, the FuzzSoapPort() method
    is similar to FuzzHttpGetPort() and FuzzHttpPostPort(), as shown in [Listing 3-30](#filepos328219).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模糊测试 SOAP XML 端口，我们需要动态构建 XML 以发送到服务器，这比构建 HTTP 参数以在 GET 或 POST 请求中发送要稍微复杂一些。不过，刚开始时，FuzzSoapPort()
    方法与 FuzzHttpGetPort() 和 FuzzHttpPostPort() 方法类似，如 [Listing 3-30](#filepos328219)
    所示。
- en: static void FuzzSoapPort(SoapBinding binding)
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static void FuzzSoapPort(SoapBinding binding)
- en: '{'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: SoapPortType portType = _wsdl.PortTypes.Single(pt => pt.Name == binding.Type.Split(':')[1]);
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SoapPortType portType = _wsdl.PortTypes.Single(pt => pt.Name == binding.Type.Split(':')[1]);
- en: ''
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapBindingOperation op in binding.Operations)
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (SoapBindingOperation op in binding.Operations)
- en: '{'
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.➊WriteLine("Fuzzing operation: " + op.Name);'
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.➊WriteLine("正在模糊测试操作：" + op.Name);
- en: SoapOperation po = portType.Operations.Single(p => p.Name == op.Name);
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SoapOperation po = portType.Operations.Single(p => p.Name == op.Name);
- en: 'SoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split('':'')[1]);
    Listing 3-30: Gathering initial information to build dynamic SOAP XML'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'SoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split('':'')[1]);
    Listing 3-30: 收集初步信息以构建动态 SOAP XML'
- en: As with the GET and POST fuzzing methods, we need to collect some information
    about what we are going to fuzz before we can do anything. We first grab the corresponding
    SoapPortType from the _wsdl.PortTypes property using LINQ; then we iterate over
    each operation with a foreach loop. As we iterate, we print the current operation
    we are fuzzing to the console ➊. In order to send the correct XML to the server,
    we need to select the SoapOperation and SoapMessage classes that correspond to
    the SoapBinding class passed to the method. Using the SoapOperation and SoapMessage,
    we can dynamically build the XML required. To do this, we use LINQ to XML, which
    is a set of built-in classes in the System.Xml.Linq namespace that lets you create
    simple, dynamic XML, as shown in [Listing 3-31](#filepos330717).
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GET 和 POST 模糊测试方法一样，我们需要在开始之前收集一些关于我们要模糊测试的目标的信息。我们首先使用 LINQ 从_wsdl.PortTypes
    属性中获取对应的 SoapPortType；然后我们通过 foreach 循环迭代每个操作。迭代时，我们将当前正在模糊测试的操作打印到控制台 ➊。为了向服务器发送正确的
    XML，我们需要选择与传递给方法的 SoapBinding 类相对应的 SoapOperation 和 SoapMessage 类。通过 SoapOperation
    和 SoapMessage，我们可以动态构建所需的 XML。为此，我们使用 LINQ to XML，它是 System.Xml.Linq 命名空间中的一组内置类，允许你创建简单的动态
    XML，如 [Listing 3-31](#filepos330717) 所示。
- en: XNamespace soapNS = "http://schemas.xmlsoap.org/soap/envelope/";
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XNamespace soapNS = "http://schemas.xmlsoap.org/soap/envelope/";
- en: XNamespace xmlNS = op.➊SoapAction.Replace(op.Name, string.Empty);
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XNamespace xmlNS = op.➊SoapAction.Replace(op.Name, string.Empty);
- en: XElement soapBody = new XElement(soapNS + "Body");
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XElement soapBody = new XElement(soapNS + "Body");
- en: XElement soapOperation = new ➋XElement(xmlNS + op.Name);
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XElement soapOperation = new ➋XElement(xmlNS + op.Name);
- en: ''
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: soapBody.Add(soapOperation);
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: soapBody.Add(soapOperation);
- en: ''
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: List<Guid> paramList = new List<Guid>();
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: List<Guid> paramList = new List<Guid>();
- en: SoapType type = _wsdl.Types.➌Single(t => t.Name == input.Parts[0].Element.Split(':')[1]);
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SoapType type = _wsdl.Types.➌Single(t => t.Name == input.Parts[0].Element.Split(':')[1]);
- en: foreach (SoapTypeParameter param in type.Parameters)
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (SoapTypeParameter param in type.Parameters)
- en: '{'
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: XElement soapParam = new ➍XElement(xmlNS + param.Name);
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XElement soapParam = new ➍XElement(xmlNS + param.Name);
- en: if (param.Type.EndsWith("string"))
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (param.Type.EndsWith("string"))
- en: '{'
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Guid guid = Guid.NewGuid();
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guid guid = Guid.NewGuid();
- en: paramList.Add(guid);
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: paramList.Add(guid);
- en: soapParam.➎SetValue(guid.ToString());
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: soapParam.➎SetValue(guid.ToString());
- en: '}'
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: soapOperation.Add(soapParam);
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: soapOperation.Add(soapParam);
- en: '}'
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-31: Building the dynamic SOAP XML using LINQ to XML in the SOAP fuzzer'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-31: 使用 LINQ to XML 在 SOAP 模糊测试器中构建动态 SOAP XML'
- en: We first create two XNameSpace instances to use when building the XML. The first
    XNameSpace is the default SOAP namespace, but the second XNameSpace will change
    based on the current operation’s SoapAction property ➊. After the namespaces are
    defined, we create two new XML elements using the XElement class. The first XElement
    (which will be called <Body>) is a standard XML element used in SOAP and will
    encapsulate the data for the current SOAP operation. The second XElement will
    be named after the current operation ➋. The XElement instances use the default
    SOAP namespace and the SOAP operation namespace, respectively. We then add the
    second XElement to the first using the XElement Add() method so that the SOAP
    <Body> XML element will contain the SOAP operation element.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建两个 XNameSpace 实例，用于构建 XML。第一个 XNameSpace 是默认的 SOAP 命名空间，而第二个 XNameSpace
    会根据当前操作的 SoapAction 属性 ➊ 进行更改。在定义命名空间后，我们使用 XElement 类创建两个新的 XML 元素。第一个 XElement（将命名为
    <Body>）是一个标准的 XML 元素，用于在 SOAP 中封装当前 SOAP 操作的数据。第二个 XElement 将以当前操作命名 ➋。这两个 XElement
    实例分别使用默认 SOAP 命名空间和 SOAP 操作命名空间。然后，我们使用 XElement Add() 方法将第二个 XElement 添加到第一个
    XElement 中，以便 SOAP <Body> XML 元素将包含 SOAP 操作元素。
- en: After creating the outer XML elements, we create a Guid list to store the values
    we generate, and we also select the current SoapType with LINQ ➌ so that we can
    iterate over the parameters required for the SOAP call. As we iterate, we first
    create a new XElement for the current parameter ➍. If the parameter type is a
    string, we assign the XElement a Guid for a value using SetValue() ➎ and store
    the Guid in the Guid list we created for reference later. We then add the XElement
    to the SOAP operation element and move on to the next parameter.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了外部 XML 元素后，我们创建一个 Guid 列表来存储我们生成的值，并且我们还使用 LINQ ➌ 选择当前的 SoapType，以便可以遍历
    SOAP 调用所需的参数。在遍历时，我们首先为当前参数 ➍ 创建一个新的 XElement。如果参数类型是字符串，我们通过 SetValue() ➎ 为 XElement
    分配一个 Guid 作为值，并将该 Guid 存储在我们创建的 Guid 列表中，供后续参考。然后，我们将 XElement 添加到 SOAP 操作元素中，并继续处理下一个参数。
- en: Once we have completed adding the parameters to the SOAP operation XML node,
    we need to put the whole XML document together, as shown in [Listing 3-32](#filepos333407).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了将参数添加到 SOAP 操作 XML 节点中，就需要将整个 XML 文档组合起来，如 [Listing 3-32](#filepos333407)
    所示。
- en: XDocument soapDoc = new XDocument(new XDeclaration("1.0", "ascii", "true"),
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XDocument soapDoc = new XDocument(new XDeclaration("1.0", "ascii", "true"),
- en: new ➊XElement(soapNS + "Envelope",
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: new ➊XElement(soapNS + "Envelope",
- en: new XAttribute(XNamespace.Xmlns + "soap", soapNS),
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: new XAttribute(XNamespace.Xmlns + "soap", soapNS),
- en: new XAttribute("xmlns", xmlNS),
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: new XAttribute("xmlns", xmlNS),
- en: '➋soapBody)); Listing 3-32: Putting the whole SOAP XML document together'
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➋soapBody)); Listing 3-32: 组合整个 SOAP XML 文档'
- en: We need to create an XDocument with one more XElement called the SOAP Envelope
    ➊. We create a new XDocument by passing a new XElement to the XDocument constructor.
    The XElement, in turn, is created with a couple of attributes defining the node’s
    XML namespaces, as well as with the SOAP body we built with the parameters ➋.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个 XDocument，并添加一个名为 SOAP Envelope ➊ 的 XElement。通过将一个新的 XElement 传递给 XDocument
    构造函数，我们创建了一个新的 XDocument。该 XElement 又是通过定义节点的 XML 命名空间的几个属性以及包含我们用参数构建的 SOAP body
    ➋ 来创建的。
- en: Now that the XML is built, we can send the XML to the web server and attempt
    to induce SQL errors, as [Listing 3-33](#filepos335195) shows. Continue to add
    this code to the FuzzSoapPort() method.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 XML 已经构建完成，我们可以将 XML 发送到 Web 服务器，并尝试引发 SQL 错误，如 [Listing 3-33](#filepos335195)
    所示。继续将这段代码添加到 FuzzSoapPort() 方法中。
- en: int k = 0;
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int k = 0;
- en: foreach (Guid parm in paramList)
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (Guid parm in paramList)
- en: '{'
  id: totrans-602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string testSoap = soapDoc.ToString().➊Replace(parm.ToString(), "fd'sa");
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string testSoap = soapDoc.ToString().➊Replace(parm.ToString(), "fd'sa");
- en: byte[] data = System.Text.Encoding.ASCII.GetBytes(testSoap);
  id: totrans-604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] data = System.Text.Encoding.ASCII.GetBytes(testSoap);
- en: HttpWebRequest req = (HttpWebRequest) WebRequest.Create(_endpoint);
  id: totrans-605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest req = (HttpWebRequest) WebRequest.Create(_endpoint);
- en: req.Headers["SOAPAction"] = ➋op.SoapAction;
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.Headers["SOAPAction"] = ➋op.SoapAction;
- en: req.Method = "POST";
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.Method = "POST";
- en: req.ContentType = "text/xml";
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.ContentType = "text/xml";
- en: req.ContentLength = data.Length;
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.ContentLength = data.Length;
- en: using (Stream stream = req.GetRequestStream())
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (Stream stream = req.GetRequestStream())
- en: 'stream.➌Write(data, 0, data.Length); Listing 3-33: Creating the  HttpWebRequest  to
    send the SOAP XML to the SOAP endpoint'
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'stream.➌Write(data, 0, data.Length); Listing 3-33: 创建 HttpWebRequest 以将 SOAP
    XML 发送到 SOAP 端点'
- en: As with the fuzzers covered previously in the chapter, we iterate over each
    Guid in the list of values that we created while building the XML for the SOAP
    operation. As we iterate, we replace the current Guid in the SOAP XML body with
    a value that should induce a SQL error if that value is being used in a SQL query
    unsafely ➊. After we replace the Guid with the tainted value, we convert the resulting
    string into a byte array using the GetBytes() method, which we’ll write to the
    HTTP stream as POST data.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章前面介绍的模糊测试器类似，我们遍历在构建SOAP操作的XML时创建的值列表中的每个Guid。遍历过程中，我们将当前Guid替换为一个值，如果该值在SQL查询中使用不当，则应引发SQL错误➊。替换Guid为被污染的值后，我们使用GetBytes()方法将结果字符串转换为字节数组，并将其写入HTTP流作为POST数据。
- en: We then build the HttpWebRequest that we’ll use to make the HTTP request and
    read the result. One special piece to note is the SOAPAction header ➋. This SOAPAction
    HTTP header will be used by the SOAP endpoint to determine which action is performed
    with the data, such as listing or deleting users. We also set the HTTP method
    to POST, the content type to text/xml, and the content length to the length of
    the byte array we created. Finally, we write the data to the HTTP stream ➌. Now
    we need to read the response from the server and determine whether the data we
    sent induced any SQL errors, as [Listing 3-34](#filepos337934) shows.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们构建HttpWebRequest，用于发起HTTP请求并读取结果。需要注意的一个特殊部分是SOAPAction头➋。此SOAPAction HTTP头将由SOAP端点使用，以确定对数据执行的操作，如列出或删除用户。我们还将HTTP方法设置为POST，内容类型设置为text/xml，内容长度设置为我们创建的字节数组的长度。最后，我们将数据写入HTTP流➌。现在我们需要读取来自服务器的响应，并确定我们发送的数据是否引发了SQL错误，如[清单3-34](#filepos337934)所示。
- en: string resp = string.Empty;
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string resp = string.Empty;
- en: try
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))
- en: resp = rdr.➊ReadToEnd();
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = rdr.➊ReadToEnd();
- en: '}'
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: catch (WebException ex)
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: catch (WebException ex)
- en: '{'
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))
- en: resp = rdr.ReadToEnd();
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = rdr.ReadToEnd();
- en: ''
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (resp.➋Contains("syntax error"))
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (resp.➋Contains("syntax error"))
- en: 'Console.WriteLine("Possible SQL injection vector in parameter: ");'
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("参数中可能存在SQL注入向量：");
- en: Console.Write(type.Parameters[k].Name);
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.Write(type.Parameters[k].Name);
- en: '}'
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: k++;
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: k++;
- en: '}'
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-34: Reading the HTTP stream in the SOAP fuzzer and looking for errors'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3-34：在SOAP模糊测试器中读取HTTP流并查找错误
- en: '[Listing 3-34](#filepos337934) uses almost the same code as the fuzzers in
    Listings [3-26](#filepos313361) and [3-29](#filepos323372) to check for a SQL
    error, but in this case we’re handling the detected error differently. First,
    we declare a string to hold the HTTP response and begin a try/catch block. Then,
    within the context of a using statement, we use a StreamReader to attempt to read
    the contents of the HTTP response and store the response in a string ➊. If an
    exception is thrown because the HTTP server returned a 50x error, we catch the
    exception and try to read the response again. If an exception is thrown and the
    response data contains the phrase syntax error ➋, we print a message to alert
    the user about a possible SQL injection and the potentially vulnerable parameter
    name. Finally, we increment k and go on to the next parameter.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单3-34](#filepos337934)使用了与[清单3-26](#filepos313361)和[清单3-29](#filepos323372)中的模糊测试器几乎相同的代码来检查SQL错误，但在这种情况下，我们以不同的方式处理检测到的错误。首先，我们声明一个字符串来保存HTTP响应并开始一个try/catch块。然后，在using语句的上下文中，我们使用StreamReader尝试读取HTTP响应的内容，并将响应存储在字符串中➊。如果由于HTTP服务器返回50x错误而引发异常，我们将捕获该异常并尝试再次读取响应。如果抛出异常且响应数据包含“syntax
    error”短语➋，我们打印一条消息提醒用户可能存在SQL注入以及潜在的易受攻击的参数名。最后，我们递增k并继续处理下一个参数。'
- en: Running the Fuzzer
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 运行模糊测试器
- en: 'We can now run the fuzzer against the vulnerable SOAP service appliance CsharpVulnSoap.
    The fuzzer takes a single argument: the URL to the vulnerable SOAP endpoint. In
    this case, we’ll use [http://192.168.1.15/Vulnerable.asmx](http://192.168.1.15/Vulnerable.asmx).
    Passing the URL as the first argument and running the fuzzer should yield similar
    output to [Listing 3-35](#filepos341828).'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以针对易受攻击的SOAP服务设备CsharpVulnSoap运行模糊测试器。该模糊测试器接受一个参数：易受攻击的SOAP端点的URL。在本例中，我们将使用[http://192.168.1.15/Vulnerable.asmx](http://192.168.1.15/Vulnerable.asmx)。将URL作为第一个参数传递并运行模糊测试器，应该会得到与[清单3-35](#filepos341828)类似的输出。
- en: $ mono ch3_soap_fuzzer.exe http://192.168.1.15/Vulnerable.asmx
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ mono ch3_soap_fuzzer.exe http://192.168.1.15/Vulnerable.asmx
- en: 'Fetching the WSDL for service: http://192.168.1.15/Vulnerable.asmx'
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 获取服务的WSDL：http://192.168.1.15/Vulnerable.asmx
- en: Fetched and loaded the web service description.
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 获取并加载了Web服务描述。
- en: 'Fuzzing service: VulnerableService'
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试服务：VulnerableService
- en: 'Fuzzing soap port: ➊VulnerableServiceSoap'
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试SOAP端口：➊VulnerableServiceSoap
- en: 'Fuzzing operation: AddUser'
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试操作：AddUser
- en: 'Possible SQL injection vector in parameter: username'
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户名参数中的可能SQL注入向量
- en: 'Possible SQL injection vector in parameter: password'
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密码参数中的可能SQL注入向量
- en: --snip--
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: --省略--
- en: 'Fuzzing http port: ➋VulnerableServiceHttpGet'
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试HTTP端口：➋VulnerableServiceHttpGet
- en: 'Fuzzing operation: AddUser'
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试操作：AddUser
- en: 'Fuzzing full url: http://192.168.1.15/Vulnerable.asmx/AddUser?username=a7ee0684-'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完整的模糊测试URL：http://192.168.1.15/Vulnerable.asmx/AddUser?username=a7ee0684-
- en: fd54-41b4-b644-20b3dd8be97a&password=85303f3d-1a68-4469-bc69-478504166314
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: fd54-41b4-b644-20b3dd8be97a&password=85303f3d-1a68-4469-bc69-478504166314
- en: 'Possible SQL injection vector in parameter: username'
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户名参数中的可能SQL注入向量
- en: 'Possible SQL injection vector in parameter: password'
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密码参数中的可能SQL注入向量
- en: 'Fuzzing operation: ListUsers'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试操作：ListUsers
- en: 'Fuzzing full url: http://192.168.1.15/Vulnerable.asmx/ListUsers'
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完整的模糊测试URL：http://192.168.1.15/Vulnerable.asmx/ListUsers
- en: --snip--
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: --省略--
- en: 'Fuzzing http port: ➌VulnerableServiceHttpPost'
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试HTTP端口：➌VulnerableServiceHttpPost
- en: 'Fuzzing operation: AddUser'
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试操作：AddUser
- en: 'Possible SQL injection vector in parameter: username'
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户名参数中的可能SQL注入向量
- en: 'Possible SQL injection vector in parameter: password'
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密码参数中的可能SQL注入向量
- en: 'Fuzzing operation: ListUsers'
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试操作：ListUsers
- en: 'Fuzzing operation: GetUser'
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试操作：GetUser
- en: 'Possible SQL injection vector in parameter: username'
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户名参数中的可能SQL注入向量
- en: 'Fuzzing operation: DeleteUser'
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模糊测试操作：DeleteUser
- en: 'Possible SQL injection vector in parameter: username Listing 3-35: Partial
    output from the SOAP fuzzer running against the CsharpVulnSoap application'
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户名参数中的可能SQL注入向量 第3-35列表：针对CsharpVulnSoap应用程序运行的SOAP模糊测试器部分输出
- en: From the output, we can see the various stages of the fuzzing. Starting with
    the VulnerableServiceSoap port ➊, we find that the AddUser operation might be
    vulnerable to SQL injection in the username and password fields passed to the
    operation. Next is the VulnerableServiceHttpGet port ➋. We fuzz the same AddUser
    operation and print the URL we built, which we can paste into a web browser to
    see what the response of a successful call is. Again, the username and password
    parameters were found to be potentially vulnerable to SQL injection. Finally,
    we fuzz the VulnerableServiceHttpPost SOAP port ➌, first fuzzing the AddUser operation,
    which reports the same as the previous ports. The ListUsers operation reports
    no potential SQL injections, which makes sense because it has no parameters to
    begin with. Both the GetUser and DeleteUser operations are potentially vulnerable
    to SQL injection in the username parameter.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到模糊测试的各个阶段。从VulnerableServiceSoap端口➊开始，我们发现AddUser操作在传递给操作的用户名和密码字段中可能存在SQL注入漏洞。接下来是VulnerableServiceHttpGet端口➋。我们对相同的AddUser操作进行模糊测试，并打印出我们构建的URL，可以将其粘贴到Web浏览器中，查看成功调用后的响应。再次发现，用户名和密码参数可能容易受到SQL注入攻击。最后，我们对VulnerableServiceHttpPost
    SOAP端口➌进行模糊测试，首先对AddUser操作进行模糊测试，结果与前面几个端口相同。ListUsers操作未发现潜在的SQL注入漏洞，这也可以理解，因为它本身没有参数。GetUser和DeleteUser操作的用户名参数可能存在SQL注入漏洞。
- en: Conclusion
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you were introduced to the XML classes available from the core
    libraries. We used the XML classes to implement a full SOAP service SQL injection
    fuzzer, and we covered a few of the methods of interacting with a SOAP service.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你了解了核心库中可用的XML类。我们使用这些XML类实现了一个完整的SOAP服务SQL注入模糊测试器，并介绍了与SOAP服务交互的一些方法。
- en: The first and most simple method was via HTTP GET requests, where we built URLs
    with dynamic query string parameters based on the how the WSDL document described
    the SOAP service. Once this was implemented, we built a method to fuzz POST requests
    to the SOAP service. Finally, we wrote the method to fuzz the SOAP XML using the
    LINQ to XML libraries in C# to dynamically create the XML used to fuzz the server.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是最简单的方法是通过HTTP GET请求，我们根据WSDL文档描述的SOAP服务构建了带有动态查询字符串参数的URL。实现这一方法后，我们构建了一种方法来对SOAP服务进行POST请求的模糊测试。最后，我们编写了一个方法，使用C#中的LINQ
    to XML库动态生成用于模糊测试服务器的SOAP XML。
- en: The powerful XML classes in C# make consuming and dealing with XML a breeze.
    With so many enterprise technologies reliant on XML for cross-platform communication,
    serialization, or storage, understanding how to efficiently read and create XML
    documents on the fly can be incredibly useful, especially for a security engineer
    or pentester.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: C#中强大的XML类使得处理和使用XML变得轻松自如。由于许多企业技术依赖XML进行跨平台通信、序列化或存储，理解如何高效地读取和创建XML文档非常有用，特别是对于安全工程师或渗透测试员。
