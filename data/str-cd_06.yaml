- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: FORTH
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: FORTH
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: Forth is the quintessential minimalist programming language. Parsing Forth is
    nothing more than extracting tokens separated by whitespace. There is no interpretation
    of formulas and everything is a discrete word operating on the stack. Programs
    are a collection of functions, called *words*, that are compiled, function by
    function, to an ever expanding memory space known as the *dictionary*. Words are
    executed when encountered, or compiled to the dictionary when defined. This is
    in contrast to languages like Python, C++, or Java, which require sophisticated
    parsers and compilers and a rigid structure, and are well-abstracted from the
    hardware of the computer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 是一种典型的极简编程语言。解析 Forth 仅仅是提取由空白字符分隔的符号。没有公式的解释，一切都是在栈上操作的离散单词。程序是由称为*单词*的函数组成，这些单词被逐个编译到一个不断扩展的内存空间中，这个空间被称为*字典*。单词在遇到时执行，或者在定义时编译到字典中。这与像
    Python、C++ 或 Java 这样的语言不同，它们需要复杂的解析器和编译器，并且具有严格的结构，且与计算机硬件有很大的抽象。
- en: In this chapter, we’ll install Forth, discuss the origins and philosophy behind
    the language, and then dive into the language itself. We’ll include some examples
    along the way and end with a discussion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将安装 Forth，讨论该语言的起源和哲学，然后深入探讨语言本身。我们将一路展示一些示例，并最后进行讨论。
- en: '**Installation**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装**'
- en: Installing Forth is particularly easy.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Forth 特别简单。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Forth runs interactively. To see if our installation is working, we can type
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 是交互式运行的。为了查看我们的安装是否正常工作，我们可以输入：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Forth is quietly waiting for us to type something. Forth interprets tokens
    separated by one or more spaces. If the token is a known word, that is, a defined
    function, it is executed. If the token is a number, then it’s pushed on the stack.
    Input lines are executed when you press ENTER. Try the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 安静地等待我们输入内容。Forth 解释由一个或多个空格分隔的符号。如果符号是已知的单词，也就是已定义的函数，它会被执行。如果符号是数字，那么它会被推送到栈上。按下回车键时，输入行会被执行。尝试以下命令：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will tell Forth to move to the next line (`cr`), push 1 on the stack followed
    by 2, and then add (`+`) the 1 and the 2, leaving 3 on the stack. Next, we push
    another 3 on the stack and multiply them (`*`). Lastly, the period (`.`) prints
    the top stack value, which is now 9\. Forth signals it’s ready for more commands
    with the `ok` prompt. To exit, enter bye.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 Forth 移动到下一行（`cr`），将 1 推送到栈上，然后是 2，接着将 1 和 2 相加（`+`），结果将 3 留在栈上。接下来，我们将另一个
    3 推送到栈上，并将它们相乘（`*`）。最后，句点（`.`）打印栈顶的值，现在是 9。Forth 通过 `ok` 提示符表示它准备接受更多命令。要退出，输入
    bye。
- en: Forth uses *postfix notation*, meaning the operator comes after the operands.
    To get 1 + 2, we entered `1 2 +`. Postfix notation was developed by Jan Łukasiewicz
    in 1924 and, because of his nationality, is often known as *reverse Polish notation*
    or *RPN*. Some early desk calculators also used postfix notation. The nice thing
    about postfix is that it never requires parentheses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 使用*后缀表示法*，意味着操作符位于操作数之后。为了得到 1 + 2，我们输入了`1 2 +`。后缀表示法是由 Jan Łukasiewicz
    在 1924 年提出的，由于他的国籍，这种表示法通常被称为*逆波兰表示法*或*RPN*。一些早期的桌面计算器也使用了后缀表示法。后缀表示法的优点是它永远不需要括号。
- en: '**Origins and Philosophy**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**起源与哲学**'
- en: Forth was created by Charles “Chuck” Moore and evolved through the 1960s, coming
    of age in the early 1970s. As an interactive system in an age of punch cards,
    Forth was ahead of the curve. One of its primary uses early on was telescope control.
    Over time, Forth found its niche in small systems, though full-blown, object-oriented
    Forths appeared for personal computers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 是由 Charles “Chuck” Moore 创建的，并在 1960 年代逐渐发展，到了 1970 年代初期逐渐成熟。作为一种交互式系统，Forth
    在打孔卡片的时代走在了前面。早期的主要用途之一是天文望远镜控制。随着时间的推移，Forth 在小型系统中找到了自己的定位，尽管面向对象的 Forth 也出现了并应用于个人计算机。
- en: Forth, originally spelled FORTH, was meant as a fourth-generation programming
    language, but the assembler only allowed five-character names. So instead of “FOURTH,”
    it was “FORTH,” and later “Forth.” The term *fourth generation* dates to when
    programming languages were grouped by the vague concept of a generation. The first
    generation was machine code and the second was assembly. Languages like C were
    the third generation. And that’s where the term *generation* started to falter—most
    languages were third generation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Forth，最初拼写为 FORTH，原本是作为第四代编程语言设计的，但汇编器只允许五个字符的名称。所以，它从“FOURTH”变成了“FORTH”，后来改为“Forth”。“第四代”这一术语源于编程语言曾按代次进行分类的模糊概念。第一代是机器码，第二代是汇编语言。像
    C 这样的语言是第三代。于是，“代次”这个术语开始出现问题——大多数语言都属于第三代。
- en: Freedom to the programmer sums up Forth’s philosophy. The extreme openness of
    the language includes extending the compiler itself, which is functionality seldom
    seen in other languages. We’ll see how to do this later in the chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对程序员来说，Forth 的哲学就是自由。语言的极度开放性包括扩展编译器本身，这是其他语言中很少见的功能。我们将在本章稍后看到如何做到这一点。
- en: Forth conceives of programs as documents written in a custom language using
    words (functions) compiled into a dictionary. The dictionary stores all the words
    needed to implement the program, along with all necessary data. Each new word
    or block of data is added to the end of the dictionary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 将程序看作是用自定义语言编写的文档，使用的“词汇”（函数）会被编译进字典中。字典存储实现程序所需的所有词汇以及所有必要的数据。每个新的词汇或数据块都会被添加到字典的末尾。
- en: 'Historically, the Forth community frowned upon code reuse. Building a library
    for later use was deemed a recipe for disaster. The modern approach of pulling
    pieces from many different libraries of pre-built code, like the standard modules
    of Python or the standard template library of C++, was alien to Forth and considered
    distasteful. A “good” Forth programmer developed the appropriate set of words
    to implement the specified task: no more and no less. If done well, the code itself
    reads much like a document. Good Forth is self documenting.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，Forth 社区对代码重用持反对态度。为了以后使用而构建一个库被认为是灾难的根源。像 Python 的标准模块或 C++ 的标准模板库这样从多个不同的预构建代码库中提取组件的现代做法，在
    Forth 中是陌生的，甚至被认为不受欢迎。“好的” Forth 程序员会开发出适合特定任务的词汇集：不多也不少。如果做得好，代码本身看起来就像一份文档。好的
    Forth 代码是自文档化的。
- en: 'I ran across an email signature many moons ago, source long lost, that read:
    “C makes you think it is the best programming language in the world. Forth makes
    you think you are the best programmer in the world.” This captures the philosophy
    of Forth quite nicely. Instead of only using what the language designers gave,
    the Forth programmer manipulates the raw material of Forth, turning it into the
    ideal language for the task at hand.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，我看到过一条电子邮件签名，来源已经无法追溯，内容是：“C 让你觉得它是世界上最好的编程语言。Forth 让你觉得你是世界上最棒的程序员。”这句话很好地捕捉了
    Forth 的哲学。Forth 程序员不仅仅使用语言设计者提供的功能，而是操作 Forth 的原始材料，将其转化为适合当前任务的理想语言。
- en: '**The Language**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**语言**'
- en: Forth is, in essence, a system and not simply a compiler or interpreter. Early
    Forths *were* the operating system. They accessed disks in 1024-byte blocks—there
    was no filesystem—and they compiled code from those blocks. There is a top-level
    *REPL* (read, evaluate, print, loop) that, by convention, uses `ok` as the prompt.
    Forth programs are a sequence of tokens separated by whitespace. In most Forths,
    any combination of characters, excluding space, tab, and newline, is a valid token.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 本质上是一个系统，而不仅仅是一个编译器或解释器。早期的 Forth *本身* 就是操作系统。它们以 1024 字节为单位访问磁盘——当时没有文件系统——并从这些块中编译代码。它有一个顶层的
    *REPL*（读取、求值、打印、循环），按照约定，使用 `ok` 作为提示符。Forth 程序是由由空格分隔的令牌组成的序列。在大多数 Forth 中，任何字符组合（除了空格、制表符和换行符）都是有效的令牌。
- en: Tokens are evaluated as encountered. If the token is found in the dictionary,
    it is executed. If the token is not in the dictionary, Forth tries to interpret
    it as a number. If Forth fails at this, Forth throws an error message and returns
    to the `ok` prompt.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌会在遇到时进行求值。如果令牌在字典中找到，它就会被执行。如果令牌不在字典中，Forth 会尝试将其解释为数字。如果 Forth 无法做到这一点，它会抛出错误信息并返回
    `ok` 提示符。
- en: Executing a word when encountered makes sense. But what does Forth do with numbers?
    Forth pushes them on the *stack*. All operations use the stack, either pulling
    arguments from or pushing results onto the stack. Tokens interpreted as numbers
    are pushed onto the stack. Words often pull values from the stack, operate on
    them, and push new values onto the stack.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到一个词时，执行它是很有意义的。但是 Forth 如何处理数字呢？Forth 会将数字推入*栈中*。所有操作都使用栈，要么从栈中取出参数，要么将结果推入栈中。被解释为数字的标记会被推入栈中。词汇通常从栈中取值，对其进行操作，并将新的值推入栈中。
- en: The stack is central to Forth and several of the esolangs we’ll encounter later
    in the book, so let’s spend a bit of time understanding what a stack is and how
    to work with one.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是 Forth 语言以及本书后面将涉及的几种 esolang（自造语言）的核心部分，因此让我们花点时间了解栈是什么，以及如何操作它。
- en: '***Understanding the Stack***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解栈***'
- en: Stacks are basic computer science data structures, often referred to as *last
    in, first out*, or *LIFO*, data structures. They are the opposite of a queue,
    which is a *first in, first out*, or *FIFO*, data structure. I think of the stack
    of trays at a buffet. When trays are put on the stack, the first tray is set down,
    then the second, then the third, and so on. When someone takes a tray, they don’t
    take the first tray; they take the last one put on the stack. In contrast, the
    first thing out of the queue is the first thing put into it, not the last.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是计算机科学中的基础数据结构，通常被称为*后进先出*（*LIFO*）数据结构。它们与队列相对，队列是*先进先出*（*FIFO*）的数据结构。我把它想象成自助餐中的盘子堆。当盘子放到栈上时，第一个盘子先放下，接着是第二个，再是第三个，以此类推。当有人拿盘子时，他们拿的不是第一个盘子，而是最后放上的那个盘子。与此相反，队列中最先放入的物品会是最先拿出的，而不是最后一个。
- en: Most programming languages use stacks. An example is the return stack for function
    calls. Forth uses a stack for data and, as we’ll see below, a separate one for
    returning from function calls. It’s the data stack that Forth programmers use
    most frequently, though they can temporarily use the return stack with care.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都使用栈。一个例子是函数调用的返回栈。Forth 使用一个栈来存储数据，正如我们下面将看到的，另有一个独立的栈用于函数调用的返回。数据栈是
    Forth 程序员最常用的栈，尽管他们也可以在必要时小心地使用返回栈。
- en: '[Figure 4-1](ch04.xhtml#ch04fig1) illustrates the operation of the stack.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](ch04.xhtml#ch04fig1) 说明了栈的操作。'
- en: '![Image](Images/04fig01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/04fig01.jpg)'
- en: '*Figure 4-1: Pushing values on the Forth stack (top), and popping values off
    (bottom)*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：将值推入 Forth 栈（上图），以及从栈中弹出值（下图）*'
- en: Let’s walk through [Figure 4-1](ch04.xhtml#ch04fig1), beginning with the top
    row going from left to right. We have three values—1, 2, and 3—and an empty stack.
    Next, we *push* 1 on the stack. The top item on the stack is marked with an arrow.
    Then we push 2 on the stack, which is now on top of 1 and is thus the new top
    stack item. Lastly, we push 3 on the stack, making it the top stack item.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照从左到右的顺序，逐步分析 [图 4-1](ch04.xhtml#ch04fig1)。我们有三个值——1、2 和 3——以及一个空栈。接下来，我们将
    1 推入栈中。栈顶的元素用箭头标示。然后我们将 2 推入栈中，2 此时位于 1 之上，成为新的栈顶元素。最后，我们将 3 推入栈中，使其成为栈顶元素。
- en: To remove items from the stack, we *pop* them. This is shown in the bottom row
    of [Figure 4-1](ch04.xhtml#ch04fig1). Again, moving from left to right, we pop
    the stack to get 3\. Notice that 3 was the *last* item pushed onto the stack,
    so it is the first item popped off of the stack. We then pop the stack again to
    get 2, and pop one last time to get 1, leaving the stack empty. Attempting to
    pop an empty stack is a common Forth error. You’ll make it yourself, eventually.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要从栈中移除元素，我们将它们弹出。下图 [图 4-1](ch04.xhtml#ch04fig1) 展示了这一过程。同样，从左到右，我们首先弹出栈顶的 3。注意，3
    是*最后*推入栈中的元素，因此它是第一个被弹出的元素。接着，我们再次弹出栈顶的 2，再弹出 1，最终栈变为空。当你尝试弹出一个空栈时，会出现 Forth 中常见的错误。最终你也会遇到这个问题。
- en: '***Using the Stack***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用栈***'
- en: Manipulating the stack is perhaps the most frustrating part of Forth. However,
    Forth comes with many intrinsic words to help you control the stack. Let’s introduce
    some of them and see how they work. We’ll start with a simple example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 操作栈可能是 Forth 中最令人头疼的部分。然而，Forth 提供了许多内建的词汇来帮助你控制栈。我们将介绍其中的一些，并看看它们是如何工作的。我们从一个简单的例子开始。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we push 1, then 2, then 3 on the stack. To pop the stack and print the
    popped value, use a period (`.`). Doing so gives us 3, the last item pushed on
    the stack. Popping and printing the stack two more times gives us 2 and then 1,
    leaving the stack empty. To exit Forth, enter bye. Forth is case insensitive,
    so `BYE` works just as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将1、2、3依次推入栈中。要弹出栈并打印弹出的值，使用句点（`.`）。这样会得到3，这是最后一个推入栈的元素。再弹出栈并打印两次，得到2和1，栈最终为空。要退出
    Forth，可以输入 bye。Forth 是不区分大小写的，所以输入`BYE`也同样有效。
- en: '[Table 4-1](ch04.xhtml#ch04tab1) introduces several words and an essential
    Forth convention.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-1](ch04.xhtml#ch04tab1)介绍了几个词汇和 Forth 的一个基本约定。'
- en: '**Table 4-1:** Stack Manipulation Words'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-1：** 栈操作命令'
- en: '| **Word** | **Effect** | **Description** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **单词** | **效果** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `dup` | `( a -- a a )` | Duplicate the top stack item |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `dup` | `( a -- a a )` | 复制栈顶元素 |'
- en: '| `drop` | `( a b -- a )` | Drop the top of stack item |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `drop` | `( a b -- a )` | 移除栈顶元素 |'
- en: '| `swap` | `( a b -- b a )` | Swap the top two stack items |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `swap` | `( a b -- b a )` | 交换栈顶两个元素 |'
- en: '| `2dup` | `( a b -- a b a b )` | Duplicate the top two stack items |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `2dup` | `( a b -- a b a b )` | 复制栈顶两个元素 |'
- en: '| `2drop` | `( a b c -- a )` | Drop the top two stack items |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `2drop` | `( a b c -- a )` | 移除栈顶两个元素 |'
- en: '| `over` | `( a b -- a b a )` | Copy the next to top of stack item |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `over` | `( a b -- a b a )` | 将栈顶元素复制到次顶端 |'
- en: '| `rot` | `( a b c -- b c a )` | Rotate the top three stack items |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `rot` | `( a b c -- b c a )` | 旋转栈顶三个元素 |'
- en: '| `nip` | `( a b c -- a c )` | Drop the next to top of stack item |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `nip` | `( a b c -- a c )` | 移除次顶端栈元素 |'
- en: '| `.s` | `( -- )` | Print the stack without altering it |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `.s` | `( -- )` | 打印栈而不改变它 |'
- en: The words are somewhat descriptive, and Forth is case insensitive, but the Effect
    column is important. The Effect column contains *stack-effect comments*, which
    we’ll describe below. Forth comments begin with a left parenthesis, `(`, and end
    with a right parenthesis, `)`. Note that a space after the `(` is required. Forth
    ignores anything after `(` until the first `)`. Comments may not be nested. Many
    Forth systems, including ours, use `\` as a comment running to the end of the
    line, like `//` in C++.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些词汇在某种程度上是描述性的，并且 Forth 是不区分大小写的，但效果列非常重要。效果列包含了*栈效应注释*，我们将在下文中描述。Forth 注释以左括号`(`开始，以右括号`)`结束。请注意，`(`后需要一个空格。Forth
    会忽略`(`之后的所有内容，直到第一个`)`为止。注释不能嵌套。许多 Forth 系统，包括我们使用的系统，使用`\`作为行尾注释符号，类似于 C++ 中的`//`。
- en: The comment itself illustrates how the word affects the stack. On the left is
    the stack as the word expects it with the top stack item on the right, next to
    the dashes. On the right of the dashes is the stack as the word leaves it, again
    with the top stack item on the right. There are conventions for the characters
    used, though they are more like guidelines than actual rules.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注释本身说明了该命令如何影响栈。左边是命令期望的栈状态，栈顶元素位于右边，紧挨着短横线。短横线右边是该命令执行后栈的状态，栈顶元素同样位于右边。对于这些字符的使用有一些约定，但它们更像是指南，而非硬性规则。
- en: For example, `dup` duplicates the top stack item, so `a` becomes `a a`. If the
    word does not affect the stack, the empty `( -- )` comment is used. By convention,
    every word definition has a stack-effect comment after its name, much like the
    convention of adding a documentation string after the definition of a function
    in Python.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`dup`命令会复制栈顶元素，因此`a`变为`a a`。如果命令不影响栈，使用空的`( -- )`注释。按照约定，每个命令定义后都有一个栈效应注释，就像在
    Python 中为函数定义添加文档字符串一样。
- en: '[Table 4-1](ch04.xhtml#ch04tab1) includes the word `.s` to print the contents
    of the stack without changing it. As you work with Forth, especially when getting
    a feel for the stack words, you’ll use `.s` often. It’s a good idea to use it
    to check that your words are not leaving extra junk on the stack.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-1](ch04.xhtml#ch04tab1)包含了`.s`这个命令，用来打印栈的内容而不改变栈的状态。当你使用 Forth 时，特别是在熟悉栈命令时，你会经常使用`.s`。最好使用它来检查你的命令是否没有在栈上留下多余的内容。'
- en: Let’s explore the stack some more.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再多了解一下栈。
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The example above ends by calling `2drop` to remove the remaining two stack
    items, which is why `.s` shows no items on the stack (`<0>`). Work with the stack
    until you feel comfortable with the stack manipulation words.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例通过调用`2drop`来移除剩余的两个栈项，这就是为什么`.s`显示栈中没有项（`<0>`）。在你熟悉栈操作命令之前，可以多多练习栈的操作。
- en: 'All Forth systems support integer arithmetic using the expected operators:
    addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), and modulo
    (`mod`). Many Forth systems, including gforth, work with floating-point numbers
    as well.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Forth 系统都支持使用常见的运算符进行整数运算：加法（`+`）、减法（`-`）、乘法（`*`）、除法（`/`）和取模（`mod`）。许多 Forth
    系统，包括 gforth，也支持浮点数运算。
- en: 'As practice, you might try implementing the following expressions using the
    standard arithmetic words:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以尝试使用标准算术运算词汇实现以下表达式：
- en: '| (1200 × 3) ÷ 4 | (ans: 900) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| (1200 × 3) ÷ 4 | （答案：900） |'
- en: '| 8 × (127 *–* 9) ÷ 11 | (ans: 85) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 8 × (127 *–* 9) ÷ 11 | （答案：85） |'
- en: '| 8 × (127 *–* 9) mod 11 | (ans: 9) |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 8 × (127 *–* 9) mod 11 | （答案：9） |'
- en: '| ((33 *–* 45) ÷ (7 + 9)) × 3 | (ans: -3) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| ((33 *–* 45) ÷ (7 + 9)) × 3 | （答案：-3） |'
- en: 'You’ll need to convert the expressions into postfix, meaning instead of *a*
    + *b* you’ll write *a* *b* +, and so on. Leave subexpression values on the stack
    and combine them with operations later: (*a* + *b*) × (*c* + *d*) becomes *a*
    *b* + *c* *d* + ×.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将表达式转换为后缀表达式，意味着你不再写 *a* + *b*，而是写 *a* *b* +，以此类推。将子表达式的值保留在栈上，稍后与操作符结合：(*a*
    + *b*) × (*c* + *d*) 变为 *a* *b* + *c* *d* + ×。
- en: 'To use floating-point with gforth, you must do two things. First, enter floating-point
    constants using scientific notation. So to push 3.1415 on the floating-point stack,
    separate from the data stack, which is integer only, use `3.1415e0`. For example,
    to calculate 1/1,121 using first integer then floating-point math, enter the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 gforth 中使用浮点数，您需要做两件事。首先，使用科学计数法输入浮点常量。比如要将 3.1415 推入浮点栈（与数据栈分开，数据栈仅支持整数），使用
    `3.1415e0`。例如，要计算 1/1,121，可以先进行整数运算再进行浮点运算，输入如下：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For simplicity, we’ll stick with integer operations for the remainder of this
    chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，接下来我们将继续使用整数运算。
- en: '**FORTHS NOT FORTH**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**FORTHS 不是 Forth**'
- en: You’ve likely noticed by now that I’ve referred several times to “Forths” instead
    of just “Forth.” There is a reason for that. The “freedom to the programmer” philosophy
    extends to Forth itself. Excluding the minor differences between versions, there
    is only one Python. Similarly, C++ is C++ and Java is Java. In contrast, there
    are, or were, legions of Forths. Most are now forgotten or virtually unusable
    because the computers they were written for are long gone. For example, few have
    ever heard of QForth for the Apple II, let alone the Jupiter ACE, the only 1980s-era
    personal computer to run Forth instead of BASIC. Because of this proliferation
    of Forth systems, what works nicely on one Forth implementation often fails on
    another. In 1994, ANSI standard Forth was defined (see ANSI X3.215-1994). Gforth
    follows this standard; however, the standard seems to have had little effect overall,
    as there are many homegrown Forth systems still in existence, most of which are
    non-standard and often highly customized.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我多次提到“Forths”而不是单单“Forth”。这有原因。所谓“赋予程序员自由”的哲学也延伸到了 Forth 本身。除了各版本之间的细微差异外，Python
    只有一个版本。类似地，C++ 就是 C++，Java 就是 Java。相比之下，Forth 有很多变种。大多数现在已经被遗忘或几乎无法使用，因为它们最初运行的计算机早已不存在。例如，几乎没人听说过
    Apple II 上的 QForth，更不用说 Jupiter ACE——这是唯一一台在 1980 年代运行 Forth 而不是 BASIC 的个人计算机。由于
    Forth 系统的泛滥，某个 Forth 实现上运行良好的程序在另一个实现上往往无法正常工作。1994 年，ANSI 标准 Forth 被定义（参见 ANSI
    X3.215-1994）。Gforth 遵循该标准；然而，这个标准似乎总体上影响不大，因为仍有许多本土的 Forth 系统存在，其中大多数是非标准的，并且通常经过高度定制。
- en: Now let’s learn how to define our own Forth words.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们学习如何定义我们自己的 Forth 词汇。
- en: '***Words and Loops***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***词汇和循环***'
- en: “Hello, world!” in Forth is
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 中的“Hello, world!”是
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we’ve defined our own word to print `Hello, world!`. Word definitions
    begin with a colon (`:`), followed by the name of the word, which in this case
    is `hi`. Next comes the stack-effect comment, which isn’t required, but strongly
    encouraged.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了自己的词汇来打印 `Hello, world!`。词汇定义以冒号（`:`）开始，后跟词汇名称，在本例中为 `hi`。接下来是栈效应注释，虽然不是必需的，但强烈建议添加。
- en: 'The word `hi` consumes nothing from the stack and leaves nothing on the stack,
    so the comment is empty: `( -- )`. The next token is `."` which begins compiling
    a string to print. Don’t forget the space after `."`; it’s required. The string
    ends with a double quote (`"`), followed by `cr` to move to the next line. The
    definition ends with a semicolon (`;`). We just defined our first word. To use
    it, enter hi at the `ok` prompt. Not too exciting, but it’s a start.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 单词`hi`不会消耗栈中的任何内容，也不会在栈上留下任何东西，因此注释是空的：`( -- )`。下一个标记是`."`，它开始编译一个要打印的字符串。不要忘记`."`后面的空格；这是必须的。字符串以双引号（`"`）结束，接着是`cr`，表示换行。定义以分号（`;`）结束。我们刚刚定义了我们的第一个单词。要使用它，只需在`ok`提示符下输入hi。虽然不太激动人心，但这是一个开始。
- en: 'What if we are feeling particularly happy today and want to greet the world
    repeatedly? That’s easy to do as well. We just need a word that knows how to say
    `hi` many times:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果今天我们特别高兴，想要反复向世界问好呢？这也很容易做到。我们只需要一个知道如何多次说`hi`的单词：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The new word, `hello`, uses a `do` loop. This is Forth’s version of a `for`
    loop, and may only be used within a word definition.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 新的单词`hello`使用了一个`do`循环。这是Forth的`for`循环版本，只能在单词定义内使用。
- en: The general form of a `do` loop is
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`循环的一般形式是'
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the ending and starting values are on the stack, with the ending value
    first, then the starting value, followed by the word `do`, the body of the loop,
    and the word `loop` to end the loop. Why so convoluted? It has to do with how
    Forth works. Comments about Forth being the exposed core of a compiler aren’t
    all that far from the truth. The words `do` and `loop` are not keywords, but rather
    words that execute immediately when encountered by Forth. Their action sets up
    the code to make the loop. All of Forth’s flow control words operate this way.
    The core Forth compiling words are no different from those a programmer might
    create, which is why the Forth compiler can be extended on the fly if desired.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结束值和起始值都位于栈上，结束值在前，然后是起始值，接着是单词`do`，接着是循环体，最后是单词`loop`来结束循环。为什么这么复杂？这与Forth的工作原理有关。关于Forth是编译器暴露的核心部分的评论，离真相并不远。单词`do`和`loop`并不是关键字，而是Forth遇到时立即执行的单词。它们的作用是设置代码以形成循环。Forth的所有流程控制单词都是这种方式运作的。Forth的核心编译单词与程序员可能创建的单词没有什么不同，这也是为什么Forth编译器可以根据需要实时扩展的原因。
- en: Some Forth systems, especially those implemented in C, define most of Forth
    in Forth using a small core set of words to build the rest of the system. For
    example, `lbForth` (*[https://gist.github.com/lbruder/10007431/](https://gist.github.com/lbruder/10007431/)*)
    is one such C-based Forth in the public domain. Here’s how it defines `do` and
    `loop` in terms of other Forth words.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Forth系统，尤其是那些用C语言实现的，使用一个小的核心单词集来定义大部分Forth，以构建系统的其余部分。例如，`lbForth`（*[https://gist.github.com/lbruder/10007431/](https://gist.github.com/lbruder/10007431/)）就是一个基于C的公共领域Forth。下面是它如何通过其他Forth单词来定义`do`和`loop`。
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Many of the words in these definitions will not make sense right now, but they
    will over time if you continue to work with Forth. The `immediate` tag after `;`
    marks the word to make sure it is executed when encountered, even when defining
    another word. Also, the single quote (`'`) takes the next token, looks up its
    execution address in the dictionary, and places that address on the stack. The
    comma (`,`) adds the top-of-stack number to the end of the dictionary, which in
    this case is the address of the word before it. The word `here` places the address
    of the end of the dictionary on the stack. Thus, `do`’s net effect is to put the
    current end of the dictionary address on the stack and then compile references
    to order and store the loop limits that are already on the stack on the return
    stack. That’s `swap >r >r`. I mentioned above that the return stack, which holds
    the address of where to go after the current word ends, is available to programmers
    if they are careful and remove anything they place on it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义中的许多单词现在可能不太容易理解，但如果你继续使用Forth，它们会随着时间变得更清晰。`immediate`标签在`;`之后标记单词，以确保在遇到时立即执行，即使是在定义其他单词时。另一个，单引号（`'`）获取下一个标记，在字典中查找其执行地址，并将该地址放入栈中。逗号（`,`）将栈顶的数字添加到字典的末尾，在这种情况下是前一个单词的地址。单词`here`将字典末尾的地址放入栈中。因此，`do`的净效应是将当前字典末尾地址放入栈中，然后编译引用以按照顺序存储已在栈上的循环限制，并存储到返回栈上。这就是`swap
    >r >r`。我在上面提到过，返回栈用于保存当前单词结束后要跳转的地址，程序员如果小心，移除他们放置在上面的任何内容，就可以使用返回栈。
- en: Notice how `loop` pulls the limits from the return stack with `r>` and orders
    them, after which it increments the lower limit and compares it with the upper
    limit. If the limits are not equal, a branch back to the initial starting address
    placed on the stack by `do` happens courtesy of `0branch`. The number of bytes
    to branch backward is calculated with `here @ -`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `loop` 如何通过 `r>` 从返回栈中拉取限制值并排序，然后它会增加下限并与上限进行比较。如果限制值不相等，`0branch` 会通过栈中由
    `do` 放置的初始起始地址跳转回去。计算回跳所需的字节数通过 `here @ -` 来实现。
- en: A firm understanding of how these words operate isn’t required. I’ve only highlighted
    them so we notice how even the compiler itself is Forth. The openness that allows
    flow control words like `do` and `loop` to be implemented in Forth is available
    to all Forth programmers. I know of no other programming language that is so open
    in this way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些词语的操作理解并非必需。我之所以提到它们，是为了让我们注意到甚至编译器本身也是 Forth。Forth 所允许的像 `do` 和 `loop` 这样的流程控制词语的开放性是所有
    Forth 程序员都可以使用的。我不知道其他编程语言能像这样开放。
- en: 'The loop of `hello` above ran 10 times even though the limits were 0 and 10\.
    This is because the upper limit is not included, making the `do` loop act like
    a C `for` loop:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上面 `hello` 的循环执行了10次，即使限制是0到10。这是因为上限不包括在内，使得 `do` 循环像 C 语言中的 `for` 循环一样。
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The C code above used `i` as the loop counter. In Forth, the word `i` supplies
    the loop counter. Consider the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上面 C 代码使用 `i` 作为循环计数器。在 Forth 中，词语 `i` 提供了循环计数器。请看以下示例：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, note that `do` uses `i` to access the current value of the
    loop counter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，注意 `do` 使用 `i` 来访问当前的循环计数器值。
- en: There are times when incrementing by one isn’t sufficient. Forth uses `+loop`
    in those cases, with the increment on the stack. The following example counts
    by threes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时单纯增加1并不够。在这种情况下，Forth 使用 `+loop`，其中增量值在栈上。以下示例每次增加3。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is also possible to use the index as the increment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用索引作为增量。
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Nested `do` loops are allowed. Use `i` to access the counter of the inner-most
    loop and `j` to access the counter of the next outer loop.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 允许嵌套 `do` 循环。使用 `i` 来访问最内层循环的计数器，使用 `j` 来访问下一个外层循环的计数器。
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, `i` refers to the counter of the inner loop and `j` the outer.
    The word `space` prints a blank, as you likely surmised from the output. Note
    that we’re writing the double loop in one line for simplicity. Forth is quite
    happy if you split up the code in a way that is easier to read.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`i` 代表内循环的计数器，`j` 代表外循环的计数器。`space` 打印一个空白，正如你从输出中可能已经推测出来的那样。注意，我们将双重循环写在一行中，以简化代码。如果你将代码拆分成更易读的格式，Forth
    也完全没有问题。
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s experiment a bit more with `i` and `j`. Consider the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做些实验，看看 `i` 和 `j` 的效果。请看以下示例：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Look at the definition of `nested1`. There are two `do` loops here. The first
    loop goes from 1 up to, but not including, 5\. The inner loop runs from 0 up to,
    but not including, the current value of `i`. The output reflects the counter of
    the outer loop and runs the inner loop that many times: first once, then twice,
    then three times, and so on, each time printing the value of the outer loop because
    of `j`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 `nested1` 的定义。这里有两个 `do` 循环。第一个循环从1开始，一直到5，但不包括5。内循环从0开始，一直到当前 `i` 的值（不包括当前值）。输出反映了外循环的计数器，并运行那么多次内循环：第一次执行一次，然后两次，接着三次，依此类推，每次都会打印外循环的值（即
    `j`）。
- en: Now, look at `nested2`. In this case, the inner loop references `i`, which is
    the counter of the inner loop. Therefore, the first pass of the outer loop sets
    `i` to 1, causing the inner loop to iterate one time from 0\. This explains the
    first 0\. On the next pass, `i` is 2 in the outer loop, thereby causing the inner
    loop to run twice. The inner loop then references `i` as well; however, this time,
    the second `i` refers to the *inner* loop counter, which is why the output, on
    separate lines, is
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下 `nested2`。在这种情况下，内循环引用 `i`，即内循环的计数器。因此，外循环的第一次迭代将 `i` 设置为1，从而使内循环从0开始执行一次。这也就解释了第一个0。下一次迭代时，外循环的
    `i` 为2，导致内循环执行两次。内循环此时也会引用 `i`；然而，这时第二个 `i` 是指*内*循环的计数器，这也是为什么输出会分成两行的原因。
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What if you have three or more nested loops? How do you get the outer-most counter?
    There is no Forth word for that, so you’d need to stash the counter with `i` before
    starting the next two nested loops and access it that way. You can either leave
    it on the stack, push it to the return stack, or dump it to a variable and reference
    it when needed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三个或更多嵌套的循环怎么办？如何获得最外层的计数器？Forth 没有这个单词，因此你需要在开始下一个嵌套循环之前使用 `i` 保存计数器，并以此方式访问它。你可以将它留在堆栈上，推送到返回堆栈，或将其转存到变量中，并在需要时引用它。
- en: '***What Is Truth?***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***什么是真理？***'
- en: Forth is unusual, so it should come as no surprise that Forth’s definition of
    truth is unusual as well. In most languages, if there is no explicit Boolean data
    type, like `False` and `True` in Python, 0 is false and 1 (or not 0) is true.
    In Forth, false is 0, but true is *–*1\. Forth also supports the usual comparison
    operators such as `<` and `>`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 是不寻常的，因此 Forth 对真理的定义也不寻常也就不足为奇了。在大多数语言中，如果没有显式的布尔数据类型（如 Python 中的 `False`
    和 `True`），0 是假，1（或非0）是真。而在 Forth 中，假是 0，真是 *–*1。Forth 还支持通常的比较运算符，如 `<` 和 `>`。
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The above tells us that 1 < 2, *–* 123 < 321, and 45 > 3 but not 3 > 45.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容告诉我们 1 < 2，*–* 123 < 321，45 > 3，但不是 3 > 45。
- en: To test for equal and not equal, use `=` and `<>`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试是否相等或不相等，可以使用 `=` 和 `<>`。
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Forth works with both signed and unsigned integers, but the comparison operators
    above work only with signed integers. However, Forth also supports unsigned versions,
    indicated with a letter `u` before the operator.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 支持有符号和无符号整数，但上面的比较运算符仅适用于有符号整数。不过，Forth 也支持无符号版本，运算符前会加上字母 `u`。
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first result makes sense, but the second might not; however, it is correct.
    The unsigned comparison looks only at the bit pattern representing *–*123\. In
    two’s complement format, assuming 16-bit integers even though our Forth system
    uses 64-bit integers, the bit pattern for *–*123 is 1111111110000101 whereas the
    bit pattern for 321 is 0000000101000001\. This means that *–*123 is greater than
    321 when using an unsigned comparison.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个结果是有道理的，但第二个可能不太直观；然而，它是正确的。无符号比较只看代表 *–*123 的位模式。在二进制补码格式中，假设使用的是 16 位整数，尽管我们的
    Forth 系统使用的是 64 位整数，*–*123 的位模式是 1111111110000101，而 321 的位模式是 0000000101000001。这意味着，使用无符号比较时，*–*123
    大于 321。
- en: Forth wouldn’t be of much use without some form of conditional expression. Thankfully,
    it supports `if`, `else`, and `then`. The general format for a conditional expression
    is
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有某种形式的条件表达式，Forth 的用处就不大了。幸运的是，它支持 `if`、`else` 和 `then`。条件表达式的一般格式是：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `<condition>` is a condition flag on the stack, with 0 indicating false
    and *–*1 indicating true. If true, the words in `<true_instructions>` are executed.
    If there is an `else` and the condition is false, the words in `<false_instructions>`
    are executed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<condition>` 是堆栈上的条件标志，0 表示假，*–*1 表示真。如果为真，`<true_instructions>` 中的指令会被执行。如果有
    `else` 且条件为假，则会执行 `<false_instructions>` 中的指令。
- en: 'For example, Goldilocks might want to know something about the state of the
    bowl of porridge she’s just stumbled upon based on its temperature. In Python,
    she might write the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，金发姑娘可能想根据粥碗的温度了解它的状态。在 Python 中，她可能会写出以下代码：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In Forth, she might write what’s shown in [Listing 4-1](ch04.xhtml#ch04list1).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Forth 中，她可能会写出 [Listing 4-1](ch04.xhtml#ch04list1) 中显示的内容。
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 4-1: Too cold, too hot, or just right*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-1: 太冷，太热，还是刚刚好*'
- en: 'She’d then test her Forth code like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，她会像这样测试她的 Forth 代码：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let’s walk through the example in [Listing 4-1](ch04.xhtml#ch04list1). The word
    `porridge` expects a number on the stack, which in this case is the porridge’s
    temperature in degrees Fahrenheit. With the temperature still on the stack, `porridge`
    prints the first part of the output sentence. Note that there is no `cr`, so by
    default, the output does not move to the next line.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 [Listing 4-1](ch04.xhtml#ch04list1) 中的示例。单词 `porridge` 期望堆栈上有一个数字，在此案例中是粥的温度（以华氏度为单位）。在温度仍然在堆栈上时，`porridge`
    会打印输出句子的第一部分。请注意，这里没有 `cr`，因此默认情况下输出不会换行。
- en: Next comes the set of nested `if` statements. Let’s start with the first one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是嵌套的 `if` 语句。我们从第一个开始。
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The word `dup` duplicates the temperature. This is necessary, as `<` will consume
    it along with 90 to test *n* < 90\. The result, either 0 or *–*1, is then pushed
    onto the stack. The value is consumed in this test, so if the first `if` fails,
    the nested second `if` will need a copy of *n* for its test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 词`dup`复制温度。这是必要的，因为`<`会将它与 90 一起消耗掉，用于测试 *n* 是否小于 90。结果，0 或 *–*1 会被推入栈中。该值在此测试中被消耗掉，因此如果第一个`if`失败，嵌套的第二个`if`就需要一个
    *n* 的副本来进行测试。
- en: 'At this point, the stack contains *n* and the output of `<`. Next, `if` consumes
    the 0 or *–*1\. If –1, `porridge` prints the rest of the sentence: too cold. What’s
    the `drop` doing there? Because *n* was duplicated to preserve it in case the
    first `if` failed, it’s still on the stack. Therefore, it must be dropped before
    `porridge` exits.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，栈中包含 *n* 和`<`的输出。接下来，`if`消耗 0 或 *–*1。如果是-1，`porridge`会打印出剩下的句子：太冷。`drop`在那里干什么呢？因为
    *n* 被复制了以防第一个`if`失败，它仍然在栈上。因此，必须在`porridge`退出前将其丢弃。
- en: The second `if` is like the first; it checks to see if *n* is less than 100\.
    If so, the porridge is just right; otherwise, it’s too hot. Note that there is
    no `dup` before the second `if` as *n* is not needed after the comparison, so
    it’s consumed by `<`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`if`与第一个类似；它检查 *n* 是否小于 100。如果是，粥就刚好；否则，粥太热。注意，第二个`if`前没有`dup`，因为比较后不再需要
    *n*，所以它被 `<` 消耗掉了。
- en: The way [Listing 4-1](ch04.xhtml#ch04list1) is written follows classic Forth
    convention. As mentioned, early Forths accessed disks in 1024-byte blocks, so
    writing compact code was essential. The Forth editor split the 1024 bytes of a
    block, a *screen*, into 16 lines of 64 characters each.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-1](ch04.xhtml#ch04list1)的写法遵循经典的 Forth 习惯。如前所述，早期的 Forth 系统以 1024 字节为单位访问磁盘，因此编写紧凑的代码非常重要。Forth
    编辑器将一个 1024 字节的块，一个*屏幕*，分为 16 行，每行 64 个字符。'
- en: Modern Forth is more flexible. The following code works just as well as [Listing
    4-1](ch04.xhtml#ch04list1).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 Forth 更加灵活。以下代码与[清单 4-1](ch04.xhtml#ch04list1)一样有效。
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Some Forth systems, including gforth, support a `case` selection structure that
    mirrors `switch` in C. For example, in a menu-driven program, the proper action
    to take depends on which option the user selects—a natural place to use `case`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Forth 系统，包括 gforth，支持一种与 C 中的 `switch` 相似的`case`选择结构。例如，在一个菜单驱动程序中，采取的适当行动取决于用户选择了哪个选项——这是使用`case`的自然场所。
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that `case` expects the option to be on the stack when the word is executed.
    Forth then searches through the cases looking for a match. If a match is found,
    Forth executes the case’s body, which consists of the words between `of` and `endof`.
    If no case matches, Forth can use a default case (“bad option”).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`case`期望在执行时选项已在栈上。Forth 然后遍历各个情况，寻找匹配项。如果找到匹配，Forth 执行该情况的主体，主体是介于`of`和`endof`之间的词。如果没有匹配的情况，Forth
    可以使用默认情况（“错误选项”）。
- en: '***Other Control Structures***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他控制结构***'
- en: Forth’s remaining control structures include a top-tested loop, a bottom-tested
    loop, and an infinite loop.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 的剩余控制结构包括顶部测试循环、底部测试循环和无限循环。
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first two are similar to `while` and `do-while` in C, but the last one
    is a bit curious. It’s an infinite loop, which is easily written in other languages
    by making the `while` condition always true. However, when considering Forth implemented
    in Forth, it’s easy to see why `begin-again` might exist:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个类似于 C 语言中的`while`和`do-while`，但最后一个有点特别。它是一个无限循环，可以通过使`while`条件始终为真在其他语言中轻松编写。然而，当考虑到
    Forth 语言在 Forth 中的实现时，就容易理解为什么会有`begin-again`：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Both `begin` and `again` are immediate words, that is, those that execute even
    when defining a word; `begin` places the current end-of-dictionary value on the
    stack, and `again` branches backward from the end of the dictionary to the location
    that `begin` initially placed on the stack. The branch is backward because `again`
    happens after the body of the loop, so `here` will report a higher address than
    the address placed on the stack by `begin`. I won’t show it here, but with a little
    imagination, one can guess how `while`, `repeat`, and `until` might be implemented
    as Forth words.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin`和`again`都是立即词，即在定义词时也会执行的那些词；`begin`将当前的字典结束值放入栈上，`again`从字典末尾返回到`begin`最初放入栈的位置。之所以是向后跳转，是因为`again`出现在循环体之后，因此`here`会报告比`begin`放入栈时的地址更高的地址。我在这里不展示，但稍微发挥一下想象力，可以猜测`while`、`repeat`和`until`可能是如何作为
    Forth 词实现的。'
- en: A simple example of `begin-again` is
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`begin-again`示例是
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The word `infinity` places 0 on the stack, duplicates it so it can be printed,
    and then increments it and starts repeating until you press CTRL-C or the power
    goes out.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`infinity` 这个词将 0 放入栈中，复制它以便打印，然后递增它并开始重复，直到你按下 CTRL-C 或者电源断开。'
- en: Of more immediate utility are the top- and bottom-tested loops. A top-tested
    loop, the `while` loop, tests its condition before executing the body of the loop.
    Therefore, the body of the loop might never execute if the condition fails initially.
    For a bottom-tested loop, the body executes at least once to get to `until`. Let’s
    see `while` in action.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 更加实用的是顶部测试和底部测试的循环。顶部测试循环，`while` 循环，会在执行循环体之前先测试条件。因此，如果条件最初失败，循环体可能根本不会执行。对于底部测试循环，循环体至少会执行一次，直到到达
    `until`。让我们看看 `while` 是如何工作的。
- en: One way to estimate the square root of a number using integer operations is
    to start at 0, square 0, and ask if that result is equal to or greater than the
    number. If it isn’t, move on to try 1, then 2, 3, 4, and so on. Eventually, we’ll
    get to the point where the number squared is equal to or greater than the given
    number. [Listing 4-2](ch04.xhtml#ch04list2) implements this inefficient algorithm
    with `*while*` .
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数运算估算一个数字的平方根的一种方法是从 0 开始，平方 0，然后问这个结果是否等于或大于给定数字。如果不是，就尝试 1，然后是 2、3、4，以此类推。最终，我们会到达一个点，数字的平方等于或大于给定的数字。[清单
    4-2](ch04.xhtml#ch04list2) 使用 `*while*` 实现了这个低效的算法。
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 4-2: A brute-force square root word*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-2：一个暴力平方根词*'
- en: We’ll call the word `dsqr` for “dumb square root” because it implements the
    simplest algorithm possible. The word pushes an initial 0, which is the counter,
    and then starts the loop with `begin`. Note that the number we want the square
    root of, *n*, is already on the stack.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这个词为 `dsqr`，即“傻平方根”，因为它实现了最简单的算法。这个词推送一个初始的 0，作为计数器，然后用 `begin` 启动循环。请注意，我们想求平方根的数字
    *n* 已经在栈上。
- en: 'There are two pieces to the `while` loop: the condition and the body. Here
    the condition is `2dup dup * >`. We have the given number and 0 on the stack for
    `2dup` to duplicate. Next, `dup` duplicates the counter so it can be multiplied
    by itself to square it. This sets up `>`, which leaves a 0 or *–*1 on the stack.
    Remember, because of `2dup`, the given number and counter are still on the stack.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环有两个部分：条件和循环体。这里条件是 `2dup dup * >`。我们在栈上有给定的数字和 0，供 `2dup` 复制。接下来，`dup`
    复制计数器，以便将其自身相乘求平方。这为 `>` 做了准备，`>` 会在栈上留下 0 或 *–*1。记住，因为有 `2dup`，给定的数字和计数器仍然在栈上。'
- en: Next, `while` uses the condition’s state to decide whether or not to execute
    the body of the loop, `1+`, which increments the counter still on the top of the
    stack. The `repeat` word does nothing as far as the loop is concerned, but again,
    we’ve seen enough of the internals of Forth to know that `repeat` is calculating
    how far back in the dictionary to branch to start again at `begin`. The word completes
    once the square root is found by removing the given number, the second-to-top
    stack item (`nip`).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`while` 使用条件的状态来决定是否执行循环体 `1+`，它会递增仍然在栈顶的计数器。`repeat` 这个词对循环来说什么也不做，但我们已经看到了
    Forth 的内部工作原理，知道 `repeat` 正在计算从字典中回溯多远以便重新开始 `begin`。一旦找到平方根，词语就完成了，通过移除给定的数字，即倒数第二个栈项（`nip`）。
- en: As dumb as it is, `dsqr` works and is exact for perfect squares (but not for
    other numbers). Later, we’ll implement a different integer square root algorithm,
    one that is surely less computationally demanding (we think).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `dsqr` 很傻，但它确实有效，并且对于完美的平方数是精确的（但不适用于其他数字）。稍后，我们将实现一种不同的整数平方根算法，这种算法肯定会更少消耗计算资源（我们认为）。
- en: In Forth, `begin-until` loops always execute the body of the loop at least once.
    For example, here’s a word that plays a little guessing game.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Forth 中，`begin-until` 循环总是至少执行一次循环体。例如，下面是一个进行小猜谜游戏的词。
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Execute `guess` and press keys on the keyboard. The game ends when the lowest
    four bits of the ASCII character code for the key are 7\. The counter is initially
    0 and placed on the stack before `begin`. It is immediately incremented (`1+`)
    as there will always be at least one guess. Next, a keystroke is read and placed
    on the stack with `key`. The lowest four bits of the key’s character code are
    kept by `and`ing with 15 (0xF = 1111 in binary). That’s `15 and`. If the result
    is 7, `=` leaves *–*1 on the stack for `until`. If the result isn’t 7, `until`
    branches back to `begin`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`guess`并按下键盘上的按键。当按键的ASCII字符代码的最低四个比特是7时，游戏结束。计数器最初为0，并在`begin`之前被放置到栈上。在每次猜测后，它会立即递增（`1+`），因为总会至少进行一次猜测。接下来，读取一个按键，并通过`key`将其放置到栈上。按键字符码的最低四位通过与15（0xF
    = 1111二进制）进行`and`操作得到保留。那就是`15 and`。如果结果是7，`=`将*–*1放置到栈上供`until`使用。如果结果不是7，`until`将跳回到`begin`。
- en: 'Earlier, I said that `begin-until` is similar to `do-while` in C; however,
    there is an important difference. Consider the C equivalent of `guess`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，`begin-until`与C语言中的`do-while`类似；然而，它们之间有一个重要的区别。考虑C语言中`guess`的等效代码：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This program uses `do-while`, but the condition on the `while` part is written
    so it is *true* if the low-order nibble (that is, the lowest four bits) of the
    key entered is not 7\. The Forth loop condition is *false* until the condition
    is met. In C, the logic is reversed: the `do-while` loop continues while the condition
    is true and the `begin-until` loop continues while the condition is false. Note
    that `key()` is not a standard C library function; it’s just a stand-in for a
    function that waits for a keystroke and returns the ASCII key code without requiring
    a newline.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用了`do-while`，但`while`部分的条件写成这样，如果输入的键值的低四位（即最低的四个比特）不是7，则条件为*真*。Forth循环条件在满足条件之前是*假*的。在C语言中，逻辑是相反的：`do-while`循环在条件为真时继续执行，而`begin-until`循环在条件为假时继续执行。请注意，`key()`不是标准C库函数；它只是一个用来等待按键并返回ASCII键码的占位符，且不要求输入换行符。
- en: This example introduced `key` to wait for a character from the keyboard. We’ll
    examine other Forth input and output functions later in the chapter. For now,
    let’s get a handle on how Forth works with memory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子引入了`key`来等待键盘输入的字符。我们将在本章稍后查看其他Forth输入和输出函数。现在，让我们先了解一下Forth如何处理内存。
- en: '***How Forth Uses Memory***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Forth如何使用内存***'
- en: Forth relies heavily on its stack, but that’s not the only means it has to work
    with data. Forth supports constants and variables natively, and can allocate space
    on the dictionary for any use. Let’s see how.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Forth高度依赖栈，但这并不是它唯一的处理数据的方式。Forth原生支持常量和变量，并且可以在字典中为任何用途分配空间。让我们来看看它是如何做到的。
- en: '**Variables and Constants**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**变量和常量**'
- en: To define constants and variables, use code like what’s shown in [Listing 4-3](ch04.xhtml#ch04list3).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义常量和变量，请使用类似[示例4-3](ch04.xhtml#ch04list3)中展示的代码。
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 4-3: Variables and constants in Forth*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例4-3：Forth中的变量和常量*'
- en: The first two lines define variables `f` and `c`. The next line defines a constant,
    `b`, which is set to the top stack value, in this case 32.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行定义了变量`f`和`c`。接下来的行定义了常量`b`，它被设置为栈顶的值，在这种情况下是32。
- en: Two short definitions come next. The first converts Celsius to Fahrenheit, *F*
    = (9/5)*C* + 32, and the second does the opposite, *C* = (5/9)(*F –* 32). Both
    definitions use the variables `f` and `c` instead of the stack—a very *un*-Forth-like
    thing to do. As an exercise, rewrite `c2f` and `f2c` to use the stack.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是两个简短的定义。第一个是将摄氏度转换为华氏度，*F* = (9/5)*C* + 32，第二个是反向转换，*C* = (5/9)(*F –* 32)。这两个定义使用变量`f`和`c`而不是栈，这是一个非常*不像*Forth的做法。作为练习，请将`c2f`和`f2c`改写为使用栈。
- en: The word definitions in [Listing 4-3](ch04.xhtml#ch04list3) have strange `@`
    and `!` characters in them. When a Forth variable is referenced, the value of
    the variable is *not* placed on the stack; only the address of the variable goes
    on the stack. To get at the value, the address must be dereferenced, just like
    in C, where a pointer must be dereferenced to get at the thing it points to. Therefore,
    the expression `c @` first places the address of `c` on the stack, then executes
    `@`, which is the word that takes an address and returns the 64-bit integer at
    that address. Equivalent C code for `c @` is `*&c`, assuming that `c` is declared
    to be an `int`. First, use `&` to get the address of `c`, then use `*` to return
    the contents of `c`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-3](ch04.xhtml#ch04list3)中的词定义有奇怪的`@`和`!`符号。当引用一个 Forth 变量时，变量的值*不会*放入堆栈；只有变量的地址会放入堆栈。为了获取值，必须取消引用地址，就像在
    C 语言中，指针必须取消引用才能获取它所指向的内容。因此，表达式`c @`首先将`c`的地址放入堆栈中，然后执行`@`，这是一个将地址传入并返回该地址上的
    64 位整数的词。相当于 C 代码中的`c @`是`*&c`，假设`c`被声明为`int`。首先，使用`&`获取`c`的地址，然后使用`*`返回`c`的内容。'
- en: Look again at the definition of `c2f` in [Listing 4-3](ch04.xhtml#ch04list3).
    The definition ends with `f !`. As you’ve likely already guessed, `!` stores values
    at the address on the top of the stack, in this case the Fahrenheit temperature.
    The stack effect for `!` is `( n a -- )` to store value *n* at address *a*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看[清单 4-3](ch04.xhtml#ch04list3)中`c2f`的定义。该定义以`f !`结束。正如你可能已经猜到的，`!`会将值存储在堆栈顶部的地址中，在这个例子中是华氏温度。`!`的堆栈效应是`(
    n a -- )`，即将值*n*存储在地址*a*处。
- en: There is an elegance to how Forth handles variables, as other data areas also
    leave their address on the stack. However, all the `@` and `!` characters flying
    around quickly become distracting. For example, to increment a variable `x` by
    1, use `x @ 1+ x !`, which isn’t particularly easy to read. Note that `1+` is
    not a typo. Incrementing the top stack item is common enough that Forth implements
    a special word for it that executes faster than `1+` will. In truth, though, I’m
    being a bit unfair here. Forth does have the word `+!`, which adds a value to
    a variable. So `x @ 1+ x !` might be written as `1 x +!`, which is slightly more
    readable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 处理变量的方式非常优雅，因为其他数据区域也会把它们的地址留在堆栈上。然而，所有的`@`和`!`符号四处飞扬，最终会让人分心。例如，要将变量`x`加1，可以使用`x
    @ 1+ x !`，这并不特别容易阅读。请注意，`1+`不是打字错误。递增堆栈顶端项目是一个足够常见的操作，Forth 为此实现了一个特殊的单词，它执行的速度比`1+`要快。实际上，我有点不公平。Forth
    确实有一个词`+!`，它会将一个值加到变量中。所以`x @ 1+ x !`可以写作`1 x +!`，这稍微更易读一些。
- en: 'Forth supplies, at a minimum, two other words for memory access: `c@` and `c!`.
    Here the `c` refers to “character,” meaning old 8-bit ASCII. These words access
    *bytes*, not 64-bit integers. Consider this code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 至少提供了两个其他的内存访问词：`c@`和`c!`。这里的`c`指的是“字符”，意味着旧的 8 位 ASCII。这些词访问的是*字节*，而不是
    64 位整数。考虑以下代码：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we define `x` as a variable. Then, we assign a value to `x` by introducing
    a new word, `hex`, to place Forth in hexadecimal mode. All numbers will be interpreted
    as base-16 until `decimal` is executed to restore base-10\. So the second and
    third lines when written in C become
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义`x`作为一个变量。然后，我们通过引入一个新词`hex`来将值赋给`x`，将 Forth 设置为十六进制模式。在执行`decimal`恢复十进制模式之前，所有的数字都会被解释为十六进制。因此，第二行和第三行写成
    C 代码后变成
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What of all the lines with `c@` in them? As `x` pushes the *address* of `x`
    on the stack, using `c@` returns the first *byte* at that address. Because Intel
    machines are little-endian, the first byte at the address of `x` is the lowest-order
    byte, `0x88` (to use C notation). Adding 1 to the address of `x` before accessing
    it moves to the next byte in memory to return `0x77`, and so on for all eight
    bytes of `x`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，所有包含`c@`的行呢？由于`x`将`x`的*地址*推入堆栈，使用`c@`会返回该地址处的第一个*字节*。因为 Intel 机器是小端模式，`x`地址处的第一个字节是最低阶字节`0x88`（使用
    C 表示法）。在访问之前，将`x`的地址加 1 移动到内存中的下一个字节，返回`0x77`，以此类推，直到`x`的八个字节都被访问。
- en: 'This freedom makes it easy to modify memory in interesting ways. For example,
    the following code defines `x` as before, but then uses `c!` to modify the low-order
    byte of `x`, changing it from `88` to `ee`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自由使得修改内存变得非常有趣。例如，以下代码像之前一样定义了`x`，但是然后使用`c!`来修改`x`的低阶字节，将它从`88`更改为`ee`：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Constants are just that: constants. Once fixed, they cannot be changed. Forth
    enforces this rule as well. However, consider these words:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 常量就是常量。一旦确定，它们就不能改变。Forth 也强制执行这个规则。然而，考虑以下这些话：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Not every Forth system will allow this, but gforth does. What on Earth is happening?
    Recall what Forth does when it encounters a token on input. If it finds the token
    in the dictionary, it executes it; otherwise, it interprets it as a number and
    pushes it on the stack. The first two lines above define constants, `2` and `1`.
    In this case, the constants’ names really are “2” and “1” as characters. The value
    of the constant “2” is 1, and the value of the constant “1” is 4.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是每个Forth系统都会允许这样做，但gforth可以。究竟发生了什么呢？回忆一下，当Forth遇到输入中的标记时，它会做什么。如果它在字典中找到了该标记，它就会执行它；否则，它会将其解释为一个数字并推送到栈上。上面的前两行定义了常量`2`和`1`。在这种情况下，常量的名称实际上是字符“2”和“1”。常量“2”的值是1，而常量“1”的值是4。
- en: So the next time “2” is encountered, Forth first searches the dictionary, finds
    a constant with that name, and dutifully executes it to place a 1 on the stack.
    The same is true for “1” to place a 4 on the stack. Therefore, while confusing,
    Forth is perfectly correct to present output that seems to us to say 1 + 1 = 8
    and 2 × 2 = 1.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以下次遇到“2”时，Forth首先会搜索字典，找到一个具有该名称的常量，并恭敬地执行它，将1放入栈中。对于“1”来说也是如此，将4放入栈中。因此，尽管令人困惑，Forth完全正确地展示了似乎对我们来说是1
    + 1 = 8和2 × 2 = 1的输出。
- en: 'There is a historical reason for allowing such shenanigans. Let’s face it:
    old computers were slow. Programmers were always on the lookout for tricks to
    speed things up. When dealing with a new token, Forth scans the dictionary from
    beginning to end, so many Forth programs started with strange definitions like
    `0 CONSTANT 0` because it was faster to look up zero as a word than scan the entire
    dictionary and then interpret the token as a number.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 允许这种做法有一个历史原因。说实话：老式计算机很慢。程序员总是寻找能够加速的技巧。在处理一个新标记时，Forth会从头到尾扫描字典，因此许多Forth程序以像`0
    CONSTANT 0`这样的奇怪定义开始，因为查找零作为单词比扫描整个字典并将标记解释为数字要快。
- en: '**Allocating Memory**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内存分配**'
- en: We’ll introduce several new words in this section. There will be a table at
    the end that contains all of them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍几个新的单词。最后会有一个表格包含所有这些单词。
- en: 'Forth puts all new data at the end of the dictionary. This includes word definitions,
    variables, and constants. To allocate arbitrary amounts of dictionary space, say
    for a buffer or a sequence of data structures of some kind, Forth provides several
    useful words: `create`, `does>`, `allot`, `cells`, a comma (`,`), and `c,`. Let’s
    see how they work.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Forth将所有新数据放在字典的末尾。这包括单词定义、变量和常量。为了分配任意数量的字典空间，例如为缓冲区或某种数据结构序列分配空间，Forth提供了几个有用的单词：`create`、`does>`、`allot`、`cells`、逗号（`,`）和`c,`。让我们看看它们是如何工作的。
- en: 'The word `create` defines a word that does nothing more than place its address
    on the stack. For memory allocation, `create` is often followed by `allot`, like
    so:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 单词`create`定义了一个仅仅将其地址放入栈中的词汇。在内存分配中，`create`通常会紧跟着`allot`，如下所示：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The word `buf` is created, and immediately following it, 1,000 bytes of dictionary
    space are allocated. Effectively, this means there is a 1,000-byte buffer at the
    end of the dictionary, and the first byte of the buffer is the address that `buf`
    leaves on the stack when executed. This alone is already useful, as shown next.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 单词`buf`被创建，紧接着为其分配了1,000字节的字典空间。实际上，这意味着在字典的末尾有一个1,000字节的缓冲区，并且当`buf`执行时，缓冲区的第一个字节就是`buf`在栈上留下的地址。这本身就已经很有用，如下所示。
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The first three lines store byte values 1, 2, and 3 in the first three bytes
    of the 1,000-byte buffer pointed to by `buf`. We’re using `buf` as an array of
    bytes. Continuing with the example above, try the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行将字节值1、2和3存储到`buf`指向的1,000字节缓冲区的前三个字节中。我们将`buf`当作字节数组来使用。继续上面的示例，试试以下内容：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first line stores a 64-bit value beginning at byte 4 of `buf`. The next
    line shows that the second byte of `buf` is still 2, as we set it above, and the
    third line that there is still a 64-bit value beginning at byte 4 of the buffer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将一个64位值存储到`buf`的第4个字节开始的地方。下一行显示`buf`的第二个字节仍然是2，就像我们之前设置的一样，第三行则表明在缓冲区的第4个字节处仍然有一个64位值。
- en: 'Although it’s definitely possible to work with a block of memory byte by byte,
    it’s tedious and error prone. [Listing 4-4](ch04.xhtml#ch04list4) shows how `create`
    works with `allot` and `does>` to create a word that defines 1D arrays:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管逐字节处理一块内存是完全可能的，但这样做既繁琐又容易出错。[列表4-4](ch04.xhtml#ch04list4)展示了`create`如何与`allot`和`does>`配合使用，创建一个定义1D数组的单词：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 4-4: Defining a byte array*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-4：定义字节数组*'
- en: The first line defines `bArray`, which expects a number on the stack, which
    is the number of bytes to `allot`. First, `create` makes the new word and leaves
    the stack untouched. Next, `allot` reserves *n* bytes of dictionary space. So
    far, this makes sense; we saw this above. However, things get interesting when
    `does>` is executed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了`bArray`，它期望栈上有一个数字，表示要`allot`的字节数。首先，`create`创建新的单词并且不改变栈。接着，`allot`保留*n*字节的字典空间。到这里为止，这一切都很有意义；我们在上面已经看到过。但是，当`does>`被执行时，事情就变得有趣了。
- en: The word `bArray` has two parts. The first part uses `create` and `allot` to
    reserve dictionary space for the byte array. This happens when `bArray` is executed.
    However, the `does>` portion is *not* executed just yet. The word `does>` details
    what happens when a word defined by `bArray` is itself executed. Additionally,
    when the word is executed, it pushes its address on the stack, after which `does>`
    the rest of the definition. Let’s walk through it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 单词`bArray`有两个部分。第一部分使用`create`和`allot`为字节数组保留字典空间。当`bArray`执行时，这个过程会发生。然而，`does>`部分*尚未*执行。单词`does>`描述了当由`bArray`定义的单词本身被执行时发生的事情。此外，当该单词被执行时，它会将其地址推送到栈上，之后`does>`执行其余的定义。我们来一步步讲解。
- en: The second line, `100 bArray x`, creates a byte array word, `x`. The `create`
    and `allot` words have executed to create `x` and reserve 100 bytes of dictionary
    space. When `x` itself is executed, its address is pushed on the stack, and the
    remainder of the definition of `bArray`, the part after `does>`, is also executed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行`100 bArray x`创建了一个字节数组单词`x`。`create`和`allot`单词已经执行，创建了`x`并保留了100字节的字典空间。当`x`本身被执行时，它的地址被推送到栈上，`bArray`定义的其余部分（即`does>`后面的部分）也会被执行。
- en: 'For `bArray`, there is a plus (`+`) after `does>`. The address of the word,
    `x`, is on the top of the stack, so the `+` adds the address to the value just
    below it on the stack `( n a -- a+n )`, with *a* representing the address and
    *n* the value below, that is, an offset. Adding an offset to a base address is
    precisely how almost all programming languages index into arrays stored in contiguous
    memory. So if we supply an index before `x`, after `x` is executed, the stack
    contains the address of an element in the byte array assigned to `x`. Now the
    `c!` and `c@` lines in [Listing 4-4](ch04.xhtml#ch04list4) make sense: `125 2
    x c!` is equivalent to `x[2] = 125` in other languages. Likewise, `2 x c@ .` is
    `print(x[2])`, if using Python. The combination of `create` and `does>` has allowed
    us to create words that implement byte arrays. Excellent. But what if we want
    not an array of bytes, but an array of integers? The word `array` does what we
    want:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`bArray`来说，在`does>`后有一个加号（`+`）。单词`x`的地址在栈顶，因此`+`将地址加到栈中紧接在它下面的值上`( n a --
    a+n )`，其中*a*表示地址，*n*表示下面的值，也就是偏移量。将偏移量加到基址上正是几乎所有编程语言在处理存储在连续内存中的数组时的索引方式。所以，如果我们在`x`之前提供一个索引，在`x`执行后，栈中就会包含指向分配给`x`的字节数组元素的地址。现在，[Listing
    4-4](ch04.xhtml#ch04list4)中的`c!`和`c@`行就有意义了：`125 2 x c!`相当于其他语言中的`x[2] = 125`。同样，`2
    x c@ .`就是`print(x[2])`，如果使用Python的话。`create`和`does>`的结合使我们能够创建实现字节数组的单词。非常好。但是如果我们想要的不是字节数组，而是整数数组呢？单词`array`正是我们想要的功能：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The only difference between `bArray` and `array` is the appearance of `cells`.
    In Forth, the basic unit of memory is a *cell*. For gforth, a cell is 64 bits
    or 8 bytes. If we want an array to store 100 values, we should allocate 800 bytes.
    Likewise, to index the array, we need addresses that are not just the base plus
    the index, but the base plus the index times the size of a cell. The word `cells`
    expects a number on the stack and returns the number of bytes in that many cells:
    `100 cells .` returns `800`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`bArray`和`array`之间唯一的区别在于`cells`的出现。在Forth中，内存的基本单位是*单元*（cell）。对于gforth来说，一个单元是64位或8字节。如果我们想让一个数组存储100个值，我们应该分配800字节。同样地，要索引数组，我们需要的地址不仅仅是基址加上索引，而是基址加上索引乘以一个单元的大小。单词`cells`期望栈上的一个数字并返回该数量单元所占的字节数：`100
    cells .`会返回`800`。'
- en: So adding `cells` after `create` simply calculates the number of bytes `allot`
    should reserve at the end of the dictionary. When we index, the part after `does>`,
    we first convert the index from cells to bytes and add the result to the base
    address. That’s what `swap cells +` accomplishes. After these changes, `array`
    works just like `bArray`, but one should use `!` and `@` to set and get values
    from the array.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`create`后添加`cells`仅仅是计算`allot`应保留的字节数。当我们进行索引操作时，`does>`之后的部分，我们首先将索引从单元转换为字节，并将结果加到基址上。这就是`swap
    cells +`的作用。经过这些更改，`array`就像`bArray`一样工作，但应该使用`!`和`@`来设置和获取数组中的值。
- en: Sometimes, allocating the array isn’t all that we want. We also want to initialize
    it at the same time. The Forth way to do this uses a comma (`,`) or `c,`. These
    words compile the top stack item into the dictionary, either as a 64-bit integer
    or a byte. For example,
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，分配数组并不是我们所想要的全部。我们还希望同时进行初始化。Forth 的做法是使用逗号（`,`）或 `c,`。这些单词将栈顶的项目编译到字典中，可以是
    64 位整数或字节。例如，
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: creates `ABCDEF` and allocates six values, the ASCII values for ABCDEF. The
    same is true if using the comma, but instead of bytes, it allocates cells (64-bit
    integers). These words are useful for setting up tables of constants or even arrays
    of words.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建 `ABCDEF` 并分配六个值，这些值是 ABCDEF 的 ASCII 值。如果使用逗号也是一样的，不过它分配的是单元（64 位整数），而不是字节。这些单词非常有用，可以用来设置常量表或甚至是单词数组。
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This example introduces two new words: single quote (`''`) and `execute`. The
    first takes the execution address of the next token, a word, and places it on
    the stack. The next word, `execute`, runs the word whose execution address is
    on the stack. So `tbl` is an array of three “function pointers” as it were, to
    use C terminology. Once the proper offset to `tbl` is known, and the execution
    address is on the stack courtesy of `@`, `execute` calls the word.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例介绍了两个新单词：单引号 (`'`) 和 `execute`。第一个单词获取下一个标记（一个单词）的执行地址，并将其压入栈中。下一个单词 `execute`
    则执行栈上地址对应的单词。因此，`tbl` 就像是一个包含三个“函数指针”的数组，借用 C 语言术语。一旦知道了正确的 `tbl` 偏移量，并且通过 `@`
    得到执行地址，`execute` 就会调用这个单词。
- en: '[Table 4-2](ch04.xhtml#ch04tab2) summarizes the words we introduced in this
    section.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-2](ch04.xhtml#ch04tab2) 总结了我们在本节中介绍的单词。'
- en: '**Table 4-2:** Forth Words for Manipulating Memory'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-2:** 用于操作内存的 Forth 单词'
- en: '| **Word** | **Effect** | **Description** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **单词** | **效果** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@` | `( a -- n )` | Get the 64-bit integer at address *a* |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `@` | `( a -- n )` | 获取地址 *a* 处的 64 位整数 |'
- en: '| `!` | `( n a -- )` | Store a 64-bit integer in address *a* |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `!` | `( n a -- )` | 将 64 位整数存储到地址 *a* |'
- en: '| `,` | `( n -- )` | Compile an integer into the dictionary |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `,` | `( n -- )` | 将整数编译到字典中 |'
- en: '| `c@` | `( a -- b )` | Get the byte at address *a* |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `c@` | `( a -- b )` | 获取地址 *a* 处的字节 |'
- en: '| `c!` | `( b a -- )` | Store a byte in address *a* |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `c!` | `( b a -- )` | 将字节存储到地址 *a* |'
- en: '| `c,` | `( b -- )` | Compile a byte to the dictionary |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `c,` | `( b -- )` | 将字节编译到字典中 |'
- en: '| `create` | `( -- )` | Create a new word |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `create` | `( -- )` | 创建一个新单词 |'
- en: '| `does>` | `( -- a )` | Define the word’s behavior |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `does>` | `( -- a )` | 定义单词的行为 |'
- en: '| `allot` | `( b -- )` | Allocate dictionary space (bytes) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `allot` | `( b -- )` | 分配字典空间（字节） |'
- en: '| `cells` | `( n -- b )` | Convert cells to bytes |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `cells` | `( n -- b )` | 将单元转换为字节 |'
- en: Let’s set memory aside for now and investigate Forth’s input and output mechanisms.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们暂时放下内存的讨论，来研究一下 Forth 的输入和输出机制。
- en: '***Input and Output***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***输入与输出***'
- en: A programming language without input or output is essentially useless. Forth,
    of course, has words for basic input and output, to say nothing of low-level I/O
    via serial and other mechanisms. We saw `key` in the `begin-until` example above.
    Modern Forth, like gforth, also has file access words as part of its interface
    to the operating system. We’ll ignore those here to save space. Additionally,
    we already mentioned classic Forth’s block-level disk access. Surprisingly, gforth
    emulates this, if desired, using a disk file as a representation of the disk itself.
    Therefore, if you care to explore it, gforth will let you relive the classic Forth
    experience.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输入或输出的编程语言本质上是无用的。当然，Forth 提供了基本的输入和输出单词，更不用说通过串行和其他机制实现低级 I/O 了。我们在上面的 `begin-until`
    示例中看到了 `key`。现代的 Forth，如 gforth，也有作为操作系统接口的一部分的文件访问单词。为了节省空间，我们将在此忽略这些内容。此外，我们已经提到过经典
    Forth 的块级磁盘访问。令人惊讶的是，gforth 可以模拟这一点（如果需要的话），使用磁盘文件作为磁盘本身的表示。因此，如果你愿意探索，gforth
    将允许你重温经典 Forth 的体验。
- en: 'We already know `.`, which prints the top stack item as a signed integer. To
    print the top stack value as an unsigned integer, use `u.`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 `.`，它将栈顶项打印为带符号整数。若要将栈顶值打印为无符号整数，可以使用 `u.`：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This example works in hexadecimal to make it easier to understand what is happening.
    We push `-0xAA` on the stack, duplicate it, and print it twice, once with `.`
    as a signed integer and again with `u.` as an unsigned integer.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例采用十六进制表示，以便更容易理解发生了什么。我们将 `-0xAA` 压入栈中，复制它，并打印两次，一次用 `.` 作为带符号整数，另一次用 `u.`
    作为无符号整数。
- en: As expected, `.` produces `-AA`. However, `u.` produces `FFFFFFFFFFFFFF56`,
    a large, positive number, which is the value found by interpreting the signed
    64-bit binary value as a positive number.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`.`输出`-AA`。然而，`u.`输出`FFFFFFFFFFFFFF56`，这是一个大正数，表示将带符号的 64 位二进制值当作正数解读后的结果。
- en: 'Forth grew up in an age of terminals and teletypes. Therefore, it supports
    many words that are variations of `.` and `u.`, including words for highly structured
    formatting. One useful variation is `u.r`. It prints right-justified unsigned
    numbers `(n d -- )`, with *n* the number and *d* the width of the field. For example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Forth是在终端和电传打字机的时代发展起来的，因此，它支持许多`.`和`u.`的变体词汇，其中包括用于高度结构化格式化的词汇。一种有用的变体是`u.r`。它打印右对齐的无符号数字`(n
    d -- )`，其中*n*是数字，*d*是字段的宽度。例如：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we create a small array, `x`, with five numbers. Next, we define `aligned`
    to iterate through the array using `u.r` to display each number.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含五个数字的小数组`x`。接着，我们定义`aligned`来遍历数组，并使用`u.r`显示每个数字。
- en: The word `key` reads a key from the user and pushes its character code on the
    stack. The analogous output word is `emit`, which takes the character code on
    the stack and displays it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 词汇`key`从用户读取一个键，并将其字符代码压入堆栈。与之相应的输出词汇是`emit`，它取出堆栈上的字符代码并显示出来。
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The word `alpha` displays the alphabet using `emit` to output the characters.
    We’ve also introduced `[char]`, which is used during compilation to take the next
    character token, which here is `A`, and push its code on the stack. We could just
    as easily have used `65` instead of `[char] A`, as that is the ASCII code for
    “A.”
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 词汇`alpha`使用`emit`输出字符来显示字母表。我们还介绍了`[char]`，它在编译期间用于获取下一个字符标记，这里是`A`，并将它的代码压入堆栈。我们本来也可以直接使用`65`，因为那是字母“A”的
    ASCII 码。
- en: 'To get a string of input from the user, use `accept`, which expects two values
    on the stack: the address of where the string should go and the maximum number
    of characters to input.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要从用户获取一串输入，可以使用`accept`，它在堆栈上期望两个值：字符串应该存放的位置的地址和要输入的最大字符数。
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`accept` returns the number of characters actually entered. The buffer, `str`
    , now holds the text. To see it, use `type`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept`返回实际输入的字符数。缓冲区`str`现在保存了文本。要查看它，可以使用`type`。'
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This also expects the address and count on the stack.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这也需要堆栈上的地址和计数值。
- en: Creating a special buffer for input is a bit tedious, so Forth provides `pad`,
    a pre-allocated buffer of at least 84 characters (for gforth). Let’s use `pad`
    to learn how to input numbers instead of strings.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个专门的输入缓冲区有点繁琐，因此 Forth 提供了`pad`，这是一个预分配的至少包含 84 个字符的缓冲区（对于 gforth）。让我们使用`pad`来学习如何输入数字，而不是字符串。
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first line reads a character string of up to 80 characters and puts it in
    `pad`. Recall that `accept` returns the actual number of characters read, which
    is used in the next line.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行读取一个最多 80 个字符的字符串，并将其存放在`pad`中。回忆一下，`accept`返回的是实际读取的字符数，这个值将在下一行中使用。
- en: The second line puts the address of `pad` on the stack, swaps to make the number
    of characters entered the top stack item, and calls `evaluate` to interpret the
    string as a number.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将`pad`的地址压入堆栈，交换堆栈，使得输入的字符数成为堆栈顶端的项，并调用`evaluate`将字符串解释为一个数字。
- en: We could spend many more pages describing all the various, sometimes quirky,
    input and output options Forth provides, but the examples discussed so far are
    a good start.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以花更多的篇幅描述 Forth 提供的各种输入输出选项，其中有些可能比较独特，但到目前为止讨论的示例已经是一个不错的开始。
- en: '**Square Root Redux**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**平方根归来**'
- en: In this section, we’ll make good on a promise made earlier in the chapter. While
    discussing `dsqr` above, we said we’d develop a better method for finding integer
    square roots. To see that we can, let’s do it now.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将兑现之前在本章做出的承诺。在上面讨论`dsqr`时，我们说过要开发一种更好的整数平方根求解方法。为了证明我们可以做到，现在就来实现它。
- en: '`dsqr` found the square root of an integer by testing all options to see which
    one was the square root. Although this approach works, it’s at first blush quite
    computationally inefficient. Instead, let’s try an implementation based on Equation
    4.1:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`dsqr`通过测试所有选项来找到整数的平方根，看看哪一个是平方根。虽然这种方法有效，但乍一看它在计算上是相当低效的。相反，让我们尝试基于方程 4.1
    的实现：'
- en: '![Image](Images/04eqa01.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/04eqa01.jpg)'
- en: This equation says that the sum of the first *n* odd numbers is *n*². Therefore,
    if we count the number of times an increasing odd number can be subtracted from
    another number, we’ll have an estimate of the square root of that number.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程说明了前*n*个奇数的和是*n*²。因此，如果我们计算一个不断增加的奇数可以从另一个数字中减去多少次，我们就能估算出该数字的平方根。
- en: '[Listing 4-5](ch04.xhtml#ch04list5) implements the algorithm implied by Equation
    4.1.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-5](ch04.xhtml#ch04list5)实现了方程4.1所暗示的算法。'
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 4-5: Integer square root in Forth*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5: Forth中的整数平方根*'
- en: The stack contains *n*, the number whose square root is sought, and *x*, an
    ever-increasing odd number, first 1, then 3, 5, 7, and so on. Each iteration sets
    *n* ←*n – x* and *x* ←*x* + 2\. When *n* is less than or equal to 0, the loop
    ends. To get the square root, we count the number of passes through the loop and
    use the return stack to hold the counter, initializing it with `0 >r` and incrementing
    it with `r> 1+ >r`. When the loop ends, *n* and *x* are dropped, and the count
    is returned.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈包含*n*，即要求平方根的数字，以及*x*，一个不断增加的奇数，首先是1，然后是3、5、7，依此类推。每次迭代都会设置*n* ← *n – x* 和
    *x* ← *x* + 2。当*n*小于或等于0时，循环结束。为了得到平方根，我们计算循环经过的次数，并使用返回堆栈保存计数器，初始化为`0 >r`并通过`r>
    1+ >r`递增。当循环结束时，*n*和*x*被丢弃，计数值被返回。
- en: A few examples demonstrate that `sqrt` works as advertised (with 7 as the estimated
    square root of 42).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例展示了`sqrt`如宣传所言有效（例如，42的估算平方根为7）。
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Surely, `sqrt` is a better option than `dsqr` from [Listing 4-2](ch04.xhtml#ch04list2).
    Let’s set up a test and see. The code we want is in the *examples* directory in
    the file *sqrt.4th*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，`sqrt`比[清单 4-2](ch04.xhtml#ch04list2)中的`dsqr`更好。让我们设置一个测试来验证一下。我们需要的代码位于*examples*目录下的文件*sqrt.4th*中。
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Listing 4-6: Testing sqrt and dsqr*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-6: 测试sqrt和dsqr*'
- en: '[Listing 4-6](ch04.xhtml#ch04list6) presents the relevant portion of *sqrt.4th*.
    The file first defines `sqrt` and `dsqr` (not shown) before defining a simple
    32-bit linear congruential pseudorandom number generator. The word `random` takes
    an upper limit, which is never returned, and replies with a random integer in
    the range [0, *n*).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-6](ch04.xhtml#ch04list6)展示了*sqrt.4th*的相关部分。该文件首先定义了`sqrt`和`dsqr`（未展示），然后定义了一个简单的32位线性同余伪随机数生成器。单词`random`有一个上限，且该上限永远不会返回，而是返回一个在[0,
    *n*)范围内的随机整数。'
- en: Gforth uses `utime` to return a double-precision (128-bit) time value, the lower
    64 bits of which become the seed for the random number generator. A copy of the
    seed is kept in `X` as well so we can repeat the sequence later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Gforth使用`utime`返回一个双精度（128位）时间值，其低64位作为伪随机数生成器的种子。该种子的副本也保存在`X`中，以便我们以后能够重复该序列。
- en: 'Two short words come next: `run0` and `run1`. Both calculate the square root
    of 100,000 random values in [1,10⁶], each of which is a perfect square. We don’t
    actually want the answers; we’re only interested in how long the calculation takes,
    so each square root is immediately discarded (`drop`). Next, `run0` uses `sqrt`
    and `run1` uses `dsqr`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是两个简短的词：`run0`和`run1`。这两个词都计算100,000个随机值的平方根，这些值的范围在[1,10⁶]之间，每个值都是一个完全平方数。我们实际上并不关心答案，我们只对计算所需的时间感兴趣，因此每个平方根计算后都会立即被丢弃（`drop`）。接下来，`run0`使用`sqrt`，而`run1`使用`dsqr`。
- en: The `main` word grabs the start time, leaving it on the stack, calls `run0`,
    and prints the time it takes to run in microseconds (`2swap d- d.`). It then resets
    the pseudorandom seed and repeats the calculation using `run1`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`词抓取开始时间，并将其留在堆栈上，调用`run0`，并打印出运行所需的时间（以微秒为单位，`2swap d- d.`）。然后，它重置伪随机种子，并使用`run1`重复计算。'
- en: Executing *sqrt.4th* 10 times (`gforth sqrt.4th`) gives us the following mean
    runtimes for the two square root methods.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 执行*sqrt.4th* 10次（`gforth sqrt.4th`）后，我们得到了两个平方根方法的平均运行时间。
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Time is now in seconds. Clearly, our intuition was incorrect. The more elegant
    algorithm takes about 1.5 times longer to execute, on average, than the brute-force
    method. This reminds me of physicist Ludwig Boltzmann’s famous quote: “If you
    are out to describe the truth, leave elegance to the tailor.” In this case, elegance
    loses out to raw computing power. It is simply faster to check all possibilities
    compared to the number of calculations and stack manipulations necessary to implement
    the subtraction method.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 时间单位为秒。显然，我们的直觉是错误的。更优雅的算法平均执行时间大约是暴力方法的1.5倍。这让我想起物理学家路德维希·玻尔兹曼的名言：“如果你想描述真理，把优雅留给裁缝。”在这种情况下，优雅败给了原始的计算能力。相比于实现减法方法所需的计算次数和堆栈操作，检查所有可能性显然更快。
- en: 'Is this the final word, though? There is one more algorithm we can try: Newton’s
    method. Newton’s method finds the roots of equations, the values of *x* that make
    the equation zero. If the equation is *x*² *– n*, then it’s clear this equation
    is zero when ![Image](Images/f00120.jpg).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这就是最终的结论吗？还有一种算法我们可以尝试：牛顿法。牛顿法找到方程的根，即使方程为零的 *x* 值。如果方程是 *x*² *– n*，那么显然当
    ![Image](Images/f00120.jpg) 时，该方程为零。
- en: Newton’s method is iterative based on an initial guess. It is powerful and converges
    quickly. Equation 4.2 shows us how to iterate with
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿法是基于初始猜测的迭代法。它强大且收敛迅速。方程 4.2 向我们展示了如何进行迭代。
- en: '![Image](Images/04eqa02.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/04eqa02.jpg)'
- en: for some initial guess, *x*[0] = *n*/2.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个初始猜测，*x*[0] = *n*/2。
- en: The code we need, also in *sqrt.4th*, is
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的代码，也在 *sqrt.4th* 中，是
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The word `step` performs one update step (Equation 4.2) with *n* and *x*[*i*]
    on the stack as input and *n*, *x*[*i*], *x*[*i*+1] as output. The `if` handles
    things if *x*[*i*] is 0.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`step` 一词执行一个更新步骤（方程 4.2），以 *n* 和 *x*[*i*] 作为输入，*n*、*x*[*i*] 和 *x*[*i*+1] 作为输出。如果
    *x*[*i*] 为 0，`if` 会处理相关情况。'
- en: '`newton` performs the iterations for as long as *x*[*i*+1] < *x*[*i*]. The
    first `dup 2/` sets the initial guess, *x*[0]. The body of the loop keeps *x*[*i*+1]
    as the new *x*[*i*] and then takes another step. After the loop, the last *x*[*i*+1]
    is dropped, along with *n*, leaving only *x*[*i*] as the answer.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`newton` 进行迭代，直到 *x*[*i*+1] < *x*[*i*]。第一次 `dup 2/` 设置初始猜测 *x*[0]。循环体将 *x*[*i*+1]
    作为新的 *x*[*i*]，然后再进行一步。循环结束后，最后的 *x*[*i*+1] 被丢弃，连同 *n* 一起，最后只剩下 *x*[*i*] 作为答案。'
- en: Running `newton` 10 times lets us complete our list of average runtimes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `newton` 10 次后，我们完成了平均运行时间的列表。
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We have a clear winner. Newton’s method is, on average, an order of magnitude
    faster than the brute force method. Boltzmann is wrong in this case; elegance
    and truth do go together.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了明确的赢家。牛顿法在平均情况下比暴力求解法快一个数量级。在这种情况下，玻尔兹曼的观点是错误的；优雅和真理确实是相辅相成的。
- en: '**Discussion**'
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: What should we make of Forth? It’s definitely a curious language, but with its
    own charm. However, it seems best suited to a computing environment that is largely
    bygone. Figuring out how to manipulate the stack to accomplish what can be done
    in a simple statement or two in other languages is both frustrating and rewarding,
    but not particularly practical for day-to-day use. Forth’s learning curve is rather
    high, though experts can do amazing things with it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何看待 Forth 语言？它绝对是一种有趣的语言，但也有它独特的魅力。然而，它似乎最适合于一个已经过时的计算环境。弄清楚如何操作栈来完成在其他语言中可以通过一两行简单语句实现的任务，既令人沮丧又充满成就感，但对于日常使用来说并不特别实用。Forth
    的学习曲线相当陡峭，尽管专家们可以用它做出令人惊叹的事情。
- en: Because the code can be difficult to read, Forth is often characterized as a
    “write-only” programming language. Expert practitioners will disagree, and strict
    adherence to Forth style guidelines might mitigate some of the effects, but the
    charge is not without merit.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码可能难以阅读，Forth 经常被认为是一种“只写”编程语言。专家从业者可能不同意这种看法，严格遵守 Forth 风格指南可能会缓解一些影响，但这一指控并非毫无根据。
- en: Back in the Introduction, you can see [Figure 1](ch00.xhtml#ch00fig1), which
    shows a functional brain imaging system I wrote in Forth for the Macintosh nearly
    25 years ago. It worked well, and I used it often. Now, some 25 years later, thanks
    to the power of open source emulators like BasiliskII, I was able to run the code
    and pull out the source. Here’s the code for accessing a single pixel of what
    amounts to a 3D block of data, a time series of magnetic resonance images.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在引言中，你可以看到 [图 1](ch00.xhtml#ch00fig1)，它展示了我在 25 年前为 Macintosh 编写的一个功能性脑部影像系统。我用了它很多次，而且效果很好。现在，经过大约
    25 年的时间，感谢像 BasiliskII 这样的开源模拟器，我能够运行这段代码并提取源代码。这里是访问一个像是 3D 数据块的单个像素的代码，这是一个时间序列的磁共振图像。
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'I agree that this probably deserves the label of write-only code. The comments
    explain what is happening, but I doubt anyone would say it’s easy to read. For
    comparison purposes, here’s how to do the same thing in Python with NumPy: `n
    = images[z,x,y]`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意这可能确实应该被贴上“只写代码”的标签。注释解释了发生了什么，但我怀疑会有人说它容易阅读。为了对比，下面是如何在 Python 中使用 NumPy
    做相同的事情：`n = images[z,x,y]`。
- en: Lest readers think me unfair in my criticism, I still use Forth for different
    projects, usually to simulate the small microcontrollers that a larger system
    communicates with via RS-232 serial. Forth works well in this case, even on old
    Apple II computers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以免读者认为我对其批评不公，我仍然使用 Forth 来做不同的项目，通常是为了模拟较大系统通过 RS-232 串行端口与之通信的小型微控制器。在这种情况下，Forth
    表现得很好，即使在老旧的 Apple II 计算机上也能使用。
- en: The Forth words of this chapter took time and some effort with pen and paper
    to work out. However, that adds to the charm of achieving success with the language,
    even as it subtracts from the practical utility.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的 Forth 语言构造花费了时间和一些努力，用笔和纸一一推导出来。然而，这也增添了用这门语言取得成功的魅力，尽管它在实际应用上有所减少。
- en: Forth’s popularity has definitely waned in recent years. However, the embedded
    development world still holds a place for Forth. There are small, single-board
    computers that run Forth as well as C, but they are few and far between. Increasingly,
    the embedded world is moving to tiny computers supporting more modern languages.
    Later in this book, for example, we’ll use the BBC micro:bit, which uses Python
    as its primary language, though hobbyists have developed a version of Forth that
    runs on the micro:bit. Full-blown Linux environments for small boards, like the
    Raspberry Pi Zero and BeagleBoard, are common. The world that motivated the development
    of Forth has changed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 的流行度在近年来的确有所下降。然而，嵌入式开发领域仍然保留着 Forth 的一席之地。有一些小型单板计算机既能运行 Forth 也能运行 C，不过它们稀少且分散。越来越多的嵌入式世界正在转向支持更现代语言的小型计算机。例如，在本书的后面，我们将使用
    BBC micro:bit，它的主要编程语言是 Python，尽管爱好者们已经开发出了在 micro:bit 上运行的 Forth 版本。像 Raspberry
    Pi Zero 和 BeagleBoard 这样的单板计算机也能运行完整的 Linux 环境。激发 Forth 开发的那个世界已经发生了变化。
- en: So why consider Forth?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要考虑 Forth 呢？
- en: 'Because Forth is a perfect exemplar for what this book intends to present to
    you: an opportunity to look at programming in a new light.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Forth 是本书所要向你展示的完美范例：它提供了一个机会，让你以新的视角看待编程。
- en: To succeed with Forth, you must think not only at the higher level of algorithm,
    though that is still necessary, but also at the lower level of *how* each algorithm
    step can be implemented, in minute detail.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要想在 Forth 中取得成功，你不仅需要从更高层次的算法角度思考，虽然这仍然是必要的，还必须从更低层次的 *如何* 实现每一个算法步骤的细节入手。
- en: Forth is close to what the computer is doing and not abstracted away from it
    like Python or Java. Bytes, addresses, order of operations on a stack, and how
    much limited dictionary memory is available all require a different kind of thinking,
    a more parsimonious approach to programming.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 接近计算机的工作原理，而不像 Python 或 Java 那样将其抽象化。字节、地址、栈上的操作顺序，以及有限的字典内存大小，都需要一种不同的思维方式，一种更节俭的编程方法。
- en: Those bitten by the Forth bug seldom recover. I recall many times reading posts
    on the old comp.lang.forth newsgroup (remember those?) that were almost spiritual
    in their expression of the joy one might feel when working with Forth. A tad excessive,
    perhaps, but there is definitely a joy to using Forth. Please do continue to play
    with the language.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦被 Forth 所吸引的人很少能恢复过来。我记得在旧的 comp.lang.forth 新闻组中曾多次看到帖子（你还记得那些吗？），帖子中表达的情感几乎是精神层面的，那种与
    Forth 一起工作时所感受到的喜悦。有点过于夸张，但毫无疑问，使用 Forth 确实令人愉快。请继续玩这门语言吧。
- en: '**Summary**'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter introduced Forth, a unique language with a long history. We explored
    the language, how it works, its programming model, and its philosophy. We looked
    at some examples and saw that Forth is often implemented in Forth, building itself
    by pulling itself up by its bootstraps.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Forth，一门有着悠久历史的独特语言。我们探讨了这门语言，它是如何运作的，它的编程模型以及其哲学思想。我们看了一些例子，并且发现 Forth
    经常用 Forth 实现，通过自我引导的方式建立自己。
- en: Thinking in Forth takes time and effort. Indeed, *Thinking FORTH* is the name
    of a classic Forth text by Leo Brodie (*[http://thinking-forth.sourceforge.net/](http://thinking-forth.sourceforge.net/)*).
    Take a look. If you want, you might also take a gander at Brodie’s *Starting FORTH*
    (*[http://www.exemark.com/FORTH/StartingFORTHfromForthWebsitev9_2013_12_24.pdf](http://www.exemark.com/FORTH/StartingFORTHfromForthWebsitev9_2013_12_24.pdf)*).
    Between these two books, you’ll get a thorough understanding of what it means
    to work with Forth.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 用 Forth 思考需要时间和精力。事实上，*《思考 Forth》* 是 Leo Brodie 所著一本经典的 Forth 书籍的名字（*[http://thinking-forth.sourceforge.net/](http://thinking-forth.sourceforge.net/)*）。看看这本书。如果你愿意，你还可以看看
    Brodie 的 *《Forth 入门》*（*[http://www.exemark.com/FORTH/StartingFORTHfromForthWebsitev9_2013_12_24.pdf](http://www.exemark.com/FORTH/StartingFORTHfromForthWebsitev9_2013_12_24.pdf)*）。这两本书将让你全面理解使用
    Forth 的意义。
- en: Now, it’s time for something completely different. We leave the low-level world
    of Forth behind and move into the oddly wonderful world of text processing with
    SNOBOL.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了完全不同的时刻。我们告别了 Forth 的低级世界，进入了 SNOBOL 文本处理的奇妙世界。
