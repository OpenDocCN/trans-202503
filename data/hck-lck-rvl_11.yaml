- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WORKING
    WITH DATA IN PYTHON</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">在
    Python 中处理数据</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: The basics of Python are behind you, but there’s still a lot to learn. In this
    chapter, you’ll expand your programming skills and start to directly investigate
    datasets, including BlueLeaks and chat logs leaked from a pro-Putin ransomware
    gang after Russia invaded Ukraine in 2022.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 基础已掌握，但仍有许多内容需要学习。在本章中，你将扩展编程技能，开始直接调查数据集，包括 BlueLeaks 数据集和 2022 年俄罗斯入侵乌克兰后，一支支持普京的勒索软件团伙泄露的聊天记录。
- en: We’ll go over some more advanced Python topics, like how to use modules, how
    to traverse the filesystem, and how to create your own command line programs in
    Python. You’ll write programs that look through all of the files in a folder,
    including the hundreds of thousands of files in the BlueLeaks dataset, and learn
    to add arguments to your programs. You’ll also start working with a new type of
    variable in Python, the dictionary, which will prove handy for working with data
    that’s too complex to store in simple lists. As with the previous chapter, future
    chapters rely on your understanding of the topics covered here.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论一些更高级的 Python 主题，比如如何使用模块、如何遍历文件系统，以及如何在 Python 中创建自己的命令行程序。你将编写程序，查找文件夹中的所有文件，包括
    BlueLeaks 数据集中的数十万文件，并学习如何为程序添加参数。你还将开始使用 Python 中的一种新类型的变量——字典，它对于处理无法简单存储在列表中的复杂数据非常有用。与上一章一样，未来的章节依赖于你对本章内容的理解。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Modules</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">模块</samp>
- en: As you learned in [Chapter 7](chapter7.xhtml), functions are reusable blocks
    of code that you can run as many times as you want without having to rewrite any
    code. Python *modules* are similar, but instead of making a single block of code
    reusable, they make an entire Python file (or multiple files) reusable. You can
    think of a module as a separate Python file that you can load into the file you’re
    currently working on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第七章](chapter7.xhtml)中学到的，函数是可重用的代码块，你可以运行它们任意次数，而无需重新编写代码。Python *模块* 类似，但它们不仅让单个代码块可重用，而是让整个
    Python 文件（或多个文件）都可以重用。你可以将模块看作是一个独立的 Python 文件，可以将其加载到当前正在工作的文件中。
- en: Python includes a wealth of features, but most of them aren’t available to every
    Python script by default. Instead, they’re stored in *built-in* modules, those
    that come with Python. Once you import a module into your script using an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statement, you can access
    all of the functions, variables, and other Python objects defined in that module
    using the syntax <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module_name</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">item_name</samp>.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包含丰富的功能，但默认情况下并非所有功能对每个 Python 脚本都可用。相反，它们存储在 *内置* 模块中，这些模块是 Python 自带的。一旦你使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> 语句将模块导入到脚本中，你就可以通过语法
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module_name</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">item_name</samp>
    访问该模块中定义的所有函数、变量和其他 Python 对象。
- en: 'For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    module includes the function <samp class="SANS_TheSansMonoCd_W5Regular_11">time.sleep()</samp>
    (pronounced “time dot sleep”), which makes your program wait a given number of
    seconds before continuing to the next line of code. Run the following commands
    to import the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> module
    and then have it tell Python to wait five seconds:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> 模块包含函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">time.sleep()</samp>（发音为“time
    点 sleep”），它使得程序在继续执行下一行代码之前，暂停给定的秒数。运行以下命令导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    模块，然后让它指示 Python 等待五秒钟：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Your Python interpreter should wait five seconds before the prompt appears again.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Python 解释器应等待五秒钟后才会再次显示提示符。
- en: 'Here are a few of the built-in modules I use the most:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我最常用的一些内置模块：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">os</samp> Includes useful functions
    for browsing the filesystem, like <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>. It also includes
    the submodule <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path</samp>, which
    is full of functions to inspect files. For example, it includes <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp>, which
    help determine whether a specific path is a file or a folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">os</samp> 包含用于浏览文件系统的实用函数，例如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>。它还包含子模块
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path</samp>，其中有许多函数用于检查文件。例如，它包括
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp>，可以帮助判断特定路径是文件还是文件夹。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">csv</samp> Lets you work with CSV
    spreadsheet data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">csv</samp> 让你处理 CSV 电子表格数据。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">json</samp> Lets you work with
    JSON data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">json</samp> 让你处理 JSON 数据。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">datetime</samp> Includes useful
    Python features for working with dates and times. For example, it allows you to
    convert strings like <samp class="SANS_TheSansMonoCd_W5Regular_11">February 24,
    2022 5:07:20 UTC+3</samp> (the exact time that Russia invaded Ukraine) into a
    timestamp that Python can understand and compare with other timestamps, then convert
    it back into strings of any format you choose.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">datetime</samp> 包含用于处理日期和时间的实用
    Python 功能。例如，它可以将像 <samp class="SANS_TheSansMonoCd_W5Regular_11">February 24,
    2022 5:07:20 UTC+3</samp>（俄罗斯入侵乌克兰的确切时间）这样的字符串转换为 Python 可以理解并与其他时间戳进行比较的时间戳，然后再将其转换回你选择的任何格式的字符串。
- en: You’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp> module
    extensively later in this chapter, the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
    module in [Chapter 9](chapter9.xhtml), and the <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp>
    module in [Chapter 11](chapter11.xhtml). You’ll briefly see how <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    works later in this chapter when you take a look at chat logs from a ransomware
    gang, as well as in the [Chapter 14](chapter14.xhtml) case study, where you’ll
    analyze leaked neo-Nazi chat logs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章后面广泛使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp> 模块，在[第 9
    章](chapter9.xhtml)中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
    模块，在[第 11 章](chapter11.xhtml)中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp>
    模块。在本章稍后，你将简要了解 <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    的使用，当你查看来自勒索软件团伙的聊天记录时，以及在[第 14 章](chapter14.xhtml)的案例研究中，你将分析泄露的新纳粹聊天记录。
- en: 'As your programs get more complex, you might find it useful to split them up
    into multiple files, with each file containing a different part of your code.
    When you do this, you’re creating your own modules. The name of the module is
    the same as its filename. For example, if you define some functions in a file
    called *helpers.py*, another Python file can access those functions by importing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp> module. The *helpers.py*
    file could contain the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序变得越来越复杂，你可能会发现将程序拆分成多个文件是很有用的，每个文件包含你代码的不同部分。当你这样做时，你就在创建自己的模块。模块的名称与其文件名相同。例如，如果你在一个名为
    *helpers.py* 的文件中定义了一些函数，另一个 Python 文件可以通过导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp>
    模块来访问这些函数。*helpers.py* 文件可能包含以下代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This module contains two functions for calculating sales tax, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_tax()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_net_price()</samp>. The
    following Python script, *price.py*, imports it like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块包含两个用于计算销售税的函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">get_tax()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_net_price()</samp>。以下 Python
    脚本，*price.py*，通过如下方式导入：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line, <samp class="SANS_TheSansMonoCd_W5Regular_11">import helpers</samp>,
    makes the functions defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp>
    module accessible to this script. The second line calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers.get_net
    _price()</samp> function from that module and stores the return value in the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">total_price</samp>. The third line
    displays the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">total_price</samp>.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行 <samp class="SANS_TheSansMonoCd_W5Regular_11">import helpers</samp> 使得在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp> 模块中定义的函数对该脚本可用。第二行调用该模块中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers.get_net _price()</samp>
    函数，并将返回值存储在变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">total_price</samp>
    中。第三行显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">total_price</samp> 的值。
- en: 'Here’s what it looks like when I run this script:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本时，它的样子如下：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running the *price.py* script executes the code defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp>
    module. Inside that module, the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_net_price()</samp>
    function calls <samp class="SANS_TheSansMonoCd_W5Regular_11">get_tax()</samp>
    and uses its return value to calculate the net price, then returns *that* value
    back into the *price.py* script.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 *price.py* 脚本执行了在 <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp>
    模块中定义的代码。在该模块内，<samp class="SANS_TheSansMonoCd_W5Regular_11">get_net_price()</samp>
    函数调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_tax()</samp> 并使用其返回值计算净价，然后将
    *该* 值返回到 *price.py* 脚本中。
- en: Before you write your first advanced Python script in Exercise 8-1, let’s look
    at the best way to start new Python scripts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写第一个高级 Python 脚本（练习 8-1）之前，我们先来看一下启动新 Python 脚本的最佳方法。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Python Script Template</samp>
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Python 脚本模板</samp>
- en: 'I use the same basic template for all my Python scripts, putting my code into
    a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>,
    then calling that function at the bottom of the file. This isn’t required (you
    didn’t do this for any of the scripts you wrote in [Chapter 7](chapter7.xhtml),
    after all), but it’s a good way to organize your code. Here’s what it looks like:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我对所有 Python 脚本使用相同的基本模板，将代码放入一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    的函数中，然后在文件底部调用该函数。这不是必须的（毕竟你在[第 7 章](chapter7.xhtml)中编写的脚本都没有这样做），但这是一种很好的组织代码的方法。它的样子如下：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The template defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">pass</samp> statement
    that tells Python, “Skip this line.” I later replace <samp class="SANS_TheSansMonoCd_W5Regular_11">pass</samp>
    with the real body of the script.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该模板定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数，并用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pass</samp> 语句告诉 Python：“跳过这一行。”稍后我会将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pass</samp> 替换为脚本的实际内容。
- en: Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    tells Python under which conditions it should run <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>.
    Python automatically defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    variable, and the definition differs depending on what Python file is being run.
    If you’re running the currently executing Python file directly, then Python sets
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp> to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp> string. But
    if you imported the currently executing Python file from another script, Python
    sets the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    to the name of the imported module. Using the example from the previous section,
    if you run the *helpers.py* script directly, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    inside that script will be <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp>,
    but if you run the *price.py* script, then the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp> inside *price.py*
    and the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp> inside *helpers.py*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句告诉 Python 在什么条件下应该运行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>。Python 会自动定义 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp> 变量，定义的值取决于正在运行的 Python
    文件。如果你直接运行当前执行的 Python 文件，那么 Python 会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    的值设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp> 字符串。但是，如果你从另一个脚本中导入当前执行的
    Python 文件，Python 会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    的值设置为导入模块的名称。使用上一节的示例，如果你直接运行 *helpers.py* 脚本，那么该脚本内部的 <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    值将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp>，但是如果你运行 *price.py*
    脚本，那么 *price.py* 内部的 <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    值将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp>，而 *helpers.py*
    内部的 <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp> 值将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp>。
- en: In short, if you run your script directly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function will run. But if you import your script as a module into another script
    or into the Python interpreter, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function won’t run unless you call it yourself. This way, if you have multiple
    Python scripts in the same folder, you can have one script import another script
    to call the functions defined within it without worrying about calling the latter
    script’s <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果你直接运行脚本，<samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数会运行。但是，如果你将脚本作为模块导入到另一个脚本或
    Python 解释器中，除非你自己调用它，否则 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    函数不会运行。这样，如果你有多个 Python 脚本在同一个文件夹中，你可以让一个脚本导入另一个脚本并调用其中定义的函数，而不必担心调用后者脚本的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数。
- en: After I create this template script, I start filling in the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function with whatever I want the script to do. Putting the main logic of your
    script inside a function allows you to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement to end <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> early,
    which will quit the script early. You can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    when you’re not in a function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我创建这个模板脚本后，我开始在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    函数中填写我希望脚本执行的内容。将脚本的主要逻辑放入函数中，可以让你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    语句提前结束 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>，从而提前退出脚本。当你不在函数中时，不能使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>。
- en: In the following exercise, you’ll put this into practice by writing a script
    to start investigating BlueLeaks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你将通过编写脚本来开始调查 BlueLeaks，实践这一点。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-1: Traverse the Files in
    BlueLeaks</samp>'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 8-1：遍历 BlueLeaks 中的文件</samp>
- en: To efficiently investigate datasets, you need to be able to write code that
    looks through large collections—sometimes thousands or millions—of files for you.
    In this exercise, you’ll learn various ways to traverse the filesystem in Python
    using functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module, working with the BlueLeaks dataset. You’ll also rely on the foundational
    skills you learned in [Chapter 7](chapter7.xhtml), like using variables, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops, and <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效地调查数据集，你需要能够编写代码，扫描大量的文件——有时是成千上万甚至更多的文件。 在本练习中，你将学习如何使用<samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>模块中的函数，在Python中遍历文件系统，并处理BlueLeaks数据集。你还将依赖在[第7章](chapter7.xhtml)中学到的基础技能，如使用变量、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环和<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句。
- en: As you read along and run the scripts, feel free to modify the code however
    you’d like and try running those versions too. You might discover revelations
    I didn’t think to look for.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读并运行脚本时，随时可以修改代码，并尝试运行这些版本。你可能会发现一些我没有想到的启示。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">List the Filenames
    in a Folder</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">列出文件夹中的文件名</samp>
- en: 'Start by using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>
    to list the files in the *BlueLeaks-extracted* folder. In your text editor, create
    a file called *list-files1.py* and enter this short script (or copy and paste
    it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/list<wbr>-files1<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/list-files1.py)):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用<samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>列出*BlueLeaks-extracted*文件夹中的文件。在你的文本编辑器中，创建一个名为*list-files1.py*的文件，并输入这段简短的脚本（或从[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/list<wbr>-files1<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/list-files1.py)复制粘贴它）：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, the script imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module. It then defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    with the path of the *BlueLeaks-extracted* folder (update the script to include
    the path of this folder on your own computer). The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>
    function takes the path to the folder as an argument and returns a list of filenames
    in that folder. The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to loop through the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir(blueleaks_path)</samp>,
    displaying each filename.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，脚本导入了<samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>模块。然后，它定义了变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>，该变量保存了*BlueLeaks-extracted*文件夹的路径（请更新脚本以包含该文件夹在你计算机上的路径）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>函数接受文件夹路径作为参数，并返回该文件夹中的文件名列表。代码使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历<samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir(blueleaks_path)</samp>的输出，显示每个文件名。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Windows paths include the backslash character (<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\</samp>),
    which Python strings consider an escape character. For example, if your* BlueLeaks-extracted
    *folder is located at* D:\BlueLeaks-extracted*, Python will misinterpret the string
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">"D:\BlueLeaks-extracted"</samp>,
    assuming that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\B</samp>
    is a special character. To escape your backslashes for any Windows path you store
    as a string, use <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\\</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\</samp>. In
    this case, set the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">blueleaks_path</samp>
    string to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">"D:\\BlueLeaks-extracted"</samp>.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Windows路径包括反斜杠字符(<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\</samp>)，而Python字符串将其视为转义字符。例如，如果你的*
    BlueLeaks-extracted *文件夹位于* D:\BlueLeaks-extracted*，Python会误解字符串 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">"D:\BlueLeaks-extracted"</samp>，认为
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\B</samp>是一个特殊字符。为了正确表示任何存储为字符串的Windows路径，请使用
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\\</samp> 而不是 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\</samp>。在这种情况下，将
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">blueleaks_path</samp> 字符串设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">"D:\\BlueLeaks-extracted"</samp>。*'
- en: 'Run this script. Here’s what the output looks like on my computer:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本。以下是我电脑上输出的内容：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, you’ll try something slightly more advanced. Instead of just listing the
    filenames in BlueLeaks, you’ll check each filename to see whether it’s a folder,
    and if so, you’ll open each of those folders and count how many files and subfolders
    they contain.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将尝试稍微复杂一点的操作。你不仅仅列出BlueLeaks中的文件名，还会检查每个文件名是否是文件夹，如果是文件夹，你将打开每个文件夹并统计它们包含多少个文件和子文件夹。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Count the Files and
    Folders in a Folder</samp>
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">计算文件夹中的文件和文件夹数量</samp>
- en: 'Create a file called *list-files2.py* and enter the following code (or copy
    and paste it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/list<wbr>-files2<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/list-files2.py)):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*list-files2.py*的文件，并输入以下代码（或从 [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/list<wbr>-files2<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/list-files2.py)
    复制粘贴）：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This script counts the number of files and folders it finds within each BlueLeaks
    folder. It starts like *list-files1.py* does, importing <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    and defining the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    variable (remember to update the variable’s value to match the correct path on
    your computer).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本计算它在每个BlueLeaks文件夹中找到的文件和文件夹的数量。它像*list-files1.py*一样开始，导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    模块，并定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> 变量（记得更新变量的值以匹配你电脑上的正确路径）。
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop cycles
    through the filenames in your *BlueLeaks-extracted* folder, this time saving each
    filename in the <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder</samp>
    variable, so its value will be something like <samp class="SANS_TheSansMonoCd_W5Regular_11">miacx</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ncric</samp> ❶. The script then
    sets the value of the new <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp>
    variable accordingly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp>
    function connects filenames together to make complete paths. Its first argument
    is the starting path, and it adds all other arguments to the end of that path.
    For example, if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">miacx</samp>, then this function
    will return the string <samp class="SANS_TheSansMonoCd_W5Regular_11">/Volumes/datasets/BlueLeaks-extracted/miacx</samp>
    on my computer (the output will be different if your <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    is different or if you’re using Windows and your filenames use backslashes instead
    of slashes).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历 *BlueLeaks-extracted*
    文件夹中的文件名，这一次将每个文件名保存在 <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder</samp>
    变量中，因此它的值会类似于 <samp class="SANS_TheSansMonoCd_W5Regular_11">miacx</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ncric</samp> ❶。接下来，脚本相应地设置新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp>
    变量的值。<samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp> 函数将文件名连接起来，形成完整的路径。它的第一个参数是起始路径，然后将所有其他参数添加到路径的末尾。例如，如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder</samp> 的值是 <samp class="SANS_TheSansMonoCd_W5Regular_11">miacx</samp>，那么该函数将返回字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/Volumes/datasets/BlueLeaks-extracted/miacx</samp>（如果你的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> 不同，或者你使用的是
    Windows 且文件名使用反斜杠而不是斜杠，输出结果会有所不同）。
- en: Since you want to look inside <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp>
    and count the number of files and folders it contains, the script needs to check
    that it’s actually a folder and not a file, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp>
    function ❷. If <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp>
    isn’t a folder, the script runs the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement. This statement, which can run only inside of loops, tells Python to
    immediately continue on to the next iteration of the loop. In short, if the script
    comes across a file instead of a folder, it ignores it and moves on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你想要查看 <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp>
    目录内部并统计它包含的文件和文件夹数量，脚本需要检查它是否确实是一个文件夹而不是一个文件，可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp>
    函数 ❷。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp> 不是一个文件夹，脚本会执行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句。这个语句只能在循环内部执行，告诉
    Python 立即继续到下一次循环的迭代。简而言之，如果脚本遇到的是一个文件而不是文件夹，它会忽略它并继续向下执行。
- en: The script then prepares to count the number of files and folders within each
    individual BlueLeaks folder as the code loops by defining the variables <samp
    class="SANS_TheSansMonoCd_W5Regular_11">files_count</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">folders_count</samp>
    with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> ❸.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本准备计算每个单独的 BlueLeaks 文件夹中的文件和文件夹数量，在循环中定义变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">files_count</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">folders_count</samp>，并将它们的初始值设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> ❸。
- en: A second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop loops
    through the files in the BlueLeaks folder from the first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, saving each filename in the <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    variable ❹. Inside this loop, the script defines <samp class="SANS_TheSansMonoCd_W5Regular_11">filename_path</samp>
    as the absolute path for the filename under consideration. For instance, if the
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> is a string
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory.csv</samp>, then
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">filename_path</samp>
    would be a string like <samp class="SANS_TheSansMonoCd_W5Regular_11">/Volumes/datasets/BlueLeaks-extracted/211sfbay/Directory.csv</samp>.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>` 循环遍历第一个 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>` 循环中的 BlueLeaks 文件夹中的文件，将每个文件名保存在
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>` 变量中 ❹。在这个循环内部，脚本将
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">filename_path</samp>` 定义为当前文件名的绝对路径。例如，如果
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>` 的值是像 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Directory.csv</samp>`
    这样的字符串，那么 `<samp class="SANS_TheSansMonoCd_W5Regular_11">filename_path</samp>`
    的值将是像 `<samp class="SANS_TheSansMonoCd_W5Regular_11">/Volumes/datasets/BlueLeaks-extracted/211sfbay/Directory.csv</samp>`
    这样的字符串。
- en: The script then checks to see if this absolute path is a file or a folder, using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp> functions
    ❺. If the path is a file, the script increments the <samp class="SANS_TheSansMonoCd_W5Regular_11">files_count</samp>
    variable by 1; if it’s a folder, the script increments <samp class="SANS_TheSansMonoCd_W5Regular_11">folders_count</samp>
    by 1\. When the second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop finishes running, these two variables should contain the total count of files
    and folders for the BlueLeaks folder you’re currently looping through in the first
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. Finally, the script
    displays an f-string that shows these numbers ❻.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本接着会检查这个绝对路径是文件还是文件夹，使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp>`
    和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp>` 函数 ❺。如果路径是文件，脚本会将
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">files_count</samp>` 变量增加 1；如果是文件夹，脚本会将
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">folders_count</samp>` 增加 1。当第二个
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>` 循环执行完毕时，这两个变量应该包含你当前在第一个
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>` 循环中遍历的 BlueLeaks 文件夹的文件和文件夹总数。最后，脚本会显示一个
    f-string，展示这些数字 ❻。
- en: 'Try running the script. The output should show how many files and folders are
    contained in each BlueLeaks folder, potentially with the list of folders in a
    different order:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行脚本。输出应该显示每个 BlueLeaks 文件夹包含的文件和文件夹数量，并可能显示文件夹的列表顺序有所不同：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So far, you’ve combined various functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module to make a list of filenames in your BlueLeaks folder and check whether
    each name actually refers to a file or to another folder. Now it’s time to learn
    to write code that can also traverse the BlueLeaks folder’s nested folders.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经结合了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>` 模块中的各种函数，列出了
    BlueLeaks 文件夹中的文件名，并检查每个名字是否实际上是文件还是另一个文件夹。现在是时候学习编写可以遍历 BlueLeaks 文件夹中嵌套文件夹的代码了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Traverse Folders with os.walk()</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 os.walk() 遍历文件夹</samp>
- en: Let’s say you want to write a program that displays all of the files in a folder
    and its subfolders, and its subsubfolders, and so on. When you have nested folders
    but don’t actually know how deep the folder structure goes, listing all of the
    filenames just by using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.path .isdir()</samp> isn’t so simple.
    Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function
    solves this problem.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编写一个程序，显示文件夹及其子文件夹、子子文件夹等所有文件。当你有嵌套文件夹时，且不知道文件夹结构的深度，仅使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>`、`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp>`
    列出所有文件名并不那么简单。Python 的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>`
    函数解决了这个问题。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function
    takes a path to a folder as an argument and returns a list of *tuples*, or multiple
    values contained in a single value. To define a tuple, you place all of the values,
    separated by commas, within parentheses. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">(3,
    4)</samp> is a tuple, as is <samp class="SANS_TheSansMonoCd_W5Regular_11">("cinco",
    "seis", "siete")</samp>. Tuples can also contain mixed types like <samp class="SANS_TheSansMonoCd_W5Regular_11">(1,
    "dos")</samp> and can contain any number of values.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> 函数将文件夹路径作为参数，并返回一个包含多个值的
    *元组* 列表。要定义一个元组，你需要将所有值用逗号分隔并放在括号中。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">(3,
    4)</samp> 是一个元组，<samp class="SANS_TheSansMonoCd_W5Regular_11">("cinco", "seis",
    "siete")</samp> 也是一个元组。元组也可以包含混合类型的值，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">(1,
    "dos")</samp>，并且可以包含任意数量的值。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function
    returns a list of tuples where each tuple contains three values:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> 函数返回一个元组列表，每个元组包含三个值：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'where <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp> is a string,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp> is a list of
    strings, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp> is
    a list of strings. For example, the following code loops through the return value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk(path)</samp>:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp> 是一个字符串，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp> 是一个字符串列表，<samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>
    是一个字符串列表。例如，以下代码会遍历 <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk(path)</samp>
    的返回值：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you use <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    to loop through lists, you normally assign just a single variable to each item
    in the list. However, since each item is a tuple, you can assign three variables
    to it: <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>. In each loop,
    the values for this set of variables will be different: the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>
    is the path to a folder, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>
    is a list of subfolders inside that folder, and the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>
    is a list of files inside that folder.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>` 循环遍历列表时，通常会为列表中的每一项分配一个单独的变量。然而，由于每个项目是一个元组，你可以为它分配三个变量：`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>`、<samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>。在每次循环中，这组变量的值会有所不同：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp> 的值是文件夹的路径，<samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>
    的值是该文件夹中的子文件夹列表，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>
    的值是该文件夹中的文件列表。
- en: 'For example, suppose you have a folder called *example* that contains these
    subfolders and files:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个名为 *example* 的文件夹，它包含这些子文件夹和文件：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This folder has two subfolders: *downloads* (containing *screenshot.png* and
    *paper.pdf*) and *documents*. The *documents* folder has its own subfolders: *work*
    (containing *finances.xlsx*) and *personal*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹有两个子文件夹：*downloads*（包含 *screenshot.png* 和 *paper.pdf*）和 *documents*。*documents*
    文件夹有它自己的子文件夹：*work*（包含 *finances.xlsx*）和 *personal*。
- en: 'The following commands loop through the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk
    ("./example")</samp>, where *./example* is the path to this *example* folder,
    to find the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>
    for each loop:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令会遍历 <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk("./example")</samp>
    的返回值，其中 *./example* 是指向 *example* 文件夹的路径，以查找每次循环中 <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>
    的值：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running this command returns the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会返回以下输出：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code loops once for each folder, including all subfolders, with the path
    to that folder stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>.
    The list of subfolders in that folder is stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>,
    and the list of files is stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>.
    Once you’ve looped through the folder and all of its subfolders, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop ends.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码每次循环都会针对一个文件夹，包括所有的子文件夹，文件夹的路径存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>
    中。该文件夹中的子文件夹列表存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>
    中，文件列表存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp> 中。一旦遍历完文件夹及其所有子文件夹，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环就会结束。
- en: Any time you need to traverse all of the files in a dataset that contains lots
    of nested folders, you’ll want to use <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>.
    With a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, you’ll
    be able to write code that inspects each file in the entire dataset. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function has many uses,
    including figuring out which files are the largest or smallest, as you’ll see
    next.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要遍历包含大量嵌套文件夹的数据集中的所有文件时，你将希望使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>。通过一个简单的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环，你就能够编写代码，检查整个数据集中的每个文件。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> 函数有许多用途，包括找出哪些文件是最大的或最小的，正如接下来你将看到的那样。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-2: Find the Largest Files
    in BlueLeaks</samp>'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">练习 8-2: 查找 BlueLeaks 中最大的文件</samp>'
- en: In this exercise, you’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>
    to write a script that looks through all the files, folders, and subfolders in
    BlueLeaks; measures the size of each file; and displays the filenames for files
    over 100MB. This code allows you to loop through all of the files in a folder,
    no matter how deep the folder structure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> 编写一个脚本，遍历
    BlueLeaks 中的所有文件、文件夹和子文件夹；测量每个文件的大小；并显示超过 100MB 的文件名。这个代码允许你循环遍历文件夹中的所有文件，无论文件夹结构有多深。
- en: 'Create a file called *find-big-files.py* and enter the following code (or copy
    and paste it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/find<wbr>-big<wbr>-files<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/find-big-files.py)):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *find-big-files.py* 的文件，并输入以下代码（或从 [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/find<wbr>-big<wbr>-files<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/find-big-files.py)
    复制并粘贴代码）：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function,
    the script first defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    variable as the path of the *BlueLeaks-extracted* folder and loops through all
    of the files in the entire BlueLeaks dataset using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>
    function. Inside each loop in the first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop are the <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>
    variables. Each item in the list that <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>
    returns represents a different folder or subfolder in the BlueLeaks dataset, so
    by the time this loop finishes, the code will have traversed the entire dataset.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数中，脚本首先将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> 变量定义为 *BlueLeaks-extracted*
    文件夹的路径，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> 函数遍历整个
    BlueLeaks 数据集中的所有文件。在第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环中的每次循环中，都有 <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>
    变量。<samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> 返回的每个项目表示 BlueLeaks
    数据集中的一个不同文件夹或子文件夹，因此当这个循环结束时，代码将已经遍历了整个数据集。
- en: To find the biggest files, the next step is to look at each file with another
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, this time looping
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>. Inside
    this second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the
    script defines <samp class="SANS_TheSansMonoCd_W5Regular_11">absolute_filename</samp>
    to be the absolute path to the filename. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>
    tells the script which folder it’s looking in, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    tells the script which file it’s looking at, the script passes these values into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp> to combine
    them, creating the absolute path to the filename.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到最大的文件，下一步是使用另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环查看每个文件，这次是循环遍历 <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>。在这个第二个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环中，脚本将 <samp class="SANS_TheSansMonoCd_W5Regular_11">absolute_filename</samp>
    定义为文件名的绝对路径。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp> 告诉脚本它正在查看哪个文件夹，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> 告诉脚本它正在查看哪个文件，脚本将这些值传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp> 以将它们合并，创建文件名的绝对路径。
- en: A new function, <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.getsize()</samp>,
    returns the size, in bytes, of the file under consideration and stores it in the
    variable <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_bytes</samp>. The
    script then converts this value from bytes to megabytes (storing that in the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_mb</samp>) and checks if
    it’s greater than or equal to 100MB. If it is, the output displays its filename
    and file size in megabytes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.getsize()</samp>，返回所考虑文件的大小（以字节为单位），并将其存储在变量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_bytes</samp> 中。脚本接着将该值从字节转换为兆字节（并将其存储在变量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_mb</samp> 中），并检查它是否大于或等于
    100MB。如果是，输出将显示文件名及其大小（以兆字节为单位），通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    函数显示。
- en: 'Try running the script. It will take longer than the previous scripts in this
    chapter, because this time, you’re measuring the size of every single file in
    BlueLeaks. Here’s what the output looks like when I run it (your output may be
    displayed in a different order):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个脚本。它将比本章之前的脚本运行得更慢，因为这一次，你要测量 BlueLeaks 中每一个文件的大小。以下是我运行它时输出的样子（你的输出可能会以不同的顺序显示）：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The script should display the absolute paths of the 101 files in BlueLeaks that
    are at least 100MB, along with each file’s size.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本应显示 BlueLeaks 中至少 100MB 的 101 个文件的绝对路径，以及每个文件的大小。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Third-Party Modules</samp>
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">第三方模块</samp>
- en: In addition to built-in modules, Python also supports third-party modules that
    you can easily incorporate into your own code. Most Python scripts that I write,
    even simple ones, rely on at least one third-party module (when a Python program
    depends on third-party modules, they’re called *dependencies*). In this section,
    you’ll learn how to install third-party modules and use them in your own scripts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置模块，Python 还支持第三方模块，你可以轻松地将其集成到自己的代码中。我编写的大多数 Python 脚本，即使是简单的脚本，也依赖于至少一个第三方模块（当
    Python 程序依赖第三方模块时，这些模块被称为*依赖项*）。在这一节中，你将学习如何安装第三方模块并在自己的脚本中使用它们。
- en: The Python Package Index (PyPI) contains hundreds of thousands of third-party
    Python *packages*, or bundles of Python modules, and subpackages. Pip, which stands
    for Package Installer for Python, is a package manager similar to Ubuntu’s apt
    or macOS’s Homebrew used to install packages hosted on PyPI. You can search for
    packages on PyPI’s website ([*https://<wbr>pypi<wbr>.org*](https://pypi.org)),
    then install a package by running the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python3
    -m pip install</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">package_name</samp>
    command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包索引（PyPI）包含数十万个第三方 Python *包*，即 Python 模块和子包的集合。Pip，即 Python 包安装器，是一个类似于
    Ubuntu 的 apt 或 macOS 的 Homebrew 的包管理器，用于安装托管在 PyPI 上的包。你可以在 PyPI 的网站上搜索包（[*https://<wbr>pypi<wbr>.org*](https://pypi.org)），然后通过运行
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python3 -m pip install</samp> <samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">package_name</samp> 命令来安装一个包。
- en: 'For example, I frequently use a package called Click, which stands for Command
    Line Interface Creation Kit. The <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    Python module makes it simple to add command line arguments to your scripts. To
    see what happens when you try importing this module before you’ve installed it,
    open a Python interpreter and run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">import
    click</samp>. Assuming you don’t already have the package installed, you should
    see a <samp class="SANS_TheSansMonoCd_W5Regular_11">ModuleNotFoundError</samp>
    error message:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我经常使用一个叫做 Click 的包，它代表的是命令行接口创建工具包（Command Line Interface Creation Kit）。`click`
    Python 模块使得向脚本添加命令行参数变得简单。要查看在尚未安装该模块的情况下尝试导入它会发生什么，打开 Python 解释器并运行 `<samp class="SANS_TheSansMonoCd_W7Bold_B_11">import
    click</samp>`。假设你尚未安装该包，你应该会看到一个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">ModuleNotFoundError</samp>`
    错误信息：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now exit the Python interpreter and install <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    with pip by running the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在退出 Python 解释器，并通过运行以下命令使用 pip 安装 `<samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>`：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the Python interpreter again and try importing <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    once more:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开 Python 解释器，尝试重新导入 `<samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>`：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If no error messages pop up, you’ve successfully imported the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, and its additional features are now available for you to use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有弹出错误信息，说明你已经成功导入了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>`
    模块，并且它的附加功能现在可以使用了。
- en: 'The command to uninstall a package is <samp class="SANS_TheSansMonoCd_W5Regular_11">python3
    -m pip uninstall</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">package_name</samp>.
    Try uninstalling <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载包的命令是 `<samp class="SANS_TheSansMonoCd_W5Regular_11">python3 -m pip uninstall</samp>`
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">package_name</samp>。尝试卸载
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>`：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, when I ran this command, the output listed the files that pip
    would need to delete to uninstall the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, then asked if I wanted to proceed. I entered <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    and pressed ENTER, and the files were deleted and the module uninstalled.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我运行这个命令时，输出列出了 pip 需要删除的文件，以卸载 `<samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>`
    模块，然后询问我是否要继续。我输入了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>` 并按下了回车键，文件被删除，模块被卸载。
- en: 'You can install multiple Python packages at once like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像下面这样一次性安装多个 Python 包：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The same is true of uninstalling.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载操作也同样适用。
- en: 'It’s common to define the Python packages that your script requires inside
    a file called *requirements.txt*, then install all of them at once with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">python3 -m pip install -r requirements.txt</samp>
    command. For example, suppose in addition to using <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>,
    you want to use the HTTP client <samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp>
    to load web pages inside Python and the <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlalchemy</samp>
    module to work with SQL databases. To include all three in your Python script,
    first create a *requirements .txt* file with each package name on its own line:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在一个名为 *requirements.txt* 的文件中定义脚本所需的 Python 包，然后使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">python3
    -m pip install -r requirements.txt</samp>` 命令一次性安装所有包。例如，假设除了使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>`，你还想使用
    HTTP 客户端 `<samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp>` 来加载 Python
    中的网页，并且使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">sqlalchemy</samp>` 模块来处理
    SQL 数据库。为了在 Python 脚本中包含这三者，首先创建一个 *requirements.txt* 文件，将每个包的名称写在单独的一行上：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then run the following command to install them simultaneously:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令以同时安装它们：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, this command installs more than just those three Python packages:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rfc3986</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">certifi</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sniffio</samp>, and so on are also
    included. That’s because <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlachemy</samp>
    have dependencies of their own. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">httpcore</samp>
    is a dependency of the <samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp>
    package, so it installs that as well. To summarize, the *requirements.txt* file
    defines your project’s dependencies, each of which might depend on its own list
    of packages.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个命令不仅仅安装了那三个 Python 包：<samp class="SANS_TheSansMonoCd_W5Regular_11">rfc3986</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">certifi</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">sniffio</samp>，等等也被包含在内。这是因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlachemy</samp> 各自有自己的依赖项。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">httpcore</samp> 是 <samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp>
    包的依赖项，因此也会安装它。总结一下，*requirements.txt* 文件定义了你项目的依赖项，每个依赖项可能会有自己的一组包。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*To learn more about how to use* *httpx* *and other Python modules to automate
    interacting with websites, check out [Appendix B](appendixB.xhtml). I recommend
    waiting until you complete [Chapters 7](chapter7.xhtml), [8](chapter8.xhtml),
    [9](chapter9.xhtml), and [11](chapter11.xhtml), however, since the instructions
    covered in [Appendix B](appendixB.xhtml) rely on the skills you’ll pick up in
    those chapters.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*要了解更多关于如何使用* *httpx* *以及其他 Python 模块来自动化与网站的交互，查阅 [附录 B](appendixB.xhtml)。不过我建议你等到完成
    [第 7 章](chapter7.xhtml)、[第 8 章](chapter8.xhtml)、[第 9 章](chapter9.xhtml) 和 [第 11
    章](chapter11.xhtml) 后再学习，因为 [附录 B](appendixB.xhtml) 中的内容依赖于你在这些章节中学到的技能。*'
- en: Now that you know how to install third-party modules, you’ll practice using
    Click.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何安装第三方模块，接下来你将练习使用Click。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-3: Practice Command Line
    Arguments with Click</samp>'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 8-3：使用 Click 练习命令行参数</samp>
- en: As you learned in the previous section, the Click package makes it simple to
    add command line arguments to your scripts. You can use it to define variables
    to pass into your <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function from the terminal, without having to define those variables in your code.
    In this exercise, you’ll learn how to use Click by writing a sample script in
    preparation for using this module in later exercises.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节中所学到的，Click 包使得将命令行参数添加到脚本中变得非常简单。你可以使用它来定义变量，从终端将这些变量传递到你的 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    函数，而不需要在代码中定义这些变量。在这个练习中，你将通过编写一个示例脚本来学习如何使用 Click，为后续练习中使用这个模块做准备。
- en: 'First, install the Click package with pip again by running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python3
    -m pip install click</samp>. Next, open your text editor and enter the following
    Python script, *exercise-8-3.py* (or copy and paste it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-3<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-3.py)):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，再次使用 pip 安装 Click 包，通过运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python3
    -m pip install click</samp>。接下来，打开你的文本编辑器，输入以下 Python 脚本，*exercise-8-3.py*（或从
    [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-3<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-3.py)
    复制并粘贴）：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, the script imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module. It then runs a few *decorators*, function calls that begin with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">@</samp> and add functionality to another
    function you’re about to define—the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, in this case. The <samp class="SANS_TheSansMonoCd_W5Regular_11">@click.command()</samp>
    decorator tells Click that <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    is a command, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">@click .argument("name")</samp>
    decorator tells Click that this command has an argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，脚本导入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> 模块。接着它运行了一些
    *装饰器*，这些是以 <samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp> 开头的函数调用，它们为你即将定义的另一个函数——在此案例中是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数——添加功能。<samp class="SANS_TheSansMonoCd_W5Regular_11">@click.command()</samp>
    装饰器告诉 Click <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 是一个命令，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">@click.argument("name")</samp> 装饰器告诉
    Click 这个命令有一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 的参数。
- en: Next, the script defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, which takes <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    as an argument. This function has a docstring, <samp class="SANS_TheSansMonoCd_W5Regular_11">Simple
    program that greets NAME</samp>. Click uses this docstring for its commands when
    it builds the output for <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>,
    as you’ll see shortly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function simply displays a string with the name you passed in as an argument.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，脚本定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数，该函数以
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 作为参数。这个函数有一个文档字符串，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Simple program that greets NAME</samp>。Click
    使用这个文档字符串来生成 <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp> 命令的输出，正如你很快会看到的那样。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数仅仅显示你作为参数传入的名字。
- en: Finally, the script calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function. Notice that even though <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    requires an argument (<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>),
    the script doesn’t explicitly pass that argument in when calling the function.
    This is where the magic of the Click decorators comes in. When the script calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>, Click will figure
    out what arguments it needs to pass in, find their values from the CLI arguments,
    and pass them in for you.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，脚本调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数。请注意，尽管
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数需要一个参数（<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>），但是脚本在调用该函数时并没有显式传递该参数。这就是
    Click 装饰器的魔力所在。当脚本调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    时，Click 会自动判断需要传入哪些参数，查找 CLI 参数中的值，然后为你传入这些值。
- en: 'Run the script as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 按照如下方式运行脚本：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you run the program, if you don’t pass in the correct CLI arguments, Click
    tells you what you did wrong. As you can see, you’re missing the required <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp> argument. Click also tells
    you that you can get help by running the script again with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    argument.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，如果没有传入正确的 CLI 参数，Click 会告诉你哪里出错了。正如你所看到的，你缺少了必需的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp>
    参数。Click 还会告诉你可以通过再次运行脚本并传入 <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    参数来获取帮助。
- en: 'Try running the <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp> 命令：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This time, the output shows a description of the program based on the docstring.
    Any CLI program that uses Click will display the docstring for the command when
    you run it with <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出将显示基于文档字符串的程序描述。任何使用 Click 的 CLI 程序，在你运行它并传入 <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    时，都会显示该命令的文档字符串。
- en: 'Try running the command again, this time passing in a name. For example, here’s
    what happens when I pass in <samp class="SANS_TheSansMonoCd_W5Regular_11">Eve</samp>
    as the name:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次运行命令，这次传入一个名字。例如，当我传入 <samp class="SANS_TheSansMonoCd_W5Regular_11">Eve</samp>
    作为名字时，结果是这样的：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You can read more about using Click at* [https://click.palletsprojects.com](https://click.palletsprojects.com)*.*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在此阅读更多关于使用 Click 的信息：* [https://click.palletsprojects.com](https://click.palletsprojects.com)*。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Avoiding Hardcoding with Command Line
    Arguments</samp>
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">通过命令行参数避免硬编码</samp>
- en: As you’ve seen in previous chapters, CLI arguments let you run the same program
    in many different ways, targeting different data. For example, in [Chapter 4](chapter4.xhtml),
    you used the <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp> command to
    estimate the disk space of a folder by adding the folder’s path as an argument.
    In <samp class="SANS_TheSansMonoCd_W5Regular_11">du -sh --apparent-size</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">path</samp>, the arguments
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">-sh</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">--apparent-size</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">path</samp>.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前几章中看到的，CLI 参数允许你以多种方式运行同一个程序，针对不同的数据。例如，在[第 4 章](chapter4.xhtml)中，你使用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp> 命令，通过将文件夹路径作为参数来估算文件夹的磁盘空间。在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">du -sh --apparent-size</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">path</samp> 中，参数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">-sh</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">--apparent-size</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">path</samp>。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp> command would be
    much less useful if it could measure disk space for only a single hardcoded folder.
    *Hardcoding* means embedding information, like a path, directly into source code.
    You can avoid hardcoding anything in your CLI programs by having the user provide
    this information as arguments when running them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp> 命令只能测量单个硬编码文件夹的磁盘空间，它的用途将大大降低。*硬编码*意味着将信息（如路径）直接嵌入到源代码中。通过让用户在运行程序时作为参数提供这些信息，你可以避免在
    CLI 程序中硬编码任何内容。
- en: Passing paths into scripts, rather than hardcoding them, makes for a better
    user experience. In previous exercises in this chapter, you hardcoded the path
    to your copy of the BlueLeaks dataset into your Python scripts. If you were to
    pass the appropriate path in as an argument, however, other people could use your
    script without editing it—they could just pass in *their* path when they ran it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将路径传入脚本，而不是硬编码它们，会带来更好的用户体验。在本章之前的练习中，你将 BlueLeaks 数据集的路径硬编码到 Python 脚本中。然而，如果你将适当的路径作为参数传入，其他人也可以在不修改脚本的情况下使用它——他们只需在运行时传入*他们*的路径即可。
- en: Using arguments rather than hardcoding can also make your scripts more universally
    useful. For example, in Exercise 8-2, you wrote a script to find all of the files
    that are at least 100MB in the BlueLeaks dataset. Using CLI arguments, you could
    make this script work for any dataset you get your hands on, not just BlueLeaks,
    and for any minimum file size, allowing you to run it in a variety of situations.
    You’d just need to pass in the dataset path and the minimum file size as CLI arguments.
    You’ll try this out in the next exercise.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数而不是硬编码也可以使你的脚本更具普适性。例如，在练习 8-2 中，你编写了一个脚本来查找 BlueLeaks 数据集中所有至少 100MB 的文件。通过使用
    CLI 参数，你可以让这个脚本适用于任何数据集，而不仅仅是 BlueLeaks，还可以设置任何最小文件大小，使得你能在各种情况中运行它。你只需要将数据集路径和最小文件大小作为
    CLI 参数传入即可。你将在下一个练习中尝试这个。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-4: Find the Largest Files
    in Any Dataset</samp>'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 8-4：在任何数据集中查找最大的文件</samp>
- en: In this exercise, you’ll modify the script you wrote in Exercise 8-2 to make
    it work for any dataset, and for any minimum file size, using CLI arguments. In
    the following chapters, you’ll write simple Python scripts that use Click for
    CLI arguments, so you can provide the paths to the datasets you’ll be working
    with.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将修改在练习 8-2 中编写的脚本，使其能够处理任何数据集和任何最小文件大小，使用 CLI 参数。在接下来的章节中，你将编写简单的 Python
    脚本，利用 Click 处理 CLI 参数，这样你就可以提供你将要使用的数据集路径。
- en: 'Create a new file called *exercise-8-4.py*, and copy and paste the *exercise-8-2
    .py* code into it. Next, make the following modifications to the code, highlighted
    in bold (or find the full modified script at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-4<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-4.py)):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*exercise-8-4.py*的新文件，并将*exercise-8-2.py*代码复制粘贴到其中。接下来，按照加粗部分修改代码（或者在[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-4<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-4.py)查看完整的修改脚本）：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module at the top of the file. Next, it adds Click decorators before the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function: <samp class="SANS_TheSansMonoCd_W5Regular_11">@click.command()</samp>
    makes the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function
    a Click command, and <samp class="SANS_TheSansMonoCd_W5Regular_11">@click.argument()</samp>
    adds <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>
    as arguments. The script specifies with <samp class="SANS_TheSansMonoCd_W5Regular_11">type=click.INT</samp>
    that the <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp> argument
    should be an *integer*, or a whole number, as opposed to a string. Then it adds
    <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>
    as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function and adds a docstring that describes what this command does.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在文件的顶部导入了<samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>模块。接着，它在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>函数之前添加了Click装饰器：<samp class="SANS_TheSansMonoCd_W5Regular_11">@click.command()</samp>使得<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>函数成为一个Click命令，而<samp class="SANS_TheSansMonoCd_W5Regular_11">@click.argument()</samp>将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">path</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>添加为参数。脚本通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">type=click.INT</samp>指定<samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>参数应为*整数*，即一个完整的数字，而不是字符串。然后，它将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">path</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>作为参数添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>函数，并添加了一个描述该命令功能的文档字符串。
- en: The new script uses arguments instead of hardcoded values. It deletes the line
    that defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    variable, and in the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>
    function call, it changes <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    to just <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>, which is the
    argument. Finally, it changes <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_mb</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 新的脚本使用参数而不是硬编码的值。它删除了定义<samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>变量的那一行，并在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>函数调用中，将<samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>改为参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">path</samp>。最后，它将<samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_mb</samp>中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">100</samp>改为<samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>。
- en: 'You can now use this program to find big files in any folder in the BlueLeaks
    dataset or elsewhere. For example, here’s what it looks like when I search for
    all files that are at least 500MB in */Applications* on my Mac:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这个程序查找BlueLeaks数据集或其他地方任何文件夹中的大文件。例如，当我在Mac的*/Applications*目录下查找所有至少500MB的文件时，它看起来是这样的：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, I have only two apps installed that include files this big:
    Dangerzone and Docker Desktop.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我安装的应用中只有两个包含这么大文件的：Dangerzone和Docker Desktop。
- en: Now that you’ve seen how to add CLI arguments to your Python scripts using Click,
    you should be able to avoid hardcoding information like dataset paths in your
    future programs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用Click向Python脚本添加CLI参数，未来编写程序时，你应该能够避免像数据集路径这样的信息被硬编码。
- en: Next, we’ll switch gears and explore a new powerful type of Python variable
    called dictionaries.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转换方向，探索一种新的强大类型的Python变量——字典。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dictionaries</samp>
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">字典</samp>
- en: In the course of your investigations, sometimes you’ll need to keep track of
    data with more structure than a simple list. To do so, you can use Python dictionaries.
    Instead of a collection of items, a *dictionary* (*dict* for short) is a collection
    of keys that map to values. *Keys* are labels that you use to save or retrieve
    information in a dictionary, and *values* are the actual information being saved
    or retrieved. Nearly every Python script I write that deals with data uses dictionaries.
    In this section, you’ll learn how to define dictionaries, get values from them,
    add values to them, and update existing values in them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的探索过程中，有时你需要记录比简单列表更具结构的数据。为此，你可以使用Python字典。与一组项目不同，*字典*（简写为*dict*）是一个键的集合，键映射到对应的值。*键*是你用来在字典中保存或获取信息的标签，*值*是实际保存或获取的信息。我写的几乎每个涉及数据的Python脚本都会使用字典。在这一节中，你将学习如何定义字典、从字典中获取值、向字典中添加值以及更新字典中的现有值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Dictionaries</samp>
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义字典</samp>
- en: 'Dictionaries are defined using braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}),
    sometimes referred to as curly brackets. Inside the braces is a list of key-value
    pairs in the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">key</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">value</samp>,
    where each pair is separated from the next by commas—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">{"country":
    "Italy", "drinking_age": 18}</samp>. For longer dictionaries, you can make your
    code more readable by putting each key-value pair on its own line.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '字典使用大括号（<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>和<|samp class="SANS_TheSansMonoCd_W5Regular_11">}）定义，有时也被称为花括号。在大括号内是按格式排列的键值对列表，格式为<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">key</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">value</samp>，每一对键值之间用逗号分隔，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{"country": "Italy", "drinking_age": 18}</samp>。对于较长的字典，你可以通过将每个键值对放在独立的行上来提高代码的可读性。'
- en: '[Listing 8-1](#list8-1) shows an example dictionary stored in the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp>.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-1](#list8-1) 显示了存储在变量<samp class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp>中的字典示例。'
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: A dictionary stored
    in the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">capitals</samp>
    variable</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1：存储在<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">capitals</samp>变量中的字典</samp>
- en: In this case, the keys are country names and the values are the capitals of
    those countries.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，键是国家名称，而值是这些国家的首都。
- en: 'Each key in a dictionary can have only one value. If you try to set the same
    key more than once, Python will save the version you last set. For example, if
    you define a dictionary and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    key more than once, the dictionary will overwrite the previous value with the
    most recent one:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的每个键只能有一个值。如果你尝试多次设置相同的键，Python将保存你最后设置的版本。例如，如果你定义一个字典并多次使用<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>键，字典将用最新的值覆盖之前的值：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, you can also use lists, or other dictionaries, as values:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你也可以使用列表或其他字典作为值：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, the value for the key <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">['Alice', 'Bob']</samp>, which
    itself is a list. You can use a combination of lists and dictionaries to organize
    pretty much any type of data, no matter how complicated, allowing you to more
    easily work with it in Python.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，键<samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp>的值是<samp class="SANS_TheSansMonoCd_W5Regular_11">['Alice',
    'Bob']</samp>，这本身就是一个列表。你可以使用列表和字典的组合来组织几乎任何类型的数据，无论数据多么复杂，从而让你在Python中更容易处理它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting and Setting
    Values</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">获取与设置值</samp>
- en: 'To retrieve an item you’ve stored inside a dictionary, add square brackets
    containing the item’s key to the end of the dictionary name. If you try to use
    a key you haven’t defined, your script will crash with a <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyError</samp>.
    For example, here’s how to look up the capitals of certain countries in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp> dictionary:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索你存储的项，将包含项键的方括号添加到字典名称的末尾。如果你尝试使用一个未定义的键，脚本会因<samp class="SANS_TheSansMonoCd_W5Regular_11">KeyError</samp>而崩溃。例如，下面是如何在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp>字典中查找某些国家的首都：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When you run <samp class="SANS_TheSansMonoCd_W5Regular_11">capitals["Kenya"]</samp>,
    Python throws the error message <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyError:
    ''Kenya''</samp>. This means that <samp class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp>
    isn’t a valid key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp>
    dictionary. You can see that the only keys defined in [Listing 8-1](#list8-1)
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">United States</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">India</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">South
    Africa</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Brazil</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Germany</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Russia</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">China</samp>. Because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp> isn’t a key in this dictionary,
    you can’t retrieve its value.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '当你运行<samp class="SANS_TheSansMonoCd_W5Regular_11">capitals["Kenya"]</samp>时，Python会抛出错误消息<samp
    class="SANS_TheSansMonoCd_W5Regular_11">KeyError: ''Kenya''</samp>。这意味着<samp class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp>不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp>字典中的有效键。你可以看到，在[清单 8-1](#list8-1)中定义的唯一键是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">United States</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">India</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">South Africa</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Brazil</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Germany</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Russia</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">China</samp>。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp>不是此字典中的键，因此无法检索其值。'
- en: 'You can add new key-value pairs to a dictionary, or update an existing one,
    like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样向字典中添加新的键值对，或者更新现有的键值对：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This code defines a new key, <samp class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp>,
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">Nairobi</samp>. It
    also updates an existing key, <samp class="SANS_TheSansMonoCd_W5Regular_11">United
    States</samp>, to have the value <samp class="SANS_TheSansMonoCd_W5Regular_11">Mar-a-Lago</samp>,
    overwriting its old value, which used to be <samp class="SANS_TheSansMonoCd_W5Regular_11">Washington,
    DC</samp>.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个新的键<samp class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp>，并将其值设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Nairobi</samp>。它还更新了一个现有的键<samp class="SANS_TheSansMonoCd_W5Regular_11">United
    States</samp>，将其值更新为<samp class="SANS_TheSansMonoCd_W5Regular_11">Mar-a-Lago</samp>，并覆盖了其旧值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Washington, DC</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Navigating Dictionaries and Lists in
    the Conti Chat Logs</samp>
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">在Conti聊天日志中导航字典和列表</samp>
- en: You can combine dictionaries and lists in a single flexible data structure that
    allows you to represent a wide variety of information. If you’re writing Python
    code to work with datasets, chances are you’re going to need both. You might directly
    load the data in this format, or you might create your own dictionaries and lists
    to store aspects of the data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将字典和列表结合在一个灵活的数据结构中，这样可以表示各种各样的信息。如果你正在编写用于处理数据集的Python代码，那么你很可能需要这两者。你可能会直接以这种格式加载数据，或者你可能会创建自己的字典和列表来存储数据的各个方面。
- en: 'To describe how to use data structures that include a combination of dictionaries
    and lists, I’ll use an example from a real dataset. The day after Russia invaded
    Ukraine on February 24, 2022, the notorious Russian ransomware gang Conti, known
    for hacking companies around the world and extorting millions of dollars from
    them, published a statement on its website throwing its full support behind the
    Russian government. It threatened any “enemy” who launched cyberattacks against
    Russia with retaliation against their “critical infrastructure.” Three days later,
    a Ukrainian security researcher anonymously leaked 30GB of internal data from
    Conti: hacking tools, training documentation, source code, and chat logs. The
    Conti chat logs originally came in the form of JSON files, which is structured
    data. When you load JSON files into Python, they’ll automatically be loaded as
    a combination of dictionaries and lists.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述如何使用包含字典和列表组合的数据结构，我将使用一个来自真实数据集的例子。2022年2月24日俄罗斯入侵乌克兰的第二天，臭名昭著的俄罗斯勒索软件团伙Conti，这个以黑客攻击全球公司并勒索数百万美元而闻名的团伙，在其网站上发布了一份声明，表示全力支持俄罗斯政府。它威胁任何对俄罗斯发起网络攻击的“敌人”，将会对其“关键基础设施”进行报复。三天后，一位乌克兰安全研究员匿名泄露了30GB的Conti内部数据：黑客工具、培训文档、源代码和聊天记录。这些Conti聊天记录最初是以JSON文件的形式存在的，这是结构化数据。当你将JSON文件加载到Python中时，它们会自动作为字典和列表的组合加载。
- en: In this section, you’ll look through some of these chat logs in order to practice
    working with real leaked data stored in dictionaries and lists. Using Python code,
    you’ll learn how to navigate these structures to access specific pieces of data
    as well as how to quickly loop through the chat logs and select just the parts
    you’re interested in.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，你将浏览一些这些聊天记录，以练习处理存储在字典和列表中的真实泄露数据。通过Python代码，你将学习如何遍历这些结构以访问特定的数据部分，并且如何快速循环遍历聊天记录，选择你感兴趣的部分。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Dictionaries
    and Lists Full of Data in Python</samp>
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在Python中探索充满数据的字典和列表</samp>
- en: You can download the complete Conti dataset from [*https://<wbr>ddosecrets<wbr>.com<wbr>/wiki<wbr>/Conti<wbr>_ransomware<wbr>_chats*](https://ddosecrets.com/wiki/Conti_ransomware_chats).
    However, for this section, you’ll use just one file from the dataset, *2022-02-24-general.json*,
    which the Ukranian security researcher extracted from a chat system called RocketChat.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[*https://<wbr>ddosecrets<wbr>.com<wbr>/wiki<wbr>/Conti<wbr>_ransomware<wbr>_chats*](https://ddosecrets.com/wiki/Conti_ransomware_chats)下载完整的Conti数据集。然而，在这一部分中，你只会使用数据集中的一个文件，*2022-02-24-general.json*，该文件是由乌克兰安全研究员从一个名为RocketChat的聊天系统中提取的。
- en: 'Download *2022-02-24-general.json* from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/2022<wbr>-02<wbr>-24<wbr>-general<wbr>.json*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/2022-02-24-general.json).
    Open a terminal, change to the folder where you stored this file, and open a Python
    interpreter. Load this file into a dictionary with the following commands:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/2022<wbr>-02<wbr>-24<wbr>-general<wbr>.json*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/2022-02-24-general.json)下载*2022-02-24-general.json*文件。打开终端，切换到存储该文件的文件夹，并打开Python解释器。使用以下命令将该文件加载到字典中：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp>
    module and loads the data from *2022-02-24-general.json* into the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    variable. The chat logs from this file are too long to display in their entirety,
    but [Listing 8-2](#list8-2) shows a snippet of the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    dictionary that demonstrates its structure.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp>模块，并将*2022-02-24-general.json*文件中的数据加载到<data>变量中。由于该文件中的聊天记录过长，无法完全显示，但[清单
    8-2](#list8-2)展示了<data>字典的一部分值，说明了其结构。
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Conti chat logs
    from RocketChat</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-2：来自RocketChat的Conti聊天记录</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> variable is a
    dictionary with two keys, <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp>. You access the
    value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp> key,
    which is a list of dictionaries, using the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>
    ❶. You can tell that the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>
    is a list because it’s enclosed in square brackets ([and]), and you can tell that
    the items inside it are dictionaries because they’re enclosed in braces (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}). Almost all of the data
    in this file is stored in this list.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> 变量是一个字典，包含两个键：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">messages</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp>。你可以通过表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> ❶ 访问 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">messages</samp> 键的值，它是一个字典的列表。你可以通过它被方括号（[和]）包围来判断
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> 的值是一个列表，并且你可以通过它被大括号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>）包围来判断其中的项目是字典。几乎所有的文件数据都存储在这个列表中。
- en: Each dictionary in the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>
    list describes a chat message. This snippet of code includes only one of the dictionaries,
    the ninth chat message in the list (I snipped out the first eight messages, so
    you can’t tell that it’s the ninth without looking at the original file). You
    can access the dictionary that contains that specific chat message using the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp>. (Remember,
    in programming we start counting at 0, not 1, so the first item is at index 0,
    the second item is at index 1, and so on.) If you run the command <samp class="SANS_TheSansMonoCd_W5Regular_11">print(data["messages"][8])</samp>
    to display the dictionary for the ninth message, the output should match the message
    in the listing. Notice that just as you place index numbers within brackets to
    select from lists, you place keys within brackets to select from dictionaries,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">["messages"]</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">["success"]</samp>.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> 列表中的每个字典描述了一条聊天消息。这个代码片段只包括其中一个字典，即列表中的第九条聊天消息（我删除了前八条消息，所以你不能通过这段代码看出它是第九条消息，除非查看原始文件）。你可以通过表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp> 访问包含该特定聊天消息的字典。（记住，在编程中我们是从0开始计数的，而不是从1开始，所以第一个项目在索引0，第二个项目在索引1，依此类推。）如果你运行命令
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print(data["messages"][8])</samp>
    来显示第九条消息的字典，输出应该与列表中的消息相匹配。请注意，正如你在方括号中放置索引数字来从列表中选择项目一样，你也可以在方括号中放置键来从字典中选择项目，例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">["messages"]</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">["success"]</samp>。
- en: You can also access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp>
    key with <samp class="SANS_TheSansMonoCd_W5Regular_11">data["success"]</samp>.
    Its value is the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    ❷. I’m not entirely sure what this means, but I suspect that the <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp>
    key was left over from whatever system the Ukrainian researcher used to export
    these chat messages from RocketChat, confirming that exporting the data was successful
    and that there were no errors.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">data["success"]</samp>
    访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp> 键的值。它的值是布尔值 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp> ❷。我不完全确定这是什么意思，但我猜测 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">success</samp> 键是从乌克兰研究人员用来导出这些来自 RocketChat
    的聊天信息的系统中遗留下来的，表明数据导出成功且没有错误。
- en: 'The file from which I loaded this code contained 604 different chat messages,
    each in its own dictionary, that were sent in Conti’s #general RocketChat channel
    on February 24, 2022\. I discovered that this list has 604 items by measuring
    its length with the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    function, like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '我加载此代码的文件包含了604条不同的聊天消息，每条消息都有自己的字典，它们是在2022年2月24日通过 Conti 的 #general RocketChat
    频道发送的。我通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp> 函数来测量列表的长度，从而发现这个列表有604个项目，代码如下：'
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The dictionary for each chat message has many keys: <samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rid</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">urls</samp>,
    and so on.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个聊天消息的字典包含多个键：<samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">rid</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">u</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">urls</samp>
    等等。
- en: 'You can find out what types of data these keys contain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">key_variable</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dictionary</samp>
    syntax, and you can determine a variable’s data type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp>
    function. Try this out using the following commands:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">key_variable</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dictionary</samp>
    语法来找出这些键包含的数据类型，并且可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp>
    函数来确定变量的数据类型。可以尝试使用以下命令：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This command loops through the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp>
    dictionary and stores each key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    variable. Then, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function and an f-string, it displays the key (<samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>)
    and the type of data stored in that key, as shown in the following output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会遍历 <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp>
    字典，并将每个键存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> 变量中。然后，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 函数和 f-string，它会显示该键（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">key</samp>）及存储在该键中的数据类型，输出如下所示：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the output, the values at the <samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rid</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ts</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">_updatedAt</samp>
    keys are all strings. The value at the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    key is a dictionary. The value at the <samp class="SANS_TheSansMonoCd_W5Regular_11">urls</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mentions</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">md</samp> keys are lists.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，<samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">rid</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">ts</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">_updatedAt</samp> 键的值都是字符串。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">u</samp> 键的值是一个字典。<samp class="SANS_TheSansMonoCd_W5Regular_11">urls</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mentions</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">md</samp> 键的值是列表。
- en: You can get the value of the data at the key using <samp class="SANS_TheSansMonoCd_W5Regular_11">data['messages'][8][key]</samp>.
    Remember that to retrieve the value of a key in a dictionary, you put the key
    in square brackets. In this case, the key itself is stored in the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">key</samp>, so you can get its value by
    putting <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> inside the square
    brackets. To find out what type of data that is, then, just pass the value into
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp> function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">data['messages'][8][key]</samp>
    获取该键的值。记住，在字典中获取键的值时，需要将键放在方括号内。在这种情况下，键本身存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    变量中，因此可以通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> 放入方括号中来获取其值。然后，为了找出该数据类型，只需将值传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp> 函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Selecting Values
    in Dictionaries and Lists</samp>
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">选择字典和列表中的值</samp>
- en: 'When working with datasets, you often end up with structures like this: a mess
    of dictionaries and lists that you need to make sense of. Being able to select
    the exact values you’re looking for is an important skill. To practice navigating
    through dictionaries and lists, take a closer look at the value of just one of
    these keys, the <samp class="SANS_TheSansMonoCd_W5Regular_11">md</samp> key, by
    running the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据集时，你经常会遇到这样的结构：一堆字典和列表，你需要理解其中的内容。能够选择你需要的精确值是一项重要的技能。为了练习浏览字典和列表，仔细查看这些键中的任意一个键的值，使用以下命令来查看
    <samp class="SANS_TheSansMonoCd_W5Regular_11">md</samp> 键的值：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the output, you can tell that this value is a list because it’s surrounded
    by square brackets:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你可以看出这个值是一个列表，因为它被方括号括起来：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The list’s single item is a dictionary, which is surrounded by braces. The dictionary
    has a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> key whose value
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">PARAGRAPH</samp>, as well as
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> key. The value of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> is another list with
    one item containing another dictionary; that dictionary itself contains <samp
    class="SANS_TheSansMonoCd_W5Regular_11">type</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    keys, where the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">PLAIN_TEXT</samp>.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表的唯一项目是一个字典，字典由大括号包围。字典有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    键，其值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">PARAGRAPH</samp>，还有一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">value</samp> 键。<samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    的值是另一个包含一个项目的列表；该项目本身包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> 键，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">PLAIN_TEXT</samp>。
- en: 'These data structures can have as many sublists and subdictionaries as you’d
    like. To select specific values, after the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    variable keep adding square brackets containing an index (if it’s a list) or a
    key (if it’s a dictionary) until you get to the value you’re looking for. For
    example, use the following command to access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    key in the inner dictionary within the inner list, which is in another <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    key in the outer dictionary in the outer list:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据结构可以包含任意数量的子列表和子字典。为了选择特定的值，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    变量后继续添加包含索引（如果是列表）或键（如果是字典）的方括号，直到找到你需要的值。例如，使用以下命令可以访问外部字典中外部列表内另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    键内的内部字典中的内部列表中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> 键的值：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You already know that <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp>
    is a dictionary that represents a chat message. To find the value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">md</samp> key in that dictionary, you
    include<samp class="SANS_TheSansMonoCd_W5Regular_11">["md"]</samp> in the command.
    As you can tell from inspecting the structure in [Listing 8-2](#list8-2), this
    is a list with one item, so adding <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp>
    selects that item. This item is a dictionary, and you select the value of its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> key by adding <samp
    class="SANS_TheSansMonoCd_W5Regular_11">["value"]</samp>. This item is another
    list with one item, so you again add <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp>
    to select that one item. This is yet another dictionary, so you can select the
    value of the final inner <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    key by adding another <samp class="SANS_TheSansMonoCd_W5Regular_11">["value"]</samp>.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp>
    是一个表示聊天信息的字典。为了查找该字典中 <samp class="SANS_TheSansMonoCd_W5Regular_11">md</samp>
    键的值，你需要在命令中包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">["md"]</samp>。从 [列表
    8-2](#list8-2) 中检查结构可以看出，这是一个包含一个项目的列表，因此添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp>
    选择该项目。这个项目是一个字典，你可以通过添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">["value"]</samp>
    来选择它的 <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> 键的值。这个项目又是一个包含一个项目的列表，所以你再次添加
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp> 来选择那个项目。这个项目是另一个字典，因此你可以通过再添加一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">["value"]</samp> 来选择最终内部 <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    键的值。
- en: 'You should get the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In English, the message that you just displayed says, “Some American Senators
    suggest blocking PornHub in Russia in addition to social networks!” It was posted
    right after Russia started its invasion of Ukraine, and US and European leaders
    immediately began imposing economic sanctions on Russia. After invading Ukraine,
    the Russian government censored access to Twitter and Facebook from the Russian
    internet. Rumors spread that PornHub, a popular American porn website, would block
    access to Russian users (though this didn’t happen). This same user followed up
    their first post with “That’s it, we’re done,” and then “They will take away our
    last joys!”
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这条你刚刚显示的消息的内容是：“一些美国参议员建议在俄罗斯封锁PornHub以及社交网络！” 这条消息发布在俄罗斯开始入侵乌克兰后不久，美国和欧洲的领导人立即开始对俄罗斯实施经济制裁。入侵乌克兰后，俄罗斯政府屏蔽了从俄罗斯互联网访问Twitter和Facebook。随后有传言称，美国著名色情网站PornHub将封锁俄罗斯用户的访问（尽管这并没有发生）。同一个用户在发布完第一条消息后，跟进发布了“就是这样，我们完了”，然后又发布了“他们会夺走我们最后的快乐！”
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analyzing Data Stored
    in Dictionaries and Lists</samp>
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分析存储在字典和列表中的数据</samp>
- en: 'Whenever I work with any sort of structured data, I find myself looping through
    a list of dictionaries and selecting specific pieces of data. As long as you understand
    its structure, you can write your own similar code to quickly pull out the relevant
    information, no matter what dataset you’re working with. For example, you might
    want to view the chat logs in the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">timestamp
    username</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">message</samp>
    in order to hide the unimportant sections of data so that you can directly copy
    and paste the relevant parts into machine translation systems like DeepL or Google
    Translate. Run the following commands to display all of the messages in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> in that format:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我处理任何类型的结构化数据时，我发现自己总是在遍历一个字典列表并选择特定的数据片段。只要你理解数据结构，你就可以编写自己的类似代码，快速提取相关信息，无论你正在处理什么数据集。例如，你可能希望以
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">timestamp username</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">message</samp>
    的格式查看聊天记录，以隐藏不重要的数据部分，这样你就可以直接将相关部分复制粘贴到像DeepL或Google翻译这样的机器翻译系统中。运行以下命令，以该格式显示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> 中的所有消息：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should get the following output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>
    is a list, each time the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop in this command runs, it updates the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>
    variable to a different item in that list. In this case, each item is a different
    dictionary. Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function
    displays three values: the timestamp (<samp class="SANS_TheSansMonoCd_W5Regular_11">message[''ts'']</samp>),
    the username (<samp class="SANS_TheSansMonoCd_W5Regular_11">message[''u''][''username'']</samp>),
    and the message itself (<samp class="SANS_TheSansMonoCd_W5Regular_11">message[''msg'']</samp>).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> 是一个列表，每次这个命令中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环执行时，它会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>
    变量更新为该列表中的不同项。在这种情况下，每一项都是一个不同的字典。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环内，<samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 函数会显示三个值：时间戳
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">message['ts']</samp>)，用户名 (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">message['u']['username']</samp>) 和消息本身
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">message['msg']</samp>)。
- en: You can change this command to display whatever information you’d like from
    each message. Maybe you’re interested is the user’s ID rather than their username.
    In that case, you could display <samp class="SANS_TheSansMonoCd_W5Regular_11">message['u']['_id']</samp>.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改这个命令，显示你希望从每条消息中提取的任何信息。也许你更感兴趣的是用户的ID，而不是他们的用户名。在这种情况下，你可以显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">message['u']['_id']</samp>。
- en: 'The previous output shows the same messages about PornHub just discussed, as
    well as a message posted just before that from another user, <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>.
    If you’re interested in seeing only the messages posted by <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>,
    view those by running the following commands:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示了刚才讨论的关于 PornHub 的相同消息，还显示了一条来自另一个用户 <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>
    在此之前发布的消息。如果你只对查看 <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp> 发布的消息感兴趣，可以通过运行以下命令来查看：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This code is similar to the previous example. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop loops through each message in <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>,
    and then a <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> statement
    displays specific pieces of information from that message. This time, though,
    each loop also contains an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. Each time the code finds another message, it checks to see if the username
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp> and, if so, displays
    the message. Otherwise, it moves on to the next message. You should get the following
    output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的示例类似。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> 中的每条消息，然后一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 语句显示该消息中的特定信息。不过，这次每个循环还包含一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句。每次代码找到一条新消息时，它会检查用户名是否为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>，如果是，则显示该消息。否则，它会继续处理下一条消息。你应该会看到以下输出：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, suppose you want to figure out how many messages each person posted,
    perhaps to find the most active poster in the #general chatroom on this day. The
    simplest way to do this is to create a new empty dictionary yourself and then
    write code to fill it up. Run the following command to create an empty dictionary
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，假设你想找出每个人发布了多少条消息，也许是为了找出当天在 #general 聊天室中最活跃的用户。最简单的办法是创建一个新的空字典，然后编写代码填充它。运行以下命令来创建一个名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp> 的空字典：'
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The keys in this dictionary will be usernames, and the values will be the number
    of posts from that user. Fill up the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>
    dictionary with the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典中的键将是用户名，值将是该用户的帖子数量。使用以下代码填充 <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>
    字典：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Again, this code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to loop through the messages. Next, it defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp>
    variable as <samp class="SANS_TheSansMonoCd_W5Regular_11">message["u"]["username"]</samp>,
    the username of the person who posted the message the code is currently looping
    through. Next, using an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, the code checks to see if this username is already a key in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp> dictionary. (It’s not
    checking to see if the string <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp>
    is a key, but rather if the *value* of the <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp>
    variable, like <samp class="SANS_TheSansMonoCd_W5Regular_11">thomas</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>, is a key.)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这段代码使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历这些消息。接下来，它将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp> 变量定义为 <samp class="SANS_TheSansMonoCd_W5Regular_11">message["u"]["username"]</samp>，即代码当前循环的这条消息的发布者的用户名。接着，使用一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句，代码检查该用户名是否已经是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp> 字典中的一个键。（它并不是在检查字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp> 是否是一个键，而是在检查 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">username</samp> 变量的*值*，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">thomas</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>，是否是一个键。）
- en: If this user doesn’t exist in the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>
    dictionary, the program adds a key to this dictionary and sets the value at that
    key to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, with the line <samp
    class="SANS_TheSansMonoCd_W5Regular_11">user_posts[username]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Otherwise, it increases
    the value by 1, with <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts[username]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    By the time the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    finishes running, the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>
    dictionary should be complete. The keys should be all of the usernames found in
    the messages, and the values should be the total number of messages for that user.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个用户不存在于<samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>字典中，程序会向该字典添加一个键，并将该键的值设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，对应的代码行是<samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts[username]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。否则，程序会将该值加1，对应的代码行是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">user_posts[username]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。当<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环完成时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>字典应已完整。键应该是所有在消息中找到的用户名，而值应是该用户的消息总数。
- en: 'Use the following code to display the information inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>
    dictionary, viewing the data you just collected:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码显示<samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>字典中的信息，查看你刚刚收集的数据：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should get the following output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'These are the users who posted in Conti’s #general chatroom, in their RocketChat
    server, on the day Russia invaded Ukraine in 2022\. The user *kermit* posted 151
    times, more than any other user.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是2022年俄罗斯入侵乌克兰当天在Conti的#general聊天室中发布的用户，在他们的RocketChat服务器上。用户*kermit*发布了151条消息，超过了其他任何用户。
- en: In these examples, you looped through hundreds of chat messages, but the same
    concepts would work with millions or billions of messages or with data representing
    any sort of information.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，你遍历了数百条聊天信息，但相同的概念也可以应用于数百万或数十亿条信息，或者任何类型的数据。
- en: In this section, you learned how to work with flexible data structures that
    combine dictionaries and lists, including how to pick out specific elements that
    you’re interested in and how to quickly traverse them by looping through them.
    These skills will often prove useful when you’re writing Python scripts to help
    you analyze data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何处理结合了字典和列表的灵活数据结构，包括如何挑选出你感兴趣的特定元素，以及如何通过循环快速遍历它们。这些技巧在你编写Python脚本帮助分析数据时会非常有用。
- en: Now that you’re familiar with data structures that combine dictionaries and
    lists, it’s time to create your own to map out the CSV files in BlueLeaks.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了结合字典和列表的数据结构，是时候创建你自己的结构来绘制BlueLeaks中的CSV文件了。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-5: Map Out the CSVs in
    BlueLeaks</samp>'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 8-5：绘制BlueLeaks中的CSV文件</samp>
- en: Each folder in BlueLeaks includes data from a single hacked law enforcement
    website in the form of hundreds of CSV files. These files contain some of the
    most interesting information in all of BlueLeaks, such as the contents of bulk
    email that fusion centers sent to local cops, or “suspicious activity reports.”
    In this exercise, you’ll construct a map of the contents of the dataset.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: BlueLeaks中的每个文件夹都包含一个被黑客攻击的执法网站的数据，形式是数百个CSV文件。这些文件包含BlueLeaks中一些最有趣的信息，比如融合中心发送给当地警察的大宗电子邮件内容，或“可疑活动报告”。在本练习中，你将构建一个数据集内容的地图。
- en: By manually looking in different BlueLeaks folders, I noticed that each folder
    seems to have a file called *Company.csv* (each containing different content),
    but only one folder, *ncric*, has a file called *911Centers.csv*. Clearly, not
    all of the BlueLeaks sites have the same data. Which CSV files are in every folder
    in BlueLeaks, which are in some folders, and which are unique to a single folder?
    Let’s write a Python script to find out.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过手动查看不同的BlueLeaks文件夹，我注意到每个文件夹似乎都有一个名为*Company.csv*的文件（每个文件包含不同的内容），但只有一个文件夹*ncric*中有一个名为*911Centers.csv*的文件。显然，并不是所有BlueLeaks站点都有相同的数据。那么，哪些CSV文件在BlueLeaks的每个文件夹中都有，哪些文件只在一些文件夹中有，哪些则是唯一属于某个文件夹的？让我们写一个Python脚本来找出答案。
- en: 'As with most programming problems, there are multiple ways you could write
    a script that answers this question. If you feel comfortable enough with Python
    by now that you’d like a challenge, try writing one on your own. Otherwise, follow
    along with this exercise. Either way, the program must meet the following requirements:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数编程问题一样，你可以用多种方式编写脚本来回答这个问题。如果你已经对 Python 感到足够自信，愿意挑战自己，可以尝试自己编写一个脚本。否则，可以跟着这个练习一步步做。无论如何，程序必须满足以下要求：
- en: Make the script accept an argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    using Click.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使脚本接受一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    的参数，使用 Click 库。
- en: Create an empty dictionary called <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>.
    Your script should fill this dictionary with data. The keys should be CSV filenames,
    and the values should be lists of BlueLeaks folders that contain this CSV.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个空字典，命名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>。你的脚本应该将数据填充到这个字典中。字典的键应为
    CSV 文件名，值应为包含该 CSV 的 BlueLeaks 文件夹的列表。
- en: Loop through all of the files and folders in <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>.
    For each folder, loop through all of the files it contains. For each CSV file,
    add data to the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    dictionary.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历 <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> 中的所有文件和文件夹。对于每个文件夹，遍历它包含的所有文件。对于每个
    CSV 文件，将数据添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    字典中。
- en: Display the contents of the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    dictionary.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> 字典的内容。
- en: In each step that follows, I’ll quote a snippet of code, explain how it works,
    and give you a chance to run it as is. You’ll then add more features to that code
    and run it again. It’s good practice to write code in small batches, pausing frequently
    to test that it works as you expect. This will help you catch bugs early, making
    the process of debugging much simpler.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的每一步中，我将引用一段代码，解释它的工作原理，并让你按照原样运行它。然后你会在这段代码的基础上添加更多功能，并再次运行它。将代码分成小块编写是一个好习惯，频繁暂停来测试它是否按预期工作。这将帮助你及早发现并解决
    bug，使调试过程变得更加简单。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accept a Command
    Line Argument</samp>
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">接受命令行参数</samp>
- en: 'Create an *exercise-8-5.py* file and enter the Python template:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 *exercise-8-5.py* 文件，并输入以下 Python 模板：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, instead of hardcoding the path to the BlueLeaks data like you did in
    Exercise 8-2, let’s use Click to pass in the path as a command line argument,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>. To do so,
    make the following modifications to your code (the added syntax is highlighted
    in bold):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，不再像在练习 8-2 中那样硬编码 BlueLeaks 数据的路径，而是使用 Click 库将路径作为命令行参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    传递。为此，对你的代码进行以下修改（新增的语法部分已加粗）：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This code modifies the template to import the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, adds the correct decorators before the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function,
    and adds a simple docstring to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function so that running this script with <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    will be more useful. Finally, it includes a line to display the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>, so that you can
    confirm the code is working when you run it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码修改了模板，导入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> 模块，在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数前添加了正确的装饰器，向 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    参数，并为 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数添加了一个简单的文档字符串，这样在运行脚本时使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp> 会更加有用。最后，它还包含一行代码来显示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> 的值，方便你确认代码是否正常工作。
- en: 'Try running your script with <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    to see if the help text works, and with a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    to see if the argument is successfully sent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行你的脚本并加上<samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>，查看帮助文本是否有效，并传入<samp
    class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>的值，看看参数是否成功传递到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>函数：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If your output looks like this, everything is working correctly so far.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的输出是这样的，说明到目前为止一切正常。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loop Through the
    BlueLeaks Folders</samp>
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">遍历BlueLeaks文件夹</samp>
- en: 'Now that you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    CLI argument, make the following modifications to your code to have it loop through
    all of the folders it finds in that path:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>命令行参数了，接下来请修改代码，使其能够遍历在该路径下找到的所有文件夹：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: First, you import the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module in order to be able to list all of the files in the *BlueLeaks-extracted*
    folder using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>
    function. Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop loops
    through the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir
    (blueleaks_path)</samp>, the list of filenames inside the folder at <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要导入<samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>模块，以便能够使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>函数列出*BlueLeaks-extracted*文件夹中的所有文件。在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>函数中，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历<samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.listdir(blueleaks_path)</samp>的返回值，即位于<sup
    class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>文件夹中的文件名列表。
- en: Inside the loop, the code defines <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>
    as the path of the specific BlueLeaks folder for the current loop. For example,
    if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    is */Volumes/datasets/BlueLeaks-extracted*, and at this point in the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>
    is *icefishx*, then the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>
    will be */Volumes/datasets/BlueLeaks-extracted/icefishx*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，代码将<samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>定义为当前循环中对应的BlueLeaks文件夹路径。例如，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>的值是*/Volumes/datasets/BlueLeaks-extracted*，并且在此时<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环中的<samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>的值是*icefishx*，那么<samp
    class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>的值将是*/Volumes/datasets/BlueLeaks-extracted/icefishx*。
- en: You want to look inside subfolders in the *BlueLeaks-extracted* folder, not
    inside files. If there are any files in that folder, you want to skip them. To
    meet these requirements, the code includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement that checks whether <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>
    is actually a folder. Finally, the code displays the current value of <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要查看*BlueLeaks-extracted*文件夹中的子文件夹，而不是文件夹中的文件。如果该文件夹中有文件，你需要跳过它们。为了满足这些要求，代码中包含了一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句，用于检查<samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>是否实际上是一个文件夹。最后，代码会显示当前的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>的值。
- en: 'Run your script again. This time, pass in the real path to your *BlueLeaks
    -extracted* folder:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行你的脚本。这次，传入*BlueLeaks-extracted*文件夹的实际路径：
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The output should show that the <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>
    variable holds just the name of the folder, like *bostonbric*, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>
    variable includes the full path to that folder, like */Volumes/datasets/BlueLeaks-extracted/bostonbric*.
    When you run this on your own computer, you may see these values in a different
    order than what’s shown here.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp> 变量仅包含文件夹名称，如
    *bostonbric*，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>
    变量则包括该文件夹的完整路径，如 */Volumes/datasets/BlueLeaks-extracted/bostonbric*。当你在自己的计算机上运行时，可能会看到这些值的顺序与这里展示的不同。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fill Up the Dictionary</samp>
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">填充字典</samp>
- en: 'You now have a script that accepts <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    as an argument and then loops through every folder in that path. Adding the code
    in bold creates the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    dictionary and starts to fill it up with data:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    作为参数的脚本，并且它会遍历该路径下的每个文件夹。添加加粗部分的代码会创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    字典，并开始用数据填充它：
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Your goal with this script is to map out which CSV files are in which BlueLeaks
    folders. To store this data, the code creates the empty dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    at the top of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function. The next step is to fill up that dictionary.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的目标是映射出哪些 CSV 文件位于哪些 BlueLeaks 文件夹中。为了存储这些数据，代码在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    函数的顶部创建了一个空字典 <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>。接下来的步骤是填充这个字典。
- en: The code loops through all of the filenames in <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>,
    checking each to see if it’s a folder. Removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    statement in the previous iteration of the code, this code instead adds a second
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop that loops through
    all of the files in that specific BlueLeaks folder.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 代码会遍历 <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> 中的所有文件名，检查每个文件是否是文件夹。去掉前一版本代码中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 语句后，这段代码添加了第二个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环，用于遍历特定 BlueLeaks 文件夹中的所有文件。
- en: In this second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop,
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement checks whether
    the filename ends in *.csv*. This <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp>
    method on the <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> string,
    which returns a lowercase-only version of the string. The code then calls the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp> method on that
    lowercase string, which returns a Boolean describing whether the string ends with
    the string that was passed in. If the string <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    ends with *.csv*, *.CSV*, or *.cSv*, the <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp>
    method will convert the file extension to *.csv*, and <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> ends with anything else,
    like *.docx*, then <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环中，一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句检查文件名是否以 *.csv* 结尾。这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句会对 <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> 字符串调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> 方法，这将返回该字符串的小写版本。然后代码会对这个小写字符串调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp> 方法，该方法返回一个布尔值，表示字符串是否以传入的子字符串结尾。如果字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> 以 *.csv*、*.CSV*
    或 *.cSv* 结尾，<samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> 方法会将文件扩展名转换为
    *.csv*，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp> 会返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    以其他任何东西结尾，比如 *.docx*，那么 <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp>
    会返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: Each time the code following this <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement runs, it means the program has found a CSV (called <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>)
    in the current BlueLeaks folder (called <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>).
    You want <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> to
    be a dictionary where the keys are CSV filenames and the values are lists of folders.
    This code checks to see if the key <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    has been created in <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>,
    and if it hasn’t, creates it and set its value to an empty list (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>).
    Finally, after the code has confirmed that the <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    key has been created and is a list, it appends the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>
    to that list.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每次代码执行到此处的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句时，表示程序已经在当前的
    BlueLeaks 文件夹（称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>）中找到了一个
    CSV 文件（称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>）。你希望 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> 是一个字典，其中键是 CSV 文件名，值是文件夹列表。此代码会检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> 中是否已经创建了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> 这个键，如果没有创建，则会创建它并将其值设置为空列表
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>)。最后，在代码确认 <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    键已经创建并且是一个列表后，它将当前 <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>
    的值追加到该列表中。
- en: These last lines are tricky, so let’s dig in a little more. The first time the
    script comes across a CSV filename (like *CatalogRelated.csv*), the script sets
    the value of that key in <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    to an empty list. If the same filename exists in another BlueLeaks folder later
    on, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">filename not
    in csv_to_folders</samp> will evaluate to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    (meaning <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders["CatalogRelated
    .csv"]</samp> already exists), so the code following the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement won’t run. Finally, the code appends <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>,
    the name of the BlueLeaks folder it’s currently looking in, to the list of folders
    that include that filename.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最后几行有点复杂，我们来深入探讨一下。第一次脚本遇到一个 CSV 文件名（例如 *CatalogRelated.csv*）时，脚本将该键在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> 中的值设置为空列表。如果同样的文件名稍后在另一个
    BlueLeaks 文件夹中出现，那么表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">filename
    not in csv_to_folders</samp> 将评估为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>（意味着
    <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders["CatalogRelated.csv"]</samp>
    已经存在），因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句后面的代码将不会运行。最后，代码会将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>（当前正在查看的 BlueLeaks
    文件夹的名称）追加到包含该文件名的文件夹列表中。
- en: 'Pause and try running the script so far:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停一下，尝试运行到目前为止的脚本：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This should take a moment to run but displays nothing, since you’re not yet
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function
    anywhere. The code is simply creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    dictionary and filling it up with data.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该需要一点时间，但不会显示任何输出，因为你还没有在任何地方使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    函数。代码只是创建了 <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    字典，并填充了数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Display the Output</samp>
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">显示输出</samp>
- en: 'By the time the previous version of the script runs, the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    dictionary should contain a complete set of CSV filenames, mapped to the BlueLeaks
    sites where they were found. The following code should show you what the program
    found:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的脚本运行完毕时，<samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    字典应该包含完整的 CSV 文件名，并将其映射到找到它们的 BlueLeaks 站点。以下代码应该能显示程序找到的内容：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The added code in bold loops through all of the keys (each a CSV filename) in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>, then displays
    the number of BlueLeaks folders that contain that file (<samp class="SANS_TheSansMonoCd_W5Regular_11">len(csv_to_folders[filename])</samp>)
    along with the filename itself.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在加粗的代码中，循环遍历了 <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    中的所有键（每个键都是一个 CSV 文件名），然后显示包含该文件的 BlueLeaks 文件夹的数量 (<samp class="SANS_TheSansMonoCd_W5Regular_11">len(csv_to_folders[filename])</samp>)
    和文件名本身。
- en: 'You can find this final script at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-5<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-5.py).
    When you run it, the output should look like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-5<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-5.py)找到这个最终的脚本。当你运行它时，输出应该如下所示：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Since this script displays the number of folders at the beginning of each line
    of output, you can pipe the output into <samp class="SANS_TheSansMonoCd_W5Regular_11">sort
    -n</samp> to sort it numerically in ascending order, like so:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个脚本在每行输出的开头显示了文件夹的数量，你可以将输出通过管道传递到<samp class="SANS_TheSansMonoCd_W5Regular_11">sort
    -n</samp>，以按升序对其进行数字排序，像这样：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Most of the CSV files are in either a single folder or all 161 folders. However,
    there are a few exceptions: *Donations.csv* should be in 10 folders, *SARs.csv*
    should be in 25, and so on. This information would have taken you many hours of
    busywork to find manually.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 CSV 文件位于一个文件夹或所有 161 个文件夹中。然而，也有一些例外：*Donations.csv* 应该位于 10 个文件夹中，*SARs.csv*
    应该位于 25 个文件夹中，等等。手动查找这些信息可能需要花费你几个小时的繁琐工作。
- en: At this point, you’ve learned the basics of navigating the filesystem in Python.
    You’ve seen how to loop through folders using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>,
    loop through entire folder structures using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>,
    and look up information about the files and folders you find. In the next section,
    you’ll learn how to actually read the contents of a file you find and create new
    files yourself.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何在 Python 中浏览文件系统的基础知识。你已经看到了如何使用<samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>循环遍历文件夹，如何使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>遍历整个文件夹结构，以及如何查找关于你找到的文件和文件夹的信息。在下一节中，你将学习如何实际读取你找到的文件内容，并自己创建新文件。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading and Writing Files</samp>
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">读取和写入文件</samp>
- en: 'To follow the rest of this book, you’ll need to know one more major Python
    concept: how to read and write files. During a data investigation, you’ll almost
    certainly need to read the contents of files, especially CSV and JSON files. You’ll
    also probably want to be able to create new files, by calculating some data of
    your own and saving it to a spreadsheet, for example. In this section you’ll learn
    how to open files and write or read content to them.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续学习本书的内容，你还需要掌握一个 Python 中的重要概念：如何读取和写入文件。在进行数据调查时，你几乎肯定需要读取文件的内容，特别是 CSV
    和 JSON 文件。你也可能希望能够创建新文件，例如通过计算一些你自己的数据并将其保存到电子表格中。在本节中，你将学习如何打开文件并写入或读取内容。
- en: In programming, to work with a file, you first need to open it and specify the
    *mode*—that is, whether you’re planning on *reading* from or *writing* to this
    file. To open an existing file and access its contents, open it for reading using
    mode <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>. To create a new file
    and put data in it, open it for writing using mode <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp>.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，要操作文件，你首先需要打开它并指定*模式*——也就是你是打算*读取*文件，还是*写入*文件。要打开一个现有的文件并访问其内容，使用模式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r</samp> 来进行读取。要创建一个新文件并将数据写入其中，使用模式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">w</samp> 来进行写入。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opening Files</samp>
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">打开文件</samp>
- en: 'To prepare to work with a file, whether for writing or reading, you use the
    built-in Python function <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>.
    To open it for reading, you use the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备处理文件，无论是写入还是读取，你使用 Python 内置函数<samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>。要打开文件进行读取，你可以使用以下代码：
- en: '[PRE61]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> statement,
    which tells Python that after the <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    function is done running, it should set the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to that function’s return value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    variable is a *file object*, a type of variable that allows you to read or write
    data to a file. The first argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    function is a path, and the second argument is the mode, which in this example
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">"r"</samp> for reading.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> 语句，告诉 Python
    在 <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp> 函数执行完毕后，应该将变量 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 设置为该函数的返回值。<samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    变量是一个 *文件对象*，一种允许你读取或写入文件数据的变量类型。<samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    函数的第一个参数是路径，第二个参数是模式，在这个例子中是 <samp class="SANS_TheSansMonoCd_W5Regular_11">"r"</samp>，表示读取模式。
- en: In the code block after the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    statement, you can call methods on <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to interact with the file. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">f.read()</samp>
    will read all of the data in the file and return it—in this case, storing it in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> variable.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> 语句之后的代码块中，你可以调用方法操作
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 来与文件进行交互。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">f.read()</samp>
    将读取文件中的所有数据并返回——在此情况下，将其存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>
    变量中。
- en: 'To open a file for writing, you set the mode to <samp class="SANS_TheSansMonoCd_W5Regular_11">"w"</samp>
    like so:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开一个文件进行写入，你需要将模式设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">"w"</samp>，如下所示：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp> function returns
    the file object <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>. To write
    data into the file, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>
    method. Here, this code is opening a file called *output.txt* and writing the
    string <samp class="SANS_TheSansMonoCd_W5Regular_11">hello world</samp> to it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp> 函数返回文件对象 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>。要向文件中写入数据，可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp> 方法。在这里，这段代码打开了一个名为
    *output.txt* 的文件，并将字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello world</samp>
    写入其中。
- en: In the next two sections, you’ll learn more about using <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>
    to write to files and <samp class="SANS_TheSansMonoCd_W5Regular_11">f.read()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">f.readlines()</samp> to read
    from files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，你将学习更多关于使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>
    向文件写入，以及使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">f.read()</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f.readlines()</samp> 从文件读取的内容。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing Lines to
    a File</samp>
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">写入文件的行</samp>
- en: 'Text files are made up of a series of individual characters. Consider a text
    file with these contents:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件由一系列独立的字符组成。考虑一个包含以下内容的文本文件：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You could also represent the entire contents of this file as a Python string:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将整个文件的内容表示为一个 Python 字符串：
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first character of the string is <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>,
    and so on. The 12th character (counting the space), <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>,
    is a special character known as a *newline* that represents a break between lines.
    As with shell scripting, the backslash is the escape character in Python, so a
    backslash followed by another character represents a single special character.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的第一个字符是 <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>，接着是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">e</samp>，然后是 <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>，依此类推。第
    12 个字符（包括空格），<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>，是一个特殊字符，称为
    *换行符*，表示行与行之间的断开。与 shell 脚本一样，反斜杠是 Python 中的转义字符，因此反斜杠后跟其他字符表示一个特殊字符。
- en: 'Newlines are used to write lines to a file. Try running these commands in your
    Python interpreter:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符用于将行写入文件。试着在你的 Python 解释器中运行这些命令：
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    in the output represent the number of bytes written. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>
    call wrote 12 bytes, because the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World</samp> takes 11 bytes of memory: it has 11 characters, plus 1 for the newline
    character. The second call wrote 11 bytes, since <samp class="SANS_TheSansMonoCd_W5Regular_11">Hola
    Mundo</samp> takes 10 bytes of memory, plus 1 for the newline character.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    代表写入的字节数。第一次 <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp> 调用写入了
    12 个字节，因为字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World</samp>
    占用 11 个字节的内存：它有 11 个字符，再加上 1 个换行符。第二次调用写入了 11 个字节，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hola
    Mundo</samp> 占用 10 个字节的内存，再加上 1 个换行符。
- en: 'In your terminal, use the following command to view the file you just wrote:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中，使用以下命令查看你刚刚写入的文件：
- en: '[PRE66]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you had written the same code but without the newlines, the output would
    have been <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello WorldHola Mundo</samp>,
    with no line breaks.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你写的是相同的代码，但没有换行符，输出将会是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    WorldHola Mundo</samp>，没有换行符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading Lines from
    a File</samp>
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从文件中读取行</samp>
- en: 'Run the following command to read the file you just created:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来读取你刚刚创建的文件：
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code reads all of the data from the file and saves it in the string <samp
    class="SANS_TheSansMonoCd_W5Regular_11">text</samp>. In fact, this might look
    familiar: earlier in this chapter, in the “Exploring Dictionaries and Lists Full
    of Data in Python” section, we used similar code to load the leaked Conti chat
    logs into a Python dictionary.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从文件中读取所有数据，并将其保存在字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>
    中。实际上，这看起来可能很熟悉：在本章的“探索 Python 中充满数据的字典和列表”一节中，我们使用类似的代码将泄漏的 Conti 聊天记录加载到 Python
    字典中。
- en: 'Since splitting text files into multiple lines is so common, file objects also
    have a convenient method called <samp class="SANS_TheSansMonoCd_W5Regular_11">readlines()</samp>.
    Instead of reading all of the data into a file, it reads only one line at a time,
    and you can loop over the lines in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop. Try this out by running the following commands:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将文本文件拆分成多行非常常见，文件对象还提供了一个方便的方法，叫做 <samp class="SANS_TheSansMonoCd_W5Regular_11">readlines()</samp>。与其将所有数据一次性读取到文件中，它只会一次读取一行，并且你可以在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环中遍历每一行。通过运行以下命令试试看：
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This code opens the file for reading, then loops through each line in the file.
    Each line is stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">line</samp>,
    then displayed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">line</samp>
    variable in each loop ends in <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    (for example, the first line is <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World\n</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World</samp>),
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function
    automatically adds an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>,
    the output shows an extra hard return after each line.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打开文件进行读取，然后循环遍历文件中的每一行。每一行被存储在变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">line</samp>
    中，然后通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 函数显示出来。因为每次循环中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">line</samp> 变量以 <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    结尾（例如，第一行是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World\n</samp>，而不是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World</samp>），而且 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    函数会自动添加一个额外的 <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>，所以输出每行之后都会显示额外的硬回车符。
- en: 'If you don’t want to display these extra newlines, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">strip()</samp>
    method to get rid of any whitespace (spaces, tabs, or newlines) from the beginning
    and end of the string. Run the same code, but this time strip out the newline
    characters on each line:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想显示这些额外的换行符，可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">strip()</samp>
    方法去掉字符串开头和结尾的任何空白（空格、制表符或换行符）。运行相同的代码，但这次去掉每一行的换行符：
- en: '[PRE69]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You’ll practice the basics of how to read and write files in Python in the following
    exercise.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你将练习如何在 Python 中读取和写入文件的基础知识。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-6: Practice Reading and
    Writing Files</samp>'
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 8-6：实践读取和写入文件</samp>
- en: In Exercise 7-5, you wrote a function that converts a string to an alternating
    caps version, like <samp class="SANS_TheSansMonoCd_W5Regular_11">This book is
    amazing</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">ThIs bOoK Is aMaZiNg</samp>.
    To practice your newfound reading and writing files, in this exercise, you’ll
    write a script to create an alternating caps version of all of the text in an
    entire text file.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习 7-5 中，你写了一个函数，将字符串转换为交替大小写版本，像 <samp class="SANS_TheSansMonoCd_W5Regular_11">This
    book is amazing</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ThIs
    bOoK Is aMaZiNg</samp>。为了练习你新学的读取和写入文件技能，在本练习中，你将编写一个脚本，创建整个文本文件中所有文本的交替大小写版本。
- en: 'If you’d like a challenge, you can try programming your own script to meet
    the following requirements:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想挑战自己，可以尝试编写一个脚本来满足以下要求：
- en: Accepts two arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>, using
    Click
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受两个参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp> 和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>，使用 Click
- en: Opens the file <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    for reading and loads its contents into the string <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开文件 <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp> 进行读取，并将其内容加载到字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> 中
- en: Opens the file <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>
    for writing and saves the alternating caps version of <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>
    to that new file
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开文件 <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp> 进行写入，并将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> 的交替大小写版本保存到该新文件中
- en: Otherwise, follow along with my explanation of the following code, which implements
    this iNcReDiBlY uSeFuL command line program.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，跟随我对以下代码的解释，这段代码实现了这个**极其有用**的命令行程序。
- en: 'Start by copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp>
    function that you wrote in Exercise 7-5 into a new Python script called *exercise-8-6.py*.
    Next, make the modifications highlighted in bold here (or copy the final script
    at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-6<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-6.py)):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 从复制你在练习 7-5 中写的 <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp>
    函数开始，粘贴到一个新的 Python 脚本中，命名为 *exercise-8-6.py*。接下来，做出这里加粗部分的修改（或者直接复制最终的脚本到 [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-6<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-6.py)）：
- en: '[PRE70]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This code first imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, used for the arguments, and then defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp>
    function. Again, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function is a Click command, but this time it takes two arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先导入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> 模块，用于处理参数，然后定义了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp> 函数。同样，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数是一个 Click 命令，但这次它接受两个参数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>。
- en: Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function
    runs, the section for reading and writing files runs. The code opens <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    for reading and loads all of the contents of that file into the string <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>.
    It then opens <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>
    for writing and saves the alternating caps version of that string into the new
    file. It does so by running <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps(text)</samp>,
    which takes <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> as an argument
    and returns its alternating caps version, and then passes that return value directly
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>, writing it
    to the file.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数运行，读取和写入文件的部分就会执行。代码打开
    <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp> 以供读取，并将该文件的所有内容加载到字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> 中。然后，它打开 <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>
    以供写入，并将该字符串的交替大小写版本保存到新文件中。它通过运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps(text)</samp>
    来实现这一点，<samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps</samp> 接受
    <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> 作为参数并返回其交替大小写版本，然后将返回值直接传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>，将其写入文件。
- en: 'To demonstrate how this script works, try running it on the famous “To be,
    or not to be” soliloquy from *Hamlet*. First, save a copy of the soliloquy found
    at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/shakespeare<wbr>.txt*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/shakespeare.txt)
    to a file called *shakespeare.txt*. Here are the original contents of *shakespeare.txt*,
    displayed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个脚本的工作原理，试着在著名的《哈姆雷特》“生存还是毁灭”独白上运行它。首先，将独白的副本保存到名为 *shakespeare.txt* 的文件中，文件内容来自
    [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/shakespeare<wbr>.txt*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/shakespeare.txt)。以下是使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> 命令显示的 *shakespeare.txt*
    的原始内容：
- en: '[PRE71]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, pass that filename into your script to create an alternating caps version
    of that file. Here’s what happens when I do it:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将该文件名传入脚本，以创建该文件的交替大小写版本。以下是我执行该操作时发生的情况：
- en: '[PRE72]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: First, I ran the script, passing in *shakespeare.txt* as <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    and *shakespeare-mocking.txt* as <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>.
    The script itself displayed no output (it doesn’t include any <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    statements), but it did create a new file. I then used <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    to display the contents of that new file, which is indeed an alternating caps
    version of Hamlet’s soliloquy.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我运行了脚本，将 *shakespeare.txt* 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    传入，将 *shakespeare-mocking.txt* 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>
    传入。脚本本身没有输出（它不包括任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    语句），但它确实创建了一个新文件。然后，我使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    命令显示了新文件的内容，的确是《哈姆雷特》独白的交替大小写版本。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: Congratulations on making it through a crash course in the fundamentals of Python
    programming! You’ve learned how to bring extra functionality to your scripts with
    built-in and third-party Python modules. You’ve also learned how to make your
    own CLI programs using Click, how to write code that traverses the filesystem,
    how to work with structured data using dictionaries and lists, and how to read
    and write files.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你成功完成了 Python 编程基础的速成课程！你已经学会了如何通过内置和第三方 Python 模块为脚本增加额外功能。你还学会了如何使用 Click
    创建自己的 CLI 程序，如何编写遍历文件系统的代码，如何使用字典和列表处理结构化数据，以及如何读取和写入文件。
- en: You’ll use these skills throughout the following chapters as you dig through
    various datasets, uncovering revelations you’d never discover otherwise. In the
    next chapter, you’ll write Python programs that loop through rows in the BlueLeaks
    CSV spreadsheets, transforming the data into a more workable format. You’ll get
    practice writing the content of law enforcement bulk email messages to files,
    and you’ll use Python to create your own CSV spreadsheets.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将使用这些技能，深入挖掘各种数据集，揭示一些你否则无法发现的发现。在下一章节中，你将编写 Python 程序，遍历 BlueLeaks
    CSV 表格中的行，将数据转化为更易于操作的格式。你将练习将执法机关的大宗邮件内容写入文件，并且使用 Python 创建你自己的 CSV 表格。
