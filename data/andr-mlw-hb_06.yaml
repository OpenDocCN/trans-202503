- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: DYNAMIC ANALYSIS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态分析**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter uses a malware sample from the Xenomorph phishing family, first
    described by Dutch security company ThreatFabric in March 2022, to introduce popular
    dynamic analysis tools for Android and best practices for using these tools. We
    cover the use of a device emulator to run the malicious app, as well as the use
    of tcpdump, Wireshark, and Frida to learn about the app’s behavior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用2022年3月荷兰安全公司ThreatFabric首次描述的Xenomorph钓鱼家族中的恶意软件样本，介绍常见的Android动态分析工具以及使用这些工具的最佳实践。我们将涵盖使用设备模拟器运行恶意应用程序，以及使用tcpdump、Wireshark和Frida来了解应用程序行为的内容。
- en: In any serious reverse engineering context, analysts use static and dynamic
    techniques in tandem to speed up malware analysis. Thus, toward the end of this
    chapter, we’ll supplement our dynamic analysis with static analysis in jadx. You’ll
    witness how to use dynamic analysis to gain a broad understanding of a piece of
    malware functionality, then seek out additional information through static analysis.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何严肃的逆向工程环境中，分析人员都会将静态和动态技术结合使用，以加速恶意软件分析。因此，在本章的末尾，我们将通过在jadx中进行静态分析来补充动态分析。你将看到如何使用动态分析获得对恶意软件功能的广泛理解，然后通过静态分析获取更多信息。
- en: '**What Is Dynamic Code Analysis?**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是动态代码分析？**'
- en: In program analysis and reverse engineering, the term *dynamic analysis* or
    *dynamic code analysis* refers to the application of analysis techniques that
    uncover properties of the program under observation by executing its code. This
    contrasts with static analysis, described in the previous chapter, which aims
    to discover properties of a program by analyzing its code and structure without
    executing it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序分析和逆向工程中，*动态分析*或*动态代码分析*指的是通过执行程序代码来揭示程序特性的分析技术。这与上一章中描述的静态分析不同，静态分析旨在通过分析程序的代码和结构而不执行它来发现程序的特性。
- en: Of course, running an app is not enough to understand what the app is doing.
    Dynamic analysis involves a whole arsenal of tools that monitor and interact with
    the app, including debuggers and software to intercept API calls, dump memory,
    or inspect network traffic. Still other tools might implement ways to interact
    with the app’s GUI or automatically test the app’s security properties for potential
    vulnerabilities. When run together, these tools should build a picture of how
    an app interacts with a device. The more tools you deploy to monitor the device,
    the more complete your understanding of the app becomes. However, deploying and
    maintaining all of these tools can take considerable time and money.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，运行应用程序并不足以了解它在做什么。动态分析涉及一整套工具，这些工具可以监控并与应用程序互动，包括调试器和用于拦截API调用、转储内存或检查网络流量的软件。还有一些工具可能实现与应用程序GUI的交互，或自动测试应用程序的安全性特性以发现潜在的漏洞。当这些工具一起运行时，它们应当构建出应用程序如何与设备交互的全貌。你部署的监控设备的工具越多，你对应用程序的理解就越全面。然而，部署和维护这些工具可能需要大量的时间和金钱。
- en: '**Dynamic vs. Static Analysis**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**动态分析与静态分析**'
- en: Dynamic and static analysis are complements. To get a full picture of an app’s
    functionality, you’ll need to use both forms of analysis, and all professional
    malware analysis programs do so.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析和静态分析是互为补充的。为了全面了解应用程序的功能，你需要同时使用这两种分析方式，所有专业的恶意软件分析程序都是如此。
- en: An example of the stark differences between static and dynamic analysis is the
    amount of effort required to set them up. For static analysis, you only have to
    load an app into jadx. On the other hand, dynamic analysis requires first setting
    up a device (real or virtual) that can execute the program, then making sure you
    have the ability to intercept and log system calls, network traffic, filesystem
    changes, and any other device modifications that the app could make. Finally,
    you have to execute the app and interact with it in the hopes of triggering malicious
    functionality. This can be more difficult than you might expect, as malware apps
    often deploy myriad anti-analysis tricks and refuse to run when they believe they
    are under analysis in a security researcher’s test environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析和动态分析之间鲜明差异的一个例子是它们的设置所需的努力程度。对于静态分析，你只需要将应用加载到 jadx 中即可。另一方面，动态分析首先需要设置一个能够执行程序的设备（无论是真实设备还是虚拟设备），然后确保你能够拦截和记录系统调用、网络流量、文件系统更改以及应用可能做出的任何其他设备修改。最后，你需要执行应用程序并与其交互，希望触发恶意功能。这可能比你想象的更为困难，因为恶意软件应用程序通常会部署各种反分析技巧，一旦它们认为自己处于安全研究人员的测试环境中，就会拒绝运行。
- en: Once you have overcome all of these obstacles and have an app running on your
    test device, however, dynamic analysis shines. It is much faster to make progress
    than with static analysis, as you can observe what the app is doing and try to
    force its execution in any direction that interests you. Your analysis system
    will log all sensitive API calls, network traffic, and environmental information
    and put the details into a report for you to study later. There is no need to
    slog through all the app code, as with static analysis.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你克服了所有这些障碍，并且在测试设备上成功运行了应用程序，动态分析就展现出了它的优势。相比静态分析，动态分析进展要快得多，因为你可以观察应用程序的运行情况，并尝试将其执行引导到任何你感兴趣的方向。你的分析系统会记录所有敏感的
    API 调用、网络流量和环境信息，并将这些细节整理成报告供你稍后研究。相比静态分析，你不需要一行一行地翻阅应用代码。
- en: Another place where dynamic and static analysis complement each other is in
    terms of *code coverage*, a measure of how much code an analysis technique can
    analyze. In static analysis, all of an app’s code is available for analysis. In
    dynamic analysis, you can only consider the executed code. The difference between
    the two can be huge. Even the best dynamic analysis runs of an app struggle to
    execute more than 5 to 10 percent of an app’s code. The remaining 90 to 95 percent
    remains a mystery and can only be uncovered by static analysis.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析和静态分析互补的另一个方面是*代码覆盖率*，它衡量了分析技术能够分析多少代码。在静态分析中，应用的所有代码都可以进行分析。而在动态分析中，你只能考虑执行过的代码。两者之间的差异可能非常巨大。即使是最好的动态分析也只能执行应用代码的
    5% 到 10%。剩下的 90% 到 95% 仍然是一个谜，只有通过静态分析才能揭示。
- en: '**The Android Studio Emulator**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Android Studio 模拟器**'
- en: The first tool you’ll have to set up for dynamic analysis is the runtime environment
    in which to execute the app. You can choose to use either a real Android device
    or an emulated one. Next, you must select the device type and configuration and,
    if you’re using an emulator, whether to use the default emulator that comes with
    the Android SDK or a third-party one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为动态分析设置的第一个工具是运行时环境，用于执行应用程序。你可以选择使用真实的 Android 设备或模拟器。接下来，你必须选择设备类型和配置，如果你使用的是模拟器，还需要决定是使用
    Android SDK 附带的默认模拟器，还是使用第三方模拟器。
- en: Using an emulator is cheap and allows you to quickly reset your analysis if
    something goes wrong. You can also get started easily. On the other hand, most
    Android malware tries to detect whether it’s running in an emulator and behaves
    differently if it thinks it’s under analysis, which can lead to you wasting large
    amounts of time. If you use a real device, you’ll breeze past these checks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟器成本低廉，并且如果出现问题，你可以快速重置分析。你也可以轻松开始分析。另一方面，大多数 Android 恶意软件会尝试检测它是否在模拟器中运行，如果它认为自己在被分析，就会表现得不同，这可能导致你浪费大量时间。如果使用真实设备，你就可以轻松绕过这些检查。
- en: We’ll use the standard Android emulator that ships with the Android Studio IDE
    and the Android SDK for the dynamic analysis in this chapter. We recommend installing
    Android Studio in its entirety, as it sets up the necessary SDK packages for you
    and provides a nice user interface. Installing just the Android SDK works too,
    but it requires a lot more fiddling around. You can download Android Studio at
    [*https://developer.android.com/studio*](https://developer.android.com/studio).
    Follow the instructions at [*https://developer.android.com/studio/install*](https://developer.android.com/studio/install)
    to install it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用随 Android Studio IDE 和 Android SDK 一起提供的标准 Android 模拟器进行动态分析。我们建议安装完整的
    Android Studio，因为它会为你设置所需的 SDK 包并提供良好的用户界面。只安装 Android SDK 也可以，但需要更多的设置工作。你可以在
    [*https://developer.android.com/studio*](https://developer.android.com/studio)
    下载 Android Studio。请按照 [*https://developer.android.com/studio/install*](https://developer.android.com/studio/install)
    上的说明进行安装。
- en: '***Creating a System Image***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建系统镜像***'
- en: Before you can start the emulator, you must first create a system image that
    the emulator can boot. The most comfortable way to do this is by using Android
    Studio. Access the device manager configuration screen by selecting **Tools**
    ▸ **Device Manager**. The device manager will walk you through creating system
    images for the Android emulator.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动模拟器之前，你必须先创建一个模拟器可以启动的系统镜像。最方便的方法是使用 Android Studio。通过选择 **Tools** ▸ **Device
    Manager** 访问设备管理器配置界面。设备管理器将指导你创建 Android 模拟器的系统镜像。
- en: Here, we use a system image configured for a Pixel XL device with API 30, compiled
    for a 32-bit x86 architecture. We chose this architecture to make the emulator
    faster, as these images can use a real computer’s CPU virtualization features.
    Choosing an ARM processor image is slower, as an x86 host machine would have to
    emulate the ARM architecture. Of course, if you’re running an ARM-based host computer,
    you should choose an ARM-based Android system image, for the same reason.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用为 Pixel XL 设备配置的系统镜像，该镜像使用 API 30，并针对 32 位 x86 架构编译。我们选择这个架构是为了让模拟器运行得更快，因为这些镜像可以利用计算机的
    CPU 虚拟化功能。选择 ARM 处理器镜像会比较慢，因为 x86 主机需要模拟 ARM 架构。当然，如果你使用的是基于 ARM 的主机计算机，应该选择 ARM
    架构的 Android 系统镜像，原因相同。
- en: '***Starting the Emulator***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动模拟器***'
- en: While it’s possible to start the Android emulator from Android Studio, we prefer
    to run it from the command line. This provides us with a whole range of command
    line options that aren’t easily accessible from Android Studio.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以从 Android Studio 启动 Android 模拟器，但我们更喜欢从命令行启动它。这让我们可以使用一系列从 Android Studio
    无法轻松访问的命令行选项。
- en: 'Here’s a quick way to start the emulator:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种快速启动模拟器的方法：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command takes just two arguments. We use `@` to pass the name of the API
    30 Pixel XL system image created in Android Studio in the previous step. The second
    argument, `-no-boot-anim`, disables the system boot animation to boot up the system
    faster.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令只需要两个参数。我们使用 `@` 来传递在前一步骤中在 Android Studio 中创建的 API 30 Pixel XL 系统镜像的名称。第二个参数
    `-no-boot-anim` 会禁用系统启动动画，从而加快系统启动速度。
- en: '***Resetting the Emulator***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重置模拟器***'
- en: During your dynamic analysis, you’ll often want to return to a clean slate by
    removing all artifacts created by previous runs of the malware from the system.
    Otherwise, you might get confused about where certain malware artifacts came from
    if you can’t tie them to anything that happened during the most recent run.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行动态分析时，你通常会希望通过删除之前运行恶意软件时在系统上创建的所有残留物来恢复到干净状态。否则，如果你无法将某些恶意软件遗留物与最近一次的运行联系起来，你可能会对它们的来源感到困惑。
- en: 'The easiest way to get back to a clean slate is to wipe all data from the Android
    emulator and reset it to its original state. The emulator provides the handy `-wipe-data`
    command line argument for that:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复到干净状态的最简单方法是清除 Android 模拟器中的所有数据，并将其重置为原始状态。模拟器提供了方便的 `-wipe-data` 命令行参数来实现这一点：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We highly recommend making liberal use of this argument between malware runs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议在每次恶意软件运行之间广泛使用这个参数。
- en: '***Interacting with the Emulator***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与模拟器互动***'
- en: To interact with the emulated device, we will use the Android Debug Bridge command
    line tool, adb, which ships with the Android SDK and can communicate with devices
    over USB or TCP/IP. This tool supports a dozen or so commands that you can learn
    more about by running `adb --help`. Throughout this chapter, we’ll use adb commands
    to install apps on the device, upload files to it, and download files from it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与模拟设备进行交互，我们将使用Android调试桥命令行工具adb，它随Android SDK一起提供，并可以通过USB或TCP/IP与设备进行通信。该工具支持大约十几个命令，你可以通过运行`adb
    --help`了解更多。贯穿本章，我们将使用adb命令在设备上安装应用程序、上传文件到设备以及从设备下载文件。
- en: '**EMULATORS AND ANTI-ANALYSIS TECHNIQUES**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟器与反分析技术**'
- en: Hundreds of dynamic anti-analysis techniques published on the internet attempt
    to detect emulators. These techniques range from fairly simple to quite sophisticated.
    For example, the default Android emulator does not attempt to hide itself. Rather,
    it broadcasts that it’s an emulator through system properties like its device
    model (set to `goldfish`) and its emulated mobile carrier (set to `Android`).
    Malware can easily detect that it’s running on this emulator by checking these
    system properties or by looking at the CPU architecture of the device it’s running
    on. There are nearly no real x86 Android devices, so anytime an app is running
    on an x86 CPU, it’s probably on an emulated device.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上发布的数百种动态反分析技术试图检测模拟器。这些技术从相对简单到相当复杂不等。例如，默认的Android模拟器并不试图隐藏自己。相反，它通过像设备型号（设置为`goldfish`）和模拟的移动运营商（设置为`Android`）这样的系统属性广播自己是一个模拟器。恶意软件可以轻松地通过检查这些系统属性或查看其运行的设备的CPU架构来检测它是否运行在此模拟器上。几乎没有真实的x86
    Android设备，因此每当一个应用程序运行在x86 CPU上时，它很可能是在一个模拟设备上。
- en: But apps don’t have to rely on these default values or hardware properties to
    detect emulators. Some may check whether popular apps like Facebook are installed
    on the device. Facebook is found on nearly all real devices but rarely on emulators.
    Other apps check whether the user’s SMS and web browsing history resemble a real
    user’s or are empty, like on a newly spun-up emulator. In even more extreme cases,
    apps can run code to evaluate timing properties of memory access. Emulated memory
    behaves differently at the hardware level than real, physical memory.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但应用程序并不一定依赖这些默认值或硬件属性来检测模拟器。一些应用程序可能会检查像Facebook这样流行的应用程序是否已安装在设备上。Facebook几乎出现在所有真实设备上，但在模拟器上很少见到。其他应用程序检查用户的短信和网页浏览历史记录是否像真实用户那样，还是像新启动的模拟器那样为空。在更极端的情况下，应用程序甚至可以运行代码来评估内存访问的时间特性。模拟内存在硬件层面上与真实的物理内存表现不同。
- en: Many publicly documented anti-analysis techniques target the dynamic analysis
    tools frequently installed on emulators. Usually, these techniques attempt to
    detect files, processes, or other system properties that are only present when
    a dynamic analysis tool is installed. In particular, malware can detect the powerful
    Frida tool used in this chapter in various ways.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公开记录的反分析技术针对的是常常安装在模拟器上的动态分析工具。通常，这些技术试图检测文件、进程或其他仅在安装了动态分析工具时才会存在的系统属性。特别是，恶意软件可以通过各种方式检测本章中使用的强大工具Frida。
- en: In a professional malware analysis lab, the cat-and-mouse game between apps
    trying to detect dynamic analysis tools and lab developers trying to hide them
    is one of the most time-consuming aspects of the profession. In the worst-case
    scenario, malware developers can upload malware files that specifically target
    your lab. These apps enumerate the system properties of your devices and send
    the information back to the malware developers, who then build anti-analysis techniques
    specifically for your equipment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个专业的恶意软件分析实验室中，应用程序试图检测动态分析工具与实验室开发人员试图隐藏这些工具之间的“猫捉老鼠”游戏是职业中最耗时的方面之一。在最坏的情况下，恶意软件开发人员可以上传专门针对你实验室的恶意软件文件。这些应用程序枚举你的设备的系统属性，并将信息发送回恶意软件开发人员，后者再为你的设备构建专门的反分析技术。
- en: '**Dynamic Analysis Tools**'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**动态分析工具**'
- en: 'Besides the Android emulator, we’ll use several third-party applications in
    our analysis: tcpdump, to intercept and log network traffic from the emulator;
    Wireshark, to analyze that network traffic; and Frida, to manipulate the malware
    we analyze.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Android模拟器，我们还将在分析中使用几个第三方应用程序：tcpdump，用于拦截并记录来自模拟器的网络流量；Wireshark，用于分析该网络流量；以及Frida，用于操作我们分析的恶意软件。
- en: '***tcpdump***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***tcpdump***'
- en: The tcpdump command line tool is a network traffic logger and analyzer. We’ll
    use it to capture all network traffic sent between the malware and its command-and-control
    server so that we can inspect the data that the malware collects and the commands
    it receives.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: tcpdump 命令行工具是一个网络流量日志记录和分析工具。我们将使用它捕获恶意软件与其指挥控制服务器之间的所有网络流量，以便检查恶意软件收集的数据和它接收到的命令。
- en: As tcpdump is an open source tool, you can download it from [*https://tcpdump.org*](https://tcpdump.org).
    The official website distributes source code only, so you’ll have to compile it
    for the Android CPU architecture of your test device. Instructions for compiling
    tcpdump can be found in the official GitHub repository, at [*https://github.com/the-tcpdump-group/tcpdump/blob/master/INSTALL.md*](https://github.com/the-tcpdump-group/tcpdump/blob/master/INSTALL.md).
    Third-party websites also host precompiled tcpdump binaries for different Android
    CPU architectures, but we don’t know how trustworthy these third-party sites are,
    so proceed with caution.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 tcpdump 是一个开源工具，您可以从 [*https://tcpdump.org*](https://tcpdump.org) 下载它。官网只提供源代码，因此您需要为测试设备的
    Android CPU 架构编译它。有关编译 tcpdump 的说明，请参阅官方 GitHub 仓库中的文档，链接为 [*https://github.com/the-tcpdump-group/tcpdump/blob/master/INSTALL.md*](https://github.com/the-tcpdump-group/tcpdump/blob/master/INSTALL.md)。一些第三方网站也托管了适用于不同
    Android CPU 架构的预编译 tcpdump 二进制文件，但我们无法确保这些第三方网站的可靠性，因此请谨慎操作。
- en: 'Next, install tcpdump on Android with adb by pushing the binary to the device
    and marking it as executable:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 adb 将 tcpdump 安装到 Android 设备上，将二进制文件推送到设备并标记为可执行：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `adb push` command transfers a file from the host computer to the Android
    device, and `adb shell` executes shell commands on the device. Please note that
    Android uses the MirBSD Korn Shell (mksh), which might behave differently from
    the more popular Bash shell to which you are probably accustomed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`adb push` 命令用于将文件从主机计算机传输到 Android 设备，而 `adb shell` 用于在设备上执行 shell 命令。请注意，Android
    使用的是 MirBSD Korn Shell（mksh），它的行为可能与您可能习惯的更常见的 Bash shell 不同。'
- en: '***Wireshark***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Wireshark***'
- en: Wireshark is an open source network traffic analyzer. We’ll use it as a GUI
    for the data captured by tcpdump. You can download it from its official website,
    [*https://wireshark.org*](https://wireshark.org). Because you’ll install Wireshark
    on your host system, not on the Android emulator, choose the installer for your
    host system. For example, if you are running Windows, install Wireshark for Windows.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 是一个开源的网络流量分析工具。我们将把它作为 tcpdump 捕获数据的图形界面。您可以从其官方网站下载，[*https://wireshark.org*](https://wireshark.org)。由于您将安装
    Wireshark 到主机系统，而不是 Android 模拟器上，因此选择适合您主机系统的安装程序。例如，如果您使用 Windows，请安装适用于 Windows
    的 Wireshark。
- en: '***Frida***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Frida***'
- en: Frida is a dynamic instrumentation toolkit that you can use to analyze running
    applications, log what they execute, and manipulate them at runtime. It is open
    source and supports many different operating systems and executable file formats.
    The official way to install Frida is to use pip, a package installer for the Python
    programming language, so as a prerequisite to using Frida, you must first install
    the latest versions of Python 3 and pip from [*https://python.org*](https://python.org)
    and [*https://pypi.org/project/pip/*](https://pypi.org/project/pip/). Next, install
    Frida by running `pip install frida-tools`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Frida 是一个动态插桩工具包，您可以使用它来分析正在运行的应用程序，记录它们执行的内容，并在运行时操控它们。它是开源的，支持多种操作系统和可执行文件格式。安装
    Frida 的官方方式是使用 pip，这是一个 Python 编程语言的包安装工具，因此，作为使用 Frida 的前提，您必须先从 [*https://python.org*](https://python.org)
    和 [*https://pypi.org/project/pip/*](https://pypi.org/project/pip/) 安装最新版本的 Python
    3 和 pip。接下来，通过运行 `pip install frida-tools` 来安装 Frida。
- en: 'Like adb, Frida uses a client/server architecture: a server binary (`frida-server`)
    runs on the Android device, and a client (`frida`) runs on the host machine to
    interact with the Android device. Download `frida-server` from Frida’s GitHub
    page ([*https://github.com/frida/frida*](https://github.com/frida/frida)), which
    offers precompiled binaries for many different operating systems and CPU architectures,
    then install it on the Android device using adb and make the file executable:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与 adb 类似，Frida 采用客户端/服务器架构：一个服务器二进制文件（`frida-server`）在 Android 设备上运行，而客户端（`frida`）在主机上运行，与
    Android 设备进行交互。从 Frida 的 GitHub 页面下载 `frida-server`（[*https://github.com/frida/frida*](https://github.com/frida/frida)），该页面为多种操作系统和
    CPU 架构提供了预编译的二进制文件，然后通过 adb 安装到 Android 设备上，并使文件可执行：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**The Malware Sample**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**恶意软件样本**'
- en: Now that we’ve installed our dynamic analysis tools, we can begin our analysis.
    We’ll look at an Android malware sample called *com.spike.old* (v1, 2877). This
    malware, which masquerades as a device cleaner utility, was never directly found
    on Google Play. Rather, its distributors uploaded a separate malware dropper app,
    *vizeeva.fast.cleaner* (v4, 8f50), which downloaded and installed *com.spike.old*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了动态分析工具，可以开始分析了。我们将分析一个名为 *com.spike.old*（v1, 2877）的 Android 恶意软件样本。这个恶意软件伪装成一个设备清理工具，虽然从未在
    Google Play 上直接发现过，但其分发者上传了一个独立的恶意软件载体应用 *vizeeva.fast.cleaner*（v4, 8f50），该应用下载并安装了
    *com.spike.old*。
- en: This phishing application of the Xenomorph family has some interesting properties
    that we will explore in this chapter. It targets banks across the world, as well
    as some other apps whose login credentials have value to the malware developers.
    When users interact with the legitimate bank apps, the malware tries to phish
    for the user’s credentials by faking a login dialog that looks like it comes from
    the legitimate app.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个来自 Xenomorph 家族的网络钓鱼应用具有一些有趣的特点，我们将在本章中探讨。它针对全球的银行以及一些其他对恶意软件开发者来说具有价值的应用的登录凭据。当用户与合法银行应用交互时，恶意软件会伪装成来自合法应用的登录对话框，试图窃取用户凭据。
- en: 'To begin our analysis, download the malware file from [*https://github.com/android-malware-ml-book*](https://github.com/android-malware-ml-book).
    Then install the app on the emulator using the `adb install` command, which takes
    an APK file on the host machine, uploads it to the Android device, and initiates
    the installation process:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始分析，请从 [*https://github.com/android-malware-ml-book*](https://github.com/android-malware-ml-book)
    下载恶意软件文件。然后使用 `adb install` 命令将应用安装到模拟器中，该命令将主机上的 APK 文件上传到 Android 设备，并启动安装过程：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can find an installed app’s private data in the */data/data/<package name>*
    directory. Immediately after you’ve installed the app, this directory exists but
    is empty, as you can see by inspecting it with the commands shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 */data/data/<包名>* 目录中找到已安装应用的私有数据。安装应用后，这个目录存在但为空，正如你通过执行此处显示的命令检查它时所见：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first command, `adb root`, restarts the adb daemon (`adbd`) on the device
    with root privileges. You must do this to access the private files of apps that
    are protected by Android’s process isolation security guarantees. The output shows
    three default directories that were created during installation, but no files
    yet. In future malware analysis, you can skip this directory check, as the layout
    of app directories is always the same.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令 `adb root` 会以 root 权限重新启动设备上的 adb 守护进程（`adbd`）。你必须执行此操作才能访问由 Android 的进程隔离安全机制保护的应用程序的私密文件。输出显示了安装过程中创建的三个默认目录，但目前没有文件。未来进行恶意软件分析时，你可以跳过这个目录检查，因为应用目录的布局始终相同。
- en: '**Detecting Malicious Functionality**'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**检测恶意功能**'
- en: Now we’ll execute the app while our dynamic analysis tools run in the background
    to monitor what it’s doing. This workflow is the essence of dynamic analysis,
    and the approach of this section mirrors the steps taken to find entry points
    in [Chapter 3](ch03.xhtml). The difference is that instead of looking for structural
    properties of the app (like permissions, APIs, or entry points), we’re now observing
    different effects of the malware on its environment and using these as clues for
    further analysis of the malware’s functionality. Concretely, we will look at how
    the malware interacts with the emulator’s filesystem, its network connections,
    and the system log.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将运行应用，同时我们的动态分析工具在后台运行以监控它的行为。这一工作流程是动态分析的核心，本节的方法与 [第 3 章](ch03.xhtml)
    中找到入口点的步骤相似。不同之处在于，我们现在不是寻找应用的结构属性（如权限、API 或入口点），而是观察恶意软件对其环境产生的不同影响，并利用这些线索进一步分析恶意软件的功能。具体来说，我们将查看恶意软件如何与模拟器的文件系统、网络连接以及系统日志进行交互。
- en: 'To run the app, you can either start it through the app drawer in the emulator,
    like a regular user, or use the command line with adb’s somewhat obscure app starting
    command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行该应用，你可以通过模拟器中的应用抽屉像普通用户一样启动它，或者使用命令行和 adb 的某些较为隐晦的应用启动命令：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Originally developed for app testing, `monkey` is a helper program on Android
    that simulates a real user interacting with the target app. Here, we only use
    its capability to start a given app by name. The trailing `1` refers to the number
    of user interface events we want `monkey` to simulate in the target process. In
    our case, we only need to start the app once.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`monkey` 是一个最初为应用测试开发的辅助程序，它模拟真实用户与目标应用的交互。在这里，我们仅使用它通过名称启动指定应用的功能。末尾的 `1`
    表示我们希望 `monkey` 在目标进程中模拟的用户界面事件的数量。在我们的案例中，我们只需要启动应用一次。'
- en: Now that the app is running, it should display the screen shown in [Figure 4-1](ch04.xhtml#ch4fig1).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已经运行，它应该显示 [图 4-1](ch04.xhtml#ch4fig1) 所示的屏幕。
- en: '![Image](../images/ch04fig01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig01.jpg)'
- en: '*Figure 4-1: The first screen of the malicious sample*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：恶意样本的第一个屏幕*'
- en: As you can see, the app tries to convince the user to grant it access to the
    powerful accessibility API. A click of the large circular button at the bottom
    opens the system dialog, where the user can give the app this permission. For
    now, we won’t grant access to the accessibility permission or go deeper into the
    application. Instead, we’ll move on to the next step of the analysis.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，应用程序试图说服用户授予它访问强大辅助功能 API 的权限。点击底部的大圆形按钮会打开系统对话框，用户可以在其中授予应用程序此权限。暂时我们不会授予辅助功能权限，也不会深入到应用程序中去。相反，我们将继续进行下一步分析。
- en: '***Observing Filesystem Changes***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***观察文件系统变化***'
- en: 'Now that the app is running, we can take another look at its default file directory.
    To make this output more useful, let’s refine the `adb` command to dump the file
    types of all files in this directory. The quotation marks are necessary due to
    the trailing semicolon:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然应用程序已经运行，我们可以再看看它的默认文件目录。为了让这个输出更加有用，我们将优化 `adb` 命令，以显示该目录中所有文件的文件类型。由于末尾有分号，必须使用引号：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output shows the creation of a lot of new files. Many of these are boilerplate
    files created by Android, but two stand out. The first is *shared_prefs/ring0.xml*,
    which seems to be a joke name: ring zero is the highest privilege level for execution
    on some computers. The other is *app_Dynamic OptDex/hq.json*, which has a file
    extension that implies it is a text file. However, the `file` command has indicated
    that it’s a ZIP file. We should investigate this mismatch between the declared
    file extension and the file’s contents.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了大量新文件的创建。其中许多是 Android 创建的模板文件，但有两个文件特别引人注目。第一个是*shared_prefs/ring0.xml*，似乎是一个玩笑名字：ring
    zero 是某些计算机上执行的最高权限级别。另一个是*app_Dynamic OptDex/hq.json*，它的文件扩展名暗示它是一个文本文件。然而，`file`
    命令显示它实际上是一个 ZIP 文件。我们应该调查声明的文件扩展名与文件内容之间的这个不匹配问题。
- en: '***Downloading Files for Inspection***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***下载文件以进行检查***'
- en: 'For further inspection of the files dumped by the app, we can download all
    of them from the device to the host computer with `adb pull`. This command can
    download both individual files and entire directories:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步检查应用程序导出的文件，我们可以通过 `adb pull` 命令将所有文件从设备下载到主机计算机。此命令可以下载单个文件或整个目录：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let’s perform a quick inspection of the two suspicious files:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们快速检查这两个可疑文件：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The *ring0.xml* file seems to contain configuration settings of unknown meaning,
    but with an interesting domain name. The *hq.json* file seems to contain DEX code,
    as indicated by the *classes.dex* string. Presumably, the malware writes this
    file to disk and loads it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*ring0.xml* 文件似乎包含一些未知含义的配置设置，但其中有一个有趣的域名。*hq.json* 文件似乎包含 DEX 代码，正如 *classes.dex*
    字符串所示。可以推测，恶意软件将此文件写入磁盘并加载它。'
- en: At this point, we have leads into the malware that we could chase down. What
    is the suspicious domain in the XML file? What do the other configuration options
    mean? Where does the DEX file come from, and what does it do? For now, we won’t
    pursue these leads. Instead, we’ll use other dynamic analysis tools to learn more
    about the malware.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经获得了一些可以追查的恶意软件线索。XML 文件中的可疑域名是什么？其他配置选项是什么意思？DEX 文件来自哪里，它有什么作用？暂时我们不会追查这些线索。相反，我们将使用其他动态分析工具来进一步了解恶意软件。
- en: '**NOTE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Apps can also access other parts of the filesystem. In particular, many apps
    write data to Android’s shared external storage. For brevity, we have omitted
    a discussion of the malware’s interaction with these storage areas, but a complete
    dynamic analysis should cover this.*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用程序还可以访问文件系统的其他部分。特别是，许多应用程序会向 Android 的共享外部存储写入数据。为了简洁起见，我们省略了关于恶意软件与这些存储区域的交互讨论，但完整的动态分析应该包括这部分内容。*'
- en: '***Capturing Network Traffic***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***捕获网络流量***'
- en: Another target of dynamic analysis is network traffic. We can capture and analyze
    this traffic to find out where malware sends data to and where it receives it
    from. This can provide important insights into the commands the malware can execute
    and what sensitive data it may attempt to steal.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析的另一个目标是网络流量。我们可以捕获并分析这些流量，以找出恶意软件向哪里发送数据以及从哪里接收数据。这可以为我们提供恶意软件能够执行的命令，以及它可能试图窃取哪些敏感数据的重要线索。
- en: Before capturing network traffic, it’s important to reset the emulated device
    to a clean state. Otherwise, the app may not repeat some network requests that
    already happened during prior runs. What if, for example, the DEX code file *hq.json*
    was downloaded from the internet? The app might not download the file again, as
    it’s already present on disk. You’d be stumped if you wanted to understand the
    origins of this DEX file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获网络流量之前，重要的是将模拟器设备重置为干净状态。否则，应用程序可能不会重复先前运行时已发生的某些网络请求。例如，如果 DEX 代码文件 *hq.json*
    是从互联网上下载的呢？应用程序可能不会再次下载该文件，因为它已经存在于磁盘上。如果你想了解这个 DEX 文件的来源，你就会感到困惑。
- en: Of course, after you wipe the device, you’ll need to again upload the tcpdump
    file to the emulator and make it executable. This task can quickly get tedious
    if you find yourself resetting the emulator regularly. We recommend putting all
    the emulator configuration commands into a shell script that you can easily execute
    after wiping it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在你清除设备数据后，你需要再次上传 `tcpdump` 文件到模拟器并使其可执行。如果你经常需要重置模拟器，这项任务会变得非常繁琐。我们建议将所有模拟器配置命令放入一个
    shell 脚本中，这样在清除设备后可以轻松执行。
- en: 'To capture network data, we use the `adb exec-out` command to run the `tcpdump`
    executable on the emulator. We then use `adb exec-out` to transfer binary data
    from the emulator to the host system, piping it into Wireshark for easy consumption.
    It’s worth noting that network traffic can only be captured if `adbd` runs as
    root on the device. If you haven’t put `adbd` into root mode after resetting the
    emulator, now is a good time to do that:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获网络数据，我们使用 `adb exec-out` 命令在模拟器上运行 `tcpdump` 可执行文件。然后，我们使用 `adb exec-out`
    将二进制数据从模拟器传输到主机系统，并将其通过管道传输到 Wireshark 以方便查看。值得注意的是，只有当 `adbd` 在设备上以 root 身份运行时，才能捕获网络流量。如果你在重置模拟器后还没有将
    `adbd` 置于 root 模式，现在是时候这么做了：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We use the tcpdump command line option `-i any` to capture traffic from any
    network interface. The combination of `-U` and `-w` makes sure that captured packets
    are immediately written to the output file. The Wireshark command line arguments
    `-k -S` immediately start capturing and displaying packets. The `-i -` argument
    tells Wireshark to expect network packets to come from stdin, which is where they
    get piped from adb.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `tcpdump` 命令行选项 `-i any` 来捕获来自任何网络接口的流量。`-U` 和 `-w` 的组合确保捕获的数据包会立即写入输出文件。Wireshark
    的命令行参数 `-k -S` 会立即开始捕获并显示数据包。`-i -` 参数告诉 Wireshark 从标准输入（stdin）接收网络数据包，数据包是通过
    adb 被管道传输到此处的。
- en: Note that this command captures all network traffic from the device, meaning
    that the captured data doesn’t necessarily come from the malware under analysis.
    If other processes make network connections, their traffic will be captured, too.
    On a freshly reset device, this is usually not a problem, as barely any apps are
    running and the operating system makes very few network connections. To get a
    better understanding of the default network connections on your Android device,
    you could capture the network traffic without running the malware or any other
    app.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个命令会捕获设备的所有网络流量，这意味着捕获的数据不一定来自正在分析的恶意软件。如果其他进程也建立了网络连接，它们的流量也会被捕获。在一个刚重置的设备上，这通常不是问题，因为几乎没有应用程序在运行，操作系统的网络连接也很少。为了更好地了解你
    Android 设备的默认网络连接，你可以在不运行恶意软件或其他应用程序的情况下捕获网络流量。
- en: '***Analyzing Network Traffic***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析网络流量***'
- en: Once tcpdump and Wireshark are up and running, we can start looking at the captured
    traffic. [Figure 4-2](ch04.xhtml#ch4fig2) shows an example of a Wireshark session
    with packets captured during a run of *com.spike.old*. The top third of the Wireshark
    window shows a summary of all captured network packets. The middle third shows
    parsed information about the selected HTTP network packet. The lower third shows
    a hex dump of the selected packet’s payload.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 tcpdump 和 Wireshark 启动并运行，我们就可以开始查看捕获的流量。[图 4-2](ch04.xhtml#ch4fig2) 显示了一个
    Wireshark 会话示例，展示了在运行 *com.spike.old* 时捕获的数据包。Wireshark 窗口的上三分之一显示了所有捕获的网络数据包的摘要。中间三分之一显示了选定的
    HTTP 网络数据包的解析信息。底部三分之一显示了选定数据包有效载荷的十六进制转储。
- en: '![Image](../images/ch04fig02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig02.jpg)'
- en: '*Figure 4-2: Wireshark showing captured network traffic from the malicious
    app*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：Wireshark 显示来自恶意应用的捕获网络流量*'
- en: Some of the information from [Figure 4-2](ch04.xhtml#ch4fig2) is reproduced
    in [Listing 4-1](ch04.xhtml#ch4lis1) to make it more readable. In particular,
    we’ve chosen to show the structured information about the HTTP packet.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](ch04.xhtml#ch4fig2) 中的一些信息在 [清单 4-1](ch04.xhtml#ch4lis1) 中有所重现，以便于阅读。特别是，我们选择展示
    HTTP 数据包的结构化信息。'
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 4-1: Details of a captured network connection in Wireshark*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：Wireshark 捕获的网络连接详情*'
- en: From this, we learn that the intercepted packet is an HTTP POST request to *http://simpleyo5.tk/ping*,
    a URL on the same domain we previously saw in the suspicious configuration file,
    *ring0.xml*. The abbreviated hex dump at the bottom of the listing shows that
    the POST payload (the data sent to the domain) appears to be JSON-formatted text
    with keys `hash` and `id` and what appear to be Base64-encoded values.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们得知，拦截到的数据包是一个 HTTP POST 请求，目标地址为 *http://simpleyo5.tk/ping*，这是我们之前在可疑配置文件
    *ring0.xml* 中看到的同一域名。底部的简略十六进制转储显示，POST 有效载荷（发送到该域的数据）似乎是 JSON 格式的文本，包含 `hash`
    和 `id` 键，以及看起来像是 Base64 编码的值。
- en: Capturing network traffic proved to be a successful strategy. We’ve confirmed
    that the malware uses the domain *simpleyo5.tk*, and that JSON and Base64-encoded
    data gets sent to the domain’s */ping* endpoint. We also know some of the plaintext
    JSON keys. We’ll add these insights to our collection of leads to pursue later.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获网络流量证明是一种成功的策略。我们已经确认恶意软件使用了域名*simpleyo5.tk*，并且 JSON 和 Base64 编码的数据被发送到该域名的*/ping*端点。我们还知道一些明文的
    JSON 键。我们将这些见解添加到我们后续要追踪的线索中。
- en: '***Analyzing Logs with Logcat***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Logcat 分析日志***'
- en: One powerful source of information is Android’s system-wide log, which the operating
    system and apps use to log debug data, error messages, and other information.
    Careless malware developers who use the default logging system to debug their
    apps may forget to remove log statements in their final release and inadvertently
    give away a lot of information.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个强大的信息来源是 Android 系统范围的日志，操作系统和应用程序使用它来记录调试数据、错误消息和其他信息。粗心的恶意软件开发者如果使用默认的日志系统来调试他们的应用，可能会忘记在最终发布时移除日志语句，从而无意间泄露了大量信息。
- en: Luckily for us, *com.spike.old* is one of those apps. It makes heavy use of
    logging, and the information it logs is so detailed that we’ve intentionally placed
    this section after our discussions of network capture and filesystem analysis
    to avoid giving away too much information.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，*com.spike.old* 就是其中一个这样的应用。它大量使用日志，且记录的信息非常详细，我们特意将这一节放在了网络捕获和文件系统分析之后，以避免泄露过多信息。
- en: 'The standard way to access the Android system log is to use the logcat tool,
    for example, through the `adb logcat` command. By default, logcat dumps the whole
    system logfile, which is usually many thousands of lines. To filter out irrelevant
    details, we can specify the process ID of the app under observation, as shown
    here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Android 系统日志的标准方法是使用 logcat 工具，例如通过 `adb logcat` 命令。默认情况下，logcat 会转储整个系统日志文件，通常有数千行。为了过滤掉不相关的细节，我们可以指定正在观察的应用程序的进程
    ID，如下所示：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We first query for the malware’s process ID (in our case, 3711) and then tell
    logcat to only include lines with this ID. As we mentioned, the `logcat` command
    returns way too much useful information to print here. However, a sneak peek is
    shown in [Listing 4-2](ch04.xhtml#ch4lis2). Yes, the app really dumps the encryption
    parameters for its command-and-control communications to the system log. Usually,
    you won’t get this lucky during malware analysis.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查询恶意软件的进程 ID（在我们的案例中为 3711），然后告诉 logcat 只包括包含该 ID 的行。如我们所提到的，`logcat` 命令返回的信息量太大，不适合在此全部打印。然而，[列表
    4-2](ch04.xhtml#ch4lis2) 展示了一个简短的预览。是的，应用程序确实将其命令与控制通信的加密参数转储到系统日志中。通常，在恶意软件分析中你不会这么幸运。
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 4-2: The logcat output for* com.spike.old'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-2: com.spike.old 的 logcat 输出*'
- en: The string `pioneer_bridge_over_white_rabbits` is noteworthy. It’s a debug string
    used by the app as a prefix for its logs. Why the app includes it is unclear.
    Elsewhere in the log data (but omitted here), you can find information about the
    network payloads, a mapping of encrypted and decrypted JSON objects, fairly detailed
    information about which classes are executed, and more.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `pioneer_bridge_over_white_rabbits` 值得注意。它是应用程序用于日志前缀的调试字符串。为什么应用程序会包含它尚不清楚。在日志数据的其他地方（但此处省略），你可以找到有关网络负载的信息、加密和解密的
    JSON 对象映射、执行的类的详细信息等。
- en: 'One advantage of logcat is that the operating system buffers and preserves
    its log for a while. This means that you don’t need to monitor logcat while the
    app is running: it’s possible to grab information from the system log long after
    the app under analysis has stopped executing. Because logcat is size-limited,
    the availability of an app’s data depends on how many log entries are generated
    on an Android device before earlier log entries get culled. In practice, usually
    they remain available for a few hours.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: logcat 的一个优点是操作系统会暂时缓冲和保存日志。这意味着你无需在应用程序运行时监控 logcat：即使在分析的应用程序停止执行后，你仍然可以从系统日志中获取信息。由于
    logcat 的大小有限，应用程序数据的可用性取决于 Android 设备上生成的日志条目的数量，以及在较早的日志条目被删除之前多少条日志仍然可用。实际上，通常它们会在几个小时内保持可用。
- en: '**Analysis with Frida**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Frida 进行分析**'
- en: So far, we’ve used the tools adb, logcat, tcpdump, and Wireshark to quickly
    discover properties of the app under observation. However, these tools don’t allow
    us to link the observed app properties back to concrete sections of the app’s
    code. We now know that *com.spike.old* dumps files to disk, connects to a command-and-control
    server, and encrypts its communication, but we don’t know any details about where,
    why, or how it does any of this. We can use Frida to make these connections.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了 adb、logcat、tcpdump 和 Wireshark 等工具快速发现了被观察应用的属性。然而，这些工具并不能让我们将观察到的应用属性与应用程序代码的具体部分关联起来。我们现在知道
    *com.spike.old* 会将文件转储到磁盘、连接到命令与控制服务器，并加密其通信，但我们并不知道它在哪、为什么或如何做这些事情。我们可以使用 Frida
    来建立这些连接。
- en: Frida is a powerful tool, and an explanation of all of its functions could fill
    a whole other book. Here, we’ll only cover those that further our understanding
    of the malicious sample. In particular, we’ll use `frida-trace` to quickly understand
    which interesting Java APIs the malware uses. We’ll also use Frida scripting to
    find these interesting APIs in the malware’s code. Curious readers are encouraged
    to read more about Frida’s many uses, as this chapter covers only about 1 percent
    of the tool’s capabilities.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Frida 是一款功能强大的工具，对其所有功能的解释可以填满另一本书。在这里，我们只会讨论那些有助于我们理解恶意样本的功能。特别地，我们将使用 `frida-trace`
    快速了解恶意软件使用了哪些有趣的 Java API。我们还将使用 Frida 脚本在恶意软件的代码中查找这些有趣的 API。好奇的读者可以进一步阅读 Frida
    的多种用途，因为本章仅涵盖了该工具大约 1% 的功能。
- en: '***Running frida-server***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行 frida-server***'
- en: 'You should have already installed `frida-server` on the device and made it
    executable. Now you must run it so that it can communicate with the `frida` client
    on the host system and interact with the malware. We’ll use `adb shell` again
    to run `frida-server`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在设备上安装了 `frida-server` 并使其可执行。现在你必须运行它，以便它能够与主机系统上的 `frida` 客户端通信并与恶意软件进行交互。我们将再次使用
    `adb shell` 来运行 `frida-server`：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: One caveat is that `frida-server` must run with root privileges.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警告是 `frida-server` 必须以 root 权限运行。
- en: '***Using frida-trace to Find Interesting APIs***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 frida-trace 查找有趣的 API***'
- en: 'The `frida-trace` tool can dynamically trace method calls in the app under
    observation and dump some basic properties about the APIs it uses. The tool expects
    a list of methods to intercept, and it sends these methods’ inputs and outputs
    to stdout. It supports regular expressions, making the monitoring of all methods
    of a class, or even a package, a breeze. For example, the following command dumps
    information about how the malware uses all methods in the classes `Cipher` and
    `SecretKeySpec` from the default Java cryptography package:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`frida-trace` 工具可以动态追踪被观察应用中的方法调用，并转储有关它所使用的 API 的一些基本属性。该工具需要一个要拦截的方法列表，并将这些方法的输入和输出发送到标准输出。它支持正则表达式，可以轻松监控一个类甚至一个包中的所有方法。例如，以下命令可以转储恶意软件如何使用来自默认
    Java 加密包中 `Cipher` 和 `SecretKeySpec` 类的所有方法的信息：'
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command outputs hundreds of lines of information about the use of this
    cryptography API. [Listing 4-3](ch04.xhtml#ch4lis3) shows a tiny part. We can
    see how the malware sets up an AES encryption key and an initialization vector
    (IV), and then uses the cipher defined by these properties to decrypt a byte array.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令输出关于该加密 API 使用情况的数百行信息。[清单 4-3](ch04.xhtml#ch4lis3)展示了其中的一小部分。我们可以看到恶意软件是如何设置
    AES 加密密钥和初始化向量（IV）的，然后使用这些属性定义的加密算法解密一个字节数组。
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 4-3: The output of frida-trace related to cryptography APIs*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-3：与加密 API 相关的 frida-trace 输出*'
- en: This output gives us more leads to pursue later. We’ve confirmed that the app
    uses the default Java cryptography package, and we know some of the configuration
    parameters it uses for encryption.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出为我们后续的工作提供了更多线索。我们已经确认应用程序使用了默认的 Java 加密包，并且了解了一些它用于加密的配置参数。
- en: In [Chapter 3](ch03.xhtml), we recommended that reverse engineers build a list
    of interesting API methods to search for when analyzing a program’s code. You
    can use this same list with `frida-trace` to intercept and log how mal-ware uses
    the APIs. Besides cryptography APIs, you might try to intercept those related
    to network communication, filesystem access, or access to sensitive data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.xhtml)中，我们建议逆向工程师在分析程序代码时建立一个有趣的 API 方法列表以便搜索。你可以使用相同的列表与`frida-trace`结合，拦截并记录恶意软件如何使用这些
    API。除了加密 API，你还可以尝试拦截与网络通信、文件系统访问或敏感数据访问相关的 API。
- en: '***Finding Entry Points into the Malware with Frida Scripting***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Frida 脚本寻找恶意软件的入口点***'
- en: The downside of `frida-trace` is that it can’t link the observed APIs to the
    malware’s code. We might know now that the malware uses encryption, and even how
    it sets up its ciphers, but we don’t know where this happens. To make this connection,
    we can use Frida scripting.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`frida-trace`的缺点是它无法将观察到的 API 与恶意软件的代码关联起来。我们现在可能知道恶意软件使用了加密，甚至知道它如何设置加密算法，但我们并不知道这发生在什么位置。为了建立这种联系，我们可以使用
    Frida 脚本。'
- en: Scripting is likely Frida’s most useful capability. It allows Frida users to
    write custom code in different programming languages to interact with the program
    under observation. In this section, we’ll use this capability to connect API calls
    to the underlying malware’s code by observing the stack traces of interesting
    functions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本编写可能是 Frida 最有用的功能。它允许 Frida 用户使用不同的编程语言编写自定义代码与被观察的程序交互。在本节中，我们将使用这个功能，通过观察有趣函数的堆栈跟踪，将
    API 调用与底层恶意软件的代码联系起来。
- en: Using `frida-trace`, we learned that the malware calls the default Java cryptography
    API `Cipher.doFinal` to encrypt and decrypt data. We can now specifically target
    this API with a custom Frida script that discovers the locations in the malware
    that call the API. Written in JavaScript, [Listing 4-4](ch04.xhtml#ch4lis4) is
    a very simple Frida script that intercepts the `Cipher.doFinal` API. Save it to
    a file called *xeno-dofinal.js*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `frida-trace`，我们了解到恶意软件调用了默认的 Java 加密 API `Cipher.doFinal` 来加密和解密数据。现在，我们可以通过一个自定义的
    Frida 脚本来专门拦截这个 API，发现恶意软件中调用该 API 的位置。这个脚本使用 JavaScript 编写，[清单 4-4](ch04.xhtml#ch4lis4)
    是一个非常简单的 Frida 脚本，用于拦截 `Cipher.doFinal` API。将其保存为名为 *xeno-dofinal.js* 的文件。
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 4-4: A Frida script that intercepts the doFinal API*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4：拦截 doFinal API 的 Frida 脚本*'
- en: We use `Java.perform`, from Frida’s JavaScript API, to ensure that the current
    thread is attached to the virtual machine and then execute the function given
    in its argument. In our example, the provided function contains the code responsible
    for hooking `Cipher.doFinal`. Hooking a Java method first requires acquiring a
    JavaScript wrapper for its class. To do this, we use the Frida JavaScript API
    `Java.use`, which takes a fully qualified Java class name as its argument.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Frida的JavaScript API中的`Java.perform`，确保当前线程附加到虚拟机上，然后执行其参数中给定的函数。在我们的示例中，提供的函数包含了负责hook
    `Cipher.doFinal`的代码。Hook一个Java方法首先需要获取该类的JavaScript封装器。为此，我们使用Frida JavaScript
    API中的`Java.use`，它以完全限定的Java类名作为参数。
- en: Before hooking and overwriting a method, we need to determine whether there
    are multiple methods with the same name in the hooked class. If so, we need to
    disambiguate them using the `overload` function, explicitly passing it the method
    parameters’ Java types. Here, we do this for the `doFinal` method by passing the
    argument `”[B”`, which indicates a byte array in Java type syntax.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在hook和覆盖方法之前，我们需要确定在被hook的类中是否存在多个同名方法。如果有，我们需要使用`overload`函数进行区分，明确传递方法参数的Java类型。在这里，我们通过传递参数`”[B”`来区分`doFinal`方法，这表示Java类型语法中的字节数组。
- en: Once we’ve found the correct overloaded method, we overwrite the object’s `implementation`
    property with the simple assignment of a custom function. Now, every time the
    app calls the hooked API, our code executes instead of the original API code.
    We also use an old Java trick to get our current location by throwing a new exception
    and printing its stack trace. Lastly, we return the expected value of `doFinal`
    by calling its original implementation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了正确的重载方法，我们通过简单地为自定义函数赋值来覆盖对象的`implementation`属性。现在，每当应用调用被hook的API时，我们的代码就会执行，而不是原始的API代码。我们还使用了一种旧的Java技巧，通过抛出一个新的异常并打印其堆栈跟踪来获取我们当前的位置。最后，我们通过调用其原始实现来返回`doFinal`的预期值。
- en: '**NOTE**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can use jadx to help you intercept methods defined in the app under analysis.
    In the jadx context menu for method definitions or calls, select **Copy as Frida
    Snippet**. This creates Frida JavaScript that uses* Java.use*, as we did in our
    script.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以使用jadx来帮助你拦截分析应用中定义的方法。在jadx的上下文菜单中，对于方法定义或调用，选择**复制为Frida脚本片段**。这将创建使用*Java.use*的Frida
    JavaScript，就像我们在脚本中所做的那样。*'
- en: '***Executing the Frida Script***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行Frida脚本***'
- en: 'Execute the Frida script from the host machine’s command line:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从主机机器的命令行执行Frida脚本：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `-U` argument instructs Frida to look for a device connected over USB,
    and the `-f` argument spawns the malware app. The `-l` argument specifies the
    script file to run. Once you run this command, the Frida shell should open and
    spawn the malware in a suspended state. To continue its execution, enter %resume
    in the shell:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`-U`参数指示Frida查找通过USB连接的设备，`-f`参数启动恶意软件应用。`-l`参数指定要运行的脚本文件。一旦你运行了这个命令，Frida
    shell应该会打开，并在挂起状态下启动恶意软件。要继续执行它，请在shell中输入%resume：'
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Listing 4-5](ch04.xhtml#ch4lis5) shows the script’s output. You should read
    this log from top to bottom. Each printed stack trace begins with `java.lang.Exception`,
    followed by the `doFinal` call under observation. After that, you’ll see the code
    snippet that calls `doFinal`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表4-5](ch04.xhtml#ch4lis5)展示了脚本的输出。你应该从上到下阅读这个日志。每个打印的堆栈跟踪都以`java.lang.Exception`开始，接着是被观察的`doFinal`调用。之后，你将看到调用`doFinal`的代码片段。'
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 4-5: The Frida script’s output shows places where* doFinal *is called.*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-5：Frida脚本的输出展示了调用*doFinal*的位置。*'
- en: The first stack trace shows the `encryptMessage` function, and the second shows
    `decryptMessage`. For the first time, we’re able to develop an understanding of
    the app’s control flow. The script’s output shows exactly how the `doFinal` method
    is called from the nonstandard *com.sniff* package, which must be the part of
    the malware that performs encryption.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个堆栈跟踪显示了`encryptMessage`函数，第二个显示了`decryptMessage`。第一次，我们能够对应用的控制流程有所了解。脚本的输出准确地显示了`doFinal`方法是如何从非标准的*com.sniff*包中被调用的，这部分应该是执行加密的恶意软件部分。
- en: To gain further insight into the malware, we could repeat this process for other
    interesting functions. For example, we might want to find where *ring0.xml* and
    *hq.json* are written to disk, and where the network connection to the command-and-control
    server is set up. We leave these tasks as an exercise for the reader.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解恶意软件，我们可以重复这个过程，分析其他有趣的功能。例如，我们可能希望找到 *ring0.xml* 和 *hq.json* 写入磁盘的位置，以及与命令与控制服务器建立网络连接的位置。我们将这些任务留给读者自行完成。
- en: '**Decrypting the Command-and-Control Communications**'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解密命令与控制通信**'
- en: As in the previous chapter, one of the most important properties of the malware
    we’ll want to reverse engineer is its encrypted communication with the command-and-control
    server. Breaking the encryption will allow us to better understand the commands
    it supports. Rather than using static analysis and code reading to find out how
    this communication works, we’ll use dynamic analysis. Between tcpdump, logcat,
    and Frida, we have all the tools we need.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章一样，我们想要逆向工程的恶意软件最重要的特性之一是它与命令与控制服务器的加密通信。破解加密将使我们更好地理解它支持的命令。我们将使用动态分析，而不是静态分析和代码阅读，来了解这种通信是如何工作的。通过
    tcpdump、logcat 和 Frida，我们拥有所需的所有工具。
- en: After our earlier analysis using tcpdump and Wireshark, we know that the first
    connection the malware makes is an HTTP POST request to *http://simpleyo5.tk/ping*.
    In this request, the malware sends a JSON object with four entries, as shown in
    [Listing 4-6](ch04.xhtml#ch4lis6).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前使用 tcpdump 和 Wireshark 进行的分析后，我们知道恶意软件首次建立的连接是一个 HTTP POST 请求，目标为 *http://simpleyo5.tk/ping*。在这个请求中，恶意软件发送了一个包含四个条目的
    JSON 对象，如 [清单 4-6](ch04.xhtml#ch4lis6) 所示。
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 4-6: The JSON payload posted to the* /ping *URL*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-6：发送到* /ping *URL 的 JSON 有效负载*'
- en: 'It’s still unclear what these values are. The one plaintext entry, `"type":
    "request_verify"`, suggests that the purpose of this connection is to request
    that the malware client be verified. We’ve shortened the value of `id` here; originally,
    it had more than 7,000 bytes. Its length indicates that it might be the message’s
    main payload. The value of `hash` is unknown at this point, as is the value of
    `iv`, which has a noteworthy name. Could this be the initialization vector used
    to encrypt the payload? Later, we’ll confirm this to be the case.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '这些值仍然不清楚。唯一的明文条目 `"type": "request_verify"` 表示此连接的目的是请求对恶意软件客户端进行验证。我们在这里简化了
    `id` 的值；原本它有超过 7,000 个字节。它的长度表明它可能是消息的主要有效负载。`hash` 的值目前尚不清楚，`iv` 的值也不明确，且其名字引人注意。它是否是用于加密有效负载的初始化向量？稍后我们将确认这一点。'
- en: '***With CyberChef***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 CyberChef***'
- en: CyberChef ([*https://gchq.github.io/CyberChef*](https://gchq.github.io/CyberChef))
    is an open source web app for encryption, encoding, compression, and data analysis.
    Developed by the Government Communications Headquarters (GCHQ), the British equivalent
    of the NSA, it is likely the most user-friendly way to manipulate, transform,
    and decrypt data during malware analysis. In this section, we’ll use it to play
    around with the malware’s encrypted communications protocol.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CyberChef ([*https://gchq.github.io/CyberChef*](https://gchq.github.io/CyberChef))
    是一个开源的 Web 应用，用于加密、编码、压缩和数据分析。由英国的政府通讯总部（GCHQ）开发，GCHQ 是英国版的 NSA，它可能是恶意软件分析过程中操作、转换和解密数据最用户友好的方式。在本节中，我们将使用它来操作恶意软件的加密通信协议。
- en: '[Figure 4-3](ch04.xhtml#ch4fig3) shows the CyberChef interface. In the upper-right
    corner, you can input plaintext data to transform. The bottom-right corner is
    an output field for the transformed data. On the left side, you can pick from
    dozens of data transformations to drag and drop into the center.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-3](ch04.xhtml#ch4fig3) 显示了 CyberChef 界面。在右上角，您可以输入要转换的明文数据。右下角是转换后数据的输出字段。在左侧，您可以从几十种数据转换中选择，拖动并放入中央区域。'
- en: '![Image](../images/ch04fig03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig03.jpg)'
- en: '*Figure 4-3: Using CyberChef to get the hexadecimal byte values of a Base64-encoded
    string*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：使用 CyberChef 获取 Base64 编码字符串的十六进制字节值*'
- en: 'In the example shown here, we’ve input the `iv` value from the JSON payload
    in the previous section. Then we chose two data transformations to apply: Base64
    decoding and converting the result into a hex string. This outputs the string
    `33 42 9c 49 1c 0e 32 f2 a7 6c d7 78 4c 4e f5 f5`, which corresponds to the bytes
    of the `iv` value before it was Base64-encoded.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里显示的示例中，我们输入了前一部分 JSON 负载中的 `iv` 值。然后，我们选择了两种数据转换应用：Base64 解码和将结果转换为十六进制字符串。这输出了字符串
    `33 42 9c 49 1c 0e 32 f2 a7 6c d7 78 4c 4e f5 f5`，它对应于 `iv` 值在进行 Base64 编码之前的字节。
- en: '**NOTE**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*CyberChef recipes can be much more complex than shown here, often using control
    flow operations, code disassembly, or YARA rules.*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*CyberChef 配方可能比这里展示的更复杂，通常使用控制流操作、代码反汇编或 YARA 规则。*'
- en: The Frida output told us that the malware uses AES encryption in its so-called
    CBC mode to encrypt and decrypt payloads. We need to recover the encryption keys
    and algorithm initialization vectors to successfully decrypt the payload. In the
    logcat logs, the JSON payload itself, and Frida’s output, we’ve encountered a
    couple of potential encryption keys and initialization vectors. In the next section,
    we’ll present a more structured approach to discovering these values, but for
    now, let’s use the IV from the JSON payload and the encryption key we found in
    the system log. We can use this information to complete the CyberChef recipe,
    making sure to pick the appropriate input formats for the payload, key, and IV
    (in our case, Raw, Hex, and Base64). [Figure 4-4](ch04.xhtml#ch4fig4) shows the
    result.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Frida 输出告诉我们，恶意软件使用 AES 加密，在所谓的 CBC 模式下对负载进行加密和解密。我们需要恢复加密密钥和算法初始化向量，才能成功解密负载。在
    logcat 日志、JSON 负载本身以及 Frida 输出中，我们遇到了一些潜在的加密密钥和初始化向量。在下一节中，我们将展示一个更有结构的方法来发现这些值，但现在，让我们先使用
    JSON 负载中的 IV 和我们在系统日志中找到的加密密钥。我们可以使用这些信息完成 CyberChef 配方，确保为负载、密钥和 IV 选择合适的输入格式（在我们这里是
    Raw、Hex 和 Base64）。[图 4-4](ch04.xhtml#ch4fig4) 显示了结果。
- en: '![Image](../images/ch04fig04.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig04.jpg)'
- en: '*Figure 4-4: Decrypting command-and-control communication with CyberChef*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：使用 CyberChef 解密命令和控制通信*'
- en: We’ve reproduced the decrypted JSON payload in its entirety in [Listing 4-7](ch04.xhtml#ch4lis7).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[列表 4-7](ch04.xhtml#ch4lis7)中完整地重现了解密后的 JSON 负载。
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 4-7: The decrypted JSON payload posted to the* /ping *URL*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-7：发送到* /ping *URL 的解密 JSON 负载*'
- en: The `api` field is likely the device’s Android API version (remember that we
    configured this to 30 at the beginning of this chapter). Next is a list of apps,
    presumably those installed on the system. The `imei` and `model` fields are probably
    the device’s IMEI number and device model. It’s unclear what `numbers` is, but
    it could be the device’s phone number or the phone numbers of contacts from the
    contact list. The `tag` field likely identifies the malware app itself, while
    `uid` could be some sort of unique user ID.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`api` 字段可能是设备的 Android API 版本（记得我们在本章开始时将其配置为 30）。接下来是一个应用程序列表，可能是安装在系统上的应用程序。`imei`
    和 `model` 字段可能是设备的 IMEI 编号和设备型号。`numbers` 是什么还不清楚，但它可能是设备的电话号码或联系人列表中的电话号码。`tag`
    字段可能标识恶意软件应用本身，而 `uid` 可能是某种唯一的用户 ID。'
- en: Of course, we now need to consider the data that the server returns. [Listing
    4-8](ch04.xhtml#ch4lis8) shows the response to the POST request.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们现在需要考虑服务器返回的数据。[列表 4-8](ch04.xhtml#ch4lis8) 显示了 POST 请求的响应。
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 4-8: The JSON response received from the* /ping *URL*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-8：从* /ping *URL 接收到的 JSON 响应*'
- en: The `type` field’s value, `response_verify`, matches the POST payload’s `request_verify`
    field. The other three fields, `hash`, `id`, and `iv`, also match fields from
    the POST request. Their values are seemingly Base64-encoded.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 字段的值 `response_verify` 与 POST 负载的 `request_verify` 字段相匹配。其他三个字段，`hash`、`id`
    和 `iv`，也与 POST 请求中的字段相匹配。它们的值似乎是 Base64 编码的。'
- en: An attempt to decrypt the `id` field with the previously used encryption key
    and IV value from the POST response doesn’t immediately produce a readable result.
    The decrypted value is a 16-byte array with seemingly random bytes. Their purpose
    and meaning are unclear for now. Likewise, we can’t easily decrypt the POST payloads
    of subsequent connections to the command-and-control server. We must strategically
    explore the malware in more depth.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用之前的加密密钥和来自 POST 响应的 IV 值解密 `id` 字段时，并未立即得到可读的结果。解密后的值是一个包含似乎随机字节的 16 字节数组。目前其用途和含义尚不清楚。同样，我们也无法轻松解密后续连接到命令和控制服务器的
    POST 负载。我们必须更深入地策略性探索恶意软件。
- en: '***With Frida***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过 Frida***'
- en: To automate the interception and decryption of encrypted command-and-control
    communications, we can use Frida. In particular, we’ll develop a script that intercepts
    important Java encryption API methods and writes their inputs and outputs to files
    for later examination. To accomplish this, we’ll use some advanced Frida features.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动拦截和解密加密的指挥控制通信，我们可以使用 Frida。具体而言，我们将编写一个脚本，拦截重要的 Java 加密 API 方法，并将它们的输入和输出写入文件，供稍后检查。为此，我们将使用一些高级
    Frida 特性。
- en: Notably, rather than using the Frida command line to spawn the malware process,
    we’ll use a second script, the *control script*, to spawn the malware process
    and control its execution. The control script will inject another script, similar
    to the one we wrote earlier in this chapter, into that process.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们不会使用 Frida 命令行来启动恶意软件进程，而是使用第二个脚本，即*控制脚本*，来启动恶意软件进程并控制其执行。控制脚本将把另一个脚本（类似于我们在本章前面编写的脚本）注入到该进程中。
- en: The Control Script
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 控制脚本
- en: Let’s begin by developing the control script, which spawns the malware app,
    attaches to it, injects the Frida script, and logs intercepted API arguments to
    disk. We’ve chosen to write it in Python to showcase Frida’s support for different
    scripting languages. Save this code to a file named *xeno.py*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写控制脚本，它将启动恶意软件应用程序、附加到其进程、注入 Frida 脚本，并将拦截到的 API 参数写入磁盘。我们选择用 Python 编写它，以展示
    Frida 对不同脚本语言的支持。将此代码保存为文件*xeno.py*。
- en: '[Listing 4-9](ch04.xhtml#ch4lis9) is the control script’s main function. It
    uses Frida Python bindings to interact with the Android emulator.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-9](ch04.xhtml#ch4lis9)是控制脚本的主函数。它使用 Frida Python 绑定与 Android 模拟器进行交互。'
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 4-9: The control script’s main function*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-9：控制脚本的主函数*'
- en: The main function connects to the Android emulator over USB, launches and attaches
    to the malware process, and gets its process ID. It uses the `inject_script` function
    to inject the Frida script into the malware process and then continues its execution,
    keeping the script alive until the user hits CTRL-C. [Listing 4-10](ch04.xhtml#ch4lis10)
    shows the definition of `inject_script`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数通过 USB 连接到 Android 模拟器，启动并附加到恶意软件进程，获取其进程 ID。它使用`inject_script`函数将 Frida
    脚本注入到恶意软件进程中，然后继续执行，保持脚本活跃，直到用户按下 CTRL-C。[清单 4-10](ch04.xhtml#ch4lis10)展示了`inject_script`的定义。
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 4-10: The control script’s process injection function*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-10：控制脚本的进程注入功能*'
- en: This function loads the Frida script file *xeno.js* (which you will find later
    in this chapter, in [Listing 4-12](ch04.xhtml#ch4lis12)) into the malware process.
    Most importantly, it sets up the callback method `on_message`, which can receive
    messages from the Frida script inside the malware process. The format of these
    messages will become clearer once we discuss the injected script’s code. Generally,
    Frida’s default message format defines key/value pairs, with two default keys,
    `type` and `payload`. Our injected script overwrites the `payload` values with
    new key/value pairs. For each message, the key can be `iv`, `key`, `input`, or
    `output`, depending on the type of binary data in the value field.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能将 Frida 脚本文件*xeno.js*（稍后在本章的[清单 4-12](ch04.xhtml#ch4lis12)中可以找到）加载到恶意软件进程中。最重要的是，它设置了回调方法`on_message`，该方法可以接收来自恶意软件进程内
    Frida 脚本的消息。消息的格式将在我们讨论注入的脚本代码时变得更加清晰。通常，Frida 的默认消息格式定义了键/值对，并有两个默认键，`type` 和
    `payload`。我们的注入脚本会用新的键/值对覆盖`payload`的值。对于每条消息，键可以是`iv`、`key`、`input`或`output`，具体取决于值字段中的二进制数据类型。
- en: Lastly, the control script defines the `write_data` function, which takes the
    intercepted data and writes it to multiple files ([Listing 4-11](ch04.xhtml#ch4lis11)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，控制脚本定义了`write_data`函数，该函数接收拦截到的数据，并将其写入多个文件（[清单 4-11](ch04.xhtml#ch4lis11)）。
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 4-11: The control script’s file writing function*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-11：控制脚本的文件写入功能*'
- en: To preserve the chronological order in which the data was collected, this function
    writes each piece to a distinct file using a filename that contains the current
    time in milliseconds (ms) and the data type.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持数据收集的时间顺序，该功能使用包含当前毫秒时间（ms）和数据类型的文件名，将每条数据写入一个独立的文件。
- en: The Injected Script
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注入脚本
- en: The script that we inject into the malware process is much smaller. Its only
    job is to intercept Java cryptography APIs `SecretKeySpec` and `Cipher.doFinal`
    and send the data passed to them to the control script. [Listing 4-12](ch04.xhtml#ch4lis12)
    shows this JavaScript script in its entirety.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注入到恶意软件进程中的脚本要小得多。它的唯一任务是拦截Java加密API `SecretKeySpec` 和 `Cipher.doFinal`，并将传递给它们的数据发送到控制脚本。[列表
    4-12](ch04.xhtml#ch4lis12)展示了整个JavaScript脚本。
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 4-12: The injected script* (xeno.js)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-12：注入的脚本*（xeno.js）'
- en: This script reuses key Frida scripting concepts, such as `Java.perform` and
    `Java.use`, discussed earlier in this chapter. It also sends messages to the control
    script, using the default Frida `send` method, to transmit the encryption keys,
    initialization vectors, and plaintext and ciphertext messages.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本重用了本章早些时候讨论的Frida脚本概念，如 `Java.perform` 和 `Java.use`。它还使用Frida的默认 `send`
    方法向控制脚本发送消息，传输加密密钥、初始化向量以及明文和密文消息。
- en: 'Running the Python script should generate the following output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Python脚本应该会生成以下输出：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the script creates files containing encryption keys, initialization
    vectors, input arrays to encryption methods, and output arrays from encryption
    methods. Note that the code does not try to determine whether data is encrypted
    or decrypted, so the filenames don’t tell us whether we can find the unencrypted
    plaintext for cryptographic operations in the *input* or *output* files.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，脚本创建了包含加密密钥、初始化向量、加密方法的输入数组以及加密方法输出数组的文件。请注意，代码并没有尝试判断数据是加密还是解密，因此文件名并不能告诉我们是否可以在*输入*或*输出*文件中找到未加密的明文用于加密操作。
- en: 'We can use the Linux command line tool xxd to dump hex values and ASCII representations
    of the content of the key and initialization vector files. You’ll notice that
    the first key is the one we’ve encountered on multiple occasions:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Linux命令行工具xxd来转储密钥和初始化向量文件的十六进制值和ASCII表示。你会注意到第一个密钥是我们多次遇到过的那个：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By examining these files, we can discover that for outgoing network traffic
    the input file contains the unencrypted information that is then encrypted and
    sent to the command-and-control server. Likewise, for inbound traffic coming from
    the command-and-control server, the input file contains the received encrypted
    messages, and the output files contain the decrypted messages.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查这些文件，我们可以发现，对于外发网络流量，输入文件包含未加密的信息，然后这些信息被加密并发送到命令与控制服务器。同样，对于来自命令与控制服务器的入站流量，输入文件包含接收到的加密消息，输出文件则包含解密后的消息。
- en: '**Command-and-Control Server Messages**'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**命令与控制服务器消息**'
- en: While our Frida script provides information about the encrypted payloads, it
    doesn’t link the payloads to URL connections. However, unless we want to fully
    automate our analysis, it doesn’t have to. We’ve already logged the HTTP connections
    and their payloads with tcpdump and can look at them in Wireshark. Let’s compare
    the payloads from the files written to Frida with those visible in Wireshark.
    Because the malware makes very few connections to its server, it’s completely
    feasible to continue without automating this step.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的Frida脚本提供了有关加密负载的信息，但它并没有将负载与URL连接关联起来。然而，除非我们想完全自动化分析，否则这并不必要。我们已经使用tcpdump记录了HTTP连接及其负载，并可以在Wireshark中查看它们。让我们将写入Frida的文件中的负载与Wireshark中可见的负载进行比较。由于恶意软件与服务器的连接非常少，因此完全可以在不自动化此步骤的情况下继续。
- en: '***The /ping URL***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***/ping URL***'
- en: When we dumped network traffic with tcpdump and Wireshark, we learned that the
    malware’s first connection is to *http://simpleyo5.tk/ping*. We also successfully
    decrypted its payload with information from Frida and logcat. The largest part
    of the payload was the list of installed apps. The server replied with a JSON
    payload of a similar format but much smaller size. Running tcpdump and Wireshark
    for longer does not seem to change this payload and response. While the app makes
    subsequent connections to this URL, it only seems to use this command to make
    the server aware of an available client.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用tcpdump和Wireshark转储网络流量时，我们发现恶意软件的第一个连接是到 *http://simpleyo5.tk/ping*。我们还通过Frida和logcat的信息成功解密了其负载。负载的最大部分是已安装应用程序的列表。服务器回复了一个格式类似但大小更小的JSON负载。长时间运行tcpdump和Wireshark似乎并不会改变这个负载和响应。虽然该应用程序随后会连接到此URL，但它似乎仅通过此命令使服务器意识到有一个可用的客户端。
- en: '***The /metrics URL***'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***/metrics URL***'
- en: If you take another look at Wireshark, you’ll notice another URL to which the
    malware connects, and this one is much more interesting. After the first connection
    to */ping*, the malware starts connecting to *http://simpleyo5.tk/metrics*. These
    connections are more frequent and have more diverse payloads in both directions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再看看Wireshark，你会注意到恶意软件连接的另一个URL，而且这个URL更为有趣。在首次连接到*/ping*后，恶意软件开始连接到*http://simpleyo5.tk/metrics*。这些连接更频繁，并且双向的有效载荷更加多样化。
- en: In the first connection to the */metrics* endpoint, the malware transmits a
    JSON file with plaintext keys and encrypted values that is similar to the one
    it transmits to */ping*. For example, it could look like the one in [Listing 4-13](ch04.xhtml#ch4lis13).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次连接到*/metrics*端点时，恶意软件传输了一个包含明文键和加密值的JSON文件，这与它发送到*/ping*的文件类似。例如，它可能看起来像[清单4-13](ch04.xhtml#ch4lis13)中所示的那样。
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 4-13: The JSON payload posted to the* /metrics *URL for a* jni_update
    *command*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-13：发送到*/metrics* URL的JSON有效载荷，针对*jni_update*命令*'
- en: The values in the fields `hash`, `id`, and `iv` likely play a role similar to
    the one they play in the payload to */ping*. The `metrics` field is new and replaces
    the plaintext value of the `type` field sent to */ping*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash`、`id`和`iv`字段中的值可能在作用上类似于它们在发送到*/ping*的有效载荷中的作用。`metrics`字段是新的，取代了发送到*/ping*的`type`字段的明文值。'
- en: It turns out that `metrics` decrypts to `{”type”:”inj_update”}`, which seems
    to be a simple request from the app to the server to receive information about
    “injections,” whatever that is. The server responds with a long message that decrypts
    to the JSON payload shown in [Listing 4-14](ch04.xhtml#ch4lis14).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，`metrics`解密后为`{"type":"inj_update"}`，这似乎是应用程序向服务器发送的一个简单请求，请求获取有关“注入”的信息，无论那是什么。服务器回应一个长消息，解密后得到的JSON有效载荷如[清单4-14](ch04.xhtml#ch4lis14)所示。
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 4-14: The decrypted JSON response from the* /metrics *URL*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-14：解密后的来自*/metrics* URL的JSON响应*'
- en: This long list of app package names and URLs is interesting. Today, these URLs
    are long gone, but we explored them in a previous analysis and can present them
    here. Each HTML file is a phishing page for a different legitimate app. The screenshot
    in [Figure 4-5](ch04.xhtml#ch4fig5) shows the phishing page associated with *com.android.vending*,
    the package name of the Google Play app.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个长长的应用包名和URL列表非常有趣。今天，这些URL已经消失，但我们在之前的分析中探索过它们，并在这里展示。每个HTML文件都是针对不同合法应用的钓鱼页面。[图4-5](ch04.xhtml#ch4fig5)中的截图展示了与*com.android.vending*（即Google
    Play应用的包名）相关的钓鱼页面。
- en: '![Image](../images/ch04fig05.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig05.jpg)'
- en: '*Figure 4-5: An input field to phish credit card information in Google Play*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：在Google Play中钓鱼信用卡信息的输入框*'
- en: In addition to `inj_update`, the */metrics* URL can also receive at least one
    other command. On a subsequent connection, the malware sends it a command called
    `get_coms` whose payload is shown in [Listing 4-15](ch04.xhtml#ch4lis15).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`inj_update`，*/metrics* URL还可以接收至少一个其他命令。在随后的连接中，恶意软件发送了一个名为`get_coms`的命令，其有效载荷如[清单4-15](ch04.xhtml#ch4lis15)所示。
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 4-15: A decrypted JSON payload posted to the* /metrics *URL for a*
    get_coms *command*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-15：解密后的JSON有效载荷，发送到*/metrics* URL，针对*get_coms*命令*'
- en: Besides the `type` field indicating the message type, only the `user_present`
    field seems self-explanatory. It’s not clear what `rm_triggered` refers to, and
    the exact meaning of the `permissions` field also remains mysterious. We do get
    an additional hint, though, that the app cares about app notifications.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指示消息类型的`type`字段外，只有`user_present`字段看起来比较容易理解。`rm_triggered`指的是什么并不清楚，`permissions`字段的确切含义仍然扑朔迷离。不过，我们得到了一些额外的线索，表明该应用程序关注应用通知。
- en: 'In our tests, `get_coms` was by far the most common command sent to the server.
    Unfortunately, the only response we observed was the empty payload `{''type'':
    ''get_coms'', ''coms'': []}`. By the time we attempted an in-depth analysis, the
    command-and-control servers had been shut down, so we had to use the payloads
    previously collected in our malware scanner archives to reason about the malware
    behavior.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的测试中，`get_coms`无疑是发送到服务器的最常见命令。不幸的是，我们观察到的唯一响应是空的有效载荷`{''type'': ''get_coms'',
    ''coms'': []}`。当我们尝试进行深入分析时，命令与控制服务器已经关闭，因此我们不得不使用之前在恶意软件扫描器归档中收集的有效载荷来推测恶意软件的行为。'
- en: '***The Rotating Encryption Keys***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***旋转加密密钥***'
- en: Readers who have meticulously followed along with this app analysis on their
    computers may have noticed that the malware changes encryption keys. You can observe
    this when the Frida script logs different values into the key files, but it becomes
    increasingly obvious when you try to manually decrypt payloads with CyberChef.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 细心跟随本次应用分析的读者可能已经注意到，恶意软件更改了加密密钥。当Frida脚本将不同的值记录到密钥文件时，你可以观察到这一点，但当你尝试使用CyberChef手动解密负载时，这变得更加明显。
- en: The encryption key we discovered earlier, `5f 9e 4a 92 b1 d8 c8 b9 8d b9 b7
    f8 f8 80 0d 2e`, is used for only the initial command-and-control server communications
    during the first connection to the */ping* URL. Recall that the */ping* reply
    payload contains a JSON field called `id`. This field holds the new encryption
    key. The field is itself encrypted, but we can decrypt it using the original key
    and the initialization vector from the reply’s `iv` field.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前发现的加密密钥 `5f 9e 4a 92 b1 d8 c8 b9 8d b9 b7 f8 f8 80 0d 2e` 仅用于首次连接到*/ping*
    URL时的初始命令和控制服务器通信。回想一下，*/ping*的回复负载包含一个名为`id`的JSON字段。该字段保存了新的加密密钥。字段本身是加密的，但我们可以使用原始密钥和回复中的`iv`字段中的初始化向量来解密它。
- en: 'It turns out that the app also logs this new key into the system log. We can
    retrieve it using logcat:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，应用程序还会将这个新密钥记录到系统日志中。我们可以使用logcat来检索它：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The Base64-encrypted value at the end of each log line is the new encryption
    key. The log also shows that the encryption key further rotates, presumably with
    each call to */ping*, as between any two calls to */ping* the key seems to remain
    stable.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日志行末尾的Base64加密值是新的加密密钥。日志还显示加密密钥会进一步旋转，可能是在每次调用*/ping*时，因为在任何两个*/ping*调用之间，密钥似乎保持稳定。
- en: '**Other Malware Functionality**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**其他恶意软件功能**'
- en: Running the app and inspecting its command-and-control messages has given us
    several leads to pursue. We know that the app wants to acquire the permission
    to use the accessibility API, cares about installed apps, and is interested in
    notification listener permissions. Let’s use this information to dig deeper.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并检查其命令和控制消息让我们获得了几个可以深入追踪的线索。我们知道该应用程序希望获得使用无障碍API的权限，关注已安装的应用程序，并对通知监听器权限感兴趣。让我们利用这些信息进行更深入的挖掘。
- en: '***com.sniff with frida-trace***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用frida-trace探索com.sniff***'
- en: On several occasions, our analysis has confirmed the presence of a Java package
    named *com.sniff* . One of the next steps we could take is to explore this package
    with Frida.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在几次分析中，我们确认了名为*com.sniff*的Java包的存在。我们可以采取的下一步是使用Frida来探索这个包。
- en: 'You might naively try to use `frida-trace` to intercept all methods in this
    package and log their usage, arguments, and return values. However, if you simply
    run a command similar to the one we used to intercept the cryptography APIs earlier
    in this chapter, this won’t work well, as you can see here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能天真地尝试使用`frida-trace`拦截该包中的所有方法并记录它们的使用情况、参数和返回值。然而，如果你只是运行类似于我们之前用来拦截加密API的命令，这样做并不会很好地工作，正如你在这里看到的那样：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As shown in the output, Frida can find only four methods in the `MainApplication`
    class. This happens because the Java class loader hasn’t finished loading all
    of the app’s classes by the time `frida-trace` enumerates the loaded classes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，Frida只能在`MainApplication`类中找到四个方法。这是因为在`frida-trace`枚举已加载的类时，Java类加载器还没有完成加载应用程序的所有类。
- en: There are two ways to perform a more complete trace. First, it’s possible to
    change the `frida-trace` command so it attaches to an existing process rather
    than spawning a new process. While easy to do, this would mean missing out on
    all method calls between the start of the app and Frida attaching to the process.
    The alternative option is to write a more complex Frida script that waits for
    the class loader to complete, enumerates all methods, and intercepts them. For
    our purpose, the scrappy option of attaching to a running process should work
    fairly well, due to a quirk in the malware. Because the malware blocks most of
    its functionality from executing until the user grants it permission to use the
    accessibility API, we simply launch the app, let it sit at the accessibility request
    window, and attach Frida to the process.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以执行更完整的跟踪。首先，可以修改`frida-trace`命令，使其附加到现有进程，而不是启动一个新进程。虽然这样做很简单，但这意味着会错过应用程序启动和Frida附加到进程之间的所有方法调用。另一种选择是编写一个更复杂的Frida脚本，等待类加载器完成，列举所有方法，并拦截它们。对于我们的目的，附加到一个正在运行的进程这一简单方法应该能够很好地工作，因为恶意软件有一个特点。由于恶意软件在用户授予它使用无障碍API的权限之前，阻止大多数功能的执行，我们只需要启动应用程序，让它停留在无障碍请求窗口，然后将Frida附加到进程上。
- en: 'To tell `frida-server` to attach to a process rather than spawn its own, we
    can switch the `-f` argument to `-p` and pass it the process ID instead of the
    package name. We could also attach to a process by name, but doing so is awkward
    on Android because Frida expects the app name, not the package name. Usually,
    during malware analysis, you’ll quickly learn an app’s package name but not its
    textual name. Here, we attach to *com.spike.old* through its process ID, 24606:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉`frida-server`附加到一个进程而不是启动它自己的进程，我们可以将`-f`参数换成`-p`，并传入进程ID而不是包名。我们也可以按名称附加到一个进程，但在Android上这样做比较麻烦，因为Frida期望的是应用名，而不是包名。通常，在恶意软件分析过程中，你会很快了解应用的包名，但不会知道它的文本名称。在这里，我们通过进程ID（24606）附加到*com.spike.old*：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We’ve shortened the output significantly for this book. In practice, this script
    generates hundreds of lines per second. Even this partial log, of 700 ms of activity,
    shows a wealth of information. We see more class and package names in *com.sniff*
    , as well as how the malware reads the command-and-control URL from the *ring0.xml*
    configuration file and uses encryption. All of this is tied together by the mysterious
    `KingService` class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的简化，我们大幅减少了输出内容。在实际操作中，这个脚本每秒生成数百行日志。即便是这部分日志，700毫秒的活动也展现了大量信息。我们看到了更多的类和包名在*com.sniff*中，还看到了恶意软件如何从*ring0.xml*配置文件读取命令和控制URL并使用加密。所有这些都通过神秘的`KingService`类联系在一起。
- en: In most cases, malware doesn’t come with an execution block mechanism like this
    sample’s accessibility request window. In these cases, you really may miss out
    on important method calls that happen before `frida-trace` attaches to the target
    process. You can find examples of custom scripts on the internet, including some
    library code to make the whole process very simple.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，恶意软件并没有像这个样本的无障碍请求窗口那样的执行阻塞机制。在这些情况下，你确实可能会错过在`frida-trace`附加到目标进程之前发生的重要方法调用。你可以在网上找到一些自定义脚本的例子，包括一些库代码，可以使整个过程变得非常简单。
- en: '***Accessibility Abuse***'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无障碍滥用***'
- en: 'We mentioned that the very first thing the app asks users to do is to grant
    it permission to use the accessibility API. Why it desires this permission is
    still unclear, so let’s dig deeper to find out. For this task, we can once again
    use `frida-trace` to cast a wide net, logging all uses of the accessibility API
    by the app:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，应用程序要求用户做的第一件事是授予它使用无障碍API的权限。为什么它需要这个权限仍然不清楚，所以我们来深入探讨一下。为了这个任务，我们可以再次使用`frida-trace`来广泛地捕捉，记录应用程序所有对无障碍API的调用：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After manually granting the app access to the accessibility API in the emulator,
    the `frida-trace` command creates several megabytes of output. In the emulator,
    however, you won’t see much apart from the home screen and two permission dialogs,
    for reading SMS messages and making phone calls, which pop up and then disappear.
    Presumably, the app grants itself these permissions by simulating a user clicking
    the dialogs’ buttons.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中手动授予应用访问无障碍API的权限后，`frida-trace`命令会生成几兆字节的输出。然而，在模拟器中，你除了看到主屏幕和两个权限对话框（用于读取短信和拨打电话）弹出并消失之外，不会看到太多其他内容。可以推测，应用通过模拟用户点击对话框按钮来授予自己这些权限。
- en: 'Slogging through megabytes of accessibility API usage logs is a chore. We can
    start by looking for certain patterns, though. When inspecting call traces in
    Frida earlier in this chapter, we identified *com.sniff.sibling* as a potentially
    interesting Java package in the malware. Grepping through the logfile reveals
    two interesting Java classes:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 穿越数兆字节的可访问性 API 使用日志是一项繁琐的工作。不过，我们可以通过寻找特定的模式来开始。当我们在本章前面检查 Frida 的调用跟踪时，识别出了*com.sniff.sibling*作为恶意软件中可能感兴趣的
    Java 包。通过在日志文件中进行 grep 搜索，我们发现了两个有趣的 Java 类：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `PermissionActivity` class could be the activity responsible for clicking
    the buttons in the SMS and call permission dialogs, while `Accessibility EnableHintActivity`
    could be the permission showing the window that asks the user to grant accessibility
    permission.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`PermissionActivity` 类可能是负责点击 SMS 和通话权限对话框中按钮的活动，而 `Accessibility EnableHintActivity`
    可能是显示请求用户授予可访问性权限的窗口的权限。'
- en: 'Another way to look at the logfile is to try to understand which classes in
    the accessibility API the app uses. The answer, it turns out, is a lot. The following
    Linux shell command returns about 50 different classes, creating a much more complicated
    situation than our earlier experiment with intercepting cryptography APIs:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 查看日志文件的另一种方式是尝试了解应用程序使用了哪些可访问性 API 类。事实证明，答案是很多。以下的 Linux shell 命令返回了大约 50 个不同的类，创建了比我们之前拦截加密
    API 时更复杂的情况：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Without an idea of what to look for next, this method of exploration may lead
    to a dead end. We’ve reached a point at which pure dynamic analysis becomes too
    cumbersome, and a mixed-mode exploration of the program, with the help of static
    analysis, may be in order.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确的下一步目标，这种探索方法可能会走到死胡同。我们已经到了纯粹的动态分析变得过于繁琐的地步，可能需要通过静态分析辅助的混合模式探索程序。
- en: '**Adding Static Analysis**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加静态分析**'
- en: Now that we’ve instrumented, observed, and manipulated the sample in so many
    different ways, we have dozens of leads we could pursue to dive deeper into the
    app. Unfortunately, our leads don’t suggest any easy ways to trigger specific
    code and behavior. Instead, we must look at the source code, bolstering our dynamic
    analysis with static techniques.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过多种不同的方式对样本进行了仪器化、观察和操作，我们有数十个线索可以进一步深入探索应用程序。不幸的是，这些线索并没有提供任何容易触发特定代码和行为的方法。相反，我们必须查看源代码，用静态技术来加强我们的动态分析。
- en: '***Other Command-and-Control Servers***'
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他命令与控制服务器***'
- en: The first piece of analysis we can complete involves the command-and-control
    server. With dynamic analysis, we found a domain, *simpleyo5.tk*, with two endpoints,
    */ping* and */metrics*. A search for this domain in jadx reveals a single line.
    The code and its surrounding lines, from *com.sniff.sibling.Constants*, is shown
    in [Listing 4-16](ch04.xhtml#ch4lis16).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以完成的第一部分分析涉及命令与控制服务器。通过动态分析，我们找到了一个域名，*simpleyo5.tk*，并且有两个端点，*/ping* 和 */metrics*。在
    jadx 中搜索这个域名时，揭示了一行代码。来自 *com.sniff.sibling.Constants* 的代码及其周围的行，如[清单 4-16](ch04.xhtml#ch4lis16)所示。
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 4-16: Domain names and encryption key inside* com.spike.old'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-16：*com.spike.old*中的域名和加密密钥'
- en: Apparently, the malware can switch between up to four command-and-control domains
    for its commands. The communications encryption key we previously discovered is
    defined in the line right above the server array initialization.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，恶意软件可以在多达四个命令与控制域之间切换进行指令传输。我们之前发现的通信加密密钥定义在服务器数组初始化的上一行。
- en: Very often in malware analysis, you’ll find interesting pieces of functionality
    located close together in the code. For example, take a look at the strings from
    the *com.sniff.sibling.Constants* file shown in [Listing 4-17](ch04.xhtml#ch4lis17).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在恶意软件分析中，通常会发现有趣的功能片段靠得很近。例如，看看[清单 4-17](ch04.xhtml#ch4lis17)中显示的来自 *com.sniff.sibling.Constants*
    文件的字符串。
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 4-17: Other interesting strings found in* com.sniff.sibling.Constants'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-17：*com.sniff.sibling.Constants* 中发现的其他有趣字符串'
- en: You should recognize these strings from our earlier analysis stages. In particular,
    the strings with the four capital letters were the XML tag names from the mysterious
    *ring0.xml* configuration file. We can see that these tag names aren’t just random
    characters but abbreviations that indicate their function. Dynamic analysis alone
    couldn’t have uncovered that. Likewise, the presence of only two strings starting
    with `api*` provides some evidence that */ping* and */metrics* are the only endpoints
    supported by the malware’s command-and-control servers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从我们早期的分析阶段就能识别出这些字符串。特别是，带有四个大写字母的字符串是来自神秘的 *ring0.xml* 配置文件的 XML 标签名称。我们可以看到，这些标签名称不仅仅是随机字符，而是表示其功能的缩写。仅靠动态分析是无法揭示这一点的。同样，只有两个以
    `api*` 开头的字符串，提供了一些证据，表明 */ping* 和 */metrics* 是恶意软件的命令与控制服务器所支持的唯一端点。
- en: One other piece of code in *com.sniff.sibling.Constants* is particularly interesting.
    In the static initializer, close to the initialization of the command-and-control
    server array, are statements that hint at which permissions the malware uses.
    [Listing 4-18](ch04.xhtml#ch4lis18) shows this.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*com.sniff.sibling.Constants* 中的另一段代码特别有趣。在静态初始化器中，接近命令与控制服务器数组初始化的位置，有一些语句暗示了恶意软件使用的权限。[清单
    4-18](ch04.xhtml#ch4lis18) 显示了这一点。'
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 4-18: Permission strings in* com.sniff.sibling.Constants'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-18：com.sniff.sibling.Constants 中的权限字符串*'
- en: Even with the caveats about permissions described in [Chapter 3](ch03.xhtml),
    this list gives us more information about the malware’s capabilities.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有关于权限的警告，如在 [第 3 章](ch03.xhtml) 中所述，这个列表仍然为我们提供了有关恶意软件功能的更多信息。
- en: '***Other Server Commands***'
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他服务器命令***'
- en: 'Our analysis of *com.sniff.sibling.Constants* revealed all of the malware’s
    command-and-control servers and their URLs, but we still don’t have the full list
    of commands the app is capable of executing. This illustrates yet another problem
    of pure dynamic analysis: if the server doesn’t instruct the malware to execute
    certain commands while under observation, the dynamic analysis environment will
    never learn about them.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 *com.sniff.sibling.Constants* 的分析揭示了所有恶意软件的命令与控制服务器及其 URL，但我们仍然没有得到应用程序能够执行的完整命令列表。这再次说明了纯动态分析的一个问题：如果服务器在观察期间没有指示恶意软件执行某些命令，那么动态分析环境永远无法了解这些命令。
- en: 'We know that the */metrics* URL supports at least two commands: `inj_update`
    and `get_coms`. To find other potential commands, we can search for the ones we
    know about and hope that the others are defined nearby. A search for these two
    command strings shows that they appear at four locations in the code, three of
    which are quite interesting.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，*/metrics* URL 至少支持两个命令：`inj_update` 和 `get_coms`。为了找到其他潜在的命令，我们可以搜索已知的命令，并希望其他命令也会在附近定义。对这两个命令字符串的搜索显示，它们出现在代码中的四个位置，其中三个位置非常有趣。
- en: We first find `inj_update` referenced inside *com.sniff.sibling.Api.Controllers.ApiOperationsController*.
    Shown in [Listing 4-19](ch04.xhtml#ch4lis19), the code using this string is helpfully
    called `parsePayload`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 *com.sniff.sibling.Api.Controllers.ApiOperationsController* 中找到 `inj_update`
    的引用。如 [清单 4-19](ch04.xhtml#ch4lis19) 所示，使用此字符串的代码被称为 `parsePayload`。
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 4-19: Code in* parsePayload *confirms the existence of three commands.*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-19：parsePayload 中的代码确认了三个命令的存在。*'
- en: The code is unnecessarily complex, as all it does is parse the previously decrypted
    response from the server to understand whether the retrieved JSON object has a
    `type` tag with a value of `notif_ic_update`, `get_coms`, or `inj_update`. We
    haven’t yet encountered `notif_ic_update`, but it appears to be unused, as no
    branch in the final `if` statement is associated with this command. Maybe that’s
    why we didn’t observe it being sent from the server.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不必要地复杂，因为它只是解析从服务器解密后的响应，来判断检索到的 JSON 对象是否包含 `type` 标签，且其值为 `notif_ic_update`、`get_coms`
    或 `inj_update`。我们还没有遇到 `notif_ic_update`，但它似乎没有被使用，因为在最终的 `if` 语句中没有任何分支与此命令相关联。也许这就是我们没有看到它从服务器发送的原因。
- en: These strings appear again inside the mysterious `KingService` class we’ve seen
    several times during our analysis. Shown in [Listing 4-20](ch04.xhtml#ch4lis20),
    the function that uses them seems to be the malware’s main execution loop. Every
    step of the malware is outlined there and matches what we observed using logcat
    and Frida.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串再次出现在我们在分析过程中多次看到的神秘 `KingService` 类中。如 [清单 4-20](ch04.xhtml#ch4lis20)
    所示，使用这些字符串的函数似乎是恶意软件的主执行循环。恶意软件的每一步都在其中列出，并与我们使用 logcat 和 Frida 所观察到的内容相符。
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 4-20: The malware’s main execution loop, found in the* KingService
    *class*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-20：恶意软件的主要执行循环，位于* KingService *类中*'
- en: 'The code straightforwardly shows that the malware first tries to connect to
    the internet and bails if no network is available. Then it checks whether the
    network is busy—that is, whether any other server command is in progress. It also
    checks the following: whether the client is verified and, if so, that the verification
    has not yet expired; whether it’s time to send the `inj_update` command to the
    server; whether it’s time to send the `get_coms` command to the server; whether
    necessary permissions have been granted; and whether the malware was granted notification
    access. Finally, it starts *doze mode*, a setting related to battery optimization.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 代码直接显示，恶意软件首先尝试连接到互联网，如果没有网络则放弃。然后它检查网络是否繁忙——即是否有其他服务器命令正在进行。它还检查以下内容：客户端是否已验证，如果已验证，则验证是否尚未过期；是否该发送`inj_update`命令到服务器；是否该发送`get_coms`命令到服务器；是否已授予必要的权限；以及恶意软件是否获得了通知权限。最后，它启动*休眠模式*，这是与电池优化相关的设置。
- en: Based on this main execution loop, we can confirm that our dynamic analysis
    was fairly complete. We uncovered all of these execution options, except for the
    one related to doze mode. Code inspection will show that entering doze mode is
    an attempt by the malware to exclude itself from system-wide optimization features
    that might kill the malware process to preserve battery life.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个主要执行循环，我们可以确认我们的动态分析是相当完整的。我们发现了所有这些执行选项，除了与休眠模式相关的选项。代码检查将显示，进入休眠模式是恶意软件尝试将自己排除在系统范围的优化功能之外，以避免在电池续航模式下杀死恶意软件进程。
- en: The third interesting piece of code that references the string `inj_update`
    is in the *com.sniff.sibling.Api.TDP.ApiGetCommandsResponsePayload* class, which
    contains code to further parse the `get_coms` server response. Shortened for brevity,
    its beginning is shown in [Listing 4-21](ch04.xhtml#ch4lis21).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 引用字符串`inj_update`的第三段有趣代码位于*com.sniff.sibling.Api.TDP.ApiGetCommandsResponsePayload*类中，包含进一步解析`get_coms`服务器响应的代码。为了简洁起见，这段代码的开头如[清单
    4-21](ch04.xhtml#ch4lis21)所示。
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 4-21: Code that reveals additional server commands*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-21：揭示额外服务器命令的代码*'
- en: 'This code goes through all the commands received from the command-and-control
    server and executes the functionality for each (omitted here). We can now see
    that the malware understands the following commands:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历从命令与控制服务器接收到的所有命令，并执行每个命令的功能（此处省略）。我们现在可以看到，恶意软件理解以下命令：
- en: app_list Uploads information about installed apps to the server
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: app_list 将已安装应用的信息上传到服务器
- en: sms_log Uploads all SMS from the device to the server
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: sms_log 将设备上的所有短信上传到服务器
- en: notif_ic_enable Starts intercepting notifications on the device
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: notif_ic_enable 开始拦截设备上的通知
- en: notif_ic_disable Stops intercepting notifications on the device
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: notif_ic_disable 停止拦截设备上的通知
- en: sms_ic_enable Starts intercepting SMS
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: sms_ic_enable 开始拦截短信
- en: sms_ic_disable Stops intercepting SMS
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: sms_ic_disable 停止拦截短信
- en: inj_enable Enables phishing overlay windows
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: inj_enable 启用钓鱼叠加窗口
- en: inj_disable Disables phishing overlay windows
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: inj_disable 禁用钓鱼叠加窗口
- en: inj_update Asks the server for new phishing windows
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: inj_update 向服务器请求新的钓鱼窗口
- en: Besides these commands, the malware also looks for many commands that aren’t
    backed by any code. This indicates that the malware is under heavy development
    and may add more functionality in the future. The unimplemented commands are `self_kill`,
    `fg_disable`, `inj_list`, `self_cleanup`, `notif_ic_update`, `fg_enable`, `app_kill`,
    `sms_ic_update`, `sms_ic_list`, and `notif_ic_list`. We can only guess their purposes
    from their names.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些命令外，恶意软件还在寻找许多没有任何代码支持的命令。这表明恶意软件正在积极开发，未来可能会添加更多功能。这些未实现的命令包括`self_kill`、`fg_disable`、`inj_list`、`self_cleanup`、`notif_ic_update`、`fg_enable`、`app_kill`、`sms_ic_update`、`sms_ic_list`和`notif_ic_list`。我们只能从它们的名称猜测它们的用途。
- en: 'Now we know everything about the command-and-control servers: their domains,
    URLs, and commands. We also know the data that the malware collects and which
    commands are actually implemented. This gives us a very good overview of its capabilities,
    proving once again that understanding the malware’s command handler is key to
    understanding its functionality.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了关于命令与控制服务器的一切：它们的域名、网址和命令。我们还知道了恶意软件收集的数据，以及哪些命令实际上被执行。这为我们提供了一个非常好的概览，证明了理解恶意软件的命令处理程序是理解其功能的关键。
- en: '***More Accessibility Abuse***'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更多的辅助功能滥用***'
- en: One of the remaining mysteries about this malware sample concerns its use of
    the accessibility API. We’ve already discovered that the malware actively pushes
    the user to grant it access to this API, and that once this is done the malware
    makes extensive use of its classes and methods. However, we don’t yet know exactly
    what it uses the API for.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这款恶意软件样本的剩余谜团之一是它如何使用可访问性 API。我们已经发现恶意软件积极推动用户授予它对该 API 的访问权限，并且一旦完成授权，恶意软件就会广泛使用其类和方法。然而，我们仍然不知道它具体用这个
    API 做什么。
- en: Code that uses the accessibility API isn’t easy to understand. The API is complex
    and messy, and achieving anything with it takes a lot of code. Because it comprises
    more than 1,000 lines, showing and explaining all of the malware’s accessibility
    API functionality is out of this book’s scope. Instead, we’ll limit ourselves
    to a few highlights.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可访问性 API 的代码不容易理解。该 API 复杂且凌乱，使用它实现任何功能都需要大量的代码。由于它包含超过 1,000 行代码，因此展示和解释所有恶意软件的可访问性
    API 功能超出了本书的范围。相反，我们将限制在几个亮点上进行讨论。
- en: Most of this code is in *com.sniff.sibling.Accessibility*, a package that contains
    nearly 20 classes, primarily for simulating real user clicks on predefined apps.
    For example, the malware can make itself the default SMS handling app by clicking
    through a series of system settings. Likewise, it has defense mechanisms that
    check whether the user has opened system dialogs for removing or disabling the
    malware and close these dialogs if necessary, before the user can complete the
    removal process.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码位于 *com.sniff.sibling.Accessibility* 包中，该包包含近 20 个类，主要用于模拟用户在预定义应用上的点击操作。例如，恶意软件可以通过一系列系统设置使自己成为默认的短信处理应用。同样，它还具有防御机制，用于检查用户是否打开了用于删除或禁用恶意软件的系统对话框，并在必要时关闭这些对话框，以防用户完成删除过程。
- en: The central part of the accessibility abuse code is the *com.sniff.sibling.Services.FitnessAccessibilityService*
    class, which extends the default Android class *android.accessibilityservice.AccessibilityService*
    and provides callback methods invoked for accessibility events happening on the
    system. The most interesting method in this service, `windowStateChangedEvent`,
    handles apps coming to the foreground or otherwise changing state. When this happens,
    the malware checks which app has come to the foreground and takes the appropriate
    action. If it finds a phishing target, for example, it shows the phishing dialog.
    If it instead finds a permission dialog, it clicks a button to grant the app that
    permission. [Listing 4-22](ch04.xhtml#ch4lis22) shows a slice of the `windowStateChangedEvent`
    method.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性滥用代码的核心部分是 *com.sniff.sibling.Services.FitnessAccessibilityService* 类，该类扩展了默认的
    Android 类 *android.accessibilityservice.AccessibilityService*，并提供了在系统上发生可访问性事件时调用的回调方法。该服务中最有趣的方法是
    `windowStateChangedEvent`，该方法处理应用程序进入前台或以其他方式改变状态。当这种情况发生时，恶意软件会检查哪个应用程序进入了前台，并采取适当的行动。例如，如果它发现一个钓鱼目标，它会显示钓鱼对话框。如果它发现的是权限对话框，它会点击按钮授予该应用权限。[清单
    4-22](ch04.xhtml#ch4lis22)展示了 `windowStateChangedEvent` 方法的一个片段。
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 4-22: The accessibility API is used to handle new apps coming to the
    foreground.*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-22：可访问性 API 用于处理新应用程序进入前台的情况。*'
- en: First, the malware checks whether it should inject phishing dialogs (`injectionsEnabled`)
    and target the active app with such a dialog (`packageHas Injection`). If so,
    the phishing dialog is shown. The next few `if` statements are self-defense mechanisms
    that simulate clicks on the back button when the user opens system dialogs to
    remove the malware. Following that is the code that accepts all permission requests
    for the app and takes some system dialog–specific actions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，恶意软件检查是否应该注入钓鱼对话框（`injectionsEnabled`）并且是否应针对活动应用显示该对话框（`packageHas Injection`）。如果是，它会显示钓鱼对话框。接下来的几个
    `if` 语句是自我防御机制，当用户打开系统对话框以删除恶意软件时，它会模拟点击返回按钮。之后是接受所有应用权限请求并执行某些系统对话框特定操作的代码。
- en: '***Automatically Granting Permissions***'
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自动授予权限***'
- en: The service also handles generic accessibility events and events that invoke
    `windowContentChanged` and `notificationStateChanged`. The code in these sections
    is messy and hard to follow. For example, take a look at the code to perform the
    seemingly simple action of clicking the OK button on a permission dialog to automatically
    grant the malware all permissions it requests. [Listing 4-23](ch04.xhtml#ch4lis23)
    shows the code for `checkPermissionsClick`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务还处理常规的可访问性事件以及触发`windowContentChanged`和`notificationStateChanged`事件的事件。这些部分的代码混乱且难以跟随。例如，看看执行看似简单的操作——点击权限对话框上的“确定”按钮以自动授予恶意软件它请求的所有权限的代码。[列表
    4-23](ch04.xhtml#ch4lis23)展示了`checkPermissionsClick`的代码。
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 4-23: Simulating a click on the permission dialog if necessary*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-23：在必要时模拟点击权限对话框*'
- en: The app first checks whether the accessibility event came from `permission controller`
    or `packageinstaller`, to make sure the app is showing the desired dialog. Then
    it checks whether its app name is part of the hierarchy that led to the accessibility
    event. We’ve omitted the 20 lines of code for doing so here. Finally, the malware
    makes sure that it hasn’t yet been granted the relevant permission. If it already
    has all the permissions it requires, the dialog likely was launched by a different
    app.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 应用首先检查可访问性事件是否来自`permission controller`或`packageinstaller`，以确保应用正在显示期望的对话框。然后，它检查应用名称是否是导致可访问性事件的层级的一部分。我们在这里省略了执行这一操作的
    20 行代码。最后，恶意软件确保它尚未被授予相关权限。如果它已经拥有所有需要的权限，说明对话框可能是由其他应用启动的。
- en: After confirming all of these conditions, the malware clicks the dialog’s OK
    button. [Listing 4-24](ch04.xhtml#ch4lis24) shows the first method for accomplishing
    this click.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认所有这些条件之后，恶意软件点击对话框的“确定”按钮。[列表 4-24](ch04.xhtml#ch4lis24)展示了实现此点击的第一个方法。
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 4-24: The outer method for clicking the permission dialog button*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-24：点击权限对话框按钮的外部方法*'
- en: This method simply invokes `pressAllowButton`, shown in [Listing 4-25](ch04.xhtml#ch4lis25).
    Here, things become more complicated, as the method iterates over lists of button
    IDs and button labels. The button label list contains the strings `Allow` and
    `OK`, meaning this code will actually fail to locate the buttons if the device
    doesn’t use these terms due to its language setting. The button ID list contains
    five strings of the form `com.android.packageinstaller:id/permission_allow_button`,
    which are presumably the IDs for the permission dialog in different Android versions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法简单地调用`pressAllowButton`，如[列表 4-25](ch04.xhtml#ch4lis25)所示。在这里，事情变得更加复杂，因为该方法遍历了按钮
    ID 和按钮标签的列表。按钮标签列表包含`Allow`和`OK`字符串，这意味着如果设备由于语言设置没有使用这些术语，该代码将无法找到按钮。按钮 ID 列表包含五个形式为`com.android.packageinstaller:id/permission_allow_button`的字符串，这些字符串可能是不同
    Android 版本中权限对话框的 ID。
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 4-25: Locating the permission dialog button*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-25：定位权限对话框按钮*'
- en: To press a button based on its text label, the malware must first retrieve the
    text of all buttons in the active dialog. If one of these buttons matches the
    expected text, it can perform a click, as shown in [Listing 4-26](ch04.xhtml#ch4lis26).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据按钮的文本标签按下按钮，恶意软件必须首先获取活动对话框中所有按钮的文本。如果这些按钮中的某一个与预期的文本匹配，它就可以执行点击操作，如[列表 4-26](ch04.xhtml#ch4lis26)所示。
- en: '[PRE49]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 4-26: Clicking the permission dialog button*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-26：点击权限对话框按钮*'
- en: A separate, nearly identical method identifies the button to click based on
    its ID rather than its label text. The only difference is that it uses the `findAccessibilityNodeInfosByViewId`
    method instead of `findAccessibilityNodeInfosByText`. The one remaining method,
    `clickButton`, is shown in [Listing 4-27](ch04.xhtml#ch4lis27); it uses the accessibility
    API `performAction` to execute the click.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的、几乎相同的方法基于按钮的 ID 而非标签文本来识别要点击的按钮。唯一的区别是，它使用`findAccessibilityNodeInfosByViewId`方法而不是`findAccessibilityNodeInfosByText`。剩下的方法`clickButton`显示在[列表
    4-27](ch04.xhtml#ch4lis27)中；它使用可访问性 API `performAction`来执行点击。
- en: '[PRE50]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 4-27: Clicking a button with the accessibility API*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-27：通过可访问性 API 点击按钮*'
- en: As you can see, even a simple workflow like clicking the OK button in a permission
    dialog takes so much code that it’s no wonder more advanced manipulation of the
    system and its dialogs take more than 1,000 lines. Following this code requires
    knowledge of Android internals and modifications made by device manufacturers.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，即使是像点击权限对话框中的“确定”按钮这样简单的工作流，也需要如此多的代码，难怪更复杂的系统操作和对话框处理会超过1000行。理解这些代码需要对Android内部机制和设备制造商所做的修改有所了解。
- en: '***Injecting Phishing Windows***'
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***注入钓鱼窗口***'
- en: 'Let’s discuss how the malware fulfills its ultimate purpose: phishing. Conceptually,
    phishing for credentials involves displaying a phishing window, hoping that the
    victim falls for the ruse, and then sending the stolen credentials to a remote
    server for future use. This app follows this textbook behavior.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下恶意软件是如何实现其最终目的：钓鱼。概念上，钓鱼凭证涉及显示一个钓鱼窗口，希望受害者上当受骗，然后将窃取的凭证发送到远程服务器供将来使用。该应用遵循了这一教科书般的行为。
- en: We’ve already discovered information about the phishing process. From the accessibility
    API code, we learned that the app displays the phishing window when a target app
    becomes active. When analyzing communications with the command-and-control server,
    we learned where the target app configuration comes from and what the phishing
    windows look like. The only thing we don’t yet understand is how the app displays
    the phishing window and steals the credentials.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经发现了关于钓鱼过程的一些信息。从辅助功能API代码中，我们得知应用会在目标应用变为活跃时显示钓鱼窗口。在分析与命令控制服务器的通信时，我们了解到目标应用的配置来源以及钓鱼窗口的样式。我们目前唯一不明白的是应用如何展示钓鱼窗口并窃取凭证。
- en: A class called `OverlayInjectActivity` is responsible for showing the phishing
    dialog, collecting user credentials, and sending them to the command-and-control
    server ([Listing 4-28](ch04.xhtml#ch4lis28)).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`OverlayInjectActivity`的类负责显示钓鱼对话框、收集用户凭证并将其发送到命令与控制服务器（见[清单4-28](ch04.xhtml#ch4lis28)）。
- en: '[PRE51]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 4-28: The phishing window uses a WebView to show the phishing pages.*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-28：钓鱼窗口使用WebView来展示钓鱼页面。*'
- en: When this dialog is shown, it loads the phishing page’s HTML code into a WebView
    and shows it to the user. The `getPageResource` method fetches HTML that has been
    customized for the target.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示此对话框时，它会将钓鱼页面的HTML代码加载到WebView中并显示给用户。`getPageResource`方法会获取针对目标定制的HTML。
- en: '***Stealing Credentials***'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***窃取凭证***'
- en: Lastly, to understand how the app steals credentials, we need to know how the
    credentials entered by the user travel from the HTML page in the WebView to the
    app and how the app sends them to its command-and-control server.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了理解应用如何窃取凭证，我们需要了解用户输入的凭证如何从WebView中的HTML页面传输到应用，并且应用是如何将它们发送到其命令与控制服务器的。
- en: A JavaScript interface serves as a bridge between the website and the app. As
    you saw in [Listing 4-28](ch04.xhtml#ch4lis28), the interface is based on a Java
    class named `WebAppInterface` that is exposed to the website as a JavaScript object
    of name `Android`. [Listing 4-29](ch04.xhtml#ch4lis29) shows the complete `WebAppInterface`
    class.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript接口作为网站与应用之间的桥梁。如[清单4-28](ch04.xhtml#ch4lis28)所示，该接口基于一个名为`WebAppInterface`的Java类，并作为名为`Android`的JavaScript对象暴露给网站。[清单4-29](ch04.xhtml#ch4lis29)展示了完整的`WebAppInterface`类。
- en: '[PRE52]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 4-29: The* WebAppInterface *class bridges the app and the phishing
    page.*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-29：* WebAppInterface *类作为应用与钓鱼页面之间的桥梁。*'
- en: The class defines two methods marked with the annotation `@JavascriptInterface`,
    which makes them available to the HTML page’s JavaScript code. The `send_log_injects`
    method simply calls the more interesting method, `returnResult`. When the app
    receives the stolen credentials, it issues a new command-and-control message of
    type `inj_success` that sends the stolen credentials to the server.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了两个方法，并使用`@JavascriptInterface`注解标记，使它们可以被HTML页面的JavaScript代码调用。`send_log_injects`方法只是简单地调用了更有趣的方法`returnResult`。当应用接收到被窃取的凭证时，它会发出一个新的命令与控制消息，类型为`inj_success`，将窃取的凭证发送到服务器。
- en: Taking a look at an example HTML page, such as the one for phishing Gmail account
    information, makes this interaction easier to understand. [Listing 4-30](ch04.xhtml#ch4lis30)
    shows an excerpt from the phishing page, which takes form input from the user,
    turns it into a JSON string, and sends it to the app.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 看一个例子HTML页面，比如钓鱼Gmail账户信息的页面，可以更容易理解这一互动。[清单4-30](ch04.xhtml#ch4lis30)展示了钓鱼页面的摘录，该页面从用户那里获取表单输入，将其转化为JSON字符串，并发送到应用。
- en: '[PRE53]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Listing 4-30: Excerpt of the HTML code for the Gmail phishing page*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-30：Gmail钓鱼页面的HTML代码摘录*'
- en: The HTML page defines an input form with a password field and a button. When
    the user clicks the button, the JavaScript method `checkPassword` is called to
    perform a quick password plausibility check. Then, `checkPassword` calls the `process`
    method, which serializes the input form into a JSON object and sends that to the
    Java code of the app through the JavaScript interface method `Android.send_log_injects`.
    The Java code of the app then sends the JSON string to the server to complete
    the password theft operation. At this point, the user has fallen for the phishing
    attack and the malware has achieved its goal.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: HTML页面定义了一个包含密码字段和按钮的输入表单。当用户点击按钮时，调用JavaScript方法`checkPassword`进行快速的密码合理性检查。接着，`checkPassword`调用`process`方法，将输入表单序列化为一个JSON对象，并通过JavaScript接口方法`Android.send_log_injects`将其发送到应用的Java代码。应用的Java代码再将JSON字符串发送到服务器，完成密码窃取操作。此时，用户已经落入了钓鱼攻击的陷阱，恶意软件也达到了其目的。
- en: '**Up Next**'
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**接下来**'
- en: After following the analysis steps in this chapter, you should understand the
    malware’s main functionality. It waits until a target application is running and
    then creates an overlay window over the legitimate app, imitating the app’s user
    interface and asking the user to log in. The credentials the user enters into
    the dialog are then stolen. This is facilitated by abuse of the accessibility
    API and orchestrated by a command-and-control server.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章按照分析步骤操作后，你应该能够理解该恶意软件的主要功能。它会等到目标应用程序运行后，创建一个覆盖在合法应用程序上的窗口，模仿应用程序的用户界面，并要求用户登录。用户在对话框中输入的凭证随后会被窃取。这是通过滥用可访问性API并由一个指挥控制服务器协调来实现的。
- en: This chapter should have also demonstrated the value of dynamic analysis. Using
    just a few tools, ranging from simple log analysis to powerful Frida scripts,
    we were able to make rapid progress in our analysis. We successfully discovered
    most of the malware’s functionality and developed a high-level understanding of
    how it works. Then we used static analysis to complement our understanding of
    details that are elusive to pure dynamic analysis.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还应该展示了动态分析的价值。仅使用一些工具，从简单的日志分析到强大的Frida脚本，我们能够快速推进分析工作。我们成功地发现了大部分恶意软件的功能，并对其工作原理有了高层次的理解。随后，我们使用静态分析来补充那些动态分析难以捕捉的细节。
- en: In the remainder of this book, we’ll transition away from the manual analysis
    of individual malware samples to using machine learning as a means of quickly
    identifying and classifying numerous malicious apps. There are millions of malware
    samples floating around the internet today, and human analysts will look at very,
    very few of these. Instead, defenders will identify the vast majority of them
    through automated means. In that sense, the next few chapters of the book more
    accurately describe how professional malware detection and analysis works.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将不再手动分析单个恶意软件样本，而是转向使用机器学习作为快速识别和分类大量恶意应用程序的手段。今天互联网上存在着数百万个恶意软件样本，而人类分析师只会查看其中极少数几个。相反，防御者将通过自动化手段识别大多数恶意软件。从这个角度来看，本书接下来的几章更准确地描述了专业恶意软件检测和分析的工作方式。
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[*OceanofPDF.com*](https://oceanofpdf.com)'
