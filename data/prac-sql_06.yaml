- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Basic Math and Stats with SQL
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQL 进行基本数学和统计
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: If your data includes any of the number data types we explored in Chapter 4—integers,
    decimals, or floating points—sooner or later your analysis will include some calculations.
    You might want to know the average of all the dollar values in a column or add
    values in two columns to produce a total for each row. SQL can handle those calculations
    and more, from basic math through advanced statistics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据包含我们在第四章中探讨的任何数值数据类型——整数、小数或浮点数——迟早你的分析将包括一些计算。你可能想知道某一列中所有美元值的平均值，或者将两列中的值相加，计算每行的总和。SQL
    可以处理这些计算以及更多的内容，从基础数学到高级统计。
- en: In this chapter, I’ll start with the basics and progress to math functions and
    beginning statistics. I’ll also discuss calculations related to percentages and
    percent change. For several of the exercises, we’ll use the 2019 US Census population
    estimates data you imported in Chapter 5.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我将从基础知识开始，逐步介绍数学函数和初步统计。我还会讨论与百分比和百分比变化相关的计算。对于几个练习，我们将使用你在第五章导入的 2019 年美国人口普查估算数据。
- en: Understanding Math Operators and Functions
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解数学运算符和函数
- en: Let’s start with the basic math you learned in grade school (all’s forgiven
    if you’ve forgotten some of it). [Table 6-1](#table6-1) shows nine math operators
    you’ll use most often in your calculations. The first four (addition, subtraction,
    multiplication, and division) are part of the ANSI SQL standard and are implemented
    in all database systems. The others are PostgreSQL-specific operators, although
    most other database managers likely have functions or operators to perform those
    operations too. For example, the modulo operator (`%`) works in Microsoft SQL
    Server and MySQL as well as with PostgreSQL. If you’re using another database
    system, check its documentation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从你在小学学到的基础数学开始（如果你忘记了一些，没关系）。[表 6-1](#table6-1) 显示了你在计算中最常使用的九个数学运算符。前四个（加法、减法、乘法和除法）是
    ANSI SQL 标准的一部分，并且在所有数据库系统中都有实现。其他的则是 PostgreSQL 特有的运算符，尽管大多数其他数据库管理系统也可能有函数或运算符来执行这些操作。例如，模运算符（`%`）不仅在
    PostgreSQL 中有效，在 Microsoft SQL Server 和 MySQL 中也能使用。如果你使用的是其他数据库系统，请查阅其文档。
- en: 'Table 6-1: Basic Math Operators'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1：基本数学运算符
- en: '| **Operator** | **Description** |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `+` | Addition |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法 |'
- en: '| `-` | Subtraction |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减法 |'
- en: '| `*` | Multiplication |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法 |'
- en: '| `/` | Division (returns the quotient only, no remainder) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法（仅返回商，不返回余数） |'
- en: '| `%` | Modulo (returns just the remainder) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 模运算（仅返回余数） |'
- en: '| `^` | Exponentiation |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 幂运算 |'
- en: '| `&#124;/` | Square root |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;/` | 平方根 |'
- en: '| `&#124;&#124;/` | Cube root |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;/` | 立方根 |'
- en: '| `!` | Factorial |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 阶乘 |'
- en: We’ll step through each of these operators by executing simple SQL queries on
    plain numbers rather than operating on a table or another database object. You
    can either enter the statements separately into the pgAdmin query tool and execute
    them one at a time, or if you copied the code for this chapter from the resources
    at [https://www.nostarch.com/practical-sql-2nd-edition/](https://www.nostarch.com/practical-sql-2nd-edition/),
    you can highlight each line and execute it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在简单数字上执行 SQL 查询来逐步了解这些运算符，而不是在表或其他数据库对象上进行操作。你可以将这些语句分别输入到 pgAdmin 查询工具中并逐一执行，或者如果你从[https://www.nostarch.com/practical-sql-2nd-edition/](https://www.nostarch.com/practical-sql-2nd-edition/)复制了本章的代码，可以高亮每一行并执行它。
- en: Understanding Math and Data Types
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解数学和数据类型
- en: 'As you work through the examples, note the data type of each result, which
    is listed beneath each column name in the pgAdmin results grid. The type returned
    for a calculation will vary depending on the operation and the data type of the
    input numbers. When using an operator between two numbers—addition, subtraction,
    multiplication, or division—the data type returned follows this pattern:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行示例时，请注意每个结果的数据类型，这些类型会列在 pgAdmin 结果网格中每个列名下方。计算返回的类型会根据操作和输入数字的数据类型有所不同。当使用运算符对两个数字进行运算（加法、减法、乘法或除法）时，返回的数据类型遵循以下模式：
- en: Two integers return an `integer`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个整数返回一个`integer`（整数）。
- en: A `numeric` on either side or both sides of the operator returns a `numeric`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作符两侧或任一侧为`numeric`类型，则返回`numeric`类型。
- en: Anything with a floating-point number returns a floating-point number of type
    `double precision`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何包含浮点数的操作都将返回一个`double precision`（双精度）浮点数。
- en: However, the exponentiation, root, and factorial functions are different. Each
    takes just one number, either before or after the operator, and returns numeric
    and floating-point types, even when the input is an integer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，指数、平方根和阶乘函数有所不同。每个函数只接受一个数字，可能在运算符的前面或后面，并且即使输入是整数，返回的也是数字和浮动类型。
- en: Sometimes the result’s data type will suit your needs; other times, you may
    need to use `CAST` to change the data type, as mentioned in “Transforming Values
    from One Type to Another with CAST” in Chapter 4, such as if you need to feed
    the result into a function that takes a certain type. I’ll note those times as
    we work through the book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时结果的数据类型会满足你的需求；但在其他情况下，你可能需要使用 `CAST` 来改变数据类型，如第 4 章中“使用 CAST 将值从一种类型转换为另一种类型”一节所提到的，例如如果你需要将结果传递给需要特定类型的函数。我们在书中进行讲解时会指出这些情况。
- en: Adding, Subtracting, and Multiplying
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加法、减法和乘法
- en: 'Let’s start with simple integer addition, subtraction, and multiplication.
    [Listing 6-1](#listing6-1) shows three examples, each with the `SELECT` keyword
    followed by the math formula. Since Chapter 3, we’ve used `SELECT` for its main
    purpose: to retrieve data from a table. But with PostgreSQL, Microsoft’s SQL Server,
    MySQL, and some other database management systems, you can omit the table name
    and perform simple math and string operations, as we do here. For readability’s
    sake, I recommend you use a single space before and after the math operator; although
    using spaces isn’t strictly necessary for your code to work, it is good practice.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从简单的整数加法、减法和乘法开始。[列表 6-1](#listing6-1)展示了三个例子，每个例子都以 `SELECT` 关键字后跟数学公式的形式。自第
    3 章以来，我们已经使用 `SELECT` 执行它的主要功能：从表中检索数据。但是，在 PostgreSQL、微软 SQL Server、MySQL 以及其他一些数据库管理系统中，你可以省略表名，执行简单的数学和字符串操作，就像我们这里做的那样。为了可读性，我建议在数学运算符前后使用一个空格；虽然使用空格并不是让代码正常工作的必需条件，但这是一个良好的习惯。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: Basic addition, subtraction, and multiplication with SQL'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-1：使用 SQL 进行基本的加法、减法和乘法
- en: 'None of these statements is rocket science, so you shouldn’t be surprised that
    running `SELECT 2 + 2;` 1 in the Query Tool shows a result of `4`. Similarly,
    the examples for subtraction 2 and multiplication 3 yield what you’d expect: `8`
    and `12`. The output displays in a column, as with any query result. But because
    we’re not querying a table and specifying a column, the results appear beneath
    a `?column?` name, signifying an unknown column:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句都不是很复杂，所以你不必感到惊讶，当你在查询工具中运行 `SELECT 2 + 2;` 时得到结果 `4`。同样，减法 2 和乘法 3 的例子也会得到你期望的结果：`8`
    和 `12`。输出会像任何查询结果一样显示在一列中。但由于我们没有查询表格并指定列，结果会显示在一个 `?column?` 名称下，表示一个未知的列：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That’s okay. We’re not affecting any data in a table, just displaying a result.
    If you want to display a column name, you can provide an alias, as in `SELECT
    3 * 4 AS result;`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 没关系。我们没有影响任何表中的数据，只是显示一个结果。如果你想显示列名，可以提供一个别名，例如 `SELECT 3 * 4 AS result;`。
- en: Performing Division and Modulo
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行除法和求余
- en: Division with SQL gets a little trickier because of the difference between math
    with integers and math with decimals. Add in *modulo*, an operator that returns
    just the *remainder* in a division operation, and the results can be confusing.
    So, to make it clear, [Listing 6-2](#listing6-2) shows four examples.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQL 进行除法会稍微复杂一些，因为整数运算和小数运算之间的区别。再加上 *取余*，这是一个在除法操作中只返回 *余数* 的运算符，结果可能会让人感到困惑。所以，为了更清楚地展示，[列表
    6-2](#listing6-2)展示了四个例子。
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-2: Integer and decimal division with SQL'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-2：使用 SQL 进行整数和小数除法
- en: The `/` operator 1 divides the integer `11` by another integer, `6`. If you
    do that math in your head, you know the answer is `1` with a remainder of `5`.
    However, running this query yields `1`, which is how SQL handles division of one
    integer by another—by reporting only the integer *quotient* without any remainder.
    If you want to retrieve the *remainder* as an integer, you must perform the same
    calculation using the modulo operator `%`, as in 2. That statement returns just
    the remainder, in this case `5`. No single operation today will provide you with
    both the quotient and the remainder as integers, though an enterprising developer
    could add that functionality in the future.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` 运算符 1 将整数 `11` 除以另一个整数 `6`。如果你在脑海中做这个计算，你知道答案是 `1`，余数为 `5`。然而，运行这个查询的结果是
    `1`，这是 SQL 处理一个整数除以另一个整数的方式——只报告整数*商*，不显示余数。如果你想获取*余数*作为整数，你必须使用模运算符 `%` 执行相同的计算，如
    2 所示。该语句仅返回余数，在此案例中为 `5`。今天没有单一操作可以同时提供商和余数作为整数，尽管有心的开发者将来可能会添加此功能。'
- en: 'Modulo is useful for more than just fetching a remainder: you can also use
    it as a test condition. For example, to check whether a number is even, you can
    test it using the `% 2` operation. If the result is `0` with no remainder, the
    number is even.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算不仅仅用于获取余数：你还可以将它作为测试条件。例如，要检查一个数是否为偶数，你可以使用 `% 2` 运算进行测试。如果结果为 `0` 且没有余数，则该数为偶数。
- en: There are two ways to divide two numbers and have the result return as a `numeric`
    type. First, if one or both of the numbers is a `numeric`, the result will by
    default be expressed as a `numeric`. That’s what happens when I divide `11.0`
    by `6` 3. Execute that query, and the result is `1.83333`. The number of decimal
    digits displayed may vary according to your PostgreSQL and system settings.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以将两个数字相除并返回 `numeric` 类型的结果。首先，如果其中一个或两个数字是 `numeric`，结果默认会以 `numeric`
    表示。这就是当我将 `11.0` 除以 `6` 3 时的情况。执行该查询，结果是 `1.83333`。显示的小数位数可能会根据你的 PostgreSQL 和系统设置有所不同。
- en: Second, if you’re working with data stored only as integers and need to force
    decimal division, you can use `CAST` to convert one of the integers to a `numeric`
    type 4. Executing this also returns `1.83333`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果你正在处理仅以整数形式存储的数据，并且需要强制进行小数除法，你可以使用 `CAST` 将其中一个整数转换为 `numeric` 类型 4。执行该操作后，同样会返回
    `1.83333`。
- en: Using Exponents, Roots, and Factorials
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用指数、根和阶乘
- en: Beyond the basics, PostgreSQL-flavored SQL also provides operators and functions
    to square, cube, or otherwise raise a base number to an exponent, as well as find
    roots or the factorial of a number. [Listing 6-3](#listing6-3) shows these operations
    in action.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基础操作外，PostgreSQL 风格的 SQL 还提供了运算符和函数来计算平方、立方，或将基数提升为指数，还可以计算根和阶乘。[清单 6-3](#listing6-3)
    展示了这些操作的实际应用。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-3: Exponents, roots, and factorials with SQL'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-3：使用 SQL 进行指数、根和阶乘运算
- en: The exponentiation operator (`^`) allows you to raise a given base number to
    an exponent, as in 1, where `3 ^ 4` (colloquially, we’d call that three to the
    fourth power) returns `81`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 指数运算符 (`^`) 允许你将给定的基数提升到一个指数，如 1 中所示，其中 `3 ^ 4`（口语中我们会称其为三的四次方）返回 `81`。
- en: 'You can find the square root of a number in two ways: using the `|/` operator
    2 or the `sqrt(``n``)` function. For a cube root, use the `||/` operator 3. Both
    are *prefix operators*, named because they come before a single value.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式求一个数的平方根：使用 `|/` 运算符 2 或 `sqrt(``n``)` 函数。对于立方根，使用 `||/` 运算符 3。这两者都是*前缀运算符*，因为它们出现在单一值之前。
- en: To find the *factorial* of a number, you can use the `factorial(``n``)` function
    or the `!` operator. The `!`, available only in PostgreSQL versions 13 and earlier,
    is a *suffix operator*, coming after a single value. You’ll use factorials in
    many places in math, but perhaps the most common is to determine how many ways
    a number of items can be ordered. Say you have four photographs. How many ways
    could you order them on a wall? To find the answer, you’d calculate the factorial
    by starting with the number of items and multiplying it by all the smaller positive
    integers. So, at 4, the function `factorial(4)` is equivalent to 4 × 3 × 2 × 1\.
    That’s 24 ways to order four photos. No wonder decorating takes so long sometimes!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一个数字的*阶乘*，你可以使用`factorial(``n``)`函数或`!`运算符。`!`运算符仅在PostgreSQL 13及以前的版本中可用，是一个*后缀运算符*，它位于单个值后面。在数学中，你将在许多地方使用阶乘，最常见的应用是确定一组物品有多少种排列方式。比如你有四张照片。你可以将它们在墙上排列成多少种方式呢？为了找到答案，你需要计算阶乘，从物品数量开始，并将其与所有较小的正整数相乘。因此，`factorial(4)`等价于4
    × 3 × 2 × 1\。这就是四张照片的24种排列方式。难怪有时候装饰需要这么长时间！
- en: Again, these operators are specific to PostgreSQL; they’re not part of the SQL
    standard. If you’re using another database application, check its documentation
    for how it implements these operations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，这些运算符是PostgreSQL特有的；它们不是SQL标准的一部分。如果你使用的是其他数据库应用程序，请查阅其文档，了解如何实现这些运算。
- en: Minding the Order of Operations
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意运算顺序
- en: 'You may recall from early math lessons what the order of operations, or *operator
    precedence*, is on a mathematical expression. Which calculations does SQL execute
    first? Not surprisingly, SQL follows the established math standard. For the PostgreSQL
    operators discussed so far, the order is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得早期的数学课程中关于数学表达式的运算顺序，或*运算符优先级*。SQL首先执行哪些计算呢？毫不奇怪，SQL遵循已建立的数学标准。到目前为止讨论的PostgreSQL运算符的优先顺序如下：
- en: Exponents and roots
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指数与根号
- en: Multiplication, division, modulo
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘法、除法、模运算
- en: Addition and subtraction
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加法与减法
- en: 'Given these rules, you’ll need to encase an operation in parentheses if you
    want to calculate it in a different order. For example, the following two expressions
    yield different results:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些规则，如果你想按照不同的顺序计算操作，你需要将操作括在圆括号内。例如，以下两个表达式会产生不同的结果：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first expression returns `79` because the multiplication operation receives
    precedence and is processed before the addition. The second returns `135` because
    the parentheses force the addition operation to occur first.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式返回`79`，因为乘法运算优先执行，先于加法。第二个返回`135`，因为圆括号强制加法先执行。
- en: 'Here’s a second example using exponents:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用指数的第二个例子：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exponent operations take precedence over subtraction, so without parentheses
    the entire expression is evaluated left to right and the operation to find 3 to
    the power of 3 happens first. Then 1 is subtracted, returning `26`. In the second
    example, the parentheses force the subtraction to happen first, so the operation
    results in `9`, which is 3 to the power of 2.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 指数运算优先于减法运算，因此在没有圆括号的情况下，整个表达式会从左到右进行求值，找到3的3次方的运算会最先发生。然后减去1，得到`26`。在第二个例子中，圆括号强制减法先进行，因此运算结果为`9`，即3的2次方。
- en: Keep operator precedence in mind to avoid having to correct your analysis later!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 记住运算符优先级，避免稍后需要纠正分析结果！
- en: Doing Math Across Census Table Columns
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨人口普查表列进行数学运算
- en: Let’s try to use the most frequently used SQL math operators on real data by
    digging into the 2019 US Census population estimates table, `us_counties_pop_est_2019`,
    that you imported in Chapter 5. Instead of using numbers in queries, we’ll use
    the names of the columns that contain the numbers. When we execute the query,
    the calculation will occur on each row of the table.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在真实数据上使用最常用的SQL数学运算符，通过挖掘你在第5章导入的2019年美国人口普查估算表`us_counties_pop_est_2019`。我们不会在查询中使用数字，而是使用包含数字的列名。当我们执行查询时，计算将发生在表中的每一行。
- en: 'To refresh your memory about the data, run the script in [Listing 6-4](#listing6-4).
    It should return 3,142 rows showing the name and state of each county in the United
    States plus the 2019 components of population change: births, deaths, and international
    and domestic migration.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新你的记忆，运行[列表6-4](#listing6-4)中的脚本。它应该返回3142行，显示每个美国县的名称和所在州，以及2019年人口变化的组成部分：出生、死亡以及国际和国内迁移。
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-4: Selecting census population estimate columns with aliases'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-4：选择带别名的人口普查估计列
- en: This query doesn’t return all columns in the table, just the ones with data
    related to the population estimates. In addition, I employ the `AS` keyword 1
    to give each column a shorter *alias* in the result set. Because all the data
    in this query is from 2019, I’m eliminating the year from the names of the results
    columns to reduce scrolling in the pgAdmin output. It’s an arbitrary decision
    that you can adjust.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询不会返回表中的所有列，而只是与人口估计相关的数据列。此外，我使用`AS`关键字1为每个列在结果集中提供了一个较短的*别名*。因为所有数据都来自2019年，我去掉了结果列名称中的年份，以减少pgAdmin输出中的滚动。这是一个任意的决定，你可以根据需要进行调整。
- en: Adding and Subtracting Columns
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列的加法和减法
- en: Now, let’s try a simple calculation using two of the columns. [Listing 6-5](#listing6-5)
    subtracts the number of deaths from the number of births in each county, a measure
    the census refers to as natural increase. Let’s see what this shows.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用两列进行简单计算。[清单 6-5](#listing6-5)将每个县的死亡人数减去出生人数，这是普查中称为自然增加的指标。让我们看看这能展示什么。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-5: Subtracting two columns in *us_counties_pop_est_2019*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-5：在*us_counties_pop_est_2019*中减去两列
- en: Providing `births_2019 - deaths_2019` 1 as one of the columns in the `SELECT`
    statement handles the calculation. Again, I use the `AS` keyword to provide a
    readable alias for the column. If you don’t provide an alias, PostgreSQL uses
    the label `?column?`, which is far less than helpful.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SELECT`语句中提供`births_2019 - deaths_2019` 1 作为其中一列来完成计算。同样，我使用`AS`关键字为该列提供一个可读的别名。如果不提供别名，PostgreSQL将使用`?column?`标签，这显然不太有用。
- en: 'Run the query to see the results. The first few rows should resemble this output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行查询以查看结果。前几行应该类似于以下输出：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A quick check with a calculator or pencil and paper confirms that the `natural_increase`
    column equals the difference between the two columns you subtracted. Excellent!
    Notice as you scroll through the output that some counties have more births than
    deaths, while others have the opposite. Typically, counties with a younger mix
    of residents see births outpace deaths; those with an older set of people—think
    rural areas and retirement hotspots—tend to see a greater number of deaths than
    births.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算器或纸笔快速检查，确认`natural_increase`列等于你减去的两列之间的差值。太棒了！当你浏览输出结果时，请注意一些县的出生人数超过死亡人数，而其他一些县则相反。通常，居民年龄较轻的县出生人数会超过死亡人数；而那些居民年龄较大的地方——比如农村地区和退休热门地区——往往死亡人数会超过出生人数。
- en: Now, let’s build on this to test our data and validate that we imported columns
    correctly. The population estimate for 2019 should equal the sum of the 2018 estimate
    and the columns about births, deaths, migration, and residual factor. The code
    in [Listing 6-6](#listing6-6) should show that it does.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在此基础上进行测试，验证我们是否正确导入了列。2019年的人口估计应等于2018年估计加上出生、死亡、迁移和剩余因子相关的列。[清单 6-6](#listing6-6)中的代码应该显示这一点。
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-6: Checking census data totals'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-6：检查人口普查数据总数
- en: This query includes the 2019 population estimate 1, followed by a calculation
    adding the components to the 2018 population estimate as `component_total` 2.
    The 2018 estimate plus the components should equal the 2019 estimate. Rather than
    manually check, we also add a column that subtracts the components total from
    the 2019 estimate 3. That column, named `difference`, should contain a zero in
    each row if all the data is in the right place. To avoid having to scan all 3,142
    rows, we add an `ORDER BY` clause 4 on the named column. Any rows showing a difference
    should appear at the top or bottom of the query result.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询包括2019年的人口估计1，后面是一个计算，将组成部分加到2018年的人口估计中作为`component_total` 2。2018年的估计加上组成部分应该等于2019年的估计。为了避免手动检查，我们还添加了一列，将组成部分总和从2019年的估计中减去3。该列名为`difference`，如果所有数据都在正确位置，则每一行应包含零。为了避免查看所有3,142行，我们在命名列上添加了`ORDER
    BY`子句4。显示差异的任何行应该出现在查询结果的顶部或底部。
- en: 'Run the query; the first few rows should provide this result:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询；前几行应该显示以下结果：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the `difference` column showing zeros, we can be confident that our import
    was clean. Whenever I encounter or import a new dataset, I like to perform little
    tests like this. They help me better understand the data and head off any potential
    issues before I dig into analysis.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`difference`列显示零，我们可以确信我们的导入数据是干净的。每当我遇到或导入新的数据集时，我喜欢进行像这样的简单测试。它们帮助我更好地理解数据，并在深入分析之前解决潜在的问题。
- en: Finding Percentages of the Whole
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找整体百分比
- en: One way to spot differences in the items in a dataset is to calculate the percentage
    of the whole that a particular data point represents. Then, you can glean meaningful
    insights—and sometimes surprises—by comparing that percentage across all the items
    in your dataset.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 发现数据集中各个项目之间差异的一种方法是计算某个数据点所代表的整个数据集的百分比。然后，你可以通过对比数据集中的所有项目的百分比，获取有意义的洞察——有时甚至是惊喜。
- en: To figure out the percentage of the whole, divide the number in question by
    the total. For example, if you had a basket of 12 apples and used 9 in a pie,
    that would be 9 / 12 or 0.75—commonly expressed as 75 percent.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算整体的百分比，需将相关数字除以总数。例如，如果你有一个12个苹果的篮子，且用了其中9个做了一个派，那么就是9 / 12或0.75——通常表示为75%。
- en: We’ll try this on the census population estimates using the two columns that
    represent the size of each county’s geographical features. The columns `area_land`
    and `area_water` show a county’s land and water measurement in square meters.
    Using the code in [Listing 6-7](#listing6-7), we can calculate for each county
    the percentage of its area that is made up of water.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用[示例 6-7](#listing6-7)中的代码，对普查人口估计数据进行操作，使用表示每个县地理特征大小的两列数据。`area_land`和`area_water`列显示了一个县的陆地和水域面积（单位为平方米）。使用该代码，我们可以计算出每个县中由水域组成的面积百分比。
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-7: Calculating the percent of a county’s area that is water'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-7：计算一个县的面积中水域的百分比
- en: The key piece of this query divides `area_water` by the sum of `area_land` and
    `area_water`, which together represent the total area of the county 1.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询的关键部分是将`area_water`除以`area_land`和`area_water`的总和，这两者代表了该县的总面积 1。
- en: 'If we use the data as their original integer types, we won’t get the fractional
    result we need: every row will display a result of 0, the quotient. Instead, we
    force decimal division by casting one of the integers to the numeric type. Here,
    for brevity, we use the PostgreSQL-specific double-colon notation after the first
    reference to `area_water`, but you can also use the ANSI SQL standard `CAST` function
    covered in Chapter 4. Finally, we multiply the result by 100 to present the result
    as a fraction of 100—the way most people understand percentages.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用原始整数类型的数据，我们将无法得到所需的分数结果：每一行将显示0的结果，即商。相反，我们通过将其中一个整数强制转换为数字类型来进行十进制除法。这里，为了简洁起见，我们在第一次引用`area_water`时使用了PostgreSQL特有的双冒号符号，但你也可以使用ANSI
    SQL标准中的`CAST`函数，具体内容见第4章。最后，我们将结果乘以100，以将其呈现为百分数——这种方式是大多数人理解百分比的方式。
- en: 'By sorting from highest to lowest percentage, the top of the output is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按照从高到低的百分比排序，输出的结果如下：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you check the Wikipedia entry for Keweenaw County, you’ll discover the reason
    why its total area is more than 90 percent water: its land area includes an island
    in Lake Superior, and the lake’s waters are included in the total reported by
    the census. Add that to your trivia collection!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看维基百科上关于基维诺县（Keweenaw County）的条目，你会发现为什么该县的总面积中超过90%是水域：其陆地面积包括了苏必利尔湖中的一个岛屿，而湖水也被包括在普查中报告的总面积内。将这一点加入你的趣闻收藏吧！
- en: Tracking Percent Change
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪百分比变化
- en: 'Another key indicator in data analysis is percent change: how much bigger,
    or smaller, is one number than another? Percent change calculations are often
    employed when analyzing change over time, and they’re particularly useful for
    comparing change among similar items.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析中的另一个关键指标是百分比变化：一个数字比另一个数字大或小多少？百分比变化计算通常用于分析随时间变化的数据，特别适用于比较相似项目之间的变化。
- en: 'Some examples include the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例包括以下内容：
- en: The year-over-year change in the number of vehicles sold by each automobile
    maker
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个汽车制造商的年度汽车销售变化
- en: The monthly change in subscriptions to each email list owned by a marketing
    firm
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个营销公司所拥有的每个邮件列表的月度订阅变化
- en: The annual increase or decrease in enrollment at schools across a nation
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全国各学校的年注册人数增减
- en: 'The formula to calculate percent change can be expressed like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 计算百分比变化的公式可以这样表达：
- en: (*new number* – *old number*) / *old number*
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (*新数值* – *旧数值*) / *旧数值*
- en: 'So, if you own a lemonade stand and sold 73 glasses of lemonade today and 59
    glasses yesterday, you’d figure the day-to-day percent change like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你经营一个柠檬水摊位，今天卖出了73杯柠檬水，昨天卖出了59杯，你可以这样计算日常百分比变化：
- en: (73 – 59) / 59 = .237 = 23.7%
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: (73 – 59) / 59 = .237 = 23.7%
- en: Let’s try this with a small collection of test data related to spending in departments
    of a hypothetical local government. [Listing 6-8](#listing6-8) calculates which
    departments had the greatest percentage increase and decrease.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一小组与假设的地方政府部门开支相关的测试数据。[清单 6-8](#listing6-8)计算了哪些部门的百分比增减最大。
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-8: Calculating percent change'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-8：计算百分比变化
- en: We create a small table called `percent_change` 1 and insert six rows 2 with
    data on department spending for the years 2019 and 2022\. The percent change formula
    3 subtracts `spend_2019` from `spend_2022` and then divides by `spend_2019`. We
    multiply by 100 to express the result as a portion of 100.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`percent_change`的小表，并插入了六行关于2019年和2022年部门开支的数据。百分比变化公式是：`spend_2022`减去`spend_2019`，然后除以`spend_2019`。我们乘以100以将结果表示为百分之一。
- en: 'To simplify the output, this time I’ve added the `round()` function to remove
    all but one decimal place. The function takes two arguments: the column or expression
    to be rounded and the number of decimal places to display. Because both numbers
    are type `numeric`, the result will also be a `numeric`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化输出，这次我添加了`round()`函数来去掉除一位小数外的所有小数位。该函数需要两个参数：要四舍五入的列或表达式，以及显示的小数位数。由于这两个数字都是`numeric`类型，因此结果也将是`numeric`类型。
- en: 'The script creates this result:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本产生了以下结果：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, it’s just a matter of finding out why the Clerk department’s spending has
    outpaced others in the town.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需找出为什么市政府的书记部门开支超过了其他部门。
- en: Using Aggregate Functions for Averages and Sums
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用聚合函数计算平均值和总和
- en: So far, we’ve performed math operations across columns in each row of a table.
    SQL also lets you calculate a result from values within the same column using
    *aggregate functions*. You can see a full list of PostgreSQL aggregates, which
    calculate a single result from multiple inputs, at [https://www.postgresql.org/docs/current/functions-aggregate.html](https://www.postgresql.org/docs/current/functions-aggregate.html).
    Two of the most-used aggregate functions in data analysis are `avg()` and `sum()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对表格中每行的列进行了数学运算。SQL还允许你使用*聚合函数*计算同一列中值的结果。你可以在[https://www.postgresql.org/docs/current/functions-aggregate.html](https://www.postgresql.org/docs/current/functions-aggregate.html)查看PostgreSQL聚合函数的完整列表，这些函数从多个输入中计算出单一结果。在数据分析中，最常用的两个聚合函数是`avg()`和`sum()`。
- en: Returning to the `us_counties_pop_est_2019` census table, it’s reasonable to
    want to calculate the total population of all counties plus the average population
    of all counties. Using `avg()` and `sum()` on column `pop_est_2019` (the population
    estimate for 2019) makes it easy, as shown in [Listing 6-9](#listing6-9). Again,
    we use the `round()` function to remove numbers after the decimal point in the
    average calculation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`us_counties_pop_est_2019`人口普查表，计算所有县的总人口以及所有县的平均人口是合理的。使用`avg()`和`sum()`函数对`pop_est_2019`列（2019年人口估算）进行操作，可以轻松完成，如[清单
    6-9](#listing6-9)所示。我们再次使用`round()`函数去掉平均计算中的小数点后的数字。
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 6-9: Using the `sum()` and `avg()` aggregate functions'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-9：使用`sum()`和`avg()`聚合函数
- en: 'This calculation produces the following result:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算产生了以下结果：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The estimated population for all counties in the United States in 2019 added
    up to approximately 328.2 million, and the average of the county population estimates
    was 104,468.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 美国所有县的2019年估计人口总和大约为3.282亿，县人口估算的平均值为104,468。
- en: Finding the Median
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找中位数
- en: 'The *median* value in a set of numbers is as important an indicator, if not
    more so, than the average. Here’s the difference between median and average:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一组数字中的*中位数*值是与平均数一样重要的指标，甚至可能更重要。以下是中位数与平均数的区别：
- en: Average The sum of all the values divided by the number of values
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平均值 所有值的总和除以值的个数
- en: Median The “middle” value in an ordered set of values
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中位数 排序后的数值中的“中间”值
- en: 'Median is important in data analysis because it reduces the effect of outliers.
    Consider this example: let’s say six kids, ages 10, 11, 10, 9, 13, and 12, go
    on a field trip. It’s easy to add the ages and divide by six to get the group’s
    average age:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数在数据分析中很重要，因为它减少了异常值的影响。考虑这个例子：假设六个孩子，年龄分别为10、11、10、9、13和12，去进行一次实地考察。将年龄相加后除以六得到平均年龄很容易：
- en: (10 + 11 + 10 + 9 + 13 + 12) / 6 = 10.8
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: (10 + 11 + 10 + 9 + 13 + 12) / 6 = 10.8
- en: Because the ages fall within a narrow range, the 10.8 average is a good representation
    of the group. But averages are less helpful when the values are bunched, or skewed,
    toward one end of the distribution, or if the group includes outliers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些年龄值分布在一个较小的范围内，所以10.8的平均数很好地代表了这个组。但是当数据值集中在分布的一端，或者组中有异常值时，平均数的帮助就会减少。
- en: 'For example, say an older chaperone joins the field trip. With ages of 10,
    11, 10, 9, 13, 12, and 46, the average age increases considerably:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一位年长的陪同人员加入了实地考察。年龄为10、11、10、9、13、12和46，平均年龄大幅增加：
- en: (10 + 11 + 10 + 9 + 13 + 12 + 46) / 7 = 15.9
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: (10 + 11 + 10 + 9 + 13 + 12 + 46) / 7 = 15.9
- en: Now the average doesn’t represent the group well because the outlier skews it,
    making it an unreliable indicator.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，平均数并不能很好地代表这个组，因为异常值会让它产生偏差，使得它成为一个不可靠的指标。
- en: 'It’s better in this case to find the median, the midpoint in an ordered list
    of values—the point at which half the values are more and half are less. Using
    the field trip, we order the attendees’ ages from lowest to highest:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最好找出中位数，它是一个有序数值列表中的中间点——也就是数据中一半的值大于它，另一半的值小于它。以这次实地考察为例，我们将参加者的年龄按从低到高的顺序排列：
- en: 9, 10, 10, 11, 12, 13, 46
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 9, 10, 10, 11, 12, 13, 46
- en: The middle (median) value is 11\. Given this group, the median of 11 is a better
    picture of the typical age than the average of 15.9.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数（median）是11。对于这个组来说，11的中位数比15.9的平均数更能代表典型年龄。
- en: 'If the set of values is an even number, you take the average of the two middle
    numbers to find the median. Let’s add another student (age 12) to the field trip:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据集的数值为偶数，则需要取中间两个数值的平均数来找出中位数。我们再加入一位学生（年龄12）到实地考察中：
- en: 9, 10, 10, 11, 12, 12, 13, 46
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 9, 10, 10, 11, 12, 12, 13, 46
- en: 'Now, the two middle values are 11 and 12\. To find the median, we average them:
    11.5.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个中间值是11和12。为了找出中位数，我们取它们的平均值：11.5。
- en: 'Medians are reported frequently in financial news. Reports on housing prices
    often use medians because a few sales of McMansions in a ZIP code that is otherwise
    modest can make averages useless. The same goes for sports player salaries: one
    or two superstars can skew a team’s average.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数在财经新闻中经常被报道。关于房价的报告经常使用中位数，因为一个区域中少数几栋奢华别墅的销售可能会使得平均数变得无用。体育运动员的薪水也是一样：一两个超级明星可能会扭曲一个队伍的平均薪资。
- en: A good test is to calculate the average and the median for a group of values.
    If they’re close, the group is probably normally distributed (the familiar bell
    curve), and the average is useful. If they’re far apart, the values are not normally
    distributed, and the median is the better representation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的测试是计算一组数值的平均数和中位数。如果它们接近，那么这组数据可能呈正态分布（即熟悉的钟形曲线），此时平均数是有用的。如果它们相差较远，那么这些数值不是正态分布的，中位数则是更好的代表。
- en: Finding the Median with Percentile Functions
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用百分位数函数查找中位数
- en: PostgreSQL (as with most relational databases) does not have a built-in `median()`
    function like you’d find in Excel or other spreadsheet programs. It’s also not
    included in the ANSI SQL standard. Instead we can use a SQL *percentile* function
    to find the median and use *quantiles* or *cut points* to divide a group of numbers
    into equal sizes. Percentile functions are part of standard ANSI SQL.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL（与大多数关系型数据库一样）没有内建的`median()`函数，如同你在Excel或其他电子表格程序中会找到的那样。它也不包含在ANSI
    SQL标准中。我们可以使用SQL中的*百分位数*函数来找出中位数，并使用*分位数*或*切分点*将一组数字划分为相等的大小。百分位数函数是ANSI SQL标准的一部分。
- en: In statistics, percentiles indicate the point in an ordered set of data below
    which a certain percentage of the data is found. For example, a doctor might tell
    you that your height places you in the 60th percentile for an adult in your age
    group. That means 60 percent of people are shorter than you.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，百分位数表示在有序数据集中，某个百分比的数据位于该值以下。例如，医生可能会告诉你，你的身高位于你所在年龄组的第60百分位。这意味着60%的人比你矮。
- en: The median is equivalent to the 50th percentile—again, half the values are below
    and half above. There are two versions of the percentile function—`percentile_cont(``n``)`
    and `percentile_disc(``n``)`. Both functions are part of the ANSI SQL standard
    and are present in PostgreSQL, Microsoft SQL Server, and other databases.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数相当于第50百分位——同样，一半的数值低于它，另一半高于它。百分位数函数有两个版本——`percentile_cont(``n``)`和`percentile_disc(``n``)`。这两个函数都是ANSI
    SQL标准的一部分，并且在PostgreSQL、Microsoft SQL Server和其他数据库中都有实现。
- en: The `percentile_cont(``n``)` function calculates percentiles as *continuous*
    values. That is, the result does not have to be one of the numbers in the dataset
    but can be a decimal value in between two of the numbers. This follows the methodology
    for calculating medians on an even number of values, where the median is the average
    of the two middle numbers. The `percentile_disc(``n``)` function returns only
    *discrete* values, meaning the result will be rounded to one of the numbers in
    the set.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`percentile_cont(``n``)`函数计算百分位数作为*连续*值。也就是说，结果不必是数据集中的一个数字，而可以是介于两个数字之间的一个小数值。这遵循了在偶数个值中计算中位数的方法，即中位数是两个中间值的平均值。`percentile_disc(``n``)`函数则只返回*离散*值，这意味着结果将四舍五入为数据集中的一个数字。'
- en: In [Listing 6-10](#listing6-10) we make a test table with six numbers and find
    the percentiles.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 6-10](#listing6-10)中，我们制作了一个包含六个数字的测试表，并计算了百分位数。
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 6-10: Testing SQL percentile functions'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-10: 测试SQL百分位数函数'
- en: 'In both the continuous 1 and discrete 2 percentile functions, we enter `.5`
    to represent the 50th percentile, equivalent to the median. Running the code returns
    the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在连续型1和离散型2百分位数函数中，我们输入`.5`表示第50个百分位数，相当于中位数。运行代码后返回如下结果：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `percentile_cont()` function returned what we’d expect the median to be:
    `3.5`. But because `percentile_disc()` calculates discrete values, it reports
    `3`, the last value in the first 50 percent of the numbers. Because the accepted
    method of calculating medians is to average the two middle values in an even-numbered
    set, use `percentile_cont(.5)` to find a median.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`percentile_cont()`函数返回了我们预期的中位数：`3.5`。但由于`percentile_disc()`计算的是离散值，它报告了`3`，即前50%数据中的最后一个值。因为计算中位数的常用方法是在偶数个数据集中取两个中间值的平均值，因此使用`percentile_cont(.5)`来找到中位数。'
- en: Finding Median and Percentiles with Census Data
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用人口普查数据查找中位数和百分位数
- en: Our census data can show how a median tells a different story than an average.
    [Listing 6-11](#listing6-11) adds `percentile_cont()` alongside the `sum()` and
    `avg()` aggregates we’ve used so far to find the sum, average, and median population
    of all counties.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的人口普查数据可以展示中位数如何与平均数讲述不同的故事。[列表 6-11](#listing6-11)在`sum()`和`avg()`聚合函数旁边，增加了`percentile_cont()`，用以找出所有县区的总和、平均值和中位数人口。
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 6-11: Using `sum()`, `avg()`, and `percentile_cont()` aggregate functions'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-11: 使用`sum()`、`avg()`和`percentile_cont()`聚合函数'
- en: 'Your result should equal the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果应该等于以下内容：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The median and average are far apart, which shows that averages can mislead.
    As of 2019 estimates, half the counties in America had fewer than 25,726 people,
    whereas half had more. If you gave a presentation on US demographics and told
    the audience that the “average county in America has 104,468 people,” they’d walk
    away with a skewed picture of reality. More than 40 counties were estimated to
    have a million or more people in 2019, and Los Angeles County had more than 10
    million. That pushed the average higher.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数和平均值相差很大，这表明平均值可能会误导人们。根据2019年的估计，美国一半的县区人口少于25,726人，另一半则多于此数。如果你在关于美国人口统计的演讲中告诉观众“美国的平均县区人口是104,468人”，他们将会得到一个扭曲的现实图像。2019年，估计有超过40个县区人口超过一百万，洛杉矶县的县区人口超过1000万，这将平均值拉高了。
- en: Finding Other Quantiles with Percentile Functions
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用百分位数函数查找其他分位数
- en: 'You can also slice data into smaller equal groups for analysis. Most common
    are *quartiles* (four equal groups), *quintiles* (five groups), and *deciles*
    (10 groups). To find any individual value, you can just plug it into a percentile
    function. To find the value marking the first quartile or the lowest 25 percent
    of data, you’d use a value of `.25`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将数据划分成更小的相等组进行分析。最常见的划分是*四分位数*（四个相等的组）、*五分位数*（五个组）和*十分位数*（10个组）。要找到任何单独的值，只需将其代入百分位数函数即可。要找到标记第一个四分位数或最低25%数据的值，你可以使用`.25`：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, entering values one at a time is laborious if you want to generate
    multiple cut points. Instead, you can pass values into `percentile_cont()` using
    an *array*, a list of items.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想生成多个切点，逐个输入值会非常繁琐。你可以通过*数组*，即一个项目列表，将值传递给`percentile_cont()`。
- en: '[Listing 6-12](#listing6-12) shows how to calculate all four quartiles at once.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-12](#listing6-12)展示了如何一次性计算四个四分位数。'
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 6-12: Passing an array of values to `percentile_cont()`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-12: 将值数组传递给`percentile_cont()`'
- en: 'In this example, we create our cut points by enclosing values in an *array
    constructor* 1 called `ARRAY[]`. An array constructor is an expression that builds
    an array from the elements included between the square brackets. Inside the brackets,
    we provide comma-separated values representing the three points at which to cut
    to create four quartiles. Run the query, and you should see this output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过将值括在*数组构造器* 1 `ARRAY[]` 中来创建分割点。数组构造器是一个表达式，用于从括号内包含的元素构建一个数组。在括号内，我们提供以逗号分隔的值，表示切分的三个点，从而创建四个四分位数。运行查询后，你应该能看到以下输出：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because we passed in an array, PostgreSQL returns an array, denoted in the
    results by curly brackets. Each quartile is separated by commas. The first quartile
    is 10,902.5, which means 25 percent of counties have a population that is equal
    to or lower than this value. The second quartile is the same as the median: 25,726\.
    The third quartile is 68,072.75, meaning the largest 25 percent of counties have
    at least this large of a population. (When reporting these, we’d of course round
    up or down, as we don’t deal in fractions when talking about people.)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们传入了一个数组，PostgreSQL 返回一个数组，结果中用大括号表示。每个四分位数之间用逗号分隔。第一个四分位数是 10,902.5，这意味着
    25% 的县份人口等于或低于此值。第二个四分位数与中位数相同：25,726。第三个四分位数是 68,072.75，这意味着最大的 25% 的县份人口至少为此值。（在报告这些数据时，我们当然会四舍五入，因为讨论人口时我们不会用小数。）
- en: Arrays are defined in the ANSI SQL standard, and our use here is just one of
    several ways you work with arrays in PostgreSQL. You can, for example, define
    a table column as an array of a particular data type. That’s useful if you want
    store multiple values in a single database column, such as a collection of tags
    for a blog post, instead of storing them in a separate table. See the PostgreSQL
    documentation at [https://www.postgresql.org/docs/current/arrays.html](https://www.postgresql.org/docs/current/arrays.html)
    for examples of declaring, searching, and modifying arrays.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在 ANSI SQL 标准中有定义，我们在这里的使用只是 PostgreSQL 中处理数组的几种方法之一。例如，你可以将表的某一列定义为特定数据类型的数组。如果你想将多个值存储在单一的数据库列中（例如博客文章的标签集合），而不是将它们存储在一个单独的表中，这样做就很有用。有关声明、查询和修改数组的示例，请参阅
    PostgreSQL 文档：[https://www.postgresql.org/docs/current/arrays.html](https://www.postgresql.org/docs/current/arrays.html)。
- en: Arrays also come with a host of functions (noted for PostgreSQL at [https://www.postgresql.org/docs/current/functions-array.html](https://www.postgresql.org/docs/current/functions-array.html))
    that allow you to perform tasks such as adding or removing values or counting
    the elements. A handy function for working with the result returned in [Listing
    6-12](#listing6-12) is `unnest()`, which makes the array easier to read by turning
    it into rows. [Listing 6-13](#listing6-13) shows the code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数组还带有一系列函数（PostgreSQL 的相关函数见：[https://www.postgresql.org/docs/current/functions-array.html](https://www.postgresql.org/docs/current/functions-array.html)），这些函数允许你执行诸如添加或移除值、计数元素等任务。一个用于处理
    [列表 6-12](#listing6-12) 返回结果的便捷函数是 `unnest()`，它通过将数组转换为行来使数组更易于阅读。[列表 6-13](#listing6-13)
    显示了相关代码。
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 6-13: Using `unnest()` to turn an array into rows'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-13：使用 `unnest()` 将数组转换为行
- en: 'Now the output should be in rows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出应该以行的形式展示：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we were computing deciles, pulling them from the resulting array and displaying
    them in rows would be especially helpful.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在计算十分位数，从结果数组中提取并将它们以行的形式展示将特别有帮助。
- en: Finding the Mode
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找众数
- en: We can find the *mode*, the value that appears most often, using the PostgreSQL
    `mode()` function. The function is not part of standard SQL and has a syntax similar
    to the percentile functions. [Listing 6-14](#listing6-14) shows a `mode()` calculation
    on `births_2019`, the column showing the number of babies born.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 PostgreSQL 的 `mode()` 函数来查找*众数*，即出现次数最多的值。该函数不是标准 SQL 的一部分，其语法类似于百分位数函数。[列表
    6-14](#listing6-14) 展示了对 `births_2019`（显示出生人数的列）进行 `mode()` 计算的示例。
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 6-14: Finding the most frequent value with `mode()`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-14：使用 `mode()` 查找最频繁的值
- en: The result is `86`, a number of births shared by 16 counties.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `86`，这是16个县份共同拥有的出生人数。
- en: Wrapping Up
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Working with numbers is a key step in acquiring meaning from your data, and
    with the math skills covered in this chapter, you’re ready to handle the foundations
    of numerical analysis with SQL. Later in the book, you’ll learn about deeper statistical
    concepts including regression and correlation, but at this point you’ve mastered
    the basics of sums, averages, and percentiles. You’ve also learned how a median
    can be a fairer assessment of a group of values than an average. That alone can
    help you avoid inaccurate conclusions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数字是从数据中获取意义的关键步骤，通过本章中涉及的数学技能，你已经准备好使用SQL处理数值分析的基础知识。书中的后续章节将介绍更深层次的统计概念，包括回归分析和相关性，但此时你已经掌握了求和、平均数和分位数的基础知识。你还学会了中位数如何比平均数更公平地评估一组值。仅此一点就能帮助你避免得出不准确的结论。
- en: In the next chapter, I’ll introduce you to the power of joining data in two
    or more tables to increase your options for data analysis. We’ll use the 2019
    US Census data you’ve already loaded into the `analysis` database and explore
    additional datasets.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将向你介绍将两个或更多表格中的数据结合起来的强大功能，以增加你进行数据分析的选择。我们将使用你已经加载到`analysis`数据库中的2019年美国人口普查数据，并探索其他数据集。
