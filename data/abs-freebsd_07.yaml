- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: THE NETWORK**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: FreeBSD is famous for its network performance. The TCP/IP network protocol suite
    was first developed on BSD, and BSD, in turn, included the first major implementation
    of TCP/IP. While competing network protocols were considered more exciting in
    the 1980s, the wide availability, flexibility, and liberal licensing of the BSD
    TCP/IP stack made it the de facto standard. This isn’t just a historical curiosity;
    today, Facebook is actively looking for engineers who can make Linux’s network
    performance match that of FreeBSD. The project is expected to take several years.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD以其网络性能著称。TCP/IP网络协议套件最初是在BSD上开发的，而BSD则包括了第一个重大实现的TCP/IP。尽管在1980年代，竞争性网络协议被认为更具吸引力，但BSD
    TCP/IP栈的广泛可用性、灵活性以及宽松的许可政策使其成为事实上的标准。这不仅仅是历史的好奇，今天，Facebook正积极寻找能够让Linux的网络性能与FreeBSD匹配的工程师。这个项目预计将持续数年。
- en: Many system administrators today have a vague familiarity with the basics of
    networking but don’t really understand how it all hangs together. Good sysadmins
    understand the network, however. Knowing what an IP address really is, how a netmask
    works, and how a port number differs from a protocol number is a necessary step
    toward mastering your profession. We’ll cover some of these issues in this chapter.
    For a start, you must understand the network layers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统管理员今天对网络基础知识有些模糊的了解，但并不真正理解这些知识是如何相互关联的。然而，优秀的系统管理员理解网络。了解IP地址的真实含义、子网掩码的工作原理以及端口号与协议号的区别是掌握你职业技能的必要步骤。本章将涵盖其中的一些问题。首先，你必须理解网络层次。
- en: While this chapter gives a decent overview of TCP/IP, it won’t cover many of
    the numerous details, gotchas, and caveats. If you need to learn more about TCP/IP,
    pick up a book on the subject. For an overview, check out my book *Networking
    for Systems Administrators* (Tilted Windmill Press, 2015). Eventually you’ll need
    a deep dive into networking; proceed directly to Charles M. Kozierok’s *The TCP/IP
    Guide* (No Starch Press, 2005).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了关于TCP/IP的一个不错概览，但并未涵盖众多细节、陷阱和注意事项。如果你需要深入学习TCP/IP，建议阅读相关书籍。作为概览，你可以参考我的书《*系统管理员的网络基础*》（Tilted
    Windmill Press，2015）。最终，你将需要深入了解网络，直接阅读Charles M. Kozierok的《*TCP/IP指南*》（No Starch
    Press，2005）。
- en: The dominant internet protocol is TCP/IP (Transmission Control Protocol over
    Internet Protocol). TCP is a transport protocol, while IP is a network protocol,
    but they’re so tightly intertwined that they’re generally referred to as a single
    entity. We’ll look at how the network works, then discuss IP versions 4 and 6,
    and proceed to TCP and UDP.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 主流的互联网协议是TCP/IP（基于互联网协议的传输控制协议）。TCP是传输协议，而IP是网络协议，但它们紧密相连，通常被视为一个整体。我们将首先探讨网络如何工作，然后讨论IP版本4和6，再继续讲解TCP和UDP。
- en: '**Network Layers**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络层**'
- en: Each layer of the network handles a specific task within the network process
    and interacts only with the layers above and below it. People learning TCP/IP
    often laugh when they hear that all these layers simplify the network process,
    but this is really true. The important thing to remember right now is that each
    layer communicates only with the layer directly above it and the layer directly
    beneath it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的每一层都处理网络过程中特定的任务，并且只与其上下相邻的层进行交互。学习TCP/IP的人常常会笑谈这些层简化了网络过程，但这确实是真的。此时需要记住的重要一点是，每一层仅与直接位于其上方和下方的层进行通信。
- en: The classic Open System Interconnection (OSI) network protocol stack has seven
    layers, is exhaustively complete, and covers almost any situation with any network
    protocol and any application. The internet, however, is just one such situation,
    and this isn’t a book about networking or networked applications in general. We’re
    limiting our discussion to TCP/IP networks, such as the internet and almost all
    corporate networks, so we need to consider only four layers of the network stack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的开放系统互联（OSI）网络协议栈有七层，完整无缺，几乎涵盖了所有网络协议和应用的各种情况。然而，互联网只是其中的一种情况，而本书并不是关于网络或网络应用的书籍。我们将讨论的内容仅限于TCP/IP网络，例如互联网和几乎所有的企业网络，因此我们只需要考虑网络栈的四个层次。
- en: '***The Physical Layer***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***物理层***'
- en: 'At the very bottom, we have the physical layer: the network card and the wire,
    fiber, or radio waves leaving it. This layer includes the physical switch; the
    hub, or base station; the cables attaching that device to the router; and the
    fiber that runs from your office to the telephone company. The telephone company
    switch is part of the physical layer, as are transcontinental fiber-optic cables.
    If it can be tripped over, dropped, or chainsawed, it’s part of the physical layer.
    From this point on, we’ll refer to the physical layer as the *wire*, although
    this layer can be just about any sort of medium.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在最底层，我们有物理层：网络卡以及从网络卡连接到的电缆、光纤或无线电波。这个层包括物理交换机、集线器或基站、连接这些设备到路由器的电缆以及从你办公室到电话公司的光纤。电话公司交换机是物理层的一部分，横跨大陆的光纤电缆也是如此。如果它能被踩到、掉落或被电锯锯断，那它就是物理层的一部分。从现在开始，我们将把物理层称为*电缆*，尽管这个层可以是任何类型的媒介。
- en: This is the easiest layer to understand—it’s as simple as having intact hardware.
    If your wire meets the requirements of the physical protocol, you’re in business.
    If not, you’re bankrupt. Without a physical layer, the rest of the network can’t
    work—period. End of story. One of the functions of internet routers is to connect
    one sort of physical layer to another—for example, converting local Ethernet into
    optical fiber. The physical layer has no decision-making abilities and no intelligence;
    everything that runs over it is dictated by the datalink layer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最容易理解的层——它就像是硬件完好无损一样简单。如果你的电缆符合物理协议的要求，那就成功了。如果不符合，那就没戏了。没有物理层，其它网络层根本无法工作——就是这么简单。互联网路由器的一个功能是将一种物理层连接到另一种物理层——例如，将本地以太网转换为光纤。物理层没有决策能力，也没有智能；它上面运行的一切都由数据链路层决定。
- en: '***Datalink: The Physical Protocol***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据链路层：物理协议***'
- en: The datalink layer, or the physical protocol, is where things get interesting.
    This layer transforms information into the actual ones and zeros that are sent
    over the physical layer in the appropriate encoding for that physical protocol.
    For example, IP version 4 (IPv4) over Ethernet uses Media Access Control (MAC)
    addresses and the Address Resolution Protocol (ARP); IP version 6 (IPv6) over
    Ethernet uses Neighbor Discovery Protocol (NDP or sometimes ND). In addition to
    the popular Ethernet datalink layers, FreeBSD supports others, including Point-to-Point
    Protocol (PPP) and High-Level Data Link Control (HDLC), as well as combinations
    such as the PPP over Ethernet (PPPoE) used by some home broadband vendors. While
    FreeBSD supports all of these datalink protocols, it doesn’t support *every* datalink
    protocol ever used. If you have unusual network requirements, check the documentation
    for your version of FreeBSD to see whether it’s supported.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层，或称物理协议层，是网络中最有趣的地方。这个层将信息转化为实际的二进制数据（0 和 1），并以适合该物理协议的编码方式通过物理层发送。例如，IP
    第四版（IPv4）通过以太网使用媒体访问控制（MAC）地址和地址解析协议（ARP）；而 IP 第六版（IPv6）通过以太网使用邻居发现协议（NDP，有时也简称
    ND）。除了流行的以太网数据链路层，FreeBSD 还支持其他协议，包括点对点协议（PPP）和高级数据链路控制协议（HDLC），以及一些组合协议，如某些家庭宽带供应商使用的
    PPPoE（以太网上的 PPP）。尽管 FreeBSD 支持所有这些数据链路协议，但它并不支持*所有*曾经使用过的数据链路协议。如果你有特殊的网络需求，可以查阅你所使用的
    FreeBSD 版本的文档，看看是否支持该协议。
- en: Some physical protocols have been implemented over many different physical layers.
    Ethernet, for instance, has been transmitted over twinax, coax, CAT3, CAT5, CAT6,
    CAT7, optical fiber, HDMI, and radio waves. With minor changes in the device drivers,
    the datalink layer can address any sort of physical layer. This is one of the
    ways in which layers simplify the network. We’ll discuss Ethernet in detail in
    “[Understanding Ethernet](ch07.xhtml#lev229)” on [page 140](ch07.xhtml#page_140)
    at the end of this chapter, as it’s the most common network type FreeBSD systems
    use. By understanding Ethernet on FreeBSD, you’ll be able to manage other protocols
    on FreeBSD as well—once you understand those protocols, of course!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些物理协议已经在许多不同的物理层上实现。例如，以太网就曾通过双轴电缆、同轴电缆、CAT3、CAT5、CAT6、CAT7、光纤、HDMI 和无线电波等方式进行传输。通过对设备驱动程序进行些许调整，数据链路层可以适应任何类型的物理层。这就是层次化结构简化网络的一种方式。我们将在本章最后的[第140页](ch07.xhtml#page_140)中的“[理解以太网](ch07.xhtml#lev229)”一节详细讨论以太网，因为它是
    FreeBSD 系统最常使用的网络类型。通过了解 FreeBSD 上的以太网，你也将能够管理其他协议——当然，前提是你已经理解了这些协议！
- en: In addition to exchanging information with the physical layer, the datalink
    layer communicates with the network layer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与物理层交换信息，数据链路层还与网络层进行通信。
- en: '***The Network Layer***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***网络层***'
- en: The network layer? Isn’t the whole thing a network?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层？难道整个东西不是网络吗？
- en: Yes, but the network layer is more specific. It maps connectivity between network
    nodes, answering questions like, “Where are other hosts?” and “Can you reach this
    particular host?” This logical protocol provides a consistent interface to programs
    that run over the network, no matter what sort of physical layer you’re using.
    The network layer used on the internet is *Internet Protocol (IP)*. IP provides
    each host with a unique^([1](footnote.xhtml#ch07fn1)) address, known as an *IP
    address*, so that any other host on the network can find it. You need to understand
    IP, both version 4 and version 6.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，但网络层更为具体。它映射网络节点之间的连接，回答诸如“其他主机在哪里？”和“你能访问这个特定的主机吗？”这样的问题。这个逻辑协议为在网络上运行的程序提供了一个一致的接口，无论你使用什么样的物理层。互联网上使用的网络层是*互联网协议（IP）*。IP为每个主机提供一个独一无二的^([1](footnote.xhtml#ch07fn1))地址，称为*IP地址*，以便网络上的任何其他主机都可以找到它。你需要了解IP的第4版和第6版。
- en: The network layer is where we truly abstract away the underlying physical media.
    Is IP running over Ethernet? ATM? Carrier pigeon? Who cares? It’s got an IP address,
    so we can talk to it. Move on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层是我们真正抽象出底层物理媒介的地方。IP是通过以太网运行的吗？ATM？信鸽？谁在乎？它有一个IP地址，所以我们可以与之通信。继续吧。
- en: The network layer talks to the datalink layer below it and the transport layer
    above it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层与下面的数据链路层和上面的传输层进行通信。
- en: '***Heavy Lifting: The Transport Layer***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***繁重工作：传输层***'
- en: The transport layer deals with real data for real applications and perhaps even
    real human beings. The three common transport layer protocols are ICMP, TCP, and
    UDP.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层处理真实应用程序的实际数据，甚至可能是实际的人类。三种常见的传输层协议是ICMP、TCP和UDP。
- en: '*Internet Control Message Protocol (ICMP)* manages basic connectivity messages
    between hosts with IP addresses. If IP provides a road and addresses, ICMP provides
    traffic lights and highway exit signs. Most of the time, ICMP just runs in the
    background and you never have to think about it.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*互联网控制消息协议（ICMP）*管理具有IP地址的主机之间的基本连接消息。如果IP提供了一条道路和地址，那么ICMP提供了交通信号灯和高速公路出口标志。大多数时候，ICMP在后台运行，你无需关注它。'
- en: The other well-known transport protocols are *User Datagram Protocol (UDP)*
    and *Transmission Control Protocol (TCP)*. How common are these?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其他著名的传输协议有*用户数据报协议（UDP）*和*传输控制协议（TCP）*。这些有多常见？
- en: Well, the Internet Protocol suite is generally called TCP/IP. These protocols
    provide services such as multiplexing via port numbers and transmitting user data.
    UDP is a bare-bones transport protocol, offering the minimum services needed to
    transfer data over the network. TCP provides more sophisticated features, such
    as congestion control and integrity checking.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，互联网协议套件通常称为TCP/IP。这些协议提供了如通过端口号复用和传输用户数据等服务。UDP是一种基本的传输协议，提供了传输数据所需的最基本服务。TCP则提供了更复杂的功能，如拥塞控制和完整性检查。
- en: 'In addition to these three, many other protocols run above IP. The file */etc/protocols*
    contains a fairly comprehensive list of transport protocols that use IP as an
    underlying mechanism. You won’t find non-IP protocols here, such as Digital’s
    LAT, but it contains many more protocols than you’ll ever see in the real world.
    For example, here are the entries for IP and ICMP, the network-layer protocols
    commonly used on the internet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三种协议，许多其他协议也运行在IP之上。文件*/etc/protocols*包含了一个相当全面的传输协议列表，这些协议使用IP作为底层机制。你不会在这里找到非IP协议，比如Digital的LAT，但它包含了许多你在现实中永远不会见到的协议。例如，下面是IP和ICMP的条目，它们是互联网上常用的网络层协议：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each entry in */etc/protocols* has three key fields: an unofficial name ➊,
    a protocol number ➋, and any aliases ➌. The protocol number is used within network
    requests to identify traffic. You’ll see it if you ever fire up a packet sniffer
    or start digging deeper into your network for any reason. As you can see, IP is
    protocol 0 and ICMP is protocol 1—if that’s not the groundwork for everything
    else, it’s hard to see what could be! TCP is protocol 6, and UDP is protocol 17\.
    You’ll also see comments ➍ giving slightly more detail about each protocol.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/protocols*中的每个条目有三个关键字段：一个非正式的名称➊，一个协议编号➋，以及任何别名➌。协议编号在网络请求中用于识别流量。如果你曾经启动过数据包嗅探器或出于某种原因深入研究过网络，你就会看到它。如你所见，IP是协议0，ICMP是协议1——如果这不是所有其他协议的基础，那么很难想象还有什么能成为基础！TCP是协议6，UDP是协议17。你还会看到注释➍，提供关于每个协议的更多细节。'
- en: The transport layer speaks to the network layer below and to the applications
    above it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层与下面的网络层和上面的应用程序层进行通信。
- en: '***Applications***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用程序***'
- en: Applications are definitely a part of the network. Applications open requests
    for network connectivity, send data over the network, receive data from the network,
    and process that data. Web browsers, email clients, JSP servers, and so on are
    all network-aware applications. Applications have to communicate only with the
    network protocol and the user. Problems with the user layer are beyond the scope
    of this book.^([2](footnote.xhtml#ch07fn2))
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序肯定是网络的一部分。应用程序发起网络连接请求，通过网络发送数据，从网络接收数据，并处理这些数据。网页浏览器、电子邮件客户端、JSP服务器等都是网络感知应用程序。应用程序只需要与网络协议和用户进行通信。用户层的问题超出了本书的范围。^([2](footnote.xhtml#ch07fn2))
- en: '**The Network in Practice**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践中的网络**'
- en: So, you understand how everything hooks together and are ready to move on, right?
    Don’t think so. Let’s see how this works in the real world. Some of this explanation
    touches on stuff that we’ll cover later in this chapter, but if you’re reading
    this book, you’re probably conversant enough with networks to be able to follow
    it. If you’re having trouble, reread this section after reading the remainder
    of this chapter. (Just buy a second copy of this book, cut these pages out of
    the second copy, and glue them in at the end of this chapter.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你现在明白所有的连接是如何搭建在一起的，并且准备继续前进，对吧？不一定。让我们看看在现实世界中它是如何工作的。部分解释涉及到我们在本章后面会讨论的内容，但如果你正在读这本书，你应该足够了解网络知识，能够跟上。如果你有困难，读完本章的其他部分后可以重新阅读这一节。（可以再买一本这本书，把这几页剪下来，粘贴在本章结尾处。）
- en: Suppose a user connected to the internet via your network wants to look at Yahoo!
    The user accesses his web browser and enters the URL.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个通过你的网络连接到互联网的用户想要查看Yahoo！用户打开他的浏览器并输入网址。
- en: The browser application knows how to talk to the next layer down in the network,
    which is the transport layer. After kneading the user’s request into an appropriate
    form, the browser asks the transport layer for a TCP connection to a particular
    IP address on port 80\. (Purists will note that we’re skipping the DNS request
    part of the process, but it’s quite similar to what’s being described and would
    only confuse our example.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器应用程序知道如何与网络中的下一层进行通信，即传输层。在将用户的请求处理成合适的格式后，浏览器向传输层请求一个到特定IP地址、端口80的TCP连接。（纯粹主义者会注意到我们跳过了DNS请求部分，但这与所描述的过程非常相似，不会对我们的示例产生影响。）
- en: The transport layer examines the browser’s request. Since the application has
    requested a TCP connection, the transport layer allocates the appropriate system
    resources for that sort of connection. The request is broken up into digestible
    chunks and handed down to the network layer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层检查浏览器的请求。由于应用程序请求了TCP连接，传输层为该类型的连接分配适当的系统资源。请求被分解成易于处理的块，并交给网络层。
- en: The network layer doesn’t care about the actual request. It’s been handed a
    lump of data to be carried over the internet. Much like your mail carrier delivers
    letters without caring about the contents, the network layer just bundles the
    TCP data with the proper addressing information. The resulting mass of data is
    called a *packet*. The network layer hands these packets down to the datalink
    layer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层不关心实际的请求。它接收到的是一堆需要通过互联网传输的数据。就像邮递员在投递信件时不关心信件内容一样，网络层只是将TCP数据与适当的地址信息捆绑在一起。最终的数据块被称为*数据包*。网络层将这些数据包交给数据链路层。
- en: The datalink layer doesn’t care about the contents of the packet. It certainly
    doesn’t care about IP addressing or routing. It’s been given a lump of zeros and
    ones, and it has the job of transmitting those zeros and ones across the network.
    All it knows is how to perform that transmission. The datalink layer may add the
    appropriate header and/or footer information to the packet for the physical medium
    used, creating a *frame*. Finally, it hands the frame off to the physical layer
    for transmission on the local wire, wave, or other media.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层不关心数据包的内容。它当然不关心IP地址或路由。它收到了一堆零和一，任务就是将这些零和一通过网络传输。它只知道如何执行这个传输。数据链路层可能会根据所使用的物理介质为数据包添加适当的头部和/或尾部信息，从而创建一个*帧*。最后，它将帧交给物理层，在本地电缆、无线或其他介质上进行传输。
- en: '**EACH INSIDE THE OTHER?**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个都在另一个里面？**'
- en: Yes, your original web request has been encapsulated by the TCP protocol. That
    request has been encapsulated again at the transport layer by the IP protocol
    and once more by the datalink protocol. All these headers are piled on at the
    front and back of your original request. Have you ever seen that picture of a
    small fish being swallowed by a slightly larger fish, which is in turn being eaten
    by a larger fish, and so on? It’s exactly like that. Or, if you prefer, a frame
    is like the outermost matryoshka doll. Unwrap one protocol and you’ll find another.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你的原始网页请求已经被TCP协议封装。这个请求在传输层又被IP协议封装一次，然后又被数据链路协议封装一次。所有这些头部信息都被加在原始请求的前后。你见过那张小鱼被稍大一点的鱼吞掉，而稍大一点的鱼又被更大的鱼吃掉的图片吗？它正是这样。或者，如果你愿意，数据帧就像是最外面的套娃。解开一个协议，你会发现另一个协议。
- en: The physical layer has no intelligence at all. The datalink layer hands it a
    bunch of zeros and ones, and the physical layer transmits them to another physical
    device. It has no idea what protocol is being spoken or how those digits might
    be echoed through a switch, hub, or repeater, but one of the hosts on this network
    is presumably the router of the network.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 物理层完全没有智能。数据链路层将一堆零和一传递给物理层，物理层将它们传输到另一个物理设备。它不知道正在使用什么协议，也不知道这些数字是如何通过交换机、集线器或中继器回响的，但这个网络中的某个主机大概是网络的路由器。
- en: When the router receives the zeros and ones, it hands them up to the datalink
    layer. The datalink layer strips its framing information and hands the resulting
    packet up to the network layer within the router. The router’s network layer examines
    the packet and decides what to do with it based on its routing tables. It then
    hands the packet down to the appropriate datalink layer. This might be another
    Ethernet interface or perhaps a PPP interface out of a T1.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器接收到零和一时，它会将它们交给数据链路层。数据链路层去除其封装信息，并将得到的数据包交给路由器中的网络层。路由器的网络层检查数据包并根据其路由表决定如何处理它。然后，它会将数据包交给适当的数据链路层。这可能是另一个以太网接口，或者是一个来自T1的PPP接口。
- en: Your wire can go through many physical changes as the data travels. Your cable
    internet line could be aggregated into an optical fiber DS3, which is then transformed
    into an OC192 cross-country link. Thanks to the wonders of layering and abstraction,
    neither your computer nor your user needs to know anything about any of these.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据传输过程中，你的电缆可能会经历许多物理变化。你的有线互联网连接可能会聚合成光纤DS3，然后再转化为OC192的跨国链路。感谢分层和抽象的奇妙，既你的计算机也你的用户都不需要了解这些内容。
- en: When the request reaches its destination, the computer at the other end of the
    transaction accepts the frame and sends it all the way back up the protocol stack.
    The physical wire accepts the zeros and ones and sends them up to the datalink
    layer. The datalink layer strips the Ethernet headers off the frame and hands
    the resulting packet up to the network. The network layer strips off the packet
    header and shuffles the remaining segments up to the transport layer. The transport
    layer reassembles the segments into a data stream, which it then hands to an application—in
    this case, a web server. The application processes the request and returns an
    answer, which descends the protocol stack and travels across the network, bouncing
    up and down through various datalink layers on the way as necessary. This is an
    awful lot of work to make the machine go through just so you can get your “404
    Page Not Found” error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达目的地时，另一端的计算机接收该帧并将其一路传回协议栈。物理层接收零和一的信号并将它们传送到数据链路层。数据链路层去除以太网头部，并将处理后的数据包交给网络层。网络层去除数据包头部，并将剩余的数据段传递到传输层。传输层将这些数据段重新组装成数据流，然后交给应用程序——在这个例子中是一个
    web 服务器。应用程序处理请求并返回答案，然后数据沿协议栈向下传递，必要时穿越各种数据链路层。这一系列的工作是为了让机器完成，只为让你看到那个“404 页面未找到”的错误。
- en: This example shows why layering is so important. Each layer knows only what
    it absolutely must about the layers above and below it, making it possible to
    swap out the innards of layers if desired. When a new datalink protocol is created,
    the other layers don’t have to change; the network protocol just hands a properly
    formatted request to the datalink layer and lets that layer do its thing. When
    you have a new network card, you only need a driver that interfaces with the datalink
    layer and the physical layer; you don’t have to change anything higher in the
    network stack, including your application. Imagine a device driver that had to
    be installed in your web browser, your email client, and every other application
    you had on your computer, including the custom-built ones. You would quickly give
    up on computing and take up something sane and sensible, like skydiving with anvils.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了为什么分层如此重要。每一层仅了解关于上下层必须知道的内容，这使得如果需要，可以轻松地替换层内部的实现。当创建新的数据链路协议时，其他层不必更改；网络协议只需向数据链路层发送格式正确的请求，让该层完成它的工作。当你拥有一个新的网卡时，你只需要一个与数据链路层和物理层接口的驱动程序；你不需要更改网络栈中更高层的任何内容，包括你的应用程序。想象一下，如果设备驱动程序必须安装在你的
    web 浏览器、电子邮件客户端和你电脑上所有其他应用程序中，包括自定义构建的应用程序，你会很快放弃计算机，去做一些更理智、更合理的事情，比如与铁砧一起跳伞。
- en: '**Getting Bits and Hexes**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取比特和十六进制**'
- en: As a system administrator, you’ll frequently come across terms like *48-bit
    address* and *18-bit netmask*. I’ve seen a surprising number of sysadmins who
    just nod and smile when they hear this, all the while thinking, “Yeah, whatever,
    just tell me what I need to know to do my job.” Unfortunately, math is a real
    part of the job, and you *must* understand bits. While this math is not immediately
    intuitive, understanding it is one of the things that separates amateurs from
    professionals. You don’t read a book like this if you want to stay an amateur.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名系统管理员，你会经常遇到像*48 位地址*和*18 位子网掩码*这样的术语。我见过不少系统管理员在听到这些时只是点点头，微笑着，心里想着：“好吧，反正告诉我做工作需要知道什么就行。”不幸的是，数学是这项工作的一部分，你*必须*理解比特。虽然这些数学计算并不直观，但理解它是区分业余者和专业人士的关键之一。如果你想保持业余水平，就不会读这样的书。
- en: Maybe you’re muttering, “But I already know this!” Then skip it. But don’t cheat
    yourself if you don’t.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你在嘀咕，“但我已经知道这些了！”那就跳过吧。但如果你不了解，就不要骗自己。
- en: You probably already know that a computer treats all data as zeros and ones,
    and that a single zero or one is a *bit*. When a protocol specifies a number of
    bits, it’s talking about the number as seen by the computer. A 32-bit number has
    32 digits, each being either zero or one. You were probably introduced to *binary*
    math, or *base 2*, back in elementary school and remembered it just long enough
    to pass the test. It’s time to dust off those memories. Binary math is simply
    a different way to work with the numbers we see every day.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道，计算机把所有数据都当作0和1来处理，一个零或一就是一个*比特*。当协议指定了比特数时，它指的是计算机看到的数字。一 个32位数字有32个数字，每个数字是0或1。你可能在小学时接触过*二进制*数学，或者说*基数2*，并且记得刚好足够长的时间来通过测试。现在是时候重新拾起那些记忆了。二进制数学实际上只是另一种处理我们每天看到的数字的方式。
- en: We use *decimal* math, or *base 10*, every day to pay the pizza guy and balance
    the checkbook. Digits run from 0 to 9\. When you want to go above the highest
    digit you have, you add a digit on the left and set your current digit to zero.
    This is the whole “carry the one” thing you learned many years ago and now probably
    do without conscious thought. In binary math, the digits run from 0 to 1, and
    when you want to go above the highest digit you have, you add a digit on the left
    and set your current digit to 0\. It’s exactly the same as decimal math with eight
    fingers missing. As an example, [Table 7-1](ch07.xhtml#ch07tab1) shows the first
    few decimal numbers converted to binary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每天使用*十进制*数学，或者说*基数10*，来支付披萨费和核对账单。数字从0到9。当你想超过当前最高数字时，你会在左边添加一个数字，并将当前数字设为零。这就是你多年前学到的“进位”规则，现在可能不加思考地自动做出来了。在二进制数学中，数字从0到1，当你想超过当前最高数字时，你会在左边添加一个数字，并将当前数字设为0。这和十进制数学一模一样，只是少了八根手指。举个例子，[表7-1](ch07.xhtml#ch07tab1)展示了将前几个十进制数字转换为二进制的过程。
- en: '**Table 7-1:** Decimal and Binary Numbers'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** 十进制和二进制数字'
- en: '| **Decimal** | **Binary** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **十进制** | **二进制** |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 0 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 |'
- en: '| 1 | 1 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 10 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 10 |'
- en: '| 3 | 11 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 11 |'
- en: '| 4 | 100 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 100 |'
- en: '| 5 | 101 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 101 |'
- en: '| 6 | 110 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 110 |'
- en: '| 7 | 111 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 111 |'
- en: '| 8 | 1000 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1000 |'
- en: When you have a 32-bit number, such as an IP address, you have a string of 32
    ones and zeros. Ethernet MAC addresses are 48-bit numbers and have 48 ones and
    zeros.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个32位数字时，例如一个IP地址，你会得到一串32个1和0。以太网MAC地址是48位数字，有48个1和0。
- en: Just for fun, Unix also uses hexadecimal numbers in some cases, such as MAC
    addresses and netmasks. Hexadecimal digits are 4 bits long. The binary number
    1111, the full 4 bits, is equivalent to 15; this means that the digits in hexadecimal
    math run from 0 to 15\. At this point, a few of you are looking at the 2-digit
    number 15 that’s supposed to be a single digit and wondering what I’m smoking
    and where you can get your own supply. Hexadecimal math uses the letters A through
    F as digits for the numbers 10 through 15\. When you count up to the last digit
    and want to add one, you set the current digit to zero and add a digit to the
    left of the number. For example, to count to 17 in hexadecimal, you say, “1, 2,
    3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11.” Take off a shoe and count along
    once or twice until you get the idea.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 仅供娱乐，Unix在某些情况下也使用十六进制数字，例如MAC地址和子网掩码。十六进制数字是4位长。二进制数1111，完整的4位，等同于15；这意味着十六进制数学中的数字范围是从0到15。此时，可能有一些人看到应该是单一数字的2位数15，心想我在吸什么烟，以及你们去哪儿能买到同样的东西。十六进制数学使用字母A到F表示数字10到15。当你数到最后一个数字并想加1时，你会将当前数字设为零，并在数字的左边添加一个新数字。例如，想要在十六进制中数到17，你会说：“1,
    2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11。”脱掉一只鞋子，数一数直到你明白为止。
- en: Hexadecimal numbers are usually marked with a *0x* in front. The number 0x12
    is the hexadecimal equivalent of decimal 18, while the number 18 is plain old
    18\. If a hex number is not marked by a leading 0x, it’s in a place where the
    output is always in hexadecimal, such as MAC addresses. The letters A to F are
    also a dead giveaway, but not entirely reliable; many hex numbers have no letters
    at all, just as many decimal numbers have no odd digits.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制数字通常会在前面加上*0x*标记。数字0x12是十六进制的18，相当于十进制的18，而数字18则是普通的18。如果一个十六进制数字没有前导的0x标记，那它出现在一个始终以十六进制输出的地方，比如MAC地址。字母A到F也是一种明显的标识，但并不完全可靠；许多十六进制数字根本没有字母，就像许多十进制数字没有奇数位一样。
- en: When you’re working with hexadecimal, decimal, and binary numbers, the simplest
    thing to do is break out a scientific calculator. Today’s medium-end or better
    calculators have functions to convert between the three systems, as do most software
    calculators.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在处理十六进制、十进制和二进制数字时，最简单的做法是拿出科学计算器。如今的中端或更高端计算器都具备在三种系统之间转换的功能，大多数软件计算器也有这种功能。
- en: '**BIT BY BYTES**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**比特与字节**'
- en: Computer systems tend to work in bytes, where an 8-bit number is represented
    by a single character. The one exception is in the network stack, where everything
    is in bits. Thus, we have a 5-mega*byte* file on a machine with a 10-mega*bit*
    network connection. Don’t confuse the two!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统通常以字节为单位工作，其中一个8位数字由单个字符表示。唯一的例外是网络栈，其中一切都以比特为单位。因此，我们在一台具有10兆比特网络连接的机器上有一个5兆*字节*的文件。不要把这两者混淆！
- en: '**Network Stacks**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络栈**'
- en: A network stack is the software that lets a host communicate with other hosts
    over the network. A host can run with an IPv4-only network stack, an IPv6-only
    network stack, or a dual-stacked setup. FreeBSD enables both by default.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 网络栈是让主机通过网络与其他主机通信的软件。主机可以使用仅支持IPv4的网络栈、仅支持IPv6的网络栈，或者使用双栈配置。FreeBSD默认启用这两者。
- en: You’re probably familiar with an IPv4-only stack. Most hosts have run on IPv4
    for much of the past 30 years. An IPv4-only stack can communicate only over IPv4\.
    Today, an IPv4-only stack gets you access to most of the internet, with a few
    deliberate exceptions. That will not be true in a few years.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对仅支持IPv4的网络栈很熟悉。在过去的30年中，大多数主机都使用IPv4。仅支持IPv4的网络栈只能通过IPv4进行通信。今天，IPv4-only的网络栈能够访问大部分互联网，尽管有一些故意的例外。但在几年后，这种情况将不再成立。
- en: Likewise, an IPv6-only stack can communicate only with IPv6 hosts. The majority
    of large internet sites support IPv6, but you’ll find a few annoying exceptions.^([3](footnote.xhtml#ch07fn3))
    Using only IPv6 will cut you off from some popular internet sites.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，只有IPv6的网络栈只能与IPv6主机通信。大多数大型互联网网站支持IPv6，但你会发现少数令人烦恼的例外。^([3](footnote.xhtml#ch07fn3))
    仅使用IPv6会使你无法访问一些流行的互联网网站。
- en: The most common server configuration these days is a dual-stack setup. Client
    hosts try to use both IPv4 and IPv6, preferring one over the other. The last few
    versions of Microsoft Windows have preferred IPv6.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当前最常见的服务器配置是双栈设置。客户端主机尝试同时使用IPv4和IPv6，通常会偏向其中一个。微软Windows的最近几个版本更倾向于使用IPv6。
- en: We’ll look at the more familiar IPv4 first and then use IPv4 as a reference
    to discuss IPv6.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将讨论更为熟悉的IPv4，然后以IPv4为参考来讨论IPv6。
- en: '**IPv4 Addresses and Netmasks**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**IPv4地址和子网掩码**'
- en: An IP address is a unique 32-bit number assigned to a particular node on a network.
    Some IP addresses are more or less permanent, such as those assigned to vital
    servers. Others change as required by the network, such as those used by dial-up
    clients. Individual machines on a shared network get adjoining IP addresses.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址是分配给网络上特定节点的唯一32位数字。有些IP地址几乎是永久性的，比如分配给重要服务器的地址。其他地址则会根据网络需求变化，比如拨号客户端使用的地址。共享网络上的单独机器会获取相邻的IP地址。
- en: Rather than expressing that 32-bit number as a single number, an IP address
    is broken up into four 8-bit numbers, usually shown as decimal numbers. While
    203.0.113.1 is the same as 11001011.00000000.01110001.00000001 or the single number
    11001011000000000111000100000001, the four decimal numbers are easiest for our
    weak minds to deal with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不是将32位数字表示为一个单一的数字，而是将IP地址分为四个8位数字，通常以十进制数字表示。虽然203.0.113.1与11001011.00000000.01110001.00000001或单一数字11001011000000000111000100000001是相同的，但四个十进制数字是我们思维最容易处理的方式。
- en: IP addresses are issued in chunks by internet service providers. Frequently
    these chunks are very small—say, 16 or 32 IP addresses. If your system is colocated
    on a server farm, you might only get a few IP addresses out of a block.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址是由互联网服务提供商以块的形式分配的。这些块通常非常小——比如说16个或32个IP地址。如果你的系统位于一个服务器农场中，你可能只会得到一个地址块中的几个IP地址。
- en: A *netmask*, which might also be called a *prefix length* or *slash*, is a label
    indicating the size of the block of IP addresses assigned to your local network.
    The size of your IP block determines your netmask—or, your netmask determines
    how many IP addresses you have. If you’ve done networking for any length of time,
    you’ve seen the netmask 255.255.255.0 and know that it’s associated with a block
    of 256 IP addresses. You might even know that the wrong netmask prevents your
    system from working. In today’s world, however, that simple netmask is becoming
    less and less common. Netmasks made up of 255s and 0s are easy to look at but
    waste IP addresses.^([4](footnote.xhtml#ch07fn4)) And IPv4 addresses are an extremely
    scarce resource.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络掩码*，也可以称为 *前缀长度* 或 *斜杠*，是一个标签，表示分配给本地网络的 IP 地址块的大小。你的 IP 块的大小决定了你的网络掩码——或者说，你的网络掩码决定了你有多少个
    IP 地址。如果你做过一段时间的网络工作，你一定见过网络掩码 255.255.255.0，并知道它与 256 个 IP 地址的块相关。你甚至可能知道，错误的网络掩码会导致你的系统无法正常工作。然而，在今天，这种简单的网络掩码变得越来越不常见。由
    255 和 0 组成的网络掩码虽然易于观察，但会浪费 IP 地址。^([4](footnote.xhtml#ch07fn4)) 而 IPv4 地址是一种极其稀缺的资源。'
- en: 'When you get a block of IP addresses for your server, it’ll probably look something
    like 203.0.113.128/25\. This isn’t a class in binary math, so I won’t make you
    draw it out and do the conversion, but think of an IP address as a string of binary
    numbers. On your network, you can change the bits on the far right, but not the
    ones on the far left. The only question is, “Where is the line that separates
    right from left?” There’s no reason for that boundary to be on one of those convenient
    8-bit lines that separate the decimal versions of the address. A prefix length
    is simply the number of fixed bits on your network. A /25 means that you have
    25 fixed bits. You can play with 7 bits. You get a decimal netmask by setting
    the fixed bits to 1 and your network bits to 0, as in the following example of
    a /25 netmask:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为服务器获取一块 IP 地址时，它可能看起来像 203.0.113.128/25\。这不是一个二进制数学课程，所以我不会让你画出来并做转换，但可以把
    IP 地址看作是一个二进制数的字符串。在你的网络上，你可以改变最右边的位，但不能改变最左边的位。唯一的问题是，“分隔左右的界线在哪里？”这个边界不一定要在那些方便的
    8 位线处，这些线把地址的十进制版本分开。前缀长度就是你网络上固定的位数。/25 意味着你有 25 个固定的位。你可以操作 7 个位。通过将固定位设为 1，将网络位设为
    0，你可以得到一个十进制的网络掩码，如以下 /25 网络掩码示例：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A binary 11111111 is a decimal 255, while 1000000 is 128\. Your netmask is 255.255.255.128\.
    It’s very simple, if you think in binary. You won’t have to work with this every
    day, but if you don’t understand the underlying binary concepts, the decimal conversion
    looks deranged. With practice, you’ll learn to recognize certain strings of decimals
    as legitimate binary conversions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制 11111111 是十进制 255，而 1000000 是 128\。你的网络掩码是 255.255.255.128\。如果你从二进制角度思考，这非常简单。你不需要每天都处理这个问题，但如果你不理解底层的二进制概念，十进制转换看起来可能会让人困惑。通过练习，你将学会识别某些十进制数字串作为合法的二进制转换。
- en: What does all this mean in practice? First off, blocks of IP addresses are issued
    in multiples of 2\. If you have 4 bits to play with, you have 16 IP addresses
    (2 × 2 × 2 × 2 = 16). If you have 8 bits to play with, you have 256 addresses
    (2⁸ = 256). If someone says that you have exactly 19 IP addresses, you’re either
    sharing an Ethernet with other people or they’re wrong.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些在实践中意味着什么呢？首先，IP 地址块是以 2 的倍数发放的。如果你有 4 位可以操作，你将拥有 16 个 IP 地址（2 × 2 × 2 ×
    2 = 16）。如果你有 8 位可以操作，你将拥有 256 个地址（2⁸ = 256）。如果有人说你正好有 19 个 IP 地址，那你要么是和别人共享以太网，要么他们错了。
- en: It’s not uncommon to see a host’s IP address with its netmask attached—for example,
    198.51.100.4/26\. This gives you everything you need to get the host on the local
    network. (Finding the default gateway is another problem, but by convention, it’s
    most often the top or bottom address in the block.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会看到主机的 IP 地址后附带其网络掩码——例如，198.51.100.4/26\。这给你提供了将主机接入本地网络所需的所有信息。（寻找默认网关是另一个问题，但根据惯例，它通常是该块中最高或最低的地址。）
- en: '***Computing Netmasks in Decimal***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***十进制计算网络掩码***'
- en: You probably don’t want to repeatedly convert between decimal and binary. Not
    only is it uncomfortable; it also increases your chances of making an error. Here’s
    a trick to calculate your netmask while remaining in decimal land.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想反复进行十进制和二进制之间的转换。这样不仅不舒服，还增加了出错的机会。这里有一个技巧，可以让你在保持十进制思维的同时计算网络掩码。
- en: You need to find how many IP addresses you have on your network. This will be
    a multiple of 2 almost certainly smaller than 256\. Subtract the number of IP
    addresses you have from 256\. This is the last number of your netmask. You’ll
    still need to recognize legitimate network sizes. If your IP address is 203.0.113.100/26,
    you’ll need to know that a /26 is 26 fixed bits, or 64 IP addresses. Look at the
    last number of your IP address, 100\. It certainly isn’t between 0 and 63, but
    it’s between 64 and 127\. The other hosts on your IP block have IP addresses ranging
    from 203.0.113.64 to 203.0.113.127, and your netmask is 255.255.255.192 (256 –
    64 = 192).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要找到你网络中有多少个IP地址。这个数字几乎肯定是2的倍数，并且小于256。将你拥有的IP地址数量从256中减去，这就是你的子网掩码的最后一个数字。你还需要识别合法的网络大小。如果你的IP地址是203.0.113.100/26，你需要知道，/26表示26个固定位，或者说64个IP地址。看一下你IP地址的最后一个数字，100。它显然不在0到63之间，但它在64到127之间。你IP块中的其他主机的IP地址范围从203.0.113.64到203.0.113.127，而你的子网掩码是255.255.255.192（256
    – 64 = 192）。
- en: At this point, I should mention that netmasks frequently appear as hex numbers.
    You might feel like giving up the whole thing as a bad job, but to simplify your
    life, [Table 7-2](ch07.xhtml#ch07tab2) shows netmasks, IP information, and related
    goodness for /24 and smaller networks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我应该提到，子网掩码经常以十六进制数出现。你可能会觉得这整个事情无望，但为了简化你的生活，[表7-2](ch07.xhtml#ch07tab2)展示了子网掩码、IP信息以及针对/24及更小网络的相关信息。
- en: '**Table 7-2:** Netmask and IP Address Conversions'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-2：** 子网掩码和IP地址转换'
- en: '| **Prefix** | **Binary mask** | **Decimal mask** | **Hex mask** | **Available
    IPs** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **前缀** | **二进制掩码** | **十进制掩码** | **十六进制掩码** | **可用IP地址** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| /24 | 00000000 | 255.255.255.0 | 0xffffff00 | 256 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| /24 | 00000000 | 255.255.255.0 | 0xffffff00 | 256 |'
- en: '| /25 | 10000000 | 255.255.255.128 | 0xffffff80 | 128 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| /25 | 10000000 | 255.255.255.128 | 0xffffff80 | 128 |'
- en: '| /26 | 11000000 | 255.255.255.192 | 0xffffffc0 | 64 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| /26 | 11000000 | 255.255.255.192 | 0xffffffc0 | 64 |'
- en: '| /27 | 11100000 | 255.255.255.224 | 0xffffffe0 | 32 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| /27 | 11100000 | 255.255.255.224 | 0xffffffe0 | 32 |'
- en: '| /28 | 11110000 | 255.255.255.240 | 0xfffffff0 | 16 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| /28 | 11110000 | 255.255.255.240 | 0xfffffff0 | 16 |'
- en: '| /29 | 11111000 | 255.255.255.248 | 0xfffffff8 | 8 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| /29 | 11111000 | 255.255.255.248 | 0xfffffff8 | 8 |'
- en: '| /30 | 11111100 | 255.255.255.252 | 0xfffffffc | 4 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| /30 | 11111100 | 255.255.255.252 | 0xfffffffc | 4 |'
- en: '| /31 | 11111110 | 255.255.255.254 | 0xfffffffe | 2 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| /31 | 11111110 | 255.255.255.254 | 0xfffffffe | 2 |'
- en: '| /32 | 11111111 | 255.255.255.255 | 0xffffffff | 1 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| /32 | 11111111 | 255.255.255.255 | 0xffffffff | 1 |'
- en: '***Unusable IP Addresses***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不可用的IP地址***'
- en: You now understand how slashes, netmasks, and IP address assignments work together
    and how, for example, a /28 has 16 IP addresses. Unfortunately, you can’t use
    all the IP addresses in a block. The first IP address in a block is the *network
    number*, which is used for internal bookkeeping.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经理解了斜杠、子网掩码和IP地址分配是如何协同工作的，举例来说，/28 有 16 个IP地址。不幸的是，你不能使用一个块中的所有IP地址。块中的第一个IP地址是*网络号*，它用于内部记账。
- en: Traditionally, the last number in any block of IP addresses was called the *broadcast
    address*. According to the original IP specifications, every machine on a network
    was supposed to respond to a request for this address. This allowed you to ping
    the broadcast address to quickly determine which IP addresses were in use. For
    example, on a typical /24 network, the broadcast address was *x* .*y* .*z* .255\.
    In the late 1990s, however, this feature was transformed into an attack technique
    and was disabled by default on almost every operating system and most network
    appliances.^([5](footnote.xhtml#ch07fn5)) If you need this feature, set the sysctl
    `net.inet.icmp.bmcastecho` to `1`. In most environments, the broadcast address
    is a waste of an IP address. In any case, you can’t assign the first or the last
    IP address in a network to a device without causing network problems. (Yes, this
    makes /31 networks useless.) Some systems fail gracefully; others fail gracelessly.
    Go ahead and try it sometime—preferably after hours, unless you want a good story
    to tell at your next job.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，任何IP地址块中的最后一个数字被称为*广播地址*。根据最初的IP规格，网络中的每台机器都应该响应该地址的请求。这使得你可以通过ping广播地址，快速确定哪些IP地址正在使用。例如，在典型的/24网络中，广播地址是*x*
    .*y* .*z* .255。 然而，在1990年代末，这一功能被转变为一种攻击技术，并且几乎所有操作系统和大多数网络设备默认禁用了它。^([5](footnote.xhtml#ch07fn5))
    如果你需要此功能，可以将sysctl `net.inet.icmp.bmcastecho` 设置为`1`。在大多数环境中，广播地址是一个浪费的IP地址。无论如何，你不能将网络中的第一个或最后一个IP地址分配给设备，否则会导致网络问题。（是的，这使得/31网络变得无用。）某些系统优雅地失败；其他系统则失败得不那么优雅。不妨试试看——最好在下班后进行，除非你想有个好故事分享给下一个工作。
- en: '***Assigning IPv4 Addresses***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分配IPv4地址***'
- en: You might think that each computer on a network has an IP address, but this
    isn’t strictly true. Every network *interface* has an IP address. Most computers
    have only one network interface, so for them, the difference is nonexistent. If
    you have multiple network cards, however, each card has a separate IP address.
    You can also have multiple IP addresses on a single card through aliasing. On
    the other hand, with special configuration you can bond multiple cards into a
    single network interface, giving the computer one virtual interface despite the
    many cards. While these distinctions are small, remember them when troubleshooting.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为每台网络上的计算机都有一个IP地址，但这并不完全正确。每个网络*接口*都有一个IP地址。大多数计算机只有一个网络接口，所以对它们来说，二者没有区别。然而，如果你有多个网络卡，每个卡都有一个单独的IP地址。你还可以通过别名配置，在一张卡上拥有多个IP地址。另一方面，通过特殊配置，你可以将多张卡合并为一个网络接口，即使有多张卡，计算机仍然只有一个虚拟接口。虽然这些区别很小，但在故障排除时要记住它们。
- en: The IP address 127.0.0.1 is always attached to every host’s loopback interface.
    It can be reached only from the local machine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址127.0.0.1始终附加在每个主机的回环接口上。它只能从本地机器访问。
- en: '**IPv6 Addresses and Subnets**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**IPv6地址和子网**'
- en: The original engineers of IPv4 thought that 4.29 billion IP addresses would
    be enough for the whole world. Computers were expensive, after all, and only military
    and educational systems connected to the internet. It’s not as if every person
    in the world would one day own multiple networked devices.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4的原始工程师认为42.9亿个IP地址足够整个世界使用。毕竟，计算机是昂贵的，只有军事和教育系统才会连接到互联网。并不是每个人都能拥有多个联网设备。
- en: Oops.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。
- en: Unused IPv4 addresses are no longer available. The prices for used IPv4 addresses
    are increasing. Eventually, IPv4 addresses will be priced beyond reach for most
    people. The world is unwillingly groaning toward IPv4’s replacement—IP version
    6.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用的IPv4地址已经不再可用。IPv4地址的价格正在上涨。最终，IPv4地址的价格将高得大多数人无法承受。全世界不得不迈向IPv4的替代者——IP版本6。
- en: Telecom networks and parts of the world outside North America already use IPv6
    pretty widely. Even if your network doesn’t use IPv6 today, one day you’ll unexpectedly
    discover that you needed it the week before.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 电信网络和北美以外地区的部分地区已经广泛使用IPv6。即使你的网络今天没有使用IPv6，总有一天你会突然发现，上一周你就应该使用它了。
- en: '***IPv6 Basics***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***IPv6基础***'
- en: Like IPv4, IPv6 is a network-layer protocol. TCP, UDP, ICMP, and other protocols
    run atop it. Recall that IPv4 uses 32-bit addresses, usually expressed as four
    groups of decimal numbers from 0 to 255—for example, 203.0.113.13\. IPv6 uses
    128-bit addresses, expressed as eight groups of four hexadecimal characters separated
    by colons—for example, 2001:db8:5c00:0:90ff:bad:c0de:cafe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 像 IPv4 一样，IPv6 是一种网络层协议。TCP、UDP、ICMP 和其他协议都运行在它之上。回想一下，IPv4 使用 32 位地址，通常表示为四组十进制数字，每组从
    0 到 255——例如，203.0.113.13。IPv6 使用 128 位地址，表示为八组四个十六进制字符，每组之间用冒号分隔——例如，2001:db8:5c00:0:90ff:bad:c0de:cafe。
- en: A 128-bit address space is unimaginably huge, but let’s try to imagine it. Count
    every human being that’s ever lived. Now count the number of cells in each of
    them—not just in their body but also all the bacterial cells in their bodies.
    IPv6 is roomy enough to assign each of those cells an address space larger than
    the entirety of IPv4.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位的地址空间是难以想象的巨大，但让我们试着想象一下。数一数每一个曾经活过的人的数量。然后计算他们每个人体内的细胞数量——不仅仅是身体中的细胞，还有身体里的所有细菌细胞。IPv6
    足够宽敞，可以为这些细胞中的每一个分配一个比整个 IPv4 地址空间还要大的地址空间。
- en: The good news is that you don’t need to relearn the basics of networking. Hosts
    need an IP address, a netmask, and a default gateway. You can almost—*almost*—substitute
    an IPv6 address for an IPv4 address and watch everything just work. A web server
    doesn’t care whether it binds to port 80 on 203.0.113.13 or 2001:db8:5c00:0:90ff:bad:c0de:cafe.
    The server accepts requests it receives and responds appropriately. That said,
    software does need to change slightly because our web server must be able to log
    connections from both IPv4 and IPv6 addresses. These changes have wide-reaching
    repercussions, and we’ll be discovering new edge cases for decades. But, in general,
    once you understand the new rules for IPv6, all of your networking knowledge is
    applicable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，你不需要重新学习网络的基础知识。主机需要一个 IP 地址、一个子网掩码和一个默认网关。你几乎可以——*几乎*——将 IPv6 地址替换为 IPv4
    地址，并观察一切正常工作。一个 Web 服务器并不关心它是绑定在 203.0.113.13 的 80 端口，还是绑定在 2001:db8:5c00:0:90ff:bad:c0de:cafe
    的 80 端口。服务器接受收到的请求并作出相应的响应。话虽如此，软件的确需要做一些轻微的更改，因为我们的 Web 服务器必须能够记录来自 IPv4 和 IPv6
    地址的连接。这些更改有广泛的影响，我们将在几十年内发现新的边缘案例。但总体而言，一旦你理解了 IPv6 的新规则，你所有的网络知识都是适用的。
- en: '***Understanding IPv6 Addresses***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解 IPv6 地址***'
- en: As noted, IPv6 addresses are 128 bits, expressed as eight colon-delimited groups
    of four hexadecimal characters each. As with decimal IP addresses, you don’t need
    to display leading zeros in each group. The address 2001:db8:5c00:0:90ff:bad:c0de:cafe
    could be written as 2001:0db8:5c00:0000:90ff:0bad:c0de:cafe, but just as we wouldn’t
    write 203.000.113.013, we strip out the leading zeros in an IPv6 address.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，IPv6 地址是 128 位，表示为八组用冒号分隔的每组四个十六进制字符。与十进制的 IP 地址类似，每组中的前导零不需要显示。地址 2001:db8:5c00:0:90ff:bad:c0de:cafe
    可以写成 2001:0db8:5c00:0000:90ff:0bad:c0de:cafe，但就像我们不会写 203.000.113.013 一样，我们会去掉
    IPv6 地址中的前导零。
- en: 'IPv6 addresses often contain long strings of zeros because of the way IPv6
    subnets. As I write this, the IPv6 address of Sprint’s website is 2600:0:0:0:0:0:0:0\.
    When consecutive groups contain only zeros, they’re replaced with two colons.
    You can display this IP address as 2600::. You can do the double-colon substitution
    only once per address, however. Addresses like 2001::a::1 would be ambiguous.
    Does 2001::a::1 represent 2001:0:0:0:0:a:0:1, 2001:0:0:0:a:0:0:1, 2001:0:0: a:0:0:0:1,
    or 2001:0:a:0:0:0:0:0:1? No way to tell.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址通常包含长串的零，这是由于 IPv6 子网的方式所致。当我写这篇文章时，Sprint 网站的 IPv6 地址是 2600:0:0:0:0:0:0:0。连续的零组会被两个冒号替代。你可以将这个
    IP 地址显示为 2600::。但是，你只能在每个地址中做一次双冒号替换。像 2001::a::1 这样的地址将是模棱两可的。2001::a::1 代表 2001:0:0:0:0:a:0:1，2001:0:0:0:a:0:0:1，2001:0:0:a:0:0:0:1，还是
    2001:0:a:0:0:0:0:0:1？没有办法确定。
- en: You’ve probably seen a port number added to an IPv4 address, such as 203.0.113.13:80\.
    Using this terminology with IPv6 addresses would make them even uglier and confuse
    everyone. An IP address and port combination like 2001:db8:5c00:0:90ff:bad:c0de:cafe:80
    is not ambiguous, but unless you read it very carefully, you might think it’s
    an IP address ending in 80\. If you’re expressing an IP and port combination,
    enclose the address in square brackets, as in [2001:db8:5c00:0:90ff:bad:c0de:cafe]:80.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经见过 IPv4 地址后面加上端口号，例如 203.0.113.13:80。将这种术语与 IPv6 地址结合使用会使它们更加丑陋，并且让所有人感到困惑。像
    2001:db8:5c00:0:90ff:bad:c0de:cafe:80 这样的 IP 地址和端口组合并不模糊，但除非你非常仔细阅读，否则你可能会以为它是一个以
    80 结尾的 IP 地址。如果你在表示 IP 和端口组合时，应该将地址用方括号括起来，如 [2001:db8:5c00:0:90ff:bad:c0de:cafe]:80。
- en: '***IPv6 Subnets***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***IPv6 子网***'
- en: 'IPv6 addresses have colons every 16 bits, so the obvious and natural ways to
    divide networks are at the /16, /32, /48, /64, /80, /96, and /112\. The original
    IPv6 standards recommend subnetting only on these boundaries (repeating one of
    IPv4’s greatest mistakes), but that’s increasingly being rejected in favor of
    IPv4-style subnetting anywhere. IPv6 subnets are always expressed as a slash,
    also known as a prefix length, so you won’t see a netmask like ffff:ffff:ffff:ffff::
    analogous to IPv4.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址每16位用冒号分隔，因此划分网络的自然方式通常是/16、/32、/48、/64、/80、/96和/112。原始的IPv6标准建议仅在这些边界进行子网划分（重复了IPv4的一个重大错误），但这一做法正被越来越多的人拒绝，转而支持类似IPv4风格的任意位置子网划分。IPv6子网总是用斜线表示，也称为前缀长度，所以你不会看到类似IPv4的网掩码ffff:ffff:ffff:ffff::。
- en: ISPs are usually issued a /32 or /48 and are expected to issue end-user networks,
    such as a typical client, a /64 network. A /64 has 2^(64) subnets, or 18,446,744,073,709,551,616
    addresses. If your home or office runs out of IP addresses, you need to stop networking
    individual blueberries.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ISP通常会分配一个/32或/48地址块，期望为终端用户网络（例如典型的客户端）分配一个/64的网络。一个/64有2^(64)个子网，即18,446,744,073,709,551,616个地址。如果你家里或办公室的IP地址用完了，你需要停止为每个蓝莓设备单独联网。
- en: When you subnet at 16-bit boundaries, each network has 65,536 subnets of the
    next smaller size. A /32 contains 65,536 /48 networks, and a /48 contains 65,536
    /64 networks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在16位边界进行子网划分时，每个网络会有65,536个下一级子网。一个/32包含65,536个/48网络，一个/48包含65,536个/64网络。
- en: This is a long-winded way of explaining why I don’t provide handy charts of
    IPv6 subnets and network size. Do an internet search for “IPv6 subnet calculator”
    to use one of the many on the internet.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个冗长的解释，说明了为什么我不提供IPv6子网和网络大小的便捷图表。你可以在网上搜索“IPv6子网计算器”来使用互联网上的计算工具。
- en: '***Link-Local Addresses***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***链路本地地址***'
- en: Addresses beginning with *fe8x:* (where *x* is any hexadecimal character) are
    local to their interface. Every interface has such *link-local* addresses that
    are valid only on a specific local network. Even if an IPv6 network has no router,
    hosts on the local directly attached network can find each other and communicate
    using these local addresses. Link-local networks are always /64 subnets. You’ll
    see identical IPv6 subnets on other interfaces and on networks completely disconnected
    from your network. That’s okay. These addresses are local to the link. For example,
    here’s a link-local address from a test machine.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以*fe8x:*开头的地址（其中*x*是任何十六进制字符）是本地接口的地址。每个接口都有这样的*链路本地*地址，这些地址仅在特定的本地网络上有效。即使一个IPv6网络没有路由器，直接附加到本地网络的主机仍然可以使用这些本地地址相互发现并进行通信。链路本地网络始终是/64子网。你会在其他接口以及完全与本地网络断开的网络上看到相同的IPv6子网。这是可以的，这些地址只对链路本地有效。例如，这是一个来自测试机器的链路本地地址。
- en: '[PRE2]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The link-local address of this interface is `fe80::bad:c0de:cafe`. The trailing
    `%vtnet0` indicates that this address is local to the interface `vtnet0` and isn’t
    usable on any other interface on the machine. If your machine has an interface
    vtnet1, and a host on that network tries to reach the address `fe80::bad:c0de:cafe`,
    this machine will not respond. This particular address is valid only for hosts
    on the network segment directly attached to interface `vtnet0`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的链路本地地址是`fe80::bad:c0de:cafe`。结尾的`%vtnet0`表示这个地址只在接口`vtnet0`本地有效，无法在机器上的任何其他接口上使用。如果你的机器有一个`vtnet1`接口，而该网络上的主机试图访问地址`fe80::bad:c0de:cafe`，这台机器不会响应。这个地址仅对直接附加到`vtnet0`接口的网络段上的主机有效。
- en: You might note that the link-local address has a section in common with the
    public IPv6 address on this interface. That’s because an autoconfigured IPv6 address
    is usually calculated from the interface’s physical address; it doesn’t matter
    whether that autoconfigured address is public or local to the link.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，这个链路本地地址和该接口的公共IPv6地址有一部分是相同的。这是因为自动配置的IPv6地址通常是根据接口的物理地址计算出来的；无论该自动配置的地址是公共的还是链路本地的，都没有关系。
- en: '***Assigning IPv6 Addresses***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分配IPv6地址***'
- en: IPv6 clients on a /64 or larger network can normally autoconfigure their network
    through *router discovery*. Router discovery resembles a stripped-down DHCP service.
    The router broadcasts gateway and subnet information, and the hosts configure
    themselves to use it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在/64或更大的网络上，IPv6客户端通常可以通过*路由器发现*自动配置自己的网络。路由器发现类似于简化版的DHCP服务。路由器广播网关和子网信息，主机自我配置以使用这些信息。
- en: Modern versions of router discovery include very basic DHCP-style options, such
    as DNS servers. Not all IPv6 providers include these options in their router discovery
    configuration, however. If you want to provide sophisticated autoconfiguration
    for phones or diskless hosts, or if your provider doesn’t offer DNS information
    in their configuration, you’ll need to set up an IPv6 DHCP server.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现代路由器发现版本包括非常基础的 DHCP 风格选项，如 DNS 服务器。然而，并非所有的 IPv6 提供商在其路由器发现配置中都包括这些选项。如果你想为手机或无盘主机提供复杂的自动配置，或者如果你的提供商没有在其配置中提供
    DNS 信息，你将需要设置一个 IPv6 DHCP 服务器。
- en: Servers should not use IPv6 autoconfiguration. A server usually needs a static
    IP, even in IPv6.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器不应使用 IPv6 自动配置。服务器通常需要一个静态 IP，即使是在 IPv6 中也是如此。
- en: Hosts on a network smaller than /64 must be manually configured.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上小于 /64 的主机必须手动配置。
- en: The address ::1 always represents the local host and is assigned to the loopback
    address.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 ::1 始终表示本地主机，并被分配给回环地址。
- en: '**TCP/IP Basics**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**TCP/IP 基础**'
- en: Now that you have a simple overview of how the IP system works, let’s consider
    the most common network protocols in more depth. The dominant transport protocol
    on the internet is the Transmission Control Protocol over Internet Protocol, or
    TCP/IP. Although TCP is a transport protocol and IP is a network protocol, the
    two are so tightly intertwined that they’re generally referred to as a single
    entity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对 IP 系统的工作原理有了简单的概述，让我们更深入地考虑一下最常见的网络协议。互联网上占主导地位的传输协议是传输控制协议/因特网协议，简称
    TCP/IP。尽管 TCP 是一种传输协议，而 IP 是一种网络协议，但它们紧密交织在一起，通常被视为一个整体。
- en: We’ll start with the simplest, ICMP, and proceed to UDP and TCP. All of these
    protocols run over both IPv4 and IPv6\. While the versions of each protocol vary
    according to the underlying IP protocol, they behave essentially the same.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的 ICMP 开始，然后讨论 UDP 和 TCP。这些协议都可以在 IPv4 和 IPv6 上运行。虽然每种协议的版本根据底层 IP 协议有所不同，但它们的行为基本相同。
- en: '***ICMP***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ICMP***'
- en: The Internet Control Message Protocol (ICMP) is the standard for transmitting
    routing and availability messages across the network. Tools such as ping(8) and
    traceroute(8) use ICMP to gather their results. IPv4 and IPv6 have slightly different
    versions of ICMP, sometimes called *ICMPv4* and *ICMPv6*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因特网控制消息协议（ICMP）是用于传输路由和可用性消息的标准协议。像 ping(8) 和 traceroute(8) 这样的工具使用 ICMP 来收集它们的结果。IPv4
    和 IPv6 有稍微不同版本的 ICMP，有时被称为 *ICMPv4* 和 *ICMPv6*。
- en: While some people claim that you must block ICMP for security reasons, ICMP
    is just as diverse as the better-understood protocols TCP and UDP. Proper IPv4
    network performance requires large chunks of ICMPv4\. If you feel you must block
    ICMP, do so selectively. For example, blocking source quench messages breaks path
    maximum transmission unit (pMTU) discovery, which is like faceplanting into a
    crate of broken glass and rusty nails. If you don’t understand that last sentence,
    don’t block ICMP.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有人声称出于安全原因必须阻止 ICMP，但 ICMP 和我们更熟悉的协议 TCP 和 UDP 一样具有多样性。正确的 IPv4 网络性能需要大量的
    ICMPv4。如果你觉得必须阻止 ICMP，应该选择性地进行。例如，阻止源抑制消息会破坏路径最大传输单元（pMTU）发现，就像跌进一箱破碎的玻璃和生锈的钉子里。如果你不明白这句话的意思，那么不要阻止
    ICMP。
- en: IPv6 dies without ICMPv6, as IPv6 doesn’t support packet fragmentation. If you
    use IPv6, never block ICMPv6 as a whole. Blocking parts of ICMPv6 without destroying
    your network requires careful research and testing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 在没有 ICMPv6 的情况下无法正常工作，因为 IPv6 不支持数据包分片。如果你使用 IPv6，绝对不要完全阻止 ICMPv6。阻止 ICMPv6
    的某些部分而不破坏你的网络需要仔细研究和测试。
- en: '***UDP***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***UDP***'
- en: The User Datagram Protocol (UDP) is the most bare-bones data transfer protocol
    that runs over IP. It has no error handling, minimal integrity verification, and
    no defense whatsoever against data loss. Despite these drawbacks, UDP can be a
    good choice for particular sorts of data transfer, and many vital internet services
    rely on it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 用户数据报协议（UDP）是最基础的数据传输协议，运行在 IP 之上。它没有错误处理，最小的完整性验证，并且完全没有防止数据丢失的机制。尽管有这些缺点，UDP
    仍然是某些类型数据传输的一个不错选择，许多重要的互联网服务依赖于它。
- en: When a host transmits data via UDP, the sender has no way of knowing whether
    the data ever reached its destination. Programs that receive UDP data simply listen
    to the network and accept what happens to arrive. When a program receives data
    via UDP, it cannot verify the source of that data—while a UDP packet includes
    a source address, this address is easily faked. This is why UDP is called *connectionless*,
    or *stateless*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机通过 UDP 传输数据时，发送方无法知道数据是否到达了目的地。接收 UDP 数据的程序只是监听网络，并接受到达的任何数据。当程序通过 UDP 接收数据时，它无法验证数据的来源——尽管
    UDP 数据包包含源地址，但这个地址很容易被伪造。这就是为什么 UDP 被称为*无连接*或*无状态*的原因。
- en: With all of these drawbacks, why use UDP at all? Applications that use UDP most
    often have their own error-correction handling methods that don’t mesh well with
    the defaults provided by protocols such as TCP. For example, simple client DNS
    queries must time out within just a few seconds or the user will call the helpdesk
    and whine. TCP connections time out only after two minutes. Since the computer
    wants to handle its failed DNS requests much more quickly, simple DNS queries
    use UDP. In cases where DNS must transfer larger amounts of data (for example,
    for zone transfers), it intelligently switches to TCP. Real-time streaming data,
    such as video conferencing, also uses UDP. If you miss a few pixels of the picture
    in a real-time video conference, retransmitting that data would simply add congestion.
    You can’t go back in time to fill in those missing chunks of the picture, after
    all! You’ll find similar reasoning behind almost all other network applications
    that use UDP.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 既然有这么多缺点，为什么还要使用 UDP 呢？使用 UDP 的应用程序通常会有自己的错误校正处理方法，这些方法与 TCP 等协议提供的默认机制不太兼容。例如，简单的客户端
    DNS 查询必须在几秒钟内超时，否则用户会打电话到帮助台抱怨。TCP 连接在两分钟后才会超时。由于计算机希望更快地处理失败的 DNS 请求，简单的 DNS
    查询使用 UDP。在需要传输大量数据的 DNS 情况下（例如，区域传送），它会智能地切换到 TCP。实时流数据，如视频会议，也使用 UDP。如果在实时视频会议中错过了一些像素，重新传输这些数据只会增加拥堵。毕竟，你无法回到过去来填补那些丢失的图片部分！几乎所有其他使用
    UDP 的网络应用程序背后都可以找到类似的理由。
- en: Because the UDP protocol itself doesn’t return anything when you connect to
    a port, there’s no reliable way to remotely test whether a UDP port is reachable
    (although tools like nmap try to do so).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 UDP 协议本身在连接到端口时不会返回任何信息，因此没有可靠的方法可以远程测试 UDP 端口是否可达（尽管像 nmap 这样的工具会尝试执行此操作）。
- en: UDP is also a *datagram* protocol, meaning that each network transmission is
    complete, self-contained, and received as a single integral unit. While the application
    might not consider a single UDP packet a complete request, the network does. TCP
    is entirely different.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 也是一种*数据报*协议，这意味着每个网络传输都是完整的、自包含的，并作为一个单独的整体单元接收。虽然应用程序可能不会将单个 UDP 数据包视为一个完整的请求，但网络会这样做。TCP
    则完全不同。
- en: '***TCP***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TCP***'
- en: The Transmission Control Protocol (TCP) includes such nifty features as error
    correction and recovery. The receiver must acknowledge every packet it gets; otherwise,
    the sender will retransmit any unacknowledged packets. Applications that use TCP
    can expect reliable data transmission. This makes TCP a *connected*, or *stateful*,
    protocol, unlike UDP.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 传输控制协议（TCP）包括如错误修正和恢复等巧妙功能。接收方必须确认每个收到的数据包；否则，发送方会重新传输任何未被确认的数据包。使用 TCP 的应用程序可以期待可靠的数据传输。这使得
    TCP 成为*连接型*或*有状态*协议，与 UDP 截然不同。
- en: TCP is also a *streaming* protocol, meaning that a single request can be split
    amongst several network packets. While the sender might transmit several chunks
    of data one after the other, the recipient could receive them out of order or
    fragmented. The recipient must keep track of these chunks and assemble them properly
    to complete the network transaction.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 也是一种*流式*协议，这意味着一个请求可能会被拆分成多个网络数据包。虽然发送方可能会依次传输多个数据块，但接收方可能会收到乱序或分片的数据。接收方必须跟踪这些数据块，并将其正确组装，以完成网络事务。
- en: For two hosts to exchange TCP data, they must set up a channel for that data
    to flow across. One host requests a connection, the other host responds to the
    request, and then the first host starts transmitting. This setup process is known
    as the *three-way handshake*. The specifics are not important right now, but you
    should know that this process happens. Similarly, once transmission is complete,
    the systems must do a certain amount of work to tear down the connections.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让两台主机交换 TCP 数据，它们必须建立一个通道来传输数据。一台主机请求连接，另一台主机响应请求，然后第一台主机开始传输。这个设置过程被称为*三次握手*。具体细节现在不重要，但你应该知道这个过程的存在。类似地，一旦传输完成，系统必须执行一定的操作来拆除连接。
- en: TCP is commonly used by applications—such as email programs, FTP clients, and
    web browsers—for its fairly generic set of timeouts and transmission features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 常常被应用程序使用，例如邮件程序、FTP 客户端和网页浏览器，因为它有一个相对通用的超时和传输功能集。
- en: '***How Protocols Fit Together***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***协议如何协同工作***'
- en: You can compare the network stack to sitting with your family at a holiday dinner.
    The datalink layer (ARP, in the case of IPv4 over Ethernet) lets you see everyone
    else at the table. IP gives every person at the table a unique chair, except for
    the three young nephews using piano bench NAT. ICMP provides basic routing information,
    such as, “The quickest way to the peas is to ask Uncle Chris to hand them to you.”
    TCP is where you hand someone a dish and the other person must say, “Thanks,”
    before you let go. Finally, UDP is like tossing a roll at Aunt Betty; she might
    catch it, it might bounce off her forehead, or it could be snatched out of midair
    by the dog who has watched for her opportunity since the meal began.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把网络协议栈比作和家人一起坐在节日聚餐桌前。数据链路层（在 IPv4 通过以太网时是 ARP）让你看到桌上的每个人。IP 给每个人分配一个独特的座位，除了那三个用钢琴凳
    NAT 的年轻侄子。ICMP 提供基本的路由信息，例如，“到豌豆的最快方式是让克里斯叔叔递给你。”TCP 是你递给别人一道菜，另一个人必须说“谢谢”，你才能放手。最后，UDP
    就像是把一个面包滚向贝蒂阿姨；她可能会接住，可能会从额头弹开，或者可能会被在饭桌旁等机会的狗从空中抓住。
- en: '***Transport Protocol Ports***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***传输协议端口***'
- en: Have you ever noticed that computers have too many ports? We’re going to add
    TCP and UDP ports into the stew. *Transport protocol ports* permit one server
    to serve many different services over a single transport protocol, multiplexing
    connections between machines.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到计算机有太多的端口？我们要在这道汤中加入 TCP 和 UDP 端口。*传输协议端口*允许一个服务器通过一个传输协议提供许多不同的服务，实现机器之间连接的复用。
- en: When a network server program starts, it attaches, or *binds*, to one or more
    logical ports. A logical port is just an arbitrary number ranging from 1 to 65535\.
    For example, internet mail servers bind to TCP port 25\. Each TCP or UDP packet
    arriving at a system has a field indicating its desired destination port. Each
    incoming request is flagged with a desired destination port number. If an incoming
    request asks for port 25, it’s connected to the mail server listening on that
    port. This means that other programs can run on different ports, clients can talk
    to those different ports, and nobody except the sysadmin gets confused.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个网络服务器程序启动时，它会附加或*绑定*到一个或多个逻辑端口。逻辑端口只是一个从 1 到 65535 的任意数字。例如，互联网邮件服务器绑定到 TCP
    端口 25。每个到达系统的 TCP 或 UDP 数据包都有一个字段，指示它希望的目标端口。每个传入请求都会标记一个目标端口号。如果传入请求请求端口 25，它会连接到在该端口上监听的邮件服务器。这意味着其他程序可以在不同的端口上运行，客户端可以与这些不同的端口通信，除非是系统管理员，否则没有人会感到困惑。
- en: The */etc/services* file contains a list of port numbers and the services that
    they’re commonly associated with. It’s possible to run almost any service on any
    port, but by doing so, you’ll confuse other internet hosts that try to connect
    to your system. If someone tries to send you email, their mail program automatically
    connects to port 25 on your system. If you run email on port 77 and you have a
    web server on port 25, you’ll never get your email and your web server will start
    receiving spam. The */etc/services* file has a very simple five-column format.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/services* 文件包含了一份端口号及其常用服务的列表。几乎可以在任何端口上运行任何服务，但这样做会让其他试图连接到你系统的互联网主机感到困惑。如果有人尝试向你发送电子邮件，他们的邮件程序会自动连接到你系统的端口
    25。如果你把邮件服务运行在端口 77，而你在端口 25 上有一个 Web 服务器，你将永远收不到邮件，且你的 Web 服务器将开始收到垃圾邮件。*/etc/services*
    文件有一个非常简单的五列格式。'
- en: '[PRE3]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the entry for the `qotd` service ➊, which runs on port 17 ➋ in the TCP
    protocol ➌. It’s also known as the `quote` service ➍. Finally, we have a comment
    ➎ that provides more detail; apparently *qotd* stands for *quote of the day*.
    Services are assigned the same port number in both TCP and UDP, even though they
    usually run only on one and not the other—for example, qotd has ports 17/tcp and
    17/udp.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`qotd`服务的条目 ➊，它在TCP协议中运行在17端口 ➋。它也被称为`quote`服务 ➍。最后，我们有一个评论 ➎，提供了更多的细节；显然，*qotd*代表*每日一句*。服务在TCP和UDP协议中都分配相同的端口号，尽管它们通常只在其中一个协议上运行而不是另一个——例如，qotd有17/tcp和17/udp端口。
- en: Many server programs read */etc/services* to learn which port to bind to on
    startup, while client programs read */etc/services* to learn which port they should
    try to connect to. If you run servers on unusual ports, you might have to edit
    this file to tell the server where to attach to.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 许多服务器程序会读取*/etc/services*文件，以了解启动时应该绑定到哪个端口，而客户端程序会读取*/etc/services*文件，以了解它们应该尝试连接到哪个端口。如果你在非标准端口上运行服务器，可能需要编辑这个文件来告知服务器应该连接到哪个端口。
- en: As in all standards, there are often good reasons for breaking the rules. The
    SSH daemon, sshd, normally listens on port 22/tcp, but I’ve run it on ports 23
    (telnet), 80 (HTTP), and 443 (HTTPS) for various reasons. Configuring this depends
    on the server program you’re using.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所有标准一样，常常有充分的理由去打破规则。SSH守护进程sshd通常监听22/tcp端口，但我曾出于各种原因将其运行在23（telnet）、80（HTTP）和443（HTTPS）端口上。配置这一点取决于你所使用的服务器程序。
- en: '**Reserved Ports**'
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**保留端口**'
- en: Ports below 1024 in both TCP and UDP are called *reserved ports*. These ports
    are assigned only to core internet infrastructure and important services such
    as DNS, SSH, HTTP, LDAP, and so on—services that should legitimately be offered
    only by a system or network administrator. Only programs with root-level privileges
    can bind to low-numbered ports. A user can provide, say, a game server on a high-numbered
    port if the system policy allows—but that’s a little different from setting up
    an official-looking web page that’s visible to everyone and states that the main
    purpose of the machine is to be a game server! The port assignment for these core
    protocols is generally carved in stone.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP协议中低于1024的端口被称为*保留端口*。这些端口只分配给核心互联网基础设施和重要服务，如DNS、SSH、HTTP、LDAP等——这些服务应该仅由系统或网络管理员合法提供。只有具有根用户权限的程序才能绑定到这些低编号的端口。用户可以在系统策略允许的情况下，在高编号端口上提供比如游戏服务器等服务——但这与设置一个公开可见并声明机器主要用途是游戏服务器的正式网页有些不同！这些核心协议的端口分配通常是固定的。
- en: You can view and change the reserved ports with the sysctls `net.inet.ip.portrange.reservedhigh`
    and `net.inet.ip.portrange.reservedlow`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用sysctl命令`net.inet.ip.portrange.reservedhigh`和`net.inet.ip.portrange.reservedlow`查看和更改保留端口。
- en: Every so often, someone thinks that they can disable this “bind-only-by-root”
    feature and increase their system’s security—after all, if your application can
    be run as a regular user instead of root, wouldn’t that increase system security?
    Most programs that run on reserved ports actually start as root, bind to the port,
    and then drop privileges to a special restricted user that has even less privilege
    than a regular user. These programs are designed to start as root and frequently
    behave differently when run as a regular user. A few programs, such as the Apache
    web server, are written so they can be started safely by a non-root user, but
    others are not.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，某些人认为他们可以禁用这个“仅根用户绑定”功能，从而提高系统的安全性——毕竟，如果你的应用程序可以作为普通用户而非根用户运行，这是否会增加系统的安全性呢？大多数在保留端口上运行的程序实际上是以根用户身份启动，绑定端口后，再将权限降级为一个权限比普通用户更少的特殊限制用户。这些程序设计上就是以根用户启动，并且在以普通用户身份运行时通常会表现得不同。一些程序，如Apache
    Web服务器，编写时已考虑到可以由非根用户安全启动，但其他程序则没有。
- en: '**Understanding Ethernet**'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解以太网**'
- en: Ethernet is extremely popular in corporate and home networks and is the most
    common connection media for FreeBSD systems. Ethernet is a shared network; many
    different machines can connect to the same Ethernet and can communicate directly
    with each other. This gives Ethernet a great advantage over other network protocols,
    but Ethernet has physical distance limitations that make it practical only for
    offices, co-location facilities, and other comparatively small networks.^([6](footnote.xhtml#ch07fn6))
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网在企业和家庭网络中极为流行，也是FreeBSD系统最常见的连接介质。以太网是一个共享网络；许多不同的机器可以连接到同一个以太网，并可以直接相互通信。这使得以太网相较于其他网络协议具有很大优势，但以太网也有物理距离限制，这使得它仅适用于办公室、共置设施和其他相对较小的网络。^([6](footnote.xhtml#ch07fn6))
- en: Many different physical media have supported Ethernet over the years. Once upon
    a time, most Ethernet cables were thick chunks of coaxial cable. Today, most are
    comparatively thin CAT6 cables with eight strands of very thin wire inside them.
    You might also encounter Ethernet over optical fiber or radio. For purposes of
    our discussion, we’ll assume that you’re working with CAT6 or better cable, today’s
    most popular choice. No matter what physical media you use, the theory of Ethernet
    doesn’t change—remember, the physical layer is abstracted away.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 多种不同的物理介质在过去多年里都支持以太网。曾几何时，大多数以太网电缆都是厚重的同轴电缆。如今，大多数则是相对较薄的CAT6电缆，内部有八根非常细的导线。你还可能遇到光纤或无线电上的以太网。为了便于讨论，我们假设你使用的是CAT6或更高规格的电缆，这是目前最流行的选择。无论你使用什么物理介质，以太网的理论并不会改变——记住，物理层已经被抽象化。
- en: '***Protocol and Hardware***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***协议和硬件***'
- en: Ethernet is a broadcast protocol, which means that every packet you send on
    the network can be sent to every workstation on the network. (Note that I said
    *can be*; some Ethernet hardware limits recipients of these broadcasts.) Either
    your network card or its device driver separates the data intended for your computer
    from the data meant for other computers. One side effect of Ethernet’s broadcast
    nature is that you can eavesdrop on other computers’ network traffic. While this
    can be very useful when diagnosing problems, it’s also a security issue. Capturing
    clear-text passwords is trivial on an old-fashioned Ethernet. A section of Ethernet
    where all hosts can communicate directly with all other hosts without involving
    a router is called a *broadcast domain*, or *segment*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网是一种广播协议，这意味着你在网络上发送的每个数据包都可以发送到网络上的每个工作站。（注意，我说的是*可以发送*；一些以太网硬件限制了这些广播的接收者。）你的网卡或其设备驱动程序将目标是你计算机的数据与目标是其他计算机的数据分开。以太网广播特性的一种副作用是，你可以窃听其他计算机的网络流量。虽然这在诊断问题时非常有用，但它也是一个安全隐患。在传统的以太网上捕获明文密码是很简单的。所有主机可以直接与所有其他主机通信而不涉及路由器的以太网部分被称为*广播域*或*段*。
- en: Ethernet segments are connected via hubs or switches. An Ethernet *hub* is a
    central piece of hardware to physically connect many other Ethernet devices. Hubs
    simply forward all received Ethernet frames to every other device attached to
    the network. Hubs broadcast all Ethernet traffic that they receive to every attached
    host and other attached hubs. Each host is responsible for filtering out the traffic
    it doesn’t want. Hubs are old-school Ethernet and rarely seen today.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网段通过集线器或交换机连接。以太网*集线器*是一个中央硬件设备，用来物理连接多个其他以太网设备。集线器只是简单地将收到的所有以太网帧转发给连接到网络的其他设备。集线器将收到的所有以太网流量广播到每个附加的主机和其他连接的集线器。每个主机负责过滤掉它不需要的流量。集线器是老式的以太网设备，现在很少见了。
- en: '*Switches* have largely supplanted hubs. A switch is like a hub, but it filters
    which traffic it sends to each host. It identifies the physical addresses of attached
    devices and, for the most part, forwards frames only to the devices they are meant
    for. Since each Ethernet host has a finite amount of bandwidth, switching reduces
    the load on individual systems by decreasing the amount of traffic each host must
    sort through.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*交换机*已经大多取代了集线器。交换机就像集线器，但它会过滤掉发送到每个主机的流量。它识别附加设备的物理地址，并在大多数情况下，仅将帧转发到它们所指向的设备。由于每个以太网主机的带宽是有限的，交换通过减少每个主机必须处理的流量，来减轻单个系统的负担。'
- en: '**Switch Failure**'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**交换机故障**'
- en: Switches fail, despite what Cisco would have you believe. Some failures are
    obvious, such as those where the magic black smoke is leaking out of the back
    of the box. When a switch loses its magic smoke, it stops working. Others are
    more subtle and make it appear that the switch is still working.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 交换机会发生故障，尽管思科公司可能不希望你这样认为。一些故障很明显，例如当神秘的黑烟从设备后面泄漏出来时。当交换机失去它的“魔法烟雾”时，它就停止工作了。还有一些故障较为微妙，看起来交换机依然在工作。
- en: Every switch manufacturer must decide how to handle subtle errors. Either the
    switch can shut down until it is attended to, or it can attempt to alert its manager
    and continue forwarding packets to the best of its ability. If you’re a vendor,
    the choice is obvious—you stumble along as best you can so your customers don’t
    think your switches are crap. This means your switch can start to act like a hub
    and you might not know about it. The bad news is that if you were relying on the
    switch to prevent leakage of secure information, you’re fated for disappointment.
    More than one switch has failed on me in this way, so don’t be too surprised when
    it happens to you.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个交换机制造商必须决定如何处理细微的错误。交换机可以选择关闭，直到有人处理，或者尝试向管理员发出警告并继续尽力转发数据包。如果你是供应商，选择显而易见——你尽最大努力让你的客户不认为你的交换机是垃圾。这意味着你的交换机可能会开始像集线器一样工作，而你可能并不知道。坏消息是，如果你依赖交换机来防止机密信息泄漏，你将注定失望。已经有不止一台交换机以这种方式失败过，所以当它发生在你身上时，别太惊讶。
- en: Installing a syslog server (see [Chapter 21](ch21.xhtml#ch21)) and having your
    switches log to it can mitigate this risk. While logging won’t prevent switch
    failure, it will simplify listening to a dying switch when it tries to complain.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 安装一个syslog服务器（参见[第21章](ch21.xhtml#ch21)）并让你的交换机将日志发送到它，可以降低这个风险。虽然日志记录无法防止交换机故障，但它将简化当交换机开始出现问题时，倾听其抱怨的过程。
- en: '**Ethernet Speed**'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**以太网速度**'
- en: Ethernet originally supported only a couple of megabits per second but has expanded
    to handle tens-of-gigabits speeds. Most Ethernet cards are *gigabit* speed, meaning
    they can handle a gigabit per second, but you’ll find a few 10Gbs or 100Gbs cards
    in high-speed applications. If a card is labeled *gigabit*, it doesn’t mean it
    can actually push that much traffic—I’ve seen gigabit cards choke on a tenth that
    much bandwidth. Card quality is important when you want to push bandwidth, and
    the quality of the entire computer is important when pushing serious bandwidth.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网最初只支持每秒几兆比特的速度，但现在已经扩展到能够处理数十吉比特的速度。大多数以太网卡的速度是*千兆*，意味着它们每秒可以处理一个千兆比特的数据，但在高速应用中你会找到一些10Gbs或100Gbs的卡。如果一张卡被标记为*千兆*，并不意味着它实际上能够处理这么大的流量——我见过千兆卡在只有十分之一带宽的情况下就卡住了。当你需要推送带宽时，卡的质量很重要，而当你推送大量带宽时，整个计算机的质量也非常重要。
- en: Let the switch and the card negotiate their settings on their own through *autonegotiation*.
    While some old hands might remember disabling autonegotiation on older Ethernet
    cards, gigabit and faster Ethernet requires autonegotiation to function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让交换机和网卡通过*自动协商*自行协商它们的设置。虽然一些经验丰富的人可能记得在旧版以太网卡上禁用自动协商，但千兆及更高速率的以太网要求自动协商才能正常工作。
- en: '***MAC Addresses***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***MAC地址***'
- en: Every Ethernet card has a unique identifier, a Media Access Control (MAC) address.
    This 48-bit number is sometimes called an *Ethernet address* or *physical address*.
    When a system transmits data to another host on the Ethernet, it first broadcasts
    an Ethernet request asking, “Which MAC address is responsible for this IP address?”
    If a host responds with its MAC address, further data for that IP is transmitted
    to that MAC address.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个以太网卡都有一个唯一的标识符，即媒体访问控制（MAC）地址。这个48位的数字有时被称为*以太网地址*或*物理地址*。当一个系统向另一个主机发送数据时，它首先广播一个以太网请求，询问：“哪个MAC地址负责这个IP地址？”如果主机用它的MAC地址作出回应，进一步的数据就会传输到那个MAC地址。
- en: IPv4 uses the Address Resolution Protocol (ARP) to map IP addresses to hosts.
    Use arp(8) to view your FreeBSD system’s knowledge of the ARP table. The most
    common usage is the `arp -a` command, which shows all of the MAC addresses and
    hostnames that your computer knows of.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4使用地址解析协议（ARP）将IP地址映射到主机。使用arp(8)命令查看你的FreeBSD系统对ARP表的了解。最常见的用法是`arp -a`命令，它显示计算机已知的所有MAC地址和主机名。
- en: '[PRE4]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This full listing of ARP information is known as the *ARP table*, or *MAC table*.
    (The terms MAC and ARP are frequently used interchangeably, so don’t worry about
    it too much.) Here we see that the host *gw.blackhelicopters.org* has an IP address
    of 198.51.100.1 and a MAC address of 00:00:93:34:4e:78, and that you can reach
    these hosts on the local system’s interface, `igb0`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整的ARP信息列表被称为*ARP表*，或*MAC表*。（术语MAC和ARP常常可以互换使用，所以不用太担心这个问题。）在这里，我们看到主机*gw.blackhelicopters.org*的IP地址是198.51.100.1，MAC地址是00:00:93:34:4e:78，并且你可以通过本地系统的接口`igb0`访问这些主机。
- en: If a MAC address shows up as `incomplete`, the host cannot be contacted on the
    local Ethernet. In this case, check your physical layer (the wire), the remote
    system, and the configuration of both systems.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果MAC地址显示为`incomplete`，则表示无法在本地以太网中联系到该主机。在这种情况下，检查你的物理层（电缆）、远程系统以及两者的配置。
- en: IPv6 uses Neighbor Discovery Protocol (NDP) to map IPv6 addresses to MAC addresses.
    It’s a separate protocol from ARP to encompass router discovery. Use ndp(8) to
    view the host’s MAC table and corresponding IPv6 addresses. The output deliberately
    resembles that of arp(1).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6使用邻居发现协议（NDP）将IPv6地址映射到MAC地址。这是一个与ARP不同的独立协议，用于包括路由器发现。使用ndp(8)查看主机的MAC表和对应的IPv6地址。输出故意与arp(1)类似。
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output deliberately resembles that of arp(8) but is slightly more tabular.
    The `Neighbor` column shows either the IPv6 address, the hostname, or the link-local
    address of each neighbor. The `Linklayer Address` column shows the MAC address
    of the neighbor. The `Netif` column displays the network interface this host is
    attached to, while the `Expire` column shows when the cached entry will expire.
    The `S` (state) column shows further information about the entry. A state of `R`
    means the host is reachable, while an `I` (incomplete) means the host is unreachable.
    The only `Flags` entry you’re likely to see is `R`, indicating this host is advertising
    itself as a router. For more states and flags, see ndp(8).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 输出故意与arp(8)类似，但略显表格化。`Neighbor`列显示每个邻居的IPv6地址、主机名或链路本地地址。`Linklayer Address`列显示邻居的MAC地址。`Netif`列显示该主机所连接的网络接口，而`Expire`列显示缓存条目将过期的时间。`S`（状态）列提供有关条目的进一步信息。`R`状态表示主机是可达的，而`I`（incomplete）表示主机不可达。你可能看到的唯一`Flags`条目是`R`，表示该主机正在将自己广告为路由器。有关更多状态和标志，请参见ndp(8)。
- en: Why two separate commands? Both arp(8) and ndp(8) exist to map IP addresses
    to MAC addresses. Some hosts might be available only via one protocol or the other.
    IPv6-only hosts will not show up in your ARP table, and IPv4-only hosts will not
    appear in the NDP table.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有两个独立的命令？arp(8)和ndp(8)都用于将IP地址映射到MAC地址。有些主机可能仅通过其中一个协议或另一个协议可用。仅支持IPv6的主机不会出现在你的ARP表中，而仅支持IPv4的主机则不会出现在NDP表中。
- en: For both arp(8) and ndp(8), the `-n` flag turns off hostname lookups. This is
    highly useful when you debug network issues and can’t get DNS resolution.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于arp(8)和ndp(8)命令，`-n`标志会关闭主机名查找。当你在调试网络问题并且无法获取DNS解析时，这个功能非常有用。
- en: Now that you know how the network works, configuring an internet connection
    is pretty straightforward.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了网络的工作原理，配置互联网连接就非常简单了。
