- en: '**0 Randomness**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**0 随机性**'
- en: '*The generation of random numbers is too important to be left to chance.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机数的生成太重要了，不能交给运气。*'
- en: —Robert R. Coveyou
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —罗伯特·R·科维尤
- en: '![Image](../images/pg41_Image_7.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg41_Image_7.jpg)'
- en: '**Random number tables from *A Million Random Digits with 100,000 Normal Deviates*
    by the RAND Corporation**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**《百万随机数字与100,000个正态偏差》中的随机数字表，由兰德公司提供**'
- en: In 1947, the RAND Corporation produced a peculiar book titled *A Million Random
    Digits with 100,000 Normal Deviates*. The book wasn’t a work of literature or
    a philosophical treatise on randomness. Rather, it was a table of random numbers
    generated using an electronic simulation of a roulette wheel. This book was one
    of the last in a series of random-number tables produced from the mid-1920s to
    the 1950s. With the development of high-speed computers, it became faster to generate
    pseudorandom numbers than to read them from tables, and so this era of printed
    random-number tables ultimately came to an end.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 1947年，兰德公司出版了一本名为*《百万随机数字与100,000个正态偏差》*的奇特书籍。这本书不是一部文学作品，也不是关于随机性的哲学论文。而是一本包含随机数字的表格，这些数字是通过电子模拟的轮盘赌产生的。这本书是从20世纪20年代中期到50年代，兰德公司出版的最后一部随机数字表之一。随着高速计算机的发展，生成伪随机数字比从表格中读取它们更快，因此这时代的打印随机数字表最终也走向了终结。
- en: 'Here we are: the beginning. If it’s been a while since you’ve programmed in
    JavaScript (or done any math, for that matter), this chapter will reacquaint your
    mind with computational thinking. To start your coding-of-nature journey, I’ll
    introduce you to some foundational tools for programming simulations: random numbers,
    random distributions, and noise. Think of this as the first (zeroth!) element
    of the array that makes up this book—a refresher and a gateway to the possibilities
    that lie ahead.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在这里：起点。如果你有一段时间没有编写JavaScript代码（或者做任何数学运算），这一章将帮助你重新熟悉计算思维。为了开始你的自然编程之旅，我将向你介绍一些编程模拟的基础工具：随机数、随机分布和噪声。把这看作是组成本书的数组中的第一个（零）元素——一个复习和通往未来可能性的门户。
- en: '![Image](../images/pg42_Image_8.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg42_Image_8.jpg)'
- en: 'In [Chapter 1](ch01.xhtml#ch01), I’m going to talk about the concept of a vector
    and how it will serve as the building block for simulating motion throughout this
    book. But before I take that step, let’s think about what it means for something
    to move around a digital canvas. I’ll begin with one of the best-known and simplest
    simulations of motion: the random walk.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch01)中，我将讨论向量的概念，以及它如何成为本书中模拟运动的构建块。但在我迈出这一步之前，让我们先思考一下让某物在数字画布上移动意味着什么。我将从最著名且最简单的运动模拟之一开始：随机漫步。
- en: '**Random Walks**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**随机漫步**'
- en: Imagine you’re standing in the middle of a balance beam. Every 10 seconds, you
    flip a coin. Heads, take a step forward. Tails, take a step backward. This is
    a **random walk**, a path defined as a series of random steps. Stepping (carefully)
    off that balance beam and onto the floor, you could expand your random walk from
    one dimension (moving only forward and back) to two dimensions (moving forward,
    back, left, and right). Now that there are four possibilities, you’d have to flip
    the same coin twice to determine each next step.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你站在一根平衡木的中央。每隔 10 秒钟，你就抛一次硬币。正面，向前迈一步。反面，向后退一步。这就是**随机漫步**，一条由一系列随机步骤定义的路径。小心地从平衡木上走到地面上，你可以将你的随机漫步从一维（仅向前和向后移动）扩展到二维（向前、向后、向左、向右移动）。现在有了四种可能性，你需要抛两次硬币来确定每一步。
- en: '|  **Flip 1**  | **Flip 2** | **Result** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **投掷 1** | **投掷 2** | **结果** |'
- en: '| --- | --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Heads | Heads | Step forward. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 正面 | 正面 | 向前迈步。 |'
- en: '| Heads | Tails | Step right. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 正面 | 反面 | 向右迈步。 |'
- en: '| Tails | Heads | Step left. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 反面 | 正面 | 向左迈步。 |'
- en: '| Tails | Tails | Step backward. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 反面 | 反面 | 向后退步。 |'
- en: 'This may seem like an unsophisticated algorithm, but you can use random walks
    to model all sorts of phenomena that occur in the real world, from the movements
    of molecules in a gas, to the foraging of an animal, to the behavior of a gambler
    spending a day at the casino. For our purposes, the random walk is the perfect
    place to start for three reasons:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个简单的算法，但你可以使用随机漫步来模拟现实世界中发生的各种现象，从气体中分子运动，到动物觅食，再到赌徒在赌场度过的一天。对于我们的目的来说，随机漫步是一个完美的起点，原因有三：
- en: 'I’d like to review a programming concept central to this book: object-oriented
    programming (OOP). The random walker I’m about to create will serve as a template
    for using object-oriented design to make things that move around a computer graphics
    canvas.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想回顾一下本书的核心编程概念：面向对象编程（OOP）。我即将创建的随机行走者将作为使用面向对象设计在计算机图形画布上制作移动对象的模板。
- en: 'The random walk instigates the two questions that I’ll ask over and over again
    throughout this book: “How do you define the rules that govern the behavior of
    your objects?” and then, “How do you implement these rules in code?”'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机游走引出了我将在本书中反复提问的两个问题：“如何定义支配对象行为的规则？”然后是，“如何在代码中实现这些规则？”
- en: You’ll periodically need a basic understanding of randomness, probability, and
    Perlin noise for this book’s projects. The random walk will allow me to demonstrate
    key points that will come in handy later.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书的项目中，您将定期需要了解基本的随机性、概率和 Perlin 噪声。随机游走将帮助我展示一些关键点，这些点稍后会派上用场。
- en: I’ll first review a bit of OOP by coding a `Walker` class to create `Walker`
    objects that can go for a random walk. This will be only a cursory review. If
    you’ve never worked with OOP before, you may want something more comprehensive;
    I’d suggest stopping here and reviewing the “Objects” section of my “Code! Programming
    with p5.js” video course at the Coding Train website (*[https://thecodingtrain.com/objects](https://thecodingtrain.com/objects)*).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过编写一个`Walker`类来回顾一下面向对象编程（OOP），创建可以进行随机行走的`Walker`对象。这将只是一个简要回顾。如果你以前没有使用过OOP，你可能需要更全面的讲解；我建议你停下来，查看我的“Code!
    Programming with p5.js”视频课程中的“对象”章节，网址是(*[https://thecodingtrain.com/objects](https://thecodingtrain.com/objects)*)。
- en: '**The Random Walker Class**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**随机行走者类**'
- en: An **object** in JavaScript is an entity that has both data and functionality.
    In this case, a `Walker` object should have data about its position on the canvas
    and functionality such as the capability to draw itself or take a step.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，**对象**是一个具有数据和功能的实体。在这个例子中，`Walker`对象应该包含关于其在画布上位置的数据和一些功能，比如能够绘制自己或执行一步。
- en: A **class** is the template for building actual instances of objects. Think
    of a class as the cookie cutter and objects as the cookies themselves. To create
    a `Walker` object, I’ll begin by defining the `Walker` class—what it means to
    be a walker.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**是构建实际对象实例的模板。可以把类想象成饼干模具，而对象则是实际的饼干。为了创建一个`Walker`对象，我将首先定义`Walker`类——即什么是一个行走者。'
- en: 'A walker needs only two pieces of data: a number for its x-position and a number
    for its y-position. I’ll initialize them to the center of the canvas to set the
    object’s starting position. I can do this in the class’s **constructor** function,
    appropriately named `constructor()`. You can think of the constructor as the object’s
    `setup()` function. It’s responsible for defining the initial properties of an
    object, much like `setup()` does for the entire sketch:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个行走者只需要两块数据：一个是它的 x 坐标，另一个是它的 y 坐标。我将把它们初始化为画布的中心，设置对象的起始位置。我可以在类的**构造函数**中完成这项工作，构造函数的名称是`constructor()`。你可以将构造函数看作对象的`setup()`函数。它负责定义对象的初始属性，类似于`setup()`函数为整个草图所做的工作：
- en: '![Image](../images/pg44_Image_9.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg44_Image_9.jpg)'
- en: 'Notice the use of the keyword `this` to attach the properties to the newly
    created object itself: `this.x` and `this.y`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用关键字`this`来将属性附加到新创建的对象本身：`this.x`和`this.y`。
- en: 'In addition to data, classes can be defined with functionality. In this example,
    a `Walker` object has two functions, known as **methods** in an OOP context. While
    methods are essentially functions, the distinction is that methods are defined
    inside a class and therefore are associated with an object or class, whereas functions
    aren’t. The `function` keyword is a nice clue: you’ll see it when defining stand-alone
    functions, but it won’t appear inside a class. I’ll try my best to use the terms
    consistently in this book, but it’s common for programmers to use the terms *function*
    and *method* interchangeably.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据，类还可以定义功能。在这个例子中，`Walker`对象有两个函数，在面向对象编程（OOP）中称为**方法**。虽然方法本质上是函数，但区别在于方法是在类内部定义的，因此与对象或类相关联，而函数则不是。`function`关键字是一个很好的线索：当定义独立的函数时，你会看到它，但在类内部不会出现它。我会尽力在本书中始终如一地使用术语，但程序员常常将*函数*和*方法*交替使用。
- en: 'The first method, `show()`, includes the code to draw the object (as a black
    dot). Once again, never forget the `this.` when referencing the properties (variables)
    of that object:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法，`show()`，包含了绘制对象（作为一个黑点）的代码。再次强调，引用该对象的属性（变量）时，切记使用`this.`：
- en: '![Image](../images/pg44_Image_10.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg44_Image_10.jpg)'
- en: The next method, `step()`, directs the `Walker` object to take a step. This
    is where things get a bit more interesting. Remember taking steps in random directions
    on a floor? Now I’ll use a p5.js canvas to represent that floor. There are four
    possible steps. A step to the right can be simulated by incrementing `x` with
    `x++`; to the left by decrementing `x` with `x--`; forward by going up a pixel
    ( `y--` ); and backward by going down a pixel ( `y++` ). But how can the code
    pick from these four choices?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的方法，`step()`，指示 `Walker` 对象迈出一步。这时事情就变得更加有趣了。记得在地板上随机走步吗？现在我会使用 p5.js 画布来表示这个地板。有四个可能的步伐。向右走可以通过增加
    `x` 来模拟，即 `x++`；向左走通过减少 `x` 来模拟，即 `x--`；向前走是通过上移一个像素（`y--`）；向后走是通过下移一个像素（`y++`）。但是，代码如何从这四个选择中做出选择呢？
- en: 'Earlier I stated that you could flip two coins. In p5.js, however, when you
    want to randomly choose from a list of options, you can simply generate a random
    number with the `random()` function. It picks a random floating-point (decimal)
    value within any range you want. Here, I use 4 to indicate a range of 0 to 4:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到过，你可以抛两枚硬币。然而，在 p5.js 中，当你想从一组选项中随机选择时，你可以简单地使用`random()`函数生成一个随机数。它会在你指定的任何范围内生成一个随机的浮动小数值。这里，我使用
    4 来表示从 0 到 4 的范围：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I declare a variable `choice` and assign it a random integer (whole number)
    by using `floor()` to remove the decimal places from the random floating-point
    number. Technically speaking, the number generated by `random(4)` lies within
    the range of 0 (inclusive) to 4 (exclusive), meaning it can never actually be
    4.0\. The highest possible number it could generate is just below 4—3.999999999
    (with as many 9s as JavaScript will allow), which `floor()` then truncates down
    to 3, removing the decimal part. Therefore, I’ve effectively assigned `choice`
    a value of 0, 1, 2, or 3.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我声明了一个变量 `choice`，并通过使用 `floor()` 函数去除随机浮动小数中的小数部分，来为它赋一个随机整数（整数）。从技术上讲，`random(4)`
    生成的数值在 0（包含）到 4（不包含）之间，这意味着它永远不可能是 4.0。它生成的最大值为接近 4 的数——3.999999999（后面跟着尽可能多的
    9，直到 JavaScript 所允许的精度），然后 `floor()` 将其舍去小数部分，变成 3。因此，我实际上已经将 `choice` 赋值为 0、1、2
    或 3。
- en: '![Image](../images/zoom.jpg) **Coding Conventions**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **编码约定**'
- en: In JavaScript, variables can be declared using either `let` or `const`. A typical
    approach is to declare all variables with `const` and change to `let` when needed.
    In this first example, `const` would be appropriate for declaring `choice` as
    it’s never reassigned a new value over the course of its life inside each call
    to `step()`. While this differentiation is important, I’m choosing to follow the
    p5.js example convention and declare all variables with `let`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，变量可以使用 `let` 或 `const` 来声明。一种典型的方法是，首先使用 `const` 声明所有变量，并在需要时切换为
    `let`。在这个例子中，使用 `const` 声明 `choice` 是合适的，因为它在每次调用 `step()` 时从未被重新赋值。虽然这种区分很重要，但我选择遵循
    p5.js 的示例约定，所有变量都使用 `let` 来声明。
- en: 'I recognize that JavaScript has both `const` and `let` for important reasons.
    However, the distinction can be a distraction and confusing for beginners. I encourage
    you to explore the topic further and make your own decisions about how to best
    declare variables in your own sketches. For more, you can read the discussion
    surrounding issue #3877 in the p5.js GitHub repository (*[https://github.com/processing/p5.js/issues/3877](https://github.com/processing/p5.js/issues/3877)*).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '我认识到 JavaScript 中有 `const` 和 `let` 这两个关键字是有重要原因的。然而，这种区别可能会让初学者感到困惑并分散注意力。我鼓励你深入探讨这个话题，并自行决定如何在自己的草图中声明变量。更多信息，请阅读
    p5.js GitHub 仓库中关于问题 #3877 的讨论 (*[https://github.com/processing/p5.js/issues/3877](https://github.com/processing/p5.js/issues/3877)*)。'
- en: I’m also choosing to use JavaScript’s strict equality ( `===` ) operator (and
    its inequality counterpart, `!==`). This Boolean operator tests both value and
    type equality. For example, `3 === '3'` will evaluate to `false` because the types
    are different (number versus string), even though they look similar. On the other
    hand, using the loose equality ( `==` ) operator in `3 == '3'` would result in
    `true` because the two different types are converted to be comparable. Although
    the loose comparison often works fine, it can sometimes lead to unexpected results,
    so `===` is probably the safer choice.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我还选择使用 JavaScript 的严格相等（`===`）运算符（以及其不等于的对立运算符`!==`）。这个布尔运算符会测试值和类型的相等性。例如，`3
    === '3'`将返回`false`，因为两者类型不同（数字与字符串），即使它们看起来相似。另一方面，使用宽松相等（`==`）运算符时，`3 == '3'`会返回`true`，因为这两种不同类型会被转换成可比较的类型。虽然宽松比较通常能正常工作，但有时会导致意外的结果，因此`===`可能是更安全的选择。
- en: 'Next, the walker takes the appropriate step (left, right, up, or down), depending
    on which random number was picked. Here’s the full `step()` method closing out
    the `Walker` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，行走者根据选择的随机数，采取适当的步伐（向左、向右、向上或向下）。下面是完整的`step()`方法，结束了`Walker`类的定义：
- en: '![Image](../images/pg45_Image_12.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg45_Image_12.jpg)'
- en: 'Now that I’ve written the class, it’s time to make an actual `Walker` object
    in the sketch itself. Assuming you’re looking to model a single random walk, start
    with a single global variable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经编写了类，接下来是时候在草图中实际创建一个`Walker`对象了。假设你想要模拟一个单一的随机行走，从一个全局变量开始：
- en: '![Image](../images/pg46_Image_14.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg46_Image_14.jpg)'
- en: 'Then create the object in `setup()` by referencing the class name with the
    `new` operator:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`setup()`中通过`new`操作符引用类名来创建对象：
- en: '![Image](../images/pg46_Image_15.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg46_Image_15.jpg)'
- en: Finally, during each cycle through `draw()`, the walker takes a step and draws
    a dot.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每次通过`draw()`时，行走者会迈出一步并画出一个点。
- en: '![Image](../images/pg46_Image_16.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg46_Image_16.jpg)'
- en: Since the background is drawn once in `setup()`, rather than clearing it continually
    each time through `draw()`, the trail of the random walk is visible in the canvas.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于背景只在`setup()`中绘制，而不是在每次通过`draw()`时都清除，所以随机行走的轨迹在画布上可见。
- en: 'I could make a couple of adjustments to the random walker. For one, this `Walker`
    object’s steps are limited to four options: up, down, left, and right. But any
    given pixel in the canvas could have eight possible neighbors, including diagonals
    (see [Figure 0.1](ch00.xhtml#ch0fig1)). A ninth possibility, to stay in the same
    place, could also be an option.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以对随机行走者做几个调整。首先，这个`Walker`对象的步伐被限制为四个选项：上、下、左、右。但画布上的任何给定像素都有八个可能的邻居，包括对角线（见[图
    0.1](ch00.xhtml#ch0fig1)）。第九个可能性是保持在同一位置。
- en: '![Image](../images/pg47_Image_17.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg47_Image_17.jpg)'
- en: 'Figure 0.1: The steps of a random walker, with and without diagonals'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.1：随机行走者的步伐，包含与不包含对角线的情况
- en: 'To implement a `Walker` object that can step to any neighboring pixel (or stay
    put), I could pick a number from 0 to 8 (nine possible choices). However, another
    way to write the code would be to pick from three possible steps along the x-axis
    (–1, 0, or 1) and three possible steps along the y-axis:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个可以步进到任何邻近像素（或保持原地）的`Walker`对象，我可以从 0 到 8 中随机选择一个数字（九个可能的选择）。不过，另一种编写代码的方式是，从
    x 轴的三个可能步伐（–1、0 或 1）和 y 轴的三个可能步伐中选择一个：
- en: '![Image](../images/pg47_Image_18.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg47_Image_18.jpg)'
- en: Taking this further, I could get rid of `floor()` and use the `random()` function’s
    original floating-point numbers to create a continuous range of possible step
    lengths from –1 to 1, as shown next.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，我可以去掉`floor()`，使用`random()`函数的原始浮点数，创建从 –1 到 1 的连续范围的可能步长，如下所示。
- en: '![Image](../images/pg47_Image_19.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg47_Image_19.jpg)'
- en: 'All of these variations on the traditional random walk have one thing in common:
    at any moment in time, the probability that the walker will take a step in a given
    direction is equal to the probability that the walker will take a step in any
    other direction. In other words, if there are four possible steps, there is a
    1 in 4 (or 25 percent) chance the walker will take any given step. With nine possible
    steps, it’s a 1 in 9 chance (about 11.1 percent).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对传统随机行走的变种有一个共同点：在任何时刻，行走者采取某一方向的步伐的概率与行走者采取任何其他方向的步伐的概率是相等的。换句话说，如果有四个可能的步伐，那么行走者采取某一特定步伐的概率是
    1/4（即 25%）。如果有九个可能的步伐，那么概率是 1/9（大约 11.1%）。
- en: Conveniently, this is how the `random()` function works. p5.js’s random-number
    generator (which operates behind the scenes) produces a **uniform distribution**
    of numbers. You can test this distribution by counting each time a random number
    is picked and graphing those values.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，这就是`random()`函数的工作方式。p5.js的随机数生成器（在后台运行）产生**均匀分布**的数字。你可以通过统计每次随机数被选中时的次数并将这些值绘制成图来测试这种分布。
- en: '![Image](../images/pg48_Image_21.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg48_Image_21.jpg)'
- en: Notice that each bar of the graph differs slightly in height. The sample size
    (the number of random numbers picked) is small, so occasional discrepancies emerge
    as certain numbers are picked more often than others. Over time, with a good random-number
    generator, this distribution would even out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，图表的每个柱子在高度上略有不同。样本量（随机数的选择次数）较小，因此偶尔会出现差异，因为某些数字被选中的频率高于其他数字。随着时间的推移，使用良好的随机数生成器，这种分布会趋于平衡。
- en: '![Image](../images/zoom.jpg) **Pseudorandom Numbers**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **伪随机数**'
- en: The random numbers from the `random()` function aren’t truly random; instead,
    they’re **pseudorandom** because they’re the result of a mathematical function
    that merely simulates randomness. This function would yield a pattern over time
    and thus stop seeming to be random. That time period is so long, however, that
    `random()` is random enough for the examples in this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`random()`函数生成的随机数并不是真正的随机数；相反，它们是**伪随机**的，因为它们是数学函数的结果，模拟了随机性。这个函数随着时间推移会产生一个模式，从而不再看起来是随机的。然而，这段时间非常长，以至于`random()`对于本书中的示例来说足够随机。'
- en: '![Image](../images/pencil.jpg) **Exercise 0.1**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 0.1**'
- en: Create a random walker that has a greater tendency to move down and to the right.
    (The solution follows in the next section.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个随机行走者，它更倾向于向下和向右移动。（解决方案将在下一节提供。）
- en: '**Probability and Nonuniform Distributions**'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**概率与非均匀分布**'
- en: Uniform randomness often isn’t the most thoughtful solution to a design problem—in
    particular, the kind of problem that involves building an organic or natural-looking
    simulation. With a few tricks, however, the `random()` function can instead produce
    **nonuniform distributions** of random numbers, where some outcomes are more likely
    than others. This type of distribution can yield more interesting, seemingly natural
    results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀的随机性往往不是设计问题的最周到解决方案——特别是那些涉及构建有机或自然外观模拟的问题。然而，使用一些技巧，`random()`函数可以生成**非均匀分布**的随机数，其中某些结果比其他结果更有可能出现。这种类型的分布能够产生更有趣、更自然的结果。
- en: Think about when you first started programming with p5.js. Perhaps you wanted
    to draw a lot of circles on the screen, so you said to yourself, “Oh, I know!
    I’ll draw all these circles at random positions, with random sizes and random
    colors.” Seeding a system with randomness is a perfectly reasonable starting point
    when you’re learning the basics of computer graphics, but in this book, I’m looking
    to build systems modeled on what we see in nature, and uniform randomness won’t
    always cut it. Sometimes you have to put your thumb on the scales a little bit.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你第一次使用p5.js编程时。也许你想在屏幕上画很多圆形，于是你对自己说：“哦，我知道了！我会随机选择位置、大小和颜色来画这些圆形。”将随机性引入系统是学习计算机图形学基础时一个完全合理的起点，但在本书中，我希望建立模拟自然界的系统，均匀的随机性并不总是足够的。有时候，你得稍微“加点偏”。
- en: Creating a nonuniform distribution of random numbers will come in handy throughout
    the book. In [Chapter 9](ch09.xhtml#ch09)’s genetic algorithms, for example, I’ll
    need a methodology for performing selection—which members of the population should
    be selected to pass their DNA to the next generation? This is akin to the Darwinian
    concept of survival of the fittest. Say you have an evolving population of monkeys.
    Not every monkey has an equal chance of reproducing. To simulate Darwinian natural
    selection, you can’t simply pick two random monkeys to be parents. The more “fit”
    ones should be more likely to be chosen. This could be considered the *probability
    of the fittest*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个非均匀分布的随机数在全书中都会非常有用。例如，在[第9章](ch09.xhtml#ch09)的遗传算法中，我需要一种执行选择的方法——哪些个体应该被选中，将它们的DNA传递给下一代？这类似于达尔文的“适者生存”概念。假设你有一个不断演化的猴子种群，并不是每只猴子都有相等的繁殖机会。为了模拟达尔文的自然选择，你不能仅仅随机挑选两只猴子作为父母。更“适应”的个体应该更有可能被选中。这可以视为*最适者的概率*。
- en: Let me pause here and take a look at probability’s basic principles so I can
    apply more precise words to the coding examples to come. I’ll start with **single-event
    probability**—the likelihood that a given event will occur. In probability, **outcomes**
    refer to all the possible results of a random process, and an **event** is the
    specific outcome or combination of outcomes being considered.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我在这里暂停一下，看看概率的基本原理，这样我就能对接下来的编码示例使用更准确的词汇。我将从**单事件概率**开始——某个事件发生的可能性。在概率论中，**结果**指的是随机过程的所有可能结果，而**事件**是指被考虑的特定结果或结果组合。
- en: 'If you have a scenario where each outcome is just as likely as the others,
    the probability of a given event occurring equals the number of outcomes that
    match that event divided by the total number of all potential outcomes. A coin
    toss is a simple example: it has only two possible outcomes, heads or tails. There’s
    only one heads, so the probability that the coin will turn up heads is 1 divided
    by 2: 1/2, or 50 percent.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个每个结果都和其他结果一样可能发生的场景，那么某个事件发生的概率等于匹配该事件的结果数除以所有潜在结果的总数。硬币投掷是一个简单的例子：它只有两个可能的结果，正面或反面。正面只有一个，因此硬币正面朝上的概率是1除以2：1/2，或者50%。
- en: 'Take a deck of 52 cards. The probability of drawing an ace from that deck is
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 拿一副52张牌的牌堆。从这副牌中抽到一张王牌的概率如下：
- en: number of aces / number of cards = 4/52 = 0.077 ≈ 8%
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 王牌的数量 / 牌的数量 = 4/52 = 0.077 ≈ 8%
- en: 'The probability of drawing a diamond is shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 抽到方块的概率在这里显示：
- en: number of diamonds / number of cards = 13/52 = 0.25 = 25%
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 方块的数量 / 牌的数量 = 13/52 = 0.25 = 25%
- en: 'You can also calculate the probability of multiple events occurring in sequence
    by multiplying the individual probabilities of each event. For example, here’s
    the probability of a coin turning up heads three times in a row:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将每个事件的个别概率相乘来计算多个事件按顺序发生的概率。例如，以下是硬币连续三次正面朝上的概率：
- en: (1/2) × (1/2) × (1/2) = 1/8 = 0.125 = 12.5%
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: (1/2) × (1/2) × (1/2) = 1/8 = 0.125 = 12.5%
- en: This indicates a coin will turn up heads three times in a row one out of eight
    times on average. If you flip a coin three times in a row 500 times, you would
    expect to see an outcome of three consecutive heads an average of one-eighth of
    the time, or about 63 times.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明硬币连续三次正面朝上的平均概率是八分之一。如果你连续三次投掷硬币500次，你会预期大约八分之一的时间，或者大约63次，出现三次连续正面。
- en: '![Image](../images/pencil.jpg) **Exercise 0.2**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 0.2**'
- en: What is the probability of drawing two aces in a row from a deck of 52 cards,
    if you reshuffle your first draw back into the deck before making your second
    draw? What would that probability be if you didn’t reshuffle after your first
    draw?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从一副52张牌的牌堆中连续抽两张王牌，而在第二次抽牌前将第一次抽到的牌放回去，抽到两张王牌的概率是多少？如果你在第一次抽牌后不将牌放回去，那么这个概率是多少？
- en: 'You can use the `random()` function in a couple of ways to apply the concepts
    of probability in your code for a nonuniform distribution. One technique is to
    fill an array with numbers—some of which are repeated—and then choose random elements
    from that array and generate events based on those choices:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式使用`random()`函数，在代码中应用概率的概念来实现不均匀分布。一种方法是用数字填充一个数组，其中一些数字是重复的，然后从这个数组中选择随机元素，并根据这些选择生成事件：
- en: '![Image](../images/pg51_Image_24.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg51_Image_24.jpg)'
- en: The five-member array has two 1s, so running this code will produce a two-out-of-five
    chance, or 40 percent chance, of printing the value 1\. Likewise, there’s a 20
    percent chance of printing 2 and a 40 percent chance of printing 3.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个五元素数组有两个1，所以运行这段代码将产生五分之二的机会，或者40%的机会打印值为1。同样，打印2的概率为20%，打印3的概率为40%。
- en: 'You can also ask for a random number (let’s make it simple and just consider
    random floating-point values from 0 to 1) and allow an event to occur only if
    the random number is within a certain range. For example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以请求一个随机数（我们简单起见，只考虑0到1之间的随机浮点值），并仅当随机数在某个范围内时才允许事件发生。例如：
- en: '![Image](../images/pg51_Image_25.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg51_Image_25.jpg)'
- en: One-tenth of the floating-point numbers from 0 to 1 are less than 0.1, so this
    code will lead to singing only 10 percent of the time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从0到1的浮点数中有十分之一小于0.1，所以这段代码只会有10%的概率会唱歌。
- en: 'You can use the same approach to apply unequal weights to multiple outcomes.
    Let’s say you want singing to have a 60 percent chance of happening; dancing,
    a 10 percent chance; and sleeping, a 30 percent chance. Again, you can pick a
    random number from 0 to 1 and see where it falls:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的方法为多个结果应用不等的权重。假设你想让唱歌的概率是60%；跳舞的概率是10%；睡觉的概率是30%。同样，你可以从0到1之间选择一个随机数，看看它落在哪个区间：
- en: From 0.0 to 0.6 (60 percent) → Singing
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从0.0到0.6（60%）→ 唱歌
- en: From 0.6 to 0.7 (10 percent) → Dancing
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从0.6到0.7（10%）→ 跳舞
- en: From 0.7 to 1.0 (30 percent) → Sleeping
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从0.7到1.0（30%）→ 睡觉
- en: '![Image](../images/pg51_Image_26.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg51_Image_26.jpg)'
- en: 'Now let’s apply this methodology to the random walker so it tends to move in
    a particular direction. Here’s an example of a `Walker` object with the following
    probabilities:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这种方法应用到随机漫步者上，让它倾向于朝某个特定方向移动。下面是一个`Walker`对象的示例，它具有以下概率：
- en: 'Chance of moving up: 20 percent'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上移动的概率：20%
- en: 'Chance of moving down: 20 percent'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下移动的概率：20%
- en: 'Chance of moving left: 20 percent'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左移动的概率：20%
- en: 'Chance of moving right: 40 percent'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向右移动的概率：40%
- en: '![Image](../images/pg52_Image_28.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg52_Image_28.jpg)'
- en: Another common use of this technique is to control the probability of an event
    that you want to occur sporadically in your code. For example, let’s say you create
    a sketch that starts a new random walker at regular time intervals (every 100
    frames). With `random()`, you could instead assign a 1 percent chance of a new
    walker starting. The end result is the same (a new walker every 1 out of 100 frames
    on average), but the latter incorporates chance and feels more dynamic and unpredictable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的另一个常见用途是控制你希望在代码中偶尔发生的事件的概率。例如，假设你创建了一个草图，每隔固定的时间间隔（每100帧）启动一个新的随机漫步者。使用`random()`，你可以将一个新的漫步者的启动概率设为1%。最终结果是相同的（平均每100帧启动一个新的漫步者），但后者引入了随机性，感觉更动态和不可预测。
- en: '![Image](../images/pencil.jpg) **Exercise 0.3**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 0.3**'
- en: Create a random walker with dynamic probabilities. For example, can you give
    it a 50 percent chance of moving in the direction of the mouse? Remember, you
    can use `mouseX` and `mouseY` to get the current mouse position in p5.js!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个具有动态概率的随机漫步者。例如，你能否让它有50%的机会朝鼠标的方向移动？记住，你可以使用`mouseX`和`mouseY`来获取当前鼠标的位置，p5.js中就是这样！
- en: '**A Normal Distribution of Random Numbers**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**随机数的正态分布**'
- en: 'Another way to create a nonuniform distribution of random numbers is to use
    a **normal distribution**, where the numbers cluster around an average value.
    To see why this is useful, let’s go back to that population of simulated monkeys
    and assume your sketch generates a thousand `Monkey` objects, each with a random
    height value of 200 to 300 (as this is a world of monkeys that have heights of
    200 to 300 pixels):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建非均匀分布的随机数的另一种方式是使用**正态分布**，其中数字会围绕平均值聚集。为了理解为什么这有用，让我们回到模拟猴子的人群，并假设你的草图生成了1000个`Monkey`对象，每个对象都有一个随机的身高值在200到300之间（因为这是一个身高为200到300像素的猴子世界）：
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Is this an accurate algorithm for creating a population of monkey heights? Think
    of a crowded sidewalk in New York City. Pick any person off the street, and it
    may appear that their height is random. Nevertheless, it’s not the kind of random
    that `random()` produces by default. People’s heights aren’t uniformly distributed;
    there are many more people of about average height than there are very tall or
    very short ones. To accurately reflect this population, random heights close to
    the **mean** (another word for *average*) should be more likely to be chosen,
    while outlying heights (very short or very tall) should be rarer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建猴子身高人群的准确算法吗？想象一下纽约市繁忙的街道。随便挑一个路人，他们的身高可能看起来是随机的。然而，这并不是`random()`默认生成的那种随机。人的身高分布并不是均匀的；大约身高平均的人远多于非常高或非常矮的人。为了准确反映这种人群，接近**均值**（即*平均值*）的身高应该更有可能被选择，而极端身高（非常矮或非常高）则应更少见。
- en: That’s exactly how a normal distribution (sometimes called a Gaussian distribution,
    after mathematician Carl Friedrich Gauss) works. A graph of this distribution
    is informally known as a **bell curve**. The curve is generated by a mathematical
    function that defines the probability of any given value occurring as a function
    of the mean (often written as µ, the Greek letter mu) and standard deviation (σ,
    the Greek letter sigma).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是正态分布（有时称为高斯分布，源自数学家卡尔·弗里德里希·高斯）的工作原理。该分布的图形非正式地被称为**钟形曲线**。该曲线由一个数学函数生成，该函数定义了某个给定值出现的概率，这个概率是均值（通常写作µ，希腊字母mu）和标准差（σ，希腊字母sigma）的函数。
- en: In the case of height values from 200 to 300, you probably have an intuitive
    sense of the mean (average) as 250\. However, what if I were to say that the standard
    deviation is 3? Or 15? What does this mean for the numbers? The graphs depicted
    in [Figure 0.2](ch00.xhtml#ch0fig2) should give you a hint.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑身高值在200到300之间，你可能已经直观地知道均值（平均值）大约是250。但是，如果我告诉你标准差是3？或者是15？这对数据意味着什么？图 [0.2](ch00.xhtml#ch0fig2)
    给出的图表应该能给你一些提示。
- en: '![Image](../images/pg54_Image_29.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg54_Image_29.jpg)'
- en: 'Figure 0.2: Two example bell curves of a normal distribution, with a low (left)
    and high (right) standard deviation'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.2：正态分布的两个示例钟形曲线，分别具有低（左）和高（右）标准差
- en: On the left is a distribution with a very low standard deviation, with the majority
    of the values piling up around the mean (they don’t deviate much from the standard).
    The version on the right has a higher standard deviation, so the values are more
    evenly spread out from the average (they deviate more).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是一个标准差非常低的分布，绝大多数值都集中在均值附近（它们与标准差的偏差很小）。右侧的版本有更高的标准差，因此值更加均匀地分布在均值周围（它们的偏差较大）。
- en: 'The numbers work out as follows: given a population, 68 percent of its members
    will have values in the range of one standard deviation from the mean, 95 percent
    within two standard deviations, and 99.7 percent within three standard deviations.
    Given a standard deviation of 5 pixels, only 0.3 percent of the monkey heights
    will be less than 235 pixels (three standard deviations below the mean of 250)
    or greater than 265 pixels (three standard deviations above the mean of 250).
    Meanwhile, 68 percent of the monkey heights will be from 245 to 255 pixels.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的计算结果如下：假设一个群体，其中68%的成员的值位于均值的一个标准差范围内，95%的值位于两个标准差范围内，99.7%的值位于三个标准差范围内。假设标准差为5像素，那么只有0.3%的猴子身高会低于235像素（低于均值250的三个标准差）或高于265像素（高于均值250的三个标准差）。同时，68%的猴子身高会在245到255像素之间。
- en: 'Luckily, to use a normal distribution of random numbers in a p5.js sketch,
    you don’t have to do any of these calculations manually. Instead, the `randomGaussian()`
    function takes care of the math and returns random numbers with a normal distribution:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 p5.js 草图中使用正态分布的随机数时，你无需手动进行这些计算。相反，`randomGaussian()` 函数会处理这些数学运算，并返回具有正态分布的随机数：
- en: '![Image](../images/pg54_Image_30.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg54_Image_30.jpg)'
- en: '![Image](../images/zoom.jpg) **Calculating Mean and Standard Deviation**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **计算均值和标准差**'
- en: 'Consider a class of 10 students who receive the following scores (out of 100)
    on a test: 85, 82, 88, 86, 85, 93, 98, 40, 73, and 83.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个包含10个学生的班级，他们在一次考试中的成绩（满分100）如下：85、82、88、86、85、93、98、40、73和83。
- en: 'The mean is the average: 81.3.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 均值是平均数：81.3。
- en: The standard deviation is calculated as the square root of the average of the
    squares of deviations around the mean. In other words, take the difference between
    the mean and each person’s grade, and square it, giving you that person’s squared
    deviation. Next, calculate the average of all these values to get the average
    variance. Then, take the square root of the average variance, and you have the
    standard deviation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差的计算方法是对偏差平方的平均值开方。换句话说，取均值与每个人成绩之间的差值，并对其进行平方，得到该人的平方偏差。接下来，计算所有这些值的平均值以获得平均方差。然后，对平均方差开方，你就得到了标准差。
- en: '| **Score** | **Difference from Mean** | **Variance** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **分数** | **与均值的差异** | **方差** |'
- en: '| --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 85 | 85 − 81.3 = 3.7 | (3.7)² = 13.69 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 85 | 85 − 81.3 = 3.7 | (3.7)² = 13.69 |'
- en: '| 40 | 40 - 81.3 = -41.3 | (-41.3)² = 1,705.69 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 40 | 40 - 81.3 = -41.3 | (-41.3)² = 1,705.69 |'
- en: '| . . . |  |  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| . . . |  |  |'
- en: '|  | **Average Variance:** | 228.21 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  | **平均方差：** | 228.21 |'
- en: 'The standard deviation is the square root of the variance: 15.13.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差是方差的平方根：15.13。
- en: What next? What if, for example, the goal is to assign the x-position of a shape
    drawn?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来该做什么？例如，目标是为绘制的形状分配x位置，应该怎么办？
- en: 'By default, the `randomGaussian()` function returns a normal distribution of
    random positive and negative numbers with a mean of 0 and a standard deviation
    of 1\. This is also known as the **standard normal distribution**. Often, however,
    these default parameters won’t work. For example, say you want to randomly assign
    the x-position of a shape by using a normal distribution with a mean of 320 (the
    center horizontal pixel in a window of width 640) and a standard deviation of
    60 pixels. In this case, you can adjust the parameters by passing the `randomGaussian()`
    function two arguments: the mean followed by the standard deviation.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`randomGaussian()`函数返回一个正态分布的随机正负数，均值为0，标准差为1。这也被称为**标准正态分布**。然而，通常这些默认参数无法满足需求。例如，假设你希望使用均值为320（宽度为640的窗口中的中心水平像素）和标准差为60像素的正态分布来随机分配一个形状的x位置。在这种情况下，你可以通过传递`randomGaussian()`函数两个参数来调整参数：均值和标准差。
- en: '![Image](../images/pg55_Image_31.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg55_Image_31.jpg)'
- en: 'Here I’ve used arguments to customize the call to `randomGaussian()`, but note
    that the math to implement this customization is quite simple: all you have to
    do is multiply the value from the standard normal distribution by the standard
    deviation and then add the mean. In other words, assigning `x` to `randomGaussian(320,
    60)` is the same as the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我使用了参数来定制对`randomGaussian()`的调用，但请注意，实现这一定制的数学原理非常简单：你所需要做的就是将标准正态分布的值乘以标准差，然后加上均值。换句话说，将`x`赋值为`randomGaussian(320,
    60)`与以下操作是等价的：
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By drawing the circles on top of one another with transparency, you can begin
    to see the distribution. The darkest spot is near the center, where most of the
    values cluster, but every so often circles are drawn farther to the right or left
    of the center.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将圆圈以透明度叠加在一起，你可以开始看到分布情况。最暗的区域位于中心，那里大多数值聚集，但偶尔会有圆圈绘制在中心的左右更远位置。
- en: '![Image](../images/pencil.jpg) **Exercise 0.4**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 0.4**'
- en: Consider a simulation of paint splatter drawn as a collection of colored dots.
    Most of the paint clusters around a central position, but some dots splatter out
    toward the edges. Can you use a normal distribution of random numbers to generate
    the positions of the dots? Can you also use a normal distribution of random numbers
    to generate a color palette? Try creating a slider to adjust the standard deviation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个模拟的油漆飞溅效果，表现为一系列彩色的点。大多数油漆聚集在中心位置，但有些点会向边缘飞溅。你能使用正态分布的随机数来生成这些点的位置吗？你能否也使用正态分布的随机数来生成颜色调色板？尝试创建一个滑块来调整标准差。
- en: '![Image](../images/pencil.jpg) **Exercise 0.5**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 0.5**'
- en: A Gaussian random walk is defined as one in which the step size (how far the
    object moves in a given direction) is generated with a normal distribution. Implement
    this variation of the `Walker` class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯随机漫步是指其中步长（对象在给定方向上移动的距离）是通过正态分布生成的。实现这种`Walker`类的变体。
- en: '**A Custom Distribution of Random Numbers**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**自定义的随机数分布**'
- en: There will come a time in your life when you don’t want a uniform distribution
    of random values, or even a Gaussian one. Imagine for a moment that you’re a random
    walker in search of food. Moving randomly around a space seems like a reasonable
    strategy for finding something to eat. After all, you don’t know where the food
    is, so you might as well search randomly until you find it. However, there’s a
    problem. As you may have noticed while watching your `Walker` object in action,
    random walkers return to previously visited positions many times, a phenomenon
    known as **oversampling**. This could make your search for food fruitless, or
    at least inefficient.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的人生中，会有某个时刻你不希望使用均匀分布的随机值，甚至也不希望使用高斯分布。假设一下，你是一个在寻找食物的随机漫步者。在空间中随机移动似乎是寻找食物的合理策略。毕竟，你并不知道食物在哪，所以你不如随机寻找，直到找到它。然而，问题是，正如你可能在观察你的`Walker`对象的行动时注意到的，随机漫步者会多次返回之前访问过的位置，这种现象被称为**过度采样**。这可能导致你的寻找食物的过程毫无成果，或者至少低效。
- en: 'One strategy to avoid such a problem is to take a very large step every so
    often. This allows the walker to forage randomly around a specific position while
    periodically jumping far away to reduce the amount of oversampling. This variation
    on the random walk, known as a **Lévy flight**, requires a custom set of probabilities.
    Though it’s not an exact implementation of a Lévy flight, you could state the
    probability distribution as follows: the longer the step, the less likely it is
    to be picked; the shorter the step, the more likely.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 避免此类问题的一种策略是每隔一段时间迈出一个非常大的步伐。这样，步态者可以在特定位置附近随机游走，同时偶尔跳得很远，以减少过度采样。这种随机漫步的变体，称为**Lévy飞行**，需要一组自定义的概率。虽然这并不是Lévy飞行的精确实现，但你可以这样表示概率分布：步伐越长，被选中的可能性越小；步伐越短，被选中的可能性越大。
- en: 'Earlier I wrote that you could generate custom probability distributions by
    filling an array with values (some duplicated so as to be picked more frequently)
    or by testing the result of `random()`. One way to implement a Lévy flight might
    be to specify a 1 percent chance of the walker taking a large step:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我写过，你可以通过填充一个数组来生成自定义概率分布（其中一些值会重复，以便更频繁地被选中），或者通过测试`random()`的结果来实现。一种实现Lévy飞行的方法可能是指定1%的机会让步态者迈出一大步：
- en: '![Image](../images/pg57_Image_33.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg57_Image_33.jpg)'
- en: 'However, this reduces the probabilities to a fixed number of options: 99 percent
    of the time, a small step; 1 percent of the time, a large step. What if you instead
    wanted to make a more general rule, such as the higher a number, the more likely
    it is to be picked? For example, 0.8791 would be more likely to be picked than
    0.8532, even if that likelihood is just a tiny bit greater. In other words, if
    *x* is the random number, the likelihood of it being picked could be mapped to
    the y-axis with the function *y* = *x* ([Figure 0.3](ch00.xhtml#ch0fig3)).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会将概率限制为固定的选项数量：99%的时间，小步前进；1%的时间，大步前进。如果你想制定一个更通用的规则呢？比如数字越大，被选中的可能性越大。例如，0.8791比0.8532更可能被选中，即使这种可能性只是略微更高。换句话说，如果*x*是随机数，它被选中的可能性可以通过函数*y*
    = *x*映射到y轴上（见[图 0.3](ch00.xhtml#ch0fig3)）。
- en: '![Image](../images/pg57_Image_34.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg57_Image_34.jpg)'
- en: 'Figure 0.3: A graph of *y* = *x*, where *y* is the probability that a value
    *x* will be picked'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.3：*y* = *x*的图形，其中*y*是值*x*被选中的概率
- en: If a distribution of random numbers can be generated according to the graph
    in [Figure 0.3](ch00.xhtml#ch0fig3), you should also be able to generate a random
    distribution that follows any other curve you can define with a formula.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以根据[图 0.3](ch00.xhtml#ch0fig3)中的图形生成随机数分布，那么你也应该能够生成一个符合任何你用公式定义的曲线的随机分布。
- en: 'One solution for a custom distribution is to pick two random numbers instead
    of one. The first random number is just that, a random number. The second one,
    however, is what I’ll call a **qualifying random value**. This value is used by
    the program to decide whether to use that first number or throw it away and pick
    another. Numbers that have an easier time qualifying will be picked more often,
    and numbers that rarely qualify will be picked infrequently. Here are the steps
    (for now, I’ll consider only random values from 0 to 1):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义分布的一种解决方案是选择两个随机数而不是一个。第一个随机数就是一个随机数。而第二个随机数，我称之为**合格随机值**。该值由程序用来决定是否使用第一个数，还是丢弃它并选择另一个。那些更容易合格的数字会更频繁地被选中，而那些很少合格的数字则会很少被选中。以下是步骤（暂时我只考虑从0到1的随机值）：
- en: 'Pick a random number: `r1`.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个随机数：`r1`。
- en: 'Compute a probability `p` that `r1` should qualify. Let’s try: `p = r1`.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算概率`p`，让`r1`符合的概率。我们试试：`p = r1`。
- en: 'Pick another random number: `r2`.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再挑一个随机数：`r2`。
- en: 'If `r2` is less than `p`, you’ve found your number: `r1`!'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`r2`小于`p`，那么你已经找到了你的数字：`r1`！
- en: If `r2` isn’t less than `p`, go back to step 1 and start over.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`r2`不小于`p`，返回第1步重新开始。
- en: Here, the likelihood that a random value will qualify is equal to the random
    number itself, just as you saw in [Figure 0.3](ch00.xhtml#ch0fig3). If `r1` equals
    0.1, for example, `r1` will have a 10 percent chance of qualifying. If `r1` equals
    0.83, it will have an 83 percent chance of qualifying. The higher the number,
    the greater the likelihood that it gets used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个随机值符合的概率等于该随机数本身，就像你在[图 0.3](ch00.xhtml#ch0fig3)中看到的那样。例如，如果`r1`等于0.1，那么`r1`有10%的机会符合。如果`r1`等于0.83，它有83%的机会符合。数字越大，被选中的概率越高。
- en: This process is called the **accept-reject algorithm**, a type of Monte Carlo
    method (named for the Monte Carlo Casino). The following example features a function
    that implements the accept-reject algorithm, returning a random value from 0 to
    1.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程被称为**接受-拒绝算法**，是一种蒙特卡洛方法（以蒙特卡洛赌场命名）。以下示例展示了一个实现接受-拒绝算法的函数，返回一个介于 0 和 1 之间的随机值。
- en: '![Image](../images/pg58_Image_35.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg58_Image_35.jpg)'
- en: While the accept-reject algorithm does work for generating custom distributions
    of random numbers, this technique is not particularly efficient. It can lead to
    a considerable amount of wasted computation when a large number of random values
    are rejected, especially when the qualifying probability is very low. When I get
    to genetic algorithms in [Chapter 9](ch09.xhtml#ch09), I’ll take a different,
    more optimal approach.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管接受-拒绝算法确实能用来生成自定义的随机数分布，但这种技术效率不高。当大量随机值被拒绝时，尤其是在合格概率非常低的情况下，可能会浪费大量计算资源。到我在[第
    9 章](ch09.xhtml#ch09)讲解遗传算法时，我将采取一种不同且更优的方式。
- en: '![Image](../images/pencil.jpg) **Exercise 0.6**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 0.6**'
- en: Use a custom probability distribution to vary the size of the random walker’s
    steps. The step size can be determined by influencing the range of values picked
    with a qualifying random value. Can you map the probability to a quadratic function
    by making the likelihood that a value is picked equal to the value squared?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义的概率分布来改变随机游走者步伐的大小。步伐的大小可以通过影响所选随机值的范围来确定。你能通过将选中某个值的可能性设为该值的平方，来将概率映射到一个二次函数吗？
- en: '![Image](../images/pg59_Image_37.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg59_Image_37.jpg)'
- en: (In [Chapter 1](ch01.xhtml#ch01), I’ll show how to vary the step sizes more
    efficiently with vectors.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: （在[第 1 章](ch01.xhtml#ch01)中，我将展示如何使用向量更高效地改变步伐大小。）
- en: '**A Smoother Approach with Perlin Noise**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Perlin 噪声的更平滑方法**'
- en: A good random-number generator produces numbers that have no relationship to
    one another and show no discernible pattern. As I’ve hinted, however, while a
    little bit of randomness can be a good thing when programming organic, lifelike
    behaviors, uniform randomness as the single guiding principle isn’t necessarily
    natural. An algorithm known as **Perlin noise**, named for its inventor, Ken Perlin,
    takes this concept into account by producing a naturally ordered sequence of pseudorandom
    numbers, where each number in the sequence is quite close in value to the one
    before it. This creates a “smooth” transition between the random numbers and a
    more organic appearance than pure noise, making Perlin noise well suited for generating
    various effects with natural qualities, such as clouds, landscapes, and patterned
    textures like marble.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的随机数生成器应当生成彼此之间没有关系且无明显模式的数字。然而，正如我所暗示的，虽然在编程模拟自然、有生命的行为时，适度的随机性是有益的，但单纯以均匀随机作为唯一指导原则并不一定符合自然规律。一个叫做**Perlin
    噪声**的算法，正是考虑到这一点，它生成一系列自然排序的伪随机数，其中每个数值都与前一个数值非常接近。这种方式在随机数之间创建了“平滑”的过渡，且比纯噪声呈现出更自然的外观，因此，Perlin
    噪声非常适合用于生成具有自然特性的各种效果，如云彩、景观和大理石等纹理图案。
- en: To illustrate the difference between Perlin noise and uniform randomness, consider
    [Figure 0.4](ch00.xhtml#ch0fig4). The graph on the left shows Perlin noise over
    time, with the x-axis representing time; note the smoothness of the curve. The
    graph on the right shows noise in the form of purely random numbers over time;
    the result is much more jagged. (The code for generating these graphs is available
    on the book’s website.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 Perlin 噪声与均匀随机之间的差异，考虑[图 0.4](ch00.xhtml#ch0fig4)。左侧的图展示了 Perlin 噪声随时间变化的情况，x
    轴表示时间；注意曲线的平滑性。右侧的图则展示了纯随机数形式的噪声随时间变化的情况，结果明显更加崎岖不平。（生成这些图的代码可以在本书网站上找到。）
- en: '![Image](../images/pg60_Image_38.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg60_Image_38.jpg)'
- en: 'Figure 0.4: A graph of Perlin noise values over time (left) and of random noise
    values over time (right)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.4：Perlin 噪声值随时间变化的图（左）和随机噪声值随时间变化的图（右）
- en: Ken Perlin developed the original Perlin noise algorithm while working on the
    movie *Tron* in the early 1980s; he later received an Academy Award in technical
    achievement for this work. The algorithm was designed to create procedural textures
    for computer-generated effects. (*Procedural* refers to generating the visual
    elements algorithmically, rather than an artist manually designing them.) Over
    the years, a variety of other flavors of noise have been developed by different
    authors. Some notable ones are value noise, Worley noise, and simplex noise (developed
    by Perlin himself in 2001). You can learn more about the history of Perlin noise
    at Ken Perlin’s website (*[https://mrl.nyu.edu/~perlin/doc/oscar.html](https://mrl.nyu.edu/~perlin/doc/oscar.html)*)
    and its variations over the years in my “What Is OpenSimplex Noise?” video on
    the Coding Train website (*[https://thecodingtrain.com/opensimplexnoise](https://thecodingtrain.com/opensimplexnoise)*).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Ken Perlin 在 1980 年代初期为电影 *Tron* 工作时开发了最初的 Perlin 噪声算法；他因这项工作获得了技术成就的奥斯卡奖。该算法旨在为计算机生成的特效创建程序化纹理。（*程序化*指的是通过算法生成视觉元素，而不是艺术家手工设计它们。）多年来，许多不同的噪声变种由不同的作者开发出来。一些著名的变种包括值噪声、Worley
    噪声和 simplex 噪声（由 Perlin 本人于 2001 年开发）。您可以在 Ken Perlin 的网站上了解更多关于 Perlin 噪声的历史
    (*[https://mrl.nyu.edu/~perlin/doc/oscar.html](https://mrl.nyu.edu/~perlin/doc/oscar.html)*)，并在我在
    Coding Train 网站上的视频“什么是 OpenSimplex 噪声？”中了解它在这些年中的变种 (*[https://thecodingtrain.com/opensimplexnoise](https://thecodingtrain.com/opensimplexnoise)*).
- en: The p5.js library incorporates an implementation of the classic 1983 Perlin
    noise algorithm in a function called `noise()`. It can take one, two, or three
    arguments, as noise is computed in one, two, or three dimensions. I’ll start by
    showing you one-dimensional (1D) noise.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: p5.js 库包含了经典 1983 年 Perlin 噪声算法的实现，该实现位于名为 `noise()` 的函数中。它可以接受一个、两个或三个参数，因为噪声是计算在一维、二维或三维空间中的。我将从展示一维（1D）噪声开始。
- en: 'Say you want to draw a circle on a canvas at a random x-position. Out of habit,
    you might use the `random()` function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想在画布上绘制一个位于随机 x 位置的圆。出于习惯，您可能会使用 `random()` 函数：
- en: '![Image](../images/pg60_Image_39.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg60_Image_39.jpg)'
- en: 'Now, instead of a random x-position, you want a smoother Perlin noise x-position.
    You might think that all you need to do is replace `random()` with an identical
    call to `noise()`, like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您不再需要一个随机的 x 位置，而是需要一个更平滑的 Perlin 噪声 x 位置。您可能会认为，只需要将 `random()` 替换为一个相同的
    `noise()` 调用，如下所示：
- en: '![Image](../images/pg60_Image_40.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg60_Image_40.jpg)'
- en: 'Conceptually, this is exactly what you want to do—calculate an x-value that
    ranges from 0 to the width according to Perlin noise—but this isn’t the correct
    implementation. While the arguments to the `random()` function specify a range
    of values between a minimum and a maximum, `noise()` doesn’t work this way. Instead,
    its output range is fixed: it always returns a value from 0 to 1\. You’ll see
    in a moment that you can get around this easily with p5.js’s `map()` function,
    but first let’s examine what exactly `noise()` expects you to pass in as an argument.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，这正是您想要做的——根据 Perlin 噪声计算一个从 0 到宽度范围的 x 值——但这不是正确的实现。虽然 `random()` 函数的参数指定了一个最小值和最大值之间的范围，但
    `noise()` 并不是这样工作的。相反，它的输出范围是固定的：它总是返回一个 0 到 1 之间的值。稍后您将看到，可以通过 p5.js 的 `map()`
    函数轻松解决这个问题，但首先我们来看看 `noise()` 期望您传入的参数到底是什么。
- en: 'One-dimensional Perlin noise can be thought of as a linear sequence of values
    over time. For example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一维 Perlin 噪声可以被视为随时间变化的线性数值序列。例如：
- en: '| **Time** | **Noise Value** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **时间** | **噪声值** |'
- en: '| --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 0.365 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0.365 |'
- en: '| 1 | 0.363 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0.363 |'
- en: '| 2 | 0.363 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0.363 |'
- en: '| 3 | 0.364 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0.364 |'
- en: '| 4 | 0.366 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0.366 |'
- en: 'To access a particular noise value, you have to choose a “moment in time” and
    pass it to the `noise()` function. For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问特定的噪声值，您必须选择一个“时间点”，并将其传递给 `noise()` 函数。例如：
- en: '[PRE3]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'According to the preceding table, `noise(3)` returns 0.364\. The next step
    is to use a variable for time and ask for a noise value continuously in `draw()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上表，`noise(3)` 返回 0.364。下一步是使用一个时间变量，并在 `draw()` 中持续请求噪声值：
- en: '![Image](../images/pg61_Image_41.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg61_Image_41.jpg)'
- en: 'Close, but not quite. This code just prints the same value over and over because
    it keeps asking for the result of the `noise()` function at the same point in
    time, 3\. If the time variable `t` increments, however, you’ll get a different
    noise value each time you call the function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接近，但还不完全正确。这段代码只是重复输出相同的值，因为它不断请求 `noise()` 函数在相同的时间点 3 的结果。然而，如果时间变量 `t` 递增，你每次调用该函数时都会得到不同的噪声值：
- en: '![Image](../images/pg61_Image_42.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg61_Image_42.jpg)'
- en: I’ve chosen to increment `t` by 0.01, but using a different increment value
    will affect the smoothness of the noise. Larger jumps in time that skip ahead
    through the noise space produce values that are less smooth and more random ([Figure
    0.5](ch00.xhtml#ch0fig5)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择将 `t` 增量为 0.01，但使用不同的增量值会影响噪声的平滑度。通过噪声空间跳跃较大的时间间隔会产生不那么平滑、更加随机的值（[图 0.5](ch00.xhtml#ch0fig5)）。
- en: '![Image](../images/pg62_Image_44.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg62_Image_44.jpg)'
- en: 'Figure 0.5: Demonstrating short and long jumps in time in Perlin noise'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.5：演示 Perlin 噪声中的短跳跃和长跳跃
- en: In the upcoming code examples that utilize Perlin noise, pay attention to how
    the animation changes with varying values of `t`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的代码示例中，使用了 Perlin 噪声，请注意随着 `t` 值变化，动画是如何变化的。
- en: '**Noise Ranges**'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**噪声范围**'
- en: Once you have noise values that range from 0 to 1, it’s up to you to map that
    range to whatever size suits your purpose. The easiest way to do this is with
    p5.js’s `map()` function ([Figure 0.6](ch00.xhtml#ch0fig6)). It takes five arguments.
    First is the value you want to map—in this case, `n`. This is followed by the
    value’s current range (minimum and maximum), followed by the desired range.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了从 0 到 1 的噪声值，你就可以将该范围映射到任何适合你目的的大小。最简单的方法是使用 p5.js 的 `map()` 函数（[图 0.6](ch00.xhtml#ch0fig6)）。它需要五个参数。第一个是你要映射的值——在这个例子中是
    `n`。接下来是该值的当前范围（最小值和最大值），然后是目标范围。
- en: '![Image](../images/pg63_Image_45.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg63_Image_45.jpg)'
- en: 'Figure 0.6: Mapping a value from one range to another'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.6：将一个值从一个范围映射到另一个范围
- en: 'In this case, while noise has a range from 0 to 1, I’d like to draw a circle
    with an x-position ranging from 0 to the canvas’s width:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，虽然噪声的范围是从 0 到 1，我想画一个 x 位置范围从 0 到画布宽度的圆：
- en: '![Image](../images/pg63_Image_46.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg63_Image_46.jpg)'
- en: The same logic can be applied to the random walker, assigning both its x- and
    y-values according to Perlin noise. This creates a smoother, more organic random
    walk.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的逻辑也可以应用于随机行走者，将其 x 和 y 值都根据 Perlin 噪声分配。这会创造一个更加平滑、更加自然的随机漫步。
- en: '![Image](../images/pg64_Image_47.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg64_Image_47.jpg)'
- en: 'Notice that this example requires a new pair of variables: `tx` and `ty`. This
    is because I need to keep track of two time variables, one for the x-position
    of the `Walker` object and one for the y-position. But something is a bit odd
    about these variables. Why does `tx` start at 0 and `ty` at 10,000?'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个例子需要一对新变量：`tx` 和 `ty`。这是因为我需要跟踪两个时间变量，一个用于 `Walker` 对象的 x 位置，另一个用于 y 位置。但这些变量有点奇怪。为什么
    `tx` 从 0 开始，而 `ty` 从 10,000 开始？
- en: 'While these numbers are arbitrary choices, I’ve intentionally initialized the
    two time variables this way because the noise function is deterministic: it always
    gives you the same result for a specific time `t`. If I asked for the noise value
    at the same time `t` for both `x` and `y`, then `x` and `y` would always be equal,
    meaning that the `Walker` object would move only along a diagonal. Instead, I
    use two different parts of the noise space, starting at 0 for `x` and 10,000 for
    `y` so that `x` and `y` appear to act independently of each other ([Figure 0.7](ch00.xhtml#ch0fig7)).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些数字是随意选择的，但我故意将这两个时间变量初始化为这种方式，因为噪声函数是确定性的：它始终在特定时间 `t` 给出相同的结果。如果我要求在相同时间
    `t` 获取 `x` 和 `y` 的噪声值，那么 `x` 和 `y` 将始终相等，这意味着 `Walker` 对象将仅沿对角线移动。相反，我使用噪声空间的两个不同部分，`x`
    从 0 开始，`y` 从 10,000 开始，这样 `x` 和 `y` 看起来彼此独立地行动（[图 0.7](ch00.xhtml#ch0fig7)）。
- en: '![Image](../images/pg65_Image_48.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg65_Image_48.jpg)'
- en: 'Figure 0.7: Using different offsets along the x-axis to vary Perlin noise values'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.7：使用不同的 x 轴偏移量来变化 Perlin 噪声值
- en: In truth, no actual concept of time is at play here. It’s a useful metaphor
    to help describe how the noise function works, but really, what you have is space,
    rather than time. The graph in [Figure 0.7](ch00.xhtml#ch0fig7) depicts a linear
    sequence of noise values in a 1D space—that is, arranged along a line. Values
    are retrieved at a specific x-position, which is why you’ll often see a variable
    named `xoff` in examples to indicate the x-offset along the noise graph, rather
    than `t` for time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这里并没有真正的时间概念在起作用。它是一个有用的隐喻，用来帮助描述噪声函数是如何工作的，但实际上，你所拥有的是空间，而不是时间。图表 [Figure
    0.7](ch00.xhtml#ch0fig7) 描绘了一个在一维空间中排列的噪声值的线性序列——也就是说，这些值沿着一条直线排列。值是在特定的 x 位置被提取的，这就是为什么你在示例中经常会看到一个变量名为
    `xoff`，用来表示噪声图中的 x 偏移量，而不是 `t` 来表示时间。
- en: '![Image](../images/pencil.jpg) **Exercise 0.7**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 0.7**'
- en: In the Perlin noise random walker, the result of the `noise()` function is mapped
    directly to the walker’s position. Create a random walker, but map the result
    of the `noise()` function to the walker’s step size instead.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Perlin 噪声随机行走器中，`noise()` 函数的结果直接映射到行走器的位置。创建一个随机行走器，但将 `noise()` 函数的结果映射到行走器的步长上。
- en: '**Two-Dimensional Noise**'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**二维噪声**'
- en: 'Having explored the concept of noise values in one dimension, let’s consider
    how they can also exist in a two-dimensional (2D) space. With 1D noise, there’s
    a sequence of values in which any given value is similar to its neighbor. Imagine
    a piece of graph paper (or a spreadsheet!) with the values for 1D noise written
    across a single row, one value per cell. Because these values live in one dimension,
    each has only two neighbors: a value that comes before it (to the left) and one
    that comes after it (to the right), as shown on the left in [Figure 0.8](ch00.xhtml#ch0fig8).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了单维噪声值的概念之后，让我们考虑它们如何在二维（2D）空间中存在。对于一维噪声来说，有一系列的值，其中任何给定的值与其邻居相似。想象一张图纸（或电子表格！），在一行中写着一维噪声的值，每个单元格一个值。由于这些值存在于一维空间中，每个值只有两个邻居：一个在它之前的值（左边）和一个在它之后的值（右边），如图
    [Figure 0.8](ch00.xhtml#ch0fig8) 左侧所示。
- en: '![Image](../images/pg66_Image_49.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg66_Image_49.jpg)'
- en: 'Figure 0.8: Comparing neighboring Perlin noise values in one (left) and two
    (right) dimensions. The cells are shaded according to their Perlin noise value.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.8：比较邻近的 Perlin 噪声值，在一维（左）和二维（右）中。单元格根据它们的 Perlin 噪声值进行着色。
- en: 'Two-dimensional noise works exactly the same way conceptually. The difference,
    of course, is that the values aren’t written in a linear path along just one row
    of the graph paper, but rather fill the whole grid. A given value will be similar
    to all its neighbors: above, below, to the right, to the left, and along any diagonal,
    as in the right half of [Figure 0.8](ch00.xhtml#ch0fig8).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 二维噪声的工作方式在概念上与一维噪声完全相同。不同之处在于，值并不是沿着图纸的单一行线性排列，而是填充整个网格。给定的值将与它所有的邻居相似：上、下、右、左以及任何对角线方向，如
    [Figure 0.8](ch00.xhtml#ch0fig8) 右侧所示。
- en: If you were to visualize this graph paper with each value mapped to the brightness
    of a color, you would get something that looks like clouds. White sits next to
    light gray, which sits next to gray, which sits next to dark gray, which sits
    next to black, which sits next to dark gray, and so on ([Figure 0.9](ch00.xhtml#ch0fig9)).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个图纸可视化，每个值映射为一种颜色的亮度，你会看到类似云彩的效果。白色旁边是浅灰色，浅灰色旁边是灰色，灰色旁边是深灰色，深灰色旁边是黑色，然后是深灰色，以此类推（见
    [Figure 0.9](ch00.xhtml#ch0fig9)）。
- en: '![Image](../images/pg66_Image_50.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg66_Image_50.jpg)'
- en: 'Figure 0.9: In this output of a p5.js sketch visualizing 2D noise, each pixel
    represents a noise value as a grayscale color.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.9：在这个 p5.js 草图的输出中，视觉化了二维噪声，每个像素表示一个噪声值，以灰度色显示。
- en: This effect is why noise was originally invented. If you tweak the parameters
    and play with color, the resulting images look more like marble, wood, or any
    other organic texture.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果正是噪声最初发明的原因。如果你调整参数并玩弄颜色，得到的图像看起来更像大理石、木材或任何其他有机纹理。
- en: '![Image](../images/zoom.jpg) **Noise Detail**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **噪声细节**'
- en: The p5.js noise reference explains that noise is calculated over several octaves
    (*[https://p5js.org/reference/#/p5/noise](https://p5js.org/reference/#/p5/noise)*).
    Calling the `noiseDetail()` function (*[https://p5js.org/reference/#/p5/noiseDetail](https://p5js.org/reference/#/p5/noiseDetail)*)
    changes both the number of octaves and their importance relative to one another.
    This, in turn, changes the quality of the noise values produced.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: p5.js的噪声参考解释了噪声是通过多个八度（*octaves*）计算的(*[https://p5js.org/reference/#/p5/noise](https://p5js.org/reference/#/p5/noise)*)。调用`noiseDetail()`函数(*[https://p5js.org/reference/#/p5/noiseDetail](https://p5js.org/reference/#/p5/noiseDetail)*)可以改变八度的数量及其相对重要性。这会改变生成的噪声值的质量。
- en: 'If you wanted to color every pixel of a canvas randomly using the `random()`
    function, you would need a nested loop to cycle through the rows and columns of
    pixels and pick a random brightness for each. Note that in p5.js, the pixels are
    arranged in an array with four spots for each: red, green, blue, and alpha. For
    details, see the pixel array video in the “Pixels” track on the Coding Train website
    (*[https://thecodingtrain.com/pixels](https://thecodingtrain.com/pixels)*).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用`random()`函数为画布上的每个像素随机上色，你需要一个嵌套循环来遍历像素的行列，并为每个像素选择一个随机亮度。请注意，在p5.js中，像素以数组的形式排列，每个像素包含四个值：红色、绿色、蓝色和透明度。详情请见“像素”教程中的像素数组视频，网址是(*[https://thecodingtrain.com/pixels](https://thecodingtrain.com/pixels)*)。
- en: '![Image](../images/pg67_Image_51.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg67_Image_51.jpg)'
- en: 'To color each pixel more smoothly according to the `noise()` function, you
    can do the same thing, only instead of calling `random()`, you’d call `noise()`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据`noise()`函数更平滑地给每个像素着色，你可以做同样的事情，只不过不是调用`random()`，而是调用`noise()`：
- en: '![Image](../images/pg67_Image_52.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg67_Image_52.jpg)'
- en: This is a nice start conceptually—the code calculates a noise value for every
    (*x*, *y*) position in a 2D space. The problem is that this won’t have the smooth,
    cloudy quality you want. Incrementing by 1 through the noise space from one pixel
    to the next is too large a jump. Remember, with 1D noise, I incremented the time
    variable by 0.01 each frame, not by 1!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上来说，这是一个不错的起点——代码为2D空间中的每个（*x*，*y*）位置计算噪声值。问题在于，这不会有你想要的平滑、云雾状的效果。从一个像素到下一个像素在噪声空间中增加1的跨度太大了。记住，在1D噪声中，我每帧将时间变量增加了0.01，而不是增加1！
- en: A pretty good solution to this problem is to just use different variables for
    the noise arguments than those you’re using to access the pixels on the canvas.
    For example, you can increment a variable called `xoff` by 0.01 each time `x`
    increases horizontally by 1, and a `yoff` variable by 0.01 each time `y` increases
    vertically by 1 through the nested loops, as shown next.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个不错的办法是，使用与访问画布上像素的变量不同的变量来表示噪声参数。例如，每次`x`在水平方向上增加1时，可以将一个名为`xoff`的变量增加0.01，每次`y`在垂直方向上增加1时，可以将`yoff`变量增加0.01，具体实现见下方的嵌套循环。
- en: '![Image](../images/pg68_Image_53.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg68_Image_53.jpg)'
- en: I have to confess, I’ve done something rather confusing. I used *1D* noise to
    set *two* variables ( `this.x` and `this.y` ) controlling the 2D motion of a walker.
    Then, I promptly moved on to using *2D* noise to set *one* variable ( `bright`
    ) controlling the brightness of each pixel in the canvas.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我得承认，我做了一些相当令人困惑的事情。我用*1D*噪声来设置控制2D行走者运动的*两个*变量（`this.x`和`this.y`）。然后，我立即转而使用*2D*噪声来设置控制画布上每个像素亮度的*一个*变量（`bright`）。
- en: The key difference here is that for the walker, my goal is to have two independent
    *1D* noise values; it’s just a coincidence that I’m using them to move an object
    through *2D* space. The way to accomplish this is to use two offsets ( `this.tx`
    and `this.ty` ) to pull values from different parts of the same 1D noise space.
    Meanwhile, in the 2D noise example, both `xoff` and `yoff` start at 0 because
    I’m looking for a single value (a pixel brightness) for a given point in a 2D
    noise space. The walker is actually navigating two separate 1D noise *paths*,
    whereas the pixels are single values in a 2D space.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键区别是，对于行走者，我的目标是拥有两个独立的*1D*噪声值；我使用它们来移动一个物体通过*2D*空间，完全是巧合。实现这一点的方法是使用两个偏移量（`this.tx`
    和 `this.ty`），从同一个1D噪声空间的不同部分提取值。同时，在2D噪声示例中，`xoff`和`yoff`都从0开始，因为我正在寻找一个特定点在2D噪声空间中的单一值（像素亮度）。行走者实际上是在导航两个独立的1D噪声*路径*，而像素则是2D空间中的单一值。
- en: '![Image](../images/pencil.jpg) **Exercise 0.8**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 0.8**'
- en: Play with color, `noiseDetail()`, and the rate at which `xoff` and `yoff` are
    incremented to achieve different visual effects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 调整颜色、`noiseDetail()`，以及 `xoff` 和 `yoff` 增量的速率，以实现不同的视觉效果。
- en: '![Image](../images/pencil.jpg) **Exercise 0.9**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 0.9**'
- en: Add a third argument to noise that increments once per cycle through `draw()`
    to animate the 2D noise.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `noise` 添加第三个参数，在 `draw()` 每次循环时递增，以便对 2D 噪声进行动画处理。
- en: '![Image](../images/pencil.jpg) **Exercise 0.10**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 0.10**'
- en: Use the noise values as the elevations of a landscape.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用噪声值作为景观的高度。
- en: '![Image](../images/pg69_Image_54.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg69_Image_54.jpg)'
- en: I’ve suggested several traditional uses of Perlin noise in this section. I assigned
    the smooth values of 1D noise to the position of an object to give the appearance
    of wandering. With 2D noise, I generated a cloudy pattern by using smoothed values
    on a plane of pixels. It’s important to remember, however, that Perlin noise values
    are just that—values. They aren’t inherently tied to pixel positions or color.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本节中建议了几种 Perlin 噪声的传统用途。我将 1D 噪声的平滑值分配给物体的位置，呈现出一种漂移的效果。使用 2D 噪声，我通过对像素平面上的平滑值进行处理，生成了云雾状的图案。然而，重要的是要记住，Perlin
    噪声值只是值而已——它们并不直接与像素位置或颜色相关联。
- en: Any example in this book that has a variable could be controlled via Perlin
    noise. When I model a wind force, for instance, its strength could be controlled
    by Perlin noise. The same goes for the angles between the branches in a fractal
    tree pattern, or the speed and direction of objects moving along a grid in a flow-field
    simulation (see [Figure 0.10](ch00.xhtml#ch0fig10)).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的任何例子，只要有变量，都可以通过 Perlin 噪声进行控制。例如，在模拟风力时，其强度可以通过 Perlin 噪声来控制。同样，分形树形图中枝条之间的角度，或者在流场模拟中沿网格移动的物体的速度和方向，也可以使用
    Perlin 噪声来控制（见 [图 0.10](ch00.xhtml#ch0fig10)）。
- en: '![Image](../images/pg69_Image_55.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg69_Image_55.jpg)'
- en: 'Figure 0.10: A tree with Perlin noise (left) and a flow field with Perlin noise
    (right)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.10：左侧为带有 Perlin 噪声的树，右侧为带有 Perlin 噪声的流场
- en: Just as you can overuse randomness, however, it’s easy to fall into the trap
    of overusing Perlin noise. How should an object move? Perlin noise! What color
    should it be? Perlin noise! How fast should it grow? Perlin noise! If that becomes
    your answer to every question, keep reading. My goal here is to introduce you
    to a universe of new possibilities for defining the rules of your systems. After
    all, those rules are yours to define, and the more possibilities at your disposal,
    the more you’ll be able to make thoughtful, informed choices. Randomness and Perlin
    noise are just the first stars in a vast creative cosmos that I’ll explore in
    this book.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你可以过度使用随机性一样，也很容易陷入过度使用 Perlin 噪声的陷阱。物体应该如何移动？Perlin 噪声！物体应该是什么颜色？Perlin
    噪声！物体应该如何生长？Perlin 噪声！如果这成了你对每个问题的答案，继续阅读下去吧。我的目标是向你介绍一个全新的可能性宇宙，用来定义你系统的规则。毕竟，这些规则由你来定义，拥有更多的可能性，你将能够做出更深思熟虑、有根据的选择。随机性和
    Perlin 噪声只是我在本书中将要探索的广阔创意宇宙中的第一颗星星。
- en: As mentioned in the introduction, one way to use this book is to build a single
    project over the course of reading it, incorporating elements from each chapter
    as you go. One such possible project is a simulation of an ecosystem. Imagine
    a population of computational creatures living in and around a digital pond, interacting
    with one another according to various rules. At the end of each chapter, you will
    find this same prompt. My goal is to provide ideas on how to incrementally expand
    your own simulated ecosystem using the concepts explored in that chapter. But
    feel free to invent your own!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在介绍中提到的，使用本书的一种方式是在阅读过程中构建一个单一的项目，将每一章中的元素逐步融入其中。一个这样的项目可能是生态系统的模拟。假设有一群计算生物生活在一个数字池塘及其周围，按照各种规则相互作用。在每一章的结尾，你都会看到相同的提示。我的目标是提供如何利用本章所探讨的概念，逐步扩展你自己模拟生态系统的思路。但也可以尽情发挥自己的创意！
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bird.jpg) **生态系统项目**'
- en: For your first step, develop a set of rules for simulating the real-world behavior
    of a creature, building on top of principles from the random walk or other noise-driven
    motions. Can you simulate a jittery bug that flies in unpredictable ways, or perhaps
    a floating leaf carried by an inconsistent breeze? Start by exploring how much
    you can express a creature’s personality purely through its behavior. Then you
    can think about its visual characteristics.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的第一步中，制定一套规则来模拟生物的现实行为，基于随机游走或其他噪声驱动运动的原则。你能模拟一个飞行轨迹不规则、颤动的昆虫吗？或者模拟一片被不稳定微风吹动的漂浮叶子？从探索如何通过行为完全表达一个生物的个性开始。然后，你可以再考虑它的视觉特征。
- en: Here’s an illustration to help you generate ideas for building an ecosystem
    based on the topics covered in this book. Watch how the illustration evolves in
    each subsequent chapter as new concepts and techniques are introduced.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一张插图，帮助你根据本书中涵盖的主题构建一个生态系统。观察插图在每一章中如何随着新概念和技术的引入而逐步演变。
- en: '![Image](../images/pg71_Image_57.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg71_Image_57.jpg)'
- en: The goal of this book is to demonstrate algorithms and behaviors, so my examples
    will almost always include only a single primitive shape, such as a circle. However,
    I fully expect that you have creative sparks within you, and I encourage you to
    challenge yourself with the designs of the elements you draw on the canvas. If
    translating designs into code is new to you, the book’s illustrator, Zannah Marsh,
    has written a helpful guide on drawing for code, which you can find in the appendix.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是展示算法和行为，因此我的示例几乎总是只包含一个简单的基本形状，比如圆形。然而，我完全相信你内心充满创造力，我鼓励你通过挑战自己设计画布上的元素。如果将设计转化为代码对你来说是新事物，本书的插画师Zannah
    Marsh已经编写了一本关于如何为代码绘图的实用指南，你可以在附录中找到它。
