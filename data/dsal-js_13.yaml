- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 10 LISTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10 列表
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg) |'
- en: 'In the previous chapters we explored algorithms that perform several generic
    tasks, and in this chapter we’ll study data structures for specific objectives,
    beginning with the most basic one: a list of elements. Lists are quite simple,
    but the concepts behind lists appear in many other structures, as you’ll learn
    in the rest of the book. In fact, lists are at the center of the most antiquated
    language still widely in use: the acronym for LISP, created in 1959, stands for
    “list processing.”'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了执行几个通用任务的算法，本章将研究用于特定目标的数据结构，从最基本的开始：元素列表。列表非常简单，但列表背后的概念在许多其他结构中都有体现，正如你将在本书的其余部分中学到的那样。事实上，列表处于仍广泛使用的最古老语言的中心：1959年创建的LISP的缩写代表“列表处理”。
    |
- en: What’s a *list*? A simple definition is that a list is a sequence of elements
    (or values, or nodes), which implies that there’s a first element and that every
    element (except the last) is followed by another element. Another definition,
    recursive in nature, is that a list is either empty (no elements) or formed by
    a specific element, called the head of the list, which is followed by the tail—which
    is another list.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是*列表*？一个简单的定义是，列表是元素（或值，或节点）的序列，这意味着列表中有第一个元素，并且每个元素（除最后一个外）后面都跟着另一个元素。另一种递归的定义是，列表要么为空（没有元素），要么由一个特定元素组成，称为列表的头部，头部后面跟着尾部——尾部又是一个列表。
    |
- en: We’ll start by defining the basic abstract data type (ADT) for lists and how
    to implement it in a couple of ways. (See [Table 10-1](chapter10.xhtml#tab10-1)
    for all operations.) It happens, however, that the ADT has some more important
    variants, so we’ll also consider those, which will lead to implementing other
    structures like stacks, queues, deques, and more.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义列表的基本抽象数据类型（ADT）开始，并探讨如何用几种方式来实现它。（请参见[表10-1](chapter10.xhtml#tab10-1)了解所有操作。）然而，ADT有一些更重要的变体，我们还会考虑这些变体，进而实现其他结构，如栈、队列、双端队列等。
    |
- en: 'Table 10-1: Basic Operations on Lists'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-1：列表的基本操作 |
- en: '| Operation | Signature | Description |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → L | Create a new list. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → L | 创建一个新列表。 |'
- en: '| Empty? | L → boolean | Determine whether the list is empty. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 是否为空？ | L → 布尔值 | 判断列表是否为空。 |'
- en: '| Size | L → number | Count how many elements are in the list. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | L → 数字 | 统计列表中有多少个元素。 |'
- en: '| Add | L × position x value → L | Add a value to the list at a certain position.
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | L × 位置 x 值 → L | 在列表的指定位置添加一个值。 |'
- en: '| Remove | L × position → L | Remove a value from the list at a certain position.
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | L × 位置 → L | 从列表中移除某个位置的值。 |'
- en: '| At | L × position → value &#124; undefined | Given a position, return the
    value at that position. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 在指定位置 | L × 位置 → 值 &#124; 未定义 | 给定位置，返回该位置的值。 |'
- en: '| Find | L × value → boolean | Given a value, find whether it exists in the
    list. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | L × 值 → 布尔值 | 给定一个值，查找它是否存在于列表中。 |'
- en: For some types of lists, such as stacks, queues, or deques, we’ll substitute
    some of the functions in [Table 10-2](chapter10.xhtml#tab10-2) (possibly with
    different names) for the add, remove, and at operations. We may also drop some
    other operations, but we’ll consider them case by case. For instance, instead
    of adding an element at any place in the list, we may want to restrict ourselves
    to adding new elements only at the front or at the back of the list.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型的列表，如栈、队列或双端队列，我们会替换[表10-2](chapter10.xhtml#tab10-2)中的某些函数（可能有不同的名称）来代替添加、移除和指定位置操作。我们还可能会删除其他一些操作，但会根据情况考虑。例如，除了可以在列表中的任何位置添加元素外，我们可能只希望限制只能在列表的前面或后面添加新元素。
    |
- en: 'Table 10-2: Extra Operations on Lists'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-2：列表的额外操作 |
- en: '| Operation | Signature | Description |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Add at front | L × value → L | Add a new value at the front of the list.
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 在前添加 | L × 值 → L | 在列表前面添加一个新值。 |'
- en: '| Add at back | L × value → L | Add a new value at the back of the list. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 在后添加 | L × 值 → L | 在列表末尾添加一个新值。 |'
- en: '| Remove from front | L → value &#124; undefined | Remove a value from the
    front of the list. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 从前移除 | L → 值 &#124; 未定义 | 从列表前面移除一个值。 |'
- en: '| Remove from back | L → value &#124; undefined | Remove a value from the back
    of the list. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 从后移除 | L → 值 &#124; 未定义 | 从列表末尾移除一个值。 |'
- en: '| At front | L → value &#124; undefined | Get the value at the front of the
    list. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 在前 | L → 值 &#124; 未定义 | 获取列表前面的值。 |'
- en: '| At back | L → value &#124; undefined | Get the value at the back of the list.
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 获取最后一个元素 | L → 值 &#124; 未定义 | 获取列表最后一个元素的值。 |'
- en: Finally, we’ll also be able to use lists to represent other ADTs, such as sets
    or maps (see [Chapter 11](chapter11.xhtml)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以使用列表来表示其他 ADT，例如集合或映射（参见 [第 11 章](chapter11.xhtml)）。
- en: Basic Lists
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本列表
- en: Let’s start with the most basic implementation of a list, which may be good
    enough for many applications, and then move on to a dynamic memory version, which
    is able to deal with more complex situations and structures.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从最基本的列表实现开始，这可能对于许多应用来说已经足够，然后再转向动态内存版本，它能够处理更复杂的情况和结构。
- en: '#### Implementing Lists with Arrays'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用数组实现列表'
- en: Given that JavaScript implements *dynamic arrays*, which can grow larger or
    become smaller as needed, using arrays for lists seems logical, and for most applications
    that’s the case. However, expanding an array often requires moving the whole array
    to a new, larger space in memory, so operations may not be as instant. (The inner
    details of how JavaScript allocates space for arrays isn’t clear, but if you keep
    adding elements, at some point, JavaScript will run out of space and have to allocate
    more space somewhere else and move the array there.) Obviously, with small, short
    lists, you won’t be able to perceive the impact, but for large structures, it
    could become noticeable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 实现了*动态数组*，这些数组可以根据需要变大或变小，因此使用数组来表示列表似乎是合乎逻辑的，对于大多数应用来说，确实如此。然而，扩展数组通常需要将整个数组移到新的、更大的内存空间中，因此操作可能不会那么即时。（JavaScript
    如何分配数组的内存空间其内部细节并不明确，但如果不断添加元素，JavaScript 到某个时候会用尽空间，必须为数组分配更多空间并将其移动到其他地方。）显然，对于小型短列表，您可能无法察觉到影响，但对于大型结构，它可能会变得显著。
- en: You can implement all the operations for the ADT in a minimum number of lines,
    taking advantage of available JavaScript methods as follows. create was renamed
    newList to make its function clearer, and Empty? was renamed isEmpty because of
    JavaScript naming rules.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方式利用现有的 JavaScript 方法，最小化代码行数，来实现 ADT 的所有操作。`create` 被重命名为 `newList`，使其功能更加明确，`Empty?`
    被重命名为 `isEmpty`，这是因为 JavaScript 的命名规则。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a new list ❶ is just a matter of producing an empty array. The list
    size is the array’s length ❷, and to check whether a list is empty, test whether
    its size is 0 ❸. Adding an element at a given position ❹ is tailor-made for the
    splice(...) standard method, which is also used to remove an element ❺. Finally,
    accessing the element at a given position ❻ is trivial. (The latest version of
    JavaScript provides an .at(...) method, which is somewhat different from what
    is defined here because of the possibility of using negative indices; see *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at)*.)
    Finally, use the .includes(...) method to see whether a list includes the value
    ❼.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新列表 ❶ 只需生成一个空数组。列表的大小是数组的长度 ❷，要检查列表是否为空，可以测试其大小是否为 0 ❸。在给定位置添加一个元素 ❹ 完美适用于
    `splice(...)` 标准方法，该方法也用于删除元素 ❺。最后，访问给定位置的元素 ❻ 是微不足道的。（JavaScript 的最新版本提供了 `.at(...)`
    方法，这与这里定义的方法有所不同，因为它允许使用负索引；请参见 *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at)*。）最后，使用
    `.includes(...)` 方法检查列表是否包含某个值 ❼。
- en: '[Table 10-3](chapter10.xhtml#tab10-3) shows the performance of these operations.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-3](chapter10.xhtml#tab10-3) 显示了这些操作的性能。'
- en: 'Table 10-3: Performance of Operations for Array-Based Lists'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-3：基于数组的列表操作性能
- en: '| Operation | Performance |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Empty? | O(1) |'
- en: '| Size | O(1) |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | O(1) |'
- en: '| Add | O(n) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(n) |'
- en: '| Remove | O(n) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | O(n) |'
- en: '| At | O(1) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 获取 | O(1) |'
- en: '| Find | O(n) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | O(n) |'
- en: Creating a new list, checking whether it’s empty, getting its size, and accessing
    the element at a given position are all *O*(1) operations. As expected, finding
    a value is *O*(*n*), because the operation needs to go through the whole list.
    On the other hand, adding and removing elements are *O*(*n*) operations, because
    they basically move the whole array to a different place in memory. If you implement
    lists dynamically, these results will change.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新列表、检查它是否为空、获取其大小以及访问给定位置的元素都是 *O*(1) 操作。正如预期的那样，查找一个值是 *O*(*n*)，因为该操作需要遍历整个列表。另一方面，添加和移除元素是
    *O*(*n*) 操作，因为它们基本上是将整个数组移到内存中的不同位置。如果您动态实现列表，这些结果会发生变化。
- en: Implementing Lists with Dynamic Memory
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用动态内存实现链表
- en: 'Languages that support dynamic memory provide a different way to deal with
    varying-length lists: through pointers. You can include a reference to an object
    in another object along the lines of the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 支持动态内存的语言提供了一种处理变长链表的不同方式：通过指针。你可以在另一个对象中包含对某个对象的引用，代码大致如下：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Given only the pointer to the first object, you can list the next object’s name
    with first.next.name, for example; then first.next.next.name would list the third
    object’s name. All of this is standard JavaScript notation. The last object has
    its next attribute with a null value, meaning there’s no next object in the list.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过指向第一个对象的指针，你可以列出下一个对象的名称，例如，first.next.name；然后first.next.next.name将列出第三个对象的名称。所有这些都是标准的JavaScript语法。最后一个对象的next属性为null值，表示链表中没有下一个对象。
- en: '[Figure 10-1](chapter10.xhtml#fig10-1) represents pointers with arrows and
    a null pointer with a line ending in a circle. Of course, you’re not limited to
    having a single pointer in a node; you can have as many as you want. Let’s start
    with a simple case: an example of a list with six elements is shown in [Figure
    10-1](chapter10.xhtml#fig10-1), where first points to the head.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-1](chapter10.xhtml#fig10-1)使用箭头表示指针，用以圆圈结尾的线表示空指针。当然，你不局限于在一个节点中只有一个指针；你可以根据需要拥有多个指针。让我们从一个简单的案例开始：[图10-1](chapter10.xhtml#fig10-1)展示了一个包含六个元素的链表示例，其中first指向链表头。'
- en: '![](../images/Figure10-1.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-1.jpg)'
- en: 'Figure 10-1: A simple list'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1：一个简单的链表
- en: Adding a new element requires changing a pointer. For instance, [Figure 10-2](chapter10.xhtml#fig10-2)
    shows adding an 80 after the 60.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新元素需要更改指针。例如，[图10-2](chapter10.xhtml#fig10-2)展示了在60后添加80。
- en: '![](../images/Figure10-2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-2.jpg)'
- en: 'Figure 10-2: Adding a new element to the list requires changing only a single
    pointer in a node.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2：向链表添加新元素只需要更改一个节点中的指针。
- en: The same result occurs when removing an element; you need to change only a single
    pointer—usually the one from the previous element, or first itself if removing
    the head of the list. In the next example, let’s remove the 60 (see [Figure 10-3](chapter10.xhtml#fig10-3)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 移除一个元素时也会得到相同的结果；你只需要改变一个指针——通常是前一个元素的指针，或者如果移除的是链表头，则是头指针。在下一个示例中，我们将移除60（见[图10-3](chapter10.xhtml#fig10-3)）。
- en: '![](../images/Figure10-3.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-3.jpg)'
- en: 'Figure 10-3: Removing an element from the list also requires just changing
    a single pointer.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3：从链表中移除元素同样只需要改变一个指针。
- en: Adding and removing elements by themselves are *O*(1) operations. (Of course,
    this assumes you already know where to effect the changes and also what other
    element points to the one you wanted to remove.) Let’s consider functioning code
    for all the possible operations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和移除元素本身是*O*(1)操作。（当然，这假设你已经知道在哪里进行更改，并且知道其他元素指向你想要移除的元素。）让我们考虑一下所有可能操作的实现代码。
- en: '##### Creating a List'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 创建一个链表'
- en: 'A list is just an object, which may have a link to another object, and so on.
    An empty list is a null pointer. With that in mind, creating a new, empty list
    is simple, and so is checking whether you have an empty list or calculating a
    list’s size:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 链表只是一个对象，它可能包含指向另一个对象的链接，依此类推。空链表是一个空指针。考虑到这一点，创建一个新的空链表非常简单，检查链表是否为空或计算链表的大小也同样简单：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Creating a list produces a null pointer that eventually points to the list’s
    head ❶. Checking whether a list is empty ❷ means seeing whether the pointer is
    null. Finally, calculating the list’s size is simple with recursion: an empty
    list has a size of 0, and a nonempty list has a size of 1 (for the list’s head)
    plus whatever the list’s tail size is ❸.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个链表会产生一个最终指向链表头的空指针❶。检查链表是否为空❷意味着查看指针是否为空。最后，通过递归计算链表的大小非常简单：空链表的大小为0，非空链表的大小为1（即链表头）加上链表尾部的大小❸。
- en: Adding a Value
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加一个值
- en: 'To figure the list’s nodes, use objects with a value (a key or whatever you
    want to add to the list) and a pointer (ptr) to the following element in the list:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定链表的节点，可以使用包含值（一个键或你想添加到链表的任何内容）和指向链表下一个元素的指针（ptr）作为对象：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The add(...) recursive function gets a pointer to a list and the position in
    which to add the new value. If the pointer is null or if the position is zero
    ❶, the new node goes at the beginning of the list ❷, pointing to whatever was
    the first element of the list earlier. Otherwise, go down the list recursively
    to the next node ❸. After the new value is added, return a pointer to the updated
    list ❹.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`add(...)`递归函数获取一个指向列表的指针以及要添加新值的位置。如果指针为null，或者位置为零 ❶，新节点将插入到列表的开头 ❷，并指向原本是列表第一个元素的部分。否则，递归地移动到下一个节点
    ❸。添加新值后，返回更新后的列表指针 ❹。'
- en: Removing a Value
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 移除一个值
- en: 'To remove an element from a list, you have two options: remove the first element
    (in which case the pointer to the first element of the list must be changed) or
    remove another element in the list (and then modify the pointer in the previous
    node as mentioned earlier). The following code does all of it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要从列表中移除一个元素，你有两个选择：移除第一个元素（此时必须更改指向列表第一个元素的指针），或者移除列表中的其他元素（然后修改前一个节点中的指针，如前所述）。以下代码实现了这些操作：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the list is null, just return it ❶; you can’t do anything else. If it’s not
    null and you want to remove its head, the new list is the list’s tail ❷. Finally,
    if the list isn’t null and you don’t want to remove its head, advance to the next
    place in the list to attempt the removal again ❸, but now the position to remove
    is one less than before. In all cases return a pointer to the list after the removal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表为null，直接返回 ❶；否则，你不能做其他任何事情。如果它不是null，并且你想要移除其头部元素，新列表将是列表的尾部 ❷。最后，如果列表不为null，且你不想移除其头部元素，则继续移动到下一个位置再次尝试移除
    ❸，但此时需要移除的位置比之前少1。在所有情况下，返回移除后的列表指针。
- en: Getting the Value at a Position
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取某位置的值
- en: 'You can get the value at a given position in a naturally recursive way by considering
    several cases. If the list is null, it has no value to return, so you’ll return
    undefined. If the list isn’t empty and the position you asked for is 0, you want
    the first element of the list. If the list isn’t empty and you want some element
    further down the list, advance by one position and apply recursion. The following
    code does exactly that:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过考虑几个情况，以自然递归的方式获取给定位置的值。如果列表为null，则没有值可返回，因此返回undefined。如果列表不为空，且你请求的位置是0，则你需要返回列表的第一个元素。如果列表不为空，而你请求的是位于列表较远位置的元素，则移动到下一个位置并递归处理。以下代码正是实现了这一点：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The logic closely follows the three cases: checking for an empty list ❶, testing
    for the head of the list ❷, and using recursion to advance down the list ❸.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑紧密跟随三个步骤：检查是否为空列表 ❶，测试列表头部 ❷，以及使用递归向下遍历列表 ❸。
- en: Searching for a Value
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 搜索值
- en: 'Finally, you can search a list to see whether it includes a given value. This
    operation isn’t as common, but you’ll do it anyway to gain more experience with
    this structure. The general logic is similar to at(...) in the example you just
    saw. Assume you have a ptr pointer to an element of the list. If the pointer is
    null, the value isn’t in the list. Otherwise, if the object ptr points to has
    the value you want, you’ve found it. If the value isn’t what you want, keep searching
    from the next node onward. Here’s the recursive logic:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以搜索一个列表，查看它是否包含给定的值。这个操作虽然不常见，但你仍然会进行它，以便通过这个结构积累更多经验。一般的逻辑类似于你刚才看到的at(...)示例。假设你有一个指针`ptr`，指向列表中的一个元素。如果指针为null，则表示该值不在列表中。否则，如果指针`ptr`指向的对象包含你想要的值，那么你就找到了。如果值不是你想要的，继续从下一个节点开始搜索。以下是递归逻辑：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the list is empty, ❶ return false. Otherwise, if the head of the list is
    the value you want ❷, return true. If it isn’t what you want, search the list’s
    tail. (Note that you’re grouping the two tests together by using JavaScript’s
    || operator.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表为空，❶ 返回false。否则，如果列表头部的值是你想要的 ❷，则返回true。如果不是你想要的值，继续搜索列表的尾部。（请注意，你通过使用JavaScript的||运算符，将这两个测试合并在一起。）
- en: Considering Performance for Dynamic Memory Lists
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考虑动态内存列表的性能
- en: To wrap up this discussion of dynamic memory lists, let’s analyze their performance
    (see [Table 10-4](chapter10.xhtml#tab10-4)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这部分关于动态内存列表的讨论，让我们分析它们的性能（见[表10-4](chapter10.xhtml#tab10-4)）。
- en: 'Table 10-4: Performance of Operations for Dynamic Memory Lists'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-4：动态内存列表操作的性能
- en: '| Operation | Performance |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 为空？ | O(1) |'
- en: '| Size | O(n) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | O(n) |'
- en: '| Add | O(n) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(n) |'
- en: '| Remove | O(n) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | O(n) |'
- en: '| At | O(n) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 在 | O(n) |'
- en: '| Find | O(n) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | O(n) |'
- en: As with the array-based implementation, creating a new list and checking whether
    it’s empty are both *O*(1) operations, but all other operations become *O*(*n*)!
    This difference suggests that simply implementing arrays with pointers, as was
    shown earlier, isn’t the best solution. However, some varieties of lists that
    have a more specific set of operations suited to their particular requirements
    achieve better performance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于数组的实现一样，创建新列表和检查它是否为空都是*O*(1)操作，但所有其他操作的时间复杂度都变成了*O*(*n*)！这一差异表明，单纯使用指针实现数组（如前所示）并不是最佳解决方案。然而，一些具有更具体操作集的列表，能更好地满足其特定需求，从而实现更好的性能。
    |
- en: Varieties of Lists
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表的种类
- en: For some tasks, a more specialized ADT is needed than the basic ADT and implementation
    for common lists that you explored in the previous section. Specifically, we’ll
    consider stacks, queues, deques, and circular lists, including their specific
    operations and applications.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些任务，可能需要比上一节中探索的常见列表的基本ADT及其实现更专业的ADT。具体来说，我们将考虑栈、队列、双端队列和循环列表，包括它们的特定操作和应用。
    |
- en: Stacks
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 栈
- en: 'A *stack* is a last-in, first-out (LIFO) data structure, similar to an actual
    physical stack of plates: imagine you can add a plate only to the top of the pile
    or remove only the top plate; adding or removing middle plates isn’t allowed.
    Stacks behave in the same way. You’ll add and remove only at the top, and these
    operations are usually known as *push* and *pop*, respectively. You’ll also want
    to check whether a stack is empty (as with common lists) and learn the value at
    the top. (Sometimes the pop operation is defined to return the updated stack and
    also what the top value is. In that case you wouldn’t need an operation to get
    the top value of the stack, since you could just pop it, use it, and push it again.)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种后进先出（LIFO）数据结构，类似于实际的盘子堆：想象一下，你只能将盘子添加到堆顶，或者只能移除顶上的盘子；不允许添加或移除中间的盘子。栈的行为也是如此。你只能在栈顶进行添加和移除操作，这些操作通常称为*压栈*（push）和*弹栈*（pop）。你还需要检查栈是否为空（与常见列表一样），并查看栈顶的值。（有时弹栈操作被定义为返回更新后的栈以及栈顶的值。在这种情况下，你就不需要一个单独的操作来获取栈顶值，因为你可以弹栈，使用栈顶值后再将其压栈。）
    |
- en: '[Table 10-5](chapter10.xhtml#tab10-5) sums up the operations you’ll need, and
    as mentioned previously, you’re dealing with a smaller, more specific set of operations
    here.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[表10-5](chapter10.xhtml#tab10-5)总结了你所需的操作，正如前面提到的，你这里处理的是一个较小、更具体的操作集。'
- en: 'Table 10-5: Operations on Stacks'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-5：栈的操作
- en: '| Operation | Signature | Description |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → S | Create a new stack. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → S | 创建一个新栈。 |'
- en: '| Empty? | S → boolean | Determine whether the stack is empty. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 空吗？ | S → 布尔值 | 确定栈是否为空。 |'
- en: '| Push | S × value → S | Add a value at the top of the stack. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 压栈 | S × 值 → S | 将一个值添加到栈顶。 |'
- en: '| Pop | S → S | Remove the value at the top of the stack. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 弹栈 | S → S | 移除栈顶的值。 |'
- en: '| Top | S → value | Get the value at the top of the stack. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 栈顶 | S → 值 | 获取栈顶的值。 |'
- en: 'Stacks are frequently used in applications. For example, to explore how to
    implement a recursive depth-first process in an iterative fashion by using a stack,
    check out question 13.3 in [Chapter 13](chapter13.xhtml). One uncommon place where
    you’ll find a stack is in Hewlett-Packard calculators that provide reverse Polish
    notation (RPN): you push numbers into a stack, and then operations pop them, do
    whatever calculation you asked, and push the result back in.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 栈在应用中被广泛使用。例如，想了解如何通过使用栈以迭代方式实现递归深度优先过程，可以查看[第13章](chapter13.xhtml)中的第13.3题。栈的一个不常见应用场景是惠普计算器中的逆波兰表示法（RPN）：你将数字压入栈中，然后操作会弹出这些数字，执行所要求的计算，并将结果重新压入栈中。
    |
- en: Stacks are also used in programming languages like FORTH or WebAssembly (WASM),
    as well as page description languages like PostScript. Central processing units
    (CPUs) use stacks for subroutine calls and interruptions. If code is executing
    and an interruption comes in, the current status is pushed into a stack, and the
    interruption is processed; afterward, the normal execution resumes after popping
    the status from the stack. (Obviously, you could have a new interruption while
    processing an old one. In that case, the status for the first interruption is
    also pushed, then the second interruption is processed, and when finished, the
    status for the first interruption is popped to continue processing it.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 栈还用于像FORTH或WebAssembly（WASM）这样的编程语言，以及像PostScript这样的页面描述语言。中央处理单元（CPU）使用栈进行子例程调用和中断。如果代码正在执行并且中断到来，当前状态会被压入栈中，然后处理中断；中断处理完成后，正常执行会从栈中弹出状态并恢复执行。（显然，在处理一个中断时，可能会有新的中断。在这种情况下，第一个中断的状态也会被压入栈中，然后处理第二个中断，处理完成后，第一个中断的状态会被弹出，继续处理它。）
- en: Finally, JavaScript itself implements a stack for calls. Whenever a function
    calls itself, it’s as if the current status and variables were pushed into a stack
    before starting the recursive call. When returning from a recursive call, the
    old status is popped from the stack and execution recommences from where it stopped.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，JavaScript 本身实现了一个调用栈。每当一个函数调用自身时，就好像当前的状态和变量在开始递归调用之前被压入了栈中。当从递归调用返回时，旧的状态会从栈中弹出，执行从停止的地方恢复。
- en: Data Structure
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据结构
- en: Implementing a stack with an array is simple given that you can directly use
    .pop(...) and .push(...)(see question 10.5). Working with linked memory is also
    simple, and you’ll base the code on the functions you wrote for lists. In this
    structure you’ll have a pointer to the first element, the one at the top of the
    stack, and each element will have a .next pointer to the element “below” it. The
    “bottom” element will have a null pointer. [Figure 10-4](chapter10.xhtml#fig10-4)
    shows how it works.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组实现栈很简单，因为你可以直接使用 .pop(...) 和 .push(...)（参见问题 10.5）。使用链式内存也很简单，你将基于你为列表编写的函数来编写代码。在这个结构中，你将有一个指向第一个元素的指针，即栈顶元素，每个元素将有一个指向“下方”元素的
    .next 指针。“底部”元素将有一个空指针。[图 10-4](chapter10.xhtml#fig10-4)显示了它是如何工作的。
- en: '![](../images/Figure10-4.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-4.jpg)'
- en: 'Figure 10-4: A stack implemented with dynamic memory'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4：使用动态内存实现的栈
- en: Pushing a new value onto a nonempty stack just requires adding a new object
    that points to the old top element and changing the top pointer (see [Figure 10-5](chapter10.xhtml#fig10-5)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将新值压入非空栈只需要添加一个新对象，该对象指向原来的栈顶元素，并更改栈顶指针（参见[图 10-5](chapter10.xhtml#fig10-5)）。
- en: '![](../images/Figure10-5.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-5.jpg)'
- en: 'Figure 10-5: Pushing a new element on top of a stack'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-5：将新元素压入栈顶
- en: 'Popping the top element is even simpler: adjust the top pointer to point to
    the next one, as shown in [Figure 10-6](chapter10.xhtml#fig10-6).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出栈顶元素更简单：调整栈顶指针指向下一个元素，如[图 10-6](chapter10.xhtml#fig10-6)所示。
- en: '![](../images/Figure10-6.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-6.jpg)'
- en: 'Figure 10-6: Popping the top element from a stack'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-6：从栈中弹出栈顶元素
- en: In both cases (pushing and popping), you need to make simple changes to the
    logic when dealing with an empty stack.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下（压栈和弹栈），当处理空栈时，你需要对逻辑进行简单的调整。
- en: Implementation
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现
- en: 'A stack is a list, so creating a stack is exactly the same as creating a generic
    list, as shown in the previous section; just change the name:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种列表，因此创建栈和创建通用列表完全相同，如上一节所示；只需更改名称：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Examining the top requires a single line of code (all other operations on stacks
    are also one-liners):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 检查栈顶只需要一行代码（栈上的所有其他操作也都是一行代码）：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For an empty stack, just return undefined; otherwise, stack points to the top
    element, so stack.value is what you want.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空栈，只需返回`undefined`；否则，栈指向栈顶元素，因此栈的值（stack.value）就是你需要的。
- en: 'Pushing a value means you’ll have a new element on top, which points to the
    element that was previously at the top:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 压入一个值意味着栈顶会有一个新元素，这个新元素指向之前的栈顶元素：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This logic also works if the stack is empty. Can you see why?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈为空，这个逻辑也能正常工作。你能看出为什么吗？
- en: 'Finally, popping the top of the stack is also quick:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，弹出栈顶元素也是快速的：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the stack is empty, return it as is. You also could easily change the code,
    for example, to throw an error. For a nonempty stack, just return the tail of
    the stack.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈为空，直接返回栈本身。你也可以轻松修改代码，例如抛出错误。对于非空栈，只需返回栈的尾部。
- en: '##### Performance for Dynamic Memory–Based Stacks'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 基于动态内存的栈性能'
- en: When considering how this stack implementation performs, the results are much
    better than with common lists (see [Table 10-6](chapter10.xhtml#tab10-6)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到此栈实现的性能，结果远比常见列表更好（见[表 10-6](chapter10.xhtml#tab10-6)）。
- en: 'Table 10-6: Performance of Operations for Dynamic Memory–Based Stacks'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-6：基于动态内存的栈操作性能
- en: '| Operation | Performance |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 是否为空？ | O(1) |'
- en: '| Push | O(1) |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 推入 | O(1) |'
- en: '| Pop | O(1) |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 弹出 | O(1) |'
- en: '| Top | O(1) |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 顶端 | O(1) |'
- en: 'All operations require constant time, and that’s optimal. Implementing stacks
    with arrays, the results would *almost* be the same with an exception: pushing
    a new value could require moving the array to a new, larger place in memory, and
    that would make pushing a value an *O*(*n*) operation. In comparison to implementing
    common lists, which brought higher costs for most operations, implementing stacks
    with dynamic memory is just as good, and in a single case, even better. Now consider
    other variations on lists that provide similar results.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都需要常数时间，这是最优的。如果使用数组实现栈，结果*几乎*是相同的，唯一的例外是：推入新值可能需要将数组移动到内存中一个新的、更大的位置，这样推入操作就变成了*O*(*n*)操作。与实现常见的列表相比，后者大多数操作的成本较高，使用动态内存实现栈既一样好，有时甚至更好。现在再考虑其他提供类似结果的列表变体。
- en: Queues
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 队列
- en: '*Queues* are another variant of lists, and they are a first-in, first-out (FIFO)
    data structure. Queues work the same as a line of people waiting for something.
    New people enter the queue at the back (nobody may cut in), and the person at
    the front will exit the queue next. These two operations are *enter* and *exit*
    (or *enqueue* and *dequeue*), and they mimic what happens in real queues. You’ll
    also want to check whether a queue is empty and be able to get the value of the
    front of the queue. [Table 10-7](chapter10.xhtml#tab10-7) shows the operations
    you’ll need.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列*是列表的另一种变体，它是一个先进先出（FIFO）的数据结构。队列的工作方式就像一排等待某事的人。新的人从队列的后面进入（没有人可以插队），前面的人将首先离开队列。这两种操作是*进入*和*退出*（或*入队*和*出队*），它们模拟了现实中排队的情况。你还需要检查队列是否为空，并能够获取队列前端的值。[表
    10-7](chapter10.xhtml#tab10-7)展示了你需要的操作。'
- en: 'Table 10-7: Operations on Queues'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-7：队列的操作
- en: '| Operation | Signature | Description |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → Q | Create a new queue. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → Q | 创建一个新的队列。 |'
- en: '| Empty? | Q → boolean | Determine whether the queue is empty. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 是否为空？ | Q → 布尔值 | 判断队列是否为空。 |'
- en: '| Enter | Q × value → Q | Add a value at the back of the queue. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 进入 | Q × 值 → Q | 在队列的末尾添加一个值。 |'
- en: '| Exit | Q → Q | Remove the value at the front of the queue. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 退出 | Q → Q | 移除队列前端的值。 |'
- en: '| Front | Q → value | Get the value at the front of the queue. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 前端 | Q → 值 | 获取队列前端的值。 |'
- en: An alternative that’s sometimes used is that the *exit* operation returns both
    the updated queue and the value that was removed from the queue, but that’s not
    needed given the *front* operation. You could also have a *rear* operation to
    access the value at the end of the queue, but that’s not common.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有时使用的替代方案是，*退出*操作返回更新后的队列和从队列中移除的值，但考虑到*前端*操作，这并不是必需的。你还可以有一个*尾端*操作来访问队列末尾的值，但这并不常见。
- en: Queues are frequently used in situations where things don’t have to be (or cannot
    be) processed immediately and should be attended to in order such as printer queues
    or call center phone systems that keep you on hold until a representative is free.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 队列通常用于那些不需要（或无法）立即处理的情况，并且应按顺序处理，例如打印队列或呼叫中心电话系统，在代表空闲之前会将你保持在等待状态。
- en: Data Structure
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据结构
- en: Implementing a queue is quite simple using arrays. With linked memory, you need
    pointers to the first and the last nodes of the queue, so you’ll represent a queue
    with an object that has first and last links. Each element in the queue has a
    next pointer to the following element, as shown in [Figure 10-7](chapter10.xhtml#fig10-7).
    (The next element is actually in the previous place in the queue, so prev could
    also be the name of the pointer.)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组实现队列非常简单。对于链式内存，你需要指向队列第一个和最后一个节点的指针，因此你将用一个具有 first 和 last 链接的对象来表示队列。队列中的每个元素都有一个指向下一个元素的
    next 指针，如 [图 10-7](chapter10.xhtml#fig10-7) 所示。（下一个元素实际上位于队列的前一个位置，因此 prev 也可以是指针的名称。）
- en: '![](../images/Figure10-7.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-7.jpg)'
- en: 'Figure 10-7: A queue implemented with dynamic memory'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-7：一个使用动态内存实现的队列
- en: The first element in the queue (the next to exit) is 22; the following is 9\.
    The last place in the queue is a 56\. Adding a new element at the back of the
    queue simply requires modifying the pointer to the last element and the pointer
    in the last element itself (see [Figure 10-8](chapter10.xhtml#fig10-8)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中的第一个元素（即下一个要退出的元素）是 22；接下来的元素是 9。队列的最后一个位置是 56。将新元素添加到队列的末尾只需要修改最后一个元素的指针和最后一个元素本身的指针（见
    [图 10-8](chapter10.xhtml#fig10-8)）。
- en: '![](../images/Figure10-8.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-8.jpg)'
- en: 'Figure 10-8: Adding an element at the back of a queue'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-8：在队列末尾添加一个元素
- en: After adding 80, the previous last element, 56, now points to the 80, and so
    does the last pointer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 80 后，之前的最后一个元素 56 现在指向 80，last 指针也是如此。
- en: Removing the element from the front of the queue is exactly the same as with
    stacks, as shown in [Figure 10-9](chapter10.xhtml#fig10-9).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从队列前端移除元素与栈的操作完全相同，如 [图 10-9](chapter10.xhtml#fig10-9) 所示。
- en: '![](../images/Figure10-9.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-9.jpg)'
- en: 'Figure 10-9: Removing an element from the front of a queue'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-9：从队列前端移除一个元素
- en: You just have to make the first point at whatever the previous first element
    pointed at. Now you’ll see how to implement all of this.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要让第一个指针指向前一个第一个元素所指向的位置。现在我们来看如何实现这一切。
- en: Implementation
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现
- en: 'Creating a new queue and checking whether it’s empty is simple:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的队列并检查它是否为空非常简单：
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The queue is represented by an object with two pointers ❶ that are initially
    null. You can tell that the queue is empty ❷ if one of those pointers is null;
    in fact, either both or none will be null.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 队列由一个包含两个指针 ❶ 的对象表示，初始时这两个指针为 null。如果其中一个指针为 null，便能判断队列为空 ❷；实际上，两个指针都为 null
    或都不为 null。
- en: 'Getting the value at the front (first in line) is easy:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 获取队列前端（排在最前面的元素）的值很容易：
- en: '[PRE12]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the queue is empty, return undefined; otherwise, queue.first points at the
    first element of the queue, and you return its value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列为空，返回 undefined；否则，queue.first 指向队列中的第一个元素，并返回其值。
- en: 'Entering a queue at the last place is a short function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列的最后位置加入元素是一个简单的操作：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the queue was empty ❶, make the first and last pointers point to a new object,
    with a null pointer to the next node in the queue. Otherwise, make the last element
    point to a new one ❷, and then make last point to it too ❸.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列为空 ❶，则让第一个和最后一个指针指向一个新的对象，并将其指向队列中下一个节点的指针设为 null。否则，让最后一个元素指向一个新元素 ❷，然后也让
    last 指针指向它 ❸。
- en: 'Finally, exiting the queue is the same as with stacks, but with a special case
    when the queue becomes empty:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，退出队列的操作与栈相同，但当队列为空时有一个特殊情况：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the queue isn’t empty ❶, you just have to make the first pointer ❷ point
    to the next element in the queue, but if the queue was emptied ❸, you also have
    to fix the last pointer.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列不为空 ❶，你只需要让第一个指针 ❷ 指向队列中的下一个元素；但如果队列已被清空 ❸，你还需要修正最后一个指针。
- en: Performance for Dynamic Memory–Based Queues
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于动态内存的队列性能
- en: Given the similarity of queues and stacks (the only difference is that pop removes
    the first element of the stack, but exit removes the last element of the queue),
    it’s no surprise that performance is the same, as shown in [Table 10-8](chapter10.xhtml#tab10-8).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于队列和栈的相似性（唯一的区别是 pop 移除栈中的第一个元素，而 exit 移除队列中的最后一个元素），因此性能是相同的，正如 [表 10-8](chapter10.xhtml#tab10-8)
    所示。
- en: 'Table 10-8: Performance of Operations for Dynamic Memory–Based Queues'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-8：基于动态内存的队列操作性能
- en: '| Operation | Performance |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 是否为空? | O(1) |'
- en: '| Enter | O(1) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 进入 | O(1) |'
- en: '| Exit | O(1) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 退出 | O(1) |'
- en: '| Front | O(1) |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 前端 | O(1) |'
- en: Again, all operations require constant time; using an array wouldn’t be as good
    (see question 10.9).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，所有操作都需要常数时间；使用数组不如这种实现有效（参见问题10.9）。
- en: Deques
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双端队列
- en: The next variation on lists doesn’t really have very many applications (stacks
    and queues are far more common), but their implementation introduces the interesting
    concept of double (forward and backward) linking. Assume a queue where entering
    or exiting is allowed at both ends. (Think of a train with several cars; new cars
    can be added only at the ends, and cars can be removed only from the ends.) This
    type of list is called a *deque* (pronounced like “deck”), which stands for “double-ended
    queue.”
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的下一个变体并没有很多应用场景（栈和队列更为常见），但其实现引入了一个有趣的概念——双向链接（前向和后向）。假设一个队列，允许从两端进入或退出。（可以想象一列火车，多个车厢可以添加到车头或车尾，但车厢只能从两端移除。）这种类型的列表被称为*双端队列*（Deque，发音类似“deck”），即“双端队列”。
- en: '[Table 10-9](chapter10.xhtml#tab10-9) shows operations necessary for deques.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[表10-9](chapter10.xhtml#tab10-9)展示了双端队列所需的操作。'
- en: 'Table 10-9: Operations on Deques'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-9：双端队列的操作
- en: '| Operation | Signature | Description |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → D | Create a new deque. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → D | 创建一个新的双端队列。 |'
- en: '| Empty? | D → boolean | Determine whether deque is empty. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 空？ | D → boolean | 判断双端队列是否为空。 |'
- en: '| Enter at front | D × value → D | Add a value at the front of the deque. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 从前端进入 | D × value → D | 在双端队列前端添加一个值。 |'
- en: '| Enter at back | D × value → D | Add a value at the back of the deque. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 从后端进入 | D × value → D | 在双端队列后端添加一个值。 |'
- en: '| Exit from front | D → D | Remove the value at the front of the deque. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 从前端退出 | D → D | 移除双端队列前端的值。 |'
- en: '| Exit from back | D → D | Remove the value at the back of the deque. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 从后端退出 | D → D | 移除双端队列后端的值。 |'
- en: '| Front | D → value | Get the value at the front of the deque. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 前端 | D → value | 获取双端队列前端的值。 |'
- en: '| Back | D → value | Get the value at the back of the deque. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 后端 | D → value | 获取双端队列后端的值。 |'
- en: Basically a deque is the same as a queue, except that you enter at or exit from
    both ends. Similarly, you also need operations to get the values at both extremes;
    for queues, you looked at only the first (front) item.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，双端队列与队列相同，唯一的区别是你可以从两端进入或退出。同样，你还需要能够获取双端队列两端的值；对于队列，你只需要查看第一个（前端）项。
- en: Data Structure
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'Is it possible to implement deques with linked memory? Since you now have full
    symmetry for all operations, you need links that go in both directions. [Figure
    10-10](chapter10.xhtml#fig10-10) shows how it works: if you were to drop all left-pointing
    links (or all right-pointing links), you’d be left with a common queue. In this
    structure, you’ll again have first and last pointers to the extremes of the deque,
    and each node will have next and prev (previous) pointers to the contiguous nodes.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以使用链式内存实现双端队列？由于现在所有操作都具有完全的对称性，你需要能够双向连接的链接。[图10-10](chapter10.xhtml#fig10-10)展示了其工作原理：如果你删除所有指向左侧的链接（或删除所有指向右侧的链接），你将剩下一个普通的队列。在这种结构中，你将再次拥有指向双端队列两端的第一个和最后一个指针，并且每个节点将拥有指向相邻节点的next和prev（前一个）指针。
- en: '![](../images/Figure10-10.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-10.jpg)'
- en: 'Figure 10-10: Implementing a deque requires two pointers at each node.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-10：实现双端队列需要在每个节点上有两个指针。
- en: Because of the symmetry, operations on one end are totally analogous to the
    same operation at the other end, so let’s just work at the end of the deque (see
    [Figure 10-11](chapter10.xhtml#fig10-11)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对称性，双端队列两端的操作是完全类似的，因此我们只讨论双端队列一端的操作（见[图10-11](chapter10.xhtml#fig10-11)）。
- en: '![](../images/Figure10-11.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-11.jpg)'
- en: 'Figure 10-11: Adding an element at one extreme of a deque'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-11：在双端队列的一个极端添加元素
- en: Adding a value at the end is the same as for a queue, with the addition that
    the newly added node must point to the node that was previously at the end of
    the deque. (Working at the other end is exactly the same, so we’ll skip it.)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在末尾添加一个值与队列的操作相同，不同之处在于新增的节点必须指向原先位于双端队列末尾的节点。（从另一端操作完全相同，因此我们跳过不谈。）
- en: Removing an element from the end of the deque is the same as shown in [Figure
    10-11](chapter10.xhtml#fig10-11), but from the bottom up; see [Figure 10-12](chapter10.xhtml#fig10-12).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从双端队列末尾移除元素与[图10-11](chapter10.xhtml#fig10-11)所示相同，只是从底部向上操作；请参见[图10-12](chapter10.xhtml#fig10-12)。
- en: '![](../images/Figure10-12.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-12.jpg)'
- en: 'Figure 10-12: Removing an element from one extreme of a deque'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-12：从双端队列的一个极端移除元素
- en: When removing a value from the back, modify the corresponding pointer (last)
    and the next pointer of the new extreme of the deque; working at the other extreme
    entails modifying first and a prev pointer.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 删除后端的值时，修改相应的指针（last）和双端队列新极端的下一个指针；在另一端工作时，涉及到修改 first 和 prev 指针。
- en: Deletions are simple in doubly linked lists. If you have a pointer to some element
    and want to remove it (say, the 60 in the list shown in [Figure 10-13](chapter10.xhtml#fig10-13)),
    doing so is easy.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向链表中，删除操作很简单。如果你有指向某个元素的指针并想删除它（例如，删除[图 10-13](chapter10.xhtml#fig10-13)中显示的列表中的60），操作非常简单。
- en: '![](../images/Figure10-13.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-13.jpg)'
- en: 'Figure 10-13: Removing an element somewhere in a deque'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-13：从双端队列中删除某个元素
- en: 'The key is that all nodes have pointers to both neighbors, so you have to do
    something along the lines of the following code, assuming that ptr points to the
    node to be removed:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是所有节点都有指向两个邻居的指针，因此你必须执行类似以下代码的操作，假设 ptr 指向要删除的节点：
- en: '[PRE15]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This kind of pointer work is common, but it can be jarring the first time you
    see it, so it merits careful study. The code works for elements in the middle
    of the deque. For elements at both ends, you need to make minor changes, as well
    as adjust at least one of (and possibly both) the first and last elements. Even
    if you don’t ever use deques, the concept of double links and the ease of extracting
    any element from the middle is the key takeaway from this section. You’ll use
    this for circular lists later in this chapter and in future chapters as well.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这种指针操作很常见，但第一次看到时可能会让人感到困惑，因此需要仔细研究。该代码适用于双端队列中间的元素。对于两端的元素，你需要进行一些小的调整，并至少调整（可能是两个）首尾元素。即使你从未使用过双端队列，双向链接的概念以及从中间提取任何元素的便利性，都是本节的关键要点。以后在本章和未来章节中，你将会使用这一概念处理循环链表。
- en: Implementation
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现
- en: 'Creating a deque and checking whether it’s empty are exactly the same as with
    a queue, since you have the same first and last pointers:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建双端队列并检查其是否为空的操作与队列完全相同，因为你有相同的首尾指针：
- en: '[PRE16]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Adding a new element to a deque is the same as entering a queue; the only difference
    is that you can add it at either extreme, subtly changing what pointers you modify:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 向双端队列（deque）添加一个新元素与向队列中插入元素相同；唯一的区别是你可以在任一端添加元素，这微妙地改变了你需要修改的指针：
- en: '[PRE17]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You use an auxiliary function to create a new node with its pair of pointers
    ❶. Entering at the front requires changing both first and last if the deque is
    empty ❷. Otherwise, use the same kind of pointer work as for queues ❸. The code
    for entering a deque at the back is exactly the same, in symmetrical fashion:
    just change last to first and prev to next ❹.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用辅助函数创建一个新节点，并为其设置一对指针 ❶。如果双端队列为空，插入前端时需要同时修改首尾指针 ❷。否则，使用与队列相同的指针操作 ❸。从双端队列的后端插入的代码与此完全相同，且具有对称性：只需将
    last 改为 first，prev 改为 next ❹。
- en: 'Similarly, removing an element from the front or back of a deque is the same
    as exiting from a queue; both algorithms are symmetrical:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，从双端队列的前端或后端删除一个元素与从队列中删除元素相同；这两种算法是对称的：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the deque is empty ❶, there’s nothing to do. Otherwise, to remove the front
    element, advance to the next element of the deque ❷, and if that element is null
    ❸, you also adjust the last element. A bit of symmetry produces exactly the same
    “remove last” operation ❹.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果双端队列为空 ❶，则无需进行任何操作。否则，若要删除前端元素，先前进到双端队列的下一个元素 ❷，如果该元素为 null ❸，你还需要调整最后一个元素。对称的操作产生了完全相同的“删除最后一个”操作
    ❹。
- en: Performance for Dynamic Memory–Based Deques
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于动态内存的双端队列性能
- en: 'A deque is essentially a queue that goes both ways: half of its operations
    are exactly the same as for queues, and the rest are symmetrical, but with the
    same style of code, so the results are not unexpected (see [Table 10-10](chapter10.xhtml#tab10-10)).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列本质上是一个双向队列：它的一半操作与队列完全相同，另外一半则是对称的，但代码风格相同，因此结果并不意外（见[表 10-10](chapter10.xhtml#tab10-10)）。
- en: 'Table 10-10: Performance of Operations for Dynamic Memory–Based Deques'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-10：基于动态内存的双端队列操作性能
- en: '| Operation | Performance |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 空吗？ | O(1) |'
- en: '| Enter at front (or at back) | O(1) |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 进入前端（或后端） | O(1) |'
- en: '| Exit from front (or from back) | O(1) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 从前端（或后端）退出 | O(1) |'
- en: '| Front (or back) | O(1) |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 前端（或后端） | O(1) |'
- en: All the operations of deques perform the same as those of queues. Everything
    is *O*(1).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列的所有操作与队列相同，所有操作都是 *O*(1)。
- en: Circular Lists
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 循环链表
- en: Circular lists are useful for “round-robin”–style processing. For example, PCs
    place apps in a list and cycle through them, and after the last completes, processing
    returns to the first. (You’ll see another example of this when looking at Fibonacci
    heaps in [Chapter 15](chapter15.xhtml).) Instead of an open-ended list, a circular
    list joins the first and last elements together. This kind of ADT allows for continuous
    processing, with a “current” element and the possibility of advancing to the next,
    but cyclically. [Table 10-11](chapter10.xhtml#tab10-11) shows the operations we’ll
    need.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表非常适用于“轮流处理”样式的任务。例如，PC会将应用程序放入一个链表中，并循环遍历它们，最后一个完成后，处理将回到第一个（当你查看[第15章](chapter15.xhtml)中的斐波那契堆时，你还会看到另一个例子）。与开放式链表不同，循环链表将第一个元素和最后一个元素连接在一起。这种ADT（抽象数据类型）允许持续的处理，具有一个“当前”元素并能够循环前进到下一个元素。[表10-11](chapter10.xhtml#tab10-11)展示了我们需要的操作。
- en: 'Table 10-11: Operations on Circular Lists'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-11：循环链表的操作
- en: '| Operation | Signature | Description |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → C | Create a new circular list. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → C | 创建一个新的循环链表。 |'
- en: '| Empty? | C → boolean | Determine whether the circular list is empty. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 空? | C → 布尔值 | 判断循环链表是否为空。 |'
- en: '| Add | C × value → C | Add a new value before the current one and make it
    current. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | C × 值 → C | 在当前元素之前添加一个新值并将其设为当前元素。 |'
- en: '| Remove | C → C | Remove the current value from the list and advance. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | C → C | 移除当前值并前进。 |'
- en: '| Current | C → value | Get the current value from the circular list. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 当前 | C → 值 | 从循环链表中获取当前值。 |'
- en: '| Advance | C → C | Advance to the next value in the list cyclically. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 前进 | C → C | 循环地前进到链表中的下一个值。 |'
- en: Some variations and changes are possible. You could require a “go back” (retreat)
    operation that performs in the opposite direction as an “advance.” You could also
    use an “add after current,” but you could achieve that by first advancing and
    then using the add operation. These changes aren’t significant, and the structure
    is useful as shown. The work you did with deques, however, will help in implementing
    it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有些变种和变化是可能的。例如，你可以要求一个“回退”操作，它在与“前进”相反的方向上执行。你还可以使用“在当前元素后添加”操作，但你也可以先前进，然后使用添加操作来实现。这些变化不大，且如所示的结构非常有用。然而，你之前在双端队列中的工作会帮助你实现这个功能。
- en: Data Structure
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据结构
- en: Circular lists can be singly or doubly linked, but the latter is the most useful
    version. Basically, you just want a list that has no first or last element. Instead,
    the elements form a circle, and you’ll have a pointer to the element that’s being
    processed currently. [Figure 10-14](chapter10.xhtml#fig10-14) shows such a list;
    the nodes have next and prev pointers, as with deques.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表可以是单向或双向链接，但后者是最有用的版本。基本上，你只需要一个没有首尾元素的链表。相反，元素们形成一个圆圈，你将有一个指针指向当前正在处理的元素。[图10-14](chapter10.xhtml#fig10-14)展示了这样一个链表；这些节点拥有与双端队列相同的`next`和`prev`指针。
- en: '![](../images/Figure10-14.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-14.jpg)'
- en: 'Figure 10-14: A circular list also needs two pointers at every node.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-14：循环链表在每个节点都需要两个指针。
- en: The “advance to the next” operation simply requires following the next link
    (see [Figure 10-15](chapter10.xhtml#fig10-15)).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: “前进到下一个”操作只需要跟随`next`链接（见[图10-15](chapter10.xhtml#fig10-15)）。
- en: '![](../images/Figure10-15.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-15.jpg)'
- en: 'Figure 10-15: Moving along the list is possible in both directions.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-15：沿链表移动可以在两个方向上进行。
- en: Adding a new element before the current one is also a matter of dealing with
    several pointers (see [Figure 10-16](chapter10.xhtml#fig10-16)).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前元素之前添加一个新元素也是通过处理多个指针来完成的（见[图10-16](chapter10.xhtml#fig10-16)）。
- en: '![](../images/Figure10-16.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-16.jpg)'
- en: 'Figure 10-16: Adding an element to a circular list is done by changing a few
    pointers.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-16：向循环链表添加元素是通过更改几个指针来完成的。
- en: Removing the current element requires some juggling with pointers, but as with
    deques, having links in both directions makes it easy (see [Figure 10-17](chapter10.xhtml#fig10-17)).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 移除当前元素需要一些指针操作，但与双端队列类似，双向链接使得这一过程变得简单（见[图10-17](chapter10.xhtml#fig10-17)）。
- en: '![](../images/Figure10-17.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-17.jpg)'
- en: 'Figure 10-17: Removing an element from a circular list also requires just a
    few pointer changes.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-17：从循环链表中移除元素也只需要做几个指针的调整。
- en: Operations in a circular list require essentially the same kind of logic that
    you’ve already explored. Now consider an actual implementation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表中的操作基本上需要你已经探索过的相同类型的逻辑。现在，考虑一个实际的实现。
- en: Implementation
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现
- en: 'Creating a circular list is the same as for common lists, and so is testing
    whether such a list is empty. The only difference is the naming:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个循环列表与创建普通列表相同，测试该列表是否为空也一样。唯一的区别是命名：
- en: '[PRE19]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In a stack, you had a pointer to the top element. Here you have a pointer to
    some element in the list, the current one.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈中，你有一个指向顶部元素的指针。在这里，你有一个指向列表中某个元素的指针，即当前元素。
- en: 'Adding a new node merely involves more work with pointers:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新节点仅仅涉及更多的指针操作：
- en: '[PRE20]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the list is empty, it consists of a single node ❶ whose next and prev links
    point to itself. Otherwise, the new node is between the nodes that circ (the current
    node) and circ.prev (the previous one) point to. Fix the four involved pointers
    so that the new node lies in its correct place ❷. At the end, return the new node
    ❸.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表为空，它由一个单独的节点组成❶，其 next 和 prev 链接指向自身。否则，新节点位于 circ（当前节点）和 circ.prev（前一个节点）所指向的节点之间。修复涉及的四个指针，使得新节点位于正确的位置❷。最后，返回新节点❸。
- en: 'Removing the current element is a tad shorter:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 删除当前元素要简单一些：
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You have three distinct cases to consider. If the circular list is empty, do
    nothing ❶. If the list consists of a single element (and in that case both its
    next and prev links point to itself), return a new, empty list ❷. Finally, if
    the list isn’t empty, make the nodes at circ.prev and circ.next (the ones that
    surround the current node) point to each other ❸.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑三种不同的情况。如果循环列表为空，什么也不做❶。如果列表只有一个元素（此时它的 next 和 prev 链接都指向自身），返回一个新的空列表❷。最后，如果列表不为空，则让
    circ.prev 和 circ.next（即围绕当前节点的节点）互相指向❸。
- en: 'Finally, getting the current value and advancing to the next one are both one-liners:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取当前值并推进到下一个值都只需要一行代码：
- en: '[PRE22]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The current element of an empty list is just undefined ❶; otherwise, circ.value
    gives its value. Advancing the current element to the next position, for a nonempty
    circular list, is just a matter of going to the next node ❷.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表的当前元素只是未定义❶；否则，circ.value 给出它的值。对于非空循环列表，将当前元素推进到下一个位置只是去下一个节点❷。
- en: Performance for Circular Lists
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 循环列表的性能
- en: Checking all the implemented functions, none of them require loops or recursion,
    so as with other data structures in this chapter, the performance is constant
    (see [Table 10-12](chapter10.xhtml#tab10-12)).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 检查所有已实现的函数，发现没有一个需要循环或递归，因此与本章其他数据结构一样，性能是常数的（见[表10-12](chapter10.xhtml#tab10-12)）。
- en: 'Table 10-12: Performance of Operations for Circular Lists'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-12：循环列表操作的性能
- en: '| Operation | Performance |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 空吗？ | O(1) |'
- en: '| Add | O(1) |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(1) |'
- en: '| Remove | O(1) |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | O(1) |'
- en: '| Current | O(1) |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 当前 | O(1) |'
- en: '| Advance | O(1) |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 推进 | O(1) |'
- en: 'You could use arrays, of course, but the performance for some operations, such
    as adding a new value, would suffer because of the possible need to move the whole
    array to a new place in memory: *O*(*n*).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用数组，但某些操作的性能，比如添加新值，会受到影响，因为可能需要将整个数组移动到内存中的新位置：*O*(*n*)。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we examined several linear structures and a circular one that
    are based on linked memory, and you’ll have the opportunity to reuse them in later
    chapters. Linked memory is key for all the dynamic structures we’ll explore in
    this book, and in upcoming chapters, we’ll work with more complex structures to
    enable better performance for more complex operations.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们检查了几种基于链接内存的线性结构和循环结构，你将在后续章节中有机会重用它们。链接内存是我们将要探讨的所有动态结构的关键，未来的章节中，我们将使用更复杂的结构，以提高更复杂操作的性能。
- en: Questions
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: '**10.1  Iterating Through Lists**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.1  遍历列表**'
- en: All the examples in the “Implementing Lists with Dynamic Memory” section on
    [page 180](chapter10.xhtml#pg_180) were written using recursion, but they are
    often coded in iterative fashion. Can you rewrite them in that way?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: “使用动态内存实现列表”部分中的所有示例都使用了递归编写，但它们通常是以迭代方式实现的。你能以这种方式重写它们吗？
- en: '**10.2  Going the Other Way**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.2  反向操作**'
- en: Implement a reverse(list) algorithm that given a list will reverse it, meaning
    the first element becomes the last, the second element the next to last, and so
    on.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个reverse(list)算法，给定一个列表，将其反转，即第一个元素变为最后一个，第二个元素变为倒数第二个，以此类推。
- en: '**10.3  Joining Forces**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.3  联手协作**'
- en: Implement an append(list1, list2) function that given two lists will append
    the second one to the first one.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个append(list1, list2)函数，给定两个列表，将第二个列表追加到第一个列表后面。
- en: '**10.4  Unloop the Loop**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.4  解除循环**'
- en: Imagine you are given a list that may or may not have a loop; in other words,
    instead of eventually finishing with a null pointer, there may be an element that
    points back to some previous element, so the list has a loop. Can you write a
    hasALoop(list) function that given a list will determine whether it has a loop?
    Your solution should use constant extra memory; don’t assume anything about the
    length of the list, because it may be incredibly long.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个列表，它可能有或没有循环；换句话说，列表可能不会最终以空指针结束，而是有一个元素指向之前的某个元素，这样列表就形成了循环。你能写一个 `hasALoop(list)`
    函数，给定一个列表判断它是否有循环吗？你的解决方案应该使用常量的额外内存；不要假设列表的长度，因为它可能非常长。
- en: '**10.5  Arrays for Stacks**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.5  用于栈的数组**'
- en: Since JavaScript provides operations on arrays like .pop(...) and .push(...),
    implementing a stack with an array should be pretty straightforward. Can you write
    appropriate code?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 提供了对数组的操作，如 .pop(...) 和 .push(...)，因此使用数组实现栈应该是相当简单的。你能写出合适的代码吗？
- en: '**10.6  Stack Printing**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.6  栈打印**'
- en: Can you write code that prints out a stack’s contents in top-to-bottom order?
    Could you print it in reverse (bottom-to-top) order?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你能写一个打印栈内容的代码，按从上到下的顺序打印吗？你能按反向顺序（从下到上）打印它吗？
- en: '**10.7  Height of a Stack**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.7  栈的高度**'
- en: Suppose you need to know how many elements are in a stack. How could you implement
    this?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要知道栈中有多少个元素。你如何实现这个功能？
- en: '**10.8  Maximum Stack**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.8  最大栈**'
- en: Suppose that you need a stack for some process, but you also need to know, after
    each push or pop, the maximum value in the stack. How can you implement this efficiently
    without having to go through the whole stack every time?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要一个栈来进行某些操作，但你还需要在每次压栈或弹栈后，知道栈中的最大值。你如何高效地实现这一点，而不必每次都遍历整个栈？
- en: '**10.9  Queued Arrays**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.9  排队数组**'
- en: In a previous question, you saw that JavaScript provided operations that made
    it simple to emulate a stack with arrays. Is the same true for queues? How would
    you emulate queues with arrays? What would the performance of such an implementation
    be?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的问题中，你看到 JavaScript 提供的操作使得使用数组模拟栈变得非常简单。那么队列也是这样吗？你如何用数组模拟队列？这种实现的性能如何？
- en: '**10.10  Queue Length**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.10  队列长度**'
- en: Write a function that given a queue will count how many values are in it; in
    other words, find the queue’s length.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个队列，计算其中有多少个值；换句话说，找出队列的长度。
- en: '**10.11  Queueing for Sorting**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.11  排序队列**'
- en: In [Chapter 6](chapter6.xhtml) you implemented radix sort with arrays, but using
    queues and linked memory is more efficient. Can you rewrite the algorithm accordingly?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第六章](chapter6.xhtml)中，你使用数组实现了基数排序，但使用队列和链式内存更高效。你能根据这个调整算法吗？
- en: '**10.12  Stacked Queues**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.12  栈式队列**'
- en: Imagine that you needed to use a queue for some program, but all you had was
    a library that implemented stacks. With some trickery, you can simulate a queue
    by using a pair of stacks; can you see how? (You’ll explore this strategy in [Chapter
    18](chapter18.xhtml).)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要使用队列来编写某个程序，但你只有一个实现了栈的库。通过一些技巧，你可以使用一对栈来模拟队列；你能理解其中的原理吗？（你将在[第18章](chapter18.xhtml)中进一步探讨这个策略。）
- en: '**10.13  Palindrome Detection**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.13  回文检测**'
- en: 'How could you use a deque to decide whether a string is a palindrome? Palindromes
    are words that can be read the same way forward or backward, like “Hannah” or
    “radar,” or ignoring spaces and punctuation “Step on no pets” or “A man, a plan,
    a canal: Panama.”'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '你如何使用双端队列（deque）来判断一个字符串是否是回文？回文是指正着读或反着读都相同的单词，如“Hannah”或“radar”，或者忽略空格和标点符号后的“Step
    on no pets”或“A man, a plan, a canal: Panama。”'
- en: '**10.14  Circular Listing**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.14  循环列表**'
- en: Implement a function to list all the contents of a circular list; take care
    not to go into a loop.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个函数来列出循环列表的所有内容；小心不要进入循环。
- en: '**10.15  Joining Circles**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.15  连接圆圈**'
- en: Suppose you have two circular lists. How could you join them into a single,
    larger list? For simplicity, assume neither of the lists is empty.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个循环列表。你如何将它们合并成一个更大的列表？为简单起见，假设这两个列表都不是空的。
