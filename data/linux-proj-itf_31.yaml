- en: 'Chapter 31. Threads: Thread Safety and Per-Thread Storage'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第31章。线程：线程安全性和每线程存储
- en: This chapter extends the discussion of the POSIX threads API, providing a description
    of thread-safe functions and one-time initialization. We also discuss how to use
    thread-specific data or thread-local storage to make an existing function thread-safe
    without changing the function’s interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章扩展了POSIX线程API的讨论，提供了线程安全函数和一次性初始化的描述。我们还讨论了如何使用线程特定数据或线程局部存储，使现有的函数变得线程安全，而无需更改函数的接口。
- en: Thread Safety (and Reentrancy Revisited)
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全性（和可重入性的再讨论）
- en: 'A function is said to be *thread-safe* if it can safely be invoked by multiple
    threads at the same time; put conversely, if a function is not thread-safe, then
    we can’t call it from one thread while it is being executed in another thread.
    For example, the following function (similar to code that we looked at in [Protecting
    Accesses to Shared Variables: Mutexes](ch30.html#protecting_accesses_to_shared_variables
    "Protecting Accesses to Shared Variables: Mutexes")) is not thread-safe:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数可以被多个线程同时安全调用，则称该函数是*线程安全的*；换句话说，如果一个函数不是线程安全的，则我们不能在一个线程执行它时从另一个线程调用它。例如，下面的函数（类似于我们在[保护共享变量的访问：互斥锁](ch30.html#protecting_accesses_to_shared_variables
    "保护共享变量的访问：互斥锁")中看到的代码）不是线程安全的：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If multiple threads invoke this function concurrently, the final value in *glob*
    is unpredictable. This function illustrates the typical reason that a function
    is not thread-safe: it employs global or static variables that are shared by all
    threads.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个线程同时调用此函数，*glob*中的最终值是不可预测的。该函数说明了一个函数不是线程安全的典型原因：它使用了所有线程共享的全局或静态变量。
- en: There are various methods of rendering a function thread-safe. One way is to
    associate a mutex with the function (or perhaps with all of the functions in a
    library, if they all share the same global variables), lock that mutex when the
    function is called, and unlock it when the mutex returns. This approach has the
    virtue of simplicity. On the other hand, it means that only one thread at a time
    can execute the function—we say that access to the function is *serialized*. If
    the threads spend a significant amount of time executing this function, then this
    serialization results in a loss of concurrency, because the threads of a program
    can no longer execute in parallel.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以使一个函数变得线程安全。一种方法是将互斥锁与该函数（或者可能是与所有在库中共享相同全局变量的函数）关联，在调用该函数时锁定互斥锁，并在互斥锁返回时解锁它。这种方法的优点是简单。另一方面，这意味着一次只有一个线程可以执行该函数——我们称访问该函数是*串行化的*。如果线程在执行此函数时花费了大量时间，则这种串行化会导致并发性丧失，因为程序的线程无法再并行执行。
- en: A more sophisticated solution is to associate the mutex with a shared variable.
    We then determine which parts of the function are critical sections that access
    the shared variable, and acquire and release the mutex only during the execution
    of these critical sections. This allows multiple threads to execute the function
    at the same time and to operate in parallel, except when more than one thread
    needs to execute a critical section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的解决方案是将互斥锁与共享变量关联。然后，我们确定函数的哪些部分是访问共享变量的临界区，并且只在这些临界区的执行过程中获取和释放互斥锁。这允许多个线程同时执行该函数并进行并行操作，除非多个线程需要执行一个临界区。
- en: Non-thread-safe functions
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非线程安全的函数
- en: To facilitate the development of threaded applications, all of the functions
    specified in SUSv3 are required to be implemented in a thread-safe manner, except
    those listed in [Table 31-1](ch31.html#functions_that_susv3_does_not_require_to
    "Table 31-1. Functions that SUSv3 does not require to be thread-safe"). (Many
    of these functions are not discussed in this book.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进线程应用程序的开发，SUSv3中规定的所有函数都必须以线程安全的方式实现，除了在[表31-1](ch31.html#functions_that_susv3_does_not_require_to
    "表31-1. SUSv3不要求线程安全的函数")中列出的函数。（这些函数中的许多在本书中未讨论。）
- en: 'In addition to the functions listed in [Table 31-1](ch31.html#functions_that_susv3_does_not_require_to
    "Table 31-1. Functions that SUSv3 does not require to be thread-safe"), SUSv3
    specifies the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在[表31-1](ch31.html#functions_that_susv3_does_not_require_to "表31-1. SUSv3不要求线程安全的函数")中列出的函数，SUSv3还规定了以下内容：
- en: The *ctermid()* and *tmpnam()* functions need not be thread-safe if passed a
    `NULL` argument.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递`NULL`参数，则*ctermid()*和*tmpnam()*函数不需要是线程安全的。
- en: The *wcrtomb()* and *wcsrtombs()* functions need not be thread-safe if their
    final argument (*ps*) is `NULL`.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最终参数（*ps*）为`NULL`，则函数*wcrtomb()*和*wcsrtombs()*不需要是线程安全的。
- en: 'SUSv4 modifies the list of functions in [Table 31-1](ch31.html#functions_that_susv3_does_not_require_to
    "Table 31-1. Functions that SUSv3 does not require to be thread-safe") as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv4对[表31-1](ch31.html#functions_that_susv3_does_not_require_to "表31-1。SUSv3不要求线程安全的函数")中的函数列表进行了修改，如下所示：
- en: The *ecvt()*, *fcvt()*, *gcvt()*, *gethostbyname()*, and *gethostbyaddr()* are
    removed, since these functions have been removed from the standard.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这些函数已从标准中移除，*ecvt()*, *fcvt()*, *gcvt()*, *gethostbyname()*, 和 *gethostbyaddr()*
    被移除。
- en: The *strsignal()* and *system()* functions are added. The *system()* function
    is nonreentrant because the manipulations that it must make to signal dispositions
    have a process-wide effect.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增了*strsignal()*和*system()*函数。*system()*函数是不可重入的，因为它必须对信号处理做出操作，这些操作会影响整个进程。
- en: The standards do not prohibit an implementation from making the functions in
    [Table 31-1](ch31.html#functions_that_susv3_does_not_require_to "Table 31-1. Functions
    that SUSv3 does not require to be thread-safe") thread-safe. However, even if
    some of these functions are thread-safe on some implementations, a portable application
    can’t rely on this to be the case on all implementations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 标准并不禁止实现使[表31-1](ch31.html#functions_that_susv3_does_not_require_to "表31-1。SUSv3不要求线程安全的函数")中的函数变为线程安全。然而，即使这些函数在某些实现中是线程安全的，可移植的应用程序也不能依赖于所有实现都具备线程安全。
- en: Table 31-1. Functions that SUSv3 does not require to be thread-safe
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表31-1。SUSv3不要求线程安全的函数
- en: '| *asctime()**basename()**catgets()**crypt()**ctime()**dbm_clearerr()**dbm_close()**dbm_delete()**dbm_error()**dbm_fetch()**dbm_firstkey()**dbm_nextkey()**dbm_open()**dbm_store()**dirname()**dlerror()**drand48()**ecvt()**encrypt()**endgrent()**endpwent()**endutxent()*
    | *fcvt()**ftw()**gcvt()**getc_unlocked()**getchar_unlocked()**getdate()**getenv()**getgrent()**getgrgid()**getgrnam()**gethostbyaddr()**gethostbyname()**gethostent()**getlogin()**getnetbyaddr()**getnetbyname()**getnetent()**getopt()**getprotobyname()**getprotobynumber()**getprotoent()**getpwent()*
    | *getpwnam()**getpwuid()**getservbyname()**getservbyport()**getservent()**getutxent()**getutxid()**getutxline()**gmtime()**hcreate()**hdestroy()**hsearch()**inet_ntoa()**l64a()**lgamma()**lgammaf()**lgammal()**localeconv()**localtime()**lrand48()**mrand48()**nftw()*
    | *nl_langinfo()**ptsname()**putc_unlocked()**putchar_unlocked()**putenv()**pututxline()**rand()**readdir()**setenv()**setgrent()**setkey()**setpwent()**setutxent()**strerror()**strtok()**ttyname()**unsetenv()**wcstombs()**wctomb()*
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| *asctime()**basename()**catgets()**crypt()**ctime()**dbm_clearerr()**dbm_close()**dbm_delete()**dbm_error()**dbm_fetch()**dbm_firstkey()**dbm_nextkey()**dbm_open()**dbm_store()**dirname()**dlerror()**drand48()**ecvt()**encrypt()**endgrent()**endpwent()**endutxent()*
    | *fcvt()**ftw()**gcvt()**getc_unlocked()**getchar_unlocked()**getdate()**getenv()**getgrent()**getgrgid()**getgrnam()**gethostbyaddr()**gethostbyname()**gethostent()**getlogin()**getnetbyaddr()**getnetbyname()**getnetent()**getopt()**getprotobyname()**getprotobynumber()**getprotoent()**getpwent()*
    | *getpwnam()**getpwuid()**getservbyname()**getservbyport()**getservent()**getutxent()**getutxid()**getutxline()**gmtime()**hcreate()**hdestroy()**hsearch()**inet_ntoa()**l64a()**lgamma()**lgammaf()**lgammal()**localeconv()**localtime()**lrand48()**mrand48()**nftw()*
    | *nl_langinfo()**ptsname()**putc_unlocked()**putchar_unlocked()**putenv()**pututxline()**rand()**readdir()**setenv()**setgrent()**setkey()**setpwent()**setutxent()**strerror()**strtok()**ttyname()**unsetenv()**wcstombs()**wctomb()*
    |'
- en: Reentrant and nonreentrant functions
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可重入和不可重入函数
- en: 'Although the use of critical sections to implement thread safety is a significant
    improvement over the use of per-function mutexes, it is still somewhat inefficient
    because there is a cost to locking and unlocking a mutex. A *reentrant function*
    achieves thread safety without the use of mutexes. It does this by avoiding the
    use of global and static variables. Any information that must be returned to the
    caller, or maintained between calls to the function, is stored in buffers allocated
    by the caller. (We first encountered reentrancy when discussing the treatment
    of global variables within signal handlers in [Reentrant and Async-Signal-Safe
    Functions](ch21.html#reentrant_and_async-signal-safe_function "Reentrant and Async-Signal-Safe
    Functions").) However, not all functions can be made reentrant. The usual reasons
    are the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用临界区来实现线程安全比使用每个函数的互斥锁要好，但由于锁定和解锁互斥锁存在一定的开销，仍然有些低效。*可重入函数*在不使用互斥锁的情况下实现线程安全。它通过避免使用全局和静态变量来实现这一点。任何必须返回给调用者的信息，或在多次调用函数之间维护的信息，都会存储在调用者分配的缓冲区中。（我们第一次遇到可重入性是在讨论在[可重入与异步信号安全函数](ch21.html#reentrant_and_async-signal-safe_function
    "Reentrant and Async-Signal-Safe Functions")中对全局变量的处理时。）然而，并非所有函数都能做到可重入。通常的原因如下：
- en: By their nature, some functions must access global data structures. The functions
    in the *malloc* library provide a good example. These functions maintain a global
    linked list of free blocks on the heap. The functions of the *malloc* library
    are made thread-safe through the use of mutexes.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本质上讲，一些函数必须访问全局数据结构。*malloc*库中的函数就提供了一个很好的例子。这些函数维护着一个全局的空闲块链表。*malloc*库的函数通过使用互斥锁（mutex）来确保线程安全。
- en: Some functions (defined before the invention of threads) have an interface that
    by definition is nonreentrant, because they return pointers to storage statically
    allocated by the function, or they employ static storage to maintain information
    between successive calls to the same (or a related) function. Most of the functions
    in [Table 31-1](ch31.html#functions_that_susv3_does_not_require_to "Table 31-1. Functions
    that SUSv3 does not require to be thread-safe") fall into this category. For example,
    the *asctime()* function ([Converting Between Broken-Down Time and Printable Form](ch10.html#converting_between_broken-down_time_and
    "Converting Between Broken-Down Time and Printable Form")) returns a pointer to
    a statically allocated buffer containing a date-time string.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些函数（在线程出现之前定义）其接口本质上是不可重入的，因为它们返回指向由函数静态分配的存储区的指针，或者它们使用静态存储在连续的调用之间保持信息。在[表31-1](ch31.html#functions_that_susv3_does_not_require_to
    "Table 31-1. Functions that SUSv3 does not require to be thread-safe")中的大多数函数都属于这一类。例如，*asctime()*函数（[转换破碎时间和可打印形式之间的转换](ch10.html#converting_between_broken-down_time_and
    "Converting Between Broken-Down Time and Printable Form")）返回一个指向包含日期时间字符串的静态分配缓冲区的指针。
- en: For several of the functions that have nonreentrant interfaces, SUSv3 specifies
    reentrant equivalents with names ending with the suffix *_r*. These functions
    require the caller to allocate a buffer whose address is then passed to the function
    and used to return the result. This allows the calling thread to use a local (stack)
    variable for the function result buffer. For this purpose, SUSv3 specifies *asctime_r()*,
    *ctime_r()*, *getgrgid_r()*, *getgrnam_r()*, *getlogin_r()*, *getpwnam_r()*, *getpwuid_r()*,
    *gmtime_r()*, *localtime_r()*, *rand_r()*, *readdir_r()*, *strerror_r()*, *strtok_r()*,
    and *ttyname_r()*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些具有不可重入接口的函数，SUSv3指定了以后缀*_r*结尾的可重入等效函数。这些函数要求调用者分配一个缓冲区，然后将其地址传递给函数，用于返回结果。这样，调用线程可以使用局部（栈）变量作为函数结果缓冲区。为此，SUSv3指定了*asctime_r()*、*ctime_r()*、*getgrgid_r()*、*getgrnam_r()*、*getlogin_r()*、*getpwnam_r()*、*getpwuid_r()*、*gmtime_r()*、*localtime_r()*、*rand_r()*、*readdir_r()*、*strerror_r()*、*strtok_r()*和*ttyname_r()*。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some implementations also provide additional reentrant equivalents of other
    traditional nonreentrant functions. For example, *glibc* provides *crypt_r()*,
    *gethostbyname_r()*, *getservbyname_r()*, *getutent_r()*, *getutid_r()*, *getutline_r()*,
    and *ptsname_r()*. However, a portable application can’t rely on these functions
    being present on other implementations. In some cases, SUSv3 doesn’t specify these
    reentrant equivalents because alternatives to the traditional functions exist
    that are both superior and reentrant. For example, *getaddrinfo()* is the modern,
    reentrant alternative to *gethostbyname()* and *getservbyname()*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现还提供了其他传统非重入函数的额外重入版本。例如，*glibc*提供了*crypt_r()*、*gethostbyname_r()*、*getservbyname_r()*、*getutent_r()*、*getutid_r()*、*getutline_r()*和*ptsname_r()*。然而，便携式应用程序不能依赖这些函数在其他实现中存在。在某些情况下，SUSv3没有指定这些重入等效函数，因为存在一些替代传统函数的既优越又重入的替代方案。例如，*getaddrinfo()*是*gethostbyname()*和*getservbyname()*的现代重入替代方案。
- en: One-Time Initialization
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次性初始化
- en: Sometimes, a threaded application needs to ensure that some initialization action
    occurs just once, regardless of how many threads are created. For example, a mutex
    may need to be initialized with special attributes using *pthread_mutex_init()*,
    and that initialization must occur just once. If we are creating the threads from
    the main program, then this is generally easy to achieve—we perform the initialization
    before creating any threads that depend on the initialization. However, in a library
    function, this is not possible, because the calling program may create the threads
    before the first call to the library function. Therefore, the library function
    needs a method of performing the initialization the first time that it is called
    from any thread.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，线程应用程序需要确保某些初始化操作只执行一次，无论创建多少个线程。例如，一个互斥锁可能需要使用*pthread_mutex_init()*进行带有特殊属性的初始化，而该初始化必须只进行一次。如果我们是从主程序创建线程，那么通常很容易实现——我们在创建任何依赖初始化的线程之前完成初始化。然而，在库函数中，这是不可能的，因为调用程序可能在第一次调用库函数之前就创建了线程。因此，库函数需要一种方法，在它第一次被任何线程调用时执行初始化。
- en: A library function can perform one-time initialization using the *pthread_once()*
    function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 库函数可以使用*pthread_once()*函数执行一次性初始化。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回正数错误代码。
- en: The *pthread_once()* function uses the state of the argument *once_control*
    to ensure that the caller-defined function pointed to by *init* is called just
    once, no matter how many times or from how many different threads the *pthread_once()*
    call is made.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_once()*函数使用参数*once_control*的状态来确保由*init*指向的调用者定义的函数仅执行一次，无论*pthread_once()*调用被调用多少次，或者是从多少个不同的线程调用。'
- en: 'The *init* function is called without any arguments, and thus has the following
    form:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*init*函数在没有任何参数的情况下被调用，因此具有以下形式：'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The *once_control* argument is a pointer to a variable that must be statically
    initialized with the value `PTHREAD_ONCE_INIT`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*once_control*参数是一个指向变量的指针，该变量必须使用值`PTHREAD_ONCE_INIT`静态初始化：'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first call to *pthread_once()* that specifies a pointer to a particular
    *pthread_once_t* variable modifies the value of the variable pointed to by *once_control*
    so that subsequent calls to *pthread_once()* don’t invoke *init*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用指定指向特定*pthread_once_t*变量的指针的*pthread_once()*时，将修改*once_control*指向的变量的值，以确保后续对*pthread_once()*的调用不会再次调用*init*。
- en: One common use of *pthread_once()* is in conjunction with thread-specific data,
    which we describe next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_once()*的一种常见用法是与线程特定数据一起使用，我们接下来将描述这一点。'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main reason for the existence of *pthread_once()* is that in early versions
    of Pthreads, it was not possible to statically initialize a mutex. Instead, the
    use of *pthread_mutex_init()* was required ([Butenhof, 1996]). Given the later
    addition of statically allocated mutexes, it is possible for a library function
    to perform one-time initialization using a statically allocated mutex and a static
    Boolean variable. Nevertheless, *pthread_once()* is retained as a convenience.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_once()*存在的主要原因是，在早期版本的Pthreads中，无法静态初始化互斥锁。相反，需要使用*pthread_mutex_init()*（[Butenhof,
    1996]）。考虑到后续增加了静态分配的互斥锁，库函数现在可以使用静态分配的互斥锁和静态布尔变量来执行一次性初始化。尽管如此，*pthread_once()*
    仍然作为一种方便的方式保留下来。'
- en: Thread-Specific Data
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程特定数据
- en: The most efficient way of making a function thread-safe is to make it reentrant.
    All new library functions should be implemented in this way. However, for an existing
    nonreentrant library function (one that was perhaps designed before the use of
    threads became common), this approach usually requires changing the function’s
    interface, which means modifying all of the programs that use the function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使函数线程安全的最有效方法是使其可重入。所有新的库函数应该以这种方式实现。然而，对于现有的不可重入库函数（可能是在线程使用普及之前设计的），这种方法通常需要改变函数的接口，这意味着必须修改所有使用该函数的程序。
- en: Thread-specific data is a technique for making an existing function thread-safe
    without changing its interface. A function that uses thread-specific data may
    be slightly less efficient than a reentrant function, but allows us to leave the
    programs that call the function unchanged.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 线程特定数据是一种使现有函数在不改变其接口的情况下变得线程安全的技术。使用线程特定数据的函数可能比可重入函数效率稍低，但可以让我们保持调用该函数的程序不变。
- en: Thread-specific data allows a function to maintain a separate copy of a variable
    for each thread that calls the function, as illustrated in [Figure 31-1](ch31.html#thread-specific_data_open_parenthesis_ts
    "Figure 31-1. Thread-specific data (TSD) provides per-thread storage for a function").
    Thread-specific data is persistent; each thread’s variable continues to exist
    between the thread’s invocations of the function. This allows the function to
    maintain per-thread information between calls to the function, and allows the
    function to pass distinct result buffers (if required) to each calling thread.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 线程特定数据允许函数为每个调用该函数的线程维护一个变量的单独副本，如[图 31-1](ch31.html#thread-specific_data_open_parenthesis_ts
    "图 31-1. 线程特定数据（TSD）为函数提供每线程存储")所示。线程特定数据是持久的；每个线程的变量在该线程调用函数之间持续存在。这允许函数在调用之间保持每线程的信息，并允许函数将不同的结果缓冲区（如果需要）传递给每个调用线程。
- en: '![Thread-specific data (TSD) provides per-thread storage for a function](figs/web/31-1_THREADS-B1-TSD-scale90.png.jpg)Figure 31-1. Thread-specific
    data (TSD) provides per-thread storage for a function'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![线程特定数据（TSD）为函数提供每线程存储](figs/web/31-1_THREADS-B1-TSD-scale90.png.jpg)图 31-1.
    线程特定数据（TSD）为函数提供每线程存储'
- en: Thread-Specific Data from the Library Function’s Perspective
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从库函数的角度看线程特定数据
- en: 'In order to understand the use of the thread-specific data API, we need to
    consider things from the point of view of a library function that uses thread-specific
    data:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解线程特定数据 API 的使用，我们需要从使用线程特定数据的库函数的角度来考虑问题：
- en: The function must allocate a separate block of storage for each thread that
    calls the function. This block needs to be allocated once, the first time the
    thread calls the function.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数必须为每个调用该函数的线程分配一个单独的存储块。这个存储块需要在该线程第一次调用函数时分配。
- en: On each subsequent call from the same thread, the function needs to be able
    to obtain the address of the storage block that was allocated the first time this
    thread called the function. The function can’t maintain a pointer to the block
    in an automatic variable, since automatic variables disappear when the function
    returns; nor can it store the pointer in a static variable, since only one instance
    of each static variable exists in the process. The Pthreads API provides functions
    to handle this task.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一线程的后续调用中，函数需要能够获取第一次该线程调用函数时分配的存储块的地址。函数不能在自动变量中保持对该块的指针，因为自动变量在函数返回时消失；也不能将指针存储在静态变量中，因为每个静态变量在进程中只有一个实例。Pthreads
    API 提供了处理此任务的函数。
- en: Different (i.e., independent) functions may each need thread-specific data.
    Each function needs a method of identifying its thread-specific data (a key),
    as distinct from the thread-specific data used by other functions.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的（即独立的）函数可能需要各自的线程特定数据。每个函数都需要一种方法来标识其线程特定数据（一个键），与其他函数使用的线程特定数据区分开来。
- en: The function has no direct control over what happens when the thread terminates.
    When the thread terminates, it is probably executing code outside the function.
    Nevertheless, there must be some mechanism (a destructor) to ensure that the storage
    block allocated for this thread is automatically deallocated when the thread terminates.
    If this is not done, then a memory leak could occur as threads are continuously
    created, call the function, and then terminate.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数无法直接控制线程终止时发生的事情。当线程终止时，它可能正在执行函数外部的代码。然而，必须有某种机制（析构函数）来确保在线程终止时自动释放为该线程分配的存储块。如果没有做到这一点，随着线程不断创建、调用函数然后终止，可能会发生内存泄漏。
- en: Overview of the Thread-Specific Data API
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程特定数据 API 概述
- en: 'The general steps that a library function performs in order to use thread-specific
    data are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 库函数使用线程特定数据的一般步骤如下：
- en: The function creates a *key*, which is the means of differentiating the thread-specific
    data item used by this function from the thread-specific data items used by other
    functions. The key is created by calling the *pthread_key_create()* function.
    Creating a key needs to be done only once, when the first thread calls the function.
    For this purpose, *pthread_once()* is employed. Creating a key doesn’t allocate
    any blocks of thread-specific data.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数创建了一个*键*，这是区分该函数使用的线程特定数据项与其他函数使用的线程特定数据项的手段。键是通过调用 *pthread_key_create()*
    函数创建的。创建键只需在第一个线程调用该函数时进行一次。为此，使用了 *pthread_once()*。创建键不会分配任何线程特定数据的块。
- en: 'The call to *pthread_key_create()* serves a second purpose: it allows the caller
    to specify the address of the programmer-defined destructor function that is used
    to deallocate each of the storage blocks allocated for this key (see the next
    step). When a thread that has thread-specific data terminates, the Pthreads API
    automatically invokes the destructor, passing it a pointer to the data block for
    this thread.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 *pthread_key_create()* 还有第二个目的：它允许调用者指定程序员定义的析构函数的地址，用于释放为此键分配的每个存储块（参见下一步）。当一个具有线程特定数据的线程终止时，Pthreads
    API 会自动调用析构函数，并传递一个指向该线程数据块的指针。
- en: The function allocates a thread-specific data block for each thread from which
    it is called. This is done using *malloc()* (or a similar function). This allocation
    is done once for each thread, the first time the thread calls the function.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数为每个调用它的线程分配一个线程特定数据块。使用 *malloc()*（或类似函数）完成此分配。每个线程第一次调用该函数时，仅为该线程进行一次分配。
- en: 'In order to save a pointer to the storage allocated in the previous step, the
    function employs two Pthreads functions: *pthread_setspecific()* and *pthread_getspecific()*.
    A call to *pthread_setspecific()* is a request to the Pthreads implementation
    to say “save this pointer, recording the fact that it is associated with a particular
    key (the one for this function) and a particular thread (the calling thread).”
    Calling *pthread_getspecific()* performs the complementary task, returning the
    pointer previously associated with a given key for the calling thread. If no pointer
    was previously associated with a particular key and thread, then *pthread_getspecific()*
    returns `NULL`. This is how a function can determine that it is being called for
    the first time by this thread, and thus must allocate the storage block for the
    thread.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保存在前一步分配的存储的指针，该函数使用了两个 Pthreads 函数：*pthread_setspecific()* 和 *pthread_getspecific()*。调用
    *pthread_setspecific()* 是向 Pthreads 实现发出的请求，表示“保存这个指针，并记录它与特定键（本函数的键）和特定线程（调用线程）相关联”。调用
    *pthread_getspecific()* 执行互补任务，返回之前与给定键和调用线程相关联的指针。如果没有指针与特定键和线程相关联，则 *pthread_getspecific()*
    返回 `NULL`。这就是一个函数如何判断它是首次由该线程调用，因此必须为该线程分配存储块的方式。
- en: Details of the Thread-Specific Data API
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程特定数据 API 的详细信息
- en: In this section, we provide details of each of the functions mentioned in the
    previous section, and elucidate the operation of thread-specific data by describing
    how it is typically implemented. The next section shows how to use thread-specific
    data to write a thread-safe implementation of the standard C library function
    *strerror()*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了前面提到的每个函数的详细信息，并通过描述其典型实现方式，阐明线程特定数据的操作。下一节将展示如何使用线程特定数据编写线程安全的标准 C 库函数
    *strerror()* 的实现。
- en: Calling *pthread_key_create()* creates a new thread-specific data key that is
    returned to the caller in the buffer pointed to by *key*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *pthread_key_create()* 创建一个新的线程特定数据键，该键通过指向 *key* 的缓冲区返回给调用者。
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，失败时返回正的错误号。
- en: Because the returned key is used by all threads in the process, *key* should
    point to a global variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因为返回的键是由进程中的所有线程使用的，*key* 应该指向一个全局变量。
- en: 'The *destructor* argument points to a programmer-defined function of the following
    form:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*destructor* 参数指向一个程序员定义的函数，形式如下：'
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Upon termination of a thread that has a non-`NULL` value associated with *key*,
    the destructor function is automatically invoked by the Pthreads API and given
    that value as its argument. The passed value is normally a pointer to this thread’s
    thread-specific data block for this key. If a destructor is not required, then
    *destructor* can be specified as `NULL`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程终止时，如果该线程与 *key* 关联的值为非 `NULL`，Pthreads API 会自动调用析构函数并将该值作为其参数传递。传递的值通常是指向该线程的线程特定数据块的指针。如果不需要析构函数，则可以将
    *destructor* 指定为 `NULL`。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a thread has multiple thread-specific data blocks, then the order in which
    the destructors are called is unspecified. Destructor functions should be designed
    to operate independently of one another.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个线程有多个线程特定数据块，则析构函数调用的顺序是未指定的。析构函数应设计为相互独立运行。
- en: 'Looking at the implementation of thread-specific data helps us to understand
    how it is used. A typical implementation (NPTL is typical), involves the following
    arrays:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 查看线程特定数据的实现有助于我们理解它是如何使用的。一个典型的实现（NPTL 是典型的）涉及以下数组：
- en: a single global (i.e., process-wide) array of information about thread-specific
    data keys; and
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全局（即进程范围内）数组，用于存储线程特定数据键的信息；
- en: a set of per-thread arrays, each containing pointers to all of the thread-specific
    data blocks allocated for a particular thread (i.e., this array contains the pointers
    stored by calls to *pthread_setspecific()*).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组每线程数组，每个数组包含指向为特定线程分配的所有线程特定数据块的指针（即，这个数组包含通过调用 *pthread_setspecific()* 存储的指针）。
- en: In this implementation, the *pthread_key_t* value returned by *pthread_key_create()*
    is simply an index into the global array, which we label *pthread_keys*, whose
    form is shown in [Figure 31-2](ch31.html#implementation_of_thread-specific_data_k
    "Figure 31-2. Implementation of thread-specific data keys"). Each element of this
    array is a structure containing two fields. The first field indicates whether
    this array element is in use (i.e., has been allocated by a previous call to *pthread_key_create()*).
    The second field is used to store the pointer to the destructor function for the
    thread-specific data blocks for this key (i.e., it is a copy of the *destructor*
    argument to *pthread_key_create()*).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，*pthread_key_t* 由 *pthread_key_create()* 返回的值仅仅是全局数组的一个索引，我们将其标记为 *pthread_keys*，其形式如[图31-2](ch31.html#implementation_of_thread-specific_data_k
    "图31-2. 线程特定数据键的实现")所示。该数组的每个元素都是一个包含两个字段的结构体。第一个字段表示该数组元素是否正在使用（即，是否已经通过先前调用
    *pthread_key_create()* 分配）。第二个字段用于存储指向该键的线程特定数据块的析构函数的指针（即，它是 *pthread_key_create()*
    的 *destructor* 参数的副本）。
- en: '![Implementation of thread-specific data keys](figs/web/31-2_THREADS-B1-TSD-key-scale90.png.jpg)Figure 31-2. Implementation
    of thread-specific data keys'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![线程特定数据键的实现](figs/web/31-2_THREADS-B1-TSD-key-scale90.png.jpg)图31-2. 线程特定数据键的实现'
- en: The *pthread_setspecific()* function requests the Pthreads API to save a copy
    of *value* in a data structure that associates it with the calling thread and
    with *key*, a key returned by a previous call to *pthread_key_create()*. The *pthread_getspecific()*
    function performs the converse operation, returning the value that was previously
    associated with the given *key* for this thread.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_setspecific()* 函数请求 Pthreads API 将 *value* 的副本保存在一个数据结构中，该数据结构将其与调用线程和
    *key*（由先前调用 *pthread_key_create()* 返回的键）关联。*pthread_getspecific()* 函数执行相反的操作，返回先前为该线程与给定
    *key* 关联的值。'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，失败时返回正的错误号。
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer, or `NULL` if no thread-specific data isassociated with *key*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指针，如果没有与 *key* 关联的线程特定数据，则返回 `NULL`。
- en: The *value* argument given to *pthread_setspecific()* is normally a pointer
    to a block of memory that has previously been allocated by the caller. This pointer
    will be passed as the argument for the destructor function for this *key* when
    the thread terminates.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 给*pthread_setspecific()*的*value*参数通常是指向调用者之前分配的内存块的指针。该指针将在线程终止时作为该*key*的析构函数的参数传递。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *value* argument doesn’t need to be a pointer to a block of memory. It could
    be some scalar value that can be assigned (with a cast) to *void **. In this case,
    the earlier call to *pthread_key_create()* would specify *destructor* as `NULL`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*value*参数不需要是指向内存块的指针。它可以是某个标量值，可以通过类型转换（cast）赋值给*void **。在这种情况下，之前调用的*pthread_key_create()*会将*destructor*指定为`NULL`。'
- en: '[Figure 31-3](ch31.html#data_structure_used_to_implement_thread- "Figure 31-3. Data
    structure used to implement thread-specific data (TSD) pointers") shows a typical
    implementation of the data structure used to store *value*. In this diagram, we
    assume that *pthread_keys[1]* was allocated to a function named *myfunc()*. For
    each thread, the Pthreads API maintains an array of pointers to thread-specific
    data blocks. The elements of each of these thread-specific arrays have a one-to-one
    correspondence with the elements of the global *pthread_keys* array shown in [Figure 31-2](ch31.html#implementation_of_thread-specific_data_k
    "Figure 31-2. Implementation of thread-specific data keys"). The *pthread_setspecific()*
    function sets the element corresponding to *key* in the array for the calling
    thread.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[图31-3](ch31.html#data_structure_used_to_implement_thread- "图31-3. 用于实现线程特定数据（TSD）指针的数据结构")展示了用于存储*value*的数据结构的典型实现。在这个图中，我们假设*pthread_keys[1]*被分配给一个名为*myfunc()*的函数。对于每个线程，Pthreads
    API维护一个指向线程特定数据块的指针数组。每个线程特定数组的元素与[图31-2](ch31.html#implementation_of_thread-specific_data_k
    "图31-2. 线程特定数据键的实现")中显示的全局*pthread_keys*数组的元素一一对应。*pthread_setspecific()*函数为调用线程设置数组中与*key*对应的元素。'
- en: '![Data structure used to implement thread-specific data (TSD) pointers](figs/web/31-3_THREADS-B1-TSD-specific-scale90.png.jpg)Figure 31-3. Data
    structure used to implement thread-specific data (TSD) pointers'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![用于实现线程特定数据（TSD）指针的数据结构](figs/web/31-3_THREADS-B1-TSD-specific-scale90.png.jpg)图31-3.
    用于实现线程特定数据（TSD）指针的数据结构'
- en: When a thread is first created, all of its thread-specific data pointers are
    initialized to `NULL`. This means that when our library function is called by
    a thread for the first time, it must begin by using *pthread_getspecific()* to
    check whether the thread already has an associated value for *key*. If it does
    not, then the function allocates a block of memory and saves a pointer to the
    block using *pthread_setspecific()*. We show an example of this in the thread-safe
    *strerror()* implementation presented in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程首次创建时，所有其线程特定数据指针都会被初始化为`NULL`。这意味着当我们的库函数首次被线程调用时，它必须先使用*pthread_getspecific()*来检查该线程是否已经有与*key*关联的值。如果没有，函数会分配一个内存块，并使用*pthread_setspecific()*保存指向该块的指针。在下一节中，我们展示了线程安全的*strerror()*实现的一个示例。
- en: Employing the Thread-Specific Data API
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用线程特定数据（Thread-Specific Data）API
- en: When we first described the standard *strerror()* function in [Handling Errors
    from System Calls and Library Functions](ch03.html#handling_errors_from_system_calls_and_li
    "Handling Errors from System Calls and Library Functions"), we noted that it may
    return a pointer to a statically allocated string as its function result. This
    means that *strerror()* may not be thread-safe. In the next few pages, we look
    at a non-thread-safe implementation of *strerror()*, and then show how thread-specific
    data can be used to make this function thread-safe.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次描述标准的*strerror()*函数时，参考了[系统调用和库函数错误处理](ch03.html#handling_errors_from_system_calls_and_li
    "系统调用和库函数错误处理")一章，我们提到该函数可能返回一个指向静态分配字符串的指针作为其函数结果。这意味着*strerror()*可能不是线程安全的。在接下来的几页中，我们将探讨一个非线程安全的*strerror()*实现，并展示如何使用线程特定数据使该函数线程安全。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On many UNIX implementations, including Linux, the *strerror()* function provided
    by the standard C library *is* thread-safe. However, we use the example of *strerror()*
    anyway, because SUSv3 doesn’t require this function to be thread-safe, and its
    implementation provides a simple example of the use of thread-specific data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多UNIX实现中，包括Linux，标准C库提供的*strerror()*函数是线程安全的。然而，我们还是以*strerror()*为例，因为SUSv3并未要求该函数是线程安全的，其实现为线程特定数据的使用提供了一个简单的示例。
- en: '[Example 31-1](ch31.html#an_implementation_of_strerror_open_paren "Example 31-1. An
    implementation of strerror() that is not thread-safe") shows a simple non-thread-safe
    implementation of *strerror()*. This function makes use of a pair of global variables
    defined by *glibc*: *_sys_errlist* is an array of pointers to strings corresponding
    to the error numbers in *errno* (thus, for example, *_sys_errlist[EINVAL]* points
    to the string *Invalid operation*), and *_sys_nerr* specifies the number of elements
    in *_sys_errlist*.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 31-1](ch31.html#an_implementation_of_strerror_open_paren "示例 31-1. 一个非线程安全的*strerror()*实现")展示了一个简单的非线程安全的*strerror()*实现。该函数利用了*glibc*定义的一对全局变量：*_sys_errlist*是一个指向字符串的指针数组，这些字符串对应于*errno*中的错误号（例如，*_sys_errlist[EINVAL]*指向字符串*Invalid
    operation*），而*_sys_nerr*指定了*_sys_errlist*中的元素数量。'
- en: Example 31-1. An implementation of *strerror()* that is not thread-safe
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 31-1. 一个非线程安全的*strerror()*实现
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can use the program in [Example 31-2](ch31.html#calling_strerror_open_parenthesis_close
    "Example 31-2. Calling strerror() from two different threads") to demonstrate
    the consequences of the fact that the *strerror()* implementation in [Example 31-1](ch31.html#an_implementation_of_strerror_open_paren
    "Example 31-1. An implementation of strerror() that is not thread-safe") is not
    thread-safe. This program calls *strerror()* from two different threads, but displays
    the returned value only after both threads have called *strerror()*. Even though
    each thread specifies a different value (`EINVAL` and `EPERM`) as the argument
    to *strerror()*, this is what we see when we compile and link this program with
    the version of *strerror()* shown in [Example 31-1](ch31.html#an_implementation_of_strerror_open_paren
    "Example 31-1. An implementation of strerror() that is not thread-safe"):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[示例 31-2](ch31.html#calling_strerror_open_parenthesis_close "示例 31-2.
    从两个不同线程调用*strerror()")中的程序来演示[示例 31-1](ch31.html#an_implementation_of_strerror_open_paren
    "示例 31-1. 一个非线程安全的*strerror()*实现")中*strerror()*实现不是线程安全的后果。该程序从两个不同的线程调用*strerror()*，但仅在两个线程都调用过*strerror()*后才显示返回值。即使每个线程为*strerror()*指定了不同的值（`EINVAL`和`EPERM`）作为参数，当我们使用[示例
    31-1](ch31.html#an_implementation_of_strerror_open_paren "示例 31-1. 一个非线程安全的*strerror()*实现")中展示的*strerror()*版本编译并链接此程序时，显示的结果如下：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Both threads displayed the *errno* string corresponding to `EPERM`, because
    the call to *strerror()* by the second thread (in *threadFunc*) overwrote the
    buffer that was written by the call to *strerror()* in the main thread. Inspection
    of the output shows that the local variable *str* in the two threads points to
    the same memory address.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 两个线程都显示了对应于`EPERM`的*errno*字符串，因为第二个线程（在*threadFunc*中）调用*strerror()*时覆盖了主线程中调用*strerror()*时写入的缓冲区。检查输出时，可以看到两个线程中的局部变量*str*指向相同的内存地址。
- en: Example 31-2. Calling *strerror()* from two different threads
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 31-2. 从两个不同线程调用*strerror()*
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Example 31-3](ch31.html#a_thread-safe_implementation_of_strerror "Example 31-3. A
    thread-safe implementation of strerror() using thread-specific data") shows a
    reimplementation of *strerror()* that uses thread-specific data to ensure thread
    safety.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 31-3](ch31.html#a_thread-safe_implementation_of_strerror "示例 31-3. 一个使用线程特定数据确保线程安全的*strerror()*实现")展示了一个重新实现的*strerror()*，该实现使用线程特定数据来确保线程安全。'
- en: The first step performed by the revised *strerror()* is to call *pthread_once()*
    ![](figs/web/U004.png) to ensure that the first invocation of this function (from
    any thread) calls *createKey()* ![](figs/web/U002.png) . The *createKey()* function
    calls *pthread_key_create()* to allocate a thread-specific data key that is stored
    in the global variable *strerrorKey* ![](figs/web/U003.png). The call to *pthread_key_create()*
    also records the address of the destructor ![](figs/web/U001.png) that will be
    used to free the thread-specific buffers corresponding to this key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 修订版的*strerror()*执行的第一步是调用*pthread_once()* ![](figs/web/U004.png)，以确保此函数的首次调用（来自任何线程）会调用*createKey()*
    ![](figs/web/U002.png)。*createKey()*函数调用*pthread_key_create()*来分配一个线程特定的数据键，该键存储在全局变量*strerrorKey*
    ![](figs/web/U003.png)中。调用*pthread_key_create()*时，还会记录析构函数的地址 ![](figs/web/U001.png)，该析构函数将用于释放与此键对应的线程特定缓冲区。
- en: The *strerror()* function then calls *pthread_getspecific()* ![](figs/web/U005.png)
    to retrieve the address of this thread’s unique buffer corresponding to *strerrorKey*.
    If *pthread_getspecific()* returns `NULL`, then this thread is calling *strerror()*
    for the first time, and so the function allocates a new buffer using *malloc()*
    ![](figs/web/U006.png), and saves the address of the buffer using *pthread_setspecific()*
    ![](figs/web/U007.png). If the *pthread_getspecific()* call returns a non-`NULL`
    value, then that pointer refers to an existing buffer that was allocated when
    this thread previously called *strerror()*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*strerror()*函数随后调用*pthread_getspecific()* ![](figs/web/U005.png)来检索与*strerrorKey*对应的该线程唯一缓冲区的地址。如果*pthread_getspecific()*返回`NULL`，则说明该线程第一次调用*strerror()*，于是该函数使用*malloc()*
    ![](figs/web/U006.png)分配一个新的缓冲区，并通过*pthread_setspecific()* ![](figs/web/U007.png)保存缓冲区的地址。如果*pthread_getspecific()*返回非`NULL`值，则该指针指向一个已存在的缓冲区，该缓冲区是在该线程之前调用*strerror()*时分配的。'
- en: The remainder of this *strerror()* implementation is similar to the implementation
    that we showed earlier, with the difference that *buf* is the address of a thread-specific
    data buffer, rather than a static variable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该*strerror()*实现的其余部分与我们之前展示的实现类似，不同之处在于*buf*是一个线程特定数据缓冲区的地址，而不是一个静态变量。
- en: Example 31-3. A thread-safe implementation of *strerror()* using thread-specific
    data
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 31-3. 使用线程特定数据的线程安全*strerror()*实现
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we compile and link our test program ([Example 31-2](ch31.html#calling_strerror_open_parenthesis_close
    "Example 31-2. Calling strerror() from two different threads")) with the new version
    of *strerror()* ([Example 31-3](ch31.html#a_thread-safe_implementation_of_strerror
    "Example 31-3. A thread-safe implementation of strerror() using thread-specific
    data")) to create an executable file, `strerror_test_tsd`, then we see the following
    results when running the program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将测试程序（[示例31-2](ch31.html#calling_strerror_open_parenthesis_close "示例31-2.
    从两个不同线程调用strerror()")）与新的*strerror()*版本（[示例31-3](ch31.html#a_thread-safe_implementation_of_strerror
    "示例31-3. 使用线程特定数据的线程安全strerror()实现")）编译并链接成可执行文件`strerror_test_tsd`，那么运行该程序时，我们会看到以下结果：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From this output, we see that the new version of *strerror()* is thread-safe.
    We also see that the address pointed to by the local variable *str* in the two
    threads is different.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，我们看到新的*strerror()*版本是线程安全的。我们还看到，在两个线程中，局部变量*str*指向的地址是不同的。
- en: Thread-Specific Data Implementation Limits
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程特定数据实现限制
- en: As implied by our description of how thread-specific data is typically implemented,
    an implementation may need to impose limits on the number of thread-specific data
    keys that it supports. SUSv3 requires that an implementation support at least
    128 (`_POSIX_THREAD_KEYS_MAX`) keys. An application can determine how many keys
    an implementation actually supports either via the definition of `PTHREAD_KEYS_MAX`
    (defined in `<limits.h>`) or by calling *sysconf(_SC_THREAD_KEYS_MAX)*. Linux
    supports up to 1024 keys.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们描述的线程特定数据通常是如何实现的那样，某些实现可能需要对它所支持的线程特定数据键的数量加以限制。SUSv3要求实现至少支持128个（`_POSIX_THREAD_KEYS_MAX`）个键。应用程序可以通过定义`PTHREAD_KEYS_MAX`（定义在`<limits.h>`中）或者通过调用*sysconf(_SC_THREAD_KEYS_MAX)*来确定实现实际支持多少个键。Linux支持最多1024个键。
- en: Even 128 keys should be more than sufficient for most applications. This is
    because each library function should employ only a small number of keys—often
    just one. If a function requires multiple thread-specific data values, these can
    usually be placed in a single structure that has just one associated thread-specific
    data key.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是128个键，对于大多数应用程序来说也应该绰绰有余。这是因为每个库函数通常只会使用少量的键——通常只有一个。如果一个函数需要多个线程特定数据值，通常可以将它们放在一个只有一个关联线程特定数据键的结构中。
- en: Thread-Local Storage
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程局部存储
- en: Like thread-specific data, thread-local storage provides persistent per-thread
    storage. This feature is nonstandard, but it is provided in the same or a similar
    form on many other UNIX implementations (e.g., Solaris and FreeBSD).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程特定数据类似，线程局部存储提供了每个线程持久的存储空间。这个特性虽然不是标准的，但许多其他UNIX实现（例如Solaris和FreeBSD）以相同或类似的形式提供了这个功能。
- en: 'The main advantage of thread-local storage is that it is much simpler to use
    than thread-specific data. To create a thread-local variable, we simply include
    the `__thread` specifier in the declaration of a global or static variable:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 线程局部存储的主要优势是它比线程特定数据更容易使用。为了创建一个线程局部变量，我们只需在全局或静态变量的声明中加入`__thread`修饰符：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each thread has its own copy of the variables declared with this specifier.
    The variables in a thread’s thread-local storage persist until the thread terminates,
    at which time the storage is automatically deallocated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有自己的一份由此修饰符声明的变量副本。线程局部存储中的变量会持续存在，直到线程终止，此时存储空间会被自动释放。
- en: 'Note the following points about the declaration and use of thread-local variables:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于线程局部变量声明和使用的要点：
- en: The `__thread` keyword must immediately follow the `static` or `extern` keyword,
    if either of these is specified in the variable’s declaration.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在变量声明中指定了`static`或`extern`关键字，`__thread`关键字必须紧跟其后。
- en: The declaration of a thread-local variable can include an initializer, in the
    same manner as a normal global or static variable declaration.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程局部变量的声明可以像普通的全局或静态变量声明一样，包含一个初始化器。
- en: The C address (`&`) operator can be used to obtain the address of a thread-local
    variable.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 的地址运算符（`&`）可以用来获取线程局部变量的地址。
- en: Thread-local storage requires support from the kernel (provided in Linux 2.6),
    the Pthreads implementation (provided in NPTL), and the C compiler (provided on
    x86-32 with *gcc* 3.3 and later).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 线程局部存储需要内核（Linux 2.6 提供）、Pthreads 实现（NPTL 提供）和 C 编译器（在 x86-32 上的 *gcc* 3.3 及以后版本提供）的支持。
- en: '[Example 31-4](ch31.html#a_thread-safe_implementation_of_stre "Example 31-4. A
    thread-safe implementation of strerror() using thread-local storage") shows a
    thread-safe implementation of *strerror()* using thread-local storage. If we compile
    and link our test program ([Example 31-2](ch31.html#calling_strerror_open_parenthesis_close
    "Example 31-2. Calling strerror() from two different threads")) with this version
    of *strerror()* to create an executable file, `strerror_test_tls`, then we see
    the following results when running the program:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 31-4](ch31.html#a_thread-safe_implementation_of_stre "示例 31-4. 使用线程局部存储的
    strerror() 线程安全实现")展示了一个使用线程局部存储的*strerror()*线程安全实现。如果我们将测试程序（[示例 31-2](ch31.html#calling_strerror_open_parenthesis_close
    "示例 31-2. 从两个不同线程调用 strerror()")）与这个版本的*strerror()*一起编译并链接，生成可执行文件 `strerror_test_tls`，那么在运行程序时，我们会看到以下结果：'
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 31-4. A thread-safe implementation of *strerror()* using thread-local
    storage
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 31-4. 使用线程局部存储的*strerror()*线程安全实现
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: A function is said to be thread-safe if it can safely be invoked from multiple
    threads at the same time. The usual reason a function is not thread-safe is that
    it makes use of global or static variables. One way to render a non-thread-safe
    function safe in a multithreaded application is to guard all calls to the function
    with a mutex lock. This approach suffers the problem that it reduces concurrency,
    because only one thread can be in the function at any time. An approach that allows
    greater concurrency is to add mutex locks around just those parts of the function
    that manipulate shared variables (the critical sections).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数可以在多个线程同时安全调用，则该函数被称为线程安全的。函数不是线程安全的通常原因是它使用了全局或静态变量。使一个非线程安全的函数在多线程应用中安全的方式之一是通过互斥锁保护对该函数的所有调用。然而，这种方法的缺点是它减少了并发性，因为在任何时刻，只有一个线程可以进入该函数。一种允许更高并发的方法是，仅在操作共享变量的函数部分（关键区段）周围添加互斥锁。
- en: Mutexes can be used to render most functions thread-safe, but they carry a performance
    penalty because there is a cost to locking and unlocking a mutex. By avoiding
    the use of global and static variables, a reentrant function achieves thread-safety
    without the use of mutexes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁可以用来使大多数函数变为线程安全，但它们带来性能损失，因为锁定和解锁互斥锁是有代价的。通过避免使用全局和静态变量，一个可重入函数可以在不使用互斥锁的情况下实现线程安全。
- en: Most of the functions specified in SUSv3 are required to be thread-safe. SUSv3
    also lists a small set of functions that are not required to be thread-safe. Typically,
    these are functions that employ static storage to return information to the caller
    or to maintain information between successive calls. By definition, such functions
    are not reentrant, and mutexes can’t be used to make them thread-safe. We considered
    two roughly equivalent coding techniques—thread-specific data and thread-local
    storage—that can be used to render an unsafe function thread-safe without needing
    to change its interface. Both of these techniques allow a function to allocate
    persistent, per-thread storage.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在SUSv3中规定的大多数函数都要求是线程安全的。SUSv3还列出了少数几个不要求线程安全的函数。通常，这些是使用静态存储来向调用者返回信息或在连续调用之间保持信息的函数。根据定义，这些函数不可重入，且不能使用互斥锁来使其线程安全。我们考虑了两种大致等价的编码技术——线程特定数据和线程局部存储——它们可以用来使一个不安全的函数变得线程安全，而不需要改变其接口。这两种技术都允许函数为每个线程分配持久的存储。
- en: Further information
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: Refer to the sources of further information listed in [Summary](ch29.html#summary-id28
    "Summary").
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[总结](ch29.html#summary-id28 "Summary")中列出的进一步信息来源。
- en: Exercises
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Implement a function, *one_time_init(control, init)*, that performs the equivalent
    of *pthread_once()*. The *control* argument should be a pointer to a statically
    allocated structure containing a Boolean variable and a mutex. The Boolean variable
    indicates whether the function *init* has already been called, and the mutex controls
    access to that variable. To keep the implementation simple, you can ignore possibilities
    such as *init()* failing or being canceled when first called from a thread (i.e.,
    it is not necessary to devise a scheme whereby, if such an event occurs, the next
    thread that calls *one_time_init()* reattempts the call to *init()*).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个函数，*one_time_init(control, init)*，它执行与*pthread_once()*等效的操作。*control*参数应是指向一个静态分配的结构体的指针，该结构体包含一个布尔变量和一个互斥锁。布尔变量表示函数*init*是否已经被调用，互斥锁控制对该变量的访问。为了简化实现，您可以忽略诸如*init()*第一次从线程调用时失败或被取消的可能性（即不需要设计一种方案，使得如果发生此类事件，下一个调用*one_time_init()*的线程会重新尝试调用*init()*）。
- en: 'Use thread-specific data to write thread-safe versions of *dirname()* and *basename()*
    ([Parsing Pathname Strings: *dirname()* and *basename()*](ch18.html#parsing_pathname_strings_colon_dirname_o
    "Parsing Pathname Strings: dirname() and basename()")).'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用线程特定数据编写线程安全版本的*dirname()*和*basename()*（[解析路径名字符串：*dirname()*和*basename()*](ch18.html#parsing_pathname_strings_colon_dirname_o
    "Parsing Pathname Strings: dirname() and basename()")）。'
