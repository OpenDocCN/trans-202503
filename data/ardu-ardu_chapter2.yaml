- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PORT
    MANIPULATION</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">端口操作</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: This chapter introduces *port manipulation*, the process of simultaneously addressing
    your Arduino’s digital input and output pins to increase the speed of controlling
    or reading their statuses. Doing so reduces the *response time*, or the time required
    for a digital read or write to complete, thus increasing the sketch’s speed of
    operation. Port manipulation also uses less code than normal digital write/read
    functions, reducing the size of your sketch, which comes in handy when you hit
    the upper limits of your Arduino’s memory constraints.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*端口操作*，即同时访问你的Arduino数字输入和输出引脚的过程，以提高控制或读取它们状态的速度。这样可以减少*响应时间*，即完成数字读写所需的时间，从而提高草图的操作速度。端口操作还比常规的数字写入/读取函数使用更少的代码，减少了草图的大小，这在遇到Arduino内存限制时非常有用。
- en: 'In this chapter, you’ll learn to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将学习：
- en: Use port manipulation to rapidly control digital outputs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用端口操作快速控制数字输出
- en: Control seven-segment LED displays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制七段LED显示器
- en: Read multiple digital input pins simultaneously
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时读取多个数字输入引脚
- en: Read binary-coded decimal (BCD) switches
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取二进制编码十进制（BCD）开关
- en: Along the way, you’ll build a binary number display, a light-emitting diode
    (LED) blinking wave, and a single-digit LED die. The instructions in this chapter
    are for an Arduino Uno or compatible board, original Nano, or other Arduino-compatible
    with an ATmega328-series microcontroller.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你将构建一个二进制数字显示器、一个发光二极管（LED）闪烁波形和一个单数字LED骰子。本章中的说明适用于Arduino Uno或兼容板、原始Nano或其他使用ATmega328系列微控制器的Arduino兼容设备。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Ports, Pins, and Registers</samp>
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">端口、引脚和寄存器</samp>
- en: A *port* is a collection of sequential I/O pins. Each has a *register* (a section
    of memory inside the microcontroller), which is written to control the output
    status or read from if the pin status is set to an input. You use another register—the
    data direction register (DDR)—to set pins in a port as inputs or outputs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*端口*是一个包含顺序排列I/O引脚的集合。每个端口都有一个*寄存器*（微控制器内的一段内存），写入该寄存器可以控制输出状态，或者如果引脚状态被设置为输入，则从该寄存器读取。你还需要使用另一个寄存器——数据方向寄存器（DDR）——来设置端口中的引脚为输入或输出。'
- en: '[Figure 2-1](chapter2.xhtml#fig2-1) shows the pins and the ports in which they
    are grouped. Port B consists of digital pins D13 through D8, port C consists of
    analog pins A5 through A0, and port D consists of digital pins D7 through D0.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-1](chapter2.xhtml#fig2-1)显示了引脚及其所在的端口。端口B包含数字引脚D13到D8，端口C包含模拟引脚A5到A0，端口D包含数字引脚D7到D0。'
- en: '![A SIMPLIFIED DIAGRAM OF AN ARDUINO UNO SHOWING THE THREE I/O PIN PORTS: PORT
    B, C AND D](../images/fig2-1.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino Uno的简化图，显示三个I/O引脚端口：端口B、C和D](../images/fig2-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: Ports on the Arduino
    Uno</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-1：Arduino Uno的端口</samp>
- en: 'To set a pin as an input or output, you don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> as you normally
    would. Rather, use the following simple syntax:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要将引脚设置为输入或输出，你不需要像通常那样在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>
    中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp>。相反，使用以下简单语法：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">DDR</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>
    is the data direction register, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>
    is the port (B, C, or D) and each <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>
    matches a pin in the port (from highest to lowest). The B in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyyyyyy</samp> indicates that
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyyyyyy</samp> is a binary
    number. For example, to set all of port D to digital outputs, you use the following
    line of code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">DDR</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>是数据方向寄存器，其中<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>是端口（B、C或D），每个<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>对应端口中的一个引脚（从最高到最低）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp>表示<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyyyyyy</samp>是一个二进制数。例如，要将整个D端口设置为数字输出，你可以在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>中使用以下代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To set digital pins D13, D12, and D11 to inputs and digital pins D9, D8, and
    D7 to outputs, use the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要将D13、D12和D11数字引脚设置为输入，将D9、D8和D7数字引脚设置为输出，请使用以下代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see how much sketch space this saves compared to multiples or loops
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp>.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到与多个或循环使用<samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp>相比，这样节省了多少草图空间。
- en: In addition to abbreviating your code and shortening the response time, port
    manipulation can save you hardware costs when controlling digital output pins.
    For example, in the past, you may have used a shift register IC to control an
    LED display. Port manipulation allows you to do the same using a spare bank of
    I/O pins instead.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简化代码和缩短响应时间，端口操作还可以在控制数字输出引脚时节省硬件成本。例如，过去你可能会使用移位寄存器IC来控制LED显示器，而端口操作可以让你使用备用的I/O引脚组来实现相同的功能。
- en: Let’s put this theory into practice with some projects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些项目将这一理论付诸实践。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #4: Increasing Digital Output
    Pin Speed</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">项目#4：提高数字输出引脚速度</samp>
- en: In this project, you’ll practice using port manipulation by controlling eight
    digital outputs at once, with LEDs used to display output status.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将通过控制八个数字输出进行端口操作练习，使用LED显示输出状态。
- en: 'You’ll need the following parts:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下元件：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Arduino Uno或兼容板及USB电缆
- en: Eight 1 kΩ, 0.25 W, 1 percent resistors
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八个1 kΩ，0.25 W，1%电阻
- en: Eight LEDs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八个LED
- en: A solderless breadboard
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊面包板
- en: Male-to-male jumper wires
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公对公跳线
- en: To minimize the number of part types used in this book and therefore reduce
    the cost of completing projects, this project uses the same 1 kΩ resistors from
    the previous chapter instead of the usual 560 Ω or thereabouts. The LEDs will
    still be plenty bright.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少本书中使用的元件类型数量，从而降低完成项目的成本，本项目使用了与前一章相同的1 kΩ电阻，而不是通常使用的560 Ω或类似的电阻。LED的亮度依然足够。
- en: Assemble the circuit as shown in [Figure 2-2](chapter2.xhtml#fig2-2) on the
    solderless breadboard, connecting the points labeled D7 through D0 and GND to
    the Arduino’s respective pins.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图2-2](chapter2.xhtml#fig2-2)所示，将电路组装在无焊面包板上，连接D7到D0以及GND标记的点到Arduino的相应引脚。
- en: '![A SCHEMATIC FOR PROJECT #4](../images/fig2-2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![项目#4原理图](../images/fig2-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: Schematic for Project
    #4</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-2：项目#4的原理图</samp>
- en: 'Enter and upload the following sketch to your Arduino:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输入并上传以下草图到你的Arduino：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the upload is complete, all the LEDs should blink on and off every half
    second. The pins on port D are set to outputs ❶ and all turned on ❷ and then off
    again ❸. This simple example shows how little code is required to accomplish a
    lot of digital pin control.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上传完成后，所有LED应每半秒闪烁一次。D端口上的引脚被设置为输出❶，并且先全部打开❷，然后再次关闭❸。这个简单的例子展示了实现大量数字引脚控制所需的极少代码。
- en: 'Keep the hardware for this project together, as you’ll use it again in Project
    #5.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请将本项目的硬件保管好，因为你将在项目#5中再次使用它。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Speed Advantage</samp>
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">速度优势</samp>
- en: The Arduino environment uses a hardware abstraction layer that simplifies controlling
    the hardware in your Arduino board or compatible circuit with the help of software
    functions and classes. This code requires extra processing time, which normally
    slows down sketch execution. Port manipulation allows you to bypass the hardware
    abstraction layer, which greatly reduces the amount of code the CPU needs to run
    to accomplish the same task.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino环境使用一个硬件抽象层，借助软件函数和类简化了控制Arduino板或兼容电路的硬件操作。此代码需要额外的处理时间，通常会导致草图执行速度变慢。端口操作可以绕过硬件抽象层，从而大大减少CPU执行相同任务所需的代码量。
- en: To see how much port manipulation speeds up I/O pin operation, this section
    shows how to use test equipment such as a frequency counter or a digital storage
    oscilloscope (DSO) to measure the frequency at which a port of digital pins turns
    on and off. If you have an oscilloscope or a frequency counter, you can follow
    along.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察端口操作如何加速I/O引脚的操作，本节将展示如何使用测试设备（如频率计或数字存储示波器（DSO））来测量数字引脚端口的开关频率。如果你有示波器或频率计，可以跟着一起操作。
- en: First, test the pin speed with the usual Arduino sketch functions, using the
    sketch in [Listing 2-1](#LiT-2-1) with a digital pin connected to the oscilloscope.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用常规的Arduino草图函数测试引脚速度，使用[清单2-1](#LiT-2-1)中的草图，并将数字引脚连接到示波器。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1 A pin speed test,
    which turns digital pins D7 to D0 on and off in sequence and then repeats</samp>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单2-1：一个引脚速度测试，依次打开和关闭数字引脚D7至D0，并重复此操作</samp>
- en: '[Figure 2-3](chapter2.xhtml#fig2-3) shows the results of this measurement:
    an average frequency of 15.15 kHz, which gives a time interval of around 0.000066
    seconds (66 μs) to turn all eight digital pins on and off.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-3](chapter2.xhtml#fig2-3)展示了此测量的结果：平均频率为15.15 kHz，意味着将所有八个数字引脚开关一次的时间间隔约为0.000066秒（66微秒）。'
- en: '![A SCREEN CAPTURE OF A DIGITAL STORAGE OSCILLOSCOPE MEASURING THE PERIOD BETWEEN
    ARDUINO DIGITAL OUTPUT ON AND OFF USING ARDUINO CODE](../images/fig2-3.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用Arduino代码测量Arduino数字输出开关周期的数字存储示波器截图](../images/fig2-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The results from
    running the [Listing 2-1](#LiT-2-1) test</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-3：运行[清单2-1](#LiT-2-1)测试的结果</samp>
- en: Now repeat this test with the modified sketch in [Listing 2-2](#LiT-2-2), which
    uses port manipulation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用[清单2-2](#LiT-2-2)中修改过的草图，使用端口操作重复此测试。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: Using port manipulation
    to test pin speed</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单2-2：使用端口操作测试引脚速度</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> commands in [Listing
    2-2](#LiT-2-2) demonstrate turning the pins on and off long enough for the oscilloscope
    to capture the true speed of this operation. If there were only two <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp>
    commands (for on and off), the time measurement would include the period between
    the pins being turned off and the loop starting over.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单2-2](#LiT-2-2)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp>命令展示了将引脚开关足够长时间，以便示波器能够捕捉到此操作的真实速度。如果只有两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp>命令（分别控制开和关），时间测量将包括引脚关闭与循环重新开始之间的时间间隔。'
- en: '[Figure 2-4](chapter2.xhtml#fig2-4) shows the results of this sketch on the
    oscilloscope.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-4](chapter2.xhtml#fig2-4)展示了该草图在示波器上的结果。'
- en: '![A SCREEN CAPTURE OF A DIGITAL STORAGE OSCILLOSCOPE MEASURING THE PERIOD BETWEEN
    ARDUINO DIGITAL OUTPUT ON AND OFF USING PORT MANIPULATION CODE](../images/fig2-4.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![使用端口操作代码测量Arduino数字输出开关周期的数字存储示波器截图](../images/fig2-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: Results from the
    “fast” test</samp>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-4：“快速”测试的结果</samp>
- en: This second test resulted in an average frequency of 8.06 MHz, or a time interval
    of around 0.00000012406 seconds (0.12405 μs) to turn all eight digital pins on
    and off. On average, using port manipulation turned those pins on and off around
    532 times faster than normal sketch functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次测试的结果是平均频率为8.06 MHz，即将所有八个数字引脚开关一次的时间间隔约为0.00000012406秒（0.12405微秒）。平均而言，使用端口操作使这些引脚的开关速度比正常草图函数快约532倍。
- en: You can see how much using port manipulation improves operation speed and reduces
    the amount of required code in your sketches. In the next project, we’ll demonstrate
    these benefits of port manipulation by controlling LEDs for display purposes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，使用端口操作如何提高操作速度，并减少草图中所需的代码量。在下一个项目中，我们将通过控制 LED 显示来演示端口操作的这些优势。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #5: Displaying Binary Numbers</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #5：显示二进制数字</samp>'
- en: In this project, you’ll continue to consolidate your knowledge of port manipulation
    by using the method to display binary numbers with eight LEDs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将继续巩固端口操作的知识，通过这种方法使用八个 LED 显示二进制数字。
- en: 'This project uses the same hardware as Project #4\. Once you’ve uploaded the
    sketch, the LEDs should illuminate in turn to display binary numbers from 0 to
    255, with the least-significant bit on the right side of the LEDs.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '这个项目使用与项目 #4 相同的硬件。一旦上传了草图，LED 应依次点亮，显示从 0 到 255 的二进制数字，最不重要的位位于 LED 的右侧。'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once again, we set the pins on port D to outputs ❶. We then set <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp>
    to the increasing value of the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    As the port register contains 8 bits, we can assign an integer between 0 and 255
    to the port so that the outputs match the binary equivalent of the number assigned
    to the register ❷.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次将端口 D 的引脚设置为输出 ❶。然后将<samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp>
    设置为整数 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 的递增值。由于端口寄存器包含 8
    位，我们可以将 0 到 255 之间的整数赋值给端口，从而使输出与分配给寄存器的数字的二进制等效值匹配 ❷。
- en: Before moving on, let’s practice mastering bit-shifting in port manipulation
    by turning LEDs on and off in one direction and then the other.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们通过在一个方向上点亮和熄灭 LED，然后在另一个方向上进行练习，掌握端口操作中的位移技巧。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #6: Creating a Blinking LED
    Wave</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #6：创建一个闪烁的 LED 波</samp>'
- en: 'In this project, using the hardware from Projects #4 and #5, you’ll create
    a wavelike light pattern to emulate the lights across the bonnet of the famous
    vehicle K.I.T.T. from the 1980s television show *Knight Rider*. Once you’ve uploaded
    this sketch, you should be presented with your own version of K.I.T.T.’s iconic
    scrolling lights.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个项目中，使用来自项目 #4 和 #5 的硬件，你将创建一个波浪状的光效图案，以模拟 1980 年代电视剧《*骑士先锋*》中著名的 K.I.T.T.
    车辆的车灯。一旦上传了这个草图，你应该会看到你自己版本的 K.I.T.T. 的标志性滚动灯光。'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This sketch has two loops: one to blink the LEDs from right to left and one
    to blink them in the opposite direction. We use bit-shifting to move the number
    1 from right to left along the port register. We loop eight times, for eight LEDs
    ❶. The LED is activated by assigning 1 to the port register ❷, which turns on
    the LED on digital pin D0 in the second run of the loop.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图有两个循环：一个从右到左闪烁 LED，另一个则是相反的方向。我们使用位移操作将数字 1 从右到左移动沿着端口寄存器。我们循环八次，处理八个 LED
    ❶。通过将 1 赋值给端口寄存器 ❷，激活 LED，这将在第二次循环中点亮数字引脚 D0 上的 LED。
- en: 'The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> is 1, so
    we shift the bit one to the left (using <samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>)
    in the port register, turning on the second LED on digital pin D1\. This process
    repeats until all eight LEDs have been turned on and off. The following list of
    port register bytes represents each event in this sequence of events:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> 的值为 1，所以我们将位向左移一位（使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>）在端口寄存器中，点亮数字引脚 D1 上的第二个
    LED。这个过程会重复，直到所有八个 LED 被依次点亮和熄灭。以下是代表这一事件序列的端口寄存器字节列表：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The process then repeats in reverse in the second loop at ❸, beginning by putting
    a bit in the seventh position (<samp class="SANS_TheSansMonoCd_W5Regular_11">01000000</samp>),
    and then continues along to bit 1\. We don’t need to put a bit in location 0 for
    this second loop, as that would illuminate the first LED twice in a row.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程然后在第二个循环中以反向重复 ❸，从将位放入第七位开始（<samp class="SANS_TheSansMonoCd_W5Regular_11">01000000</samp>），然后继续到位
    1。对于这个第二个循环，我们不需要在位置 0 放置位，因为那样会连续点亮第一个 LED 两次。
- en: 'The next two projects demonstrate another convenient application for port manipulation:
    using seven-segment LED displays, which are simply eight LEDs arranged to form
    a number with an optional decimal point.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个项目展示了端口操作的另一个便捷应用：使用七段 LED 显示器，这实际上是八个 LED 排列成一个数字并可以选择性地显示小数点。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #7: Controlling Seven-Segment
    LED Displays</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #7：控制七段 LED 显示屏</samp>'
- en: People generally use an external shift register IC, such as the 74HC595, to
    display simple numerical information with seven-segment LED displays. If you have
    the digital I/O pins to spare, however, you can save money on parts by using the
    method in this project. This project also includes a quick review of bitwise arithmetic.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常使用外部移位寄存器 IC，如 74HC595，通过七段 LED 显示屏显示简单的数字信息。然而，如果你有多余的数字 I/O 引脚，你可以通过使用本项目中的方法节省零件费用。本项目还包含了按位运算的简要回顾。
- en: 'You’ll need the following parts for this project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下零件来完成这个项目：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块 Arduino Uno 或兼容板以及 USB 电缆
- en: Eight 1 kΩ, 0.25 W, 1 percent resistors
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八个 1 kΩ、0.25 W、1% 的电阻
- en: A common-cathode seven-segment LED display (FND500-compatible)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个共阴极七段 LED 显示屏（兼容 FND500）
- en: A solderless breadboard
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊接面包板
- en: Male-to-male jumper wires
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公对公跳线
- en: Assemble the circuit as shown in [Figure 2-5](chapter2.xhtml#fig2-5) on the
    solderless breadboard and connect the points labeled D7 through D0 and GND to
    the Arduino’s respective pins.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图 2-5](chapter2.xhtml#fig2-5)中所示的电路图，在无焊接面包板上组装电路，并将标记为 D7 至 D0 和 GND 的点连接到
    Arduino 的相应引脚。
- en: '![THE SCHEMATIC FOR PROJECT #7](../images/fig2-5.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #7 的电路图](../images/fig2-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: The schematic for
    Project #7</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-5：项目 #7 的电路图</samp>'
- en: Once you’ve uploaded the sketch, the numbers 0 through 9 should display in turn
    and then display once more, this time with the decimal point in the LED display
    turned on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上传了草图，数字 0 到 9 应该依次显示，然后再次显示一次，这次 LED 显示屏上的小数点会亮起。
- en: 'Let’s see how this works:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何工作：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The sketch defines an array with 10 elements ❶, each including a binary number
    representing the LEDs of the display needed to power on or off to display each
    digit. From the schematic in [Figure 2-5](chapter2.xhtml#fig2-5), you can see
    that the display is wired so its first pin (A) is connected to digital pin D7,
    and so on. In this project, port D is set at ❷. Displaying the required digit
    is a simple matter of allocating the required array element (0 to 9) to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> at ❸ and ❹.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图定义了一个包含 10 个元素 ❶ 的数组，每个元素包含一个二进制数字，表示需要打开或关闭的 LED，以显示每个数字。从[图 2-5](chapter2.xhtml#fig2-5)的电路图中可以看到，显示屏的第一个引脚（A）连接到数字引脚
    D7，依此类推。在这个项目中，端口 D 被设置为 ❷。显示所需数字的操作很简单，只需将所需的数组元素（0 到 9）分配给 ❸ 和 ❹ 处的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp>
    即可。
- en: The loop ❹ turns the decimal point on. Bit 0 in each array element represents
    the decimal point LED in the display, so the sketch needs to change the bit in
    bit 0 using the OR function (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>)
    in bitwise arithmetic. When you use OR to compare 2 bits, the result is 1 if either
    bit is 1 or if both are 1.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 循环 ❹ 打开小数点。每个数组元素中的第 0 位代表显示屏中的小数点 LED，因此草图需要使用按位运算中的 OR 函数（<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>）来更改第
    0 位。当你使用 OR 比较两个比特时，如果其中一个比特是 1，或者两个比特都是 1，结果就是 1。
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Therefore, you can add the decimal point to a numerical byte using the following
    (in the sketch, the numerical byte is set to display the number 1 and the decimal
    point):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以通过以下方法将小数点添加到数字字节中（在草图中，数字字节被设置为显示数字 1 和小数点）：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the future, if you’re using the LED display in your own projects with port
    manipulation, you can take advantage of the following custom function to display
    numbers with or without the decimal point. You can also test it by adding it to
    Project #7.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '未来，如果你在自己的项目中使用带有端口操作的 LED 显示屏，可以利用以下自定义函数显示带或不带小数点的数字。你也可以通过将其添加到项目 #7 来进行测试。'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you want to turn off a particular output that you know is currently on without
    affecting the other pins, use the bitwise AND function <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>.
    When a bit is compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    0, the result is 0 if the bit is 1\. For example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想关闭当前已打开的某个特定输出，而不影响其他引脚，可以使用按位与函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>。当比特与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 0 比较时，如果比特是 1，结果为 0。例如：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To turn off the first and last output when all pins are on, you’d use the following
    code, which leaves bits 6 through 1 on, with 7 and 0 off:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭第一个和最后一个输出（当所有引脚都打开时），你可以使用以下代码，这将保留位 6 到位 1 打开，而位 7 和位 0 关闭：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that you have the LED display circuit connected, let’s make an electronic
    die.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经连接了 LED 显示电路，接下来让我们制作一个电子骰子。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #8: Creating an Electronic
    Die</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #8：创建一个电子骰子</samp>'
- en: In this project, you’ll create an electronic die that generates a random number
    between one and six to mimic rolling a physical die.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将创建一个电子骰子，生成一个 1 到 6 之间的随机数，模拟掷物理骰子的过程。
- en: 'This project uses the same hardware as Project #7\. Upload the sketch; the
    display should rapidly scroll through the numbers and then slow down bit by bit
    until it stops.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '该项目使用与项目 #7 相同的硬件。上传草图后，显示屏应迅速滚动显示数字，然后逐渐变慢直到停止。'
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The sketch is a combination of new code and the functions that were used in
    Project #7\. The sketch first uses the custom function from that project to display
    the digits ❶ and then seed the random number generator ❷. It rapidly displays
    100 random numbers for visual effect ❸ and then displays the next 10 random numbers
    with an increasing time delay between each number ❹. Finally, after one last random
    number is displayed ❺, everything stops. To display another random number, press
    the reset button.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '该草图结合了新代码和项目 #7 中使用的函数。草图首先使用该项目中的自定义函数显示数字 ❶，然后初始化随机数生成器 ❷。它迅速显示 100 个随机数以产生视觉效果
    ❸，然后显示接下来的 10 个随机数，每个数字之间的时间延迟逐渐增加 ❹。最后，在显示最后一个随机数 ❺ 后，一切停止。要显示另一个随机数，按下重置按钮。'
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #9: Reading Multiple Digital
    Inputs Simultaneously</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #9：同时读取多个数字输入</samp>'
- en: You can also read digital input pins rapidly using the port-style operations,
    rather than by using multiple <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalRead()</samp>
    functions. Since each port returns 8 bits of data (including ports B and C, which
    have only six physical pins), we can simply set the required port to inputs and
    then assign the value of a port to a variable. The value is an 8-bit number that
    represents the status of the input pins.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用端口式操作快速读取数字输入引脚，而不是通过使用多个 <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalRead()</samp>
    函数。因为每个端口返回 8 位数据（包括 B 和 C 端口，虽然它们只有六个物理引脚），所以我们只需将所需端口设置为输入，然后将端口的值赋给变量。该值是一个
    8 位数字，表示输入引脚的状态。
- en: 'Once inputs have been set using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DDR</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> function in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>, just assign the port to a variable to read the status of the pins.
    For example, to read the status of port D once set to inputs, use this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DDR</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>
    函数在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> 中设置了输入，只需将端口赋值给一个变量来读取引脚的状态。例如，一旦将端口
    D 设置为输入，就可以使用以下代码读取其状态：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This project demonstrates how to read an entire port at once and then display
    the status of that port using another port of LEDs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目演示了如何一次性读取整个端口，然后使用另一个端口的 LED 显示该端口的状态。
- en: 'You’ll need the following parts:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下部件：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块 Arduino Uno 或兼容板及 USB 数据线
- en: Four 1 kΩ, 0.25 W, 1 percent resistors
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个 1 kΩ，0.25 W，1% 的电阻
- en: Four 10 kΩ, 0.25 W, 1 percent resistors
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个 10 kΩ，0.25 W，1% 的电阻
- en: Four LEDs
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个 LED
- en: Four tactile buttons
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个触摸按钮
- en: A solderless breadboard
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无焊面包板
- en: Male-to-male jumper wires
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 男对男跳线
- en: Assemble the circuit as shown in [Figure 2-6](chapter2.xhtml#fig2-6) on the
    solderless breadboard and connect the points labeled D7 through D4, D13 through
    D10, 5V, and GND to the Arduino’s respective pins.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 [图 2-6](chapter2.xhtml#fig2-6) 所示的电路在无焊面包板上组装电路，并将标记为 D7 到 D4，D13 到 D10，5V
    和 GND 的点连接到 Arduino 的相应引脚。
- en: '![THE SCHEMATIC FOR PROJECT #9](../images/fig2-6.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #9 的电路图](../images/fig2-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: The schematic for
    Project #9</samp>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-6：项目 #9 的电路图</samp>'
- en: Once you’ve uploaded the sketch, pressing a button should illuminate the matching
    LED.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上传草图后，按下按钮应点亮对应的 LED。
- en: 'Let’s see how this works:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This sketch demonstrates the code minimalization made possible using port manipulation:
    you can read the status of up to eight buttons in one line, instead of using eight
    separate <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalRead()</samp> functions.
    After setting the pins’ status ❶, the sketch assigns the value of the pins (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp>) to port D, which sets the
    outputs as instructed ❷.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了通过端口操作使代码最小化的可能性：你可以在一行中读取最多八个按钮的状态，而不是使用八个单独的 <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalRead()</samp>
    函数。在设置引脚状态❶后，示例将引脚的值(<samp class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp>)赋给端口D，从而按照指示设置输出❷。
- en: Next, the code bit-shifts the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp>
    2 bits to the left ❸. Port B has only six physical pins but still returns an 8-bit
    number when read. The two most significant bits are 0, and the final six represent
    the status of D13 to D8\. Therefore, this project moves the <samp class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp>
    value to the left so the bits match port D for the output control.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码将 <samp class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp> 的值左移2位❸。B端口只有六个物理引脚，但读取时仍会返回一个8位数字。最显著的两位是0，最后六位代表D13到D8的状态。因此，本项目将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp> 的值左移，以便与端口D的输出控制匹配。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Binary-Coded Decimal Switches</samp>
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">二进制编码十进制开关</samp>
- en: 'The form of reading digital inputs demonstrated in Project #9 lends itself
    well to input devices with more than one output, such as rotary switches with
    BCD outputs representing the binary values of numbers 0 through 9\. BCD switches
    are a convenient method of accepting user input for setting options, values, or
    other project requirements where the user inputs a number between 0 and 9.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '项目 #9 中展示的数字输入读取形式非常适合多输出的输入设备，例如带有BCD输出的旋转开关，BCD输出代表0到9之间数字的二进制值。BCD开关是一种方便的用户输入方法，用于设置选项、数值或其他项目需求，其中用户输入一个0到9之间的数字。'
- en: '![THE SCHEMATIC SYMBOL FOR A TYPICAL BCD SWITCH](../images/fig2-7.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![典型BCD开关的原理符号](../images/fig2-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-7: The schematic symbol
    for a typical BCD switch</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-7：典型BCD开关的原理符号</samp>
- en: BCD switches offer 10 position selections and have 4 output pins easily readable
    with 4 digital input pins. The fifth pin is commonly connected to the 5V pin,
    which allows the current to flow through to the switched output pins. [Figure
    2-7](chapter2.xhtml#fig2-7) shows the schematic symbol for a typical BCD switch.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: BCD开关提供10个位置选择，并且有4个输出引脚，可以通过4个数字输入引脚轻松读取。第五个引脚通常连接到5V引脚，这允许电流通过切换的输出引脚。[图2-7](chapter2.xhtml#fig2-7)展示了典型BCD开关的原理符号。
- en: '![A PHOTO OF A PUSH-WHEEL BCD SWITCH](../images/fig2-8.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![推轮BCD开关的照片](../images/fig2-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-8: A push-wheel BCD
    switch</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-8：推轮BCD开关</samp>
- en: Examples of BCD switches include the retro-style “push-wheel” switches, as shown
    in [Figure 2-8](chapter2.xhtml#fig2-8), and rotary switches, as shown in [Figure
    2-9](chapter2.xhtml#fig2-9).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: BCD开关的例子包括复古风格的“推轮”开关，如[图2-8](chapter2.xhtml#fig2-8)所示，以及旋转开关，如[图2-9](chapter2.xhtml#fig2-9)所示。
- en: '![A PHOTO OF A ROTARY BCD SWITCH](../images/fig2-9.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![旋转BCD开关的照片](../images/fig2-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-9: A rotary BCD switch</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-9：旋转BCD开关</samp>
- en: For performing simple BCD experiments, it’s easier to use the rotary BCD switch
    shown in [Figure 2-9](chapter2.xhtml#fig2-9), as it doesn’t require any soldering.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行简单的BCD实验，使用[图2-9](chapter2.xhtml#fig2-9)中展示的旋转BCD开关更为方便，因为它不需要任何焊接。
- en: With any switch, users must be careful to move the lever or pointer to the correct
    position. For example, if you change a rotary switch and leave the pointer between
    two digits, it will not return a correct value. The next project demonstrates
    how to implement these switches with port manipulation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何开关时，用户必须小心将杠杆或指针移到正确的位置。例如，如果你改变旋转开关并将指针留在两个数字之间，它将无法返回正确的值。下一个项目展示了如何使用端口操作实现这些开关。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #10: Reading BCD Switches</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #10：读取BCD开关</samp>'
- en: This project demonstrates reading a BCD switch by using port manipulation to
    return the value in both binary and decimal to the Serial Monitor, allowing you
    to receive numerical user input simply and efficiently.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目演示了如何通过端口操作读取BCD开关，将值以二进制和十进制返回到串行监视器，允许你简单高效地接收数字用户输入。
- en: 'You’ll need the following parts:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下组件：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Arduino Uno或兼容板和USB线
- en: A BCD rotary or push-wheel switch
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个BCD旋转开关或推钮开关
- en: A solderless breadboard
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊接面包板
- en: Male-to-male jumper wires
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公对公跳线
- en: Assemble the circuit as shown in [Figure 2-10](chapter2.xhtml#fig2-10) on the
    solderless breadboard and connect the points labeled 5V and D11 through D8 to
    the Arduino’s respective pins.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图 2-10](chapter2.xhtml#fig2-10)所示，在无焊接面包板上组装电路，并将标记为5V和D11到D8的点连接到Arduino的相应引脚。
- en: '![THE SCHEMATIC FOR PROJECT #10](../images/fig2-10.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![项目#10的电路图](../images/fig2-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-10: The schematic
    for Project #10</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-10：项目#10的电路图</samp>
- en: Enter and upload the sketch and then open the Serial Monitor. You should see
    the value of the switch’s setting displayed in both binary and decimal, as shown
    in [Figure 2-11](chapter2.xhtml#fig2-11).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输入并上传草图，然后打开串行监视器。你应该能看到开关设置的值以二进制和十进制显示，如[图 2-11](chapter2.xhtml#fig2-11)所示。
- en: '![AN EXAMPLE OUTPUT FROM PROJECT #10 ON THE ARDUINO SERIAL MONITOR, SHOWING
    BINARY AND DECIMAL RESULTS FROM READING THE BCD SWITCH](../images/fig2-11.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![来自项目#10的示例输出，在Arduino串行监视器中显示来自BCD开关的二进制和十进制结果](../images/fig2-11.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-11: Example output
    for Project #10</samp>'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-11：项目#10的示例输出</samp>
- en: 'Let’s see how this works:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code sets pins D11 through D8 to inputs and sets D12 and D13 to outputs
    ❶, since it doesn’t want to return the values of pins D12 and D13\. It then simply
    returns the value of port B to the Serial Monitor in binary ❷ and decimal ❸ forms.
    The binary value should reflect the actual signals from the switch back to the
    Arduino’s input pins, while the decimal is the integer equivalent of the same
    signals.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将D11到D8的引脚设置为输入，将D12和D13设置为输出❶，因为它不想返回D12和D13的引脚值。然后，它简单地将端口B的值以二进制❷和十进制❸形式返回给串行监视器。二进制值应反映来自开关到Arduino输入引脚的实际信号，而十进制是相同信号的整数等价物。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">继续前进</samp>
- en: This chapter showed you how to work more quickly and efficiently with your Arduino’s
    digital input and output pins by using port manipulation, controlling many LEDs
    without external ICs and receiving settings without needing to use a display or
    multiple switches. In the next chapter, you’ll learn how to use the physically
    smaller and cheaper ATtiny series of microcontrollers for less complex Arduino
    projects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你展示了如何通过使用端口操作，更快速高效地使用Arduino的数字输入和输出引脚，控制许多LED而无需外部IC，并接收设置而不需要使用显示器或多个开关。在下一章，你将学习如何使用体积更小、成本更低的ATtiny系列微控制器来进行不太复杂的Arduino项目。
