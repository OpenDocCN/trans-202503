- en: 9. hardware hacking
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9. 硬件破解
- en: 'The biggest barrier to hacking is often the fear that you’ll break something
    while poking around. But you have to break eggs to make an omelet; likewise, you
    have to be willing to sacrifice devices to hack a system. Fortunately, acquiring
    multiple copies of a mass-produced piece of hardware is easy. I often do a bit
    of dumpster diving or check classified advertisements to get sample units for
    research purposes. I generally try to start with three copies: one to tear apart
    and never put back together, one to probe, and one to keep relatively pristine.
    I use the pristine copy to sanity-check whether a certain behavior is due to my
    probing or just how the hardware behaves.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 破解的最大障碍通常是担心在试探过程中弄坏某些东西。但你必须打破鸡蛋才能做出煎蛋卷；同样，你必须愿意牺牲一些设备才能破解一个系统。幸运的是，获得多台大规模生产的硬件样本非常容易。我经常做一些垃圾桶潜水，或查看分类广告，以获取研究用的样品。我通常会从三台设备开始：一台拆开并永远不再组装，
    一台用来探测，还有一台保持相对完好。我使用完好的设备来检查某种行为是否是由于我的探测所引起的，或者仅仅是硬件的正常表现。
- en: My typical approach to any hardware hack is first getting the device open and
    then getting a probe in just the right spot without affecting the device’s functionality.
    When you’re looking inside computer chips, that’s virtually the entire challenge.
    The first hack in this chapter is an example of silicon hacking, and you’ll see
    that once the package is off and you’re staring at naked silicon, an attacker
    has a profound advantage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我对任何硬件破解的典型方法是，首先打开设备，然后将探针放在正确的位置，而不影响设备的功能。当你研究计算机芯片时，这几乎就是全部挑战。 本章中的第一个破解示例是硅片破解，你将看到，一旦包装去除，裸露的硅片暴露在眼前，攻击者就拥有了巨大的优势。
- en: Some hardware hacks require more system engineering, particularly when you want
    to reverse engineer and repur-pose a device. In these situations, I tend to develop
    additional bespoke tools that allow me to tweak and observe a system in close
    to real time, or at least as fast as I can type commands, to minimize the time
    spent validating hypotheses. The goal is to make the primary limitation how fast
    you can think of ideas to test, not how long it takes to upload a change to test
    those ideas. The second hack in this chapter talks about reverse engineering a
    relatively simple System-on-Chip (SoC) device found inside common SD memory cards
    and some tools I developed to aid that process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一些硬件破解需要更多的系统工程，特别是当你想逆向工程并重新利用一个设备时。在这些情况下，我倾向于开发额外的定制工具，让我能够接近实时地调整和观察系统，或者至少在我能输入命令的速度下，尽量减少验证假设所花费的时间。目标是让主要的限制变成你能多快想到要测试的想法，而不是多长时间才能上传一个改变以测试这些想法。本章中的第二个破解讲述了如何逆向工程一种相对简单的系统单芯片（SoC）设备，这种设备常见于SD存储卡中，以及我为辅助这一过程而开发的一些工具。
- en: Finally, some hacks inevitably push the boundaries of the law. The third hack
    in this chapter talks about NeTV, a system I developed that takes a new look at
    the High-Definition Content Protection (HDCP) encryption standard, which secures
    most HDMI video links. NeTV is a hack on both a legal issue and a hardware system.
    It works around the thorny problems presented by the DMCA by reinterpreting the
    HDCP standard to enable a man-in-the-middle (MITM) attack to change video data
    without circumventing encryption. No circumvention, no DMCA problem. Hacks often
    push the boundary of what’s legal and what’s been tested in the courts. Just like
    any other system, the legal system can also be hacked, and one key takeaway from
    this chapter is how to think of laws as just another constraint to work with on
    the way to achieving a particular goal.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些破解不可避免地会突破法律的边界。本章中的第三个破解讲述了NeTV，一个我开发的系统，它对高清内容保护（HDCP）加密标准进行了全新的解读，HDCP标准用于保护大多数HDMI视频连接。NeTV是一个既涉及法律问题又涉及硬件系统的破解。它通过重新解释HDCP标准，绕过了DMCA所带来的棘手问题，从而实现了中间人攻击（MITM），可以在不绕过加密的情况下修改视频数据。没有绕过加密，就没有DMCA问题。破解经常突破法律和司法判决的边界。就像任何其他系统一样，法律系统也可以被破解，本章的一个重要收获是如何将法律看作是实现某个特定目标时需要应对的另一个约束条件。
- en: The final hack in this chapter combines hardware penetration, tool creation,
    and legal considerations to reverse engineer a complex mobile phone SoC. That’s
    another project I worked on with xobs, and once again, building bespoke hacking
    tools was invaluable because it allowed us to experiment with the system as it
    ran.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个破解结合了硬件渗透、工具创作和法律考量，旨在逆向工程一个复杂的手机SoC。这是我和xobs一起做的另一个项目，再次证明，构建定制的破解工具是非常宝贵的，因为它使我们能够在系统运行时进行实验。
- en: '**HACKING THE PIC18F1320**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**破解PIC18F1320**'
- en: Keeping a secret is a common challenge for any security system. To solve this
    challenge, security system designers frequently hide secrets inside silicon chips
    because the chips’ rugged epoxy packages and tiny geometries are difficult to
    penetrate and inspect.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 保守秘密是任何安全系统面临的常见挑战。为了应对这个挑战，安全系统设计师经常将秘密隐藏在硅芯片内部，因为芯片的坚固环氧封装和微小的几何结构很难穿透和检查。
- en: This sounds good in theory but is problematic in practice. Chip designers make
    mistakes, and when a chip has a problem, the designers need a way to open it up
    and investigate. This situation is so common that there are commercial services
    that specialize in opening up chips expressly for that purpose. Called *failure
    analysis services*, they’ve mastered several techniques for removing tough epoxy
    from chips.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个理论上听起来不错，但在实际操作中却有问题。芯片设计师会犯错，当芯片出现问题时，设计师需要一种方式来打开芯片并进行调查。这种情况非常普遍，以至于有专门的商业服务，专门为此目的打开芯片。它们被称为*故障分析服务*，已经掌握了多种去除芯片上顽固环氧树脂的技术。
- en: A couple of years before my crash course in setting up a Chinese supply chain
    with Chumby, I decided it would be fun to demonstrate how simple hacking a chip
    can be if you’re aware of failure analysis services. At the time, Microchip’s
    PIC series of microcontrollers was quite ubiquitous, so I decided to have a go
    at a popular PIC model. PICs typically have *configuration fuses*, which you can
    activate to prevent certain regions of memory from being read or written to. But
    there’s often a legitimate need to read the contents of a secured, programmed
    PIC. For instance, a company that loses either the documentation for a product
    or the personnel that originally created the codes for a secured PIC would be
    stuck without a way to read the chip. This is a problem when a company needs to
    revise or upgrade a legacy line of products.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始学习如何搭建中国供应链并与Chumby合作之前的几年，我决定展示一下如果知道故障分析服务，破解一个芯片其实有多简单。当时，Microchip的PIC系列微控制器非常普及，所以我决定尝试一个流行的PIC型号。PIC芯片通常有*配置保险丝*，你可以激活它们来防止某些内存区域被读取或写入。但是，通常会有合法的需求需要读取已加密、已编程的PIC内容。例如，一家公司如果丢失了产品文档或失去了原来编写加密PIC代码的人员，就无法读取芯片。这对需要修订或升级旧款产品线的公司来说是一个问题。
- en: I wanted to figure out how to dump the memory from a secured PIC. Knowing I’d
    have to break a few eggs to make this omelet, I scored four PIC18F1320s from a
    friend and started stripping them down. Here’s what I found.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我想弄清楚如何从加密的PIC中转储内存。我知道要想做这件事，必须打破一些规则。所以我从朋友那里拿到了四个PIC18F1320并开始拆解它们。这是我发现的。
- en: '![image](../images/f0282-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0282-01.jpg)'
- en: '*A PIC18F1320 in its native state*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始状态下的PIC18F1320*'
- en: '**Decapping the IC**'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**去封装IC**'
- en: First, I had to take the top off so I could see the silicon under the hood.
    Many homebrew techniques for decapping a chip typically involve applying fuming
    nitric or sulfuric acid, but those aren’t compounds you’d want to keep at home,
    nor are they easy to obtain. Nitric acid, in particular, is an important compound
    for explosives fabrication. So, I’ve found the easiest and most reliable way to
    decap a chip is to just send it to a failure analysis lab. For about $50, you
    can have a decapped part in two days.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要去掉顶部才能看到芯片内部的硅。许多自制的去封装芯片技术通常涉及使用硝酸或硫酸，但这些化学品你不希望在家里存放，而且它们也不容易获得。特别是硝酸，是制造炸药的重要化学品。所以，我发现最简单、最可靠的去封装方式就是直接把芯片送到故障分析实验室。大约50美元，你可以在两天内获得一个去封装的芯片。
- en: I decapped three parts for this project. Two were *functionally decapped* (silicon
    revealed with the device still in its lead frame, fully functional), and the last
    was *fully decapped* (just a bare silicon die with no package). I had one die
    fully decapped because my inspection microscope had a very short working distance
    at the highest magnifications, and the remaining epoxy from the package would
    have interfered with the lens.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个项目去掉了三个芯片的封装。其中两个是*功能性去封装*（在保持设备仍在引脚框架中的情况下揭示硅芯片，完全可操作），最后一个是*完全去封装*（只是裸硅芯片，没有封装）。我去掉了一个芯片的封装，因为我的检查显微镜在最高放大倍数下工作距离非常短，封装上剩余的环氧树脂会干扰镜头。
- en: '![image](../images/f0283-01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0283-01.jpg)'
- en: '*A functionally decapped PIC18F1320.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能性去封装的PIC18F1320。'
- en: The little raised square in the middle (it’s goldish in real life) is the silicon
    chip.*
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的小方块（现实中呈金色）是硅芯片。*
- en: '**Taking a Closer Look**'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**仔细观察**'
- en: With my decapped ICs in hand, I did a sweep around one of the dies with the
    microscope and noticed several prominent features. Because physics is the same
    everywhere, most of the fine-grained structure in a silicon chip looks pretty
    much the same, no matter who makes the chip. These constraints propagate their
    way up to the system level, and with a bit of training, you can read a silicon
    chip like a book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 手中拿着已经去掉封装的集成电路（IC），我用显微镜仔细观察了其中一个芯片的表面，注意到了一些显著的特征。由于物理规律在任何地方都是相同的，硅芯片中的大多数精细结构看起来几乎是一样的，不管是哪个厂家制造的。这些限制条件会一直延续到系统层面，通过一点训练，你可以像读书一样阅读硅芯片。
- en: '![image](../images/f0283-02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0283-02.jpg)'
- en: '*My best guess at what various structures in this chip do. I could be wrong.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*我对于这个芯片中各种结构的功能的最佳猜测。我可能是错的。*'
- en: 'One set of structures grabbed my attention immediately: there were metal shields
    over some transistors, following a regular pattern that had about the right number
    of devices to account for all the security bits. Full-metal shields covering a
    device are very rare in silicon, so they’re like a big X marking the spot where
    something very important is kept.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有一组结构立即吸引了我的注意：一些晶体管上方有金属屏蔽，按照规律的图案排列，正好有足够的设备数量来对应所有的安全位。完全覆盖设备的全金属屏蔽在硅芯片中非常罕见，因此它们像一个大大的X，标记着存放非常重要内容的地方。
- en: '![image](../images/f0284-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0284-01.jpg)'
- en: '*Zooming in on the metal shields*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*放大观察金属屏蔽*'
- en: '**Erasing the Flash Memory**'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**擦除闪存**'
- en: The shields were significant because of some interesting facts about flash memory
    technology, which this PIC device used to store the security fuse information,
    as well as the internal program code. Flash technology uses a floating-gate transistor
    structure very similar to old *UV-erasable programmable read-only memory (UV-EPROM)*
    technologies like the ceramic-packaged 2716 chips from the 1970s, which had quartz
    windows so they could be erased.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 屏蔽层之所以重要，是因为闪存技术的一些有趣事实，这种技术被这款PIC设备用来存储安全熔丝信息以及内部程序代码。闪存技术使用的浮动栅极晶体管结构，与老式的*紫外可擦除可编程只读存储器（UV-EPROM）*技术非常相似，比如1970年代的陶瓷封装2716芯片，这些芯片上有石英窗口，因此可以进行擦除。
- en: In both flash and UV-EPROM devices, data is written when electrons tunnel into
    a floating gate, where the electrons remain for decades. The extra electrons in
    the floating gate create a measurable offset in the characteristics of the storage
    transistor. The difference is that flash memory can withdraw the stored electrons
    (erase the device) using only electrical pulses, while a UV-EPROM requires energetic
    photons to knock the electrons out of the floating gate. The UV light required
    to accomplish this is typically on a wavelength of around 250 nm. You need expensive
    quartz optics to manipulate this wavelength of UV without excessive loss, making
    it a bit difficult to harness.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在闪存和紫外EPROM设备中，数据是在电子隧穿到浮动栅极时写入的，电子会在栅极中停留数十年。浮动栅极中的额外电子会在存储晶体管的特性中产生可测量的偏移。不同之处在于，闪存可以通过电脉冲将存储的电子抽回（擦除设备），而紫外EPROM则需要高能光子将电子从浮动栅极中撞出。完成此操作所需的紫外光通常波长大约为250纳米。你需要昂贵的石英光学器件来操控这种波长的紫外线，以避免过多的损失，这使得利用这种光源有些困难。
- en: 'Here’s the important conclusion I drew from these facts: flash devices can
    usually *also* be erased using UV light since they have a similar transistor structure
    to UV-EPROM devices. The encapsulation around a flash device normally prevents
    any UV light from effectively reaching the die, but since the PIC devices had
    the plastic around them removed, I could attempt to apply UV light and see what
    happened.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些事实中我得出了一个重要结论：闪存设备通常也*可以*通过紫外光擦除，因为它们的晶体管结构与紫外EPROM设备相似。闪存设备周围的封装通常会阻止紫外光有效到达芯片表面，但由于这些PIC设备的塑料外壳已被去除，我可以尝试施加紫外光并观察发生了什么。
- en: I performed a simple experiment by programming the PIC device with a ramping
    pattern, where I stored the hexadecimal numbers from 0x00 to 0xFF over and over
    again. Then, I tossed the PIC into my UV-EPROM eraser to bake for ... oh, about
    the length of a good long shower and some email checking. When I took the device
    out of the eraser, the flash memory was indeed blanked to its normal all 1s state,
    and the security fuses were unaffected. After baking a few more PIC devices in
    the eraser, I found that if I didn’t bake a PIC long enough, I got odd readings
    out of the array I wrote to, such as all 0s, a phenomenon that I still don’t understand.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我进行了一次简单的实验，通过为 PIC 设备编程一个逐步变化的模式，反复存储从 0x00 到 0xFF 的十六进制数值。然后，我将 PIC 放进紫外线
    EPROM 擦除器中烘烤……大约是洗个长时间的热水澡和查点邮件的时间。当我从擦除器中取出设备时，闪存确实恢复到正常的全 1 状态，安全熔断器则没有受到影响。经过几次烘烤
    PIC 设备后，我发现如果我没有烘烤足够长时间，擦除的数据阵列会出现奇怪的读数，例如全 0，这种现象我至今无法解释。
- en: '**Erasing the Security Bits**'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**擦除安全位**'
- en: Clearly, the metal shields over the security fuses were there to thwart attempts
    to selectively erase the security fuses while leaving the flash memory array unaffected.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，覆盖在安全熔断器上的金属屏蔽是为了阻止尝试选择性擦除安全熔断器，同时不影响闪存阵列的操作。
- en: '![image](../images/f0286-01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0286-01.jpg)'
- en: '*A diagram showing how the shields got in the way of the fuse bits, and how
    to work around them*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*一张示意图，展示了屏蔽如何妨碍熔断位的操作，以及如何绕过这些屏蔽*'
- en: My problem was that for the flash memory transistor to be erased, high-intensity
    UV light needed to strike the floating gate. The metal shield effectively reflected
    all incident light, so the light never reached the gate. But I knew there was
    a refraction index mismatch between the optically clear protective dielectric
    layer of silicon dioxide covering the chip and the silicon proper, meaning light
    at certain angles would reflect off of the smooth silicon surface. For an example
    of this reflective effect, jump in a swimming pool, go under water, and look up
    at where the water and air meet. The water should look highly reflective at an
    oblique angle because the refractive index mismatch between water and air causes
    total internal reflection of light.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我的难题在于，为了擦除闪存晶体管，必须有高强度的紫外线光照射到浮动栅极。金属屏蔽有效地反射了所有入射光，因此光线无法到达栅极。但我知道，覆盖在芯片上的光学透明保护介电层——二氧化硅与硅本身之间存在折射率不匹配，这意味着光线在某些角度下会从光滑的硅表面反射回来。要了解这种反射效果的例子，你可以跳进游泳池，潜入水下，抬头看水面与空气接触的地方。由于水和空气之间的折射率不匹配，光线在倾斜角度下会发生全内反射，因此水面在这个角度下看起来非常反光。
- en: 'I planned to use this reflection to bounce the UV light off the oxide to hit
    the metal shield and bounce back onto the floating gate. By angling the PIC inside
    the ROM eraser, I thought I could get enough light to bounce into the flash memory
    transistor region and erase the security bits. After a couple of attempts using
    bits and bobs of material to fix the angle of the chip, I developed a simple technique
    that worked surprisingly well: shoving the chip into the antistatic foam liner
    of the UV eraser at an angle.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我计划利用这种反射效应将紫外线反射到氧化层上，再打到金属屏蔽上并反弹回浮动栅极。我认为通过调整 ROM 擦除器内部的 PIC 角度，我可以让足够的光反射到闪存晶体管区域，进而擦除安全位。在用各种小材料调整芯片角度尝试了几次后，我开发了一种意外有效的简单技巧：将芯片按一定角度推入紫外线擦除器的防静电泡沫内。
- en: '![image](../images/f0287-01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0287-01.jpg)'
- en: '*The chip in the UV eraser’s antistatic foam*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*紫外线擦除器中的芯片与防静电泡沫*'
- en: '**Protecting the Other Data**'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**保护其他数据**'
- en: That technique didn’t protect the flash data I wanted to keep, though. To avoid
    erasing this data, I made a hard mask out of a very carefully cut piece of electrical
    tape and stuck that mask to the surface of the die using a steady hand, two tweezers,
    and a microscope. The electrical tape blocked the UV light from directly hitting
    the flash code memory regions and somewhat absorbed light bounced back from the
    silicon substrate.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种技巧并没有保护我想保留的闪存数据。为了避免擦除这些数据，我用一小块精确裁剪的电气胶带制作了一个硬掩膜，并用稳定的手法、两只镊子和显微镜将掩膜贴在芯片表面。电气胶带阻挡了紫外线直接照射到闪存代码存储区，并且部分从硅基底反弹回来的光线被胶带吸收。
- en: '![image](../images/f0287-02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0287-02.jpg)'
- en: '*The die in its package, with electrical tape over the flash ROM array*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*封装中的芯片，闪存 ROM 数组上覆盖着电气胶带*'
- en: This mask allowed me to reset only the security fuses without impacting the
    flash code array too much. The following screenshots show the array memory status
    according to the programming and readback tool I was using.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个掩码让我只重置了安全熔丝，而不会对闪存代码阵列造成太大的影响。以下截图展示了我使用的编程和读回工具根据内存阵列的状态。
- en: '![image](../images/f0288-01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0288-01.jpg)'
- en: '*My PIC programmer workspace, showing the device settings before erasure The
    device settings after erasure*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*我的PIC编程工作区，显示了擦除前的设备设置 和擦除后的设备设置*'
- en: '![image](../images/f0288-02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0288-02.jpg)'
- en: '*The device settings after erasure*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*擦除后的设备设置*'
- en: In the before shot, note the settings of the security fuses in the Configuration
    Bits window and the values programmed in the flash ROM, shown in the Program Memory
    window. In the after shot, the security fuses switch to being disabled, while
    the flash ROM contents in the Program Memory window read identically to what was
    programmed in previously. A different part of the code array was actually still
    erased, but I could probably have fixed that by cutting a bigger piece of electrical
    tape.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前图中，请注意配置位窗口中的安全熔丝设置，以及在程序内存窗口中显示的闪存ROM中编程的值。在后图中，安全熔丝切换为禁用状态，而程序内存窗口中的闪存ROM内容与之前编程的内容完全一致。实际上，代码阵列的另一部分仍然被擦除了，但我可能可以通过剪下一块更大的电气胶带来解决这个问题。
- en: I’ve heard reports that since this hack was published, Microchip started putting
    metal shields over the code memory array as well as the fuses, making it a bit
    more difficult to pull off this trick. Still, this hack underscores the fact that
    quite often, the hardest part of silicon hacking is removing the outer package,
    and fortunately, there are cheap, if obscure, services available to assist with
    that problem.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我听说自从这个黑客攻击被公开后，Microchip开始在代码内存阵列以及熔丝上放置金属屏蔽，使得实施这个攻击变得有些困难。尽管如此，这个攻击仍然突显了硅黑客的一个事实，那就是最难的部分往往是去除外包装，幸运的是，仍然有一些便宜但可能不太为人知的服务可以帮助解决这个问题。
- en: '**HACKING SD CARDS**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**破解SD卡**'
- en: 'Years later, I found myself hacking into yet another interesting device with
    flash memory: an SD card. I’d already torn down SD cards when investigating a
    batch of potentially fake cards that found their way into Chumby production units,
    which I discuss in “[Fake MicroSD Cards](ch05.xhtml#ch00lev1sec99)” on [page 156](ch05.xhtml#page_156).
    This time, my intent was to figure out how to get an SD card to do something it
    wasn’t made to do. This particular hack was another team effort with my friend
    xobs, and it was funded by DARPA’s Cyber Fast Track (CFT) initiative. The brainchild
    of uberhacker .mudge (one of the original crew of L0pht), CFT was a hack on the
    US government to make it smarter about innovation, particularly on matters related
    to internet security. We pulled it off around the same time we were working on
    Novena and I was collaborating with Jie Qi on Chibitronics.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，我发现自己又在破解一个有趣的设备——SD卡。我曾在调查一批可能是伪造的SD卡时拆解过SD卡，这些卡被发现进入了Chumby生产单元，我在《[伪造MicroSD卡](ch05.xhtml#ch00lev1sec99)》中对此进行了讨论，见[第156页](ch05.xhtml#page_156)。这次，我的目的是弄清楚如何让SD卡做一些它原本不应该做的事情。这个黑客攻击是我与我的朋友xobs合作的另一个团队项目，资金来自DARPA的网络快速跟踪（CFT）计划。CFT是超级黑客.mudge（L0pht的原始成员之一）的构思，它是对美国政府的一次黑客攻击，目的是让政府在创新方面变得更聪明，尤其是在与互联网安全相关的问题上。我们在做Novena项目时差不多也同时完成了这个任务，而我当时还在与Jie
    Qi合作Chibitronics项目。
- en: xobs and I discovered that some SD cards contain vulnerabilities that allow
    arbitrary code execution on the memory cards themselves. We also found that similar
    classes of vulnerabilities exist in related devices like USB flash drives and
    solid-state drives. On the dark side, code execution on a memory card enables
    MITM attacks where the card seems to behave one way but in fact does something
    else as an attacker intercepts and manipulates communications between the card
    and the device using it. On the light side, however, this vulnerability also gives
    hardware enthusiasts access to a very cheap and ubiquitous source of microcontrollers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我和xobs发现一些SD卡存在漏洞，允许在内存卡上执行任意代码。我们还发现类似的漏洞存在于相关设备中，如USB闪存驱动器和固态硬盘。在暗面，这种内存卡上的代码执行使得中间人攻击（MITM）成为可能，其中卡片看起来以一种方式工作，但实际上却做了别的事情，攻击者通过拦截并操纵卡片与设备之间的通信来实现这一点。然而，从积极的方面来看，这个漏洞也为硬件爱好者提供了一个非常便宜且普遍存在的微控制器来源。
- en: '![image](../images/f0290-01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0290-01.jpg)'
- en: '*Some of the eggs—or rather, SD cards—we cracked open to find the vulnerability*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们打开的其中一些“蛋”——或者说 SD 卡——找到了漏洞*'
- en: '**How SD Cards Work**'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SD 卡是如何工作的**'
- en: To understand the hack, you need to know how SD cards are structured. The information
    I’m about to explain applies to all *managed flash* devices, which includes microSD,
    SD, and MMC, as well as the eMMC and iNAND devices typically soldered onto the
    mainboards of smartphones to store the operating system and other private user
    data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个黑客技巧，你需要了解 SD 卡的结构。我接下来要解释的信息适用于所有*受管理闪存*设备，包括 microSD、SD 和 MMC，以及通常焊接在智能手机主板上的
    eMMC 和 iNAND 设备，用于存储操作系统和其他私人用户数据。
- en: 'Flash memory is billed as a contiguous, reliable storage medium, and it’s really
    cheap—so cheap that the premise is literally too good to be true. In reality,
    all flash memory is riddled with defects, without exception. It crafts the illusion
    of reliability through sophisticated error correction and badblock management
    functions. This system is the result of a constant arms race between the engineers
    and mother nature: every time the fabrication process shrinks transistors, memory
    becomes cheaper but more unreliable. Likewise, with every generation of chips,
    engineers create more sophisticated and complicated algorithms to compensate for
    nature’s propensity for entropy and randomness at the atomic scale.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存被宣传为一种连续、可靠的存储介质，而且它非常便宜——便宜到这个前提几乎好得让人难以相信。实际上，所有闪存都充满了缺陷，毫无例外。它通过复杂的错误修正和坏块管理功能制造出了可靠性的假象。这个系统是工程师和大自然之间持续博弈的结果：每次制造过程缩小晶体管尺寸时，内存变得便宜，但也更加不可靠。同样，每一代芯片，工程师都会创造出更加复杂的算法，以弥补大自然在原子尺度上对熵和随机性的倾向。
- en: 'These algorithms are too complicated and too device-specific to be run at the
    application or operating system level, so every flash memory disk ships with a
    reasonably powerful microcontroller to run a custom set of disk abstraction algorithms.
    Even tiny microSD cards contain not one, but *at least* two, chips: a controller
    and at least one flash chip. (High-density cards stack multiple flash dies.)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法过于复杂且设备特定，无法在应用程序或操作系统层面运行，因此每个闪存磁盘都会配备一个相当强大的微控制器来运行一套定制的磁盘抽象算法。即使是微小的
    microSD 卡，也包含不止一个，而是*至少*两个芯片：一个控制器和至少一个闪存芯片。（高密度卡会堆叠多个闪存芯片。）
- en: '![image](../images/f0291-01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0291-01.jpg)'
- en: '*Inside a microSD card. The small square in the upper-right corner is a microcontroller
    SoC mounted on top of the larger flash memory chip that it manages.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*microSD 卡内部。右上角的小方块是一个微控制器 SoC，它安装在更大的闪存芯片上，负责管理该闪存芯片。*'
- en: In my experience, the quality of the flash chip(s) integrated into memory cards
    varies widely. The chip could be anything from high-grade, factory-new silicon
    to material with more than 80 percent bad sectors. If you’re concerned about e-waste,
    you may (or may not) be pleased to know that memory card vendors commonly use
    recycled flash chips salvaged from discarded parts. Larger vendors tend to offer
    more consistent quality, but even the largest players staunchly reserve the right
    to mix and match flash memory chips with different controllers yet sell the assembly
    as the same part number. That’s a nightmare if you’re dealing with implementation-specific
    bugs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，集成在存储卡中的闪存芯片质量差异很大。芯片的质量可以从高品质、全新的硅片，到含有超过 80% 坏扇区的材料。如果你关心电子废弃物，可能（或者可能不会）高兴地知道，存储卡供应商通常使用回收的闪存芯片，这些芯片是从废弃的零部件中回收的。较大的供应商往往提供更一致的质量，但即使是最大的厂商，也坚决保留将不同控制器和闪存芯片混合搭配，然后将组装品以相同的零件号出售的权利。如果你正在处理与特定实现相关的错误，这无疑是一场噩梦。
- en: A memory card’s embedded microcontroller is often a heavily modified Intel 8051
    or ARM CPU that approaches 100 MHz performance levels and has several hardware
    accelerators on-die. Amazingly, adding these controllers to a memory card only
    costs about $0.15 to $0.30, particularly for companies that can fab both the flash
    memory and the controllers in the same business unit. Even more interestingly,
    due to the high cost of testing chips at the wafer level, it’s probably net cheaper
    to add a microcontroller that manages bad blocks, rather than thoroughly test
    and characterize each raw flash memory chip. And in fact, managed flash devices
    tend to be cheaper per bit than raw flash chips, despite the extra functionality.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 内存卡中的嵌入式微控制器通常是一个经过重度修改的Intel 8051或ARM CPU，接近100 MHz的性能水平，并且在芯片上集成了多个硬件加速器。令人惊讶的是，将这些控制器添加到内存卡上的成本仅约为$0.15到$0.30，特别是对于那些能够在同一业务单元中生产闪存和控制器的公司来说。更有趣的是，由于在晶圆级别测试芯片的高成本，添加一个管理坏块的微控制器可能比彻底测试和表征每个原始闪存芯片的成本还要低。而事实上，尽管功能更多，管理型闪存设备的每位成本往往低于原始闪存芯片。
- en: Every flash implementation has unique algorithmic requirements, multiplying
    the number of hardware abstraction layers a microcontroller must handle. This
    complexity inevitably leads to bugs, meaning indelibly burning a static body of
    code into on-chip ROM just isn’t feasible, particularly for third-party controllers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每种闪存实现都有独特的算法要求，这增加了微控制器必须处理的硬件抽象层的数量。这种复杂性不可避免地会导致漏洞，这意味着将静态代码烧录到片上ROM中并不可行，特别是对于第三方控制器而言。
- en: Thus, a firmware loading and update mechanism is virtually mandatory. End users
    are rarely exposed to this process since it all happens in the factory, but the
    mechanism exists. While exploring the electronics markets in China, I’ve seen
    shopkeepers burn firmware onto a card that “expands” the card’s capacity. In other
    words, they load firmware that reports the capacity of a card as much larger than
    the actual available storage. The fact that this is possible at the point of sale
    indicates the update mechanism is likely not well secured.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，固件加载和更新机制几乎是必须的。最终用户很少接触到这个过程，因为它通常发生在工厂里，但这个机制是存在的。在中国电子市场上，我曾看到店主将固件烧录到卡片上，以“扩展”卡片的容量。换句话说，他们加载的固件报告的卡片容量要远大于实际可用存储。这种在销售时就能做到的事实表明，更新机制可能并没有得到很好的安全保障。
- en: '**Reverse Engineering the Card’s Microcontroller**'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**反向工程卡片的微控制器**'
- en: xobs and I discovered an example of this vulnerability while exploring memory
    cards using AppoTech’s AX211 and AX215 microcontrollers. We discovered a simple
    “knock” sequence transmitted over manufacturer-reserved commands (a command named
    `CMD63` followed by the bytes `A`, `P`, `P`, `O`) that dropped the controller
    into a firmware loading mode. After receiving the knock sequence, the card accepted
    the next 512 bytes and ran the data as code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我和xobs在使用AppoTech的AX211和AX215微控制器探索内存卡时，发现了这个漏洞的一个例子。我们发现了一个简单的“敲击”序列，它通过制造商保留的命令（一个名为`CMD63`的命令，后面跟着字节`A`、`P`、`P`、`O`）将控制器置于固件加载模式。收到敲击序列后，卡片接受接下来的512字节，并将数据作为代码执行。
- en: '**NOTE**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The AppoTech chips I describe here technically integrate sufficient functionality
    that in an academic sense, they’re not mere microcontrollers; they’re full SoCs.
    But it’s just* weird *to me to refer to the AppoTech as an SoC, so I won’t. It
    will always be a microcontroller to me!*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在这里描述的AppoTech芯片技术上集成了足够的功能，从学术角度来看，它们不仅仅是微控制器；它们是完整的SoC。但对我来说，称AppoTech为SoC有点*奇怪*，所以我不会这么称呼它。对我而言，它永远是一个微控制器！*'
- en: The AppoTech system on this particular memory card also used an 8051 microcontroller.
    From the knock sequence beachhead, we used a combination of analyzing code with
    IDA, the interactive disassembler, and *fuzzing* (that is, giving the microcontroller
    invalid or random input to see how it responds) to reverse engineer most of the
    8051’s function-specific registers. That allowed us to develop novel applications
    for the controller without the manufacturer’s proprietary documentation. We did
    most of this work with the Novena laptop hardware I described in [Chapter 7](ch07.xhtml#ch07).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定内存卡上的AppoTech系统也使用了8051微控制器。通过“敲击序列”突击，我们使用了分析代码的工具IDA（交互式反汇编器）和*模糊测试*（即给微控制器输入无效或随机数据，看看它如何响应）相结合的方法，反向工程了8051的大部分功能特定寄存器。这使我们能够在没有制造商专有文档的情况下为控制器开发新型应用。我们大部分工作是使用我在[第7章](ch07.xhtml#ch07)中描述的Novena笔记本硬件完成的。
- en: As I alluded at the beginning of this chapter, we developed several bespoke
    tools to help us reverse engineer the SD card. One of the more interesting tools
    we (and by we, I mean primarily xobs) made is an interactive REPL (read-evaluate-print-loop)
    shell for executing arbitrary code on the SD card. The following listing shows
    what that environment looks like.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开头提到的，我们开发了几个定制工具来帮助我们逆向工程 SD 卡。我们（严格来说是主要由 xobs）制作的一个更有趣的工具是一个交互式 REPL（读取-评估-打印-循环）外壳，用于在
    SD 卡上执行任意代码。以下列出了该环境的外观。
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From inside this environment, we could run programs in a debugger, get a list
    of available commands and what they did by entering `help`, and disassemble sections
    of code by entering `disasm`. Although it took a lot of time to develop an interactive
    tool with such a rich feature set, the effort quickly paid off because we could
    test complex hypotheses using automated fuzzing frameworks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个环境中，我们可以在调试器中运行程序，通过输入 `help` 获取可用命令及其功能列表，输入 `disasm` 反汇编代码段。虽然开发这样一个功能丰富的交互工具花费了大量时间，但这个努力很快得到了回报，因为我们能够使用自动化模糊测试框架测试复杂的假设。
- en: The code upload size was limited to 512 bytes, which meant we had to partition
    the REPL environment between the host Novena computer and the target device.[*](footnote.xhtml#fn26)
    For example, disassembling a particular region of memory breaks down to a script
    executed on the host side that drives issue requests to the AX211 to dump the
    requested portion of memory, followed by the disassembly algorithm running on
    the host ARM CPU.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码上传的大小限制为 512 字节，这意味着我们必须在主机 Novena 计算机和目标设备之间划分 REPL 环境。[*](footnote.xhtml#fn26)
    例如，反汇编某个特定内存区域的操作会分解为在主机端执行的脚本，脚本向 AX211 发出请求，以转储请求的内存部分，接着在主机 ARM CPU 上运行反汇编算法。
- en: '![image](../images/f0295-01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0295-01.jpg)'
- en: '*Partitioning the SD debugger functions between the host and the target*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*将 SD 调试功能在主机和目标之间进行分配*'
- en: The tool we built started with an SD physical emulation layer, which I’ll refer
    to as *PHY*. We used the FPGA built into the Novena to present a GPIO-like register
    API for the SD host PHY. There was one register for data output, one register
    for data input, and one register to bitwise set the data direction. The AX211
    card was attached to the FPGA via a custom flex-circuit adapter.[*](footnote.xhtml#fn27)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的工具从 SD 物理仿真层开始，我将其称为 *PHY*。我们使用 Novena 中内置的 FPGA 为 SD 主机 PHY 提供类似 GPIO
    的寄存器 API。这里有一个寄存器用于数据输出，一个寄存器用于数据输入，还有一个寄存器用于按位设置数据方向。AX211 卡通过定制的柔性电路适配器连接到 FPGA。[*](footnote.xhtml#fn27)
- en: '![image](../images/f0296-01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0296-01.jpg)'
- en: '*A flex-circuit adapter plugged into a Novena*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接到 Novena 的柔性电路适配器*'
- en: The SD commands were received on the AX211 and processed by a hardware state
    machine attached to the embedded 8051 CPU. The state machine handled receiving
    the data, plus it computed and checked the cyclic redundancy code for error detection.
    Once a complete packet was received by the state machine, an interrupt notified
    the 8051 of the packet’s arrival.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: SD 命令通过 AX211 接收，并由连接到嵌入式 8051 CPU 的硬件状态机处理。状态机负责接收数据，并计算和检查循环冗余码以进行错误检测。一旦状态机接收到完整的数据包，它会通过中断通知
    8051 数据包的到达。
- en: We hijacked the interrupt processing mechanism and remapped the default handler
    to our own 512-byte code stub. That allowed us to define a novel set of SD commands
    that we used to implement the callback functions our REPL environment needed,
    like `peek`, `poke`, `jump`, NAND register manipulation, and so on. These callbacks
    were also an ideal hook for implementing an MITM attack.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们劫持了中断处理机制，并将默认处理程序重新映射到我们自己的 512 字节代码存根。这样，我们就能够定义一组新颖的 SD 命令，用于实现 REPL 环境所需的回调函数，例如
    `peek`、`poke`、`jump`、NAND 寄存器操作等。这些回调也为实施 MITM 攻击提供了理想的挂钩。
- en: '![image](../images/f0297-01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0297-01.jpg)'
- en: '*The callback functions for the REPL, displayed in IDA*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*REPL 的回调函数，显示在 IDA 中*'
- en: I don’t know how many other manufacturers leave their firmware updating sequences
    unsecured. AppoTech is a relatively minor player in the SD controller world; a
    handful of companies that you’ve probably never heard of also produce SD controllers,
    including Alcor Micro, Skymedi, Phison, and SMI. Of course, there are also SanDisk
    and Samsung. Each has different mechanisms and methods for loading and updating
    firmware. But I know of at least one Samsung eMMC implementation using an ARM
    instruction set that had a bug requiring a firmware updater to be pushed to Android
    devices, indicating yet another potentially promising venue for further discovery.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我不清楚还有多少其他厂商没有保护他们的固件更新过程。AppoTech是SD控制器行业中的一个相对较小的玩家；还有一些你可能从未听说过的公司也生产SD控制器，包括Alcor
    Micro、Skymedi、Phison和SMI。当然，还有SanDisk和Samsung。每家公司都有不同的固件加载和更新机制。但我知道至少有一个使用ARM指令集的三星eMMC实现存在一个bug，需要通过固件更新器推送到Android设备上，这也暗示着另一个可能的、有前景的探索方向。
- en: '**Potential Security Issues**'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**潜在的安全问题**'
- en: From a security perspective, our findings indicated that while memory cards
    look inert, they run code that could be modified to perform MITM attacks that
    are difficult to detect. There’s no standard protocol or method to inspect and
    attest to the contents of the code running on the memory card’s microcontroller.
    If you’re using an SD card in a high-risk, high-sensitivity situation, don’t assume
    that running a `security-erase` command (or some other secure erase tool) on a
    card will guarantee the complete erasure of sensitive data. If you really need
    data to disappear, I recommend disposing of your memory card through total physical
    destruction. Grind it up with a mortar and pestle if you have to.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，我们的研究表明，虽然存储卡看似无害，但它们运行的代码可以被修改，用来执行难以检测的中间人攻击（MITM）。目前没有标准协议或方法来检查和验证存储卡微控制器上运行的代码内容。如果你在高风险、高敏感度的环境下使用SD卡，不要认为运行`security-erase`命令（或其他某些安全擦除工具）就能确保完全擦除敏感数据。如果你真的需要让数据彻底消失，我建议通过完全物理销毁来处理你的存储卡。如果有需要，可以用研钵和杵把它碾碎。
- en: '**A Resource for Hobbyists**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**爱好者的资源**'
- en: From a DIY and hacker perspective, our findings suggested a potentially interesting
    source of cheap and powerful microcontrollers for use in simple projects. An Arduino
    clone—with an 8-bit, 16 MHz microcontroller—will set you back around $20\. A microSD
    card with several gigabytes of memory and a microcontroller with several times
    the performance costs a fraction of the price. While SD cards are admittedly I/O-limited,
    some clever hacking of the microcontroller in an SD card could make for a very
    economical and compact data logging solution for I2C or SPI-based sensors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从DIY和黑客的角度来看，我们的研究表明，存储卡可能是一个有趣的来源，可以为简单项目提供便宜而强大的微控制器。一个8位、16 MHz的Arduino克隆板大约需要花费$20。而一张带有几GB内存的microSD卡和性能是其几倍的微控制器则只需花费极小的价格。尽管SD卡的输入输出性能的确有限，但通过巧妙地破解SD卡上的微控制器，可能会为基于I2C或SPI的传感器提供一个非常经济且紧凑的数据记录解决方案。
- en: '**HACKING HDCP-SECURED LINKS TO ALLOW CUSTOM OVERLAYS**'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**破解HDCP保护的链接以允许自定义叠加层**'
- en: “That’s neat, but is it legal?” is a frequently asked question I get when hacking.
    Just as engineered systems have hacks, legal systems have loopholes. Some legal
    loopholes exist by design; others are unintentional. Either way, they can provide
    vital breathing room for innovation. When contemplating a hack, I consider legal
    issues as I do engineering constraints, similar to having to fit something within
    a case of a certain height or run for a certain length of time on a given battery.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: “那很酷，但这合法吗？”这是我在破解时经常被问到的问题。就像工程系统有破解一样，法律系统也有漏洞。有些法律漏洞是设计使然；而有些则是无意中产生的。无论是哪种情况，它们都能为创新提供重要的喘息空间。在考虑破解时，我会像考虑工程限制一样考虑法律问题，这就像必须将某个东西装入特定高度的机箱，或者让它在给定的电池上运行特定时间。
- en: 'Around 2011, when I was still at Chumby, we were puzzling about how to drive
    adoption in the face of the iPhone and Android phones consuming the market niche
    we hoped to occupy. Cost was an eternal barrier for user adoption, and the integral
    LCD in a chumby was by far the highest-cost item. Our then-CEO, Steve Tomlin,
    observed that the biggest screen in the house had yet to become connected to the
    internet in any meaningful way. And so this question was posed to me: could we
    find a way to kill two birds with one stone, removing the screen from our bill
    of materials while bringing TVs into the internet age? This was before products
    like the Google Chromecast or the Logitech Revue were introduced on the market.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2011年，当我还在Chumby时，我们在思考如何应对iPhone和安卓手机占领我们希望进入的市场细分。成本是用户接受的永恒障碍，而Chumby中集成的LCD屏幕无疑是最昂贵的部分。我们当时的首席执行官Steve
    Tomlin指出，家里最大的屏幕仍然没有以任何有意义的方式连接到互联网。于是，这个问题被抛给了我：我们能否找到一种方法，一举两得，既去掉屏幕这一部件，同时把电视带入互联网时代？那时像Google
    Chromecast和Logitech Revue这样的产品还未问世。
- en: It occurred to us that we could pack a cheap computer into a stick that plugs
    into an HDMI port. This solves the problem of getting chumby onto a TV screen,
    but then you’re not watching your favorite movies or TV shows when the chumby
    is selected. We figured what people really wanted was some way to watch TV and
    have, say, Twitter or Facebook notifications pop up onscreen, too.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想到，或许可以把一台便宜的计算机装进一个可以插入HDMI端口的棒子里。这样就解决了将Chumby显示到电视屏幕上的问题，但当选择Chumby时，你就不能看你最喜欢的电影或电视节目了。我们认为人们真正想要的是某种方式，既能看电视，又能在屏幕上弹出比如Twitter或Facebook的通知。
- en: The concept is simple enough. Take the existing output from a cable box, Blu-ray
    player, or AV receiver; feed it into a box that blends in chumby content; and
    pass the resulting video on to a TV. But due to the ubiquitous application of
    HDCP encryption over digital video feeds, it is legally perilous to remix content
    if you do it the wrong way. Figuring out the right way to do it is how NeTV was
    born.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念非常简单。获取来自机顶盒、蓝光播放器或AV接收器的现有输出，传入一个将Chumby内容与视频信号融合的盒子，然后将合成后的信号传送到电视上。但由于HDCP加密技术在数字视频信号中的广泛应用，如果你采用错误的方法混合内容，从法律上讲是非常危险的。找到正确的方法就是NeTV诞生的原因。
- en: '![image](../images/f0300-01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0300-01.jpg)'
- en: '*A NeTV sporting the Chumby logo*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*带有Chumby标志的NeTV*'
- en: '![image](../images/f0300-02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0300-02.jpg)'
- en: '*Inside the NeTV*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*NeTV内部*'
- en: '**Background and Context**'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**背景与 context**'
- en: NeTV was my response to the challenge of remixing existing video with internet
    content while staying within legal boundaries, aided by the public release of
    the master key to HDCP in September 2010\. To help you understand this hack, let’s
    start with a little background on HDCP.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: NeTV是我对如何在法律框架内将现有视频与互联网内容混合的回应，得益于2010年9月公开发布的HDCP主密钥。为了帮助你理解这个黑客行为，我们先从HDCP的背景开始讲起。
- en: High-bandwidth Digital Content Protection is a pixel-level encryption system
    used to encrypt video transmissions over HDMI. HDCP puts broadcasters and studios
    in control of the screens their content plays on, as those companies use the encryption
    as a copyright control mechanism. HDCP restricts legitimate content manipulation
    like picture-in-picture displays, content overlays, and third-party filtering
    and image modification. Combine HDCP with the DMCA, which criminalizes the circumvention
    of copyright control, and you’ll realize that when watching certain videos, it’s
    illegal to modify content on your own screen. That’s why there are few HDMI video
    mixing solutions that actually operate on broadcast or movie content.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 高带宽数字内容保护（HDCP）是一种用于加密通过HDMI传输的视频信号的像素级加密系统。HDCP让广播公司和电影公司掌控其内容播放的屏幕，因为这些公司利用加密作为版权控制机制。HDCP限制了合法的视频内容操作，比如画中画显示、内容叠加、第三方过滤和图像修改。将HDCP与数字千年版权法案（DMCA）结合起来后，你会意识到，在观看某些视频时，擅自修改屏幕上的内容是非法的。这也是为什么实际上没有多少HDMI视频混合解决方案能够操作广播或电影内容。
- en: 'To recap, I had four goals for NeTV: enable consumer-side content remixing,
    allow users to eliminate ads or replace them with ads relevant to themselves,
    create an interactive TV experience, and make something compatible with any TV.
    To accomplish those goals, I designed NeTV as a man in the middle to take data
    from, say, a Blu-ray player, and apply the master key to give users a custom overlay.
    There are many applications for video overlays, but the basic scenario is that
    while you’re enjoying content X, you’d also like to be aware of content Y. Combining
    the two content sources requires a video overlay mechanism.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我为NeTV设定了四个目标：使消费者能够进行内容重混，允许用户消除广告或将其替换为与自己相关的广告，创建互动电视体验，并使其与任何电视兼容。为了实现这些目标，我将NeTV设计为中间人，从例如Blu-ray播放器获取数据，并应用主密钥以提供自定义叠加效果。视频叠加有许多应用场景，但基本的场景是，当你在享受内容X时，你还希望能够了解内容Y。将这两个内容源结合起来需要一个视频叠加机制。
- en: With my MITM attack, NeTV overlaid a WebKit browser (the engine Safari and Chrome
    use) over any video feed. A concrete use case for this technology is overlaying
    Twitter feeds as news crawlers across a TV show to watch community commentary
    in real time on the same screen you’re watching the show on. Some TV programs
    attempt to incorporate Twitter feeds already, but they’ve only done so on the
    source side; users can only watch hashtags the show displays. With this hack,
    however, the same broadcast program (say, a political debate) could have a very
    different viewing experience based on which hashtag is keyed into the viewer’s
    Twitter crawler.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我的MITM攻击，NeTV在任何视频流上叠加了一个WebKit浏览器（Safari和Chrome使用的引擎）。这个技术的具体应用案例是将Twitter动态作为新闻滚动条覆盖在电视节目上，实时观看社区评论，并且是在你观看节目的同一屏幕上。有些电视节目已经尝试将Twitter动态结合进来，但他们仅在源端做了这些；用户只能观看节目显示的标签。然而，通过这个黑客技术，相同的广播节目（例如一场政治辩论）就能根据观众Twitter爬虫中输入的标签，提供截然不同的观看体验。
- en: The simple fact that a trivial video overlay is an interesting topic illustrates
    the distortion of traditional rights and freedoms brought about by the DMCA. Unlike
    the HDCP strippers people speculated would come out of the master key’s release,
    however, my hack never decrypted the original video data it operated on. Thus,
    it didn’t circumvent copyright, and the DMCA couldn’t apply to it. Loophole found!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的事实是，简单的视频叠加是一个有趣的话题，这说明了DMCA所带来的对传统权利和自由的扭曲。然而，与人们猜测主密钥发布后可能出现的HDCP去除器不同，我的黑客行为从未解密它操作的原始视频数据。因此，它没有绕过版权，DMCA无法适用。漏洞找到了！
- en: '**How NeTV Worked**'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**NeTV的工作原理**'
- en: 'Of course, I released the exploit as an entirely open source project,[*](footnote.xhtml#fn28)
    including the hardware and the Verilog implementation of the Spartan-6 FPGA I
    used to create the TMDS-compatible source and sink. TMDS is the signaling standard
    used by HDMI and DVI. The basic pipeline within the FPGA deserializes incoming
    video and reserializes it to the output. In this trivial mode, NeTV is simply
    a signal amplifier for the video: encrypted pixels in, encrypted pixels out—no
    decryption and no video manipulation.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我将该漏洞作为一个完全开源的项目发布，[*](footnote.xhtml#fn28)，包括硬件以及我用来创建TMDS兼容源和接收器的Spartan-6
    FPGA的Verilog实现。TMDS是HDMI和DVI使用的信号标准。FPGA内部的基本流水线将输入的视频进行反序列化，然后再序列化到输出端。在这个简单模式下，NeTV仅仅是视频的信号放大器：加密的像素输入，加密的像素输出——没有解密，也没有视频处理。
- en: NeTV could mix a user-generated content stream over an encrypted video feed
    because HDCP encrypts without validation. In other words, if a man in the middle
    tampers with the encrypted feed, the receiver simply accepts the tampered pixels
    as valid data, decrypts them, and presents them to the user. The lack of link
    verification is intentional and necessary. The natural bit error rate of HD video
    links is atrocious, but the human eye won’t detect bit errors even on the level
    of 1 in every 10,000 bits. (At high error rates, users see a “sparkle” or “snow”
    on the screen, but the image is largely intact.) Allowing some pixel-level corruption
    keeps consumer costs low. Otherwise, much higher-quality cables would be required
    along with FEC techniques to achieve a bit error rate compatible with strict cryptographic
    verification techniques like full-frame hashing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: NeTV 可以将用户生成的内容流与加密视频流混合，因为 HDCP 加密时不进行验证。换句话说，如果中间人篡改了加密流，接收器会直接接受篡改后的像素作为有效数据，解密后并将其呈现给用户。缺乏链路验证是有意为之，也是必要的。HD
    视频链接的自然比特错误率非常高，但人眼即便在每 10,000 个比特中有 1 个错误时，也无法察觉（在高错误率下，用户会在屏幕上看到“闪烁”或“雪花”效果，但图像基本完好）。允许一些像素级的损坏能保持消费者成本低廉，否则将需要更高质量的电缆并采用
    FEC 技术，才能实现与严格的加密验证技术（如全帧哈希）兼容的比特错误率。
- en: Thus, NeTV’s prime challenge is to derive a keystream identical and synchronized
    to the transmitter’s keystream, encrypt the user-generated content with this keystream,
    and selectively swap the transmitter’s pixels on the fly for user-encrypted pixels.
    If everything lines up, the receiver will decrypt an image that appears to be
    a perfect overlay of user-generated content on top of the original video feed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，NeTV 的主要挑战是生成与发射器密钥流相同并同步的密钥流，使用该密钥流加密用户生成的内容，并在飞行过程中选择性地将发射器的像素交换为用户加密的像素。如果一切对齐，接收器将解密出看似完美的图像，即用户生成的内容叠加在原始视频流之上。
- en: '![image](../images/f0303-01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0303-01.jpg)'
- en: '*A high-level conceptual diagram of how NeTV worked*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*NeTV 工作原理的高级概念图*'
- en: CREATING THE OVERLAY
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建覆盖层
- en: To generate the user overlay content, we connected a tiny embedded Linux computer
    to an FPGA. From the Linux computer’s standpoint, the FPGA emulates a parallel
    RGB LCD that you can access by using the frame buffer at */dev/fb0* (the filepath
    for the first frame buffer in Linux). The Linux computer would automatically launch
    a WebKit browser full-screen at boot, thus filling */dev/fb0* with the user’s
    content.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成用户覆盖内容，我们将一台小型嵌入式 Linux 计算机连接到 FPGA。从 Linux 计算机的角度来看，FPGA 模拟了一个并行 RGB LCD，可以通过使用帧缓冲区
    */dev/fb0*（Linux 中第一个帧缓冲区的文件路径）来访问。Linux 计算机将在启动时自动启动一个全屏的 WebKit 浏览器，从而将 */dev/fb0*
    填充为用户的内容。
- en: The system selected which pixel to swap by observing the color of the WebKit
    overlay’s video, a trick known as *chroma keying*. The overlay video wasn’t encrypted
    and was generated by the user, so looking at the color of the overlay video was
    perfectly legal. Other more expressive and aesthetically appealing pixel-combining
    methods like alpha blending, however, would have required decrypting the original
    video, which would have been illegal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 系统通过观察 WebKit 覆盖层视频的颜色来选择交换哪个像素，这个技巧被称为 *色键技术*。覆盖层视频没有被加密，并且是用户生成的，因此查看覆盖层视频的颜色是完全合法的。然而，其他更具表现力且在美学上更具吸引力的像素合成方法（如
    alpha 混合）则需要解密原始视频，这将是非法的。
- en: If the overlay video matched a certain chroma key color (in this case, a specific
    shade of bright pink), the incoming video was displayed; otherwise, the overlay
    video was displayed. Following this system, users could create transparent “holes”
    in the custom UI to show the original video underneath. Since the UI was rendered
    by a WebKit browser, users could implement chroma keying by simply setting the
    background color in the CSS of the UI pages to that magic shade of pink. With
    those settings, the default state of a web page would be transparent, and all
    items rendered on top of it were opaque, so long as the UI elements avoided the
    chroma key color and turned off enhancements like anti-aliasing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果覆盖层视频匹配某个特定的色键颜色（在这种情况下，是特定的亮粉色），则显示传入的视频；否则，显示覆盖层视频。按照这一系统，用户可以在自定义 UI 中创建透明的“孔”，以展示底下的原始视频。由于
    UI 是通过 WebKit 浏览器渲染的，用户可以通过简单地在 UI 页面 CSS 中设置背景色为那种魔法粉色来实现色键效果。使用这些设置后，网页的默认状态将是透明的，所有渲染在其上的项都是不透明的，只要
    UI 元素避免使用色键颜色并关闭像抗锯齿这样的增强效果。
- en: CRAFTING A KEYSTREAM
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建密钥流
- en: Of course, the chroma keying happened in the encrypted domain. Thus, the FPGA’s
    second job was to snoop the HDMI link and craft a keystream identical to the transmitter’s.
    First, the FPGA observed an I2C link found on HDMI known as the *data display
    channel* (DDC). The DDC enables monitors to report their capability records (called
    *extended display identification data,* or EDID) and is also where the encryption
    keys are exchanged.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，色度键控发生在加密域中。因此，FPGA的第二项任务是窃听HDMI连接，并制作一个与发射器完全相同的密钥流。首先，FPGA观察了HDMI上的I2C连接，该连接被称为*数据显示通道*（DDC）。DDC使得显示器能够报告其能力记录（称为*扩展显示识别数据*，或EDID），并且也是加密密钥交换的地方。
- en: By observing the key exchange handshake between the transmitter and the receiver,
    NeTV could mathematically extract the transmitter’s and receiver’s private keys
    with the help of the HDCP master key. Once the private-key vectors were derived,
    they could be multiplied exactly as they’d be in the source or sink to derive
    the shared secret, called Km. When that shared secret was written into the FPGA’s
    HDCP engine, the cipher state was ready to go, allowing NeTV to encrypt overlays
    on the video transmitted between the video source and the video display device.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察发射器和接收器之间的密钥交换握手，NeTV可以借助HDCP主密钥数学地提取发射器和接收器的私钥。一旦私钥向量被推导出来，它们可以像源或接收端一样被相乘，以推导出共享的秘密，称为Km。当共享的秘密写入FPGA的HDCP引擎时，密码状态就绪，从而使NeTV能够加密视频源和视频显示设备之间传输的视频叠加层。
- en: 'By considering legal constraints as just another engineering constraint, I
    was able to create a completely new device that proves a point: it’s incorrect
    to automatically equate hacks that work around a DRM system with attempts to circumvent
    copyright. NeTV never decrypts previously encrypted video and can’t operate without
    an existing, valid HDCP link, making it a bona fide, non-infringing, commercially
    useful application of the HDCP master key.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将法律约束视为另一种工程约束，我能够创造出一种全新的设备，这证明了一个观点：自动将绕过DRM系统的黑客行为与规避版权的尝试等同起来是错误的。NeTV从不解密之前加密的视频，并且在没有有效的HDCP连接的情况下无法操作，这使其成为HDCP主密钥的真正合法且商业上有用的应用。
- en: '![image](../images/f0305-01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0305-01.jpg)'
- en: '*A more detailed block diagram showing how NeTV’s FPGA worked*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*更详细的框图展示了NeTV的FPGA如何工作*'
- en: So far in this chapter, we’ve seen examples of different hardware hacking approaches
    and techniques, from physical penetration to system-level tool building and analysis
    to treating legal constraints as engineering problems. In “[Who Are the Shanzhai?](ch04.xhtml#ch00lev1sec73)”
    on [page 122](ch04.xhtml#page_122), I discussed the legal approach of a project,
    codenamed Fernvale, to reverse engineer a mobile phone chipset. In addition to
    thinking about law as engineers, xobs and I had to pull out all the stops and
    apply every technical skill at our disposal to reverse engineer such a complex
    system. The rest of this chapter dives into some of these techniques.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到了不同硬件黑客方法和技巧的示例，从物理渗透到系统级工具构建与分析，再到将法律约束视为工程问题。在“[谁是山寨？](ch04.xhtml#ch00lev1sec73)”一节中，位于[第122页](ch04.xhtml#page_122)，我讨论了一个名为Fernvale的项目如何采用法律手段逆向工程一个手机芯片。在将法律视为工程问题的同时，我和xobs不得不竭尽全力，运用我们掌握的所有技术手段来逆向工程如此复杂的系统。本章的其余部分深入探讨了其中一些技术。
- en: '**HACKING A SHANZHAI PHONE**'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**破解山寨手机**'
- en: When xobs and I worked on Fernvale, our goal was to make a new platform derived
    from the hardware in my $12 gongkai phone and repatriate technical information
    into the open source IP system. We had no documentation whatsoever for some parts
    of the chip we wanted to reverse, but that didn’t deter us. We navigated complex
    legal waters and created our own custom scripting language to program the chip’s
    firmware to avoid subconscious plagiarism.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我和xobs在Fernvale项目中工作时，我们的目标是从我那台$12的公开手机硬件中衍生出一个新平台，并将技术信息重新引入开源IP系统。我们对一些芯片的部分内容没有任何文档，但这并没有阻止我们。我们航行在复杂的法律水域中，并创造了自己的自定义脚本语言，以编程芯片的固件，避免无意识的剽窃。
- en: Compared to the firmware, though, the hardware reverse-engineering task was
    fairly straightforward. The documents we scavenged gave us a notion of the chip’s
    pinout, and the pin naming scheme was sufficiently descriptive that I could apply
    common sense and experience to guess how to connect the chip. For ambiguous areas,
    I buzzed out some stripped-down phones with a multimeter or stared at them under
    a microscope to determine connectivity. In the worst cases, I’d probe a live phone
    with an oscilloscope to make sure I understood the connections correctly. The
    more difficult question was how to architect the hardware.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与固件相比，硬件的逆向工程任务相对简单。我们搜集到的文档给了我们芯片引脚布局的概念，且引脚命名方案足够清晰，以至于我可以凭借常识和经验猜测如何连接这些引脚。对于不明确的部分，我使用万用表测试了一些拆解的手机，或者通过显微镜观察它们以确定连接情况。在最糟糕的情况下，我会用示波器探测一个工作中的手机，以确保我正确理解了连接方式。更难的问题是如何设计硬件架构。
- en: '**The System Architecture**'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**系统架构**'
- en: We weren’t gunning to build a phone, but rather something closer to Particle’s
    Spark Core (since reborn as the Photon), a generic System-on-Module type of single-board
    computer built for Internet of Things applications. In fact, our original renderings
    and pinouts were designed to be compatible with the Spark ecosystem of hardware
    extensions, until we realized the gongkai phone’s MT6260 microcontroller just
    had too many interesting peripherals to fit into such a small footprint.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是要制造一部手机，而是做一个更接近Particle的Spark Core（现在的Photon）的产品，即一个为物联网应用设计的通用系统模块型单板计算机。事实上，我们最初的设计和引脚布局是为了兼容Spark硬件扩展生态系统的，直到我们意识到公开手机的MT6260微控制器有太多有趣的外设，无法在这么小的体积中容纳下。
- en: '![image](../images/f0307-01.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0307-01.jpg)'
- en: '*Early sketches of the Fernvale PCB*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fernvale PCB的早期草图*'
- en: We settled eventually on a single-sided core PCB that we called the Fernvale
    Frond, which embedded the microUSB, microSD, battery, camera, speaker, and Bluetooth
    functionality (as well as the obligatory buttons and LED) on one board. The Frond
    turned out slim and small, at 3.5 mm thick, 57 mm long, and 35 mm wide. We included
    holes to mount a partial set of pin headers, spaced for Arduino compatibility,
    although the board could only be plugged into 3.3 V–compatible Arduino devices.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们选择了一个单面核心PCB，称之为Fernvale Frond，嵌入了microUSB、microSD、电池、相机、扬声器和蓝牙功能（以及必备的按钮和LED）在一块板上。Frond设计得既薄又小，厚度为3.5毫米，长度为57毫米，宽度为35毫米。我们在板上设置了安装部分引脚头的孔位，孔距适配Arduino，尽管这块板只能插入3.3V兼容的Arduino设备。
- en: '![image](../images/f0308-01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0308-01.jpg)'
- en: '*The actual implementation of the Fernvale Frond, pictured with an Arduino
    Uno for size reference*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fernvale Frond的实际实现，图中搭配Arduino Uno以便对比尺寸*'
- en: 'We broke the remaining peripherals out to a pair of connectors: one dedicated
    to GSM-related signals (GSM is the protocol for 2G cell phone networks) and the
    other to UI-related peripherals. We called the GSM board the Fernvale Spore and
    the UI board the Fernvale Blade. We split GSM into a module with many choices
    for the RF frontend to make GSM a bona fide user-installed feature, thus pushing
    the regulatory and emissions issue down to the user level. Splitting the UI-related
    features out to another board also reduced the cost of the core module and let
    users try the Frond in numerous scenarios without being locked into a particular
    LCD or button arrangement.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将剩余的外设分开到一对连接器中：一个专门用于GSM相关信号（GSM是2G手机网络的协议），另一个用于UI相关外设。我们把GSM板称为Fernvale
    Spore，UI板称为Fernvale Blade。我们将GSM拆分成一个模块，提供多种RF前端选择，使GSM成为一个真正由用户安装的功能，从而将监管和排放问题推到用户层面。将UI相关功能拆分到另一个板卡也降低了核心模块的成本，让用户在多种场景下尝试Frond，而不必被限制在特定的LCD或按钮布局中。
- en: '![image](../images/f0309-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0309-01.jpg)'
- en: '*A Fernvale system diagram, showing the features of each of the three boards*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*一张Fernvale系统图，展示了三个板卡的各自特点*'
- en: '**Inside the MT6260**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**MT6260内部结构**'
- en: I had some X-rays taken of the MT6260 to help us identify fake components. We
    had to source our MT6260s on the gray market, and we wanted to guard against being
    sold empty epoxy blocks or remarked versions of other chips. The MT6260 has -DA
    and -A variants, where the difference is how much on-chip flash memory is included.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我让人对MT6260进行了X射线检查，帮助我们识别假冒组件。我们不得不从灰色市场采购MT6260，并且我们希望防止买到空的环氧树脂块或者其他芯片的伪造版本。MT6260有-DA和-A两种变种，区别在于芯片内嵌的闪存大小。
- en: '![image](../images/f0310-01.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0310-01.jpg)'
- en: '*An X-ray of the MT6260 chip.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*MT6260芯片的X光图像。'
- en: Look carefully to spot outlines of multiple ICs among the wire bonds.*
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，可以发现多个集成电路（IC）在引线焊接之间的轮廓。*
- en: To our surprise, this $3 chip didn’t contain a single IC, but rather a set of
    at least four (possibly five) chips integrated into a single multichip module
    (MCM) containing hundreds of wire bonds. I remember back when the Pentium Pro’s
    dual-die package came out in the late 1990s. It sparked arguments over yield costs
    of MCMs versus using a single big die; generally, MCMs were considered exotic
    and expensive.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 令我们吃惊的是，这款3美元的芯片并不包含单个集成电路（IC），而是将至少四个（可能五个）芯片集成在一个包含数百根引线焊接的多芯片模块（MCM）中。我记得1990年代末，Pentium
    Pro的双芯片封装问世时，曾引发关于MCM产量成本与使用单一大芯片的争论；通常认为，MCM是异国情调且昂贵的。
- en: I also remember at the same time Krste Asanović, then a professor at the MIT
    Artificial Intelligence Lab and later at UC Berkeley, told me that the future
    of electronics wasn’t system-on-a-chip devices, but rather “system-mostly-on-a-chip”
    devices. The root of his claim was that the economics of adding in mask layers
    to merge DRAM, flash, analog, RF, and digital into a single process wasn’t favorable;
    bonding multiple dies together into a single package was cheaper and easier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我还记得在那个时候，Krste Asanović——当时是麻省理工学院人工智能实验室的教授，后来在加利福尼亚大学伯克利分校任教——曾告诉我，电子产品的未来并不是单芯片系统（System-on-a-chip）设备，而是“以芯片为主的系统”（system-mostly-on-a-chip）设备。他主张这一观点的根本原因是，将DRAM、闪存、模拟、射频和数字功能集成到单一工艺中，增加掩膜层的经济性并不理想；将多个芯片合并成单一封装既更便宜又更容易。
- en: It’s still a race between the cost impact (in terms of both the per-unit cost
    and nonrecurring engineering costs) of adding more process steps in the semiconductor
    fab, and the yield impact, relative reworkability, and lower nonrecurring engineering
    cost of assembling modules. Single-chip, System-on-Chip devices were the zeitgeist
    when Krste made that observation and they still kind of are, so it was interesting
    to see a significant data point validating his insight.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一场关于半导体厂商在制造过程中添加更多步骤所带来的成本影响（包括单件成本和非重复工程成本）与组装模块的产量影响、相对可重工性以及更低的非重复工程成本之间的竞赛。在Krste提出这一观察时，单芯片系统（System-on-Chip）设备是时代的产物，而且它们至今仍然是，所以看到一个重要的数据点验证了他的洞察力，确实很有意思。
- en: Understanding the internal structure of the chip was also helpful in reverse
    engineering the system. Knowing that MediaTek was simply combining several chips
    together in a single package shed much-needed light on the purpose and organization
    of their APIs. It also tipped us off that certain elements of the system would
    be reused across several product categories and generations, so we knew we could
    draw meaningful conclusions from documentation on older or related chips. When
    you’re piecing together a puzzle this complex, every clue helps, including those
    gained by just looking at the physical structure of the chip.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 理解芯片的内部结构对于反向工程系统也非常有帮助。得知联发科仅仅是将多个芯片结合在一个封装中，给我们提供了关于其API的目的和组织结构的宝贵线索。它还提示我们，系统中的某些元素会在多个产品类别和代际间重复使用，因此我们知道可以从老旧或相关芯片的文档中得出有意义的结论。在拼凑这样复杂的难题时，每一条线索都很重要，包括仅仅通过观察芯片的物理结构得到的线索。
- en: '**Reverse Engineering the Boot Structure**'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**反向工程引导结构**'
- en: Shanzhai engineers in China seem to have access to just enough documentation
    to assemble a phone and customize its UI, but not enough to do a full OS port.
    After looking at enough phones, I eventually realized that all phones based on
    a particular chipset will have the same backdoor codes, and their GUIs are often
    inconsistent with the implemented hardware. For example, the $12 phone I tore
    down in [Chapter 4](ch04.xhtml#ch04) prompted me to plug headphones into the headphone
    jack for the FM radio to work, yet it has no headphone jack.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 中国的山寨工程师似乎仅仅能接触到足够的文档来组装手机并自定义其用户界面，但却没有足够的资料进行完整的操作系统移植。在拆解了足够多的手机后，我最终意识到，所有基于某一特定芯片组的手机都会有相同的后门代码，并且它们的图形用户界面（GUI）通常与实现的硬件不一致。例如，我在[第4章](ch04.xhtml#ch04)拆解的那款12美元的手机就让我不得不把耳机插入耳机插孔才能使用FM收音机，然而它根本没有耳机插孔。
- en: To make Fernvale accessible to engineers in the West through open source licensing,
    we had to reconstruct everything from scratch, including the toolchain, the firmware
    flashing tool, the OS, and the applications. But all the Chinese phone implementations
    simply relied on MediaTek’s proprietary toolchain, meaning we had to do some reverse
    engineering to figure out the boot process and firmware upload protocol.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过开源许可使Fernvale能被西方工程师访问，我们不得不从零开始重建所有内容，包括工具链、固件闪存工具、操作系统和应用程序。但所有中国的手机实现都仅依赖于联发科的专有工具链，这意味着我们不得不进行一些逆向工程，以弄清楚启动过程和固件上传协议。
- en: 'My first step in reversing a chip is always to dump the ROM, if possible. We
    found exactly one phone model with an external ROM that we could desolder (it
    used the -D ROMless variant of the chip), and we read its data using a conventional
    ROM reader. We saw very little ciphertext in the ROM, but there was a lot of compressed
    data. Here is a page from our notes after we did a static analysis on the ROM
    image:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我逆向工程芯片的第一步通常是尽可能地转储ROM。我们找到了一款具有外部ROM的手机型号，可以将其焊接下来（它使用的是-D无ROM版本的芯片），并通过传统的ROM读取器读取其数据。我们在ROM中几乎没有看到密文，但却有很多压缩数据。这是我们对ROM镜像进行静态分析后记录的一个页面：
- en: '[PRE1]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The hexadecimal numbers on the left are memory addresses, and the text on the
    right describes what xobs and I thought was stored at each address. One concern
    about reverse engineering an SoC is it has an internal boot ROM that always runs
    before code is loaded from an external device. That internal ROM can also have
    signature and security checks that prevent tampering with the external code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的十六进制数字是内存地址，右侧的文本描述了xobs和我认为存储在每个地址上的内容。逆向工程SoC时的一个问题是，它有一个在从外部设备加载代码之前始终运行的内部引导ROM。这个内部ROM还可能有签名和安全检查，防止篡改外部代码。
- en: To determine how hard reverse engineering this system would be, we wanted to
    quickly figure out how much code was running inside the CPU before jumping to
    external boot code. A Tek MDO4104B-6 oscilloscope let us accomplish that task
    in just a couple of hours.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速评估逆向工程这个系统的难度，我们想弄清楚在跳转到外部启动代码之前，CPU内部运行了多少代码。一台Tek MDO4104B-6示波器让我们在短短几个小时内完成了这一任务。
- en: '![image](../images/f0313-01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0313-01.jpg)'
- en: '*Screenshot from the Tek MDO4104B-6.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tek MDO4104B-6的截图。'
- en: The top quarter shows a zoomed-out view of the entire capture.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部四分之一显示了整个捕获的缩小视图。
- en: Notice how the SPI ROM accesses are punctuated with console output.*
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意SPI ROM访问时如何通过控制台输出进行标注。*
- en: This particular oscilloscope has the uncanny ability to perform post-capture
    analysis on deep, high-resolution analog traces and output the result as digital
    data. For example, we could simply probe around the chip with a multimeter while
    cycling power until we saw something that looked like an RS-232 encoded signal,
    and then run a post-capture analysis to extract any ASCII text that was coded
    in the analog traces. Likewise, if we captured SPI traces, the oscilloscope could
    extract ROM access patterns through a similar method. By looking at the timing
    of text emissions versus SPI ROM address patterns, we quickly determined that
    if the internal boot ROM did any verification, it was minimal and nothing approaching
    the computational complexity of RSA encryption.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这款特定的示波器具有一种神奇的能力，可以对深度、高分辨率的模拟波形进行后捕获分析，并将结果输出为数字数据。例如，我们可以在芯片周围用万用表探测，同时反复开关电源，直到看到类似RS-232编码信号的东西，然后进行后捕获分析，提取出任何在模拟波形中编码的ASCII文本。同样地，如果我们捕获了SPI波形，示波器也可以通过类似的方法提取ROM访问模式。通过观察文本输出的时序与SPI
    ROM地址模式之间的关系，我们迅速确定，如果内部引导ROM进行了任何验证，那也只是非常有限的，远未达到RSA加密的计算复杂度。
- en: From there, we needed to speed up our measure-modify-test loop. Desoldering
    the ROM, sticking it in a burner, and resoldering it to the board were going to
    get old really fast. Fortunately, we’d implemented a NAND flash ROM emulator (we
    lovingly shortened that to ROMulator) on Novena, which we previously used to reverse
    engineer the AX211 contained in certain SD cards. We just reused that codebase
    and made an SPI ROMulator. We hacked up a GPBB and its corresponding FPGA code
    to add the ability to swap between the original boot SPI ROM and a dual-ported
    64kiB emulator region that was also memory-mapped into the Novena Linux host’s
    address space. Then, we plugged the phone into the laptop and put the ROMulator
    to work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要加快度量-修改-测试循环的速度。拆下ROM、将其放入刻录机并重新焊接到板上，这样的工作很快就会变得枯燥。幸运的是，我们已经在Novena上实现了一个NAND闪存ROM模拟器（我们亲切地将其简称为ROMulator），之前我们曾用它来逆向工程某些SD卡中包含的AX211芯片。我们只是重复使用了那个代码库，并制作了一个SPI
    ROMulator。我们修改了一个GPBB及其对应的FPGA代码，增加了在原始引导SPI ROM和一个双端口64KiB模拟区域之间切换的功能，该模拟区域也被映射到Novena
    Linux主机的地址空间中。然后，我们将手机连接到笔记本电脑，并启动了ROMulator。
- en: '![image](../images/f0314-01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0314-01.jpg)'
- en: '*A block diagram of the SPI ROMulator FPGA*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*SPI ROMulator FPGA的框图*'
- en: '![image](../images/f0315-01.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0315-01.jpg)'
- en: '*There’s a phone in my Novena! What’s that doing there?*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*我的Novena里有一部手机！它怎么会在那里？*'
- en: With the address stream determined by the Tek oscilloscope, some rapid ROM patching
    by the ROMulator, and hints of a SHA-1 function existing in the ROM via a static
    code analysis using IDA, we determined that the initial bootloader (which we called
    the 1bl), was hash-checked using a SHA-1 appendix.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Tek示波器确定的地址流、ROMulator快速的ROM修补以及使用IDA进行静态代码分析时发现ROM中存在一个SHA-1函数的提示，我们确定了初始引导程序（我们称之为1bl）是通过SHA-1附录进行哈希检查的。
- en: '**NOTE**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释**'
- en: '*The assembly for a hash function tends to have a very distinctive shape, or
    set of instructions, and a given hash also has some amount of magic numbers unique
    to it. Given those facts, when trying to reverse an authentication method, one
    of the first things a hacker does is use IDA to search for such constants near
    a function with the shape of the hash function in question.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈希函数的汇编代码通常具有非常独特的形状或一组指令，而且给定的哈希值也有一些独特的“魔法数字”。鉴于这些事实，当黑客试图逆向认证方法时，最先做的事情之一就是使用IDA在哈希函数附近搜索这样的常量。*'
- en: '**Building a Beachhead**'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**建立立足点**'
- en: The next step was to create a small interactive shell we could use as a beachhead
    for running experiments on the target hardware. Just as he did for the SD card
    reverse engineering project, xobs created a compact REPL environment, called Fernly,
    that supported commands like peeking at memory, writing data, and dumping CPU
    registers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个小型交互式shell，我们可以用它作为在目标硬件上运行实验的立足点。正如他在SD卡逆向工程项目中所做的那样，xobs创建了一个紧凑的REPL环境，称为Fernly，支持诸如查看内存、写入数据和转储CPU寄存器等命令。
- en: Designing the ROMulator to make the emulated ROM appear as a 64kiB memory-mapped
    window on a Linux host enabled useful POSIX abstractions like the `mmap()` function,
    the `open()` function (via */dev/mem*), the `read()` function, and the `write()`
    function to access the emulated ROM. xobs used these abstractions to create an
    I/O target for radare2, a portable reverse engineering framework. The I/O target
    automatically updated the SHA-1 hash every time we made changes in the 1bl code
    space. With that system in place, we could do cute things like interactively patch
    and disassemble code within the emulated ROM space.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 设计ROMulator使得模拟的ROM呈现为一个64KiB的内存映射窗口在Linux主机上，从而使得像`mmap()`函数、`open()`函数（通过*/dev/mem*）、`read()`函数和`write()`函数等POSIX抽象变得可用，用来访问模拟的ROM。xobs利用这些抽象创建了一个I/O目标，用于radare2，一个便携式逆向工程框架。每次我们修改1bl代码区时，I/O目标都会自动更新SHA-1哈希。有了这个系统，我们就可以做一些有趣的事情，比如在模拟的ROM空间内交互式地修补和反汇编代码。
- en: '![image](../images/f0316-01.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0316-01.jpg)'
- en: '*Patching some code in the ROM*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*在ROM中修补一些代码*'
- en: We also wired up the power switch of the phone to an FPGA I/O. That allowed
    us to write automated scripts that toggled the power on the phone while updating
    the ROM contents so we could automatically fuzz unknown hardware blocks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将手机的电源开关连接到FPGA的I/O端口。这使我们能够编写自动化脚本，在更新ROM内容的同时切换手机的电源，从而自动模糊测试未知的硬件模块。
- en: '**Attaching a Debugger**'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**附加调试器**'
- en: We had to take an unconventional approach to attach a debugger to the code in
    the ROM, because locating critical blocks was difficult, and JTAG was multiplexed
    with critical functions on the target device. xobs emulated the ARM core and used
    his Fernly shell to reflect virtual loads and stores to the live target. We were
    able to attach a remote debugger to the emulated core that way, bypassing the
    need for JTAG entirely. That also let us use cross-platform tools like IDA on
    x86 for the reversing UI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不采用一种非常规的方法将调试器附加到ROM中的代码，因为定位关键块很困难，而JTAG与目标设备上的关键功能是复用的。xobs模拟了ARM核心，并使用Fernly
    Shell将虚拟的加载和存储反射到实际目标上。通过这种方式，我们能够将远程调试器附加到模拟核心，完全绕过了JTAG的需求。这也让我们能够使用像IDA这样的跨平台工具，在x86上进行反向工程的界面操作。
- en: At the heart of this debugging technique was QEMU, a multiplatform system emulator.
    QEMU supports emulating ARM targets, specifically the ARMv5 chip our target device
    used. We made a new virtual machine type, called Fernvale, that implemented part
    of the observed hardware on the target and simply passed unknown memory accesses
    directly to the device.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调试技术的核心是QEMU，一个多平台系统模拟器。QEMU支持模拟ARM目标，特别是我们的目标设备使用的ARMv5芯片。我们创建了一个新的虚拟机类型，称为Fernvale，它实现了目标设备上部分硬件的模拟，并将未知的内存访问直接传递到设备上。
- en: 'The Fernly shell was stripped down to support only three commands: write, read,
    and zero-memory. The write command pokes a byte, word, or dword of data into RAM
    on the live target. A read command reads a byte, word, or dword from the live
    target. The zero-memory command is an optimization, as the operating system writes
    large quantities of zeros across a large memory area.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Fernly Shell被简化为只支持三条命令：写、读和零内存。写命令将一个字节、字或双字的数据写入实际目标的RAM中。读命令从实际目标中读取一个字节、字或双字的数据。零内存命令是一种优化，操作系统会将大量零写入一个大范围的内存区域。
- en: We also hooked and emulated the serial port registers, allowing a host system
    to display serial data as if it were printed on the target device. Finally, we
    emulated SPI, IRAM, and PSRAM as they’d appear on the real device. Other areas
    of memory were either trapped and funneled to the actual device or left unmapped
    and reported as errors by QEMU.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还钩住并模拟了串口寄存器，使得主机系统能够像在目标设备上打印一样显示串行数据。最后，我们模拟了SPI、IRAM和PSRAM的行为，仿真它们在真实设备上的表现。其他内存区域则被捕获并传送到实际设备，或者保持未映射状态并由QEMU报告为错误。
- en: '![image](../images/f0318-01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0318-01.jpg)'
- en: '*The architecture of the debugger*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试器的架构*'
- en: Invoking the debugger was a multistage process. First, we primed the actual
    MT6260 target with the Fernly shell environment. Then, we booted the QEMU virtual
    ARM CPU with a version of the original vendor image primed with a known register
    state at a convenient point in the boot process. At this point, code execution
    proceeded on the virtual machine until a load or store was performed to an unknown
    address. On that load or store, virtual machine execution paused while a query
    was sent to the real MT6260 via the Fernly shell interface. The load or store
    was then executed on the real machine, which would relay the results of the load
    or store to the virtual machine so execution could resume.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 调用调试器是一个多阶段的过程。首先，我们使用Fernly Shell环境对实际的MT6260目标进行初始化。然后，我们启动了QEMU虚拟ARM CPU，加载了一个经过初始化并处于启动过程中的已知寄存器状态的原厂镜像。在此时，虚拟机开始执行代码，直到发生对未知地址的加载或存储。此时，虚拟机执行暂停，查询通过Fernly
    Shell接口发送到真实的MT6260。然后，加载或存储操作在真实机器上执行，结果会传回虚拟机，代码执行得以恢复。
- en: We couldn’t run Fernly directly from the SPI ROM because the vendor binary’s
    initialization routine modified SPI ROM timings. But of course Fernly would have
    crashed if a store happened to land somewhere inside its memory footprint. To
    avoid the possibility of a load or store overwriting the Fernly shell code, we
    hid the code in a region of IRAM that was trapped and emulated. Emulating the
    target CPU let us attach a remote debugger like IDA via GDB over TCP. The debugger
    had complete control over the emulated CPU and could access its emulated RAM.
    Here is an example of the output of the hybrid QEMU/live-target debug harness.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法直接从SPI ROM运行Fernly，因为供应商二进制的初始化例程修改了SPI ROM的时序。当然，如果存储操作恰好发生在Fernly的内存区域内，Fernly就会崩溃。为了避免加载或存储操作覆盖Fernly
    Shell代码，我们将代码隐藏在一个被捕获并模拟的IRAM区域中。模拟目标CPU让我们能够通过GDB在TCP上连接远程调试器，如IDA。调试器完全控制模拟的CPU，并可以访问模拟的RAM。这是混合QEMU/实际目标调试系统的输出示例。
- en: '[PRE2]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This output shows the trapped serial writes appearing on the console, plus a
    log of the writes and reads executed by the emulated ARM CPU as they were relayed
    to the live target running the reduced Fernly shell. This was our beachhead.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出显示了控制台上出现的串行写入操作，以及由模拟的 ARM CPU 执行的写入和读取日志，这些操作被转发到运行精简版 Fernly shell 的实时目标。这是我们的登陆点。
- en: From there, xobs and I discovered the offsets of a few IP blocks that were reused
    from previous known MediaTek chips by searching for their “signature” in memory.
    A signature could be as simple as the power-on default register values, or something
    more complex, like changes in bit patterns due to the side effects of bit set
    or clear registers located at offsets within the IP block’s address space. Following
    the signatures helped us find the register offsets of several peripherals and
    generate a memory map.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，xobs 和我通过搜索内存中已知的前 MediaTek 芯片的“签名”，发现了几个 IP 块的偏移地址。签名可以是像开机默认寄存器值这么简单，或者更复杂一些，比如由于位设置或清除寄存器的副作用，在
    IP 块地址空间的偏移处出现的位模式变化。通过追踪这些签名，帮助我们找到了几个外设的寄存器偏移，并生成了内存映射。
- en: '| **Starting Address** | **Ending Address** | **Size of Region** | **Description**
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **起始地址** | **结束地址** | **区域大小** | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0x00000000` | `0x0fffffff` | `0x0fffffff` | `PSRAM map, repeated and mirrored
    at 0x00800000 offsets` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000000` | `0x0fffffff` | `0x0fffffff` | `PSRAM 映射，在 0x00800000 偏移处重复并镜像`
    |'
- en: '| `0x10000000` | `0x1fffffff` | `0x0fffffff` | `Memory-mapped SPI chip` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `0x10000000` | `0x1fffffff` | `0x0fffffff` | `内存映射 SPI 芯片` |'
- en: '| `??????????` | `??????????` | `??????????` | `????????????????????????????????`
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `??????????` | `??????????` | `??????????` | `????????????????????????????????`
    |'
- en: '| `0x70000000` | `0x7000cfff` | `0xcfff` | `On-chip SRAM (maybe cache?)` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `0x70000000` | `0x7000cfff` | `0xcfff` | `片上 SRAM（可能是缓存？）` |'
- en: '| `??????????` | `??????????` | `??????????` | `????????????????????????????????`
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `??????????` | `??????????` | `??????????` | `????????????????????????????????`
    |'
- en: '| `0x80000000` | `0x80000008` | `0x08` | `Config block (chip version, etc.)`
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `0x80000000` | `0x80000008` | `0x08` | `配置块（芯片版本等）` |'
- en: '| `0x82200000` | `??????????` | `??????????` |  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `0x82200000` | `??????????` | `??????????` |  |'
- en: '| `0x83000000` | `??????????` | `??????????` |  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `0x83000000` | `??????????` | `??????????` |  |'
- en: '| `0xa0000000` | `0xa0000008` | `0x08` | `Config block (mirror?)` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `0xa0000000` | `0xa0000008` | `0x08` | `配置块（镜像？）` |'
- en: '| `0x10010000` | `??????????` | `??????????` | `(?SPI mode?) ????????????????????`
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `0x10010000` | `??????????` | `??????????` | `(?SPI 模式?) ????????????????????`
    |'
- en: '| `0x10020000` | `0xa0020e10` | `0x0e10` | `GPIO control block` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `0x10020000` | `0xa0020e10` | `0x0e10` | `GPIO 控制块` |'
- en: '| `0xa0030000` | `0xa0030040` | `0x40` | `WDT block` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `0xa0030000` | `0xa0030040` | `0x40` | `WDT 块` |'
- en: '|  |  |  | `   + 0x08 -> WDT register (?)    + 0x18 -> Boot src (?)` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | `   + 0x08 -> WDT 寄存器 (?)    + 0x18 -> 启动源 (?)` |'
- en: '| `0xa0030800` | `??????????` | `??????????` | `????????????????????????????????`
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `0xa0030800` | `??????????` | `??????????` | `????????????????????????????????`
    |'
- en: '| `0xa0040000` | `??????????` | `??????????` | `????????????????????????????????`
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `0xa0040000` | `??????????` | `??????????` | `????????????????????????????????`
    |'
- en: '| `0xa0050000` | `??????????` | `??????????` | `????????????????????????????????`
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `0xa0050000` | `??????????` | `??????????` | `????????????????????????????????`
    |'
- en: '| `0xa0060000` | `??????????` | `??????????` | `?? Possible IRQs at 0xa0060200
    ??` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `0xa0060000` | `??????????` | `??????????` | `?? 可能的 IRQ 位于 0xa0060200 ??`
    |'
- en: '| `0xa0070000` | `==========` | `==========` | `== Empty (all zeroes) ===========`
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `0xa0070000` | `==========` | `==========` | `== 空（全零） ===========` |'
- en: '| `0xa0080000` | `0xa008005c` | `0x5c` | `UART1 block` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `0xa0080000` | `0xa008005c` | `0x5c` | `UART1 块` |'
- en: '| `0xa0090000` | `0xa009005c` | `0x5c` | `UART2 block` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `0xa0090000` | `0xa009005c` | `0x5c` | `UART2 块` |'
- en: '| `0xa00a0000` | `??????????` | `??????????` | `?????????????????????????????????`
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `0xa00a0000` | `??????????` | `??????????` | `?????????????????????????????????`
    |'
- en: This memory map shows what content is stored at different address ranges on
    the chip. For instance, the second address range in the map (0x10000000 to 0x1FFFFFFF)
    consisted of 0x0FFFFFFF bytes corresponding to a memory-mapped SPI chip.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内存映射展示了芯片不同地址范围内存储的内容。例如，映射中的第二个地址范围（0x10000000 到 0x1FFFFFFF）由 0x0FFFFFFF
    字节组成，对应一个内存映射的 SPI 芯片。
- en: '**Booting an OS**'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**启动操作系统**'
- en: After finding the register offsets, we progressed rapidly on many fronts, but
    our goal (to port NuttX, a BSD-based real-time operating system, to the device)
    remained elusive. There was no documentation on the interrupt controller within
    the canon of shanzhai datasheets. We found the routines that installed the interrupt
    handlers through static analysis of the binaries, but we couldn’t determine the
    address offsets of the interrupt controller itself.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到寄存器偏移后，我们在多个方面迅速取得了进展，但我们的目标（将基于BSD的实时操作系统NuttX移植到该设备上）依然未能实现。关于中断控制器的文档在山寨数据手册的规范中并不存在。我们通过对二进制文件的静态分析找到了安装中断处理程序的例程，但无法确定中断控制器本身的地址偏移。
- en: All we could do was open the MediaTek codebase and refer to the header file
    that contained the register offsets and bit definitions of the interrupt controller.
    This fit within our self-imposed limitations to not breach copyright, because
    facts are not copyrightable. I describe the legal reasoning behind this idea in
    [Chapter 4](ch04.xhtml#ch04), under “[Dealing with Copyrights](ch04.xhtml#ch00lev1sec82)”
    on [page 138](ch04.xhtml#page_138). After looking up those facts, we created our
    own custom scripting language, called Scriptic, to avoid unconsciously plagiarizing
    anything from the existing codebase.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做的就是打开联发科技的代码库，参考其中包含中断控制器寄存器偏移和位定义的头文件。这符合我们自己设定的“不侵犯版权”的限制，因为事实是不可版权的。我在[第4章](ch04.xhtml#ch04)中的“[处理版权问题](ch04.xhtml#ch00lev1sec82)”部分，位于[第138页](ch04.xhtml#page_138)中描述了这一思想背后的法律推理。在查阅了这些事实后，我们创建了自己的定制脚本语言——Scriptic，以避免无意中抄袭现有代码库中的任何内容。
- en: '**Building a New Toolchain**'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**构建新的工具链**'
- en: Requiring users to own a Novena ROMulator to hack on Fernvale wasn’t a scalable
    solution, however. To round out the story, we created a complete developer toolchain.
    The compiler was fairly cut-and-dried; many standard compilers support ARM as
    a target, including clang and GCC. But making open tools for flashing the MT6260
    was much trickier. All the existing tools we knew supported the protocol version
    required by the MT6260 were proprietary Windows programs. That meant we had to
    reverse engineer the MediaTek flashing protocol and write our own open source
    tool.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要求用户拥有一个Novena ROMulator来破解Fernvale并不是一个可扩展的解决方案。为了完成这个故事，我们创建了一个完整的开发工具链。编译器相对简单明了；许多标准编译器支持将ARM作为目标，包括clang和GCC。但制作用于刷写MT6260的开源工具则要复杂得多。我们知道的所有现有支持MT6260所需协议版本的工具都是专有的Windows程序。这意味着我们必须逆向工程联发科技的刷写协议，并编写自己的开源工具。
- en: Fortunately, a blank, unfused MT6260 shows up as */dev/ttyUSB0* when you plug
    it into a Linux host. In other words, it shows up as an emulated serial device
    over USB. That took care of the lower-level details of sending and receiving bytes
    to the device, leaving us to reverse engineer the protocol layer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当你将一个空白、未熔断的MT6260连接到Linux主机时，它会显示为*/dev/ttyUSB0*。换句话说，它作为一个通过USB模拟的串口设备出现。这解决了向设备发送和接收字节的低级细节，剩下的就是逆向工程协议层。
- en: xobs located the internal boot ROM of the MT6260 and performed static code analysis
    to learn more about the protocol. He also did some static analysis on MediaTek’s
    flashing tool and captured live traces using a USB protocol analyzer to clarify
    the remaining details. Here is a summary of the commands he extracted, as we used
    in our open version of the USB flashing tool.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: xobs定位了MT6260的内部启动ROM，并进行了静态代码分析以深入了解协议。他还对联发科技的刷写工具进行了静态分析，并使用USB协议分析仪捕获了实时数据，以澄清剩余的细节。以下是他提取的命令的总结，这是我们在开源版USB刷写工具中使用的。
- en: '[PRE3]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is just a C `enum` structure, making it a very geeky way of specifying
    a mapping of numbers to command meanings. For example, `mtk_cmd_old_write16` is
    command 0xA1, `mtk_command_old_read16` is command 0xA2, and so on.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个C语言的`enum`结构，因此它是一个非常极客的方式来指定数字与命令含义之间的映射。例如，`mtk_cmd_old_write16`是命令0xA1，`mtk_command_old_read16`是命令0xA2，以此类推。
- en: '**Fernvale Results**'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**Fernvale结果**'
- en: After about a year of on-and-off effort between work on the Novena and Chibitronics
    campaigns, we were able to boot a port of NuttX on the MT6260, supporting a minimal
    set of hardware peripherals. It was enough for us to roughly reproduce the functionality
    of an AVR used in an Arduino-like context, but not much more.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在大约一年间，经过在Novena和Chibitronics项目之间的断断续续努力后，我们成功地在MT6260上启动了NuttX的移植，支持了一组最基本的硬件外设。这足以让我们大致复现类似Arduino环境中使用的AVR的功能，但也仅此而已。
- en: xobs and I presented our results at the 31st Chaos Communication Congress (CCC),
    and events actually took an unexpected twist as we wrote our proposal. The week
    before submission, we learned that MediaTek released the LinkIT ONE development
    platform, based on the MT2502A, in conjunction with Seeed Studios. The LinkIT
    ONE is an Internet of Things platform made for entrepreneurs and hobbyists. It’s
    integrated into the Arduino framework and features an open API that enables the
    full functionality of the chip, including GSM functions. But the core OS that
    boots on the MT2502A in the LinkIT ONE is still proprietary, and you can’t access
    the hardware without going through the API calls provided by the Arduino shim.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: xobs和我在第31届混沌通信大会（CCC）上展示了我们的成果，而事件在我们撰写提案时意外发生了转折。在提交前的一周，我们得知联发科技发布了基于MT2502A的LinkIT
    ONE开发平台，并与Seeed Studios合作。LinkIT ONE是一个为创业者和爱好者设计的物联网平台。它集成到Arduino框架中，拥有一个开放的API，能够提供芯片的完整功能，包括GSM功能。但在LinkIT
    ONE上运行的核心操作系统仍然是专有的，并且在没有通过Arduino shim提供的API调用的情况下，无法直接访问硬件。
- en: Realistically, it’s still going to be a while before we can port a reasonable
    fraction of the MT6260’s features into the open source domain. It’s quite possible
    we’ll never be able to do a blob-free implementation of the GSM call functions,
    as those are controlled by a DSP unit that’s even more obscure and undocumented
    than the MT6260\. Given the robust functionality of the LinkIT ONE compared to
    Fernvale, we decided to leave the question of whether there was value in continuing
    the effort to reverse engineer the MT6260 to the open source community. In the
    end, there was a lot of enthusiasm for the project, but not a lot of action. The
    LinkIT ONE’s introduction took a lot of wind out of the sails of the Fernvale
    project, which has since been effectively retired.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现实来说，我们仍然需要一些时间才能将MT6260的部分功能移植到开源领域。我们很可能永远无法实现不依赖二进制代码的GSM呼叫功能实现，因为这些功能由一个数字信号处理器（DSP）单元控制，该单元比MT6260更为隐晦且没有文档支持。考虑到LinkIT
    ONE相比于Fernvale的强大功能，我们决定将是否继续逆向工程MT6260的价值问题交给开源社区来判断。最终，尽管这个项目吸引了大量的热情，但行动却并不多。LinkIT
    ONE的发布让Fernvale项目失去了很多动力，Fernvale项目也在此后实际上被停用了。
- en: This is, in fact, the fate of most open source projects. There are dozens, if
    not hundreds, of open source operating systems but only one Linux. The truth is
    that there are far more interesting ideas than capable developers to execute them.
    For an open source project to catch fire and become self-sustaining, it has to
    not only pass the minimum viable product (MVP) stage but also meet a receptive
    audience with a real need for the project. Sometimes your project strikes a chord,
    and a huge community pushes it forward. Other times, you get a lot of nice, helpful
    onlookers who nod appreciatively but are unwilling or too busy with day jobs to
    jump in. And still other times, you yell into a void or, worse, get torn to shreds
    on some internet forum about how flawed and pointless your project is.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这正是大多数开源项目的命运。尽管有数十个，甚至数百个开源操作系统，但只有一个Linux。事实是，比起能够实现这些创意的开发者，实际上有更多有趣的创意。为了让一个开源项目成功并自给自足，它不仅需要通过最小可行产品（MVP）阶段，还要遇到有真正需求的、愿意接受这个项目的受众。有时，你的项目能引起共鸣，成千上万的社区成员会推动它向前发展；而有时，你会得到许多友好、乐于助人的旁观者，他们会欣赏地点头，但却不愿意或太忙于日常工作而无法参与。还有其他时候，你只是对着空洞大喊，或者更糟的是，在某个互联网论坛上被撕得粉碎，指责你的项目多么有缺陷和无意义。
- en: '**CLOSING THOUGHTS**'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束思考**'
- en: Given the nature of open source projects, I tend to take a page from my startup
    days and follow a “fail forward fast” philosophy. Try a bunch of different things,
    see what sticks, learn from your mistakes, and try again. It’s important not to
    get too wedded to any one idea, especially if the idea isn’t working out. Finally,
    you’ll find it helps to be more about the journey than the destination. Fernvale
    was most certainly an epic journey; xobs and I learned a lot, honed a set of tools
    and skills that we continue to use to this day for other projects, and most importantly,
    had a lot of fun.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于开源项目的性质，我倾向于借鉴我在创业时期的一些经验，遵循“快速失败，迅速前进”的理念。尝试不同的事情，看看哪些行得通，从错误中学习，并再次尝试。重要的是不要过于固守某个想法，尤其是当这个想法并未取得成功时。最后，你会发现，重要的是享受过程，而非只专注于结果。Fernvale无疑是一次史诗般的旅程；xobs和我学到了很多，磨练了一套工具和技能，这些我们至今还在其他项目中使用，最重要的是，我们玩得非常开心。
- en: In the next chapter, we’ll take a look at another kind of hacking that will
    become increasingly relevant to all of us over the coming decades—that of biological
    systems.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨另一种黑客技术，它将在未来几十年对我们所有人变得越来越相关——即生物系统的黑客技术。
