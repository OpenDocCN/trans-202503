- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: WRITING AND PORTING EXPLOIT CODE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写与移植利用代码
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: In the majority of the previous chapters, you used Go to create network-based
    attacks. You’ve explored raw TCP, HTTP, DNS, SMB, database interaction, and passive
    packet capturing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的大部分章节中，你使用Go语言创建了基于网络的攻击。你已经探索了原始TCP、HTTP、DNS、SMB、数据库交互以及被动数据包捕获等内容。
- en: This chapter focuses instead on identifying and exploiting vulnerabilities.
    First, you’ll learn how to create a vulnerability fuzzer to discover an application’s
    security weaknesses. Then you’ll learn how to port existing exploits to Go. Finally,
    we’ll show you how to use popular tools to create Go-friendly shellcode. By the
    end of the chapter, you should have a basic understanding of how to use Go to
    discover flaws while also using it to write and deliver various payloads.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍识别和利用漏洞。首先，你将学习如何创建漏洞模糊测试器来发现应用程序的安全弱点。然后，你将学习如何将现有的利用代码移植到Go语言中。最后，我们将展示如何使用流行的工具创建Go语言友好的shellcode。到本章结束时，你应该对如何使用Go语言发现缺陷，并利用Go编写和传递各种有效载荷有基本的理解。
- en: Creating a Fuzzer
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模糊测试器
- en: '*Fuzzing* is a technique that sends extensive amounts of data to an application
    in an attempt to force the application to produce abnormal behavior. This behavior
    can reveal coding errors or security deficiencies, which you can later exploit.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*模糊测试*是一种技术，通过向应用程序发送大量数据，试图迫使应用程序产生异常行为。这种行为可以揭示编码错误或安全漏洞，之后你可以利用这些漏洞。'
- en: Fuzzing an application can also produce undesirable side effects, such as resource
    exhaustion, memory corruption, and service interruption. Some of these side effects
    are necessary for bug hunters and exploit developers to do their jobs but bad
    for the stability of the application. Therefore, it’s crucial that you always
    perform fuzzing in a controlled lab environment. As with most of the techniques
    we discuss in this book, don’t fuzz applications or systems without explicit authorization
    from the owner.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对应用程序进行模糊测试也可能产生不良副作用，例如资源耗尽、内存损坏和服务中断。其中一些副作用对于漏洞猎人和利用代码开发者的工作是必要的，但对应用程序的稳定性不利。因此，必须始终在受控的实验室环境中进行模糊测试。与本书中讨论的大多数技术一样，未经所有者明确授权，不要对应用程序或系统进行模糊测试。
- en: In this section, you’ll build two fuzzers. The first will check the capacity
    of an input in an attempt to crash a service and identify a buffer overflow. The
    second fuzzer will replay an HTTP request, cycling through potential input values
    to detect SQL injection.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将构建两个模糊测试器。第一个将检查输入的容量，试图使服务崩溃并识别缓冲区溢出。第二个模糊测试器将重放HTTP请求，循环测试潜在的输入值，以检测SQL注入。
- en: Buffer Overflow Fuzzing
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓冲区溢出模糊测试
- en: '*Buffer overflows* occur when a user submits more data in an input than the
    application has allocated memory space for. For example, a user could submit 5,000
    characters when the application expects to receive only 5\. If a program uses
    the wrong techniques, this could allow the user to write that surplus data to
    parts of memory that aren’t intended for that purpose. This “overflow” corrupts
    the data stored within adjacent memory locations, allowing a malicious user to
    potentially crash the program or alter its logical flow.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*缓冲区溢出*发生在用户提交的输入数据超出了应用程序为其分配的内存空间。例如，用户可能提交5,000个字符，而应用程序只期望接收5个字符。如果程序使用了错误的技术，这可能允许用户将多余的数据写入不为此目的而分配的内存区域。这个“溢出”会破坏相邻内存位置中存储的数据，从而使恶意用户有可能使程序崩溃或改变其逻辑流程。'
- en: 'Buffer overflows are particularly impactful for network-based programs that
    receive data from clients. Using buffer overflows, a client can disrupt server
    availability or possibly achieve remote code execution. It’s worth restating:
    don’t fuzz systems or applications unless you are permitted to do so. In addition,
    make sure you fully understand the consequences of crashing the system or service.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出对网络程序特别有影响，尤其是那些从客户端接收数据的程序。利用缓冲区溢出，客户端可以破坏服务器的可用性，甚至可能实现远程代码执行。值得重申的是：除非获得许可，否则不要对系统或应用程序进行模糊测试。另外，确保你充分理解崩溃系统或服务的后果。
- en: How Buffer Overflow Fuzzing Works
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 缓冲区溢出模糊测试的工作原理
- en: Fuzzing to create a buffer overflow generally involves submitting increasingly
    longer inputs, such that each subsequent request includes an input value whose
    length is one character longer than the previous attempt. A contrived example
    using the *A* character as input would execute according to the pattern shown
    in [Table 9-1](ch09.xhtml#ch19tab1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制造缓冲区溢出，通常会提交逐渐变长的输入，每次请求的输入值长度比上次尝试的长度多一个字符。使用 *A* 字符作为输入的一个假设例子将按照 [表9-1](ch09.xhtml#ch19tab1)
    中所示的模式执行。
- en: By sending numerous inputs to a vulnerable function, you’ll eventually reach
    a point where the length of your input exceeds the function’s defined buffer size,
    which will corrupt the program’s control elements, such as its return and instruction
    pointers. At this point, the application or system will crash.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向一个脆弱的函数发送大量输入，你最终会达到一个输入长度超过该函数定义的缓冲区大小的点，这将破坏程序的控制元素，例如返回指针和指令指针。此时，应用程序或系统将崩溃。
- en: By sending incrementally larger requests for each attempt, you can precisely
    determine the expected input size, which is important for exploiting the application
    later. You can then inspect the crash or resulting core dump to better understand
    the vulnerability and attempt to develop a working exploit. We won’t go into debugger
    usage and exploit development here; instead, let’s focus on writing the fuzzer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过每次尝试发送逐渐增大的请求，你可以精确确定期望的输入大小，这对后续利用该应用程序非常重要。然后，你可以检查崩溃或产生的核心转储，更好地理解漏洞并尝试开发一个有效的攻击代码。我们这里不会讨论调试器的使用和漏洞开发，而是集中精力编写模糊测试器。
- en: '**Table 9-1:** Input Values in a Buffer Overflow Test'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-1：** 缓冲区溢出测试中的输入值'
- en: '| **Attempt** | **Input value** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **尝试** | **输入值** |'
- en: '| 1 | A |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 1 | A |'
- en: '| 2 | AA |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 2 | AA |'
- en: '| 3 | AAA |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 3 | AAA |'
- en: '| 4 | AAAA |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 4 | AAAA |'
- en: '| *N* | A repeated *N* times |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| *N* | 重复 *N* 次 |'
- en: 'If you’ve done any manual fuzzing using modern, interpreted languages, you’ve
    probably used a construct to create strings of specific lengths. For example,
    the following Python code, run within the interpreter console, shows how simple
    it is to create a string of 25 *A* characters:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做过任何使用现代解释型语言的手动模糊测试，你可能已经使用了某种构造来创建特定长度的字符串。例如，下面的 Python 代码，在解释器控制台中运行，展示了如何简单地创建一个由
    25 个 *A* 字符组成的字符串：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unfortunately, Go has no such construct to conveniently build strings of arbitrary
    length. You’ll have to do that the old-fashioned way—using a loop—which would
    look something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Go 没有类似的结构来方便地构建任意长度的字符串。你必须采用传统的方式——使用循环——其代码大致如下：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Sure, it’s a little more verbose than the Python alternative, but not overwhelming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它比 Python 的替代方案稍微冗长一些，但并不难以理解。
- en: The other consideration you’ll need to make is the delivery mechanism for your
    payload. This will depend on the target application or system. In some instances,
    this could involve writing a file to a disk. In other cases, you might communicate
    over TCP/UDP with an HTTP, SMTP, SNMP, FTP, Telnet, or other networked service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑的另一个问题是如何传递你的有效载荷。这将取决于目标应用程序或系统。在某些情况下，这可能涉及将文件写入磁盘。在其他情况下，你可能会通过 TCP/UDP
    与 HTTP、SMTP、SNMP、FTP、Telnet 或其他网络服务进行通信。
- en: In the following example, you’ll perform fuzzing against a remote FTP server.
    You can tweak a lot of the logic we present fairly quickly to operate against
    other protocols, so it should act as a good basis for you to develop custom fuzzers
    against other services.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你将针对一个远程 FTP 服务器进行模糊测试。你可以快速调整我们展示的逻辑，使其适用于其他协议，因此它应该为你开发针对其他服务的自定义模糊测试器提供一个良好的基础。
- en: Although Go’s standard packages include support for some common protocols, such
    as HTTP and SMTP, they don’t include support for client-server FTP interactions.
    Instead, you could use a third-party package that already performs FTP communications,
    so you don’t have to reinvent the wheel and write something from the ground up.
    However, for maximum control (and to appreciate the protocol), you’ll instead
    build the basic FTP functionality using raw TCP communications. If you need a
    refresher on how this works, refer to [Chapter 2](ch02.xhtml#ch2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Go 的标准库包含对一些常见协议的支持，比如 HTTP 和 SMTP，但它不支持客户端与服务器之间的 FTP 交互。相反，你可以使用一个已经实现
    FTP 通信的第三方库，这样你就不必从头开始重新发明轮子。然而，为了最大程度地控制（并理解协议），你可以通过原始 TCP 通信构建基本的 FTP 功能。如果你需要关于如何工作的复习，请参见
    [第2章](ch02.xhtml#ch2)。
- en: Building The Buffer Overflow Fuzzer
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建缓冲区溢出模糊测试器
- en: '[Listing 9-1](ch09.xhtml#ch9list1) shows the fuzzer code. (All the code listings
    at the root location of / exist under the provided github repo [*https://github.com/blackhat-go/bhg/*](https://github.com/blackhat-go/bhg/).)
    We’ve hardcoded some values, such as the target IP and port, as well as the maximum
    length of your input. The code itself fuzzes the `USER` property. Since this property
    occurs before a user is authenticated, it represents a commonly testable point
    on the attack surface. You could certainly extend this code to test other pre-authentication
    commands, such as `PASS`, but keep in mind that if you supply a legitimate username
    and then keep submitting inputs for `PASS`, you might get locked out eventually.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-1](ch09.xhtml#ch9list1)显示了模糊器代码。（位于根位置的所有代码列表都存在于提供的 GitHub 仓库[*https://github.com/blackhat-go/bhg/*](https://github.com/blackhat-go/bhg/)中。）我们已经硬编码了一些值，比如目标
    IP 和端口，以及输入的最大长度。代码本身会模糊化`USER`属性。由于该属性发生在用户身份验证之前，因此它代表了攻击面上的常见测试点。你当然可以扩展此代码来测试其他身份验证前的命令，比如`PASS`，但请记住，如果你提供了一个合法的用户名并且继续提交`PASS`的输入，你最终可能会被锁定。'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-1: A buffer overflow fuzzer (*[/ch-9/ftp-fuzz/main.go](https://github.com/blackhat-go/bhg/tree/master/ch-9/ftp_fuzz/main.go)*)*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-1：一个缓冲区溢出模糊器 (*[/ch-9/ftp-fuzz/main.go](https://github.com/blackhat-go/bhg/tree/master/ch-9/ftp_fuzz/main.go)*)*'
- en: The code is essentially one large loop, beginning at ❶. Each time the program
    loops, it adds another character to the username you’ll supply. In this case,
    you’ll send usernames from 1 to 2,500 characters in length.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本质上是一个大的循环，从❶开始。每次程序循环时，它会向你提供的用户名中添加一个字符。在这个例子中，你将发送长度从 1 到 2500 的用户名。
- en: For each iteration of the loop, you establish a TCP connection to the destination
    FTP server ❷. Any time you interact with the FTP service, whether it’s the initial
    connection or the subsequent commands, you explicitly read the response from the
    server as a single line ❹. This allows the code to block while waiting for the
    TCP responses so you don’t send your commands prematurely, before packets have
    made their round trip. You then use another `for` loop to build the string of
    *A*s in the manner we showed previously ❺. You use the index `i` of the outer
    loop to build the string length dependent on the current iteration of the loop,
    so that it increases by one each time the program starts over. You use this value
    to write the `USER` command by using `fmt.Fprintf(conn, raw, user)` ❻.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次循环迭代，你都会与目标 FTP 服务器建立一个 TCP 连接❷。每次你与 FTP 服务交互时，无论是初始连接还是后续命令，你都需要显式地将服务器的响应作为一行读取❹。这使得代码在等待
    TCP 响应时能够阻塞，以免你在数据包完成往返之前过早发送命令。然后，你使用另一个`for`循环按我们之前展示的方式构建一串*A*s❺。你使用外部循环的索引`i`来构建依赖于当前循环迭代的字符串长度，以便每次程序重新开始时增加一个字符。你使用这个值通过`fmt.Fprintf(conn,
    raw, user)`来写入`USER`命令❻。
- en: Although you could end your interaction with the FTP server at this point (after
    all, you’re fuzzing only the `USER` command), you proceed to send the `PASS` command
    to complete the transaction. Lastly, you close your connection cleanly ❼.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此时你可以结束与 FTP 服务器的交互（毕竟，你只是在模糊化`USER`命令），你仍然继续发送`PASS`命令以完成事务。最后，你会干净地关闭连接❼。
- en: 'It’s worth noting that there are two points, ❸ and ❽, where abnormal connectivity
    behavior could indicate a service disruption, implying a potential buffer overflow:
    when the connection is first established and when the connection closes. If you
    can’t establish a connection the next time the program loops, it’s likely that
    something went wrong. You’ll then want to check whether the service crashed as
    a result of a buffer overflow.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有两个点，❸和❽，在这些位置，异常的连接行为可能表明服务中断，暗示可能发生了缓冲区溢出：即在连接首次建立时和连接关闭时。如果你在程序下次循环时无法建立连接，很可能是出现了问题。你需要检查服务是否因为缓冲区溢出而崩溃。
- en: If you can’t close a connection after you’ve established it, this may indicate
    the abnormal behavior of the remote FTP service abruptly disconnecting, but it
    probably isn’t caused by a buffer overflow. The anomalous condition is logged,
    but the program will continue.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在建立连接后无法关闭连接，这可能表明远程 FTP 服务出现异常行为，突然断开连接，但很可能不是由于缓冲区溢出引起的。该异常情况会被记录，但程序将继续执行。
- en: A packet capture, illustrated in [Figure 9-1](ch09.xhtml#ch9fig1), shows that
    each subsequent `USER` command grows in length, confirming that your code works
    as desired.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数据包捕获示意图，如[图 9-1](ch09.xhtml#ch9fig1)所示，显示了每个后续的`USER`命令在长度上逐渐增加，确认了你的代码按预期工作。
- en: '![Image](Images/09fig01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/09fig01.jpg)'
- en: '*Figure 9-1: A Wireshark capture depicting the USER command growing by one
    letter each time the program loops*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：Wireshark捕获图，展示每次程序循环时USER命令增加一个字母*'
- en: You could improve the code in several ways for flexibility and convenience.
    For example, you’d probably want to remove the hardcoded IP, port, and iteration
    values, and instead include them via command line arguments or a configuration
    file. We invite you to perform these usability updates as an exercise. Furthermore,
    you could extend the code so it fuzzes commands after authentication. Specifically,
    you could update the tool to fuzz the `CWD`/`CD` command. Various tools have historically
    been susceptible to buffer overflows related to the handling of this command,
    making it a good target for fuzzing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式改进代码，以提高灵活性和便利性。例如，您可能希望删除硬编码的IP、端口和迭代值，而是通过命令行参数或配置文件将它们包含在内。我们邀请您将这些可用性更新作为练习。此外，您可以扩展代码，使其在身份验证后进行模糊测试。具体来说，您可以更新工具，使其对`CWD`/`CD`命令进行模糊测试。历史上，许多工具在处理该命令时易受到缓冲区溢出的影响，因此它是一个很好的模糊测试目标。
- en: SQL Injection Fuzzing
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SQL注入模糊测试
- en: In this section, you’ll explore SQL injection fuzzing. Instead of changing the
    length of each input, this variation on the attack cycles through a defined list
    of inputs to attempt to cause SQL injection. In other words, you’ll fuzz the username
    parameter of a website login form by attempting a list of inputs consisting of
    various SQL meta-characters and syntax that, if handled insecurely by the backend
    database, will yield abnormal behavior by the application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将探索SQL注入模糊测试。与更改每个输入的长度不同，这种攻击的变种会循环尝试一组定义好的输入，以尝试触发SQL注入。换句话说，您将通过尝试包含各种SQL元字符和语法的输入列表来对网站登录表单的用户名参数进行模糊测试。如果后端数据库处理这些输入时不安全，它将导致应用程序出现异常行为。
- en: To keep things simple, you’ll be probing only for error-based SQL injection,
    ignoring other forms, such as boolean-, time-, and union-based. That means that
    instead of looking for subtle differences in response content or response time,
    you’ll look for an error message in the HTTP response to indicate a SQL injection.
    This implies that you expect the web server to remain operational, so you can
    no longer rely on connection establishment as a litmus test for whether you’ve
    succeeded in creating abnormal behavior. Instead, you’ll need to search the response
    body for a database error message.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，您将仅探测基于错误的SQL注入，忽略其他形式的SQL注入，如基于布尔值、时间和联合的SQL注入。这意味着，您不会查找响应内容或响应时间的细微差异，而是会查找HTTP响应中的错误信息，以指示SQL注入。这意味着您期望Web服务器保持运行，因此您不再可以依赖连接建立来作为判断是否成功造成异常行为的标准。相反，您需要在响应正文中搜索数据库错误信息。
- en: How SQL Injection Works
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SQL注入是如何工作的
- en: 'At its core, SQL injection allows an attacker to insert SQL meta-characters
    into a statement, potentially manipulating the query to produce unintended behavior
    or return restricted, sensitive data. The problem occurs when developers blindly
    concatenate untrusted user data to their SQL queries, as in the following pseudocode:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入的核心原理是允许攻击者将SQL元字符插入语句中，可能通过操控查询产生意外行为或返回受限的敏感数据。当开发者盲目地将不可信的用户数据拼接到SQL查询中时，就会发生问题，如下伪代码所示：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our pseudocode, the username variable is read directly from an HTTP parameter.
    The value of the username variable isn’t sanitized or validated. You then build
    a query string by using the value, concatenating it onto the SQL query syntax
    directly. The program executes the query against the database and inspects the
    result. If it finds at least one matching record, you’d consider the authentication
    successful. The code should behave appropriately so long as the supplied username
    consists of alphanumeric and a certain subset of special characters. For example,
    supplying a username of `alice` results in the following safe query:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的伪代码中，用户名变量直接从HTTP参数中读取。用户名变量的值没有经过清理或验证。然后，你将使用该值构建查询字符串，将其直接连接到SQL查询语法中。程序执行查询并检查结果。如果找到至少一条匹配的记录，认为身份验证成功。只要提供的用户名由字母数字字符和某些子集的特殊字符组成，代码应该正常工作。例如，提供用户名`alice`会生成以下安全查询：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, what happens when the user supplies a username containing an apostrophe?
    Supplying a username of `o''doyle` produces the following query:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当用户提供包含撇号的用户名时，会发生什么呢？提供用户名`o'doyle`会生成以下查询：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The problem here is that the backend database now sees an unbalanced number
    of single quotation marks. Notice the emphasized portion of the preceding query,
    doyle; the backend database interprets this as SQL syntax, since it’s outside
    the enclosing quotes. This, of course, is invalid SQL syntax, and the backend
    database won’t be able to process it. For error-based SQL injection, this produces
    an error message in the HTTP response. The message itself will vary based on the
    database. In the case of MySQL, you’ll receive an error similar to the following,
    possibly with additional details disclosing the query itself:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，后端数据库现在看到的不平衡的单引号数量。注意前面查询中强调的部分，doyle；后端数据库将其解释为SQL语法，因为它位于包围引号之外。当然，这是无效的SQL语法，后端数据库无法处理它。对于基于错误的SQL注入，这会在HTTP响应中生成一个错误消息。消息的内容会根据数据库的不同而有所变化。在MySQL的情况下，你会收到类似以下的错误，可能还会附加一些披露查询本身的详细信息：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Although we won’t go too deeply into exploitation, you could now manipulate
    the username input to produce a valid SQL query that would bypass the authentication
    in our example. The username input `'' OR 1=1#` does just that when placed in
    the following SQL statement:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会深入讨论漏洞利用，但现在你可以操纵用户名输入，生成一个有效的SQL查询，从而绕过我们示例中的认证。当用户名输入为`' OR 1=1#`时，它会在以下SQL语句中实现这一点：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This input appends a logical `OR` onto the end of the query. This `OR` statement
    always evaluates to true, because 1 always equals 1\. You then use a MySQL comment
    (`#`) to force the backend database to ignore the remainder of the query. This
    results in a valid SQL statement that, assuming one or more rows exist in the
    database, you can use to bypass authentication in the preceding pseudocode example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输入会在查询的末尾附加一个逻辑`OR`。这个`OR`语句始终评估为真，因为1总是等于1。然后你使用MySQL注释（`#`）强制后端数据库忽略查询的其余部分。这样就会得到一个有效的SQL语句，假设数据库中存在一行或多行数据，你可以使用它绕过前面伪代码示例中的认证。
- en: Building the SQL Injection Fuzzer
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建SQL注入模糊器
- en: The intent of your fuzzer won’t be to generate a syntactically valid SQL statement.
    Quite the opposite. You’ll want to break the query such that the malformed syntax
    yields an error by the backend database, as the O’Doyle example just demonstrated.
    For this, you’ll send various SQL meta-characters as input.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模糊器的目的是不生成一个语法上有效的SQL语句。恰恰相反，你希望破坏查询，使得不正确的语法会导致后端数据库报错，就像O’Doyle的示例所展示的那样。为此，你将发送各种SQL元字符作为输入。
- en: 'The first order of business is to analyze the target request. By inspecting
    the HTML source code, using an intercepting proxy, or capturing network packets
    with Wireshark, you determine that the HTTP request submitted for the login portal
    resembles the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是分析目标请求。通过检查HTML源代码、使用拦截代理或使用Wireshark捕获网络数据包，你可以确定提交到登录门户的HTTP请求类似于以下内容：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The login form sends a POST request to *http://10.0.1.20:8080/WebApplication/login.jsp*.
    There are two form parameters: `username` and `password`. For this example, we’ll
    limit the fuzzing to the `username` field for brevity. The code itself is fairly
    compact, consisting of a few loops, some regular expressions, and the creation
    of an HTTP request. It’s shown in [Listing 9-2](ch09.xhtml#ch9list2).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 登录表单向*http://10.0.1.20:8080/WebApplication/login.jsp*发送POST请求。表单有两个参数：`username`和`password`。为了简洁起见，这里我们仅对`username`字段进行模糊测试。代码本身非常简洁，包含了一些循环、正则表达式以及HTTP请求的创建。代码展示在[Listing
    9-2](ch09.xhtml#ch9list2)中。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-2: A SQL injection fuzzer (*[/ch-9/http_fuzz/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-9/http_fuzz/main.go)*)*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-2: SQL注入模糊器 (*[/ch-9/http_fuzz/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-9/http_fuzz/main.go)*)*'
- en: The code begins by defining a slice of payloads you want to attempt ❶. This
    is your fuzzing list that you’ll supply later as the value of the `username` request
    parameter. In the same vein, you define a slice of strings that represent keywords
    within an SQL error message ❷. These will be the values you’ll search for in the
    HTTP response body. The presence of any of these values is a strong indicator
    that an SQL error message is present. You could expand on both of these lists,
    but they’re adequate datasets for this example.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先定义了一个负载切片，你希望尝试这些负载❶。这就是你稍后将作为`username`请求参数的值提供的模糊列表。同样，你定义了一个字符串切片，表示SQL错误消息中的关键字❷。这些是你将在HTTP响应体中搜索的值。只要这些值中的任何一个存在，就可以强烈指示SQL错误消息的存在。你可以扩展这两个列表，但它们对于本示例来说已经足够了。
- en: Next, you perform some preprocessing work. For each of the error keywords you
    wish to search for, you build and compile a regular expression ❸. You do this
    work outside your main HTTP logic so you don’t have to create and compile these
    regular expressions multiple times, once for each payload. A minor optimization,
    no doubt, but good practice nonetheless. You’ll use these compiled regular expressions
    to populate a separate slice for use later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您进行一些预处理工作。对于每一个您希望搜索的错误关键词，您需要构建并编译一个正则表达式❸。您可以在主 HTTP 逻辑之外完成这项工作，这样就不必为每个有效载荷多次创建和编译这些正则表达式。虽然这只是一个小优化，但仍然是一个良好的实践。您将使用这些编译好的正则表达式来填充一个单独的切片，以便后续使用。
- en: Next comes the core logic of the fuzzer. You loop through each of the payloads
    ❹, using each to build an appropriate HTTP request body whose `username` value
    is your current payload ❺. You use the resulting value to build an HTTP POST request
    ❻, targeting your login form. You then set the `Content-Type` header and send
    the request by calling `client.Do(req)`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是模糊器的核心逻辑。您遍历每一个有效载荷❹，使用每个有效载荷构建一个合适的 HTTP 请求体，其中`username`值为当前有效载荷❺。然后，您使用生成的值构建一个
    HTTP POST 请求❻，并将其定向到登录表单。接着，您设置`Content-Type`头，并通过调用`client.Do(req)`发送请求。
- en: Notice that you send the request by using the long-form process of creating
    a client and an individual request and then calling `client.Do()`. You certainly
    could have used Go’s `http.PostForm()` function to achieve the same behavior more
    concisely. However, the more verbose technique gives you more granular control
    over HTTP header values. Although in this example you’re setting only the `Content-Type`
    header, it’s not uncommon to set additional header values when making HTTP requests
    (such as `User-Agent`, `Cookie`, and others). You can’t do this with `http.PostForm()`,
    so going the long route will make it easier to add any necessary HTTP headers
    in the future, particularly if you’re ever interested in fuzzing the headers themselves.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您是通过使用创建客户端和单独请求的长形式过程来发送请求的，然后调用`client.Do()`。当然，您也可以使用 Go 的`http.PostForm()`函数来更简洁地实现相同的行为。然而，更冗长的技术为您提供了对
    HTTP 头值的更细粒度控制。尽管在这个示例中您只设置了`Content-Type`头，但在进行 HTTP 请求时，设置额外的头值（如`User-Agent`、`Cookie`等）是很常见的。使用`http.PostForm()`是无法做到这一点的，因此采用长方式将使您以后更容易添加任何必要的
    HTTP 头，特别是如果您将来有兴趣进行头部模糊测试。
- en: Next, you read the HTTP response body by using `ioutil.ReadAll()` ❼. Now that
    you have the body, you loop through all of your precompiled regular expressions
    ❽, testing the response body for the presence of your SQL error keywords ❾. If
    you get a match, you probably have a SQL injection error message. The program
    will log details of the payload and error to the screen and move onto the next
    iteration of the loop.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您使用`ioutil.ReadAll()`❼读取 HTTP 响应体。现在您有了响应体，您遍历所有预编译的正则表达式❽，测试响应体中是否存在 SQL
    错误关键词❾。如果您匹配到了，您很可能遇到了 SQL 注入错误信息。程序将把有效载荷和错误的详细信息记录到屏幕上，并继续下一次循环迭代。
- en: 'Run your code to confirm that it successfully identifies a SQL injection flaw
    in a vulnerable login form. If you supply the `username` value with a single quotation
    mark, you’ll get the error indicator `SQL,` as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行您的代码，确认它成功地识别出一个易受攻击的登录表单中的 SQL 注入漏洞。如果您提供带有单引号的`username`值，您将看到错误指示符`SQL,`，如下面所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We encourage you to try the following exercises to help you better understand
    the code, appreciate the nuances of HTTP communications, and improve your ability
    to detect SQL injection:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您尝试以下练习，以帮助您更好地理解代码，了解 HTTP 通信的细微差别，并提高检测 SQL 注入漏洞的能力：
- en: Update the code to test for time-based SQL injection. To do this, you’ll have
    to send various payloads that introduce a time delay when the backend query executes.
    You’ll need to measure the round-trip time and compare it against a baseline request
    to deduce whether SQL injection is present.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新代码以测试基于时间的 SQL 注入。为此，您需要发送不同的有效载荷，在后端查询执行时引入时间延迟。您需要测量往返时间，并将其与基准请求进行比较，以推断是否存在
    SQL 注入。
- en: Update the code to test for boolean-based blind SQL injection. Although you
    can use different indicators for this, a simple way is to compare the HTTP response
    code against a baseline response. A deviation from the baseline response code,
    particularly receiving a response code of 500 (internal server error), may be
    indicative of SQL injection.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新代码以测试基于布尔值的盲 SQL 注入。虽然你可以使用不同的指示符来进行测试，但一种简单的方法是将 HTTP 响应代码与基准响应进行比较。如果响应代码偏离基准响应，尤其是接收到
    500（内部服务器错误）响应代码，这可能表示发生了 SQL 注入。
- en: Rather than relying on Go’s `net.http` package to facilitate communications,
    try using the `net` package to dial a raw TCP connection. When using the `net`
    package, you’ll need to be aware of the `Content-Length` HTTP header, which represents
    the length of the message body. You’ll need to calculate this length correctly
    for each request because the body length may change. If you use an invalid length
    value, the server will likely reject the request.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要依赖 Go 的 `net.http` 包来实现通信，尝试使用 `net` 包来建立原始 TCP 连接。当使用 `net` 包时，你需要注意 `Content-Length`
    HTTP 头部，它表示消息体的长度。你需要正确计算每个请求的长度，因为消息体长度可能会变化。如果使用无效的长度值，服务器很可能会拒绝该请求。
- en: In the next section, we’ll show you how to port exploits to Go from other languages,
    such as Python or C.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何将漏洞从其他语言（如 Python 或 C）移植到 Go。
- en: Porting Exploits to Go
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将漏洞移植到 Go
- en: For various reasons, you may want to port an existing exploit to Go. Perhaps
    the existing exploit code is broken, incomplete, or incompatible with the system
    or version you wish to target. Although you could certainly extend or update the
    broken or incomplete code using the same language with which it was created, Go
    gives you the luxury of easy cross-compilation, consistent syntax and indentation
    rules, and a powerful standard library. All of this will make your exploit code
    arguably more portable and readable without compromising on features.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种原因，你可能希望将现有的漏洞移植到 Go。也许现有的漏洞代码已损坏、不完整，或者与目标系统或版本不兼容。尽管你完全可以使用原编写语言扩展或更新已损坏或不完整的代码，但
    Go 提供了轻松跨平台编译、一致的语法和缩进规则，以及强大的标准库等优势。所有这些都会让你的漏洞代码更具可移植性和可读性，而不会妥协功能。
- en: Likely the most challenging task when porting an existing exploit is determining
    the equivalent Go libraries and function calls to achieve the same level of functionality.
    For example, addressing endianness, encoding, and encryption equivalents may take
    a bit of research, particularly for those who aren’t well versed in Go. Fortunately,
    we’ve addressed the complexity of network-based communications in previous chapters.
    The implementations and nuances of this should, hopefully, be familiar.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 移植现有漏洞时，最具挑战性的任务可能是确定等效的 Go 库和函数调用，以实现相同的功能。例如，处理字节序、编码和加密的等效内容可能需要一些研究，特别是对于那些不熟悉
    Go 的人来说。幸运的是，我们在前几章中已解决了基于网络的通信复杂性。希望你对这些实现和细节已有一定了解。
- en: 'You’ll find countless ways to use Go’s standard packages for exploit development
    or porting. While it’s unrealistic for us to comprehensively cover these packages
    and use cases in a single chapter, we encourage you to explore Go’s official documentation
    at *[https://golang.org/pkg/](https://golang.org/pkg/)*. The documentation is
    extensive, with an abundance of good examples to help you understand function
    and package usage. Here are just a few of the packages that will likely be of
    greatest interest to you when working with exploitation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现许多使用 Go 标准包进行漏洞开发或移植的方法。虽然在本章中全面涵盖这些包和用例是不现实的，但我们鼓励你探索 Go 的官方文档 *[https://golang.org/pkg/](https://golang.org/pkg/)*。该文档内容丰富，提供了大量良好的示例，帮助你理解函数和包的用法。以下是一些你在进行漏洞工作时可能最感兴趣的包：
- en: bytes Provides low-level byte manipulation
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: bytes 提供低级字节操作
- en: crypto Implements various symmetric and asymmetric ciphers and message authentication
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: crypto 实现各种对称和非对称加密算法以及消息认证
- en: debug Inspects various file type metadata and contents
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: debug 检查各种文件类型的元数据和内容
- en: encoding Encodes and decodes data by using various common forms such as binary,
    Hex, Base64, and more
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: encoding 使用各种常见的格式（如二进制、十六进制、Base64 等）对数据进行编码和解码
- en: io and bufio Reads and writes data from and to various common interface types
    including the file system, standard output, network connections, and more
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: io 和 bufio 读取和写入来自各种常见接口类型的数据，包括文件系统、标准输出、网络连接等
- en: net Facilitates client-server interaction by using various protocols such as
    HTTP and SMTP
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: net 通过使用 HTTP 和 SMTP 等多种协议促进客户端与服务器的交互
- en: os Executes and interacts with the local operating system
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: os 执行并与本地操作系统交互
- en: syscall Exposes an interface for making low-level system calls
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: syscall 提供一个接口，用于进行低级系统调用
- en: unicode Encodes and decodes data by using UTF-16 or UTF-8
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: unicode 使用 UTF-16 或 UTF-8 编码和解码数据
- en: unsafe Useful for avoiding Go’s type safety checks when interacting with the
    operating system
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: unsafe 用于避免 Go 在与操作系统交互时的类型安全检查
- en: Admittedly, some of these packages will prove to be more useful in later chapters,
    particularly when we discuss low-level Windows interactions, but we’ve included
    this list for your awareness. Rather than trying to cover these packages in detail,
    we’ll show you how to port an existing exploit by using some of these packages.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这些包在后续章节中会更加有用，特别是当我们讨论低级 Windows 交互时，但我们列出了这个清单供你参考。与其详细介绍这些包，我们将向你展示如何使用其中的一些包移植现有的漏洞利用代码。
- en: Porting an Exploit from Python
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 Python 移植漏洞
- en: In this first example, you’ll port an exploit of the Java deserialization vulnerability
    released in 2015\. The vulnerability, categorized under several CVEs, affects
    the deserialization of Java objects in common applications, servers, and libraries.[¹](footnote.xhtml#ch9fn1)
    This vulnerability is introduced by a deserialization library that doesn’t validate
    input prior to server-side execution (a common cause of vulnerabilities). We’ll
    narrow our focus to exploiting JBoss, a popular Java Enterprise Edition application
    server. At *[https://github.com/roo7break/serialator/blob/master/serialator.py](https://github.com/roo7break/serialator/blob/master/serialator.py)*,
    you’ll find a Python script that contains logic to exploit the vulnerability in
    multiple applications. [Listing 9-3](ch09.xhtml#ch9list3) provides the logic you’ll
    replicate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，你将移植一个 2015 年发布的 Java 反序列化漏洞的利用代码。这个漏洞被归类为多个 CVE，影响了常见应用、服务器和库中 Java
    对象的反序列化。[¹](footnote.xhtml#ch9fn1) 这个漏洞是由一个不验证输入的反序列化库引入的，输入未经过服务器端执行前的验证（这是漏洞的常见原因）。我们将重点讨论利用
    JBoss，这是一款流行的 Java 企业版应用服务器。在 *[https://github.com/roo7break/serialator/blob/master/serialator.py](https://github.com/roo7break/serialator/blob/master/serialator.py)*，你会找到一个
    Python 脚本，包含了利用该漏洞的逻辑，适用于多个应用程序。[Listing 9-3](ch09.xhtml#ch9list3) 提供了你将要复制的逻辑。
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 9-3: The Python serialization exploit code*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-3: Python 序列化漏洞利用代码*'
- en: Let’s take a look at what you’re working with here. The function receives a
    host, port, SSL indicator, and operating system command as parameters. To build
    the proper request, the function has to create a payload that represents a serialized
    Java object. This script starts by hardcoding a series of bytes onto a variable
    named `body_serObj` ❶. These bytes have been snipped for brevity, but notice they
    are represented in the code as a string value. This is a hexadecimal string, which
    you’ll need to convert to a byte array so that two characters of the string become
    a single byte representation. For example, you’ll need to convert `AC` to the
    hexadecimal byte `\xAC`. To accomplish this conversion, the exploit code calls
    a function named `hex2raw3`. Details of this function’s underlying implementation
    are inconsequential, so long as you understand what’s happening to the hexadecimal
    string.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你正在处理的内容。这个函数接收主机、端口、SSL指示符和操作系统命令作为参数。为了构建正确的请求，函数必须创建一个表示序列化 Java 对象的有效负载。该脚本通过将一系列字节硬编码到一个名为`body_serObj`的变量中开始❶。这些字节为了简洁已被省略，但请注意它们在代码中以字符串值表示。这是一个十六进制字符串，你需要将其转换为字节数组，使得字符串中的两个字符成为一个字节的表示。例如，你需要将`AC`转换为十六进制字节`\xAC`。为了完成这个转换，漏洞代码调用了一个名为`hex2raw3`的函数。只要你明白十六进制字符串正在发生什么，函数的具体实现细节并不重要。
- en: Next, the script calculates the length of the operating system command, and
    then appends the length and command to the `body_serObj` variable ❷. The script
    completes the construction of the payload by appending additional data that represents
    the remainder of your Java serialized object in a format that JBoss can process
    ❸. Once the payload is constructed, the script builds the URL and sets up SSL
    to ignore invalid certificates, if necessary ❹. It then sets the required `Content-Type`
    and `Content-Length` HTTP headers ❺ and sends the malicious request to the target
    server ❻.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，脚本计算操作系统命令的长度，然后将长度和命令附加到 `body_serObj` 变量 ❷。脚本通过附加其他数据，表示 Java 序列化对象的剩余部分，以
    JBoss 可以处理的格式，完成有效负载的构建 ❸。一旦有效负载构建完成，脚本生成 URL 并设置 SSL，以忽略无效证书（如有需要） ❹。然后，它设置所需的
    `Content-Type` 和 `Content-Length` HTTP 头 ❺，并将恶意请求发送到目标服务器 ❻。
- en: Most of what’s presented in this script shouldn’t be new to you, as we’ve covered
    the majority of it in previous chapters. It’s now just a matter of making the
    equivalent function calls in a Go friendly manner. [Listing 9-4](ch09.xhtml#ch9list4)
    shows the Go version of the exploit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中展示的大部分内容对你来说应该不陌生，因为我们在之前的章节中已经覆盖了大部分内容。现在只是以 Go 友好的方式进行等效的函数调用。[清单 9-4](ch09.xhtml#ch9list4)
    显示了利用的 Go 版本。
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-4: The Go equivalent of the original Python serialization exploit
    (*[/ch-9/jboss/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-9/jboss/main.go)*)*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-4：原始 Python 序列化利用的 Go 等效版本 (*[/ch-9/jboss/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-9/jboss/main.go)*)*'
- en: The code is nearly a line-by-line reproduction of the Python version. For this
    reason, we’ve set the annotations to align with their Python counterparts, so
    you’ll be able to follow the changes we’ve made.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码几乎是 Python 版本逐行复制的。因此，我们已经将注释设置与 Python 版本对齐，这样你就能够跟随我们所做的更改。
- en: First, you construct your payload by defining your serialized Java object `byte`
    slice ❶, hardcoding the portion before your operating system command. Unlike the
    Python version, which relied on user-defined logic to convert your hexadecimal
    string to a `byte` array, the Go version uses the `hex.DecodeString()` from the
    `encoding/hex` package. Next, you determine the length of your operating system
    command, and then append it and the command itself to your payload ❷. You complete
    the construction of your payload by decoding your hardcoded hexadecimal trailer
    string onto your existing payload ❸. The code for this is slightly more verbose
    than the Python version because we intentionally added in additional error handling,
    but it’s also able to use Go’s standard `encoding` package to easily decode your
    hexadecimal string.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过定义序列化的 Java 对象 `byte` 切片 ❶ 来构建有效负载，在操作系统命令之前的部分进行硬编码。与依赖用户定义逻辑将十六进制字符串转换为
    `byte` 数组的 Python 版本不同，Go 版本使用 `encoding/hex` 包中的 `hex.DecodeString()`。接下来，确定操作系统命令的长度，然后将其和命令本身附加到有效负载
    ❷。通过将硬编码的十六进制结尾字符串解码到现有有效负载上 ❸，完成有效负载的构建。这段代码比 Python 版本稍显冗长，因为我们特意添加了额外的错误处理，但它也能够使用
    Go 的标准 `encoding` 包轻松解码十六进制字符串。
- en: You proceed to initialize your HTTP client ❹, configuring it for SSL communications
    if requested, and then build a POST request. Prior to sending the request, you
    set your necessary HTTP headers ❺ so that the JBoss server interprets the content
    type appropriately. Notice that you don’t explicitly set the `Content-Length`
    HTTP header. That’s because Go’s `http` package does that for you automatically.
    Finally, you send your malicious request by calling `client.Do(req)` ❻.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你初始化 HTTP 客户端 ❹，如果需要，配置它进行 SSL 通信，然后构建一个 POST 请求。在发送请求之前，设置必要的 HTTP 头 ❺，以便
    JBoss 服务器能正确解析内容类型。注意，你没有显式设置 `Content-Length` HTTP 头。这是因为 Go 的 `http` 包会自动为你处理这一点。最后，你通过调用
    `client.Do(req)` ❻ 发送恶意请求。
- en: For the most part, this code makes use of what you’ve already learned. The code
    introduces small modifications such as configuring SSL to ignore invalid certificates
    ❹ and adding specific HTTP headers ❺. Perhaps the one novel element in our code
    is the use of `hex.DecodeString()`, which is a Go core function that translates
    a hexadecimal string to its equivalent byte representation. You’d have to do this
    manually in Python. [Table 9-2](ch09.xhtml#ch19tab2) shows some additional, commonly
    encountered Python functions or constructs with their Go equivalents.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码都使用了你已经学过的内容。代码引入了一些小的修改，例如配置 SSL 以忽略无效证书❹，以及添加特定的 HTTP 头❺。或许我们代码中唯一的新颖元素是使用了
    `hex.DecodeString()`，这是 Go 的核心函数，用于将十六进制字符串转换为等效的字节表示。在 Python 中，你需要手动完成这一操作。[表
    9-2](ch09.xhtml#ch19tab2) 显示了一些额外的常见 Python 函数或结构及其 Go 等效项。
- en: This is not a comprehensive list of functional mappings. Too many variations
    and edge cases exist to cover all the possible functions required for porting
    exploits. We’re hopeful that this will help you translate at least some of the
    most common Python functions to Go.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是功能映射的全面列表。由于存在太多的变种和边缘情况，无法涵盖移植漏洞利用所需的所有可能函数。我们希望这能帮助你将一些最常见的 Python 函数转换为
    Go。
- en: '**Table 9-2:** Common Python Functions and Their Go Equivalents'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-2：** 常见 Python 函数及其 Go 等效项'
- en: '| **Python** | **Go** | **Notes** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **Go** | **备注** |'
- en: '| `hex(x)` | `fmt.Sprintf("` %#x`",` x`)` | Converts an integer, x, to a lowercase
    hexadecimal string, prefixed with `"0x`". |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `hex(x)` | `fmt.Sprintf("` %#x`",` x`)` | 将整数 x 转换为小写十六进制字符串，并以 `"0x`" 为前缀。
    |'
- en: '| `ord(`c`)` | `rune(`c`)` | Used to retrieve the integer (`int32`) value of
    a single character. Works for standard 8-bit strings or multibyte Unicode. Note
    that `rune` is a built-in type in Go and makes working with ASCII and Unicode
    data fairly simple. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `ord(`c`)` | `rune(`c`)` | 用于检索单个字符的整数（`int32`）值。适用于标准的 8 位字符串或多字节 Unicode。请注意，`rune`
    是 Go 中的内建类型，它使得处理 ASCII 和 Unicode 数据变得相对简单。 |'
- en: '| `chr(`i`) and unichr(`i`)` | `fmt.Sprintf("`%+q`", rune(`i`))` | The inverse
    of `ord` in Python, `chr` and `unichr` return a string of length 1 for the integer
    input. In Go, you use the `rune` type and can retrieve it as a string by using
    the `%+q` format sequence. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `chr(`i`) 和 unichr(`i`)` | `fmt.Sprintf("`%+q`", rune(`i`))` | Python 中 `ord`
    的反操作，`chr` 和 `unichr` 对整数输入返回长度为 1 的字符串。在 Go 中，你使用 `rune` 类型，并可以通过使用 `%+q` 格式序列将其作为字符串返回。
    |'
- en: '| `struct.pack(`fmt`,` v1`,` v2`,` . . .`)` | `binary.Write(`. . .`)` | Creates
    a binary representation of the data, formatted appropriately for type and endianness.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `struct.pack(`fmt`,` v1`,` v2`,` . . .`)` | `binary.Write(`. . .`)` | 创建数据的二进制表示，并根据类型和字节顺序进行适当格式化。
    |'
- en: '| `struct.unpack(`fmt`,` string`)` | `binary.Read(`. . .`)` | The inverse of
    `struct.pack` and `binary.Write`. Reads structured binary data into a specified
    format and type. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `struct.unpack(`fmt`,` string`)` | `binary.Read(`. . .`)` | `struct.pack`
    和 `binary.Write` 的反操作。将结构化的二进制数据读取到指定的格式和类型中。 |'
- en: Porting an Exploit from C
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 C 移植一个漏洞利用
- en: Let’s step away from Python and focus on C. C is arguably a less readable language
    than Python, yet C shares more similarities with Go than Python does. This makes
    porting exploits from C easier than you might think. To demonstrate, we’ll be
    porting a local privilege escalation exploit for Linux. The vulnerability, dubbed
    *Dirty COW*, pertains to a race condition within the Linux kernel’s memory subsystem.
    This flaw affected most, if not all, common Linux and Android distributions at
    the time of disclosure. The vulnerability has since been patched, so you’ll need
    to take some specific measures to reproduce the examples that follow. Specifically,
    you’ll need to configure a Linux system with a vulnerable kernel version. Setting
    this up is beyond the scope of the chapter; however, for reference, we use a 64-bit
    Ubuntu 14.04 LTS distribution with kernel version 3.13.1.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时离开 Python，专注于 C。C 可以说是一种比 Python 更难读懂的语言，但 C 与 Go 的相似性要比 Python 更多。这使得从
    C 移植漏洞利用比你想象的要容易。为了演示，我们将移植一个本地特权提升漏洞利用，针对的是 Linux 系统。这个漏洞被称为 *Dirty COW*，涉及到
    Linux 内核内存子系统中的竞态条件。该漏洞在公开时影响了大多数（如果不是所有的话）常见的 Linux 和 Android 发行版。该漏洞现已修复，因此你需要采取一些特定的措施来重现以下示例。具体来说，你需要配置一个有漏洞的内核版本的
    Linux 系统。设置过程超出了本章的范围，但作为参考，我们使用的是 64 位的 Ubuntu 14.04 LTS 发行版，内核版本为 3.13.1。
- en: Several variations of the exploit are publicly available. You can find the one
    we intend to replicate at *[https://www.exploit-db.com/exploits/40616/](https://www.exploit-db.com/exploits/40616/)*.
    [Listing 9-5](ch09.xhtml#ch9list5) shows the original exploit code, slightly modified
    for readability, in its entirety.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该漏洞的多个变种是公开可用的。您可以在*[https://www.exploit-db.com/exploits/40616/](https://www.exploit-db.com/exploits/40616/)*找到我们打算复现的版本。[Listing
    9-5](ch09.xhtml#ch9list5)展示了经过轻微修改以提高可读性的原始漏洞代码，完整展示如下。
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 9-5: The Dirty COW privilege escalation exploit written in the C language*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-5: 用C语言编写的Dirty COW特权提升漏洞利用代码*'
- en: Rather than explaining the details of the C code’s logic, let’s look at it generally,
    and then break it into chunks to compare it line by line with the Go version.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与其详细解释C代码的逻辑，不如先概括地看一下，然后将其拆分成小块，逐行与Go版本进行比较。
- en: The exploit defines some malicious shellcode, in Executable and Linkable Format
    (ELF), that generates a Linux shell. It executes the code as a privileged user
    by creating multiple threads that call various system functions to write our shellcode
    to memory locations. Eventually, the shellcode exploits the vulnerability by overwriting
    the contents of a binary executable file that happens to have the SUID bit set
    and belongs to the root user. In this case, that binary is */usr/bin/passwd*.
    Normally, a nonroot user wouldn’t be able to overwrite the file. However, because
    of the Dirty COW vulnerability, you achieve privilege escalation because you can
    write arbitrary contents to the file while preserving the file permissions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个利用漏洞的攻击定义了一些恶意的Shellcode，采用可执行和可链接格式（ELF），该代码生成一个Linux shell。它通过创建多个线程来执行代码，这些线程调用各种系统函数，将我们的Shellcode写入内存位置。最终，Shellcode通过覆盖一个恰好设置了SUID位且属于root用户的二进制可执行文件的内容来利用这个漏洞。在这种情况下，该二进制文件是*/usr/bin/passwd*。通常，非root用户无法覆盖该文件。然而，由于Dirty
    COW漏洞，您可以通过写入任意内容到该文件，同时保留文件权限，从而实现特权提升。
- en: Now let’s break the C code into easily digestible portions and compare each
    section with its equivalent in Go. Note that the Go version is specifically trying
    to achieve a line-by-line reproduction of the C version. [Listing 9-6](ch09.xhtml#ch9list6)
    shows the global variables defined or initialized outside our functions in C,
    while [Listing 9-7](ch09.xhtml#ch9list7) shows them in Go.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将C代码拆分成易于消化的部分，并逐一与Go中的等效部分进行比较。请注意，Go版本特别试图逐行再现C版本。[Listing 9-6](ch09.xhtml#ch9list6)展示了在C中定义或初始化的全局变量，而[Listing
    9-7](ch09.xhtml#ch9list7)则展示了Go中的对应内容。
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 9-6: Initialization in C*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-6: C中的初始化*'
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-7: Initialization in Go*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-7: Go中的初始化*'
- en: The translation between C and Go is fairly straightforward. The two code sections,
    C and Go, maintain the same numbering to demonstrate how Go achieves similar functionality
    to the respective lines of C code. In both cases, you track mapped memory by defining
    a `uintptr` variable ❶. In Go, you declare the variable name as `mapp` since,
    unlike C, `map` is a reserved keyword in Go. You then initialize a variable to
    be used for signaling the threads to stop processing ❷. Rather than use an integer,
    as the C code does, the Go convention is instead to use a buffered boolean channel.
    You explicitly define its length to be `2` since there will be two concurrent
    functions that you’ll wish to signal. Next, you define a string to your SUID executable
    ❸ and wrap up your global variables by hardcoding your shellcode into a slice
    ❹. A handful of global variables were omitted in the Go code compared to the C
    version, which means you’ll define them as needed within their respective code
    blocks.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: C与Go之间的翻译相当简单。C和Go的两段代码保持相同的行号，展示Go如何实现与C代码相应行的类似功能。在这两种情况下，您都通过定义一个`uintptr`变量❶来跟踪映射内存。在Go中，您将变量名声明为`mapp`，因为与C不同，`map`是Go中的保留关键字。接下来，您初始化一个变量，用于信号线程停止处理❷。与C代码中使用整数不同，Go的惯例是使用带缓冲的布尔通道。您显式地定义其长度为`2`，因为将会有两个并发函数需要进行信号传递。接下来，您定义一个指向SUID可执行文件的字符串❸，并通过将Shellcode硬编码到切片中来完成全局变量的定义❹。与C版本相比，Go代码中省略了一些全局变量，这意味着您将在相应的代码块中按需定义它们。
- en: Next, let’s look at `madvise()` and `procselfmem()`, the two primary functions
    that exploit the race condition. Again, we’ll compare the C version in [Listing
    9-8](ch09.xhtml#ch9list8) with the Go version in [Listing 9-9](ch09.xhtml#ch9list9).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看`madvise()`和`procselfmem()`，这两个主要利用竞态条件的函数。我们将再次将[C版本](ch09.xhtml#ch9list8)与[Go版本](ch09.xhtml#ch9list9)进行比较。
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 9-8: Race condition functions in C*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-8：C语言中的竞态条件函数*'
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 9-9: Race condition functions in Go*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-9：Go语言中的竞态条件函数*'
- en: The race condition functions use variations for signaling ❶. Both functions
    contain `for` loops that iterate an extensive number of times. The C version checks
    the value of the `stop` variable, while the Go version uses a `select` statement
    that attempts to read from the `signals` channel. When a signal is present, the
    function returns. In the event that no signal is waiting, the `default` case executes.
    The primary differences between the `madvise()` and `procselfmem()` functions
    occur within the `default` case. Within our `madvise()` function, you issue a
    Linux system call to the `madvise()` ❷ function, whereas your `procselfmem()`
    function issues Linux system calls to `lseek()` ❸ and writes your payload to memory
    ❹.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件函数使用变体进行信号传递❶。这两个函数都包含`for`循环，循环执行次数非常多。C语言版本检查`stop`变量的值，而Go语言版本则使用`select`语句尝试从`signals`通道读取信号。当信号存在时，函数会返回。如果没有信号等待，`default`情况会被执行。`madvise()`和`procselfmem()`函数之间的主要区别发生在`default`情况中。在我们的`madvise()`函数中，你会向`madvise()`❷函数发出Linux系统调用，而在`procselfmem()`函数中，你会发出Linux系统调用到`lseek()`❸，并将负载写入内存❹。
- en: 'Here are the main differences between the C and Go versions of these functions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是C语言版本和Go语言版本函数的主要区别：
- en: The Go version uses a channel to determine when to prematurely break the loop,
    while the C function uses an integer value to signal when to break the loop after
    the thread race condition has occurred.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言版本使用通道来确定何时提前退出循环，而C语言函数使用整数值来表示在发生线程竞态条件后何时退出循环。
- en: The Go version uses the `syscall` package to issue Linux system calls. The parameters
    passed to the function include the system function to be called and its required
    parameters. You can find the name, purpose, and parameters of the function by
    searching Linux documentation. This is how we are able to call native Linux functions.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言版本使用`syscall`包来发出Linux系统调用。传递给函数的参数包括要调用的系统函数和其所需的参数。你可以通过查找Linux文档来了解函数的名称、功能和参数。这就是我们能够调用本地Linux函数的方式。
- en: Now, let’s review the `waitForWrite()` function, which monitors for the presence
    of changes to SUID in order to execute the shellcode. The C version is shown in
    [Listing 9-10](ch09.xhtml#ch9list10), and the Go version is shown in [Listing
    9-11](ch09.xhtml#ch9list11).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下`waitForWrite()`函数，该函数监视SUID是否有变化，从而执行shellcode。C语言版本显示在[列表 9-10](ch09.xhtml#ch9list10)，Go语言版本显示在[列表
    9-11](ch09.xhtml#ch9list11)。
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 9-10: The* waitForWrite() *function in C*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-10：C语言中的* waitForWrite() *函数*'
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 9-11: The* waitForWrite() *function in Go*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-11：Go语言中的* waitForWrite() *函数*'
- en: 'In both cases, the code defines an infinite loop that monitors the SUID binary
    file for changes ❶. While the C version uses `memcmp()` to check whether the shellcode
    has been written to the target, the Go code uses `bytes.Compare()`. When the shellcode
    is present, you’ll know the exploit succeeded in overwriting the file. You then
    break out of the infinite loop and signal the running threads that they can now
    stop ❷. As with the code for the race conditions, the Go version does this via
    a channel, while the C version uses an integer. Lastly, you execute what is probably
    the best part of the function: the SUID target file that now has your malicious
    code within it ❸. The Go version is a little bit more verbose, as you need to
    pass in attributes corresponding to stdin, stdout, and stderr: files pointers
    to open input files, output files, and error file descriptors, respectively.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，代码都定义了一个无限循环，用来监控SUID二进制文件的变化❶。C语言版本使用`memcmp()`检查shellcode是否已经写入目标，而Go代码使用`bytes.Compare()`。当shellcode出现时，你就知道漏洞利用成功，文件已被覆盖。然后，你会跳出无限循环，并通知运行中的线程可以停止了❷。与竞态条件代码一样，Go语言版本通过通道实现这一点，而C语言版本使用整数。最后，你执行的可能是函数中最精彩的部分：现在已经包含恶意代码的SUID目标文件❸。Go语言版本略显冗长，因为你需要传递与stdin、stdout和stderr对应的属性：分别是指向输入文件、输出文件和错误文件描述符的文件指针。
- en: Now let’s look at our `main()` function, which calls the previous functions
    necessary to execute this exploit. [Listing 9-12](ch09.xhtml#ch9list12) shows
    the C version, and [Listing 9-13](ch09.xhtml#ch9list13) shows the Go version.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`main()`函数，它调用了执行这个漏洞利用所需的前述函数。[列表 9-12](ch09.xhtml#ch9list12)显示了C语言版本，[列表
    9-13](ch09.xhtml#ch9list13)显示了Go语言版本。
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 9-12: The* main() *function in C*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-12：C语言中的* main() *函数*'
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 9-13: The* main() *function in Go*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-13：Go 中的* main() *函数*'
- en: The `main()` function starts by backing up the target executable ❶. Since you’ll
    eventually be overwriting it, you don’t want to lose the original version; doing
    so may adversely affect the system. While C allows you to run an operating system
    command by calling `system()` and passing it the entire command as a single string,
    the Go version relies on the `exec.Command()` function, which requires you to
    pass the command as separate arguments. Next, you open the SUID target file in
    read-only mode ❷, retrieving the file stats, and then use them to initialize a
    payload slice of identical size as the target file ❸. In C, you fill the array
    with NOP (0x90) instructions by calling `memset()`, and then copy over a portion
    of the array with your shellcode by calling `memcpy()`. These are convenience
    functions that don’t exist in Go.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数首先备份目标可执行文件 ❶。由于最终会覆盖它，因此你不想丢失原始版本；丢失原文件可能会对系统产生不良影响。虽然 C 语言可以通过调用
    `system()` 并传入整个命令字符串来运行操作系统命令，但 Go 版本则依赖于 `exec.Command()` 函数，它要求你将命令作为单独的参数传入。接下来，你以只读模式打开
    SUID 目标文件 ❷，检索文件统计信息，并用它们来初始化一个与目标文件大小相同的有效载荷切片 ❸。在 C 中，你可以通过调用 `memset()` 填充一个数组为
    NOP（0x90）指令，然后通过调用 `memcpy()` 将一部分数组替换为你的 shellcode。在 Go 中，这些便捷的函数是不存在的。'
- en: Instead, in Go, you loop over the slice elements and manually populate them
    one byte at a time. After doing so, you issue a Linux system call to the `mapp()`
    function ❹, which maps the contents of your target SUID file to memory. As for
    previous system calls, you can find the parameters needed for `mapp()` by searching
    the Linux documentation. You may notice that the Go code issues a call to `syscall.Syscall6()`
    rather than `syscall.Syscall()`. The `Syscall6()` function is used for system
    calls that expect six input parameters, as is the case with `mapp()`. Lastly,
    the code spins up a couple of threads, calling the `madvise()` and `procselfmem()`
    functions concurrently ❺. As the race condition ensues, you call your `waitForWrite()`
    function, which monitors for changes to your SUID file, signals the threads to
    stop, and executes your malicious code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在 Go 中，你需要遍历切片元素，并手动逐个字节地填充它们。完成后，你发出一个 Linux 系统调用，调用 `mapp()` 函数 ❹，将目标 SUID
    文件的内容映射到内存中。关于之前的系统调用，你可以通过查阅 Linux 文档找到 `mapp()` 所需的参数。你可能会注意到，Go 代码调用的是 `syscall.Syscall6()`
    而不是 `syscall.Syscall()`。`Syscall6()` 函数用于需要六个输入参数的系统调用，正如 `mapp()` 的情况。最后，代码启动了几个线程，同时调用
    `madvise()` 和 `procselfmem()` 函数 ❺。随着竞争条件的产生，你调用 `waitForWrite()` 函数，监视 SUID 文件的变化，通知线程停止，并执行你的恶意代码。
- en: For completeness, [Listing 9-14](ch09.xhtml#ch9list14) shows the entirety of
    the ported Go code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，[清单 9-14](ch09.xhtml#ch9list14) 显示了完整的 Go 移植代码。
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 9-14: The complete Go port* (/[ch-9/dirtycow/main.go/](https://github.com/blackhat-go/bhg/blob/master/ch-9/dirtycow/main.go/))'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-14：完整的 Go 移植版* (/[ch-9/dirtycow/main.go/](https://github.com/blackhat-go/bhg/blob/master/ch-9/dirtycow/main.go/))'
- en: To confirm that your code works, run it on your vulnerable host. There’s nothing
    more satisfying than seeing a root shell.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认代码是否有效，请在你的易受攻击的主机上运行它。没有什么比看到 root shell 更令人满足的了。
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, a successful run of the program backs up the */usr/bin/passwd*
    file, races for control of the handle, overwrites the file location with the newly
    intended values, and finally produces a system shell. The output of the Linux
    `id` command confirms that the `alice` user account has been elevated to a `uid=0`
    value, indicating root-level privilege.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序成功运行时，它会备份 */usr/bin/passwd* 文件，竞夺文件句柄控制，使用新的预定值覆盖文件位置，并最终产生一个系统 shell。Linux
    的 `id` 命令输出确认 `alice` 用户帐户已被提升到 `uid=0`，这表示获得了 root 权限。
- en: Creating Shellcode in Go
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Go 中创建 Shellcode
- en: In the previous section, you used raw shellcode in valid ELF format to overwrite
    a legitimate file with your malicious alternative. How might you generate that
    shellcode yourself? As it turns out, you can use your typical toolset to generate
    Go-friendly shellcode.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你使用了有效 ELF 格式的原始 shellcode 来覆盖一个合法文件，替换为你的恶意版本。你如何自己生成这些 shellcode 呢？事实证明，你可以使用你的常规工具集生成
    Go 兼容的 shellcode。
- en: We’ll show you how to do this with `msfvenom`, a command-line utility, but the
    integration techniques we’ll teach you aren’t tool-specific. You can use several
    methods to work with external binary data, be it shellcode or something else,
    and integrate it into your Go code. Rest assured that the following pages deal
    more with common data representations than anything specific to a tool.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 `msfvenom` 来展示如何实现这个操作，`msfvenom` 是一个命令行工具，但我们教给你的集成技术并不局限于特定工具。你可以使用几种方法来处理外部二进制数据，无论是
    Shellcode 还是其他任何东西，并将其集成到 Go 代码中。请放心，接下来的页面更多地讨论的是常见的数据表示方法，而非某个特定工具的用法。
- en: 'The Metasploit Framework, a popular exploitation and post-exploitation toolkit,
    ships with `msfvenom`, a tool that generates and transforms any of Metasploit’s
    available payloads to a variety of formats specified via the `-f` argument. Unfortunately,
    there is no explicit Go transform. However, you can integrate several formats
    into your Go code fairly easily with minor adjustments. We’ll explore five of
    these formats here: C, `hex`, `num`, `raw`, and Base64, while keeping in mind
    that our end goal is to create a byte slice in Go.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 框架是一个流行的漏洞利用和后渗透工具包，带有 `msfvenom` 工具，该工具可以将 Metasploit 的任何有效负载生成并转换为通过
    `-f` 参数指定的多种格式。不幸的是，没有明确的 Go 转换格式。然而，通过一些微调，你可以轻松地将几种格式集成到 Go 代码中。我们将在这里探索五种格式：C、`hex`、`num`、`raw`
    和 Base64，同时记住我们的最终目标是创建一个 Go 中的字节切片。
- en: C Transform
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C 转换
- en: 'If you specify a C transform type, `msfvenom` will produce the payload in a
    format that you can directly place into C code. This may seem like the logical
    first choice, since we detailed many of the similarities between C and Go earlier
    in this chapter. However, it’s not the best candidate for our Go code. To show
    you why, look at the following sample output in C format:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了 C 转换类型，`msfvenom` 会以一种你可以直接放入 C 代码中的格式生成有效负载。这看起来可能是最合乎逻辑的选择，因为我们在本章早些时候已经详细说明了
    C 和 Go 之间的许多相似之处。然而，它并不是我们 Go 代码的最佳选择。为了向你展示原因，看看以下 C 格式的示例输出：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’re interested almost exclusively in the payload. To make it Go-friendly,
    you’ll have to remove the semicolon and alter the line breaks. This means you’ll
    either need to explicitly append each line by adding a `+` to the end of all lines
    except the last, or remove the line breaks altogether to produce one long, continuous
    string. For small payloads this may be acceptable, but for larger payloads this
    becomes tedious to do manually. You’ll find yourself likely turning to other Linux
    commands such as `sed` and `tr` to clean it up.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎只关心有效负载。为了使其更适合 Go，你需要去掉分号并调整换行符。这意味着你要么需要在所有行的末尾（除了最后一行）显式地添加 `+`，要么完全去掉换行符，生成一个长的连续字符串。对于小型有效负载，这可能是可以接受的，但对于较大的有效负载，这样手动操作会变得很繁琐。你很可能会转向其他
    Linux 命令，如 `sed` 和 `tr` 来清理它。
- en: 'Once you clean up the payload, you’ll have your payload as a string. To create
    a byte slice, you’d enter something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清理了有效负载，你就会得到一个字符串形式的有效负载。要创建一个字节切片，你可以输入类似以下的内容：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It’s not a bad solution, but you can do better.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个坏的解决方案，但你可以做得更好。
- en: Hex Transform
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 十六进制转换
- en: 'Improving upon the previous attempt, let’s look at a `hex` transform. With
    this format, `msfvenom` produces a long, continuous string of hexadecimal characters:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的尝试基础上进行改进，我们来看一个 `hex` 转换。使用这种格式，`msfvenom` 会生成一个长的、连续的十六进制字符字符串：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If this format looks familiar, it’s because you used it when porting the Java
    deserialization exploit. You passed this value as a string into a call to `hex.DecodeString()`.
    It returns a byte slice and error details, if present. You could use it like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个格式看起来很熟悉，那是因为你在移植 Java 反序列化漏洞时使用过它。你将这个值作为字符串传递给 `hex.DecodeString()`。它会返回一个字节切片和错误信息（如果存在）。你可以这样使用它：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Translating this to Go is pretty simple. All you have to do is wrap your string
    in double quotes and pass it to the function. However, a large payload will produce
    a string that may not be aesthetically pleasing, wrapping lines or running beyond
    recommended page margins. You may still want to use this format, but we’ve provided
    a third alternative in the event that you want your code to be both functional
    and pretty.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转为 Go 代码其实非常简单。你只需要将字符串用双引号包裹，并传递给函数即可。然而，较大的有效负载会生成一个可能不太美观的字符串，可能会换行或超出推荐的页面边距。你仍然可以使用这种格式，但我们提供了第三种选择，以防你希望代码既实用又美观。
- en: Num Transform
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字转换
- en: 'A `num` transform produces a comma-separated list of bytes in numerical, hexadecimal
    format:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`num` 转换生成一个以逗号分隔的字节列表，采用数字十六进制格式：'
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can use this output in the direct initialization of a byte slice, like
    so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样直接使用这个输出来初始化字节切片：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because the `msfvenom` output is comma-separated, the list of bytes can wrap
    nicely across lines without clumsily appending data sets. The only modification
    required is the addition of a single comma after the last element in the list.
    This output format is easily integrated into your Go code and formatted pleasantly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`msfvenom`的输出是以逗号分隔的，字节列表可以在行之间很好地换行，而不会笨拙地附加数据集。唯一需要修改的是在列表的最后一个元素后添加一个逗号。这种输出格式可以轻松集成到你的
    Go 代码中并以愉快的方式格式化。
- en: Raw Transform
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原始转换
- en: 'A `raw` transform produces the payload in raw binary format. The data itself,
    if displayed on the terminal window, likely produces unprintable characters that
    look something like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`raw`转换会生成原始二进制格式的有效负载。如果在终端窗口中显示这些数据，可能会产生一些不可打印的字符，类似于这样：'
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can’t use this data in your code unless you produce it in a different format.
    So why, you may ask, are we even discussing raw binary data? Well, because it’s
    fairly common to encounter raw binary data, whether as a payload generated from
    a tool, the contents of a binary file, or crypto keys. Knowing how to recognize
    binary data and work it into your Go code will prove valuable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你以不同格式生成数据，否则无法在代码中使用这些数据。那么你可能会问，为什么我们要讨论原始二进制数据呢？嗯，原因是无论是从工具生成的有效负载、二进制文件的内容还是加密密钥，遇到原始二进制数据是相当常见的。了解如何识别二进制数据并将其处理到
    Go 代码中将非常有价值。
- en: 'Using the `xxd` utility in Linux with the `-i` command line switch, you can
    easily transform your raw binary data into the `num` format of the previous section.
    A sample `msfvenom` command would look like this, where you pipe the raw binary
    output produced by `msfvenom` into the `xxd` command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Linux 中的`xxd`工具和`-i`命令行开关，你可以轻松地将原始二进制数据转换为前一节中的`num`格式。一个示例`msfvenom`命令如下所示，你将`msfvenom`生成的原始二进制输出通过管道传入`xxd`命令：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can assign the result directly to a byte slice as demonstrated in the previous
    section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接将结果分配给字节切片，如前一节所示。
- en: Base64 Encoding
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Base64 编码
- en: Although `msfvenom` doesn’t include a pure Base64 encoder, it’s fairly common
    to encounter binary data, including shellcode, in Base64 format. Base64 encoding
    extends the length of your data, but also allows you to avoid ugly or unusable
    raw binary data. This format is easier to work with in your code than `num`, for
    example, and can simplify data transmission over protocols such as HTTP. For that
    reason, it’s worth discussing its usage in Go.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`msfvenom`不包含纯 Base64 编码器，但在实际应用中经常会遇到 Base64 格式的二进制数据，包括 shellcode。Base64
    编码会增加数据的长度，但也能避免丑陋或无法使用的原始二进制数据。例如，与`num`格式相比，这种格式在代码中更易于处理，并且可以简化通过 HTTP 等协议的数据传输。因此，值得讨论如何在
    Go 中使用它。
- en: 'The easiest method to produce a Base64-encoded representation of binary data
    is to use the `base64` utility in Linux. It allows you to encode or decode data
    via stdin or from a file. You could use `msfvenom` to produce raw binary data,
    and then encode the result by using the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 生成二进制数据的 Base64 编码表示的最简单方法是使用 Linux 中的`base64`工具。它允许你通过标准输入或文件来编码或解码数据。你可以使用`msfvenom`生成原始二进制数据，然后使用以下命令对结果进行编码：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Much like your C output, the resulting payload contains line breaks that you’ll
    have to deal with before including it as a string in your code. You can use the
    `tr` utility in Linux to clean up the output, removing all line breaks:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 很像你在 C 中的输出，生成的有效负载包含换行符，你需要在将其作为字符串包含到代码中之前处理这些换行符。你可以使用 Linux 中的`tr`工具清理输出，去除所有换行符：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The encoded payload will now exist as a single, continuous string. In your
    Go code, you can then get the raw payload as a byte slice by decoding the string.
    You use the `encoding/base64` package to get the job done:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 编码后的有效负载现在将以单一的连续字符串存在。在你的 Go 代码中，你可以通过解码该字符串来获得原始有效负载作为字节切片。你可以使用`encoding/base64`包来完成这项工作：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You’ll now have the ability to work with the raw binary data without all the
    ugliness.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将能够处理原始二进制数据，而无需担心所有那些丑陋的部分。
- en: A Note on Assembly
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于汇编的说明
- en: A discussion of shellcode and low-level programming isn’t complete without at
    least mentioning assembly. Unfortunately for the shellcode composers and assembly
    artists, Go’s integration with assembly is limited. Unlike C, Go doesn’t support
    inline assembly. If you want to integrate assembly into your Go code, you can
    do that, sort of. You’ll have to essentially define a function prototype in Go
    with the assembly instructions in a separate file. You then run `go build` to
    compile, link, and build your final executable. While this may not seem overly
    daunting, the problem is the assembly language itself. Go supports only a variation
    of assembly based on the Plan 9 operating system. This system was created by Bell
    Labs and used in the late 20th century. The assembly syntax, including available
    instructions and opcodes, is almost nonexistent. This makes writing pure Plan
    9 assembly a daunting, if not nearly impossible, task.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论 shellcode 和低级编程时，至少提到汇编是不可或缺的。不幸的是，对于 shellcode 编写者和汇编艺术家来说，Go 与汇编的集成是有限的。与
    C 语言不同，Go 不支持内联汇编。如果你想在 Go 代码中集成汇编，你是可以做到的，但有些限制。你需要在 Go 中定义一个函数原型，并将汇编指令放在一个单独的文件中。然后，你可以运行
    `go build` 来编译、链接并生成最终的可执行文件。虽然这看起来不算过于复杂，但问题在于汇编语言本身。Go 只支持基于 Plan 9 操作系统的汇编变种。这个系统是由贝尔实验室创建的，并在
    20 世纪末使用。汇编语法，包括可用的指令和操作码，几乎不存在。这使得编写纯 Plan 9 汇编变得艰难，甚至几乎不可能。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Despite lacking assembly usability, Go’s standard packages offer a tremendous
    amount of functionality conducive to vulnerability hunters and exploit developers.
    This chapter covered fuzzing, porting exploits, and handling binary data and shellcode.
    As an additional learning exercise, we encourage you to explore the exploit database
    at [*https://www.exploit-db.com/*](https://www.exploit-db.com/) and try to port
    an existing exploit to Go. Depending on your comfort level with the source language,
    this task could seem overwhelming but it can be an excellent opportunity to understand
    data manipulation, network communications, and low-level system interaction.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管缺乏汇编的可用性，Go 的标准包提供了大量功能，适合漏洞猎人和漏洞开发者使用。本章介绍了模糊测试、漏洞移植以及处理二进制数据和 shellcode。作为额外的学习练习，我们鼓励你浏览
    [*https://www.exploit-db.com/*](https://www.exploit-db.com/) 漏洞数据库，并尝试将现有漏洞移植到
    Go 中。根据你对源语言的熟悉程度，这项任务可能显得令人不知所措，但它可以是一个理解数据处理、网络通信和低级系统交互的绝佳机会。
- en: In the next chapter, we’ll step away from exploitation activities and focus
    on producing extendable toolsets.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将从漏洞利用活动中抽离出来，专注于制作可扩展的工具集。
