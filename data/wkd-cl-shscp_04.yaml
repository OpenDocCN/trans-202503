- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**CREATING UTILITIES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建工具**'
- en: '![image](../images/common4.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common4.jpg)'
- en: One of the main purposes of creating shell scripts is to drop complex command
    line sequences into files, making them replicable and easy to tweak. It should
    be no surprise, then, that user commands are sprawled across this book. What is
    surprising? That we haven’t written a wrapper for every single command on our
    Linux, Solaris, and OS X systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 创建shell脚本的主要目的之一是将复杂的命令行序列放入文件中，使其可复制并且易于调整。所以，不足为奇的是，本书中到处都是用户命令。那么，什么是令人惊讶的呢？令人惊讶的是，我们没有为Linux、Solaris和OS
    X系统上的每个命令编写一个封装脚本。
- en: Linux/Unix is the only major operating system where you can decide that you
    don’t like the default flags of a command and fix it forever with just a few keystrokes,
    or where you can emulate the behavior of your favorite utilities from other operating
    systems by using an alias or a dozen lines of script. That’s what makes Unix so
    tremendously fun—and what led to writing this book in the first place!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Linux/Unix是唯一一个你可以决定不喜欢某个命令的默认标志，并通过几个按键永远修复它的操作系统，或者你可以通过使用别名或十几行脚本来模拟你喜欢的其他操作系统工具的行为。这就是Unix如此有趣的原因，也是最初写这本书的原因！
- en: '**#22 A Reminder Utility**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#22 提醒工具**'
- en: Windows and Mac users have appreciated simple utilities like Stickies for years,
    the streamlined applications that let you keep tiny notes and reminders stuck
    on your screen. They’re perfect for jotting down phone numbers or other reminders.
    Unfortunately, there’s no analog if you want to take notes while working on a
    Unix command line, but the problem is easily solved with this pair of scripts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Windows和Mac用户一直喜欢像Stickies这样的简单工具，这些精简的应用程序让你可以在屏幕上粘贴小便签和提醒。它们非常适合记录电话号码或其他提醒。不幸的是，如果你想在Unix命令行下记笔记，没有类似的工具，但这个问题可以通过这对脚本轻松解决。
- en: The first script, `remember` (shown in [Listing 3-1](ch03.xhtml#ch3ex1)), lets
    you easily save your snippets of information into a single `rememberfile` in your
    home directory. If invoked without any arguments, it reads standard input until
    the end-of-file sequence (`^D`) is given by pressing CTRL-D. If invoked with arguments,
    it just saves those arguments directly to the data file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本`remember`（如[清单 3-1](ch03.xhtml#ch3ex1)所示）可以让你轻松将信息片段保存在家目录中的单个`rememberfile`文件中。如果没有传递任何参数，它会读取标准输入直到输入文件结束符（`^D`），即按CTRL-D。如果传递了参数，它会直接将这些参数保存到数据文件中。
- en: The other half of this duo is `remindme`, a companion shell script shown in
    [Listing 3-2](ch03.xhtml#ch3ex2), which either displays the contents of the whole
    `rememberfile` when no arguments are given or displays the results of searching
    through it using the arguments as a pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这对脚本中的另一部分是`remindme`，一个伴随脚本，显示在[清单 3-2](ch03.xhtml#ch3ex2)中，当没有给定参数时，它会显示整个`rememberfile`的内容，或者使用参数作为模式进行搜索并显示其结果。
- en: '***The Code***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 3-1: The* `*remember*` *shell script*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-1: `*remember*` 脚本*'
- en: '[Listing 3-2](ch03.xhtml#ch3ex2) details the companion script, `remindme`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-2](ch03.xhtml#ch3ex2)详细介绍了伴随脚本`remindme`。'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 3-2: The* `*remindme*` *shell script, a companion to the* `*remember*`
    *shell script in [Listing 3-1](ch03.xhtml#ch3ex1)*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-2: `*remindme*` 脚本，作为[清单 3-1](ch03.xhtml#ch3ex1)中`*remember*`脚本的伴随脚本*'
- en: '***How It Works***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'The `remember` shell script in [Listing 3-1](ch03.xhtml#ch3ex1) can work as
    an interactive program, requesting the user to enter the details to remember,
    or it could actually be scripted since it can also accept anything to store simply
    as a command line argument. If a user does not pass any arguments to the script,
    then we do a little tricky coding. After printing a user-friendly message on how
    to enter an item, we read the data from the user with `cat` ➊:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-1](ch03.xhtml#ch3ex1)中的`remember`脚本可以作为交互式程序工作，要求用户输入需要记住的详细信息，或者它也可以像脚本一样工作，因为它也可以接受任何作为命令行参数存储的内容。如果用户没有向脚本传递任何参数，那么我们会做一些巧妙的编码。在打印出如何输入项的用户友好消息后，我们通过`cat`
    ➊读取用户输入的数据：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In previous chapters, we have used the `read` command to get input from the
    user. This line of code reads from `stdin` (the `-` in the command is shorthand
    for `stdin` or `stdout`, depending on the context) using `cat` until the user
    presses CTRL-D, which tells the `cat` utility that the file has ended. As `cat`
    prints the data it reads from `stdin`, and appends this data to the `rememberfile`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用`read`命令从用户获取输入。此行代码使用`cat`从`stdin`（命令中的`-`是`stdin`或`stdout`的简写，具体取决于上下文）读取数据，直到用户按下CTRL-D，告诉`cat`工具文件结束。当`cat`从`stdin`读取数据时，它会将这些数据追加到`rememberfile`中。
- en: If an argument is specified to the script, however, all arguments are simply
    appended as is to the `rememberfile` ➋.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向脚本指定了参数，所有参数会直接按原样附加到`rememberfile`中 ➋。
- en: The `remindme` script in [Listing 3-2](ch03.xhtml#ch3ex2) cannot work if the
    `rememberfile` doesn’t exist, so we first check if the `rememberfile` exists before
    attempting to do anything. If the `rememberfile` doesn’t exist, we exit immediately
    after printing a message to the screen alerting the user why.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[列表 3-2](ch03.xhtml#ch3ex2)中的`remindme`脚本无法运行是因为`rememberfile`文件不存在，因此我们首先会检查`rememberfile`是否存在，在尝试执行任何操作之前。如果`rememberfile`不存在，我们会在屏幕上打印一条消息告知用户原因，然后立即退出。
- en: If no arguments are passed to the script, we assume the user just wants to see
    the contents of the `rememberfile`. Using the `more` utility to allow paging through
    the `rememberfile`, we simply display the contents to the user ➌.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有向脚本传递任何参数，我们假设用户只是想查看`rememberfile`的内容。我们使用`more`工具来分页显示`rememberfile`的内容，直接将内容展示给用户
    ➌。
- en: Otherwise, if arguments are passed to the script, we perform a case-insensitive
    `grep` to search for any matching terms in the `rememberfile`, and then display
    these results with paging as well ➍.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果传递了参数给脚本，我们将执行不区分大小写的`grep`，以搜索`rememberfile`中任何匹配的词条，然后也以分页形式显示这些结果 ➍。
- en: '***Running the Script***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: To use the `remindme` utility, first add notes, phone numbers, or anything else
    to the `rememberfile` with the `remember` script, as in [Listing 3-3](ch03.xhtml#ch3ex3).
    Then search this freeform database with `remindme`, specifying as long or short
    a pattern as you’d like.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`remindme`工具，首先用`remember`脚本将笔记、电话号码或其他任何东西添加到`rememberfile`中，如[列表 3-3](ch03.xhtml#ch3ex3)所示。然后，用`remindme`搜索这个自由格式的数据库，可以指定任何长短的模式。
- en: '***The Results***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-3: Testing the* `*remember*` *shell script*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-3：测试`*remember*` shell 脚本*'
- en: Then, when you want to remember that note months later, [Listing 3-4](ch03.xhtml#ch3ex4)
    shows how you can find the reminder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你几个月后想要记起那条笔记时，[列表 3-4](ch03.xhtml#ch3ex4)展示了你如何找到提醒。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-4: Testing the* `*remindme*` *shell script*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-4：测试`*remindme*` shell 脚本*'
- en: Or if there’s an 800 number you can’t quite recall, [Listing 3-5](ch03.xhtml#ch3ex5)
    demonstrates locating a partial phone number.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你记不清一个800电话号码，[列表 3-5](ch03.xhtml#ch3ex5)展示了如何查找部分电话号码。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 3-5: Locating a partial phone number with the* `*remindme*` *script*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-5：使用`*remindme*`脚本查找部分电话号码*'
- en: '***Hacking the Script***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: While certainly not any sort of shell script programming tour de force, these
    scripts neatly demonstrate the extensibility of the Unix command line. If you
    can envision something, the odds are good that there’s a simple way to accomplish
    it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些脚本绝对称不上是任何形式的shell脚本编程杰作，但它们很好地展示了Unix命令行的可扩展性。如果你能想象某件事情，很可能就有一个简单的方法来实现它。
- en: 'These scripts could be improved in any number of ways. For instance, you could
    introduce the concept of *records*: each `remember` entry is timestamped, and
    multiline input can be saved as a single record that can be searched for using
    regular expressions. This approach lets you store phone numbers for a group of
    people and retrieve them all just by remembering the name of one person in the
    group. If you’re really into scripting, you might also want to include edit and
    delete capabilities. Then again, it’s pretty easy to edit the *~/.remember* file
    by hand.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本可以通过多种方式改进。例如，你可以引入*记录*的概念：每个`remember`条目都有时间戳，多行输入可以作为单一记录保存，并且可以使用正则表达式进行搜索。这个方法让你能够为一组人存储电话号码，并仅凭记住组中某个人的名字就能检索出所有号码。如果你真的热衷于脚本编程，你还可以加入编辑和删除功能。话说回来，手动编辑*~/.remember*文件其实也非常容易。
- en: '**#23 An Interactive Calculator**'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#23 一个交互式计算器**'
- en: 'If you’ll remember, `scriptbc` ([Script #9](ch01.xhtml#ch01lev1sec10) on [page
    34](ch01.xhtml#page_34)) allowed us to invoke floating-point `bc` calculations
    as inline command arguments. The logical next step is to write a wrapper script
    to turn this script into a fully interactive command line–based calculator. The
    script (shown in [Listing 3-6](ch03.xhtml#ch3ex6)) ends up being really short!
    Ensure that the `scriptbc` script is in the `PATH`, otherwise this script will
    fail to run.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你记得的话，`scriptbc`（在[脚本 #9](ch01.xhtml#ch01lev1sec10)中位于[第34页](ch01.xhtml#page_34)）允许我们将浮动点`bc`计算作为内联命令参数调用。接下来的合乎逻辑的步骤是编写一个包装脚本，将这个脚本变成一个完全交互的命令行计算器。这个脚本（如[清单
    3-6](ch03.xhtml#ch3ex6)所示）非常简短！确保`scriptbc`脚本在`PATH`中，否则这个脚本将无法运行。'
- en: '***The Code***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 3-6: The* `*calc*` *command line calculator shell script*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-6: `*calc*` 命令行计算器 Shell 脚本*'
- en: '***How It Works***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'Perhaps the most interesting part of this code is the `while read` statement
    ➊, which creates an infinite loop that displays the `calc>` prompt until the user
    exits, either by entering `quit` or by entering an end-of-file sequence (`^D`).
    The simplicity of this script is what makes it extra wonderful: shell scripts
    don’t need to be complex to be useful!'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这个代码最有趣的部分是`while read`语句 ➊，它创建了一个无限循环，直到用户退出（通过输入`quit`或输入文件结束符号（`^D`））之前，一直显示`calc>`提示。这个脚本的简单性正是它特别棒的原因：Shell
    脚本不需要复杂才有用！
- en: '***Running the Script***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'This script uses `scriptbc`, the floating-point calculator we wrote in [Script
    #9](ch01.xhtml#ch01lev1sec10), so make sure you have that script available in
    your `PATH` as `scriptbc` (or set a variable like `$scriptbc` to the script’s
    current name) before running it. By default, this script runs as an interactive
    tool that prompts the user for the desired actions. If invoked with arguments,
    those arguments are passed along to the `scriptbc` command instead. [Listing 3-7](ch03.xhtml#ch3ex7)
    shows both usage options at work.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '该脚本使用了我们在[脚本 #9](ch01.xhtml#ch01lev1sec10)中编写的浮动点计算器`scriptbc`，因此在运行之前，请确保该脚本可以在你的`PATH`中找到，或者将变量像`$scriptbc`设置为脚本当前的名称。如果没有参数传递给它，默认情况下，该脚本将作为交互工具运行，提示用户进行所需的操作。如果带有参数调用，则这些参数将传递给`scriptbc`命令。[清单
    3-7](ch03.xhtml#ch3ex7)展示了两种用法选项的实际操作。'
- en: '***The Results***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 3-7: Testing the* `*calc*` *shell script*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-7: 测试`*calc*` Shell 脚本*'
- en: '**WARNING**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Floating-point calculations, even those that are easy for us humans, can be
    tricky on computers. Unfortunately, the* `*bc*` *command can reveal some of these
    glitches in unexpected ways. For example, in* `*bc*`*, set* `***scale=0***` *and
    enter* `***7 % 3***`*. Now try it with* `***scale=4***`*. This produces* `*.0001*`*,
    which is clearly incorrect.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮动点计算，即使对我们人类来说很容易，但在计算机上可能会非常棘手。不幸的是，`*bc*` 命令可能以意想不到的方式暴露出一些这些问题。例如，在`*bc*`中，设置`***scale=0***`并输入`***7
    % 3***`。现在尝试使用`***scale=4***`。这将产生`*.0001*`，显然是不正确的。*'
- en: '***Hacking the Script***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'Whatever you can do in `bc` on a command line you can do in this script, with
    the caveat that `calc.sh` has no line-to-line memory or state retention. This
    means you could add more mathematical functions to the help system, if you were
    so inclined. For example, the variables `obase` and `ibase` let you specify input
    and output numeric bases, though since there’s no line-by-line memory, you’d have
    to either modify `scriptbc` ([Script #9](ch01.xhtml#ch01lev1sec10) on [page 34](ch01.xhtml#page_34))
    or learn to enter the setting and the equation all on a single line.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以在命令行中的`bc`上做的任何事情，在这个脚本中也可以做，前提是`calc.sh`没有逐行内存或状态保持。这意味着，如果你有兴趣，你可以向帮助系统添加更多的数学函数。例如，变量`obase`和`ibase`允许你指定输入和输出的数字基数，尽管由于没有逐行内存，你需要修改`scriptbc`（在[脚本
    #9](ch01.xhtml#ch01lev1sec10)中位于[第34页](ch01.xhtml#page_34)）或者学会将设置和方程都输入在同一行。'
- en: '**#24 Converting Temperatures**'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#24 转换温度**'
- en: 'The script in [Listing 3-8](ch03.xhtml#ch3ex8), which marks the first use of
    sophisticated mathematics in this book, can translate any temperature between
    Fahrenheit, Celsius, and Kelvin units. It uses the same trick of piping an equation
    to `bc` as we used in [Script #9](ch01.xhtml#ch01lev1sec10) on [page 34](ch01.xhtml#page_34).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-8](ch03.xhtml#ch3ex8)中的脚本标志着本书中第一次使用复杂数学运算，它可以在华氏度、摄氏度和开尔文单位之间转换任何温度。它使用与[脚本
    #9](ch01.xhtml#ch01lev1sec10)中相同的技巧，将方程传递给`bc`，正如我们在[第34页](ch01.xhtml#page_34)上所做的那样。'
- en: '***The Code***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 3-8: The* `*convertatemp*` *shell script*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-8: `*convertatemp*` Shell 脚本*'
- en: '***How It Works***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'At this point in the book, most of the script is probably clear, but let’s
    have a closer look at the math and regular expressions that do all the work. “Math
    first,” as most school-age children would undoubtedly *not* appreciate hearing!
    Here is the formula for converting degrees Fahrenheit to degrees Celsius:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这个阶段，大部分脚本应该已经很清晰了，但让我们仔细看看做所有工作的数学公式和正则表达式。“先讲数学，”大多数学龄儿童无疑会*不*喜欢听到这样的话！这是将华氏度转换为摄氏度的公式：
- en: '![image](../images/e0086-01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e0086-01.jpg)'
- en: 'Converted into a sequence that can be fed to `bc` and solved, it looks like
    the code at ➌. The reverse conversion, Celsius to Fahrenheit, is at ➍. The script
    also converts the temperature from Celsius to Kelvin ➎. This script demonstrates
    one big reason to use mnemonic variable names: it makes the code a whole lot easier
    to read and debug.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 转换成可以传递给 `bc` 并求解的序列后，它看起来像 ➌ 中的代码。反向转换，即摄氏度到华氏度的转换，位于 ➍。该脚本还将温度从摄氏度转换为开尔文 ➎。这个脚本展示了使用助记变量名的一个重要原因：它使代码更容易阅读和调试。
- en: The other bits of code here that are interesting are the regular expressions,
    the gnarliest of which is easily the one at ➊. What we’re doing is pretty straightforward,
    if you can unwrap the `sed` substitution. Substitutions always look like `s/*old*/*new*/`;
    the `*old*` pattern here is zero or more occurrences of `-`, followed by any of
    the set of digits (recall that `[:digit:]` is the ANSI character set notation
    for any digit and `*` matches zero or more occurrences of the previous pattern).
    The `*new*` pattern then is what we want to replace the `*old*` pattern with,
    and in this case it is simply `//`, which signifies an empty pattern; this pattern
    is useful when you just want to remove the old one. This substitution effectively
    removes all the digits so that inputs like `-31f` turn into just `f`, giving us
    the type of units. Finally, the `tr` command normalizes everything to uppercase
    so, for example, `-31f` turns into `F`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里另一个有趣的代码部分是正则表达式，其中最复杂的无疑是 ➊ 的表达式。我们所做的事情其实非常直接，如果你能解读 `sed` 替换的语法。替换的格式总是看起来像
    `s/*旧值*/*新值*/`；其中 `*旧值*` 模式表示零次或多次出现的 `-`，后面跟着数字集合中的任何一个（记住 `[:digit:]` 是 ANSI
    字符集表示任意数字，`*` 匹配前述模式的零次或多次出现）。然后，`*新值*` 模式是我们希望用来替换 `*旧值*` 模式的内容，在这种情况下它只是 `//`，表示一个空模式；当你只想删除旧模式时，这个模式非常有用。这个替换有效地删除了所有的数字，使得像
    `-31f` 这样的输入变成了仅有 `f`，从而得到单位类型。最后，`tr` 命令将所有内容转换为大写，因此，例如，`-31f` 变成了 `F`。
- en: 'The other `sed` expression does the opposite ➋: it removes anything that isn’t
    numeric by using the `^` operator to negate matches for any characters in the
    class `[:digit:]`. (Most languages use `!` as negation.) This provides us with
    the value we eventually convert using the appropriate equation.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 `sed` 表达式执行相反的操作 ➋：它使用 `^` 操作符来否定类 `[:digit:]` 中任何字符的匹配，从而移除任何非数字字符。（大多数编程语言使用
    `!` 作为否定符号。）这为我们提供了最终使用适当方程式进行转换的值。
- en: '***Running the Script***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script has a nice, intuitive input format, even if it is pretty unusual
    for a Unix command. Input is entered as a numeric value, with an optional suffix
    that indicates the units of the temperature entered; when no suffix is given,
    the code assumes the units are Fahrenheit.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本有一个直观的输入格式，即使它在 Unix 命令中相当不寻常。输入是作为一个数值输入的，带有一个可选后缀，表示输入温度的单位；如果没有给定后缀，代码假设单位为华氏度。
- en: To see the Celsius and Kelvin equivalents of 0° Fahrenheit, enter `0F`. To see
    what 100° Kelvin is in Fahrenheit and Celsius, use `100K`. And to get 100° Celsius
    in Kelvin and Fahrenheit, enter `100C`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 0° 华氏度对应的摄氏度和开尔文度数，请输入 `0F`。要查看 100° 开尔文在华氏度和摄氏度中的值，请使用 `100K`。要获取 100°
    摄氏度在开尔文和华氏度中的值，请输入 `100C`。
- en: 'You’ll see this same single-letter suffix approach again in [Script #60](ch07.xhtml#ch07lev1sec08)
    on [page 190](ch07.xhtml#page_190), which converts currency values.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '你将在 [脚本 #60](ch07.xhtml#ch07lev1sec08) 中再次看到这种单字母后缀的方法，该脚本用于转换货币值，见 [第 190
    页](ch07.xhtml#page_190)。'
- en: '***The Results***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[Listing 3-9](ch03.xhtml#ch3ex9) shows conversion across many different temperatures.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-9](ch03.xhtml#ch3ex9) 展示了不同温度之间的转换。'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-9: Testing the* `*convertatemp*` *shell script with a few conversions*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-9：使用一些转换测试* `*convertatemp*` *Shell 脚本*'
- en: '***Hacking the Script***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: You can add a few input flags to generate succinct output for only one conversion
    at a time. Something like `convertatemp -c 100F` could output just the Celsius
    equivalent of 100° Fahrenheit, for example. This approach will help you use converted
    values in other scripts as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加一些输入标志，每次只生成简洁的输出。例如，`convertatemp -c 100F`可以仅输出100°F的摄氏等效温度。这个方法也能帮助你在其他脚本中使用转换后的值。
- en: '**#25 Calculating Loan Payments**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#25 计算贷款支付**'
- en: Another common calculation users might deal with is estimation of loan payments.
    The script in [Listing 3-10](ch03.xhtml#ch3ex10) also helps answer the question
    “What can I do with that bonus?” and the related question “Can I finally afford
    that new Tesla?”
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用户可能会遇到的常见计算是贷款支付估算。[清单3-10](ch03.xhtml#ch3ex10)中的脚本也有助于回答“我可以拿这些奖金做什么？”以及相关问题“我终于可以买得起那辆新特斯拉了吗？”。
- en: While the formula to calculate payments based on the principal, interest rate,
    and duration of the loan is a bit tricky, some judicious use of shell variables
    can tame the mathematical beast and make it surprisingly understandable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于本金、利率和贷款期限来计算支付金额的公式有些复杂，但通过巧妙使用Shell变量，能够驯服这个数学难题，并让它变得出乎意料地易于理解。
- en: '***The Code***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-10: The* `*loancalc*` *shell script*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-10：* `*loancalc*` *Shell脚本*'
- en: '***How It Works***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: Exploring the formula itself is beyond the scope of this book, but it’s worth
    noting how a complex mathematical formula can be implemented directly in a shell
    script.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 探索公式本身超出了本书的范围，但值得注意的是，如何在Shell脚本中直接实现一个复杂的数学公式。
- en: 'The entire calculation could be solved using a single long input stream to
    `bc`, because that program also supports variables. However, being able to manipulate
    the intermediate values within the script itself proves beyond the capabilities
    of the `bc` command alone. Also, frankly, breaking up the equation into a number
    of intermediate equations ➋ also facilitates debugging. For example, here’s the
    code that splits the computed monthly payment into dollars and cents and ensures
    that it’s presented as a properly formatted monetary value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 整个计算可以通过将一个长输入流传递给`bc`来解决，因为该程序也支持变量。然而，能够在脚本中操作中间值超出了`bc`命令本身的能力。此外，坦率地说，将公式拆分为多个中间方程式➋，也有助于调试。例如，下面是将计算出的月支付额拆分为美元和美分并确保以正确格式显示为货币值的代码：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `cut` command proves useful here ➌. The second line of this code grabs the
    portion of the monthly payment value that follows the decimal point and then chops
    off anything after the second character. If you would prefer to round this number
    to the next nearest cent instead, just add 0.005 to the value before truncating
    the cents at two digits.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut`命令在这里证明非常有用➌。这段代码的第二行抓取了月支付值中小数点后的部分，然后将第二个字符之后的内容截断。如果你更愿意将这个数字四舍五入到下一个最接近的美分，只需在截断美分之前加上0.005。'
- en: Notice also how at ➊, the script library from earlier in the book is neatly
    included with the `. library.sh` command in the script, ensuring that all the
    functions (for our purposes in this script, the `nicenumber()` function from [Chapter
    1](ch01.xhtml#ch01)) are then accessible to the script.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同时注意到，在➊处，书中早先提到的脚本库通过`. library.sh`命令被整齐地包含进脚本中，确保所有函数（在本脚本中，来自[第1章](ch01.xhtml#ch01)的`nicenumber()`函数）都能被脚本访问。
- en: '***Running the Script***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'This minimalist script expects three parameters: the amount of the loan, the
    interest rate, and the duration of the loan (in years).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简化版脚本需要三个参数：贷款金额、利率和贷款期限（单位为年）。
- en: '***The Results***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Say you’ve been eyeing a new Tesla Model S, and you’re curious about how much
    your payments would be if you bought the car. The Model S starts at about $69,900
    out the door, and the latest interest rates are running at 4.75 percent for an
    auto loan. Assuming your current car is worth about $25,000 and that you can trade
    it in at that price, you’ll be financing the difference of $44,900\. If you haven’t
    already had second thoughts, you’d like to see what the difference is in total
    payments between a four-year and five-year car loan—easily done with this script,
    as [Listing 3-11](ch03.xhtml#ch3ex11) shows.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你一直在关注一辆新的特斯拉Model S，并且想知道如果你购买这辆车，月供会是多少。Model S的起售价大约为69,900美元，最新的汽车贷款利率为4.75%。假设你目前的汽车价值约25,000美元，并且你能够以这个价格进行置换，你将贷款44,900美元的差额。如果你还没有改变主意，你希望看到四年期和五年期车贷的总支付差异——这个脚本可以轻松完成这个任务，如[列表
    3-11](ch03.xhtml#ch3ex11)所示。
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 3-11: Testing the* `*loancalc*` *shell script*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-11：测试`*loancalc*`脚本*'
- en: 'If you can afford the higher payments on the four-year loan, the car will be
    paid off sooner, and your total payments (monthly payment times number of payments)
    will be significantly less. To calculate the exact savings, we can use the interactive
    calculator from [Script #23](ch03.xhtml#ch03lev1sec02) on [page 82](ch03.xhtml#page_82),
    as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你能承受四年贷款的较高月供，那么汽车将更早还清，而你的总支付额（即月供乘以还款期数）将明显减少。为了计算准确的节省金额，我们可以使用[脚本 #23](ch03.xhtml#ch03lev1sec02)中的互动计算器，如[第82页](ch03.xhtml#page_82)所示：'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This seems like a worthwhile savings: $1,142.16 could buy a nice laptop!'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个值得的节省：$1,142.16足够买一台不错的笔记本电脑！
- en: '***Hacking the Script***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: This script could really do with a way to prompt for each field if the user
    doesn’t provide any parameters. An even more useful version of this script would
    let a user specify *any* three parameters of the four (principal, interest rate,
    number of payments, and monthly payment amount) and automatically solve for the
    fourth value. That way, if you knew you could afford only $500 per month in payments
    and that the maximum duration of a 6 percent auto loan was 5 years, you could
    ascertain the largest amount of principal that you could borrow. You could accomplish
    this calculation by implementing flags that users can use to pass in the values
    they want.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本实际上可以加入一个提示功能，如果用户没有提供任何参数的话。更有用的版本可以让用户指定四个参数中的任意三个（本金、利率、还款期数和月供金额），然后自动计算出第四个值。这样，如果你知道自己每月最多可以支付500美元，并且6%的汽车贷款的最长期限是5年，你就能计算出自己可以借款的最大金额。你可以通过实现标志，让用户传入他们希望的值，从而完成这个计算。
- en: '**#26 Keeping Track of Events**'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#26 事件追踪**'
- en: 'This is actually a pair of scripts that together implement a simple calendar
    program, similar to our reminder utility from [Script #22](ch03.xhtml#ch03lev1sec01)
    on [page 80](ch03.xhtml#page_80). The first script, `addagenda` (shown in [Listing
    3-12](ch03.xhtml#ch3ex12)), enables you to specify a recurring event (with either
    a day of the week for weekly events or a day and month for annual ones) or a one-time
    event (with the day, month, and year). All the dates are validated and saved,
    along with a one-line event description, in an *.agenda* file in your home directory.
    The second script, `agenda` (shown in [Listing 3-13](ch03.xhtml#ch3ex13)), checks
    all known events to show which ones are scheduled for the current date.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '这实际上是一对脚本，它们一起实现了一个简单的日历程序，类似于我们在[脚本 #22](ch03.xhtml#ch03lev1sec01)中的提醒工具（见[第80页](ch03.xhtml#page_80)）。第一个脚本`addagenda`（见[列表
    3-12](ch03.xhtml#ch3ex12)）允许你指定一个周期性事件（每周某天的周事件或每年某天的年度事件）或一次性事件（指定日期、月份和年份）。所有日期都会经过验证并保存，同时还有一个单行事件描述，这些内容会存储在你主目录下的*.agenda*文件中。第二个脚本`agenda`（见[列表
    3-13](ch03.xhtml#ch3ex13)）检查所有已知事件，显示哪些事件安排在当前日期。'
- en: This kind of tool is particularly useful for remembering birthdays and anniversaries.
    If you have trouble remembering events, this handy script can save you a lot of
    grief!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工具特别适合用来记住生日和纪念日。如果你总是忘记重要的事件，这个实用的脚本将能为你节省不少麻烦！
- en: '***The Code***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 3-12: The* `*addagenda*` *shell script*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-12：`*addagenda*`脚本*'
- en: The second script, in [Listing 3-13](ch03.xhtml#ch3ex13), is shorter but is
    used more often.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个脚本（见[列表 3-13](ch03.xhtml#ch3ex13)）较短，但使用频率更高。
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 3-13: The* `*agenda*` *shell script, a companion to the* `*addagenda*`
    *script in [Listing 3-12](ch03.xhtml#ch3ex12)*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-13：* `*agenda*` *脚本，它是[列表 3-12](ch03.xhtml#ch3ex12)中`*addagenda*`脚本的伴侣*'
- en: '***How It Works***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: 'The `addagenda` and `agenda` scripts support three types of recurring events:
    weekly events (“every Wednesday”), annual events (“every August 3”), and one-time
    events (“January 1, 2017”). As entries are added to the agenda file, their specified
    dates are normalized and compressed so that `3 August` becomes `3Aug` and `Thursday`
    becomes `Thu`. This is accomplished with the `normalize` function in `addagenda`
    ➊.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`addagenda`和`agenda`脚本支持三种类型的重复事件：每周事件（“每周三”）、年度事件（“每年8月3日”）和一次性事件（“2017年1月1日”）。随着议程文件中条目的添加，它们指定的日期会被标准化和压缩，`3
    August`变为`3Aug`，`Thursday`变为`Thu`。这一切通过`addagenda`中的`normalize`函数实现 ➊。'
- en: This function chops any value entered down to three characters, ensuring that
    the first character is uppercase and the second and third are lowercase. This
    format matches the standard abbreviated day and month name values from the `date`
    command output, which will be critical for the correct functioning of the `agenda`
    script. The rest of the `addagenda` script has nothing particularly complex happening
    in it; the bulk of it is devoted to error tests for bad data formats.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输入的任何值截断为三个字符，确保第一个字符为大写，第二个和第三个字符为小写。这个格式与`date`命令输出的标准缩写日期和月份名称值相匹配，这对于`agenda`脚本的正确运行至关重要。`addagenda`脚本的其余部分没有特别复杂的内容；大部分代码用于检测无效的数据格式。
- en: 'Finally, at ➋ it saves the now normalized record data to the hidden file. The
    ratio of error-checking code to actual functional code is pretty typical of a
    well-written program: clean up the data on input and you’ll be able to confidently
    make assumptions about its formatting in subsequent apps.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在➋处，它将现在标准化的记录数据保存到隐藏文件中。错误检查代码与实际功能代码的比例非常典型，是一个写得很好的程序：在输入时清理数据，你就可以自信地对后续应用程序中的数据格式做出假设。
- en: The `agenda` script checks for events by transforming the current date into
    the three possible date string formats (*dayname*, *day+month*, and *day+month+year*)
    ➌. It then compares these date strings to each line in the *.agenda* data file.
    If there’s a match, that event is shown to the user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`agenda`脚本通过将当前日期转换为三种可能的日期字符串格式（*dayname*，*day+month*，*day+month+year*）来检查事件
    ➌。然后，它将这些日期字符串与*.agenda*数据文件中的每一行进行比较。如果找到匹配的条目，事件将展示给用户。'
- en: The coolest hack in this pair of scripts is probably how an `eval` is used to
    assign variables to each of the four date values needed ➍.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这对脚本中的最酷的黑客技巧可能就是如何使用`eval`来为所需的四个日期值分配变量 ➊。
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s possible to extract the values one by one (for example, `weekday="$(date
    +%a)"`), but in very rare cases, this method can fail if the date rolls over to
    a new day in the middle of the four `date` invocations, so a succinct single invocation
    is preferable. Plus, it’s just cool.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以逐个提取值（例如，`weekday="$(date +%a)"`），但在极少数情况下，如果日期在四次`date`调用之间发生了跨天，方法可能会失败，因此最好使用简洁的单次调用。而且，这样做也很酷。
- en: Since `date` returns a day as a number with either a leading zero or a leading
    space, neither of which are desired, the next line of code at ➎ strips both from
    the value, if present, before proceeding. Go have a peek to see how that works!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`date`返回的日期是带有前导零或前导空格的数字，而这两者都是不需要的，下一个代码行在➎处会去掉这些多余的部分，然后再继续执行。快去看一看它是怎么工作的！
- en: '***Running the Script***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: The `addagenda` script prompts the user for the date of a new event. Then, if
    it accepts the date format, the script prompts for a one-line description of the
    event.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`addagenda`脚本会提示用户输入新事件的日期。然后，如果它接受日期格式，脚本会提示输入事件的一行描述。'
- en: The companion `agenda` script has no parameters and, when invoked, produces
    a list of all events scheduled for the current date.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 附带的`agenda`脚本没有参数，当调用时，它会生成一个当前日期所有事件的列表。
- en: '***The Results***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: To see how this pair of scripts works, let’s add a number of new events to the
    database, as [Listing 3-14](ch03.xhtml#ch3ex14) shows.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这对脚本如何工作，我们可以像[清单 3-14](ch03.xhtml#ch3ex14)所示，向数据库中添加一些新事件。
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 3-14: Testing the* `*addagenda*` *script and adding many agenda items*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-14：测试* `*addagenda*` *脚本并添加多个议程项*'
- en: Now the `agenda` script offers a quick and handy reminder of what’s happening
    today, detailed in [Listing 3-15](ch03.xhtml#ch3ex15).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`agenda`脚本提供了一个快速便捷的方式，提醒今天发生了什么，详见[清单 3-15](ch03.xhtml#ch3ex15)。
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 3-15: Using the* `*agenda*` *script to see what our agenda items are
    for today*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-15：使用* `*agenda*` *脚本查看今天的议程项*'
- en: 'Notice that it matched entries formatted as *dayname*, *day+month*, and *day+month+year*.
    For completeness, [Listing 3-16](ch03.xhtml#ch3ex16) shows the associated *.agenda*
    file, with a few additional entries:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到它匹配了格式为 *dayname*、*day+month* 和 *day+month+year* 的条目。为了完整起见，[列表 3-16](ch03.xhtml#ch3ex16)
    显示了相关的 *.agenda* 文件，并且添加了一些额外的条目：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 3-16: The raw contents of the* .agenda *file storing the agenda items*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-16：存储议程项目的* .agenda *文件的原始内容*'
- en: '***Hacking the Script***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***脚本黑客***'
- en: 'This script really just scratches the surface of this complex and interesting
    topic. It’d be nice to have it look a few days ahead, for example; this could
    be accomplished in the `agenda` script by doing some date math. If you have the
    GNU `date` command, date math is easy. If you don’t, well, enabling date math
    solely in the shell requires a complex script. We’ll look more closely at date
    math later in the book, notably in [Script #99](ch15.xhtml#ch15lev1sec01) on [page
    330](ch15.xhtml#page_330), [Script #100](ch15.xhtml#ch15lev1sec02) on [page 332](ch15.xhtml#page_332),
    and [Script #101](ch15.xhtml#ch15lev1sec03) on [page 335](ch15.xhtml#page_335).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '这个脚本实际上只是触及了这个复杂且有趣话题的皮毛。举个例子，如果它能够提前几天查看就好了；这可以通过在 `agenda` 脚本中进行一些日期运算来实现。如果你有
    GNU `date` 命令，日期运算就很容易。如果没有，那么在 shell 中仅启用日期运算就需要一个复杂的脚本。我们将在本书稍后的章节中更详细地介绍日期运算，特别是在[脚本
    #99](ch15.xhtml#ch15lev1sec01)（第330页）、[脚本 #100](ch15.xhtml#ch15lev1sec02)（第332页）和[脚本
    #101](ch15.xhtml#ch15lev1sec03)（第335页）。'
- en: Another (easier) hack would be to have `agenda` output `Nothing scheduled for
    today` when there are no matches for the current date, rather than the sloppier
    `On the agenda for today:` followed by nothing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个（更简单的）方法是，当没有与当前日期匹配的项目时，`agenda` 输出 `今天没有安排`，而不是更为草率的 `今天的议程：` 后面什么也没有。
- en: This script could also be used on a Unix box for sending out systemwide reminders
    about events like backup schedules, company holidays, and employee birthdays.
    First, have the `agenda` script on each user’s machine additionally check a shared
    read-only *.agenda* file. Then add a call to the `agenda` script in each user’s
    *.login* or similar file that’s invoked on login.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本还可以在 Unix 机器上用于发送全系统的事件提醒，比如备份计划、公司假期和员工生日。首先，让每个用户机器上的 `agenda` 脚本额外检查一个共享的只读
    *.agenda* 文件。然后在每个用户的 *.login* 或类似文件中添加调用 `agenda` 脚本的命令，该文件会在登录时执行。
- en: '**NOTE**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Rather surprisingly, date implementations vary across different Unix and Linux
    systems, so if you try something more complicated with your own date command and
    it fails, make sure to check the man page to see what your system can and cannot
    do.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*令人惊讶的是，不同的 Unix 和 Linux 系统上的日期实现有所不同，因此，如果你尝试使用自己的 `date` 命令做一些更复杂的操作且失败了，记得查阅手册页，看看你的系统能做什么，不能做什么。*'
