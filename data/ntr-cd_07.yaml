- en: '**6 Physics Libraries**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6 个物理学库**'
- en: '*A library implies an act of faith Which generations still in darkness hid
    Sign in their night, in witness of the dawn.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*图书馆意味着一种信念的行为，几代人依然在黑暗中隐藏，签署他们的夜晚，以见证黎明的到来。*'
- en: —Victor Hugo
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —维克多·雨果
- en: '![Image](../images/pg327_Image_503.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg327_Image_503.jpg)'
- en: '**Living root bridges (photo by Arshiya Urveeja Bose)**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**活根桥（照片由 Arshiya Urveeja Bose 提供）**'
- en: In the Indian state of Meghalaya, the Khasi and Jaiñtia peoples live in areas
    that experience some of the highest rainfall in the world. During the monsoon
    season, floods often make traveling between villages impossible. As a result,
    the ancient tradition of constructing living root bridges emerged. These bridges,
    like the double living root bridge in East Khasi shown here, are created by guiding
    and growing tree roots through bamboo, palm trunks, or steel scaffolding. They
    grow and become stronger as the roots interact with the environment, forming adaptive,
    springlike connections.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在印度梅加拉亚邦，卡西族和贾因提亚族生活在世界上降雨量最高的地区之一。在季风季节，洪水常常使得村庄之间的交通变得不可能。因此，建造活根桥的古老传统应运而生。这些桥梁，如这里展示的东卡西的双层活根桥，是通过引导和生长树根穿过竹子、棕榈树干或钢架搭建而成的。随着树根与环境的互动，它们不断生长并变得更强，形成适应性强、如弹簧般的连接。
- en: 'Think about what you’ve accomplished so far in this book. You’ve done the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想你在这本书中迄今为止所取得的成就。你已经完成了以下内容：
- en: Learned about concepts from the world of physics (What is a vector? What is
    a force? What is a wave?)
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习了物理学中的一些概念（什么是向量？什么是力？什么是波动？）
- en: Understood the math and algorithms behind those concepts
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解了这些概念背后的数学和算法
- en: Implemented those algorithms in p5.js with an object-oriented approach, culminating
    in building simulations of autonomous steering agents
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用面向对象的方法在 p5.js 中实现了这些算法，最终构建了自动导航代理的模拟
- en: These activities have yielded a set of motion simulations, allowing you to creatively
    define the physics of the worlds you build (whether realistic or fantastical).
    But, of course, you and I aren’t the first or only people to do this. The world
    of computer graphics and programming is full of prewritten code libraries dedicated
    to physics simulations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些活动已经产生了一套运动模拟，允许你创造性地定义你所构建世界中的物理规律（无论是现实的还是幻想的）。但当然，你和我并不是第一个或唯一这样做的人。计算机图形学和编程的世界充满了为物理模拟提供的预编写代码库。
- en: 'Just try searching *open source physics engine* and you could spend the rest
    of your day poring over a host of rich and complex codebases. This begs the question:
    If an existing code library takes care of physics simulation, why should you bother
    learning how to write any of the algorithms yourself? Here’s where the philosophy
    behind this book comes into play. While many libraries provide out-of-the-box
    physics to experiment with (super-awesome, sophisticated, and robust physics at
    that), there are several good reasons for learning the fundamentals from scratch
    before diving into such libraries.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 只要搜索一下 *开源物理引擎*，你可能会花上整天的时间去研究一堆丰富而复杂的代码库。这引出了一个问题：如果现有的代码库已经处理了物理模拟，为什么你还要费心学习如何自己编写这些算法呢？这就是本书背后哲学思想的体现。虽然许多库提供了现成的物理效果供你实验（而且这些物理效果超级棒、复杂且强大），但在深入使用这些库之前，学习基础知识有几个充分的理由。
- en: First, without an understanding of vectors, forces, and trigonometry, it’s easy
    to get lost just reading the documentation of a library, let alone using it. Second,
    even though a library may take care of the math behind the scenes, it won’t necessarily
    simplify your code. A great deal of overhead may be required in understanding
    how a library works and what it expects from you code-wise. Finally, as wonderful
    as a physics engine might be, if you look deep down into your heart, you’ll likely
    see that you seek to create worlds and visualizations that stretch the limits
    of the imagination. A library may be great, but it provides only a limited set
    of features. It’s important to know when to live within those limitations in the
    pursuit of a creative coding project and when those limits will prove to be confining.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果不理解向量、力和三角学的知识，仅仅阅读库的文档就容易迷失方向，更不用说使用它了。其次，尽管库可能会处理幕后的一些数学运算，但它并不一定会简化你的代码。在理解库如何工作以及它对你的代码有何期望方面，可能需要大量的额外努力。最后，尽管物理引擎可能非常棒，但如果你深入内心，你可能会发现你希望创造的是突破想象力极限的世界和可视化。库可能很棒，但它只提供有限的功能集。重要的是，要知道何时在追求创意编程项目的过程中，接受这些限制，何时这些限制将变得束缚你。
- en: 'This chapter is dedicated to examining two open source physics libraries for
    JavaScript: Matter.js (*[https://brm.io/matter-js](https://brm.io/matter-js)*)
    and Toxiclibs.js (*[http://haptic-data.com/toxiclibsjs](http://haptic-data.com/toxiclibsjs)*).
    I don’t mean to imply that these are the only libraries you should use for any
    and all creative coding projects that could benefit from a physics engine (see
    “Other Physics Libraries” on [page 290](ch06.xhtml#common01) for alternatives,
    and check the book’s website for ports of the chapter’s examples to other libraries).
    However, both libraries integrate nicely with p5.js and will allow me to demonstrate
    the fundamental concepts behind physics engines and how they relate to and build
    upon the material I’ve covered so far.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍两个JavaScript开源物理库：Matter.js (*[https://brm.io/matter-js](https://brm.io/matter-js)*)
    和 Toxiclibs.js (*[http://haptic-data.com/toxiclibsjs](http://haptic-data.com/toxiclibsjs)*).
    我并不是暗示这些是你在任何和所有需要物理引擎的创意编程项目中唯一应该使用的库（有关其他替代库，请参见[第290页](ch06.xhtml#common01)的“其他物理库”，并查看本书网站上的例子，看看如何将本章的示例移植到其他库中）。然而，这两个库与p5.js很好地集成，并且将使我能够展示物理引擎的基本概念以及它们如何与我迄今为止介绍的内容相关联和相互补充。
- en: Ultimately, the aim of this chapter isn’t to teach you the details of a specific
    physics library, but to provide you with a foundation for working with *any* physics
    library. The skills you acquire here will enable you to navigate and understand
    documentation, opening the door for you to expand your abilities with any library
    you choose.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，本章的目的不是教你某个具体物理库的细节，而是为你提供一个使用*任何*物理库的基础。你在这里获得的技能将使你能够浏览和理解文档，为你打开通向使用任何库的能力的大门。
- en: '**Why Use a Physics Library?**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为什么使用物理库？**'
- en: I’ve made the case for writing your own physics simulations (as you’ve learned
    to do in the previous chapters), but why use a physics library? After all, adding
    any external framework or library to a project introduces complexity and extra
    code. Is that additional overhead worth it? If you just want to simulate a circle
    falling down because of gravity, for example, do you really need to import an
    entire physics engine and learn its API? As the early chapters of this book hopefully
    demonstrated, probably not. Lots of scenarios like this are simple enough for
    you to get by writing the code yourself.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提出了编写你自己物理仿真的理由（正如你在前几章中学到的那样），但是为什么要使用物理库呢？毕竟，将任何外部框架或库添加到项目中会引入复杂性和额外的代码。额外的开销值得吗？例如，如果你只是想模拟一个因为重力而下落的圆形物体，你真的需要导入一个完整的物理引擎并学习它的API吗？正如本书的前几章所展示的那样，可能并不需要。许多这样的场景足够简单，你完全可以通过自己编写代码来解决。
- en: But consider another scenario. What if you want to have 100 circles falling?
    And what if they aren’t circles at all, but rather irregularly shaped polygons?
    And what if you want these polygons to bounce off one another in a realistic manner
    when they collide?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但请考虑另一个场景。如果你想要让100个圆形物体掉落呢？如果它们根本不是圆形，而是不规则形状的多边形呢？而且，如果你希望这些多边形在碰撞时能够以一种现实的方式互相反弹呢？
- en: 'You may have noticed that while I’ve covered motion and forces in detail, I’ve
    so far skipped over a rather important aspect of physics simulation: **collisions**.
    Let’s pretend for a moment that you aren’t reading a chapter about physics libraries
    and that I’ve decided right now to explain how to handle collisions in a particle
    system. I’d have to cover two distinct algorithms that address these questions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你已经注意到，虽然我详细介绍了运动和力量，但到目前为止，我却略过了物理模拟中一个相当重要的方面：**碰撞**。假设一下，你现在不是在阅读关于物理库的章节，而是我决定立即解释如何在粒子系统中处理碰撞。我必须讨论两种不同的算法来解决这些问题：
- en: How do I determine if two shapes are colliding (or intersecting)? This is known
    as **collision detection**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确定两个形状是否发生碰撞（或相交）？这被称为**碰撞检测**。
- en: How do I determine the shapes’ velocities after the collision? This is known
    as **collision resolution**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确定碰撞后形状的速度？这被称为**碰撞解决**。
- en: If you’re working with simple geometric shapes, question 1 isn’t too tough.
    In fact, perhaps you’ve encountered it before. With two circles, for instance,
    you know they’re intersecting if the distance between their centers is less than
    the sum of their radii (see [Figure 6.1](ch06.xhtml#ch6fig1)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在处理简单的几何形状，第一个问题并不太难。事实上，也许你之前已经遇到过类似的情况。例如，对于两个圆来说，如果它们的中心之间的距离小于它们半径的和，你就知道它们是相交的（见[图
    6.1](ch06.xhtml#ch6fig1)）。
- en: '![Image](../images/pg329_Image_504.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg329_Image_504.jpg)'
- en: 'Figure 6.1: Two circles with radii *r*[1] and *r*[2] are colliding if the distance
    between them is less than *r*[1] + *r*[2].'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：两个半径分别为 *r*[1] 和 *r*[2] 的圆，如果它们之间的距离小于 *r*[1] + *r*[2]，则它们发生碰撞。
- en: That’s easy enough, but how about calculating the circles’ velocities after
    the collision? This is where I’m going to stop the discussion. Why, you ask? It’s
    not that understanding the math behind collisions isn’t important or valuable.
    (In fact, I’m including additional examples on the website related to collisions
    without a physics library.) The reason for stopping is that life is short! (Let
    this also be a reason for you to consider going outside and frolicking for a bit
    before sitting down to write your next sketch.) You can’t expect to master every
    detail of physics simulation. And while you might enjoy learning about collision
    resolution for circles, it’s only going to make you want to work with rectangles
    next. And then with strangely shaped polygons. And then curved surfaces. And then
    swinging pendulums colliding with springy springs. And then, and then, and then
    . . .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但是计算碰撞后圆的速度怎么样呢？这就是我要停止讨论的地方。为什么，你问？不是因为理解碰撞背后的数学不重要或没有价值。（事实上，我在网站上还包含了关于不使用物理库的碰撞的额外例子。）停止的原因是生命是短暂的！（这也是你考虑出去玩一会儿然后再坐下来写下一个草图的一个理由。）你不能指望掌握物理模拟的每一个细节。虽然你可能喜欢学习圆形碰撞的碰撞解决方案，但这只会让你想要处理下一个矩形。然后是奇怪形状的多边形。然后是曲面。然后是摆动的钟摆和弹簧的碰撞。然后，然后，然后……
- en: Incorporating complex features like collisions into a p5.js sketch while still
    having time to spend with friends and family—that’s the reason for this chapter.
    People have spent years developing solutions to these kinds of problems, and beautiful
    JavaScript libraries like Matter.js and Toxiclibs.js are the fruits of those efforts.
    You don’t need to reinvent the proverbial wheel, at least for now.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将像碰撞这样的复杂特性纳入 p5.js 的草图中，同时还有时间与朋友和家人在一起——这就是本章的原因。人们花了多年时间开发解决这类问题的解决方案，而像
    Matter.js 和 Toxiclibs.js 这样美妙的 JavaScript 库就是这些努力的成果。至少现在你不需要重新发明“轮子”。
- en: In conclusion, if you find yourself describing an idea for a p5.js sketch and
    the word *collisions* comes up, then it’s likely time to learn to use a physics
    engine.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，如果你发现自己在描述一个 p5.js 草图的想法时，提到了“碰撞”这个词，那么现在可能是时候学习使用物理引擎了。
- en: '![Image](../images/zoom.jpg) **Other Physics Libraries**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **其他物理库**'
- en: A multitude of other physics libraries are worth exploring alongside this chapter’s
    two case studies, each with unique strengths that may offer advantages in certain
    kinds of projects. In fact, when I first began writing this book, Matter.js didn’t
    exist, so the physics engine I initially used to demonstrate the examples was
    Box2D. It was (and likely still is) the most well-known physics engine of them
    all.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他物理库值得与本章的两个案例一起探索，每个库都有独特的优势，可能在某些类型的项目中提供优势。事实上，当我刚开始写这本书时，Matter.js还不存在，因此我最初用来展示示例的物理引擎是Box2D。它曾是（并且可能仍然是）最著名的物理引擎。
- en: Box2D (*[https://box2d.org](https://box2d.org)*) began as a set of physics tutorials
    written in C++ by Erin Catto for the Game Developers Conference in 2006\. Since
    then, Box2D has evolved into a rich and elaborate open source physics engine.
    It’s been used for countless projects, most notably highly successful games such
    as the award-winning *Crayon Physics* and the runaway hit *Angry Birds*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D (*[https://box2d.org](https://box2d.org)*) 最初是由Erin Catto为2006年的游戏开发者大会编写的一系列C++物理教程。自那时以来，Box2D已经发展成一个丰富且复杂的开源物理引擎。它已被用于无数项目中，最著名的包括获奖游戏*Crayon
    Physics*和风靡一时的*Angry Birds*。
- en: 'One important feature of Box2D is that it’s a true physics engine: it knows
    nothing about computer graphics and the world of pixels, and instead does all
    its measurements and calculations in real-world units like meters, kilograms,
    and seconds. It’s just that its “world” (a key term in Box2D) is a 2D plane with
    top, bottom, left, and right edges. You tell it things like “The gravity of the
    world is 9.81 newtons per kilogram, and a circle with a radius of 4 meters and
    a mass of 50 kilograms is located 10 meters above the world’s bottom.” Box2D will
    then tell you things like “One second later, the rectangle is at 5 meters from
    the bottom; two seconds later, it’s 10 meters below,” and so on.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D的一个重要特性是它是一个真正的物理引擎：它对计算机图形和像素世界一无所知，而是以真实世界的单位进行所有的测量和计算，如米、千克和秒。它的“世界”（Box2D中的一个关键术语）是一个具有上下左右边界的二维平面。你告诉它诸如“世界的重力是每千克9.81牛顿，半径为4米、质量为50千克的圆形物体位于距离世界底部10米的地方。”
    Box2D然后会告诉你“1秒钟后，矩形距离底部5米；2秒钟后，它距离底部10米。”依此类推。
- en: While this provides for an amazingly accurate and robust physics engine (one
    that’s highly optimized and fast for C++ projects), it also necessitates lots
    of complicated code to translate back and forth between Box2D’s physics world
    and the world you want to draw—the pixel world of the graphics canvas. This creates
    a tremendous burden for the coder. I will, as best I can, continue to maintain
    a set of Box2D-compatible examples for this book (there are several JavaScript
    ports), but I believe the relative simplicity of working with a library like Matter.js
    that is native to JavaScript and uses pixels as the unit of measurement will make
    for a more intuitive and friendly bridge from my p5.js examples.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这提供了一个极其准确和强大的物理引擎（一个对C++项目高度优化且快速的引擎），但它也需要大量复杂的代码来在Box2D的物理世界与你想绘制的世界——即图形画布的像素世界——之间进行转换。这对程序员来说是一个巨大的负担。我将尽力继续为本书维护一组与Box2D兼容的示例（有几个JavaScript移植版本），但我相信，使用像Matter.js这样的库，它本土支持JavaScript并使用像素作为度量单位，将为我p5.js示例提供一个更直观、更友好的桥梁。
- en: Another notable library is p5play (*[https://p5play.org](https://p5play.org)*),
    a project initiated by Paolo Pedercini and currently led by Quinton Ashley that
    was specifically designed for game development. It simplifies the creation of
    visual objects—known as sprites—and manages their interactions (namely, collisions
    and overlaps). As you may have guessed from the name, p5play is tailored to work
    seamlessly with p5.js. It uses Box2D under the hood for physics simulation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的库是p5play (*[https://p5play.org](https://p5play.org)*)，这是由Paolo Pedercini发起、目前由Quinton
    Ashley领导的项目，专门为游戏开发设计。它简化了视觉对象——即精灵（sprites）的创建，并管理它们之间的交互（即碰撞和重叠）。正如你从名称中可能猜到的，p5play被量身定制以便与p5.js无缝配合使用。它在底层使用Box2D进行物理模拟。
- en: '**Importing the Matter.js Library**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入Matter.js库**'
- en: In a moment, I’ll turn to working with Matter.js, created by Liam Brummitt in
    2014\. But before you can use an external JavaScript library in a p5.js project,
    you need to import it into your sketch. As you’re already quite aware, I’m using
    the official p5.js web editor for developing and sharing this book’s code examples.
    The easiest way to add a library is to edit the *index.html* file that’s part
    of every new p5.js sketch created in the editor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我将开始使用由Liam Brummitt于2014年创建的Matter.js。不过，在你可以在p5.js项目中使用外部JavaScript库之前，你需要先将它导入到你的草图中。正如你已经非常清楚的那样，我正在使用官方的p5.js网页编辑器来开发和分享本书的代码示例。添加库的最简单方法是编辑每个新创建的p5.js草图中的*index.html*文件。
- en: To do that, first expand the file navigation bar on the left-hand side of the
    editor and select *index.html*, as shown in [Figure 6.2](ch06.xhtml#ch6fig2).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先展开编辑器左侧的文件导航栏，并选择*index.html*，如[图6.2](ch06.xhtml#ch6fig2)所示。
- en: The file includes a series of `<script>` tags inside the HTML tags `<head>`
    and `</head>`. This is how JavaScript libraries are referenced in a p5.js sketch.
    It’s no different from including `sketch.js` or `particle.js` in the page’s `<body>`,
    only here, instead of keeping and editing a copy of the JavaScript code, the library
    is referenced with a URL of a **content delivery network (CDN)**. This is a type
    of server for hosting files. For JavaScript libraries that are used across hundreds
    of thousands of web pages accessed by millions upon millions of users, CDNs need
    to be pretty good at their job of serving up these libraries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含一系列位于HTML标签`<head>`和`</head>`之间的`<script>`标签。这是如何在p5.js草图中引用JavaScript库的方式。它与在页面的`<body>`中包含`sketch.js`或`particle.js`没有什么不同，只是在这里，我们通过内容分发网络（**CDN**）的URL引用库，而不是保存和编辑JavaScript代码的副本。这是一种用于托管文件的服务器类型。对于那些在成千上万的网页中使用并被数百万用户访问的JavaScript库，CDN必须非常擅长提供这些库。
- en: '![Image](../images/pg332_Image_505.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg332_Image_505.jpg)'
- en: 'Figure 6.2: Accessing a sketch’s *index.html* file'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：访问草图的*index.html*文件
- en: 'You should already see a `<script>` tag referencing the CDN for p5.js (it may
    be a later version by the time you are reading this):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经看到一个引用p5.js CDN的`<script>`标签（当你阅读本文时，它可能是更新版本）：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To use Matter.js, add another `<script>` tag referencing its CDN right below
    the one for p5:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Matter.js，请在p5的`<script>`标签下面再添加一个引用其CDN的`<script>`标签：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At the time of this writing, the most recent version of Matter.js is `0.19.0`,
    and that’s what I’ve referenced in this snippet. As Matter.js updates and new
    versions are released, it’s often a good idea to upgrade, but by referencing a
    specific version that you know works with your sketch, you don’t have to worry
    about new features of the library breaking your existing code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这篇文章时，Matter.js的最新版本是`0.19.0`，我在这个代码片段中引用的就是这个版本。随着Matter.js的更新和新版本的发布，通常升级是个好主意，但通过引用一个特定的版本（你知道它与你的草图兼容），你就不必担心库的新特性会破坏你现有的代码。
- en: '**Matter.js Overview**'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Matter.js概述**'
- en: 'When you use Matter.js (or any physics engine) in p5.js, your code ends up
    looking a bit different. Here’s a pseudocode generalization of all the examples
    in [Chapters 1](ch01.xhtml#ch01) through [5](ch05.xhtml#ch05):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在p5.js中使用Matter.js（或任何物理引擎）时，你的代码看起来会有些不同。以下是[第1章](ch01.xhtml#ch01)到[第5章](ch05.xhtml#ch05)所有示例的伪代码概括：
- en: setup()
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: setup()
- en: Create all the objects in the world.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建世界中的所有物体。
- en: draw()
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: draw()
- en: Calculate all the forces in the world.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算世界中的所有力。
- en: Apply all the forces to the objects (*F* = *M* × *A*).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对物体应用所有的力（*F* = *M* × *A*）。
- en: Update the positions of all the objects based on their acceleration.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据物体的加速度更新它们的位置。
- en: Draw all the objects.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制所有物体。
- en: 'By contrast, here’s the pseudocode for a Matter.js example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，以下是一个Matter.js示例的伪代码：
- en: setup()
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: setup()
- en: Create all the objects in the world.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建世界中的所有物体。
- en: draw()
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: draw()
- en: Draw all the objects.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制所有物体。
- en: This, of course, is the allure of a physics engine. I’ve eliminated all those
    painful steps of figuring out how the objects are moving according to velocity
    and acceleration. Matter.js is going to take care of this for me!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这就是物理引擎的魅力所在。我已经消除了所有那些根据速度和加速度来计算物体如何运动的痛苦步骤。Matter.js将为我处理这一切！
- en: While there will be more details to reveal, the good news is that the simplicity
    of this pseudocode is an accurate reflection of the overall process. In this sense,
    Matter.js is a bit like a magic box. In `setup()`, I’m going to say to Matter,
    “Hello there. Here are all of the things I want in my world.” Then, in `draw()`,
    I’m going to politely ask Matter, “Oh, hello again. If it’s not too much trouble,
    I’d like to draw all of those things in my world. Could you please tell me where
    they are?”
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然还会有更多的细节揭示，但好消息是，这段伪代码的简单性准确反映了整个过程。从这个意义上来说，Matter.js有点像一个魔法盒子。在`setup()`中，我将对Matter说：“你好，这里是我在世界中想要的所有东西。”然后，在`draw()`中，我将礼貌地对Matter说：“哦，又见面了。如果不麻烦的话，我想把这些东西画出来。能告诉我它们在哪里吗？”
- en: 'The bad news: the process is not quite as simple as the pseudocode might lead
    you to believe. Actually making the stuff that goes into the Matter.js world requires
    several steps related to building and configuring different kinds of shapes.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息是：这个过程并不像伪代码所暗示的那样简单。实际上，创建进入Matter.js世界的东西需要几个步骤，这些步骤与构建和配置不同种类的形状有关。
- en: 'It’s also necessary to learn to speak the language of Matter.js in terms of
    how the various forces and other parameters of the world are configured. Here
    are the core concepts:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 学会使用Matter.js的语言配置世界中各种力和其他参数也是必要的。以下是核心概念：
- en: '**Engine:** The entity that manages the physics simulation itself. The engine
    holds on to the world of the simulation as well as various properties indicating
    how the world is updated over time.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引擎：** 管理物理模拟本身的实体。引擎持有模拟世界以及各种表示世界如何随着时间推移更新的属性。'
- en: '**Bodies:** The primary elements in the world, corresponding to the physical
    objects being simulated. A body has a position and a velocity. Sound familiar?
    It’s basically another version of the class I’ve been building throughout [Chapters
    1](ch01.xhtml#ch01) through [5](ch05.xhtml#ch05). It also has geometry to define
    its shape. It’s important to note that *body* is a generic term that physics engines
    use to describe a *thing* in the world (similarly to the term *particle*); it
    isn’t related to an anthropomorphic body.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物体：** 世界中的主要元素，对应于正在被模拟的物理对象。物体有位置和速度。听起来很熟悉吧？它基本上是我在[第1章](ch01.xhtml#ch01)到[第5章](ch05.xhtml#ch05)中一直在构建的类的另一种版本。它还具有定义形状的几何属性。需要注意的是，*物体*是物理引擎用来描述世界中*事物*的通用术语（类似于*粒子*这个术语）；它与拟人化的身体无关。'
- en: '**Composite:** A container that allows for the creation of complex entities
    (made up of multiple bodies). The world itself is an example of a composite, and
    every body created has to be added to the world.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合体：** 一个容器，允许创建复杂的实体（由多个物体组成）。世界本身就是一个复合体的例子，且每个创建的物体都必须被添加到世界中。'
- en: '**Constraints:** Act as connections between bodies.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**约束：** 作为物体之间的连接。'
- en: 'In the coming sections, I’ll walk through each of these elements in detail,
    building several examples along the way. But first, there’s one other important
    element to briefly discuss:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将详细介绍这些元素，并在此过程中构建几个示例。但首先，还有一个重要的元素需要简要讨论：
- en: '**Vector:** Describes an entity with magnitude and direction using x- and y-components,
    defining positions, velocities, and forces in a Matter.js world.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量：** 使用x和y分量描述一个具有大小和方向的实体，定义在Matter.js世界中的位置、速度和力。'
- en: This brings us to an important crossroads. Any physics library is fundamentally
    built around vectors, and depending on how you spin it, that’s either a good thing
    or a bad thing. The good part is that you’ve just spent several chapters familiarizing
    yourself with what it means to describe motion and forces with vectors, so there’s
    nothing conceptually new for you to learn. The bad part—the part that makes a
    single tear fall from my eye—is that once you cross this threshold into the brave
    new world of physics libraries, you don’t get to use `p5.Vector` anymore.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这把我们带到了一个重要的交叉点。任何物理库的基础都是向量，取决于你如何看待，它可以是好事也可以是坏事。好的一面是，你刚刚花了好几章时间熟悉如何用向量描述运动和力，因此在概念上你不需要学习新的内容。坏的一面——让我眼中掉下了一滴泪——是，一旦你跨越了进入物理库的这道门槛，你就不再能使用`p5.Vector`了。
- en: It’s been great that p5.js has a built-in vector representation, but anytime
    you use a physics library, you’ll likely discover that it includes its own separate
    vector implementation, designed to be especially compatible with the rest of the
    library’s code. This makes sense. After all, why should Matter.js be expected
    to know about `p5.Vector` objects?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很高兴p5.js有内建的向量表示，但每次你使用物理库时，你很可能会发现它包括了自己独立的向量实现，设计上特别兼容库的其他代码。这是有道理的。毕竟，为什么Matter.js应该了解`p5.Vector`对象呢？
- en: The upshot of all this is that while you won’t have to learn any new concepts,
    you do have to get used to new naming conventions and syntax. To illustrate, I’ll
    show you some now-familiar `p5.Vector` operations alongside the equivalent `Matter.Vector`
    code. First, how do you create a vector?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切的结果是，虽然你不需要学习任何新的概念，但你确实需要习惯新的命名约定和语法。为了说明这一点，我将展示一些现在已熟悉的`p5.Vector`操作，以及等效的`Matter.Vector`代码。首先，如何创建一个向量？
- en: '| **p5.js** | **Matter.js** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **p5.js** | **Matter.js** |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: What about adding two vectors together?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，两个向量相加怎么办？
- en: '| **p5.js** | **Matter.js** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **p5.js** | **Matter.js** |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'That overwrites vector `a` with the result. Here’s how to put the result in
    a separate vector instead:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这会用结果覆盖向量`a`。以下是如何将结果放入一个单独向量的方法：
- en: '| **p5.js** | **Matter.js** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **p5.js** | **Matter.js** |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: How about if you want to scale the vector (multiply by a scalar value)?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想缩放向量（乘以标量值）怎么办？
- en: '| **p5.js** | **Matter.js** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **p5.js** | **Matter.js** |'
- en: '| --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Magnitude and normalize?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 大小和归一化？
- en: '| **p5.js** | **Matter.js** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **p5.js** | **Matter.js** |'
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: As you can see, the concepts are the same, but the specifics of the code are
    different. First, every method name is now preceded by `Matter.Vector`, which
    defines the **namespace** of the source code. This is common for JavaScript libraries;
    p5.js is unusual for not consistently using namespaces. For example, to draw a
    circle in p5.js, you call `circle()` rather than `p5.circle()`. The `circle()`
    function lives in the global namespace. This, in my view, is one of the features
    that makes p5.js special in terms of ease of use and beginner friendliness. However,
    it also means that for any code you write with p5.js, you can’t use `circle` as
    a variable name. Namespacing a library protects against these kinds of errors
    and naming conflicts, and it’s why you’ll see everything in Matter.js called with
    the `Matter` prefix.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，概念是相同的，但代码的具体实现不同。首先，每个方法名称前面现在都加上了`Matter.Vector`，这定义了源代码的**命名空间**。这在JavaScript库中很常见；p5.js与其他库不同，它没有始终如一地使用命名空间。例如，在p5.js中画一个圆，你调用`circle()`而不是`p5.circle()`。`circle()`函数位于全局命名空间中。我认为这是p5.js在易用性和对初学者友好的方面的一个特点。然而，这也意味着在使用p5.js编写的任何代码中，你不能使用`circle`作为变量名。为库使用命名空间可以防止这类错误和命名冲突，这也是为什么你会看到Matter.js中的所有内容都带有`Matter`前缀的原因。
- en: 'In addition, unlike p5.js’s static and nonstatic versions of vector methods
    like `add()` and `mult()`, all vector methods in Matter.js are static. If you
    want to change a `Matter.Vector` while operating on it, you can add it as an optional
    argument: `Matter.Vector.add(a, b, a)` adds `a` and `b` and places the result
    in `a` (the third argument). You can also set an existing variable to the newly
    created vector object resulting from a calculation, as in `v = Matter.Vector.mult(v,
    2)`. However, this version still creates a new vector in memory rather than updating
    the old one.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与p5.js中的静态和非静态版本的向量方法如`add()`和`mult()`不同，Matter.js中的所有向量方法都是静态的。如果你想在操作`Matter.Vector`时更改它，可以将其作为可选参数添加：`Matter.Vector.add(a,
    b, a)`将`a`和`b`相加并将结果放入`a`（第三个参数）。你也可以将一个现有的变量设置为由计算结果生成的新向量对象，像这样`v = Matter.Vector.mult(v,
    2)`。然而，这个版本仍然会在内存中创建一个新向量，而不是更新旧的向量。
- en: I’ll cover more of the basics for working with `Matter.Vector` in this chapter,
    but for details, you can find the full documentation on the Matter.js website
    (*[https://brm.io/matter-js](https://brm.io/matter-js)*).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我会介绍更多关于`Matter.Vector`的基础知识，但如果你需要详细信息，可以在Matter.js的官方网站上找到完整文档（* [https://brm.io/matter-js](https://brm.io/matter-js)
    *）。
- en: '**Engine**'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**引擎**'
- en: 'Many physics libraries include a *world* object to manage everything. The world
    is typically in charge of the coordinate space, keeping a list of all the bodies
    in the simulation, controlling time, and more. In Matter.js, the world is created
    inside an `Engine` object, the main controller of your physics world and simulation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 许多物理库都包含一个*world*对象来管理所有的内容。世界通常负责坐标空间，保持模拟中所有物体的列表，控制时间等。在Matter.js中，世界是在`Engine`对象内创建的，这是你物理世界和模拟的主要控制器：
- en: '![Image](../images/pg336_Image_506.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg336_Image_506.jpg)'
- en: Notice that the very first line of code creates an `Engine` variable and sets
    it equal to `Matter.Engine`. Here, I’m deciding to point the single keyword `Engine`
    to the `Engine` class namespaced inside Matter.js in order to make my code less
    verbose. This works because I know I won’t be using the word `Engine` for any
    other variables, nor does it conflict with something in p5.js. I’ll be doing this
    with `Vector`, `Bodies`, `Composite`, and more as I continue to build the examples.
    (But while the linked source code will always include all the aliases, I won’t
    always show them in the book text.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一行代码创建了一个`Engine`变量，并将其设置为`Matter.Engine`。在这里，我决定将单个关键字`Engine`指向Matter.js中命名空间内的`Engine`类，以便让我的代码更加简洁。之所以这样做，是因为我知道后面不会再用到`Engine`这个词作为其他变量名，而且它也不会和p5.js中的某个东西冲突。在接下来的示例中，我还会对`Vector`、`Bodies`、`Composite`等进行类似的处理。（不过，虽然关联的源代码中会始终包括所有别名，但书中的文本不会每次都展示它们。）
- en: 'When you call `create()` on `Engine`, Matter.js returns a new physics engine
    and world with a default gravity—a vector (0, 1) pointing down. You can change
    this default by accessing the `gravity` variable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`Engine`上调用`create()`时，Matter.js会返回一个新的物理引擎和世界，并赋予默认的重力——一个指向下方的(0, 1)向量。你可以通过访问`gravity`变量来改变这个默认值：
- en: '![Image](../images/pg336_Image_507.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg336_Image_507.jpg)'
- en: Of course, gravity doesn’t have to be fixed for the duration of the simulation;
    you can adjust the gravity vector while your program is running. You can also
    turn gravity off altogether by setting it to a (0, 0) vector.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，重力不必在整个模拟过程中保持固定；你可以在程序运行时调整重力向量。你还可以通过将其设置为(0, 0)向量完全关闭重力。
- en: '![Image](../images/zoom.jpg) **Object Destructuring**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **对象解构**'
- en: '**Object destructuring** in JavaScript is a technique for extracting properties
    from an object and assigning them to variables. In the case of Matter.js, the
    `Matter` object contains the `Engine` property. Normally, an alias for this property
    can be set with `let Engine = Matter.Engine`, but with destructuring, the alias
    can be created more concisely:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象解构**是JavaScript中一种从对象中提取属性并将其赋值给变量的技术。在Matter.js中，`Matter`对象包含了`Engine`属性。通常，可以使用`let
    Engine = Matter.Engine`为这个属性设置别名，但使用解构后，可以更简洁地创建别名：'
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Hold on. Did you catch that I snuck in a `const` here? I know I said back in
    [Chapter 0](ch00.xhtml#ch00) that I would use only `let` for variable declarations
    throughout this book. However, working with an external library is a really good
    time to dip your toe in the `const` waters. In JavaScript, `const` is used for
    declaring variables whose values should never be reassigned after initialization.
    In this case, I want to protect myself from accidentally overwriting the `Engine`
    variable later in the code, which would likely break everything!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，你注意到我偷偷用了一个`const`吗？我记得在[第0章](ch00.xhtml#ch00)中说过，整本书中我只会使用`let`来声明变量。不过，使用外部库正是一个很好地尝试`const`的机会。在JavaScript中，`const`用于声明那些初始化后永远不应被重新赋值的变量。在这种情况下，我希望保护自己避免在代码后面不小心覆盖掉`Engine`变量，这样可能会把一切弄坏！
- en: 'With that out of the way, let’s look at how the destructuring syntax really
    shines when you need to create aliases to multiple properties of the same object:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 话说完了，接下来我们来看一下，当你需要为同一对象的多个属性创建别名时，解构语法是如何发挥作用的：
- en: '![Image](../images/pg337_Image_508.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg337_Image_508.jpg)'
- en: This sets up `Engine` as an alias for `Matter.Engine`, and `Vector` as an alias
    for `Matter.Vector`, all in one statement. I’ll use this technique throughout
    the chapter’s examples.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将`Engine`设置为`Matter.Engine`的别名，将`Vector`设置为`Matter.Vector`的别名，所有这些都在一个语句中完成。我将在本章的示例中使用这种技术。
- en: Once the world is initialized, it’s time to put stuff in it—bodies!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦世界初始化完成，就该往里面放东西——物体！
- en: '**Bodies**'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**物体**'
- en: The **body** is the primary element in the Matter.js world. It’s the equivalent
    of the `Vehicle` (née `Particle`, née `Mover`) class I built in previous chapters—the
    thing that moves around the space and experiences forces. A body can also be static
    (fixed and not moving).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**物体**是Matter.js世界中的主要元素。它相当于我在之前章节中创建的`Vehicle`（前身为`Particle`，再前身为`Mover`）类——也就是在空间中移动并经历力的东西。物体也可以是静态的（固定的，不会移动）。'
- en: 'Matter.js bodies are created using factory methods found in `Matter.Bodies`,
    with different methods available for creating different kinds of bodies. A **factory
    method** is a function that creates an object. While you’re probably more familiar
    with calling a constructor to create an object—for example, with `new Particle()`—you’ve
    seen factory methods before: `createVector()` is a factory method for creating
    a `p5.Vector` object. Whether an object is created from a constructor or a factory
    method is a matter of style and design choice by a library creator.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Matter.js物体是通过在`Matter.Bodies`中找到的工厂方法创建的，创建不同类型物体的方法也有所不同。**工厂方法**是创建对象的函数。虽然你可能更熟悉使用构造函数来创建对象——例如，使用`new
    Particle()`——但你之前也见过工厂方法：`createVector()`是一个创建`p5.Vector`对象的工厂方法。无论一个对象是通过构造函数还是工厂方法创建，都是库作者的风格和设计选择问题。
- en: 'All the factory methods for creating bodies can be found in the `Matter.Bodies`
    documentation page (*[https://brm.io/matter-js/docs/classes/Bodies.html](https://brm.io/matter-js/docs/classes/Bodies.html)*).
    I’ll start with the `rectangle()` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建物体的所有工厂方法都可以在`Matter.Bodies`文档页面中找到（*[https://brm.io/matter-js/docs/classes/Bodies.html](https://brm.io/matter-js/docs/classes/Bodies.html)*）。我将从`rectangle()`方法开始：
- en: '![Image](../images/pg338_Image_509.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg338_Image_509.jpg)'
- en: What luck! The `rectangle()` method signature is exactly the same as p5.js’s
    `rect()` function. In this case, however, the method isn’t *drawing* a rectangle
    but rather building the geometry for a `Body` object to store. (Note that calling
    `Bodies.rectangle()` works only if you first establish `Bodies` as an alias to
    `Matter.Bodies`.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 真幸运！`rectangle()`方法的签名与p5.js的`rect()`函数完全相同。然而，在这个例子中，该方法不是*绘制*一个矩形，而是为`Body`对象构建几何形状来存储。（注意，调用`Bodies.rectangle()`只有在你首先将`Bodies`作为`Matter.Bodies`的别名时才有效。）
- en: 'A body has now been created with a position and a size, and a reference to
    it is stored in the variable `box`. Bodies have many more properties that affect
    their motion, however. For example, density ultimately determines that body’s
    mass. Friction and restitution (bounciness) affect how the body interacts when
    it comes into contact with other bodies. For most cases, the defaults are sufficient,
    but Matter.js does allow you to specify these properties by passing through an
    additional argument to the factory method in the form of a JavaScript **object
    literal**, a collection of key-value pairs separated by commas and enclosed in
    curly brackets:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个物体现在已经被创建，并具有一个位置和大小，并且对它的引用存储在变量`box`中。然而，物体还有许多其他影响其运动的属性。例如，密度最终决定了物体的质量。摩擦力和恢复力（弹性）影响物体与其他物体接触时的相互作用。对于大多数情况，默认值已经足够，但Matter.js确实允许你通过向工厂方法传递额外的参数来指定这些属性，这些参数的形式是一个JavaScript**对象字面量**，它是由逗号分隔并被花括号括起来的键值对集合：
- en: '![Image](../images/pg338_Image_510.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg338_Image_510.jpg)'
- en: 'Each key in the object literal (for example, `friction`) serves as a unique
    identifier, and its value ( `0.5` ) is the data associated with that key. You
    can think of an object literal as a simple dictionary or lookup table—in this
    case, holding the desired settings for a new Matter.js body. Note, however, that
    while the `options` argument is useful for configuring the body, other initial
    conditions, such as linear or angular velocity, can be set via static methods
    of the `Matter.Body` class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量中的每个键（例如，`friction`）作为一个唯一的标识符，而它的值（`0.5`）是与该键相关的数据。你可以将对象字面量看作一个简单的字典或查找表——在这个例子中，它保存了用于创建新Matter.js物体的设置。请注意，虽然`options`参数对于配置物体非常有用，但其他初始条件，例如线性或角速度，可以通过`Matter.Body`类的静态方法来设置：
- en: '![Image](../images/pg338_Image_511.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg338_Image_511.jpg)'
- en: 'Creating a body and storing it in a variable isn’t enough. Any body must be
    explicitly added to the world in order for it to be simulated with physics. The
    physics world is a `Composite` object called `world` stored inside the `engine`
    itself. The `box` can be added to that world with the static `add()` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个物体并将其存储在变量中并不足够。任何物体必须显式地添加到世界中，才能通过物理模拟。物理世界是一个名为`world`的`Composite`对象，存储在`engine`内部。可以通过静态的`add()`方法将`box`添加到这个世界中：
- en: '![Image](../images/pg339_Image_512.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg339_Image_512.jpg)'
- en: This extra step is easy to forget—it’s a mistake I’ve made on countless occasions.
    If you’re ever wondering why one of your objects doesn’t appear or move along
    with the world’s physics, always check that you’ve actually added it to the world!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个额外的步骤很容易被忘记——这是我无数次犯过的错误。如果你曾经想知道为什么你的物体没有出现或者没有随着世界物理的变化而移动，记得检查你是否已经将它添加到世界中了！
- en: '![Image](../images/pencil.jpg) **Exercise 6.1**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 6.1**'
- en: 'Knowing what you know about Matter.js so far, fill in the blank in the following
    code that demonstrates how to make a circular body:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了目前关于Matter.js的知识后，请填写以下代码中的空白部分，以展示如何创建一个圆形物体：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Render**'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**Render**'
- en: Once a body is added to the world, Matter.js will always know it’s there, check
    it for collisions, and update its position appropriately, according to any forces
    in the environment. It’ll do all that without you having to lift a finger! But
    how do you draw the body?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个物体被添加到世界中，Matter.js将始终知道它的存在，检查它是否发生碰撞，并根据环境中的任何力更新它的位置。所有这些都不需要你动一根手指！但你怎么画出这个物体呢？
- en: 'In the next section, I’ll show you how to query Matter.js for the position
    of the various bodies in order to render the world with p5.js. The way that works
    is fundamental to being able to control the look of your own animations. This
    is your time to shine: you can be the designer of your world, using your creativity
    and p5.js skills to visualize the bodies, while politely asking Matter.js to compute
    all the physics in the background.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我将向你展示如何查询Matter.js中各种物体的位置，以便用p5.js渲染世界。这种方法对于能够控制你自己的动画外观至关重要。这是你大展拳脚的时候：你可以成为你世界的设计师，利用你的创造力和p5.js技能来可视化物体，同时礼貌地让Matter.js在后台计算所有物理。
- en: That said, Matter.js does include a fairly simple and straightforward `Render`
    class, which is incredibly useful for quickly seeing and debugging the world you’ve
    designed. It provides ways to customize the *debug drawing* style, but I find
    the defaults perfectly adequate for quickly double-checking that I’ve configured
    a world correctly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，Matter.js确实包括一个非常简单直观的`Render`类，这对于快速查看和调试你设计的世界非常有用。它提供了自定义*调试绘图*样式的方法，但我发现默认设置足以快速检查我是否正确配置了世界。
- en: The first step is to call `Matter.Render.create()` (or `Render.create()`, assuming
    an alias). This method expects an object with the desired settings for the renderer,
    which I’ll call `params`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是调用`Matter.Render.create()`（或者如果用了别名则是`Render.create()`）。这个方法需要一个包含渲染器所需设置的对象，我将其称为`params`。
- en: '![Image](../images/pg340_Image_513.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg340_Image_513.jpg)'
- en: Notice that I’m storing a reference to the p5.js canvas in the `canvas` variable.
    This is necessary because I need to tell the renderer to draw in a specific canvas.
    Matter.js doesn’t know about p5.js, so the canvas it’s assigned is a native HTML5
    canvas, stored inside the `elt` property of a p5.js canvas object. The engine
    is the `engine` I previously created. The Matter.js default canvas dimensions
    are 800×600, so if I prefer a different size, I need to configure an `options`
    property with `width` and `height`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我将p5.js画布的引用存储在`canvas`变量中。这是必要的，因为我需要告诉渲染器在特定的画布上绘制。Matter.js并不知道p5.js，所以它所分配的画布是一个原生的HTML5画布，存储在p5.js画布对象的`elt`属性中。引擎是我之前创建的`engine`。Matter.js的默认画布尺寸为800×600，如果我希望使用不同的尺寸，我需要配置一个包含`width`和`height`的`options`属性。
- en: 'Once I have a `render` object, I need to tell Matter.js to run it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我有了`render`对象，我需要告诉Matter.js去运行它：
- en: '![Image](../images/pg340_Image_514.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg340_Image_514.jpg)'
- en: 'One more critical order of business remains: physics engines must be told to
    step forward in time. Since I’m using the built-in renderer, I can also use the
    built-in runner, which runs the engine at a default frame rate of 60 frames per
    second. The runner is also customizable, but the details aren’t terribly important
    since the goal here is to move toward using p5.js’s `draw()` loop instead (coming
    in the next section):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的步骤：物理引擎必须被告知在时间上向前推进。由于我使用的是内置渲染器，我还可以使用内置的运行器，它以每秒 60 帧的默认帧率运行引擎。运行器也是可以自定义的，但由于目标是在接下来的部分中改用
    p5.js 的 `draw()` 循环（将在下一节介绍），所以这些细节并不那么重要：
- en: '![Image](../images/pg340_Image_515.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg340_Image_515.jpg)'
- en: 'Here’s the Matter.js code all together, with an added `ground` object—another
    rectangular body. Note the use of the `{ isStatic: true }` option in the creation
    of the ground body to ensure that it remains in a fixed position. I’ll cover more
    details about static bodies in “Static Matter.js Bodies” on [page 307](ch06.xhtml#ch00lev1sec59).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '这是完整的 Matter.js 代码，其中新增了一个 `ground` 对象——另一个矩形物体。注意在创建地面物体时使用了 `{ isStatic:
    true }` 选项，以确保它保持在固定位置。关于静态物体的更多细节，我将在[第 307 页](ch06.xhtml#ch00lev1sec59)的《静态
    Matter.js 物体》一节中介绍。'
- en: '![Image](../images/pg341_Image_516.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg341_Image_516.jpg)'
- en: There’s no `draw()` function here, and all the variables are local to `setup()`.
    In fact, I’m not using any p5.js capabilities (beyond injecting a canvas onto
    the page). This is exactly what I want to tackle next!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有 `draw()` 函数，所有变量都在 `setup()` 中是局部的。实际上，我并没有使用任何 p5.js 的功能（除了将画布注入到页面中）。这正是我接下来要解决的问题！
- en: '**Matter.js with p5.js**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Matter.js 与 p5.js**'
- en: Matter.js keeps a list of all bodies that exist in the world, and as you’ve
    just seen, it can handle drawing and animating them with the `Render` and `Runner`
    objects. (That list, incidentally, is stored in `engine.world.bodies`.) What I’d
    like to show you now, however, is a technique for keeping your own list(s) of
    Matter.js bodies, so you can draw them with p5.js.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Matter.js 会保持一个所有物体的列表，正如你刚才看到的，它可以通过 `Render` 和 `Runner` 对象来处理物体的绘制和动画。顺便提一下，这个列表存储在
    `engine.world.bodies` 中。不过，我现在想展示的是一种技术，用于维护你自己的 Matter.js 物体列表，以便你可以使用 p5.js
    来绘制它们。
- en: Yes, this approach may add redundancy and sacrifice a small amount of efficiency,
    but it more than makes up for that with ease of use and customization. With this
    methodology, you’ll be able to code as you’re accustomed to in p5.js, keeping
    track of which bodies are which and drawing them appropriately. Consider the file
    structure of the sketch shown in [Figure 6.3](ch06.xhtml#ch6fig3).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这种方法可能会增加冗余并牺牲一些效率，但它通过简便的使用和定制弥补了这一点。通过这种方法，你将能够像在 p5.js 中一样进行编码，跟踪哪些物体是哪个，并适当地绘制它们。请参阅[图
    6.3](ch06.xhtml#ch6fig3)中显示的草图文件结构。
- en: '![Image](../images/pg342_Image_517.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg342_Image_517.jpg)'
- en: 'Figure 6.3: The file structure of a typical p5.js sketch'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：典型 p5.js 草图的文件结构
- en: 'Structurally, this looks like just another p5.js sketch. There’s a main *sketch.js*
    file, as well as *box.js*. This sort of extra file is where I’d typically declare
    a class needed for the sketch—in this case, a `Box` class describing a rectangular
    body in the world:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从结构上看，这看起来只是另一个 p5.js 草图。它包含一个主要的*sketch.js* 文件，还有 *box.js* 文件。这样的额外文件通常是用来声明草图中需要的类——在这个例子中，是描述世界中矩形物体的
    `Box` 类：
- en: '![Image](../images/pg342_Image_518.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg342_Image_518.jpg)'
- en: Now I’ll write a *sketch.js* file that creates a new `Box` whenever the mouse
    is clicked and stores all the `Box` objects in an array. (This is the same approach
    I took in the particle system examples from [Chapter 4](ch04.xhtml#ch04).)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将编写一个 *sketch.js* 文件，每当点击鼠标时创建一个新的 `Box` 并将所有 `Box` 对象存储在一个数组中。（这与我在[第 4
    章](ch04.xhtml#ch04)的粒子系统示例中采用的方法相同。）
- en: '![Image](../images/pg343_Image_520.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg343_Image_520.jpg)'
- en: 'Right now, this sketch draws fixed boxes to the screen. Here’s the challenge:
    How can I instead draw boxes that experience physics (calculated with Matter.js)
    as soon as they appear, while changing the code as little as possible?'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个草图会将固定的盒子绘制到屏幕上。挑战是：我如何才能绘制出那些一出现就会经历物理计算（由 Matter.js 计算）的盒子，同时尽量少修改代码？
- en: I’ll need three steps to accomplish this goal.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我需要三步。
- en: '**Step 1: Add Matter.js to the p5.js Sketch**'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第 1 步：将 Matter.js 添加到 p5.js 草图中**'
- en: 'As it stands, the sketch makes no reference to Matter.js. That clearly needs
    to change. Fortunately, this part isn’t too tough: I’ve already demonstrated all
    the elements needed to build a Matter.js world. (And don’t forget, in order for
    this to work, make sure the library is imported in *index.html.*)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，草图中没有引用Matter.js。这显然需要改变。幸运的是，这部分不算太难：我已经展示了构建Matter.js世界所需的所有元素。（别忘了，为了让这个工作正常进行，确保在*index.html*中导入了这个库。）
- en: 'First, I need to add aliases for the necessary Matter.js classes and create
    an `Engine` object in `setup()`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要为必要的Matter.js类添加别名，并在`setup()`中创建一个`Engine`对象：
- en: '![Image](../images/pg344_Image_522.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg344_Image_522.jpg)'
- en: 'Then, in `draw()`, I need to make sure to call one critical Matter.js method,
    `Engine.update()`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`draw()`中，我需要确保调用一个关键的Matter.js方法，`Engine.update()`：
- en: '![Image](../images/pg344_Image_523.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg344_Image_523.jpg)'
- en: The `Engine.update()` method advances the physics world one step forward in
    time. Calling it inside the p5.js `draw()` loop ensures that the physics will
    update at every frame of the animation. This mechanism takes the place of the
    built-in Matter.js `Runner` object I used in [Example 6.1](ch06.xhtml#ch6ex1).
    The `draw()` loop is the runner now!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Engine.update()`方法将物理世界推进一步。将其放在p5.js的`draw()`循环中调用，确保物理引擎在每一帧动画中都进行更新。这个机制取代了我在[示例6.1](ch06.xhtml#ch6ex1)中使用的内建Matter.js
    `Runner`对象。现在`draw()`循环就是运行器！'
- en: Internally, when `Engine.update()` is called, Matter.js sweeps through the world,
    looks at all the bodies in it, and figures out what to do with them. Just calling
    `Engine.update()` on its own moves the world forward with default settings. However,
    as with `Render`, these settings are customizable and documented in the Matter.js
    documentation (*[https://brm.io/matter-js/docs/classes/Engine.html#method_update](https://brm.io/matter-js/docs/classes/Engine.html#method_update)*).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，当调用`Engine.update()`时，Matter.js会遍历世界，查看其中的所有物体，并决定如何处理它们。仅仅调用`Engine.update()`会将世界按默认设置向前推进。然而，与`Render`一样，这些设置是可以自定义的，并在Matter.js文档中有所说明（*
    [https://brm.io/matter-js/docs/classes/Engine.html#method_update](https://brm.io/matter-js/docs/classes/Engine.html#method_update)*）。
- en: '**Step 2: Link Every Box Object with a Matter.js Body**'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤2：将每个Box对象与Matter.js物体链接**'
- en: I’ve set up my Matter.js world; now I need to link each `Box` object in my p5.js
    sketch with a body in that world. The original `Box` class includes variables
    for position and width. What I now want to say is “I hereby relinquish command
    of this object’s position to Matter.js. I no longer need to keep track of anything
    related to position, velocity, or acceleration. Instead, I need to keep track
    of only the existence of a Matter.js body and have faith that the physics engine
    will do the rest.”
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经设置好了我的Matter.js世界；现在，我需要将每个`Box`对象在我的p5.js草图中与那个世界中的物体链接起来。原始的`Box`类包含位置和宽度的变量。我现在想说的是：“我在此放弃对这个对象位置的控制，交给Matter.js。我不再需要跟踪任何与位置、速度或加速度相关的内容。相反，我只需要跟踪一个Matter.js物体的存在，并相信物理引擎会完成剩下的事情。”
- en: '![Image](../images/pg345_Image_524.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg345_Image_524.jpg)'
- en: I don’t need `this.x` and `this.y` position variables anymore. The `Box` constructor
    takes in the starting x- and y-coordinates, passes them along to `Bodies.rectangle()`
    to create a new Matter.js body, and then forgets about them. As you’ll see, the
    body itself will keep track of its position behind the scenes. The body could
    technically keep track of its dimensions as well, but since Matter.js stores them
    as a list of vertices, it’s a bit more convenient to hold onto the width of the
    square in the `this.w` variable for when it comes time to draw the box.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我不再需要`this.x`和`this.y`位置变量了。`Box`构造函数接收起始的x和y坐标，将它们传递给`Bodies.rectangle()`以创建一个新的Matter.js物体，然后忘记这些值。正如你将看到的，物体本身会在幕后跟踪其位置。物体理论上也可以跟踪其尺寸，但由于Matter.js将它们存储为一个顶点列表，因此在绘制方框时，保留方块的宽度在`this.w`变量中会更方便。
- en: '**Step 3: Draw the Body**'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤3：绘制物体**'
- en: 'Almost there. Before I introduced Matter.js into the sketch, drawing `Box`
    was easy. The object’s position was stored in the variables `this.x` and `this.y`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 快完成了。在我将Matter.js引入草图之前，绘制`Box`是很简单的。该对象的位置存储在`this.x`和`this.y`变量中：
- en: '![Image](../images/pg345_Image_525.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg345_Image_525.jpg)'
- en: Now that Matter.js manages the object’s position, I can no longer use my own
    `x` and `y` variables to draw the shape. But fear not! The `Box` object has a
    reference to the Matter.js body associated with it, and that body knows its own
    position. All I need to do is politely ask the body, “Pardon me, where are you
    located?”
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 既然Matter.js管理物体的位置，我就不能再使用我自己的`x`和`y`变量来绘制该形状了。但别担心！`Box`对象有一个对Matter.js物体的引用，而该物体知道自己的位置。我所需要做的就是礼貌地问物体：“不好意思，请问你在哪里？”
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Just knowing the position of a body isn’t enough, however. The body is a square,
    so I also need to know its angle of rotation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅知道物体的位置是不够的。物体是一个方形，所以我还需要知道它的旋转角度：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once I have the position and angle, I can render the object by using the native
    p5.js `translate()`, `rotate()`, and `square()` functions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我得到了位置和角度，我就可以通过使用本地的p5.js `translate()`、`rotate()`和`square()`函数来渲染该物体：
- en: '![Image](../images/pg346_Image_526.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg346_Image_526.jpg)'
- en: 'It’s important to note here that if you delete a `Box` object from the `boxes`
    array—perhaps when it moves outside the boundaries of the canvas or reaches the
    end of its life span, as demonstrated in [Chapter 4](ch04.xhtml#ch04)—you must
    also explicitly remove the body associated with that `Box` object from the Matter.js
    world. This can be done with a `removeBody()` method on the `Box` class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的是，如果你从`boxes`数组中删除了一个`Box`对象——可能是因为它移动出了画布边界或达到了其生命周期的终点，如[第4章](ch04.xhtml#ch04)中所示——你还必须显式地从Matter.js世界中移除与该`Box`对象关联的物体。这可以通过在`Box`类中使用`removeBody()`方法来完成：
- en: '![Image](../images/pg346_Image_527.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg346_Image_527.jpg)'
- en: In `draw()`, you would then iterate over the array in reverse, just as in the
    particle system examples, and call both `removeBody()` and `splice()` to delete
    the object from the Matter.js world and your array of boxes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`中，你将按逆序遍历数组，就像粒子系统示例那样，调用`removeBody()`和`splice()`，以便从Matter.js世界和你的盒子数组中删除该对象。
- en: '![Image](../images/pencil.jpg) **Exercise 6.2**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习6.2**'
- en: Start with the code for [Example 6.2](ch06.xhtml#ch6ex2) and, using the methodology
    outlined in this chapter, add the code to implement Matter.js physics. Delete
    bodies that have left the canvas. The result should appear as in this image. Feel
    free to be creative in the way you draw the boxes!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从[示例6.2](ch06.xhtml#ch6ex2)的代码开始，按照本章中概述的方法，添加代码以实现Matter.js物理。删除离开画布的物体。结果应该如下图所示。你可以在绘制盒子时发挥创意！
- en: '![Image](../images/pg347_Image_528.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg347_Image_528.jpg)'
- en: '**Static Matter.js Bodies**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**静态 Matter.js 物体**'
- en: 'In the example I just created, the `Box` objects appear at the mouse position
    and fall downward because of the default gravity force. What if I want to add
    immovable boundaries to the world that will block the path of the falling `Box`
    objects? Matter.js makes this easy with the `isStatic` property:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我刚刚创建的示例中，`Box`对象出现在鼠标位置，并因默认的重力作用而向下掉落。如果我想为世界添加不可移动的边界来阻挡下落的`Box`对象怎么办？Matter.js通过`isStatic`属性使这一切变得简单：
- en: '![Image](../images/pg347_Image_529.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg347_Image_529.jpg)'
- en: I’m still creating a body with the `Bodies.rectangle()` factory method, but
    setting the `isStatic` property ensures that the body will never move. I’ll incorporate
    this feature into the solution to [Exercise 6.2](ch06.xhtml#ch6exe2) by creating
    a separate `Boundary` class that links a p5.js rectangle to a static Matter.js
    body. For variety, I’ll also randomize the dimensions of each falling box. (See
    the online code for the changes to the `Box` class.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然是使用`Bodies.rectangle()`工厂方法创建物体，但设置`isStatic`属性确保该物体永远不会移动。我将在[练习6.2](ch06.xhtml#ch6exe2)的解决方案中加入此功能，创建一个单独的`Boundary`类，将p5.js矩形与静态Matter.js物体连接起来。为了增加变化，我还将随机化每个掉落盒子的尺寸。（请参阅在线代码，了解`Box`类的更改。）
- en: '![Image](../images/pg348_Image_530.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg348_Image_530.jpg)'
- en: Static bodies don’t incorporate material properties like `restitution` or `friction`.
    Make sure you set those in the dynamic bodies in your world.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 静态物体不会包含如`恢复力`或`摩擦力`等物理属性。请确保在动态物体中设置这些属性。
- en: '**Polygons and Groups of Shapes**'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**多边形和形状组**'
- en: Now that I’ve demonstrated how easy it is to use a primitive shape like a rectangle
    or circle with Matter.js, let’s imagine that you want to create a more interesting
    body, such as the abstract character in [Figure 6.4](ch06.xhtml#ch6fig4).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经演示了如何使用像矩形或圆形这样的基本形状与Matter.js，假设你想创建一个更有趣的物体，比如[图6.4](ch06.xhtml#ch6fig4)中的抽象人物。
- en: '![Image](../images/pg349_Image_531.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg349_Image_531.jpg)'
- en: 'Figure 6.4: A compound body made up of multiple shapes'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：由多个形状组成的复合体
- en: 'Two strategies can be used to make such complex forms. The generic `Bodies.polygon()`
    method can create any regular polygon (pentagon, hexagon, and so on). Additionally,
    `Bodies.trapezoid()` makes a quadrilateral with at least one pair of parallel
    sides:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种策略来制作这种复杂的形状。通用的`Bodies.polygon()`方法可以创建任何规则的多边形（如五边形、六边形等）。另外，`Bodies.trapezoid()`可以创建一个至少有一对平行边的四边形：
- en: '![Image](../images/pg349_Image_532.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg349_Image_532.jpg)'
- en: A more general-purpose option is `Bodies.fromVertices()`. It builds a shape
    from an array of vectors, treating them as a series of connected vertices. I’ll
    encapsulate this logic in a `CustomShape` class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更通用的选项是`Bodies.fromVertices()`。它通过一个向量数组构建一个形状，将它们视为一系列连接的顶点。我将把这个逻辑封装在`CustomShape`类中。
- en: '![Image](../images/pg349_Image_533.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg349_Image_533.jpg)'
- en: When creating a custom polygon in Matter.js, you must remember two important
    details. First, the vertices must be specified in clockwise order. For instance,
    [Figure 6.5](ch06.xhtml#ch6fig5) shows the five vertices used to create the bodies
    in [Example 6.4](ch06.xhtml#ch6ex4). Notice that the example added them to the
    `vertices` array in clockwise order from the top left.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Matter.js 中创建自定义多边形时，你必须记住两个重要细节。首先，顶点必须按顺时针顺序指定。例如，[图 6.5](ch06.xhtml#ch6fig5)展示了用来创建[示例
    6.4](ch06.xhtml#ch6ex4)中物体的五个顶点。注意，示例将它们按从左上角开始的顺时针顺序添加到`vertices`数组中。
- en: '![Image](../images/pg350_Image_535.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg350_Image_535.jpg)'
- en: 'Figure 6.5: Vertices on a custom polygon oriented in clockwise order'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：按顺时针顺序排列的自定义多边形顶点
- en: Second, each shape must be convex, not concave. As shown in [Figure 6.6](ch06.xhtml#ch6fig6),
    a **concave** shape has a surface that curves inward, whereas **convex** is the
    opposite. Every internal angle in a convex shape must be 180 degrees or less.
    Matter.js can work with concave shapes, but you need to build them out of multiple
    convex shapes (more about that in a moment).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，每个形状必须是凸形的，而不是凹形的。如[图 6.6](ch06.xhtml#ch6fig6)所示，**凹形**的形状表面向内弯曲，而**凸形**则相反。每个凸形的内角必须小于或等于
    180 度。Matter.js 可以处理凹形状，但你需要将它们由多个凸形状组成（稍后会详细介绍）。
- en: '![Image](../images/pg351_Image_536.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg351_Image_536.jpg)'
- en: 'Figure 6.6: A concave shape can be drawn with multiple convex shapes.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：凹形状可以通过多个凸形状绘制。
- en: 'Since the shape is built out of custom vertices, you can use p5.js’s `beginShape()`,
    `endShape()`, and `vertex()` functions when it comes time to actually draw the
    body. The `CustomShape` class *could* include an array to store the vertices’
    pixel positions, relative to (0, 0), for drawing purposes. However, it’s best
    to query Matter.js for the positions instead. This way, there’s no need to use
    `translate()` or `rotate()`, since the Matter.js body stores its vertices as absolute
    world positions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于形状是由自定义顶点构建的，所以在绘制物体时，你可以使用 p5.js 的`beginShape()`、`endShape()`和`vertex()`函数。`CustomShape`类*可以*包括一个数组，用于存储顶点的像素位置，相对于
    (0, 0)，以便绘制。不过，最好是直接查询 Matter.js 来获取位置。这样，就不需要使用`translate()`或`rotate()`，因为 Matter.js
    物体将顶点存储为绝对世界坐标：
- en: '![Image](../images/pg351_Image_537.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg351_Image_537.jpg)'
- en: The Matter.js body stores the array of its vertex positions inside a `vertices`
    property. Notice that I can then use a `for...of` loop to cycle through the vertices
    between `beginShape()` and `endShape()`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Matter.js 物体将其顶点位置数组存储在一个`vertices`属性中。注意，我可以使用`for...of`循环在`beginShape()`和`endShape()`之间遍历这些顶点。
- en: '![Image](../images/pencil.jpg) **Exercise 6.3**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 6.3**'
- en: Using `Bodies.fromVertices()`, create your own polygon design (remember, it
    must be convex). Some possibilities are shown here.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Bodies.fromVertices()`创建你自己的多边形设计（记住，它必须是凸形的）。这里展示了一些可能的形状。
- en: '![Image](../images/pg352_Image_538.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg352_Image_538.jpg)'
- en: A custom shape built from an array of vertices will get you pretty far. However,
    the convex shape requirement does limit the range of possibilities. The good news
    is that you can eliminate this restriction by creating a **compound body** made
    up of multiple shapes! How about creating a delicious lollipop with a thin rectangle
    and a circle on top?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个顶点数组构建的自定义形状会让你走得很远。然而，凸形状的要求确实限制了可能性范围。好消息是，你可以通过创建由多个形状组成的**复合体**来消除这一限制！比如，使用一个细长的矩形和一个圆形在上面，做一个美味的棒棒糖怎么样？
- en: 'I’ll start by creating two individual bodies, one rectangle and one circle.
    Then I can join them by putting them in a `parts` array and passing the array
    to `Body.create()`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先创建两个独立的物体，一个矩形和一个圆形。然后，我可以通过将它们放入一个`parts`数组，并将该数组传递给`Body.create()`来将它们合并：
- en: '![Image](../images/pg352_Image_539.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg352_Image_539.jpg)'
- en: While this does create a compound body by combining two shapes, the code isn’t
    quite right. If you run it, you’ll see that both shapes are centered on the same
    (*x*, *y*) position, as in [Figure 6.7](ch06.xhtml#ch6fig7).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过组合两个形状创建了一个复合体，但代码并不完全正确。如果你运行它，你会发现两个形状都位于相同的(*x*, *y*)位置，正如[图 6.7](ch06.xhtml#ch6fig7)所示。
- en: '![Image](../images/pg352_Image_540.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg352_Image_540.jpg)'
- en: 'Figure 6.7: A rectangle and a circle with the same (*x*, *y*) reference point'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：一个矩形和一个圆形具有相同的(*x*, *y*)参考点
- en: Instead, I need to offset the center of the circle horizontally from the center
    of the rectangle, as in [Figure 6.8](ch06.xhtml#ch6fig8).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我需要将圆形的中心在水平方向上从矩形的中心偏移，如[图 6.8](ch06.xhtml#ch6fig8)所示。
- en: '![Image](../images/pg353_Image_541.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg353_Image_541.jpg)'
- en: 'Figure 6.8: A circle placed relative to a rectangle with a horizontal offset'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：一个相对于矩形水平偏移的圆形
- en: 'I’ll use half the width of the rectangle as the offset, so the circle is centered
    on the edge of the rectangle:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用矩形宽度的一半作为偏移量，这样圆形就会被居中在矩形的边缘：
- en: '![Image](../images/pg353_Image_542.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg353_Image_542.jpg)'
- en: Because the lollipop’s body has two parts, drawing it is a bit trickier. I could
    take multiple approaches. For example, I could use the body’s `vertices` array
    and draw the lollipop as a custom shape, much like [Example 6.4](ch06.xhtml#ch6ex4).
    (Every body stores an array of vertices, even if it wasn’t created with the `fromVertices()`
    method.) Since each part of the lollipop is a primitive shape, however, I’d prefer
    to separately translate to each part’s position and rotate by the collective body’s
    angle.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于棒棒糖的身体有两个部分，绘制它稍微复杂一点。我可以采用多种方法。例如，我可以使用物体的`vertices`数组，将棒棒糖绘制为一个自定义形状，就像[示例
    6.4](ch06.xhtml#ch6ex4)一样。（每个物体都会存储一个顶点数组，即使它不是通过`fromVertices()`方法创建的。）然而，由于棒棒糖的每个部分都是原始形状，我更倾向于分别平移到每个部分的位置，并按照整体物体的角度进行旋转。
- en: '![Image](../images/pg353_Image_543.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg353_Image_543.jpg)'
- en: Before moving on, I want to stress that what you draw in your canvas window
    doesn’t magically experience perfect physics just by the mere act of creating
    Matter.js bodies. The chapter’s examples have worked because I’ve been carefully
    matching the way I’ve drawn each p5.js body with the way I’ve defined the geometry
    of each Matter.js body. If you accidentally draw a shape differently, you won’t
    get an error—not from p5.js or from Matter.js. However, your sketch will look
    odd, and the physics won’t work correctly because the world you’re seeing won’t
    be aligned with the world as Matter.js understands it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想强调的是，单纯通过创建 Matter.js 物体并不会让你在画布窗口中绘制的内容自动表现出完美的物理效果。本章中的示例之所以有效，是因为我小心地匹配了每个
    p5.js 物体的绘制方式与我为每个 Matter.js 物体定义的几何形状。如果你不小心以不同的方式绘制了一个形状，你不会收到错误提示——无论是来自 p5.js
    还是 Matter.js。不过，你的画面看起来会很奇怪，物理效果也会不正常，因为你看到的世界与 Matter.js 理解的世界不一致。
- en: 'To illustrate, let me return to [Example 6.5](ch06.xhtml#ch6ex5). A lollipop
    is a compound body consisting of two parts, a rectangle ( `this.part1` ) and a
    circle ( `this.part2` ). I’ve been drawing each lollipop by getting the positions
    for the two parts separately: `this.part1.position` and `this.part2.position`.
    However, the overall compound body also has a position, `this.body.position`.
    It would be tempting to use that as the position for drawing the rectangle, and
    to figure out the circle’s position manually using an offset. After all, that’s
    how I conceived of the compound shape to begin with (look back at [Figure 6.8](ch06.xhtml#ch6fig8)):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我回到[示例 6.5](ch06.xhtml#ch6ex5)。一个棒棒糖是由两个部分组成的复合体，一个矩形（`this.part1`）和一个圆形（`this.part2`）。我一直是通过分别获取两个部分的位置来绘制每个棒棒糖：`this.part1.position`和`this.part2.position`。然而，整体复合体也有一个位置，`this.body.position`。使用这个位置来绘制矩形，并手动计算圆形的位置并使用偏移量，看起来很诱人。毕竟，这就是我最初设想复合形状的方式（回顾[图
    6.8](ch06.xhtml#ch6fig8)）：
- en: '![Image](../images/pg354_Image_545.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg354_Image_545.jpg)'
- en: '[Figure 6.9](ch06.xhtml#ch6fig9) shows the result of this change.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.9](ch06.xhtml#ch6fig9)展示了这一变化的结果。'
- en: '![Image](../images/pg355_Image_546.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg355_Image_546.jpg)'
- en: 'Figure 6.9: What happens when the shapes are drawn differently from their Matter.js
    configurations'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：当形状与它们在Matter.js中的配置不同绘制时会发生什么
- en: At first glance, this new version may look fine, but if you look closer, the
    collisions are off and the shapes overlap in odd ways. This isn’t because the
    physics is broken; it’s because I’m not communicating properly between p5.js and
    Matter.js. It turns out the overall body position isn’t the center of the rectangle,
    but rather the center of mass between the rectangle and the circle. Matter.js
    is calculating the physics and managing collisions as before, but I’m drawing
    each body in the wrong place! (In the online version, you can toggle the correct
    and incorrect renderings by clicking the mouse.)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个新版本可能看起来没问题，但如果仔细观察，碰撞就会出现偏差，形状也会以奇怪的方式重叠。这并不是物理引擎出了问题，而是我没有在p5.js和Matter.js之间正确地进行通信。事实证明，物体的整体位置不是矩形的中心，而是矩形与圆形之间的质心。Matter.js正在像以前一样计算物理和管理碰撞，但我把每个物体绘制在了错误的位置！（在在线版本中，你可以通过点击鼠标切换正确和错误的渲染效果。）
- en: '![Image](../images/pencil.jpg) **Exercise 6.4**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习6.4**'
- en: Make your own little alien being by using multiple shapes attached to a single
    body. Remember, you aren’t limited to using the basic shape-drawing functions
    in p5.js; you can use images and colors, add hair with lines, and more. Think
    of the Matter.js shapes as skeletons for your original fantastical design!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多个附加到单一物体的形状，制作你自己的小外星生物。记住，你不仅限于在p5.js中使用基本的形状绘制功能；你还可以使用图片和颜色，添加用线条表示的头发等。把Matter.js的形状想象成你原创幻想设计的骨架！
- en: '**Matter.js Constraints**'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Matter.js约束**'
- en: 'A Matter.js **constraint** is a mechanism to connect one body to another, enabling
    simulations of swinging pendulums, elastic bridges, squishy characters, wheels
    spinning on an axle, and more. Constraints have three types: distance constraints
    and revolute constraints, both managed through the `Constraint` class, and mouse
    constraints, managed through the `MouseConstraint` class.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Matter.js的**约束**是将一个物体与另一个物体连接的机制，用于模拟摆动的钟摆、弹性桥梁、软体角色、在轴上旋转的车轮等。约束有三种类型：距离约束和转动约束，都通过`Constraint`类进行管理；以及鼠标约束，通过`MouseConstraint`类进行管理。
- en: '**Distance Constraints**'
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**距离约束**'
- en: A **distance constraint** is a connection of fixed length between two bodies,
    similar to a spring force connecting two shapes in [Chapter 3](ch03.xhtml#ch03).
    The constraint is attached to each body at a specified **anchor**, a point relative
    to the body’s center (see [Figure 6.10](ch06.xhtml#ch6fig10)). Depending on the
    constraint’s stiffness property, the “fixed” length can exhibit variability, much
    as a spring can be more or less rigid.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**距离约束**是两个物体之间的固定长度连接，类似于[第3章](ch03.xhtml#ch03)中连接两个形状的弹簧力。约束附加在每个物体的**锚点**上，锚点是相对于物体中心的位置（见[图6.10](ch06.xhtml#ch6fig10)）。根据约束的刚度特性，“固定”长度可能会有所变化，就像弹簧可以更硬或更软一样。'
- en: '![Image](../images/pg356_Image_547.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg356_Image_547.jpg)'
- en: 'Figure 6.10: A constraint is a connection between two bodies at an anchor point
    for each body.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：约束是两个物体之间的连接，每个物体都有一个锚点。
- en: 'Defining a constraint uses a similar methodology as creating bodies, only you
    need to have two bodies ready to go. Let’s assume that two `Particle` objects
    each store a reference to a Matter.js body in a property called `body`. I’ll call
    them `particleA` and `particleB`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个约束的方法与创建物体类似，只不过你需要准备好两个物体。假设两个`Particle`对象分别在一个名为`body`的属性中存储着指向Matter.js物体的引用。我将它们称为`particleA`和`particleB`：
- en: '[PRE16]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'I want to create a constraint between these particles. For that, I need to
    define a series of options that determine the constraint’s behavior:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这些粒子之间创建一个约束。为此，我需要定义一系列选项来决定约束的行为：
- en: '`bodyA`: The first body that the constraint connects, establishing one end
    of the constraint.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bodyA`：约束连接的第一个物体，建立约束的一端。'
- en: '`bodyB`: The second body that the constraint connects, forming the other end.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bodyB`：约束连接的第二个物体，形成另一端。'
- en: '`pointA`: The position, relative to `bodyA`, where the constraint is anchored
    to the first body.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pointA`：约束附加在第一个物体上的位置，相对于`bodyA`。'
- en: '`pointB`: The position, relative to `bodyB`, where the constraint is anchored
    to the second body.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pointB`：约束附加在第二个物体上的位置，相对于`bodyB`。'
- en: '`length`: The resting or target length of the constraint. The constraint will
    attempt to maintain this length during the simulation.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：约束的静止或目标长度。约束会在仿真过程中尽力保持这个长度。'
- en: '`stiffness`: A value from 0 to 1 that represents the rigidity of the constraint,
    with 1 being fully rigid and 0 being completely soft.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stiffness`：一个从 0 到 1 的值，表示约束的刚性，1 为完全刚性，0 为完全柔软。'
- en: 'These settings get packaged up in an object literal:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置会打包成一个对象字面量：
- en: '[PRE17]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Technically, the only required options are `bodyA` and `bodyB`, the two bodies
    connected by the constraint. If you don’t specify any additional options, Matter.js
    will choose defaults for the other properties. For example, it will use `(0, 0)`
    for each relative anchor point (the body’s center), set the `length` to the current
    distance between the bodies, and assign a default `stiffness` of `0.7`. Two other
    notable options I didn’t include are `damping` and `angularStiffness`. The `damping`
    option affects the constraint’s resistance to motion, with higher values causing
    the constraint to lose energy more quickly. The `angularStiffness` option controls
    the rigidity of the constraint’s angular motion, with higher values resulting
    in less angular flexibility between the bodies.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，唯一需要的选项是 `bodyA` 和 `bodyB`，即由约束连接的两个物体。如果你没有指定任何其他选项，Matter.js 会为其他属性选择默认值。例如，它会使用
    `(0, 0)` 作为每个相对锚点（物体的中心），将 `length` 设置为两个物体之间的当前距离，并为 `stiffness` 赋默认值 `0.7`。还有两个我没有包括的重要选项是
    `damping` 和 `angularStiffness`。`damping` 选项影响约束对运动的阻力，值越高，约束失去能量的速度越快。`angularStiffness`
    选项控制约束的角运动刚性，值越高，物体之间的角度灵活性越小。
- en: 'Once the options are configured, the constraint can be created. As usual, this
    assumes another alias—`Constraint` is equal to `Matter.Constraint`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好选项后，就可以创建约束条件。像往常一样，这假定另一个别名——`Constraint` 等于 `Matter.Constraint`：
- en: '![Image](../images/pg357_Image_548.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg357_Image_548.jpg)'
- en: I can include a constraint to a class to encapsulate and manage the relationships
    among multiple bodies. Here’s an example of a class that represents a swinging
    pendulum (mirroring [Example 3.11](ch03.xhtml#ch3ex11) from [Chapter 3](ch03.xhtml#ch03)).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在一个类中包含一个约束来封装和管理多个物体之间的关系。下面是一个代表摆锤摆动的类示例（模仿 [示例 3.11](ch03.xhtml#ch3ex11)
    来自 [第 3 章](ch03.xhtml#ch03)）。
- en: '![Image](../images/pg358_Image_550.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg358_Image_550.jpg)'
- en: '[Example 6.6](ch06.xhtml#ch6ex6) uses a default `stiffness` of `0.7`. If you
    try a lower value, the pendulum will appear more like a soft spring.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.6](ch06.xhtml#ch6ex6)使用默认的 `stiffness` 值 `0.7`。如果你尝试更低的值，摆锤会更像是一个软弹簧。'
- en: '![Image](../images/pencil.jpg) **Exercise 6.5**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 6.5**'
- en: Create a simulation of a bridge by using constraints to connect a sequence of
    circles (or rectangles) as shown in the following image. Use the `isStatic` property
    to lock the endpoints in place. Experiment with different values to make the bridge
    more or less springy. The joints have no physical geometry, so in order for your
    bridge not to have holes, spacing between the nodes will be important.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个桥梁模拟，通过使用约束将一系列圆形（或矩形）连接起来，如下图所示。使用 `isStatic` 属性将端点固定在原地。尝试不同的值，使桥梁更加或不那么有弹性。关节没有物理几何形状，因此为了避免桥梁出现间隙，节点之间的间距非常重要。
- en: '![Image](../images/pg359_Image_551.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg359_Image_551.jpg)'
- en: '**Revolute Constraints**'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**转动约束**'
- en: Another kind of connection between bodies common to physics engines is a **revolute
    joint**. This type of constraint connects two bodies at a common anchor point,
    also known as a **hinge** (see [Figure 6.11](ch06.xhtml#ch6fig11)). While Matter.js
    doesn’t have a separate revolute constraint, you can make one with a regular `Constraint`
    of length 0\. This way, the bodies can rotate around a common anchor point.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在物理引擎中常见的物体连接方式是 **转动关节**。这种类型的约束将两个物体连接在一个共同的锚点，也称为 **铰链**（见 [图 6.11](ch06.xhtml#ch6fig11)）。虽然
    Matter.js 没有单独的转动约束，但你可以通过一个长度为 0 的常规 `Constraint` 来实现。这样，物体就可以围绕一个共同的锚点旋转。
- en: '![Image](../images/pg359_Image_552.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg359_Image_552.jpg)'
- en: 'Figure 6.11: A revolute constraint is a connection between two bodies at a
    single anchor point, or hinge.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11：转动约束是两个物体在单一锚点或铰链处的连接。
- en: The first step is to create the connected bodies. For a first example, I’d like
    to create a spinning rectangle (akin to a propeller or windmill) in a fixed position.
    For this case, I need only one body connected to a point. This simplifies the
    code since I don’t have to worry about collisions between the two bodies connected
    at a hinge.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建连接的物体。以第一个例子为例，我想创建一个旋转的矩形（类似于螺旋桨或风车），并固定在某个位置。对于这种情况，我只需要一个物体连接到一个点。这简化了代码，因为我不必担心两个连接在铰链上的物体之间的碰撞。
- en: '![Image](../images/pg360_Image_553.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg360_Image_553.jpg)'
- en: 'Next, I can create the constraint. With a `length` of `0`, it needs a `stiffness`
    of `1`; otherwise, the constraint may not be stable enough to keep the body connected
    at the anchor point:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我可以创建约束。设置`length`为`0`时，它需要一个`stiffness`为`1`；否则，约束可能不够稳定，无法将物体固定在锚点上：
- en: '![Image](../images/pg360_Image_554.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg360_Image_554.jpg)'
- en: Putting the code together, I’ll write a sketch with a class called `Windmill`
    representing a rotating body. The sketch also includes a `Particle` class for
    dropping particles onto the windmill.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码组合在一起，我将编写一个名为`Windmill`的类，表示一个旋转的物体。该草图还包括一个`Particle`类，用于将粒子投放到风车上。
- en: '![Image](../images/pg360_Image_555.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg360_Image_555.jpg)'
- en: 'Notice the line in this example representing the windmill stand. It isn’t part
    of the Matter.js physics world, and I never created a body for it. This illustrates
    an important point about working with a physics engine alongside p5.js: you can
    add elements to the canvas that contribute to the visual design without affecting
    the physics, as long as you don’t need those elements to participate in the simulation
    itself.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这个例子中的线条，表示风车的支架。它不是Matter.js物理世界的一部分，我也从未为它创建物体。这说明了一个重要的概念：在与p5.js一同使用物理引擎时，你可以向画布添加元素，这些元素有助于视觉设计，但不会影响物理模拟，只要你不需要这些元素参与模拟本身。
- en: '![Image](../images/pencil.jpg) **Exercise 6.6**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 6.6**'
- en: Create a vehicle that has revolute joints for its wheels. Consider the size
    and positioning of the wheels. How does changing the `stiffness` property affect
    their movement?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个具有转动关节的车辆，考虑车轮的大小和位置。改变`stiffness`属性如何影响它们的运动？
- en: '![Image](../images/pg362_Image_557.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg362_Image_557.jpg)'
- en: '**Mouse Constraints**'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**鼠标约束**'
- en: 'Before I introduce the `MouseConstraint` class, consider the following question:
    How do you set the position of a Matter.js body to the mouse position? More to
    the point, why would you need a constraint for this? After all, you have access
    to the body’s position, and you have access to the mouse’s position. What’s wrong
    with assigning one to the other?'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍`MouseConstraint`类之前，先考虑一个问题：如何将Matter.js中的物体位置设置为鼠标位置？更进一步，为什么需要一个约束呢？毕竟，你可以访问物体的位置，也可以访问鼠标的位置。那么，将一个位置赋值给另一个位置有什么问题呢？
- en: '[PRE18]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While this code will move the body, it will also have the unfortunate result
    of breaking the physics. Imagine you’ve built a teleportation machine that allows
    you to move instantly from your bedroom to your kitchen (good for late-night snacking).
    That’s easy enough to imagine, but now go ahead and rewrite Newton’s laws of motion
    to account for the possibility of teleportation. Not so easy anymore, is it?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码会移动物体，但它也会带来一个不幸的结果——破坏物理效果。想象一下，你已经建造了一台传送机，可以让你从卧室瞬间移动到厨房（对深夜小吃来说很有用）。这个场景很容易想象，但现在请重新编写牛顿的运动定律，来考虑瞬移的可能性。现在就不那么容易了，对吧？
- en: Matter.js has the same problem. If you manually assign the position of a body,
    it’s like saying, “Teleport that body,” and Matter.js no longer knows how to compute
    the physics properly. However, Matter.js *does* allow you to tie a string around
    your waist and have a friend of yours stand in the kitchen and drag you there.
    Replace your friend with your mouse, and that’s what a mouse constraint is.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Matter.js也有同样的问题。如果你手动设置物体的位置，就像是在说：“瞬移这个物体”，然后Matter.js就不知道如何正确计算物理效果了。然而，Matter.js
    *确实*允许你在腰间绑上一根绳子，让你的朋友站在厨房里并把你拖过去。将你的朋友换成鼠标，那就是鼠标约束的原理。
- en: Imagine that the moment you click the mouse over a shape, the mouse attaches
    to that body with a string. Now you can move the mouse around, and it will drag
    the body around with it until you release the mouse. This works in a similar fashion
    as a revolute joint in that you can set the length of that “string” to 0, effectively
    moving a shape with the mouse.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当你点击鼠标在一个形状上时，鼠标会通过一根绳子与那个物体连接。现在你可以移动鼠标，它会把物体一起拖动，直到你松开鼠标。这与转动关节类似，你可以将“绳子”的长度设置为0，从而有效地用鼠标移动形状。
- en: 'Before you can attach the mouse, however, you need to create a Matter.js `Mouse`
    object that listens for mouse interactions with the p5.js canvas:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你能附加鼠标之前，你需要创建一个 Matter.js `Mouse`对象，它会监听与 p5.js 画布的鼠标交互：
- en: '![Image](../images/pg363_Image_558.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg363_Image_558.jpg)'
- en: 'Next, use the `mouse` object to create a `MouseConstraint`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`mouse`对象创建一个`MouseConstraint`：
- en: '[PRE19]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will instantly allow you to interact with all Matter.js bodies via the
    mouse. You don’t need to explicitly attach the constraint to a particular body;
    any body you click will be constrained to the mouse.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将立即允许你通过鼠标与所有 Matter.js 物体进行交互。你不需要显式地将约束附加到特定的物体；你点击的任何物体都会被约束到鼠标上。
- en: 'You can also configure all the usual constraint variables by adding a `constraint`
    property to the options passed into the `MouseConstraint.create()` method:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在传递给`MouseConstraint.create()`方法的选项中添加`constraint`属性，来配置所有常见的约束变量：
- en: '![Image](../images/pg363_Image_559.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg363_Image_559.jpg)'
- en: Here’s an example demonstrating a `MouseConstraint` with two `Box` objects.
    Static bodies act as walls around the borders of the canvas.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示了一个包含两个`Box`物体的`MouseConstraint`。静态物体充当画布边界的墙壁。
- en: '![Image](../images/pg364_Image_560.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg364_Image_560.jpg)'
- en: In this example, you’ll see that the `stiffness` property of the constraint
    is set to `0.7`, giving a bit of elasticity to the imaginary mouse string. Other
    properties such as `angularStiffness` and `damping` can also influence the mouse’s
    interaction. What happens if you adjust these values?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你会看到约束的`stiffness`属性被设置为`0.7`，给虚拟的鼠标绳子增加了一些弹性。其他属性，如`angularStiffness`和`damping`，也可以影响鼠标的互动。如果你调整这些值会发生什么？
- en: '**Adding More Forces**'
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加更多的力**'
- en: 'In [Chapter 2](ch02.xhtml#ch02), I covered how to build an environment with
    multiple forces at play. An object might respond to gravitational attraction,
    wind, air resistance, and so on. Clearly, forces are at work in Matter.js as rectangles
    and circles spin and fly around the screen! But so far, I’ve demonstrated how
    to manipulate only a single global force: gravity.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.xhtml#ch02)中，我介绍了如何构建一个具有多重力作用的环境。一个物体可能会受到重力、风力、空气阻力等的影响。显然，在 Matter.js
    中，力正在起作用，矩形和圆形物体在屏幕上旋转和飞行！但是到目前为止，我只展示了如何操控单一的全局力：重力。
- en: '![Image](../images/pg364_Image_561.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg364_Image_561.jpg)'
- en: 'If I want to use any of the [Chapter 2](ch02.xhtml#ch02) techniques with Matter.js,
    I need look no further than the trusty `applyForce()` method, which I wrote as
    part of the `Mover` class. It received a vector, divided it by mass, and accumulated
    it into the mover’s acceleration. With Matter.js, the same method exists, so I
    no longer need to write all the details myself! I can call it with the static
    `Body.applyForce()`. Here’s what that looks like in what’s now the `Box` class:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想在 Matter.js 中使用[第二章](ch02.xhtml#ch02)中的任何技术，我只需使用可靠的`applyForce()`方法，这个方法是我在`Mover`类中编写的。它接收一个向量，将其除以质量，并将其累加到移动物体的加速度中。在
    Matter.js 中，存在相同的方法，因此我不再需要自己编写所有细节！我可以通过静态的`Body.applyForce()`来调用它。下面是现在在`Box`类中的实现：
- en: '![Image](../images/pg364_Image_562.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg364_Image_562.jpg)'
- en: Here, the `Box` class’s `applyForce()` method receives a force vector and simply
    passes it along to Matter.js’s `applyForce()` method to apply it to the corresponding
    body. The key difference with this approach is that Matter.js is a more sophisticated
    engine than the examples from [Chapter 2](ch02.xhtml#ch02). The earlier examples
    assumed that the force was always applied at the mover’s center. Here, I’ve specified
    the exact position on the body where the force is applied. In this case, I’ve
    just applied it to the center as before by asking the body for its position, but
    this could be adjusted—for example, a force pushing at the edge of a box, causing
    it to spin across the canvas, much like dice tumbling when thrown.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Box`类的`applyForce()`方法接收一个力向量，并将其传递给Matter.js的`applyForce()`方法，以将其应用到相应的物体上。与这种方法的关键区别在于，Matter.js是一个比[第2章](ch02.xhtml#ch02)中的示例更复杂的引擎。早期的示例假设力总是作用于驱动器的中心位置。在这里，我指定了力应用于物体的确切位置。在这个例子中，我像之前一样将力应用于物体的中心，通过询问物体的位置来实现，但这也可以进行调整——例如，施加在箱子边缘的力，使其像掷骰子一样旋转在画布上。
- en: How can I bring forces into a Matter.js-driven sketch? Say I want to use a gravitational
    attraction force. Remember the code from [Example 2.6](ch02.xhtml#ch2ex6) in the
    `Attractor` class?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将力引入一个由Matter.js驱动的草图中？假设我想使用重力吸引力。还记得`Attractor`类中的[示例 2.6](ch02.xhtml#ch2ex6)代码吗？
- en: '[PRE20]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I can rewrite the exact same method by using `Matter.Vector` and incorporate
    it into a new `Attractor` class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`Matter.Vector`重写完全相同的方法，并将其集成到一个新的`Attractor`类中。
- en: '![Image](../images/pg365_Image_563.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg365_Image_563.jpg)'
- en: 'In addition to writing a custom `attract()` method for [Example 6.9](ch06.xhtml#ch6ex9),
    two other key elements are required for the sketch to behave more like the example
    from [Chapter 2](ch02.xhtml#ch02). First, remember that a Matter.js `Engine` has
    a default gravity pointing down. I need to disable it in `setup()` with a `(0,
    0)` vector:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为[示例 6.9](ch06.xhtml#ch6ex9)编写自定义的`attract()`方法外，还需要另外两个关键元素，才能使草图的行为更像[第2章](ch02.xhtml#ch02)中的示例。首先，记住Matter.js的`Engine`有一个默认的向下重力。我需要在`setup()`中通过`(0,
    0)`向量禁用它：
- en: '![Image](../images/pg366_Image_565.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg366_Image_565.jpg)'
- en: 'Second, bodies in Matter.js are created with a default air resistance that
    causes them to slow down as they move. I need to set this to `0` as well to simulate
    the bodies being in the vacuum of space:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，Matter.js中的物体默认具有空气阻力，会导致它们在移动时减速。我还需要将其设置为`0`，以模拟物体处于真空中的状态：
- en: '![Image](../images/pg366_Image_566.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg366_Image_566.jpg)'
- en: This is also a good time to revisit the concept of mass. Although I’m accessing
    the `mass` property of the body associated with the mover in the `attract()` method,
    I never explicitly set it. In Matter.js, the mass of a body is automatically calculated
    based on its size (area) and density. Larger bodies will therefore have a greater
    mass. To increase the mass relative to the size, you can try setting a `density`
    property in the `options` object (the default is `0.001`). For static bodies,
    such as the attractor, the mass is considered infinite. This is how the attractor
    stays locked in position despite the movers continuously knocking into it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重新审视质量概念的好时机。虽然我在`attract()`方法中访问了与驱动器相关的物体的`mass`属性，但我从未显式地设置过它。在Matter.js中，物体的质量是根据其大小（面积）和密度自动计算的。因此，较大的物体会有更大的质量。为了增加质量相对于大小的比重，你可以尝试在`options`对象中设置`density`属性（默认值为`0.001`）。对于静态物体，例如引力源，质量被认为是无限的。这就是为什么引力源即使在驱动器不断撞击它时，仍然保持锁定位置。
- en: '![Image](../images/pencil.jpg) **Exercise 6.7**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 6.7**'
- en: Incorporate `Body.applyForce()` into a new `spin()` method for [Example 6.7](ch06.xhtml#ch6ex7)’s
    `Windmill` class to simulate a motor continuously rotating the windmill.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Body.applyForce()`集成到新的`spin()`方法中，用于[示例 6.7](ch06.xhtml#ch6ex7)的`Windmill`类，以模拟电动机持续旋转风车。
- en: '![Image](../images/pg367_Image_567.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg367_Image_567.jpg)'
- en: '![Image](../images/pencil.jpg) **Exercise 6.8**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 6.8**'
- en: Convert any of the steering behavior examples from [Chapter 5](ch05.xhtml#ch05)
    to Matter.js. What does flocking look like with collisions?
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 将[第5章](ch05.xhtml#ch05)中的任何一个引导行为示例转换为Matter.js。带有碰撞的群体行为看起来如何？
- en: '**Collision Events**'
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**碰撞事件**'
- en: 'This book isn’t called *The Nature of Matter.js*, so I’m not going to cover
    every possible feature of the Matter.js library. At this point, I’ve gone over
    the basics of creating bodies and constraints, and shown you some of what the
    library can do. With the skills you’ve gained, hopefully the learning process
    will be considerably less painful when it comes time to use an aspect of Matter.js
    that I haven’t addressed here. Before moving on, however, one more feature of
    the library is worth covering: collision events.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的名字不是《Matter.js的本质》，所以我不会涵盖Matter.js库的所有可能特性。到目前为止，我已经讲解了如何创建物体和约束，并展示了库的一些功能。通过你所获得的技能，希望在使用Matter.js的其他方面时，学习过程会变得不那么痛苦。然而，在继续之前，库的另一个值得介绍的功能是：碰撞事件。
- en: 'Here’s a question you’ve likely been wondering about: “What if I want something
    extra to happen when two bodies collide? I mean, don’t get me wrong—I’m thrilled
    that Matter.js is handling all the collisions behind the scenes. But if it’s taking
    care of the collisions for me, how am I supposed to know when they’re happening?”'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能一直在想一个问题：“如果我希望在两个物体碰撞时发生一些额外的事情怎么办？我的意思是，不要误会我——我很高兴Matter.js在后台处理所有的碰撞。但是，如果它为我处理了碰撞，我怎么知道它们发生了呢？”
- en: 'Your first thoughts to answer this question might be as follows: “Well, I know
    all the bodies in the system, and I know where they’re all located. I can just
    start comparing the bodies’ positions and see which ones are intersecting. Then
    I can do something extra for the bodies that are determined to be colliding.”'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会这样回答这个问题：“嗯，我知道系统中的所有物体，我也知道它们的位置。我可以开始比较物体的位置，看看哪些物体发生了相交。然后我可以为那些确定发生碰撞的物体做一些额外的事情。”
- en: That’s a nice thought, but hello? The whole point of using a physics engine
    like Matter.js is that it will take care of all that work for you. If you’re going
    to implement the computational geometry algorithms to test for intersection, you’re
    basically implementing your own Matter.js!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个不错的想法，但喂？使用像Matter.js这样的物理引擎的重点就是它会为你处理所有这些工作。如果你打算实现计算几何算法来检测相交，那基本上就是在自己实现一个Matter.js！
- en: 'Of course, wanting to know when bodies are colliding is a pretty common problem,
    so Matter.js has anticipated it. It can alert you to moments of collision with
    an **event listener**. If you’ve worked with mouse or keyboard interaction in
    p5.js, you already have experience with event listeners. Consider the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，想知道物体何时发生碰撞是一个相当常见的问题，因此Matter.js早就考虑到了这一点。它可以通过**事件监听器**提醒你发生碰撞的时刻。如果你曾在p5.js中处理过鼠标或键盘交互，那么你已经有了使用事件监听器的经验。请考虑以下内容：
- en: '![Image](../images/pg368_Image_568.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg368_Image_568.jpg)'
- en: 'The global `mousePressed()` function in p5.js is executed whenever the mouse
    is clicked. This is known as a **callback**, a function that’s called back at
    a later time when an event occurs. Matter.js collision events operate in a similar
    fashion. Instead of p5.js just knowing to look for a function called `mousePressed()`
    when a mouse event occurs, however, you have to explicitly define the name for
    a Matter.js collision callback:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: p5.js中的全局`mousePressed()`函数在每次点击鼠标时都会执行。这被称为**回调函数**，即在某个事件发生时，稍后被调用的函数。Matter.js的碰撞事件也以类似的方式操作。然而，和p5.js只需在鼠标事件发生时查找名为`mousePressed()`的函数不同，在Matter.js中，你需要明确地为碰撞回调函数定义名称：
- en: '[PRE21]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code specifies that a function named `handleCollisions` should be executed
    whenever a collision between two bodies starts. Matter.js also has events for
    `'collisionActive'` (executed over and over for the duration of an ongoing collision)
    and `'collisionEnd'` (executed when two bodies stop colliding), but for a basic
    demonstration, knowing when the collision begins is more than adequate.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码指定了一个名为`handleCollisions`的函数，当两个物体发生碰撞时就会执行。Matter.js还有用于`'collisionActive'`（在持续碰撞的过程中反复执行）和`'collisionEnd'`（当两个物体停止碰撞时执行）的事件，但对于一个基本的演示，知道碰撞何时开始已经足够。
- en: 'Just as `mousePressed()` is triggered when the mouse is clicked, `handleCollisions()`
    (or whatever you choose to name the callback function) is triggered when two shapes
    collide. It can be written as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在点击鼠标时会触发`mousePressed()`一样，当两个物体发生碰撞时，`handleCollisions()`（或者你选择的回调函数名）也会被触发。它可以写成如下形式：
- en: '[PRE22]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the function includes an `event` parameter. This is an object that
    includes all the data associated with a collision (or multiple collisions if more
    than one has occurred in that time step), such as which bodies are involved. Matter.js
    automatically creates this object and passes it along to the `handleCollisions()`
    callback every time a collision occurs.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个函数包括一个 `event` 参数。这个对象包含与碰撞相关的所有数据（如果在那个时间步骤内发生了多个碰撞，它会包含多次碰撞的数据），例如涉及到哪些物体。Matter.js
    会自动创建这个对象，并在每次碰撞发生时将其传递给 `handleCollisions()` 回调函数。
- en: Say I have a sketch of `Particle` objects. Each stores a reference to a Matter.js
    body, and I want the particles to change color when they collide. Here’s the process
    to follow to make that happen.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个 `Particle` 对象的草图。每个 `Particle` 都存储一个 Matter.js 物体的引用，我希望粒子在碰撞时改变颜色。以下是实现这一目标的步骤。
- en: '**Step 1: Event, could you tell me which two things collided?**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1：事件，你能告诉我是哪两个物体发生了碰撞吗？**'
- en: 'Now, what has collided here? Matter.js detects collisions between a pair of
    bodies. Any pair of colliding bodies will be in an array called `pairs` inside
    the `event` object. Inside `handleCollisions()`, I can use a `for...of` loop to
    iterate over those pairs:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，到底发生了什么碰撞呢？Matter.js 会检测一对物体之间的碰撞。任何发生碰撞的物体对都会出现在 `event` 对象中的 `pairs` 数组里。在
    `handleCollisions()` 中，我可以使用 `for...of` 循环遍历这些物体对：
- en: '[PRE23]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Step 2: Pair, could you tell me which two bodies you include?**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2：配对，你能告诉我你包含了哪两个物体吗？**'
- en: 'Each pair in the `pairs` array is an object with references to the two bodies
    involved in the collision, `bodyA` and `bodyB`. I’ll extract those bodies:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairs` 数组中的每一对物体都是一个包含碰撞中涉及的两个物体引用的对象，分别是 `bodyA` 和 `bodyB`。我会提取出这些物体：'
- en: '[PRE24]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Step 3: Bodies, could you tell me which particles you’re associated with?**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3：物体，你能告诉我你与哪些粒子相关联吗？**'
- en: Getting from the relevant Matter.js bodies to the `Particle` objects they’re
    associated with is a little harder. After all, Matter.js doesn’t know anything
    about my code. Sure, it’s doing all sorts of stuff to keep track of the relationships
    between bodies and constraints, but it’s up to me to manage my own objects and
    their associations with Matter.js elements. That said, every Matter.js body is
    instantiated with an empty object—`{ }`—called `plugin`, ready to store any custom
    data about that body. I can link the body to a custom object (in this case, a
    `Particle`) by storing a reference to that object in the `plugin` property.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 从相关的 Matter.js 物体获取它们所关联的 `Particle` 对象稍微有点困难。毕竟，Matter.js 对我的代码一无所知。它确实在做各种操作来跟踪物体和约束之间的关系，但管理我自己的对象及其与
    Matter.js 元素的关联是我自己的责任。话虽如此，每个 Matter.js 物体都会实例化一个空对象——`{ }`——叫做 `plugin`，它用来存储关于该物体的任何自定义数据。我可以通过将该对象的引用存储在
    `plugin` 属性中，将物体与自定义对象（在这个例子中是 `Particle`）链接起来。
- en: Take a look at the updated constructor in the `Particle` class where the body
    is made. Note that the body-making procedure has been expanded by one line of
    code to add a `particle` property inside `plugin`. It’s important to make sure
    you’re adding a new property to the existing `plugin` object (in this case, `plugin.particle
    = this`) rather than overwriting the `plugin` object (for example, with `plugin
    = this`). The latter could interfere with other features or customizations.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 看看在 `Particle` 类中更新后的构造函数，其中物体是如何创建的。请注意，创建物体的过程已经通过增加一行代码进行扩展，往 `plugin` 中添加了一个
    `particle` 属性。非常重要的一点是，确保你是给现有的 `plugin` 对象添加一个新属性（在这个例子中是 `plugin.particle =
    this`），而不是覆盖整个 `plugin` 对象（例如，使用 `plugin = this`）。后者可能会干扰其他功能或自定义设置。
- en: '![Image](../images/pg370_Image_569.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg370_Image_569.jpg)'
- en: Later, in the `handleCollision()` callback function, that `Particle` object
    can be accessed from the `Body` via the `plugin`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后的 `handleCollision()` 回调函数中，可以通过 `plugin` 从 `Body` 中访问到那个 `Particle` 对象。
- en: '![Image](../images/pg370_Image_570.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg370_Image_570.jpg)'
- en: In most cases, you can’t assume that the objects that collided are all `Particle`
    objects. After all, the particle might have collided with a `Boundary` object
    (another kind of thing, depending on what’s in your world). You can check an object’s
    type with JavaScript’s `instanceof` operator, as I’ve done in this example.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不能假设发生碰撞的对象都是 `Particle` 对象。毕竟，粒子可能与一个 `Boundary` 对象发生碰撞（根据你世界里的内容，这可能是另一种类型的对象）。你可以使用
    JavaScript 的 `instanceof` 操作符检查一个对象的类型，正如我在这个例子中所做的那样。
- en: '![Image](../images/pencil.jpg) **Exercise 6.9**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 6.9**'
- en: Create a simulation in which `Particle` objects disappear when they collide
    with one another. Where and how should you delete the particles? Can you have
    them shatter into smaller particles?
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个模拟，其中`Particle`对象在相互碰撞时消失。你应该在哪里以及如何删除这些粒子？你能让它们碎成更小的粒子吗？
- en: '**A Brief Interlude: Integration Methods**'
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**简短插曲：积分方法**'
- en: 'Has this ever happened to you? You’re at a fancy cocktail party, regaling your
    friends with tall tales of your incredible software physics simulations. Suddenly,
    out of the blue, someone pipes up: “Enchanting! But what integration method are
    you using?”'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有经历过这样的情境？你正在一个高级鸡尾酒会上，和朋友们分享你那令人难以置信的软件物理模拟的精彩故事。突然，有人插话说：“太迷人了！你使用的是什么积分方法？”
- en: '*What?!* you think to yourself. *Integration?*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么？！*你心里想，*积分？*'
- en: Maybe you’ve heard the term before. Along with differentiation, it’s one of
    the two main operations in calculus. Oh right, calculus.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你之前听说过这个术语。与微分一起，它是微积分中的两大基本操作之一。哦，对了，微积分。
- en: I’ve managed to get most of the way through this material related to physics
    simulation without really needing to dive into calculus. As I wrap up the first
    half of this book, however, it’s worth taking a moment to examine the calculus
    behind what I’ve been demonstrating and how it relates to the methodology in certain
    physics libraries (like Box2D, Matter.js, and the upcoming Toxiclibs.js). This
    way, you’ll know what to say at the next cocktail party when someone asks you
    about integration.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经成功地完成了与物理模拟相关的大部分内容，而几乎没有真正深入微积分。然而，在我完成本书的上半部分时，值得花点时间来审视我所展示的内容背后的微积分原理，以及它如何与某些物理库（如Box2D、Matter.js，以及即将发布的Toxiclibs.js）中的方法论相关联。这样，当有人在下次鸡尾酒会上问你关于积分的问题时，你就能知道该怎么回答。
- en: 'I’ll begin with a question: “What does integration have to do with position,
    velocity, and acceleration?” To answer, I should first define **differentiation**,
    the process of finding a derivative. The **derivative** of a function is a measure
    of how a function changes over time. Consider position and its derivative. Position
    is a point in space, while velocity is the change in position over time. Therefore,
    velocity can be described as the derivative of position. And what’s acceleration?
    The change in velocity over time. Acceleration is the derivative of velocity.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我先来问一个问题：“积分和位置、速度、加速度有什么关系？”为了回答这个问题，我应该首先定义**微分**，即求导的过程。**导数**是衡量一个函数随时间变化的程度。考虑位置和它的导数。位置是空间中的一个点，而速度是位置随时间的变化。因此，速度可以描述为位置的导数。那么加速度是什么？是速度随时间的变化。加速度是速度的导数。
- en: '**Integration**, the process of finding an integral, is the inverse of differentiation.
    For example, the **integral** of an object’s velocity over time tells us the object’s
    new position when that time period ends. Position is the integral of velocity,
    and velocity is the integral of acceleration.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**积分**，即求积分的过程，是微分的逆过程。例如，物体速度随时间的**积分**告诉我们物体在该时间段结束时的新位置。位置是速度的积分，速度是加速度的积分。'
- en: Since the physics simulations in this book are founded on the notion of calculating
    acceleration based on forces, integration is needed to figure out the object’s
    location after a certain period of time (like one cycle of the `draw()` loop).
    In other words, you’ve been doing integration all along!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中的物理模拟是基于通过力来计算加速度的概念，因此需要使用积分来计算物体在一定时间（例如一个`draw()`循环周期）后的位置。换句话说，你一直在做积分！
- en: '[PRE25]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This methodology is known as **Euler integration**, or the Euler method (named
    for the mathematician Leonhard Euler, pronounced *Oiler*). It’s essentially the
    simplest form of integration and is very easy to implement in code—just two lines!
    However, while it’s computationally simple, it’s by no means the most accurate
    or stable choice for certain types of simulations.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法叫做**欧拉积分**，或称欧拉方法（以数学家莱昂哈德·欧拉的名字命名，发音为*Oiler*）。它本质上是最简单的积分形式，并且非常容易在代码中实现——只需两行！然而，尽管它在计算上很简单，但对于某些类型的模拟来说，它并不是最准确或最稳定的选择。
- en: 'Why is Euler inaccurate? Think about it this way: when you bounce down a sidewalk
    on a pogo stick, does the pogo stick sit in one position at time equals 1 second,
    then disappear and suddenly reappear in a new position at time equals 2 seconds,
    and do the same thing for 3 seconds, and 4, and 5? No, of course not. The pogo
    stick moves continuously through time.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么欧拉法不准确？可以这样想：当你用蹦床棒在 sidewalk 上蹦跳时，蹦床棒会在时间等于 1 秒时停在一个位置，然后消失，并在时间等于 2 秒时突然出现在一个新位置，接着在
    3 秒、4 秒、5 秒时继续这样做吗？当然不是。蹦床棒是持续不断地在时间中移动的。
- en: But what’s happening in a p5.js sketch? A circle is at one position at frame
    0, another at frame 1, another at frame 2, and so on. Sure, at 30 frames per second,
    you see the *illusion* of motion. But a new position is computed only every *N*
    units of time, whereas the real world is perfectly continuous. This results in
    some inaccuracies, as shown in [Figure 6.12](ch06.xhtml#ch6fig12).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在 p5.js 草图中发生了什么？一个圆形在第 0 帧时在一个位置，第 1 帧时在另一个位置，第 2 帧时又在另一个位置，依此类推。当然，在每秒 30
    帧的情况下，你会看到运动的*假象*。但是，新的位置只有在每 *N* 个时间单位时才会计算出来，而现实世界是完全连续的。这会导致一些不准确性，如[图 6.12](ch06.xhtml#ch6fig12)所示。
- en: '![Image](../images/pg372_Image_571.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg372_Image_571.jpg)'
- en: 'Figure 6.12: The Euler approximation of a curve'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12：曲线的欧拉近似
- en: The “real world” is the smooth curve; the Euler simulation is the series of
    straight-line segments. One option to improve on Euler is to use smaller time
    steps—instead of once per frame, you could recalculate an object’s position 20
    times per frame. But this isn’t practical; the sketch might then run too slowly.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: “现实世界”是平滑的曲线；欧拉模拟则是由一系列直线段组成。改进欧拉法的一个选择是使用更小的时间步长——而不是每帧计算一次，你可以每帧重新计算 20 次物体的位置。但这并不实际，因为草图可能会运行得太慢。
- en: I still believe that Euler is the best method for learning the basics, and it’s
    also perfectly adequate for most of the projects you might want to make with p5.js.
    Anything lost in efficiency or inaccuracy is made up for in ease of use and understandability.
    For better accuracy, for example, the Box2D engine uses symplectic Euler, or semi-explicit
    Euler, a slight modification of Euler. Other engines use an integration method
    called Runge-Kutta (named for German mathematicians Carl Runge and Martin Kutta).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然认为欧拉方法是学习基础的最佳方法，而且对于你可能用 p5.js 做的大多数项目，它也完全足够。任何在效率或准确性上的损失，都会在易用性和可理解性上得到补偿。为了更高的准确性，例如，Box2D
    引擎使用了辛欧拉方法，或者说是半显式欧拉法，这是欧拉法的一种轻微修改。其他引擎使用了一种叫做龙格-库塔（Runge-Kutta）的方法，它以德国数学家卡尔·龙格（Carl
    Runge）和马丁·库塔（Martin Kutta）命名。
- en: Another popular integration method used in physics libraries, including both
    Matter.js and Toxiclibs.js, is **Verlet integration**. A simple way to describe
    Verlet integration is to think of the typical motion algorithm without explicitly
    storing velocity. After all, you don’t really need to store the velocity; if you
    always know where an object was at one point in time and where it is now, you
    can extrapolate its velocity. Verlet integration does precisely this, calculating
    velocity on the fly while the program is running, instead of maintaining a separate
    velocity variable.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理库中，包括 Matter.js 和 Toxiclibs.js，另一个常用的积分方法是**Verlet 积分**。描述 Verlet 积分的一个简单方式是将其看作一种典型的运动算法，不需要显式存储速度。毕竟，你实际上并不需要存储速度；只要你始终知道一个物体在某个时间点的位置以及它当前的位置，你就可以推算出它的速度。Verlet
    积分正是这样做的，它在程序运行时动态计算速度，而不是维护一个单独的速度变量。
- en: 'Verlet integration is particularly well suited for particle systems, especially
    those with spring connections between the particles. Physics libraries hide the
    details from you so you don’t have to worry about how it all works, but if you’re
    interested in diving deeper into Verlet physics, I suggest reading the seminal
    paper on the topic, from which just about every Verlet computer graphics simulation
    is derived: “Advanced Character Physics” by Thomas Jakobsen (*[https://www.cs.cmu.edu/afs/cs/academic/class/15462-s13/www/lec_slides/Jakobsen.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15462-s13/www/lec_slides/Jakobsen.pdf)*).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Verlet 积分特别适合粒子系统，尤其是那些粒子之间有弹簧连接的系统。物理库将细节隐藏在你面前，这样你就不必担心它如何工作，但如果你有兴趣深入了解 Verlet
    物理学，我建议阅读这篇关于该主题的开创性论文，几乎所有 Verlet 计算机图形学模拟都源自这篇论文：“Advanced Character Physics”
    by Thomas Jakobsen (*[https://www.cs.cmu.edu/afs/cs/academic/class/15462-s13/www/lec_slides/Jakobsen.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15462-s13/www/lec_slides/Jakobsen.pdf)*)。
- en: '**Verlet Physics with Toxiclibs.js**'
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Toxiclibs.js 中的 Verlet 物理**'
- en: 'Around 2005, Karsten Schmidt began work on Toxiclibs, a sweeping and pioneering
    open source library for computational design, specifically built for the Java
    version of Processing. Though it hasn’t been actively maintained in more than
    10 years, the concepts and techniques that the library demonstrated can be found
    in countless creative coding projects today. Its website described it as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2005年，Karsten Schmidt开始了Toxiclibs的开发，这是一个广泛而开创性的计算设计开源库，专门为Processing的Java版本而构建。尽管它已经超过10年没有积极维护，但该库展示的概念和技术在今天的无数创意编码项目中仍然可以找到。它的网站是这样描述的：
- en: '*Toxiclibs is an independent, open source library collection for computational
    design tasks with Java and Processing developed by Karsten “toxi” Schmidt. The
    classes are purposefully kept fairly generic in order to maximize reuse in different
    contexts ranging from generative design, animation, interaction/interface design,
    data visualization to architecture and digital fabrication, use as teaching tool
    and more.*'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*Toxiclibs是由Karsten “toxi” Schmidt开发的，专为计算设计任务而设计的独立开源库，支持Java和Processing。类的设计故意保持通用，以最大化在不同环境中的重用，涵盖了从生成设计、动画、交互/界面设计、数据可视化到建筑和数字化制造、教学工具等多个领域。*'
- en: Schmidt continues to contribute to the creative coding field through his recent
    project, [thi.ng](http://thi.ng) umbrella (*[https://thi.ng/umbrella](https://thi.ng/umbrella)*).
    This work can be considered an indirect successor to Toxiclibs, but with a much
    greater scope and detail. If you like this book, you might especially enjoy exploring
    [thi.ng](http://thi.ng) vectors (*[https://thi.ng/vectors](https://thi.ng/vectors)*),
    which provides more than 800 vector algebra functions using plain-vanilla JavaScript
    arrays.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Schmidt通过他最近的项目，[thi.ng](http://thi.ng) umbrella (*[https://thi.ng/umbrella](https://thi.ng/umbrella)*)，继续为创意编码领域做出贡献。这项工作可以被视为Toxiclibs的间接继任者，但其范围和细节远远更广泛。如果你喜欢这本书，你可能会特别喜欢探索[thi.ng](http://thi.ng)向量库
    (*[https://thi.ng/vectors](https://thi.ng/vectors)*)，它提供了使用纯粹的JavaScript数组的800多个向量代数函数。
- en: While [thi.ng/umbrella](http://thi.ng/umbrella) may be a more modern and sophisticated
    approach, Toxiclibs remains a versatile tool, and I continue to use a version
    compatible with the latest version of Processing (4.3 as of the time of this writing).
    For this book, we should thank our lucky stars for Toxiclibs.js, a JavaScript
    adaptation of the library, created by Kyle Phillips (hapticdata). I’m going to
    cover only a few examples related to Verlet physics, but Toxiclibs.js includes
    a suite of other packages with functionality related to color, geometry, math,
    and more.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[thi.ng/umbrella](http://thi.ng/umbrella)可能是一种更现代、更复杂的方法，但Toxiclibs仍然是一个多功能的工具，我继续使用与最新版本Processing兼容的版本（截至本文写作时为4.3）。对于这本书，我们应该感谢我们的幸运星，感谢Toxiclibs.js，它是由Kyle
    Phillips（hapticdata）创建的库的JavaScript版本。我将只介绍与Verlet物理学相关的少数几个示例，但Toxiclibs.js还包括一套与颜色、几何、数学等相关的其他功能包。
- en: The examples I’m about to demonstrate could also be created using Matter.js,
    but I’ve decided to move to Toxiclibs.js for several reasons. The library holds
    a special place in my heart as a personal favorite, and it’s historically significant.
    I also believe that showing more than one physics library is important for providing
    a broader understanding of the tools and approaches available.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我接下来要展示的示例也可以使用Matter.js创建，但我决定转向Toxiclibs.js，原因有很多。这个库在我心中占有特殊的地位，是我的个人最爱，而且它具有历史意义。我还认为展示多个物理库对于提供更广泛的工具和方法理解非常重要。
- en: 'This switch from Matter.js to Toxiclibs.js raises an important question, though:
    How should you decide which library to use for a project? Matter.js, or Toxiclibs.js,
    or something else? If you fall into one of the following two categories, your
    decision is a bit easier:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从Matter.js切换到Toxiclibs.js提出了一个重要的问题：你应该如何决定在项目中使用哪个库？是Matter.js，Toxiclibs.js，还是其他的库？如果你属于以下两类之一，那么你的决定就简单一些：
- en: '**My project involves collisions. I have circles, squares, and other strangely
    shaped objects that knock each other around and bounce off each other.** In this
    case, you’re going to want to use Matter.js, since Toxiclibs.js doesn’t handle
    rigid-body collisions.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我的项目涉及碰撞。我有圆形、方形和其他奇形怪状的物体，它们相互碰撞并弹开。** 在这种情况下，你会希望使用Matter.js，因为Toxiclibs.js不处理刚体碰撞。'
- en: '**My project involves lots of particles flying around the screen. Sometimes
    they attract each other. Sometimes they repel each other. And sometimes they’re
    connected with springs.** In this case, Toxiclibs.js is likely your best choice.
    It’s simpler to use in some ways than Matter.js and particularly well suited to
    connected systems of particles. It’s also high performance, because it gets to
    ignore all of the collision geometry.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我的项目涉及大量粒子在屏幕上飞动。有时它们相互吸引，有时相互排斥。有时它们还通过弹簧连接。** 在这种情况下，Toxiclibs.js可能是最佳选择。从某些方面来说，它比Matter.js更易于使用，尤其适合处理粒子连接系统。它的性能也非常高，因为它可以忽略所有的碰撞几何。'
- en: 'Here’s a little chart that covers some of the features for each physics library:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小表格，展示了每个物理库的一些特性：
- en: '| **Feature** | **Matter.js** | **Toxiclibs.js** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **Matter.js** | **Toxiclibs.js** |'
- en: '| --- | --- | --- |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Rigid-body collisions | Yes | No |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 刚体碰撞 | 是 | 否 |'
- en: '| 3D physics | No | Yes |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 3D物理 | 否 | 是 |'
- en: '| Particle attraction and repulsion forces | No | Yes |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 粒子吸引与排斥力 | 否 | 是 |'
- en: '| Spring connections (force based) | Yes | Yes |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 弹簧连接（基于力） | 是 | 是 |'
- en: '| Constraints (general-purpose connections) | Yes | No |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| 约束（通用连接） | 是 | 否 |'
- en: 'All the documentation and downloads for the library files can be found at the
    Toxiclibs.js website (*[http://haptic-data.com/toxiclibsjs](http://haptic-data.com/toxiclibsjs)*).
    For the examples in this book, I’ll be working with a hosted CDN version of the
    library referenced in *index.html*, just as I demonstrated earlier for Matter.js.
    Here’s the `<script>` element to add:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 所有库文件的文档和下载可以在Toxiclibs.js官网找到 (*[http://haptic-data.com/toxiclibsjs](http://haptic-data.com/toxiclibsjs)*)。对于本书中的示例，我将使用托管的CDN版本的库，参考
    *index.html*，就像我之前为Matter.js演示的那样。这里是需要添加的 `<script>` 元素：
- en: '[PRE26]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'My overview of Matter.js focused on a few key features of that library: world,
    vector, body, constraint. This has given you a head start on understanding Toxiclibs.js
    as well, since it follows a similar structure. The following table shows the corresponding
    Toxiclibs.js features:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我对Matter.js的概述集中在该库的几个关键特性上：世界、向量、物体、约束。这也为你理解Toxiclibs.js奠定了基础，因为它遵循类似的结构。下表展示了相应的Toxiclibs.js特性：
- en: '|  **Matter.js**  | **Toxiclibs.js** |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|  **Matter.js**  | **Toxiclibs.js** |'
- en: '| --- | --- |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: I’ll discuss how some of these features translate to Toxiclibs.js before putting
    them together to create some interesting examples.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我会讨论一些这些特性如何转化到Toxiclibs.js中，然后将它们组合起来创建一些有趣的示例。
- en: '**Vectors**'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向量**'
- en: 'Here we go again. Remember all that time spent learning the ins and outs of
    the `p5.Vector` class? Then remember how you had to revisit all those concepts
    with Matter.js and the `Matter.Vector` class? Well, it’s time to do it again,
    because Toxiclibs.js also includes its own vector classes. It has one for two
    dimensions and one for three: `Vec2D` and `Vec3D`. Both are found in the `toxi.geom`
    package and can be aliased in the same manner as `Vector` with Matter.js:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 又来了。记得曾经花了很多时间学习`p5.Vector`类的细节吗？然后记得你如何必须重新学习这些概念，应用到Matter.js和`Matter.Vector`类上吗？好吧，现在是时候再来一遍了，因为Toxiclibs.js也包含了自己的向量类。它有一个二维的和一个三维的：`Vec2D`和`Vec3D`。它们都在`toxi.geom`包中，并且可以像在Matter.js中使用`Vector`那样进行别名化：
- en: '[PRE35]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once again, Toxiclibs.js vectors are conceptually the same as the p5.js vectors
    we know and love, but they have their own style and syntax. Here’s an overview
    of how some of the basic vector math operations from `p5.Vector` translate to
    `Vec2D` (I’m sticking with 2D to match the rest of this book, but I encourage
    you to explore 3D vectors as well).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Toxiclibs.js的向量在概念上与我们熟知并喜爱的p5.js向量相同，但它们有自己独特的风格和语法。以下是一些基本的向量数学操作从`p5.Vector`转化为`Vec2D`的概览（我坚持使用2D，以与本书的其余部分保持一致，但我鼓励你也探索3D向量）。
- en: '| **p5.Vector** | **Vec2D** |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| **p5.Vector** | **Vec2D** |'
- en: '| --- | --- |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE40]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Notice in particular that Toxiclibs.js vectors are created by calling the `Vec2D`
    constructor with the `new` keyword, rather than by using a factory method like
    `Matter.Vector()` or `createVector()`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，Toxiclibs.js的向量是通过调用`Vec2D`构造函数并使用`new`关键字来创建的，而不是像`Matter.Vector()`或`createVector()`那样使用工厂方法。
- en: '**The Physics World**'
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**物理世界**'
- en: 'The classes to describe the world and its particles and springs in Toxiclibs.js
    are found in `toxi.physics2d.` I’m also going to use a `Rect` object (to describe
    a generic rectangle boundary) and `GravityBehavior` to apply a global gravity
    force to the world. Including `Vec2D`, I now have all the following class aliases:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 用于描述Toxiclibs.js中世界、粒子和弹簧的类位于`toxi.physics2d.`。我还将使用一个`Rect`对象（用于描述一个通用的矩形边界）和`GravityBehavior`来施加全局重力。包括`Vec2D`后，我现在有了以下所有类的别名：
- en: '![Image](../images/pg376_Image_572.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg376_Image_572.jpg)'
- en: 'The first step is to create the world:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建世界：
- en: '![Image](../images/pg376_Image_573.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg376_Image_573.jpg)'
- en: 'Once I have the `VerletPhysics` world, I can set global properties. For example,
    if I want hard boundaries beyond which particles can’t travel, I can provide rectangular
    bounds:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我有了`VerletPhysics`世界，我就可以设置全局属性。例如，如果我想要设置硬边界，防止粒子穿越，我可以提供矩形边界：
- en: '![Image](../images/pg376_Image_573a.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg376_Image_573a.jpg)'
- en: In addition, I can add gravity with the `GravityBehavior` object. A gravity
    behavior requires a vector—how strong and in what direction is the gravity?
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我可以通过`GravityBehavior`对象来添加重力。重力行为需要一个向量——重力的强度和方向是多少？
- en: '![Image](../images/pg376_Image_573b.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg376_Image_573b.jpg)'
- en: 'Finally, to calculate the physics of the world and move the world’s objects
    around, I have to call the world’s `update()` method. Typically, this would happen
    once per frame in `draw()`:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了计算世界的物理并移动世界中的物体，我必须调用世界的`update()`方法。通常，这会在`draw()`中每帧执行一次：
- en: '![Image](../images/pg376_Image_574.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg376_Image_574.jpg)'
- en: Now all that remains is to populate the world.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的就是填充世界了。
- en: '**Particles**'
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**粒子**'
- en: The Toxiclibs.js equivalent of a Matter.js body—a thing that exists in the world
    and experiences physics—is a **particle**, as represented by the `VerletParticle2D`
    class. However, unlike Matter.js bodies, Toxiclibs.js particles don’t store geometry.
    They’re just points in space.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Toxiclibs.js中相当于Matter.js物体的——一个在世界中存在并经历物理的东西——是一个**粒子**，由`VerletParticle2D`类表示。然而，与Matter.js物体不同，Toxiclibs.js粒子不存储几何形状。它们只是空间中的点。
- en: 'How should I integrate Toxiclibs.js particles into a p5.js sketch? In the Matter.js
    examples, I created my own class (called `Particle`) and included a reference
    to a Matter.js body:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将Toxiclibs.js粒子集成到p5.js草图中？在Matter.js的示例中，我创建了自己的类（称为`Particle`），并包含了对Matter.js物体的引用：
- en: '[PRE42]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This technique was somewhat redundant, since Matter.js keeps track of the bodies
    in its world. However, it allowed me to manage which body is which (and therefore
    how each body should be drawn) without having to rely on iterating through Matter.js’s
    internal lists. I might take the same approach with Toxiclibs.js, making my own
    `Particle` class that stores a reference to a `VerletParticle2D` object. This
    way, I’ll be able to give the particles custom properties and draw them however
    I want. I’d probably write the code as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技术有点冗余，因为Matter.js会跟踪其世界中的物体。然而，它让我可以管理哪个物体是什么（因此如何绘制每个物体），而不必依赖于遍历Matter.js的内部列表。我可能会采用同样的方法使用Toxiclibs.js，创建自己的`Particle`类，存储对`VerletParticle2D`对象的引用。这样，我就能给粒子添加自定义属性，并按照我希望的方式绘制它们。我可能会将代码写成如下：
- en: '![Image](../images/pg377_Image_575.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg377_Image_575.jpg)'
- en: 'Looking over this code, you might first notice that drawing the particle is
    as simple as grabbing the `x` and `y` properties and using them with `circle()`.
    Second, you might notice that this `Particle` class doesn’t do much beyond storing
    a reference to a `VerletParticle2D` object. This hints at something important.
    Think back to the discussion of inheritance in [Chapter 4](ch04.xhtml#ch04), and
    then ask yourself: What is a `Particle` object other than an augmented `VerletParticle2D`
    object? Why bother making two objects—a `Particle` and a `VerletParticle2D`—for
    every one particle in the world, when I could simply extend the `VerletParticle2D`
    class to include the extra code needed to draw the particle?'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 看这段代码，你可能会首先注意到，绘制粒子就像抓取`x`和`y`属性并用`circle()`来绘制一样简单。其次，你可能会注意到，这个`Particle`类除了存储对`VerletParticle2D`对象的引用外，并没有做什么。这暗示了一个重要的点。回想一下[第4章](ch04.xhtml#ch04)中关于继承的讨论，然后问问自己：一个`Particle`对象除了是一个扩展过的`VerletParticle2D`对象外，还有什么？为什么要为世界中的每个粒子创建两个对象——一个`Particle`和一个`VerletParticle2D`，而我完全可以通过扩展`VerletParticle2D`类，加入绘制粒子所需的额外代码？
- en: '![Image](../images/pg378_Image_576.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg378_Image_576.jpg)'
- en: Furthermore, at the risk of blowing your mind, it turns out that the `VerletParticle2D`
    class is a subclass of `Vec2D`. This means that in addition to inheriting everything
    from `VerletParticle2D`, the `Particle` class has inherited all the `Vec2D` methods
    as well!
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，冒险地告诉你一件事，`VerletParticle2D`类实际上是`Vec2D`类的子类。这意味着除了继承`VerletParticle2D`的所有内容外，`Particle`类还继承了所有`Vec2D`的方法！
- en: 'I can now create new particles:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以创建新的粒子了：
- en: '[PRE43]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Just creating a particle isn’t enough, however. Just as in Matter.js, I have
    to explicitly add the new particle to the world. In Toxiclibs.js, this is done
    with the `addParticle()` method:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅创建一个粒子还不够。就像在Matter.js中一样，我必须显式地将新粒子添加到世界中。在Toxiclibs.js中，这是通过`addParticle()`方法完成的：
- en: '[PRE44]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you look at the Toxiclibs.js documentation, you’ll see that `addParticle()`
    expects a `VerletParticle2D` object. But I’ve passed it a `Particle` object. Does
    that work?
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Toxiclibs.js的文档，你会看到`addParticle()`方法期望的是一个`VerletParticle2D`对象。但我传入的是一个`Particle`对象。这样可以吗？
- en: 'Yes! Remember one of the tenets of OOP: polymorphism. Here, because the `Particle`
    class extends `VerletParticle2D`, I can treat the particle in two ways: as a `Particle`
    or as a `VerletParticle2D`. This is an incredibly powerful feature of OOP. If
    you build custom classes that inherit from Toxiclibs.js classes, you can use the
    objects of those classes in conjunction with all the methods Toxiclibs.js has
    to offer.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！记住面向对象编程（OOP）的一个原则：多态性。在这里，由于`Particle`类继承了`VerletParticle2D`，我可以将粒子以两种方式处理：作为一个`Particle`或者作为一个`VerletParticle2D`。这是OOP中一个非常强大的特性。如果你创建自定义类继承自Toxiclibs.js的类，你可以将这些类的对象与Toxiclibs.js提供的所有方法一起使用。
- en: '**Springs**'
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**弹簧**'
- en: 'In addition to the `VerletParticle2D` class, Toxiclibs.js has a set of classes
    that allow you to connect particles with spring forces. Toxiclibs.js has three
    types of springs:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`VerletParticle2D`类外，Toxiclibs.js还提供了一组可以用弹簧力连接粒子的类。Toxiclibs.js有三种类型的弹簧：
- en: '`VerletSpring2D`: A springy connection between two particles. The spring’s
    properties can be configured in such a way as to create a stiff, stick-like connection
    or a highly elastic, stretchy connection. A particle can also be locked so that
    only one end of the spring can move.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerletSpring2D`：两个粒子之间的弹簧连接。弹簧的属性可以配置成创造一个刚性、类似棒子的连接，或者一个高度弹性、可伸展的连接。还可以锁定某个粒子，使得弹簧的另一端只能移动。'
- en: '`VerletConstrainedSpring2D`: A spring whose maximum distance can be limited.
    This can help the whole spring system achieve better stability.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerletConstrainedSpring2D`：一种可以限制最大距离的弹簧。这有助于使整个弹簧系统达到更好的稳定性。'
- en: '`VerletMinDistanceSpring2D`: A spring that enforces its rest length only if
    the current distance is less than its rest length. This is handy if you want to
    ensure that objects are at least a certain distance from each other, but you don’t
    care if the distance is bigger than the enforced minimum.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerletMinDistanceSpring2D`：一种只在当前距离小于其静止长度时才会强制执行静止长度的弹簧。如果你希望确保物体之间至少保持一定的距离，但不在乎距离超过强制最小值的情况，这个弹簧很有用。'
- en: Inheritance and polymorphism once again prove to be useful when making springs.
    A spring expects two `VerletParticle2D` objects when it’s created, but as before,
    two `Particle` objects will do, since `Particle` extends `VerletParticle2D`.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 继承和多态性再次在创建弹簧时发挥了作用。一个弹簧在创建时期望两个`VerletParticle2D`对象，但和之前一样，两个`Particle`对象也能工作，因为`Particle`继承了`VerletParticle2D`。
- en: Here’s some example code to create a spring. This snippet assumes the existence
    of two particles, `particle1` and `particle2`, and creates a connection between
    them with a given rest length and strength.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一段创建弹簧的示例代码。这个代码假设已经存在两个粒子，`particle1`和`particle2`，并通过给定的静止长度和强度在它们之间创建一个连接。
- en: '![Image](../images/pg379_Image_577.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg379_Image_577.jpg)'
- en: 'Just as with particles, in order for the connection to be part of the physics
    world, it must be explicitly added to the world:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 就像粒子一样，为了让连接成为物理世界的一部分，它必须显式地添加到世界中：
- en: '[PRE45]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'I have almost everything I need to build a simple first Toxiclibs.js example:
    two particles connected to form a springy pendulum. I want to add one more element,
    however: mouse interactivity.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎具备了构建一个简单Toxiclibs.js示例所需的一切：两个粒子连接在一起形成一个弹簧摆。但我还想添加一个元素：鼠标交互。
- en: With Matter.js, I explained that the physics simulation breaks down if you manually
    override a body’s position by setting it to the mouse. With Toxiclibs.js, this
    isn’t a problem. If I want to, I can set a particle’s (*x*, *y*) position manually.
    However, before doing so, it’s generally a good idea to call the particle’s `lock()`
    method, which fixes the particle in place. This is identical to setting the `isStatic`
    property to `true` in Matter.js.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Matter.js 时，我解释过，如果手动通过将物体的位置设置为鼠标位置来覆盖物体的位置，物理模拟会崩溃。但在 Toxiclibs.js 中，这不是问题。如果我愿意，可以手动设置粒子的
    (*x*, *y*) 位置。然而，在这样做之前，通常建议调用粒子的 `lock()` 方法，这会将粒子固定在当前位置。这与在 Matter.js 中将 `isStatic`
    属性设置为 `true` 是相同的。
- en: 'The idea is to lock the particle temporarily so it stops responding to the
    world’s physics, alter its position, and then unlock it (with the `unlock()` method)
    so it can start moving again from its new location. For example, say I want to
    reposition a particle whenever the mouse is clicked:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是暂时锁定粒子，使其停止响应世界的物理作用，改变其位置，然后解锁它（使用 `unlock()` 方法），这样它就可以从新的位置开始重新运动。例如，假设我想在每次点击鼠标时重新定位一个粒子：
- en: '![Image](../images/pg380_Image_578.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg380_Image_578.jpg)'
- en: And with that, I’m ready to put all these elements together in a simple sketch
    with two particles connected by a spring. One particle is permanently locked in
    place, and the other can be moved by dragging the mouse. This example is virtually
    identical to [Example 3.11](ch03.xhtml#ch3ex11) from [Chapter 3](ch03.xhtml#ch03).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我准备将所有这些元素结合在一个简单的草图中，图中有两个粒子通过弹簧连接。一个粒子永久锁定在原位，另一个可以通过拖动鼠标来移动。这个示例与 [第3章](ch03.xhtml#ch03)
    中的 [示例 3.11](ch03.xhtml#ch3ex11) 几乎完全相同。
- en: '![Image](../images/pg380_Image_579.jpg)![Image](../images/pg381_Image_580.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg380_Image_579.jpg)![Image](../images/pg381_Image_580.jpg)'
- en: In this example, I’m continuing to visually represent the spring connecting
    the particles with a line. Keep in mind, however, that the behavior of the spring
    still exists, whether you choose to visually represent it or not. This can open
    up creative possibilities. For instance, you could decide to make the spring invisible
    or depict it in a completely different way, perhaps as a series of dots or a shape
    of your own invention.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我继续用一条线来直观表示连接粒子的弹簧。然而，请记住，无论你是否选择将其可视化，弹簧的行为仍然存在。这为创造性可能性打开了大门。例如，你可以决定让弹簧不可见，或者以完全不同的方式表现它，也许用一系列点或者你自己发明的形状来表示。
- en: '**Soft-Body Simulations**'
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**软体模拟**'
- en: Verlet physics is particularly well suited for a genre of computer graphics
    known as soft-body simulation. Unlike the **rigid-body** simulations of Matter.js,
    in which hard-edged boxes crash into one another and retain their shapes, **soft-body**
    simulations involve objects that can deform and change shape with physics. Soft
    bodies allow for more flexible, fluid, and organic movements. They can stretch,
    squish, and jiggle in response to forces and collisions, and they appear . . .
    well, soft.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: Verlet 物理学特别适合一种被称为软体模拟的计算机图形学类型。与 **刚体** 模拟不同，刚体模拟中，硬边框的盒子相互碰撞并保持形状，而 **软体**
    模拟则涉及能够变形并随着物理作用而改变形状的物体。软体物体允许更灵活、更流畅、更有机的运动。它们能在受力和碰撞时拉伸、挤压、抖动，并且看起来...嗯，就是软的。
- en: One of the first popular examples of soft-body physics was *SodaConstructor*,
    a game created in the early 2000s. Players could construct and animate custom
    2D creatures built out of masses and springs. Other examples over the years have
    included games like *LocoRoco*, *World of Goo*, and more recently, *JellyCar*.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 软体物理学的第一个流行示例之一是 *SodaConstructor*，这是一款在2000年代初期创建的游戏。玩家可以构建并动画化由质量和弹簧组成的自定义2D生物。多年来，其他一些例子包括
    *LocoRoco*、*World of Goo*，以及最近的 *JellyCar*。
- en: The basic building blocks of soft-body simulations are particles connected by
    springs—just like the pair particles in [Example 6.11](ch06.xhtml#ch6ex11). [Figure
    6.13](ch06.xhtml#ch6fig13) shows how to configure a network of particle-spring
    connections to make various forms.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 软体模拟的基本构建块是由弹簧连接的粒子——就像 [示例 6.11](ch06.xhtml#ch6ex11) 中的成对粒子一样。[图6.13](ch06.xhtml#ch6fig13)展示了如何配置粒子-弹簧连接的网络来创建各种形态。
- en: '![Image](../images/pg382_Image_581.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg382_Image_581.jpg)'
- en: 'Figure 6.13: Soft-body simulation designs'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：软体模拟设计
- en: As the figure shows, a string can be simulated by connecting a line of particles
    with springs; a blanket can be simulated by connecting a grid of particles with
    springs; and a cute, cuddly, squishy cartoon character can be simulated with a
    custom layout of particles connected with springs. It’s not much of a leap from
    one to another.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，字符串可以通过用弹簧连接一排粒子来模拟；毛毯可以通过用弹簧连接一网格粒子来模拟；而一个可爱、柔软、弹性十足的卡通角色则可以通过用弹簧连接粒子的自定义布局来模拟。从一个到另一个并不是很大的飞跃。
- en: '**A String**'
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一根弦**'
- en: I’ll begin by simulating a *soft pendulum*—a bob hanging from a flexible string
    instead of a rigid arm. As it happens, Toxiclibs.js offers a convenient `ParticleString2D`
    class that creates a string of particles connected by springs in a single constructor
    call. However, for demonstration purposes, I’ll create my own particle string
    by using an array and a `for` loop. This way, you’ll gain a deeper understanding
    of the system, enabling you to create your own custom designs beyond a single
    string in the future.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从模拟一个*软摆锤*开始——它是一个悬挂在柔性弦上的摆锤，而不是悬挂在刚性臂上的摆锤。事实上，Toxiclibs.js 提供了一个方便的`ParticleString2D`类，可以通过一次构造函数调用来创建由弹簧连接的粒子链。不过，为了演示，我将通过使用数组和`for`循环来创建我自己的粒子链。通过这种方式，您将对系统有更深的理解，未来可以设计出超出单一弦的自定义设计。
- en: 'First, I need an array of particles. I’ll use the same `Particle` class built
    in [Example 6.11](ch06.xhtml#ch6ex11):'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要一个粒子数组。我将使用[示例 6.11](ch06.xhtml#ch6ex11)中构建的相同`Particle`类：
- en: '[PRE46]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, let’s say I want to have 20 particles, all spaced 10 pixels apart, as in
    [Figure 6.14](ch06.xhtml#ch6fig14).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我想要有20个粒子，每个粒子之间间隔10个像素，就像[图 6.14](ch06.xhtml#ch6fig14)那样。
- en: '![Image](../images/pg383_Image_582.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg383_Image_582.jpg)'
- en: 'Figure 6.14: Twenty particles all spaced 10 pixels apart'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14：二十个粒子，每个粒子之间间隔10个像素
- en: 'I can loop from `i` equals `0` all the way up to `total`, creating new particles
    and setting each one’s `y` position to `i * 10`. The first particle is at (0,
    10), the second at (0, 20), the third at (0, 30), and so on:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以从`i`等于`0`开始循环，直到`total`，在此过程中创建新的粒子并将每个粒子的`y`位置设置为`i * 10`。第一个粒子在(0, 10)，第二个粒子在(0,
    20)，第三个粒子在(0, 30)，以此类推：
- en: '![Image](../images/pg383_Image_583.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg383_Image_583.jpg)'
- en: Even though it’s redundant, I’m adding the particles to both the Toxiclibs.js
    `physics` world and the `particles` array. This will help me manage the sketch
    (especially when I might have more than one string of particles).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这有些冗余，我还是将粒子添加到Toxiclibs.js的`physics`世界和`particles`数组中。这将有助于我管理草图（特别是当我可能有不止一根粒子链时）。
- en: 'Now for the fun part: it’s time to connect all the particles. Particle index
    0 will be connected to particle 1, particle 1 to particle 2, 2 to 3, 3 to 4, and
    so on (see [Figure 6.15](ch06.xhtml#ch6fig15)).'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分：是时候连接所有粒子了。粒子索引0将与粒子1连接，粒子1与粒子2连接，粒子2与粒子3连接，依此类推（见[图 6.15](ch06.xhtml#ch6fig15)）。
- en: '![Image](../images/pg384_Image_584.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg384_Image_584.jpg)'
- en: 'Figure 6.15: Each particle is connected to the next particle in the array.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15：每个粒子与数组中的下一个粒子连接。
- en: 'In other words, particle `i` needs to be connected to particle `i+1` (except
    for when `i` represents the last element of the array):'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，粒子`i`需要与粒子`i+1`连接（除了当`i`是数组的最后一个元素时）：
- en: '![Image](../images/pg384_Image_585.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg384_Image_585.jpg)'
- en: 'Now, what if I want the string to hang from a fixed point? I can lock one of
    the particles—perhaps the first, the last, or the middle one. I’ll go with the
    first:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我想让弦从一个固定点悬挂该怎么办？我可以固定一个粒子——可能是第一个、最后一个或中间的粒子。我选择第一个粒子：
- en: '[PRE47]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finally, I need to draw the particles. Instead of drawing them as circles, however,
    I want to treat them as points in a line. For that, I can use `beginShape()`,
    `endShape()`, and `vertex()`, accessing the individual particle positions from
    the array. I’ll use the `show()` method to draw only the last particle as a circle,
    creating a bob at the end of the string.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我需要绘制这些粒子。然而，我并不打算将它们绘制成圆形，而是希望将它们视为一条线上的点。为此，我可以使用`beginShape()`、`endShape()`和`vertex()`，并从数组中获取各个粒子的位置。我将使用`show()`方法将最后一个粒子绘制为圆形，从而在弦的末端创建一个摆锤。
- en: '![Image](../images/pg385_Image_586.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg385_Image_586.jpg)'
- en: The full code available on the book’s website also demonstrates how to drag
    the bob particle with the mouse.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 书本网站上提供的完整代码还演示了如何用鼠标拖动摆锤粒子。
- en: '![Image](../images/pencil.jpg) **Exercise 6.10**'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 6.10**'
- en: Create a hanging cloth simulation using particles and springs. You’ll need to
    connect each particle with its vertical and horizontal neighbors.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个悬挂布料的模拟，使用粒子和弹簧。你需要将每个粒子与其垂直和水平方向的邻居连接起来。
- en: '![Image](../images/pg386_Image_587.jpg)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg386_Image_587.jpg)'
- en: '**A Soft-Body Character**'
  id: totrans-506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**软体角色**'
- en: Now that I’ve built a simple connected system—a single string of particles—I’ll
    expand on this idea to create a squishy, cute friend in p5.js, otherwise known
    as a **soft-body character**. The first step is to design a skeleton of connected
    particles. I’ll begin with a very simple design with only six vertices, as shown
    in [Figure 6.16](ch06.xhtml#ch6fig16). Each vertex (drawn as a dot) represents
    a `Particle` object, and each connection (drawn as a line) represents a `Spring`
    object.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经建立了一个简单的连接系统——一串粒子——接下来我将在p5.js中扩展这个思路，创建一个软乎乎、可爱的朋友，也就是**软体角色**。第一步是设计一个连接粒子的骨架。我将从一个非常简单的设计开始，只有六个顶点，如[图6.16](ch06.xhtml#ch6fig16)所示。每个顶点（绘制为一个点）代表一个`Particle`对象，每个连接（绘制为一条线）代表一个`Spring`对象。
- en: '![Image](../images/pg386_Image_588.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg386_Image_588.jpg)'
- en: 'Figure 6.16: A skeleton for a soft-body character. The vertices are numbered
    according to their positions in an array.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：软体角色的骨架。顶点按照它们在数组中的位置编号。
- en: 'Creating the particles is the easy part; it’s exactly the same as before! I’d
    like to make one change, though. Rather than having the `setup()` function add
    the particles and springs to the physics world, I’ll incorporate this responsibility
    into the `Particle` constructor:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 创建粒子是简单的部分；它与之前完全相同！不过，我想做一个小的改变。与其让`setup()`函数将粒子和弹簧添加到物理世界中，不如将这个责任合并到`Particle`构造函数中：
- en: '![Image](../images/pg387_Image_589.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg387_Image_589.jpg)'
- en: While it’s not strictly necessary, I’d also like to make a `Spring` class that
    inherits its functionality from `VerletSpring2D`. For this example, I want the
    resting length of the spring to always be equal to the distance between the skeleton’s
    particles when they’re first created. Additionally, I’m keeping the implementation
    simple here by hardcoding a uniform strength value of `0.01` in the `Spring` constructor.
    You may want to enhance the example with a more sophisticated design that sets
    varying degrees of springiness to the different parts of the soft-body character.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然严格来说不是必要的，但我还想创建一个`Spring`类，它继承自`VerletSpring2D`类。在这个示例中，我希望弹簧的静止长度始终等于骨架粒子在创建时的距离。此外，为了保持实现的简单性，我在`Spring`构造函数中硬编码了一个统一的弹簧强度值`0.01`。你可能想用一个更复杂的设计来增强这个示例，为软体角色的不同部分设置不同的弹性。
- en: '![Image](../images/pg387_Image_590.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg387_Image_590.jpg)'
- en: Now that I have the `Particle` and `Spring` classes, I can assemble the character
    by adding a series of particles with hardcoded starting positions to a `particles`
    array, and a series of spring connections to a `springs` array.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了`Particle`和`Spring`类，我可以通过将一系列具有硬编码起始位置的粒子添加到`particles`数组中，和一系列弹簧连接添加到`springs`数组中，来组合这个角色。
- en: '![Image](../images/pg387_Image_591.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg387_Image_591.jpg)'
- en: 'The beauty of this system is that you can easily expand it to create your own
    design by adding more particles and springs! However, there’s one major issue
    here: I’ve made connections only around the perimeter of the character. If I were
    to apply a force (like gravity) to the body, it would instantly collapse onto
    itself. This is where additional internal springs come into play, as shown in
    [Figure 6.17](ch06.xhtml#ch6fig17). They keep the character’s structure stable
    while still allowing it to move and squish in a realistic manner.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的美妙之处在于，你可以通过添加更多的粒子和弹簧，轻松扩展并创造出属于你自己的设计！然而，这里有一个主要问题：我只在角色的外围做了连接。如果我对身体施加力（如重力），它会立即塌陷。这就是额外的内部弹簧发挥作用的地方，如[图6.17](ch06.xhtml#ch6fig17)所示。它们保持角色的结构稳定，同时仍然允许其以现实的方式移动和挤压。
- en: '![Image](../images/pg388_Image_593.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg388_Image_593.jpg)'
- en: 'Figure 6.17: Internal springs keep the structure from collapsing. This is just
    one possible design. Try others!'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：内部弹簧防止结构坍塌。这只是一个可能的设计，尝试其他设计吧！
- en: The final example incorporates the additional springs from [Figure 6.17](ch06.xhtml#ch6fig17),
    a gravity force, and mouse interaction.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 最终示例包含了[图6.17](ch06.xhtml#ch6fig17)中的附加弹簧、重力和鼠标交互。
- en: '![Image](../images/pg389_Image_594.jpg)![Image](../images/pg390_Image_595.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg389_Image_594.jpg)![Image](../images/pg390_Image_595.jpg)'
- en: For the soft-body character example, you’ll notice that I’m no longer drawing
    all the elements of the physics simulation on the canvas! The `show()` method
    of the particles isn’t called, and the internal springs that give the character
    its structure are not rendered with lines. In fact, the springs themselves are
    never referenced after `setup()`, since the character’s shape is constructed from
    its particle positions. As such, the springs array isn’t strictly needed in this
    example, although I do find it useful to have, considering it may be necessary
    for enhancing the sketch in the future.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在软体角色的例子中，你会注意到我不再在画布上绘制物理模拟的所有元素！粒子的`show()`方法没有被调用，而赋予角色结构的内部弹簧也没有用线条进行渲染。事实上，弹簧本身在`setup()`之后从未被引用过，因为角色的形状是由其粒子的位置构建的。因此，弹簧数组在这个例子中并不是严格需要的，尽管考虑到将来可能需要增强草图，我觉得它有一定的用处。
- en: Considering the drawing as its own problem, distinct from the character’s skeletal
    structure, also opens up possibilities for adding other design elements such as
    eyes or antennae. These creative enhancements don’t need to be directly connected
    to the physics of the character, although they can be if you choose to do so!
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 将绘图视为一个独立的问题，而不是角色骨架结构的一部分，也为添加其他设计元素如眼睛或触角打开了可能性。这些创意增强不需要直接与角色的物理性质连接，尽管如果你愿意，也可以将它们与物理性相连！
- en: '![Image](../images/pencil.jpg) **Exercise 6.11**'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 6.11**'
- en: Design your own soft-body character with additional vertices and connections.
    What other design elements can you add? What other forces and interactions can
    you incorporate?
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 设计你自己的软体角色，增加额外的顶点和连接。你可以添加哪些其他设计元素？你可以融入哪些其他力量和交互？
- en: '![Image](../images/pg390_Image_596.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg390_Image_596.jpg)'
- en: '**A Force-Directed Graph**'
  id: totrans-526
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**力导向图**'
- en: Have you ever had the following thought? “I have a whole bunch of stuff I want
    to draw, and I want all that stuff to be spaced out evenly in a nice, neat, organized
    manner. Otherwise, I’ll have trouble sleeping at night.”
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有想过以下这种情况？“我有一大堆东西想要绘制，并且我希望所有的东西都能均匀地分布在一个漂亮、整洁、有序的方式中。否则，我晚上就没法好好睡觉。”
- en: 'This isn’t an uncommon problem in computational design. One solution is a **force-directed
    graph**, a visualization of elements—let’s call them *nodes*—whose positions aren’t
    manually assigned. Instead, the nodes arrange themselves according to a set of
    forces. While any forces can be used, a classic approach uses spring forces: each
    node is connected to every other node with a spring, such that when the springs
    reach equilibrium, the nodes are evenly spaced (see [Figure 6.18](ch06.xhtml#ch6fig18)).
    Sounds like a job for Toxiclibs.js!'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这在计算设计中并不罕见。一个解决方案是**力导向图**，它是一个元素的可视化——我们称它们为*节点*——这些节点的位置不是手动指定的。相反，节点会根据一组力来排列自己。虽然可以使用任何类型的力，但经典方法使用的是弹簧力：每个节点通过弹簧与其他所有节点相连，当弹簧达到平衡时，节点会均匀分布（见[图6.18](ch06.xhtml#ch6fig18)）。听起来像是Toxiclibs.js的工作！
- en: '![Image](../images/pg391_Image_597.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg391_Image_597.jpg)'
- en: 'Figure 6.18: In this force-directed graph, clusters of particles are connected
    by spring forces.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：在这个力导向图中，粒子群通过弹簧力相连接。
- en: To create a force-directed graph, I’ll first need a class to describe an individual
    node in the system. Because the term *node* is associated with the JavaScript
    framework Node.js, I’ll stick with the term *particle* to avoid any confusion,
    and I’ll continue using my `Particle` class from the earlier soft-body examples.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个力导向图，我首先需要一个类来描述系统中的每个节点。由于“节点”这个术语与JavaScript框架Node.js相关，我将使用*粒子*这个术语，以避免任何混淆，并且继续使用我在早期软体例子中创建的`Particle`类。
- en: 'Next, I’ll encapsulate a list of *N* particles into a new class called `Cluster`
    that represents the graph as a whole. The particles all start out near the center
    of the canvas:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将把一个*N*粒子的列表封装到一个新的类`Cluster`中，该类表示整个图形。所有粒子最初都靠近画布的中心：
- en: '![Image](../images/pg391_Image_598.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg391_Image_598.jpg)'
- en: Let’s assume that the `Cluster` class also has a `show()` method to draw all
    the particles in the cluster and that I’ll create a new `Cluster` object in `setup()`
    and render it in `draw()`. If I ran the sketch as is, nothing would happen. Why?
    Because I have yet to implement the whole force-directed graph part! I need to
    connect every single node to every other node with a spring. This is somewhat
    similar to creating a soft-body character, but rather than handcraft a skeleton,
    I want to write an algorithm to make all the connections automatically.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `Cluster` 类也有一个 `show()` 方法来绘制集群中的所有粒子，并且我将在 `setup()` 中创建一个新的 `Cluster`
    对象，并在 `draw()` 中渲染它。如果我直接运行这个草图，什么也不会发生。为什么？因为我还没有实现整个基于力的图形部分！我需要将每个节点与其他所有节点通过弹簧连接起来。这有点类似于创建一个软体角色，但与其手工制作一个骨架，我更希望编写一个算法来自动创建所有连接。
- en: 'What exactly do I mean by that? Say I have five `Particle` objects: 0, 1, 2,
    3, and 4\. [Figure 6.19](ch06.xhtml#ch6fig19) illustrates the connections.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这到底是什么意思呢？假设我有五个 `Particle` 对象：0、1、2、3 和 4。 [图 6.19](ch06.xhtml#ch6fig19) 展示了这些连接。
- en: '![Image](../images/pg392_Image_600.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg392_Image_600.jpg)'
- en: 'Figure 6.19: A network graph showing each of the five nodes connected to every
    other node'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19：一个网络图，显示了每个节点与其他所有节点的连接
- en: 'Notice two important details about the list of connections:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 注意关于连接列表的两个重要细节：
- en: '**No particle is connected to itself.** That is, 0 isn’t connected to 0, 1
    isn’t connected to 1, and so on.'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有粒子连接到它自身。** 也就是说，0 不连接到 0，1 不连接到 1，依此类推。'
- en: '**Connections aren’t repeated in reverse.** For example, if 0 is connected
    to 1, I don’t need to explicitly say that 1 is also connected to 0\. I already
    know this, based on the definition of how a spring works!'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接不会反向重复。** 例如，如果 0 连接到 1，我就不需要明确地说 1 也连接到 0。我已经知道这一点，基于弹簧工作原理的定义！'
- en: 'How do I write the code to make these connections for *N* particles? Look at
    the four columns illustrated in [Figure 6.19](ch06.xhtml#ch6fig19). They iterate
    all the connections starting from particles 0 up to 3\. This tells me that I need
    to access each particle in the list from 0 to *N* – 1:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如何编写代码来为 *N* 个粒子创建这些连接？看看 [图 6.19](ch06.xhtml#ch6fig19) 中展示的四列。它们迭代了从粒子 0 到粒子
    3 的所有连接。这告诉我，我需要访问列表中从 0 到 *N* – 1 的每个粒子：
- en: '![Image](../images/pg393_Image_601.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg393_Image_601.jpg)'
- en: 'Now look at the connections listed in [Figure 6.19](ch06.xhtml#ch6fig19). I
    need to connect node 0 to nodes 1, 2, and 3\. For node 1, I connect 2 and 3\.
    For node 2, only 3\. In general, for every node `i`, I need to iterate from `i
    + 1` all the way until the end of the array. I’ll use the counter variable `j`
    for this purpose:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看 [图 6.19](ch06.xhtml#ch6fig19) 中列出的连接。我需要将节点 0 连接到节点 1、2 和 3。对于节点 1，我将其连接到
    2 和 3。对于节点 2，仅连接到 3。一般来说，对于每个节点 `i`，我需要从 `i + 1` 开始，直到数组的末尾。我将使用计数器变量 `j` 来实现这个目的：
- en: '![Image](../images/pg393_Image_602.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg393_Image_602.jpg)'
- en: 'For every pair of particles `i` and `j`, I can then create a spring. I’ll go
    back to using `VerletSpring2D` directly, but you could also incorporate a custom
    `Spring` class:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一对粒子 `i` 和 `j`，我可以创建一个弹簧。我将回到直接使用 `VerletSpring2D`，但你也可以结合一个自定义的 `Spring`
    类：
- en: '![Image](../images/pg393_Image_603.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg393_Image_603.jpg)'
- en: Assuming those connections are made in the `Cluster` constructor, all that’s
    left is to create the cluster in `setup()` and call `show()` in the `draw()` loop!
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这些连接是在 `Cluster` 构造函数中创建的，那么剩下的就是在 `setup()` 中创建集群并在 `draw()` 循环中调用 `show()`！
- en: '![Image](../images/pg393_Image_604.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg393_Image_604.jpg)'
- en: This example illustrates a force-directed graph but does not involve any actual
    data! Here, the number of nodes in each cluster and the equilibrium length between
    the nodes are assigned randomly, and the spring strength has a constant value
    of `0.01`. In a real-world application, these values could be determined based
    on your specific data, hopefully resulting in a meaningful visualization of the
    relationships within the data.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一个基于力的图形，但并没有涉及任何实际数据！在这里，每个集群中的节点数量和节点之间的平衡长度是随机分配的，而弹簧的强度恒定为 `0.01`。在实际应用中，这些值可以根据你的特定数据来确定，希望能够形成一个有意义的可视化，展示数据之间的关系。
- en: '![Image](../images/pencil.jpg) **Exercise 6.12**'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 6.12**'
- en: Design a cluster-like structure as a skeleton for a cute, cuddly, squishy creature.
    Add gravity and mouse interaction.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个类似集群的结构，作为一个可爱、柔软、黏糊糊的生物的骨架。加入重力和鼠标交互。
- en: '![Image](../images/pencil.jpg) **Exercise 6.13**'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 6.13**'
- en: Expand the force-directed graph to have more than one `Cluster` object. Use
    a `VerletMinDistanceSpring2D` object to connect cluster to cluster. What kind
    of data might you visualize with this technique?
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展力导向图，使其拥有多个`Cluster`对象。使用`VerletMinDistanceSpring2D`对象连接簇与簇。你可能会使用这种技术可视化什么样的数据？
- en: '![Image](../images/pg394_Image_606.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg394_Image_606.jpg)'
- en: '**Attraction and Repulsion Behaviors**'
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**吸引力与排斥力行为**'
- en: When it came time to create an attraction example for Matter.js, I showed how
    the `Matter.Body` class includes an `applyForce()` method. All I then needed to
    do was calculate the attraction force *F[g]* = (*G* × *m*[1] × *m*[2]) ÷ *d*²
    as a vector and apply it to the body. Similarly, the Toxiclibs.js `VerletParticle2D`
    class also includes a method called `addForce()` that can apply any calculated
    force to a particle.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Matter.js创建吸引力示例时，我展示了`Matter.Body`类如何包括一个`applyForce()`方法。然后我只需做的就是将吸引力公式
    *F[g]* = (*G* × *m*[1] × *m*[2]) ÷ *d*² 作为一个向量计算并应用到物体上。同样，Toxiclibs.js的`VerletParticle2D`类也包括一个名为`addForce()`的方法，可以将任何计算出的力应用到粒子上。
- en: However, Toxiclibs.js takes this idea one step further by offering built-in
    functionality for common forces (called behaviors) such as attraction! For example,
    if you add an `AttractionBehavior` object to a particular `VerletParticle2D` object,
    all other particles in the physics world will experience an attraction force toward
    that particle.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Toxiclibs.js进一步提升了这一想法，提供了内建的常见力（称为行为）功能，例如吸引力！例如，如果你将一个`AttractionBehavior`对象添加到某个`VerletParticle2D`对象，物理世界中的所有其他粒子都会受到向该粒子的吸引力作用。
- en: 'Say I create an instance of my `Particle` class (which extends the `VerletParticle2D`
    class):'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我创建了一个`Particle`类的实例（该类继承自`VerletParticle2D`类）：
- en: '[PRE48]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now I can create an `AttractionBehavior` associated with that particle:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以创建一个与该粒子关联的`AttractionBehavior`：
- en: '[PRE49]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Notice that the behavior is created with three arguments: a particle to assign
    it to, a distance, and a strength. The distance specifies the range within which
    the behavior will be applied. In this case, only particles within 20 pixels will
    experience the attraction force. The strength, of course, specifies how strong
    the force is.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，行为是通过三个参数创建的：一个粒子、一个距离和一个强度。距离指定行为将应用的范围。在这种情况下，只有20像素范围内的粒子才会受到吸引力的作用。强度当然指定了力的大小。
- en: 'Finally, in order for the force to be activated, the behavior needs to be added
    to the physics world:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了激活力，行为需要添加到物理世界中：
- en: '[PRE50]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now everything that lives in the physics simulation will always be attracted
    to that particle, as long as it’s within the distance threshold.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，物理模拟中的所有对象只要在距离阈值范围内，都会始终被吸引到该粒子上。
- en: 'The `AttractionBehavior` class is a very powerful tool. For example, even though
    Toxiclibs.js doesn’t automatically handle collisions like Matter.js does, you
    can create a collision-like simulation by adding an `AttractionBehavior` with
    a negative strength—a repulsive behavior—to each and every particle. If the force
    is strong and activated only within a short range (scaled to the particle’s radius),
    the result is much like a rigid-body collision. Here’s how to modify the `Particle`
    class to do this:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttractionBehavior`类是一个非常强大的工具。例如，尽管Toxiclibs.js不像Matter.js那样自动处理碰撞，但你可以通过为每个粒子添加一个负强度的`AttractionBehavior`—即排斥行为—来创建一个类似碰撞的模拟。如果力很强并且仅在短范围内激活（缩放到粒子的半径），其效果就像刚体碰撞。以下是如何修改`Particle`类来实现这一点：'
- en: '![Image](../images/pg396_Image_607.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg396_Image_607.jpg)'
- en: I can now remake the attraction example from [Chapter 2](ch02.xhtml#ch02) with
    a single `Attractor` object that exerts an attraction behavior anywhere on the
    canvas. Even though the attractor is centered, I’m using a distance threshold
    of the full `width` to account for any movement of the attractor, and for particles
    located outside the canvas boundaries.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以使用一个单一的`Attractor`对象重建[第2章](ch02.xhtml#ch02)的吸引力示例，使其在画布上的任何地方施加吸引力行为。尽管吸引体位于中心，我使用了整个`width`的距离阈值来考虑吸引体的任何移动，以及位于画布边界之外的粒子。
- en: '![Image](../images/pg397_Image_608.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg397_Image_608.jpg)'
- en: Just as discussed in “Spatial Subdivisions” on [page 275](ch05.xhtml#ch00lev2sec38),
    Toxiclibs.js projects with large numbers of particles interacting with one another
    can run very slowly because of the *N*² nature of the algorithm (every particle
    checking every other particle). To speed up the simulation, you could use the
    manual `addForce()` method in conjunction with a binning algorithm. Keep in mind,
    this would also require you to manually calculate the attraction force, as the
    built-in `AttractionBehavior` would no longer apply.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第275页](ch05.xhtml#ch00lev2sec38)的“空间划分”中讨论的那样，带有大量相互作用粒子的Toxiclibs.js项目可能会运行得非常慢，因为算法的*N*²特性（每个粒子都要检查其他所有粒子）。为了加速模拟，你可以结合使用手动`addForce()`方法和分箱算法。请记住，这也要求你手动计算引力，因为内置的`AttractionBehavior`将不再适用。
- en: '![Image](../images/pencil.jpg) **Exercise 6.14**'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习6.14**'
- en: Use `AttractionBehavior` in conjunction with spring forces.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 将`AttractionBehavior`与弹簧力结合使用。
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bird.jpg) **生态系统项目**'
- en: 'Take your system of creatures from [Chapter 5](ch05.xhtml#ch05) and use a physics
    engine to drive their motion and behaviors. Here are some possibilities:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第五章](ch05.xhtml#ch05)获取你的生物系统，并使用物理引擎驱动它们的运动和行为。以下是一些可能的选项：
- en: Use Matter.js to allow collisions between creatures. Consider triggering an
    event when two creatures collide.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Matter.js允许生物之间发生碰撞。考虑在两只生物碰撞时触发事件。
- en: Use Matter.js to augment the design of your creatures. Build a skeleton with
    distance joints or make appendages with revolute joints.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Matter.js来增强你生物的设计。使用带有距离关节的骨架或用转动关节做附肢。
- en: Use Toxiclibs.js to augment the design of your creature. Use a chain of Toxiclibs.js
    particles for tentacles or a mesh of springs as a skeleton.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Toxiclibs.js来增强你生物的设计。用Toxiclibs.js粒子链做触手，或用弹簧网状结构做骨架。
- en: Use Toxiclibs.js to add attraction and repulsion behaviors to your creatures.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Toxiclibs.js为你的生物添加引力和排斥行为。
- en: Use spring (or joint) connections between objects to control their interactions.
    Create and delete these springs on the fly. Consider making these connections
    visible or invisible to the viewer.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物体之间使用弹簧（或关节）连接来控制它们的相互作用。动态创建和删除这些弹簧。考虑将这些连接设置为可见或不可见。
- en: '![Image](../images/pg398_Image_609.jpg)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg398_Image_609.jpg)'
