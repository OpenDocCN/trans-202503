- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Open Redirects
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开放重定向
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Sites often use HTTP or URL parameters to redirect users to a specified URL
    without any user action. While this behavior can be useful, it can also cause
    *open redirects*, which happen when an attacker is able to manipulate the value
    of this parameter to redirect the user offsite. Let’s discuss this common bug,
    why it’s a problem, and how you can use it to escalate other vulnerabilities you
    find.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 网站通常使用 HTTP 或 URL 参数将用户重定向到指定的 URL，而无需用户任何操作。虽然这种行为可能有用，但也可能导致 *开放重定向*，即攻击者能够操纵该参数的值，将用户重定向到其他网站。让我们讨论一下这个常见的漏洞，为什么它是个问题，以及如何利用它来升级你发现的其他漏洞。
- en: Mechanisms
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: Websites often need to automatically redirect their users. For example, this
    scenario commonly occurs when unauthenticated users try to access a page that
    requires logging in. The website will usually redirect those users to the login
    page, and then return them to their original location after they’re authenticated.
    For example, when these users visit their account dashboards at *https://example.com/dashboard*,
    the application might redirect them to the login page at *https://example.com/login.*
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 网站经常需要自动重定向用户。例如，当未认证的用户尝试访问需要登录的页面时，这种情况通常会发生。网站通常会将这些用户重定向到登录页面，认证后再将他们返回到原来的位置。例如，当这些用户访问他们的账户仪表板
    *https://example.com/dashboard* 时，应用程序可能会将他们重定向到登录页面 *https://example.com/login*。
- en: 'To later redirect users to their previous location, the site needs to remember
    which page they intended to access before they were redirected to the login page.
    Therefore, the site uses some sort of redirect URL parameter appended to the URL
    to keep track of the user’s original location. This parameter determines where
    to redirect the user after login. For example, the URL *https://example.com/login?redirect=https://example.com/dashboard*
    will redirect to the user’s dashboard, located at *https://example.com/dashboard*,
    after login. Or if the user was originally trying to browse their account settings
    page, the site would redirect the user to the settings page after login, and the
    URL would look like this: *https://example.com/login?redirect=https://example.com/settings*.
    Redirecting users automatically saves them time and improves their experience,
    so you’ll find many applications that implement this functionality.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍后将用户重定向回他们之前的位置，网站需要记住他们在被重定向到登录页面之前打算访问的页面。因此，网站会使用某种形式的重定向 URL 参数，将其附加到
    URL 中，以跟踪用户的原始位置。这个参数决定了在登录后将用户重定向到哪里。例如，URL *https://example.com/login?redirect=https://example.com/dashboard*
    会在登录后将用户重定向到他们的仪表板，位于 *https://example.com/dashboard*。或者，如果用户最初试图浏览他们的账户设置页面，网站将在登录后将用户重定向到设置页面，URL
    将如下所示：*https://example.com/login?redirect=https://example.com/settings*。自动重定向用户节省了时间并改善了他们的体验，因此你会发现许多应用程序都实现了这一功能。
- en: 'During an open-redirect attack, an attacker tricks the user into visiting an
    external site by providing them with a URL from the legitimate site that redirects
    somewhere else, like this: *https://example.com/login?redirect=https://attacker.com*.
    A URL like this one could trick victims into clicking the link, because they’ll
    believe it leads to a page on the legitimate site, *example.com*. But in reality,
    this page automatically redirects to a malicious page. Attackers can then launch
    a social engineering attack and trick users into entering their *example.com*
    credentials on the attacker’s site. In the cybersecurity world, *social engineering*
    refers to attacks that deceive the victim. Attacks that use social engineering
    to steal credentials and private information are called *phishing*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开放重定向攻击中，攻击者通过提供来自合法站点的 URL，将用户引导到外部网站，就像这样：*https://example.com/login?redirect=https://attacker.com*。像这样的
    URL 可能会欺骗受害者点击链接，因为他们会相信它会带他们到合法站点 *example.com* 的页面。但实际上，这个页面会自动重定向到一个恶意页面。攻击者随后可以发起社交工程攻击，诱骗用户在攻击者网站上输入他们的
    *example.com* 凭证。在网络安全领域，*社交工程* 是指通过欺骗手段攻击受害者。使用社交工程窃取凭证和私人信息的攻击被称为 *钓鱼*。
- en: 'Another common open-redirect technique is referer-based open redirect. The
    *referer* is an HTTP request header that browsers automatically include. It tells
    the server where the request originated from. Referer headers are a common way
    of determining the user’s original location, since they contain the URL that linked
    to the current page. Thus, some sites will redirect to the page’s referer URL
    automatically after certain user actions, like login or logout. In this case,
    attackers can host a site that links to the victim site to set the referer header
    of the request, using HTML like the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的开放重定向技术是基于referer的开放重定向。*referer*是一个HTTP请求头，浏览器会自动包括它。它告诉服务器请求来自哪里。Referer头是确定用户原始位置的常用方法，因为它包含指向当前页面的链接URL。因此，一些网站在用户执行某些操作（如登录或注销）后，会自动重定向到页面的referer
    URL。在这种情况下，攻击者可以托管一个链接到受害者网站的页面，以设置请求的referer头，HTML代码如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This HTML page contains an `<a>` tag, which links the text in the tag to another
    location. This page contains a link with the text `Click here to log in to example.com`.
    When a user clicks the link, they’ll be redirected to the location specified by
    the `href` attribute of the `<a>` tag, which is *https://example.com/login* in
    this example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML页面包含一个`<a>`标签，该标签将文本链接到另一个位置。这个页面包含一个链接，文本为`Click here to log in to example.com`。当用户点击该链接时，他们将被重定向到`<a>`标签的`href`属性指定的位置，在这个例子中是*https://example.com/login*。
- en: '[Figure 7-1](#figure7-1) shows what the page would look like when rendered
    in the browser.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-1](#figure7-1)显示了在浏览器中渲染后的页面效果。'
- en: '![f07001](image_fi/501546c07/f07001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![f07001](image_fi/501546c07/f07001.png)'
- en: 'Figure 7-1: Our sample rendered HTML page'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1：我们的示例渲染HTML页面
- en: If *example.com* uses a referer-based redirect system, the user’s browser would
    redirect to the attacker’s site after the user visits *example.com*, because the
    browser visited *example.com* via the attacker’s page.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*example.com*使用基于referer的重定向系统，那么在用户访问*example.com*后，用户的浏览器会将其重定向到攻击者的网站，因为浏览器是通过攻击者的页面访问*example.com*的。
- en: Prevention
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预防
- en: To prevent open redirects, the server needs to make sure it doesn’t redirect
    users to malicious locations. Sites often implement *URL validators* to ensure
    that the user-provided redirect URL points to a legitimate location. These validators
    use either a blocklist or an allowlist.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止开放重定向，服务器需要确保不会将用户重定向到恶意位置。网站通常会实现*URL验证器*来确保用户提供的重定向URL指向合法位置。这些验证器使用黑名单或白名单来进行过滤。
- en: When a validator implements a blocklist, it will check whether the redirect
    URL contains certain indicators of a malicious redirect, and then block those
    requests accordingly. For example, a site may blocklist known malicious hostnames
    or special URL characters often used in open-redirect attacks. When a validator
    implements an allowlist, it will check the hostname portion of the URL to make
    sure that it matches a predetermined list of allowed hosts. If the hostname portion
    of the URL matches an allowed hostname, the redirect goes through. Otherwise,
    the server blocks the redirect.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当验证器实施黑名单时，它会检查重定向URL是否包含某些恶意重定向的标志，然后相应地阻止这些请求。例如，一个网站可能会将已知的恶意主机名或开放重定向攻击中常用的特殊URL字符列入黑名单。当验证器实施白名单时，它会检查URL中的主机名部分，确保它与预先确定的允许主机列表匹配。如果URL中的主机名部分与允许的主机名匹配，重定向会继续进行。否则，服务器会阻止该重定向。
- en: These defense mechanisms sound straightforward, but the reality is that parsing
    and decoding a URL is difficult to get right. Validators often have a hard time
    identifying the hostname portion of the URL. This makes open redirects one of
    the most common vulnerabilities in modern web applications. We’ll talk about how
    attackers can exploit URL validation issues to bypass open-redirect protection
    later in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些防御机制听起来简单明了，但实际上，解析和解码URL是一个很难做到准确的任务。验证器通常很难识别URL中的主机名部分。这使得开放重定向成为现代Web应用中最常见的漏洞之一。我们将在本章稍后讨论攻击者如何利用URL验证问题绕过开放重定向保护。
- en: Hunting for Open Redirects
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找开放重定向
- en: Let’s start by looking for a simple open redirect. You can find open redirects
    by using a few recon tricks to discover vulnerable endpoints and confirm the open
    redirect manually.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从寻找一个简单的开放重定向开始。你可以通过使用一些侦察技巧来发现易受攻击的端点，并手动确认开放重定向。
- en: 'Step 1: Look for Redirect Parameters'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤1：查找重定向参数
- en: 'Start by searching for the parameters used for redirects. These often show
    up as URL parameters like the ones in bold here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从查找用于重定向的参数开始。这些参数通常会作为 URL 参数出现，如这里加粗的内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open your proxy while you browse the website. Then, in your HTTP history, look
    for any parameter that contains absolute or relative URLs. An *absolute URL* is
    complete and contains all the components necessary to locate the resource it points
    to, like *https://example.com/login*. Absolute URLs contain at least the URL scheme,
    hostname, and path of a resource. A *relative URL* must be concatenated with another
    URL by the server in order to be used. These typically contain only the path component
    of a URL, like */login*. Some redirect URLs will even omit the first slash (`/`)
    character of the relative URL, as in *https://example.com/login?next=dashboard*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览网站时打开你的代理。然后，在你的 HTTP 历史记录中，查找任何包含绝对或相对 URL 的参数。*绝对 URL* 是完整的，包含了定位其指向的资源所需的所有组件，如*https://example.com/login*。绝对
    URL 至少包含 URL 协议、主机名和资源路径。*相对 URL* 必须通过服务器与另一个 URL 连接才能使用。它们通常仅包含 URL 的路径组件，如*/login*。某些重定向
    URL 甚至会省略相对 URL 的第一个斜杠（`/`），如*https://example.com/login?next=dashboard*。
- en: Note that not all redirect parameters have straightforward names like `redirect`
    or `redir`. For example, I’ve seen redirect parameters named `RelayState`, `next`,
    `u`, `n`, and `forward`. You should record all parameters that seem to be used
    for redirect, regardless of their parameter names.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并非所有的重定向参数都有像`redirect`或`redir`这样直接的名称。例如，我见过名为`RelayState`、`next`、`u`、`n`和`forward`的重定向参数。无论参数名称是什么，你都应该记录下所有看起来是用于重定向的参数。
- en: In addition, take note of the pages that don’t contain redirect parameters in
    their URLs but still automatically redirect their users. These pages are candidates
    for referer-based open redirects. To find these pages, you can keep an eye out
    for 3*XX* response codes like 301 and 302\. These response codes indicate a redirect.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意那些 URL 中没有重定向参数，但仍然会自动重定向用户的页面。这些页面是基于 referer 的开放重定向的候选对象。要查找这些页面，你可以留意像
    3*XX* 的响应代码，如 301 和 302。这些响应代码表示重定向。
- en: 'Step 2: Use Google Dorks to Find Additional Redirect Parameters'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：使用 Google Dork 查找额外的重定向参数
- en: 'Google dork techniques are an efficient way to find redirect parameters. To
    look for redirect parameters on a target site by using Google dorks, start by
    setting the `site` search term to your target site:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Google Dork 技巧是一种高效的查找重定向参数的方法。要使用 Google Dork 查找目标网站上的重定向参数，首先将`site`搜索词设置为你的目标站点：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then look for pages that contain URLs in their URL parameters, making use of
    `%3D`, the URL-encoded version of the equal sign (=). By adding `%3D` in your
    search term, you can search for terms like `=http` and `=https`, which are indicators
    of URLs in a parameter. The following searches for URL parameters that contain
    absolute URLs:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，查找包含 URL 参数中 URL 的页面，利用`%3D`，即等号（=）的 URL 编码版本。通过在搜索词中添加`%3D`，你可以搜索像`=http`和`=https`这样的词，它们是
    URL 参数中 URL 的指示符。以下搜索会查找包含绝对 URL 的 URL 参数：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This search term might find the following pages:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个搜索词可能会找到如下页面：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also try using `%2F`, the URL-encoded version of the slash (/). The following
    search term searches URLs that contain `=/`, and therefore returns URL parameters
    that contain relative URLs:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以尝试使用`%2F`，即斜杠（/）的 URL 编码版本。以下搜索词会查找包含`=/`的 URL，因此返回包含相对 URL 的 URL 参数：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This search term will find URLs such as this one:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个搜索词将查找如下的 URL：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you can search for the names of common URL redirect parameters.
    Here are a few search terms that will likely reveal parameters used for a redirect:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以搜索常见 URL 重定向参数的名称。以下是一些搜索词，可能会揭示用于重定向的参数：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These search terms will find URLs such as the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些搜索词将查找如下的 URL：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the new parameters you’ve discovered, along with the ones found in step
    1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意你发现的新参数，以及在步骤 1 中找到的那些参数。
- en: 'Step 3: Test for Parameter-Based Open Redirects'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：测试基于参数的开放重定向
- en: 'Next, pay attention to the functionality of each redirect parameter you’ve
    found and test each one for an open redirect. Insert a random hostname, or a hostname
    you own, into the redirect parameters; then see if the site automatically redirects
    to the site you specified:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意你找到的每个重定向参数的功能，并对每个进行开放重定向的测试。将一个随机的主机名，或者你拥有的主机名，插入重定向参数中；然后查看该站点是否自动重定向到你指定的站点：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Some sites will redirect to the destination site immediately after you visit
    the URL, without any user interaction. But for a lot of pages, the redirect won’t
    happen until after a user action, like registration, login, or logout. In those
    cases, be sure to carry out the required user interactions before checking for
    the redirect.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网站会在你访问 URL 后立即重定向到目标站点，无需任何用户互动。但对于许多页面，重定向通常会在用户执行某些操作后才发生，比如注册、登录或注销。在这些情况下，确保在检查重定向之前，先执行所需的用户互动。
- en: 'Step 4: Test for Referer-Based Open Redirects'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步：测试基于 Referer 的开放重定向
- en: 'Finally, test for referer-based open redirects on any pages you found in step
    1 that redirected users despite not containing a redirect URL parameter. To test
    for these, set up a page on a domain you own and host this HTML page:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测试在第 1 步中找到的任何页面，看看是否存在基于 referer 的开放重定向，即使这些页面没有包含重定向 URL 参数。要测试这些，可以在你拥有的域名上设置一个页面，并托管此
    HTML 页面：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Replace the linked URL with the target page. Then reload and visit your HTML
    page. Click the link and see if you get redirected to your site automatically
    or after the required user interactions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 替换链接 URL 为目标页面。然后重新加载并访问你的 HTML 页面。点击链接，看看是否会在自动或需要用户互动后重定向到你的站点。
- en: Bypassing Open-Redirect Protection
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过开放重定向保护
- en: As a bug bounty hunter, I find open redirects in almost all the web targets
    I attack. Why are open redirects still so prevalent in web applications today?
    Sites prevent open redirects by validating the URL used to redirect the user,
    making the root cause of open redirects failed URL validation. And, unfortunately,
    URL validation is extremely difficult to get right.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个漏洞奖励猎人，我在攻击的几乎所有网站目标中都能发现开放重定向漏洞。为什么开放重定向在今天的 web 应用中仍然如此普遍？网站通过验证用于重定向用户的
    URL 来防止开放重定向，开放重定向的根本原因是 URL 验证失败。不幸的是，URL 验证非常难以做到完全正确。
- en: 'Here, you can see the components of a URL. The way the browser redirects the
    user depends on how the browser differentiates between these components:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到一个 URL 的组成部分。浏览器如何重定向用户取决于浏览器如何区分这些组成部分：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The URL validator needs to predict how the browser will redirect the user and
    reject URLs that will result in a redirect offsite. Browsers redirect users to
    the location indicated by the hostname section of the URL. However, URLs don’t
    always follow the strict format shown in this example. They can be malformed,
    have their components out of order, contain characters that the browser does not
    know how to decode, or have extra or missing components. For example, how would
    the browser redirect this URL?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: URL 验证器需要预测浏览器如何重定向用户，并拒绝那些会导致站外重定向的 URL。浏览器会将用户重定向到 URL 中主机名部分所指示的位置。然而，URL
    不总是严格遵循此示例中所示的格式。它们可能会格式错误，组成部分顺序混乱，包含浏览器无法解码的字符，或缺少或多余的组成部分。例如，浏览器会如何重定向这个 URL？
- en: https://user:password:8080/example.com@attacker.com
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: https://user:password:8080/example.com@attacker.com
- en: When you visit this link in different browsers, you will see that different
    browsers handle this URL differently. Sometimes validators don’t account for all
    the edge cases that can cause the browser to behave unexpectedly. In this case,
    you could try to bypass the protection by using a few strategies, which I’ll go
    over in this section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在不同的浏览器中访问这个链接时，你会发现不同的浏览器对这个 URL 的处理方式不同。有时验证器没有考虑到所有可能导致浏览器异常行为的边缘情况。在这种情况下，你可以尝试通过几种策略来绕过保护，我将在本节中讲解这些策略。
- en: Using Browser Autocorrect
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用浏览器自动更正功能
- en: 'First, you can use browser autocorrect features to construct alternative URLs
    that redirect offsite. Modern browsers often autocorrect URLs that don’t have
    the correct components, in order to correct mangled URLs caused by user typos.
    For example, Chrome will interpret all of these URLs as pointing to *https://attacker.com*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用浏览器自动更正功能来构造替代 URL，从而实现站外重定向。现代浏览器通常会自动更正那些没有正确组成部分的 URL，以纠正由于用户输入错误导致的
    URL 错误。例如，Chrome 会将以下所有 URL 解释为指向 *https://attacker.com*：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These quirks can help you bypass URL validation based on a blocklist. For example,
    if the validator rejects any redirect URL that contains the strings `https://`
    or `http://`, you can use an alternative string, like `https;`, to achieve the
    same results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小细节可以帮助你绕过基于黑名单的 URL 验证。例如，如果验证器拒绝任何包含 `https://` 或 `http://` 的重定向 URL，你可以使用一个替代字符串，如
    `https;`，来实现相同的效果。
- en: 'Most modern browsers also automatically correct backslashes (\) to forward
    slashes (/), meaning they’ll treat these URLs as the same:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代浏览器还会自动将反斜杠（\）更正为斜杠（/），这意味着它们会将这些 URL 视为相同：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the validator doesn’t recognize this behavior, the inconsistency could lead
    to bugs. For example, the following URL is potentially problematic:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证器未能识别这种行为，不一致性可能导致漏洞。例如，下面的 URL 可能存在问题：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Unless the validator treats the backslash as a path separator, it will interpret
    the hostname to be *example.com*, and treat *attacker.com\* as the username portion
    of the URL. But if the browser autocorrects the backslash to a forward slash,
    it will redirect the user to *attacker.com*, and treat *@example.com* as the path
    portion of the URL, forming the following valid URL:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除非验证器将反斜杠视为路径分隔符，否则它会将主机名解释为 *example.com*，并将 *attacker.com\* 视为 URL 的用户名部分。但如果浏览器自动将反斜杠修正为正斜杠，它会将用户重定向到
    *attacker.com*，并将 *@example.com* 视为 URL 的路径部分，从而形成以下有效的 URL：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Exploiting Flawed Validator Logic
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用有缺陷的验证器逻辑
- en: 'Another way you can bypass the open-redirect validator is by exploiting loopholes
    in the validator’s logic. For example, as a common defense against open redirects,
    the URL validator often checks if the redirect URL starts with, contains, or ends
    with the site’s domain name. You can bypass this type of protection by creating
    a subdomain or directory with the target’s domain name:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过利用验证器逻辑中的漏洞绕过开放重定向验证器。例如，作为一种常见的防止开放重定向的措施，URL 验证器通常会检查重定向 URL 是否以站点的域名开始、包含或结束。你可以通过创建一个带有目标域名的子域或目录来绕过这种保护：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To prevent attacks like these from succeeding, the validator might accept only
    URLs that both start and end with a domain listed on the allowlist. However, it’s
    possible to construct a URL that satisfies both of these rules. Take a look at
    this one:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止类似这些攻击的成功，验证器可能只接受那些既以允许列表上的域名开始又以该域名结束的 URL。然而，也有可能构造一个满足这两个规则的 URL。看看这个例子：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This URL redirects to *attacker.com*, despite beginning and ending with the
    target domain. The browser will interpret the first *example.com* as the subdomain
    name and the second one as the filepath.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 会重定向到 *attacker.com*，尽管它的开始和结束都包含目标域名。浏览器会将第一个 *example.com* 解释为子域名，而将第二个解释为文件路径。
- en: 'Or you could use the at symbol (@) to make the first *example.com* the username
    portion of the URL:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用 @ 符号，让第一个 *example.com* 成为 URL 的用户名部分：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Custom-built URL validators are prone to attacks like these, because developers
    often don’t consider all edge cases.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 定制的 URL 验证器容易受到类似这些攻击的影响，因为开发人员常常没有考虑到所有的边缘情况。
- en: Using Data URLs
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数据 URL
- en: 'You can also manipulate the scheme portion of the URL to fool the validator.
    As mentioned in Chapter 6, data URLs use the `data:` scheme to embed small files
    in a URL. They are constructed in this format:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以操控 URL 的方案部分来欺骗验证器。如第六章所述，数据 URL 使用 `data:` 方案将小文件嵌入到 URL 中。它们的构造格式如下：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For example, you can send a plaintext message with the data scheme like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以发送一个带有数据方案的纯文本消息，格式如下：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The optional base64 specification allows you to send base64-encoded messages.
    For example, this is the base64-encoded version of the preceding message:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 Base64 规范允许你发送 Base64 编码的消息。例如，这是前述消息的 Base64 编码版本：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can use the `data:` scheme to construct a base64-encoded redirect URL that
    evades the validator. For example, this URL will redirect to *example.com*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `data:` 方案构造一个 Base64 编码的重定向 URL，绕过验证器。例如，下面的 URL 会重定向到 *example.com*：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The data encoded in this URL, *PHNjcmlwdD5sb2NhdGlvbj0iaHR0cHM6Ly9leGFtcGxlLmNvbSI8L3NjcmlwdD4=*,
    is the base64-encoded version of this script:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该 URL 中编码的数据，*PHNjcmlwdD5sb2NhdGlvbj0iaHR0cHM6Ly9leGFtcGxlLmNvbSI8L3NjcmlwdD4=*，是该脚本的
    Base64 编码版本：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is a piece of JavaScript code wrapped between HTML `<script>` tags. It
    sets the location of the browser to *https://example.com*, forcing the browser
    to redirect there. You can insert this data URL into the redirection parameter
    to bypass blocklists:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 JavaScript 代码片段，包裹在 HTML `<script>` 标签之间。它将浏览器的位置设置为 *https://example.com*，强制浏览器重定向到该位置。你可以将这个数据
    URL 插入重定向参数中，从而绕过黑名单：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Exploiting URL Decoding
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用 URL 解码
- en: URLs sent over the internet can contain only *ASCII* *characters*, which include
    a set of characters commonly used in the English language and a few special characters.
    But since URLs often need to contain special characters or characters from other
    languages, people encode characters by using URL encoding. URL encoding converts
    a character into a percentage sign, followed by two hex digits; for example, `%2f`.
    This is the URL-encoded version of the slash character (`/`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过互联网发送的 URL 只能包含 *ASCII* *字符*，这些字符包括常用于英语中的一组字符以及一些特殊字符。但由于 URL 经常需要包含特殊字符或其他语言的字符，人们通过使用
    URL 编码对字符进行编码。URL 编码将字符转换为百分号，后跟两个十六进制数字；例如，`%2f`。这是斜杠字符 (`/`) 的 URL 编码版本。
- en: When validators validate URLs, or when browsers redirect users, they have to
    first find out what is contained in the URL by decoding any characters that are
    URL encoded. If there is any inconsistency between how the validator and browsers
    decode URLs, you could exploit that to your advantage.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当验证器验证 URL 或浏览器重定向用户时，它们必须首先通过解码任何 URL 编码的字符来确定 URL 中包含的内容。如果验证器和浏览器解码 URL 的方式存在任何不一致，你可以利用这一点来获得优势。
- en: Double Encoding
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双重编码
- en: 'First, try to double- or triple-URL-encode certain special characters in your
    payload. For example, you could URL-encode the slash character in *https://example.com/@attacker.com*.
    Here is the URL with a URL-encoded slash:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试在你的 payload 中对某些特殊字符进行双重或三重 URL 编码。例如，你可以对 *https://example.com/@attacker.com*
    中的斜杠字符进行 URL 编码。这里是一个带有 URL 编码斜杠的 URL：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And here is the URL with a double-URL-encoded slash:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个双重 URL 编码的斜杠的 URL：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, here is the URL with a triple-URL-encoded slash:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一个三重 URL 编码的斜杠：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Whenever a mismatch exists between how the validator and the browser decode
    these special characters, you can exploit the mismatch to induce an open redirect.
    For example, some validators might decode these URLs completely, then assume the
    URL redirects to *example.com*, since *@attacker.com* is in the path portion of
    the URL. However, the browsers might decode the URL incompletely, and instead
    treat *example.com%25252f* as the username portion of the URL.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当验证器和浏览器在解码这些特殊字符时存在不匹配时，你可以利用这种不匹配来引发开放重定向。例如，一些验证器可能会完全解码这些 URL，然后假设该 URL
    会重定向到*example.com*，因为 *@attacker.com* 位于 URL 的路径部分。然而，浏览器可能会解码不完全，而将 *example.com%25252f*
    视为 URL 的用户名部分。
- en: 'On the other hand, if the validator doesn’t double-decode URLs, but the browser
    does, you can use a payload like this one:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果验证器不对 URL 进行双重解码，而浏览器会，那么你可以使用像这样的 payload：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The validator would see *example.com* as the hostname. But the browser would
    redirect to *attacker.com*, because *@example.com* becomes the path portion of
    the URL, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器会将 *example.com* 视为主机名。但浏览器会重定向到 *attacker.com*，因为 *@example.com* 成为 URL
    的路径部分，像这样：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Non-ASCII Characters
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非 ASCII 字符
- en: 'You can sometimes exploit inconsistencies in the way the validator and browsers
    decode non-ASCII characters. For example, let’s say that this URL has passed URL
    validation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时可以利用验证器和浏览器解码非 ASCII 字符时的不一致。例如，假设这个 URL 已通过 URL 验证：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`%ff` is the character ÿ, which is a non-ASCII character. The validator has
    determined that *example.com* is the domain name, and *attacker.comÿ* is the subdomain
    name. Several scenarios could happen. Sometimes browsers decode non-ASCII characters
    into question marks. In this case, *example.com* would become part of the URL
    query, not the hostname, and the browser would navigate to *attacker.com* instead:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`%ff` 是字符 ÿ，这是一个非 ASCII 字符。验证器已确定 *example.com* 是域名，而 *attacker.comÿ* 是子域名。可能发生几种情况。有时浏览器会将非
    ASCII 字符解码为问号。在这种情况下，*example.com* 将成为 URL 查询的一部分，而不是主机名，浏览器会导航到 *attacker.com*：'
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Another common scenario is that browsers will attempt to find a “most alike”
    character. For example, if the character ╱ (`%E2%95%B1`) appears in a URL like
    this, the validator might determine that the hostname is *example.com*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的情况是，浏览器会尝试查找“最相似”的字符。例如，如果字符 ╱ (`%E2%95%B1`) 出现在像这样的 URL 中，验证器可能会确定主机名是
    *example.com*：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But the browser converts the slash look-alike character into an actual slash,
    making *attacker.com* the hostname instead:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但浏览器将斜杠相似字符转换为实际的斜杠，使 *attacker.com* 成为主机名：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Browsers normalize URLs this way often in an attempt to be user-friendly. In
    addition to similar symbols, you can use character sets in other languages to
    bypass filters. The *Unicode* standard is a set of codes developed to represent
    all of the world’s languages on the computer. You can find a list of Unicode characters
    at [http://www.unicode.org/charts/](http://www.unicode.org/charts/). Use the Unicode
    chart to find look-alike characters and insert them in URLs to bypass filters.
    The *Cyrillic* character set is especially useful since it contains many characters
    similar to ASCII characters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器通常会以这种方式标准化 URL，旨在提高用户友好性。除了使用类似的符号外，你还可以使用其他语言的字符集来绕过过滤器。*Unicode* 标准是一组为在计算机上表示世界所有语言而开发的代码集。你可以在[http://www.unicode.org/charts/](http://www.unicode.org/charts/)上找到
    Unicode 字符的列表。利用 Unicode 图表查找相似字符并将其插入 URL 中，以绕过过滤器。*西里尔*字符集特别有用，因为它包含许多与 ASCII
    字符相似的字符。
- en: Combining Exploit Techniques
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合利用技巧
- en: 'To defeat more-sophisticated URL validators, combine multiple strategies to
    bypass layered defenses. I’ve found the following payload to be useful:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了破解更复杂的 URL 验证器，可以结合多种策略来绕过层层防御。我发现以下载荷非常有用：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This URL bypasses protection that checks only that a URL contains, starts with,
    or ends with an allowlisted hostname by making the URL both start and end with
    *example.com*. Most browsers will interpret *example.com%252f* as the username
    portion of the URL. But if the validator over-decodes the URL, it will confuse
    *example.com* as the hostname portion:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 绕过了仅检查 URL 是否包含、以某个允许列出的主机名开始或结束的保护，方法是使 URL 同时以*example.com*开头和结尾。大多数浏览器会将*example.com%252f*解释为
    URL 的用户名部分。但如果验证器对 URL 进行过度解码，它会将*example.com*误认为是主机名部分：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can use many more methods to defeat URL validators. In this section, I’ve
    provided an overview of the most common ones. Try each of them to check for weaknesses
    in the validator you are testing. If you have time, experiment with URLs to invent
    new ways of bypassing URL validators. For example, try inserting random non-ASCII
    characters into a URL, or intentionally messing up its different components, and
    see how browsers interpret it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用更多方法来破解 URL 验证器。在本节中，我提供了最常见的一些方法概述。尝试每一种方法，检查你正在测试的验证器是否存在弱点。如果你有时间，可以尝试构造新的
    URL，发明绕过 URL 验证器的新的方式。例如，尝试在 URL 中插入随机的非 ASCII 字符，或者故意搞乱它的不同部分，看看浏览器如何解释它。
- en: Escalating the Attack
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级攻击
- en: 'Attackers could use open redirects by themselves to make their phishing attacks
    more credible. For example, they could send this URL in an email to a user: *https://example.com/login?next=https://attacker.com/fake_login.html.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过自己使用开放重定向来使他们的网络钓鱼攻击更加可信。例如，他们可以将此 URL 发送到用户的电子邮件中：*https://example.com/login?next=https://attacker.com/fake_login.html*。
- en: 'Though this URL would first lead users to the legitimate website, it would
    redirect them to the attacker’s site after login. The attacker could host a fake
    login page on a malicious site that mirrors the legitimate site’s login page,
    and prompt the user to log in again with a message like this one:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个 URL 最初会将用户引导到合法网站，但登录后会将他们重定向到攻击者的网站。攻击者可以在恶意网站上托管一个虚假的登录页面，模仿合法站点的登录页面，并通过类似下面这样的消息提示用户重新登录：
- en: Sorry! The password you provided was incorrect. Please enter your username and
    password again.
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对不起！您提供的密码不正确。请重新输入您的用户名和密码。
- en: Believing they’ve entered an incorrect password, the user would provide their
    credentials to the attacker’s site. At this point, the attacker’s site could even
    redirect the user back to the legitimate site to keep the victim from realizing
    that their credentials were stolen.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能会认为自己输入了错误的密码，从而将自己的凭据提供给攻击者的站点。这时，攻击者的站点甚至可以将用户重定向回合法站点，避免受害者意识到他们的凭据已被盗。
- en: 'Since organizations can’t prevent phishing completely (because those attacks
    depend on human judgment), security teams will often dismiss open redirects as
    trivial bugs if reported on their own. But open redirects can often serve as a
    part of a bug chain to achieve a bigger impact. For example, an open redirect
    can help you bypass URL blocklists and allowlists. Take this URL, for example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组织无法完全防止网络钓鱼攻击（因为这些攻击依赖于人为判断），安全团队通常会将开放重定向视为微不足道的漏洞，如果仅仅是单独报告时。然而，开放重定向往往能作为一系列漏洞中的一环，发挥更大的作用。例如，开放重定向可以帮助绕过
    URL 阻止列表和白名单。例如，考虑这个 URL：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This URL will pass even well-implemented URL validators, because the URL is
    technically still on the legitimate website. Open redirects can, therefore, help
    you maximize the impact of vulnerabilities like server-side request forgery (SSRF),
    which I’ll discuss in Chapter 13. If a site utilizes an allowlist to prevent SSRFs
    and allows requests to only a list of predefined URLs, an attacker can utilize
    an open redirect within those allowlisted pages to redirect the request anywhere.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 即使是经过精心实现的 URL 验证器也能通过，因为从技术上讲，URL 仍然在合法的网站上。因此，开放重定向可以帮助你最大化诸如服务器端请求伪造（SSRF）等漏洞的影响，我将在第
    13 章讨论。如果一个网站利用白名单来防止 SSRF，并只允许请求访问预定义的 URL 列表，攻击者可以利用在这些白名单页面中的开放重定向，将请求重定向到任何地方。
- en: You could also use open redirects to steal credentials and OAuth tokens. Often,
    when a page redirects to another site, browsers will include the originating URL
    as a referer HTTP request header. When the originating URL contains sensitive
    information, like authentication tokens, attackers can induce an open redirect
    to steal the tokens via the referer header. (Even when there is no open redirect
    on the sensitive endpoint, there are ways to smuggle tokens offsite by using open
    redirect chains. I’ll go into detail about how these attacks work in Chapter 20.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以利用开放重定向来窃取凭证和 OAuth 令牌。通常，当页面重定向到另一个网站时，浏览器会将原始 URL 作为 referer HTTP 请求头包含在内。当原始
    URL 包含敏感信息，如认证令牌时，攻击者可以通过诱导开放重定向来通过 referer 头窃取令牌。（即使在敏感端点没有开放重定向，也有方法通过使用开放重定向链将令牌转移到站外。关于这些攻击如何工作的详细信息，我将在第
    20 章讲解。）
- en: Finding Your First Open Redirect!
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找你的第一个开放重定向！
- en: 'You’re ready to find your first open redirect. Follow the steps covered in
    this chapter to test your target applications:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你已准备好寻找第一个开放重定向。按照本章介绍的步骤测试你的目标应用：
- en: Search for redirect URL parameters. These might be vulnerable to parameter-based
    open redirect.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索重定向 URL 参数。这些参数可能会对基于参数的开放重定向存在漏洞。
- en: Search for pages that perform referer-based redirects. These are candidates
    for a referer-based open redirect.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索执行基于 referer 的重定向的页面。这些页面是基于 referer 的开放重定向的候选者。
- en: Test the pages and parameters you’ve found for open redirects.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试你找到的页面和参数，查看是否存在开放重定向。
- en: If the server blocks the open redirect, try the protection bypass techniques
    mentioned in this chapter.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果服务器阻止了开放重定向，尝试本章提到的保护绕过技术。
- en: Brainstorm ways of using the open redirect in your other bug chains!
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 思考如何在其他漏洞链中使用开放重定向！
