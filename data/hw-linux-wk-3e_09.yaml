- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Understanding Your Network and Its Configuration
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的网络及其配置
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Networking is the practice of connecting computers and sending data between
    them. That sounds simple enough, but to understand how it works, you need to ask
    two fundamental questions:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是连接计算机并在它们之间传输数据的实践。听起来很简单，但要理解它是如何工作的，你需要提出两个基本问题：
- en: How does the computer sending the data know *where* to send its data?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送数据的计算机如何知道*把数据发送到哪里*呢？
- en: When the destination computer receives the data, how does it know *what* it
    just received?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当目标计算机接收到数据时，它如何知道*它刚刚接收到的是什么*呢？
- en: A computer answers these questions by using a series of components, with each
    one responsible for a certain aspect of sending, receiving, and identifying data.
    The components are arranged in groups that form *network layers*, which stack
    on top of each other in order to form a complete system. The Linux kernel handles
    networking in a similar way to the SCSI subsystem described in Chapter 3.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通过使用一系列组件来回答这些问题，每个组件负责发送、接收和识别数据的某个方面。这些组件被组织成多个*网络层*，这些网络层依次堆叠，形成一个完整的系统。Linux内核处理网络的方式与第3章中描述的SCSI子系统类似。
- en: Because each layer tends to be independent, it’s possible to build networks
    with many different combinations of components. This is where network configuration
    can become very complicated. For this reason, we’ll begin this chapter by looking
    at the layers in very simple networks. You’ll learn how to view your own network
    settings, and when you understand the basic workings of each layer, you’ll be
    ready to learn how to configure those layers by yourself. Finally, you’ll move
    on to more advanced topics like building your own networks and configuring firewalls.
    (Skip over that material if your eyes start to glaze over; you can always come
    back.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每一层往往是独立的，所以可以通过许多不同的组件组合来构建网络。这也是网络配置变得非常复杂的地方。正因如此，我们将从研究非常简单的网络中的层开始。本章将教你如何查看自己的网络设置，当你理解了每一层的基本工作原理后，你就能自己配置这些层。最后，你将进入更高级的主题，比如构建自己的网络和配置防火墙。（如果这些内容让你感到困惑，可以跳过；你总可以回来继续学习。）
- en: 9.1 Network Basics
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 网络基础
- en: Before getting into the theory of network layers, take a look at the simple
    network shown in [Figure 9-1](#figure9-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨网络层的理论之前，先看看[图9-1](#figure9-1)中展示的简单网络。
- en: '![f09001](image_fi/500402c09/f09001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](image_fi/500402c09/f09001.png)'
- en: 'Figure 9-1: A typical local area network with a router that provides internet
    access'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：一个典型的局域网，路由器提供互联网接入
- en: This type of network is ubiquitous; most home and small office networks are
    configured this way. Each machine connected to the network is called a *host*.
    One of these is a *router*, which is a host that can move data from one network
    to another. In this example, these four hosts (Hosts A, B, C, and the router)
    form a local area network (*LAN*). The connections on the LAN can be wired or
    wireless. There isn’t a strict definition of a LAN; the machines residing on a
    LAN are usually physically close and share much of the same configuration and
    access rights. You’ll see a specific example soon.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的网络是无处不在的；大多数家庭和小型办公室的网络都是这样配置的。每一台连接到网络的计算机称为*主机*。其中之一是*路由器*，它是一个可以将数据从一个网络移动到另一个网络的主机。在这个例子中，这四台主机（主机A、B、C和路由器）组成了一个局域网（*LAN*）。局域网中的连接可以是有线的，也可以是无线的。局域网没有严格的定义；局域网上的计算机通常彼此物理接近，且共享相似的配置和访问权限。你很快就会看到一个具体的例子。
- en: The router is also connected to the internet—the cloud in the figure. This connection
    is called the *uplink* or the wide area network (*WAN*) connection, because it
    links the much smaller LAN to a larger network. Because the router is connected
    to both the LAN and the internet, all machines on the LAN also have access to
    the internet through the router. One of the goals of this chapter is to see how
    the router provides this access.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器也连接到互联网——图中的云。这个连接被称为*上行链路*或广域网（*WAN*）连接，因为它将更小的局域网（LAN）连接到更大的网络。由于路由器同时连接到局域网和互联网，局域网上的所有计算机也可以通过路由器访问互联网。本章的目标之一就是了解路由器是如何提供这种访问的。
- en: Your initial point of view will be from a Linux-based machine such as Host A
    on the LAN in [Figure 9-1](#figure9-1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的初步视角将来自一个基于Linux的机器，例如[图9-1](#figure9-1)中局域网上的主机A。
- en: 9.2 Packets
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 数据包
- en: 'A computer transmits data over a network in small chunks called *packets*,
    which consist of two parts: a *header* and a *payload*. The header contains identifying
    information such as the source and destination host machines and the basic protocol.
    The payload, on the other hand, is the actual application data that the computer
    wants to send (for example, HTML or image data).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通过网络传输数据时，会将数据分成小块，称为*数据包*，每个数据包由两部分组成：*头部*和*负载*。头部包含标识信息，如源主机和目标主机，以及基本协议。另一方面，负载则是计算机希望发送的实际应用数据（例如
    HTML 或图像数据）。
- en: A host can send, receive, and process packets in any order, regardless of where
    they came from or where they’re going, which makes it possible for several hosts
    to communicate “simultaneously.” For example, if a host needs to transmit data
    to two others at once, it can alternate between the destinations in outgoing packets.
    Breaking messages into smaller units also makes it easier to detect and compensate
    for errors in transmission.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 主机可以以任何顺序发送、接收和处理数据包，无论它们来自哪里或将要去往何处，这使得多个主机可以“同时”进行通信。例如，如果一台主机需要同时向两台主机传输数据，它可以在发送的数据包中交替选择目的地。将消息拆分成较小的单元也使得在传输过程中更容易检测并弥补错误。
- en: For the most part, you don’t have to worry about translating between packets
    and the data that your application uses, because the operating system does this
    for you. However, it is helpful to know the role of packets in the network layers
    that you’re about to see.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，你不需要担心在数据包和应用程序使用的数据之间进行转换，因为操作系统会为你处理这个问题。然而，了解数据包在你即将看到的网络层中的角色是很有帮助的。
- en: 9.3 Network Layers
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 网络层
- en: 'A fully functioning network includes a set of network layers called a *network
    stack*. Any functional network has a stack. The typical internet stack, from the
    top to bottom layer, looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完全功能的网络包括一组被称为*网络栈*的网络层。任何功能性的网络都有一个栈。典型的互联网栈，从上到下的层级如下：
- en: Application layer Contains the “language” that applications and servers use
    to communicate—usually a high-level protocol of some sort. Common application
    layer protocols include Hypertext Transfer Protocol (HTTP, used for the web),
    encryption protocols such as TLS, and File Transfer Protocol (FTP). Application
    layer protocols can often be combined. For example, TLS is commonly used in conjunction
    with HTTP to form HTTPS.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用层包含应用程序和服务器用于通信的“语言”——通常是一种高级协议。常见的应用层协议包括超文本传输协议（HTTP，网页使用）、加密协议如 TLS 和文件传输协议（FTP）。应用层协议通常可以组合使用。例如，TLS
    常与 HTTP 配合使用，形成 HTTPS。
- en: Application layer processing occurs in user space.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用层处理发生在用户空间。
- en: Transport layer Defines the data transmission characteristics of the application
    layer. This layer includes data integrity checking, source and destination ports,
    and specifications for breaking application data into packets at the host side
    (if the application layer has not already done so), and reassembling them at the
    destination. Transmission Control Protocol (TCP) and User Datagram Protocol (UDP)
    are the most common transport layer protocols. The transport layer is sometimes
    called the *protocol layer*.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传输层定义了应用层的数据传输特性。该层包括数据完整性检查、源和目标端口、以及在主机端将应用数据拆分为数据包（如果应用层尚未这样做）并在目标端重新组装的规范。传输控制协议（TCP）和用户数据报协议（UDP）是最常见的传输层协议。传输层有时被称为*协议层*。
- en: In Linux, the transport layer and all layers below are primarily handled by
    the kernel, but there are some exceptions where packets are sent into user space
    for processing.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Linux 中，传输层及以下的所有层主要由内核处理，但也有一些例外，数据包会被发送到用户空间进行处理。
- en: Network or internet layer Defines how to move packets from a source host to
    a destination host. The particular packet transit rule set for the internet is
    known as the *internet protocol (IP)*. Because we’ll only talk about internet
    networks in this book, we’ll really only be talking about the internet layer.
    However, because network layers are meant to be hardware independent, you can
    simultaneously configure several independent network layers—such as IP (IPv4),
    IPv6, IPX, and AppleTalk—on a single host.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络层或互联网层定义了如何将数据包从源主机传输到目标主机。互联网的特定数据包传输规则集被称为*互联网协议（IP）*。因为本书只讨论互联网网络，所以我们实际上只讨论互联网层。然而，由于网络层旨在硬件独立，你可以在一台主机上同时配置多个独立的网络层——如
    IP（IPv4）、IPv6、IPX 和 AppleTalk。
- en: Physical layer Defines how to send raw data across a physical medium, such as
    Ethernet or a modem. This is sometimes called the *link layer* or *host-to-network
    layer*.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 物理层 定义了如何通过物理介质发送原始数据，例如以太网或调制解调器。这有时被称为*链路层*或*主机到网络层*。
- en: It’s important to understand the structure of a network stack because your data
    must travel through these layers at least twice before it reaches a program at
    its destination. For example, if you’re sending data from Host A to Host B, as
    shown in [Figure 9-1](#figure9-1), your bytes leave the application layer on Host
    A and travel through the transport and network layers on Host A; then they go
    down to the physical medium, across the medium, and up again through the various
    lower levels to the application layer on Host B in much the same way. If you’re
    sending something to a host on the internet through the router, it will go through
    some (but usually not all) of the layers on the router and anything else in between.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理解网络堆栈的结构非常重要，因为你的数据必须至少通过这些层两次才能到达目标程序。例如，如果你从主机A向主机B发送数据，如[图 9-1](#figure9-1)所示，你的数据字节会离开主机A的应用层，穿过主机A的传输层和网络层；然后它们下降到物理介质，通过介质，再通过各个较低层次，最终到达主机B的应用层。如果你通过路由器向互联网上的主机发送数据，它会经过路由器的某些（但通常不是全部）层以及任何其他中间设备。
- en: The layers sometimes bleed into each other in strange ways because it can be
    inefficient to process all of them in order. For example, devices that historically
    dealt with only the physical layer now sometimes look at the transport and internet
    layer data simultaneously to filter and route data quickly. In addition, the terminology
    itself can be confusing. For example, TLS stands for Transport Layer Security,
    but in reality, resides one layer higher, in the application layer. (Don’t worry
    about these annoying details when you’re learning the basics.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 层有时会以奇怪的方式互相重叠，因为按顺序处理所有层可能效率低下。例如，历史上仅处理物理层的设备现在有时会同时查看传输层和互联网层的数据，以便快速过滤和路由数据。此外，术语本身可能会让人困惑。例如，TLS代表传输层安全性，但实际上它位于更高的层次——应用层。（当你学习基础知识时，不用太担心这些烦人的细节。）
- en: We’ll begin by looking at how your Linux machine connects to the network in
    order to answer the *where* question at the beginning of the chapter. This is
    the lower part of the stack—the physical and network layers. Later, we’ll look
    at the upper two layers that answer the *what* question.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看你的Linux机器是如何连接到网络的，以回答本章开头的*where*问题。这是堆栈的底部——物理层和网络层。稍后，我们将查看回答*what*问题的上面两个层。
- en: 9.4 The Internet Layer
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 互联网层
- en: Rather than start at the very bottom of the network stack with the physical
    layer, we’ll start at the network layer because it can be easier to understand.
    The internet as we currently know it is based on internet protocol versions 4
    (IPv4) and 6 (IPv6). One of the most important aspects of the internet layer is
    that it’s meant to be a software network that places no particular requirements
    on hardware or operating systems. The idea is that you can send and receive internet
    packets over any kind of hardware, using any operating system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从网络层开始，而不是从网络堆栈的最底层——物理层开始，因为网络层可能更容易理解。我们目前所知道的互联网是基于互联网协议版本4（IPv4）和版本6（IPv6）。互联网层的一个最重要方面是，它旨在成为一个软件网络，不对硬件或操作系统提出任何特定要求。其想法是，你可以通过任何类型的硬件，使用任何操作系统，发送和接收互联网数据包。
- en: Our discussion will start with IPv4 because it’s a little easier to read the
    addresses (and understand its limitations), but we’ll explain the primary differences
    in IPv6\.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的讨论将从IPv4开始，因为它的地址稍微容易阅读（并且理解其局限性），但我们会解释IPv6的主要区别。
- en: The internet’s topology is decentralized; it’s made up of smaller networks called
    *subnets*. The idea is that all subnets are interconnected in some way. For example,
    in [Figure 9-1](#figure9-1), the LAN is normally a single subnet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的拓扑是去中心化的；它由称为*子网*的较小网络组成。这个想法是，所有子网以某种方式相互连接。例如，在[图 9-1](#figure9-1)中，局域网通常是一个单一的子网。
- en: A host can be attached to more than one subnet. As you saw in Section 9.1, that
    kind of host is called a router if it can transmit data from one subnet to another
    (another term for router is *gateway*). [Figure 9-2](#figure9-2) refines [Figure
    9-1](#figure9-1) by identifying the LAN as a subnet, as well as internet addresses
    for each host and the router. The router in the figure has two addresses, the
    local subnet 10.23.2.1 and the link to the internet (the internet link’s address
    is not important right now, so it’s just labeled Uplink Address). We’ll look first
    at the addresses and then the subnet notation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一台主机可以连接到多个子网。正如你在第9.1节看到的，如果主机能够在不同子网之间传输数据，它就被称为路由器（路由器的另一个术语是*网关*）。[图9-2](#figure9-2)通过将局域网标识为子网，并为每个主机和路由器指定互联网地址，完善了[图9-1](#figure9-1)。图中的路由器有两个地址，一个是本地子网10.23.2.1，另一个是连接到互联网的地址（互联网连接的地址目前并不重要，因此它被标记为上行地址）。我们首先来看看这些地址，然后再看子网表示法。
- en: Each internet host has at least one numeric *IP address*. For IPv4, it’s in
    the form of *a.b.c.d*, such as 10.23.2.37\. An address in this notation is called
    a *dotted-quad* sequence. If a host is connected to multiple subnets, it has at
    least one IP address per subnet. Each host’s IP address should be unique across
    the entire internet, but as you’ll see later, private networks and Network Address
    Translation (NAT) can make this a little confusing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个互联网主机至少有一个数字的*IP地址*。对于IPv4，它的格式是*a.b.c.d*，例如10.23.2.37。这样的地址表示法称为*点分四段*序列。如果一台主机连接到多个子网，它在每个子网上至少有一个IP地址。每台主机的IP地址应该在整个互联网中是唯一的，但正如你稍后会看到的，私有网络和网络地址转换（NAT）可能会让这个问题变得有些复杂。
- en: Don’t worry about the subnet notation in [Figure 9-2](#figure9-2) yet; we’ll
    discuss it shortly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心[图9-2](#figure9-2)中的子网表示法，我们稍后会讨论。
- en: '![f09002](image_fi/500402c09/f09002.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](image_fi/500402c09/f09002.png)'
- en: 'Figure 9-2: Network with IP addresses'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2：带有IP地址的网络
- en: IP addresses are like postal addresses in some ways. To communicate with another
    host, your machine must know that other host’s IP address.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址在某些方面类似于邮政地址。为了与另一台主机通信，你的机器必须知道另一台主机的IP地址。
- en: Let’s take a look at the address on your machine.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看你机器上的地址。
- en: 9.4.1 Viewing IP Addresses
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 查看IP地址
- en: 'One machine can have many IP addresses, accommodating multiple physical interfaces,
    virtual internal networks, and more. To see the addresses that are active on your
    Linux machine, run:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一台机器可以拥有多个IP地址，支持多个物理接口、虚拟内部网络等。要查看在Linux机器上活动的地址，请运行：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There will probably be a lot of output (grouped by physical interface, covered
    in Section 9.10), but it should include something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有大量的输出（按物理接口分组，详见第9.10节），但它应该包括如下内容：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ip` command’s output includes many details from the internet layer(s) and
    the physical layer. (Sometimes it doesn’t even include an internet address at
    all!) We’ll discuss the output in more detail later, but for now, concentrate
    on the fourth line, which reports that the host is configured to have an IPv4
    address (denoted with `inet`) of 10.23.2.4\. The `/24` after the address helps
    define the subnet that the IP address belongs to. Let’s see how that works.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip`命令的输出包含来自互联网层和物理层的许多详细信息。（有时它甚至根本不会显示互联网地址！）我们稍后会更详细地讨论输出内容，但现在，请关注第四行，它报告主机已配置一个IPv4地址（以`inet`表示）为10.23.2.4。地址后面的`/24`有助于定义该IP地址所属的子网。我们来看一下它是如何工作的。'
- en: 9.4.2 Subnets
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 子网
- en: A subnet, defined previously, is a connected group of hosts with IP addresses
    in a particular range. For example, the hosts in the range 10.23.2.1 to 10.23.2.254
    could comprise a subnet, as could all hosts between 10.23.1.1 and 10.23.255.254\.
    Usually, the subnet hosts are on the same physical network, as shown in [Figure
    9-2](#figure9-2).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，子网是一个由IP地址位于特定范围内的主机组成的连接组。例如，10.23.2.1到10.23.2.254范围内的主机可以组成一个子网，同样，10.23.1.1到10.23.255.254之间的所有主机也可以组成一个子网。通常，子网中的主机位于同一个物理网络中，如[图9-2](#figure9-2)所示。
- en: 'You define a subnet with two pieces: a *network prefix* (also called a *routing
    prefix*) and a *subnet mask* (sometimes called the *network mask* or *routing
    mask*). Let’s say you want to create a subnet containing the IP addresses between
    10.23.2.1 and 10.23.2.254\. The network prefix is the part that is *common* to
    all addresses in the subnet; in this example, it’s 10.23.2.0 with a subnet mask
    of 255.255.255.0\. Let’s see where those numbers come from.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义一个子网有两个部分：一个 *网络前缀*（也叫 *路由前缀*）和一个 *子网掩码*（有时叫做 *网络掩码* 或 *路由掩码*）。假设你想创建一个包含
    10.23.2.1 到 10.23.2.254 之间 IP 地址的子网。网络前缀是所有子网地址中 *共同* 的部分；在这个例子中，它是 10.23.2.0，子网掩码是
    255.255.255.0。让我们看看这些数字是如何来的。
- en: To see how the prefix and mask work together to give you all possible IP addresses
    on a subnet, we’ll look at the binary form. The mask marks the bit locations in
    an IP address that are common to the subnet. For example, here are the binary
    forms of 10.23.2.0 and 255.255.255.0.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解前缀和子网掩码如何协同工作，从而给出子网上所有可能的 IP 地址，我们将查看二进制形式。子网掩码标记了 IP 地址中与子网共有的位位置。例如，下面是
    10.23.2.0 和 255.255.255.0 的二进制形式。
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let’s use boldface to mark the bit locations in 10.23.2.0 that are 1s
    in 255.255.255.0:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用粗体标记 10.23.2.0 中在 255.255.255.0 中为 1 的位位置：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Any address containing the bit configuration in bold is in the subnet. Looking
    at the bits that are *not* in bold (the last set of eight 0s), setting any number
    of these bits to 1 results in a valid IP address in this subnet, with the exception
    of all 0s or all 1s.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含粗体位配置的地址都在该子网中。查看那些 *不* 是粗体的位（最后一组八个 0），将这些位中的任何数量设置为 1 都会得到该子网中的有效 IP 地址，唯一的例外是全
    0 或全 1。
- en: Putting it all together, you can see how a host with an IP address of 10.23.2.1
    and a subnet mask of 255.255.255.0 is on the same subnet as any other computer
    that has an IP address beginning with 10.23.2\. You can denote this entire subnet
    as 10.23.2.0/255.255.255.0.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们结合起来，你可以看到一个 IP 地址为 10.23.2.1 且子网掩码为 255.255.255.0 的主机，和任何其他 IP 地址以 10.23.2
    开头的计算机在同一个子网中。你可以用 10.23.2.0/255.255.255.0 来表示整个子网。
- en: Now let’s see how this becomes the shorthand notation (such as /24) that you’ve
    seen from tools such as `ip`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这如何变成你从工具（如 `ip`）中看到的简写表示法（如 /24）。
- en: 9.4.3 Common Subnet Masks and CIDR Notation
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.3 常见子网掩码和 CIDR 表示法
- en: In most internet tools, you’ll encounter a different form of subnet representation
    called *Classless Inter-Domain Routing (CIDR) notation*, where a subnet such as
    10.23.2.0/255.255.255.0 is written as 10.23.2.0/24\. This shorthand takes advantage
    of the simple pattern that subnet masks follow.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数互联网工具中，你会遇到一种不同的子网表示法，称为 *无类域间路由（CIDR）表示法*，其中像 10.23.2.0/255.255.255.0 这样的子网会写作
    10.23.2.0/24。这种简写方式利用了子网掩码遵循的简单模式。
- en: Look at the mask in binary form, as in the example you saw in the preceding
    section. You’ll find that all subnet masks are (or should be, according to RFC
    1812) just one block of 1s followed by one block of 0s. For example, you just
    saw that 255.255.255.0 in binary form is 24 1-bits followed by 8 0-bits. The CIDR
    notation identifies the subnet mask by the number of *leading* 1s in the subnet
    mask. Therefore, a combination such as 10.23.2.0/24 includes both the subnet prefix
    and its subnet mask.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前一节中你看到的二进制形式的子网掩码。你会发现所有子网掩码都是（或者根据 RFC 1812，应该是）一个 1 的块后跟一个 0 的块。例如，你刚刚看到的
    255.255.255.0 的二进制形式是 24 个 1 位后跟 8 个 0 位。CIDR 表示法通过子网掩码中的 *前导* 1 位的数量来标识子网掩码。因此，像
    10.23.2.0/24 这样的组合包括了子网前缀和其子网掩码。
- en: '[Table 9-1](#table9-1) shows several example subnet masks and their CIDR forms.
    The /24 subnet mask is the most common on local end-user networks; it’s often
    used in combination with one of the private networks that you’ll see in Section
    9.22.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](#table9-1) 显示了几个示例子网掩码及其 CIDR 形式。/24 子网掩码是本地终端用户网络中最常见的；它通常与你将在 9.22
    节中看到的某个私有网络一起使用。'
- en: 'Table 9-1: Subnet Masks'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1：子网掩码
- en: '| **Long form** | **CIDR form** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **长格式** | **CIDR 格式** |'
- en: '| --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 255.0.0.0 | /8 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 255.0.0.0 | /8 |'
- en: '| 255.255.0.0 | /16 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 255.255.0.0 | /16 |'
- en: '| 255.240.0.0 | /12 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 255.240.0.0 | /12 |'
- en: '| 255.255.255.0 | /24 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 255.255.255.0 | /24 |'
- en: '| 255.255.255.192 | /26 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 255.255.255.192 | /26 |'
- en: Taking this one step further, you might have already noticed that if you’ve
    got the IP address and the subnet mask, you don’t even need to bother with a separate
    network definition. You can combine them, as you saw back in Section 9.4.1; the
    `ip address show` output included 10.23.2.4/24.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，你可能已经注意到，如果你有IP地址和子网掩码，实际上你甚至不需要单独定义网络。你可以将它们组合在一起，就像你在第9.4.1节中看到的那样；`ip
    address show`的输出包括了10.23.2.4/24。
- en: Identifying subnets and their hosts is the first building block to understanding
    how the internet works. However, you still need to connect the subnets.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 识别子网及其主机是理解互联网如何工作的第一步。然而，你仍然需要连接这些子网。
- en: 9.5 Routes and the Kernel Routing Table
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 路由和内核路由表
- en: Connecting internet subnets is mostly a process of sending data through hosts
    connected to more than one subnet. Returning to [Figure 9-2](#figure9-2), think
    about Host A at IP address 10.23.2.4\. This host is connected to a local network
    of 10.23.2.0/24 and can directly reach hosts on that network. To reach hosts on
    the rest of the internet, it must communicate through the router (host) at 10.23.2.1\.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 连接互联网子网通常是通过连接到多个子网的主机发送数据来实现的。回到[图9-2](#figure9-2)，考虑一下IP地址为10.23.2.4的主机A。该主机连接到10.23.2.0/24的本地网络，并且可以直接访问该网络中的主机。为了访问互联网其他主机，它必须通过10.23.2.1的路由器（主机）进行通信。
- en: 'The Linux kernel distinguishes between these two different kinds of destinations
    by using a *routing table* to determine its routing behavior. To show the routing
    table, use the `ip route show` command. Here’s what you might see for a simple
    host such as 10.23.2.4:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核通过使用*路由表*来区分这两种不同的目标，以确定其路由行为。要查看路由表，请使用`ip route show`命令。以下是你可能会看到的简单主机（例如10.23.2.4）的输出：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This output can be a little difficult to read. Each line is a routing rule;
    let’s start with the second line in this example, and break that into fields.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出可能有些难以阅读。每一行都是一个路由规则；我们从本例的第二行开始，将其拆分成各个字段。
- en: The first field you encounter is `10.23.2.0/24`, which is a destination network.
    As with previous examples, this is the host’s local subnet. This rule says that
    the host can reach the local subnet directly through its network interface, indicated
    by the `dev enp0s31f6` mechanism label after the destination. (Following this
    field is more detail about the route, including how it was put in place. You don’t
    need to worry about that for now.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你遇到的第一个字段是`10.23.2.0/24`，它是一个目标网络。和之前的例子一样，这是主机的本地子网。该规则表示主机可以通过其网络接口直接访问本地子网，这由目标后面的`dev
    enp0s31f6`机制标签指示。（在该字段之后是关于路由的更多细节，包括它是如何设置的。目前你不需要担心这些细节。）
- en: Then we can move back to the first line of output, which has the destination
    network `default`. This rule, which matches any host at all, is also called the
    *default route*, explained in the next section. The mechanism is `via 10.23.2.1`,
    indicating that traffic using the default route is to be sent to 10.23.2.1 (in
    our example network, this is a router); `dev enp0s31f6` indicates that the physical
    transmission will happen on that network interface.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以回到输出的第一行，该行的目标网络是`default`。这个规则匹配任何主机，因此也叫做*默认路由*，在下一节中会解释。该机制是`via 10.23.2.1`，表示使用默认路由的流量会被发送到10.23.2.1（在我们示例网络中，这是一台路由器）；`dev
    enp0s31f6`表示物理传输将在该网络接口上进行。
- en: 9.6 The Default Gateway
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 默认网关
- en: The entry for `default` in the routing table has special significance because
    it matches any address on the internet. In CIDR notation, it’s 0.0.0.0/0 for IPv4\.
    This is the default route, and the address configured as the intermediary in the
    default route is the *default gateway*. When no other rules match, the default
    route always does, and the default gateway is where you send messages when there
    is no other choice. You can configure a host without a default gateway, but it
    won’t be able to reach hosts outside the destinations in the routing table.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 路由表中`default`条目的意义特殊，因为它匹配互联网中的任何地址。在CIDR表示法中，它是0.0.0.0/0用于IPv4。这是默认路由，配置为默认路由中间人的地址被称为*默认网关*。当没有其他规则匹配时，默认路由始终匹配，默认网关就是没有其他选择时发送消息的地方。你可以配置一个没有默认网关的主机，但它将无法访问路由表中目的地之外的主机。
- en: On most networks with a netmask of /24 (255.255.255.0), the router is usually
    at address 1 of the subnet (for example, 10.23.2.1 in 10.23.2.0/24). This is simply
    a convention, and there can be exceptions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数子网掩码为/24（255.255.255.0）的网络中，路由器通常位于子网的地址1处（例如，在10.23.2.0/24中是10.23.2.1）。这只是一种约定，当然也有例外。
- en: 9.7 IPv6 Addresses and Networks
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 IPv6 地址与网络
- en: If you look back at Section 9.4, you can see that IPv4 addresses consist of
    32 bits, or 4 bytes. This yields a total of roughly 4.3 billion addresses, which
    is insufficient for the current scale of the internet. There are several problems
    caused by the lack of addresses in IPv4, so in response, the Internet Engineering
    Task Force (IETF) developed the next version, IPv6\. Before looking at more network
    tools, we’ll discuss the IPv6 address space.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾第 9.4 节，你会看到 IPv4 地址由 32 位或 4 字节组成。这样大约可以提供 43 亿个地址，但对于当前规模的互联网来说，数量是不够的。由于
    IPv4 地址不足，造成了几个问题，因此，互联网工程任务组（IETF）开发了下一版本的 IPv6。在查看更多网络工具之前，我们先讨论一下 IPv6 地址空间。
- en: 'An IPv6 address has 128 bits—32 bytes, arranged in eight sets of 4 bytes. In
    long form, an address is written as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv6 地址有 128 位——32 字节，分为八组 4 字节。以长格式表示时，地址写作如下：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The representation is hexadecimal, with each digit ranging from 0 to f. There
    are a few commonly used methods of abbreviating the representation. First, you
    can leave out any leading zeros (for example, 0db8 becomes db8), and one—and only
    one—set of contiguous zero groups can become :: (two colons). Therefore, you can
    write the preceding address as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表示是十六进制的，每个数字范围从 0 到 f。有几种常用的缩写表示方法。首先，你可以省略任何前导零（例如，0db8 可以写作 db8），而且可以有一个——且只能有一个——连续零组变为
    ::（两个冒号）。因此，你可以将前面的地址写为：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Subnets are still denoted in CIDR notation. For the end user, they often cover
    half of the available bits in the address space (/64), but there are instances
    where fewer are used. The portion of the address space that’s unique for each
    host is called the *interface ID*. [Figure 9-3](#figure9-3) shows the breakdown
    of an example address with a 64-bit subnet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 子网仍然使用 CIDR 表示法。对于最终用户来说，它们通常覆盖地址空间中一半的可用位（/64），但也有使用更少位的情况。地址空间中对每个主机唯一的部分称为*接口
    ID*。[图 9-3](#figure9-3) 显示了一个带有 64 位子网的示例地址的拆解。
- en: '![f09003](image_fi/500402c09/f09003.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](image_fi/500402c09/f09003.png)'
- en: 'Figure 9-3: Subnet and interface ID of a typical IPv6 address'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：典型 IPv6 地址的子网和接口 ID
- en: The last thing to know for now about IPv6 is that hosts normally have at least
    two addresses. The first, which is valid across the internet, is called the *global
    unicast address*. The second, for the local network, is called the *link-local
    address*. Link-local addresses always have an fe80::/10 prefix, followed by an
    all-zero 54-bit network ID, and end with a 64-bit interface ID. The result is
    that when you see a link-local address on your system, it will be in the fe80::/64
    subnet.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 IPv6 目前需要知道的最后一件事是，主机通常至少有两个地址。第一个是有效的互联网地址，称为*全局单播地址*。第二个是用于本地网络的地址，称为*链路本地地址*。链路本地地址总是具有
    fe80::/10 前缀，后面跟着一个全零的 54 位网络 ID，最后是一个 64 位的接口 ID。结果是，当你在系统上看到链路本地地址时，它将位于 fe80::/64
    子网中。
- en: 9.7.1 Viewing IPv6 Configuration on Your System
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.1 在您的系统上查看 IPv6 配置
- en: 'If your system has an IPv6 configuration, you would have gotten some IPv6 information
    from the `ip` command that you ran earlier. To single out IPv6, use the `-6` option:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统配置了 IPv6，你应该从之前运行的 `ip` 命令中获取了一些 IPv6 信息。要单独查看 IPv6 配置，使用 `-6` 选项：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In addition to the loopback interface (which we’ll talk about later), you can
    see two more addresses. The global unicast address is denoted with `scope global`,
    and the link-local address gets a `scope link` label.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了回环接口（我们稍后会讨论）外，你还可以看到另外两个地址。全局单播地址用 `scope global` 表示，而链路本地地址则会标记为 `scope
    link`。
- en: 'Viewing the routes is similar:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 查看路由类似：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is slightly more complicated than the IPv4 setup because there are both
    link-local and global subnets configured. The second line 1 is for destinations
    in the locally attached global unicast address subnets; the host knows that it
    can reach them directly, and the link-local line below 2 is similar. For the default
    route 3 (also written as ::/0 in IPv6; remember that this is anything that’s not
    directly connected), this configuration arranges for traffic to go through the
    router at the link-local address fe80::800d:7bff:feb8:14a0 instead of its address
    on the global subnet. You will see later that the router usually doesn’t care
    about how it gets traffic, only where the traffic is supposed to go. Using a link-local
    address as a default gateway has the advantage that it doesn’t need to change
    if the global IP address space changes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这比IPv4的设置稍微复杂一些，因为既配置了链路本地地址，也配置了全局子网。第二行1是针对本地附加的全局单播地址子网中的目标；主机知道它可以直接到达它们，下面的链路本地行2也类似。对于默认路由3（在IPv6中也写作::/0；记住这是任何未直接连接的东西），该配置安排将流量通过链路本地地址fe80::800d:7bff:feb8:14a0的路由器，而不是其在全局子网上的地址。你稍后会看到，路由器通常不关心它如何接收流量，只关心流量应该去哪里。使用链路本地地址作为默认网关的优势在于，如果全局IP地址空间发生变化，它不需要改变。
- en: 9.7.2 Configuring Dual-Stack Networks
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.2 配置双栈网络
- en: As you may have guessed by now, it’s possible to configure hosts and networks
    to run both IPv4 and IPv6\. This is sometimes called a *dual-stack network*, though
    the use of the word *stack* is questionable as there’s really only one layer of
    the typical network stack that’s being duplicated in this case (true dual-stack
    would be something like IP+IPX). Pedantry aside, the IPv4 and IPv6 protocols are
    independent of each other and can run simultaneously. On such a host, it’s up
    to the application (such as a web browser) to choose IPv4 or IPv6 to connect to
    another host.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能已经猜到的那样，配置主机和网络以同时运行IPv4和IPv6是可能的。这有时被称为*双栈网络*，虽然使用*栈*这个词有些值得商榷，因为在这种情况下，真正被复制的仅仅是典型网络栈中的一层（真正的双栈应该像是IP+IPX那样）。抛开这些细节不谈，IPv4和IPv6协议是彼此独立的，并且可以同时运行。在这样的主机上，由应用程序（比如Web浏览器）来选择使用IPv4还是IPv6连接到另一个主机。
- en: An application originally written for IPv4 does not automatically have IPv6
    support. Fortunately, because the layers in the stack sitting on top of the network
    layer are unchanged, the code necessary to communicate with IPv6 is minimal and
    easy to add. Most important applications and servers now include IPv6 support.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 原本为IPv4编写的应用程序并不会自动支持IPv6。幸运的是，由于网络层之上的栈层没有改变，与IPv6通信所需的代码非常少，且容易添加。现在，大多数重要的应用程序和服务器都已包含IPv6支持。
- en: 9.8 Basic ICMP and DNS Tools
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8 基本的ICMP和DNS工具
- en: 'Now it’s time to look at some basic practical utilities to help you interact
    with hosts. These tools use two protocols of particular interest: Internet Control
    Message Protocol (ICMP), which can help you root out problems with connectivity
    and routing, and the Domain Name Service (DNS) system, which maps names to IP
    addresses so that you don’t have to remember a bunch of numbers.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看一些基本的实用工具来帮助你与主机互动了。这些工具使用了两个特别重要的协议：互联网控制消息协议（ICMP），它可以帮助你排查连接性和路由问题；以及域名服务（DNS）系统，它将名称映射到IP地址，以便你不必记住一堆数字。
- en: ICMP is a transport layer protocol used to configure and diagnose internet networks;
    it differs from other transport layer protocols in that it doesn’t carry any true
    user data, and thus there’s no application layer above it. By comparison, DNS
    is an application layer protocol used to map human-readable names to internet
    addresses.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP是一种传输层协议，用于配置和诊断互联网网络；它与其他传输层协议的不同之处在于，它不携带任何真正的用户数据，因此在它之上没有应用层。相比之下，DNS是一种应用层协议，用于将人类可读的名称映射到互联网地址。
- en: 9.8.1 ping
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.1 ping
- en: '`ping` (see [https://ftp.arl.army.mil/~mike/ping.html](https://ftp.arl.army.mil/~mike/ping.html))
    is one of the most basic network debugging tools. It sends ICMP echo request packets
    to a host that asks a recipient host to return the packet to the sender. If the
    recipient host gets the packet and is configured to reply, it sends an ICMP echo
    response packet in return.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping`（参见[https://ftp.arl.army.mil/~mike/ping.html](https://ftp.arl.army.mil/~mike/ping.html)）是最基本的网络调试工具之一。它向主机发送ICMP回显请求包，请求接收主机将该包返回给发送者。如果接收主机收到该包并配置为回应，它会返回一个ICMP回显响应包。'
- en: 'For example, say you run `ping 10.23.2.1` and get this output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你运行`ping 10.23.2.1`并得到以下输出：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first line says that you’re sending 56-byte packets (84 bytes, if you include
    the headers) to 10.23.2.1 (by default, one packet per second), and the remaining
    lines indicate responses from 10.23.2.1\. The most important parts of the output
    are the sequence number (`icmp_req`) and the round-trip time (`time`). The number
    of bytes returned is the size of the packet sent plus 8\. (The content of the
    packets isn’t important to you.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表示你正在向 10.23.2.1 发送 56 字节的包（如果包括头部的话是 84 字节），默认情况下，每秒发送一个包，剩下的行则显示来自 10.23.2.1
    的响应。输出中最重要的部分是序列号（`icmp_req`）和往返时间（`time`）。返回的字节数是发送的包大小加上 8。（包的内容对你来说并不重要。）
- en: A gap in the sequence numbers, such as the one between 2 and 4, usually means
    there’s some kind of connectivity problem. Packets shouldn’t be arriving out of
    order, because `ping` sends only one packet a second. If a response takes more
    than a second (1,000 ms) to arrive, the connection is extremely slow.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 序列号之间的间隙，比如 2 和 4 之间的间隙，通常意味着某种连接问题。包不应该乱序到达，因为 `ping` 每秒只发送一个包。如果响应花费超过一秒（1,000
    毫秒）才到达，那么连接速度极慢。
- en: The round-trip time is the total elapsed time between the moment that the request
    packet leaves and the moment that the response packet arrives. If there’s no way
    to reach the destination, the final router to see the packet returns an ICMP “host
    unreachable” packet to `ping`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 往返时间是从请求包发送的时刻到响应包到达的时刻之间的总耗时。如果无法到达目标，最终看到该包的路由器会向 `ping` 返回一个 ICMP “主机不可达”
    包。
- en: On a wired LAN, you should expect absolutely no packet loss and very low numbers
    for the round-trip time. (The preceding example output is from a wireless network.)
    You should also expect no packet loss from your network to and from your ISP and
    reasonably steady round-trip times.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在有线局域网中，你应该完全不遇到包丢失，并且往返时间应该非常低。（上面的示例输出来自无线网络。）你还应该期望从你的网络到 ISP 之间没有包丢失，并且往返时间保持相对稳定。
- en: You can force `ping` to use IPv4 or IPv6 with the `-4` and `-6` options, respectively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-4` 和 `-6` 选项分别强制 `ping` 使用 IPv4 或 IPv6。
- en: 9.8.2 DNS and host
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.2 DNS 和主机
- en: 'IP addresses are difficult to remember and subject to change, which is why
    we normally use names such as *www.example.com* instead. The Domain Name Service
    (DNS) library on your system normally handles this translation automatically,
    but sometimes you’ll want to manually translate between a name and an IP address.
    To find the IP address behind a domain name, use the `host` command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址难以记忆且易变，这就是为什么我们通常使用像 *www.example.com* 这样的名称。系统上的域名服务（DNS）库通常会自动处理这种转换，但有时你会需要手动转换名称和
    IP 地址之间的关系。要找到域名背后的 IP 地址，可以使用 `host` 命令：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how this example has both the IPv4 address 172.17.216.34 and the much
    longer IPv6 address. There may be more than one address for a hostname, and the
    output may additional information such as mail exchangers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个示例中既有 IPv4 地址 172.17.216.34，又有更长的 IPv6 地址。一个主机名可能有多个地址，输出还可能包含其他信息，如邮件交换器。
- en: 'You can also use `host` in reverse: enter an IP address instead of a hostname
    to try to discover the hostname behind the IP address. Don’t expect this to work
    reliably, however. A single IP address may be associated with more than one hostname,
    and DNS doesn’t know how to determine which of those hostnames should correspond
    to an IP address. In addition, the administrator for that host needs to manually
    set up the reverse lookup, and administrators often don’t do so.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以反向使用 `host` 命令：输入一个 IP 地址，而不是主机名，尝试发现该 IP 地址背后的主机名。然而，不要指望它能可靠工作。一个单独的 IP
    地址可能与多个主机名相关联，DNS 并不知道如何确定应该对应哪个主机名。此外，主机的管理员需要手动设置反向查找，然而管理员通常不会这样做。
- en: There’s a lot more to DNS than the `host` command. We’ll cover basic client
    configuration in Section 9.15.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 的内容远不止 `host` 命令。我们将在第 9.15 节中讨论基本的客户端配置。
- en: There are `-4` and `-6` options for `host`, but they work differently than you
    might expect. They force the `host` command to get its information via IPv4 or
    IPv6, but because that information should be the same regardless of the network
    protocol, the output will potentially include both IPv4 and IPv6.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`host` 命令有 `-4` 和 `-6` 选项，但它们的作用可能和你预期的不同。它们强制 `host` 命令通过 IPv4 或 IPv6 获取信息，但因为无论使用哪种网络协议，信息应该是一样的，所以输出可能会同时包含
    IPv4 和 IPv6。'
- en: 9.9 The Physical Layer and Ethernet
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9 物理层与以太网
- en: One of the key points to understand about the internet is that it’s a *software*
    network. Nothing we’ve discussed so far is hardware specific, and indeed, one
    reason for the internet’s success is that it works on almost any kind of computer,
    operating system, and physical network. However, if you actually want to talk
    to another computer, you still have to put a network layer on top of some kind
    of hardware. That interface is the physical layer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 理解互联网的一个关键点是，它是一个*软件*网络。到目前为止，我们讨论的内容与硬件无关，实际上，互联网之所以成功的一个原因是它可以在几乎任何类型的计算机、操作系统和物理网络上运行。然而，如果你确实想与另一台计算机通信，你仍然需要在某种硬件上方放置一个网络层。这个接口就是物理层。
- en: 'In this book, we’ll look at the most common kind of physical layer: an Ethernet
    network. The IEEE 802 family of standards documentation defines many different
    kinds of Ethernet networks, from wired to wireless, but they all have a few things
    in common:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将讨论最常见的物理层类型：以太网网络。IEEE 802标准族的文档定义了多种不同类型的以太网网络，从有线到无线，但它们都有一些共同点：
- en: All devices on an Ethernet network have a *Media Access Control (MAC) address*,
    sometimes called a *hardware address*. This address is independent of a host’s
    IP address, and it is unique to the host’s Ethernet network (but not necessarily
    a larger software network such as the internet). A sample MAC address is 10:78:d2:eb:76:97.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网网络上的所有设备都有*媒体访问控制（MAC）地址*，有时也称为*硬件地址*。该地址与主机的IP地址无关，并且是唯一的，专属于主机的以太网网络（但不一定是更大的软件网络，如互联网）。一个示例MAC地址为10:78:d2:eb:76:97。
- en: Devices on an Ethernet network send messages in *frames*, which are wrappers
    around the data sent. A frame contains the origin and destination MAC addresses.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网网络上的设备通过*帧*发送消息，帧是数据的封装。一个帧包含源和目标的MAC地址。
- en: Ethernet doesn’t really attempt to go beyond hardware on a single network. For
    example, if you have two different Ethernet networks with one host attached to
    both networks (and two different network interface devices), you can’t directly
    transmit a frame from one Ethernet network to the other unless you set up an Ethernet
    bridge. And this is where higher network layers (such as the internet layer) come
    in. By convention, each Ethernet network is also usually an internet subnet. Even
    though a frame can’t leave one physical network, a router can take the data out
    of a frame, repackage it, and send it to a host on a different physical network,
    which is exactly what happens on the internet.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网实际上并不试图在单一网络上超越硬件。例如，如果你有两个不同的以太网网络，并且一个主机连接到这两个网络（并且有两个不同的网络接口设备），你无法直接将一个帧从一个以太网网络传输到另一个，除非你设置了以太网桥。这就是更高层网络（如互联网层）发挥作用的地方。根据惯例，每个以太网网络通常也是一个互联网子网。尽管帧无法离开一个物理网络，但路由器可以将数据从帧中提取出来，重新打包，并将其发送到另一个物理网络上的主机，这正是互联网运作的方式。
- en: 9.10 Understanding Kernel Network Interfaces
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.10 理解内核网络接口
- en: The physical and the internet layers must be connected such that the internet
    layer can retain its hardware-independent flexibility. The Linux kernel maintains
    its own division between the two layers and provides a communication standard
    for linking them called a *(kernel) network interface*. When you configure a network
    interface, you link the IP address settings from the internet side with the hardware
    identification on the physical device side. Network interfaces usually have names
    that indicate the kind of hardware underneath, such as *enp0s31f6* (an interface
    in a PCI slot). A name like this is called a *predictable network interface device
    name*, because it remains the same after a reboot. At boot time, interfaces have
    traditional names such as *eth0* (the first Ethernet card in the computer) and
    *wlan0* (a wireless interface), but on most machines running systemd, they are
    quickly renamed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 物理层和互联网层必须连接，以便互联网层保持其硬件独立的灵活性。Linux内核在这两层之间保持着自己的分割，并提供了一种称为*(内核)网络接口*的通信标准，用于将它们连接起来。当你配置网络接口时，你将互联网层的IP地址设置与物理设备上的硬件标识关联起来。网络接口通常有名称，表示底层硬件类型，如*enp0s31f6*（一个PCI插槽中的接口）。这样的名称被称为*可预测的网络接口设备名称*，因为它在重启后保持不变。在启动时，接口有传统的名称，如*eth0*（计算机中的第一个以太网卡）和*wlan0*（无线接口），但在大多数运行systemd的机器上，它们会很快被重命名。
- en: 'In Section 9.4.1, you learned how to view the network interface settings with
    `ip address show`. The output is organized by interface. Here’s the one we saw
    before:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 9.4.1 节中，你学习了如何使用 `ip address show` 查看网络接口设置。输出按接口组织。这里是我们之前看到的：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each network interface gets a number; this one is 2\. Interface 1 is almost
    always the loopback described in Section 9.16. The flag `UP` tells you that the
    interface is working 1. In addition to the internet layer pieces that we’ve already
    covered, you also see the MAC address on the physical layer, `link/ether` 2.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络接口都会分配一个编号；这个接口的编号是 2。接口 1 通常是第 9.16 节中描述的回环接口。标志 `UP` 表示该接口正在正常工作 1。除了我们已经讲解的互联网层部分之外，你还会看到物理层上的
    MAC 地址，`link/ether` 2。
- en: Although `ip` shows some hardware information, it’s designed primarily for viewing
    and configuring the software layers attached to the interfaces. To dig deeper
    into the hardware and physical layer behind a network interface, use something
    like the `ethtool` command to display or change the settings on Ethernet cards.
    (We’ll look briefly at wireless networks in Section 9.27.)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `ip` 显示一些硬件信息，但它主要用于查看和配置附加到接口的软件层。要深入了解网络接口背后的硬件和物理层，可以使用类似 `ethtool` 的命令来显示或更改以太网卡的设置。（我们将在第
    9.27 节简要讨论无线网络。）
- en: 9.11 Introduction to Network Interface Configuration
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.11 网络接口配置简介
- en: 'You’ve now seen all of the basic elements that go into the lower levels of
    a network stack: the physical layer, the network (internet) layer, and the Linux
    kernel’s network interfaces. In order to combine these pieces to connect a Linux
    machine to the internet, you or a piece of software must do the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了构成网络栈底层的所有基本元素：物理层、网络（互联网）层以及 Linux 内核的网络接口。为了将这些部分组合起来将 Linux 机器连接到互联网，你或某个软件必须执行以下操作：
- en: Connect the network hardware and ensure that the kernel has a driver for it.
    If the driver is present, `ip address show` includes an entry for the device,
    even if it hasn’t been configured.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接网络硬件并确保内核有相应的驱动程序。如果驱动程序存在，即使设备尚未配置，`ip address show` 也会显示该设备的条目。
- en: Perform any additional physical layer setup, such as choosing a network name
    or password.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行任何额外的物理层设置，如选择网络名称或密码。
- en: Assign IP address(es) and subnets to the kernel network interface so that the
    kernel’s device drivers (physical layer) and internet subsystems (internet layer)
    can talk to each other.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为内核网络接口分配 IP 地址和子网，使得内核的设备驱动（物理层）和互联网子系统（互联网层）能够相互通信。
- en: Add any additional necessary routes, including the default gateway.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加任何必要的附加路由，包括默认网关。
- en: 'When all machines were big stationary boxes wired together, this was relatively
    straightforward: the kernel did step 1, you didn’t need step 2, and you’d do step
    3 with the old `ifconfig` command and step 4 with the old `route` command. We’ll
    briefly look at how to do this with the `ip` command.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有机器都是大的固定盒子并通过线缆连接时，这一过程相对简单：内核执行第 1 步，你不需要第 2 步，而你可以通过旧的 `ifconfig` 命令执行第
    3 步，通过旧的 `route` 命令执行第 4 步。我们将简要看一下如何使用 `ip` 命令执行这些操作。
- en: 9.11.1 Manually Configuring Interfaces
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.11.1 手动配置接口
- en: We’re now going to see how to set up interfaces manually, but we won’t go into
    too much detail because doing so is rarely needed and error-prone. This is typically
    something you’d only do when experimenting with your system. Even when configuring,
    you may wish to use a tool such as Netplan to build the configuration in a text
    file instead of using a series of commands as shown next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何手动设置接口，但我们不会深入讨论，因为这种操作很少需要，且容易出错。通常只有在试验系统时才会执行这种操作。即使在配置时，你也可能希望使用诸如
    Netplan 这样的工具，在文本文件中构建配置，而不是像接下来所示的那样使用一系列命令。
- en: 'You can bind an interface to the internet layer with the `ip` command. To add
    an IP address and subnet for a kernel network interface, you’d do this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `ip` 命令将接口绑定到互联网层。要为内核网络接口添加 IP 地址和子网，可以执行如下操作：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `interface` is the name of the interface, such as *enp0s31f6* or *eth0*.
    This also works for IPv6, except that you need to add parameters (for example,
    to indicate link-local status). If you’d like to see all of the options, see the
    ip-address(8) manual page.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`interface` 是接口的名称，例如 *enp0s31f6* 或 *eth0*。这同样适用于 IPv6，唯一不同的是你需要添加参数（例如，指示链路本地状态）。如果你想查看所有选项，请参阅
    ip-address(8) 手册页。
- en: 9.11.2 Manually Adding and Deleting Routes
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.11.2 手动添加和删除路由
- en: 'With the interface up, you can add routes, which is typically just a matter
    of setting the default gateway, like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口启动后，你可以添加路由，通常这只是设置默认网关的问题，像这样：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `gw-address` parameter is the IP address of your default gateway; it *must*
    be an address in a locally connected subnet assigned to one of your network interfaces.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`gw-address` 参数是默认网关的 IP 地址；它 *必须* 是分配给你网络接口的本地连接子网中的一个地址。'
- en: 'To remove the default gateway, run:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除默认网关，请运行：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can easily override the default gateway with other routes. For example,
    say your machine is on subnet 10.23.2.0/24, you want to reach a subnet at 192.168.45.0/24,
    and you know that the host at 10.23.2.44 can act as a router for that subnet.
    Run this command to send traffic bound for 192.168.45.0 to that router:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地用其他路由覆盖默认网关。例如，假设你的机器位于 10.23.2.0/24 子网，你想要访问 192.168.45.0/24 子网，并且你知道
    10.23.2.44 这台主机可以充当该子网的路由器。运行以下命令，将前往 192.168.45.0 的流量发送到该路由器：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You don’t need to specify the router in order to delete a route:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 删除路由时，你不需要指定路由器：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Before you go crazy with routes, you should know that configuring routes is
    often more complicated than it appears. For this particular example, you also
    have to make sure that the routing for all hosts on 192.163.45.0/24 can lead back
    to 10.23.2.0/24, or the first route you add is basically useless.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理路由之前，你应该知道，配置路由通常比看起来更复杂。以这个特定的例子为例，你还必须确保所有 192.163.45.0/24 网段的主机能够返回到 10.23.2.0/24
    网段，否则你添加的第一条路由基本上是无效的。
- en: Normally, you should keep things as simple as possible, setting up local networks
    so that their hosts need only a default route. If you need multiple subnets and
    the ability to route between them, it’s usually best to configure the routers
    acting as the default gateways to do all of the work of routing between different
    local subnets. (You’ll see an example in Section 9.21.)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该尽可能保持简洁，设置本地网络，使得它们的主机只需要一个默认路由。如果你需要多个子网并且能够在它们之间路由，通常最好配置作为默认网关的路由器来处理不同本地子网之间的路由工作。（你将在第
    9.21 节看到一个示例。）
- en: 9.12 Boot-Activated Network Configuration
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.12 启动激活网络配置
- en: We’ve discussed ways to manually configure a network, and the traditional way
    to ensure the correctness of a machine’s network configuration was to have init
    run a script to run the manual configuration at boot time. This boils down to
    running a tool like `ip` somewhere in the chain of boot events.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了手动配置网络的方法，确保机器网络配置正确的传统方法是通过 init 运行脚本，在启动时执行手动配置。这归结为在启动事件链中的某个地方运行像
    `ip` 这样的工具。
- en: There have been many attempts in Linux to standardize configuration files for
    boot-time networking. The tools `ifup` and `ifdown` are among them; for example,
    a boot script can (in theory) run `ifup eth0` to run the correct `ip` commands
    to set up an interface. Unfortunately, different distributions have completely
    different implementations of `ifup` and `ifdown`, and as a result, their configuration
    files are also different.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，有许多尝试标准化启动时网络配置文件的方案。`ifup` 和 `ifdown` 工具就是其中之一；例如，启动脚本可以（理论上）运行 `ifup
    eth0` 来执行正确的 `ip` 命令以设置接口。不幸的是，不同的发行版对 `ifup` 和 `ifdown` 有完全不同的实现，因此它们的配置文件也不同。
- en: There is a deeper disparity due to the fact that network configuration elements
    are present in each of the different network layers; a consequence is that the
    software responsible for making networking happen is in several parts of kernel
    and user-space tools, written and maintained by different developers. In Linux,
    there is a general agreement not to share configuration files among separate tool
    suites or libraries, because changes made for one tool could break another.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络配置元素存在于不同的网络层中，因此存在更深层的差异；其结果是，负责实现网络功能的软件位于内核和用户空间工具的多个部分，由不同的开发者编写和维护。在
    Linux 中，普遍的共识是不在不同的工具套件或库之间共享配置文件，因为为一个工具所做的更改可能会破坏另一个工具。
- en: Dealing with network configuration in several different places makes it difficult
    to manage systems. As a result, there are several different network management
    tools that each have their own approach to the configuration problem. However,
    these tend to be specialized for the particular kind of role that a Linux machine
    can serve. A tool might work on a desktop but not be appropriate for a server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个不同位置处理网络配置使得系统管理变得困难。因此，有几种不同的网络管理工具，每种工具都有自己解决配置问题的方法。然而，这些工具通常专门针对 Linux
    机器可能扮演的特定角色。某个工具可能在桌面上有效，但在服务器上则不合适。
- en: A tool called Netplan offers a different approach to the configuration problem.
    Rather than managing the network, Netplan is nothing more than a unified network
    configuration standard and a tool to transform that configuration into the files
    used by existing network managers. Currently, Netplan supports NetworkManager
    and systemd-networkd, which we’ll talk about later in this chapter. Netplan files
    are in YAML format, and reside in */etc/netplan*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个叫做 Netplan 的工具提供了不同的配置方法。与其管理网络，Netplan 仅仅是一个统一的网络配置标准和一个将该配置转换为现有网络管理工具使用的文件的工具。目前，Netplan
    支持 NetworkManager 和 systemd-networkd，我们将在本章后面讨论这两者。Netplan 文件使用 YAML 格式，并存储在*/etc/netplan*目录下。
- en: Before we can talk about network configuration managers, let’s look a little
    closer at some of the issues they face.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论网络配置管理器之前，让我们先深入了解一些它们面临的问题。
- en: 9.13 Problems with Manual and Boot-Activated Network Configuration
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.13 手动和引导激活的网络配置问题
- en: Although most systems used to configure the network in their boot mechanisms—and
    many servers still do—the dynamic nature of modern networks means that most machines
    don’t have static (unchanging) IP addresses. In IPv4, rather than storing the
    IP address and other network information on your machine, your machine gets this
    information from somewhere on the local physical network when it first attaches
    to that network. Most normal network client applications don’t particularly care
    what IP address your machine uses, as long as it works. Dynamic Host Configuration
    Protocol (DHCP, described in Section 9.19) tools do the basic network layer configuration
    on typical IPv4 clients. In IPv6, clients are capable of configuring themselves
    to a certain extent; we’ll look at that briefly in Section 9.20.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数系统用于配置网络时会使用启动机制——许多服务器仍然如此——但现代网络的动态特性意味着大多数机器并没有静态（不变的）IP 地址。在 IPv4 中，机器不会将
    IP 地址和其他网络信息存储在本地，而是在首次连接到本地物理网络时从网络的某个地方获取这些信息。大多数常见的网络客户端应用程序并不特别关心你的机器使用什么
    IP 地址，只要它能够正常工作。动态主机配置协议（DHCP，详见 9.19 节）工具会在典型的 IPv4 客户端上进行基本的网络层配置。在 IPv6 中，客户端能够在一定程度上自我配置；我们将在
    9.20 节简要讨论这一点。
- en: 'There’s more to the story, though. For example, wireless networks add further
    dimensions to interface configuration, such as network names, authentication,
    and encryption techniques. When you step back to look at the bigger picture, you
    see that your system needs a way to answer the following questions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事情还有更多内容。例如，无线网络为接口配置增加了更多维度，如网络名称、认证和加密技术。当你从宏观角度来看待这个问题时，你会发现系统需要能够回答以下问题：
- en: If the machine has multiple physical network interfaces (such as a notebook
    with wired and wireless Ethernet), how do you choose which one(s) to use?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器有多个物理网络接口（例如一台既有有线以太网又有无线以太网的笔记本），应该如何选择使用哪个接口？
- en: How should the machine set up the physical interface? For wireless networks,
    this includes scanning for network names, choosing a name, and negotiating authentication.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器应该如何设置物理接口？对于无线网络，这包括扫描网络名称、选择一个名称并协商认证。
- en: Once the physical network interface is connected, how should the machine set
    up the software network layers, such as the internet layer?
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦物理网络接口连接上，机器应该如何设置软件网络层，例如互联网层？
- en: How can you let a user choose connectivity options? For example, how do you
    let a user choose a wireless network?
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让用户选择连接选项？例如，如何让用户选择一个无线网络？
- en: What should the machine do if it loses connectivity on a network interface?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器在网络接口丢失连接时应该怎么做？
- en: Answering these questions is usually more than simple boot scripts can handle,
    and it’s a real hassle to do it all by hand. The answer is to use a system service
    that can monitor physical networks and choose (and automatically configure) the
    kernel network interfaces based on a set of rules that makes sense to the user.
    The service should also be able to respond to requests from users, who in turn
    should be able to change the wireless network they’re on without having to become
    root.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 解答这些问题通常超出了简单的启动脚本所能处理的范围，手动完成这一切也非常麻烦。解决方案是使用一个系统服务，它可以监控物理网络，并根据一组对用户有意义的规则选择（并自动配置）内核网络接口。该服务还应能够响应用户的请求，而用户应能够在不成为
    root 用户的情况下更改所连接的无线网络。
- en: 9.14 Network Configuration Managers
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.14 网络配置管理器
- en: There are several ways to automatically configure networks in Linux-based systems.
    The most widely used option on desktops and notebooks is NetworkManager. There
    is an add-on to systemd, called systemd-networkd, that can do basic network configuration
    and is useful for machines that don’t need much flexibility (such as servers),
    but it doesn’t have the dynamic capabilities of NetworkManager. Other network
    configuration management systems are mainly targeted for smaller embedded systems,
    such as OpenWRT’s `netifd`, Android’s ConnectivityManager service, ConnMan, and
    Wicd.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Linux 的系统中，有几种自动配置网络的方式。桌面和笔记本电脑上最常用的选项是 NetworkManager。还有一个附加组件，叫做 systemd-networkd，它可以执行基本的网络配置，适用于不需要太多灵活性的机器（如服务器），但它没有
    NetworkManager 的动态功能。其他网络配置管理系统主要针对较小的嵌入式系统，例如 OpenWRT 的 `netifd`、Android 的 ConnectivityManager
    服务、ConnMan 和 Wicd。
- en: We’ll briefly discuss NetworkManager because it’s the one you’re most likely
    to encounter. We won’t go into a tremendous amount of detail, though, because
    after you see the basic concepts, NetworkManager and other configuration systems
    will be much easier to understand. If you’re interested in systemd-networkd, the
    systemd.network(5) manual page describes the settings, and the configuration directory
    is */etc/systemd/network*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要讨论 NetworkManager，因为它是你最有可能遇到的。尽管如此，我们不会深入讨论，因为在了解了基本概念后，NetworkManager
    和其他配置系统将更容易理解。如果你对 systemd-networkd 感兴趣，可以查看 systemd.network(5) 手册页，其中描述了相关设置，配置目录为
    */etc/systemd/network*。
- en: 9.14.1 NetworkManager Operation
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.14.1 网络管理器操作
- en: NetworkManager is a daemon that the system starts upon boot. Like most daemons,
    it does not depend on a running desktop component. Its job is to listen to events
    from the system and users and to change the network configuration based on a set
    of rules.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkManager 是一个守护进程，系统在启动时会启动它。像大多数守护进程一样，它不依赖于正在运行的桌面组件。它的工作是监听来自系统和用户的事件，并根据一组规则更改网络配置。
- en: 'When running, NetworkManager maintains two basic levels of configuration. The
    first is a collection of information about available hardware devices, which it
    normally collects from the kernel and maintains by monitoring udev over the Desktop
    Bus (D-Bus). The second configuration level is a more specific list of *connections*:
    hardware devices and additional physical and network layer configuration parameters.
    For example, a wireless network can be represented as a connection.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，NetworkManager 保持两个基本的配置层次。第一个是关于可用硬件设备的信息集合，它通常通过内核收集并通过监控 udev 通过桌面总线（D-Bus）进行维护。第二个配置层次是更具体的*连接*列表：硬件设备和额外的物理与网络层配置参数。例如，一个无线网络可以表示为一个连接。
- en: To activate a connection, NetworkManager often delegates the tasks to other
    specialized network tools and daemons, such as `dhclient`, to get internet layer
    configuration from a locally attached physical network. Because network configuration
    tools and schemes vary among distributions, NetworkManager uses plug-ins to interface
    with them, rather than imposing its own standard. There are plug-ins for the both
    the Debian/Ubuntu and Red Hat–style interface configuration, for example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激活连接，NetworkManager 通常会将任务委派给其他专用的网络工具和守护进程，例如 `dhclient`，从本地连接的物理网络获取互联网层配置。由于网络配置工具和方案在各个发行版之间有所不同，NetworkManager
    使用插件与它们交互，而不是强加自己的标准。例如，Debian/Ubuntu 和 Red Hat 风格的接口配置都有对应的插件。
- en: 'Upon startup, NetworkManager gathers all available network device information,
    searches its list of connections, and then decides to try to activate one. Here’s
    how it makes that decision for Ethernet interfaces:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时，NetworkManager 会收集所有可用的网络设备信息，搜索其连接列表，然后决定尝试激活其中一个。以下是它如何为以太网接口做出决策：
- en: If a wired connection is available, try to connect using it. Otherwise, try
    the wireless connections.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有有线连接可用，请尝试使用它。如果没有，尝试使用无线连接。
- en: Scan the list of available wireless networks. If a network is available that
    you’ve previously connected to, NetworkManager will try it again.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描可用的无线网络列表。如果有一个你以前连接过的网络可用，NetworkManager会再次尝试连接。
- en: If more than one previously connected wireless network is available, select
    the most recently connected.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有多个以前连接过的无线网络可用，选择最近连接的网络。
- en: After establishing a connection, NetworkManager maintains it until the connection
    is lost, a better network becomes available (for example, you plug in a network
    cable while connected over wireless), or the user forces a change.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立连接后，NetworkManager会保持连接，直到连接丢失、出现更好的网络（例如，你在无线连接的同时插入了网络电缆）或用户强制更改。
- en: 9.14.2 NetworkManager Interaction
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.14.2 NetworkManager交互
- en: Most users interact with NetworkManager through an applet on the desktop; it’s
    usually an icon in the upper or lower right that indicates the connection status
    (wired, wireless, or not connected). When you click the icon, you get a number
    of connectivity options, such as a choice of wireless networks and an option to
    disconnect from your current network. Each desktop environment has its own version
    of this applet, so it looks a little different on each one.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户通过桌面上的小程序与NetworkManager交互；它通常是位于屏幕右上角或右下角的图标，显示连接状态（有线、无线或未连接）。当你点击该图标时，会出现多个连接选项，如选择无线网络和断开当前网络的选项。每个桌面环境都有自己的版本，所以每个环境中的小程序看起来稍有不同。
- en: In addition to the applet, there are a few tools that you can use to query and
    control NetworkManager from your shell. For a very quick summary of your current
    connection status, use the `nmcli` command with no arguments. You’ll get a list
    of interfaces and configuration parameters. In some ways, this is like `ip` except
    that there’s more detail, especially when you’re viewing wireless connections.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了小程序外，还有一些工具可以让你在Shell中查询和控制NetworkManager。要快速查看当前连接状态，可以使用不带参数的`nmcli`命令。你将看到一个接口和配置参数的列表。在某些方面，这类似于`ip`命令，只不过当你查看无线连接时，`nmcli`会提供更多细节。
- en: The `nmcli` command allows you to control NetworkManager from the command line.
    This is a somewhat extensive command; in fact, there’s an nmcli-examples(5) manual
    page in addition to the usual nmcli(1) manual page.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmcli`命令允许你从命令行控制NetworkManager。这是一个比较复杂的命令；实际上，除了常规的nmcli(1)手册页之外，还有一个nmcli-examples(5)手册页。'
- en: Finally, the utility `nm-online` will tell you whether the network is up or
    down. If the network is up, the command returns `0` as its exit code; it’s nonzero
    otherwise. (For more on how to use an exit code in a shell script, see Chapter
    11.)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，工具`nm-online`会告诉你网络是连接还是断开。如果网络连接，命令返回`0`作为退出码；否则，返回非零值。（有关如何在脚本中使用退出码的更多信息，请参见第11章。）
- en: 9.14.3 NetworkManager Configuration
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.14.3 NetworkManager配置
- en: 'NetworkManager’s general configuration directory is usually */etc/NetworkManager*,
    and there are several different kinds of configuration. The general configuration
    file is *NetworkManager.conf*. The format is similar to the XDG-style *.desktop*
    and Microsoft *.ini* files, with key-value parameters falling into different sections.
    You’ll find that nearly every configuration file has a `[main]` section that defines
    the plug-ins to use. Here’s a simple example that activates the ifupdown plug-in
    used by Ubuntu and Debian:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkManager的一般配置目录通常是*/etc/NetworkManager*，并且有几种不同类型的配置。通用配置文件是*NetworkManager.conf*。其格式类似于XDG风格的*.desktop*文件和Microsoft的*.ini*文件，使用键值对参数并分为不同的部分。几乎每个配置文件中都会有一个`[main]`部分，用于定义要使用的插件。以下是一个简单的示例，激活了Ubuntu和Debian使用的ifupdown插件：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Other distribution-specific plug-ins are ifcfg-rh (for Red Hat–style distributions)
    and ifcfg-suse (for SuSE). The keyfile plug-in that you also see here supports
    NetworkManager’s native configuration file support. When using the plug-in, you
    can see all of the system’s known connections in */etc/NetworkManager/system-connections*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其他特定发行版的插件包括ifcfg-rh（适用于Red Hat风格的发行版）和ifcfg-suse（适用于SuSE）。你在这里看到的keyfile插件支持NetworkManager的本地配置文件支持。在使用此插件时，你可以在*/etc/NetworkManager/system-connections*中查看系统所有已知的连接。
- en: For the most part, you won’t need to change *NetworkManager.conf* because the
    more specific configuration options are found in other files.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你无需更改*NetworkManager.conf*，因为更具体的配置选项通常在其他文件中。
- en: Unmanaged Interfaces
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 未管理的接口
- en: Although you may want NetworkManager to manage most of your network interfaces,
    there will be times when you want it to ignore interfaces. For example, most users
    wouldn’t need any kind of dynamic configuration on the localhost (*lo*; see Section
    9.16) interface, because its configuration never changes. You also want to configure
    this interface early in the boot process, because basic system services often
    depend on it. Most distributions keep NetworkManager away from localhost.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能希望 NetworkManager 管理大多数网络接口，但也会有一些时候你希望它忽略某些接口。例如，大多数用户不需要对 localhost (*lo*；见第
    9.16 节) 接口进行任何动态配置，因为它的配置永远不会改变。你还希望在启动过程的早期配置此接口，因为基本的系统服务通常依赖于它。大多数发行版会让 NetworkManager
    忽略 localhost。
- en: 'You can tell NetworkManager to disregard an interface by using plug-ins. If
    you’re using the ifupdown plug-in (for example, in Ubuntu and Debian), add the
    interface configuration to your */etc/network/interfaces* file and then set the
    value of `managed` to `false` in the `ifupdown` section of the *NetworkManager.conf*
    file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用插件让 NetworkManager 忽略某个接口。如果你使用的是 ifupdown 插件（例如，在 Ubuntu 和 Debian 中），请将接口配置添加到
    */etc/network/interfaces* 文件中，然后在 *NetworkManager.conf* 文件的 `ifupdown` 部分将 `managed`
    的值设置为 `false`：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the ifcfg-rh plug-in that Fedora and Red Hat use, look for a line like
    this in the */etc/sysconfig/network-scripts* directory that contains the *ifcfg-**
    configuration files:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Fedora 和 Red Hat 使用的 ifcfg-rh 插件，请在 */etc/sysconfig/network-scripts* 目录中查找类似这样的行，其中包含
    *ifcfg-** 配置文件：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If this line is not present or the value is set to `no`, NetworkManager ignores
    the interface. In the case of localhost, you’ll find it deactivated in the *ifcfg-lo*
    file. You can also specify a hardware address to ignore, like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此行不存在或其值设置为 `no`，NetworkManager 将忽略该接口。在 localhost 的情况下，你会在 *ifcfg-lo* 文件中发现它被停用。你也可以指定一个要忽略的硬件地址，如下所示：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you don’t use either of these network configuration schemes, you can still
    use the keyfile plug-in to specify the unmanaged device directly inside your *NetworkManager.conf*
    file using its MAC address. Here’s an example showing two unmanaged devices:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用这两种网络配置方案中的任何一种，仍然可以使用 keyfile 插件，通过其 MAC 地址在 *NetworkManager.conf* 文件中直接指定未管理的设备。以下是一个显示两个未管理设备的示例：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Dispatching
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分派
- en: One final detail of NetworkManager configuration relates to specifying additional
    system actions for when a network interface goes up or down. For example, some
    network daemons need to know when to start or stop listening on an interface in
    order to work correctly (such as the secure shell daemon discussed in the next
    chapter).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkManager 配置的一个最终细节涉及在网络接口启动或停止时指定额外的系统操作。例如，一些网络守护进程需要知道何时开始或停止在接口上监听，以便正确工作（例如下章中讨论的安全外壳守护进程）。
- en: When a system’s network interface status changes, NetworkManager runs everything
    in */etc/NetworkManager/dispatcher.d* with an argument such as `up` or `down`.
    This is relatively straightforward, but many distributions have their own network
    control scripts so they don’t place the individual dispatcher scripts in this
    directory. Ubuntu, for example, has just one script named `01ifupdown` that runs
    everything in an appropriate subdirectory of */etc/network*, such as */etc/network/if-up.d*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统的网络接口状态发生变化时，NetworkManager 会在 */etc/NetworkManager/dispatcher.d* 中运行所有脚本，并传递类似
    `up` 或 `down` 的参数。这相对直接，但许多发行版有自己的网络控制脚本，因此不会将单独的分派脚本放在此目录中。例如，Ubuntu 只有一个名为 `01ifupdown`
    的脚本，它会在 */etc/network* 的适当子目录中运行所有脚本，例如 */etc/network/if-up.d*。
- en: As with the rest of the NetworkManager configuration, the details of these scripts
    are relatively unimportant; all you need to know is how to track down the appropriate
    location if you need to make an addition or change (or use Netplan and let it
    figure out the location for you). As ever, don’t be shy about looking at scripts
    on your system.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与其余的 NetworkManager 配置一样，这些脚本的细节相对不那么重要；你需要知道的是如何在需要添加或更改时找到合适的位置（或者使用 Netplan，让它为你找到位置）。像往常一样，不要害怕查看你系统上的脚本。
- en: 9.15 Resolving Hostnames
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.15 主机名解析
- en: One of the final basic tasks in any network configuration is hostname resolution
    with DNS. You’ve already seen the `host` resolution tool that translates a name
    such as *www.example.com* to an IP address such as 10.23.2.132.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何网络配置中，最基本的任务之一是通过 DNS 进行主机名解析。你已经看到过 `host` 解析工具，它将像 *www.example.com* 这样的名称转换为像
    10.23.2.132 这样的 IP 地址。
- en: DNS differs from the network elements we’ve looked at so far because it’s in
    the application layer, entirely in user space. Therefore, it’s technically slightly
    out of place in this chapter alongside the internet and physical layer discussion.
    However, without proper DNS configuration, your internet connection is practically
    worthless. No one in their right mind advertises IP addresses (much less IPv6
    addresses) for websites and email addresses, because a host’s IP address is subject
    to change and it’s not easy to remember a bunch of numbers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: DNS与我们迄今为止所讨论的网络元素不同，因为它处于应用层，完全在用户空间内。因此，它在这一章中与互联网和物理层的讨论相比，技术上略显不合适。然而，没有正确的DNS配置，你的互联网连接几乎没有价值。正常人不会为网站和电子邮件地址发布IP地址（更不用说IPv6地址了），因为主机的IP地址是会变化的，而且一堆数字也不容易记住。
- en: 'Practically all network applications on a Linux system perform DNS lookups.
    The resolution process typically unfolds like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有Linux系统上的网络应用程序都执行DNS查找。解析过程通常是这样展开的：
- en: The application calls a function to look up the IP address behind a hostname.
    This function is in the system’s shared library, so the application doesn’t need
    to know the details of how it works or whether the implementation will change.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序调用一个函数来查找主机名背后的IP地址。这个函数位于系统的共享库中，因此应用程序无需了解它是如何工作的或实现是否会改变。
- en: When the function in the shared library runs, it acts according to a set of
    rules (found in */etc/nsswitch.conf*; see Section 9.15.4) to determine a plan
    of action on lookups. For example, the rules usually say that even before going
    to DNS, check for a manual override in the */etc/hosts* file.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当共享库中的函数运行时，它会根据一组规则（这些规则可以在*/etc/nsswitch.conf*中找到；见9.15.4节）来决定查找的行动方案。例如，规则通常会说，在去DNS之前，先检查*/etc/hosts*文件中是否有手动覆盖。
- en: When the function decides to use DNS for the name lookup, it consults an additional
    configuration file to find a DNS name server. The name server is given as an IP
    address.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当函数决定使用DNS进行名称查找时，它会查阅一个额外的配置文件来查找DNS名称服务器。该名称服务器作为IP地址提供。
- en: The function sends a DNS lookup request (over the network) to the name server.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数向名称服务器发送DNS查找请求（通过网络）。
- en: The name server replies with the IP address for the hostname, and the function
    returns this IP address to the application.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名称服务器回复主机名的IP地址，函数将该IP地址返回给应用程序。
- en: This is the simplified version. In a typical contemporary system, there are
    more actors attempting to speed up the transaction or add flexibility. Let’s ignore
    that for now and look at some of the basic pieces. As with other kinds of network
    configuration, you probably won’t need to change hostname resolution, but it’s
    helpful to see how it works.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是简化版。在一个典型的现代系统中，通常会有更多的参与者试图加快交易或增加灵活性。暂时忽略这些，先来看一些基本的组成部分。像其他类型的网络配置一样，你可能不需要更改主机名解析，但了解它的工作原理会很有帮助。
- en: 9.15.1 /etc/hosts
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.15.1 /etc/hosts
- en: 'On most systems, you can override hostname lookups with the */etc/hosts* file.
    It usually looks like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统上，你可以通过*/etc/hosts*文件覆盖主机名查找。它通常如下所示：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You’ll nearly always see the entry (or entries) for localhost here (see Section
    9.16). The other entries here illustrate a simple way to add hosts on a local
    subnet.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎总是会在这里看到localhost的条目（或条目）（见9.16节）。这里的其他条目展示了一种简单的方式来在本地子网中添加主机。
- en: 9.15.2 resolv.conf
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.15.2 resolv.conf
- en: 'The traditional configuration file for DNS servers is */etc/resolv.conf*. When
    things were simpler, a typical example might have looked like this, where the
    ISP’s name server addresses are 10.32.45.23 and 10.3.2.3:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: DNS服务器的传统配置文件是*/etc/resolv.conf*。在简单的情况下，典型的例子可能如下所示，其中ISP的名称服务器地址是10.32.45.23和10.3.2.3：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `search` line defines rules for incomplete hostnames (just the first part
    of the hostname—for example, `myserver` instead of `myserver.example.com`). Here,
    the resolver library would try to look up `host``.mydomain.example.com` and `host``.example.com`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`行定义了不完整主机名的规则（仅主机名的第一部分——例如，使用`myserver`而不是`myserver.example.com`）。在这里，解析器库会尝试查找`host``.mydomain.example.com`和`host``.example.com`。'
- en: Generally, name lookups are no longer this straightforward. Many enhancements
    and modifications have been made to the DNS configuration.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，名称查找已经不再这么直接。DNS配置已经做了许多增强和修改。
- en: 9.15.3 Caching and Zero-Configuration DNS
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.15.3 缓存和零配置DNS
- en: There are two main problems with the traditional DNS configuration. First, the
    local machine does not cache name server replies, so frequent repeated network
    access may be unnecessarily slow due to name server requests. To solve this problem,
    many machines (and routers, if acting as name servers) run an intermediate daemon
    to intercept name server requests and cache the reply, and then use the cached
    answers if possible. The most common of these daemons is systemd-resolved; you
    might also see dnsmasq or nscd on your system. You can also set up BIND (the standard
    Unix name server daemon) as a cache. You can often tell that you’re running a
    name server caching daemon if you see 127.0.0.53 or 127.0.0.1 either in your */etc/resolv.conf*
    file or listed as the server when you run `nslookup -debug` `host`. Take a closer
    look, though. If you’re running systemd-resolved, you might notice that *resolv.conf*
    isn’t even a file in */etc*; it’s a link to an automatically generated file in
    */run*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 DNS 配置有两个主要问题。首先，本地机器不缓存名称服务器的回复，因此频繁的重复网络访问可能会因为名称服务器请求而变得不必要地慢。为了解决这个问题，许多机器（以及作为名称服务器的路由器）运行一个中间守护进程，用来拦截名称服务器请求并缓存回复，然后在可能的情况下使用缓存的答案。这些守护进程中最常见的是
    systemd-resolved；你可能还会在系统上看到 dnsmasq 或 nscd。你也可以将 BIND（标准的 Unix 名称服务器守护进程）设置为缓存。如果你在
    */etc/resolv.conf* 文件中看到 127.0.0.53 或 127.0.0.1，或者在运行 `nslookup -debug` `host`
    时看到这些，通常说明你正在运行名称服务器缓存守护进程。不过，再仔细看看。如果你正在运行 systemd-resolved，你可能会注意到 *resolv.conf*
    甚至不在 */etc* 中；它是一个指向 */run* 中自动生成文件的链接。
- en: 'There’s a lot more to systemd-resolved than meets the eye, as it can combine
    several name lookup services and expose them differently for each interface. This
    addresses the second problem with the traditional name server setup: it can be
    particularly inflexible if you want to be able to look up names on your local
    network without messing around with a lot of configuration. For example, if you
    set up a network appliance on your network, you’ll want to be able to call it
    by name immediately. This is part of the idea behind zero-configuration name service
    systems such as Multicast DNS (mDNS) and Link-Local Multicast Name Resolution
    (LLMNR). If a process wants to find a host by name on the local network, it just
    broadcasts a request over the network; if present, the target host replies with
    its address. These protocols go beyond hostname resolution by also providing information
    about available services.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: systemd-resolved 的功能远不止于此，它能够结合多个名称查找服务，并为每个接口提供不同的呈现方式。这解决了传统名称服务器设置中的第二个问题：如果你想在不进行大量配置的情况下，能够查找本地网络上的名称，传统的设置尤其显得不够灵活。例如，如果你在网络上设置了一个网络设备，你会希望能够立刻通过名称来访问它。这也是零配置名称服务系统（如多播DNS（mDNS）和链路本地多播名称解析（LLMNR））背后的理念之一。如果某个进程想要通过名称在本地网络上查找主机，它只需广播一个请求到网络上；如果目标主机存在，它会回复自己的地址。这些协议不仅超越了主机名解析，还提供了有关可用服务的信息。
- en: 'You can check the current DNS settings with the `resolvectl status` command
    (note that this might be called `systemd-resolve` on older systems). You’ll get
    a list of global settings (typically of little use), and then you’ll see the settings
    for each individual interface. It’ll look like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `resolvectl status` 命令查看当前的DNS设置（注意，在旧系统上，这个命令可能叫做 `systemd-resolve`）。你将看到一份全局设置列表（通常没什么用处），接着是每个独立接口的设置。它看起来像这样：
- en: '[PRE24]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can see various supported name protocols here, as well as the name server
    that systemd-resolved consults for a name that it doesn’t know.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到各种支持的名称协议，以及 systemd-resolved 用来查询它不认识的名称的名称服务器。
- en: We’re not going to go further into DNS or systemd-resolved because it’s such
    a vast topic. If you want to change your settings, take a look at the resolved.conf(5)
    manual page and proceed to change */etc/systemd/resolved.conf*. However, you’ll
    probably need to read up on a lot of the systemd-resolved documentation, as well
    as get familiar with DNS in general from a source such as *DNS and BIND*, 5th
    edition, by Cricket Liu and Paul Albitz (O’Reilly, 2006).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会进一步讨论 DNS 或 systemd-resolved，因为这是一个庞大的话题。如果你想修改设置，可以查看 `resolved.conf(5)`
    手册页，并继续修改 */etc/systemd/resolved.conf*。然而，你可能需要深入阅读 systemd-resolved 的大量文档，同时也要通过像
    *DNS and BIND*（第5版，Cricket Liu 和 Paul Albitz 著，O'Reilly，2006年）这样的资料，熟悉 DNS 的基本概念。
- en: 9.15.4 /etc/nsswitch.conf
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.15.4 /etc/nsswitch.conf
- en: 'Before we leave the topic of name lookups, there’s one last setting you should
    be aware of. The */etc/nsswitch.conf* file is the traditional interface for controlling
    several name-related precedence settings on your system, such as user and password
    information, and it has a host lookup setting. The file on your system should
    have a line like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束关于名称查找的话题之前，还有一个你应该了解的最后一个设置。*/etc/nsswitch.conf* 文件是传统的接口，用于控制系统上多个名称相关的优先级设置，比如用户和密码信息，并且它有一个主机查找设置。你系统中的文件应该有如下的这一行：
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Putting `files` ahead of `dns` here ensures that, when looking up hosts, your
    system checks the */etc/hosts* file for host lookup before asking any DNS server,
    including systemd-resolved. This is usually a good idea (especially for looking
    up localhost, as discussed next), but your */etc/hosts* file should be as *short*
    as possible. Don’t put anything in there to boost performance; doing so will burn
    you later. You can put hosts within a small private LAN in */etc/hosts*, but the
    general rule of thumb is that if a particular host has a DNS entry, it has no
    place in */etc/hosts*. (The */etc/hosts* file is also useful for resolving hostnames
    in the early stages of booting, when the network may not be available.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `files` 放在 `dns` 前面，确保在查找主机时，系统会首先检查 */etc/hosts* 文件中的主机查找，然后再询问任何 DNS 服务器，包括
    systemd-resolved。这通常是一个好主意（特别是对于接下来的本地主机查找），但你的 */etc/hosts* 文件应该尽可能*简短*。不要在里面放入任何东西来提升性能；这么做会在以后给你带来麻烦。你可以在
    */etc/hosts* 中放入一个小型私有局域网的主机，但一般规则是，如果一个特定的主机有 DNS 条目，它就不应该出现在 */etc/hosts* 中。（*/etc/hosts*
    文件也在启动的早期阶段非常有用，那时网络可能尚未可用。）
- en: All of this works through standard calls in the system library. It can be complicated
    to remember all of the places that name lookups can happen, but if you ever need
    to trace something from the bottom up, start with /*etc/nsswitch.conf*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都通过系统库中的标准调用实现。记住所有名称查找可能发生的地方可能会很复杂，但如果你需要从底层追踪某些东西，首先从 /*etc/nsswitch.conf*
    开始。
- en: 9.16 Localhost
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.16 本地主机
- en: 'When running `ip address show`, you’ll notice the *lo* interface:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 `ip address show` 时，你会看到 *lo* 接口：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The *lo* interface is a virtual network interface called the *loopback* because
    it “loops back” to itself. The effect is that connecting to 127.0.0.1 (or ::1
    in IPv6) is connecting to the machine that you’re currently using. When outgoing
    data to localhost reaches the kernel network interface for *lo*, the kernel just
    repackages it as incoming data and sends it back through *lo*, for use by any
    server program that’s listening (by default, most do).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*lo* 接口是一个虚拟网络接口，被称为 *loopback*，因为它“回环”到自身。效果是，连接到 127.0.0.1（或在 IPv6 中的 ::1）就是连接到你当前使用的机器。当发往本地主机的数据到达
    *lo* 的内核网络接口时，内核会将其重新封装为入站数据，并通过 *lo* 发送回去，供任何正在监听的服务器程序使用（默认情况下，大多数程序都在监听）。'
- en: The *lo* loopback interface is often the only place you might see static network
    configuration in boot-time scripts. For example, Ubuntu’s `ifup` command reads
    */etc/network/interfaces*. However, this is often redundant, because systemd configures
    the loopback interface upon startup.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*lo* 回环接口通常是你在启动时脚本中看到静态网络配置的唯一地方。例如，Ubuntu 的 `ifup` 命令会读取 */etc/network/interfaces*。然而，这通常是多余的，因为
    systemd 会在启动时配置回环接口。'
- en: The loopback interface has one peculiarity, which you might have noticed. The
    netmask is /8, and anything starting with 127 is assigned to loopback. This allows
    you to run different servers on different IPv4 addresses in the loopback space
    without configuring additional interfaces. One server that takes advantage of
    this is systemd-resolved, which uses 127.0.0.53\. This way, it won’t interfere
    with another name server running on 127.0.0.1\. So far, IPv6 defines only one
    loopback address, but there are proposals to change this.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 回环接口有一个特殊之处，你可能已经注意到了。子网掩码是 /8，任何以 127 开头的地址都会分配给回环接口。这允许你在回环空间中运行不同的服务器，而无需配置额外的接口。利用这一点的一个服务器是
    systemd-resolved，它使用 127.0.0.53\。这样，它就不会干扰另一个运行在 127.0.0.1\ 上的名称服务器。到目前为止，IPv6
    只定义了一个回环地址，但有提案要对此进行更改。
- en: '9.17 The Transport Layer: TCP, UDP, and Services'
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.17 传输层：TCP、UDP 和服务
- en: 'So far, we’ve only seen how packets move from host to host on the internet—in
    other words, the *where* question from the beginning of the chapter. Now let’s
    start to answer the question of *what* is transmitted. It’s important to know
    how your computer presents the packet data it receives from other hosts to its
    running processes. It would be difficult and inconvenient for user-space programs
    to deal with a bunch of raw packets the way that the kernel does. Flexibility
    is especially important: more than one application should be able to talk to the
    network at the same time (for example, you might have email and several web clients
    running).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了数据包如何从主机传输到主机——换句话说，回答了章节开头的*在哪里*的问题。现在我们开始回答*什么*被传输的问题。了解你的计算机如何将从其他主机接收到的包数据呈现给其正在运行的进程非常重要。如果用户空间程序必须像内核那样处理一堆原始数据包，那将会既困难又不方便。灵活性尤其重要：多个应用程序应该能够同时与网络通信（例如，你可能同时运行电子邮件和多个网页客户端）。
- en: '*Transport layer* protocols bridge the gap between the raw packets of the internet
    layer and the refined needs of applications. The two most popular transport protocols
    are the Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP).
    We’ll concentrate on TCP because it’s by far the most common protocol in use,
    but we’ll also take a quick look at UDP.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*传输层*协议桥接了互联网层的原始数据包和应用程序的精细需求之间的鸿沟。两种最流行的传输协议是传输控制协议（TCP）和用户数据报协议（UDP）。我们将集中讨论TCP，因为它是使用最广泛的协议，但我们也会快速了解UDP。'
- en: 9.17.1 TCP Ports and Connections
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.17.1 TCP端口和连接
- en: TCP provides for multiple network applications on one machine by means of network
    *ports*, which are just numbers used in conjunction with an IP address. If an
    IP address of a host is like the postal address of an apartment building, a port
    number is like a mailbox number—it’s a further subdivision.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: TCP通过网络*端口*为一台机器上的多个网络应用提供支持，端口只是与IP地址结合使用的数字。如果一个主机的IP地址像一座公寓楼的邮政地址，那么端口号就像是邮箱号码——它是进一步的细分。
- en: When using TCP, an application opens a *connection* (not to be confused with
    NetworkManager connections) between one port on its own machine and a port on
    a remote host. For example, an application such as a web browser could open a
    connection between port 36406 on its own machine and port 80 on a remote host.
    From the application’s point of view, port 36406 is the local port and port 80
    is the remote port.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TCP时，应用程序会在自己机器的一个端口与远程主机的端口之间打开一个*连接*（不要与NetworkManager连接混淆）。例如，像网页浏览器这样的应用程序可以在自己机器的36406端口和远程主机的80端口之间建立连接。从应用程序的角度来看，36406端口是本地端口，80端口是远程端口。
- en: 'You can identify a connection by using the pair of IP addresses and port numbers.
    To view the connections currently open on your machine, use `netstat`. Here’s
    an example that shows TCP connections; the `-n` option disables hostname resolution
    (DNS), and `-t` limits the output to TCP:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过IP地址和端口号对来识别一个连接。要查看当前机器上打开的连接，可以使用`netstat`。下面是一个显示TCP连接的示例；`-n`选项禁用主机名解析（DNS），`-t`选项将输出限制为TCP：
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Local Address and Foreign Address fields refer to connections from your
    machine’s point of view, so the machine here has an interface configured at 10.23.2.4,
    and ports 47626, 41475, and 57132 on the local side are all connected. The first
    connection here shows port 47626 connected to port 5222 of 10.194.79.125.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 本地地址和外部地址字段表示从你机器的角度来看连接情况，因此这里的机器在10.23.2.4配置了一个接口，本地端的47626、41475和57132端口都已连接。第一个连接显示端口47626连接到10.194.79.125的5222端口。
- en: To show only IPv6 connections, add `-6` to the `netstat` options.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅显示IPv6连接，可以在`netstat`选项中添加`-6`。
- en: Establishing TCP Connections
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 建立TCP连接
- en: To establish a transport layer connection, a process on one host initiates the
    connection from one of its local ports to a port on a second host with a special
    series of packets. In order to recognize the incoming connection and respond,
    the second host must have a process *listening* on the correct port. Usually,
    the connecting process is called the *client*, and the listener is called the
    *server* (more about this in Chapter 10).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立一个传输层连接，一台主机上的进程会通过一系列特殊的包从它的本地端口向第二台主机的端口发起连接。为了识别这个传入连接并作出响应，第二台主机必须有一个进程在正确的端口上*监听*。通常，发起连接的进程被称为*客户端*，而监听的进程被称为*服务器*（第10章会详细介绍）。
- en: 'The important thing to know about the ports is that the client picks a port
    on its side that isn’t currently in use, and nearly always connects to some well-known
    port on the server side. Recall this output from the `netstat` command in the
    preceding section:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 关于端口的一个重要知识点是，客户端选择一个本地端口，该端口当前未被占用，并且几乎总是连接到服务器端的某个知名端口。回想一下前一节中`netstat`命令的输出：
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With a little knowledge about port-numbering conventions, you can see that this
    connection was probably initiated by a local client to a remote server, because
    the port on the local side (47626) looks like a dynamically assigned number, whereas
    the remote port (5222) is a well-known service listed in */etc/services* (the
    Jabber or XMPP messaging service, to be specific). You’ll see many connections
    to port 443 (the default for HTTPS) on most desktop machines.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些端口编号约定的知识，你可以看出，这个连接很可能是由本地客户端发起到远程服务器的，因为本地端口（47626）看起来像是一个动态分配的端口，而远程端口（5222）是*/etc/services*中列出的知名服务（具体来说是Jabber或XMPP消息服务）。在大多数桌面机器上，你会看到许多连接到端口443（HTTPS的默认端口）。
- en: 'However, if the local port in the output is well known, a remote host probably
    initiated the connection. In this example, remote host 172.24.54.234 has connected
    to port 443 on the local host:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果输出中的本地端口是知名端口，那么很可能是远程主机发起了连接。在这个例子中，远程主机172.24.54.234已连接到本地主机的443端口：
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A remote host connecting to your machine on a well-known port implies that
    a server on your local machine is listening on this port. To confirm this, list
    all TCP ports that your machine is listening on with `netstat`, this time with
    the `-l` option, which shows ports that processes are listening on:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果远程主机连接到你的机器上的知名端口，那么说明你的本地机器上有一个服务器在该端口上监听。为确认这一点，可以使用`netstat`列出你机器上所有正在监听的TCP端口，这次使用`-l`选项，显示进程正在监听的端口：
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Line 1 with 0.0.0.0:80 as the local address shows that the local machine is
    listening on port 80 for connections from any remote machine; it’s the same for
    port 443 (line 2). A server can restrict the access to certain interfaces, as
    shown in line 3, where something is listening for connections only on the localhost
    interface. In this case, it’s systemd-resolved; we talked about why it’s listening
    using 127.0.0.53 instead of 127.0.0.1 back in Section 9.16. To learn even more,
    use `lsof` to identify the specific process that’s listening (as discussed in
    Section 10.5.1).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本地地址为0.0.0.0:80的第1行显示，本地机器正在监听端口80，接受来自任何远程机器的连接；端口443（第2行）也是如此。服务器可以限制对特定接口的访问，如第3行所示，其中某个进程仅在本地接口上监听连接。在这种情况下，是systemd-resolved；我们曾在第9.16节讨论过它为什么使用127.0.0.53而不是127.0.0.1来监听。欲了解更多信息，请使用`lsof`命令识别正在监听的特定进程（如第10.5.1节所讨论）。
- en: Port Numbers and /etc/services
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 端口号与/etc/services
- en: 'How do you know if a port is well known? There’s no single way to tell, but
    a good place to start is to look in */etc/services*, which translates well-known
    port numbers into names. This is a plaintext file. You should see entries like
    this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如何判断一个端口是否为知名端口？没有单一的方法可以确定，但一个好的起点是查看*/etc/services*，该文件将知名端口号转换为名称。这是一个纯文本文件，你应该能看到如下条目：
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first column is a name, and the second column indicates the port number
    and the specific transport layer protocol (which can be other than TCP).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是名称，第二列表示端口号和特定的传输层协议（可能是TCP以外的协议）。
- en: On Linux, only processes running as the superuser can use ports 1 through 1023,
    also known as system, well-known, or privileged ports. All user processes may
    listen on and create connections from ports 1024 and up.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，只有以超级用户身份运行的进程才能使用1到1023号端口，这些端口也称为系统端口、知名端口或特权端口。所有用户进程可以在1024及以上端口上监听并创建连接。
- en: Characteristics of TCP
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TCP的特点
- en: TCP is popular as a transport layer protocol because it requires relatively
    little from the application side. An application process only needs to know how
    to open (or listen for), read from, write to, and close a connection. To the application,
    it seems as if there are incoming and outgoing streams of data; the process is
    nearly as simple as working with a file.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: TCP作为传输层协议非常流行，因为它对应用层要求相对较少。一个应用进程只需要知道如何打开（或监听）连接、从中读取、写入以及关闭连接。对于应用程序来说，似乎存在着传入和传出的数据流；这个过程几乎和处理文件一样简单。
- en: 'However, there’s a lot of work going on behind the scenes. For one, the TCP
    implementation needs to know how to break an outgoing data stream from a process
    into packets. The harder part, though, is knowing how to convert a series of incoming
    packets into an input data stream for processes to read, especially when incoming
    packets don’t necessarily arrive in the correct order. In addition, a host using
    TCP must check for errors: packets can get lost or mangled when sent across the
    internet, and a TCP implementation must detect and correct these situations. [Figure
    9-4](#figure9-4) shows a simplification of how a host might use TCP to send a
    message.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，背后有很多工作在进行。首先，TCP 实现需要知道如何将进程中的输出数据流拆分成数据包。然而，更难的部分是如何将一系列传入的数据包转换成进程可以读取的输入数据流，特别是当数据包的到达顺序不一定正确时。此外，使用
    TCP 的主机必须检查错误：数据包在通过互联网发送时可能会丢失或损坏，TCP 实现必须检测并修正这些情况。[图 9-4](#figure9-4) 展示了主机如何使用
    TCP 发送消息的简化示意图。
- en: Luckily, you need to know next to nothing about this mess other than that the
    Linux TCP implementation is primarily in the kernel and that utilities that work
    with the transport layer tend to manipulate kernel data structures. One example
    is the iptables packet-filtering system discussed in Section 9.25.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，除了 Linux 的 TCP 实现主要在内核中，并且与传输层相关的工具往往会操作内核数据结构外，你几乎不需要了解这个复杂的内容。一个例子是第
    9.25 节中讨论的 iptables 数据包过滤系统。
- en: 9.17.2 UDP
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.17.2 UDP
- en: UDP is a far simpler transport layer than TCP. It defines a transport only for
    single messages; there is no data stream. At the same time, unlike TCP, UDP won’t
    correct for lost or out-of-order packets. In fact, although UDP has ports, it
    doesn’t even have connections! One host simply sends a message from one of its
    ports to a port on a server, and the server sends something back if it wants to.
    However, UDP *does* have error detection for data inside a packet; a host can
    detect if a packet gets mangled, but it doesn’t have to do anything about it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 是比 TCP 更简单的传输层协议。它仅定义单一消息的传输；没有数据流。同时，与 TCP 不同，UDP 不会修正丢失或乱序的数据包。实际上，尽管
    UDP 有端口，它甚至没有连接！一个主机只需将消息从其某个端口发送到服务器的端口，如果服务器愿意，它可以回复消息。然而，UDP *确实*有数据包内的错误检测；主机可以检测到数据包是否损坏，但它不必对此做任何处理。
- en: Where TCP is like having a telephone conversation, UDP is like sending a letter,
    telegram, or instant message (except that instant messages are more reliable).
    Applications that use UDP are often concerned with speed—sending a message as
    quickly as possible. They don’t want the overhead of TCP because they assume the
    network between two hosts is generally reliable. They don’t need TCP’s error correction
    because they either have their own error detection systems or simply don’t care
    about errors.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果说 TCP 就像进行电话通话，UDP 就像发送信件、电报或即时消息（只不过即时消息更可靠）。使用 UDP 的应用程序通常关注速度——尽可能快速地发送消息。它们不希望有
    TCP 的开销，因为它们假设两个主机之间的网络通常是可靠的。它们不需要 TCP 的错误修正，因为它们要么有自己的错误检测系统，要么根本不在乎错误。
- en: '![f09004](image_fi/500402c09/f09004.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![f09004](image_fi/500402c09/f09004.png)'
- en: 'Figure 9-4: Sending a message with TCP'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：使用 TCP 发送消息
- en: One example of an application that uses UDP is the *Network Time Protocol (NTP)*.
    A client sends a short and simple request to a server to get the current time,
    and the response from the server is equally brief. Because the client wants the
    response as quickly as possible, UDP suits the application; if the response from
    the server gets lost somewhere in the network, the client can just resend a request
    or give up. Another example is video chat. In this case, pictures are sent with
    UDP, and if some pieces get lost along the way, the client on the receiving end
    compensates the best it can.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 UDP 的一个应用示例是 *网络时间协议（NTP）*。客户端向服务器发送一个简短的请求以获取当前时间，服务器的响应同样简短。由于客户端希望尽快得到响应，UDP
    适合这个应用；如果服务器的响应在网络中丢失，客户端可以重新发送请求或放弃。另一个例子是视频聊天。在这种情况下，图像通过 UDP 发送，如果过程中某些部分丢失，接收端的客户端会尽力进行补偿。
- en: 9.18 Revisiting a Simple Local Network
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.18 再次回顾一个简单的局部网络
- en: 'Now we’ll look at additional components of the simple network introduced in
    Section 9.4. This network consists of one LAN as a subnet and a router that connects
    the subnet to the rest of the internet. You’ll learn the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下在第 9.4 节中介绍的简单网络的其他组件。该网络由一个局域网（LAN）作为子网，以及一个将子网连接到互联网其他部分的路由器组成。你将学习以下内容：
- en: How a host on the subnet automatically gets its network configuration
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网中的主机如何自动获取其网络配置
- en: How to set up routing
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置路由
- en: What a router really is
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器到底是什么
- en: How to know which IP addresses to use for the subnet
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何知道子网应使用哪些IP地址
- en: How to set up firewalls to filter out unwanted traffic from the internet
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置防火墙来过滤来自互联网的不必要流量
- en: For the most part, we’ll concentrate on IPv4 (if for no other reason than that
    the addresses are easier to read), but when IPv6 differs, you’ll see how.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们将专注于IPv4（如果不是因为地址更容易阅读的话），但当IPv6有所不同时，你会看到它的变化。
- en: Let’s start by looking at how a host on the subnet automatically gets its network
    configuration.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看子网中的主机如何自动获取其网络配置。
- en: 9.19 Understanding DHCP
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.19 理解DHCP
- en: Under IPv4, when you set a network host to get its configuration automatically
    from the network, you’re telling it to use the Dynamic Host Configuration Protocol
    (DHCP) to get an IP address, subnet mask, default gateway, and DNS servers. Aside
    from not having to enter these parameters by hand, network administrators gain
    other advantages with DHCP, such as preventing IP address clashes and minimizing
    the impact of network changes. It’s very rare to see a network that doesn’t use
    DHCP.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4下，当你设置网络主机从网络自动获取配置时，你是在告诉它使用动态主机配置协议（DHCP）来获取IP地址、子网掩码、默认网关和DNS服务器。除了不需要手动输入这些参数外，网络管理员还可以通过DHCP获得其他优势，例如防止IP地址冲突和最小化网络变化的影响。几乎很少见到没有使用DHCP的网络。
- en: For a host to get its configuration with DHCP, it must be able to send messages
    to a DHCP server on its connected network. Therefore, each physical network should
    have its own DHCP server, and on a simple network (such as the one in Section
    9.1), the router usually acts as the DHCP server.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让主机通过DHCP获取其配置，它必须能够向连接网络上的DHCP服务器发送消息。因此，每个物理网络应该有自己的DHCP服务器，在简单的网络（如第9.1节中的网络）中，路由器通常充当DHCP服务器。
- en: When a machine asks a DHCP server to assign it an IP address, it’s really asking
    for a *lease* on an address for a certain amount of time. When the lease is up,
    a client can ask to renew the lease.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当一台机器请求DHCP服务器分配一个IP地址时，它实际上是在请求某个地址的*租约*，并且该租约会持续一段时间。当租约到期时，客户端可以请求续租。
- en: 9.19.1 Linux DHCP Clients
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.19.1 Linux DHCP客户端
- en: Although there are many different kinds of network manager systems, there are
    only two DHCP clients that do the actual work of obtaining leases. The traditional
    standard client is the Internet Software Consortium (ISC) `dhclient` program.
    However, systemd-networkd now also includes a built-in DHCP client.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多不同类型的网络管理系统，但实际上只有两个DHCP客户端负责获取租约。传统的标准客户端是互联网软件联盟（ISC）`dhclient`程序。然而，systemd-networkd现在也包括了一个内置的DHCP客户端。
- en: Upon startup, `dhclient` stores its process ID in */var/run/dhclient.pid* and
    its lease information in */var/lib/dhcp/dhclient.leases*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时，`dhclient`将其进程ID存储在*/var/run/dhclient.pid*中，并将其租约信息存储在*/var/lib/dhcp/dhclient.leases*中。
- en: 'You can test `dhclient` by hand on the command line, but before doing so you
    *must* remove any default gateway route (see Section 9.11.2). To run the test,
    simply specify the network interface name (here, it’s enp0s31f6):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动在命令行上测试`dhclient`，但在此之前你*必须*移除任何默认网关路由（参见第9.11.2节）。要运行测试，只需指定网络接口名称（这里是enp0s31f6）：
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Unlike `dhclient`, the systemd-networkd DHCP client can’t be run by hand on
    the command line. The configuration, described the systemd.network(5) manual page,
    is in */etc/systemd/network*, but like other kinds of network configuration, can
    be automatically generated by Netplan.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与`dhclient`不同，systemd-networkd DHCP客户端不能在命令行中手动运行。配置文件位于*/etc/systemd/network*，如systemd.network(5)手册页所描述，但与其他类型的网络配置一样，可以通过Netplan自动生成。
- en: 9.19.2 Linux DHCP Servers
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.19.2 Linux DHCP服务器
- en: You can task a Linux machine with running a DHCP server, which provides a good
    amount of control over the addresses it gives out. However, unless you’re administering
    a large network with many subnets, you’re probably better off using specialized
    router hardware that includes built-in DHCP servers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将Linux机器配置为运行DHCP服务器，这样可以很好地控制它分配的地址。然而，除非你在管理一个拥有多个子网的大型网络，否则你可能更倾向于使用内置DHCP服务器的专用路由器硬件。
- en: Probably the most important thing to know about DHCP servers is that you want
    only one running on the same subnet in order to avoid problems with clashing IP
    addresses or incorrect configurations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最重要的一点是，关于DHCP服务器，你只希望在同一子网中运行一个，以避免IP地址冲突或配置错误的问题。
- en: 9.20 Automatic IPv6 Network Configuration
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.20 自动IPv6网络配置
- en: DHCP works acceptably well in practice, but it relies on certain assumptions,
    including that there will be a DHCP server available, that the server is correctly
    implemented and stable, and that it can track and maintain leases. Although there’s
    a version of DHCP for IPv6 called DHCPv6, there’s an alternative that’s far more
    common.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP在实践中工作得相当好，但它依赖于某些假设，包括必须有一个可用的DHCP服务器，服务器需要正确实现且稳定，并且能够跟踪和维护租约。虽然有一种适用于IPv6的DHCP版本，称为DHCPv6，但还有一种更为常见的替代方式。
- en: The IETF took advantage of the large IPv6 address space to devise a new way
    of network configuration that does not require a central server. This is called
    *stateless configuration*, because clients don’t need to store any data such as
    lease assignments.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: IETF利用了广阔的IPv6地址空间，设计了一种新的网络配置方式，不需要中央服务器。这被称为*无状态配置*，因为客户端不需要存储任何数据，如租约分配。
- en: Stateless IPv6 network configuration starts with the link-local network. Recall
    that this network includes the addresses prefixed fe80::/64\. Because there are
    so many available addresses on the link-local network, a host can generate an
    address that is unlikely to be duplicated anywhere on the network. Furthermore,
    the network prefix is already fixed, so the host can broadcast to the network,
    asking if any other host on the network is using the address.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态IPv6网络配置从链路本地网络开始。回想一下，这个网络包括以fe80::/64为前缀的地址。由于链路本地网络上有大量可用地址，主机可以生成一个不太可能在网络中任何地方重复的地址。此外，网络前缀已经固定，因此主机可以广播到网络，询问网络上是否有其他主机正在使用该地址。
- en: Once the host has a link-local address, it can determine a global address. It
    does so by listening for a router advertisement (RA) message that routers occasionally
    send on the link-local network. The RA message includes the global network prefix,
    the router IP address, and possibly DNS information. With that information, the
    host can attempt to fill in the interface ID part of the global address, similar
    to what it did with the link-local address.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦主机拥有了链路本地地址，它就可以确定一个全球地址。它通过监听路由器偶尔在链路本地网络上发送的路由器广告（RA）消息来实现这一点。RA消息包括全球网络前缀、路由器IP地址以及可能的DNS信息。有了这些信息，主机可以尝试填写全球地址的接口ID部分，类似于它在链路本地地址时所做的。
- en: Stateless configuration relies on a global network prefix at most 64 bits long
    (in other words, its netmask is /64 or lower).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态配置依赖于一个最大为64位长的全球网络前缀（换句话说，其子网掩码是/64或更低）。
- en: 9.21 Configuring Linux as a Router
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.21 配置Linux作为路由器
- en: Routers are just computers with more than one physical network interface. You
    can easily configure a Linux machine to be a router.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器只是具有多个物理网络接口的计算机。你可以轻松地配置一台Linux机器作为路由器。
- en: 'Let’s look at an example. Say you have two LAN subnets, 10.23.2.0/24 and 192.168.45.0/24\.
    To connect them, you have a Linux router machine with three network interfaces:
    two for the LAN subnets and one for an internet uplink, as shown in [Figure 9-5](#figure9-5).'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个例子。假设你有两个局域网子网，10.23.2.0/24和192.168.45.0/24。为了连接它们，你有一台Linux路由器机器，具有三个网络接口：两个用于局域网子网，一个用于互联网上行链接，如[图9-5](#figure9-5)所示。
- en: 'As you can see, this doesn’t look very different from the simple network example
    used in the rest of this chapter. The router’s IP addresses for the LAN subnets
    are 10.23.2.1 and 192.168.45.1\. When those addresses are configured, the routing
    table looks something like this (the interface names might vary in practice; ignore
    the internet uplink for now):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这看起来与本章其余部分使用的简单网络示例并没有太大区别。路由器在局域网子网中的IP地址分别是10.23.2.1和192.168.45.1。当这些地址被配置后，路由表大致如下所示（接口名称在实践中可能有所不同；暂时忽略互联网上行链接）：
- en: '[PRE33]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now let’s say that the hosts on each subnet have the router as their default
    gateway (10.23.2.1 for 10.23.2.0/24 and 192.168.45.1 for 192.168.45.0/24). If
    10.23.2.4 wants to send a packet to anything outside of 10.23.2.0/24, it passes
    the packet to 10.23.2.1\. For example, to send a packet from 10.23.2.4 (Host A)
    to 192.168.45.61 (Host E), the packet goes to 10.23.2.1 (the router) via its enp0s31f6
    interface, then back out through the router’s enp0s1 interface.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设每个子网中的主机都将路由器作为默认网关（10.23.2.1对于10.23.2.0/24，192.168.45.1对于192.168.45.0/24）。如果10.23.2.4想要发送一个数据包到10.23.2.0/24以外的任何地方，它会将数据包传递给10.23.2.1。例如，为了将数据包从10.23.2.4（主机A）发送到192.168.45.61（主机E），数据包会通过其enp0s31f6接口发送到10.23.2.1（路由器），然后通过路由器的enp0s1接口返回出去。
- en: '![f09005](image_fi/500402c09/f09005.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![f09005](image_fi/500402c09/f09005.png)'
- en: 'Figure 9-5: Two subnets joined with a router'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：通过路由器连接的两个子网
- en: 'However, in some basic configurations, the Linux kernel does not automatically
    move packets from one subnet to another. To enable this basic routing function,
    you need to enable *IP forwarding* in the router’s kernel with this command:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一些基本配置中，Linux 内核并不会自动将数据包从一个子网移动到另一个子网。要启用这一基本路由功能，你需要通过以下命令在路由器的内核中启用*IP
    转发*：
- en: '[PRE34]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As soon as you enter this command, the machine should start routing packets
    between subnets, assuming that the hosts on those subnets know to send their packets
    to the router you just created.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入此命令，机器应该开始在子网之间路由数据包，前提是这些子网中的主机知道将数据包发送到你刚创建的路由器。
- en: To make this change permanent upon reboot, you can add it to your */etc/sysctl.conf*
    file. Depending on your distribution, you may have the option to put it into a
    file in */etc/sysctl.d* so that distribution updates won’t overwrite your changes.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在重启时使此更改永久生效，你可以将其添加到*/etc/sysctl.conf* 文件中。根据你的发行版，你可能有选择将其放入*/etc/sysctl.d*
    文件的选项，这样发行版的更新就不会覆盖你的更改。
- en: When the router also has the third network interface with an internet uplink,
    this same setup allows internet access for all hosts on both subnets because they’re
    configured to use the router as the default gateway. But that’s where things get
    more complicated. The problem is that certain IPv4 addresses such as 10.23.2.4
    are not actually visible to the whole internet; they’re on so-called private networks.
    To provide for internet connectivity, you must set up a feature called *Network
    Address Translation* *(NAT)* on the router. The software on nearly all specialized
    routers does this, so there’s nothing out of the ordinary here, but let’s examine
    the problem of private networks in a bit more detail.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器也具有第三个带有互联网上行链路的网络接口时，这种设置允许所有子网中的主机访问互联网，因为它们已配置为使用路由器作为默认网关。但问题在于，这也让事情变得更加复杂。问题在于，某些
    IPv4 地址，如 10.23.2.4，实际上并不能被整个互联网看到；它们属于所谓的私有网络。为了提供互联网连接，你必须在路由器上设置一个名为*网络地址转换*（*NAT*）的功能。几乎所有专用路由器的软件都能完成这一点，所以这并不算什么特别的事情，但让我们稍微更详细地研究一下私有网络的问题。
- en: 9.22 Private Networks (IPv4)
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.22 私有网络（IPv4）
- en: Say you decide to build your own network. You have your machines, router, and
    network hardware ready. Given what you know about a simple network so far, your
    next question is, “What IP subnet should I use?”
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你决定建立自己的网络。你已经准备好了计算机、路由器和网络硬件。根据你目前对简单网络的理解，你的下一个问题是：“我应该使用什么 IP 子网？”
- en: If you want a block of internet addresses that every host on the internet can
    see, you can buy one from your ISP. However, because the range of IPv4 addresses
    is very limited, this costs a lot and isn’t useful for much more than running
    a server that the rest of the internet can see. Most people don’t really need
    this kind of service because they access the internet as a client.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个全互联网可见的地址块，你可以向你的 ISP 购买一个。然而，由于 IPv4 地址的范围非常有限，这样做成本高昂，且仅适合用于运行一个互联网能够看到的服务器。大多数人并不需要这种服务，因为他们作为客户端访问互联网。
- en: The conventional, inexpensive alternative is to pick a private subnet from the
    addresses in the RFC 1918/6761 internet standards documents, shown in [Table 9-2](#table9-2).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的、廉价的替代方法是从 RFC 1918/6761 互联网标准文档中选择一个私有子网地址，如[表 9-2](#table9-2)所示。
- en: 'Table 9-2: Private Networks Defined by RFC 1918 and 6761'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2：RFC 1918 和 6761 定义的私有网络
- en: '| **Network** | **Subnet mask** | **CIDR form** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **网络** | **子网掩码** | **CIDR 形式** |'
- en: '| --- | --- | --- |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 10.0.0.0 | 255.0.0.0 | 10.0.0.0/8 |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0 | 255.0.0.0 | 10.0.0.0/8 |'
- en: '| 192.168.0.0 | 255.255.0.0 | 192.168.0.0/16 |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 192.168.0.0 | 255.255.0.0 | 192.168.0.0/16 |'
- en: '| 172.16.0.0 | 255.240.0.0 | 172.16.0.0/12 |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 172.16.0.0 | 255.240.0.0 | 172.16.0.0/12 |'
- en: You can carve up private subnets as you wish. Unless you plan to have more than
    254 hosts on a single network, pick a small subnet like 10.23.2.0/24, as we’ve
    been using throughout this chapter. (Networks with this netmask are sometimes
    called *class C* subnets. Although the term is technically obsolete, it’s still
    useful.)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要划分私有子网。除非你计划在单一网络中拥有超过 254 个主机，否则可以选择一个小的子网，如 10.23.2.0/24，就像本章中所使用的那样。（具有这种子网掩码的网络有时被称为*Class
    C* 子网，虽然这一术语在技术上已经过时，但仍然有用。）
- en: What’s the catch? Hosts on the real internet know nothing about private subnets
    and won’t send packets to them, so without some help, hosts on private subnets
    can’t talk to the outside world. A router connected to the internet (with a true,
    nonprivate address) needs to have some way to fill in the gap between that connection
    and the hosts on a private network.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题在哪里？真实互联网中的主机对私有子网一无所知，并且不会向它们发送数据包，因此，如果没有帮助，私有子网中的主机无法与外部世界通信。连接到互联网的路由器（具有真实的、非私有的地址）需要有某种方式来填补该连接与私有网络中主机之间的空白。
- en: 9.23 Network Address Translation (IP Masquerading)
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.23 网络地址转换（IP 伪装）
- en: NAT is the most commonly used way to share a single IP address with a private
    network, and it’s nearly universal in home and small office networks. In Linux,
    the variant of NAT that most people use is known as *IP masquerading*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: NAT 是最常用的方式来与私有网络共享单一的 IP 地址，并且在家庭和小型办公室网络中几乎是普遍使用的。在 Linux 中，大多数人使用的 NAT 变体被称为
    *IP 伪装*。
- en: The basic idea behind NAT is that the router doesn’t just move packets from
    one subnet to another; it transforms them as it moves them. Hosts on the internet
    know how to connect to the router, but they know nothing about the private network
    behind it. The hosts on the private network need no special configuration; the
    router is their default gateway.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: NAT 的基本思想是，路由器不仅仅是将数据包从一个子网移动到另一个子网，它还在移动的过程中转换这些数据包。互联网上的主机知道如何连接到路由器，但它们不知道路由器后面的私有网络。私有网络上的主机不需要特殊配置；路由器是它们的默认网关。
- en: 'The system works roughly like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 系统大致是这样的工作原理：
- en: A host on the internal private network wants to make a connection to the outside
    world, so it sends its connection request packets through the router.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部私有网络上的主机想要连接到外部世界，因此它通过路由器发送连接请求数据包。
- en: The router intercepts the connection request packet rather than passing it out
    to the internet (where it would get lost because the public internet knows nothing
    about private networks).
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器拦截连接请求数据包，而不是将其传递到互联网（否则它会丢失，因为公共互联网对私有网络一无所知）。
- en: The router determines the destination of the connection request packet and opens
    its own connection to the destination.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器确定连接请求数据包的目的地，并打开到该目的地的连接。
- en: When the router obtains the connection, it fakes a “connection established”
    message back to the original internal host.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当路由器获得连接时，它会假装向原始内部主机发送一个“连接已建立”消息。
- en: The router is now the middleman between the internal host and the destination.
    The destination knows nothing about the internal host; the connection on the remote
    host looks like it came from the router.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，路由器成为了内部主机和目的地之间的中介。目的地对内部主机一无所知；远程主机上的连接看起来像是来自路由器。
- en: This isn’t quite as simple as it sounds. Normal IP routing knows only source
    and destination IP addresses in the internet layer. However, if the router dealt
    only with the internet layer, each host on the internal network could establish
    only one connection to a single destination at a time (among other limitations),
    because there is no information in the internet layer part of a packet to distinguish
    among multiple requests from the same host to the same destination. Therefore,
    NAT must go beyond the internet layer and dissect packets to pull out more identifying
    information, particularly the UDP and TCP port numbers from the transport layers.
    UDP is fairly easy because there are ports but no connections, but the TCP transport
    layer is complex.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像听起来那么简单。普通的 IP 路由只知道互联网层中的源地址和目的地址。然而，如果路由器仅处理互联网层，内部网络上的每个主机一次只能与单个目的地建立一个连接（还有其他的限制），因为数据包的互联网层部分没有信息来区分同一主机向同一目的地发出的多个请求。因此，NAT
    必须超越互联网层，拆解数据包以提取更多的识别信息，特别是来自传输层的 UDP 和 TCP 端口号。UDP 相对简单，因为它有端口但没有连接，而 TCP 传输层则较为复杂。
- en: 'In order to set up a Linux machine to perform as a NAT router, you must activate
    all of the following inside the kernel configuration: network packet filtering
    (“firewall support”), connection tracking, iptables support, full NAT, and MASQUERADE
    target support. Most distribution kernels come with this support.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Linux 机器设置为执行 NAT 路由器，你必须在内核配置中激活以下所有选项：网络数据包过滤（“防火墙支持”）、连接跟踪、iptables 支持、完全的
    NAT 以及 MASQUERADE 目标支持。大多数发行版内核都提供这些支持。
- en: 'Next you need to run some complex-looking `iptables` commands to make the router
    perform NAT for its private subnet. Here’s an example that applies to an internal
    Ethernet network on enp0s2 sharing an external connection at enp0s31f6 (you’ll
    learn more about the `iptables` syntax in Section 9.25):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要运行一些看起来复杂的`iptables`命令，使路由器对其私有子网执行 NAT。这里有一个例子，适用于 enp0s2 上的内部以太网网络，分享
    enp0s31f6 上的外部连接（你将在第 9.25 节学习更多关于 `iptables` 的语法）：
- en: '[PRE35]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You likely won’t ever need to manually enter these commands unless you’re developing
    your own software, especially with so much special-purpose router hardware available.
    However, a variety of virtualization software can set up NAT for use in networking
    for virtual machines and containers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你在开发自己的软件，否则你可能永远不需要手动输入这些命令，尤其是现在有这么多专用路由器硬件可用。然而，各种虚拟化软件可以设置 NAT，用于虚拟机和容器的网络配置。
- en: Although NAT works well in practice, remember that it’s essentially a hack that
    extends the lifetime of the IPv4 address space. IPv6 does not need NAT, thanks
    to its larger and more sophisticated address space described in Section 9.7.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 NAT 在实际中运行良好，但请记住，它本质上是一种延长 IPv4 地址空间生命周期的技巧。由于 IPv6 的地址空间更大、更复杂，正如第 9.7
    节所述，它不需要 NAT。
- en: 9.24 Routers and Linux
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.24 路由器与 Linux
- en: In the early days of broadband, users with less demanding needs simply connected
    their machine directly to the internet. But it didn’t take long for many users
    to want to share a single broadband connection with their own networks, and Linux
    users in particular would often set up an extra machine to use as a router running
    NAT.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在宽带的早期，需求较低的用户通常直接将计算机连接到互联网。但很快，许多用户就希望将一个宽带连接共享到他们自己的网络，尤其是 Linux 用户，通常会设置一台额外的机器作为路由器运行
    NAT。
- en: Manufacturers responded to this new market by offering specialized router hardware
    consisting of an efficient processor, some flash memory, and several network ports—with
    enough power to manage a typical simple network, run important software such as
    a DHCP server, and use NAT. When it came to software, many manufacturers turned
    to Linux to power their routers. They added the necessary kernel features, stripped
    down the user-space software, and created GUI-based administration interfaces.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 厂商通过提供专门的路由器硬件来回应这一新市场，这些硬件通常包括高效的处理器、一些闪存和几个网络端口——足以管理一个典型的简单网络，运行重要的软件如 DHCP
    服务器，并使用 NAT。在软件方面，许多厂商选择使用 Linux 来驱动它们的路由器。它们添加了必要的内核特性，精简了用户空间的软件，并创建了基于图形界面的管理界面。
- en: Almost as soon as the first of these routers appeared, many people became interested
    in digging deeper into the hardware. One manufacturer, Linksys, was required to
    release the source code for its software under the terms of the license of one
    of its components, and soon specialized Linux distributions such as OpenWRT appeared
    for routers. (The “WRT” in these names came from the Linksys model number.)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在这些路由器出现的第一时间，许多人就开始对深入挖掘硬件产生兴趣。一个厂商 Linksys 被要求根据其某一组件的许可条款发布软件的源代码，很快，像
    OpenWRT 这样的专门针对路由器的 Linux 发行版就出现了。（这些名称中的 “WRT” 来自 Linksys 的型号编号。）
- en: Aside from the hobbyist aspect, there are good reasons to install these distributions
    on routers. They’re often more stable than the manufacturer firmware, especially
    on older router hardware, and they typically offer additional features. For example,
    to bridge a network with a wireless connection, many manufacturers require you
    to buy matching hardware, but with OpenWRT installed, the manufacturer and age
    of the hardware don’t really matter. This is because you’re using a truly open
    operating system on the router that doesn’t care what hardware you use as long
    as your hardware is supported.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 除了爱好者的角度外，安装这些发行版在路由器上也有充分的理由。它们通常比厂商固件更稳定，特别是在老旧的路由器硬件上，并且通常提供更多功能。例如，要通过无线连接桥接网络，许多厂商要求你购买匹配的硬件，但如果安装了
    OpenWRT，硬件的品牌和年代并不重要。这是因为你在路由器上使用的是一个真正开放的操作系统，它并不关心你使用什么硬件，只要你的硬件被支持。
- en: You can use much of the knowledge in this book to examine the internals of custom
    Linux firmware, though you’ll encounter differences, especially when logging in.
    As with many embedded systems, open firmware tends to use BusyBox to provide many
    shell features. BusyBox is a single executable program that offers limited functionality
    for many Unix commands such as the shell, `ls`, `grep`, `cat`, and `more`. (This
    saves a significant amount of memory.) In addition, the boot-time init tends to
    be very simple on embedded systems. However, you typically won’t find these limitations
    to be a problem, because custom Linux firmware often includes a web administration
    interface similar to what you’d see from a manufacturer.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用本书中的大部分知识来检查自定义 Linux 固件的内部结构，尽管你会遇到一些差异，尤其是在登录时。与许多嵌入式系统一样，开源固件通常使用 BusyBox
    来提供许多 shell 功能。BusyBox 是一个单一的可执行程序，提供许多 Unix 命令的有限功能，例如 shell、`ls`、`grep`、`cat`
    和 `more`。 （这节省了大量的内存。）此外，嵌入式系统上的启动时 init 通常非常简单。然而，你通常不会觉得这些限制有问题，因为自定义 Linux
    固件通常包括一个 Web 管理界面，类似于制造商所提供的界面。
- en: 9.25 Firewalls
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.25 防火墙
- en: Routers should always include some kind of firewall to keep undesirable traffic
    out of your network. A *firewall* is a software and/or hardware configuration
    that usually sits on a router between the internet and a smaller network, attempting
    to ensure that nothing “bad” from the internet harms the smaller network. You
    can also set up firewall features on any host to screen all incoming and outgoing
    data at the packet level (as opposed to at the application layer, where server
    programs usually try to perform some access control of their own). Firewalling
    on individual machines is sometimes called *IP filtering*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器应始终包含某种类型的防火墙，以防止不需要的流量进入你的网络。*防火墙*是一个软件和/或硬件配置，通常位于路由器上，位于互联网和较小网络之间，试图确保互联网中的任何“坏东西”不会伤害到较小的网络。你也可以在任何主机上设置防火墙功能，筛选所有进出数据包的数据（与在应用层进行的访问控制不同，服务器程序通常会尝试在应用层执行某些访问控制）。在单独的机器上进行防火墙过滤有时被称为*IP
    过滤*。
- en: A system can filter packets when it receives a packet, sends a packet, or forwards
    (routes) a packet to another host or gateway.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 系统可以在接收到数据包、发送数据包或将数据包转发（路由）到另一个主机或网关时进行数据包过滤。
- en: 'With no firewalling in place, a system just processes packets and sends them
    on their way. Firewalls put checkpoints for packets at the points of data transfer
    just identified. The checkpoints drop, reject, or accept packets, usually based
    on some of these criteria:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有防火墙，系统只会处理数据包并将它们发送出去。防火墙在刚才提到的数据传输点上设置了数据包的检查点。检查点会丢弃、拒绝或接受数据包，通常根据以下一些标准：
- en: The source or destination IP address or subnet
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源 IP 地址或目标 IP 地址或子网
- en: The source or destination port (in the transport layer information)
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源端口或目标端口（在传输层信息中）
- en: The firewall’s network interface
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙的网络接口
- en: Firewalls provide an opportunity to work with the subsystem of the Linux kernel
    that processes IP packets. Let’s look at that now.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙提供了一个机会，让你可以与处理 IP 数据包的 Linux 内核子系统进行交互。我们现在来看看这个。
- en: 9.25.1 Linux Firewall Basics
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.25.1 Linux 防火墙基础
- en: In Linux, you create firewall rules in a series known as a *chain*. A set of
    chains makes up a *table*. As a packet moves through the various parts of the
    Linux networking subsystem, the kernel applies the rules in certain chains to
    the packets. For example, a new packet arriving from the physical layer is classified
    by the kernel as “input,” so it activates rules in chains corresponding to input.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，你可以通过一系列称为*链*的规则来创建防火墙规则。一组链组成一个*表*。当数据包在 Linux 网络子系统的各个部分中传输时，内核会根据规则将数据包应用到某些链。例如，一个新的数据包从物理层到达时，内核将其分类为“输入”，因此它会激活对应输入链中的规则。
- en: All of these data structures are maintained by the kernel. The whole system
    is called *iptables*, with an `iptables` user-space command to create and manipulate
    the rules.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据结构都是由内核维护的。整个系统被称为*iptables*，并通过一个 `iptables` 用户空间命令来创建和操作规则。
- en: 'Because there can be many tables—each with its own sets of chains, which in
    turn can contain many rules—packet flow can become quite complicated. However,
    you’ll normally work primarily with a single table named *filter* that controls
    basic packet flow. There are three basic chains in the filter table: INPUT for
    incoming packets, OUTPUT for outgoing packets, and FORWARD for routed packets.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能有多个表—每个表有自己的一组链，而这些链又可能包含多个规则—数据包流动可能变得相当复杂。然而，你通常主要会处理一个名为*filter*的单一表，它控制基本的数据包流动。过滤表中有三个基本链：用于入站数据包的
    INPUT，出站数据包的 OUTPUT，以及路由数据包的 FORWARD。
- en: Figures 9-6 and 9-7 show simplified flowcharts for where rules are applied to
    packets in the filter table. There are two figures because packets can either
    come into the system from a network interface ([Figure 9-6](#figure9-6)) or be
    generated by a local process ([Figure 9-7](#figure9-7)).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6 和 9-7 显示了简化的流程图，展示了在过滤表中应用规则的位置。之所以有两张图，是因为数据包可以通过网络接口进入系统（[图 9-6](#figure9-6)），或者由本地进程生成（[图
    9-7](#figure9-7)）。
- en: '![f09006](image_fi/500402c09/f09006.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![f09006](image_fi/500402c09/f09006.png)'
- en: 'Figure 9-6: Chain-processing sequence for incoming packets from a network'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6：来自网络的入站数据包的链处理顺序
- en: '![f09007](image_fi/500402c09/f09007.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![f09007](image_fi/500402c09/f09007.png)'
- en: 'Figure 9-7: Chain-processing sequence for incoming packets from a local process'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-7：来自本地进程的入站数据包的链处理顺序
- en: As you can see, an incoming packet from the network can be consumed by a user
    process and may not reach the FORWARD chain or the OUTPUT chain. Packets generated
    by user processes won’t reach the INPUT or FORWARD chains.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，来自网络的入站数据包可以被用户进程消耗，并且可能不会到达 FORWARD 链或 OUTPUT 链。用户进程生成的数据包不会到达 INPUT
    或 FORWARD 链。
- en: This gets more complicated because there are many steps along the way other
    than just these three chains. For example, packets are subject to PREROUTING and
    POSTROUTING chains, and chain processing can also occur at any of the three lower
    network levels. For a big diagram of everything that’s going on, search the internet
    for “Linux netfilter packet flow,” but remember that these diagrams try to include
    every possible scenario for packet input and flow. It often helps to break the
    diagrams down by packet source, as in Figures 9-6 and 9-7.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这变得更复杂，因为除了这三条链外，数据包还会经过许多其他步骤。例如，数据包会受到 PREROUTING 和 POSTROUTING 链的影响，链处理也可以在任何一个三层网络层进行。要查看所有发生的步骤的大图，可以在网上搜索
    “Linux netfilter packet flow”，但请记住，这些图试图涵盖数据包输入和流动的每种可能场景。通常将图按数据包来源分解，如图 9-6
    和 9-7 中所示，会更有帮助。
- en: 9.25.2 Setting Firewall Rules
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.25.2 设置防火墙规则
- en: 'Let’s look at how the iptables system works in practice. Start by viewing the
    current configuration with this command:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 iptables 系统如何在实践中工作。首先使用此命令查看当前配置：
- en: '[PRE36]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is usually an empty set of chains, as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 输出通常是一个空的链集，如下所示：
- en: '[PRE37]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Each firewall chain has a default *policy* that specifies what to do with a
    packet if no rule matches the packet. The policy for all three chains in this
    example is ACCEPT, meaning that the kernel allows the packet to pass through the
    packet-filtering system. The DROP policy tells the kernel to discard the packet.
    To set the policy on a chain, use `iptables -P` like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 每个防火墙链都有一个默认的*策略*，该策略指定如果没有规则匹配数据包时应该如何处理数据包。此示例中所有三个链的策略都是 ACCEPT，这意味着内核允许数据包通过数据包过滤系统。DROP
    策略告诉内核丢弃数据包。要在链上设置策略，可以像这样使用 `iptables -P`：
- en: '[PRE38]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Say that someone at 192.168.34.63 is annoying you. To prevent them from talking
    to your machine, run this command:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 192.168.34.63 上的某人让你感到烦恼。为了防止他们与你的机器通信，可以运行此命令：
- en: '[PRE39]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `-A INPUT` parameter appends a rule to the INPUT chain. The `-s 192.168.34.63`
    part specifies the source IP address in the rule, and `-j DROP` tells the kernel
    to discard any packet matching the rule. Therefore, your machine will throw out
    any packet coming from 192.168.34.63\.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`-A INPUT` 参数将规则追加到 INPUT 链中。`-s 192.168.34.63` 部分指定规则中的源 IP 地址，而 `-j DROP`
    告诉内核丢弃任何匹配该规则的数据包。因此，你的机器将丢弃来自 192.168.34.63 的任何数据包\。'
- en: 'To see the rule in place, run `iptables -L` again:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看已应用的规则，请再次运行 `iptables -L`：
- en: '[PRE40]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Unfortunately, your friend at 192.168.34.63 has told everyone on his subnet
    to open connections to your SMTP port (TCP port 25). To get rid of that traffic
    as well, run:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，192.168.34.63 上的你的朋友已经通知他子网中的每个人打开连接到你的 SMTP 端口（TCP 端口 25）。为了摆脱这些流量，请运行：
- en: '[PRE41]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This example adds a netmask qualifier to the source address as well as `-p
    tcp` to specify TCP packets only. A further restriction, `--destination-port 25`,
    says that the rule should apply only to traffic to port 25\. The IP table list
    for INPUT now looks like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例向源地址添加了一个子网掩码限定符，并且使用`-p tcp`来指定仅允许TCP数据包。进一步的限制`--destination-port 25`表示规则应仅适用于端口25的流量。现在，INPUT的IP表列表如下所示：
- en: '[PRE42]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'All is well until you hear from someone you know at 192.168.34.37 saying that
    she can’t send you email because you blocked her machine. Thinking this is a quick
    fix, you run this command:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都好，直到你听到来自192.168.34.37的某个熟人的消息，她说她无法给你发邮件，因为她的机器被你阻止了。认为这是一个快速修复，你运行了这个命令：
- en: '[PRE43]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, it doesn’t work. To see why, look at the new chain:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它不起作用。要查看原因，请查看新的链：
- en: '[PRE44]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The kernel reads the chain from top to bottom, using the first rule that matches.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 内核从上到下读取链，使用第一个匹配的规则。
- en: The first rule does not match 192.168.34.37, but the second does, because it
    applies to all hosts from 192.168.34.1 to 192.168.34.254 and this second rule
    says to drop packets. When a rule matches, the kernel carries out the action and
    looks no further down in the chain. (You might notice that 192.168.34.37 can send
    packets to any port on your machine *except* port 25 because the second rule applies
    *only* to port 25.)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则不匹配192.168.34.37，但第二条规则匹配，因为它适用于从192.168.34.1到192.168.34.254的所有主机，并且第二条规则指示丢弃数据包。当规则匹配时，内核执行该动作并不再向下查看链中的其他规则。（你可能会注意到，192.168.34.37可以向你机器的任何端口发送数据包，*除了*端口25，因为第二条规则*仅*适用于端口25。）
- en: 'The solution is to move the third rule to the top. First, delete the third
    rule with this command:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将第三条规则移到顶部。首先，用这个命令删除第三条规则：
- en: '[PRE45]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then *insert* that rule at the top of the chain with `iptables -I`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用`iptables -I`将该规则插入链的顶部：
- en: '[PRE46]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To insert a rule elsewhere in a chain, put the rule number after the chain name
    (for example, `iptables -I INPUT 4 ...`).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要在链中其他位置插入规则，请将规则编号放在链名之后（例如，`iptables -I INPUT 4 ...`）。
- en: 9.25.3 Firewall Strategies
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.25.3 防火墙策略
- en: Although the preceding tutorial showed you how to insert rules and how the kernel
    processes IP chains, you haven’t seen firewall strategies that actually work.
    Let’s talk about that now.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的教程展示了如何插入规则以及内核如何处理IP链，但你还没有看到实际有效的防火墙策略。现在让我们来谈谈这个。
- en: 'There are two basic kinds of firewall scenarios: one for protecting individual
    machines (where you set rules in each machine’s INPUT chain) and one for protecting
    a network of machines (where you set rules in the router’s FORWARD chain). In
    both cases, you can’t have serious security if you use a default policy of ACCEPT
    and continuously insert rules to drop packets from sources that start to send
    bad stuff. You must allow only the packets that you trust, and deny everything
    else.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙策略有两种基本情况：一种是保护单个机器（你在每台机器的INPUT链中设置规则），另一种是保护一组机器的网络（你在路由器的FORWARD链中设置规则）。在这两种情况下，如果你使用默认的ACCEPT策略，并持续插入规则以丢弃来自开始发送恶意内容的源的数据包，你就无法实现严密的安全。你必须只允许你信任的数据包，通过其他的数据包则一律拒绝。
- en: 'For example, say your machine has an SSH server on TCP port 22\. There’s no
    reason for any random host to initiate a connection to any other port on your
    machine, and you shouldn’t give any such host a chance. To set that up, first
    set the INPUT chain policy to DROP:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你的机器上有一个SSH服务器，使用TCP端口22。没有任何原因让随机主机尝试连接你机器的任何其他端口，而且你不应当给任何这样的主机机会。要设置此功能，首先将INPUT链策略设置为DROP：
- en: '[PRE47]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To enable ICMP traffic (for `ping` and other utilities), use this line:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用ICMP流量（用于`ping`和其他工具），请使用这一行：
- en: '[PRE48]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Make sure that you can receive packets you send to both your own network IP
    address and 127.0.0.1 (localhost). Assuming your host’s IP address is `my_addr`,
    do this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你能够接收发送到自己网络IP地址和127.0.0.1（localhost）的数据包。假设你的主机IP地址是`my_addr`，请执行以下操作：
- en: '[PRE49]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you control your entire subnet (and trust everything on it), you can replace
    `my_addr` with your subnet address and subnet mask—for example, `10.23.2.0/24`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你控制整个子网（并信任子网上的所有内容），你可以用你的子网地址和子网掩码替换`my_addr`，例如，`10.23.2.0/24`。
- en: 'Now, although you still want to deny incoming TCP connections, you still need
    to make sure that your host can make TCP connections to the outside world. Because
    all TCP connections start with a SYN (connection request) packet, if you let all
    TCP packets through that aren’t SYN packets, you’re still okay:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然你仍然希望拒绝传入的TCP连接，但你仍然需要确保你的主机能够与外界建立TCP连接。因为所有的TCP连接都以SYN（连接请求）数据包开始，所以如果你允许所有不是SYN数据包的TCP数据包通过，仍然是可以的：
- en: '[PRE50]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `!` symbol indicates a negation, so `! --syn` matches any non-SYN packet.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`!` 符号表示否定，因此 `! --syn` 匹配任何非 SYN 包。'
- en: 'Next, if you’re using remote UDP-based DNS, you must accept traffic from your
    name server so that your machine can look up names with DNS. Do this for *all*
    DNS servers in */etc/resolv.conf*. Use this command (where the name server’s address
    is `ns_addr`):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果你使用的是基于远程 UDP 的 DNS，你必须允许来自你的域名服务器的流量，这样你的机器才能通过 DNS 查找名称。对*/etc/resolv.conf*
    中的 *所有* DNS 服务器执行此操作。使用以下命令（其中域名服务器的地址为 `ns_addr`）：
- en: '[PRE51]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And finally, allow SSH connections from anywhere:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，允许来自任何地方的 SSH 连接：
- en: '[PRE52]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding iptables settings work for many situations, including any direct
    connection (especially broadband) where an intruder is much more likely to port-scan
    your machine. You could also adapt these settings for a firewalling router by
    using the FORWARD chain instead of INPUT and using source and destination subnets
    where appropriate. For more advanced configurations, you may find a configuration
    tool such as Shorewall to be helpful.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 iptables 设置适用于许多情况，包括任何直接连接（尤其是宽带连接），在这种情况下，入侵者更有可能对你的机器进行端口扫描。你还可以通过使用
    FORWARD 链代替 INPUT，并在适当的地方使用源和目标子网，将这些设置调整为适用于防火墙路由器的情况。对于更高级的配置，你可能会发现像 Shorewall
    这样的配置工具非常有用。
- en: This discussion has only touched on security policy. Remember that the key idea
    is to permit only the things that you find acceptable, not to try to find and
    exclude the bad stuff. Furthermore, IP firewalling is only one piece of the security
    picture. (You’ll see more in the next chapter.)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论仅涉及了安全策略。记住，关键思想是仅允许你认为可以接受的东西，而不是试图找出并排除坏东西。此外，IP 防火墙仅是安全防护的一部分。（你将在下一章看到更多内容。）
- en: 9.26 Ethernet, IP, ARP, and NDP
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.26 以太网、IP、ARP 和 NDP
- en: 'There is one basic detail in the implementation of IP over Ethernet that we
    have yet to cover. Recall that a host must place an IP packet inside an Ethernet
    frame in order to transmit the packet across the physical layer to another host.
    Recall, too, that frames themselves do not include IP address information; they
    use MAC (hardware) addresses. The question is this: When constructing the Ethernet
    frame for an IP packet, how does the host know which MAC address corresponds to
    the destination IP address?'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太网上实现 IP 传输中有一个基本的细节我们还没有涉及。回想一下，主机必须将一个 IP 数据包放入以太网帧中，以便将数据包通过物理层传输到另一台主机。还记得，帧本身不包括
    IP 地址信息；它们使用的是 MAC（硬件）地址。问题是：在构建 IP 数据包的以太网帧时，主机如何知道哪个 MAC 地址对应目标 IP 地址？
- en: We don’t normally think about this question much because networking software
    includes an automatic system of looking up MAC addresses. In IPv4, this is called
    *Address Resolution Protocol (ARP)*. A host using Ethernet as its physical layer
    and IP as the network layer maintains a small table called an *ARP cache* that
    maps IP addresses to MAC addresses. In Linux, the ARP cache is in the kernel.
    To view your machine’s ARP cache, use the `ip neigh` command. (The “neigh” part
    will make sense when you see the IPv6 equivalent. The old command for working
    with the ARP cache is `arp`.)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不会过多考虑这个问题，因为网络软件包含了一个自动查找 MAC 地址的系统。在 IPv4 中，这叫做 *地址解析协议（ARP）*。使用以太网作为物理层、IP
    作为网络层的主机会维护一个叫做 *ARP 缓存* 的小表，它将 IP 地址映射到 MAC 地址。在 Linux 中，ARP 缓存位于内核中。要查看你机器的
    ARP 缓存，可以使用 `ip neigh` 命令。（“neigh”部分等你看到 IPv6 对应命令时会更明白。旧的命令是 `arp`。）
- en: '[PRE53]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We’re using the `-4` option to restrict the output to IPv4\. You can see the
    IP and hardware addresses for the hosts that the kernel knows about. The last
    field indicates the status of the entry in the cache. REACHABLE means that some
    communication with the host occurred recently, and STALE means that it’s been
    a while, and the entry should be refreshed.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `-4` 选项将输出限制为 IPv4。你可以看到内核知道的主机的 IP 和硬件地址。最后一列表示缓存条目的状态。REACHABLE 表示最近与主机发生了通信，而
    STALE 表示已经有一段时间没有通信，条目应该被刷新。
- en: 'When a machine boots, its ARP cache is empty. So how do these MAC addresses
    get in the cache? It all starts when the machine wants to send a packet to another
    host. If a target IP address is not in an ARP cache, the following steps occur:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当一台机器启动时，它的 ARP 缓存是空的。那么这些 MAC 地址是如何进入缓存的呢？这一切始于机器想要发送数据包到另一台主机时。如果目标 IP 地址不在
    ARP 缓存中，将会发生以下步骤：
- en: The origin host creates a special Ethernet frame containing an ARP request packet
    for the MAC address that corresponds to the target IP address.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始主机创建一个特殊的以太网帧，其中包含一个 ARP 请求包，用于请求与目标 IP 地址对应的 MAC 地址。
- en: The origin host broadcasts this frame to the entire physical network for the
    target’s subnet.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源主机将此帧广播到目标子网的整个物理网络。
- en: If one of the other hosts on the subnet knows the correct MAC address, it creates
    a reply packet and frame containing the address and sends it back to the origin.
    Often, the host that replies *is* the target host and is simply replying with
    its own MAC address.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果子网中的其他主机知道正确的 MAC 地址，它会创建一个包含该地址的回复包和帧，并将其发送回源主机。通常，回复的主机 *就是* 目标主机，并仅仅是回复自己的
    MAC 地址。
- en: The origin host adds the IP-MAC address pair to the ARP cache and can proceed.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源主机将 IP-MAC 地址对添加到 ARP 缓存中，并可以继续操作。
- en: 'The only real problem you can have with ARP is that your system’s cache can
    get out of date if you’re moving an IP address from one network interface card
    to another because the cards have different MAC addresses (for example, when testing
    a machine). Unix systems invalidate ARP cache entries if there’s no activity after
    a while, so there shouldn’t be any trouble other than a small delay for invalidated
    data, but you can delete an ARP cache entry immediately with this command:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ARP 相关的唯一实际问题是，如果你将 IP 地址从一个网卡转移到另一个网卡（因为网卡有不同的 MAC 地址，例如，在测试机器时），系统的缓存可能会过时。Unix
    系统会在一段时间后使 ARP 缓存条目失效，因此除了因无效数据而导致的短暂延迟外，不应该有其他问题，但你可以通过以下命令立即删除 ARP 缓存条目：
- en: '[PRE54]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The ip-neighbour(8) manual page explains how to manually set ARP cache entries,
    but you shouldn’t need to do this. Note the spelling.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ip-neighbour(8) 手册页解释了如何手动设置 ARP 缓存条目，但你不需要这样做。请注意拼写。
- en: 9.27 Wireless Ethernet
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.27 无线以太网
- en: In principle, wireless Ethernet (“Wi-Fi”) networks aren’t much different from
    wired networks. Much like any wired hardware, they have MAC addresses and use
    Ethernet frames to transmit and receive data, and as a result the Linux kernel
    can talk to a wireless network interface much as it would a wired network interface.
    Everything at the network layer and above is the same; the main differences are
    additional components in the physical layer, such as frequencies, network IDs,
    and security features.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，无线以太网（“Wi-Fi”）网络与有线网络没有太大区别。就像任何有线硬件一样，它们有 MAC 地址，并使用以太网帧来传输和接收数据，因此 Linux
    内核可以像与有线网络接口一样与无线网络接口进行通信。网络层及以上的内容是相同的；主要的区别在于物理层的额外组件，比如频率、网络 ID 和安全特性。
- en: Unlike wired network hardware, which is very good at automatically adjusting
    to nuances in the physical setup without much fuss, wireless network configuration
    is much more open-ended. To get a wireless interface working properly, Linux needs
    additional configuration tools.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 与有线网络硬件不同，有线网络硬件非常擅长在物理设置中的细微差别上自动调整而无需过多干扰，无线网络配置则更为开放。为了使无线接口正常工作，Linux 需要额外的配置工具。
- en: Let’s take a quick look at the additional components of wireless networks.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下无线网络的附加组件。
- en: Transmission details These are physical characteristics, such as the radio frequency.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传输细节 这些是物理特征，例如无线频率。
- en: Network identification Because more than one wireless network can share the
    same basic medium, you have to be able to distinguish between them. The Service
    Set Identifier (SSID, also known as the “network name”) is the wireless network
    identifier.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络识别 由于多个无线网络可以共享同一个基本介质，因此你必须能够区分它们。服务集标识符（SSID，也称为“网络名称”）是无线网络标识符。
- en: Management Although it’s possible to configure wireless networking to have hosts
    talk directly to each other, most wireless networks are managed by one or more
    *access points* that all traffic goes through. Access points often bridge a wireless
    network with a wired network, making both appear as one single network.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理 尽管可以配置无线网络使主机直接相互通信，但大多数无线网络是由一个或多个 *接入点* 管理的，所有流量都会经过这些接入点。接入点通常将无线网络与有线网络桥接，使得两者看起来像是一个单一的网络。
- en: Authentication You may want to restrict access to a wireless network. To do
    so, you can configure access points to require a password or other authentication
    key before they’ll even talk to a client.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 身份验证 你可能希望限制无线网络的访问。为此，你可以配置接入点，要求在与客户端通信之前输入密码或其他身份验证密钥。
- en: Encryption In addition to restricting the initial access to a wireless network,
    you normally want to encrypt all traffic that goes out across radio waves.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密 除了限制无线网络的初始访问外，通常还需要加密所有通过无线电波传输的流量。
- en: The Linux configuration and utilities that handle these components are spread
    out over a number of areas. Some are in the kernel; Linux features a set of wireless
    extensions that standardize user-space access to hardware. As far as user space
    goes, wireless configuration can get complicated, so most people prefer to use
    GUI frontends, such as the desktop applet for NetworkManager, to get things working.
    Still, it’s worth looking at a few of the things happening behind the scenes.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些组件的Linux配置和工具分布在多个领域。有些位于内核中；Linux具有一套无线扩展，标准化了用户空间对硬件的访问。就用户空间而言，无线配置可能变得复杂，因此大多数人更喜欢使用图形用户界面（GUI）前端，例如NetworkManager的桌面小程序，以便使其正常工作。尽管如此，了解一些幕后发生的事情还是值得的。
- en: 9.27.1 iw
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.27.1 iw
- en: You can view and change kernel space device and network configuration with a
    utility called `iw`. To use `iw`, you normally need to know the network interface
    name for the device, such as *wlp1s0* (predictable device name) or *wlan0* (traditional
    name). Here’s an example that dumps a scan of available wireless networks. (Expect
    a lot of output if you’re in an urban area.)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个名为`iw`的工具查看和更改内核空间的设备和网络配置。使用`iw`时，你通常需要知道设备的网络接口名称，如*wlp1s0*（可预测设备名称）或*wlan0*（传统名称）。这里有一个示例，它展示了可用无线网络的扫描结果。（如果你处于城市区域，预计会有大量输出。）
- en: '[PRE55]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If the network interface has joined a wireless network, you can view the network
    details like this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络接口已连接到无线网络，你可以像这样查看网络详情：
- en: '[PRE56]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The MAC address in the output of this command is from the access point that
    you’re currently talking to.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令输出中的MAC地址来自你当前正在连接的接入点。
- en: 'Use `iw` to connect a network interface to an unsecured wireless network as
    follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`iw`将网络接口连接到一个无加密的无线网络，如下所示：
- en: '[PRE57]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Connecting to secured networks is a different story. For the rather insecure
    Wired Equivalent Privacy (WEP) system, you can use the `keys` parameter with the
    `iw connect` command. However, you shouldn’t use WEP because it’s not secure,
    and you won’t find many networks that support it.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到安全网络是另一回事。对于相当不安全的有线等效隐私（WEP）系统，你可以在`iw connect`命令中使用`keys`参数。然而，你不应该使用WEP，因为它不安全，而且你不会找到许多支持它的网络。
- en: 9.27.2 Wireless Security
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.27.2 无线安全
- en: For most wireless security setups, Linux relies on the wpa_supplicant daemon
    to manage both authentication and encryption for a wireless network interface.
    This daemon can handle the WPA2 and WPA3 (WiFi Protected Access; don’t use the
    older, insecure WPA) schemes of authentication, as well as nearly any kind of
    encryption technique used on wireless networks. When the daemon first starts,
    it reads a configuration file (by default, */etc/wpa_supplicant.conf*) and attempts
    to identify itself to an access point and establish communication based on a given
    network name. The system is well documented; in particular, the wpa_supplicant(8)
    manual page is very detailed.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数无线安全设置，Linux依赖wpa_supplicant守护进程来管理无线网络接口的认证和加密。这个守护进程可以处理WPA2和WPA3（WiFi受保护访问；不要使用较旧的、不安全的WPA）认证方案，以及几乎所有无线网络上使用的加密技术。当守护进程首次启动时，它会读取一个配置文件（默认情况下是*/etc/wpa_supplicant.conf*），并尝试识别自己并与接入点建立通信，基于给定的网络名称。该系统有很好的文档支持；特别是，wpa_supplicant(8)手册页非常详细。
- en: Running the daemon by hand every time you want to establish a connection is
    a lot of work. In fact, just creating the configuration file is tedious due to
    the number of possible options. To make matters worse, all of the work of running
    `iw` and wpa_supplicant simply allows your system to join a wireless physical
    network; it doesn’t even set up the network layer. And that’s where automatic
    network configuration managers such as NetworkManager take a lot of pain out of
    the process. Although they don’t do any of the work on their own, they know the
    correct sequence and required configuration for each step toward getting a wireless
    network operational.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 每次想要建立连接时手动运行守护进程是很繁琐的。实际上，仅仅创建配置文件就很麻烦，因为有许多可选项。更糟糕的是，运行`iw`和wpa_supplicant的所有工作仅仅是让你的系统加入一个无线物理网络；它甚至没有设置网络层。正因如此，像NetworkManager这样的自动网络配置管理器在整个过程中大大减轻了工作负担。虽然它们不会自己做任何工作，但它们知道每一步所需的正确顺序和配置，以便让无线网络正常运行。
- en: 9.28 Summary
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.28 总结
- en: As you’ve seen, understanding the positions and roles of the various network
    layers is critical to understanding how Linux networking operates and how to perform
    network configuration. Although we’ve covered only the basics, more advanced topics
    in the physical, network, and transport layers are similar to what you’ve seen
    here. Layers themselves are often subdivided, as you just saw with the various
    pieces of the physical layer in a wireless network.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，理解各个网络层的位置和作用对于理解Linux网络如何工作以及如何执行网络配置至关重要。虽然我们只讲解了基础内容，但物理层、网络层和传输层的更高级主题与这里所见类似。各层本身也通常会被细分，就像你刚才看到的无线网络中物理层的各个部分。
- en: A substantial amount of action that you’ve seen in this chapter happens in the
    kernel, with some basic user-space control utilities to manipulate the kernel’s
    internal data structures (such as routing tables). This is the traditional way
    of working with the network. However, as with many of the topics discussed in
    this book, some tasks aren’t suitable for the kernel due to their complexity and
    need for flexibility, and that’s where user-space utilities take over. In particular,
    NetworkManager monitors and queries the kernel and then manipulates the kernel
    configuration. Another example is support for dynamic routing protocols such as
    Border Gateway Protocol (BGP), which is used in large internet routers.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你所看到的大量操作发生在内核中，辅以一些基本的用户空间控制工具来操作内核的内部数据结构（例如路由表）。这就是传统的网络工作方式。然而，正如本书讨论的许多主题一样，由于复杂性和对灵活性的需求，一些任务并不适合在内核中完成，这时用户空间工具就会接管。例如，NetworkManager会监视和查询内核，然后操作内核配置。另一个例子是对动态路由协议（如边界网关协议BGP）的支持，BGP广泛应用于大型互联网路由器中。
- en: But you’re probably a little bit bored with network configuration by now. Let’s
    turn to *using* the network—the application layer.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 但你现在可能有些厌倦了网络配置。让我们转向*使用*网络——应用层。
