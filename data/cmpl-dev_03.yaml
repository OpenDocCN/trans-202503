- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MODERN
    JAVASCRIPT</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">现代JavaScript</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: In [Chapter 1](chapter1.xhtml), you used basic JavaScript to create a web server
    with Node.js. Now we’ll take a closer look at the language’s more advanced features
    and how you can effectively use them to create full-stack web applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](chapter1.xhtml)中，你使用了基础的JavaScript通过Node.js创建了一个Web服务器。现在，我们将更深入地探讨语言的高级特性，以及如何有效地使用这些特性来创建全栈Web应用程序。
- en: You’ll sometimes hear the term *ES.Next* used to refer to new versions of JavaScript.
    In this book, we use ES.Next as a broad label for modern JavaScript and its concepts.
    Most runtime environments have implemented the features covered here. Otherwise,
    you can transpile them with Babel.js, creating backward-compatible JavaScript
    that emulates the new features for older runtimes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会听到*ES.Next*这个术语，它指的是JavaScript的新版本。在本书中，我们使用ES.Next作为现代JavaScript及其概念的广义标签。大多数运行时环境都已经实现了这里讨论的特性。如果没有，你可以通过Babel.js进行转译，生成与旧版运行时兼容的JavaScript，从而模拟新特性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">ES.Next Modules</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">ES.Next模块</samp>
- en: ES.Next modules allow you to separate code into files to improve maintenance
    and testability. They encapsulate a piece of logic into easily reusable code,
    and because variables and functions are limited to the module’s scope, you can
    use the same variable name in different modules without running into conflicts.
    (We discuss the concept of scopes in “Declaring Variables” on page 17.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ES.Next模块允许你将代码分离到不同的文件中，以提高可维护性和可测试性。它们将一段逻辑封装成易于重用的代码，并且因为变量和函数的作用域仅限于模块本身，你可以在不同的模块中使用相同的变量名而不会发生冲突。（我们在“声明变量”一节中讨论了作用域的概念，见第17页。）
- en: The official ES.Next modules replaced various unofficial module formats, such
    as UMD and AMD, which you would load with a <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    statement. For example, you used <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    to include the Express.js package for the Node.js server code in [Chapter 1](chapter1.xhtml).
    Instead, ES.Next modules use <samp class="SANS_TheSansMonoCd_W5Regular_11">export</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statements to
    export functions from one module’s scope and import them for use somewhere else.
    In other words, modules allow you to create functions and variables and expose
    them to a new scope.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的ES.Next模块取代了各种非官方的模块格式，如UMD和AMD，这些格式会通过<samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>语句加载。例如，你在[第1章](chapter1.xhtml)中使用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">require</samp>来包含Express.js包，供Node.js服务器代码使用。相反，ES.Next模块使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">export</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>语句来从一个模块的作用域中导出函数，并在其他地方导入它们。换句话说，模块允许你创建函数和变量，并将它们暴露到一个新的作用域。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Named and Default
    Exports</samp>
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用命名导出和默认导出</samp>
- en: 'There are two kinds of Next.js exports: *named* and *default*. These exports
    use slightly different syntaxes when you import them later. Default exports require
    you to define new function names on import. For named exports, renaming is optional
    and done with the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> statement.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js导出有两种类型：*命名导出*和*默认导出*。当你稍后导入它们时，这些导出使用略有不同的语法。默认导出要求你在导入时定义新的函数名称。对于命名导出，重命名是可选的，可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">as</samp>语句完成。
- en: It’s considered a best practice to use named exports over default exports, because
    named exports define a clear and unique interface for the module’s functionality.
    When we use default exports, the user risks importing the same function under
    different names. TypeScript, which we’ll cover in [Chapter 3](chapter3.xhtml),
    recommends that we use default exports if the module has one clear purpose and
    a single export. In contrast, it recommends using named exports whenever the module
    exports more than one item.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是最佳实践的是使用命名导出，而不是默认导出，因为命名导出为模块的功能定义了一个清晰且唯一的接口。当我们使用默认导出时，用户可能会在不同的名称下导入相同的函数。TypeScript（我们将在[第3章](chapter3.xhtml)中讨论）推荐在模块有一个明确的用途和单个导出时使用默认导出。相反，当模块导出多个项时，它推荐使用命名导出。
- en: You should know the syntax of default exports so that you can work with third-party
    modules that use them. Unlike named exports, there can be only one default export
    per file, marked by the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    keyword ([Listing 2-1](chapter2.xhtml#Lis2-1)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解默认导出的语法，这样你才能与使用它们的第三方模块一起工作。与命名导出不同，每个文件只能有一个默认导出，并由<samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>关键字标记（[列表
    2-1](chapter2.xhtml#Lis2-1)）。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: Default exports'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-1：默认导出
- en: In this listing, we define an anonymous function and store it in the constant
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getFoo</samp>. Then we export the
    constant with the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    keyword to make it the module’s default export.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们定义了一个匿名函数并将其存储在常量<samp class="SANS_TheSansMonoCd_W5Regular_11">getFoo</samp>中。然后，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">default</samp>关键字导出常量，使其成为模块的默认导出。
- en: You can export named exports inline or at the end of the file, with curly brackets
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>). [Listing 2-2](chapter2.xhtml#Lis2-2)
    shows several named exports.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在文件的开头或结尾导出命名导出，使用大括号（<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>）。[列表
    2-2](chapter2.xhtml#Lis2-2)展示了几个命名导出。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 2-2: Named exports'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-2：命名导出
- en: Here we define an anonymous function, store it in the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">getFooBar</samp>,
    and immediately export it as <samp class="SANS_TheSansMonoCd_W5Regular_11">getFooBar</samp>.
    Then we define two more anonymous functions and export them as named exports in
    curly brackets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个匿名函数，将其存储在常量<samp class="SANS_TheSansMonoCd_W5Regular_11">getFooBar</samp>中，并立即将其作为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">getFooBar</samp>导出。然后，我们定义了另外两个匿名函数，并将它们作为命名导出在大括号中导出。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Importing Modules</samp>
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">导入模块</samp>
- en: The syntax to import an ES.Next module depends on the type of export you created.
    Named exports do need to be imported using curly brackets, whereas default exports
    do not. In [Listing 2-3](chapter2.xhtml#Lis2-3), we import the default export
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getFoo</samp> by using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statement followed by the
    local name we assign to it. Finally, we conclude the import with a reference to
    the file that contains the code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 导入一个 ES.Next 模块的语法取决于你创建的导出类型。命名导出需要使用大括号导入，而默认导出则不需要。在[列表 2-3](chapter2.xhtml#Lis2-3)中，我们通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">import</samp>语句并后跟分配给它的本地名称来导入默认导出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">getFoo</samp>。最后，我们通过引用包含代码的文件来结束导入。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 2-3: Importing default exports'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-3：导入默认导出
- en: We follow a similar pattern for the named exports in [Listing 2-4](chapter2.xhtml#Lis2-4),
    except that we need to refer to the original function names inside curly brackets.
    To rename the functions locally, we would need to explicitly do so with an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">as</samp> statement, and there is usually
    no reason to do so.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[列表 2-4](chapter2.xhtml#Lis2-4)中遵循了类似的模式来进行命名导出，唯一不同的是我们需要在大括号内引用原始函数名。要在本地重命名函数，我们需要明确地使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">as</samp>语句，通常没有必要这样做。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 2-4: Importing named exports'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-4：导入命名导出
- en: Now you can use the imported functions in your code, as they are available in
    the scope to which you imported them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在代码中使用导入的函数，因为它们在导入的作用域内是可用的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Declaring Variables</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">声明变量</samp>
- en: 'JavaScript offers three different ways to declare a variable: <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>.
    This section discusses the use cases for each of them. Often, you’ll be given
    the advice to avoid <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> because
    it is “outdated.” You can rest assured that it’s not, and you must understand
    each of these variable declaration methods in order to choose the right tool for
    the job.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了三种不同的声明变量的方式：<samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">let</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>。本节讨论了它们的使用场景。通常，你会被建议避免使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp>，因为它“过时了”。你可以放心，它并没有过时，你必须理解这三种变量声明方式，以便选择适合工作的工具。
- en: 'These variables differ in their *scope*, which defines the code area in which
    we can access and use them. JavaScript has multiple levels of scope: global, module,
    function, and block. *Block* scope, which applies to any block of code enclosed
    in curly brackets, is the smallest unit of scope. Every time you use curly brackets,
    you create a new block scope. In comparison, you make a *function* scope when
    you define a function. The scope is limited to the code area inside a specific
    function. The *module* scope applies only to a specific module, whereas the *global*
    scope applies to the entire program. Variables defined in the global scope are
    available in every part of your code.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量在它们的 *作用域* 上有所不同，作用域定义了我们可以访问和使用它们的代码区域。JavaScript 有多个级别的作用域：全局作用域、模块作用域、函数作用域和块作用域。适用于任何用花括号括起来的代码块的
    *块* 作用域是作用域的最小单元。每次你使用花括号时，你都会创建一个新的块作用域。相比之下，当你定义一个函数时，你会创建一个 *函数* 作用域。该作用域仅限于特定函数内部的代码区域。*模块*
    作用域仅适用于特定模块，而 *全局* 作用域适用于整个程序。定义在全局作用域中的变量在代码的任何部分都是可用的。
- en: As you’ll see in the following code listings, a variable is always available
    in its own scope and all of its child scopes. Hence, you should remember that,
    for example, a function scope can contain multiple block scopes. The same variable
    name can be defined twice in one program as long as each variable occurs in different
    scopes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在以下代码清单中看到的，一个变量在其所在的作用域及其所有子作用域中始终可用。因此，你应记住，例如，一个函数作用域可以包含多个块作用域。同样的变量名可以在一个程序中定义两次，只要每个变量出现在不同的作用域中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hoisted Variables</samp>
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">提升的变量</samp>
- en: Traditional JavaScript declares variables with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    keyword. The scope of these variables is the current execution context (usually
    the enclosing function). If declared outside any function, the variable’s scope
    is global, and the variable creates a property on the global object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 JavaScript 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> 关键字声明变量。这些变量的作用域是当前的执行上下文（通常是封闭的函数）。如果在任何函数外部声明，则变量的作用域是全局的，并且该变量会在全局对象上创建一个属性。
- en: Unlike for all other variables, the runtime environment moves, or *hoists*,
    the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> to
    the top of its scope upon execution. Therefore, you can call these variables in
    your code before you define them. [Listing 2-5](chapter2.xhtml#Lis2-5) shows a
    short example of hoisting.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他变量不同，运行时环境会在执行时将 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    的声明提升到作用域的顶部。因此，你可以在代码中先调用这些变量再定义它们。[清单 2-5](chapter2.xhtml#Lis2-5) 展示了提升的简短示例。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 2-5: Using a hoisted variable before it is defined'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-5：在定义变量之前使用提升的变量
- en: In this listing, we assign a value to a variable before declaring it in the
    following line. In languages like Java and C, we can’t use variables before we
    declare them, and any attempt to do so will throw an error. However, because of
    hoisting in JavaScript, the parser moves all variable declarations defined with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword to the top
    of the scope. Thus, the code is equivalent to that in [Listing 2-6](chapter2.xhtml#Lis2-6).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码清单中，我们在下一行声明变量之前给变量赋了一个值。在像 Java 和 C 这样的语言中，我们不能在声明之前使用变量，任何尝试这么做都会抛出错误。然而，由于
    JavaScript 中的提升机制，解析器会将所有使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    关键字定义的变量声明提升到作用域的顶部。因此，代码等价于 [清单 2-6](chapter2.xhtml#Lis2-6) 中的代码。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 2-6: Defining a variable before using it'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-6：在使用变量之前定义变量
- en: Because of hoisting, block scope does not apply to variables declared with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword. They are always
    hoisted. To illustrate this, take a look at [Listing 2-7](chapter2.xhtml#Lis2-7),
    where we declare a global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>,
    a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> inside the
    function scope, and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    inside a block scope, all with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    keyword.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于提升机制，块作用域不适用于使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> 关键字声明的变量。它们总是被提升。为了说明这一点，看看
    [清单 2-7](chapter2.xhtml#Lis2-7)，我们在其中声明了一个全局变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>、一个函数作用域内的变量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> 和一个块作用域内的变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>，所有这些变量都使用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> 关键字。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 2-7: The scope of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">var</samp>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-7：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">var</samp>的作用域
- en: We run the <samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp> function
    and see that <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">window.globalVar</samp> are the
    same; the parser hoists both variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>, to the top of the
    function scope. Thus, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    is available outside the block scope, and the function scope writes both variables’
    values, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    to the console.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行<samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp>函数，并看到<samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">window.globalVar</samp>是相同的；解析器将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>这两个变量提升到函数作用域的顶部。因此，变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>可以在块作用域外使用，且函数作用域会将这两个变量的值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>打印到控制台。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Scope-Abiding Variables</samp>
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">作用域变量</samp>
- en: Modern JavaScript introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>
    keyword to supplement <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>.
    With <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>, we can declare
    variables that are block-scoped and can be accessed only after they have been
    declared. For this reason, they are considered *non-hoisted* variables. Block-scoped
    variables are limited to the scope of the block statement inside which they are
    defined. Unlike global variables defined with <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>,
    a global <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp> variable isn’t
    added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">window</samp> object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 引入了<samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>关键字来补充<samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp>。使用<samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>，我们可以声明块级作用域的变量，且这些变量只能在声明后访问。因此，它们被认为是*非提升*变量。块级作用域的变量仅限于其定义所在的块语句的作用域内。与使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp>定义的全局变量不同，全局的<samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>变量不会被添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">window</samp>对象中。
- en: Let’s look at the scope of a variable declared with <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>.
    In [Listing 2-8](chapter2.xhtml#Lis2-8), we declare a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    inside a function scope, a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    inside a block scope, and a global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用<samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>声明的变量的作用域。在[示例
    2-8](chapter2.xhtml#Lis2-8)中，我们在一个函数作用域内声明了变量<samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>，在一个块作用域内声明了变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>，以及一个全局变量<samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 2-8: The scope of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">let</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-8：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">let</samp>的作用域
- en: Each variable is available only in its respective scope. The parser does not
    hoist them, and therefore, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    is not available outside the block statement. If you try to reference it elsewhere,
    the parser will throw an error and notify you that <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    is not defined.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量仅在其各自的作用域内可用。解析器不会提升它们，因此变量<samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>在块语句外不可用。如果你尝试在其他地方引用它，解析器会抛出一个错误并通知你<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>未定义。
- en: 'We execute the function, and unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    code, it writes only the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    to the console. When we try to access <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>,
    we receive an error, <samp class="SANS_TheSansMonoCd_W5Regular_11">Uncaught ReferenceError:
    bar is not defined</samp>. For <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>,
    we see the value <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> printed
    on the console, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">window.globalVar</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">undefined</samp>.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '我们执行该函数，与 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> 代码不同，它只会将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> 的值写入控制台。当我们尝试访问 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> 时，会收到错误 <samp class="SANS_TheSansMonoCd_W5Regular_11">Uncaught
    ReferenceError: bar is not defined</samp>。对于 <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>，我们看到控制台打印出值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp>，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">window.globalVar</samp>
    的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">undefined</samp>。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant-Like Data</samp>
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">常量型数据</samp>
- en: Modern JavaScript introduced another new keyword, <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    for declaring constants such as data types. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> does not create properties
    of the global object when declared globally. They, too, are considered non-hoisted,
    as they cannot be accessed before being declared.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 引入了另一个新的关键字，<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>，用于声明常量，如数据类型。与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp> 类似，<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    在全局声明时不会创建全局对象的属性。它们也被视为非提升的，因为在声明之前无法访问。
- en: Constants in JavaScript are different from those in many other languages, where
    they function as immutable data types. In JavaScript, constants only *look* immutable.
    In fact, they are read-only references to their value. Therefore, you cannot directly
    reassign another value to the variable identifier for primitive data types. However,
    objects or arrays are non-primitive data types, so even when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    you can mutate their values through methods or direct property access.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的常量与许多其他语言中的常量不同，在那些语言中，常量是不可变的数据类型。在 JavaScript 中，常量仅仅是*看起来*不可变。实际上，它们是对其值的只读引用。因此，你不能直接为原始数据类型的变量标识符重新赋值。然而，对象或数组是非原始数据类型，因此即使使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>，你仍然可以通过方法或直接访问属性来修改它们的值。
- en: In [Listing 2-9](chapter2.xhtml#Lis2-9), we declare both a primitive and a non-primitive
    data type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    keyword and try to change their content.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 2-9](chapter2.xhtml#Lis2-9) 中，我们用 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    关键字声明了原始数据类型和非原始数据类型，并尝试修改它们的内容。
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 2-9: Using <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">const</samp>
    to declare primitive and non-primitive types'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-9：使用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">const</samp>
    声明原始类型和非原始类型
- en: We declare and assign a value to two constant-like data structures. Now when
    we try to reassign a value to the primitive data structure, the runtime throws
    the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Attempted to assign to
    readonly property</samp>. Because we used <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    we cannot reassign its value. In contrast, we can modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">nonPrimitiveDataType</samp>
    array (done here with the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    method) and append a value without running into an error. The array should now
    contain one item with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>;
    hence, we see <samp class="SANS_TheSansMonoCd_W5Regular_11">[1]</samp> in the
    console.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并为两个常量型数据结构赋值。当我们尝试重新为原始数据结构赋值时，运行时会抛出错误 <samp class="SANS_TheSansMonoCd_W5Regular_11">Attempted
    to assign to readonly property</samp>。由于我们使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>，我们无法重新赋值。相反，我们可以修改
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nonPrimitiveDataType</samp> 数组（这里使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> 方法）并追加一个值，而不会遇到错误。现在该数组应包含一个值为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 的项；因此，我们在控制台看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">[1]</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arrow Functions</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">箭头函数</samp>
- en: Modern JavaScript introduced arrow functions as alternatives to regular functions.
    There are two concepts you need to know about arrow functions. First, they use
    a different syntax than regular functions. Defining an arrow function is much
    quicker, requiring just a few characters and one line of code. The second important,
    but not so obvious, change is that they use something called a lexical scope,
    making them more intuitive and less error prone.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 引入了箭头函数，作为常规函数的替代方案。你需要了解箭头函数的两个概念。首先，它们使用与常规函数不同的语法。定义一个箭头函数要快得多，只需几个字符和一行代码。第二个重要但不那么明显的变化是它们使用被称为词法作用域的东西，使得箭头函数更加直观且不容易出错。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing Arrow Functions</samp>
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写箭头函数</samp>
- en: Instead of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">function</samp>
    keyword to declare an arrow function, we use the equal-to and greater-than signs
    to form an arrow (<samp class="SANS_TheSansMonoCd_W5Regular_11">=></samp>). This
    syntax, also called the *fat arrow*, reduces noise and results in more compact
    code. Therefore, modern JavaScript prefers this syntax when passing functions
    as arguments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用<samp class="SANS_TheSansMonoCd_W5Regular_11">function</samp>关键字来声明箭头函数，而是使用等号和大于号组成箭头（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=></samp>）。这种语法，也叫做*胖箭头*，减少了冗余，使代码更简洁。因此，现代
    JavaScript 在将函数作为参数传递时倾向于使用这种语法。
- en: In addition, if an arrow function has only one parameter and one statement,
    we can omit the curly brackets and the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    keyword. In this compact form, we call the function a *concise body* function.
    [Listing 2-10](chapter2.xhtml#Lis2-10) shows the definition of a traditional function
    followed by an arrow function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果一个箭头函数只有一个参数和一条语句，我们可以省略花括号和<samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>关键字。在这种紧凑的形式中，我们称该函数为*简洁函数体*函数。[列表
    2-10](chapter2.xhtml#Lis2-10) 显示了传统函数的定义，随后是箭头函数的定义。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 2-10: A traditional function and an arrow function with the concise
    body syntax'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-10：一个传统函数和一个具有简洁函数体语法的箭头函数
- en: We first define a standard function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">function</samp>
    keyword and familiar <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. Then we write the same functionality as an arrow function with the
    concise body syntax. Here we omit the curly brackets and use an implied <samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, without the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用<samp class="SANS_TheSansMonoCd_W5Regular_11">function</samp>关键字和常见的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句定义一个标准函数。然后，我们以简洁的函数体语法编写相同的功能。这里我们省略了花括号，使用隐式的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句，而不使用<samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>关键字。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding Lexical
    Scope</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理解词法作用域</samp>
- en: Unlike regular functions, arrow functions do not bind their scope to the object
    that calls the function. Instead, they use a *lexical scope*, in which the surrounding
    scope determines the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    keyword. Therefore, the scope to which <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    refers in an arrow function always represents the object *defining* the arrow
    function instead of the object *calling* the function. [Listing 2-11](chapter2.xhtml#Lis2-11)
    illustrates the concepts of lexical and defining scopes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规函数不同，箭头函数不会将它们的作用域绑定到调用函数的对象上。相反，它们使用一种*词法作用域*，其中周围的作用域决定了<samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>关键字的值。因此，在箭头函数中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">this</samp>所指代的作用域始终表示*定义*箭头函数的对象，而不是*调用*该函数的对象。[列表
    2-11](chapter2.xhtml#Lis2-11) 说明了词法作用域和定义作用域的概念。
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 2-11: An arrow function’s scope'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-11：箭头函数的作用域
- en: We first declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp>
    property on the lexical scope ❶; this is the defining object. Then we create an
    object with a property of the same name inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">defining
    scope</samp> ❷. Next, we define two functions, both of which use <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    to return the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">this.scope</samp>
    ❸.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在词法作用域❶上声明<samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp>属性；这是定义对象。然后我们在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">定义作用域</samp>❷内部创建一个具有相同名称属性的对象。接下来，我们定义两个函数，它们都使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">this</samp>来返回<samp class="SANS_TheSansMonoCd_W5Regular_11">this.scope</samp>的值❸。
- en: Upon calling them, you can see the difference between the two references. Whereas
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this.scope</samp> in the arrow function
    refers to the property defined in the lexical scope, the traditional function’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> refers to the second
    property we defined. Consequently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">scopeOf.traditional</samp>
    function outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">defining scope</samp>,
    whereas the <samp class="SANS_TheSansMonoCd_W5Regular_11">scopeOf.arrow</samp>
    function outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">lexical scope</samp>.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用它们时，您可以看到两者引用之间的区别。箭头函数中的<samp class="SANS_TheSansMonoCd_W5Regular_11">this.scope</samp>指的是词法作用域中定义的属性，而传统函数的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">this</samp>指的是我们定义的第二个属性。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">scopeOf.traditional</samp>函数输出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">定义作用域</samp>，而<samp class="SANS_TheSansMonoCd_W5Regular_11">scopeOf.arrow</samp>函数输出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">词法作用域</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Practical
    Use Cases</samp>
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">探索实际应用场景</samp>
- en: Because functions are first-class citizens in JavaScript, we can pass them as
    arguments to other functions. In [Chapter 1](chapter1.xhtml), you used this pattern
    to define callbacks in Node.js or previously when you worked with event handlers
    in the browser. But when you use regular functions as callbacks, the code quickly
    gets cluttered with function statements and curly brackets, even if the actual
    code in the callback is quite simple. Arrow functions allow for a clean and simple
    syntax in callbacks. In [Listing 2-12](chapter2.xhtml#Lis2-12), we use a callback
    on the array <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp> method
    and define it as a traditional function and as an arrow function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是 JavaScript 中的头等公民，我们可以将它们作为参数传递给其他函数。在[第1章](chapter1.xhtml)中，您使用这种模式在
    Node.js 中定义回调，或者之前在浏览器中处理事件处理程序时也使用过。当您将常规函数作为回调时，即使回调中的实际代码非常简单，代码也会迅速被函数语句和花括号弄得杂乱无章。箭头函数在回调中提供了干净简洁的语法。在[列表
    2-12](chapter2.xhtml#Lis2-12)中，我们使用回调来处理数组的<samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>方法，并将其定义为传统函数和箭头函数。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 2-12: Passing a fat arrow function as a parameter'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-12：将胖箭头函数作为参数传递
- en: 'The first version of the callback is a traditional function, whereas the second
    implementation uses an arrow function with a concise body syntax. Both return
    the same array: <samp class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2]</samp>.
    We see that the actual functionality, to remove all negative numbers from the
    array, is a simple check to see if the current item is greater than or equal to
    zero. The traditional function is harder to understand, as it requires additional
    characters. Once you fully grasp the arrow syntax, you’ll enhance the readability
    of your code and, in turn, improve the code quality.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回调的第一个版本是传统函数，而第二个实现使用了具有简洁主体语法的箭头函数。两者都返回相同的数组：<samp class="SANS_TheSansMonoCd_W5Regular_11">[0,
    1, 2]</samp>。我们看到，实际功能是从数组中删除所有负数，这只是简单地检查当前项是否大于或等于零。传统函数较难理解，因为它需要额外的字符。一旦您完全掌握箭头语法，您将提高代码的可读性，从而提升代码质量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating Strings</samp>
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建字符串</samp>
- en: Modern JavaScript introduces untagged and tagged template literals. *Template
    literals* are a simple way to add variables and expressions to a string. This
    string interpolation can span multiple lines and include single and double quotation
    marks without requiring escaping. We enclose template literals in backticks (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">`</samp>) and indicate a variable or expression
    in the template by using a dollar sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>)
    and curly brackets.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 引入了未标记和标记的模板字面量。*模板字面量* 是一种简单的方法，可以将变量和表达式添加到字符串中。这个字符串插值可以跨越多行，并且可以包含单引号和双引号，而无需进行转义。我们使用反引号
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">`</samp>) 将模板字面量括起来，并使用美元符号 (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">$</samp>) 和大括号来表示模板中的变量或表达式。
- en: An *untagged* template literal is just a string enclosed in backticks. The parser
    interpolates the variables and expressions and returns a string. As a full-stack
    developer, you’ll use this pattern every time you want to add variables to a string
    or concatenate multiple strings. [Listing 2-13](chapter2.xhtml#Lis2-13) shows
    an example of an untagged template literal. They can span multiple lines without
    the need for any control characters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*未标记* 模板字面量只是一个用反引号括起来的字符串。解析器会进行变量和表达式的插值并返回一个字符串。作为全栈开发者，每次需要将变量添加到字符串中或连接多个字符串时，你都会使用这种模式。[清单
    2-13](chapter2.xhtml#Lis2-13)展示了一个未标记模板字面量的示例。它们可以跨越多行，而无需任何控制字符。'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 2-13: An untagged template literal'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-13：一个未标记的模板字面量
- en: The parser will substitute the placeholders and evaluate the expression in the
    template literal to the string <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器会替换占位符并计算模板字面量中的表达式，结果是字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>。
- en: As soon as an expression precedes a template literal, it becomes *tagged*. In
    these cases, the function receives both a template literal and the substitution
    values as arguments and then performs an action with both of them before returning
    a value. This returned value can be of any primitive or non-primitive type. In
    [Listing 2-14](chapter2.xhtml#Lis2-14), we use a tagged template literal with
    a custom function to add or subtract numbers and explain the process using words.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个表达式出现在模板字面量之前，它就变成了*标记模板字面量*。在这些情况下，函数接收模板字面量和替换值作为参数，然后对它们进行处理并返回一个值。这个返回值可以是任何原始类型或非原始类型。在[清单
    2-14](chapter2.xhtml#Lis2-14)中，我们使用带有自定义函数的标记模板字面量来加减数字，并通过文字解释这个过程。
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 2-14: A basic tagged template literal'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-14：一个基础的标记模板字面量
- en: Here the parser calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">tag</samp>
    expression and then passes the template literal and substitution values as arguments
    to the function. The function constructs a string from the parameters and returns
    it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，解析器调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">tag</samp> 表达式，然后将模板字面量和替换值作为参数传递给函数。该函数根据这些参数构建字符串并返回它。
- en: 'Let’s take a deeper look at our code. In our <samp class="SANS_TheSansMonoCd_W5Regular_11">tag</samp>
    expression, the first argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">literal</samp>,
    is an array that is split at the variables, like this: <samp class="SANS_TheSansMonoCd_W5Regular_11">[''What
    is '', '' minus '', ''?'']</samp>. The argument <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    is also an array, and it contains the values of the template literal variables
    we passed to the function: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2]</samp>.
    We use a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">switch/case</samp>
    statement to calculate the result based on the literal and values. Finally, we
    return a new string with the answer to the “question” and see <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    plus 2 is 3</samp> on the console.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看我们的代码。在我们的<samp class="SANS_TheSansMonoCd_W5Regular_11">tag</samp>表达式中，第一个参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">literal</samp>是一个数组，数组在变量处被分割，如下所示：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">['What is ', ' minus ', '?']</samp>。参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">value</samp>也是一个数组，包含我们传递给函数的模板字面量变量的值：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[1, 2]</samp>。我们使用一个简单的<samp class="SANS_TheSansMonoCd_W5Regular_11">switch/case</samp>语句来根据字面量和数值计算结果。最后，我们返回一个新字符串，显示“问题”的答案，并在控制台上看到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1 plus 2 is 3</samp>。
- en: With their simple interface for complex string substitutions, tagged template
    literals provide an elegant way to create a *domain-specific language (DSL)* in
    JavaScript. A DSL is a language targeted to solve a particular task in a particular
    domain. It’s in contrast to a general-purpose language, such as JavaScript, which
    we can use to solve a wide array of software-related problems. A familiar example
    of a DSL is HTML, which we use in the web development domain to mark up text but
    which we cannot use for mathematical operations or reading file contents. You
    will define your own DSL for full-stack development with GraphQL schemas. When
    you define your first GraphQL schema in [Chapter 6](chapter6.xhtml), you’ll understand
    that its DSL is nothing more than a tagged template literal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其简洁的界面来进行复杂的字符串替换，标签模板字面量为在 JavaScript 中创建*领域特定语言（DSL）*提供了一种优雅的方法。DSL 是一种针对特定领域中解决某一任务的语言。与之相对的是通用语言，比如
    JavaScript，我们可以用它来解决各种软件相关问题。一个常见的 DSL 示例是 HTML，它用于 web 开发领域标记文本，但我们不能用它进行数学运算或读取文件内容。你将为全栈开发定义自己的
    DSL，通过 GraphQL 模式。在[第6章](chapter6.xhtml)中定义第一个 GraphQL 模式时，你会明白它的 DSL 其实不过是一个标签模板字面量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Asynchronous Scripts</samp>
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">异步脚本</samp>
- en: JavaScript is single-threaded, which means that it can run only one task at
    a time. Therefore, long-running tasks can block the application. A simple solution
    is *asynchronous* programming, a pattern where you start a long-running task without
    blocking the whole application. While your script waits for a result, the rest
    of the application can still respond to interactions or user interface events
    and perform other calculations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是单线程的，这意味着它一次只能执行一个任务。因此，长时间运行的任务可能会阻塞应用程序。一种简单的解决方案是*异步*编程，这是一种在不阻塞整个应用程序的情况下启动长时间运行任务的模式。当你的脚本等待结果时，应用程序的其余部分仍然可以响应交互或用户界面事件并执行其他计算。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Avoiding Traditional
    Callbacks</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">避免传统的回调函数</samp>
- en: Traditional JavaScript implements asynchronous code with callback functions
    executed after another function returns a result. You’ve probably already used
    callbacks when your code has needed to react to an event instead of running immediately.
    One common use case for this technique in full-stack web development is performing
    I/O operations in Node.js or calling remote APIs. [Listing 2-15](chapter2.xhtml#Lis2-15)
    provides an example of an I/O operation. We import the Node.js <samp class="SANS_TheSansMonoCd_W5Regular_11">fs</samp>
    module, which handles filesystem operations, and use a callback function to display
    the file’s contents as soon as the operation concludes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 JavaScript 使用回调函数来实现异步代码，在另一个函数返回结果后执行回调函数。你可能已经在需要对事件作出反应而不是立即执行代码时使用过回调函数。这种技术在全栈
    web 开发中的一个常见使用场景是执行 Node.js 中的 I/O 操作或调用远程 API。[列表 2-15](chapter2.xhtml#Lis2-15)提供了一个
    I/O 操作的示例。我们导入 Node.js 的<samp class="SANS_TheSansMonoCd_W5Regular_11">fs</samp>模块，它处理文件系统操作，并使用回调函数在操作完成后立即显示文件内容。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 2-15: Reading a file in Node.js with a callback function'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-15：使用回调函数在 Node.js 中读取文件
- en: Reading a file is a common example of asynchronous scripting. We don’t want
    the application to be blocked while waiting for the file content to be ready;
    however, we also need to use the file’s content in a specific part of the application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件是异步脚本的一个常见示例。我们不希望在等待文件内容准备好时应用程序被阻塞；但是，我们也需要在应用程序的特定部分使用文件内容。
- en: Here we create the callback function and pass it as a parameter to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fs.readFile</samp> function. This function
    reads a file from the filesystem and executes the callback as soon as the I/O
    operation fails or succeeds. The callback receives the file data and an optional
    error object, which we write to the console for now.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建回调函数并将其作为参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">fs.readFile</samp>
    函数。此函数从文件系统中读取文件，并在 I/O 操作失败或成功时执行回调。回调接收文件数据和一个可选的错误对象，暂时将其写入控制台。
- en: Callbacks are a clumsy solution to asynchronous scripting. As soon as you have
    multiple dependent callback functions, you end up in so-called callback hell,
    where every callback function takes another callback function as an argument.
    The result is a pyramid of functions that are difficult to read and prone to errors.
    Modern JavaScript introduced promises and <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> as an alternative to callbacks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数是处理异步脚本的一个笨重解决方案。一旦你有多个依赖回调函数，就会陷入所谓的回调地狱，在这种情况下，每个回调函数都将另一个回调函数作为参数。结果就是一个难以阅读、容易出错的函数金字塔。现代
    JavaScript 引入了 promises 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp>，作为回调函数的替代方案。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Promises</samp>
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 Promises</samp>
- en: '*Promises* provide a much cleaner syntax for chainable asynchronous tasks.
    Similar to callbacks, they defer further tasks until a previous action has completed
    or failed. Essentially, promises are function calls that do not return an immediate
    result. Instead, they promise to return the result at some later point. If there
    is an error, the promise is rejected instead of resolved.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*Promises* 提供了一个更简洁的语法，用于链式异步任务。与回调类似，它们会将后续任务推迟，直到前一个操作完成或失败。实际上，promises
    是不立即返回结果的函数调用。相反，它们承诺在稍后的某个时间点返回结果。如果发生错误，promise 会被拒绝，而不是被解决。'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp> object has
    two properties: the state and the result. When the state is pending, the result
    is undefined. However, as soon as the promise resolves, the state changes to fulfilled,
    and the result reflects the return value. If the promise is rejected instead,
    the state is also set to rejected, and the result contains an error object.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp> 对象有两个属性：状态和结果。当状态为
    pending 时，结果是未定义的。然而，一旦 promise 被解决，状态会变为 fulfilled，结果会反映返回值。如果 promise 被拒绝，状态也会设置为
    rejected，结果将包含一个错误对象。
- en: Promises follow a unique syntax. To use them, you first create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp>
    or call a function that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp>.
    Then you consume the <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp>
    object, and finally you clean up. This is done by registering the consuming functions
    <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp>. The promise
    initially calls <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> as soon
    as the state changes from pending to fulfilled and passes the returned data to
    it. Each following <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> method
    receives the return value of the previous one, allowing you to create a single
    task chain that works with and manipulates these return values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 遵循独特的语法规则。要使用它们，首先需要创建一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp>，或者调用返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp> 的函数。然后你消费这个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp> 对象，最后进行清理。清理工作通过注册消费函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp> 来完成。当状态从待处理变为已完成时，Promise
    最初会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> 并将返回的数据传递给它。随后的每个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> 方法都接收前一个方法的返回值，这样你就可以创建一个任务链来处理和操作这些返回值。
- en: The promise chain invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>
    method only if an error occurs either initially or later in the chain of tasks.
    In addition, a state change (of this particular promise) to <samp class="SANS_TheSansMonoCd_W5Regular_11">rejected</samp>
    also invokes it. In any case, the parser calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp>
    method after the stack of <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>
    methods has completed or the <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>
    method was invoked. You use the <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp>
    method for cleanup tasks such as unlocking the user interface or closing database
    connections. It’s similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp>
    call of a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> statement.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 链仅在任务链中的某个地方发生错误时才会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>
    方法，或者在此 Promise 状态变化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">rejected</samp>
    时也会触发它。在任何情况下，解析器会在所有 <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>
    方法完成或 <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp> 方法被调用之后，调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">finally</samp> 方法。你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp>
    方法来进行清理工作，比如解锁用户界面或关闭数据库连接。它类似于 <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>
    语句中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp> 调用。
- en: You can use promises in any function. In [Listing 2-16](chapter2.xhtml#Lis2-16),
    we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API
    to request JSON data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何函数中使用 Promise。在 [列表 2-16](chapter2.xhtml#Lis2-16) 中，我们使用原生的 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API 请求 JSON 数据。
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 2-16: Fetching remote data with promises'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-16：使用 Promise 获取远程数据
- en: Like I/O operations on the filesystem, network requests are long-running tasks
    that block the application. Therefore, we should use asynchronous patterns to
    load remote datasets. As in [Listing 2-15](chapter2.xhtml#Lis2-15), we need to
    wait until the operation is complete before we can process the requested data
    or handle an error.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件系统上的 I/O 操作类似，网络请求是长期运行的任务，会阻塞应用程序。因此，我们应当使用异步模式来加载远程数据集。如 [列表 2-15](chapter2.xhtml#Lis2-15)
    所示，我们需要等待操作完成后，才能处理请求的数据或处理错误。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API is promise-based
    by default. As soon as the promise resolves and the state changes to fulfilled,
    the following <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> function
    receives the response object. We then parse the data and pass the JSON object
    to the next function in the *promise chain*, a sequence of functions connected
    with a dot (<samp class="SANS_TheSansMonoCd_W5Regular_11">.then</samp>). If there
    is an error, the promise is rejected. In this case, we <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>
    the error and write it to the console.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API 默认是基于 Promise
    的。只要 Promise 解决并且状态变为 fulfilled，接下来的 <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>
    函数就会接收到响应对象。我们接着解析数据，并将 JSON 对象传递给下一个函数，这个函数位于 *Promise 链* 中，这是由点（<samp class="SANS_TheSansMonoCd_W5Regular_11">.then</samp>）连接的函数序列。如果出现错误，Promise
    会被拒绝。在这种情况下，我们会 <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp> 错误并将其输出到控制台。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simplifying Asynchronous
    Scripts</samp>
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">简化异步脚本</samp>
- en: 'Modern JavaScript introduces a new, simpler pattern for handling asynchronous
    requests: the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> keywords. Instead of relying
    on chained functions, we can write code whose structure is similar to regular
    synchronous code by employing these keywords.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 引入了一种新的、更简单的模式来处理异步请求：<samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> 关键字。我们不再依赖链式函数，而是通过使用这些关键字编写与常规同步代码结构相似的代码。
- en: When using this pattern, you mark functions explicitly as asynchronous with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>. Then you use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> instead of the promise-based
    syntax for your asynchronous code. In [Listing 2-17](chapter2.xhtml#Lis2-17),
    we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    to perform another long-running task and fetch JSON data from a remote location.
    This code is functionally the same as [Listing 2-16](chapter2.xhtml#Lis2-16),
    and you should see that its syntax is more intuitive and cleaner than the chain
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> calls.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式时，你需要显式地将函数标记为异步函数，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>。然后，你使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>，而不是基于 Promise 的语法来处理异步代码。在[示例
    2-17](chapter2.xhtml#Lis2-17)中，我们使用本地的 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API 配合 <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    来执行另一个长时间运行的任务，并从远程位置获取 JSON 数据。此代码在功能上与[示例 2-16](chapter2.xhtml#Lis2-16)相同，你会发现它的语法比一系列
    <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> 调用更直观、更简洁。
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 2-17: Fetching remote data with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">await</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-17：使用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">await</samp> 获取远程数据
- en: First we declare the function as <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>
    to enable the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> keyword
    inside the function. Then we use <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    to wait for the response of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    call. Unlike the promise syntax we used before, <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    simplifies the code. It awaits the response object and returns it. Thus, the code
    block looks similar to regular synchronous code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将函数声明为 <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>，以启用函数内部的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> 关键字。然后，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    来等待 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> 调用的响应。与我们之前使用的
    Promise 语法不同，<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> 简化了代码。它等待响应对象并返回它。因此，代码块看起来与常规的同步代码相似。
- en: This pattern requires us to handle errors manually. Unlike with promises, there
    is no default reject function. Therefore, we must wrap <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    statements in a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>
    block to handle error states gracefully.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式要求我们手动处理错误。与 Promise 不同，这里没有默认的拒绝函数。因此，我们必须将<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>语句包裹在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>块中，以优雅地处理错误状态。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Looping Through an Array</samp>
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">遍历数组</samp>
- en: Modern JavaScript introduced a whole set of new array functions. The most important
    one for full-stack web development is <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>.
    It allows us to run a function on each array item and return a new array with
    the modified items, preserving the original array. Developers commonly use it
    in React to generate a list or populate JSX with datasets from arrays. You will
    use this pattern extensively once we introduce React in [Chapter 4](chapter4.xhtml).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 引入了一整套新的数组函数。对于全栈 Web 开发，最重要的一个是<samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>。它允许我们对每个数组项执行一个函数，并返回一个包含修改后项的新数组，同时保留原始数组。开发人员通常在
    React 中使用它来生成列表或使用数组中的数据集填充 JSX。我们将在[第 4 章](chapter4.xhtml)引入 React 后，你将广泛使用这种模式。
- en: In [Listing 2-18](chapter2.xhtml#Lis2-18), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    to iterate over an array of numbers and create an arrow function as a callback.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 2-18](chapter2.xhtml#Lis2-18)中，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>来遍历一个数字数组，并创建一个箭头函数作为回调函数。
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 2-18: Using <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">array.map</samp>
    to manipulate each item of an array'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-18：使用<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">array.map</samp>来操作数组的每一项
- en: We iterate over the array items and pass each of them to the callback function.
    Here we multiply each item by 10, and then <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    returns an array with the multiplied items.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历数组中的每一项，并将它们传递给回调函数。在这里，我们将每个元素乘以10，然后<samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>返回一个包含乘法结果的新数组。
- en: When we log the initial array and the returned array, we see that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">original</samp> array still contains the
    actual, unchanged numbers (<samp class="SANS_TheSansMonoCd_W5Regular_11">1,2,3,4</samp>).
    Only the <samp class="SANS_TheSansMonoCd_W5Regular_11">multiplied</samp> array
    contains the new, modified items (<samp class="SANS_TheSansMonoCd_W5Regular_11">10,20,30,40</samp>).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们记录初始数组和返回的数组时，我们会看到<samp class="SANS_TheSansMonoCd_W5Regular_11">原始</samp>数组仍然包含实际的、未更改的数字（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1,2,3,4</samp>）。只有<samp class="SANS_TheSansMonoCd_W5Regular_11">乘法</samp>数组包含新的、已修改的项（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">10,20,30,40</samp>）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dispersing Arrays and Objects</samp>
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">分散数组和对象</samp>
- en: Modern JavaScript’s spread operator is written as three dots (<samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>).
    It *spreads out*, or expands, the values of an array or the properties of an object
    into their own variables or constants.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 的展开运算符用三个点（<samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>）表示。它*展开*了数组的值或对象的属性，将它们扩展到各自的变量或常量中。
- en: Technically, the spread operator copies its content to variables that allocate
    their own memory. In [Listing 2-19](chapter2.xhtml#Lis2-19), we use the spread
    operator to assign the multiple values of an object to several constants. You’ll
    use this pattern in nearly all React code to access component properties.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，展开运算符将其内容复制到为各自分配内存的变量中。在[示例 2-19](chapter2.xhtml#Lis2-19)中，我们使用展开运算符将对象的多个值赋给多个常量。在几乎所有的
    React 代码中，你都会使用这种模式来访问组件属性。
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 2-19: Dispersing an object into constants with the spread operator'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-19：使用展开运算符将对象分散到常量中
- en: 'We first create an object with two properties, <samp class="SANS_TheSansMonoCd_W5Regular_11">fruit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>. Then we use the
    spread operator to expand the object into variables and log them to the console.
    The variables’ names are the same as the object properties’ names. However, we
    can now access the values directly from the variables instead of referring to
    the object. We do so in the template literal and see <samp class="SANS_TheSansMonoCd_W5Regular_11">fruit:
    apple, color: green</samp> as the console output.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '我们首先创建一个包含两个属性的对象，<samp class="SANS_TheSansMonoCd_W5Regular_11">fruit</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>。然后我们使用扩展运算符将对象展开为变量，并将它们打印到控制台。变量的名称与对象属性的名称相同。然而，现在我们可以直接通过变量访问这些值，而不需要引用对象。我们在模板字面量中这样做，并看到控制台输出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fruit: apple, color: green</samp>。'
- en: 'Also, as these variables allocate their own memory, they are complete clones.
    Therefore, modifying the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp> won’t change the original
    value: <samp class="SANS_TheSansMonoCd_W5Regular_11">object.color</samp> still
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp> when we log
    both variables to the console.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于这些变量分配了自己的内存，因此它们是完整的克隆。因此，将变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    修改为 <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp> 不会改变原始值：<samp class="SANS_TheSansMonoCd_W5Regular_11">object.color</samp>
    在我们将两个变量打印到控制台时仍然返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp>。
- en: Using the spread operator to clone an array or object is useful because JavaScript
    treats arrays as references to its values. When you assign an array or object
    to a new variable or constant, this merely copies the reference to the original;
    it does not clone the array or object by allocating memory. Therefore, changing
    the copy also changes the original. Using spread instead of the equals operator
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) allocates memory and
    keeps no reference to the original value. Hence, it’s an excellent solution for
    cloning an array or object, as shown in [Listing 2-20](chapter2.xhtml#Lis2-20).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展运算符克隆数组或对象非常有用，因为 JavaScript 将数组视为对其值的引用。当你将一个数组或对象赋值给一个新变量或常量时，这仅仅是复制了对原始数组或对象的引用，并没有通过分配内存来克隆数组或对象。因此，修改副本也会改变原始值。使用扩展运算符代替等号操作符
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) 会分配内存并不再保持对原始值的引用。因此，它是克隆数组或对象的一个极好解决方案，如[列表
    2-20](chapter2.xhtml#Lis2-20)所示。
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 2-20: Cloning an array with the spread operator'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-20：使用扩展运算符克隆数组
- en: Here we use the spread operator to copy the values from the original array to
    the cloned array in the same operation. Then we modify the cloned array’s items.
    Finally, we write the two arrays to the console and see that the original array
    differs from the cloned array.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用扩展运算符将原始数组的值复制到克隆数组中，并修改克隆数组的项。最后，我们将这两个数组输出到控制台，看到原始数组与克隆数组有所不同。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 2: Extend Express.js with
    Modern JavaScript</samp>'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 2：用现代 JavaScript 扩展 Express.js</samp>
- en: Modern JavaScript provides the tools you need to write clean and efficient code.
    In [Part II](part2.xhtml), you’ll use it in the Food Finder application. For now,
    let’s apply your new knowledge to optimize the simple Express.js server you created
    in [Chapter 1](chapter1.xhtml).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 提供了编写干净且高效代码所需的工具。在[第二部分](part2.xhtml)中，你将在“食品查找器”应用程序中使用这些工具。现在，让我们将你新学到的知识应用到优化你在[第
    1 章](chapter1.xhtml)中创建的简单 Express.js 服务器上。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Editing the package.json
    File</samp>
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编辑 package.json 文件</samp>
- en: We’ll replace the server’s <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    call with named modules for different routes. To do so, we need to explicitly
    specify that our project uses native modules. Otherwise, Node.js will throw an
    error. Modify your *package.json* file so that it looks like [Listing 2-21](chapter2.xhtml#Lis2-21).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用命名模块替换服务器的 <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    调用，用于不同的路由。为此，我们需要明确指定我们的项目使用本地模块，否则，Node.js 会抛出错误。修改你的 *package.json* 文件，使其看起来像[列表
    2-21](chapter2.xhtml#Lis2-21)。
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 2-21: The modified package.json file'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-21：修改后的 package.json 文件
- en: Add the property <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> with
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">module</samp>. Also, you’ll
    want to install the *node-fetch* package to make an asynchronous API call in one
    of your routes. Run <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install
    node-fetch</samp> to do so.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 添加属性<samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>，值为<samp class="SANS_TheSansMonoCd_W5Regular_11">module</samp>。另外，您需要安装*node-fetch*包，以便在某个路由中进行异步API调用。运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">npm install node-fetch</samp>来实现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing an ES.Next
    Module with Asynchronous Code</samp>
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写具有异步代码的ES.Next模块</samp>
- en: Create the file *routes.js* in the *sample-express* folder, next to the *index.js*
    file, and add the code in [Listing 2-22](chapter2.xhtml#Lis2-22).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在*sample-express*文件夹中创建文件*routes.js*，与*index.js*文件位于同一目录，并添加[清单2-22](chapter2.xhtml#Lis2-22)中的代码。
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 2-22: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">route</samp>
    module in the routes.js file'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-22：routes.js文件中的<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">route</samp>模块
- en: First we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    module for making asynchronous requests. Then we create the first route, for our
    existing */hello* endpoint. Its behavior should be the same as before; using a
    fat arrow function with a concise body syntax, it returns the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World!</samp>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入<samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>模块，以进行异步请求。接着我们创建第一个路由，处理我们现有的*/hello*端点。其行为应与之前相同；使用简洁的箭头函数语法，它返回字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
- en: Next, we create a route for a new */api/names* endpoint. This endpoint will
    add a page to our web server displaying a list of usernames and IDs. But first
    we explicitly define an <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>
    function so that we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    syntax for our <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> call.
    Then we define the API endpoint in a constant and another variable to store asynchronous
    data. We need to define these before we use them because the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    calls happen inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>
    block, and these variables are block-scoped. If we defined them inside the block,
    we wouldn’t be able to use them later.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为新的*/api/names*端点创建一个路由。这个端点将向我们的Web服务器添加一个页面，显示用户名和ID的列表。但首先，我们显式定义一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">async</samp>函数，以便我们可以在<samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>调用中使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp>语法。然后我们在常量中定义API端点，并使用另一个变量存储异步数据。我们需要在使用它们之前定义这些变量，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp>调用发生在<samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>块内，而这些变量是块作用域的。如果我们在块内定义它们，后续将无法使用。
- en: We call the API and await the response data, which we convert to JSON as soon
    as the call succeeds. The <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    variable now holds an array of objects. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    to iterate over the data and create the strings we want to display. Then we join
    all array items with break tags (<samp class="SANS_TheSansMonoCd_W5Regular_11"><br></samp>)
    to display them in rows and return the string.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用API并等待响应数据，当调用成功时，我们立即将数据转换为JSON。<samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>变量现在保存的是一个对象数组。我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>来遍历数据，并创建我们想要显示的字符串。然后我们用换行标签(<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><br></samp>)将所有数组项连接起来，并返回该字符串。
- en: Finally, we export the two routes under their names.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据路由名称导出这两个路由。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Modules
    to the Server</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将模块添加到服务器</samp>
- en: Modify the file *index.js* in the *sample-express* folder to match [Listing
    2-23](chapter2.xhtml#Lis2-23). We use native modules for importing the <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    module and the routes we created in [Listing 2-22](chapter2.xhtml#Lis2-22).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 修改*index.js*文件，位于*sample-express*文件夹中，使其与[清单2-23](chapter2.xhtml#Lis2-23)匹配。我们使用原生模块导入`require`模块，以及我们在[清单2-22](chapter2.xhtml#Lis2-22)中创建的路由。
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 2-23: The basic Express.js server with modern JavaScript'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-23：使用现代JavaScript的基本Express.js服务器
- en: First we import <samp class="SANS_TheSansMonoCd_W5Regular_11">routes</samp>
    with the syntax for named imports. Then we replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    call for the *express* package with an <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    statement. The */hello* endpoint we created earlier calls the route we imported,
    and the server sends <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    as the response to the browser.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用命名导入的语法导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">routes</samp>。然后，我们用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> 语句替代了对 *express* 包的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp> 调用。我们之前创建的 */hello*
    端点调用了我们导入的路由，服务器向浏览器发送了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    作为响应。
- en: Finally, we create a new endpoint, */api/names*, that contains asynchronous
    code. Therefore, we mark the handler as *async* and await the route inside a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> block.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个新的端点 */api/names*，其中包含异步代码。因此，我们将处理程序标记为 *async*，并在 <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>
    块中等待路由。
- en: 'Start the server from your command line:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行启动服务器：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now visit *http://localhost:3000/api/names* in your browser, as shown in [Figure
    2-1](#fig2-1).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中访问 *http://localhost:3000/api/names*，如 [图 2-1](#fig2-1) 所示。
- en: '![](../images/Figure2-1.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 2-1: The response the
    browser receives from the Node.js web server</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 2-1：浏览器从 Node.js Web 服务器接收到的响应</samp>
- en: You should see the new list of user IDs and names.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到新的用户 ID 和姓名列表。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter taught you enough modern JavaScript and ES.Next to create a full-stack
    application. We covered how to use JavaScript modules to create maintainable packages
    and import and export code, the different ways to declare variables and constants,
    the arrow function, and tagged and untagged template literals. We wrote asynchronous
    code with promises and <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp>. We also covered <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>,
    the spread operator, and their usefulness for your full-stack code. Finally, you
    used your new knowledge to update the sample Node.js server from [Chapter 1](chapter1.xhtml)
    with modern JavaScript concepts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教会了你足够的现代 JavaScript 和 ES.Next 知识，以便创建一个全栈应用程序。我们涵盖了如何使用 JavaScript 模块创建可维护的包，并导入和导出代码，声明变量和常量的不同方式，箭头函数，以及带标签和不带标签的模板字面量。我们使用
    Promise 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    编写了异步代码。我们还涵盖了 <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>、展开运算符及其在全栈代码中的实用性。最后，你使用新学到的知识更新了
    [第 1 章](chapter1.xhtml) 中的示例 Node.js 服务器，加入了现代 JavaScript 概念。
- en: Modern JavaScript has many more features than this chapter covers. From the
    freely available resources, I recommend the JavaScript tutorials at [*https://<wbr>www<wbr>.javascripttutorial<wbr>.net*](https://www.javascripttutorial.net).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 有许多本章未涵盖的功能。根据公开的资源，我推荐 [*https://<wbr>www<wbr>.javascripttutorial<wbr>.net*](https://www.javascripttutorial.net)
    上的 JavaScript 教程。
- en: In the next chapter, we cover TypeScript, a superset of JavaScript with support
    for types.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将介绍 TypeScript，这是 JavaScript 的超集，支持类型。
