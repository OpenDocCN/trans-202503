- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Serial Output on the STM
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: STM的串行输出
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: We’re now back to “Hello World,” only this time we’ll use our Nucleo board,
    which presents several challenges. The first is where to write the message. There
    is no display. Fortunately, the chip has a serial port that’s nicely connected
    to a USB/serial port on the top half of the board.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在回到“Hello World”，这一次我们将使用我们的Nucleo开发板，这带来了一些挑战。第一个挑战是在哪里写入信息。板上没有显示屏。幸运的是，芯片上有一个串行端口，且与开发板上部的USB/串行端口连接良好。
- en: The next challenge is the writing itself. We need to initialize the device and
    create a procedure to actually write a character. The device is designed to accept
    one character at a time, and we must keep that limitation in mind when writing
    our program.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个挑战是编写程序本身。我们需要初始化设备，并创建一个实际写入字符的过程。设备设计为一次接受一个字符，在编写程序时，我们必须牢记这一限制。
- en: We’ll simulate the process before working with the device. C has a great deal
    of standard functions, such as `puts`, that make outputting data easy. The Nucleo
    board doesn’t have such nice features, so we must write our own output functions.
    In order to transition into the low-level coding we need for the Nucleo, we’ll
    write out “Hello World” one character at a time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在与设备交互之前模拟这个过程。C语言提供了很多标准函数，例如`puts`，使得输出数据变得非常简单。然而，Nucleo开发板没有这么方便的功能，所以我们必须编写自己的输出函数。为了过渡到适用于Nucleo的低级编码，我们将一次写入一个字符，输出“Hello
    World”。
- en: Writing a String One Character at a Time
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次写入一个字符的字符串
- en: When a C program calls the standard `puts` function, it starts a long programming
    process that involves kernel calls, internal buffering, interrupt scheduling,
    and device drivers (more on those in the next chapter). Ultimately, it reaches
    the point where it sends one character at a time to the device. To simulate this,
    we’ll send one character at a time to the operating system. In other words, we’ll
    limit ourselves to using only the standard `putchar` function to write the output.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当C程序调用标准的`puts`函数时，它会启动一个涉及内核调用、内部缓冲、Interrupt调度和设备驱动的长过程（下一章会详细介绍这些内容）。最终，它会到达一个阶段，开始一次发送一个字符到设备。为了模拟这一过程，我们将一次发送一个字符到操作系统。换句话说，我们将限制自己只使用标准的`putchar`函数来写入输出。
- en: '[Listing 9-1](#listing9-1) contains a program that writes out `"Hello World\n"`
    the hard way. Again, we’re doing this the hard way because later, with the Nucleo
    board, we’re going to have to do it the *really* hard way.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 9-1](#listing9-1)包含了一个以“艰难的方式”写出`"Hello World\n"`的程序。再次强调，我们这样做是因为在接下来的Nucleo板使用中，我们将不得不以*真正*艰难的方式来做。'
- en: '**putchar.c**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**putchar.c**'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: Writing a string one character at a time*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-1: 一次写入一个字符的字符串*'
- en: The only interesting piece in this program is the `for` loop 1, which does not
    stop after a certain number of characters. Instead, it stops when the program
    reaches the end-of-string (`'\0'`) character. That way, the program can output
    any length of string.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序中唯一有趣的部分是`for`循环1，它不会在达到一定字符数后停止。相反，它会在程序遇到字符串结尾字符（`'\0'`）时停止。这样，程序就可以输出任意长度的字符串。
- en: Defining Our Own putchar
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义我们自己的putchar
- en: To improve this program, first we’ll make `curChar` a local variable. Then we’ll
    define a function called `myPutchar` that sends the character to standard out
    (see [Listing 9-2](#listing9-2)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这个程序，首先我们将把`curChar`定义为局部变量。然后我们将定义一个名为`myPutchar`的函数，将字符发送到标准输出（参见[Listing
    9-2](#listing9-2)）。
- en: '**my_putchar.c**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**my_putchar.c**'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-2: One character at a time using our own output function*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-2: 使用我们自己的输出函数一次写一个字符*'
- en: At the beginning of `myPutchar`, we’ve added some additional elements 1 to the
    comment block. The keyword `@param` indicates a parameter, and the `@note` keyword
    defines a note. You can use lots of other keywords in Doxygen-style comments,
    but for now we’ll use the basics to be compatible with the existing STM code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`myPutchar`的开始部分，我们向注释块中添加了一些附加元素。关键字`@param`表示参数，`@note`关键字定义了一个注释。你可以在Doxygen风格的注释中使用许多其他关键字，但目前我们只使用基础内容，以便与现有的STM代码兼容。
- en: The actual function starts with the `void myPutchar(const char ch)` declaration
    2, which indicates that the `myPutchar` procedure returns nothing and takes one
    parameter of type `char`. The `const` modifier indicates that we don’t change
    it inside the procedure. (In fact, we can’t change it, because if we try, the
    compiler will generate an error.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的函数从`void myPutchar(const char ch)`声明开始 2，这表明`myPutchar`过程不返回任何值，并且接受一个类型为`char`的参数。`const`修饰符表示我们在过程内部不会修改它。（实际上，我们不能修改它，因为如果我们尝试，编译器会报错。）
- en: 'When the procedure is executed 4, the program performs the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行该过程时 4，程序将执行以下步骤：
- en: It computes the value of `hello[curChar]`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它计算`hello[curChar]`的值。
- en: It places this value in a location where `myPutchar` can find it.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将这个值放置在`myPutchar`可以找到的位置。
- en: It records the address of the next instruction (the end of the `for` loop).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它记录下下一个指令的地址（`for`循环的结束）。
- en: It starts executing `myPutchar`. (The `ch` variable will have been initialized
    by step 2.)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它开始执行`myPutchar`。（`ch`变量将在步骤2中初始化。）
- en: A similar set of steps is executed when we call `putchar` 3. The only difference
    is that we had to write `myPutchar`, and the people who wrote the standard C library
    supplied `putchar`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`putchar` 3时，会执行一组相似的步骤。唯一的不同之处在于我们必须写出`myPutchar`，而编写标准C库的人则提供了`putchar`。
- en: Creating a function (`myPutchar`) that does nothing but call another (`putchar`)
    is not very useful. The Nucleo board doesn’t have a `putchar` function, so we’ll
    write our own later in the chapter. But before we do that, let’s look at the details
    of the serial device.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个什么也不做只调用另一个（`putchar`）的函数（`myPutchar`）并不是特别有用。Nucleo开发板没有`putchar`函数，因此我们将在本章稍后自己编写。但在此之前，让我们先了解串行设备的细节。
- en: Serial Output
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行输出
- en: Serial output is one of the easiest ways to get data out of an embedded system.
    The electrical interface consists of a send line (TX), a receive line (RX), and
    ground (GND). Most embedded systems have them hidden away, available only to developers
    willing to crack open the case and connect to the serial port.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 串行输出是从嵌入式系统中获取数据的最简单方式之一。电气接口由发送线（TX）、接收线（RX）和地线（GND）组成。大多数嵌入式系统将这些接口隐藏起来，仅供愿意拆开机箱并连接串行端口的开发者使用。
- en: Our chip has a serial device we can write to. All we need to do is connect TX,
    RX, and GND between our microcontroller (the bottom half of the development board)
    and the USB/serial device on the top half of the board.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的芯片有一个串行设备可以写入。我们所需要做的就是连接开发板下半部分的微控制器（TX、RX、GND）和开发板上半部分的USB/串行设备。
- en: 'The following table shows the connections we need:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了我们需要的连接：
- en: '| **Microcontroller** | **USB/serial and other support devices** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **微控制器** | **USB/串行及其他支持设备** |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| RX | CN9-1 | TX | CN3-1 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| RX | CN9-1 | TX | CN3-1 |'
- en: '| TX | CN9-2 | RX | CN3-2 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| TX | CN9-2 | RX | CN3-2 |'
- en: '| GND | CN6-5 | GND | CN4-3 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| GND | CN6-5 | GND | CN4-3 |'
- en: We would have to make these connections if we had a Raspberry Pi or other embedded
    system without a built-in serial controller. [Figure 9-1](#figure9-1) shows the
    layout of these components and the internal wiring supplied by STM.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个没有内建串行控制器的Raspberry Pi或其他嵌入式系统，我们需要进行这些连接。[图9-1](#figure9-1)展示了这些组件的布局和STM提供的内部接线。
- en: STM has already made the connections for us. No jumpers needed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: STM已经为我们做好了连接。无需跳线。
- en: '![f09001](image_fi/501621c09/f09001.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](image_fi/501621c09/f09001.png)'
- en: 'Figure 9-1: Serial communications on the Nucleo board'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：Nucleo开发板上的串行通信
- en: A Brief History of Serial Communications
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 串行通信简史
- en: Serial communications go back a long way, back to the BC years (as in, *before
    computers*). The telegraph was the internet of its day, allowing for the transmission
    of long-distance messages over wires. The sender consisted of a telegraph key
    that, when pressed, would cause the receiver to “click.” The clicks were encoded
    using a system called *Morse code* (still in use today). This invention revolutionized
    communications. You could send a message to the next city and get a response the
    same day. Take that, Pony Express.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 串行通信的历史可以追溯到很久以前，甚至可以追溯到公元前（即*计算机出现之前*）。电报是那个时代的互联网，它允许通过电线传输远距离的信息。发送方由电报键组成，当按下时，接收方会发出“点击”声。这些点击声音通过一种叫做*摩尔斯电码*的系统进行编码（今天仍在使用）。这一发明彻底改变了通信方式。你可以将信息发送到下一个城市，并在当天收到回应。比起Pony
    Express，这更快。
- en: 'There was just one problem, however; you needed skilled operators at both ends
    of the telegraph who knew Morse code. Unskilled people could not send or receive
    messages, and training operators was expensive. One solution was to use two clocks:
    one for the transmitter and one for the receiver. On the clock dial were the letters,
    from *A* to *Z*. To send an *S*, for example, the sender would wait until the
    single hand on the clock pointed to the *S* and press the telegraph key. The receiver
    would see that the hand pointed to *S* and record the letter.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题是；你需要在电报两端有熟练的操作员，他们懂得摩尔斯电码。没有技能的人无法发送或接收信息，而培训操作员非常昂贵。一个解决方案是使用两个时钟：一个用于发射器，一个用于接收器。在时钟表盘上有字母，从*A*到*Z*。例如，要发送一个*S*，发送方会等到时钟上的单一指针指向*S*，然后按下电报键。接收方看到指针指向*S*，然后记录下这个字母。
- en: 'Keeping the clocks in sync was next to impossible, though, so a very smart
    inventor decided that each clock would stop its hands at the top position. When
    the sender wanted to send a letter, they would press the telegraph key as a *start
    signal*. The clocks would keep good enough time to make it around the dial once
    correctly. The sender would then press the letter signal. When the hand reached
    the top, a short pause called the *stop time* would give the slower clock a chance
    to catch up. The sequence of events went like this: start signal, letter signal,
    stop time.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，保持时钟同步几乎是不可能的，因此一位非常聪明的发明家决定，每个时钟的指针都停在顶部位置。当发送方想要发送一个字母时，他们会按下电报键作为*启动信号*。时钟会足够精确地保持时间，确保指针正确地转动一圈。然后，发送方按下字母信号。当指针到达顶部时，一个短暂的暂停时间，称为*停止时间*，会给较慢的时钟一个赶上的机会。事件的顺序是这样的：启动信号，字母信号，停止时间。
- en: Now let’s fast-forward to the invention of the teletype machine, which could
    send text over the equivalent of telegraph lines. Instead of a single letter pulse,
    the teletype encoded the characters into a series of eight pulses (seven for data
    and one for primitive error checking). It used a keyboard encoder built out of
    levers to turn a key press into an 8-bit code that was fed to a mechanical shift
    register that looked like a distributor cap. This device sent the pulses down
    the wire, where another teletype would turn them into a single printed letter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们快速回到电传打字机的发明，它能够通过类似电报线路的方式发送文本。电传打字机并不是发送一个单一的字母脉冲，而是将字符编码成一系列八个脉冲（七个数据脉冲和一个用于基本错误检查的脉冲）。它使用由杠杆组成的键盘编码器，将按键转换成一个8位的代码，这个代码传递给一个机械移位寄存器，移位寄存器看起来像一个分配器帽。这个装置通过电线发送脉冲，另一个电传打字机会将脉冲转换为一个单一的打印字母。
- en: 'The teletype sequence went like this: The sender would press a key, and the
    mechanical sender would send out a 10-bit signal (1 start bit, 8 data bits, and
    1 stop bit). When the receiver got the start bit, it turned on its shift register
    (another motor with a distributor cap) and used the incoming pulses to turn a
    print head so the right letter printed. After the 8 data bits were sent, both
    machines paused at least 1 bit time (the stop bit) to remain synchronized.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 电传打字机的顺序是这样的：发送方按下一个键，机械发送器会发送一个10位信号（1个起始位，8个数据位和1个停止位）。当接收方接收到起始位时，它会启动其移位寄存器（另一个带有分配器帽的电动机），并使用传入的脉冲来转动打印头，以便正确的字母被打印出来。在8个数据位发送完毕后，两台机器至少暂停1个位时间（即停止位），以保持同步。
- en: Most teletypes could transmit characters at 110 baud (bits/second), or 10 characters
    a second. That doesn’t sound like much in the day of megabit internet connections,
    but it was a revolutionary improvement in communications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数电传打字机的传输速率为110波特（比特/秒），即每秒10个字符。虽然在如今的兆比特互联网连接时代听起来不算什么，但在当时这是一项革命性的通信改进。
- en: Computers today still use the serial communication that the teletype used. The
    speeds have improved, but the basic protocol remains the same.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如今的计算机仍然使用电传打字机所使用的串行通信方式。速度有所提升，但基本协议保持不变。
- en: Line Endings
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 行结束符
- en: 'In fact, we’re still dealing with one other teletype legacy: line endings.
    After typing 80 characters, you could send the machine a character called a *carriage
    return* to make it return to position 1\. The problem was that it took two-tenths
    of a second to move the printhead. If you sent a character immediately after the
    carriage return, you’d get a blurred blob printed in the middle of the line as
    the printhead tried to print while moving.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们仍在处理另一个电传打字机遗留下来的问题：行结束符。在输入80个字符后，你可以发送一个叫做*回车*的字符，让机器返回到位置1。问题在于，移动打印头需要两十分之一秒的时间。如果你在回车后立即发送一个字符，打印头在移动时尝试打印，会导致一团模糊的印刷痕迹出现在行的中间。
- en: The teletype people solved this issue by making the end of a line two characters.
    The first, the carriage return, moved the print head to position 1\. The second,
    the line feed, moved the paper up one line. Since the line feed didn’t print anything
    on the paper, the fact that it was done while the printhead was flying to the
    left didn’t matter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 打字机的人通过将行结束符设为两个字符来解决了这个问题。第一个字符，回车符，将打印头移动到第 1 位。第二个字符，换行符，将纸张上移一行。由于换行符不会在纸上打印任何内容，因此它是在打印头移动到左边时完成的，这并不重要。
- en: However, when computers came out, storage cost a lot of money (hundreds of dollars
    *per* *byte*), so storing two characters for an end of line was costly. The people
    who created Unix, the inspiration for Linux, decided to use the line feed (`\n`)
    character only. Apple decided to use the carriage return (`\r`) only, and Microsoft
    decided to use both the carriage return and the line feed (`\r\n`) for its line
    ending.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，计算机出现时，存储的成本非常高（每字节数百美元），因此存储两个字符作为行结束符非常昂贵。创建 Unix 的人，Linux 的灵感来源，决定只使用换行符
    (`\n`) 字符。苹果决定只使用回车符 (`\r`)，而微软决定使用回车符和换行符 (`\r\n`) 作为行结束符。
- en: C automatically handles the different types of newlines in the system library,
    but only when you use the system library. If you are doing it yourself, like we
    are about to do, you must write out the full end-of-line sequence (`\r\n`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言自动处理系统库中的不同类型的换行符，但仅在使用系统库时才会这样做。如果你自己编写代码，就像我们即将做的那样，你必须写出完整的行结束序列（`\r\n`）。
- en: Serial Communications Today
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 今天的串行通信
- en: Today, almost every embedded processor has a serial interface on it. Serial
    devices are simple and cheap to make. The only difference between the interface
    of today and that of the 1800s is that speed has gone up (from 110 bits/second
    up to 115,200 bits/second), and the voltages have changed. In the 1800s they used
    –15 to –3 as a zero bit and +3 to +15 as a one bit. That’s still the “standard,”
    but most computers use voltages of 0 (for zero) and 3 (for one).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，几乎每个嵌入式处理器都有一个串行接口。串行设备简单且便宜。今天的接口与 1800 年代的区别在于，速度提高了（从 110 比特/秒到 115,200
    比特/秒），电压也发生了变化。在 1800 年代，他们使用 -15 到 -3 作为零位，+3 到 +15 作为一位。这仍然是“标准”，但大多数计算机使用 0（表示零）和
    3（表示一）作为电压标准。
- en: 'The device that handles the serial I/O is called a *universal asynchronous
    receiver-transmitter (UART)*. There are two major types of serial communication:
    *asynchronous* and *synchronous*. With synchronous communications, the sender’s
    and receiver’s clocks must be synchronized by having the sender continually send
    out characters. The receiver then looks at the incoming characters and deduces
    the clock timing from them. The sender must always send characters, even if it’s
    just an “idle” character (indicating no data). With asynchronous communications,
    there is no shared clock. The start bit triggers the receiver to start its clock
    and look for a character. Asynchronous communications assume that the sender and
    receiver can keep their clocks close enough together for one character time. Because
    there is no need for continuous transmissions to keep the clocks synchronized,
    there is no idle character. When idle, the transmitter just doesn’t send anything.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 处理串行 I/O 的设备被称为 *通用异步接收器-发送器 (UART)*。串行通信有两种主要类型：*异步* 和 *同步*。在同步通信中，发送方和接收方的时钟必须通过让发送方持续发送字符来进行同步。接收方然后查看传入的字符，并从中推测时钟的时序。发送方必须始终发送字符，即使它只是一个“空闲”字符（表示没有数据）。在异步通信中，没有共享的时钟。起始位触发接收方启动其时钟并等待字符。异步通信假定发送方和接收方的时钟可以保持足够接近，以保证一个字符的时间。由于不需要持续的传输来保持时钟同步，因此没有空闲字符。当空闲时，发送方只是停止发送任何内容。
- en: The STM chip has one port that allows for both synchronous and asynchronous
    communications, so in the STM documentation, you’ll see it referred to as a *universal
    synchronous/asynchronous receiver-transmitter (USART)*. This program uses the
    term *UART* to be compatible with the STM HAL library.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: STM 芯片有一个端口，支持同步和异步通信，因此在 STM 文档中，你会看到它被称为 *通用同步/异步接收器-发送器 (USART)*。本程序使用 *UART*
    这一术语，以兼容 STM HAL 库。
- en: Serial Hello World!
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 串行 Hello World！
- en: 'Let’s create a new project for *main.c*, which is a somewhat long “Hello World,”
    but it has to do all the things that the operating system hides from us. First,
    we include the header files that define the information about the UART (and lots
    of other devices as well):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为*main.c*创建一个新项目，这是一个比较长的“Hello World”，但它必须完成操作系统为我们隐藏的所有任务。首先，我们包含定义UART信息（以及许多其他设备信息）的头文件：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the code, we’ll start with the `main` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码，我们将从`main`函数开始：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `main` function looks pretty much like the one in Listings 9-1 and 9-2\.
    One addition is that it must initialize all the devices we’re going to use 1,
    including the hardware library (`HAL_Init`), the red LED (`led2_Init`), and the
    UART (`uart2_Init`). Our embedded program can’t stop, so we have an infinite loop
    2 that sends out the string 3 and then sleeps for half a second 4.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数看起来与列表9-1和9-2中的一样。唯一的不同是它必须初始化我们将要使用的所有设备1，包括硬件库（`HAL_Init`）、红色LED（`led2_Init`）和UART（`uart2_Init`）。我们的嵌入式程序不能停止，因此我们有一个无限循环2，发送字符串3，然后睡眠半秒4。'
- en: One of the first things to do next is create an `ErrorHandler` function, which
    the HAL library calls if something goes wrong. We can’t print an error message,
    because our printing code just went south, so we resort to blinking the red light.
    True, it’s a very limited error indication, but so is the check engine light in
    your car. In both cases, the designers are doing the best they can. We won’t go
    through the `Error_Handler` function here; it’s “blink” from Chapter 3 with a
    new name.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来需要做的事情之一是创建一个`ErrorHandler`函数，HAL库会在出现问题时调用它。我们不能打印错误信息，因为我们的打印代码已经崩溃了，所以我们转而使用红色指示灯闪烁。确实，这是一个非常有限的错误指示，但就像你车上的检查引擎灯一样。在这两种情况下，设计师们都在尽最大努力。我们在这里不会详细介绍`Error_Handler`函数；它与第3章中的“blink”函数相同，只是换了个名字。
- en: UART Initialization
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UART 初始化
- en: A serial device should be simple to program. The engineers at STMicroelectronics,
    however, have decided to improve the simple UART by providing additional features.
    As a result, our simple serial device now takes 45 pages worth of reference manual
    to describe. We just want to use the thing to send characters. It doesn’t even
    need to receive them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 串行设备应该是简单易编程的。然而，意法半导体（STMicroelectronics）的工程师们决定通过提供额外的功能来改进简单的UART。因此，我们的简单串行设备现在需要45页的参考手册来描述。我们只想用它来发送字符，甚至不需要接收它们。
- en: 'Fortunately, the HAL library provides a function called `HAL_UART_Init` that
    hides many of the messy details from us. Unfortunately, it doesn’t hide the messy
    details of calling `HAL_UART_Init`, but you can’t have everything. In the `uart2_Init`
    function, we have to set up an initialization structure and then call `HAL_UART_Init`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，HAL库提供了一个名为`HAL_UART_Init`的函数，它隐藏了很多复杂的细节。不幸的是，它并没有隐藏调用`HAL_UART_Init`时的复杂细节，但你不能要求所有东西都完美。在`uart2_Init`函数中，我们必须设置一个初始化结构，然后调用`HAL_UART_Init`：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We first tell the system which UART to use 1. Our chip has more than one, and
    the second one is connected to the USB serial interface. Next, we set the speed
    to 9,600 baud (bits/second) 2, or 960 characters a second. Why the 10 to 1 ratio?
    We have 1 bit for the start bit, 8 data bits, and 1 stop bit. The number of bits
    per character is 8, because C stores characters in 8-bit units. It is possible
    to have systems with 5, 6, 7, or 9 bits per character, but almost everyone uses
    8, except for a TDD deaf communication device, which uses 5\. We need to tell
    the system that we’re using 8 bits 3.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先告诉系统使用哪个UART 1。我们的芯片有多个UART，第二个UART连接到USB串行接口。接下来，我们将速度设置为9,600波特（位/秒）2，也就是每秒960个字符。为什么是10比1的比例？我们有1个位用于起始位，8个位用于数据位，1个位用于停止位。每个字符的位数是8，因为C语言将字符存储在8位单元中。确实也可以有每个字符5、6、7或9位的系统，但几乎所有人都使用8位，除了用于TDD聋人通信设备的系统，它使用5位。我们需要告诉系统我们使用的是8位3。
- en: The next line configures the number of stop bits 4, which is the amount of time
    (in bits) that occurs between characters. Most people use 1 stop bit. (If the
    sender uses 2 and the receiver uses 1, it still works. The extra bit will be interpreted
    as between-character idle time.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行配置停止位的数量4，即字符之间的时间（以位为单位）。大多数人使用1个停止位。（如果发送方使用2个停止位而接收方使用1个，仍然可以正常工作。额外的位将被解释为字符之间的空闲时间。）
- en: Early serial devices used a 7-bit character and 1 parity bit. The parity bit
    provided a simple, primitive method of error checking. We do not use this feature,
    so we turn parity off 5. We then enable the transmitter and receiver 6.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的串行设备使用7位字符和1位校验位。校验位提供了一种简单、原始的错误检查方法。我们不使用这个功能，所以我们关闭了校验 5。然后我们启用发射器和接收器
    6。
- en: The original serial interface (RS-232 standard) has a number of hardware flow
    control lines. On our board, they are not wired up, and we don’t use them 7.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 原始串行接口（RS-232标准）有许多硬件流控制线。在我们的电路板上，它们并没有接线，我们也没有使用它们 7。
- en: One of this UART’s advanced features is *oversampling*, which allows the receiver
    to check the state of an incoming bit multiple times before deciding whether it
    is a one or a zero. This feature is sometimes useful when you have a noisy electrical
    environment and are running serial cables over long distances. Our serial “cable”
    consists of two traces that run from the bottom of the board to the top, a distance
    of about 3 inches. We don’t need oversampling, but we do have to turn it off 8.
    Finally, we are not using any advanced features.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UART的一个高级特性是*过采样*，它允许接收端在决定一个比特是1还是0之前，多次检查传入比特的状态。当电气环境噪声较大或者串行电缆长度较长时，这个特性非常有用。我们的串行“电缆”由两条走线组成，从电路板底部延伸到顶部，约3英寸。我们不需要过采样，但我们确实需要关闭它
    8。最后，我们没有使用任何高级特性。
- en: 'Next, we call `HAL_UART_Init` to initialize the UART 9, which needs help to
    do its job. The general-purpose input/output (GPIO) pins on our processor can
    do a lot of different things, including act as GPIO pins. Most of them have “alternate
    functions,” meaning that you can program them to act as different devices (GPIO
    pin, USART device, SPI bus, I2C bus, PWM pin, and so on). Note that not all pins
    support all devices. Finally, `HAL_UART_Init` calls `HAL_UART_MspInit`, which
    sets up pins for the UART:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`HAL_UART_Init`来初始化UART 9，这需要一些帮助来完成任务。我们处理器上的通用输入/输出（GPIO）引脚可以做很多不同的事情，包括作为GPIO引脚。大多数引脚有“替代功能”，意味着你可以将它们编程为不同的设备（GPIO引脚、USART设备、SPI总线、I2C总线、PWM引脚等）。请注意，并不是所有引脚都支持所有设备。最后，`HAL_UART_Init`调用`HAL_UART_MspInit`，它为UART设置引脚：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to supply `HAL_UART_MspInit`. Keep in mind that pins are expensive and
    transistors to drive them are cheap. By default, the two pins that drive our serial
    device, named PA2 and PA3, are GPIO pins. We need to tell the system to use the
    pins’ alternate function and turn them into serial device pins.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供`HAL_UART_MspInit`。请记住，引脚是昂贵的，而驱动它们的晶体管很便宜。默认情况下，驱动我们串行设备的两个引脚，分别命名为PA2和PA3，是GPIO引脚。我们需要告诉系统使用这些引脚的替代功能，并将它们转变为串行设备引脚。
- en: 'Our `HAL_UART_MspInit` function looks a lot like the initialization code for
    the GPIO pin we used for “blink,” but with some slight differences:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`HAL_UART_MspInit`函数看起来与我们为“闪烁”程序使用的GPIO引脚初始化代码非常相似，但有一些细微的不同：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function starts by checking which USART we are using. We only set up USART2
    in this code 1. Then we enable the clock for the device 2. Next, we configure
    the GPIO pins 3 (we’ve done this before in our blink program), which tells the
    chip that PA2/PA3 are not GPIO pins but instead should be connected to USART2.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先检查我们使用的是哪个USART。在这段代码中我们只设置了USART2 1。然后，我们启用设备的时钟 2。接下来，我们配置GPIO引脚 3（在之前的闪烁程序中我们做过），这告诉芯片PA2/PA3不是GPIO引脚，而应该连接到USART2。
- en: Transmitting a Character
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输一个字符
- en: 'We’ll use the `myPutchar` function to transmit characters over the serial device.
    The USART is a memory-mapped I/O device. To send a character, we have to assign
    (write) it to the magic memory location (a *register*), and then it goes out the
    wire:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`myPutchar`函数通过串行设备传输字符。USART是一个内存映射的I/O设备。要发送一个字符，我们必须将它分配（写入）到神奇的内存位置（一个*寄存器*），然后它就会通过电缆发送出去：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need to time the character just right, and that requires some extra
    code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要正确地计算字符的时机，这需要一些额外的代码：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The register we are writing is called the *transmit data register (TDR)*. If
    we write this register while a character is being transmitted, the new character
    overwrites the old one, causing errors and confusion. To send `a`, `b`, `c`, we’d
    write code like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写的寄存器叫做*传输数据寄存器（TDR）*。如果在传输字符的同时写入此寄存器，新字符会覆盖旧字符，导致错误和混乱。要发送`a`、`b`、`c`，我们会写出类似这样的代码：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This sort of timing is tricky, especially if we want to execute code between
    characters. The STM32 chip has a bit for everything, including “TDR empty, you
    can write another character now.”
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定时非常棘手，尤其是当我们想在字符之间执行代码时。STM32芯片有为每个操作分配的位，包括“TDR空，可以写入另一个字符”。
- en: This bit is in a register called the *interrupt and status register (ISR)* that
    has a number of bits in it indicating the status of the device. [Figure 9-2](#figure9-2)
    shows a diagram of this register from the STM32F030R8 reference manual (“RM0360
    Reference manual/STM32F030x4/x6/x8/xC and STM32F070x6/xB”).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个位位于一个叫做*中断和状态寄存器（ISR）*的寄存器中，该寄存器包含多个位，用于指示设备的状态。[图9-2](#figure9-2)展示了来自STM32F030R8参考手册（“RM0360参考手册/STM32F030x4/x6/x8/xC和STM32F070x6/xB”）中该寄存器的示意图。
- en: '![f09002](image_fi/501621c09/f09002.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](image_fi/501621c09/f09002.png)'
- en: 'Figure 9-2: Interrupt and status register contents'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2：中断和状态寄存器内容
- en: We are interested in the bit named TXE (bit 0 in the diagram). The HAL defines
    the TXE bit using the name `UART_FLAG_TXE`. We must wait for the TXE bit to clear
    (become zero) before we can send data to the TDR without clobbering a character
    being transmitted. Nothing in the code changes `uartHandle.Instance->ISR`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心的是名为TXE的位（图中的第0位）。HAL使用`UART_FLAG_TXE`这个名称定义了TXE位。我们必须等待TXE位被清除（变为零），然后才能将数据发送到TDR，而不会覆盖正在传输的字符。代码中没有任何操作会改变`uartHandle.Instance->ISR`。
- en: However, `uartHandle.Instance->ISR` is a magic memory location electrically
    connected to the device. The state of the device changes when something like a
    character transmission completes, and when that happens, the contents of `uartHandle.Instance->ISR`
    change as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`uartHandle.Instance->ISR`是一个神奇的内存位置，电气上与设备连接。当像字符传输完成这样的事件发生时，设备的状态会发生变化，而`uartHandle.Instance->ISR`的内容也会发生变化。
- en: Now if you try to examine `uartHandle.Instance->ISR` using the debugger, the
    `UART_FLAG_TXE` flag will appear always to be set. That’s because it’s cleared
    when a character is transmitted (in 1/960th of a second), which is a long time
    in terms of computers, but a very short time in terms of humans typing commands.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试通过调试器检查`uartHandle.Instance->ISR`，`UART_FLAG_TXE`标志将始终显示为已设置。这是因为它在字符传输完成时会被清除（在1/960秒内），对于计算机而言，这是很长的时间，但对于人类打字命令来说却是非常短的时间。
- en: 'To help show what’s going on, we’ve added a useless statement:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助显示正在发生的事情，我们添加了一条无用的语句：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This statement tests the value of `UART_FLAG_TXE` and stores it in `result`.
    Now the value of `(uartHandle.Instance->ISR & UART_FLAG_TXE)` might magically
    change, but the value `result` will remain the same for the lifetime of the procedure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句测试了`UART_FLAG_TXE`的值，并将其存储在`result`中。现在，`(uartHandle.Instance->ISR & UART_FLAG_TXE)`的值可能会神奇地变化，但`result`的值将在整个过程生命周期内保持不变。
- en: 'You can look at `result` in the debugger and see what the value of the bit
    was at the beginning of the loop. You’ll notice a strange phrase in the code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在调试器中查看`result`，并看到循环开始时位的值。你会注意到代码中有一个奇怪的短语：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a GCC extension to the C language. It tells the compiler that we know
    this variable is not used, so it doesn’t generate a warning. (In fact, it’s not
    used by the program, but it may be used by the debugger. The compiler doesn’t
    see anything outside the program itself.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C语言的一个GCC扩展。它告诉编译器我们知道这个变量未被使用，因此不会生成警告。（实际上，它未被程序使用，但调试器可能会使用它。编译器看不到程序外部的内容。）
- en: The string we send for “Hello World” ends with `\r\n` (carriage return, line
    feed). In our original “Hello World” program from Chapter 1, the operating system
    edited the output stream and changed `\n` into `\r\n` for us. We have no operating
    system, so we must do it all ourselves.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为“Hello World”发送的字符串以`\r\n`（回车，换行）结尾。在我们第1章的原始“Hello World”程序中，操作系统编辑了输出流并将`\n`转换为`\r\n`。但我们没有操作系统，所以必须自己完成这一切。
- en: '[Listing 9-3](#listing9-3) contains the full serial version of our “Hello World”
    program.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-3](#listing9-3)包含了我们“Hello World”程序的完整串行版本。'
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-3: Program* 08.serial'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-3：程序* 08.serial'
- en: Communicating with the Device
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与设备通信
- en: We now have a program that sends out the “Hello World” message on the serial
    line. The serial line is connected to the USB/serial device on the board, which
    is plugged in to your computer. To view the message, you need to run a terminal
    emulator on your computer. [Figure 9-3](#figure9-3) shows the setup.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个程序，可以通过串行线发送“Hello World”消息。串行线连接到板上的USB/串行设备，该设备已插入你的计算机。要查看消息，你需要在计算机上运行一个终端仿真器。[图9-3](#figure9-3)展示了这个设置。
- en: '![f09003](image_fi/501621c09/f09003.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](image_fi/501621c09/f09003.png)'
- en: 'Figure 9-3: Serial communications'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：串口通信
- en: Each operating system has a different terminal emulator program, and in some
    cases, more than one. The ones mentioned here are common, free, and easy to use.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都有不同的终端仿真程序，某些情况下可能不止一个。这里提到的程序都是常见的、免费的并且易于使用。
- en: Windows
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: 'On Windows, we’ll use the PuTTY program ([https://putty.org](https://putty.org)).
    Download and install it on your system, selecting the defaults for all options,
    and then follow these steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们将使用 PuTTY 程序（[https://putty.org](https://putty.org)）。下载并安装到你的系统中，选择所有选项的默认设置，然后按照以下步骤操作：
- en: Make sure the Nucleo board is *not* connected to your computer. Open the Control
    Panel and go to the Device Manager screen (see [Figure 9-4](#figure9-4)). There
    is no serial device and, therefore, no Ports section in the list.![f09004](image_fi/501621c09/f09004.png)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 Nucleo 开发板*没有*连接到你的电脑。打开控制面板，进入设备管理器界面（参见[图 9-4](#figure9-4)）。列表中没有串口设备，因此也没有“端口”部分。![f09004](image_fi/501621c09/f09004.png)
- en: 'Figure 9-4: Serial device not installed'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9-4：未安装串口设备
- en: Plug in the Nucleo board. The device list will change as shown in [Figure 9-5](#figure9-5).![f09005](image_fi/501621c09/f09005.png)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入 Nucleo 开发板。设备列表将发生变化，如[图 9-5](#figure9-5)所示。![f09005](image_fi/501621c09/f09005.png)
- en: 'Figure 9-5: New USB serial device'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9-5：新的 USB 串口设备
- en: You should see a new USB serial device named COM3\. (Windows has a system for
    assigning COM parts to serial devices, but no one knows what that is. You may
    see a different COM port on your machine.)
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该会看到一个名为 COM3\ 的新 USB 串口设备。（Windows 有一个为串口设备分配 COM 端口的系统，但没有人知道具体是怎样的。你可能会在你的电脑上看到不同的
    COM 端口。）
- en: Start PuTTY. In the main window, shown in [Figure 9-6](#figure9-6), select the
    **Serial** radio button. Under **Serial Line**, select the new COM port you just
    found in the Device Manager. The speed should default to 9600.![f09006](image_fi/501621c09/f09006.png)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 PuTTY。在主窗口中，如[图 9-6](#figure9-6)所示，选择**串口**单选按钮。在**串口线路**下，选择你刚在设备管理器中找到的新
    COM 端口。速度应该默认设置为 9600。![f09006](image_fi/501621c09/f09006.png)
- en: 'Figure 9-6: Starting PuTTY'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9-6：启动 PuTTY
- en: Click **Open**. A terminal window should appear, and the device should start
    greeting you.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开**。应该会出现一个终端窗口，设备应开始向你打招呼。
- en: Linux and macOS
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux 和 macOS
- en: On Unix-based systems like Linux and macOS, the `screen` program works well.
    (The `minicom` program also does the job.) To use `screen`, you need to know the
    serial device’s name, which is different on different operating systems. On Linux,
    the device is most likely */dev/ttyACM0*, although if you have other serial devices
    plugged in, it might be */dev/ttyACM1*, */dev/ttyACM2*, or similar. On macOS,
    the name is likely */dev/tty.usbmodem001*, but it could be */dev/tty.usbmodem002*,
    */dev/tty.usbmodem003*, or something similar.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Linux 和 macOS 这样的 Unix 系统上，`screen` 程序效果很好。（`minicom` 程序也能完成这项工作。）要使用 `screen`，你需要知道串口设备的名称，不同操作系统中该名称不同。在
    Linux 上，该设备很可能是 */dev/ttyACM0*，但是如果你插入了其他串口设备，它可能是 */dev/ttyACM1*、*/dev/ttyACM2*
    或类似的名称。在 macOS 上，该名称可能是 */dev/tty.usbmodem001*，但也可能是 */dev/tty.usbmodem002*、*/dev/tty.usbmodem003*
    或类似名称。
- en: 'To find the name, make sure the Nucleo board is *not* connected to your computer,
    then execute one of the following commands in the terminal:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到设备名称，确保 Nucleo 开发板*没有*连接到你的电脑，然后在终端中执行以下命令之一：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Plug in the device and execute the same command again. You should see one more
    device in the list. Use that one. Now execute the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 插入设备并再次执行相同的命令。你应该会在列表中看到一个新的设备。使用那个设备。现在执行以下命令：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should see “Hello World” appear. To exit the program, press CTRL-A-\.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到“Hello World”出现在屏幕上。要退出程序，按 CTRL-A-\。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This programming book covers “Hello World” in Chapter 9. Why? Because we had
    to do everything ourselves. Writing a simple program to send out our message,
    character by character, involved initializing the UART (a nontrivial process),
    telling the GPIO pin that it was now a serial pin, and using a hardware register
    (those mysterious memory locations that magically change depending on the state
    of the device) to see when the UART was ready to transmit a character.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的编程内容在第 9 章介绍了“Hello World”。为什么？因为我们必须自己做所有的事情。编写一个简单的程序逐字符地发送我们的信息，涉及到初始化
    UART（这是一个复杂的过程），告诉 GPIO 引脚它现在是串口引脚，并使用硬件寄存器（那些神秘的内存位置，根据设备的状态会发生变化）来查看 UART 是否准备好发送字符。
- en: We’ve made a tremendous leap forward. First, we’ve programmed a moderately complex
    device and in the process learned a lot about direct low-level I/O. Second, the
    serial port is the main diagnostic and maintenance device hidden in many embedded
    devices. Despite all the advances in computer technology in the last 60 years,
    the most commonly used debugging technique is still `printf` to the serial port.
    The serial port is a very simple robust device that’s cheap to make and easy to
    connect to, and now we know how to use it to debug our embedded systems.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经取得了巨大的进步。首先，我们编程了一个中等复杂的设备，在这个过程中学到了很多关于直接低级I/O的知识。其次，串口是许多嵌入式设备中隐藏的主要诊断和维护工具。尽管过去60年计算机技术取得了巨大的进步，但最常用的调试技术仍然是`printf`输出到串口。串口是一个非常简单且稳健的设备，制造成本低且易于连接，现在我们知道如何使用它来调试嵌入式系统。
- en: Programming Problems
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程问题
- en: 'For the student: After you get the program working, see what happens if you
    remove the `\r`. Then try it with the `\r` back in, but the `\n` removed.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对学生而言：当你让程序正常运行后，试试看去掉`\r`会发生什么。然后再试一下将`\r`恢复，但去掉`\n`。
- en: 'Moderately difficult mystery: Try changing the configuration so that you send
    7 data bits and even parity (instead of 8 data bits, no parity). Do not change
    your terminal emulator’s configuration. Some of the characters will be changed.
    Examine the bit pattern of the characters and figure out which ones changed and
    why.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中等难度的谜题：尝试更改配置，使你发送7个数据位并使用偶校验（而不是8个数据位，无校验）。不要更改终端仿真器的配置。一些字符将会被改变。检查字符的位模式，找出哪些字符发生了变化，并解释为什么。
- en: 'Advanced: As written, our program has no flow control. You’re going to get
    a “Hello World” whether you like it or not. Change the initialization code to
    use soft flow control. This means when you type the XOFF character (CTRL-S), the
    output should stop. When you type XON (CTRL-Q), it should resume.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高级：如目前程序所写，我们没有使用流控制。无论你是否喜欢，程序都会输出“Hello World”。更改初始化代码以使用软件流控制。这意味着，当你输入XOFF字符（CTRL-S）时，输出应该停止。当你输入XON（CTRL-Q）时，输出应该恢复。
- en: 'Advanced: Write a function for the Nucleo board that reads a character. It
    will look much like the `myPutchar` function, only it will check a different bit
    and read the I/O port instead of writing to it. You’ll need to read the microcontroller’s
    documentation to see what the RDR bit does.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高级：为Nucleo板编写一个读取字符的函数。它看起来与`myPutchar`函数非常相似，只是它会检查不同的位，并读取I/O端口而不是写入它。你需要阅读微控制器的文档，了解RDR位的作用。
