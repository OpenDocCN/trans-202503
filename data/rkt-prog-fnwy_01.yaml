- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: RACKET BASICS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: RACKET 基础
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: Let’s begin with an introduction to some basic concepts in Racket. In this chapter,
    we’ll cover some of the fundamental data types that will be used throughout the
    book. You’ll want to pay particular attention to the discussion of lists, which
    underpin much of Racket’s functionality. We’ll also cover how to assign values
    to variables and various ways to manipulate strings, and along the way, you’ll
    encounter a first look at vectors and structs. The chapter wraps up with a discussion
    on how to produce formatted output.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从介绍一些 Racket 的基本概念开始。在本章中，我们将介绍一些将在整本书中使用的基本数据类型。你需要特别关注列表的讨论，因为它支撑了 Racket
    的大部分功能。我们还将介绍如何给变量赋值以及各种字符串操作方法，在过程中，你将初次接触向量和结构体。最后，本章将讨论如何生成格式化输出。
- en: Atomic Data
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原子数据
- en: '*Atomic data* is the basic building block of any programming language, and
    Racket is no exception. Atomic data refers to elementary data types that are typically
    considered to be indivisible entities; that is, numbers like `123`, strings like
    `"hello there"`, and identifiers such as `pi`. Numbers and strings evaluate to
    themselves; if bound, identifiers evaluate to their associated value:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*原子数据* 是任何编程语言的基本构建块，Racket 也不例外。原子数据指的是通常被认为是不可分割的基本数据类型；即，像 `123` 这样的数字，像
    `"hello there"` 这样的字符串，以及像 `pi` 这样的标识符。数字和字符串求值为其本身；如果被绑定，标识符则会求值为其关联的值：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Evaluating an unbound identifier results in an error. To prevent an unbound
    identifier from being evaluated, you can prefix it with an apostrophe:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 求值一个未绑定的标识符会导致错误。为了防止未绑定的标识符被求值，你可以在它前面加上撇号：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can organize atomic data together using lists, which are covered next.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表将原子数据组织在一起，接下来会介绍列表。
- en: Lists
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: In Racket, lists are the primary non-atomic data structures (that is, something
    other than a number, string, and so on). Racket relies heavily on lists because
    it’s a descendant of *Lisp* (short for LISt Processing). Before we get into the
    details, let’s look at some simple representative samples.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中，列表是主要的非原子数据结构（即，除了数字、字符串等之外的其他东西）。Racket 依赖列表的原因之一是它是 *Lisp*（LISt
    Processing，列表处理）的后代。在深入细节之前，让我们看一些简单的示例。
- en: '***A First Look at Lists***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***初探列表***'
- en: 'Here’s how to make a list with some numbers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建一个包含一些数字的列表的方法：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice the syntax. Lists typically begin with an open parenthesis, `(`, followed
    by a list of space-separated items and end with a closed parenthesis, `)`. The
    first item in the list is normally an identifier that indicates how the list is
    to be evaluated.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意语法。列表通常以一个开括号 `(` 开始，接着是由空格分隔的元素列表，最后以闭括号 `)` 结束。列表中的第一个元素通常是一个标识符，用来指示该列表如何被求值。
- en: Lists can also contain other lists.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表也可以包含其他列表。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: which prints as
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印为
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note the apostrophe (or tick mark) at the beginning of the last example. This
    is an alias for the `quote` keyword. If you want to enter a literal list (a list
    that is simply accepted as is), you can enter it *quoted*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一个示例中开头的撇号（或反引号）。这是 `quote` 关键字的别名。如果你想输入一个字面量列表（即一个按原样接受的列表），你可以将其*引用*：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: or
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Either of which print as
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其中任何一个都打印为
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While `list` and `quote` seem like two equivalent ways to build lists, there’s
    an important difference between them. The following sequence illustrates the difference.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `list` 和 `quote` 看起来是构建列表的两种等效方式，但它们之间有一个重要的区别。以下示例演示了这个区别。
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that `quote` returns the list exactly as it was entered, but when `list`
    was used, the identifier `pi` was evaluated and its value was substituted in its
    place. In general, in a non-quoted list, *all* identifiers are evaluated and replaced
    by their associated values. The keyword `quote` plays an important role in macros
    and symbolic expression evaluation, which are advanced topics that we will not
    cover in this text.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`quote` 会返回输入的列表内容，而当使用 `list` 时，标识符 `pi` 被求值并用其值替代。通常，在一个非引用的列表中，*所有* 标识符都会被求值并替换为其对应的值。关键字
    `quote` 在宏和符号表达式求值中扮演重要角色，这些是高级主题，我们在本书中不予讨论。
- en: One criticism of the Lisp family of languages is the proliferation of parentheses.
    To alleviate this, Racket allows either square brackets or curly brackets to be
    used instead. For example, it’s perfectly acceptable to write the last expression
    as
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 系列语言的一个批评点是括号的过多。为了解决这个问题，Racket 允许使用方括号或花括号代替圆括号。例如，最后一个表达式完全可以写成：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: or
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***S-Expressions***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***S 表达式***'
- en: 'A list is a special case of something called an *s-expression*. An s-expression
    (or symbolic expression) is defined as being one of two cases:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是称为 *s-表达式* 的事物的一种特殊情况。s-表达式（或符号表达式）被定义为两种情况之一：
- en: '**Case 1** The s-expression is an atom.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**案例 1** s-表达式是一个原子。'
- en: '**Case 2** The s-expression is expression of the form `(x . y)` where *x* and
    *y* are other s-expressions.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**案例 2** s-表达式是形如 `(x . y)` 的表达式，其中 *x* 和 *y* 是其他 s-表达式。'
- en: The form `(x . y)` is typically called a *pair*. This is a special syntactic
    form used to designate a *cons* cell, which we will have much more to say about
    shortly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 形式 `(x . y)` 通常称为 *对*。这是一种特殊的语法形式，用来指定一个 *cons* 单元，我们将很快详细讨论这个内容。
- en: 'Let’s see if we can construct a few examples of s-expressions. Ah, how about
    `1`? Yes, it’s an atom, so it satisfies case 1\. What about `"spud"`? Yep, strings
    are atoms, and thus `"spud"` is also an s-expression. We can combine these to
    make another s-expression: `(1 . "spud")`, which satisfies case 2\. Since `(1
    . "spud")` is an s-expression, case 2 allows us to form another s-expression as
    `((1 . "spud") . (1 . "spud"))`. We can see from this that s-expressions are actually
    tree-like structures as illustrated in [Figure 1-1](ch01.xhtml#ch1fig1). (Technically
    s-expressions form a *binary tree*, where non-leaf nodes have exactly two child
    nodes).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看能否构造一些 s-表达式的例子。嗯，`1` 怎么样？是的，它是一个原子，因此符合案例 1。`"spud"` 呢？没错，字符串是原子，因此 `"spud"`
    也是一个 s-表达式。我们可以将这些组合起来形成另一个 s-表达式：`(1 . "spud")`，它符合案例 2。由于 `(1 . "spud")` 是一个
    s-表达式，案例 2 允许我们再形成另一个 s-表达式：`((1 . "spud") . (1 . "spud"))`。从中我们可以看出，s-表达式实际上是类似树状的结构，如
    [图 1-1](ch01.xhtml#ch1fig1) 所示。（严格来说，s-表达式形成了一个 *二叉树*，其中非叶节点有恰好两个子节点。）
- en: '![Image](../images/01fig01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig01.jpg)'
- en: '*Figure 1-1: `((a . (2 . pi) . x))`*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：`((a . (2 . pi) . x))`*'
- en: In [Figure 1-1](ch01.xhtml#ch1fig1), the square boxes are leaf nodes representing
    atoms, and the circle nodes represent pairs. We’ll see how s-expressions are used
    to construct lists in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 1-1](ch01.xhtml#ch1fig1) 中，方框是表示原子的叶节点，圆形节点表示对。接下来我们将看到 s-表达式如何用于构建列表。
- en: '***List Structure***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表结构***'
- en: As mentioned above, a list is a special case of an s-expression. The difference
    is that, in a list, if we follow the rightmost elements in each pair, the final
    node is a special atomic node called *nil*. [Figure 1-2](ch01.xhtml#ch1fig2) illustrates
    what the list ’`(1 2 3)`—which as an s-expression is `(1 . (2 . (3 . nil)))`—looks
    like internally.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，列表是 s-表达式的一种特殊情况。不同之处在于，在一个列表中，如果我们跟踪每个对中的最右边元素，最终的节点是一个特殊的原子节点，称为 *nil*。[图
    1-2](ch01.xhtml#ch1fig2) 展示了列表 `'(1 2 3)`——作为一个 s-表达式是 `(1 . (2 . (3 . nil)))`——在内部的样子。
- en: '![Image](../images/01fig02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig02.jpg)'
- en: '*Figure 1-2: List structure*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：列表结构*'
- en: 'We’ve flattened the tree to better resemble a list. We’ve also expanded each
    pair node (aka a *cons cell*) to show that it consists of two cells, each of which
    contains a pointer to another node. These pointer cells, for historical reasons,
    are called *car* and *cdr* respectively (the names of computer registers used
    in early versions of Lisp). We can see that the last cdr cell in the list is pointing
    to nil. Nil is indicated in Racket by an empty list: ’`()` or `null`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将树状结构展平，以便更像一个列表。我们还展开了每个对节点（也就是 *cons 单元*），以显示它包含两个单元，每个单元包含指向另一个节点的指针。这些指针单元，出于历史原因，分别被称为
    *car* 和 *cdr*（它们是 Lisp 早期版本中使用的计算机寄存器的名称）。我们可以看到，列表中的最后一个 cdr 单元指向 nil。Nil 在 Racket
    中由空列表表示：`()` 或 `null`。
- en: Cons cells can be created directly by using the `cons` function. Note that the
    `cons` function does not necessarily create a list. For example
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `cons` 函数直接创建 cons 单元。注意，`cons` 函数不一定创建一个列表。例如：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: produces a pair but *not* a list. However, if we use an empty list as our second
    s-expression
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它生成一个对，但 *不是* 一个列表。然而，如果我们使用一个空列表作为第二个 s-表达式：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: we produce a list with just one element.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成一个只有一个元素的列表。
- en: 'Racket provides a couple of functions to test whether something is a list or
    a pair. Note in Racket `#t` means true and `#f` means false:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 提供了几个函数来测试某个元素是否是列表或对。在 Racket 中，`#t` 表示真，`#f` 表示假：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From this we can see that a list is always a pair, but the converse is not
    always true: a pair is not always a list.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以看出，列表始终是一个对，但反过来并不总是成立：一对并不总是一个列表。
- en: 'Typically, `cons` is used to add an atomic value to the beginning of a list,
    like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`cons` 用于将一个原子值添加到列表的开头，如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Racket provides special functions to access the components of a cons cell. The
    function `car` returns the item being pointed to by the car pointer, and correspondingly
    the `cdr` function returns the item being pointed to by the cdr pointer. In Racket
    the functions `first` and `rest` are similar to `car` and `cdr` but are not aliases
    for these functions, since they only work with lists. A few examples are given
    below.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 提供了专门的函数来访问 cons 单元的组成部分。`car` 函数返回由 car 指针指向的元素，`cdr` 函数则返回由 cdr 指针指向的元素。在
    Racket 中，`first` 和 `rest` 函数与 `car` 和 `cdr` 类似，但它们不是这两个函数的别名，因为它们仅适用于列表。下面给出了一些示例。
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: List elements can also be accessed with the functions `second`, `third`, . .
    . , `tenth`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表元素也可以通过 `second`、`third` 等函数进行访问。
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, a value at any position can be extracted by using `list-ref`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用 `list-ref` 提取任意位置的值。
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `list-ref` function takes a list and the index of the value you want, with
    the list coming first. Notice that Racket uses *zero-based indexes*, meaning for
    any sequence of values, the first value has an index of 0, the second value has
    an index of 1, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`list-ref` 函数接受一个列表和你想要的值的索引，列表作为第一个参数。请注意，Racket 使用 *从零开始的索引*，这意味着在任何值序列中，第一个值的索引为
    0，第二个值的索引为 1，以此类推。'
- en: '***A Few Useful List Functions***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一些有用的列表函数***'
- en: Let’s quickly go through a number of useful list functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一些有用的列表函数。
- en: '**length**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**长度**'
- en: 'To get the length of a list, you can use the `length` function, like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取列表的长度，你可以使用 `length` 函数，像这样：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**reverse**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**反转**'
- en: If you need the elements in a list reversed, you can use the `reverse` function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将列表中的元素反转，可以使用 `reverse` 函数。
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**sort**'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**排序**'
- en: 'The `sort` function will sort a list. You can pass in `<` to sort the list
    in ascending order:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 函数将对列表进行排序。你可以传入 `<` 来将列表按升序排序：'
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or, if you pass in `>`, it will sort the list in descending order:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你传入 `>`，它将按降序排序列表：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**append**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**追加**'
- en: 'To merge two lists together, you can use the `append` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要将两个列表合并在一起，可以使用 `append` 函数：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `append` function can take more than two lists:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 函数可以接受多个列表：'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**range**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**范围**'
- en: 'The `range` function will create a list of numbers given some specifications.
    You can pass a start value and an end value, as well as a step to increment:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 函数将根据一些参数创建一个数字列表。你可以传入一个起始值和一个结束值，以及一个步进值：'
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or, if you just pass an end value, it will start at 0 with a step of 1:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你只传入一个结束值，它将从 0 开始，步进为 1：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**make-list**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建列表**'
- en: 'Another way to make lists is using the `make-list` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表的另一种方式是使用 `make-list` 函数：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, `make-list` takes a number and a value, and makes a list that
    contains that value repeated that number of times.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`make-list` 接受一个数字和一个值，并创建一个包含该值，且该值重复指定次数的列表。
- en: '**null?**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**空?**'
- en: 'To test whether a list is empty or not, you can use the `null?` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个列表是否为空，可以使用 `null?` 函数：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**index-of**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**索引值**'
- en: 'If you need to search a list for a value, you can use `index-of`. It’ll return
    the index of the value if it appears:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在列表中查找一个值，可以使用 `index-of`。如果该值存在，它将返回该值的索引：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It’ll return `#f` if it doesn’t:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，它将返回 `#f`：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**member**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**成员**'
- en: Another way to search lists is to use `member`, which tests whether a list contains
    an instance of a particular element. It returns the symbol `#f` if it does not,
    and returns the tail of the list starting with the first instance of the matching
    element if it does.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种搜索列表的方法是使用 `member`，它测试一个列表是否包含某个特定元素的实例。如果没有，返回符号 `#f`；如果有，则返回从第一个匹配元素开始的列表尾部。
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that in the last instance, even though 6 is a member of a sublist of
    the searched list, the `member` function still returns false. However, the following
    does work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最后一个例子中，尽管 6 是被搜索列表的一个子列表中的成员，`member` 函数仍然返回了 false。然而，以下的做法是有效的。
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You’ll see later that in functional programming, you often need to determine
    whether an item is contained in a list. The `member` function not only finds the
    item (if it exists) but returns the actual value so that it can be used in further
    computations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后你会看到，在函数式编程中，你常常需要判断一个元素是否包含在列表中。`member` 函数不仅能找到该元素（如果它存在），还会返回实际的值，以便在后续计算中使用。
- en: We’ll have much more to say about lists in the remainder of this text.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将对列表进行更多的讲解。
- en: Defines, Assigns, and Variables
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义、赋值和变量
- en: Thus far, we’ve seen a few examples of a *function*, something that takes one
    or more input values and provides an output value (some form of data). The first
    element in a function-call expression is an identifier (the function name). The
    remaining elements in a function form are the arguments to the function. These
    elements are each evaluated and then fed to the function, which performs some
    operation on its arguments and returns a value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经见过一些*函数*的例子，函数是接受一个或多个输入值并提供一个输出值（某种形式的数据）。函数调用表达式中的第一个元素是标识符（函数名）。函数形式中的其余元素是函数的参数。这些元素会被逐一评估，然后传递给函数，函数对其参数执行某些操作并返回一个值。
- en: More specifically, a *form* or *expression* may define a function, execute a
    function call, or simply return a structure (normally a list), and may or may
    not evaluate all its arguments. Notice that `quote` is a different type of form
    (distinct from a function form, which evaluates its arguments) since it *does
    not* first evaluate its arguments. In the next section you’ll meet `define`, which
    is yet another type of form since it does not evaluate its first argument, but
    it does evaluate its second argument. We will meet many other types of forms as
    we progress through the text.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体来说，一个*形式*或*表达式*可以定义一个函数，执行一个函数调用，或仅仅返回一个结构（通常是一个列表），并且可能会或可能不会评估它的所有参数。请注意，`quote`
    是一种不同类型的形式（与评估其参数的函数形式不同），因为它*不会*首先评估其参数。在下一节中，你将见到 `define`，它是另一种形式，因为它不会评估其第一个参数，但会评估其第二个参数。随着文本的推进，我们将会见到许多其他类型的形式。
- en: 'A *variable* is a placeholder for a value. In Racket, variables are specified
    by *identifiers* (specific sequences of characters) associated with one thing
    only. (We’ll have more to say about what constitutes a valid identifier shortly.)
    To define a variable, you use the `define` form. For example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*是一个值的占位符。在 Racket 中，变量通过*标识符*（特定的字符序列）来指定，每个标识符只与一个事物关联。（稍后我们将详细讨论什么构成有效的标识符。）要定义一个变量，你使用
    `define` 形式。例如：'
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here `define` is said to *bind* the value `123` to the identifier `a`. Virtually
    anything can be bound to a variable. Here we’ll bind a list to the identifier
    `b`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`define` 被用来*绑定*值 `123` 到标识符 `a`。几乎任何东西都可以绑定到一个变量。这里我们将绑定一个列表到标识符 `b`。
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It’s possible to bind several variables in parallel:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以并行绑定多个变量：
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Racket makes a distinction between *defining* a variable and *assigning* a
    value to a variable. Assignments are made with a `set!` expression. Typically
    any form which changes, or *mutates*, a value will end with an exclamation point.
    Attempting to assign to an identifier that hasn’t been previously defined will
    result in an ugly error message:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 区分*定义*变量和*赋值*变量。赋值通过 `set!` 表达式进行。通常，任何改变或*变更*一个值的形式都会以感叹号结尾。试图赋值给一个未曾定义的标识符会导致一个难看的错误信息：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'But this is okay:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是可以的：
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: One way to think of this is that `define` sets up a location to store a value,
    and `set!` simply places a new value in a previously defined location.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一种理解方式是，`define` 设置了一个存储值的位置，而 `set!` 只是将一个新值放入先前定义的位置。
- en: When we speak of a variable *x* that is defined in Racket code, it will be typeset
    as `x`. If we’re simply speaking of the variable in the mathematical sense, it
    will be typeset in italics as *x*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到在 Racket 代码中定义的变量 *x* 时，它将被排版为 `x`。如果我们仅仅在数学意义上讨论该变量，它将以斜体形式排版为 *x*。
- en: Symbols, Identifiers, and Keywords
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号、标识符和关键字
- en: 'Unlike most languages, Racket allows just about any string of characters to
    be used as an identifier. For example we can use `2x3` as an identifier:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言不同，Racket 允许几乎任何字符串用作标识符。例如，我们可以使用 `2x3` 作为标识符：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You could conceivably define a function literally called `rags->riches` that
    would convert rags to riches (let me know when you get that working). All this
    seems quite bizarre, but it lends Racket an expressive power not found in many
    other computer languages. There are of course some restrictions to this, but aside
    from a few special characters such as parentheses, brackets, and arithmetic operators
    (even these are usually okay if they aren’t the first character), just about anything
    goes. In fact it’s common to see identifiers containing dashes, as in `solve-for-x`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以设想定义一个名为`rags->riches`的函数，它将破衣服变成财富（告诉我你完成后是如何实现的）。这一切看起来很奇怪，但它赋予Racket一种许多其他编程语言所没有的表达能力。当然，这其中有一些限制，但除了少数特殊字符，如圆括号、方括号和算术运算符（即使这些通常也没问题，只要它们不是第一个字符），几乎任何东西都可以使用。事实上，看到包含连字符的标识符（如`solve-for-x`）是很常见的。
- en: 'A *symbol* is essentially just a quoted identifier:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*符号*本质上就是一个带引号的标识符：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: They are sort of a second-rate string (more on strings below). They are typically
    used much like an `enum` in other programming languages where they’re used to
    stand for a specific value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有点像二等字符串（下面会详细介绍字符串）。它们通常像其他编程语言中的`enum`一样使用，用来表示特定的值。
- en: 'A *keyword* is an identifier prefixed with #`:`. Keywords are mainly used to
    identify optional arguments in function calls. Here’s an example of a function
    (˜`r`) that uses a keyword to output *π* as a string with two decimal places of
    accuracy.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*关键字*是一个以#`:`为前缀的标识符。关键字主要用于在函数调用中标识可选参数。这里是一个函数（˜`r`）的例子，它使用关键字将*π*以两位小数的字符串形式输出。
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we define the optional `precision` argument to specify that the value of
    `pi` should be rounded to two decimal places.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了可选的`precision`参数，用来指定`pi`的值应该四舍五入到两位小数。
- en: Equality
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相等性
- en: 'Racket defines two different kinds of equality: things that look exactly alike
    and things that are the same thing. Here’s the difference. Suppose we make the
    following two definitions.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Racket定义了两种不同的相等性：看起来完全相同的东西和实际上是同一个东西。下面是它们的区别。假设我们做以下两个定义。
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Identifiers `a` and `b` look exactly alike, and if we ask Racket if they are
    the same with the `equal?` predicate, it will respond that they are the same.
    Note a *predicate* is a function that returns a Boolean value of true or false.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符`a`和`b`看起来完全一样，如果我们询问Racket它们是否相同，使用`equal?`谓词，它会回答它们是相同的。注意，*谓词*是一个返回布尔值（真或假）的函数。
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: But if we ask whether they are the same thing by using the `eq?` predicate,
    we get a different answer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们使用`eq?`谓词来询问它们是否是同一个东西，我们会得到不同的答案。
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So when does `eq?` return true? Here’s an example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候`eq?`返回`true`呢？这里有一个例子。
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case we have bound `x` to the list ’`(1 2 3)`. We then bind `y` to the
    same value *location* that `x` is bound to, effectively making `x` and `y` be
    bound to the same thing. The difference is subtle, but important. In most cases
    `equal?` is what you need, but there are scenarios where `eq?` is used to ensure
    that variables are bound to the same object and not just to things that *look*
    the same.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将`x`绑定到列表`(1 2 3)`。然后，我们将`y`绑定到与`x`绑定的相同*位置*，有效地使`x`和`y`绑定到相同的内容。这个差异微妙但重要。在大多数情况下，`equal?`是你需要的，但也有一些场景使用`eq?`来确保变量绑定到相同的对象，而不仅仅是绑定到*看起来*相同的东西。
- en: 'One other nuance of equality that must be discussed is numeric equality. In
    the discussion above, we were focused on structural equality. Numbers are a different
    animal. We’ll have much more to say about numbers in the next chapter, but we
    need to clarify a few things about numbers that relate to equality. Examine the
    following sequence:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个必须讨论的相等性细微差别是数字相等性。在上面的讨论中，我们关注的是结构相等性。数字是另一种情况。我们将在下一章详细讨论数字，但我们需要澄清一些与数字相等性相关的事项。请检查以下序列：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Above we bound `a` and `b` to identical lists ’`(1 2 3)`, and in that case
    `eq?` returned false. In this case we bound `a` and `b` to the identical number
    `123`, and `eq?` returned true. Numbers (technically *fixnums*, that is, small
    integers that fit into a fixed amount of storage—typically 32 or 64 bits, depending
    on your computing platform) are unique in this sense. There is only one instance
    of every number, no matter how many different identifiers it is bound to. In other
    words, each number is stored in one and only one location. Furthermore, there’s
    a special predicate (=) that can only be used with numbers:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上面我们将 `a` 和 `b` 绑定到相同的列表 '`(1 2 3)`，在这种情况下 `eq?` 返回了 false。在这个例子中，我们将 `a` 和
    `b` 绑定到相同的数字 `123`，`eq?` 返回了 true。数字（严格来说是*fixnums*，即适合存储在固定存储空间中的小整数——通常是 32
    位或 64 位，具体取决于计算平台）在这方面是独一无二的。每个数字只有一个实例，不管它绑定了多少不同的标识符。换句话说，每个数字都存储在唯一的一个位置。此外，还有一个特殊的谓词
    (=)，只能用于数字：
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this section we only cover equality in general. We’ll look at more specifics
    on numerical comparisons in the next chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们仅覆盖一般的相等性。我们将在下一章详细讨论数值比较的更多细节。
- en: Strings and Things
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串与其他元素
- en: In this section, we’ll look at different ways of handling text values in Racket.
    We’ll begin with the simplest kind of text value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Racket 中处理文本值的不同方式。我们将从最简单的文本值类型开始。
- en: '***Characters***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符***'
- en: 'Individual text values, like single letters, are represented using a *character*,
    a special entity that corresponds to a *Unicode* value. For example, the letter
    A corresponds to the Unicode value 65\. Unicode values are usually specified in
    hexadecimal, so the Unicode value for A is 65[10] = 0041[16]. Character values
    either start with #\ followed by a literal keyboard character or #\`u` followed
    by a Unicode value.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '单个文本值，例如单个字母，使用*字符*表示，字符是一个特殊实体，对应于*Unicode*值。例如，字母 A 对应的 Unicode 值是 65\。Unicode
    值通常以十六进制指定，因此 A 的 Unicode 值为 65[10] = 0041[16]。字符值要么以 #\ 开头，后跟一个字面键盘字符，要么以 #\`u`
    开头，后跟一个 Unicode 值。'
- en: Here’s a sampling of the multiple ways to write a character using character
    functions. Notice the use of the comment character (`;`), which allows comments
    (non-compiled text) to be added to Racket code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用字符函数编写字符的多种方式。注意使用了注释字符（`;`），它允许将注释（非编译文本）添加到 Racket 代码中。
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Unicode supports a wide range of characters. Here are some examples:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 支持广泛的字符集。这里有一些示例：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Most Unicode characters should print fine, but this depends to some extent on
    the fonts available on your computer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Unicode 字符应该能够正常打印，但这在一定程度上取决于你计算机上可用的字体。
- en: '**Strings**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: A *string* typically consists of a sequence of keyboard characters surrounded
    by double-quote characters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*字符串*通常由一系列键盘字符组成，并被双引号字符包围。
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Unicode characters can be embedded in a string, but in this case, the leading
    `#` is left off.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 字符可以嵌入到字符串中，但在这种情况下，前导的 `#` 会被省略。
- en: '[PRE49]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can also use `string-append` on two strings to create a new string.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `string-append` 将两个字符串连接起来，创建一个新的字符串。
- en: '[PRE50]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To access a character within a string, use `string-ref`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问字符串中的字符，使用 `string-ref`：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The position of each character in a string is numbered starting from 0, so in
    this example using an index of 2 actually returns the third character.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中每个字符的位置从 0 开始编号，因此在这个例子中，使用索引 2 实际上返回的是第三个字符。
- en: The strings we have seen so far are immutable. To create a mutable string, use
    the `string` function. This allows changing characters in the string.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的字符串是不可变的。要创建一个可变字符串，请使用 `string` 函数。这允许在字符串中修改字符。
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that for mutable strings we have to define the string using individual
    characters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于可变字符串，我们必须使用单个字符来定义字符串。
- en: 'Another way to create a mutable string is with `string-copy`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可变字符串的另一种方式是使用 `string-copy`：
- en: '[PRE53]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can also use `make-string` to do the same thing:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `make-string` 来做同样的事情：
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Depending on what’s needed, any one of the above may be preferred. If you need
    to make an existing string mutable, `string-copy` is the obvious choice. If you
    only want a string of spaces, `make-string` is the clear winner.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要，以上任何一个都可能是优选项。如果你需要让现有的字符串变为可变的，`string-copy` 是显而易见的选择。如果你只想要一个空格字符串，`make-string`
    是明确的赢家。
- en: '***Useful String Functions***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***有用的字符串函数***'
- en: There are of course a number of other useful string functions, a few of which
    we illustrate next.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他有用的字符串函数，接下来我们将展示其中的一些。
- en: '**string-length**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串长度**'
- en: The `string-length` function outputs the number of characters in a string (see
    `wishy-washy` earlier in [“Strings” on page 14](ch01.xhtml#ch00lev2sec_10).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`string-length`函数输出字符串中的字符数（请参见之前在[第14页“字符串”](ch01.xhtml#ch00lev2sec_10)中的`wishy-washy`）。'
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**substring**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**substring**'
- en: The `substring` function extracts a substring from a given string.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring`函数从给定的字符串中提取子字符串。'
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**string-titlecase**'
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**string-titlecase**'
- en: Use `string-titlecase` to capitalize the first character of each word in a string.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`string-titlecase`将字符串中每个单词的首字母大写。
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**string-upcase**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**string-upcase**'
- en: 'To output a string in all caps, use `string-upcase`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串输出为大写形式，请使用`string-upcase`：
- en: '[PRE58]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**string-downcase**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**string-downcase**'
- en: 'Conversely, for a lowercase string, use `string-downcase`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，对于小写字符串，使用`string-downcase`：
- en: '[PRE59]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**string<=?**'
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**string<=?**'
- en: 'To perform an alphabetical comparison, use the `string<=?` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行字母比较，请使用`string<=?`函数：
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**string=?**'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**string=?**'
- en: 'The `string=?` function tests whether two strings are equal:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`string=?`函数用于测试两个字符串是否相等：'
- en: '[PRE61]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**string-replace**'
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**string-replace**'
- en: 'The `string-replace` function replaces part of a string with another string:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`string-replace`函数用于将字符串的部分内容替换为另一个字符串：'
- en: '[PRE62]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**string-contains?**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**string-contains?**'
- en: 'To test whether one string is contained within another, use `string-contains?`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个字符串是否包含在另一个字符串中，请使用`string-contains?`：
- en: '[PRE63]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**string-split**'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**string-split**'
- en: 'The `string-split` function can be used to split a string into tokens:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`string-split`函数可用于将字符串拆分为多个标记：'
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Notice that the first example above uses the default version that splits on
    spaces whereas the second version explictly uses a comma (,).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面的第一个示例使用了默认版本，它会根据空格拆分，而第二个版本明确使用了逗号（,）。
- en: '**string-trim**'
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**string-trim**'
- en: 'The `string-trim` function gets rid of any leading and/or trailing spaces:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`string-trim`函数用于去除字符串的前导和/或尾随空格：'
- en: '[PRE65]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice in the last two versions, `#:left?` or `#:right?` is used to suppress
    trimming the corresponding side. The final `#f` argument (the default) is used
    to specify that only one match is removed from each side; otherwise all initial
    or trailing matches are trimmed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最后两个版本中，`#:left?`或`#:right?`用于禁止修剪对应一侧的内容。最后的`#f`参数（默认值）用于指定每一侧只去掉一个匹配项；否则，所有的前导或尾随匹配项都会被去掉。
- en: For more advanced string functionality, see [“Regular Expressions” on page 279](ch10.xhtml#ch00lev2sec_75).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 更多高级字符串功能，请参见第279页的[“正则表达式”](ch10.xhtml#ch00lev2sec_75)。
- en: '***String Conversion and Formatting Functions***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串转换和格式化函数***'
- en: There are a number of functions that convert values to and from strings. They
    all have intuitive names and are illustrated below.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多函数可以将值转换为字符串或从字符串转换。它们的名称都很直观，下面有相关示例。
- en: '[PRE66]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: For a complete list of these, go to [*https://docs.racket-lang.org/reference/strings.html*](https://docs.racket-lang.org/reference/strings.html).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的列表，请访问[*https://docs.racket-lang.org/reference/strings.html*](https://docs.racket-lang.org/reference/strings.html)。
- en: A handy function to embed other values within a string is `format`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的函数用于在字符串中嵌入其他值的是`format`。
- en: '[PRE67]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Within the format statement, ˜`a` acts as a placeholder. There should be one
    placeholder for each additional argument. Note that the number 2 is automatically
    converted to a string before it’s embedded in the output string.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式化语句中，˜`a`充当占位符。每个额外的参数应该有一个占位符。请注意，数字2在嵌入到输出字符串中之前会自动转换为字符串。
- en: 'If you want to simply convert a number to a string, use the `number->string`
    function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想简单地将数字转换为字符串，请使用`number->string`函数：
- en: '[PRE68]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Conversely:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 相反：
- en: '[PRE69]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Trying to get Racket to translate the value of words into numbers, however,
    will not work:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试让Racket将单词的值转换为数字是行不通的：
- en: '[PRE70]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For more control we can use the ˜`r` function, defined in the *racket/format*
    library, which has many options that can be used to convert a number to a string
    and control the precision and other output characteristics of the number. For
    example, to show *π* to four decimal places, we would use this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多的控制，可以使用在*racket/format*库中定义的˜`r`函数，它提供了多种选项，可以将数字转换为字符串并控制数字的精度及其他输出特性。例如，要显示*π*到四位小数，可以使用以下方式：
- en: '[PRE71]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To show this right-justified, in a field 20 characters wide, and left padded
    with periods, we execute the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其右对齐，在20个字符宽的字段中并用句点填充左侧，可以执行以下操作：
- en: '[PRE72]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Additional info on ˜`r` is available in Appendix A, which talks about number
    bases. There are a number of other useful tilde-prefixed string conversion functions
    available, such as ˜`a`, ˜`v`, and ˜`s`. We won’t go into detail here, but you
    can consult the Racket Documentation for details: [*https://docs.racket-lang.org/reference/strings.html*](https://docs.racket-lang.org/reference/strings.html).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 ˜`r` 的更多信息，请参见附录 A，该附录讨论了数字基数。还有许多其他有用的波浪符前缀字符串转换函数，如 ˜`a`、˜`v` 和 ˜`s`。我们这里不做详细讨论，但你可以查阅
    Racket 文档了解更多信息：[ *https://docs.racket-lang.org/reference/strings.html*](https://docs.racket-lang.org/reference/strings.html)。
- en: Vectors
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量
- en: Vectors bear a superficial resemblance to lists, but they are quite different.
    In contrast to the internal tree structure of lists, *vectors* are a sequential
    array of cells (much like arrays in imperative languages) that directly contain
    values, as illustrated in [Figure 1-3](ch01.xhtml#ch1fig3).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 向量看起来与列表有些相似，但实际上它们大不相同。与列表的内部树结构不同，*向量*是一个顺序数组（类似于命令式语言中的数组），直接包含值，如[图 1-3](ch01.xhtml#ch1fig3)所示。
- en: '![Image](../images/01fig03.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig03.jpg)'
- en: '*Figure 1-3: Vector structure*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-3：向量结构*'
- en: Vectors can be entered using the `vector` function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 向量可以通过 `vector` 函数来输入。
- en: '[PRE73]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Alternatively, vectors can be entered using `#` as follows (note that an unquoted
    `#` implies a quote):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，向量可以通过使用 `#` 来输入，如下所示（请注意，未加引号的 `#` 表示一个引用）：
- en: '[PRE74]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'It’s important to note that these methods are *not* equivalent. Here’s one
    reason why:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这些方法是 *不* 等价的。以下是一个原因：
- en: '[PRE75]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the first example, just as for `list`, `vector` first evaluates its arguments
    before forming the vector. In the last example, like `quote`, `#` does not evaluate
    its arguments. More importantly, `#` is an alias for `vector-immutable`, which
    leads to our next topic.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，就像 `list` 一样，`vector` 会先评估它的参数，然后再形成向量。在最后一个示例中，像 `quote` 一样，`#` 不会评估它的参数。更重要的是，`#`
    是 `vector-immutable` 的别名，这也引出了我们下一个话题。
- en: '***Accessing Vector Elements***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问向量元素***'
- en: 'The function `vector-ref` is an indexing operator that returns an element of
    a vector. This function takes a vector as its first argument and an index as its
    second:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `vector-ref` 是一个索引操作符，用于返回向量的元素。该函数将一个向量作为第一个参数，一个索引作为第二个参数：
- en: '[PRE76]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To assign a value to a vector cell, `vector-set!` is used. The `vector-set!`
    expression takes three arguments: a vector, an index, and a value to be assigned
    to the indexed position in the vector.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要给向量单元赋值，使用 `vector-set!`。`vector-set!` 表达式接受三个参数：一个向量、一个索引和一个要赋给该索引位置的值。
- en: '[PRE77]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let’s try this a bit differently:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来尝试一种不同的方式：
- en: '[PRE78]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Remember that `#` is an alias for `vector-immutable`. What this means is that
    vectors created with `#` (or `vector-immutable`) are (drum roll . . . ) *immutable*:
    they cannot be changed or assigned new values. On the other hand, vectors created
    with `vector` are *mutable*, meaning that their cells can be modified.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`#` 是 `vector-immutable` 的别名。这意味着通过 `#`（或 `vector-immutable`）创建的向量是（敲锣打鼓。。。）*不可变的*：它们不能被更改或赋予新值。另一方面，通过
    `vector` 创建的向量是 *可变的*，意味着它们的单元可以被修改。
- en: One advantage of vectors over lists is that elements of vectors can be accessed
    much faster than elements of lists. This is because to access the 100th element
    of a list, each cell of the list must be accessed sequentially to get to the 100th
    element. Conversely, with vectors, the 100th element can be accessed directly,
    without working through earlier cells. On the other hand, lists are quite flexible
    and can easily be extended as well as being used to represent other data structures
    like trees. They are the bread and butter of Racket (and all Lisp-based languages),
    so much of the functionality of the language depends on the list structure. Predictably,
    functions are provided to easily convert from one to the other.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 向量相对于列表的一个优势是，向量的元素可以比列表的元素访问得更快。这是因为要访问列表的第 100 个元素，必须按顺序访问列表中的每个单元，直到达到第 100
    个元素。相反，对于向量，可以直接访问第 100 个元素，而无需遍历之前的单元。另一方面，列表非常灵活，可以轻松扩展，还可以用来表示其他数据结构，如树。它们是
    Racket（以及所有基于 Lisp 的语言）的核心，因此语言的大部分功能依赖于列表结构。可预见地，提供了将两者相互转换的函数。
- en: '***Useful Vector Functions***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***常用的向量函数***'
- en: '**vector-length**'
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**向量长度**'
- en: 'The `vector-length` function returns the number of elements in a vector:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector-length` 函数返回向量中元素的数量：'
- en: '[PRE79]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '**vector-sort**'
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**向量排序**'
- en: 'The `vector-sort` function sorts the elements of a vector:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector-sort` 函数对向量的元素进行排序：'
- en: '[PRE80]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: To whet your appetite for what’s to come later, `vector-sort` is a typical example
    of functional programming. The last argument actually evaluates a function that
    determines the direction of the sort.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激发你对后面内容的兴趣，`vector-sort` 是函数式编程的典型例子。最后一个参数实际上会评估一个函数，用来确定排序的方向。
- en: '**vector->list**'
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**vector->list**'
- en: 'The `vector->list` function takes a vector and returns a list:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector->list` 函数将一个向量转换为一个列表：'
- en: '[PRE81]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '**list->vector**'
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**list->vector**'
- en: 'Conversely `list->vector` takes a list and returns a vector:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`list->vector` 将一个列表转换为向量：
- en: '[PRE82]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '**make-vector**'
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**make-vector**'
- en: 'To create a mutable vector, use the `make-vector` form:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可变向量，使用 `make-vector` 形式：
- en: '[PRE83]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**vector-append**'
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**vector-append**'
- en: 'To concatenate two vectors together, use `vector-append`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要将两个向量连接在一起，使用 `vector-append`：
- en: '[PRE84]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '**vector-member**'
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**vector-member**'
- en: 'The `vector-member` function returns the index to where an item is located
    in a vector:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector-member` 函数返回项目在向量中的索引位置：'
- en: '[PRE85]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: There are of course many other useful vector functions, and we will explore
    some of them in the chapters to come.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他有用的向量函数，我们将在接下来的章节中探索其中的一些。
- en: Using structs
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用结构体
- en: 'To introduce the next Racket feature, let’s build an example program. Instead
    of keeping your checkbook transactions in a paper bankbook, you could create an
    electronic version using Racket. Typically such transactions have the following
    components:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍下一个 Racket 特性，让我们构建一个示例程序。你可以用 Racket 创建一个电子版的支票簿，而不是在纸质银行本上记录交易。通常，这样的交易包含以下组件：
- en: Transaction date
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易日期
- en: Payee
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收款人
- en: Check number
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支票号码
- en: Amount
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金额
- en: 'One way to keep track of these disparate pieces of information is in a Racket
    structure called a `struct`. A Racket `struct` is conceptually similar to a `struct`
    in languages such as C or C++. It’s a composite data structure that has a set
    of predefined fields. Before you can use a `struct`, you have to tell Racket what
    it looks like. For our bank transaction example, such a definition might look
    like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪这些不同信息的一个方法是使用 Racket 结构体，称为 `struct`。Racket 中的 `struct` 概念上类似于 C 或 C++ 等语言中的
    `struct`。它是一种复合数据结构，包含一组预定义的字段。在使用 `struct` 之前，必须告诉 Racket 它的样子。对于我们的银行交易示例，这样的定义可能是这样的：
- en: '[PRE86]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Each of the components of a structure (`date`, `payee`, etc.) is called a *field*.
    Once we’ve defined our `transaction struct`, we can create one like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 结构的每个组件（`date`、`payee` 等）都称为*字段*。一旦我们定义了 `transaction struct`，我们可以像这样创建一个：
- en: '[PRE87]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Racket automatically creates an *accessor method* for each of the fields in
    the structure. An accessor method returns the value of the field. They always
    begin with the name of the structure (in this case `transaction`), a hyphen, and
    then the name of the field.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 会自动为结构中的每个字段创建一个*访问器方法*。访问器方法返回字段的值。它们总是以结构体的名称（在本例中为 `transaction`）、连字符和字段名开头。
- en: '[PRE88]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Suppose, however, that you made a mistake and determined that the check to
    John Doe should have been for $100.12 instead of $100.10 and try to correct it
    via `set-transaction-amount!`. Note the exclamation point: this is a signal that
    `set-transaction-amount!` is a *mutator*, that is, a method that modifies a field
    value). These mutators are generated when the struct is defined and typically
    start with `set` and end with `!`.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你犯了个错误，发现支付给 John Doe 的支票应该是 $100.12 而不是 $100.10，并尝试通过 `set-transaction-amount!`
    来修正它。注意感叹号：这是一个信号，表示 `set-transaction-amount!` 是一个*变异器*，即修改字段值的方法。这些变异器在定义结构时生成，通常以
    `set` 开头并以 `!` 结尾。
- en: '[PRE89]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Oops . . . Fields in a structure are immutable by default and hence do not export
    *mutators*. The way around this is to include the `#:mutable` keyword in the structure
    definition for any field that may need to be modified.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。。。结构体中的字段默认是不可变的，因此不会导出*变异器*。解决方法是在结构定义中为需要修改的字段包含 `#:mutable` 关键字。
- en: '[PRE90]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: If all the fields should be mutable, adding the `#:mutable` keyword after the
    field list will do the trick.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有字段都应是可变的，可以在字段列表后添加 `#:mutable` 关键字。
- en: '[PRE91]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: While the accessor methods are sufficient for getting the value of a single
    field, they are a bit cumbersome for seeing all the values at once. Just entering
    the structure name does not yield much information.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然访问器方法足以获取单个字段的值，但它们在查看所有值时有些繁琐。仅输入结构名称并不会提供太多信息。
- en: '[PRE92]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: To make your structure more transparent, include the `#:transparent` option
    in the `struct` definition.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的结构更加透明，在 `struct` 定义中包含 `#:transparent` 选项。
- en: '[PRE93]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: There are additional useful options that can be applied when defining structures,
    but one that is of particular interest is `#:guard`. `#:guard` provides a mechanism
    to validate the fields when a structure is constructed. For instance, to ensure
    that negative check numbers are not used, we could do the following.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义结构时，有一些额外的有用选项，其中一个特别值得关注的是 `#:guard`。`#:guard` 提供了一种机制，用于在构造结构时验证字段。例如，为了确保不使用负的支票号，我们可以采取以下措施。
- en: '[PRE94]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Don’t panic. We haven’t covered that funny-looking symbol (*λ*, or *lambda*)
    yet, but you should be able to get the gist of what’s going on. The `#:guard`
    expression is a function that takes one parameter for each field and one additional
    parameter that contains the structure name. In this case we’re only testing whether
    the check number is greater than zero. The `#:guard` expression must return the
    same number of values as the number of fields in the `struct`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 别慌张。我们还没有介绍那个看起来有点奇怪的符号（*λ*，或 *lambda*），但你应该能理解发生了什么。`#:guard` 表达式是一个函数，它为每个字段接受一个参数，并且还有一个额外的参数，包含结构的名称。在这个例子中，我们只是测试支票号是否大于零。`#:guard`
    表达式必须返回与 `struct` 中字段数量相同的值。
- en: In the previous example we simply returned the same values that were entered,
    but suppose we had a variable that contained the last check number called `last-check`.
    In this case, we could enter a 0 for the check number and use the `#:guard` expression
    to plug in the next available number as shown here.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是返回了输入的相同值，但假设我们有一个变量保存了最后的支票号，叫做 `last-check`。在这种情况下，我们可以输入 0 作为支票号，并使用
    `#:guard` 表达式插入下一个可用的号码，如下所示。
- en: '[PRE95]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'As you can see, non-zero check numbers are stored as the last check number,
    but if a zero is entered for the check number, the `struct` value gets generated
    with the next available number, which becomes the current value for `last-check`.
    The `cond` statement will be explained in more detail a bit later in the book,
    but its use here should be fairly clear: it’s a way to check multiple cases.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，非零的支票号被存储为最后的支票号，但如果输入了零作为支票号，`struct` 值将使用下一个可用的号码生成，这个号码成为 `last-check`
    的当前值。`cond` 语句将在本书稍后详细解释，但它在这里的使用应该相当清晰：它是用来检查多个情况的一种方式。
- en: Controlling Output
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制输出
- en: In the interactions pane, DrRacket immediately displays the output resulting
    from evaluating any expression. It’s often desirable to have some control over
    how the output is presented. This is especially important when the output is being
    generated by some function or method. Racket provides a number of mechanisms for
    generating formatted output. The main forms are `write`, `print`, and `display`.
    Each of these works in a slightly different way. The best way to illustrate this
    is with examples.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互面板中，DrRacket 会立即显示评估任何表达式后的输出。通常我们希望对输出的呈现方式进行一定控制。当输出是由某个函数或方法生成时，这一点尤其重要。Racket
    提供了多种生成格式化输出的机制。主要的形式有 `write`、`print` 和 `display`。每种方式的工作方式略有不同。最好的说明方法是通过示例。
- en: '**write**'
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**write**'
- en: 'The `write` expression outputs in such a way that the output value forms a
    valid value that can be used in the input:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 表达式的输出方式使得输出值形成一个有效的值，这个值可以在输入中使用：'
- en: '[PRE96]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '**display**'
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**display**'
- en: 'The `display` expression is similar to `write`, but strings and character data
    types are written as raw strings and characters without any adornments such as
    quotation or tick marks:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`display` 表达式与 `write` 类似，但字符串和字符数据类型会原样输出，不会添加任何修饰符，如引号或反引号：'
- en: '[PRE97]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '**print**'
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**print**'
- en: 'The `print` expression is also similar to `write`, but adds a bit more formatting
    to the output. The intent of `print` is to show an expression that would evaluate
    to the same value as the printed one:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 表达式也类似于 `write`，但它为输出添加了一些额外的格式化。`print` 的目的是展示一个表达式，该表达式在计算后会得到与打印的值相同的结果：'
- en: '[PRE98]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Notice how the rational value `1/2` is printed (more on rationals in the next
    chapter).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意理性数值 `1/2` 是如何被打印的（关于有理数的内容将在下一章讲解）。
- en: Each of these comes in a form that ends with `ln`. The only difference is that
    the ones that end with `ln` automatically print a new line at the end. Here are
    a couple of examples to highlight the difference.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 每种表达式都有一个以 `ln` 结尾的形式。唯一的区别是，带有 `ln` 结尾的会自动在输出末尾打印一个新行。以下是几个例子来突出这个区别。
- en: '[PRE99]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'One very useful form is `printf`. The `printf` expression works much like the
    `format` function: it takes a format string as its first argument and any number
    of other values as its other argument. The format string uses ˜`a` as a placeholder.
    There must be one placeholder for each of the arguments after the format string.
    The format string is printed exactly as entered, with the exception that for each
    placeholder the corresponding argument is substituted. Here’s `printf` in action.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的形式是`printf`。`printf`表达式的工作方式类似于`format`函数：它将一个格式字符串作为第一个参数，其他值作为随后的参数。格式字符串使用˜`a`作为占位符。格式字符串之后的每个参数必须对应一个占位符。格式字符串会按输入的方式打印，唯一的例外是每个占位符会被相应的参数替换。下面是`printf`的示例。
- en: '[PRE100]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: There are additional format specifiers (see the Racket Documentation for details),
    but we’ll mostly be using `print` since it gives a better visual indication of
    the data type of the value being output.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些额外的格式说明符（详细信息请参阅Racket文档），但我们主要使用`print`，因为它能更好地视觉化输出值的数据类型。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we laid the groundwork for what’s to come. Most of the core
    data types have been introduced along with what are hopefully some helpful examples.
    By now you should be comfortable with basic Racket syntax and have a pretty good
    understanding of the structure of lists and how to manipulate them. The next chapter
    will take a detailed look at the various numeric data types provided by Racket.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为接下来的内容奠定了基础。大多数核心数据类型已被介绍，并附有一些希望能帮助理解的示例。到目前为止，你应该已经对基础的Racket语法感到熟悉，并且对列表的结构以及如何操作它们有了相当好的理解。下一章将详细讲解Racket提供的各种数字数据类型。
