- en: '18'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '18'
- en: A CATALOG OF TIPS AND REUSABLE SOLUTIONS FOR CREATING GREAT PROJECTS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建优秀项目的技巧和可重用解决方案目录
- en: '*Experience is a hard teacher because she gives the test first, the lesson
    afterwards.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*经验是一个严厉的老师，因为她先给测试，然后才教课。'
- en: —Vernon Sanders Law^([1](footnote.xhtml#ch18fn1))*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —Vernon Sanders Law^([1](footnote.xhtml#ch18fn1))*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter began as a catalog of reusable solutions—canned macros, if you
    will. But as I finished the chapters preceding this one, it became clear to me
    that I needed to broaden my definition of a *canned solution*. Instead of just
    cataloging interesting macros, this chapter lists several unrelated but important
    tips for creating great projects. Some of these are related to the GNU Autotools,
    but others are merely good programming practice with respect to open source and
    free software projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最初是作为一个可重用解决方案的目录——可以说是预设宏。但当我完成了之前的章节后，我意识到我需要拓宽我对 *预设解决方案* 的定义。与其仅仅列出有趣的宏，本章列出了几个不相关但对创建优秀项目非常重要的技巧。其中一些与
    GNU Autotools 相关，但其他的只是涉及开源和自由软件项目的良好编程实践。
- en: 'Item 1: Keeping Private Details out of Public Interfaces'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 1：将私有细节与公共接口隔离
- en: At times, I’ve come across poorly designed library interfaces where a project’s
    *config.h* file is required by the project’s public header files. This presents
    a problem when more than one such library is required by a consumer. Which *config.h*
    file should be included? Both have the same name, and chances are that both provide
    similar or identically named definitions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我遇到过设计不良的库接口，其中一个项目的 *config.h* 文件是该项目公共头文件所必须的。当消费者需要多个这样的库时，就会出现问题。应该包含哪个
    *config.h* 文件呢？它们的名字相同，而且很可能提供了相似或相同的定义。
- en: When you carefully consider the purpose of *config.h*, you see that it makes
    little sense to expose it in a library’s public interface (by including it in
    any of the library’s public header files), because its purpose is to provide platform-specific
    definitions to a particular build of the library. On the other hand, the public
    interface of a portable library is, by definition, platform independent.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你仔细考虑 *config.h* 的目的时，你会发现将其暴露在库的公共接口中（通过将其包含在任何公共头文件中）没有多大意义，因为它的目的是为库的特定构建提供平台特定的定义。另一方面，便携库的公共接口定义上是平台无关的。
- en: Interface design is a fairly general topic in computer science. This item focuses
    a bit more specifically on how to avoid including *config.h* in your public interfaces
    and, by extension, ensuring that you never install *config.h*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接口设计是计算机科学中的一个相当通用的话题。这个项目专注于如何避免在公共接口中包含 *config.h*，并通过这一点，确保你永远不要安装 *config.h*。
- en: When designing a library for consumption by other projects, you’re responsible
    for not polluting your consumers’ symbol spaces with useless garbage from your
    header files. I once worked on a project that consumed a library interface from
    another team. This team provided both a Windows and a Unix version of their library,
    with the header file being portable between the two platforms. Unfortunately,
    they didn’t understand the definition of a clean interface. At some point in their
    public header files, they had a bit of code that looked like [Listing 18-1](ch18.xhtml#ch18ex1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在为其他项目设计库时，你有责任避免将无用的垃圾从你的头文件污染到消费者的符号空间。我曾经参与过一个项目，它使用了来自另一个团队的库接口。该团队提供了 Windows
    和 Unix 版本的库，头文件在这两个平台之间是可移植的。不幸的是，他们没有理解干净接口的定义。在他们的公共头文件中，某个地方有一段代码看起来像是 [清单
    18-1](ch18.xhtml#ch18ex1)。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 18-1: A poorly designed public header file that exposes platform-specific
    header files*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-1：一个设计不良的公共头文件，暴露了平台特定的头文件*'
- en: Ouch! Did they really need to include *windows.h* just for the definition of
    `HANDLE`? No, and they probably should have used a different name for the handle
    object in their public interface because `HANDLE` is too generic and could easily
    conflict with a dozen other library interfaces. Something like `XYZ_HANDLE` or
    something more specific to the *XYZ* library would have been a better choice.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！他们真的需要仅仅为了定义 `HANDLE` 就包含 *windows.h* 吗？不需要，他们可能应该为其公共接口中的句柄对象使用一个不同的名称，因为
    `HANDLE` 太过通用，容易与其他许多库的接口冲突。像 `XYZ_HANDLE` 或更具体的与 *XYZ* 库相关的名称会是更好的选择。
- en: To properly design a library, first design the public interface to expose as
    little of the library’s internals as is reasonable. Now, you’ll have to determine
    the definition of *reasonable*, but it will probably involve a compromise between
    abstraction and performance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确设计一个库，首先设计公共接口，尽可能少地暴露库的内部实现。现在，你需要确定*合理*的定义是什么，但这通常会在抽象和性能之间进行折衷。
- en: When designing an API, start with the functionality you want to expose from
    your library; design functions that will maximize ease of use. If you find yourself
    trying to decide between a simpler implementation and a simpler user experience,
    always err on the side of ease of use for your consumers. They’ll thank you by
    actually using your library. Of course, if the interface is already defined by
    a software standard, then much of your work is done for you. Often this is not
    the case, and you will have to make these decisions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计API时，从你想要暴露的库功能开始；设计能最大化易用性的函数。如果你发现自己在选择更简单的实现和更简单的用户体验之间犹豫不决，始终倾向于为消费者提供更易用的体验。他们会通过实际使用你的库来感谢你。当然，如果接口已经由软件标准定义，那么你的工作大部分已经完成。通常情况并非如此，你将不得不做出这些决策。
- en: 'Next, try to abstract away internal details. Unfortunately, the C language
    doesn’t make this easy to do because you often need to pass structure references
    in public APIs containing internal details of your implementation that consumers
    don’t need to see. (C++ is actually worse in this area: C++ classes define public
    interfaces and private implementation details in the same class definition.)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试抽象掉内部细节。不幸的是，C语言并不容易做到这一点，因为你通常需要在公共API中传递包含内部实现细节的结构引用，而消费者不需要看到这些细节。（C++在这方面实际上更糟：C++类在同一个类定义中定义公共接口和私有实现细节。）
- en: '*Solutions in C*'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*C中的解决方案*'
- en: In C, a common solution for this problem is to define a public alias for a private
    structure in terms of a generic (`void`) pointer. Many developers don’t care for
    this approach because it reduces type safety in the interface, but the loss of
    type safety is significantly offset by the increase in interface abstraction,
    as shown in [Listings 18-2](ch18.xhtml#ch18ex2) and [18-3](ch18.xhtml#ch18ex3).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，解决这个问题的常见方法是为私有结构定义一个公共别名，通常是通过通用（`void`）指针。许多开发者不喜欢这种方法，因为它降低了接口的类型安全性，但类型安全性的丧失被接口抽象化的提升大大抵消了，正如[示例18-2](ch18.xhtml#ch18ex2)和[18-3](ch18.xhtml#ch18ex3)所示。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 18-2: An example of a private C-language source file*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例18-2：一个私有C语言源文件的示例*'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 18-3:* abc_pub.h: *A public header file describing a public interface
    (API)*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例18-3：* abc_pub.h：*一个描述公共接口（API）的公共头文件*'
- en: Notice that the abstraction conveniently alleviates the need to include a bunch
    of really private definitions in the library’s public interface.^([2](footnote.xhtml#ch18fn2))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，抽象化方便地减轻了在库的公共接口中包含大量非常私有定义的需求。^([2](footnote.xhtml#ch18fn2))
- en: But there’s a way that makes even better use of language syntax. In C, there’s
    a little-known, and even less used, concept called a *forward declaration* that
    allows you to name the type in a public header file without actually defining
    it there. [Listing 18-4](ch18.xhtml#ch18ex4) provides an example of a library’s
    public header file that uses a forward declaration for the type used in the function
    declaration.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一种方法可以更好地利用语言语法。在C语言中，有一个鲜为人知、且使用更少的概念，叫做*前向声明*，它允许你在公共头文件中仅仅声明类型，而不必在那里实际定义它。[示例18-4](ch18.xhtml#ch18ex4)提供了一个使用前向声明来定义函数声明中使用的类型的库公共头文件的示例。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 18-4: Using a forward declaration in a public header file*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例18-4：在公共头文件中使用前向声明*'
- en: Of course, this use of `struct abc` assumes that some other function in your
    public interface returns pointers to objects of that type that you can then pass
    into `abc_func`. If your user is responsible for filling out the structure before
    passing its address, then this mechanism will obviously not work for you. Rather,
    its use here is for the sole purpose of hiding the internals of `struct abc`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用`struct abc`假设你的公共接口中的其他函数返回该类型对象的指针，你可以将其传递给`abc_func`。如果用户需要在传递其地址之前填写结构体，那么这个机制显然不适用。相反，这里的使用仅仅是为了隐藏`struct
    abc`的内部实现。
- en: '*Solutions in C++*'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*C++中的解决方案*'
- en: Forward declarations can also be used in C++, but not in the same manner. In
    C++, forward declarations are used more to minimize compile-time header file interdependencies
    than to hide implementation details in public interfaces. We can use other techniques,
    however, to hide implementation details from users.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中也可以使用前向声明，但方式不同。在 C++ 中，前向声明更多用于最小化编译时头文件之间的相互依赖，而不是在公共接口中隐藏实现细节。然而，我们可以使用其他技术来将实现细节隐藏在用户之外。
- en: In C++, hiding implementation details with interface abstraction can be done
    in a few different ways, which include using virtual interfaces and the *PIMPL
    (Private IMPLementation)* pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，使用接口抽象来隐藏实现细节可以通过几种不同的方式完成，其中包括使用虚拟接口和 *PIMPL（私有实现）*模式。
- en: The PIMPL Pattern
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: PIMPL 模式
- en: In the PIMPL pattern, implementation details are hidden behind a pointer to
    a private implementation class stored as private data within the public interface
    class, as shown in [Listings 18-5](ch18.xhtml#ch18ex5) and [18-6](ch18.xhtml#ch18ex6).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PIMPL 模式中，实现细节通过指向一个私有实现类的指针隐藏，该指针作为公共接口类中的私有数据存储，正如 [清单 18-5](ch18.xhtml#ch18ex5)
    和 [18-6](ch18.xhtml#ch18ex6) 中所示。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 18-5: A private C++-language source file showing the proper use of
    the PIMPL pattern*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-5：一个私有的 C++ 语言源文件，展示了 PIMPL 模式的正确使用*'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 18-6:* abc_pub.h: *The public header file exposes few private details
    via the PIMPL pattern.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-6:* abc_pub.h: *公共头文件通过 PIMPL 模式仅暴露少量私有细节。*'
- en: As mentioned previously, the C++ language also allows the use of a forward declaration
    (like the one at ➊) for any types used only through references or pointers (as
    at ➋) but never actually dereferenced in the public interface. Thus, the definition
    of the implementation class need not be exposed in the public interface because
    the compiler will happily compile the public interface header file without the
    definition of the private implementation class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，C++ 语言也允许使用前向声明（如 ➊ 处的声明），用于任何仅通过引用或指针使用的类型（如 ➋ 所示），但在公共接口中从未实际取消引用。因此，私有实现类的定义不需要暴露在公共接口中，因为编译器可以愉快地编译公共接口头文件，而不需要私有实现类的定义。
- en: The performance tradeoff here generally involves the dynamic allocation of an
    instance of the private implementation class and then the access of class data
    indirectly through this pointer, rather than directly in the public structure.
    Notice that all internal details are now conveniently hidden and thus not required
    by the public interface.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的性能权衡通常涉及动态分配一个私有实现类的实例，然后通过这个指针间接访问类的数据，而不是直接在公共结构体中访问。请注意，所有内部细节现在都方便地隐藏了，因此公共接口不需要这些细节。
- en: C++ Virtual Interfaces
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: C++ 虚拟接口
- en: Another approach when using C++ is to define a public *interface* class, whose
    methods are declared *pure virtual*, with the interface implemented internally
    by the library. To access an object of this class, consumers call a public *factory*
    function, which returns a pointer to the implementation class in terms of the
    interface definition. [Listings 18-7](ch18.xhtml#ch18ex7) and [18-8](ch18.xhtml#ch18ex8)
    illustrate the concept of C++ virtual interfaces.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++ 的另一种方法是定义一个公共的 *接口* 类，其方法被声明为 *纯虚拟*，接口由库内部实现。要访问该类的对象，消费者调用一个公共的 *工厂*
    函数，该函数返回指向实现类的指针，并以接口定义的形式表示。[清单 18-7](ch18.xhtml#ch18ex7) 和 [18-8](ch18.xhtml#ch18ex8)
    展示了 C++ 虚拟接口的概念。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 18-7: A private C++ language source file implementing a pure virtual
    interface*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-7：一个私有的 C++ 语言源文件，实施了一个纯虚拟接口*'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 18-8:* abc_pub.h: *A public C++ language header file, providing only
    the interface definition*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-8:* abc_pub.h: *一个公共的 C++ 语言头文件，仅提供接口定义*'
- en: Here, I use the C++ preprocessor to define a new keyword, `xyz_interface`. By
    definition, `xyz_interface` is synonymous with `class`, so the terms may be used
    interchangeably. The idea here is that an interface doesn’t expose any implementation
    details to the consumer. The public *factory* function `abc_instantiate` at ➊
    returns a pointer to a new object of type `abc_impl`, except in terms of `abc`.
    Thus, nothing internal needs to be shown to the caller in the public header file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用 C++ 预处理器定义了一个新的关键字 `xyz_interface`。根据定义，`xyz_interface` 与 `class` 同义，因此可以互换使用。这里的理念是接口不会向消费者暴露任何实现细节。公共的
    *工厂* 函数 `abc_instantiate` 在 ➊ 返回一个指向 `abc_impl` 类型新对象的指针，除了 `abc` 之外。因此，公共头文件中不需要显示任何内部内容给调用者。
- en: It may seem like the virtual interface class method is more efficient than the
    PIMPL method, but the fact is that most compilers implement virtual function calls
    as tables of function pointers referred to by a hidden *vptr* address within the
    implementation class. As a result, you still end up calling all of your public
    methods indirectly through a pointer. The technique you choose to help hide your
    implementation details is more a matter of personal preference than performance.^([3](footnote.xhtml#ch18fn3))
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来虚拟接口类的方法比 PIMPL 方法更高效，但实际上，大多数编译器将虚拟函数调用实现为由隐藏的 *vptr* 地址引用的函数指针表，存在于实现类中。因此，你最终还是会通过指针间接调用所有公共方法。你选择隐藏实现细节的技术更多是个人偏好的问题，而不是性能问题。^([3](footnote.xhtml#ch18fn3))
- en: When I design a library, I first design a minimal, but complete, functional
    interface with as much of my internal implementation abstracted away as is reasonable.
    I try to use only standard library basic types, if possible, in my function prototypes
    and then include only the C or C++ standard header files required by the use of
    those types and definitions. This technique is the fastest way I’ve found to create
    a highly portable and maintainable interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我设计一个库时，我首先设计一个最小的，但完整的，功能接口，并尽可能多地将我的内部实现抽象化。我尽量在函数原型中只使用标准库的基本类型，然后仅包含那些由这些类型和定义所需的
    C 或 C++ 标准头文件。这种技巧是我发现的创建高可移植性和可维护性接口的最快方法。
- en: If you still can’t see the value in the advice offered by this item, then let
    me give you one more scenario to ponder. Consider what happens when a Linux distro
    packager decides to create a *devel* package for your library—that is, a package
    containing static libraries and header files, designed to be installed into the
    */usr/lib* and */usr/include* directories on a target system. Every header file
    required by your library must be installed into the */usr/include* directory.
    If your library’s public interface requires the inclusion of your *config.h* file,
    then by extension your *config.h* file must be installed into the */usr/include*
    directory. Now consider what happens when multiple such libraries need to be installed.
    Which copy of *config.h* will win? Only one *config.h* file can exist in */usr/include*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然看不出这条建议的价值，那么让我给你再提供一个情景来思考。考虑一下当一个 Linux 发行版的打包者决定为你的库创建一个 *devel* 包时会发生什么——即，一个包含静态库和头文件的包，设计用于安装到目标系统的
    */usr/lib* 和 */usr/include* 目录中。你的库所需的每一个头文件必须安装到 */usr/include* 目录中。如果你的库的公共接口需要包含你的
    *config.h* 文件，那么扩展来说，你的 *config.h* 文件必须安装到 */usr/include* 目录中。现在考虑一下当多个此类库需要安装时会发生什么。哪一份
    *config.h* 文件会被保留？在 */usr/include* 目录中只能存在一个 *config.h* 文件。
- en: I’ve seen message threads on the Autotools mailing lists defending the need
    to publish *config.h* in a public interface and providing techniques for naming
    *config.h* in a package-specific manner. These techniques often involve some form
    of post-processing of this file to rename its macros so they don’t conflict with
    *config.h* definitions installed by other packages. While this can be done, and
    while there are a few good reasons for doing so (usually involving a widely used
    legacy code base that can’t be modified without breaking a lot of existing code),
    these situations should be considered the exception, not the rule, because a well-designed
    project should not need to expose platform- and project-specific definitions in
    its public interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 Autotools 邮件列表上看到过一些讨论，支持在公共接口中发布 *config.h* 的必要性，并提供一些为包特定方式命名 *config.h*
    的技巧。这些技巧通常涉及对该文件进行某种形式的后处理，以重命名其宏，以避免与其他包安装的 *config.h* 定义冲突。虽然这样做是可行的，并且在某些情况下有一些合理的理由（通常是涉及到一个无法修改的广泛使用的遗留代码库，修改它会破坏大量现有代码），但这些情况应该被视为例外，而不是常规，因为一个设计良好的项目不应该需要在其公共接口中暴露平台和项目特定的定义。
- en: If your project simply can’t live without *config.h* in its public interface,
    explore the nuances of the `AC_CONFIG_HEADERS` macro. Like all of the instantiating
    macros, this macro accepts a list of input files. The `autoheader` utility only
    writes the first input file in the list, so you can hand-create a second input
    file that contains definitions that you feel must be included in your public interface.
    Remember to name your public input file so as to reduce conflict with other packages’
    public interfaces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目在公共接口中无法没有*config.h*，可以探索`AC_CONFIG_HEADERS`宏的细节。像所有实例化宏一样，这个宏接受一个输入文件列表。`autoheader`工具只会写入列表中的第一个输入文件，因此你可以手动创建第二个输入文件，包含你认为必须包含在公共接口中的定义。记得命名你的公共输入文件，以减少与其他包公共接口的冲突。
- en: '**NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Also, explore the *`AX_PREFIX_CONFIG_H`* macro, found in the Autoconf Macro
    Archive (see “Item 8: Using the Autoconf Archive Project” on [page 528](ch18.xhtml#page_528),
    which will add a custom prefix to all items found in* config.h.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*此外，还可以探索Autoconf宏库中的*`AX_PREFIX_CONFIG_H`*宏（见“项目8：使用Autoconf宏库”在[第528页](ch18.xhtml#page_528)），它会为config.h中的所有项添加自定义前缀。*'
- en: 'Item 2: Implementing Recursive Extension Targets'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目2：实现递归扩展目标
- en: An *extension target* is a `make` target that you write to accomplish some build
    goal that Automake doesn’t automatically support. A *recursive extension target*
    is one that traverses your project directory structure, visiting every *Makefile.am*
    file in your Autotools build system and giving each one the opportunity to do
    some work when the extension target is made.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展目标*是你为实现某个构建目标而编写的`make`目标，Automake并不会自动支持该目标。*递归扩展目标*是那种遍历你的项目目录结构，访问Autotools构建系统中的每个*Makefile.am*文件，并在扩展目标被创建时为每个文件提供执行操作的机会。'
- en: When you add a new top-level target to your build system, you have to either
    tie it into an existing Automake target or add your own `make` code to the desired
    target that traverses the subdirectory structure provided by Automake in your
    build system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向构建系统中添加新的顶级目标时，你必须将其绑定到现有的Automake目标，或者将你自己的`make`代码添加到所需的目标中，来遍历Automake在你的构建系统中提供的子目录结构。
- en: The `SUBDIRS` variable is used to recursively traverse all subdirectories of
    the current directory, passing requested build commands into the makefiles in
    these directories. This works great for targets that must be built based on configuration
    options, because after configuration, the `SUBDIRS` variable contains only those
    directories destined to be built.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUBDIRS`变量用于递归遍历当前目录的所有子目录，并将请求的构建命令传递到这些目录中的makefile。这对于那些必须基于配置选项构建的目标非常有效，因为在配置之后，`SUBDIRS`变量仅包含那些注定要被构建的目录。'
- en: However, if you need to execute your new recursive target in *all* subdirectories,
    regardless of any conditional configuration that might exclude a subdirectory
    specified in `SUBDIRS`, use the `DIST_SUBDIRS` variable instead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要在*所有*子目录中执行新的递归目标，不管`SUBDIRS`中是否排除了某些目录，你可以使用`DIST_SUBDIRS`变量。
- en: There are various ways to traverse the build hierarchy, including some really
    simple one-liners provided by GNU `make`-specific syntax. But the most portable
    way is to use the technique that Automake itself uses, as shown in [Listing 18-9](ch18.xhtml#ch18ex9).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以遍历构建层次结构，包括GNU `make`特有语法提供的一些非常简单的一行命令。但最具可移植性的方法是使用Automake本身使用的技术，如[清单18-9](ch18.xhtml#ch18ex9)所示。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 18-9: A makefile with a recursive target (WARNING: no support for
    "`.`" in `SUBDIRS`)*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-9：具有递归目标的makefile（警告：`SUBDIRS`中不支持“`.`”）*'
- en: At some point in the hierarchy, you’ll need to do something useful besides calling
    down to lower levels. The `preorder_commands` macro at ➊ can be used to do things
    that must be done before recursing into lower-level directories. The `postorder_commands`
    macro at ➋ can likewise be used to do additional things once you return from the
    lower-level directories. Simply define either or both of these macros in any makefiles
    that need to do some pre-order or post-order processing for `my-recursive-target`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构的某个点，你需要做一些有用的事情，而不仅仅是向下调用更低层次。➊处的`preorder_commands`宏可以用于在递归进入更低层次的目录之前做一些必要的操作。➋处的`postorder_commands`宏同样可以在从更低层次的目录返回后执行额外的操作。只需在需要进行某些前序或后序处理的makefile中定义这两个宏中的任何一个或两个，即可为`my-recursive-target`执行相应操作。
- en: For example, if you want to build some generated documentation, you might have
    a special target called `doxygen`. Even if you happen to be okay with building
    your documentation in the top-level directory, there may be times when you need
    to distribute the generation of your documentation to various directories within
    your project hierarchy. You might use code similar to that shown in [Listing 18-10](ch18.xhtml#ch18ex10)
    in each *Makefile.am* file in your project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想生成一些文档，你可能会有一个名为`doxygen`的特殊目标。即使你可以在顶层目录中构建文档，仍然可能需要将文档的生成分发到项目层次结构中的各个目录。你可能会在项目中的每个*Makefile.am*文件中使用类似于[清单
    18-10](ch18.xhtml#ch18ex10)中所示的代码。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 18-10: Implementing *`postorder_commands`* for a `doxygen` directory*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-10：为`doxygen`目录实现*`postorder_commands`**'
- en: For directories where *doxyfile* doesn’t exist, you can comment out (or better
    yet, simply omit) the `postorder_commands` macro definition at ➊. In this case,
    the `doxygen` target will be harmlessly propagated to the next lower level in
    the build tree by the three lines of shell code at ➋.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有*doxyfile*的目录，你可以注释掉（或者更好的是，干脆省略）在➊处的`postorder_commands`宏定义。在这种情况下，`doxygen`目标将通过➋处的三行Shell代码无害地传播到构建树中的下一级。
- en: The `exit` statement at the end of ➌ ensures that the build terminates when
    a lower-level makefile fails on the recursive target, propagating the shell error
    code (1) back up to each parent makefile until the top-level shell is reached.
    This is important; without it, the build may continue after a failure until a
    different error is encountered.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处的`exit`语句确保当低级makefile在递归目标上失败时，构建会终止，并将Shell错误代码（1）传播回每个父makefile，直到到达顶层Shell。这一点非常重要；如果没有它，构建可能会在失败后继续，直到遇到另一个错误。
- en: '**NOTE**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I chose not to use the somewhat less portable *`-C make`* command line option
    to change directories before running the sub-*`make`* operation. I also use an
    Automake macro called *`am__cd`* to change directories. This macro is defined
    to take the contents of the *`CDPATH`* environment variable into account to reduce
    extraneous output noise during a built. You can replace it with *`cd`* (or *`chdir`*).
    Examine an Automake-generated makefile to see how Automake defines this macro.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*我选择不使用有些不太便携的*`-C make`*命令行选项来在运行子*`make`*操作之前更改目录。我还使用了一个名为*`am__cd`*的Automake宏来更改目录。这个宏被定义为考虑*`CDPATH`*环境变量的内容，以减少构建过程中不必要的输出噪音。你可以用*`cd`*（或*`chdir`*）来替代它。检查一个由Automake生成的makefile，看看Automake是如何定义这个宏的。*'
- en: If you choose to implement a completely recursive global target in this manner,
    you must include [Listing 18-10](ch18.xhtml#ch18ex10) in every *Makefile.am* file
    in your project, even if that makefile has nothing to do with the generation of
    documentation. If you don’t, `make` will fail on that makefile because no `doxygen`
    target exists within it. The commands may do nothing, but the target must exist.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择以这种方式实现一个完全递归的全局目标，你必须在项目中的每个*Makefile.am*文件中包含[清单 18-10](ch18.xhtml#ch18ex10)，即使该makefile与文档生成无关。如果不这样做，`make`将在该makefile上失败，因为其中不存在`doxygen`目标。命令可能什么都不做，但目标必须存在。
- en: If you want to do something simpler, such as pass a target down to a single
    subdirectory beneath the top-level directory (such as a *doc* directory just below
    the top), life becomes easier. Just implement the code shown in [Listings 18-11](ch18.xhtml#ch18ex11)
    and [18-12](ch18.xhtml#ch18ex12).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想做一些更简单的事情，比如将一个目标传递到顶层目录下的单个子目录（例如，紧邻顶层的*doc*目录），那么生活就变得更轻松了。只需实现[清单 18-11](ch18.xhtml#ch18ex11)和[18-12](ch18.xhtml#ch18ex12)中所示的代码。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 18-11: A top-level makefile that propagates a target to a single subdirectory*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-11：一个将目标传播到单个子目录的顶层makefile*'
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 18-12:* doc/Makefile.am: *The code to handle the new target*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-12:* doc/Makefile.am: *处理新目标的代码*'
- en: The shell statement at ➊ in the top-level makefile in [Listing 18-11](ch18.xhtml#ch18ex11)
    simply passes the target (`doxygen`) down to the desired directory (`doc`).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 18-11](ch18.xhtml#ch18ex11)的顶层makefile中的➊处，Shell语句只是将目标（`doxygen`）传递到目标目录（`doc`）。
- en: '**NOTE**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The variables *`DOXYGEN`* and *`DOXYFLAGS`* are assumed to exist by virtue
    of some macro or shell code executed within the *`configure`* script.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设变量*`DOXYGEN`*和*`DOXYFLAGS`*已经存在，它们是通过某些宏或Shell代码在*`configure`*脚本中执行的。*'
- en: Automake recursive targets are more sophisticated in that they also support
    `make`’s `-k` command line option to continue building after errors. Additionally,
    Automake’s recursive target implementation supports the use of the dot (`.`) in
    the `SUBDIRS` variable, which represents the current directory. You may also support
    these features, but if you do, your boilerplate recursive `make` shell code will
    be messier. For the sake of completeness, [Listing 18-13](ch18.xhtml#ch18ex13)
    shows an implementation that supports these features. Compare this listing to
    [Listing 18-9](ch18.xhtml#ch18ex9). The highlighted shell code shows the differences
    between these listings.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Automake的递归目标更为复杂，因为它们还支持`make`的`-k`命令行选项，以便在发生错误后继续构建。此外，Automake的递归目标实现支持在`SUBDIRS`变量中使用点（`.`），它代表当前目录。你也可以支持这些功能，但如果支持的话，你的标准递归`make`
    shell代码将变得更为混乱。为了完整起见，[清单18-13](ch18.xhtml#ch18ex13)展示了支持这些功能的实现。将这个清单与[清单18-9](ch18.xhtml#ch18ex9)进行对比，突出显示的shell代码展示了这两者之间的差异。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 18-13: Adding `make -k` and a check for the current directory*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-13：添加`make -k`和检查当前目录*'
- en: At ➊, the `case` statement checks for a `-k` option in the `MAKEFLAGS` environment
    variable and, on finding it, sets the `failcom` shell variable to some innocuous
    shell code. If it’s not found, then `failcom` is left at its default value, `exit
    1`, which is then inserted where an exit should occur on error. The `if` statement
    within the `for` loop at ➋ simply skips the recursive call for the dot entry in
    `SUBDIRS`. As with the previous examples, for the current directory, the functionality
    of the recursive target is found entirely within the `$(preorder_commands)` and
    `$(postorder_commands)` macro expansions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，`case`语句检查`MAKEFLAGS`环境变量中是否存在`-k`选项，并在找到该选项时将`failcom` shell变量设置为一些无害的shell代码。如果未找到该选项，则`failcom`保持其默认值`exit
    1`，然后在错误发生时插入该命令以退出。➋处的`if`语句仅跳过`SUBDIRS`中的点条目递归调用。如前所述，针对当前目录，递归目标的功能完全包含在`$(preorder_commands)`和`$(postorder_commands)`宏扩展中。
- en: I’ve tried to show you in this item that you can do as much or as little as
    you like with your own recursive targets. Most of the implementation is simply
    shell code in the command.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试在这个项目中向你展示，你可以根据自己的需要做更多或更少的递归目标实现。大多数实现其实只是命令中的shell代码。
- en: 'Item 3: Using a Repository Revision Number in a Package Version'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目3：在包版本中使用仓库修订版本号
- en: Version control is an important part of every project. Not only does it protect
    intellectual property, but it also allows the developer to back up and start again
    after a long series of mistakes. One advantage of version control systems like
    Git and Subversion is that the system assigns a unique revision number to every
    change to a project’s repository. This means that any distribution of the project’s
    source code can be logically tied to a particular repository revision number.
    This item presents a technique you can use to automatically insert a repository
    revision number into your package’s Autoconf version string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是每个项目中非常重要的一部分。它不仅保护知识产权，还允许开发者在经历了一系列错误后进行备份并重新开始。像Git和Subversion这样的版本控制系统的一个优势是，系统为每次更改分配一个唯一的修订版本号。这意味着任何项目源代码的发布都可以逻辑上与特定的仓库修订版本号相关联。本节介绍了一种技术，允许你将仓库修订版本号自动插入到包的Autoconf版本字符串中。
- en: Arguments to Autoconf’s `AC_INIT` macro must be static text. That is, they can’t
    be shell variables, and Autoconf will flag attempts to use shell variables in
    these arguments as errors. This is all well and good until you want to calculate
    any portion of your package’s version number during the configuration process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf的`AC_INIT`宏的参数必须是静态文本。也就是说，它们不能是shell变量，Autoconf会将尝试在这些参数中使用shell变量的行为标记为错误。除非你在配置过程中想要计算包版本号的某部分，否则这一点完全没有问题。
- en: I once tried to use a shell variable in `AC_INIT`’s `VERSION` argument so that
    I could substitute my Subversion revision number into the `VERSION` argument when
    `configure` was executed. I spent a couple of days trying to figure out how to
    trick Autoconf into letting me use a shell variable as a *revision* field in my
    package’s version number. Eventually, I discovered the trick shown in [Listing
    18-14](ch18.xhtml#ch18ex14), which I implemented in my *configure.ac* file and
    in my top-level *Makefile.am* file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经尝试在 `AC_INIT` 的 `VERSION` 参数中使用 shell 变量，以便在执行 `configure` 时将我的 Subversion
    修订号替换到 `VERSION` 参数中。我花了几天时间试图弄清楚如何欺骗 Autoconf 让我在软件包的版本号中使用 shell 变量作为 *修订* 字段。最终，我发现了[清单
    18-14](ch18.xhtml#ch18ex14)中展示的技巧，并在我的 *configure.ac* 文件和顶层 *Makefile.am* 文件中实现了该技巧。
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 18-14:* configure.ac: *Implementing a dynamic revision number as part
    of the package version*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-14:* configure.ac: *作为软件包版本的一部分实现动态修订号*'
- en: Here, the shell variable `SVNREV` is set at ➊ to the output of the `svnversion`
    command, as executed on the project top-level directory. The output is a raw Subversion
    revision number—that is, *if* the code is executed in a true Subversion work area,
    which isn’t always the case.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，shell 变量 `SVNREV` 在 ➊ 处被设置为 `svnversion` 命令的输出，该命令在项目顶层目录中执行。输出是一个原始的 Subversion
    修订号——也就是说，*如果*代码在一个真实的 Subversion 工作区中执行，但这并不总是如此。
- en: When a user executes this `configure` script from a distribution archive, Subversion
    may not even be installed on his workstation. Even if it is, the top-level project
    directory comes from the archive, not a Subversion repository. To handle these
    situations, the line at ➋ checks to see if `svnversion` can be executed or if
    the output from the first line starts with the first few letters of the phrase
    *Unversioned directory*, the result of executing the `svnversion` utility on a
    non-work-area directory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从分发归档中执行此 `configure` 脚本时，Subversion 可能甚至没有安装在他的工作站上。即使安装了，顶层项目目录也来自归档，而不是
    Subversion 仓库。为了处理这些情况，➋ 处的行会检查 `svnversion` 是否能执行，或者第一行的输出是否以 *Unversioned directory*
    这几个字母开头，这是在非工作区目录上执行 `svnversion` 工具时的结果。
- en: If either of these cases is true, the `SVNREV` variable is populated at ➌ from
    the contents of a file called *SVNREV*. The project should be configured to ship
    the *SVNREV* file with a distribution archive containing the configuration code
    in [Listing 18-14](ch18.xhtml#ch18ex14). This must be done because if `svnversion`
    generates a true Subversion repository revision number, that value is immediately
    written to the *SVNREV* file by the `else` clause of this `if` statement at ➍.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两种情况之一为真，`SVNREV` 变量将在 ➌ 处从名为 *SVNREV* 的文件的内容中填充。该项目应配置为随分发归档一起发送 *SVNREV*
    文件，该归档包含了[清单 18-14](ch18.xhtml#ch18ex14)中的配置代码。必须这样做，因为如果 `svnversion` 生成了一个真实的
    Subversion 仓库修订号，该值会立即通过 ➍ 处的 `if` 语句的 `else` 子句写入 *SVNREV* 文件。
- en: Finally, the call to `AC_SUBST` at ➎ substitutes the `SVNREV` variable into
    template files, including the project makefiles.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，➎ 处对 `AC_SUBST` 的调用将 `SVNREV` 变量替换到模板文件中，包括项目的 makefile 文件。
- en: In the top-level *Makefile.am* file, I ensure that the *SVNREV* file becomes
    part of the distribution archive by adding it to the `EXTRA_DIST` list. Thus,
    when a distribution archive is created and published by the maintainer, it contains
    an *SVNREV* file with the source tree revision number used to generate the archive
    from this source code. The value in the *SVNREV* file is also used when an archive
    is generated from the source code in this tarball (via `make dist`). This is accurate
    because the original archive was actually generated from this particular revision
    of the Subversion repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层的 *Makefile.am* 文件中，我通过将 *SVNREV* 文件添加到 `EXTRA_DIST` 列表中，确保它成为分发归档的一部分。因此，当维护者创建并发布分发归档时，它将包含一个
    *SVNREV* 文件，其中记录了用于从该源代码生成归档的源树修订号。*SVNREV* 文件中的值也会在从该 tarball 中的源代码生成归档时使用（通过
    `make dist`）。这是准确的，因为原始归档实际上是从这个特定修订的 Subversion 仓库生成的。
- en: Generally, it’s not particularly important that a project’s distribution archive
    be able to generate a proper distribution archive, but an Automake-generated archive
    can do so without this modification, so it should also be able to do so *with*
    it. [Listing 18-15](ch18.xhtml#ch18ex15) highlights the relevant changes to the
    top-level *Makefile.am* file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，项目的分发归档能否生成正确的分发归档并不特别重要，但一个由 Automake 生成的归档可以做到这一点，而无需进行此修改，因此它在*有*此修改的情况下也应该能够做到。[清单
    18-15](ch18.xhtml#ch18ex15) 突出了对顶层 *Makefile.am* 文件的相关更改。
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 18-15:* Makefile.am: *A top-level makefile configured for SVN revision
    numbers*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*第18-15节:* Makefile.am: *配置为 SVN 修订号的顶层 makefile*'
- en: In [Listing 18-15](ch18.xhtml#ch18ex15), the `distdir` variable controls the
    name of the distribution directory and the archive filename generated by Automake.
    Setting this variable in the top-level *Makefile.am* file affects the generation
    of the distribution archive, because that *Makefile.am* file is where this functionality
    is located in the final generated *Makefile*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第18-15节](ch18.xhtml#ch18ex15) 中，`distdir` 变量控制由 Automake 生成的分发目录名称和归档文件名。在顶层的
    *Makefile.am* 文件中设置此变量会影响分发归档的生成，因为该 *Makefile.am* 文件是最终生成的 *Makefile* 中包含此功能的位置。
- en: '**NOTE**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Note the similarity of the* SVNREV *filename and the *`SVNREV make`* variable
    *`[$(SVNREV)]`* in [Listing 18-15](ch18.xhtml#ch18ex15). Although they appear
    to be the same, the text added to the *`EXTRA_DIST`* line refers to the* SVNREV
    *file in the top-level project directory, while the text added to the *`distdir`*
    variable refers to a *`make`* variable.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* SVNREV *文件名和*`SVNREV make`* 变量 *`[$(SVNREV)]`* 在 [第18-15节](ch18.xhtml#ch18ex15)
    中的相似性。尽管它们看起来相同，添加到 *`EXTRA_DIST`* 行的文本指的是顶层项目目录中的 *SVNREV* 文件，而添加到 *`distdir`*
    变量的文本则指向一个 *`make`* 变量。'
- en: For most purposes, setting `distdir` in the top-level *Makefile.am* file should
    be sufficient. However, if you need `distdir` to be formatted correctly in another
    *Makefile.am* file in your project, just set it in that file as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数目的，在顶层 *Makefile.am* 文件中设置 `distdir` 应该足够。然而，如果你需要在项目中的另一个 *Makefile.am*
    文件中正确格式化 `distdir`，只需在该文件中也设置它即可。
- en: The technique presented in this item does not automatically reconfigure the
    project to generate a new *SVNREV* file when you commit new changes (and so change
    the Subversion revision used in your build). I could have added this functionality
    with a few well-placed `make` rules, but that would have forced the build to check
    for commits with each new build.^([4](footnote.xhtml#ch18fn4))
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本项中介绍的技术并不会在你提交新更改时自动重新配置项目以生成新的 *SVNREV* 文件（因此更改构建中使用的 Subversion 修订号）。我本可以通过一些恰当的
    `make` 规则添加此功能，但那样会迫使每次构建时检查是否有提交^([4](footnote.xhtml#ch18fn4))。
- en: '[Listing 18-16](ch18.xhtml#ch18ex16) shows code similar to that in [Listing
    18-14](ch18.xhtml#ch18ex14), except this code works for Git, rather than Subversion.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18-16节](ch18.xhtml#ch18ex16) 显示了与 [第18-14节](ch18.xhtml#ch18ex14) 中的代码类似的代码，区别在于此代码适用于
    Git，而非 Subversion。'
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 18-16:* configure.ac: *Implementing a Git dynamic revision number*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*第18-16节:* configure.ac: *实现一个 Git 动态修订号*'
- en: This version seems a little more intuitive to me because the `git` utility makes
    better use of the proper output channels for error conditions—the output of the
    command is sent to `stderr` if the current working directory is not a Git repository.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本对我来说似乎更直观，因为 `git` 工具更好地利用了错误条件的正确输出通道——如果当前工作目录不是 Git 仓库，命令的输出会被发送到 `stderr`。
- en: Of course, you should also modify the code from [Listing 18-15](ch18.xhtml#ch18ex15)
    to reference the *GITREV* file instead of the *SVNREV* file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还应该修改 [第18-15节](ch18.xhtml#ch18ex15) 中的代码，引用 *GITREV* 文件而不是 *SVNREV* 文件。
- en: Another great option, if you’re already using Gnulib, is to use the *version-gen*
    module in that library. This module provides many nice features related to incorporating
    a version number into your build.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在使用 Gnulib，另一个很好的选择是使用该库中的 *version-gen* 模块。此模块提供了许多与将版本号融入构建过程相关的好功能。
- en: 'Item 4: Ensuring Your Distribution Packages Are Clean'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '第4项: 确保你的分发包是干净的'
- en: Have you ever downloaded and unpacked an open source package and then tried
    to run **`./configure && make`**, only to have it fail halfway through one of
    these steps? As you dug into the problem, perhaps you discovered missing files
    in the archive. How sad to have this happen in an Autotools project, when the
    Autotools make it so easy to ensure that this simply doesn’t happen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经下载并解压了一个开源包，然后尝试运行 **`./configure && make`**，结果在这些步骤中的某一环节失败了？当你深入研究问题时，或许发现了归档中的缺失文件。可惜的是，这种情况发生在
    Autotools 项目中，尽管 Autotools 使得确保这一点不发生变得非常简单。
- en: To ensure that your distribution archives are always clean and complete, run
    the `distcheck` target on a newly created archive. Don’t be satisfied with what
    you *believe* about your package. Allow Automake to run the distribution unit
    tests. I call these tests *unit tests* because they provide the same testing functionality
    for a distribution package that regular unit tests provide for your source code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的分发归档始终干净和完整，请在新创建的归档上运行`distcheck`目标。不要满足于你*相信*你包的状态。让 Automake 来运行分发单元测试。我将这些测试称为*单元测试*，因为它们为分发包提供了与常规单元测试为源代码提供的相同测试功能。
- en: You’d never make a code change and ship a package without running your unit
    tests, would you? (If so, then you can safely skip this section.) Likewise, don’t
    ship your archives without running the build system unit tests—run **`make distcheck`**
    on your project *before* posting your new archives. If the `distcheck` target
    fails, find out why and fix it. The payoff is worth the effort.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你绝不会在没有运行单元测试的情况下进行代码更改并发布软件包，对吧？（如果是这样，那么你可以放心跳过这一部分。）同样，不要在没有运行构建系统单元测试的情况下发布归档——在发布新归档之前，先在你的项目上运行**`make
    distcheck`**。如果`distcheck`目标失败了，找出原因并修复它。这样做的回报是值得的。
- en: 'Item 5: Hacking Autoconf Macros'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 项：黑客攻关 Autoconf 宏
- en: Occasionally you need a macro that Autoconf doesn’t quite provide. That’s when
    it pays to know how to copy and modify existing Autoconf macros.^([5](footnote.xhtml#ch18fn5))
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要一个 Autoconf 并未完全提供的宏。这时候，知道如何复制和修改现有的 Autoconf 宏就很有帮助。^([5](footnote.xhtml#ch18fn5))
- en: For example, here’s a solution to a common Autoconf mailing list issue. A user
    wants to use `AC_CHECK_LIB` to capture a desired library in the `LIBS` variable.
    The catch is that this library exports functions with C++, rather than C linkage.
    `AC_CHECK_LIB` is not very accommodating when it comes to C++, primarily because
    `AC_CHECK_LIB` makes certain assumptions about symbols exported with C linkage
    that just don’t apply to C++ symbols.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个解决常见 Autoconf 邮件列表问题的方案。一个用户想使用`AC_CHECK_LIB`来捕获所需的库到`LIBS`变量中。问题在于这个库导出了
    C++ 函数，而不是 C 函数。`AC_CHECK_LIB`在处理 C++ 时并不太友好，主要是因为`AC_CHECK_LIB`对符号的假设是基于 C 语言的链接方式，而这些假设并不适用于
    C++ 符号。
- en: For example, the widely known (and standardized) rules of C linkage state that
    an exported C-linkage symbol (also known as the `cdecl` calling convention on
    Intel systems) is case sensitive and decorated with a leading underscore,^([6](footnote.xhtml#ch18fn6))
    whereas a symbol exported with C++ linkage is *mangled* using nonstandard, vendor-defined
    rules. The decorations are based on the signature of the function—specifically,
    the number and types of parameters as well as the classes and/or namespaces to
    which the function belongs. But the exact scheme is not defined by the C++ standard.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，广为人知的（并且是标准化的）C 链接规则指出，导出的 C 链接符号（在 Intel 系统上也称为`cdecl`调用约定）是区分大小写的，并且会加上前导下划线，^([6](footnote.xhtml#ch18fn6))而使用
    C++ 链接导出的符号则是通过非标准的、厂商定义的规则进行*改编*的。这些修饰符是基于函数签名——具体来说，是参数的数量和类型，以及函数所属的类和/或命名空间。但确切的规则并未在
    C++ 标准中定义。
- en: Now, stop and consider under what circumstances you’re likely to have symbols
    exported from a library using C++ linkage. There are two ways to export C++ symbols
    from a library. The first is to (either purposely or accidentally) export *global*
    functions without using the `extern "C"` linkage specification on your function
    prototypes. The second is to export entire classes—including public and protected
    methods and class data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，停下来思考一下，在什么情况下你可能会有符号从库中导出，并使用 C++ 链接方式。导出 C++ 符号有两种方式。第一种是（无论是故意还是不小心）导出*全局*函数而没有在函数原型中使用`extern
    "C"`链接说明。第二种是导出整个类——包括公共和受保护的方法以及类数据。
- en: If you’ve accidentally forgotten to use `extern "C"` on your global functions,
    well, then, stop it. If you’re doing it on purpose, then I wonder why? The only
    reason I can think of is that you want to export more than one overload of a given
    function name. This seems a rather trivial reason to keep your C developers from
    being able to use your library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心忘记在全局函数中使用`extern "C"`，那么，请停止这种做法。如果你故意这么做，那我想知道为什么？我能想到的唯一理由是你想导出一个给定函数名的多个重载。这似乎是一个相当微不足道的理由，阻止你的
    C 开发者使用你的库。
- en: If you’re exporting classes, now that’s another story. In this case, you’re
    catering specifically to C++ users, which presents a real issue with `AC_CHECK_LIB`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导出的是类，那就是另一个问题了。在这种情况下，你专门为 C++ 用户提供支持，而这给`AC_CHECK_LIB`带来了一个实际问题。
- en: Autoconf provides a framework around the definition of `AC_CHECK_LIB` that allows
    for differences between C and C++. If you use the `AC_LANG([C++])` macro before
    you call `AC_CHECK_LIB`, you’ll generate a version of the test program that’s
    specific to C++. But don’t get your hopes up; the current implementation of the
    C++ version is simply a copy of the C version. I expect that a generic C++ implementation
    would be difficult at best to design.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf为`AC_CHECK_LIB`的定义提供了一个框架，允许在C和C++之间进行差异处理。如果在调用`AC_CHECK_LIB`之前使用`AC_LANG([C++])`宏，你将生成一个特定于C++的测试程序版本。但不要抱太大希望；当前的C++版本实现仅仅是C版本的复制。我预计设计一个通用的C++实现充其量是非常困难的。
- en: But all is not lost. While a *generic* implementation would be difficult, as
    the project maintainer, you can easily write a project-specific version of the
    test code using `AC_CHECK_LIB`’s test code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非一切都失去希望。虽然实现一个*通用*的版本可能很困难，但作为项目的维护者，你可以轻松地使用`AC_CHECK_LIB`的测试代码编写一个特定于项目的版本。
- en: 'First we need to find the definition of the `AC_CHECK_LIB` macro. A `grep`
    of the Autoconf macro directory (usually */usr/(local/)share/autoconf/autoconf*)
    should quickly locate the definition of `AC_CHECK_LIB` in the file called *libs.m4*.
    Because most macro definitions start with a comment header containing a hash mark
    and then the name of the macro and a single space, the following should work:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到`AC_CHECK_LIB`宏的定义。对Autoconf宏目录（通常是*/usr/(local/)share/autoconf/autoconf*）进行`grep`搜索，应该很快就能在名为*libs.m4*的文件中找到`AC_CHECK_LIB`的定义。因为大多数宏定义都以注释头开始，头部包含一个井号和宏的名称及一个空格，因此以下方法应该有效：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The definition of `AC_CHECK_LIB` is shown in [Listing 18-17](ch18.xhtml#ch18ex17).^([7](footnote.xhtml#ch18fn7))
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_CHECK_LIB`的定义如[清单18-17](ch18.xhtml#ch18ex17)所示。^([7](footnote.xhtml#ch18fn7))'
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 18-17: The definition of `AC_CHECK_LIB`, as found in* libs.m4'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-17：`AC_CHECK_LIB`的定义，如在*libs.m4中找到的'
- en: This apparent quagmire is easily sorted out with a little analysis. The macro
    appears to accept up to five arguments (as shown in the comment header), the first
    two of which are required. The highlighted portion is the macro definition—the
    part we’ll copy into our *configure.ac* file and modify to work with our C++ exports.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个明显的难题通过一点分析就能轻松解决。宏似乎接受最多五个参数（如注释头部所示），其中前两个是必需的。突出显示的部分是宏的定义——我们将把它复制到我们的*configure.ac*文件中并修改，以便与我们的C++导出功能兼容。
- en: 'Recall from [Chapter 16](ch16.xhtml) that the placeholders for M4 macro definition
    parameters are similar to those of shell scripts: a dollar sign followed by a
    number. The first parameter is represented by `$1`, the second by `$2`, and so
    on. We need to determine which parameters are important to us and which ones to
    discard. We know that most calls to `AC_CHECK_LIB` pass only the first two arguments.
    The third and fourth parameters are optional and exist only so that you can change
    the macro’s default behavior, depending on whether it locates the desired function
    in the specified library. The fifth parameter allows you to provide a list of
    additional linker command line arguments (usually additional library and library
    directory references) that are required to properly link the desired library so
    the test program will not fail for extraneous reasons.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第16章](ch16.xhtml)，M4宏定义参数的占位符类似于Shell脚本的占位符：一个美元符号后跟一个数字。第一个参数用`$1`表示，第二个用`$2`表示，依此类推。我们需要确定哪些参数对我们重要，哪些可以忽略。我们知道，大多数对`AC_CHECK_LIB`的调用只传递前两个参数。第三和第四个参数是可选的，仅仅存在于你希望根据是否在指定的库中找到所需的函数来更改宏的默认行为时。第五个参数允许你提供一个额外的链接器命令行参数列表（通常是附加的库和库目录引用），这些是正确链接所需库的必要条件，以确保测试程序不会因为多余的原因失败。
- en: Say we have a C++ library that exports a class’s public data and methods. Our
    library is named *fancy*, our class is `Fancy`, and the method we’re interested
    in is called `execute`—specifically the `execute` method that accepts two integer
    arguments. Thus, its signature would be
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个C++库，导出了一个类的公共数据和方法。我们的库名为*fancy*，类名为`Fancy`，我们感兴趣的方法名为`execute`——特别是接受两个整数参数的`execute`方法。因此，它的签名将是
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When exported with C linkage, such a function would be presented to the linker
    merely as `_execute` (or simply as `execute`, without the leading underscore,
    on some platforms), but when it’s exported with C++ linkage, all bets are off
    because of vendor-specific name mangling.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用C链接导出时，这样的函数仅以`_execute`（或在某些平台上直接为`execute`，没有前导下划线）呈现给链接器，但当它使用C++链接导出时，由于供应商特定的名称修饰，情况就复杂了。
- en: 'The only way to get the linker to find this symbol is to declare it in compiled
    source code with exactly this signature, but we don’t supply enough information
    to `AC_CHECK_LIB` to properly declare the function signature in the test code.
    Here’s the declaration required to tell the compiler how to properly mangle this
    method’s name:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让链接器找到这个符号的唯一方法是使用完全相同的签名在编译后的源代码中声明它，但我们没有向`AC_CHECK_LIB`提供足够的信息，以便在测试代码中正确声明函数签名。以下是所需的声明，告诉编译器如何正确地修饰此方法的名称：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Assuming that we’re looking for a function with C linkage called `execute`,
    the `AC_CHECK_LIB` macro generates a small test program like the one shown in
    [Listing 18-18](ch18.xhtml#ch18ex18). I’ve highlighted our function name so you
    can easily see where the macro inserts it into the generated test code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在寻找一个具有 C 连接性的名为`execute`的函数，`AC_CHECK_LIB`宏会生成一个像[清单 18-18](ch18.xhtml#ch18ex18)中所示的小型测试程序。我已经突出显示了我们的函数名，以便你可以轻松看到宏如何将其插入到生成的测试代码中。
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 18-18: An Autoconf-generated check for the global C-language `execute`
    function*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-18：一个由 Autoconf 生成的检查全局 C 语言 `execute` 函数的示例*'
- en: Except for these two uses of the specified function name, the entire test program
    is identical for every call to `AC_CHECK_LIB`. This macro creates a common prototype
    for all functions so that all functions are treated the same way. Clearly, however,
    not all functions accept no parameters and return a character, as defined in this
    code. `AC_CHECK_LIB` effectively lies to the compiler about the true nature of
    the function. The test only cares whether the test program can successfully be
    linked; it will never attempt to execute it (an operation that would fail spectacularly
    in most cases).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两处使用指定函数名的地方外，所有对`AC_CHECK_LIB`的调用生成的测试程序都是相同的。这个宏为所有函数创建一个通用的原型，以便所有函数都以相同的方式处理。然而，显然并不是所有函数都不接受参数并返回一个字符，正如这段代码中所定义的那样。`AC_CHECK_LIB`实际上是在向编译器谎报函数的真实性质。测试只关心测试程序是否能够成功链接；它永远不会尝试执行它（在大多数情况下，这一操作会以灾难性的方式失败）。
- en: For C++ symbols, we need to generate a different test program—one that makes
    no assumptions about the signature of our exported symbol.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C++ 符号，我们需要生成一个不同的测试程序——一个不对我们导出的符号的签名做任何假设的程序。
- en: Looking back at ➊ in [Listing 18-17](ch18.xhtml#ch18ex17), it appears as if
    the `AC_LANG_CALL` macro has something to do with the generation of the test code
    in [Listing 18-18](ch18.xhtml#ch18ex18) because the output of `AC_LANG_CALL` is
    generated directly into the first argument of a call to `AC_LINK_IFELSE`; its
    first argument is source code to be tested with the linker. As it turns out, this
    macro, too, is a higher-level wrapper around another macro, `AC_LANG_PROGRAM`.
    [Listing 18-19](ch18.xhtml#ch18ex19) shows the definitions of both macros.^([8](footnote.xhtml#ch18fn8))
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[清单 18-17](ch18.xhtml#ch18ex17)中的➊，看起来`AC_LANG_CALL`宏与[清单 18-18](ch18.xhtml#ch18ex18)中测试代码的生成有关系，因为`AC_LANG_CALL`的输出会直接生成到对`AC_LINK_IFELSE`的调用的第一个参数中；其第一个参数是要用链接器测试的源代码。事实证明，这个宏也是另一个宏`AC_LANG_PROGRAM`的高级封装。[清单
    18-19](ch18.xhtml#ch18ex19)展示了这两个宏的定义。^([8](footnote.xhtml#ch18fn8))
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 18-19: The definitions of `AC_LANG_CALL` and `AC_LANG_PROGRAM`*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-19：`AC_LANG_CALL`和`AC_LANG_PROGRAM`的定义*'
- en: At ➊, `AC_LANG_CALL(C)` generates a call to `AC_LANG_PROGRAM`, passing the `PROLOGUE`
    argument in the first parameter. At ➌, this prologue (in the form of `$1`) is
    immediately sent to the output stream. If the second argument passed to `AC_LANG_CALL(C)`
    (`FUNCTION`) is not `main`, a C-style function prototype is generated for the
    function. At ➋, the text `return $2 ();` is passed as the `BODY` argument to `AC_LANG_PROGRAM`,
    which uses this text at ➍ to generate a call to the function. (Remember that this
    code will only be linked, never executed.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`AC_LANG_CALL(C)`会生成对`AC_LANG_PROGRAM`的调用，将`PROLOGUE`参数作为第一个参数传入。在➌处，这个序言（以`$1`的形式）会立即发送到输出流。如果传递给`AC_LANG_CALL(C)`的第二个参数（`FUNCTION`）不是`main`，则会为该函数生成一个
    C 风格的函数原型。在➋处，文本`return $2 ();`作为`BODY`参数传递给`AC_LANG_PROGRAM`，该宏在 ➍ 处使用这段文本生成对函数的调用。（记住，这段代码只会被链接，而不会执行。）
- en: For C++, we need to be able to define more of the test program so that it makes
    no assumptions about the prototype of our exported symbol, and `AC_LANG_CALL`
    is too specific to C, so we’ll use the lower-level macro, `AC_LANG_PROGRAM`, instead.
    [Listing 18-20](ch18.xhtml#ch18ex20) shows how we might rework `AC_CHECK_LIB`
    to handle the function `Fancy::execute(int, int)` from a library called *fancy*.
    I’ve highlighted the places where I’ve modified the original macro definition
    of [Listing 18-17](ch18.xhtml#ch18ex17) on [page 512](ch18.xhtml#page_512).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++，我们需要能够定义更多的测试程序，以使其不对我们导出的符号的原型做任何假设，而`AC_LANG_CALL`对C来说过于具体，因此我们将使用更底层的宏`AC_LANG_PROGRAM`。[示例
    18-20](ch18.xhtml#ch18ex20)展示了如何改写`AC_CHECK_LIB`来处理来自名为*fancy*的库中的函数`Fancy::execute(int,
    int)`。我已在[第512页](ch18.xhtml#page_512)的[示例 18-17](ch18.xhtml#ch18ex17)中标出了我修改原始宏定义的地方。
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 18-20: Hacking a modified version of `AC_CHECK_LIB` into* configure.ac'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 18-20：将修改版的`AC_CHECK_LIB`黑客化到configure.ac中*'
- en: In [Listing 18-20](ch18.xhtml#ch18ex20), I’ve replaced the parameter placeholders
    with library and function names at ➊ and ➋ and added the prologue and body of
    the program to be generated by `AC_LANG_PROGRAM` at ➌. I’ve also removed some
    extraneous text that specifically had to do with the optional parameters of `AC_CHECK_LIB`
    that I don’t care about in my version.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 18-20](ch18.xhtml#ch18ex20)中，我在➊和➋处分别用库名和函数名替换了参数占位符，并在➌处添加了由`AC_LANG_PROGRAM`生成的程序的前言和主体。我还删除了一些与`AC_CHECK_LIB`的可选参数相关的冗余文本，这些参数在我的版本中不需要。
- en: This code is much longer and more difficult to understand than a simple call
    to `AC_CHECK_LIB`, so it just begs to be turned into a macro. I’ll leave that
    to you as an exercise. Having read [Chapter 16](ch16.xhtml), you should be able
    to do this without too much difficulty. Note also that there is much room for
    optimization in this macro. As you become more proficient with M4, you’ll undoubtedly
    find ways you can reduced the size and complexity of this reworked macro, while
    maintaining the desired functionality.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比简单的`AC_CHECK_LIB`调用要长得多，理解起来也更困难，因此它迫切需要被转化为一个宏。我会把这个任务留给你作为练习。读完[第16章](ch16.xhtml)后，你应该能够轻松完成这项任务。还要注意，这个宏有很多优化的空间。随着你对M4的熟练度提升，你无疑会找到减少此宏大小和复杂性的方式，同时保持所需的功能。
- en: '*Providing Library-Specific Autoconf Macros*'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*提供特定库的Autoconf宏*'
- en: 'This item is about hacking Autoconf macros when you need special features not
    provided by the standard macros, but the example I used was specifically about
    looking for a particular function in a library. This is a special case of a more
    general issue: finding libraries that provide desired functionality.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这一条是关于在需要标准宏未提供的特殊功能时，修改Autoconf宏的内容。我使用的示例特别是关于在库中寻找特定函数的情况。这是一个更普遍问题的特殊案例：查找提供所需功能的库。
- en: If you’re a library developer, consider providing downloadable Autoconf macros
    that test for the existence of your libraries, and perhaps version-specific functionality
    within them. By doing so, you make it easier for your users to ensure that their
    users have proper access to your libraries.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是库的开发者，可以考虑提供可下载的Autoconf宏，用来测试库的存在性，或许还可以测试其中的特定版本功能。通过这样做，你可以使用户更容易确保他们的用户能够正确访问你的库。
- en: Such macros don’t have to be general purpose in nature, because they’re tailored
    to a specific library. Library-specific macros are much easier to write and can
    be more thorough in testing for the functionality of your library. As the author,
    you’re more likely to understand all the nuances of various versions of your library,
    so your macros can be spot-on with respect to determining library characteristics
    that your users may need to differentiate.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏不必具有通用性，因为它们是为特定库量身定制的。特定库的宏更容易编写，并且在测试库功能时可以更为彻底。作为作者，你更有可能理解库的各个版本的细微差别，因此你的宏可以准确地确定用户可能需要区分的库特征。
- en: 'Item 6: Cross-Compiling'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6项：交叉编译
- en: Cross-compilation occurs when the *build system* (the system on which the binaries
    are built) and the *host system* (the system on which those binaries are meant
    to be executed) are not of the same types. For example, we’re cross-compiling
    when we build Motorola 68000 binaries for an embedded system on a typical Intel
    x86 platform running GNU/Linux, or when we build Sparc binaries on a DEC Alpha
    system running Solaris. A far more common scenario is using your Linux system
    to build software designed to run on an embedded microcontroller.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译发生在*构建系统*（即构建二进制文件的系统）和*主机系统*（即这些二进制文件将要运行的系统）类型不同时。例如，当我们在典型的 Intel x86
    平台上运行 GNU/Linux 时为嵌入式系统构建 Motorola 68000 二进制文件，或者在运行 Solaris 的 DEC Alpha 系统上构建
    Sparc 二进制文件时，我们就是在进行交叉编译。一个更常见的场景是使用 Linux 系统为旨在运行在嵌入式微控制器上的软件进行构建。
- en: The situation becomes even more complex if the software you’re building, such
    as a compiler or linker, can generate software. In this case, the *target system*
    represents the system for which your compiler or linker will ultimately generate
    code. When such a build system involves three different architectures, it’s often
    referred to as a *Canadian cross*.^([9](footnote.xhtml#ch18fn9)) In this case,
    a compiler or linker is built on architecture A to run on architecture B and generate
    code for architecture C. Another type of three-system build, called a *cross-to-native*
    build, involves building an architecture-A compiler *on* architecture A to run
    on architecture B. In this case, three architectures are involved, but the host
    and target architectures are the same. Once you master the concepts of dual-system
    cross-compilation, moving on to using a three-system cross-compile mode is fairly
    simple.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建的软件（如编译器或链接器）能够生成软件，情况会变得更加复杂。在这种情况下，*目标系统*代表了你的编译器或链接器最终将生成代码的系统。当这样的构建系统涉及三种不同的架构时，通常称之为*加拿大交叉编译*^([9](footnote.xhtml#ch18fn9))。在这种情况下，编译器或链接器是在架构
    A 上构建的，运行在架构 B 上，并为架构 C 生成代码。另一种三系统构建类型，称为*交叉到本地*构建，涉及在架构 A 上构建编译器*以在*架构 B 上运行。在这种情况下，涉及三种架构，但主机架构和目标架构相同。一旦掌握了双系统交叉编译的概念，转向使用三系统交叉编译模式就相对简单了。
- en: Autoconf generates configuration scripts that attempt to guess the build system
    type and then assume that the host system type is the same. Unless told otherwise
    with command line options, `configure` assumes that non-cross-compilation mode
    is in effect. When executed without command line options that specify the build
    or host system types, an Autoconf-generated configuration script can usually accurately
    determine system type and characteristics.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 会生成配置脚本，试图猜测构建系统类型，并假定主机系统类型与其相同。除非通过命令行选项另行指定，否则`configure`假定处于非交叉编译模式。当没有指定构建或主机系统类型的命令行选项时，Autoconf
    生成的配置脚本通常能够准确确定系统类型及其特征。
- en: '**NOTE**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Section 14, “Manual Configuration,” of the* GNU Autoconf Manual *discusses
    how to put Autoconf into cross-compilation mode. Unfortunately, the information
    that you’ll need in order to write proper* configure.ac *files for cross-compilation
    is spread throughout that manual in bits and pieces. Each macro with nuances specific
    to cross-compilation has a paragraph describing the effects of cross-compilation
    mode on that macro. Search the manual for “cross-comp” to find all the references.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU Autoconf 手册*的第14节“手动配置”讨论了如何将 Autoconf 设置为交叉编译模式。不幸的是，编写适用于交叉编译的*configure.ac*文件所需的信息散布在手册中的各个部分。每个与交叉编译相关的宏都包含一段描述交叉编译模式对该宏影响的文字。可以通过搜索手册中的“cross-comp”来查找所有相关内容。'
- en: 'System types are defined in the *GNU Autoconf Manual* in terms of a three-part
    canonical naming scheme involving CPU, vendor, and operating system, in the form
    `cpu-vendor-os`. But the `os` portion can itself be a pair containing a kernel
    and system type (`kernel-system`). If you know a canonical name for a system,
    you can specify it in each of three parameters to `configure`, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 系统类型在*GNU Autoconf 手册*中通过一种包含 CPU、厂商和操作系统的三部分规范命名方式来定义，形式为`cpu-vendor-os`。但是，`os`部分本身可以是一个包含内核和系统类型的对（`kernel-system`）。如果你知道某个系统的规范名称，你可以在`configure`的三个参数中分别指定它，如下所示：
- en: '`--build=build-type`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build=build-type`'
- en: '`--host=host-type`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--host=host-type`'
- en: '`--target=target-type`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--target=target-type`'
- en: These `configure` command line options, with correct canonical system type names,
    allow you to define the build, host, and target system types. (Defining the host
    system type to be the same as your build system type is redundant, because this
    is the default case for `configure`.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`configure`命令行选项，配合正确的规范系统类型名称，允许你定义构建、主机和目标系统类型。（将主机系统类型定义为与你的构建系统类型相同是多余的，因为这是`configure`的默认情况。）
- en: One of the most challenging (and least documented) aspects of using these options
    is determining a proper canonical system name to use in these command line options.
    Nowhere in the *GNU Autoconf Manual* will you find a statement that tells you
    how to contrive a proper canonical name because canonical names are not unique
    for each system type. For instance, in most valid cross-compilation configurations,
    the `vendor` portion of the canonical name is simply ignored and can thus be set
    to anything.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项时，最具挑战性（也是文档最少）的一方面是确定在这些命令行选项中使用的适当规范系统名称。在*GNU Autoconf手册*中，你不会找到任何告诉你如何构造一个合适规范名称的语句，因为规范名称并不是每种系统类型唯一的。例如，在大多数有效的交叉编译配置中，规范名称中的`vendor`部分会被忽略，因此可以设置为任何值。
- en: 'When you use the `AC_CANONICAL_SYSTEM` macro early in your *configure.ac* file,
    you’ll find two new Autoconf helper scripts added to your project directory (by
    `automake --add-missing`, which is also executed by `autoreconf --install`). Specifically,
    these helper scripts are `config.guess` and `config.sub`. The job of `config.guess`
    is to determine, through heuristics, the canonical system name for your user’s
    system—the build system. You can execute this program yourself to determine an
    appropriate canonical name for your own build system. For instance, on my 64-bit
    Intel GNU/Linux system, I get the following output from `config.guess`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在*configure.ac*文件中早期使用`AC_CANONICAL_SYSTEM`宏时，你会发现两个新的Autoconf助手脚本被添加到你的项目目录中（由`automake
    --add-missing`添加，`autoreconf --install`也会执行此操作）。具体来说，这些助手脚本是`config.guess`和`config.sub`。`config.guess`的任务是通过启发式方法确定用户系统的规范名称——构建系统。你可以自己执行此程序来确定适合自己构建系统的规范名称。例如，在我的64位Intel
    GNU/Linux系统上，运行`config.guess`会得到以下输出：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see here, `config.guess` requires no command line options, although
    there are a few available. (Use the `--help` option to see them.) Its job is to
    guess your system type, mostly based on the output of the `uname` utility. This
    guess is used as a default system type that can be overridden by a user on the
    `configure` command line. When cross-compiling, you can use this value in your
    `--build` command line option.^([10](footnote.xhtml#ch18fn10))
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`config.guess`不需要命令行选项，尽管有一些可用选项。（使用`--help`选项可以查看它们。）它的任务是猜测你的系统类型，主要基于`uname`工具的输出。这个猜测会作为默认的系统类型，但用户可以在`configure`命令行中覆盖它。在交叉编译时，你可以在`--build`命令行选项中使用这个值。^([10](footnote.xhtml#ch18fn10))
- en: 'The task of the `config.sub` program is to accept an input string as a sort
    of alias for a system type that you’re looking for and then to convert it to a
    proper Autoconf canonical name. But what is a valid alias? For a few clues, search
    for “Decode aliases” within `config.sub`. You’ll likely find a comment above a
    bit of code whose job it is to decode aliases for certain `CPU-COMPANY` combinations.
    Here are a few examples executed from my system; you should find the same results
    on your system:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.sub`程序的任务是接受一个输入字符串，作为你所寻找的系统类型的别名，然后将其转换为适当的Autoconf规范名称。那么，什么是有效的别名呢？你可以在`config.sub`中搜索“Decode
    aliases”以获取一些线索。你可能会在某段代码上方找到一个注释，解释它的任务是解码某些`CPU-COMPANY`组合的别名。以下是我系统中执行的一些示例，你应该在你的系统上找到相同的结果：'
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, a lone CPU name is usually not quite enough information for
    `config.sub` to properly determine a useful canonical name for a desired host
    system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，单独的CPU名称通常不足以让`config.sub`正确地确定所需主机系统的有用规范名称。
- en: Notice, too, that there are a few generic keywords that can sometimes provide
    enough information for cross-compilation, without actually providing true vendor
    or operating system names. For instance, `unknown` can be substituted for the
    vendor name in general, and `none` is occasionally appropriate for the operating
    system name. Clearly `elf` is a valid system name as well, and it can be enough
    in some circumstances for `configure` to determine which tool chain to use. However,
    by simply appending a proper vendor name to the CPU, you can allow `config.sub`
    can take a pretty good stab at coming up with the most likely operating system
    for that pair and then generate a useful canonical system type name.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另外需要注意的是，有一些通用的关键字，有时可以提供足够的信息进行交叉编译，而不需要提供真实的厂商或操作系统名称。例如，`unknown` 可以作为厂商名称的替代项，而
    `none` 有时适用于操作系统名称。显然，`elf` 也是一个有效的系统名称，并且在某些情况下，对于 `configure` 来说，仅凭它就足以决定使用哪种工具链。然而，通过简单地将合适的厂商名称附加到
    CPU 上，您可以让 `config.sub` 相当准确地推测出该 CPU 和厂商组合最可能的操作系统，从而生成有用的标准系统类型名称。
- en: Ultimately, the best way to determine a proper canonical system type name is
    to examine `config.sub` for something close to what you think you should be using
    for a CPU and a vendor name and then simply ask it. While this may seem like a
    shot in the dark, chances are good that if you’ve gotten to the point of writing
    a build system for a program that should be cross-compiled, you’re probably already
    very familiar with the names of your host CPU, vendor, and operating system.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，确定合适的标准系统类型名称的最佳方法是检查 `config.sub`，找到与您认为应该用于 CPU 和厂商名称的内容相近的条目，然后直接询问它。虽然这看起来像是在瞎猜，但如果您已经进入编写需要交叉编译的程序构建系统的阶段，您可能已经非常熟悉主机
    CPU、厂商和操作系统的名称了。
- en: When cross-compiling, you’ll most likely use tools other than the ones you normally
    use on your system or, at the very least, additional command line options on your
    normal tools. Such tools are usually installed in sets as packages. Another clue
    to a proper host system canonical name is the prefix of these tools’ names. There’s
    nothing magic in the way Autoconf handles cross-compilation. The host system canonical
    name is used directly to locate the proper tools by name in the system path. Thus,
    the host system canonical name you use will have to match the prefix on your tools.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行交叉编译时，您很可能会使用一些不同于通常在系统中使用的工具，或者至少会在您的常用工具中添加额外的命令行选项。这些工具通常作为软件包一起安装。另一个确定合适主机系统标准名称的线索是这些工具名称的前缀。Autoconf
    处理交叉编译的方式并没有什么神秘之处。主机系统标准名称直接用于在系统路径中通过名称定位正确的工具。因此，您使用的主机系统标准名称必须与工具名称的前缀匹配。
- en: 'Now let’s examine a common scenario: building 32-bit code on a 64-bit machine
    of the same CPU architecture. Technically, this is a form of cross-compilation,
    and it’s often a much simpler scenario than cross-compiling code for an entirely
    different machine architecture. Many GNU/Linux systems support both 32- and 64-bit
    execution. On these systems, you can often use your build system’s tool chain
    to perform this task with special command line options. For example, to build
    C source code for a 32-bit Intel system on a 64-bit Intel system, you would simply
    use the following `configure` command line (I’ve highlighted the lines related
    to cross-compilation):^([11](footnote.xhtml#ch18fn11))'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个常见场景：在相同 CPU 架构的 64 位机器上构建 32 位代码。从技术上讲，这是一种交叉编译形式，而且通常比为完全不同的机器架构进行交叉编译更简单。许多
    GNU/Linux 系统支持 32 位和 64 位执行。在这些系统上，您通常可以使用构建系统的工具链，通过特定的命令行选项来执行此任务。例如，要在 64 位
    Intel 系统上为 32 位 Intel 系统构建 C 源代码，您只需使用以下 `configure` 命令行（我已突出显示与交叉编译相关的行）：^([11](footnote.xhtml#ch18fn11))
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice at ➌ that, as far as `configure` is concerned, we are not cross-compiling
    because we haven’t given `configure` any command line options instructing it to
    use a different tool chain than it would normally use. As you can see at ➊ and
    ➋, both the build and host system types are what you’d expect for a 64-bit GNU/Linux
    system. Additionally, because my system is a dual-mode system, it can execute
    test programs compiled with these flags. They’ll run on the 64-bit CPU in 32-bit
    mode just fine.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 ➌，就 `configure` 来说，我们并没有进行交叉编译，因为我们没有给 `configure` 提供任何命令行选项，指示它使用不同于常规的工具链。如您在
    ➊ 和 ➋ 中所看到的，构建系统和主机系统类型都是您期望的 64 位 GNU/Linux 系统类型。此外，由于我的系统是双模式系统，它可以执行使用这些标志编译的测试程序。它们将在
    64 位 CPU 的 32 位模式下正常运行。
- en: '**NOTE**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Many systems require that you install the 32-bit tools before *`gcc`* will
    even recognize the *`-m32`* flag. For example, Fedora systems require the installation
    of the* glibc-devel.i686 *package, and my Linux Mint (Ubuntu-based) system required
    me to install the* gcc-multilib *package.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多系统要求你在`gcc`能够识别`-m32`标志之前安装32位工具。例如，Fedora系统要求安装`glibc-devel.i686`包，而我的Linux
    Mint（基于Ubuntu）系统则要求我安装`gcc-multilib`包。*'
- en: 'To be even more certain of a proper build on Linux systems, you can also use
    the `linux32` utility to change the personality of your 64-bit system to that
    of a 32-bit system, like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更确保在Linux系统上正确构建，你还可以使用`linux32`工具将你的64位系统的特性更改为32位系统，像这样：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We use `linux32` here because some subscripts executed by `configure` may inspect
    `uname -m` to determine the build machine’s architecture. The `linux32` utility
    ensures that these scripts properly see a 32-bit Linux system. You can test this
    yourself by running `uname` under `linux32`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`linux32`，因为`configure`执行的一些子脚本可能会检查`uname -m`来确定构建机器的架构。`linux32`工具确保这些脚本能正确识别为32位Linux系统。你可以通过在`linux32`下运行`uname`来自己测试这一点：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To get this sort of cross-compile to work on a Linux dual-mode system, you usually
    need to install one or more 32-bit development packages, as noted previously.
    If your project uses other system-level services, such as a graphical desktop,
    you will need the 32-bit versions of these libraries, as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这种交叉编译在Linux双模式系统上工作，通常需要安装一个或多个32位开发包，如前所述。如果你的项目使用其他系统级服务，如图形桌面，那么你还需要这些库的32位版本。
- en: 'Now let’s do it the more conventional (dare I say, *canonical*?) way. Rather
    than add `-m32` to the `CPPFLAGS` and `LDFLAGS` variables, we’ll set the build
    and host system types manually on the `configure` command line and see what happens.
    Again, I’ve highlighted the output lines related to cross-compilation:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用更传统的方式（敢说是*标准*吗？）来做。我们不再将`-m32`添加到`CPPFLAGS`和`LDFLAGS`变量中，而是手动在`configure`命令行中设置构建和主机系统类型，然后看看会发生什么。再次说明，我已经突出显示了与交叉编译相关的输出行：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Several key lines in this example indicate that, as far as `configure` is concerned,
    we’re cross-compiling. The cross-compilation build environment is `x86_64-pc-linux-gnu`,
    while the host is `i686-pc-linux-gnu`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的几行关键内容表明，就`configure`而言，我们正在进行交叉编译。交叉编译的构建环境是`x86_64-pc-linux-gnu`，而主机系统是`i686-pc-linux-gnu`。
- en: But notice the highlighted `WARNING` text at ➋. My system doesn’t have a tool
    chain that’s dedicated to building 32-bit Intel binaries. Such a tool chain includes
    all of the same tools required to build the 64-bit versions of my products, but
    the 32-bit versions are prefixed with the canonical system name of the host system.
    If you don’t have a properly prefixed tool chain installed and available in the
    system path, `configure` will default to using the build system tools—those without
    a prefix. This can work fine if your build system’s tools can cross-compile to
    the host system with proper command line options and if you’ve also specified
    those options in `CPPFLAGS` and `LDFLAGS`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但是注意看➋处的`WARNING`文本。我的系统没有专门用于构建32位Intel二进制文件的工具链。这样的工具链包含了构建我的产品64位版本所需的所有相同工具，但32位版本的工具会以主机系统的标准系统名称作为前缀。如果你没有安装并在系统路径中可用的正确前缀工具链，`configure`将默认使用构建系统工具——那些没有前缀的工具。如果你的构建系统工具可以通过正确的命令行选项交叉编译到主机系统，并且你在`CPPFLAGS`和`LDFLAGS`中也指定了这些选项，那么这样是可以正常工作的。
- en: Normally, you’d have to install a tool chain designed to build the correct type
    of binaries. In this example, a version of such tools could easily be provided
    by creating soft links and simple shell scripts that pass additional required
    flags. According to the `configure` script output at ➊ and ➌, I need to provide
    `i686-pc-linux-gnu-` prefixed versions of `strip` and `gcc`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要安装一个设计用于构建正确类型二进制文件的工具链。在这个例子中，可以通过创建软链接和简单的shell脚本来提供这些工具的版本，脚本会传递额外所需的标志。根据➊和➌处`configure`脚本的输出，我需要提供`i686-pc-linux-gnu-`前缀版本的`strip`和`gcc`。
- en: 'Generally, such foreign tool chains are installed into an auxiliary directory,
    which means you’d have to add that directory to your system `PATH` variable in
    order to allow `configure` to find them. For this example, I’ll just create them
    in *~/bin*.^([12](footnote.xhtml#ch18fn12)) Once again I’ve highlighted the output
    text related to cross-compilation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些外部工具链会安装到一个辅助目录中，这意味着你需要将该目录添加到你的系统 `PATH` 变量中，以便 `configure` 可以找到它们。对于这个例子，我将它们创建在*~/bin*中。^([12](footnote.xhtml#ch18fn12))
    我再次强调了与跨平台编译相关的输出文本：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This time, `configure` was able to find the proper tools. Notice that the compiler
    command at ➊ no longer contains the `-m32` flag. It’s there, but it’s hidden inside
    the `i686-pc-linux-gnu-gcc` script. As far as the Autotools are concerned, `i686-pc-linux-gnu-gcc`
    already knows how to build 32-bit binaries on a 64-bit system.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`configure` 能够找到正确的工具。注意，➊ 处的编译器命令不再包含 `-m32` 标志。它仍然存在，但已隐藏在 `i686-pc-linux-gnu-gcc`
    脚本中。就 Autotools 而言，`i686-pc-linux-gnu-gcc` 已经知道如何在 64 位系统上构建 32 位二进制文件。
- en: Cross-compilation is not for the average end user. As open source software developers,
    we use packages like the Autotools to ensure that our end users don’t have to
    be experts in software development in order to build and install our packages.
    But cross-compilation requires a certain level of system configuration that is
    beyond the scope of what the Autotools generally expect of end users. Additionally,
    cross-compilation is used most often within specialized fields, such as tool chain
    or embedded systems development. End users in these areas usually *are* experts
    in software development.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台编译并不适合普通的终端用户。作为开源软件开发者，我们使用像 Autotools 这样的工具包，确保我们的终端用户在构建和安装我们的软件包时，不需要成为软件开发专家。但跨平台编译需要一定的系统配置，这超出了
    Autotools 通常对终端用户的预期。此外，跨平台编译通常应用于一些专业领域，例如工具链或嵌入式系统开发。这些领域的终端用户通常*是*软件开发专家。
- en: There are a few places where cross-compilation can, and possibly should, be
    made available to the average end user. However, I strongly encourage you to be
    explicit and detailed in the instructions you provide your users in your *README*
    and *INSTALL* documents.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些地方，跨平台编译可以，并且可能应该，提供给普通终端用户。然而，我强烈建议你在你提供给用户的*README*和*INSTALL*文档中，详细并明确地说明这些指令。
- en: 'Item 7: Emulating Autoconf Text Replacement Techniques'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7项：模拟 Autoconf 文本替换技术
- en: 'Say your project builds a daemon that is configured at startup with values
    in a configuration text file. How does the daemon know where to find this file
    on startup? One way is to simply assume it’s located in */etc*, but a well-written
    program will allow the user to configure this location when building the software.
    The system configuration directory has a variable location whose value can be
    specified on the `configure`, `make all`, or `make install` command line, as shown
    in the following examples:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的项目构建了一个在启动时通过配置文本文件中的值进行配置的守护进程。守护进程如何在启动时知道在哪里找到这个文件？一种方法是简单地假设它位于*/etc*目录中，但一个写得好的程序会允许用户在构建软件时配置该位置。系统配置目录的路径是一个可变位置，其值可以在
    `configure`、`make all` 或 `make install` 命令行中指定，如下例所示：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All of these examples take advantage of command line functionality provided
    by Autotools build systems, so they must all be carefully taken into account when
    creating project and project build source files. Let’s look at some examples that
    will explain how to do this.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些例子都利用了 Autotools 构建系统提供的命令行功能，因此在创建项目和项目构建源文件时，必须仔细考虑它们。让我们看一些例子，来说明如何做到这一点。
- en: Now, some conditions simply can’t work. For instance, you can’t pass a system
    configuration directory path into C source code from within the makefile when
    you build your program and then expect it to run correctly if you change where
    the configuration files are installed on the `make install` command line. Most
    end users won’t pass anything on the command line, but you should still ensure
    that they can set prefix directories from the `configure` and `make` command lines.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有些情况是根本无法工作的。例如，你不能在构建程序时通过 makefile 将系统配置目录路径传递到 C 源代码中，然后期望它在你更改配置文件安装位置并在
    `make install` 命令行上运行时仍然正常工作。大多数终端用户不会在命令行上传递任何内容，但你仍然需要确保他们可以通过 `configure` 和
    `make` 命令行设置前缀目录。
- en: This item is focused on placing command line prefix variable override information
    into the proper locations in your code and installed data files as late as possible
    in the build process.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本条目重点讨论的是如何将命令行前缀变量覆盖信息放置到代码和安装数据文件的适当位置，以尽可能晚地在构建过程中进行处理。
- en: 'Autoconf replaces text in `AC_SUBST` variables with the values of those variables
    as defined in `configure` at configuration time, but it doesn’t replace the text
    with raw values. In an Autotools project, if you execute `configure` with a specific
    `datadir`, you get the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 会在配置时将 `AC_SUBST` 变量中的文本替换为那些变量在 `configure` 中定义的值，但它不会将文本替换为原始值。在一个
    Autotools 项目中，如果你用特定的 `datadir` 执行 `configure`，你会得到如下结果：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can see at ➊ that the value of the shell variable `datadir` in `configure`
    is substituted exactly according to the command line instructions in the `make`
    variable `datadir` in *Makefile*. What’s not obvious here is that the default
    value of `datadir`, both in the `configure` script and in the makefile after substitution,
    is relative to other variables within the build system. By not overriding `datadir`
    on the `configure` command line, we see that the default value in the makefile
    contains unexpanded shell variable references:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如➊所示，你可以看到 `configure` 中 shell 变量 `datadir` 的值会根据 `make` 变量 `datadir` 在 *Makefile*
    中的命令行指令被精确替换。这里不显而易见的是，`datadir` 的默认值，无论是在 `configure` 脚本中，还是在替换后的 makefile 中，都是相对于构建系统中的其他变量的。通过不在
    `configure` 命令行上覆盖 `datadir`，我们可以看到 makefile 中默认值包含了未展开的 shell 变量引用：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In [Chapter 3](ch03.xhtml) (see [Listing 3-36](ch03.xhtml#ch03ex36)), we saw
    that we could pass command line options to the preprocessor that would allow us
    to consume these sorts of path values within our source code. [Listing 18-21](ch18.xhtml#ch18ex21)
    demonstrates this by passing a C-preprocessor definition in the `CPPFLAGS` variable
    for a hypothetical program called `myprog`.^([13](footnote.xhtml#ch18fn13))
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.xhtml)（参见[示例 3-36](ch03.xhtml#ch03ex36)）中，我们看到我们可以将命令行选项传递给预处理器，以允许我们在源代码中使用这些路径值。[示例
    18-21](ch18.xhtml#ch18ex21)通过在 `CPPFLAGS` 变量中传递 C 预处理器定义，展示了这一点，假设程序名为 `myprog`。^([13](footnote.xhtml#ch18fn13))
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 18-21: Pushing prefix variables into C source code in* Makefile.am
    *or* Makefile.in'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 18-21：将前缀变量推送到 C 源代码中的* Makefile.am *或* Makefile.in'
- en: A C source file might then contain the code shown in [Listing 18-22](ch18.xhtml#ch18ex22).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 C 源文件可能会包含[示例 18-22](ch18.xhtml#ch18ex22)中显示的代码。
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 18-22: Using the preprocessor-defined variables in C source code*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 18-22：在 C 源代码中使用预处理器定义的变量*'
- en: Automake does nothing special with the line in [Listing 18-21](ch18.xhtml#ch18ex21)
    between *Makefile.am* and *Makefile.in*, but the `configure` script converts the
    *Makefile.in* line into the *Makefile* line shown in [Listing 18-23](ch18.xhtml#ch18ex23).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 对[示例 18-21](ch18.xhtml#ch18ex21)中 *Makefile.am* 和 *Makefile.in* 之间的行没有做特殊处理，但
    `configure` 脚本会将 *Makefile.in* 中的这一行转换为在[示例 18-23](ch18.xhtml#ch18ex23)中显示的 *Makefile*
    行。
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 18-23: The resulting* Makefile *line after `configure` substitutes
    `@sysconfdir@`*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 18-23：`configure` 替换 `@sysconfdir@` 后的 Makefile 行*'
- en: 'When `make` passes this option on the compiler command line, it dereferences
    the variables to produce the following output command line (shown only in part
    here):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `make` 在编译器命令行中传递这个选项时，它会解引用这些变量，从而生成以下输出命令行（这里只展示了部分）：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There are a couple of problems with this approach. First, between `configure`
    and `make`, you lose the resolution of the `sysconfdir` variable because `configure`
    substitutes `${prefix}`*/etc*, rather than `${sysconfdir}`, for `@sysconfdir@`.
    The problem is that you can no longer set the value of `sysconfdir` on the `make`
    command line. To solve this problem, use the `${sysconfdir} make` variable directly
    in your `CPPFLAGS` variable, as shown in [Listing 18-24](ch18.xhtml#ch18ex24),
    rather than the Autoconf `@sysconfdir@` substitution variable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些问题。首先，在 `configure` 和 `make` 之间，你会丢失 `sysconfdir` 变量的解析，因为 `configure`
    用 `${prefix}`*/etc* 来替换 `@sysconfdir@`，而不是用 `${sysconfdir}`。问题在于，你不能再在 `make`
    命令行上设置 `sysconfdir` 的值。为了解决这个问题，可以直接在 `CPPFLAGS` 变量中使用 `${sysconfdir} make` 变量，如[示例
    18-24](ch18.xhtml#ch18ex24)所示，而不是使用 Autoconf 的 `@sysconfdir@` 替代变量。
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 18-24: Using the `make` variable in `CPPFLAGS` instead of the Autoconf
    substitution variable*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 18-24：在 `CPPFLAGS` 中使用 `make` 变量，而不是 Autoconf 替代变量*'
- en: You can use this approach to specify a value for `sysconfdir` on both the `configure`
    and `make` command lines. Setting the variable on the `configure` command line
    defines a default value in *Makefile.in* (and subsequently in the generated *Makefile*),
    which can then be overridden on the `make` command line.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种方法在`configure`和`make`命令行上都指定`sysconfdir`的值。在`configure`命令行上设置变量会在*Makefile.in*（以及随后生成的*Makefile*）中定义一个默认值，然后可以在`make`命令行中覆盖这个值。
- en: 'The problem with using different values on the `make all` and `make install`
    command lines is a bit more subtle. Consider what happens if you do the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`make all`和`make install`命令行上使用不同的值所带来的问题稍微微妙一些。考虑一下如果你做了以下操作会发生什么：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, you’re basically lying to the compiler when you tell it that your configuration
    file will be installed in */usr/local/myprog/etc* during the build. The compiler
    will happily generate the code in [Listing 18-22](ch18.xhtml#ch18ex22) so that
    it refers to this path; the second command line will then install your configuration
    file into */etc*, and your program will contain a hardcoded path to the wrong
    location. Unfortunately, there’s little that you can do to correct this, because
    you’ve allowed your users to define these variables anywhere and because the *GNU
    Coding Standards* state the `make install` shouldn’t recompile anything.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你基本上是在欺骗编译器，当你告诉它你的配置文件将在构建期间安装到*/usr/local/myprog/etc*时。编译器会高兴地生成[清单18-22](ch18.xhtml#ch18ex22)中的代码，让它引用这个路径；然后第二个命令行会将你的配置文件安装到*/etc*，而你的程序将包含一个硬编码的错误路径。不幸的是，你几乎无法纠正这个问题，因为你允许用户在任何地方定义这些变量，并且*GNU编码标准*指出`make
    install`不应该重新编译任何内容。
- en: '**NOTE**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are cases where different installation paths are given to the build
    and install processes on purpose. Recall the discussion of *`DESTDIR`* in “Getting
    Your Project into a Linux Distro” on [page 67](ch03.xhtml#page_67), wherein RPM
    packages are built and installed in a staging directory so that built products
    can be packaged in an RPM to be installed into the correct location later.*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*有时，构建和安装过程会故意指定不同的安装路径。回想一下在《将项目集成到Linux发行版》中关于*`DESTDIR`*的讨论（参见[第67页](ch03.xhtml#page_67)），其中RPM包会在临时目录中构建和安装，以便之后将构建的产品打包成RPM，并安装到正确的位置。*'
- en: Regardless of the potential pitfalls, being able to specify installation locations
    on the `make` command line is a powerful technique, but one that only works in
    makefiles because it relies heavily on `make` variable substitution within compiler
    command lines in your makefiles.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在潜在的陷阱，但能够在`make`命令行上指定安装位置是一种强大的技术，然而这种方法仅在makefile中有效，因为它在makefile中的编译器命令行内
    heavily 依赖于`make`变量替换。
- en: What if you want to replace a value in an installed data file that isn’t processed
    by `make` on a shell command line? You could convert your data file into an Autoconf
    template and then simply reference the Autoconf substitution variable within that
    file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想替换一个已安装数据文件中的值，而这个数据文件没有经过`make`命令处理，你可以将数据文件转换为一个Autoconf模板，然后在该文件中简单地引用Autoconf替换变量。
- en: In fact, we did just that in the *doxyfile.in* templates that we created for
    the FLAIM project in [Chapter 15](ch15.xhtml). However, this only worked in Doxygen
    input files because the class of variables used in those templates is always defined
    with complete absolute or relative paths by `configure`. That is, the values of
    `@srcdir@` and `@top_srcdir@` contain no additional shell variables. These variables
    are not installation directory (prefix) variables, which, with the exception of
    `prefix` itself, are always defined relative to other prefix variables.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们在[第15章](ch15.xhtml)为FLAIM项目创建的*doxyfile.in*模板中做的就是这件事。然而，这只在Doxygen输入文件中有效，因为这些模板中使用的变量类始终由`configure`定义为完整的绝对或相对路径。也就是说，`@srcdir@`和`@top_srcdir@`的值不包含任何额外的shell变量。这些变量不是安装目录（前缀）变量，除了`prefix`本身，其他前缀变量总是相对于其他前缀变量定义的。
- en: You can, however, *emulate* the Autoconf substitution variable process within
    a makefile, allowing substitution variables to be used in installed data files.
    [Listing 18-25](ch18.xhtml#ch18ex25) shows a template in which you might want
    to replace variables with path information normally found in the standard prefix
    variables during a build.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在makefile中*模拟*Autoconf替换变量的过程，从而允许在已安装的数据文件中使用替换变量。[清单18-25](ch18.xhtml#ch18ex25)展示了一个模板，其中你可能希望用在构建过程中通常在标准前缀变量中找到的路径信息替换变量。
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 18-25: A sample config file template for myprog, to be installed in
    `$(sysconfdir)`*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-25：myprog的配置文件模板示例，将被安装到`$(sysconfdir)`中*'
- en: This template is for a program configuration file, which might normally be installed
    in the system configuration directory. We want the location of the program’s log
    file, specified in this configuration file, to be determined at install time by
    the value of `@localstatedir@`. Unfortunately, `configure` would replace this
    variable with a string containing at least `${prefix}`, which is not useful in
    a program configuration file. [Listing 18-26](ch18.xhtml#ch18ex26) shows a *Makefile.am*
    file with additional `make` script to generate *myprog.cfg* by performing substitution
    on variables in *myprog.cfg.in*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板用于程序配置文件，通常会安装在系统配置目录中。我们希望程序日志文件的位置，按照该配置文件中的指定，在安装时通过`@localstatedir@`的值来确定。不幸的是，`configure`会将这个变量替换成至少包含`${prefix}`的字符串，这在程序配置文件中并没有用处。[清单
    18-26](ch18.xhtml#ch18ex26)展示了一个*Makefile.am*文件，里面有一个额外的`make`脚本，通过对*myprog.cfg.in*中的变量进行替换，生成*myprog.cfg*文件。
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 18-26: Substituting `make` variables into data files using `sed` in
    a makefile*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-26：在makefile中使用`sed`将`make`变量替换到数据文件中*'
- en: In this *Makefile.am* file, I’ve defined a custom `make` target at ➌ to build
    the *myprog.cfg* data file. I’ve also defined a `make` variable called `edit`
    at ➋, which resolves to a partial `sed` command that replaces all instances of
    `@localstatedir@` in the template file (`$(srcdir)/`*myprog.cfg.in*) with the
    value of the `$(localstatedir)` variable. Because `make` recursively processes
    variable replacements until all variable references are resolved, using `make`
    in this manner will ensure that you never leave any variable references in your
    final output. In the command where this variable is used, `sed`’s output is redirected
    to the output file (*myprog.cfg*).^([14](footnote.xhtml#ch18fn14))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个*Makefile.am*文件中，我在➌定义了一个自定义的`make`目标，用来构建*myprog.cfg*数据文件。我还在➋定义了一个名为`edit`的`make`变量，这个变量解析为一个部分的`sed`命令，用来将模板文件(`$(srcdir)/`*myprog.cfg.in*)中的所有`@localstatedir@`替换为`$(localstatedir)`变量的值。由于`make`会递归地处理变量替换，直到所有的变量引用都被解析，因此以这种方式使用`make`可以确保最终输出中不会留下任何变量引用。在这个命令中，`sed`的输出被重定向到输出文件(*myprog.cfg*)。^([14](footnote.xhtml#ch18fn14))
- en: The only nonobvious code in this example is the use of the square brackets around
    the trailing at sign (`@`) in the `sed` expression, which represent regular expression
    syntax indicating that any of the enclosed characters should be matched. Because
    there is only one enclosed character, this would seem to be a pointless complication,
    but the purpose of these brackets is to keep `configure` from replacing `@localstatedir@`
    in the `edit` variable when it performs Autoconf variable substitution on this
    makefile. We want `make` to use this variable, not `configure`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中唯一不明显的代码是`sed`表达式中在尾随的`@`符号周围使用方括号，它们表示正则表达式语法，指示任何包含的字符都应该被匹配。由于只有一个包含的字符，这看起来像是一个无意义的复杂化，但这些方括号的目的是防止`configure`在对这个makefile进行Autoconf变量替换时，替换掉`edit`变量中的`@localstatedir@`。我们希望`make`使用这个变量，而不是`configure`。
- en: I assign *myprog.cfg* to the `sysconf_DATA` variable at ➊ to tie execution of
    this new rule into the framework provided by Automake. Automake will install this
    file into the system configuration directory after building it, if necessary.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我在➊将*myprog.cfg*分配给`sysconf_DATA`变量，以将这一新规则的执行与Automake提供的框架绑定。Automake会在构建文件之后（如果需要）将其安装到系统配置目录中。
- en: The files in `DATA` primaries are added as dependencies to the `all` target
    via the internal `all-am` target. If *myprog.cfg* doesn’t exist, `make` will look
    for a rule to build it. Since I have such a rule, `make` will simply execute that
    rule when I build the `all` target.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATA`主文件中的文件作为依赖项被添加到`all`目标中，经过内部的`all-am`目标。如果*myprog.cfg*不存在，`make`会查找构建它的规则。由于我有这样的规则，`make`会在我构建`all`目标时简单地执行这个规则。'
- en: I’ve added the template file name *myprog.cfg.in* to the `EXTRA_DIST` variable
    at the top of [Listing 18-26](ch18.xhtml#ch18ex26) because neither Autoconf nor
    Automake is aware of this file. In addition, I’ve added the generated file *myprog.cfg*
    to the `CLEANFILES` variable at the bottom of the listing because, as far as Automake
    is concerned, *myprog.cfg* is a distributed data file that should not be automatically
    deleted by `make clean`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我将模板文件名*myprog.cfg.in*添加到了[Listing 18-26](ch18.xhtml#ch18ex26)顶部的`EXTRA_DIST`变量中，因为Autoconf和Automake都不了解这个文件。另外，我将生成的文件*myprog.cfg*添加到了列表底部的`CLEANFILES`变量中，因为在Automake看来，*myprog.cfg*是一个分发数据文件，不应该被`make
    clean`自动删除。
- en: '**NOTE**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This example demonstrates a good reason for Automake to not automatically
    distribute files listed in *`DATA`* primaries. Sometimes such files are built
    in this manner. If built data files were automatically distributed, the *`distcheck`*
    target would fail because myprog.cfg was not available for distribution before
    building.*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个例子展示了Automake不自动分发*`DATA`*主文件的一个充分理由。有时候这些文件是以这种方式构建的。如果自动分发构建数据文件，*`distcheck`*目标将失败，因为在构建之前，myprog.cfg并不可以用于分发。*'
- en: In this example, I tied the building of *myprog.cfg* into the install process
    by adding it to the `sysconf_DATA` variable, and then I placed a dependency between
    *mydata.cfg.in* and *mydata.cfg*^([15](footnote.xhtml#ch18fn15)) to ensure that
    the installed file is built when `make all` is executed. You could also tie into
    a standard or custom build or installation target using appropriate `-hook` or
    custom targets.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将*myprog.cfg*的构建过程与安装过程结合，通过将其添加到`sysconf_DATA`变量中，然后我在*mydata.cfg.in*和*mydata.cfg*之间建立了一个依赖关系^([15](footnote.xhtml#ch18fn15))，以确保在执行`make
    all`时正确构建安装文件。你还可以通过使用适当的`-hook`或自定义目标，将其与标准或自定义构建或安装目标结合。
- en: No discussion of this topic would be complete without a mention of the Gnulib
    *configmake* module. If you’re already using Gnulib and need to do something like
    what I’ve been talking about in this item, consider using *configmake*, which
    creates a *configmake.h* header file that can be included by your source files
    to provide access to all of the standard directory variables as C preprocessor
    macros. It’s only useful for C code, so you’d still need the techniques I’ve shown
    you here for non-C-source code use cases (such as installed configuration files
    that need to reference prefix variable paths).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论这个话题时，如果不提到Gnulib的*configmake*模块，那就不完整。如果你已经在使用Gnulib，并且需要做一些像我在这一项目中讨论的事情，可以考虑使用*configmake*，它会创建一个*configmake.h*头文件，可以被你的源文件包含，以便通过C预处理器宏访问所有标准目录变量。它仅对C代码有用，因此对于非C源代码的使用场景（比如需要引用前缀变量路径的已安装配置文件），你仍然需要我在这里展示的技巧。
- en: 'Item 8: Using the Autoconf Archive Project'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 8：使用Autoconf档案项目
- en: 'In “Item 5: Hacking Autoconf Macros” on [page 511](ch18.xhtml#page_511), I
    demonstrated a technique for hacking Autoconf macros to provide functionality
    that’s close to, but not exactly the same as, that of the original macro. When
    you need a macro that Autoconf doesn’t provide, you can either write it yourself
    or look for one that someone else has written. This item is about the second option,
    and a perfect place to begin your search is the Autoconf Archive project.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第511页](ch18.xhtml#page_511)的“项目5：黑客Autoconf宏”中，我演示了一种黑客Autoconf宏的技术，提供了接近但并不完全相同于原始宏功能的功能。当你需要一个Autoconf没有提供的宏时，你可以自己编写，或者寻找别人已经编写的。这一项目讲的是第二个选项，开始寻找的一个完美地方是Autoconf档案项目。
- en: 'As of this writing, the Autoconf Archive source project is hosted by GNU Savannah.^([16](footnote.xhtml#ch18fn16))
    The original ac-archive project was the result of a merger between two older projects:
    one by Guido Draheim (at *[http://ac-archive.sourceforge.net/](http://ac-archive.sourceforge.net/)*)
    and the other by Peter Simon (at *http://auto-archive.cryp.to*). The first of
    these sites is still online today, although it displays a huge red warning box
    indicating that you should submit updates to the GNU Autoconf Macro Archive at
    Savannah; the second has been taken down. There is some long history and not a
    few flame wars on email lists between these two projects. Ultimately, each project
    incorporated most of the contents of the other, but Peter Simon’s is the one that
    was migrated into the Savannah repository, and the current home page is found
    at *[https://www.gnu.org/software/autoconf-archive/](https://www.gnu.org/software/autoconf-archive/)*.^([17](footnote.xhtml#ch18fn17))'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，Autoconf Archive源项目托管在GNU Savannah上。^([16](footnote.xhtml#ch18fn16)) 原始的ac-archive项目是两个较旧项目合并的结果：一个由Guido
    Draheim（位于*[http://ac-archive.sourceforge.net/](http://ac-archive.sourceforge.net/)*)创建，另一个由Peter
    Simon（位于*http://auto-archive.cryp.to*）创建。第一个网站至今仍在运行，尽管它显示了一个巨大的红色警告框，提示你应将更新提交到GNU
    Autoconf宏存档（位于Savannah）；第二个网站已被关闭。这两个项目之间有很长的历史，也有不少邮件列表上的激烈争论。最终，每个项目都将对方的大部分内容纳入了自己的项目中，但Peter
    Simon的项目最终被迁移到了Savannah仓库，当前主页位于*[https://www.gnu.org/software/autoconf-archive/](https://www.gnu.org/software/autoconf-archive/)*。^([17](footnote.xhtml#ch18fn17))
- en: The value in the archive is that private macros become public and public macros
    are incrementally improved by many users.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 存档中的价值在于，私有宏变为公开宏，而公开宏则被许多用户逐步改进。
- en: As of this writing, the macro archive contains over 500 macros not distributed
    with Autoconf, including the `AX_PTHREAD` macro discussed in “Doing Threads the
    Right Way” on [page 384](ch14.xhtml#page_384). The latest release of the archive
    can be checked out from the project’s Savannah git site. The site indexes macros
    by category, author, and open source license, allowing you to choose macros based
    on specific criteria. You can also search for a macro by name or by entering any
    text that might be found in the macro’s header comments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，宏存档包含超过500个不随Autoconf分发的宏，包括在《正确使用线程》一文中讨论的`AX_PTHREAD`宏，见[第384页](ch14.xhtml#page_384)。存档的最新版本可以从项目的Savannah
    git站点进行查看。该站点按类别、作者和开源许可证索引宏，允许你根据特定标准选择宏。你还可以通过名称搜索宏，或输入宏头部注释中可能出现的任何文本。
- en: If you find yourself in need of a macro that Autoconf doesn’t appear to provide,
    check out the Autoconf Archive.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要一个Autoconf似乎没有提供的宏，可以查看Autoconf Archive。
- en: 'Item 9: Using Incremental Installation Techniques'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 9：使用增量安装技术
- en: Some people have requested that `make install` be made smart enough to install
    only files that are not already installed or that are newer than installed versions
    of the same files.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人要求`make install`足够智能，只安装那些尚未安装或比已安装版本更新的文件。
- en: 'This feature is available by default to users by passing the `-C` command line
    option to `install-sh`. It can be enabled directly by end users by using the following
    syntax on the `make` command line during execution of `make install`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，用户可以通过向`install-sh`传递`-C`命令行选项来使用此功能。最终用户可以通过在执行`make install`时使用以下语法直接启用此功能：
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you think your users will benefit from this option, consider adding some
    information about its proper use to the *INSTALL* file that ships with your project.
    Don’t you just love features you don’t have to implement?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你的用户会受益于此选项，可以考虑在项目随附的*INSTALL*文件中添加一些关于如何正确使用此功能的信息。你不觉得这种不需要你实现的功能很棒吗？
- en: 'Item 10: Using Generated Source Code'
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 10：使用生成的源代码
- en: Automake requires that all source files used within a project be statically
    defined within the project’s *Makefile.am* files, but sometimes the contents of
    source files need to be generated at build time.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Automake要求在项目的*Makefile.am*文件中静态定义所有源文件，但有时源文件的内容需要在构建时生成。
- en: There are two ways to deal with generated sources (more specifically, generated
    header files) in your projects. The first involves the use of an Automake-provided
    crutch for developers not interested in the finer points of `make`. The second
    involves writing proper dependency rules to allow `make` to understand the relationships
    between your source files and your products. I’ll cover the crutch first, and
    then we’ll get into the details of proper dependency management in *Makefile.am*
    files.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以处理项目中的生成源文件（更具体地说，是生成的头文件）。第一种方法是使用Automake提供的“拐杖”，供那些不关心`make`细节的开发人员使用。第二种方法是编写适当的依赖规则，让`make`理解源文件与产品之间的关系。我将首先讲解“拐杖”方法，然后我们再深入探讨如何在*Makefile.am*文件中进行适当的依赖管理。
- en: '*Using the BUILT_SOURCES Variable*'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用BUILT_SOURCES变量*'
- en: When you have a header file that’s generated as part of your build process,
    you can tell Automake to generate rules that will always create this file first,
    before attempting to build your products. To do this, add the header file to the
    Automake `BUILT_SOURCES` variable, as shown in [Listing 18-27](ch18.xhtml#ch18ex27).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个作为构建过程一部分生成的头文件时，可以告诉Automake生成规则，确保在尝试构建产品之前总是先创建该文件。为此，请将头文件添加到Automake的`BUILT_SOURCES`变量中，如[清单
    18-27](ch18.xhtml#ch18ex27)所示。
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 18-27: Using `BUILT_SOURCES` to deal with generated source files*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-27：使用`BUILT_SOURCES`处理生成的源文件*'
- en: The `nodist_program_SOURCES` variable ensures that Automake will not generate
    rules that try to distribute this file; we want it to be built when the end user
    runs `make`, not shipped in the distribution package.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodist_program_SOURCES`变量确保Automake不会生成尝试分发此文件的规则；我们希望它在最终用户运行`make`时构建，而不是在分发包中提供。'
- en: Without a user-provided clue, Automake-generated makefiles have no way of knowing
    that the rule for *generated.h* should be executed before *program.c* is compiled.
    I call `BUILT_SOURCES` a “crutch” because it simply forces the rules used to generate
    the listed files to execute first, and only when the user makes the `all` or `check`
    target. The rules created using `BUILT_SOURCES` aren’t even executed if you attempt
    to make the `program` target directly. With that said, let’s look at what’s going
    on under the covers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有用户提供的线索，Automake生成的makefile无法知道*generated.h*的规则应该在编译*program.c*之前执行。我称`BUILT_SOURCES`为“拐杖”，因为它只是强制执行用于生成列出的文件的规则，并且仅在用户执行`all`或`check`目标时执行。即使直接尝试构建`program`目标，如果没有执行`BUILT_SOURCES`规则，也不会执行这些规则。话虽如此，让我们看看背后发生了什么。
- en: '*Dependency Management*'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*依赖管理*'
- en: 'There are two distinct classes of source files in a C or C++ project: those
    explicitly defined as dependencies within your makefile and those referenced only
    indirectly through, for instance, preprocessor inclusion.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在C或C++项目中，源文件分为两类：一种是明确在makefile中定义为依赖项的文件，另一种是通过例如预处理器包含间接引用的文件。
- en: You can hardcode all of these dependencies directly into your makefiles. For
    instance, if *program.c* includes *program.h*, and if *program.h* includes *console.h*
    and *print.h*, then *program.o* actually depends on all of these files, not just
    *program.c*. And yet, a normal handcoded makefile explicitly defines only the
    relationships between the *.c* files and the program. For a truly accurate build,
    `make` needs to be told about all of these relationships using a rule like the
    one shown in [Listing 18-28](ch18.xhtml#ch18ex28).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将所有这些依赖直接硬编码到你的makefile中。例如，如果*program.c*包含*program.h*，并且*program.h*包含*console.h*和*print.h*，那么*program.o*实际上依赖于所有这些文件，而不仅仅是*program.c*。然而，普通的手工编写的makefile只会显式定义*.c*文件与程序之间的关系。为了实现真正准确的构建，`make`需要通过类似[清单
    18-28](ch18.xhtml#ch18ex28)中所示的规则来了解所有这些关系。
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 18-28: Rules describing the complete relationship between files*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-28：描述文件之间完整关系的规则*'
- en: The relationship between *program.o* and *program.c* is often defined by an
    *implicit* rule, so the rule at ➊ in [Listing 18-28](ch18.xhtml#ch18ex28) is often
    broken into two separate rules, as shown in [Listing 18-29](ch18.xhtml#ch18ex29).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*program.o*与*program.c*之间的关系通常由一个*隐式*规则定义，因此[清单 18-28](ch18.xhtml#ch18ex28)中➊的规则通常会被拆分为两个独立的规则，如[清单
    18-29](ch18.xhtml#ch18ex29)所示。'
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 18-29: An implicit rule for C source files, defined as a GNU `make`
    pattern rule*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-29：C源文件的隐式规则，定义为GNU `make`模式规则*'
- en: In [Listing 18-29](ch18.xhtml#ch18ex29), the GNU `make`-specific *pattern rule*
    at ➊ tells `make` that the associated command can generate a file ending in *.o*
    from a file of the same base name ending in *.c*.^([18](footnote.xhtml#ch18fn18))
    Thus, whenever `make` needs to find a rule to generate a file ending in *.o* that’s
    listed as a dependency in one of your rules, it searches for a *.c* file with
    the same base name. If it finds one, it applies this rule to rebuild the *.o*
    file from the corresponding *.c* file if the timestamp on the *.c* file is newer
    than that of the existing *.o* file or if the *.o* file is missing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 18-29](ch18.xhtml#ch18ex29)中，GNU `make` 特定的 *模式规则* 在 ➊ 处告诉 `make` 关联的命令可以从一个以
    *.c* 结尾、基名相同的文件生成一个以 *.o* 结尾的文件。^([18](footnote.xhtml#ch18fn18)) 因此，每当 `make`
    需要找到一个规则来生成作为某个规则依赖项列出的以 *.o* 结尾的文件时，它会搜索一个基名相同的 *.c* 文件。如果找到了，它会应用这个规则，从相应的 *.c*
    文件重新构建 *.o* 文件，前提是 *.c* 文件的时间戳比现有的 *.o* 文件更新，或者 *.o* 文件丢失。
- en: There is a documented set of implicit pattern rules built into `make`, so you
    don’t generally have to write such rules. Still, you must somehow tell `make`
    about the indirect^([19](footnote.xhtml#ch18fn19)) dependencies between the *.o*
    file and any included *.h* files. These dependencies cannot simply be implied
    with a built-in rule because there are no implicit relationships between these
    files that are based on file naming conventions, such as the relationship between
    *.c* and *.o* files. The relationships are manually coded into the source and
    header files as inclusions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 中有一套文档化的隐式模式规则，因此你通常不需要编写这样的规则。然而，你仍然需要以某种方式告诉 `make` *.o* 文件与任何包含的
    *.h* 文件之间的间接^([19](footnote.xhtml#ch18fn19)) 依赖关系。这些依赖关系不能仅通过内建规则来推断，因为这些文件之间没有基于文件命名约定的隐式关系，例如
    *.c* 和 *.o* 文件之间的关系。这些关系是手动编码到源文件和头文件中的包含关系。'
- en: As I mentioned in [Chapter 3](ch03.xhtml), writing such rules is tedious and
    error prone, because during development (and even maintenance, to a lesser degree),
    the myriad relationships between source and header files can change all the time
    and the rules must be updated carefully with each change to keep the build accurate.
    The C preprocessor is much better suited to automatically writing and maintaining
    these rules for you.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第3章](ch03.xhtml)中提到的，编写这样的规则是繁琐且容易出错的，因为在开发过程中（甚至在维护过程中，虽然程度较轻），源文件和头文件之间的种种关系可能随时发生变化，每次更改时都必须小心地更新规则以保持构建的准确性。C
    预处理器更适合自动为你编写和维护这些规则。
- en: A Two-Pass System
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 两遍系统
- en: There are two ways to use the preprocessor to manage dependencies. The first
    is to create a two-pass system, wherein the first pass just builds the dependencies
    and the second pass compiles the source code based on those dependencies. This
    is done by defining rules that use certain preprocessor commands to generate `make`
    dependency rules, as shown in [Listing 18-30](ch18.xhtml#ch18ex30).^([20](footnote.xhtml#ch18fn20))
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以使用预处理器来管理依赖关系。第一种方法是创建一个两遍系统，其中第一遍仅构建依赖关系，第二遍则根据这些依赖关系编译源代码。这是通过定义使用某些预处理器命令生成
    `make` 依赖规则的规则来完成的，如[清单 18-30](ch18.xhtml#ch18ex30)所示。^([20](footnote.xhtml#ch18fn20))
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 18-30: Building automatic dependencies directly*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-30：直接构建自动依赖关系*'
- en: 'In [Listing 18-30](ch18.xhtml#ch18ex30), the pattern rule at ➊ specifies the
    same sort of relationship between *.d* and *.c* files as the one shown at ➊ in
    [Listing 18-29](ch18.xhtml#ch18ex29) does for *.o* and *.c* files. The `sinclude`
    statement here at ➋ tells `make` to include another makefile, and GNU `make` is
    smart enough not only to ensure that all makefiles are included before the primary
    dependency graph is analyzed but also to look for rules to build them.^([21](footnote.xhtml#ch18fn21))
    Running `make` on this makefile produces the following output:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 18-30](ch18.xhtml#ch18ex30)中，➊ 处的模式规则指定了与 *.d* 和 *.c* 文件之间的关系，正如[清单 18-29](ch18.xhtml#ch18ex29)中
    ➊ 处所示的 *.o* 和 *.c* 文件之间的关系。这里的 `sinclude` 语句在 ➋ 处告诉 `make` 包含另一个 makefile，并且 GNU
    `make` 足够聪明，不仅确保在分析主依赖关系图之前包含所有 makefile，还会查找构建它们的规则。^([21](footnote.xhtml#ch18fn21))
    运行 `make` 时会产生如下输出：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see here, the rule to generate *program.d* is executed first, as
    `make` attempts to include that file. The elided section at ➊ refers to the many
    system header files traversed while recursively scanning the included set of headers.
    The file contains a dependency rule similar^([22](footnote.xhtml#ch18fn22)) to
    the one we wrote at ➋ in [Listing 18-29](ch18.xhtml#ch18ex29). (The reference
    to *program.c* is missing in our hand-coded rule’s dependency list because it’s
    redundant, though harmless.) You can also see from the console example that touching
    one of these included files now properly causes the *program.c* source file to
    be rebuilt.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，生成*program.d*的规则首先被执行，因为`make`尝试包含该文件。➊位置省略的部分指的是在递归扫描包含的头文件集时遍历的许多系统头文件。该文件包含了类似于我们在[列表
    18-29](ch18.xhtml#ch18ex29)中的➋位置编写的依赖规则^([22](footnote.xhtml#ch18fn22))。 （我们手动编写的规则依赖列表中缺少对*program.c*的引用，因为它是多余的，尽管这样并不会造成问题。）从控制台示例中，你也可以看到，现在触碰这些包含的文件之一会正确地导致*program.c*源文件重新构建。
- en: 'The problems with the mechanism outlined in [Listing 18-30](ch18.xhtml#ch18ex30)
    include the fact that the entire source tree must be traversed twice: once to
    check for and possibly generate the dependency files and then again to compile
    any modified source files.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 18-30](ch18.xhtml#ch18ex30)中概述的机制存在的问题包括：整个源代码树必须被遍历两次：第一次是检查并可能生成依赖文件，然后再次编译任何修改过的源文件。'
- en: 'Another problem is that if one header includes another, and the second header
    is modified, the object file will be updated but not the dependency file included
    by `make`. The next time the second-level header is modified, neither the object
    nor the dependency file will be updated. Deleted header files also cause problems:
    the build system doesn’t recognize that the deleted file was purposely removed,
    so it complains that files referenced in the existing dependencies are missing.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，如果一个头文件包含了另一个头文件，并且第二个头文件被修改了，目标文件会更新，但`make`包含的依赖文件却没有更新。下次修改第二级头文件时，既不会更新目标文件，也不会更新依赖文件。已删除的头文件也会引发问题：构建系统无法识别已删除的文件是被故意移除的，因此它会抱怨现有依赖关系中引用的文件丢失。
- en: Doing It in One Pass
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一次性完成
- en: A more efficient way to handle automatic dependencies is to generate the dependency
    files as a side effect of compilation. [Listing 18-31](ch18.xhtml#ch18ex31) shows
    how this can be done by using the non-portable `-MMD` GNU extension compiler option
    (highlighted in the listing).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 处理自动依赖关系的更高效方式是将依赖文件作为编译的副作用生成。[列表 18-31](ch18.xhtml#ch18ex31)展示了如何通过使用非便携的`-MMD`
    GNU扩展编译器选项（在列表中突出显示）来完成这一操作。
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 18-31: Generating dependencies as a side effect of compilation*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-31：将生成依赖作为编译的副作用*'
- en: Here, I’ve removed the second pattern rule (originally shown at ➊ in [Listing
    18-30](ch18.xhtml#ch18ex30)) and added a `-MMD` option to the compiler command
    line at ➊ in [Listing 18-31](ch18.xhtml#ch18ex31). This option tells the preprocessor
    to generate a *.d* file of the same base name as the *.c* file that it’s currently
    compiling. When `make` is executed on a clean work area, the `sinclude` statement
    at ➋ silently fails to include the missing *program.d* file, but it doesn’t matter
    because all of the object files will be built the first time anyway. During subsequent
    incremental builds, the previously built *program.d* is included, and its dependency
    rules take effect during those builds.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我已删除第二个模式规则（原本在[列表 18-30](ch18.xhtml#ch18ex30)中的➊位置），并在[列表 18-31](ch18.xhtml#ch18ex31)中的➊位置为编译器命令行添加了`-MMD`选项。此选项告诉预处理器生成一个与当前编译的*.c*文件具有相同基本名称的*.d*文件。当`make`在干净的工作区执行时，➋位置的`sinclude`语句会静默地失败，未能包含缺失的*program.d*文件，但这并不重要，因为所有的目标文件第一次都会被构建。在随后的增量构建过程中，之前构建的*program.d*文件会被包含，并且它的依赖规则会在这些构建中生效。
- en: '*Built Sources Done Right*'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*正确构建的源文件*'
- en: The one-pass method just described is roughly the one that Automake uses to
    manage automatic dependencies, when possible. The problems with this approach
    are most often manifested when working with generated sources, including both
    *.c* files and *.h* files. For instance, let’s expand the example shown in [Listing
    18-31](ch18.xhtml#ch18ex31) a bit to contain a generated header file called *generated.h*,
    included by *program.h*. [Listing 18-32](ch18.xhtml#ch18ex32) shows a first attempt
    at this modification. Additions to [Listing 18-31](ch18.xhtml#ch18ex31) are highlighted
    in this listing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述的一次性方法大致是Automake在可能的情况下用来管理自动依赖的方式。这种方法的问题通常出现在处理生成的源文件时，包括*.c*文件和*.h*文件。例如，让我们扩展[清单18-31](ch18.xhtml#ch18ex31)中的示例，增加一个名为*generated.h*的生成的头文件，该文件被*program.h*包含。[清单18-32](ch18.xhtml#ch18ex32)展示了这一修改的第一次尝试。[清单18-31](ch18.xhtml#ch18ex31)中的新增内容在此清单中有所高亮。
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 18-32: A makefile that works with a generated header file dependency*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-32：一个与生成的头文件依赖关系一起工作的makefile*'
- en: 'In this case, when we execute `make`, we find that the lack of an initial dependency
    file works against us:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当我们执行`make`时，我们发现缺乏初始依赖文件对我们不利：
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because there is no initial secondary dependency information, `make` doesn’t
    know it needs to run the commands for the *generated.h* rule yet, because *generated.h*
    only depends on *Makefile*, which hasn’t changed. To fix this problem in a *Makefile.am*
    file, we could just list *generated.h* in the `BUILT_SOURCES` variable, as we
    did in [Listing 18-27](ch18.xhtml#ch18ex27) on [page 531](ch18.xhtml#page_531).
    This would add *generated.h* as the first dependency of the `all` and `check`
    targets, thereby forcing them to be built first in the likely event the user happens
    to enter `make`, `make all`, or `make check`.^([23](footnote.xhtml#ch18fn23))
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有初始的二级依赖信息，`make`不知道它需要执行*generated.h*规则的命令，因为*generated.h*只依赖于*Makefile*，而*Makefile*没有变化。为了解决在*Makefile.am*文件中的这个问题，我们可以像在[清单18-27](ch18.xhtml#ch18ex27)中[第531页](ch18.xhtml#page_531)那样，将*generated.h*列入`BUILT_SOURCES`变量中。这样会将*generated.h*添加为`all`和`check`目标的第一个依赖项，从而强制它们首先构建，以应对用户输入`make`、`make
    all`或`make check`的可能性。^([23](footnote.xhtml#ch18fn23))
- en: 'The proper way to handle this problem is very simple, and it works every time
    in both makefiles and *Makefile.am* files: write a dependency rule between *program.o*
    and *generated.h*, as shown in the updated makefile in [Listing 18-33](ch18.xhtml#ch18ex33).
    The highlighted line contains the additional rule.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的正确方法非常简单，并且在makefile和*Makefile.am*文件中每次都能奏效：在*program.o*和*generated.h*之间编写一个依赖规则，如[清单18-33](ch18.xhtml#ch18ex33)中更新后的makefile所示。高亮的行包含了额外的规则。
- en: '[PRE50]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 18-33: Adding a hardcoded dependency rule for a generated header file*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-33：为生成的头文件添加硬编码依赖规则*'
- en: 'The new rule tells `make` about the relationship between *program.o* and *generated.h*:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 新的规则告知`make`*program.o*与*generated.h*之间的关系：
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, touching *generated.h* (at ➊) causes `program` to be updated. Touching
    *Makefile* (at ➋) causes *generated.h* to be re-created first.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，修改*generated.h*（在➊处）会导致`program`被更新。修改*Makefile*（在➋处）会首先重新创建*generated.h*。
- en: To implement the dependency rule shown in [Listing 18-33](ch18.xhtml#ch18ex33)
    in an Automake *Makefile.am* file, you’d use the highlighted rule shown in [Listing
    18-34](ch18.xhtml#ch18ex34).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Automake的*Makefile.am*文件中实现[清单18-33](ch18.xhtml#ch18ex33)中显示的依赖规则，您将使用[清单18-34](ch18.xhtml#ch18ex34)中高亮的规则。
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 18-34: Replacing `BUILT_SOURCES` with a proper dependency rule*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-34：用一个合适的依赖规则替换`BUILT_SOURCES`*'
- en: This is exactly the same code shown previously in [Listing 18-27](ch18.xhtml#ch18ex27)
    on [page 531](ch18.xhtml#page_531), except that we’ve replaced the `BUILT_SOURCES`
    variable with a proper dependency rule. The advantage of this method is that it
    always works as it should; *generated.h* will always be built exactly when it
    needs to be, regardless of the target specified by the user.^([24](footnote.xhtml#ch18fn24))
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前在[清单18-27](ch18.xhtml#ch18ex27)中[第531页](ch18.xhtml#page_531)展示的代码完全相同，唯一的区别是我们将`BUILT_SOURCES`变量替换为了一个合适的依赖规则。此方法的优点在于它始终按预期工作；无论用户指定什么目标，*generated.h*都会在需要的时候被构建。^([24](footnote.xhtml#ch18fn24))
- en: If you had tried to generate a C source file rather than a header file, you’d
    find that you didn’t even need the additional dependency rule because *.o* files
    implicitly depend on their *.c* files. However, you must still list your generated
    *.c* file in the `nodist_program_SOURCES` variable to keep Automake from trying
    to distribute it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试生成一个 C 源文件而不是头文件，你会发现其实你根本不需要额外的依赖规则，因为 *.o* 文件隐式地依赖于它们的 *.c* 文件。然而，你仍然必须在
    `nodist_program_SOURCES` 变量中列出你生成的 *.c* 文件，以防止 Automake 尝试分发它。
- en: '**NOTE**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you define your own rule, you suppress any rules that Automake may generate
    for that product. In the case of a specific object file, this is not likely to
    be a problem, but keep this Automake idiosyncrasy in mind when defining rules.*'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你定义自己的规则时，你会抑制 Automake 可能为该产品生成的任何规则。在特定的目标文件的情况下，这通常不会成为问题，但在定义规则时请记住这个
    Automake 的特性。*'
- en: As you can see, all you really need to properly manage generated sources is
    a correctly written set of dependency rules as well as appropriate `nodist_*_SOURCES`
    variables. The `make` utility and the Autotools provide the required framework
    in the form of built-in `make` functionality, macros, and variables. You just
    have to put them together correctly. For example, in the *GNU Automake Manual*,
    see Section 8.1.2, which discusses program linking.^([25](footnote.xhtml#ch18fn25))
    This section refers to the `EXTRA_prog_DEPENDENCIES` variable as a mechanism for
    extending Automake’s generated dependency graph for a specific target.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，正确管理生成的源文件所需要的仅仅是正确编写的依赖规则集以及适当的 `nodist_*_SOURCES` 变量。`make` 工具和 Autotools
    提供了所需的框架，通过内建的 `make` 功能、宏和变量。你只需要将它们正确地组合在一起。例如，在 *GNU Automake 手册* 中，参见第 8.1.2
    节，它讨论了程序链接。^([25](footnote.xhtml#ch18fn25)) 本节提到 `EXTRA_prog_DEPENDENCIES` 变量，作为扩展
    Automake 生成的特定目标的依赖图的一种机制。
- en: 'Item 11: Disabling Undesirable Targets'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 11：禁用不需要的目标
- en: 'Sometimes the Autotools do too much for you. Here’s an example from the Automake
    mailing list:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，Autotools 为你做了太多的事情。以下是来自 Automake 邮件列表的一个例子：
- en: I use automake in one of my projects along with texinfo. That project has documentation
    full of images. As you probably know, `` `make pdf' `` makes a PDF document from
    JPGs and PNGs, whereas `` `make dvi' `` requires EPSs. However, EPS images are
    insanely large (in this case like 15 times larger than JPGs).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的一个项目中使用 automake 和 texinfo。该项目的文档充满了图片。正如你可能知道的，`` `make pdf' `` 会将 JPG
    和 PNG 文件制作成 PDF 文档，而 `` `make dvi' `` 则需要 EPS 文件。然而，EPS 图像非常大（在这个案例中比 JPG 大 15
    倍）。
- en: The problem is that running `` `make distcheck' `` results in error since the
    EPS images that should be there aren't there and `` `make distcheck' `` tries
    to run `make dvi' everywhere. I would like to run `` `make pdf' `` instead, or
    at least to disable building DVI. Is there any way to accomplish that?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是运行 `` `make distcheck' `` 会导致错误，因为应该存在的 EPS 图像并不存在，而 `` `make distcheck'
    `` 会尝试在所有地方运行 `make dvi'`。我希望能运行 `` `make pdf' ``，或者至少禁用构建 DVI。有办法做到吗？
- en: 'First a little background information: The Automake `TEXINFOS` primary makes
    several documentation targets available to the end user, including `info`, `dvi`,
    `ps`, `pdf`, and `html`. It also provides several installation targets, including
    `install-info`, `install-dvi`, `install-ps`, `install-pdf`, and `install-html`.
    Of these targets, only `info` is automatically built with `make` or `make all`,
    and only `install-info` is executed with `make install`.^([26](footnote.xhtml#ch18fn26))'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是一些背景信息：Automake 的 `TEXINFOS` 主要使多个文档目标可供最终用户使用，包括 `info`、`dvi`、`ps`、`pdf`
    和 `html`。它还提供了多个安装目标，包括 `install-info`、`install-dvi`、`install-ps`、`install-pdf`
    和 `install-html`。在这些目标中，只有 `info` 会在执行 `make` 或 `make all` 时自动构建，只有 `install-info`
    会在执行 `make install` 时执行。^([26](footnote.xhtml#ch18fn26))
- en: However, it appears that the `distcheck` target also builds at least the `dvi`
    target, as well. The problem just outlined is that the poster doesn’t provide
    the Encapsulated PostScript (EPS) graphics files required to build the DVI documentation,
    so the `distcheck` target fails because it can’t build documentation that the
    poster doesn’t want to support anyway.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，似乎 `distcheck` 目标也会构建至少 `dvi` 目标。刚才提到的问题是，海报没有提供构建 DVI 文档所需的封装 PostScript（EPS）图形文件，因此
    `distcheck` 目标失败，因为它无法构建海报本不打算支持的文档。
- en: To fix this issue, you would simply provide your own version of the target that
    does nothing, as shown in [Listing 18-35](ch18.xhtml#ch18ex35).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，你只需要提供你自己的版本的目标，它什么也不做，如[清单 18-35](ch18.xhtml#ch18ex35)所示。
- en: '[PRE53]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Listing 18-35: Disabling the `dvi` target in a* Makefile.am *that specifies
    `TEXINFOS` primaries*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-35：在 Makefile.am 中禁用 `dvi` 目标，该文件指定了 `TEXINFOS` 主项*'
- en: With the one-line addition at ➊, `make distcheck` is back in business. Now,
    when it builds the `dvi` target, it succeeds because it does nothing.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处添加一行代码后，`make distcheck` 又恢复了工作。现在，当它构建 `dvi` 目标时，它成功了，因为什么都没有做。
- en: Other Automake primaries provide multiple additional targets as well. If you
    only want to support a subset of these targets, you can effectively disable the
    undesired targets by providing one of your own. If you’d like to be a bit more
    vocal about the disabling override, simply include an `echo` statement as a command
    that tells the user that your package doesn’t provide DVI documentation, but be
    careful not to execute anything that might fail in this override, or your user
    will be right back in the same boat.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 Automake 主项也提供了多个附加目标。如果你只想支持这些目标中的一部分，你可以通过提供你自己的目标来有效地禁用不需要的目标。如果你希望在禁用重写时更加直言不讳，可以简单地包括一个
    `echo` 语句，告诉用户你的包不提供 DVI 文档，但要小心不要执行任何可能失败的操作，否则用户会再次遇到相同的问题。
- en: 'Item 12: Watch Those Tab Characters!'
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 12：注意制表符字符！
- en: Having made the transition to Automake, you’re not using raw makefiles anymore,
    so why should you still care about tab characters? Remember that *Makefile.am*
    files are simply stylized makefiles. Ultimately, every line in a *Makefile.am*
    file will be either consumed directly by Automake, and then transformed into true
    `make` syntax, or copied directly into the final makefile. This means that tab
    characters matter within *Makefile.am* files.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡到 Automake 后，你不再使用原始的 makefile，因此为什么你还需要关注制表符字符呢？记住，*Makefile.am* 文件只是样式化的
    makefile。最终，*Makefile.am* 文件中的每一行都会被 Automake 直接处理，然后转化为真正的 `make` 语法，或者直接复制到最终的
    makefile 中。这意味着，在 *Makefile.am* 文件中，制表符字符是重要的。
- en: 'Consider this example from the Automake mailing list:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 参考这个来自 Automake 邮件列表的例子：
- en: '[PRE54]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: I have been reading both autoconf and automake manuals and as far as I can see,
    the above should work. However the files (a.cpp or b.cpp) [are] always added at
    the bottom of the generated Makefile and are therefore not used in the compilation.
    No matter what I try, I cannot get even the above code to generate a correct makefile,
    but obviously I am doing something wrong.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经阅读了 autoconf 和 automake 手册，据我所见，上面的做法应该是可行的。然而，文件（a.cpp 或 b.cpp）[始终] 被添加到生成的
    Makefile 的底部，因此在编译时未被使用。不管我尝试什么，我无法让上述代码生成正确的 makefile，但显然我做错了什么。
- en: 'The answer, provided by another poster, was simple and accurate, if not terse
    to a fault:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 另一位发布者提供的答案简单而准确，尽管有些简洁到极点：
- en: Remove the indentation.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 移除缩进。
- en: The trouble here is that the two lines within the Automake conditional at ➊
    and ➋ are indented with tab characters.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，Automake 条件语句中的两行在 ➊ 和 ➋ 处用制表符字符进行了缩进。
- en: You may recall from “Automake Configuration Features” on [page 380](ch14.xhtml#page_380),
    where I discussed the implementation of Automake conditionals, that text within
    conditionals is prefixed with an Autoconf substitution variable that is ultimately
    transformed into either an empty string or a hash mark. The implication here is
    that these lines are essentially either left as is or commented out within the
    final makefile. The commented lines really don’t concern us, but you can clearly
    see that if the uncommented lines in the makefile begin with the tab character,
    Automake will treat them as commands, rather than as definitions, and sort them
    accordingly in the final makefile. When `make` processes the generated makefile,
    it will attempt to interpret these lines as orphan commands.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在 [第380页](ch14.xhtml#page_380)中“Automake 配置特性”部分，我讨论了 Automake 条件语句的实现，其中条件语句中的文本前缀是一个
    Autoconf 替换变量，最终会转化为空字符串或哈希符号。这里的含义是，这些行在最终的 makefile 中基本上是保留原样或被注释掉。被注释的行对我们不重要，但你可以清楚地看到，如果
    makefile 中未注释的行以制表符字符开头，Automake 会将它们视为命令，而不是定义，并将它们在最终的 makefile 中进行排序。当 `make`
    处理生成的 makefile 时，它会试图将这些行解释为孤立命令。
- en: '**NOTE**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Had the original poster used spaces to indent the conditional statements,
    they’d have had no problem.*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果原始发布者使用空格来缩进条件语句，就不会遇到问题了。*'
- en: 'The moral of the story: watch those tab characters!'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的教训：注意制表符字符！
- en: 'Item 13: Packaging Choices'
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 13：打包选项
- en: The ultimate goal of a package maintainer is to make it easy for the end user.
    System-level packages never have this problem because they don’t rely on anything
    that’s not part of the core operating system. But higher-level packages often
    rely on multiple subpackages, some of which are more pervasive than others.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 包维护者的最终目标是使最终用户的使用变得简单。系统级包通常没有这个问题，因为它们不依赖于任何不是操作系统核心部分的东西。但更高层次的包常常依赖于多个子包，其中有些比其他的更加普遍。
- en: For example, consider the Subversion project. If you download the latest source
    archive from the Subversion project website, you’ll find that it comes in two
    flavors. The first contains only the Subversion source code, but if you unpack
    and build this project, you’ll find that you’ll need to download and install the
    Apache runtime and runtime utility (*apr* and *apr-utils*) packages, the *zlib-devel*
    package, and the *sqlite-devel* package. At this point, you can build Subversion,
    but to enable secure access to repositories via HTTPS, you’ll also need *neon*
    or *serf* and *openssl*.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑Subversion项目。如果你从Subversion项目网站下载最新的源代码包，你会发现它有两种版本。第一个包只包含Subversion源代码，但如果你解压并构建该项目，你会发现你需要下载并安装Apache运行时和运行时工具（*apr*和*apr-utils*）包、*zlib-devel*包和*sqlite-devel*包。这时，你可以构建Subversion，但为了通过HTTPS启用对仓库的安全访问，你还需要*neon*或*serf*和*openssl*。
- en: The Subversion project maintainers felt that community adoption of Subversion
    was important enough to go the extra mile, so to speak. To help you out in your
    quest to build a functional Subversion package, they’ve provided a second package
    called *subversion-deps*, which contains a source-level distribution of some of
    Subversion’s more important requirements.^([27](footnote.xhtml#ch18fn27)) Simply
    unpack the *subversion-deps* source package in the same directory where you unpacked
    your *subversion* source package. The root directory in the *subversion-deps*
    package contains only subdirectories—one for each of these source-level dependencies.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion项目的维护者认为，社区采用Subversion足够重要，值得不遗余力地推进。所以，为了帮助你构建一个功能完备的Subversion包，他们提供了一个名为*subversion-deps*的第二个包，其中包含了Subversion一些重要依赖的源代码分发包^([27](footnote.xhtml#ch18fn27))。只需将*subversion-deps*源包解压到与你解压*subversion*源包相同的目录中。*subversion-deps*包的根目录仅包含子目录——每个子目录对应一个源级别的依赖。
- en: You can choose to add source packages to your projects’ build systems in the
    same manner. Of course, the process is much simpler if you’re using Automake.
    You need only call `AC_CONFIG_SUBDIRS` for subdirectories containing add-on projects
    in your build tree. `AC_CONFIG_SUBDIRS` quietly ignores missing subproject directories.
    I showed you an example of this process in [Chapter 14](ch14.xhtml), where I built
    the FLAIM toolkit as a subproject if it existed as a subdirectory within any of
    the higher-level FLAIM project directories.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择以相同的方式将源代码包添加到你的项目构建系统中。当然，如果你使用的是Automake，过程会简单得多。你只需要调用`AC_CONFIG_SUBDIRS`来为构建树中包含附加项目的子目录配置子项目。`AC_CONFIG_SUBDIRS`会默默忽略缺失的子项目目录。我在[第14章](ch14.xhtml)中向你展示了这个过程的一个例子，当FLAIM工具包作为任何更高层次FLAIM项目目录中的子目录存在时，我将它构建为一个子项目。
- en: Which packages should you ship with your package? The key lies in determining
    which packages your consumers are least likely to be able to find on their own.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该随你的包一起发布哪些包？关键在于确定哪些包是你的消费者最不可能自行找到的。
- en: Wrapping Up
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: I hope you find these solutions—indeed, this book—useful on your quest to create
    a really great user experience with your open source projects. I began this book
    with the statement that people often start out hating the Autotools because they
    don’t understand the purpose of the Autotools. By now, you should have a fairly
    well-developed sense of this purpose. If you were disinclined to use the Autotools
    before, then I hope I’ve given you reason to reconsider.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些解决方案——实际上，这本书——对你在开源项目中创建出色用户体验的探索有所帮助。我在本书开头提到，人们常常因为不了解Autotools的目的而讨厌它们。到现在为止，你应该已经对这个目的有了相当清晰的认识。如果你之前不愿意使用Autotools，那么希望我已经给你足够的理由去重新考虑。
- en: 'Recall the famously misquoted line from Albert Einstein: “Everything should
    be made as simple as possible, but no simpler.”^([28](footnote.xhtml#ch18fn28))
    Not all things can be made so simple that anyone can master them with little training.
    This is especially true when it comes to processes that are designed to make life
    simpler for others. The Autotools offer the ability for experts—programmers and
    software engineers—to make open source software more accessible to end users.
    Let’s face it—this process is less than trivial, but the Autotools attempt to
    make it as simple as possible.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下阿尔伯特·爱因斯坦那句常被误引的名言：“一切事物都应该尽可能简单，但不能过于简单。”^([28](footnote.xhtml#ch18fn28))
    并不是所有事物都能简化到任何人都能在少量培训下掌握的程度。尤其是当涉及到那些旨在为他人简化生活的过程时，这一点尤为明显。Autotools 提供了一个让专家—程序员和软件工程师—能够让开源软件更加易于终端用户访问的能力。说实话，这个过程并不简单，但
    Autotools 力图将其简化到尽可能的程度。
