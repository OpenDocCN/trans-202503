- en: '## **5'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **5'
- en: MATH WITH DIGITAL CIRCUITS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数字电路中的数学**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In the previous chapter we covered logic gates and digital circuits, which enable
    us to implement logical expressions in hardware. Earlier in this book we defined
    computers as electronic devices that can be programmed to carry out a set of instructions.
    In this chapter, I begin to bridge those concepts by showing you how simple logic
    gates pave the way for the operations a computer executes. We cover a specific
    operation that all computers are able to perform–addition. First, we go over the
    basics of addition in binary. Then we use logic gates to build hardware that adds,
    demonstrating how simple gates work together in a computer to perform useful operations.
    Finally, we cover the representation of integers as signed and unsigned numbers
    in a computer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了逻辑门和数字电路，它们使我们能够在硬件中实现逻辑表达式。在本书的早些时候，我们将计算机定义为可以被编程执行一组指令的电子设备。在本章中，我将通过向你展示简单的逻辑门如何为计算机执行的操作铺平道路，来桥接这些概念。我们将讨论所有计算机都能执行的一个特定操作——加法。首先，我们将回顾二进制加法的基础知识。然后，我们使用逻辑门构建加法硬件，演示简单的逻辑门如何在计算机中协同工作以执行有用的操作。最后，我们将讨论整数在计算机中的有符号和无符号表示。
- en: '**Binary Addition**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二进制加法**'
- en: 'Let’s look at the basics of how addition works in binary. The underlying principles
    of addition are the same for all place-value systems, so you have a head start
    since you already know how to add in decimal! Rather than deal in abstract concepts,
    let’s take a concrete example: adding two specific 4-bit numbers, 0010 and 0011,
    as shown in [Figure 5-1](ch05.xhtml#ch5fig1).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下二进制加法的基础。加法的基本原理在所有位置值系统中是相同的，因此你已经知道如何在十进制中加法，所以你有一定的基础！为了避免抽象的概念，我们来看一个具体的例子：加法两个特定的
    4 位数 0010 和 0011，如[图 5-1](ch05.xhtml#ch5fig1)所示。
- en: '![image](../images/fig5-1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-1.jpg)'
- en: '*Figure 5-1: Adding two binary numbers*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：加法两个二进制数*'
- en: Just as we do in decimal, we begin with the rightmost place, known as the *least
    significant bit*, and add the two values together ([Figure 5-2](ch05.xhtml#ch5fig2)).
    Here, 0 + 1 is 1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在十进制中一样，我们从最右侧的位开始，称为*最低有效位*，并将两个值相加（[图 5-2](ch05.xhtml#ch5fig2)）。这里，0 + 1
    等于 1。
- en: '![image](../images/fig5-2.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-2.jpg)'
- en: '*Figure 5-2: Adding the least significant bit of two binary numbers*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：加法两个二进制数的最低有效位*'
- en: Now let’s move one bit to the left and add those values together, as shown in
    [Figure 5-3](ch05.xhtml#ch5fig3).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们向左移动一位并将这些值相加，如[图 5-3](ch05.xhtml#ch5fig3)所示。
- en: '![image](../images/fig5-3.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-3.jpg)'
- en: '*Figure 5-3: Adding the twos place*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：加法中的二进制位*'
- en: As you can see in [Figure 5-3](ch05.xhtml#ch5fig3), this place requires us to
    add 1 + 1, which presents us with an interesting twist. In decimal, we represent
    1 + 1 with the symbol 2, but in binary we only have two symbols, 0 and 1\. In
    binary, 1 + 1 is 10 (see [Chapter 1](ch01.xhtml) for an explanation), which requires
    two bits to represent. We can only put one bit in this place, so 0 goes into the
    current place, and we carry the 1 to the next place, as indicated in [Figure 5-3](ch05.xhtml#ch5fig3).
    We can now move to the next place (see [Figure 5-4](ch05.xhtml#ch5fig4)), and
    when we add these bits, we must include the carried bit from the previous place.
    This gives us 1 + 0 + 0 = 1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 5-3](ch05.xhtml#ch5fig3)中看到的，这一位要求我们加 1 + 1，这给我们带来了一个有趣的转折。在十进制中，1 + 1用符号
    2 来表示，但在二进制中我们只有两个符号，0 和 1。在二进制中，1 + 1 是 10（详见[第一章](ch01.xhtml)的解释），这需要两个比特来表示。我们只能在这一位放一个比特，所以
    0 放在当前位，1 被进位到下一位，如[图 5-3](ch05.xhtml#ch5fig3)所示。现在我们可以移到下一位（参见[图 5-4](ch05.xhtml#ch5fig4)），当我们加上这些比特时，必须包括从上一位进位的比特。这给我们
    1 + 0 + 0 = 1。
- en: '![image](../images/fig5-4.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-4.jpg)'
- en: '*Figure 5-4: Adding the fours place*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：加法四位数*'
- en: Finally, we add the *most significant bit*, as shown in [Figure 5-5](ch05.xhtml#ch5fig5).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们加上*最高有效位*，如[图 5-5](ch05.xhtml#ch5fig5)所示。
- en: '![image](../images/fig5-5.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-5.jpg)'
- en: '*Figure 5-5: Adding the eights place*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：加法八位数*'
- en: Once we add all the places, the complete result in binary is 0101\. One way
    to sanity-check our work is to simply convert everything to decimal, as shown
    in [Figure 5-6](ch05.xhtml#ch5fig6).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加完所有位，完整的二进制结果是 0101。我们检查工作的一个方法是将所有内容转换为十进制，如[图 5-6](ch05.xhtml#ch5fig6)所示。
- en: '![image](../images/fig5-6.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-6.jpg)'
- en: '*Figure 5-6: Adding two binary numbers, then converting to decimal*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：加法二进制数，然后转换为十进制*'
- en: As you can see in [Figure 5-6](ch05.xhtml#ch5fig6), our answer in binary (0101)
    matches what we’d expect in decimal (5). Simple enough!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图 5-6](ch05.xhtml#ch5fig6)中看到的，我们的二进制答案（0101）与十进制（5）一致。很简单吧！
- en: '**EXERCISE 5-1: PRACTICE BINARY ADDITION**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5-1：二进制加法练习**'
- en: 'You can now practice what you’ve just learned. Try the following addition problems:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以练习你刚学到的内容。尝试以下加法问题：
- en: 0001 + 0010 = ______
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 0001 + 0010 = ______
- en: 0011 + 0001 = ______
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 0011 + 0001 = ______
- en: 0101 + 0011 = ______
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 0101 + 0011 = ______
- en: 0111 + 0011 = ______
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 0111 + 0011 = ______
- en: See [Appendix A](appa.xhtml) for answers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[附录 A](appa.xhtml)查找答案。
- en: 'Fortunately, addition works the same way no matter what base you’re working
    in. The only difference between bases is how many symbols are available to you.
    Binary makes addition particularly straightforward, since the addition of each
    place always results in exactly two output bits, each with only two possible values:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，不管你使用的是哪个进制，加法的方式都是一样的。不同的进制唯一的区别是可用的符号数量。二进制使得加法特别简单，因为每个位的加法总是会产生两个输出位，每个输出位只有两个可能的值：
- en: '**Output 1**   A *sum* bit (S) of 0 or 1, representing the least significant
    bit of the result of the addition operation'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出 1**   一个 *和* 位（S），值为 0 或 1，表示加法操作结果的最低有效位'
- en: '**Output 2**   A *carry-out* bit (C[out]) of 0 or 1'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出 2**   一个 *进位输出* 位（C[out]）为 0 或 1'
- en: '**Half Adders**'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**半加器**'
- en: Now let’s say we want to construct a digital circuit that adds a *single* place
    of two binary numbers. We initially focus on the least significant bit. Adding
    the least significant bits of two numbers only requires two binary inputs (let’s
    call them A and B), and the binary outputs are a sum bit (S) and a carry-out bit
    (C[out]). We call such a circuit a *half adder*. [Figure 5-7](ch05.xhtml#ch5fig7)
    shows the symbol for a half adder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们要构建一个数字电路，来加和两个二进制数的 *单个位*。我们最初关注的是最低有效位。对两个数的最低有效位进行加法只需要两个二进制输入（我们称之为
    A 和 B），而二进制输出是一个和位（S）和一个进位输出位（C[out]）。我们称这样的电路为 *半加器*。[图 5-7](ch05.xhtml#ch5fig7)显示了半加器的符号。
- en: '![image](../images/fig5-7.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-7.jpg)'
- en: '*Figure 5-7: Symbol for a half adder*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：半加器符号*'
- en: To clarify how the half adder fits in with our earlier example of adding two
    binary numbers, [Figure 5-8](ch05.xhtml#ch5fig8) relates the two concepts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清半加器如何与我们之前添加两个二进制数的示例相适应，[图 5-8](ch05.xhtml#ch5fig8)将这两个概念联系起来。
- en: '![image](../images/fig5-8.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-8.jpg)'
- en: '*Figure 5-8: Half adder in action*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：半加器工作示意图*'
- en: As you can see in [Figure 5-8](ch05.xhtml#ch5fig8), the least significant bit
    from the first number is input A and the least significant bit from the second
    number is input B. The sum is an output, S, and the carry-out is also an output.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 5-8](ch05.xhtml#ch5fig8)所示，第一个数字的最低有效位是输入 A，第二个数字的最低有效位是输入 B。和位是输出 S，进位输出也是输出。
- en: Internally, the half adder can be implemented as a combinational logic circuit,
    so we can also describe it with a truth table, as shown in [Table 5-1](ch05.xhtml#ch5tab1).
    Note that A and B are inputs, while S and C[out] are outputs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，半加器可以实现为一个组合逻辑电路，因此我们也可以用真值表来描述它，如[表 5-1](ch05.xhtml#ch5tab1)所示。请注意，A 和
    B 是输入，而 S 和 C[out] 是输出。
- en: '**Table 5-1:** Truth Table for a Half Adder'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1：半加器的真值表**'
- en: '| **Inputs** | **Outputs** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **输入** | **输出** |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **A** | **B** | **S** | **C[out]** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **S** | **C[out]** |'
- en: '| 0 | 0 | 0 | 0 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 |'
- en: '| 0 | 1 | 1 | 0 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 |'
- en: '| 1 | 0 | 1 | 0 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 |'
- en: '| 1 | 1 | 0 | 1 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 |'
- en: Let’s walk through the truth table in [Table 5-1](ch05.xhtml#ch5tab1). Adding
    0 and 0 results in 0 with no carry. Adding 0 and 1 (or the reverse) results in
    1 with no carry. Adding 1 and 1 gives us 0 with a carry of 1.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过[表 5-1](ch05.xhtml#ch5tab1)中的真值表进行讲解。将 0 和 0 相加的结果是 0，没有进位。将 0 和 1（或反之）相加的结果是
    1，没有进位。将 1 和 1 相加的结果是 0，进位为 1。
- en: Now, how do we go about implementing this with digital logic gates? The solution
    is straightforward if we examine one output at a time, as shown in [Figure 5-9](ch05.xhtml#ch5fig9).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何使用数字逻辑门来实现这一点呢？如果我们逐个检查输出，解决方案就很简单，如[图 5-9](ch05.xhtml#ch5fig9)所示。
- en: '![image](../images/fig5-9.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-9.jpg)'
- en: '*Figure 5-9: Truth table for a half adder; outputs match XOR, AND*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：半加器的真值表；输出与 XOR，AND 相匹配*'
- en: 'Looking at only output S in [Figure 5-9](ch05.xhtml#ch5fig9), we can see that
    it exactly matches the truth table for an XOR gate (see [Chapter 4](ch04.xhtml)).
    Looking at C[out] only, we can observe that it matches the output of an AND gate.
    Therefore, we can implement a half adder using only two gates: XOR and AND, as
    shown in [Figure 5-10](ch05.xhtml#ch5fig10).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 仅从[图5-9](ch05.xhtml#ch5fig9)中的输出S来看，我们可以看到它与异或门的真值表完全匹配（参见[第4章](ch04.xhtml)）。仅从C[out]来看，我们可以观察到它与与门的输出相匹配。因此，我们可以仅使用两个门：异或门和与门，来实现一个半加器，如[图5-10](ch05.xhtml#ch5fig10)所示。
- en: '![image](../images/fig5-10.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-10.jpg)'
- en: '*Figure 5-10: Half adder implemented with two logic gates, XOR and AND*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-10：用两个逻辑门（异或门和与门）实现的半加器*'
- en: As you can see in [Figure 5-10](ch05.xhtml#ch5fig10), digital inputs A and B
    act as the inputs for both the XOR gate and the AND gate. The gates then produce
    the desired outputs, S and C[out].
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图5-10](ch05.xhtml#ch5fig10)所示，数字输入A和B作为异或门和与门的输入。然后，这些门产生所需的输出S和C[out]。
- en: '**NOTE**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #5](ch05.xhtml#proj5) on [page 89](ch05.xhtml#page_89),
    where you can build a circuit for a half adder*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #5](ch05.xhtml#proj5)在[第89页](ch05.xhtml#page_89)，在那里你可以构建一个半加器的电路*。'
- en: '**Full Adders**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**全加器**'
- en: 'A half adder can handle the logic needed to perform addition for the least
    significant bits of two binary numbers. However, each subsequent bit requires
    an additional input: the carry-in bit, C[in]. This is because every bit place,
    except the least significant bit, needs to handle the situation where addition
    of the previous bit place resulted in a carry-out, which in turn becomes the carry-in
    for the current bit place. Adding a C[in] input to our adder component requires
    a new circuit design, and we call this circuit a *full adder*. The symbol for
    a full adder, shown in [Figure 5-11](ch05.xhtml#ch5fig11), is similar to the symbol
    for a half adder, differing only by an extra input, C[in].'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 半加器可以处理两位二进制数最低有效位的加法逻辑。然而，每一位之后的位需要一个额外的输入：进位输入C[in]。这是因为除了最低有效位之外的每个位，都需要处理上一位加法结果产生的进位，这个进位会成为当前位的进位输入。为加法器组件添加一个C[in]输入需要新的电路设计，我们将这个电路称为*全加器*。全加器的符号，如[图5-11](ch05.xhtml#ch5fig11)所示，类似于半加器的符号，唯一的区别是多了一个输入C[in]。
- en: '![image](../images/fig5-11.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-11.jpg)'
- en: '*Figure 5-11: Symbol for a full adder*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-11：全加器的符号*'
- en: In [Figure 5-12](ch05.xhtml#ch5fig12), we see an example of the relationship
    between binary addition of a single place and the full adder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图5-12](ch05.xhtml#ch5fig12)中，我们看到一个关于二进制加法和全加器之间关系的例子。
- en: '![image](../images/fig5-12.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-12.jpg)'
- en: '*Figure 5-12: Full adder in action*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-12：全加器的工作过程*'
- en: The full adder handles the addition of a single place, including the carry-in
    bit. In the example shown in [Figure 5-12](ch05.xhtml#ch5fig12), we add the bits
    in the 4s place. Since the bits in the previous place were 1 and 1, there’s a
    carry-in of 1\. The full adder takes all three inputs (A = 0, B = 0, and C[in]
    = 1) and produces an output of S = 1 and C[out] = 0.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 全加器处理一个位的加法，包括进位输入位。在[图5-12](ch05.xhtml#ch5fig12)所示的例子中，我们加的是4位的数字。由于前一位的两个数字是1和1，因此有一个进位输入1。全加器接受所有三个输入（A
    = 0, B = 0, C[in] = 1），并输出S = 1和C[out] = 0。
- en: For a complete picture of the possible inputs and outputs of a full adder, we
    can use a truth table, shown in [Table 5-2](ch05.xhtml#ch5tab2). This table has
    three inputs (A, B, C[in]) and two outputs (S, C[out]). Take a moment to consider
    the outputs from the various input combinations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整展示全加器的可能输入和输出，我们可以使用真值表，如[表5-2](ch05.xhtml#ch5tab2)所示。这个表有三个输入（A、B、C[in]）和两个输出（S、C[out]）。请花一点时间考虑各种输入组合下的输出。
- en: '**Table 5-2:** Full Adder Truth Table'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-2：** 全加器真值表'
- en: '| **Inputs** | **Outputs** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **输入** | **输出** |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **A** | **B** | **C[in]** | **S** | **C[out]** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **C[in]** | **S** | **C[out]** |'
- en: '| 0 | 0 | 0 | 0 | 0 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 1 | 0 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | 0 |'
- en: '| 0 | 1 | 0 | 1 | 0 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 0 |'
- en: '| 0 | 1 | 1 | 0 | 1 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | 1 |'
- en: '| 1 | 0 | 0 | 1 | 0 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | 0 |'
- en: '| 1 | 0 | 1 | 0 | 1 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 | 0 | 1 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 1 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 |'
- en: How do we go about implementing a full adder? As the name implies, a full adder
    can be realized by combining two half adders ([Figure 5-13](ch05.xhtml#ch5fig13)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现全加器呢？顾名思义，全加器可以通过将两个半加器结合来实现（见[图5-13](ch05.xhtml#ch5fig13)）。
- en: '![image](../images/fig5-13.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-13.jpg)'
- en: '*Figure 5-13: A full adder circuit realized with two half adders and an OR
    gate*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-13：由两个半加法器和一个 OR 门实现的全加法器电路*'
- en: A full adder’s sum output (S) should be the sum of A and B (which we can calculate
    using one half adder—HA1) plus C[in] (which we can calculate with a second half
    adder—HA2), as shown in [Figure 5-13](ch05.xhtml#ch5fig13).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全加法器的和输出（S）应该是 A 和 B 的和（我们可以使用一个半加法器 HA1 来计算）加上 C[in]（我们可以使用第二个半加法器 HA2 来计算），如
    [图 5-13](ch05.xhtml#ch5fig13) 所示。
- en: We also need our full adder to output a carry-out bit. This turns out to be
    simple to implement, because the full adder’s C[out] value is 1 if the carry-out
    from either half adder is 1\. We can therefore use an OR gate to complete the
    full adder circuit, as shown in [Figure 5-13](ch05.xhtml#ch5fig13).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要全加法器输出一个进位位。这个实现起来很简单，因为如果任意半加法器的进位为 1，那么全加法器的 C[out] 值就为 1。因此，我们可以使用一个
    OR 门来完成全加法器电路，如 [图 5-13](ch05.xhtml#ch5fig13) 所示。
- en: Here we see another example of encapsulation. Once this circuit is constructed,
    the functionality of a full adder can be used without knowledge of the specific
    implementation details. In the next section, let’s see how we can use full and
    half adders together to add a number with multiple bits.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到另一个封装的例子。一旦这个电路构建完成，使用全加法器的功能时，就无需了解具体的实现细节。在下一部分，让我们看看如何将全加法器和半加法器结合起来，以便对多个位的数字进行加法运算。
- en: '**A 4-bit Adder**'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一个 4 位加法器**'
- en: A full adder allows us to add two 1-bit numbers, plus a carry-in bit. This gives
    us a building block for creating a circuit that can add binary numbers with more
    than one place. Let’s now combine several 1-bit adder circuits to create a 4-bit
    adder. Let’s use a half adder for the least significant bit (since it doesn’t
    require a carry-in) and full adders for the other bits. The idea is to string
    the adders together so the carry-out from each adder flows into the carry-in of
    the subsequent adder, as shown in [Figure 5-14](ch05.xhtml#ch5fig14).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全加法器允许我们加两个 1 位数字，再加上一个进位输入位。这样我们就可以构建一个电路模块，用于加多个数字位的二进制数。现在，让我们将多个 1 位加法器电路组合在一起，构建一个
    4 位加法器。对于最低有效位，使用半加法器（因为它不需要进位输入），对于其他位使用全加法器。我们的思路是将加法器连接在一起，使每个加法器的进位输出流入下一个加法器的进位输入，正如
    [图 5-14](ch05.xhtml#ch5fig14) 所示。
- en: '![image](../images/fig5-14.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-14.jpg)'
- en: '*Figure 5-14: A 4-bit adder*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-14：一个 4 位加法器*'
- en: For consistency with the way people write numbers, I’ve arranged [Figure 5-14](ch05.xhtml#ch5fig14)
    with the least significant bit on the right, and the diagram’s flow progressing
    from right to left. This means that our adder block diagrams will have inputs
    and outputs positioned differently than previously shown; don’t let that confuse
    you!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与人们书写数字的方式保持一致，我将 [图 5-14](ch05.xhtml#ch5fig14) 安排成最低有效位位于右侧，并且图表的流向是从右到左。这意味着我们的加法器框图将具有与之前显示的不同的输入和输出位置；不要因此而感到困惑！
- en: In [Figure 5-15](ch05.xhtml#ch5fig15), I applied our earlier example of two
    (0010) plus three (0011) to this 4-bit adder.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 5-15](ch05.xhtml#ch5fig15) 中，我将之前提到的两个（0010）加三个（0011）应用到这个 4 位加法器中。
- en: '![image](../images/fig5-15.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-15.jpg)'
- en: '*Figure 5-15: A 4-bit adder in action*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-15：4 位加法器的工作过程*'
- en: In [Figure 5-15](ch05.xhtml#ch5fig15), we can see how each bit from input A
    (0010) and input B (0011) is fed into each subsequent adder unit, starting with
    the least significant bit on the right, moving to the most significant bit on
    the left. You can follow the flow of the diagram by reading from right to left.
    Add the rightmost bits first, 0 (A0) and 1 (B0); the result is 1 (S0) with a carry
    of 0.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 5-15](ch05.xhtml#ch5fig15) 中，我们可以看到输入 A（0010）和输入 B（0011）中的每一位是如何依次传递到每个加法单元的，从右边的最低有效位开始，向左移动到最高有效位。你可以通过从右到左阅读图表，跟踪信号流动。首先加上最右侧的位，0（A0）和
    1（B0）；结果是 1（S0）和进位 0。
- en: The output carry bit from the rightmost adder flows into the next adder as C1,
    where 1 (A1) and 1 (B1) are added, along with the carry of 0\. This results in
    0 (S1) with a carry of 1 (C2). The process continues until the leftmost adder
    completes. The final result is a set of the output bits, 0101 (S3 to S0), and
    a carry of 0 (C4). If we need to handle a larger number of bits, we can extend
    the design in [Figure 5-15](ch05.xhtml#ch5fig15) by simply incorporating more
    full adders.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最右侧加法器的输出进位位作为 C1 传递到下一个加法器，在这里，1（A1）和 1（B1）被相加，同时进位为 0。结果是 0（S1），并产生进位 1（C2）。该过程会继续，直到最左侧的加法器完成。最终结果是一组输出位，0101（S3
    到 S0），以及进位 0（C4）。如果我们需要处理更多位的数字，可以通过简单地增加更多的全加法器来扩展 [图 5-15](ch05.xhtml#ch5fig15)
    中的设计。
- en: This type of adder requires the carry bits to propagate, or ripple, through
    the circuit. For this reason, we call this circuit a *ripple carry adder*. Each
    carry bit that ripples to the next full adder introduces a small delay, so extending
    the design to handle more bits makes the circuit slower. The output of the circuit
    will be inaccurate until all the carry bits have time to propagate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的加法器需要进位比特通过电路传播，或称为“波纹”传播。因此，我们称这种电路为*波纹进位加法器*。每个传播到下一个全加器的进位比特都会引入小的延迟，因此，将设计扩展到处理更多的比特会使电路变慢。直到所有进位比特有时间传播完毕，电路的输出才会准确。
- en: Several versions of 4-bit adders are available in the 7400 series of ICs. If
    you need a 4-bit adder in a project, you can use such an IC rather than construct
    the adder from individual logic gates.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 7400系列集成电路中有几种版本的4位加法器。如果你的项目需要一个4位加法器，你可以使用这样的集成电路，而不必通过单独的逻辑门来构建加法器。
- en: Let’s pause here and consider the broader implications of what we’ve just covered.
    Yes, you learned how to build a 4-bit adder, but how does this relate to computing?
    Recall that computers are electronic devices that can be programmed to carry out
    a set of logical instructions. Those instructions include mathematical operations,
    and we just saw how logic gates, built from transistors, can be combined to perform
    one of those operations—addition. We covered addition as a concrete example of
    a computer operation, and although we don’t go into the details in this book,
    you can also implement other fundamental computer operations with logic gates.
    This is how computers work—simple logic gates work together to perform complex
    tasks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里暂停一下，思考我们刚才讨论的内容对更广泛的计算机应用有什么影响。是的，你学会了如何构建一个4位加法器，但这与计算机有什么关系呢？回想一下，计算机是可以编程的电子设备，能够执行一系列逻辑指令。这些指令包括数学运算，我们刚才看到，由晶体管构建的逻辑门可以组合在一起，执行其中的一个操作——加法。我们以加法为具体例子来说明计算机操作，虽然本书中我们不详细介绍，但你也可以使用逻辑门实现其他基本的计算机操作。这就是计算机的工作原理——简单的逻辑门通过协作来完成复杂的任务。
- en: '**Signed Numbers**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**带符号数**'
- en: Thus far in this chapter we’ve only concerned ourselves with positive integers,
    but what if we want to be able to handle negative integers as well? First, we
    need to consider how a negative number can be represented in a digital system
    like a computer. As you know, all data in a computer is represented as sequences
    of 0s and 1s. A negative sign is neither a 0 nor a 1, so we need to adopt a convention
    for representing negative values in a digital system. In computing, a *signed
    number* is a sequence of bits that can be used to represent a negative or positive
    number, depending on the specific values of those bits.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中我们只关注了正整数，但如果我们还想处理负整数该怎么办呢？首先，我们需要考虑如何在像计算机这样的数字系统中表示负数。正如你所知道的，计算机中的所有数据都是由一串0和1来表示的。负号既不是0也不是1，因此我们需要采用一种约定来表示数字系统中的负值。在计算中，*带符号数*是一串比特，可以用来表示负数或正数，具体取决于这些比特的值。
- en: A digital system’s design must define how many bits are used to represent an
    integer. Typically, we represent integers using 8, 16, 32, or 64 bits. One of
    those bits can be assigned to represent a negative sign. We can, for example,
    say that if the most significant bit is 0, then the number is positive, and if
    the most significant bit is 1, then the number is negative. The remaining bits
    are then used to represent the absolute value of the number. This approach is
    known as *signed magnitude representation*. This works, but it requires extra
    complexity in a system’s design to account for the bit that has a special meaning.
    For example, the adder circuits we built earlier would need to be modified to
    account for the sign bit.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字系统的设计必须定义用于表示整数的比特数。通常，我们使用8、16、32或64个比特来表示整数。可以为其中一个比特分配来表示负号。例如，我们可以规定，如果最高有效位是0，则该数为正数；如果最高有效位是1，则该数为负数。剩余的比特用于表示数值的绝对值。这种方法被称为*带符号的大小表示法*。这种方法是可行的，但它要求系统设计增加额外的复杂性，以考虑那个具有特殊意义的符号位。例如，我们之前构建的加法器电路需要进行修改，以考虑符号位。
- en: A better way to represent negative numbers in a computer is known as *two’s
    complement*. In this context, the two’s complement of a number represents the
    negative of that number. The simplest way to find the two’s complement of a number
    is to replace every 1 with a 0 and every 0 with a 1 (in other words, flip the
    bits), and then add 1\. Hang tight with me here; this is going to seem overly
    complicated at first, but if you follow the details, it will make sense.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的计算机中表示负数的方法被称为*二进制补码*。在这个上下文中，一个数字的二进制补码表示该数字的负数。找到一个数字的二进制补码的最简单方法是将每个1替换为0，每个0替换为1（换句话说，翻转位），然后加上1。稍微耐心一下，起初这看起来可能过于复杂，但如果你按照细节操作，它就会变得清晰。
- en: Let’s take a 4-bit example, the number 5, or 0101 in binary. [Figure 5-16](ch05.xhtml#ch5fig16)
    shows the process of finding the two’s complement of this number.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个4位的例子，数字5，或者在二进制中表示为0101。[图5-16](ch05.xhtml#ch5fig16)展示了找到这个数字的二进制补码的过程。
- en: '![image](../images/fig5-16.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-16.jpg)'
- en: '*Figure 5-16: Finding the two’s complement of 0101*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-16：找到0101的二进制补码*'
- en: First, we flip the bits, then we add one, giving us 1011 binary. So, in this
    system, 5 is represented as 0101 and –5 is represented as 1011\. Keep in mind
    that 1011 only represents –5 in the context of a 4-bit signed number. That binary
    sequence could be interpreted in other ways in a different context, as we will
    see later. What if we want to go the other way, starting with the negative value?
    The process is the same, as shown in [Figure 5-17](ch05.xhtml#ch5fig17).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们翻转位，然后加上1，得到1011二进制。因此，在这个系统中，5表示为0101，而-5表示为1011。请记住，1011仅在4位带符号数字的上下文中表示-5。这个二进制序列在不同的上下文中可能有不同的解释，正如我们稍后将看到的那样。如果我们想从负值开始，反向操作怎么办？过程是相同的，如[图5-17](ch05.xhtml#ch5fig17)所示。
- en: '![image](../images/fig5-17.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-17.jpg)'
- en: '*Figure 5-17: Finding the two’s complement of 1011*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-17：找到1011的二进制补码*'
- en: As you can see in [Figure 5-17](ch05.xhtml#ch5fig17), taking the two’s complement
    of –5 gets us back to the original value of 5\. This makes sense, given that the
    negative of –5 is 5.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图5-17](ch05.xhtml#ch5fig17)中看到的，取-5的二进制补码会让我们回到原来的5。这是有道理的，因为-5的负数是5。
- en: '**EXERCISE 5-2: FIND THE TWO’S COMPLEMENT**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习5-2：寻找二进制补码**'
- en: Find the 4-bit two’s complement of 6\. See [Appendix A](appa.xhtml) for the
    answer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 找到6的4位二进制补码。答案请参见[附录A](appa.xhtml)。
- en: Now we know how to represent a number as a positive value or a negative value
    using two’s complement, but how is this useful? I think the easiest way to see
    the benefits of this system is to just try it. Let’s say we want to add 7 and
    –3 (that is, subtract 3 from 7). We expect the result to be positive 4\. Let’s
    first determine what our inputs are in binary, shown in [Figure 5-18](ch05.xhtml#ch5fig18).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用二进制补码将数字表示为正数或负数，但这怎么有用呢？我认为看清这个系统的好处最简单的方式就是亲自试试。假设我们要加7和-3（即从7中减去3）。我们期望结果是正数4。首先让我们确定二进制形式的输入，如[图5-18](ch05.xhtml#ch5fig18)所示。
- en: '![image](../images/fig5-18.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-18.jpg)'
- en: '*Figure 5-18: Find the 4-bit two’s complement form of 7 and –3.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-18：找到7和-3的4位二进制补码形式。*'
- en: Our two binary inputs will be 0111 and 1101\. Now, forget for a moment that
    we’re dealing with positive and negative values. Just add the two binary numbers.
    Don’t worry about what the bits represent, just add them, and prepare to be amazed!
    Look at [Figure 5-19](ch05.xhtml#ch5fig19) once you’ve done the binary math.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个二进制输入将是0111和1101。现在，暂时忘记我们正在处理的是正值和负值。只需将两个二进制数相加。不用担心这些位代表什么，直接加，准备好惊讶吧！做完二进制计算后，请查看[图5-19](ch05.xhtml#ch5fig19)。
- en: '![image](../images/fig5-19.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-19.jpg)'
- en: '*Figure 5-19: Addition of two binary numbers, interpreted as signed decimal*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-19：两二进制数相加，作为带符号的十进制数解释*'
- en: As you can see in [Figure 5-19](ch05.xhtml#ch5fig19), this addition results
    in a carry-out bit beyond what a 4-bit number can represent. I’ll explain this
    in more detail later, but for now, we can ignore that carry-out bit. This gives
    us a 4-bit result of 0100, which is positive 4, our expected number! That’s the
    beauty of two’s complement notation. We don’t have to do anything special during
    the addition or subtraction operation; it just works.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图5-19](ch05.xhtml#ch5fig19)中看到的，这个加法操作导致了超出4位数字能表示范围的进位位。我稍后会更详细地解释这个问题，但目前我们可以忽略那个进位位。这样我们得到的4位结果是0100，表示正数4，正是我们预期的数字！这就是二进制补码表示法的魅力所在。在加法或减法操作中，我们无需做任何特殊处理，它自然就能奏效。
- en: Let’s pause here and reflect on the implications of this. Remember those adder
    circuits we built earlier? They will work for negative values too! Any circuit
    designed to handle binary addition can use the two’s complement as a means of
    handling negative numbers or subtraction. The detailed mathematical explanation
    for why all of this works is outside the scope of this book; if you are curious,
    there are good explanations available online.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，反思一下这意味着什么。还记得我们之前构建的加法电路吗？它们同样适用于负值！任何设计用来处理二进制加法的电路都可以使用二进制补码来处理负数或减法。详细的数学解释超出了本书的范围；如果你有兴趣，可以在网上找到很多好的解释。
- en: '**TWO’S COMPLEMENT TERMINOLOGY**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制补码术语**'
- en: The term *two’s complement* actually refers to two related concepts. Two’s complement
    is a form of *notation* for representing positive and negative integers. For example,
    the number 5, represented in 4-bit two’s complement notation is 0101, whereas
    –5 is represented as 1011\. At the same time, two’s complement is also an *operation*
    used to negate an integer stored in two’s complement format. For example, taking
    the two’s complement of 0101 gives us 1011.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: “二进制补码”这个术语实际上指的是两个相关的概念。二进制补码是一种*表示法*，用于表示正整数和负整数。例如，数字5，在4位二进制补码表示法中为0101，而-5表示为1011。同时，二进制补码也是一种*运算*，用于取反存储在二进制补码格式中的整数。例如，取0101的二进制补码得到1011。
- en: 'Here’s another way to look at two’s complement notation: the most significant
    place has a weight equal to the negative value of that place, and all other places
    have weights equal to the positive values of those places. So, for a 4-bit number,
    the places have the weights shown in [Figure 5-20](ch05.xhtml#ch5fig20).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待二进制补码表示法的方式是：最高有效位的权重等于该位的负值，而其他所有位的权重等于该位的正值。因此，对于一个4位数字，位的权重如[图5-20](ch05.xhtml#ch5fig20)所示。
- en: '![image](../images/fig5-20.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-20.jpg)'
- en: '*Figure 5-20: Place-value weights of a signed 4-bit number using two’s complement
    notation*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-20：使用二进制补码表示法的有符号4位数字的位值权重*'
- en: If we then apply this approach to the two’s complement representation of –3
    (1101), we can calculate the decimal value as shown in [Figure 5-21](ch05.xhtml#ch5fig21).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这种方法应用于-3的二进制补码表示（1101），则可以按照[图5-21](ch05.xhtml#ch5fig21)所示计算十进制值。
- en: '![image](../images/fig5-21.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-21.jpg)'
- en: '*Figure 5-21: Find the signed decimal value of 1101 using two’s complement
    place value.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-21：使用二进制补码位权查找1101的有符号十进制值。*'
- en: When dealing with two’s complement, I find that looking at the most significant
    place’s weight as equal to the negative value of that place is a convenient mental
    shortcut. Now that we have covered the weights of all the places in a 4-bit signed
    number, we can examine the full range of values that can be represented with such
    a number, as shown in [Table 5-3](ch05.xhtml#ch5tab3).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理二进制补码时，我发现将最重要的位权看作该位的负值是一个方便的思维捷径。现在我们已经涵盖了4位有符号数的所有位的权重，我们可以检查这种数字所能表示的全部值范围，如[表5-3](ch05.xhtml#ch5tab3)所示。
- en: '**Table 5-3:** All Possible Values of a 4-bit Signed Number'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-3：** 4位有符号数的所有可能值'
- en: '| **Binary** | **Signed decimal** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **有符号十进制** |'
- en: '| --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0000 | 0 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 |'
- en: '| 0001 | 1 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 |'
- en: '| 0010 | 2 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 |'
- en: '| 0011 | 3 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 |'
- en: '| 0100 | 4 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 |'
- en: '| 0101 | 5 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 |'
- en: '| 0110 | 6 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 |'
- en: '| 0111 | 7 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 |'
- en: '| 1000 | –8 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | –8 |'
- en: '| 1001 | –7 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | –7 |'
- en: '| 1010 | –6 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | –6 |'
- en: '| 1011 | –5 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | –5 |'
- en: '| 1100 | –4 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 1100 | –4 |'
- en: '| 1101 | –3 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | –3 |'
- en: '| 1110 | –2 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | –2 |'
- en: '| 1111 | –1 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | –1 |'
- en: 'Given [Table 5-3](ch05.xhtml#ch5tab3), we can observe that for a signed 4-bit
    number, our maximum value is 7 and our most negative value is –8, for a total
    of 16 possible values. Note that anytime the most significant bit is 1, the value
    will be negative. We can generalize as follows for an *n*-bit signed number:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[表5-3](ch05.xhtml#ch5tab3)，我们可以观察到，对于一个4位有符号数，最大值是7，最小负值是-8，总共有16个可能的值。请注意，每当最高有效位为1时，值就会是负数。我们可以将其概括为：对于一个*n*位有符号数：
- en: 'Maximum value: (2^(*n*–1)) – 1'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最大值: (2^(*n*–1)) – 1'
- en: 'Minimum value: –(2^(*n*–1))'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最小值: –(2^(*n*–1))'
- en: 'Count of unique values: 2^(*n*)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '唯一值的个数: 2^(*n*)'
- en: So, for an 8-bit signed number (as an example), we find that
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，对于一个8位有符号数（举例来说），我们可以发现
- en: Maximum value = 127
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大值 = 127
- en: Minimum value = –128
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小值 = –128
- en: Count of unique values = 256
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一值的个数 = 256
- en: '**Unsigned Numbers**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**无符号数**'
- en: Signed integers that use two’s complement to represent negative values are a
    convenient way to handle negatives without requiring specialized adder hardware.
    The adder we covered earlier works just as well with negative values as it does
    with positive values. However, there are scenarios in computing in which negative
    values simply aren’t needed, and treating our numbers as signed simply wastes
    about half the range of values (all the negative values go unused), while also
    capping the maximum possible value to about half of what could otherwise be represented.
    Because of this, in such scenarios we want to treat numbers as *unsigned*, meaning
    the sequence of bits always represents a positive value or zero, but never a negative
    value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二进制补码表示负值的带符号整数，是处理负数的一种便捷方式，无需专用的加法器硬件。我们之前讲解的加法器同样适用于负值，就像它适用于正值一样。然而，在计算中，某些情况下负值根本不需要，若我们将数字视为带符号的，那么大约有一半的值区间将被浪费（所有负值都不使用），同时最大值也会被限制为本应能表示的值的一半。因此，在这种情况下，我们希望将数字视为*无符号*，即比特序列始终表示一个正值或零，但绝不表示负值。
- en: Looking again at a 4-bit number, [Table 5-4](ch05.xhtml#ch5tab4) shows what
    each 4-bit binary value represents if we interpret it as signed or unsigned.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看一个 4 位数字，[表 5-4](ch05.xhtml#ch5tab4)展示了如果我们将其解释为带符号或无符号时，每个 4 位二进制值所代表的内容。
- en: '**Table 5-4:** All Possible Values of a 4-bit Number, Signed or Unsigned'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-4：** 一个 4 位数字的所有可能值，带符号或无符号'
- en: '| **Binary** | **Signed decimal** | **Unsigned decimal** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **带符号十进制** | **无符号十进制** |'
- en: '| --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0000 | 0 | 0 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 | 0 |'
- en: '| 0001 | 1 | 1 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 | 1 |'
- en: '| 0010 | 2 | 2 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 | 2 |'
- en: '| 0011 | 3 | 3 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 | 3 |'
- en: '| 0100 | 4 | 4 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 | 4 |'
- en: '| 0101 | 5 | 5 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 | 5 |'
- en: '| 0110 | 6 | 6 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 | 6 |'
- en: '| 0111 | 7 | 7 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 | 7 |'
- en: '| 1000 | –8 | 8 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | –8 | 8 |'
- en: '| 1001 | –7 | 9 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | –7 | 9 |'
- en: '| 1010 | –6 | 10 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | –6 | 10 |'
- en: '| 1011 | –5 | 11 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | –5 | 11 |'
- en: '| 1100 | –4 | 12 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 1100 | –4 | 12 |'
- en: '| 1101 | –3 | 13 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | –3 | 13 |'
- en: '| 1110 | –2 | 14 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | –2 | 14 |'
- en: '| 1111 | –1 | 15 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | –1 | 15 |'
- en: 'We can generalize as follows for an *n*-bit unsigned number:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 *n* 位无符号数做出以下概括：
- en: 'Maximum value: (2^(*n*)) – 1'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大值： (2^(*n*)) – 1
- en: 'Minimum value: 0'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小值：0
- en: 'Count of unique values: 2^(*n*)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一值的个数：2^(*n*)
- en: 'So, let’s take an example 4-bit value, say 1011\. Looking at [Table 5-4](ch05.xhtml#ch5tab4),
    what does it represent? Does it represent –5 or does it represent 11? The answer
    is “it depends!” It can represent either –5 or 11, depending on the context. From
    an adder circuit’s point of view, it doesn’t matter. As far as the adder is concerned,
    the 4-bit value is just 1011\. Any addition operation is performed the same way
    regardless; the only difference is how we interpret the result. Let’s look at
    an example. In [Figure 5-22](ch05.xhtml#ch5fig22), we add two binary numbers:
    1011 and 0010.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们来看一个例子，4 位值 1011。查看[表 5-4](ch05.xhtml#ch5tab4)，它代表什么？是代表 –5 还是 11？答案是“取决于情况！”它可以代表
    –5 或 11，取决于上下文。从加法器电路的角度来看，这无关紧要。对加法器而言，4 位值就是 1011。无论执行什么加法运算，过程是一样的，唯一的区别是我们如何解释结果。我们来看一个例子。在[图
    5-22](ch05.xhtml#ch5fig22)中，我们将两个二进制数 1011 和 0010 相加。
- en: '![image](../images/fig5-22.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-22.jpg)'
- en: '*Figure 5-22: Adding two binary numbers, interpreted as signed or unsigned*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-22：加法运算的两个二进制数，解释为带符号或无符号*'
- en: As you can see in [Figure 5-22](ch05.xhtml#ch5fig22), adding those two binary
    numbers results in 1101, regardless of whether we’re working with signed or unsigned
    numbers. After the calculation is complete, we get to decide how to interpret
    that result. Either we just added –5 and 2 and the result was –3, or we added
    11 and 2 and the result was 13\. In either case the math works out; it’s just
    a matter of interpretation! In the context of computing, it is the program running
    on a computer that is responsible for correctly interpreting the result of an
    addition operation as signed or unsigned.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 5-22](ch05.xhtml#ch5fig22)所示，添加这两个二进制数的结果是 1101，无论我们是在处理带符号数还是无符号数。计算完成后，我们可以决定如何解释这个结果。我们要么认为是将
    –5 和 2 相加，结果为 –3，要么认为是将 11 和 2 相加，结果为 13。在这两种情况下，数学运算都没有问题，问题只是出在如何解释结果！在计算机科学中，正确解释加法运算结果是带符号还是无符号的责任归程序。
- en: '**EXERCISE 5-3: ADD TWO BINARY NUMBERS AND INTERPRET AS SIGNED AND UNSIGNED**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 5-3：加两个二进制数并解释为带符号和无符号**'
- en: Add 1000 and 0110\. Interpret your work as signed numbers. Then interpret it
    as unsigned. Do the results make sense? See [Appendix A](appa.xhtml) for the answer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将1000与0110相加。将你的结果解释为有符号数。然后将其解释为无符号数。结果是否有意义？请参阅[附录 A](appa.xhtml)以获得答案。
- en: So far, we’ve mostly ignored the most significant carry-out bit, but it has
    a meaning that should be understood. For unsigned numbers, a carry-out of 1 means
    that an *integer overflow* has occurred. In other words, the result is too large
    to be represented by the number of bits assigned to represent an integer. For
    signed numbers, if the most significant carry-in bit is not equal to the most
    significant carry-out bit, then an overflow has occurred. Also for signed numbers,
    if the most significant carry-in is equal to the most significant carry-out, then
    no overflow has occurred, and the carry-out bit can be ignored.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们大多数情况下忽略了最重要的进位输出位，但它有一个需要理解的意义。对于无符号数，进位输出为1意味着发生了*整数溢出*。换句话说，结果太大，无法用分配给整数的位数表示。对于有符号数，如果最重要的进位输入位不等于最重要的进位输出位，则发生了溢出。对于有符号数，如果最重要的进位输入位等于最重要的进位输出位，则没有发生溢出，进位输出位可以被忽略。
- en: Integer overflows are a source of errors in computer programs. If a program
    does not check if an overflow has occurred, then the result of an addition operation
    may be incorrectly interpreted, leading to unexpected behavior. A famous example
    of an integer overflow error is found in the arcade game Pac-Man. When the player
    reaches level 256, the right side of the screen is filled with garbled graphics.
    This happens because the level number is stored as an 8-bit unsigned integer,
    and adding 1 to its maximum value of 255 results in an overflow. The game’s logic
    doesn’t account for this condition, leading to the glitch.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 整数溢出是计算机程序中的一种错误来源。如果程序没有检查是否发生了溢出，那么加法运算的结果可能会被错误地解释，导致意外的行为。一个著名的整数溢出错误出现在街机游戏《吃豆人》中。当玩家到达256级时，屏幕的右侧会充满乱码图形。发生这种情况是因为级别数被存储为8位无符号整数，当它的最大值255加1时发生了溢出。游戏的逻辑没有考虑到这种情况，从而导致了这个故障。
- en: '**Summary**'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we used addition as an example of how computers build upon
    logic gates to perform complex tasks. You learned how to perform addition in binary
    and how to construct hardware that can add binary numbers from logic gates. You
    saw how a half adder can add 2 bits and produce a sum and a carry-out bit, whereas
    a full adder can add 2 bits plus a carry-in bit. We covered how single-bit adders
    can be combined to perform multi-bit addition. You also learned how integers are
    represented in a computer using signed and unsigned numbers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用加法作为计算机如何基于逻辑门进行复杂任务的示例。你学习了如何在二进制中进行加法，以及如何从逻辑门构建能够进行二进制加法的硬件。你看到了半加器如何对2位进行加法并生成和与进位输出位，而全加器可以对2位加上进位输入位进行加法。我们讨论了如何将单比特加法器组合起来进行多比特加法。你还学习了计算机中整数是如何使用有符号和无符号数字表示的。
- en: In the next chapter, we’ll move beyond combinational logic circuits and learn
    about sequential logic. With sequential logic, hardware can have memory, allowing
    for the storage and retrieval of data. You’ll see how memory circuits can be built.
    We’ll also cover clock signals, a method of synchronizing the state of multiple
    components in a computer system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将超越组合逻辑电路，学习顺序逻辑。使用顺序逻辑，硬件可以具有存储功能，允许存储和检索数据。你将看到如何构建存储电路。我们还将介绍时钟信号，这是一种同步计算机系统中多个组件状态的方法。
- en: '**PROJECT #5: BUILD A HALF ADDER**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #5：构建一个半加器**'
- en: 'In this project, you’ll construct a half adder using an XOR gate and an AND
    gate. The inputs will be controlled with switches or pushbuttons. The outputs
    should be connected to LEDs to easily observe their states. For this project,
    you’ll need the following components:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用异或门和与门构建一个半加器。输入将通过开关或按钮控制。输出应连接到LED，以便轻松观察其状态。这个项目需要以下组件：
- en: Breadboard
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板
- en: Two LEDs
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个LED
- en: Two current-limiting resistors to use with your LEDs (approximately 220Ω)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个限流电阻，用于LED（大约220Ω）
- en: Jumper wires
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 7408 IC (contains four AND gates)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7408集成电路（包含四个与门）
- en: 7486 IC (contains four XOR gates)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7486集成电路（包含四个异或门）
- en: Two pushbuttons or switches that will fit a breadboard
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个适合面包板的按钮或开关
- en: Two 470Ω resistors
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个470Ω电阻
- en: 5-volt power supply
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5伏电源
- en: As a reminder, see the sections “Buying Electronic Components” on [page 333](appb.xhtml#page_333)
    and “Powering Digital Circuits” on [page 336](appb.xhtml#page_336) if you need
    help on those topics. For a reminder of how the pins are numbered on the 7408
    IC, see [Figure 4-14](ch04.xhtml#ch4fig14). The 7486 IC wasn’t covered previously,
    so I’m including its pinout diagram here in [Figure 5-23](ch05.xhtml#ch5fig23).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，如果你需要有关这些主题的帮助，请参见“购买电子元件”一节，[第333页](appb.xhtml#page_333)和“为数字电路供电”一节，[第336页](appb.xhtml#page_336)。有关7408
    IC引脚编号的回顾，请参见[图 4-14](ch04.xhtml#ch4fig14)。7486 IC之前没有涉及，因此在此我将它的引脚图包含在[图 5-23](ch05.xhtml#ch5fig23)中。
- en: '![image](../images/fig5-23.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-23.jpg)'
- en: '*Figure 5-23: Pinout diagram for the 7486 XOR integrated circuit*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-23：7486 XOR 集成电路的引脚图*'
- en: '[Figure 5-24](ch05.xhtml#ch5fig24) provides the wiring diagram for a half adder.
    Keep reading past the figure for more details on how to build this circuit.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-24](ch05.xhtml#ch5fig24)提供了半加器的接线图。继续阅读图示后面的内容，了解如何构建这个电路的更多细节。'
- en: '![image](../images/fig5-24.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-24.jpg)'
- en: '*Figure 5-24: Half adder built from XOR and AND gates*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-24：由XOR和AND门构建的半加器*'
- en: '[Figure 5-24](ch05.xhtml#ch5fig24) shows the connections for switches, with
    pull-down resistors, and for LEDs, with current-limiting resistors. Also note
    the pin numbers on the 7486 and 7408 ICs, shown in boxes. Note the black dots
    found on the wires connecting A and B to the resistors and ICs. The dots represent
    a connection point—for example, switch A, the 470Ω resistor, pin 1 on the 7486
    IC, and pin 4 on the 7408 IC are all connected. Don’t forget to connect the 7486
    and 7408 ICs to 5V and ground via pins 14 and 7 (not shown in [Figure 5-24](ch05.xhtml#ch5fig24)),
    respectively.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-24](ch05.xhtml#ch5fig24)展示了开关的连接，带有下拉电阻，以及LED的连接，带有限流电阻。还请注意7486和7408
    IC上的引脚编号，显示在方框内。注意连接A和B到电阻和IC的电线上的黑点。黑点表示连接点——例如，开关A、470Ω电阻、7486 IC的引脚1和7408 IC的引脚4都连接在一起。不要忘记将7486和7408
    IC分别通过引脚14和7连接到5V和地（这在[图 5-24](ch05.xhtml#ch5fig24)中没有显示）。'
- en: '[Figure 5-25](ch05.xhtml#ch5fig25) shows how this circuit could look when implemented
    on a breadboard.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-25](ch05.xhtml#ch5fig25)展示了当这个电路在面包板上实现时的样子。'
- en: '![image](../images/fig5-25.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig5-25.jpg)'
- en: '*Figure 5-25: Half adder built from XOR and AND gates*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-25：由XOR和AND门构建的半加器*'
- en: Once you’ve constructed this circuit, try all combinations of inputs A and B
    to confirm that the outputs match the expected values as shown in the half adder
    truth table ([Table 5-1](ch05.xhtml#ch5tab1)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这个电路的构建，尝试所有A和B的输入组合，以确认输出符合预期值，如半加器真值表中所示（[表 5-1](ch05.xhtml#ch5tab1)）。
