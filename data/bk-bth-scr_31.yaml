- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 28 COMPACT CONDITIONAL EXECUTION
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 28 紧凑型条件执行
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: In this chapter, I’ll discuss conditional execution ... and no, this isn’t a
    chapter about the if command. It’s true that the if command is the quintessential
    example of executing code conditionally, and this chapter will revisit that discussion
    from [Chapter 4](chapter4.xhtml), but with a very different take. Batch has a
    funky construct simply called *conditional execution* that executes one or more
    commands based on the success or failure of a prior command. It’s a compact and
    streamlined alternative to the if...else construct, but there are striking differences,
    and it’s crucial that you understand them before using it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论条件执行... 但不，这不是一章关于if命令的内容。的确，if命令是条件执行代码的经典示例，本章将从[第4章](chapter4.xhtml)重新审视这一讨论，但会有一个非常不同的角度。批处理有一个叫做*条件执行*的特殊构造，它基于前一个命令的成功或失败来执行一个或多个命令。这是if...else结构的一个紧凑且精简的替代方案，但也有显著的区别，理解这些差异在使用前至关重要。
- en: I’ll introduce the two operators used in the conditional execution syntax, and
    you’ll see something that’s very similar to, but not identical to, an if...else
    construct. I’ll demonstrate how to successively execute several commands where
    if any one command fails, the rest won’t execute. Flipping the script, I’ll then
    show how to successively execute several commands where if any one command *succeeds*,
    the rest won’t execute.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍条件执行语法中使用的两个运算符，你会看到一些类似但不完全相同的内容，类似于if...else结构。我将演示如何依次执行多个命令，在这些命令中，如果任何一个命令失败，其余命令将不会执行。反转脚本后，我将展示如何依次执行多个命令，如果任何一个命令*成功*，则其余命令不会执行。
- en: Conditional Execution Operators
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件执行运算符
- en: 'In many languages, the double ampersand (&&) is the and operator and the double
    pipe (||) is the or operator, and in [Chapter 27](chapter27.xhtml), I detailed
    how Batch doesn’t support this functionality. Instead, the conditional execution
    syntax employs the double ampersand and the double pipe as operators, which produces
    a level of cognitive dissonance for coders versed in other languages, but these
    operators offer a unique and very succinct alternative to the if command:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，双安培符号（&&）是“与”运算符，双管道符号（||）是“或”运算符，在[第27章](chapter27.xhtml)中，我详细说明了批处理（Batch）不支持这些功能。相反，条件执行语法使用双安培符号和双管道符号作为运算符，这对于熟悉其他语言的程序员来说可能会产生一定的认知失调，但这些运算符提供了一种简洁且独特的替代方法，代替了if命令：
- en: '**The **&&** Operator**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**“&&” 运算符**'
- en: 'In the following general syntax, command1 always executes, and command2 executes
    only if the value of errorlevel is 0 after the completion of command1:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的通用语法中，命令1总是执行，而命令2仅在命令1完成后，`errorlevel`的值为0时才会执行：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A single ampersand separates two commands that execute unconditionally, but
    the extra ampersand invokes the conditional logic. For lack of a better term,
    this is the positive conditional execution operator.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 单个安培符号分隔的两条命令不加条件地执行，但额外的安培符号会触发条件逻辑。可以称之为“正向条件执行运算符”。
- en: '**The **||** Operator**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**“||” 运算符**'
- en: 'Replacing the ampersands with pipes negates the logic. In the following example,
    command2 executes only if the value of errorlevel is *not* 0 after the completion
    of the first command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将安培符号替换为管道符号会改变逻辑。在以下示例中，命令2仅在命令1执行完毕后，`errorlevel`的值*不是*0时才会执行：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A single pipe (appropriately enough) pipes the output of one command to another,
    but here nothing is being piped to the second command, which might not even execute
    at all because of the negative conditional operator.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单个管道符号（恰如其分）将一个命令的输出传递给另一个命令，但这里没有任何内容被传递到第二个命令，后者可能根本不会执行，因为它是负向条件执行运算符。
- en: Using a Single Operator
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用单个运算符
- en: As an alternative to an if command, you can often use a single conditional execution
    operator to streamline your code, but first you need to compare and contrast the
    two methods.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为if命令的替代方案，你通常可以使用单个条件执行运算符来简化代码，但首先需要比较和对比这两种方法。
- en: Positive Conditional Execution
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正向条件执行
- en: To demonstrate, [Listing 28-1](#Lis28-1) offers this straightforward and easy-to-read
    example that creates an empty file and checks the return code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，[列表28-1](#Lis28-1)提供了这个简洁易懂的示例，用于创建一个空文件并检查返回代码。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 28-1: Empty file creation with error handling'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 28-1：带有错误处理的空文件创建
- en: 'Using conditional execution, this one line of code is functionally equivalent:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件执行，这一行代码在功能上是等效的：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the copy command creates the empty file and returns 0, the echo command writes
    the message to the console. In essence, the && is synonymous with if %errorlevel%
    equ 0. If the copy command fails to create the empty file, it returns a value
    other than 0 as the return code, and the echo command doesn’t execute.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果copy命令创建了空文件并返回0，echo命令会将消息写入控制台。实质上，&&等同于if %errorlevel% equ 0。如果copy命令未能创建空文件，它会返回非0的值作为返回代码，echo命令则不会执行。
- en: Because errorlevel is only implied in the conditional execution syntax, its
    value doesn’t find its way into stdout, sometimes obscuring whether certain code
    ever executed. If it’s important that you can find the value of the return code
    in the trace file, the more verbose option is the wise choice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在条件执行语法中，errorlevel的值仅为暗示，因此其值并不会出现在stdout中，这有时会让我们无法确定某些代码是否执行过。如果你需要在跟踪文件中找到返回代码的值，那么更为详细的选项是明智的选择。
- en: 'The conditional execution syntax can be a very succinct (some may say cryptic)
    alternative to an if command, but when you rewrite it to span multiple lines,
    it’s more readable and more closely resembles an if command. You can initiate
    a code block by placing an open parenthesis after the && operator. Then you can
    make your code block out of one or more commands before terminating it with a
    trailing close parenthesis. The following is functionally equivalent to both of
    the prior listings:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 条件执行语法可以是if命令的一个简洁（有些人可能会说是难以理解）替代方式，但当你将其重写为多行时，它更易于阅读，也更接近if命令。你可以通过在&&运算符后面放一个左括号来启动代码块。然后，你可以将一个或多个命令放入代码块中，最后用一个右括号结束它。以下代码在功能上等同于之前的两种写法：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Comparing this to [Listing 28-1](#Lis28-1), I’ve reduced the code by one line
    and replaced the if command along with its conditional clause with the && operator.
    The code is clearly condensed, but whether it’s simplified depends on the reader’s
    knowledge of conditional execution.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与[列表28-1](#Lis28-1)进行对比，我减少了一行代码，并将if命令及其条件语句替换为&&运算符。代码显然被简化了，但是否简化取决于读者对条件执行的理解。
- en: Negative Conditional Execution
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 否定条件执行
- en: 'Now, let’s make some modifications to this logic to experiment with the negative
    conditional execution operator. First, let’s use a folder that doesn’t exist.
    (Spoiler alert: the copy command fails to create an empty file.) Second, let’s
    change && to the || operator and make the message reflect a failure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对这个逻辑进行一些修改，以实验否定条件执行运算符。首先，使用一个不存在的文件夹。（剧透：copy命令未能创建空文件。）其次，将&&更改为||运算符，并使消息反映出失败情况：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now the echo command executes only when the copy command fails, because when
    it fails, it also sets errorlevel to 1. If the command creates the file successfully,
    it sets the return code to 0, and the interpreter writes nothing to the console.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，echo命令只有在copy命令失败时执行，因为当copy命令失败时，它会将errorlevel设置为1。如果命令成功创建文件，它会将返回代码设置为0，并且解释器不会向控制台输出任何内容。
- en: Real-World Applications
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 现实世界中的应用
- en: There’s no shortage of applications; I’ll detail a couple here that use a single
    conditional execution operator.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 应用场景有很多；我将在这里详细介绍几个使用单个条件执行运算符的例子。
- en: Text Searches
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 文本搜索
- en: One scenario starts with a variable holding a program name. If you can find
    a particular server name in its path, you might want to call a certain process
    contained in an internal routine.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一种场景开始时，变量存储了一个程序名称。如果你能在其路径中找到特定的服务器名称，可能想要调用某个内部例程中包含的进程。
- en: 'The following code searches the contents of progName for the value of svrName,
    calling a routine if it finds the server:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码搜索progName的内容以查找svrName的值，如果找到服务器，则调用一个例程：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The echo command pipes the program name into the findstr command, which sets
    errorlevel to 0 if it finds the server name in the input text. Don’t be fooled
    by the single pipe; that’s not conditional execution, but the double ampersands
    do represent this technique.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: echo命令将程序名称传递给findstr命令，如果在输入文本中找到服务器名称，findstr会将errorlevel设置为0。不要被单个管道符迷惑；那不是条件执行，而双&符号则确实代表了这种技术。
- en: 'Similarly, using the || operator instead results in the following code calling
    a different routine, but only when it doesn’t find the text:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用||运算符则会导致以下代码调用不同的例程，但只有在没有找到文本时才会调用：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example also starkly illustrates the difference between a pipe and double
    pipes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也鲜明地说明了管道符和双管道符之间的区别。
- en: Calling Another Bat File
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调用另一个Bat文件
- en: One popular usage of conditional execution is the validation of a call command
    when the argument is a variable containing the name of a bat file to invoke, but
    there are some common pitfalls to avoid.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个常见的条件执行用法是验证 `call` 命令，当参数是一个包含要调用的 bat 文件名称的变量时，但有一些常见的陷阱需要避免。
- en: 'For this demonstration, the calledBat variable might contain the path and name
    of a valid bat file, but it might also contain junk resulting in a failed call
    command. A failure triggers the interpreter to set errorlevel to a value of 1,
    so it’s quite understandable if you were to use the || operator with the following
    error handling:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示范，`calledBat` 变量可能包含一个有效的 bat 文件的路径和名称，但它也可能包含垃圾数据，导致 `call` 命令失败。失败会触发解释器将
    `errorlevel` 设置为 1，因此，如果你使用 || 运算符并配合以下错误处理，这是可以理解的：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, if the call command successfully calls the bat file, the interpreter
    doesn’t set errorlevel to 0—in fact, it doesn’t change the return code at all.
    It’s probably a bug, but that doesn’t change the coder’s plight. If the call command
    is successful, the return code holds the value returned by the last command to
    update it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `call` 命令成功调用了 bat 文件，解释器并不会将 `errorlevel` 设置为 0——实际上，它根本不会改变返回码。这个可能是一个
    bug，但这并不会改变程序员的困境。如果 `call` 命令成功，返回码将保存最后一个命令返回的值来更新它。
- en: I’m making note of this because it’s very easily overlooked. You can test this
    code with a bad bat file, and it’ll work—that is, it’ll write out the error message.
    Then you can test it again with a good bat file, and it’ll probably appear to
    work—that is, it won’t write the message—but it *worked* only because errorlevel
    just happened to be set to 0 before the call command executed, which is something
    you might not always be able to count on. Earlier, I had suggested against using
    conditional execution with the robocopy command because of its unconventional
    return code. I’m not suggesting the same when using commands that don’t universally
    reset the return code, such as the call command, but I do recommend a certain
    level of diligence. There’s a potential, yet very correctable, problem lurking
    with this type of command and conditional execution.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以要提到这一点，是因为这很容易被忽视。你可以用一个错误的 bat 文件测试这段代码，它会正常工作——也就是说，它会输出错误信息。然后你可以用一个正确的
    bat 文件再次测试，可能看起来会正常工作——也就是说，它不会输出消息——但它*之所以工作*，仅仅是因为在执行 `call` 命令之前，`errorlevel`
    正好被设置为 0，这是你可能无法始终依赖的。早些时候，我曾建议不要在使用 `robocopy` 命令时使用条件执行，因为它的返回码不规范。我并没有建议在使用那些没有统一重置返回码的命令时（比如
    `call` 命令）采取相同的做法，但我确实推荐一定程度的谨慎。使用这种类型的命令和条件执行时，潜在的、但可以纠正的问题是存在的。
- en: 'The return code issue should in no way preclude your use of this technique.
    In fact, the same issue exists if you were to evaluate the return code in a traditional
    if command after the execution of the call command. Remember that this technique
    is a glorified way of comparing the contents of errorlevel to a specific value,
    namely, 0. To make this work, you need the value of the return code to be 0 before
    the call command executes. The following cmd command ensures that you reset the
    return code just before the call command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 返回码问题绝不应妨碍你使用这种技术。事实上，如果你在执行 `call` 命令后在传统的 `if` 命令中评估返回码时，同样的问题也会存在。记住，这种技术本质上是将
    `errorlevel` 的值与特定值（即 0）进行比较的高级方式。要使其生效，你需要确保在 `call` 命令执行之前返回码的值为 0。以下 `cmd`
    命令确保你在 `call` 命令执行前重置返回码：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The final concern here is that some command in the called bat file might set
    errorlevel to a nonzero value upon its completion. Unfortunately, this error handling
    treats the bad return code no differently than a failed call of the bat file.
    In this context, both present simply as a nonzero errorlevel after the call command,
    resulting in the possibility of an unrelated failure in the called bat file incorrectly
    triggering the echo command stating that the bat file is invalid.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是，某些在被调用的 bat 文件中的命令可能会在完成后将 `errorlevel` 设置为非零值。不幸的是，这种错误处理不会将错误的返回码与失败的
    `call` 命令区分开来。在这种情况下，这两者都会在 `call` 命令之后以非零 `errorlevel` 出现，从而可能导致被调用的 bat 文件中的一个不相关的失败错误，错误地触发
    echo 命令，声明 bat 文件无效。
- en: The best solution is an agreement between the two bat files. The called bat
    file can use an exit /B 0 command to ensure that it always returns 0 at the end
    of a successful invocation. Error handling between the two bat files might take
    on another form, perhaps a parameter containing a descriptive error message, where
    the called bat file sets it to null as an indication of a successful execution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的解决方案是两个 bat 文件之间达成协议。被调用的 bat 文件可以使用 `exit /B 0` 命令，确保在成功调用结束时始终返回 0。两个 bat
    文件之间的错误处理可以采取另一种形式，也许是一个包含描述性错误信息的参数，其中被调用的 bat 文件将其设置为 null，以表示成功执行。
- en: It’s a very useful tool, but you must consider all possible values of errorlevel
    at different stages of the process flow. This advice is even more critical when
    multiple conditional execution operators are used in tandem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的工具，但你必须考虑在流程的不同阶段 errorlevel 的所有可能值。尤其在多个条件执行操作符联用时，这个建议更加重要。
- en: Using Multiple Operators
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个操作符
- en: Alone, these operators are fairly straightforward, but it gets interesting and
    useful when you use them together.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这些操作符相当直观，但当你将它们组合在一起使用时，它就变得既有趣又有用。
- en: A Pseudo if...else Construct
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个伪 if...else 结构
- en: 'You’ve learned that a pseudo-random number isn’t random, but it’s close; likewise,
    a pseudo if...else construct isn’t really an if...else construct, but it’s close.
    The following code looks remarkably similar to just such a construct, and it acts
    quite a bit like one as well:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到伪随机数并不是真正的随机数，但它接近随机数；同样，伪 if...else 结构并不是真正的 if...else 结构，但它很相似。下面的代码看起来与这种结构非常相似，而且行为上也很像：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I’m using the && operator in place of the if command and its conditional clause;
    even more oddly, the || operator is taking the place of the else keyword (and
    looking a little like a failed attempt at an emoji nestled in between the close
    and open parentheses). In practice, this usually behaves like an if...else construct.
    The copy command tries to create an empty file; if successful, the first echo
    command executes, and if not, the second echo writes a different message. That’s
    exactly what an if...else construct would do, but this technique has a major batveat.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我用 `&&` 操作符代替了 if 命令及其条件子句；更奇怪的是，`||` 操作符取代了 else 关键字（看起来有点像一个失败的表情符号尝试，夹在括号的开闭之间）。在实际操作中，这通常表现得像一个
    if...else 结构。复制命令尝试创建一个空文件；如果成功，第一个 echo 命令执行，如果失败，第二个 echo 命令会写出不同的消息。这正是 if...else
    结构会做的，但这种技术有一个重大的 batveat。
- en: If something inside the first code block sets errorlevel to a nonzero value
    upon its completion, this construct also triggers the second code block. In this
    example, each code block consists of a single echo command, but it isn’t hard
    to imagine more complex logic between the parentheses.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个代码块中的某个操作在完成时将 errorlevel 设置为非零值，那么这个结构也会触发第二个代码块。在这个例子中，每个代码块由一个单独的 echo
    命令组成，但很容易想象括号之间会有更复杂的逻辑。
- en: This is incredibly counterintuitive; if this code successfully creates *Empty.dat*,
    the first echo command executes, but if that command fails, the echo command from
    what might be thought of as the else code block also executes. An if...else construct
    that can execute both code blocks isn’t a true if...else construct.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常违反直觉；如果这段代码成功创建了*Empty.dat*，那么第一个 echo 命令会执行，但如果那个命令失败，那么可以认为是 else 代码块中的
    echo 命令也会执行。一个可以执行两个代码块的 if...else 结构并不是一个真正的 if...else 结构。
- en: In this particular instance, this behavior might be perfectly acceptable because
    it’s unlikely if not impossible for a simple echo command to the console to produce
    a failure, but anything complex enough to reset errorlevel in the first code block
    is ill-advised. Because of this batveat, I don’t use this particular technique
    often, but the next couple of examples demonstrate its true usefulness.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定实例中，这种行为可能是完全可以接受的，因为一个简单的 echo 命令向控制台输出不太可能失败，如果失败，那几乎是不可能的，但任何复杂到足以重置
    errorlevel 的操作放在第一个代码块中都是不明智的。因为有这个 batveat，我不常使用这种技术，但接下来的几个例子展示了它的真正用处。
- en: Multiple && Operators
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多个 && 操作符
- en: Conditional execution is most powerful and useful when you execute multiple
    similar commands consecutively and want to address the error handling en masse.
    For instance, you can copy four distinct files to a target path with four distinct
    xcopy commands. The goal might be to abort the execution if any one of the four
    copies fails, but it doesn’t matter which one fails. At the same time, I don’t
    want to redundantly interrogate the return code four different times. You can
    accomplish that with two different methods, one with and one without conditional
    execution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 条件执行在你连续执行多个类似的命令并希望统一处理错误时最为强大和有用。例如，你可以使用四个不同的xcopy命令将四个不同的文件复制到目标路径。目标可能是，如果其中任何一个复制操作失败，就终止执行，但并不关心是哪个失败。同时，我不想重复四次询问返回码。你可以使用两种不同的方法来实现，一种使用条件执行，另一种不使用条件执行。
- en: 'In lieu of conditional execution, this method concatenates the value of the
    errorlevel variable from each copy attempt. For this demonstration, I’ll just
    write an error message to the console instead of aborting. Assuming that the four
    source files and the target path are defined earlier in the code, this listing
    performs the task:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为条件执行的替代方法，这种方法将每次复制尝试返回的errorlevel值连接起来。为了演示，我将只在控制台写出一条错误信息，而不是中止操作。假设四个源文件和目标路径在代码的前面已定义，这个示例完成了任务：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After the first xcopy command, I set cmlRC (cumulative return code) to the value
    of errorlevel. Then I concatenate the errorlevel returned from the next two commands
    onto the end of cmlRC. Finally, I concatenate the three return codes of cmlRC
    with the errorlevel from the last xcopy command and compare it to 0 in the conditional
    clause of the if command. The interpreter is smart enough to perform a numeric
    compare—four zeros are considered to be equal to one zero. (If each side of the
    conditional clause had been encased in double quotes, Batch would’ve treated them
    like strings, unequal strings to be precise—that is, 0000 equals 0, but "0000"
    doesn’t equal "0".)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个xcopy命令之后，我将cmlRC（累计返回码）设置为errorlevel的值。然后，我将接下来两个命令返回的errorlevel附加到cmlRC的末尾。最后，我将cmlRC的三个返回码与最后一个xcopy命令的errorlevel一起连接，并在if命令的条件句中将其与0进行比较。解释器足够智能，可以进行数字比较——四个零被视为与一个零相等。（如果条件句的每一边都被双引号包围，Batch会将它们视为字符串，实际上是不相等的字符串——即，0000等于0，但"0000"不等于"0"。）
- en: If only the second xcopy fails, the left side of the conditional clause might
    resolve to 0400. Since that isn’t equal to 0, the error handling logic initiates.
    This works, it’s readable, and it has its place in the Batch canon, but now let’s
    compare it to a solution using conditional execution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有第二个xcopy失败，条件句的左侧可能会解析为0400。由于它不等于0，错误处理逻辑将启动。这个方法是可行的、可读的，并且在Batch语法中占有一席之地，但现在让我们将其与使用条件执行的解决方案进行比较。
- en: The syntax has a couple variants. The first requires all of the commands to
    be on one line, which we can make more readable with carets acting as continuation
    characters, as shown in [Listing 28-2](#Lis28-2).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 语法有几种变体。第一种要求所有命令都在一行上，我们可以使用插入符号作为续行符来使其更具可读性，如[Listing 28-2](#Lis28-2)所示。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 28-2: Multiple && operators followed by a || operator'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 28-2：多个&&操作符后跟一个||操作符
- en: Conditional execution allows us to streamline this logic quite a bit compared
    to the prior method, but it isn’t nearly as intuitive.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法相比，条件执行可以大大简化逻辑，但它的直观性不强。
- en: Each && operator separates a pair of xcopy commands, meaning that if the first
    command succeeds, the next one executes, and if it succeeds, the third executes,
    and if all of these did not fail, the final xcopy command also executes. The ||
    operator at the front of the last line of code indicates that the echo command
    executes only if—and immediately after—any one of the xcopy commands fails. This
    is a subtle and important point resulting in these two methods *not* being functionally
    equivalent.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个&&操作符将一对xcopy命令分开，这意味着如果第一个命令成功，第二个命令就会执行，如果第二个成功，第三个命令也会执行，且如果这些命令都没有失败，最后一个xcopy命令也会执行。代码最后一行前面的||操作符表示只有在任何一个xcopy命令失败后，并且立即执行，echo命令才会执行。这是一个微妙且重要的点，导致这两种方法*并不*在功能上等效。
- en: In the concatenation method, all four xcopy commands execute before we examine
    the complete set of return codes, regardless of any earlier failures. In the conditional
    execution method, if one command fails, execution skips immediately to the error
    handling after the two pipes. But how exactly does it work?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接方法中，所有四个 xcopy 命令会在我们检查完整的返回代码集之前执行，无论是否有早期的失败。在条件执行方法中，如果一个命令失败，执行会立即跳转到两个管道符后的错误处理部分。那么，它到底是怎么工作的呢？
- en: Assume for a moment that the first xcopy works. Seeing the && operator before
    the next xcopy command, the interpreter checks the return code. It’s 0, so that
    second command also executes, but assume that it fails because of a lack of disk
    space. The && operator in front of the third command again tells the interpreter
    to check the return code. This time it isn’t 0; the interpreter skips over the
    third command to find the third and last && operator. Since errorlevel is still
    nonzero, the fourth command doesn’t execute. Next, the interpreter finds the ||
    operator and executes the echo command precisely because errorlevel isn’t equal
    to 0. Only if all four xcopy commands execute successfully (that is, each returns
    0) will the echo command not execute.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设第一条 xcopy 命令执行成功。在下一个 xcopy 命令前看到 && 运算符，解释器会检查返回代码。返回值是 0，因此第二条命令也会执行，但假设它因磁盘空间不足而失败。第三条命令前的
    && 运算符再次告诉解释器检查返回代码。这次返回的不是 0；解释器会跳过第三条命令，直到找到第三个也是最后一个 && 运算符。由于 errorlevel 仍然非零，第四条命令不会执行。接下来，解释器会找到
    || 运算符，并执行 echo 命令，恰恰因为 errorlevel 不等于 0。只有当所有四个 xcopy 命令都成功执行（即每个返回 0）时，echo
    命令才不会执行。
- en: So, if there’s any value in executing all of the commands even if one fails,
    the return code concatenation method is preferred. But typically, if one failed
    copy means that you will abort the execution, it’s pointless to even attempt the
    other copies. In this instance, it’s more efficient to not bother with the other
    attempts; hence, the conditional execution method is optimal. Choose the one that
    works best for your situation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果即使一个命令失败，执行所有命令仍然有意义，那么返回代码连接方法更为优先。但通常来说，如果一个失败的复制意味着你会中止执行，那么尝试其他复制操作没有任何意义。在这种情况下，不去尝试其他复制操作会更高效；因此，条件执行方法是最佳选择。选择最适合你情况的方式。
- en: 'I hinted earlier about an alternate syntax for this application of conditional
    execution. For those who appreciate the aesthetics of parentheses over carets,
    the following version of the code is functionally equivalent to the prior listing:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过一种条件执行的替代语法。对于那些喜欢使用括号而非插入符号的用户，以下版本的代码在功能上与之前的示例相同：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Which one is easier to read is subject to debate. I like both and don’t have
    a strong opinion on the matter (which in itself may be as odd as either syntax).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个更容易阅读是一个有争议的问题。我喜欢两者，都没有强烈的意见（这本身可能和任何语法一样奇怪）。
- en: NOTE
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*When using conditional execution with multiple operators, I usually indent
    the continued line just two spaces to differentiate it from a code block, which
    I usually indent three spaces. Sometimes I’ll indent a continued line more than
    three spaces, but I never indent it exactly three.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*当使用多个运算符进行条件执行时，我通常会将继续的行缩进两个空格，以便与代码块区分开来，代码块通常会缩进三个空格。有时我会将继续的行缩进超过三个空格，但我从不将其缩进正好三个空格。*'
- en: Multiple || Operators
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多个 || 运算符
- en: Let’s turn the last scenario on its head. We’ll have the same xcopy commands,
    and we don’t necessarily want all of them to execute. The difference is that we
    need just one of the copies to work. Perhaps a resource file has multiple possible
    locations, with a hierarchy dictating the order of selection. If we successfully
    copy one file, we’ll want to skip over the later copy attempts and call some process
    that uses the file, but to keep this as simple as possible an echo command will
    simply declare the success instead.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们颠倒一下最后的场景。我们将使用相同的 xcopy 命令，并且我们不一定希望它们都执行。不同之处在于，我们只需要其中一个复制操作成功。也许某个资源文件有多个可能的位置，且有一个层级结构决定选择的顺序。如果我们成功复制了一个文件，我们希望跳过后续的复制尝试，并调用一些使用该文件的进程，但为了简化起见，echo
    命令会简单地声明成功。
- en: Once again, assuming that the source files and the target path are defined earlier
    in the code, the code in [Listing 28-3](#Lis28-3) copies at most one file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设源文件和目标路径在代码前面已经定义，[示例 28-3](#Lis28-3)中的代码至多复制一个文件。
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 28-3: Multiple || operators followed by a && operator'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 28-3：多个 || 运算符后跟一个 && 运算符
- en: Compared to [Listing 28-2](#Lis28-2), the most striking difference here is that
    multiple || operators separate the xcopy commands and a && operator comes before
    the trailing command. A more subtle difference is that the xcopy commands make
    up the entirety of a code block.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与[Listing 28-2](#Lis28-2)相比，这里最显著的区别是多个||运算符分隔了xcopy命令，并且&&运算符位于尾部命令之前。一个更微妙的区别是，xcopy命令构成了整个代码块。
- en: Let’s step through the logic assuming that none of the source files exists.
    The first xcopy command executes unconditionally, and it fails, setting errorlevel
    to 4; the nonzero return code and the first || operator trigger the second xcopy
    command, which also fails; two more || operators and two more failures result
    in the final two xcopy commands executing and failing. The last failure sets errorlevel
    to 4 as control exits the first code block. The interpreter immediately finds
    the && operator, quickly checks errorlevel, sees that it isn’t 0, and does *not*
    execute the echo command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设源文件都不存在，我们逐步分析逻辑。第一个xcopy命令无条件执行，并且失败，设置errorlevel为4；非零的返回码和第一个||运算符触发了第二个xcopy命令，该命令也失败；两个更多的||运算符和两次失败导致最后两个xcopy命令执行并失败。最后一次失败将errorlevel设置为4，控制流退出第一个代码块。解释器立即找到&&运算符，快速检查errorlevel，发现它不是0，于是*不*执行echo命令。
- en: It gets even more interesting when one of the copies works. Imagine that the
    first xcopy command successfully copies the file denoted by sorc1 to the target
    path. Because of the good return code and the first || operator, the interpreter
    doesn’t execute the next xcopy command. Furthermore, it doesn’t even recognize
    the third and fourth commands. This is easier to visualize when you consider that
    the four xcopy commands are really all part of the same line of continued code.
    Once the interpreter determines that the command after a || operator won’t execute,
    nothing that comes after it will execute.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当其中一个复制成功时，事情变得更加有趣。假设第一个xcopy命令成功地将sorc1表示的文件复制到目标路径。由于返回码良好和第一个||运算符，解释器不会执行下一个xcopy命令。此外，它甚至不会识别第三个和第四个命令。当你考虑到这四个xcopy命令实际上都是同一行继续代码的一部分时，这就更容易理解了。一旦解释器确定在||运算符之后的命令不会执行，之后的任何命令都不会执行。
- en: More interesting yet, control now exits the first code block after the one successful
    copy where the interpreter finds the && operator. Since errorlevel equals 0 from
    the first xcopy command, which was successful, the code block with the echo command
    executes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，控制流在第一个成功复制之后退出第一个代码块，解释器找到了&&运算符。由于第一个xcopy命令成功，errorlevel等于0，因此包含echo命令的代码块会执行。
- en: If the first xcopy command fails and the second is successful, the third and
    fourth don’t execute because of the second || operator, but the echo command executes
    because of the && operator trailing the first code block. Likewise, if the third
    or fourth xcopy commands are the first to copy a file successfully, the echo command
    also executes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个xcopy命令失败，而第二个命令成功，第三个和第四个命令不会执行，因为第二个||运算符，但echo命令会执行，因为第一个代码块之后跟着&&运算符。同样，如果第三个或第四个xcopy命令是第一个成功复制文件的命令，echo命令也会执行。
- en: 'The parentheses are crucial in this example. In the prior section, four commands
    were separated by && operators, with the last command coming after the || operator.
    In this example, the operators are reversed, demonstrating a significant difference
    between them. I’ll address why the parentheses are in place momentarily, but first,
    since one of the primary reasons to use this conditional execution syntax is to
    condense the code, notice the following five lines of code are functionally equivalent
    to the prior listing:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 括号在这个例子中至关重要。在前面的部分，四个命令通过&&运算符分隔，最后一个命令在||运算符之后执行。在这个例子中，运算符被反转，展示了它们之间的显著差异。我稍后会解释括号为何存在，但首先，由于使用这种条件执行语法的主要原因之一是为了简化代码，注意下面这五行代码在功能上等同于之前的列表：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I’m not fond of this syntax, because it does violate my convention concerning
    the alignment of the open and close parentheses of a naked code block ([Chapter
    16](chapter16.xhtml)). However, it’s nothing if not concise, but I find the version
    with more whitespace more readable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我不太喜欢这种语法，因为它确实违背了我关于裸代码块的括号对齐惯例（[第16章](chapter16.xhtml)）。不过，它简洁明了，但我发现有更多空格的版本更具可读性。
- en: 'Here’s the same basic logic with a pseudo if...else construct to write a message
    indicating either the success or failure to copy one file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同的基本逻辑，使用伪`if...else`结构来写一条消息，表示复制一个文件的成功或失败：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This does come with the obligatory batveat that if the first echo command somehow
    manages to reset errorlevel to a nonzero value, the second echo command will also
    execute.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个必要的警告，如果第一个`echo`命令以某种方式将错误级别重置为非零值，那么第二个`echo`命令也会执行。
- en: Multiple && vs. Multiple || Operators
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多个`&&`与多个`||`运算符
- en: I promised more details on why the parentheses are in place when using multiple
    || operators in [Listing 28-3](#Lis28-3) but not with the multiple && operators
    in [Listing 28-2](#Lis28-2).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我承诺在[Listing 28-3](#Lis28-3)中解释为什么在使用多个`||`运算符时需要括号，但在[Listing 28-2](#Lis28-2)中使用多个`&&`运算符时不需要。
- en: 'To understand, first take this generic syntax of multiple commands separated
    by && operators with a trailing || operator:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，首先看一下这个由多个通过`&&`运算符分隔的命令以及后续`||`运算符组成的通用语法：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Assume that command1 returns 0. If so, command2 executes; assume it fails to
    return 0. Because of the && operator prior to command3, the interpreter doesn’t
    execute the command, skipping over it instead to find another && operator; errorlevel
    is still nonzero, so it also skips command4. It finds yet another && operator,
    so command5 doesn’t execute. But then the interpreter finds the || operator, and
    the nonzero errorlevel from the second command triggers the execution of command6.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`command1`返回0。如果是这样，`command2`会执行；假设它执行失败并返回非0。由于`&&`运算符在`command3`之前，解释器不会执行该命令，而是跳过它，继续寻找另一个`&&`运算符；错误级别仍然非0，因此它也跳过`command4`。它又找到了一个`&&`运算符，所以`command5`不会执行。但接下来解释器找到了`||`运算符，第二条命令返回的非0错误级别触发了`command6`的执行。
- en: 'Now let’s flip each of the conditional execution operators. This is more like
    the scenario where we wanted a single command to execute successfully, but no
    more than one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们交换每个条件执行运算符。这更像是我们想让一个命令成功执行，但不超过一个的场景：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This time let’s assume that command1 returns something other than 0. Because
    of the || operator before command2, the second command also executes; now assume
    it executes successfully and returns 0. Because of the || operator after it, the
    logical flow skips command3. This is where it gets interesting.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这次`command1`返回的不是0。由于`command2`之前有`||`运算符，第二条命令也会执行；现在假设它成功执行并返回0。由于后面的`||`运算符，逻辑流程会跳过`command3`。这就是有趣的地方。
- en: The interpreter does *not* continue to look for another operator. The line is
    abandoned right there, regardless of the subsequent commands and operators.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器*不会*继续查找另一个运算符。该行在此被放弃，无论后续的命令和运算符是什么。
- en: 'That’s significant and the reason why I included the parentheses in [Listing
    28-3](#Lis28-3) along with the multiple || operators. Consider this apparently
    minor tweak to the prior syntax:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常重要的，也是我在[Listing 28-3](#Lis28-3)中加入括号并使用多个`||`运算符的原因。请考虑这种看似微小的语法调整：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With a set of parentheses surrounding the commands separated by || operators,
    the first command again executes unconditionally. The other commands in the parentheses
    execute only if the one prior to it fails. It doesn’t matter how many execute;
    after any one of these commands succeeds or after they all fail, control exits
    the logic inside the parentheses. The interpreter immediately encounters the &&
    operator, where command6 executes only if one command (the last command to execute)
    returned 0.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用一对括号将通过`||`运算符分隔的命令包围起来，第一个命令会无条件执行。括号内的其他命令只有在前一个命令失败时才会执行。执行多少条命令并不重要；只要其中一条命令成功执行，或者它们全部失败，控制流就会退出括号内的逻辑。接着，解释器会立即遇到`&&`运算符，只有在某个命令（最后一个执行的命令）返回0时，`command6`才会执行。
- en: Don’t assume anything when using multiple conditional execution operators; always
    test.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个条件执行运算符时不要做任何假设；一定要进行测试。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: If nothing else is to be taken away from this chapter, && isn’t an and operator
    and || isn’t an or operator. They are the conditional execution operators that
    evaluate errorlevel being equal to 0 or not equal to 0, respectively. I’ve detailed
    in depth how each works alone, together, and in series.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从这一章没有别的东西要记住的话，`&&`不是一个与运算符，`||`也不是一个或运算符。它们分别是评估错误级别是否为0或不为0的条件执行运算符。我已经详细讲解了每个运算符单独、组合以及串联使用时的工作原理。
- en: Conditional execution is similar to the if command, but you’ve learned the important
    differences that you must know before you can use this technique successfully.
    Although it isn’t ideal in all situations, it does offer a very concise alternative
    syntax. I also explained an important difference between how the interpreter handles
    both operators and demonstrated some real-world applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 条件执行类似于 if 命令，但你已经了解了在成功使用该技巧之前必须知道的重要区别。尽管在所有情况下它并不理想，但它确实提供了一种非常简洁的替代语法。我还解释了解释器如何处理这两种运算符之间的重要区别，并演示了一些实际应用。
- en: In the next chapter, I’ll return to the concept of building tools in Batch that
    were not imagined at its onset, namely, arrays and hash tables.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我将回到在 Batch 中构建最初未曾设想的工具的概念，即数组和哈希表。
