- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: GO PLUGINS AND EXTENDABLE TOOLS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GO插件与可扩展工具
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: Many security tools are constructed as *frameworks*—core components, built with
    a level of abstraction that allows you to easily extend their functionality. If
    you think about it, this makes a lot of sense for security practitioners. The
    industry is constantly changing; the community is always inventing new exploits
    and techniques to avoid detection, creating a highly dynamic and somewhat unpredictable
    landscape. However, by using plug-ins and extensions, tool developers can future-proof
    their products to a degree. By reusing their tools’ core components without making
    cumbersome rewrites, they can handle industry evolution gracefully through a pluggable
    system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多安全工具都是作为*框架*构建的——核心组件采用一定的抽象级别，允许你轻松扩展其功能。仔细想想，这对于安全从业人员来说是非常有意义的。行业不断变化，社区总是在发明新的漏洞和技术以避免检测，创造了一个高度动态且有些不可预测的环境。然而，通过使用插件和扩展，工具开发人员可以在一定程度上使他们的产品具备应对未来变化的能力。通过重复使用工具的核心组件，而无需繁琐的重写，他们可以通过可插拔系统优雅地应对行业演变。
- en: This, coupled with massive community involvement, is arguably how the Metasploit
    Framework has managed to age so well. Hell, even commercial enterprises like Tenable
    see the value in creating extendable products; Tenable relies on a plug-in-based
    system to perform signature checks within its Nessus vulnerability scanner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式，加上广泛的社区参与，可以说是Metasploit框架得以成功发展的原因之一。甚至像Tenable这样的商业企业也看到了创建可扩展产品的价值；Tenable依赖于基于插件的系统，在其Nessus漏洞扫描器中执行签名检查。
- en: In this chapter, you’ll create two vulnerability scanner extensions in Go. You’ll
    first do this by using the native Go plug-in system and explicitly compiling your
    code as a shared object. Then you’ll rebuild the same plug-in by using an embedded
    Lua system, which predates the native Go plug-in system. Keep in mind that, unlike
    creating plug-ins in other languages, such as Java and Python, creating plug-ins
    in Go is a fairly new construct. Native support for plug-ins has existed only
    since Go version 1.8\. Further, it wasn’t until Go version 1.10 that you could
    create these plug-ins as Windows dynamic link libraries (DLLs). Make sure you’re
    running the latest version of Go so that all the examples in this chapter work
    as planned.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用Go创建两个漏洞扫描器扩展。首先，你将使用原生的Go插件系统，并显式地将代码编译为共享对象。然后，你将通过使用嵌入式Lua系统重建相同的插件，而Lua系统早于Go的原生插件系统。请记住，与在其他语言中创建插件（如Java和Python）不同，Go中创建插件是一个相对较新的概念。原生支持插件的功能仅从Go
    1.8版本开始。此外，直到Go 1.10版本，你才能将这些插件创建为Windows动态链接库（DLL）。确保你正在运行最新版本的Go，以便本章中的所有示例都能按计划工作。
- en: Using Go’s Native Plug-in System
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Go的原生插件系统
- en: 'Prior to version 1.8 of Go, the language didn’t support plug-ins or dynamic
    runtime code extendibility. Whereas languages like Java allow you to load a class
    or JAR file when you execute your program to instantiate the imported types and
    call their functions, Go provided no such luxury. Although you could sometimes
    extend functionality through interface implementations and such, you couldn’t
    truly dynamically load and execute the code itself. Instead, you needed to properly
    include it during compile time. As an example, there was no way to replicate the
    Java functionality shown here, which dynamically loads a class from a file, instantiates
    the class, and calls `someMethod()` on the instance:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go 1.8版本之前，该语言不支持插件或动态运行时代码扩展性。而像Java这样的语言允许你在执行程序时加载一个类或JAR文件，从而实例化导入的类型并调用它们的函数，Go则没有这种奢侈的功能。尽管有时你可以通过接口实现等方式扩展功能，但你无法真正动态加载和执行代码本身。相反，你需要在编译时正确地包含它。例如，无法复制Java的功能，如下所示，它动态加载一个类文件，实例化该类，并调用实例上的`someMethod()`方法：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Luckily, the later versions of Go have the ability to mimic this functionality,
    allowing developers to compile code explicitly for use as a plug-in. Limitations
    exist, though. Specifically, prior to version 1.10, the plug-in system worked
    only on Linux, so you’d have to deploy your extendable framework on Linux.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go的后续版本具备了模拟这种功能的能力，允许开发人员明确地将代码编译为插件进行使用。然而，仍然存在一些限制。具体来说，在1.10版本之前，插件系统仅在Linux上有效，因此你需要将可扩展框架部署在Linux上。
- en: 'Go’s plug-ins are created as shared objects during the building process. To
    produce this shared object, you enter the following build command, which supplies
    `plugin` as the `buildmode` option:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go的插件在构建过程中作为共享对象创建。要生成该共享对象，你输入以下构建命令，并将`plugin`作为`buildmode`选项：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, to build a Windows DLL, use `c-shared` as the `buildmode` option:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要构建Windows DLL，可以使用`c-shared`作为`buildmode`选项：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To build a Windows DLL, your program must meet certain conventions to export
    your functions and also must import the `C` library. We’ll let you explore these
    details on your own. Throughout this chapter, we’ll focus almost exclusively on
    the Linux plug-in variant, since we’ll demonstrate how to load and use DLLs in
    [Chapter 12](ch12.xhtml#ch12).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建Windows DLL，你的程序必须符合一定的约定，以便导出函数，并且还必须导入`C`库。我们将让你自行探索这些细节。在本章中，我们将几乎专注于Linux插件变体，因为我们将在[第12章](ch12.xhtml#ch12)中演示如何加载和使用DLL。
- en: 'After you’ve compiled to a DLL or shared object, a separate program can load
    and use the plug-in at runtime. Any of the exported functions will be accessible.
    To interact with the exported features of a shared object, you’ll use Go’s `plugin`
    package. The functionality in the package is straightforward. To use a plug-in,
    follow these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编译成DLL或共享对象后，另一个程序可以在运行时加载并使用该插件。任何导出的函数都可以访问。要与共享对象的导出功能交互，你将使用Go的`plugin`包。该包的功能是直接的。要使用插件，按照以下步骤操作：
- en: Call `plugin.Open(`filename string`)` to open a shared object file, creating
    a `*plugin.Plugin` instance.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`plugin.Open(`filename string`)`打开共享对象文件，并创建一个`*plugin.Plugin`实例。
- en: On the `*plugin.Plugin` instance, call `Lookup(`symbolName string`)` to retrieve
    a `Symbol` (that is, an exported variable or function) by name.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`*plugin.Plugin`实例上，调用`Lookup(`symbolName string`)`通过名称检索一个`Symbol`（即导出的变量或函数）。
- en: Use a type assertion to convert the generic `Symbol` to the type expected by
    your program.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类型断言将通用的`Symbol`转换为程序预期的类型。
- en: Use the resulting converted object as desired.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要使用转换后的对象。
- en: You may have noticed that the call to `Lookup()` requires the consumer to supply
    a symbol name. This means that the consumer must have a predefined, and hopefully
    publicized, naming scheme. Think of it as almost a defined API or generic interface
    to which plug-ins will be expected to adhere. Without a standard naming scheme,
    new plug-ins would require you to make changes to the consumer code, defeating
    the entire purpose of a plug-in-based system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`Lookup()`的调用要求消费者提供符号名称。这意味着消费者必须有一个预定义的、并且最好是公开的命名方案。可以将其视为几乎定义的API或通用接口，插件将被要求遵守。如果没有标准的命名方案，新的插件将需要你修改消费者代码，从而破坏了基于插件的系统的整个目的。
- en: In the examples that follow, you should expect plug-ins to define an exported
    function named `New()` that returns a specific interface type. That way, you’ll
    be able to standardize the bootstrapping process. Getting a handle back to an
    interface allows us to call functions on the object in a predictable way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，你应该预期插件定义一个名为`New()`的导出函数，该函数返回一个特定的接口类型。这样，你将能够标准化引导过程。获取到接口的句柄可以让我们以可预测的方式调用该对象上的函数。
- en: 'Now let’s start creating your pluggable vulnerability scanner. Each plug-in
    will implement its own signature-checking logic. Your main scanner code will bootstrap
    the process by reading your plug-ins from a single directory on your filesystem.
    To make this all work, you’ll have two separate repositories: one for your plug-ins
    and one for the main program that consumes the plug-ins.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始创建你的可插拔漏洞扫描器。每个插件将实现自己的签名检查逻辑。你的主扫描程序将通过从文件系统的一个目录中读取插件来引导整个过程。为了让这一切顺利运行，你将有两个独立的仓库：一个用于插件，一个用于消费插件的主程序。
- en: Creating the Main Program
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建主程序
- en: 'Let’s start with your main program, to which you’ll attach your plug-ins. This
    will help you understand the process of authoring your plug-ins. Set up your repository’s
    directory structure so it matches the one shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从你的主程序开始，你将把插件附加到它上面。这将帮助你理解编写插件的过程。设置你的仓库目录结构，使其与这里显示的结构相匹配：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The file called *cmd/scanner/main.go* is your command line utility. It will
    load the plug-ins and initiate a scan. The *plugins* directory will contain all
    the shared objects that you’ll load dynamically to call various vulnerability
    signature checks. You’ll use the file called *scanner/scanner.go* to define the
    data types your plug-ins and main scanner will use. You put this data into its
    own package to make it a little bit easier to use.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 *cmd/scanner/main.go* 的文件是你的命令行工具。它将加载插件并启动扫描。*plugins* 目录将包含你需要动态加载的所有共享对象，用于执行各种漏洞签名检查。你将使用名为
    *scanner/scanner.go* 的文件来定义插件和主扫描器所使用的数据类型。你将这些数据放入一个单独的包中，以使其使用起来更为方便。
- en: '[Listing 10-1](ch10.xhtml#ch10list1) shows what your *scanner.go* file looks
    like. (All the code listings at the root location of / exist under the provided
    github repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-1](ch10.xhtml#ch10list1) 显示了你的 *scanner.go* 文件的样子。（所有位于根目录的代码清单都存在于提供的
    GitHub 仓库 *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*
    中。）'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-1: Defining core scanner types (*[/ch-10/plugin-core/scanner/scanner.go](https://ch-10/plugin-core/scanner/scanner.go)*)*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：定义核心扫描器类型 (*[/ch-10/plugin-core/scanner/scanner.go](https://ch-10/plugin-core/scanner/scanner.go)*)*'
- en: In this package, named `scanner`, you define two types. The first is an interface
    called `Checker` ❶. The interface defines a single method named `Check()` ❷, which
    accepts a host and port value and returns a pointer to a `Result`. Your `Result`
    type is defined as a `struct` ❸. Its purpose is to track the outcome of the check.
    Is the service vulnerable? What details are pertinent in documenting, validating,
    or exploiting the flaw?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个名为 `scanner` 的包中，你定义了两种类型。第一个是一个名为 `Checker` 的接口 ❶。该接口定义了一个名为 `Check()` ❷
    的方法，该方法接受主机和端口值，并返回指向 `Result` 的指针。你的 `Result` 类型被定义为一个 `struct` ❸。它的作用是追踪检查的结果。服务是否存在漏洞？在记录、验证或利用漏洞时需要哪些详细信息？
- en: You’ll treat the interface as a contract or blueprint of sorts; a plug-in is
    free to implement the `Check()` function however it chooses, so long as it returns
    a pointer to a `Result`. The logic of the plug-in’s implementation will vary based
    on each plug-in’s vulnerability-checking logic. For instance, a plug-in checking
    for a Java deserialization issue can implement the proper HTTP calls, whereas
    a plug-in checking for default SSH credentials can issue a password-guessing attack
    against the SSH service. The power of abstraction!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把接口视为一种契约或蓝图；插件可以自由地实现 `Check()` 函数，方式由其自行决定，只要它返回指向 `Result` 的指针即可。插件的实现逻辑将根据每个插件的漏洞检查逻辑有所不同。例如，检查
    Java 反序列化问题的插件可以实现适当的 HTTP 调用，而检查默认 SSH 凭证的插件可以对 SSH 服务发起密码猜测攻击。抽象的力量！
- en: Next, let’s review *cmd/scanner/main.go*, which will consume your plug-ins ([Listing
    10-2](ch10.xhtml#ch10list2)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下 *cmd/scanner/main.go*，它将使用你的插件（[清单 10-2](ch10.xhtml#ch10list2)）。
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-2: The scanner client that runs plug-ins (*[/ch-10/plugin-core/cmd/scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-10/plugin-core/cmd/scanner/main.go)*)*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：运行插件的扫描器客户端 (*[/ch-10/plugin-core/cmd/scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-10/plugin-core/cmd/scanner/main.go)*)*'
- en: The code starts by defining the location of your plug-ins ❶. In this case, you’ve
    hardcoded it; you could certainly improve the code so it reads this value in as
    an argument or environment variable instead. You use this variable to call `ioutil.ReadDir(PluginDir)`
    and obtain a file listing ❷, and then loop over each of these plug-in files ❸.
    For each file, you use Go’s `plugin` package to read the plug-in via a call to
    `plugin.Open()` ❹. If this succeeds, you’re given a `*plugin.Plugin` instance,
    which you assign to the variable named `p`. You call `p.Lookup("New")` to search
    your plug-in for a symbol named `New` ❺.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先定义了插件的路径 ❶。在这种情况下，你已经硬编码了它；你当然可以改进代码，使它从参数或环境变量中读取该值。你使用此变量调用 `ioutil.ReadDir(PluginDir)`
    获取文件列表 ❷，然后遍历这些插件文件 ❸。对于每个文件，你使用 Go 的 `plugin` 包通过调用 `plugin.Open()` ❹ 来读取插件。如果成功，你将获得一个
    `*plugin.Plugin` 实例，并将其分配给名为 `p` 的变量。你调用 `p.Lookup("New")` 来搜索插件中名为 `New` 的符号
    ❺。
- en: As we mentioned during the high-level overview earlier, this symbol lookup convention
    requires your main program to provide the explicit name of the symbol as an argument,
    meaning you expect the plug-in to have an exported symbol by the same name—in
    this case, our main program is looking for the symbol named `New`. Furthermore,
    as you’ll see shortly, the code expects the symbol to be a function that will
    return a concrete implementation of your `scanner.Checker` interface, which we
    discussed in the previous section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的高层概述中提到的，这种符号查找约定要求你的主程序将符号的显式名称作为参数传递，这意味着你期望插件拥有一个同名的导出符号——在这个例子中，我们的主程序正在寻找名为`New`的符号。此外，正如你稍后将看到的，代码期望这个符号是一个函数，它将返回你在上一节中讨论的`scanner.Checker`接口的具体实现。
- en: Assuming your plug-in contains a symbol named `New`, you make a type assertion
    for the symbol as you try to convert it to type `func()` `scanner.Checker` ❻.
    That is, you’re expecting the symbol to be a function that returns an object implementing
    `scanner.Checker`. You assign the converted value to a variable named `newFunc`.
    Then you invoke it and assign the returned value to a variable named `check` ❼.
    Thanks to your type assertion, you know that `check` satisfies your `scanner.Checker`
    interface, so it must implement a `Check()` function. You call it, passing in
    a target host and port ❽. The result, a `*scanner.Result`, is captured using a
    variable named `res` and inspected to determine whether the service was vulnerable
    or not ❾.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的插件包含一个名为`New`的符号，你尝试将它转换为类型`func()` `scanner.Checker` ❻。也就是说，你期望这个符号是一个返回实现了`scanner.Checker`的对象的函数。你将转换后的值赋给名为`newFunc`的变量。然后你调用它，并将返回的值赋给名为`check`的变量
    ❼。由于你进行了类型断言，你知道`check`满足你的`scanner.Checker`接口，因此它必须实现一个`Check()`函数。你调用它，传入一个目标主机和端口
    ❽。结果，一个`*scanner.Result`，被使用名为`res`的变量捕获，并检查是否服务存在漏洞 ❾。
- en: Notice that this process is generic; it uses type assertions and interfaces
    to create a construct through which you can dynamically call plug-ins. Nothing
    within the code is specific to a single vulnerability signature or method used
    to check for a vulnerability’s existence. Instead, you’ve abstracted the functionality
    enough that plug-in developers can create stand-alone plug-ins that perform units
    of work without having knowledge of other plug-ins—or even extensive knowledge
    of the consuming application. The only thing that plug-in authors must concern
    themselves with is properly creating the exported `New()` function and a type
    that implements `scanner.Checker`. Let’s have a look at a plug-in that does just
    that.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个过程是通用的；它使用类型断言和接口来创建一个构造体，允许你动态调用插件。代码中的任何内容都不是特定于单一漏洞签名或用于检查漏洞是否存在的方法。相反，你已经将功能抽象得足够清晰，以至于插件开发者可以创建独立的插件，执行各自的工作单元，而无需了解其他插件——甚至无需深入了解使用应用程序。插件作者唯一需要关注的是正确创建导出的`New()`函数和实现`scanner.Checker`的类型。让我们来看一个做到这一点的插件。
- en: Building a Password-Guessing Plug-in
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建一个密码猜测插件
- en: This plug-in ([Listing 10-3](ch10.xhtml#ch10list3)) performs a password-guessing
    attack against the Apache Tomcat Manager login portal. A favorite target for attackers,
    the portal is commonly configured to accept easily guessable credentials. With
    valid credentials, an attacker can reliably execute arbitrary code on the underlying
    system. It’s an easy win for attackers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件（[清单 10-3](ch10.xhtml#ch10list3)）对 Apache Tomcat Manager 登录门户进行密码猜测攻击。这个门户是攻击者的热门目标，通常配置为接受易于猜测的凭证。凭有效凭证，攻击者可以可靠地在底层系统上执行任意代码。这对攻击者来说是一次轻松的胜利。
- en: In our review of the code, we won’t cover the specific details of the vulnerability
    test, as it’s really just a series of HTTP requests issued to a specific URL.
    Instead, we’ll focus primarily on satisfying the pluggable scanner’s interface
    requirements.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对代码的回顾中，我们不会涉及漏洞测试的具体细节，因为它实际上只是向特定 URL 发出的一系列 HTTP 请求。相反，我们将主要关注满足插件式扫描器接口要求的部分。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-3: Creating a Tomcat credential-guessing plug-in natively (*[/ch-10/plugin-tomcat/main.go](https://github.com/blackhat-go/bhg/tree/master/ch-10/plugin-tomcat/main.go)*)*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：原生创建 Tomcat 凭证猜测插件 (*[/ch-10/plugin-tomcat/main.go](https://github.com/blackhat-go/bhg/tree/master/ch-10/plugin-tomcat/main.go)*)*'
- en: First, you need to import the `scanner` package we detailed previously ❶. This
    package defines both the `Checker` interface and the `Result` struct that you’ll
    be building. To create an implementation of `Checker`, you start by defining an
    empty `struct` type named `TomcatChecker` ❷. To fulfill the `Checker` interface’s
    implementation requirements, you create a method matching the required `Check(host
    string, port uint64) *scanner.Result` function signature ❸. Within this method,
    you perform all of your custom vulnerability-checking logic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要导入我们之前详细介绍的`scanner`包 ❶。该包定义了`Checker`接口和你将要构建的`Result`结构体。为了创建`Checker`的实现，你需要定义一个名为`TomcatChecker`的空`struct`类型
    ❷。为了满足`Checker`接口的实现要求，你需要创建一个匹配所需函数签名`Check(host string, port uint64) *scanner.Result`的方法
    ❸。在这个方法中，你执行所有自定义的漏洞检查逻辑。
- en: Since you’re expected to return a `*scanner.Result`, you initialize one, assigning
    it to a variable named `res` ❹. If the conditions are met—that is, if the checker
    verifies the guessable credentials—and the vulnerability is confirmed ❺, you set
    `res.Vulnerable` to `true` and set `res.Details` to a message containing the identified
    credentials. If the vulnerability isn’t identified, the instance returned will
    have `res.Vulnerable` set to its default state—`false`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你需要返回`*scanner.Result`，你先初始化一个，将其赋值给名为`res`的变量 ❹。如果条件满足——也就是说，如果检查器验证了可猜测的凭据——并且漏洞得到确认
    ❺，你将`res.Vulnerable`设置为`true`，并将`res.Details`设置为包含已识别凭据的消息。如果未识别出漏洞，返回的实例将保持`res.Vulnerable`的默认状态——`false`。
- en: Lastly, you define the required exported function `New() *scanner.Checker` ❻.
    This adheres to the expectations set by your scanner’s `Lookup()` call, as well
    as the type assertion and conversion needed to instantiate the plug-in-defined
    `TomcatChecker`. This basic entry point does nothing more than return a new `*TomcatChecker`
    (which, since it implements the required `Check()` method, happens to be a `scanner.Checker`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要定义所需的导出函数`New() *scanner.Checker` ❻。这符合扫描器的`Lookup()`调用的预期，同时也满足了类型断言和转换的要求，以实例化插件定义的`TomcatChecker`。这个基本的入口点仅仅是返回一个新的`*TomcatChecker`（由于它实现了所需的`Check()`方法，它恰好是一个`scanner.Checker`）。
- en: Running the Scanner
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行扫描器
- en: 'Now that you’ve created both your plug-in and the main program that consumes
    it, compile your plug-in, using the `-o` option to direct your compiled shared
    object to the scanner’s plug-ins directory:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经创建了插件和使用它的主程序，编译你的插件，并使用`-o`选项将编译后的共享对象导入到扫描器的插件目录中：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then run your scanner (*cmd/scanner/main.go*) to confirm that it identifies
    the plug-in, loads it, and executes the plug-in’s `Check()` method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行你的扫描器（*cmd/scanner/main.go*），确认它能识别插件、加载插件并执行插件的`Check()`方法：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Would you look at that? It works! Your scanner is able to call code within your
    plug-in. You can drop any number of other plug-ins into the plug-ins directory.
    Your scanner will attempt to read each and kick off the vulnerability-checking
    functionality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个？它有效！你的扫描器能够调用插件中的代码。你可以将任意数量的其他插件放入插件目录中。扫描器会尝试读取每个插件并启动漏洞检查功能。
- en: 'The code we developed could benefit from a number of improvements. We’ll leave
    these improvements to you as an exercise. We encourage you to try a few things:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的代码可以通过一些改进来优化。我们将这些改进留给你作为练习。我们鼓励你尝试以下几项内容：
- en: Create a plug-in to check for a different vulnerability.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个插件以检查另一种漏洞。
- en: Add the ability to dynamically supply a list of hosts and their open ports for
    more extensive tests.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加动态提供主机列表及其开放端口的能力，以进行更广泛的测试。
- en: Enhance the code to call only applicable plug-ins. Currently, the code will
    call all plug-ins for the given host and port. This isn’t ideal. For example,
    you wouldn’t want to call the Tomcat checker if the target port isn’t HTTP or
    HTTPS.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增强代码，仅调用适用的插件。目前，代码会为给定的主机和端口调用所有插件。这并不理想。例如，如果目标端口不是 HTTP 或 HTTPS，你肯定不希望调用
    Tomcat 检查器。
- en: Convert your plug-in system to run on Windows, using DLLs as the plug-in type.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的插件系统转换为在 Windows 上运行，使用 DLL 作为插件类型。
- en: 'In the next section, you’ll build the same vulnerability-checking plug-in in
    a different, unofficial plug-in system: Lua.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将构建相同的漏洞检查插件，但使用一个不同的、非官方的插件系统：Lua。
- en: Building Plug-ins in Lua
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用 Lua 构建插件
- en: Using Go’s native `buildmode` feature when creating pluggable programs has limitations,
    particularly because it’s not very portable, meaning the plug-ins may not cross-compile
    nicely. In this section, we’ll look at a way to overcome this deficiency by creating
    plug-ins with Lua instead. Lua is a scripting language used to extend various
    tools. The language itself is easily embeddable, powerful, fast, and well-documented.
    Security tools such as Nmap and Wireshark use it for creating plug-ins, much as
    you’ll do right now. For more info, refer to the official site at *[https://www.lua.org/](https://www.lua.org/)*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建可插拔程序时使用 Go 的原生 `buildmode` 特性有一定的局限性，特别是因为它不太具备可移植性，意味着插件可能无法顺利交叉编译。在这一部分，我们将通过使用
    Lua 来创建插件，看看如何克服这一缺陷。Lua 是一种用于扩展各种工具的脚本语言。它本身易于嵌入，功能强大、快速且文档完善。像 Nmap 和 Wireshark
    这样的安全工具就用它来创建插件，正如你现在将要做的那样。更多信息，请参考官方站点 *[https://www.lua.org/](https://www.lua.org/)*
- en: 'To use Lua within Go, you’ll use a third-party package, `gopher-lua`, which
    is capable of compiling and executing Lua scripts directly in Go. Install it on
    your system by entering the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Go 中使用 Lua，你将使用一个第三方包 `gopher-lua`，它能够直接在 Go 中编译和执行 Lua 脚本。通过输入以下命令安装它：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, be forewarned that the price you’ll pay for portability is increased complexity.
    That’s because Lua has no implicit way to call functions in your program or various
    Go packages and has no knowledge of your data types. To solve this problem, you’ll
    have to choose one of two design patterns:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意，你为获得可移植性所付出的代价是增加了复杂性。因为 Lua 没有隐式的方式调用你的程序或各种 Go 包中的函数，也不了解你的数据类型。为了解决这个问题，你需要选择两种设计模式中的一种：
- en: Call a single entry point in your Lua plug-in, and let the plug-in call any
    helper methods (such as those needed to issue HTTP requests) through other Lua
    packages. This makes your main program simple, but it reduces portability and
    could make dependency management a nightmare. For example, what if a Lua plug-in
    requires a third-party dependency not installed as a core Lua package? Your plug-in
    would break the moment you move it to another system. Also, what if two separate
    plug-ins require different versions of a package?
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Lua 插件中调用一个单一入口点，并通过其他 Lua 包让插件调用任何辅助方法（例如发起 HTTP 请求所需的方法）。这使得你的主程序简洁，但也降低了可移植性，并可能使依赖管理变得复杂。举个例子，如果一个
    Lua 插件需要一个未作为核心 Lua 包安装的第三方依赖呢？当你把插件移到另一个系统时，它就会崩溃。此外，如果两个独立的插件需要不同版本的某个包呢？
- en: In your main program, wrap the helper functions (such as those from the `net/http`
    package) in a manner that exposes a façde through which the plug-in can interact.
    This, of course, requires you to write extensive code to expose all the Go functions
    and types. However, once you’ve written the code, the plug-ins can reuse it in
    a consistent manner. Plus, you can sort of not worry about the Lua dependency
    issues that you’d have if you used the first design pattern (although, of course,
    there’s always the chance that a plug-in author uses a third-party library and
    breaks something).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主程序中，将辅助函数（如来自 `net/http` 包的函数）封装成一种方式，通过该方式，插件可以进行交互。当然，这要求你编写大量代码以暴露所有
    Go 函数和类型。然而，一旦你写完代码，插件就可以以一致的方式重用它。此外，你可以不用太担心使用第一种设计模式时会遇到的 Lua 依赖问题（当然，也有可能插件作者使用了第三方库并导致出现问题）。
- en: For the remainder of this section, you’ll work on the second design pattern.
    You’ll wrap your Go functions to expose a façde that’s accessible to your Lua
    plug-ins. It’s the better of the two solutions (and plus, the word *façde* makes
    it sound like you’re building something really fancy).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，你将使用第二种设计模式。你将封装你的 Go 函数，暴露一个插件可以访问的 façade。这是两种解决方案中更优的一个（而且，*façde*
    这个词让它听起来像是你在构建一些非常高端的东西）。
- en: The bootstrapping, core Go code that loads and runs plug-ins will reside in
    a single file for the duration of this exercise. For the sake of simplicity, we’ve
    specifically removed some of patterns used in the examples at *[https://github.com/yuin/gopher-lua/](https://github.com/yuin/gopher-lua/)*.
    We felt that some of the patterns, such as using user-defined types, made the
    code less readable. In a real implementation, you’d likely want to include some
    of those patterns for better flexibility. You’d also want to include more extensive
    error and type checking.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 引导和核心的 Go 代码，用于加载和运行插件，在本次练习的整个过程中将保持在一个单一文件中。为了简化起见，我们特意移除了一些在 *[https://github.com/yuin/gopher-lua/](https://github.com/yuin/gopher-lua/)*
    示例中使用的模式。我们认为某些模式，比如使用用户定义的类型，使得代码的可读性降低。在实际实现中，你可能会想要包含一些这样的模式，以提高灵活性。同时，你还需要加入更全面的错误和类型检查。
- en: Your main program will define functions to issue GET and HEAD HTTP requests,
    register those functions with the Lua virtual machine (VM), and load and execute
    your Lua scripts from a defined plug-ins directory. You’ll build the same Tomcat
    password-guessing plug-in from the previous section, so you’ll be able to compare
    the two versions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你的主程序将定义用于发出 GET 和 HEAD HTTP 请求的函数，注册这些函数到 Lua 虚拟机（VM），并从指定的插件目录加载并执行 Lua 脚本。你将重建上一节中的
    Tomcat 密码猜测插件，这样你就可以对比这两个版本。
- en: Creating the head() HTTP Function
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 head() HTTP 函数
- en: Let’s start with the main program. First, let’s look at the `head()` HTTP function,
    which wraps calls to Go’s `net/http` package ([Listing 10-4](ch10.xhtml#ch10list4)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从主程序开始。首先，让我们看一下 `head()` HTTP 函数，它封装了对 Go 的 `net/http` 包的调用（[列表 10-4](ch10.xhtml#ch10list4)）。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-4: Creating a* head() *function for Lua (*[/ch-10/lua-core/cmd/scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go)*)*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-4：为 Lua 创建一个* head() *函数 (*[/ch-10/lua-core/cmd/scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go)*)*'
- en: First, notice that your `head()` function accepts a pointer to a `lua.LState`
    object and returns an `int` ❶. This is the expected signature for any function
    you wish to register with the Lua VM. The `lua.LState` type maintains the running
    state of the VM, including any parameters passed in to Lua and returned from Go,
    as you’ll see shortly. Since your return values will be included within the `lua.LState`
    instance, the `int` return type represents the number of values returned. That
    way, your Lua plug-in will be able to read and use the return values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意你的 `head()` 函数接受一个指向 `lua.LState` 对象的指针并返回一个 `int` ❶。这是你希望注册到 Lua 虚拟机中的任何函数的预期签名。`lua.LState`
    类型维护了虚拟机的运行状态，包括传入 Lua 和从 Go 返回的任何参数，稍后你将看到。由于返回值将包含在 `lua.LState` 实例中，`int` 返回类型表示返回的值的数量。这样，你的
    Lua 插件就能够读取并使用这些返回值。
- en: Since the `lua.LState` object, `l`, contains any parameters passed to your function,
    you read the data in via calls to `l.CheckString()` and `l.CheckInt64()` ❷. (Although
    not needed for our example, other `Check*` functions exist to accommodate other
    expected data types.) These functions receive an integer value, which acts as
    the index for the desired parameter. Unlike Go slices, which are 0-indexed, Lua
    is 1-indexed. So, the call to `l.CheckString(1)` retrieves the first parameter
    supplied in the Lua function call, expecting it to be a string. You do this for
    each of your expected parameters, passing in the proper index of the expected
    value. For your `head()` function, you’re expecting Lua to call `head(host, port,
    path)`, where `host` and `path` are strings and `port` is an integer. In a more
    resilient implementation, you’d want to do additional checking here to make sure
    the data supplied is valid.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `lua.LState` 对象 `l` 包含传递给你的函数的所有参数，你可以通过调用 `l.CheckString()` 和 `l.CheckInt64()`
    ❷ 来读取数据。（虽然在我们的示例中不需要，其他 `Check*` 函数也存在，用于处理其他预期的数据类型。）这些函数接收一个整数值，作为期望的参数的索引。与
    Go 的切片不同，Lua 使用的是 1 为基的索引。因此，调用 `l.CheckString(1)` 会获取 Lua 函数调用中传入的第一个参数，并期望它是一个字符串。你会为每个预期的参数这样做，传入正确的索引以获取预期的值。对于
    `head()` 函数，你期望 Lua 调用 `head(host, port, path)`，其中 `host` 和 `path` 是字符串，`port`
    是整数。在更健壮的实现中，你可能需要在这里进行额外的检查，以确保提供的数据有效。
- en: The function proceeds to issue an HTTP HEAD request and perform some error checking.
    In order to return values to your Lua callers, you push the values onto your `lua.LState`
    by calling `l.Push()` and passing it an object that fulfills the `lua.LValue`
    interface type ❸. The `gopher-lua` package contains several types that implement
    this interface, making it as easy as calling `lua.LNumber(0)` and `lua.LBool(false)`,
    for example, to create numerical and boolean return types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接着发出一个 HTTP HEAD 请求并进行一些错误检查。为了将值返回给 Lua 调用者，你通过调用 `l.Push()` 并传入一个符合 `lua.LValue`
    接口类型的对象，将值推送到你的 `lua.LState` 中 ❸。`gopher-lua` 包包含多个实现该接口的类型，使得创建数值和布尔返回类型变得非常简单，例如调用
    `lua.LNumber(0)` 和 `lua.LBool(false)`。
- en: In this example, you’re returning three values. The first is the HTTP status
    code, the second determines whether the server requires basic authentication,
    and the third is an error message. We’ve chosen to set the status code to `0`
    if an error occurs. You then return `3`, which is the number of items you’ve pushed
    onto your `LState` instance ❹. If your call to `http.Head()` doesn’t produce an
    error, you push your return values onto `LState` ❺, this time with a valid status
    code, and then check for basic authentication and return `3` ❻.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你返回三个值。第一个是 HTTP 状态码，第二个决定服务器是否需要基本认证，第三个是错误消息。如果发生错误，我们选择将状态码设置为 `0`。然后，你返回
    `3`，即你推送到 `LState` 实例中的项数 ❹。如果 `http.Head()` 的调用没有产生错误，你将把返回值推送到 `LState` ❺，这次带有有效的状态码，并检查基本认证，最后返回
    `3` ❻。
- en: Creating the get() Function
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 get() 函数
- en: Next, you’ll create your `get()` function, which, like the previous example,
    wraps the `net/http` package’s functionality. In this case, however, you’ll issue
    an HTTP GET request. Other than that, the `get()` function uses fairly similar
    constructs as your `head()` function by issuing an HTTP request to your target
    endpoint. Enter the code in [Listing 10-5](ch10.xhtml#ch10list5).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建 `get()` 函数，类似于之前的示例，它包装了 `net/http` 包的功能。然而，在这个例子中，你将发出一个 HTTP GET
    请求。除此之外，`get()` 函数使用的构造与 `head()` 函数非常相似，都是向目标端点发出 HTTP 请求。输入代码见 [列表 10-5](ch10.xhtml#ch10list5)。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-5: Creating a* get() *function for Lua (*[/ch-10/lua-core/cmd/scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go)*)*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-5：为 Lua 创建一个* get() *函数（*[/ch-10/lua-core/cmd/scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go)*)*'
- en: 'Much like your `head()` implementation, your `get()` function will return three
    values: the status code, a value expressing whether the system you’re trying to
    access requires basic authentication, and any error messages. The only real difference
    between the two functions is that your `get()` function accepts two additional
    string parameters: a username and a password ❶. If either of these values is set
    to a non-empty string, you’ll assume you have to perform basic authentication.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `head()` 实现一样，`get()` 函数将返回三个值：状态码、一个表示目标系统是否需要基本认证的值，以及任何错误消息。两者之间唯一的实际区别是，`get()`
    函数接受两个额外的字符串参数：用户名和密码 ❶。如果这两个值中的任何一个被设置为非空字符串，你将假设需要进行基本认证。
- en: Now, some of you are probably thinking that the implementations are oddly specific,
    almost to the point of negating any flexibility, reusability, and portability
    of a plug-in system. It’s almost as if these functions were designed for a very
    specific use case—that is, to check for basic authentication—rather than for a
    general purpose. After all, why wouldn’t you return the response body or the HTTP
    headers? Likewise, why wouldn’t you accept more robust parameters to set cookies,
    other HTTP headers, or issue POST requests with a body, for example?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你们中的一些人可能会觉得这些实现非常具体，几乎到了消除插件系统灵活性、可重用性和可移植性的程度。它们几乎是为一个非常特定的用例设计的——即检查基本认证——而不是为了通用目的。毕竟，为什么不返回响应体或
    HTTP 头呢？同样，为什么不接受更多的参数来设置 cookies、其他 HTTP 头，或者发送带有请求体的 POST 请求呢？
- en: '*Simplicity* is the answer. Your implementations can act as a starting point
    for building a more robust solution. However, creating that solution would be
    a more significant endeavor, and you’d likely lose the code’s purpose while trying
    to navigate implementation details. Instead, we’ve chosen to do things in a more
    basic, less flexible fashion to make the general, foundational concepts simpler
    to understand. An improved implementation would likely expose complex user-defined
    types that better represent the entirety of, for example, the `http.Request` and
    `http.Response` types. Then, rather than accepting and returning multiple parameters
    from Lua, you could simplify your function signatures, reducing the number of
    parameters you accept and return. We encourage you to work through this challenge
    as an exercise, changing the code to accept and return user-defined `structs`
    rather than primitive types.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*简洁性* 是答案。你的实现可以作为构建更强大解决方案的起点。然而，创建该解决方案将是一项更为复杂的工作，而且在尝试解决实现细节时，你很可能会失去代码的初衷。相反，我们选择以一种更基础、更少灵活的方式来处理，从而让一般的、基础的概念更易于理解。改进后的实现可能会暴露出更复杂的用户定义类型，这些类型能够更好地表示例如
    `http.Request` 和 `http.Response` 类型的整体。然后，你可以简化函数签名，而不是接受和返回多个参数，减少你接受和返回的参数数量。我们鼓励你通过这个挑战来练习，将代码修改为接受和返回用户定义的
    `structs`，而不是基本类型。'
- en: Registering the Functions with the Lua VM
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注册函数到 Lua 虚拟机
- en: Up to this point, you’ve implemented wrapper functions around the necessary
    `net/http` calls you intend to use, creating the functions so `gopher-lua` can
    consume them. However, you need to actually register the functions with the Lua
    VM. The function in [Listing 10-6](ch10.xhtml#ch10list6) centralizes this registration
    process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经实现了围绕你打算使用的必要`net/http`调用的包装函数，创建了这些函数以便 `gopher-lua` 可以使用它们。然而，你需要实际将这些函数注册到
    Lua 虚拟机中。[清单 10-6](ch10.xhtml#ch10list6) 中的函数集中处理了这个注册过程。
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10-6: Registering plug-ins with Lua (*[/ch-10/lua-core/cmd/scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go)*)*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6：将插件注册到 Lua (*[/ch-10/lua-core/cmd/scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go)*)*'
- en: You start by defining a constant that will uniquely identify the namespace you’re
    creating in Lua ❶. In this case, you’ll use `http` because that’s essentially
    the functionality you’re exposing. In your `register()` function, you accept a
    pointer to a `lua.LState`, and use that namespace constant to create a new Lua
    type via a call to `l.NewTypeMetatable()` ❷. You’ll use this metatable to track
    types and functions available to Lua.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你从定义一个常量开始，该常量将唯一标识你在 Lua 中创建的命名空间 ❶。在这种情况下，你将使用 `http`，因为这本质上是你暴露的功能。在你的 `register()`
    函数中，你接受一个指向 `lua.LState` 的指针，并使用该命名空间常量通过调用 `l.NewTypeMetatable()` ❷ 创建一个新的 Lua
    类型。你将使用这个元表来跟踪可供 Lua 使用的类型和函数。
- en: You then register a global name, `http`, on the metatable ❸. This makes the
    `http` implicit package name available to the Lua VM. On the same metatable, you
    also register two fields by using calls to `l.SetField()` ❹. Here, you define
    two static functions named `head()` and `get()`, available on the `http` namespace.
    Since they’re static, you can call them via `http.get()` and `http.head()` without
    having to create an instance of type `http` in Lua.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你在元表 ❸ 上注册了一个全局名称 `http`。这使得 `http` 隐式包名对 Lua 虚拟机可用。在同一个元表上，你还通过调用 `l.SetField()`
    ❹ 注册了两个字段。在这里，你定义了两个静态函数，分别命名为 `head()` 和 `get()`，它们可以在 `http` 命名空间下使用。由于它们是静态的，你可以通过
    `http.get()` 和 `http.head()` 来调用它们，而无需在 Lua 中创建 `http` 类型的实例。
- en: As you may have noted in the `SetField()` calls, the third parameter is the
    destination function that’ll handle the Lua calls. In this case, those are your
    `get()` and `head()` functions you previously implemented. These are wrapped in
    a call to `l.NewFunction()`, which accepts a function of form `func(*LState) int`,
    which is how you defined your `get()` and `head()` functions. They return a `*lua.LFunction`.
    This might be a little overwhelming, since we’ve introduced a lot of data types
    and you’re probably unfamiliar with `gopher-lua`. Just understand that this function
    is registering the global namespace and function names and creating mappings between
    those function names and your Go functions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 `SetField()` 调用中注意到的，第三个参数是处理 Lua 调用的目标函数。在这种情况下，它们是你之前实现的 `get()` 和 `head()`
    函数。这些函数被包装在 `l.NewFunction()` 调用中，它接受一个 `func(*LState) int` 形式的函数，这也是你定义 `get()`
    和 `head()` 函数的方式。它们返回一个 `*lua.LFunction`。这可能有点令人困惑，因为我们引入了很多数据类型，并且你可能不熟悉 `gopher-lua`。只需理解，这个函数正在注册全局命名空间和函数名，并在这些函数名和你的
    Go 函数之间创建映射。
- en: Writing Your Main Function
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写你的主函数
- en: Lastly, you’ll need to create your `main()` function, which will coordinate
    this registration process and execute the plug-in ([Listing 10-7](ch10.xhtml#ch10list7)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要创建 `main()` 函数，它将协调这个注册过程并执行插件 ([清单 10-7](ch10.xhtml#ch10list7))。
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 10-7: Registering and calling Lua plug-ins (*[/ch-10/lua-core/cmd/scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go)*)*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-7：注册和调用 Lua 插件 (*[/ch-10/lua-core/cmd/scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go)*)*'
- en: As you did for your `main()` function in the Go example, you’ll hardcode the
    directory location from which you’ll load your plug-ins ❶. In your `main()` function,
    you issue a call to `lua.NewState()` ❷ to create a new `*lua.LState` instance.
    The `lua.NewState()` instance is the key item you’ll need to set up your Lua VM,
    register your functions and types, and execute arbitrary Lua scripts. You then
    pass that pointer to the `register()` function you created earlier ❸, which registers
    your custom `http` namespace and functions on the state. You read the contents
    of your plug-ins directory ❹, looping through each file in the directory ❺. For
    each file, you call `l.DoFile(f)` ❻, where `f` is the absolute path to the file.
    This call executes the contents of the file within the Lua state on which you
    registered your custom types and functions. Basically, `DoFile()` is `gopher-lua`’s
    way of allowing you to execute entire files as if they were stand-alone Lua scripts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 Go 示例中的 `main()` 函数那样，你将硬编码加载插件的目录位置 ❶。在你的 `main()` 函数中，你调用 `lua.NewState()`
    ❷ 来创建一个新的 `*lua.LState` 实例。这个 `lua.NewState()` 实例是你设置 Lua 虚拟机、注册函数和类型、执行任意 Lua
    脚本所需的关键项目。然后你将该指针传递给你之前创建的 `register()` 函数 ❸，它会在状态中注册你自定义的 `http` 命名空间和函数。你接着读取插件目录的内容
    ❹，并遍历目录中的每个文件 ❺。对于每个文件，你调用 `l.DoFile(f)` ❻，其中 `f` 是文件的绝对路径。此调用会在你注册了自定义类型和函数的
    Lua 状态中执行该文件的内容。基本上，`DoFile()` 是 `gopher-lua` 允许你像执行独立的 Lua 脚本一样执行整个文件的方式。
- en: Creating Your Plug-in Script
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建你的插件脚本
- en: Now let’s take a look at your Tomcat plug-in script, written in Lua ([Listing
    10-8](ch10.xhtml#ch10list8)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看你的 Tomcat 插件脚本，它是用 Lua 编写的 ([清单 10-8](ch10.xhtml#ch10list8))。
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-8: A Lua plug-in for Tomcat password guessing (*[/ch-10/lua-core/plugins/tomcat.lua](https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/plugins/tomcat.lua)*)*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-8：Tomcat 密码猜测的 Lua 插件 (*[/ch-10/lua-core/plugins/tomcat.lua](https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/plugins/tomcat.lua)*)*'
- en: Don’t worry too much about the vulnerability-checking logic. It’s essentially
    the same as the logic you created in the Go version of this plug-in; it performs
    basic password guessing against the Tomcat Manager portal after it fingerprints
    the application by using a HEAD request. We’ve highlighted the two most interesting
    items.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不必太担心漏洞检查的逻辑。它本质上与 Go 版本插件中你创建的逻辑相同；它在使用 HEAD 请求指纹识别应用程序后，针对 Tomcat Manager
    门户执行基本的密码猜测。我们突出了两个最有趣的项目。
- en: The first is a call to `http.head("10.0.1.20", 8080, "/manager/html")` ❶. Based
    off your global and field registrations on the state metatable, you can issue
    a call to a function named `http.head()` without receiving a Lua error. Additionally,
    you’re supplying the call with the three parameters your `head()` function expected
    to read from the `LState` instance. The Lua call is expecting three return values,
    which align with the numbers and types you pushed onto the `LState` before you
    exited the Go function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是对`http.head("10.0.1.20", 8080, "/manager/html")`的调用❶。根据你在状态元表上的全局和字段注册，你可以调用名为`http.head()`的函数而不会收到Lua错误。此外，你向调用中传递了`head()`函数从`LState`实例中读取的三个参数。Lua调用期望三个返回值，这与在退出Go函数之前推送到`LState`上的数字和类型相匹配。
- en: The second item is your call to `http.get()` ❷, which is similar to the `http.head()`
    function call. The only real difference is that you are passing username and password
    parameters to the `http.get()` function. If you refer back to the Go implementation
    of your `get()` function, you’ll see that we’re reading these two additional strings
    from the `LState` instance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二项是对`http.get()`的调用❷，这与`http.head()`函数调用类似。唯一的真正区别是你传递了用户名和密码参数给`http.get()`函数。如果你回顾一下`get()`函数的Go实现，你会发现我们从`LState`实例中读取了这两个附加的字符串。
- en: Testing the Lua Plug-in
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试Lua插件
- en: 'This example isn’t perfect and could benefit from additional design considerations.
    But as with most adversarial tools, the most important thing is that it works
    and solves a problem. Running your code proves that it does, indeed, work as expected:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并不完美，还可以通过更多的设计考虑来改进。但和大多数对抗工具一样，最重要的是它能工作并解决问题。运行你的代码证明它确实按预期工作：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that you have a basic working example, we encourage you to improve the design
    by implementing user-defined types so that you aren’t passing lengthy lists of
    arguments and parameters to and from functions. With this, you’ll likely need
    to explore registering instance methods on your struct, whether for setting and
    getting values in Lua or for calling methods on a specifically implemented instance.
    As you work through this, you’ll notice that your code will get significantly
    more complex, since you’ll be wrapping a lot of your Go functionality in a Lua-friendly
    manner.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个基本的工作示例，我们鼓励你通过实现用户定义的类型来改进设计，这样你就不会在函数之间传递冗长的参数和参数列表了。这样，你可能需要探索在结构体上注册实例方法，无论是为了在Lua中设置和获取值，还是为了在特定实现的实例上调用方法。在此过程中，你会注意到你的代码会变得显著复杂，因为你会以Lua友好的方式封装大量Go的功能。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: As with many design decisions, there are multiple ways to skin a cat. Whether
    you’re using Go’s native plug-in system or an alternative language like Lua, you
    must consider trade-offs. But regardless of your approach, you can easily extend
    Go to make rich security frameworks, particularly since the addition of its native
    plug-in system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多设计决策一样，总有多种方法可以实现目标。无论是使用Go的本地插件系统，还是像Lua这样的替代语言，你都必须考虑权衡。无论你采取哪种方法，你都可以轻松扩展Go来构建丰富的安全框架，特别是自从其本地插件系统的加入之后。
- en: In the next chapter, you’ll tackle the rich topic of cryptography. We’ll demonstrate
    various implementations and use cases, and then build an RC2 symmetric-key brute-forcer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将深入探讨密码学这一丰富的话题。我们将展示各种实现和使用案例，然后构建一个RC2对称密钥暴力破解工具。
