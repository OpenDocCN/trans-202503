- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">COMPOUND
    DATA TYPES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">复合数据类型</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: In the previous chapter we discussed JavaScript’s primitive data types, which
    represent a single piece of data, like a number or a string. Now we’ll look at
    JavaScript’s *compound data types*, arrays and objects, which combine multiple
    pieces of data into a single unit. Compound data types are an essential part of
    programming because they allow us to organize and work with collections of data
    of any size. You’ll learn how to create and manipulate arrays and objects, and
    how to combine them into more complex data structures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了JavaScript的原始数据类型，它们代表单一的数据项，比如数字或字符串。现在我们将了解JavaScript的*复合数据类型*，即数组和对象，它们将多个数据项组合成一个单元。复合数据类型是编程中不可或缺的一部分，因为它们使我们能够组织和处理任意大小的数据集合。你将学习如何创建和操作数组与对象，并如何将它们组合成更复杂的数据结构。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arrays</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">数组</samp>
- en: A JavaScript *array* is a compound data type that holds an ordered list of values.
    The elements of an array can be of any data type. They don’t all have to be the
    same type, although they typically are. For instance, an array might function
    as a to-do list by holding a series of strings describing tasks that need to be
    performed, or it might hold a collection of numbers representing temperature readings
    taken at regular intervals from a particular location.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的*数组*是一种复合数据类型，用于存储有序的值列表。数组的元素可以是任何数据类型，它们不必全是相同的类型，尽管它们通常是。例如，一个数组可以作为待办事项清单，存储一系列描述需要完成的任务的字符串，或者它也可以存储一个数字集合，表示从特定位置定期测量的温度读数。
- en: Arrays are perfect for these sorts of structures because they collect the related
    values together in one place, and they have the flexibility to grow and shrink
    as values are added or removed. If you had a fixed number of to-do items—say,
    four—then you might use separate variables to hold them, but using an array enables
    you to hold an unbounded, changing number of items and keep them in a fixed order.
    Also, once you have your elements together in a single array, you can write code
    to efficiently operate on each item in the array in turn, as you’ll see in [Chapter
    4](chapter4.xhtml).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数组非常适合这些结构，因为它们将相关的值集合在一起，并且随着值的增加或删除，它们具有增长和缩小的灵活性。如果你有固定数量的待办事项——比如四个——你可能会使用单独的变量来存储它们，但使用数组可以让你存储一个无限、可变化的项目数，并保持它们的固定顺序。此外，一旦将元素聚集在一个数组中，你就可以编写代码，高效地依次操作数组中的每个项目，正如你将在[第4章](chapter4.xhtml)中看到的那样。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creation and Indexing</samp>
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建与索引</samp>
- en: 'To create an array, list its elements separated by commas inside a pair of
    square brackets:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个数组，将其元素用逗号分隔，并放在一对方括号内：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This array contains the first eight prime numbers and is stored in the primes
    variable. When you enter primes; the Chrome console should print the length of
    the array (8) followed by its elements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组包含了前八个素数，并存储在primes变量中。当你输入primes;时，Chrome控制台应该会打印出数组的长度（8），后面跟着它的元素。
- en: 'Every element in an array has an index number associated with it. Like strings,
    arrays are zero-indexed, so the first element is found at index 0, the second
    at index 1, and so on. To access an individual element of an array, place its
    index number in square brackets after the name of the array. Here, for example,
    we access the first element of the primes array:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的每个元素都有一个与之关联的索引号。像字符串一样，数组是零索引的，因此第一个元素位于索引0，第二个元素位于索引1，依此类推。要访问数组中的单个元素，可以在数组名称后加上其索引号并用方括号括起来。例如，这里我们访问了primes数组的第一个元素：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Because arrays are zero-indexed, the index of the last element of the array
    is one less than the array’s length. So, the last element of our eight-element
    primes array is at index 7:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组是零索引的，所以数组最后一个元素的索引比数组的长度少1。因此，我们八个元素的primes数组的最后一个元素位于索引7：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you don’t know how long an array is and you want to get its last element,
    you can first use dot notation to access its length property and look up the array’s
    length, as we did with strings in [Chapter 2](chapter2.xhtml):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道数组的长度，并且想要获取它的最后一个元素，可以先使用点符号访问其length属性，并查看数组的长度，就像我们在[第2章](chapter2.xhtml)中操作字符串一样：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or, to do this in a single statement, you can simply subtract 1 from the length
    to get the element at the last index, like so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了在一个语句中做到这一点，你可以简单地从长度中减去1来获取最后一个索引处的元素，像这样：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you use an index outside the range of the array, JavaScript returns undefined:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了超出数组范围的索引，JavaScript将返回undefined：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To replace an element in an array, assign the element a new value using indexing
    syntax:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个元素，可以使用索引语法为元素赋予一个新值：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we add a 1 in the third position (index 2) of primes, replacing the value
    that was previously at that index. The console output confirms that 1 is the new
    third element in the array.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们在质数数组的第三个位置（索引2）添加了一个1，替换了之前在该索引位置的值。控制台输出确认1是数组的新第三个元素。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arrays of Arrays</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数组的数组</samp>
- en: 'Arrays can contain other arrays. These *multidimensional arrays* are often
    used to represent two-dimensional grids of points, or tables. To illustrate this,
    let’s make a simple tic-tac-toe game. We’ll create an array (we’ll call this the
    *outer* array) containing three elements, each of which is another array (we’ll
    call these the *inner* arrays) representing one of the rows of the tic-tac-toe
    board. Each inner array will contain three empty strings to represent the squares
    within that row:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以包含其他数组。这些*多维数组*通常用于表示二维点阵或表格。为了说明这一点，让我们制作一个简单的井字游戏。我们将创建一个数组（我们将其称为*外部*数组），其中包含三个元素，每个元素都是另一个数组（我们将这些称为*内部*数组），代表井字棋盘的每一行。每个内部数组将包含三个空字符串，表示该行中的方格：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In order to make the code easier to read, I’ve put each inner array on a new
    line. Usually when you press ENTER (commonly to start a new line), the JavaScript
    console will run the line of code you just entered, but in this case, it’s clever
    enough to realize that the first line isn’t finished, because there’s no closing
    square bracket to match the opening bracket. It will interpret everything up to
    the final closing bracket and semicolon as a single statement, even if you include
    additional brackets and carriage returns.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更易读，我将每个内部数组放在了新的一行。通常，当你按下ENTER（通常是为了开始新的一行）时，JavaScript控制台会运行你刚刚输入的代码行，但在这种情况下，它足够聪明，能够意识到第一行没有完成，因为没有关闭的方括号来匹配开括号。它会将直到最后一个闭括号和分号的所有内容解释为一个单一语句，即使你包含了额外的括号和回车符。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The Chrome console automatically applies indentation to the inner arrays,
    to indicate that they’re nested inside the outer array. Chrome and VS Code by
    default use four spaces for each level of indentation, but this is a matter of
    personal preference. Throughout this book I’ll be using two spaces for indentation,
    both because this is more common in modern JavaScript code and because it helps
    some of the bigger listings fit on the page.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chrome控制台自动为内部数组应用缩进，以表明它们嵌套在外部数组中。Chrome和VS Code默认为每一层缩进使用四个空格，但这只是个人偏好的问题。在本书中，我将使用两个空格进行缩进，因为这在现代JavaScript代码中更为常见，也因为它能帮助一些较长的代码更好地适应页面。*'
- en: 'I could have written this array on one line, as shown here, but this way it’s
    harder to see its two-dimensionality:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以将这个数组写在一行中，如此显示，但这样更难看出它的二维结构：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let’s see what happens when we ask the console for the value of the ticTacToe
    variable:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看当我们请求控制台输出ticTacToe变量的值时会发生什么：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, the length of the outer array is shown as (3), indicating that
    it’s an array with three elements. Each element of the array is Array(3), which
    means each inner array is another three-element array.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，外部数组的长度显示为（3），表示它是一个包含三个元素的数组。数组的每个元素是Array(3)，这意味着每个内部数组是另一个包含三个元素的数组。
- en: 'To expand the view and see what’s in those inner arrays, click the arrow on
    the left:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展开视图并查看内部数组中的内容，点击左侧的箭头：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first three lines show the values of the inner arrays at indexes 0, 1, and
    2. After these, the outer array’s length property is shown, with its value of
    3. The final property, [[Prototype]], is where the array’s built-in methods come
    from (more on this in [Chapter 6](chapter6.xhtml)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行显示了索引为0、1和2的内部数组的值。在这些之后，显示了外部数组的长度属性，值为3。最后的属性[[Prototype]]，是数组内置方法的来源（更多内容请参见[第6章](chapter6.xhtml)）。
- en: 'We’ve created our tic-tac-toe board, but it’s empty. Let’s set an X in the
    top-right corner. The first inner array represents the top row; we access it with
    ticTacToe[0]. The top-right corner is the third element of that row, or index
    2 of the inner array. Because ticTacToe[0] returns an array, we can just add [2]
    on the end to access the element we want: ticTacToe[0][2]. Knowing this, we can
    set this element to "X" as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了井字棋棋盘，但它是空的。让我们在右上角设置一个X。第一个内部数组代表的是上排，我们可以通过ticTacToe[0]来访问它。右上角是这一行的第三个元素，或者说是内部数组的索引2。由于ticTacToe[0]返回的是一个数组，我们只需在后面加上[2]来访问我们想要的元素：ticTacToe[0][2]。知道这一点后，我们可以按如下方式将这个元素设置为"X"：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let’s look at the value of ticTacToe again, clicking the arrow to expand
    the outer array:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次查看ticTacToe的值，点击箭头展开外部数组：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The top-right corner of the tic-tac-toe board now contains an X.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋的右上角现在包含一个X。
- en: 'Next, let’s set an O in the bottom-left corner. The bottom row is index 2 of
    the outer array, and the leftmost square of that row is index 0 of the inner array,
    so we enter the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在左下角设置一个O。底行是外部数组的索引2，这一行最左边的方格是内部数组的索引0，所以我们输入如下内容：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now there’s an O in the bottom-left corner of the board.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，板子的左下角有一个O。
- en: To summarize, if you want to access an element in a nested array, use one set
    of square brackets to select the element in the outer array (which returns one
    of the inner arrays), then a second set to select the element in the inner array.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，如果你想访问嵌套数组中的元素，可以使用一组方括号来选择外部数组中的元素（这会返回其中一个内部数组），然后再用第二组方括号选择内部数组中的元素。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Methods</samp>
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数组方法</samp>
- en: JavaScript has several useful methods for working with arrays. We’ll look at
    a few important ones in this section. Some of these methods modify the array in
    question, which is known as *mutation*. Example mutations include adding or deleting
    array elements, or changing the elements’ order. Other methods create and return
    a new array while leaving the original array unchanged, which is useful if you
    still need the original array for other purposes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有几个用于处理数组的有用方法。在本节中，我们将看一些重要的方法。这些方法中的一些会修改目标数组，这被称为*变异*。变异的示例包括添加或删除数组元素，或改变元素的顺序。其他方法则创建并返回一个新的数组，同时保持原始数组不变，这在你还需要原始数组用于其他目的时非常有用。
- en: It’s important to be aware of whether or not the method you’re using will mutate
    the array. For example, say you have an array containing the months of the year
    listed chronologically, but one part of your program needs them in alphabetical
    order. You’d want to be sure that alphabetizing the months doesn’t inadvertently
    change the original, chronological array, or other parts of your program might
    start thinking April is the first month of the year. On the other hand, if you
    have an array representing a to-do list, you’d probably want the original array
    itself to be updated when a task is added or removed, rather than creating a new
    array.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，你使用的方法是否会改变数组。例如，假设你有一个包含按顺序列出月份的数组，但你程序的某一部分需要按字母顺序排列这些月份。你需要确保将月份按字母顺序排列时，不会无意中改变原始的按顺序排列的数组，否则程序的其他部分可能会误认为四月是第一个月。另一方面，如果你有一个表示待办事项的数组，当添加或删除任务时，你可能希望更新原始数组，而不是创建一个新的数组。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding an Element to an Array</samp>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">向数组添加元素</samp>
- en: 'The push method mutates an array by adding a supplied element to the end of
    the array. The return value of the push method is the new length of the array.
    As an example, let’s use push to build up an array of programming languages:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: push方法通过将提供的元素添加到数组的末尾来改变数组。push方法的返回值是数组的新长度。举个例子，让我们用push来构建一个编程语言的数组：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First we create a new array called languages and initialize it with [], an empty
    array. The first time we call the push method, we pass the value "Python". The
    method returns 1, which means there’s now one element in the array. We do this
    three more times, and finally ask for the value of languages by entering languages;.
    This returns the four languages we added to the array, in the order we added them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为languages的新数组，并用[]（一个空数组）初始化它。第一次调用push方法时，我们传入值"Python"。该方法返回1，表示数组中现在有一个元素。我们再做三次相同的操作，最后通过输入languages;来查看languages的值。这将返回我们按顺序添加到数组中的四个编程语言。
- en: 'To add an element to the beginning of the array rather than the end, use the
    unshift method, like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将元素添加到数组的开头而不是末尾，请使用 `unshift` 方法，如下所示：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we’ve added three more languages to the front of the languages array. Because
    each element is added to the beginning of the array, they end up in the opposite
    order to how they were added. Like push, calling unshift returns the new length
    of the array.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们向 languages 数组的开头添加了三个语言。因为每个元素都被添加到数组的开头，它们最终的顺序与添加时的顺序相反。像 `push` 一样，调用
    `unshift` 会返回数组的新长度。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Removing Elements from an
    Array</samp>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">从数组中移除元素</samp>
- en: 'To mutate an array by removing its last element, use the pop method. Here we
    call the pop method on the languages array, deleting its last element:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过移除数组的最后一个元素来改变数组，请使用 `pop` 方法。这里我们在 languages 数组上调用 `pop` 方法，删除它的最后一个元素：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The method returns the value of the element being removed, in this case "Rust".
    When we then check the array, it contains only six elements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回被移除元素的值，在此例中为“Rust”。当我们检查数组时，它只包含六个元素。
- en: 'Because the pop method returns the array element being removed, it’s particularly
    useful if you want to do something with that element as you’re removing it. For
    example, here we delete another element from the languages array and use it in
    a message:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `pop` 方法返回被移除的数组元素，所以如果你在移除元素时想要对其进行操作，它特别有用。例如，这里我们从 languages 数组中删除另一个元素，并在消息中使用它：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This time when we call languages.pop() we store the method’s return value in
    the bestLanguage variable, which we incorporate into a string using a template
    literal. When we print the resulting message, it includes the word *JavaScript*.
    This was the element removed from the array, which is now down to five languages.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们调用 `languages.pop()` 时，将方法的返回值存储在 bestLanguage 变量中，并使用模板字面量将其嵌入到字符串中。当我们打印结果消息时，它包含了
    *JavaScript* 这个单词。这个元素是从数组中移除的，现在数组只剩下五个语言。
- en: 'To remove the *first* element from an array, rather than the last, use the
    shift method. Like pop, the shift method returns the removed element:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 若要移除数组中的*第一个*元素，而不是最后一个元素，请使用 `shift` 方法。像 `pop` 一样，`shift` 方法返回被移除的元素：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As with the previous example, we save the result of calling shift in a variable,
    this time called worstLanguage, and use it in a template literal. This variable
    contains the string "Fortran", and languages is left with four elements.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的例子一样，我们将调用 `shift` 的结果保存到一个变量中，这次叫做 worstLanguage，并将其用于模板字面量中。该变量包含字符串“Fortran”，而
    languages 数组剩下四个元素。
- en: The four methods we’ve looked at so far, pop, unshift, push, and shift, are
    commonly used to implement more specialized data structures, like queues. A *queue*
    is a data structure that resembles a line of people, where new items are added
    to the end and items are removed and processed from the beginning. This is useful
    when you want to process data in the order it arrives. For example, imagine a
    Q and A app, where many users can ask questions. You could use an array to store
    the list of questions, with the push method adding each new question to the end
    of the array. When the answerer is ready to answer a question, they would use
    shift to get the first element in the array and remove it from the array. This
    ensures that only unanswered questions are in the array, and that they’re answered
    in the order they were received.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们查看过的四种方法，`pop`、`unshift`、`push` 和 `shift`，通常用于实现更专业的数据结构，如队列。*队列*是一种数据结构，类似于排队的人群，新项被添加到队列的末尾，而项则从队列的开头被移除和处理。这在你需要按照到达顺序处理数据时非常有用。例如，想象一个问答应用，很多用户可以提问。你可以使用一个数组来存储问题列表，`push`
    方法将每个新问题添加到数组的末尾。当回答者准备好回答问题时，他们可以使用 `shift` 方法获取数组中的第一个元素并将其移除。这样可以确保数组中只有未回答的问题，并且它们会按照收到的顺序进行回答。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Combining Arrays</samp>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">合并数组</samp>
- en: 'The concat method (short for *concatenate*) adds two arrays together. Here,
    for example, we start with two arrays, fish and mammals, and combine them into
    a new array, saving that into the animals variable:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat` 方法（*连接*的缩写）将两个数组合并在一起。例如，这里我们从两个数组 `fish` 和 `mammals` 开始，并将它们合并成一个新数组，然后将其保存到
    `animals` 变量中：'
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When you call concat on an array, a new array is created with all the elements
    from the first array (the array on which you called concat) followed by all the
    elements from the second array (the array passed as an argument to concat). The
    original arrays remain unchanged because, unlike the other methods we’ve looked
    at so far, concat isn’t a mutating method. This is useful here, because we wouldn’t
    want our fish array to suddenly contain the elements from mammals!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在一个数组上调用 concat 时，会创建一个新数组，其中包含第一个数组（你调用 concat 的数组）中的所有元素，接着是第二个数组（作为参数传递给
    concat 的数组）中的所有元素。原始数组保持不变，因为与我们迄今为止看到的其他方法不同，concat 并不是一个改变原数组的方法。这在这里非常有用，因为我们不希望我们的鱼类数组突然包含哺乳动物的元素！
- en: 'To combine three or more arrays, pass multiple arrays as arguments to concat,
    as in this example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要将三个或更多数组合并，传递多个数组作为 concat 的参数，如这个例子所示：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we create three separate arrays, originals, prequels, and sequels, representing
    the three sets of *Star Wars* movies. Then we use concat to combine them into
    a single nine-element starWars array. Notice that the elements in the combined
    array appear in the order in which the arrays were passed as arguments.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了三个单独的数组：originals、prequels 和 sequels，代表三套*星球大战*电影。然后，我们使用 concat 将它们合并成一个包含九个元素的
    starWars 数组。注意，合并后的数组中的元素按传递数组作为参数的顺序出现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Finding the Index of an Element
    in an Array</samp>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">查找数组中元素的索引</samp>
- en: 'To find out where a particular element is in an array, use the indexOf method.
    This method returns the index of the first occurrence of the specified element.
    If the element isn’t found in the array, indexOf returns -1:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出数组中某个特定元素的位置，可以使用 indexOf 方法。该方法返回指定元素第一次出现的索引。如果元素在数组中没有找到，indexOf 返回 -1：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we want to check the position of "Medium" in the sizes array,
    and we get back the answer 1. Then, because "Huge" isn’t in the array, we get
    the answer -1.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们要检查 "Medium" 在 sizes 数组中的位置，并且得到了答案 1。然后，因为 "Huge" 不在数组中，我们得到了答案 -1。
- en: 'If the array contains multiple instances of the given value, indexOf returns
    the index of the first matching element only. For example, here’s an array with
    the colors of the flag of Argentina:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组包含多个指定值的实例，indexOf 只会返回第一个匹配元素的索引。例如，这里有一个包含阿根廷国旗颜色的数组：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Even though "Blue" is found twice in the array, indexOf returns only the index
    of the first occurrence.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 "Blue" 在数组中出现了两次，indexOf 只会返回第一次出现的索引。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Turning an Array into a String</samp>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将数组转换为字符串</samp>
- en: 'The join method converts an array into a single string, joining all the elements
    together, as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: join 方法将一个数组转换成一个单一的字符串，将所有元素连接在一起，如下所示：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice how the separate strings in the beatles array are combined into one
    string. By default, join places a comma between each element to form the returned
    string. To change this, you can give your own separator as an argument to join.
    For example, if you want nothing in between each element, pass an empty string
    as an argument:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，beatles 数组中的独立字符串如何合并成一个字符串。默认情况下，join 会在每个元素之间放置一个逗号来形成返回的字符串。要更改这一点，你可以将你自己的分隔符作为参数传递给
    join。例如，如果你希望元素之间没有任何内容，可以传递一个空字符串作为参数：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can pass any valid string as a separator. In the next example, we pass
    a space, an ampersand, and a newline escape character to set each element on its
    own line. As you learned in [Chapter 2](chapter2.xhtml), we have to use console.log
    for the newlines to display correctly in Chrome:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以传递任何有效的字符串作为分隔符。在下一个例子中，我们传递一个空格、一个与号和一个换行符转义字符，将每个元素放在自己的行上。正如你在[第二章](chapter2.xhtml)中学到的那样，我们必须使用
    console.log 才能在 Chrome 中正确显示换行符：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Keep in mind that the separator appears only *between* array elements, not after
    each one. This is why there isn’t an extra ampersand and newline after Ringo.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，分隔符只出现在数组元素*之间*，而不是每个元素后面。这就是为什么在 Ringo 后面没有额外的与号和换行符。
- en: 'If you use join on an array containing non-string values, those values will
    be converted to strings, as in this example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对包含非字符串值的数组使用 join，这些值会被转换为字符串，正如这个例子所示：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As with the previous joins, the result is one long string, joined together by
    the separator (in this case, " - "). The difference is that the non-string values
    (the number 100 and the Booleans true and false) had to be automatically converted
    to strings before the join. This example also shows how you can call array methods
    directly on array literals, rather than having to save the array into a variable
    first.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的连接方法一样，结果是一个由分隔符（在本例中为 " - "）连接起来的长字符串。不同之处在于，非字符串值（例如数字 100 和布尔值 true 和
    false）在连接之前必须自动转换为字符串。这个例子还展示了如何可以直接在数组字面量上调用数组方法，而无需先将数组保存到变量中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Other Useful Array Methods</samp>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">其他有用的数组方法</samp>
- en: 'Here are some other useful array methods you might want to try out:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可能想尝试的其他有用的数组方法：
- en: arr.includes(elem)    Returns true or false depending on whether a given elem
    is in the arr array.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: arr.includes(elem)    根据给定的 elem 是否在 arr 数组中，返回 true 或 false。
- en: arr.reverse()    Reverses the order of elements in the array. This is a mutating
    method, so it modifies the original array.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: arr.reverse()    反转数组中元素的顺序。这是一个变异方法，因此会修改原始数组。
- en: arr.sort()    Sorts the array elements, modifying the original array. If the
    elements are strings, they’re sorted in alphabetical order. Otherwise, the sorting
    happens as if the elements were converted to strings.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: arr.sort()    对数组元素进行排序，修改原数组。如果元素是字符串，它们会按字母顺序排序。否则，排序会像将元素转换为字符串后进行排序一样。
- en: arr.slice(start, end)    Creates a new array by extracting elements from the
    original array starting at index start, up to but not including index end. This
    method is equivalent to the slice method on strings, introduced in the previous
    chapter. If you call slice() without any arguments, the entire array is copied
    into a new array. This is useful if you need to use a mutating method like sort
    but you don’t want to mutate the original array.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: arr.slice(start, end)    通过从原数组中提取从索引 start 开始到索引 end 之前的元素来创建一个新数组。此方法等同于上一章介绍的字符串的
    slice 方法。如果调用 slice() 时不带任何参数，则会将整个数组复制到一个新数组中。如果你需要使用像 sort 这样的变异方法，但又不想修改原数组，这个方法会很有用。
- en: arr.splice(index, count)    Removes count elements from the array, starting
    at index.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: arr.splice(index, count)    从数组中删除从索引 index 开始的 count 个元素。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Objects</samp>
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">对象</samp>
- en: '*Objects* are another compound data type in JavaScript. They’re similar to
    arrays in that they hold a collection of values, but they differ in that objects
    use strings called *keys* instead of numeric indices to access the values. Each
    key is associated with a specific value, forming a *key-value pair*.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象*是 JavaScript 中的另一种复合数据类型。它们与数组类似，都是用来存储一组值，但不同之处在于，对象使用称为 *键* 的字符串来访问值，而不是数字索引。每个键都与一个特定的值关联，形成一个
    *键值对*。'
- en: Whereas arrays are commonly used to store ordered lists of elements of the same
    data type, objects are usually used to store multiple pieces of information about
    a single entity. These pieces of information often are not all of the same data
    type. For example, an object representing a person might hold information like
    the person’s name (a string), their age (a number), whether or not they’re married
    (a Boolean), and so on. Objects are better suited for this purpose than arrays
    because each piece of information is given a meaningful name—its key—rather than
    a generic index number. It’s much clearer what the values 35 and true mean if
    they’re stored in a person object under the keys "age" and "married" than it would
    be if they were stored in a person array under the indices 1 and 2.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 数组通常用于存储相同数据类型的有序元素列表，而对象通常用于存储关于单一实体的多个信息。这些信息通常并非全部是相同的数据类型。例如，表示一个人的对象可能包含该人的姓名（字符串）、年龄（数字）、是否已婚（布尔值）等信息。对象比数组更适合用于这种情况，因为每个信息片段都有一个有意义的名称——它的键——而不是一个通用的索引号。如果这些值
    35 和 true 存储在表示人的数组中，且其索引分别为 1 和 2，那么它们的含义就不如存储在表示人的对象中，分别作为 "age" 和 "married"
    键的值那样清晰。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Objects</samp>
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建对象</samp>
- en: 'One way to create an object is with an *object literal*, which consists of
    a pair of braces ({ and }) enclosing a series of key-value pairs, separated by
    commas. Each key-value pair must have a colon between the key and the value. For
    example, here’s an object literal called casablanca containing some information
    about that movie:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象的一种方式是使用*对象字面量*，它由一对大括号（{ 和 }）组成，括起来的是一系列键值对，键值对之间用逗号分隔。每个键值对必须在键和值之间有一个冒号。例如，下面是一个名为
    casablanca 的对象字面量，包含一些关于那部电影的信息：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here we create a new object with three keys: "title", "released", and "director".
    Each key has a value associated with it. I’ve written each key-value pair on its
    own line to make the object literal easier to read, but this isn’t strictly necessary.
    As you’ll see in later examples, the key-value pairs can also all be written on
    the same line.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个包含三个键的对象："title"、"released" 和 "director"。每个键都关联有一个值。我将每个键值对写在单独的行上，以便更容易阅读对象字面量，但这并不是严格必要的。正如你在后面的示例中会看到的，键值对也可以写在同一行。
- en: 'All object keys are strings, but if your key is a valid identifier, it’s common
    practice to omit the quotes. A *valid identifier* is any series of characters
    that can be used as a JavaScript variable name. An identifier can consist of letters,
    numbers, and the characters _ and $, but it can’t start with a number. It also
    can’t contain other symbols, like *, (, or #, nor can it include whitespace characters
    like spaces and newlines. These other characters *are* allowed in object keys,
    but only if the key is enclosed in quotes. For example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '所有对象的键都是字符串，但如果你的键是有效的标识符，通常做法是省略引号。*有效标识符*是指任何可以作为 JavaScript 变量名使用的一系列字符。标识符可以由字母、数字和字符
    _ 和 $ 组成，但不能以数字开头。它也不能包含其他符号，如 *、( 或 #，也不能包含空白字符，如空格和换行符。这些字符 *在*对象键中是允许的，但前提是键必须用引号括起来。例如：'
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here key1 and key_2 are valid identifiers, so they don’t need quotes. However,
    key 3 contains a space and key#4 contains a hash mark, making them invalid identifiers.
    They must be enclosed in quotes to be used as object keys.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 key1 和 key_2 是有效的标识符，因此不需要加引号。然而，key 3 包含空格，key#4 包含井号，因此它们是无效的标识符。它们必须用引号括起来，才能作为对象的键使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing Object
    Values</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">访问对象值</samp>
- en: 'To get the value associated with a key, call the name of the object with the
    string key in square brackets:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与某个键关联的值，可以使用方括号括起来的字符串键来调用对象名：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is just like the syntax for accessing an element from an array, but instead
    of using the numeric index, you use the string key.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像访问数组元素的语法一样，只不过不使用数字索引，而是使用字符串键。
- en: 'For keys that are valid identifiers, you can use dot notation instead of square
    brackets, with the key name coming after the dot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有效的标识符，可以使用点表示法代替方括号，键名跟在点后面：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This doesn’t work for keys that aren’t valid identifiers. For example, you can’t
    write obj.key 3 because to JavaScript that looks like obj.key followed after the
    space by the number literal 3.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于无效标识符的键不起作用。例如，你不能写 obj.key 3，因为在 JavaScript 中，这看起来像是 obj.key 后面跟着一个空格和数字字面量
    3。
- en: Notice that this dot notation looks like the syntax we used for accessing the
    length property of strings (in [Chapter 2](chapter2.xhtml)) and arrays (earlier
    in this chapter). That’s because it’s the same thing! A property is just another
    name for a key-value pair. Behind the scenes, JavaScript treats strings like objects,
    and arrays, too, are actually a special kind of object. When we write something
    like [1, 2, 3].length, we say we’re accessing the array’s length property, but
    we could also say we’re getting the value associated with the array’s length key.
    Likewise, when we write something like casablanca.title, we often say we’re accessing
    the object’s title property instead of the value associated with its title key.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种点表示法看起来就像我们用于访问字符串的 length 属性（在[第二章](chapter2.xhtml)中）和数组（在本章前面）的语法。那是因为它们是一样的！属性实际上就是键值对的另一种说法。在后台，JavaScript
    将字符串视为对象，数组也是一种特殊的对象。当我们写出类似 [1, 2, 3].length 这样的代码时，我们说我们正在访问数组的 length 属性，但我们也可以说我们正在获取与数组
    length 键关联的值。同样，当我们写出类似 casablanca.title 的代码时，我们通常说我们正在访问对象的 title 属性，而不是与 title
    键关联的值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Object Values</samp>
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设置对象值</samp>
- en: 'To add a new key-value pair to an object, use the same bracket or dot notation
    used to look up a value. Here, for example, we set up an empty dictionary object,
    then add two definitions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要向对象中添加一个新的键值对，使用与查找值时相同的括号或点表示法。例如，这里我们设置了一个空字典对象，然后添加了两个定义：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We first create a new, empty object using a pair of empty braces. We then set
    two new keys, "mouse" and "computer mouse", giving each a definition as a value.
    As before, we can use dot notation with the valid identifier mouse, but we need
    bracket notation for "computer mouse" because it contains a space.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一对空大括号创建一个新的空对象。然后，我们设置两个新的键，“mouse”和“computer mouse”，并为每个键设置一个定义作为值。像之前一样，我们可以使用点表示法来访问有效的标识符
    mouse，但对于“computer mouse”，由于它包含空格，我们需要使用括号表示法。
- en: 'Changing the value associated with a key that already exists follows the same
    syntax:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 更改与已存在的键相关联的值遵循相同的语法：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The output confirms that the definition for mouse has been updated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确认鼠标的定义已经更新。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Objects</samp>
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">与对象一起工作</samp>
- en: JavaScript has plenty of methods for working with objects; we’ll examine a few
    of the most common ones here. Unlike with arrays, where the methods are called
    directly on the array you want to operate on, object methods are called as static
    methods by entering Object.methodName() and passing the object you want to operate
    on as an argument inside the parentheses. Here, Object is a *constructor*, a type
    of function used to create objects, and *static methods* are methods defined directly
    on the constructor instead of on a particular object. We’ll discuss constructors
    in more detail in [Chapter 6](chapter6.xhtml).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有很多用于处理对象的方法；我们将在这里讨论其中一些最常见的方法。与数组不同，数组的方法是直接在你想操作的数组上调用的，而对象的方法是作为静态方法调用的，方法格式是
    `Object.methodName()`，并在括号内传入你想操作的对象作为参数。这里，Object 是一个*构造函数*，是一种用于创建对象的函数类型，而*静态方法*是直接在构造函数上定义的方法，而不是在某个特定对象上定义的方法。我们将在[第6章](chapter6.xhtml)中更详细地讨论构造函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Getting an Object’s Keys</samp>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">获取对象的键</samp>
- en: 'To get an array of all the keys of an object, use the static method Object.keys.
    For example, here’s how you could retrieve the names of my cats:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取对象的所有键的数组，使用静态方法 `Object.keys`。例如，这里是如何获取我猫的名字：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The cats object has three key-value pairs, where each key represents a cat name
    and each value represents that cat’s color. Object.keys returns just the keys,
    as an array of strings.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: cats 对象有三个键值对，其中每个键代表一只猫的名字，每个值代表该猫的颜色。`Object.keys` 返回的只是键，作为一个字符串数组。
- en: Object.keys can be helpful in cases like this where the only pieces of information
    you need from an object are the names of its keys. For example, you might have
    an object tracking how much money you owe your friends, where the keys are your
    friends’ names and the values are the amounts owed. With Object.keys you can list
    just the names of the friends that you’re tracking, giving you a general sense
    of whom you owe money to.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.keys` 在像这种情况下很有用，当你只需要从对象中获取其键的名称时。例如，你可能有一个对象来跟踪你欠朋友多少钱，其中键是朋友的名字，值是欠款金额。使用
    `Object.keys`，你可以列出你正在跟踪的朋友的名字，从而大致了解你欠钱的人。'
- en: 'You might be wondering why keys is a static method—that is, why we need to
    call it with Object.keys(cats) rather than with cats.keys(). To understand why
    this is the case, consider this piano object:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么 keys 是一个静态方法——也就是说，为什么我们需要通过 `Object.keys(cats)` 来调用它，而不是用 `cats.keys()`。为了理解这是为什么，考虑这个钢琴对象：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The object has a property named "keys" that represents the number of keys on
    the piano. If methods like keys could be called directly on the piano object itself,
    the property name and method name would conflict, which isn’t allowed. JavaScript
    has many more built-in object methods besides keys, and it would be tedious to
    have to remember all of their names to make sure they don’t conflict with any
    of your objects’ property names. To avoid this issue, the designers of the language
    made these object methods static. They’re attached to the overall Object constructor
    instead of to individual objects like cat or piano, so there’s no possibility
    of a naming conflict.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象有一个名为"keys"的属性，表示钢琴上的按键数量。如果像keys这样的函数可以直接在钢琴对象本身上调用，属性名和方法名会发生冲突，这是不被允许的。JavaScript除了keys之外，还有许多内建的对象方法，记住所有这些方法的名称以确保它们不会与对象的属性名冲突是非常繁琐的。为了解决这个问题，语言设计者将这些对象方法设置为静态方法。它们被附加到整体的Object构造器上，而不是附加到像猫（cat）或钢琴（piano）这样的单个对象上，因此不会发生命名冲突。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*None of this is an issue with arrays. Method names must be valid identifiers,
    meaning they can’t start with a number. Therefore, there’s no way an array method
    could conflict with the array’s numerical indices.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组没有这个问题。方法名必须是有效的标识符，这意味着它们不能以数字开头。因此，数组方法不可能与数组的数字索引发生冲突。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Getting an Object’s Keys and
    Values</samp>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">获取对象的键和值</samp>
- en: 'To get an array of the keys *and* values of an object, use Object.entries.
    This static method returns an array of two-element arrays, where the first element
    of each inner array is a key and the second is its value. Here’s how it works:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取对象的键*和*值，可以使用Object.entries。这个静态方法返回一个包含二元素数组的数组，每个内层数组的第一个元素是键，第二个元素是值。下面是它的工作原理：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We create an object with four key-value pairs, showing how many chromosomes
    various animals have. Object.entries(chromosomes) returns an array containing
    four elements, each of which is a two-element array. To expand the outer array
    and view its full contents, click the arrow:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含四个键值对的对象，展示了各种动物的染色体数量。Object.entries(chromosomes)返回一个包含四个元素的数组，每个元素都是一个包含两个元素的数组。点击箭头以展开外部数组并查看完整内容：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This shows that each inner array contains a key from the original object as
    its first element, and the associated value as its second element.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示每个内层数组包含原始对象的一个键作为第一个元素，关联的值作为第二个元素。
- en: Converting an object into an array with Object.entries makes it easier to cycle
    through all of the object’s key-value pairs and do something with each one in
    turn. We’ll see how to do this with loops in [Chapter 4](chapter4.xhtml).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Object.entries将一个对象转换成数组，可以更方便地遍历对象的所有键值对，并对每个键值对依次进行处理。我们将在[第4章](chapter4.xhtml)中看到如何使用循环来实现这一点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Combining Objects</samp>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">合并对象</samp>
- en: 'The Object.assign method lets you combine multiple objects into one. For example,
    say you have two objects, one giving the physical attributes of a book and the
    other describing its contents:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Object.assign方法允许你将多个对象合并成一个。例如，假设你有两个对象，一个给出一本书的物理属性，另一个描述书的内容：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With Object.assign, you can consolidate these separate objects into one overall
    book object:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Object.assign，你可以将这些独立的对象合并成一个整体的书籍对象：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first argument to Object.assign is the *target*, the object that the keys
    from the other objects are assigned to. In this case, we use an empty object called
    book as the target. The remaining arguments are the *sources*, the objects whose
    key-value pairs are to be copied into the target. You can pass as many source
    objects after the initial target argument as you want—we’re just doing two here.
    The method mutates and returns the target object with the key-value pairs copied
    from the source objects. The source objects themselves are untouched.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Object.assign的第一个参数是*目标*，即将从其他对象中复制的键赋值给的对象。在这个例子中，我们使用一个名为book的空对象作为目标。其余的参数是*源对象*，即其键值对将被复制到目标对象中的对象。你可以在初始目标参数之后传入任意多个源对象——我们这里只传入了两个。该方法会修改并返回目标对象，复制来自源对象的键值对。源对象本身不会受到影响。
- en: 'You don’t have to create a new, empty object to use as the target for Object.assign,
    but if you don’t, you’ll end up modifying one of your source objects. For example,
    we could remove the first argument, book, from the previous call and still get
    an object with the same four key-value pairs:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定需要创建一个新的空对象作为Object.assign的目标，但是如果不这么做，你将会修改其中一个源对象。例如，我们可以去掉之前调用中的第一个参数book，仍然得到一个具有相同四个键值对的对象：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The problem here is that physical is now the target object, so it gets mutated,
    gaining all the key-value pairs from contents. This usually isn’t what you want,
    as the original, separate objects are often still important to other parts of
    your application. For this reason, it’s common practice to use an empty object
    as the first argument to Object.assign.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，physical现在是目标对象，因此它会被修改，获得来自contents的所有键值对。通常情况下，这不是我们想要的，因为原本的单独对象在应用程序的其他部分通常仍然很重要。基于这个原因，常见做法是将一个空对象作为Object.assign的第一个参数。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Nesting Objects and Arrays</samp>
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">嵌套对象和数组</samp>
- en: 'As with arrays, we can nest objects in other objects. We can also nest objects
    in arrays, and arrays in objects, to create more sophisticated data structures.
    For example, you might want to make an object representing a person that contained
    a children property containing an array of objects representing that person’s
    children. We build these nested structures in two ways: by creating an object
    or array literal with nested object or array literals inside, or by creating the
    inner elements, saving them to variables, and then building up the composite structures
    using the variables. We’ll examine both of these techniques here.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，我们可以将对象嵌套在其他对象中。我们还可以将对象嵌套在数组中，或者将数组嵌套在对象中，从而创建更复杂的数据结构。例如，你可能想创建一个表示“人”的对象，这个对象包含一个children属性，属性值是一个数组，数组中的每个元素都是一个表示该人孩子的对象。我们可以通过两种方式来构建这些嵌套结构：一种是创建一个包含嵌套对象或数组字面量的对象或数组字面量，另一种是先创建内部元素，保存到变量中，然后使用这些变量来构建复合结构。我们将在这里探讨这两种技巧。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nesting with Literals</samp>
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用字面量进行嵌套</samp>
- en: 'First, let’s build a nested structure using literals. We’ll create an array
    of objects representing different book trilogies:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来使用字面量构建一个嵌套结构。我们将创建一个表示不同书籍三部曲的对象数组：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The variable trilogies contains an array of two elements, ❶ and ❷, each of which
    is an object with information about a particular trilogy. Notice that each object
    has the same keys, since we want to store the same pieces of information about
    each trilogy. One of those keys, books, itself contains an array of strings representing
    the book titles within the trilogy. We thus have an array within an object within
    an array.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 变量trilogies包含一个包含两个元素的数组，❶和❷，每个元素都是一个包含特定三部曲信息的对象。注意，每个对象都有相同的键，因为我们希望存储关于每个三部曲的相同信息。其中一个键是books，它本身包含一个数组，表示该三部曲中的书籍标题。因此，我们得到了一个嵌套在数组中的对象，又嵌套在数组中。
- en: 'Accessing an element from one of these inner arrays requires a combination
    of array indexing and object dot notation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些内部数组中访问元素需要结合数组索引和对象点表示法：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, trilogies[1] means we want the second object in the outer array, .books
    means we want the value of that object’s books key (which is an array), and [0]
    means we want the first element from that array. Putting it together, we get the
    first book from the second trilogy in the outer array.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，trilogies[1]表示我们想要外部数组中的第二个对象，.books表示我们想要该对象的books键的值（即一个数组），而[0]表示我们想要该数组中的第一个元素。将它们结合起来，我们就得到了外部数组中第二个三部曲的第一本书。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nesting with Variables</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用变量进行嵌套</samp>
- en: 'An alternative technique for making nested structures is to create objects
    containing the inner elements, assign those objects to variables, and then build
    the outer structure out of these variables. For example, say we want to create
    a data structure modeling the change in our pocket. We create four objects representing
    a penny, nickel, dime, and quarter, assigning each to its own variable:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建嵌套结构的技巧是先创建包含内部元素的对象，将这些对象赋值给变量，然后使用这些变量构建外部结构。例如，假设我们想创建一个模拟我们口袋里零钱变化的数据结构。我们创建四个对象，分别表示便士、五分镍币、十分镍币和四分之一硬币，并将每个对象赋值给各自的变量：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we use these variables to create an array representing the specific combination
    of coins in our pocket. For example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用这些变量创建一个数组，表示我们口袋中特定组合的硬币。例如：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Notice that some of the coin objects appear in the array multiple times. This
    is one advantage of assigning the inner objects to variables before we create
    the outer array: an object can be repeated within the array without having to
    manually write out the object literal each time.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到某些硬币对象在数组中出现多次。这是先将内部对象赋值给变量再创建外部数组的一个优点：对象可以在数组中重复，而不需要每次手动写出对象字面量。
- en: 'Accessing a value from one of the inner objects again requires a combination
    of array indexing and object dot notation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 再次访问内部对象的值时，需要结合数组索引和对象点符号：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, change[0] gives us the first element of the change array (a quarter object)
    and .value gives us its value key.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，change[0]给我们返回change数组的第一个元素（一枚硬币对象），而.value给我们它的value键。
- en: 'An interesting consequence of building the array from object variables like
    this is that the repeated elements share a common identity. For example, change[3]
    and change[4] refer to the same penny object. If the US government decided to
    update the weight of a penny, we could update the weight property of the underlying
    penny object, and that update would be reflected in all the penny elements of
    the change array:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象变量构建数组的一个有趣结果是，重复的元素共享一个共同的身份。例如，change[3]和change[4]引用的是同一枚penny对象。如果美国政府决定更新一枚penny的重量，我们只需要更新该penny对象的weight属性，这个更新就会反映到change数组中所有的penny元素上：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here we change the weight property of penny from 2.5 to 2.49. Then we check
    the weight of each penny in the array, confirming that the update has carried
    over to each one.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将penny的weight属性从2.5修改为2.49。然后，我们检查数组中每个penny的重量，确认更新已经反映到每一个硬币上。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Nested
    Objects in the Console</samp>
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在控制台中探索嵌套对象</samp>
- en: 'The Chrome console makes it easy to explore nested objects, like we did earlier
    in this chapter with the nested ticTacToe array. To illustrate, we’ll create a
    deeply nested object and try to look inside:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome控制台让我们轻松地探索嵌套对象，就像我们之前在本章中使用嵌套的ticTacToe数组那样。为了说明这一点，我们将创建一个深度嵌套的对象并尝试查看其中内容：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our nested object contains three layers of objects, each with a name and content
    property. The value of content for the outer and middle layers is another object.
    Getting the value of the innermost object’s content property requires a long chain
    of dot notation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的嵌套对象包含三层对象，每一层都有name和content属性。外层和中间层的content值是另一个对象。要获取最内层对象的content属性值，需要一连串的点符号：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is equivalent to asking for the content property of the content property
    of the content property of the outermost object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于请求最外层对象的内容属性的内容属性的内容属性。
- en: 'Now try viewing the value of nested as a whole:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试查看嵌套对象的整体值：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The console just gives an abbreviated version with the value of the outer object’s
    content property shown as {…} to imply that there’s an object here but there isn’t
    room to display it. Click the arrow to expand the view of the outer object. Now
    the next nested object (with name: "Middle") is shown in abbreviated form. Click
    the arrow to expand this object, too, and then one more time to expand the object
    with name: "Inner". You should now see the entire content of the object in the
    console:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台只会显示外部对象内容属性的简略版本，内容显示为{…}，表示这里有一个对象，但没有足够的空间来展示它。点击箭头以展开外部对象的视图。现在，下一个嵌套对象（名称：“Middle”）也以简略形式显示。点击箭头再展开此对象，然后再点击一次展开名为：“Inner”的对象。现在你应该能在控制台中看到整个对象的内容：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The [[Prototype]] properties refer to the Object constructor, which we’ve previously
    used to call object methods like Object.keys and Object.assign. We’ll discuss
    prototypes in detail in [Chapter 6](chapter6.xhtml).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[[Prototype]]属性指向Object构造函数，我们之前已经使用过它来调用像Object.keys和Object.assign这样的对象方法。我们将在[第六章](chapter6.xhtml)中详细讨论原型。'
- en: Using the console like this to view complex objects is a very helpful debugging
    tool. You’ll often be working with objects that come from different JavaScript
    libraries, or that contain data you fetch from a server, and you won’t necessarily
    know the “shape” of the data—what properties the objects contain, how many levels
    of nesting they have, and the like. With the console, you can interactively explore
    the objects and see their contents.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这样使用控制台查看复杂对象是一个非常有用的调试工具。你经常会处理来自不同 JavaScript 库的对象，或者包含你从服务器获取的数据的对象，而你不一定知道这些数据的“形状”——例如对象包含哪些属性、它们有多少层嵌套等等。通过控制台，你可以交互式地探索对象并查看它们的内容。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Printing Nested Objects
    with JSON.stringify</samp>
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 JSON.stringify
    打印嵌套对象</samp>
- en: 'Another way to view a nested object is to turn it into a JSON string. *JSON*,
    or *JavaScript Object Notation*, is a textual data format based on JavaScript
    object and array literals that’s heavily used across the web and beyond to store
    and exchange information. The JSON.stringify method converts a JavaScript object
    into a JSON string. Let’s pass it the nested object as an example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 查看嵌套对象的另一种方式是将其转换为 JSON 字符串。*JSON*，即 *JavaScript 对象表示法*，是一种基于 JavaScript 对象和数组字面量的文本数据格式，在
    web 及其他领域被广泛使用来存储和交换信息。JSON.stringify 方法将一个 JavaScript 对象转换为 JSON 字符串。我们以嵌套对象作为例子：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The result is a string (it’s enclosed in single quotes) containing a JSON representation
    of the nested object. Essentially, it’s the equivalent of the original object
    literal we used to create nested. Just like JavaScript, JSON uses braces to enclose
    objects, colons to separate keys from values, and commas to separate different
    key-value pairs. All that’s missing from this representation are the original
    line breaks and indentations we used to clarify the object literal’s nested structure.
    To re-create those, we can pass JSON.stringify another argument representing the
    number of spaces to indent each new nested object:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个字符串（它被单引号括起来），包含了嵌套对象的 JSON 表示。实质上，它等同于我们用来创建嵌套对象的原始对象字面量。像 JavaScript
    一样，JSON 使用大括号括起来对象，使用冒号分隔键和值，使用逗号分隔不同的键值对。这个表示中唯一缺失的是我们用来澄清对象字面量嵌套结构的原始换行符和缩进。为了重新创建这些换行符和缩进，我们可以传递
    JSON.stringify 另一个参数，表示每个新的嵌套对象的缩进空格数：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The second argument to JSON.stringify lets you define a replacer function that
    can modify the output by replacing key-value pairs, but we don’t have a need for
    that here, so we pass null. Passing 2 for the third argument modifies the behavior
    of JSON.stringify to add newlines after each property and after opening braces
    and brackets, and then two extra spaces of indentation for each additional level
    of nesting. If we viewed the result in the console directly, we’d see a bunch
    of \n escape characters for all the newlines. Instead, we store the result in
    a variable and pass it to console.log, giving us a well-formatted view of the
    object’s nested hierarchy.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: JSON.stringify 的第二个参数让你定义一个替换函数，可以通过替换键值对来修改输出，但在这里我们不需要这样做，所以传递 null。将 2 作为第三个参数传递会修改
    JSON.stringify 的行为，在每个属性后、在大括号和方括号后添加换行符，并为每个额外的嵌套级别增加两个额外的缩进空格。如果我们直接在控制台中查看结果，我们会看到许多
    \n 转义字符表示所有的换行符。相反，我们将结果存储在一个变量中并传递给 console.log，这样就能给我们一个格式良好的对象嵌套层次视图。
- en: Calling JSON.stringify in this way is helpful for getting a quick visual representation
    of an object without having to repeatedly click the arrows in the console to expand
    each nested level. The method works on non-nested objects, too, but in that case
    the regular view of the object in the console is usually sufficient.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式调用 JSON.stringify 有助于快速获取对象的可视化表示，而无需在控制台中反复点击箭头来展开每个嵌套级别。该方法同样适用于非嵌套对象，但在这种情况下，控制台中对象的常规视图通常就足够了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter introduced you to JavaScript’s compound data types, which allow
    you to combine multiple values into a single unit. By organizing data in this
    way, you can manipulate unbounded amounts of information more efficiently. You
    learned about arrays, which are ordered collections of values identified by numerical
    indices, usually all of the same data type, and about objects, which are collections
    of key-value pairs where each key is a string and the values are often of different
    data types. You’ve seen how arrays are useful for storing lists of similar values,
    such as a list of prime numbers or a list of programming languages. Meanwhile,
    objects are useful for collecting multiple pieces of information about a single
    entity, such as information about a particular book or movie.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 JavaScript 的复合数据类型，它们允许你将多个值组合成一个单一的单位。通过这种方式组织数据，你可以更高效地处理无限量的信息。你了解了数组，它是由数字索引标识的有序值集合，通常所有值的数据类型相同；你还了解了对象，它是由键值对组成的集合，其中每个键是一个字符串，而值通常是不同的数据类型。你已经了解了数组如何用于存储类似值的列表，例如素数列表或编程语言列表。同时，对象对于收集单个实体的多个信息也非常有用，比如一本书或一部电影的相关信息。
