- en: Chapter 2. Compilation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章：编译
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The code Ruby actually runs looks nothing like your original code.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Ruby 实际运行的代码与你原始的代码完全不同。*'
- en: Now that Ruby has tokenized and parsed your code, is it ready to run it? Will
    it finally get to work and iterate through the block 10 times in my simple `10.times
    do` example? If not, what else could Ruby possibly have to do first?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Ruby 已经对你的代码进行了词法分析和语法解析，它准备好运行了吗？它是否终于会在我的简单 `10.times do` 示例中迭代 10 次？如果没有，Ruby
    可能还需要做什么？
- en: Starting with version 1.9, Ruby compiles your code before executing it. The
    word *compile* means to translate your code from one programming language to another.
    Your programming language is easy for you to understand, while usually the target
    language is easy for the computer to understand.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.9 版本开始，Ruby 会在执行代码之前编译它。*编译*一词意味着将你的代码从一种编程语言转换为另一种语言。你的编程语言对你来说容易理解，而通常目标语言对计算机来说更容易理解。
- en: For example, when you compile a C program, the compiler translates C code to
    machine language, a language your computer’s microprocessor hardware understands.
    When you compile a Java program, the compiler translates Java code to Java bytecode,
    a language the Java Virtual Machine understands.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你编译一个 C 程序时，编译器将 C 代码转换为机器语言，这是计算机的微处理器硬件能理解的语言。当你编译一个 Java 程序时，编译器将 Java
    代码转换为 Java 字节码，这是 Java 虚拟机能够理解的语言。
- en: Ruby’s compiler is no different. It translates your Ruby code into another language
    that Ruby’s virtual machine understands. The only difference is that you don’t
    use Ruby’s compiler directly; unlike in C or Java, Ruby’s compiler runs automatically
    without you ever knowing. Here in [Chapter 2](ch02.html "Chapter 2. Compilation"),
    I’ll explain how Ruby does this and what language it translates your code into.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的编译器也没有什么不同。它将你的 Ruby 代码转换为 Ruby 虚拟机能够理解的另一种语言。唯一的区别是你不会直接使用 Ruby 的编译器；不像
    C 或 Java，Ruby 的编译器会自动运行，你根本不会知道。在本章 [第 2 章](ch02.html "第 2 章：编译") 中，我将解释 Ruby
    是如何做到这一点的，以及它将你的代码转换为什么语言。
- en: Roadmap
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[No Compiler for Ruby 1.8](ch02.html#no_compiler_for_ruby_1dot8 "No Compiler
    for Ruby 1.8")'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[没有 Ruby 1.8 的编译器](ch02.html#no_compiler_for_ruby_1dot8 "没有 Ruby 1.8 的编译器")'
- en: '[Ruby 1.9 and 2.0 Introduce a Compiler](ch02.html#ruby_1dot9_and_2dot0_introduce_a_compile
    "Ruby 1.9 and 2.0 Introduce a Compiler")'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 1.9 和 2.0 引入了编译器](ch02.html#ruby_1dot9_and_2dot0_introduce_a_compile
    "Ruby 1.9 和 2.0 引入了编译器")'
- en: '[How Ruby Compiles a Simple Script](ch02.html#how_ruby_compiles_a_simple_script
    "How Ruby Compiles a Simple Script")'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 如何编译一个简单脚本](ch02.html#how_ruby_compiles_a_simple_script "Ruby 如何编译一个简单脚本")'
- en: '[Compiling a Call to a Block](ch02.html#compiling_a_call_to_a_block "Compiling
    a Call to a Block")'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编译对块的调用](ch02.html#compiling_a_call_to_a_block "编译对块的调用")'
- en: '[How Ruby Iterates Through the AST](ch02.html#how_ruby_iterates_through_the_ast
    "How Ruby Iterates Through the AST")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 如何遍历 AST](ch02.html#how_ruby_iterates_through_the_ast "Ruby 如何遍历 AST")'
- en: '**[Experiment 2-1: Displaying YARV Instructions](ch02.html#experiment_2-1_displaying_yarv_instructi
    "Experiment 2-1: Displaying YARV Instructions")**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 2-1：显示 YARV 指令](ch02.html#experiment_2-1_displaying_yarv_instructi "实验
    2-1：显示 YARV 指令")**'
- en: '[The Local Table](ch02.html#local_table "The Local Table")'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[本地表](ch02.html#local_table "本地表")'
- en: '[Compiling Optional Arguments](ch02.html#compiling_optional_arguments "Compiling
    Optional Arguments")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编译可选参数](ch02.html#compiling_optional_arguments "编译可选参数")'
- en: '[Compiling Keyword Arguments](ch02.html#compiling_keyword_arguments "Compiling
    Keyword Arguments")'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编译关键字参数](ch02.html#compiling_keyword_arguments "编译关键字参数")'
- en: '**[Experiment 2-2: Displaying the Local Table](ch02.html#experiment_2-2_displaying_the_local_tabl
    "Experiment 2-2: Displaying the Local Table")**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 2-2：显示本地表](ch02.html#experiment_2-2_displaying_the_local_tabl "实验 2-2：显示本地表")**'
- en: '[Summary](ch02.html#summary-id00008 "Summary")'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch02.html#summary-id00008 "总结")'
- en: No Compiler for Ruby 1.8
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有 Ruby 1.8 的编译器
- en: The Ruby core team introduced a compiler with version 1.9\. Ruby 1.8 and earlier
    versions of Ruby don’t contain a compiler. Instead, Ruby 1.8 immediately executes
    your code after the tokenizing and parsing processes are finished. It does this
    by walking through the nodes in the AST tree and executing each one. [Figure 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.")
    shows another way of looking at the Ruby 1.8 tokenizing and parsing processes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 核心团队在版本 1.9 中引入了编译器。Ruby 1.8 及更早版本不包含编译器。相反，Ruby 1.8 会在标记化和解析过程完成后立即执行代码。它通过遍历
    AST 树中的节点并执行每个节点来实现这一点。[图 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "图 2-1. 在 Ruby 1.8 中，您的代码被转换为 AST 节点，然后被解释执行。")展示了另一种看待 Ruby 1.8 标记化和解析过程的方式。
- en: 'The top of [Figure 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.")
    shows your Ruby code. Below this are the different internal formats Ruby converts
    your Ruby code into. These are the tokens and AST nodes we saw in [Chapter 1](ch01.html
    "Chapter 1. Tokenization and Parsing")—the different forms your code takes when
    you run it using Ruby. The lower section of the diagram shows the code the Ruby
    core team wrote: the C source code for the Ruby language and the machine language
    it is converted into by the C compiler.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte "图 2-1. 在 Ruby 1.8
    中，您的代码被转换为 AST 节点，然后被解释执行。") 的顶部显示了您的 Ruby 代码。其下是 Ruby 将您的 Ruby 代码转换成的不同内部格式。这些就是我们在[第
    1 章](ch01.html "第 1 章. 标记化和解析")中看到的标记和 AST 节点——当您使用 Ruby 运行代码时，代码所呈现的不同形式。图表的下半部分展示了
    Ruby 核心团队编写的代码：Ruby 语言的 C 源代码，以及 C 编译器将其转换成的机器语言。'
- en: '![In Ruby 1.8, your code is converted into AST nodes and then interpreted.](httpatomoreillycomsourcenostarchimages1853899.png.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![在 Ruby 1.8 中，您的代码被转换为 AST 节点，然后被解释执行。](httpatomoreillycomsourcenostarchimages1853899.png.jpg)'
- en: Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1. 在 Ruby 1.8 中，您的代码被转换为 AST 节点，然后被解释执行。
- en: The dotted line between the two code sections indicates that Ruby interprets
    your code. The Ruby C code, the lower section, reads and executes your code, the
    top section. Ruby 1.8 doesn’t compile or translate your code into any form beyond
    AST nodes. After converting it into AST nodes, it proceeds to iterate over the
    nodes in the AST, taking whatever action each node represents as it executes each
    node.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 两个代码部分之间的虚线表示 Ruby 会解释您的代码。Ruby 的 C 代码（下半部分）读取并执行您的代码（上半部分）。Ruby 1.8 不会将您的代码编译或转换为
    AST 节点之外的任何形式。在将其转换为 AST 节点后，它会继续遍历 AST 中的节点，按每个节点所代表的操作执行。
- en: The gap in the middle of the diagram shows that your code is never completely
    compiled into machine language. If you were to disassemble and inspect the machine
    language that your CPU actually runs, you would not see instructions that directly
    map to your original Ruby code. Instead, you would find instructions that tokenize,
    parse, and execute your code, or, in other words, that implement the Ruby interpreter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中间的空隙表明，您的代码从未完全编译成机器语言。如果您反汇编并检查 CPU 实际运行的机器语言，您将看不到直接映射到您原始 Ruby 代码的指令。相反，您会发现执行代码的指令，这些指令会进行标记化、解析和执行，换句话说，它们实现了
    Ruby 解释器。
- en: Ruby 1.9 and 2.0 Introduce a Compiler
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 1.9 和 2.0 引入了编译器
- en: If you’ve upgraded to Ruby 1.9 or 2.0, Ruby is still not quite ready to run
    your code. It needs to compile it first.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经升级到 Ruby 1.9 或 2.0，Ruby 仍然无法直接运行您的代码。它首先需要编译代码。
- en: With Ruby 1.9, Koichi Sasada and the Ruby core team introduced Yet Another Ruby
    Virtual Machine (YARV), which actually executes your Ruby code. At a high level,
    this is the same idea behind the Java Virtual Machine (JVM) used by Java and many
    other languages. (I’ll cover YARV in more detail in [Chapter 3](ch03.html "Chapter 3. How
    Ruby Executes Your Code") and [Chapter 4](ch04.html "Chapter 4. Control Structures
    and Method Dispatch").)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.9 中，Koichi Sasada 和 Ruby 核心团队引入了“另一个 Ruby 虚拟机”（YARV），它实际上执行您的 Ruby
    代码。从高层次上看，这与 Java 虚拟机（JVM）的概念相同，JVM 被 Java 和许多其他语言所使用。（我将在[第 3 章](ch03.html "第
    3 章. Ruby 如何执行您的代码")和[第 4 章](ch04.html "第 4 章. 控制结构与方法调用")中更详细地介绍 YARV。）
- en: 'When using YARV (as with the JVM), you first compile your code into *bytecode*,
    a series of low-level instructions that the virtual machine understands. The only
    differences between YARV and the JVM are the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 YARV 时（与 JVM 类似），你首先将代码编译成*字节码*，即虚拟机可以理解的一系列低级指令。YARV 和 JVM 之间的唯一区别如下：
- en: Ruby doesn’t expose the compiler to you as a separate tool. Instead, it automatically
    compiles your Ruby code into bytecode instructions internally.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 并没有将编译器作为一个独立的工具暴露给你。相反，它会自动将你的 Ruby 代码在内部编译成字节码指令。
- en: Ruby never compiles your Ruby code all the way to machine language. As you can
    see in [Figure 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod "Figure 2-2. Ruby
    1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them."),
    Ruby interprets the bytecode instructions. The JVM, on the other hand, can compile
    some of the bytecode instructions all the way into machine language using its
    “hotspot” or just-in-time (JIT) compiler.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 永远不会将你的 Ruby 代码完全编译成机器语言。正如你在[图 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod
    "图 2-2. Ruby 1.9 和 2.0 在解释之前会将 AST 节点编译成 YARV 指令")中看到的那样，Ruby 会解释字节码指令。而 JVM 则可以通过其“热点”或即时编译器（JIT）将一些字节码指令编译成机器语言。
- en: '[Figure 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod "Figure 2-2. Ruby
    1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them.")
    shows how Ruby 1.9 and 2.0 handle your code.'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[图 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod "图 2-2. Ruby 1.9
    和 2.0 在解释之前会将 AST 节点编译成 YARV 指令")展示了 Ruby 1.9 和 2.0 如何处理你的代码。'
- en: Notice that this time, unlike in the process shown in [Figure 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted."),
    your code is translated into a third format. After parsing the tokens and producing
    the AST, Ruby 1.9 and 2.0 continue to compile your code into a series of low-level
    instructions called *YARV instructions*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次不同于[图 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte "图 2-1.
    在 Ruby 1.8 中，你的代码首先被转换成 AST 节点然后被解释")中展示的过程，你的代码被转换成了第三种格式。在解析完符号并生成 AST 后，Ruby
    1.9 和 2.0 会继续将代码编译成一系列低级指令，称为*YARV 指令*。
- en: 'The primary reason for using YARV is speed: Ruby 1.9 and 2.0 run much faster
    than Ruby 1.8 due to the use of YARV instructions. Like Ruby 1.8, YARV is an interpreter—just
    a faster one. Your Ruby code ultimately is still not converted directly into machine
    language by Ruby 1.9 or 2.0\. There is still a gap in [Figure 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod
    "Figure 2-2. Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before
    interpreting them.") between the YARV instructions and Ruby’s C code.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 YARV 的主要原因是速度：由于采用了 YARV 指令，Ruby 1.9 和 2.0 比 Ruby 1.8 运行得要快得多。像 Ruby 1.8
    一样，YARV 是一个解释器——只不过是一个更快的解释器。最终，Ruby 1.9 或 2.0 依然不会直接将你的 Ruby 代码转换成机器语言。[图 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod
    "图 2-2. Ruby 1.9 和 2.0 在解释之前会将 AST 节点编译成 YARV 指令")中，YARV 指令和 Ruby 的 C 代码之间仍然存在差距。
- en: '![Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting
    them.](httpatomoreillycomsourcenostarchimages1853901.png.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 1.9 和 2.0 在解释之前会将 AST 节点编译成 YARV 指令。](httpatomoreillycomsourcenostarchimages1853901.png.jpg)'
- en: Figure 2-2. Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before
    interpreting them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2. Ruby 1.9 和 2.0 在解释之前会将 AST 节点编译成 YARV 指令。
- en: How Ruby Compiles a Simple Script
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 如何编译一个简单的脚本
- en: 'In this section, we’ll look at the last step along your code’s journey through
    Ruby: how Ruby compiles your code into the instructions that YARV expects. Let’s
    explore how Ruby’s compiler works by stepping through an example compilation.
    [Example 2-1](ch02.html#one-line_ruby_program_we_will_compile "Example 2-1. A
    one-line Ruby program we will compile as an example") shows a simple Ruby script
    that calculates 2 + 2 = 4.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看看代码在 Ruby 中执行的最后一步：Ruby 如何将你的代码编译成 YARV 所期望的指令。通过一个编译的示例，我们来探索 Ruby
    编译器的工作原理。[示例 2-1](ch02.html#one-line_ruby_program_we_will_compile "示例 2-1. 我们将编译的一个简单
    Ruby 程序")展示了一个简单的 Ruby 脚本，它计算了 2 + 2 = 4。
- en: Example 2-1. A one-line Ruby program we will compile as an example
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-1. 我们将编译的一个简单 Ruby 程序
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure 2-3](ch02.html#ast_ruby_produces_after_parsing_the "Figure 2-3. The
    AST Ruby produces after parsing the code in Example 2-1") shows the AST structure
    that Ruby will create after tokenizing and parsing this simple program. (This
    is a more detailed view of the AST than you would get from the Ripper tool that
    we saw in [Experiment 1-2: Using Ripper to Parse Different Ruby Scripts](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "Experiment 1-2: Using Ripper to Parse Different Ruby Scripts").)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](ch02.html#ast_ruby_produces_after_parsing_the "图 2-3. Ruby 在解析 [示例
    2-1](ch02.html#one-line_ruby_program_we_will_compile) 代码后生成的 AST") 展示了 Ruby 在对这个简单程序进行词法分析和解析后生成的
    AST 结构。（这比我们在[实验 1-2: 使用 Ripper 解析不同的 Ruby 脚本](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "实验 1-2: 使用 Ripper 解析不同的 Ruby 脚本")中看到的 Ripper 工具所呈现的 AST 更为详细。）'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The technical names shown in [Figure 2-3](ch02.html#ast_ruby_produces_after_parsing_the
    "Figure 2-3. The AST Ruby produces after parsing the code in Example 2-1") (*`NODE_SCOPE`*,
    *`NODE_FCALL`*, and so on) are taken from the actual Ruby C source code. To keep
    things simple, I’m omitting some AST nodes—specifically, ones that represent arrays
    of the arguments to each method call, which in this simple example would be arrays
    of only one element.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图 2-3](ch02.html#ast_ruby_produces_after_parsing_the "图 2-3. Ruby 在解析 [示例
    2-1](ch02.html#one-line_ruby_program_we_will_compile) 代码后生成的 AST") 中显示的技术名称（*`NODE_SCOPE`*，*`NODE_FCALL`*
    等）来自实际的 Ruby C 源代码。为了简化起见，我省略了一些 AST 节点——特别是那些表示每个方法调用的参数数组的节点，在这个简单的例子中，这些数组只有一个元素。*'
- en: '![The AST Ruby produces after parsing the code in](httpatomoreillycomsourcenostarchimages1853903.png.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 解析代码后生成的 AST](httpatomoreillycomsourcenostarchimages1853903.png.jpg)'
- en: Figure 2-3. The AST Ruby produces after parsing the code in [Example 2-1](ch02.html#one-line_ruby_program_we_will_compile
    "Example 2-1. A one-line Ruby program we will compile as an example")
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3. Ruby 在解析 [示例 2-1](ch02.html#one-line_ruby_program_we_will_compile "示例
    2-1. 一个我们将编译的 Ruby 单行程序") 代码后生成的 AST。
- en: 'Before we cover the details of how Ruby compiles the `puts 2+2` script, let’s
    look at one very important attribute of YARV: It’s a *stack-oriented virtual machine*.
    That means when YARV executes your code, it maintains a stack of values—mainly
    arguments and return values for the YARV instructions. (I’ll explain this in more
    detail in [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code").) Most
    of YARV’s instructions either push values onto the stack or operate on the values
    that they find on the stack, leaving a result value on the stack as well.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细讲解 Ruby 如何编译 `puts 2+2` 脚本之前，让我们先看一下 YARV 的一个非常重要的特性：它是一个 *栈导向虚拟机*。这意味着，当
    YARV 执行你的代码时，它会维护一个值的栈——主要是 YARV 指令的参数和返回值。（我将在[第 3 章](ch03.html "第 3 章. Ruby
    如何执行你的代码")中详细解释这个问题。）YARV 的大多数指令要么将值推入栈中，要么操作栈中的值，最终将结果值保留在栈中。
- en: In order to compile the `puts 2+2` AST structure into YARV instructions, Ruby
    will iterate over the tree recursively from the top down, converting each AST
    node into instructions. [Figure 2-4](ch02.html#ruby_starts_the_compile_process_at_the_r
    "Figure 2-4. Ruby starts the compile process at the root of the AST.") shows how
    this works, beginning with `NODE_SCOPE`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `puts 2+2` 的 AST 结构编译成 YARV 指令，Ruby 将从上到下递归遍历树，将每个 AST 节点转换为指令。[图 2-4](ch02.html#ruby_starts_the_compile_process_at_the_r
    "图 2-4. Ruby 从 AST 的根开始编译过程") 展示了这个过程，从 `NODE_SCOPE` 开始。
- en: '![Ruby starts the compile process at the root of the AST.](httpatomoreillycomsourcenostarchimages1853905.png.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 从 AST 的根开始编译过程](httpatomoreillycomsourcenostarchimages1853905.png.jpg)'
- en: Figure 2-4. Ruby starts the compile process at the root of the AST.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-4. Ruby 从 AST 的根开始编译过程。
- en: '`NODE_SCOPE` tells the Ruby compiler that it is starting to compile a new *scope*,
    or section of Ruby code, which, in this case, is a whole new program. This scope
    is indicated on the right with an empty box. (The `table` and `args` values are
    both empty, so we’ll ignore them for now.)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`NODE_SCOPE` 告诉 Ruby 编译器，它开始编译一个新的 *作用域*，或一段 Ruby 代码，在这个例子中是一个全新的程序。右侧的空框表示该作用域。（`table`
    和 `args` 值都为空，所以我们暂时忽略它们。）'
- en: Next, the Ruby compiler steps down the AST tree and encounters `NODE_FCALL`,
    as shown in [Figure 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir "Figure 2-5. To
    compile a function call, Ruby first creates an instruction to push the receiver.").
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 编译器会沿着 AST 树向下，遇到 `NODE_FCALL`，如[图 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir
    "图 2-5. 为了编译函数调用，Ruby 首先创建一个指令来推送接收者")所示。
- en: '![To compile a function call, Ruby first creates an instruction to push the
    receiver.](httpatomoreillycomsourcenostarchimages1853907.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![为了编译一个函数调用，Ruby 首先创建一个指令将接收者推入栈中。](httpatomoreillycomsourcenostarchimages1853907.png.jpg)'
- en: Figure 2-5. To compile a function call, Ruby first creates an instruction to
    push the receiver.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-5. 为了编译一个函数调用，Ruby 首先创建一个指令将接收者推入栈中。
- en: '`NODE_FCALL` represents a *function call*—in this case, the call to `puts`.
    (Function and method calls are very important and very common in Ruby programs.)
    Ruby compiles function calls for YARV according to the following pattern:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`NODE_FCALL` 表示一个*函数调用*——在这个例子中，就是调用 `puts`。（函数和方法调用在 Ruby 程序中非常重要，也非常常见。）Ruby
    按照以下模式为 YARV 编译函数调用：'
- en: Push receiver.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推入接收者。
- en: Push arguments.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推入参数。
- en: Call the method/function.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用方法/函数。
- en: In [Figure 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir "Figure 2-5. To
    compile a function call, Ruby first creates an instruction to push the receiver."),
    the Ruby compiler first creates a YARV instruction called `putself` to indicate
    that the function call uses the current value of the `self` pointer as the receiver.
    Because I call `puts` from the top-level scope—that is, the top section—of this
    simple script, `self` is set to point to the `top self` object. (The `top self`
    object is an instance of the `Object` class that is automatically created when
    Ruby starts up. One purpose of `top self` is to serve as the receiver for function
    calls like this one in the top-level scope.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir "图 2-5. 为了编译一个函数调用，Ruby
    首先创建一个指令将接收者推入栈中。")中，Ruby 编译器首先创建了一个名为 `putself` 的 YARV 指令，表示该函数调用使用当前 `self`
    指针的值作为接收者。由于我在该简单脚本的顶层作用域中调用了 `puts`，也就是说在顶层部分，`self` 被设置为指向 `top self` 对象。(`top
    self` 对象是一个 `Object` 类的实例，它在 Ruby 启动时自动创建。`top self` 的一个作用是作为顶层作用域中类似这种函数调用的接收者。)
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In Ruby all functions are actually methods. That is, functions are always
    associated with a Ruby class; there is always a receiver. Inside of Ruby, however,
    Ruby’s parser and compiler distinguish between functions and methods: Method calls
    have an explicit receiver, while function calls assume the receiver is the current
    value of `self`*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Ruby 中，所有函数实际上都是方法。也就是说，函数总是与 Ruby 类关联；总会有一个接收者。然而，在 Ruby 内部，Ruby 的解析器和编译器区分函数和方法：方法调用有显式的接收者，而函数调用则假定接收者是当前的
    `self` 值。*'
- en: Next, Ruby needs to create instructions to push the arguments of the `puts`
    function call. But how? The argument to `puts` is `2+2`, which is the result of
    another method call. Although `2+2` is a simple expression, `puts` could instead
    be operating on some extremely complex Ruby expression involving many operators,
    method calls, and so on. How can Ruby know which instructions to create here?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 需要创建指令将 `puts` 函数调用的参数推入栈中。但是，如何做到这一点呢？`puts` 的参数是 `2+2`，它是另一个方法调用的结果。尽管
    `2+2` 是一个简单的表达式，`puts` 也可能是在处理一个非常复杂的 Ruby 表达式，涉及许多运算符、方法调用等。那么，Ruby 如何知道在这里创建哪些指令呢？
- en: The answer lies in the structure of the AST. By simply following the tree nodes
    down recursively, Ruby can take advantage of all the parser’s earlier work. In
    this case, it can now just step down to the `NODE_CALL` node, as shown in [Figure 2-6](ch02.html#nextcomma_ruby_writes_instructions_for_c
    "Figure 2-6. Next, Ruby writes instructions for calculating 2+2, the argument
    to puts.").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在 AST（抽象语法树）的结构中。通过递归地向下遍历树节点，Ruby 可以利用解析器之前的工作。在这种情况下，Ruby 现在只需一步步下到 `NODE_CALL`
    节点，如[图 2-6](ch02.html#nextcomma_ruby_writes_instructions_for_c "图 2-6. 接下来，Ruby
    编写计算 2+2 的指令，作为 `puts` 的参数。")所示。
- en: '![Next, Ruby writes instructions for calculating 2+2, the argument to puts.](httpatomoreillycomsourcenostarchimages1853909.png.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![接下来，Ruby 编写计算 2+2 的指令，作为 `puts` 的参数。](httpatomoreillycomsourcenostarchimages1853909.png.jpg)'
- en: Figure 2-6. Next, Ruby writes instructions for calculating `2+2`, the argument
    to `puts`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-6. 接下来，Ruby 编写计算 `2+2` 的指令，作为 `puts` 的参数。
- en: 'Here Ruby will compile the `+` method call, which theoretically is the process
    of sending the `+` message to the `2` integer object. Again, following the same
    receiver, arguments, method call pattern, Ruby performs these actions in order:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 Ruby 将编译 `+` 方法调用，理论上这就是将 `+` 消息发送给 `2` 这个整数对象的过程。同样，按照接收者、参数、方法调用的模式，Ruby
    按顺序执行以下操作：
- en: Creates a YARV instruction to push the receiver onto the stack (the object `2`
    in this case).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 YARV 指令，将接收者（在此例中为对象`2`）推入栈中。
- en: Creates a YARV instruction to push the argument or arguments onto the stack
    (again, `2` in this example).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 YARV 指令，将参数或参数们推入栈中（在此例中是 `2`）。
- en: Creates a method call YARV instruction `send <callinfo!mid:+, argc:1, ARGS_SKIP>`
    that means “send the + message” to the receiver, which is the object previously
    pushed onto the YARV stack (in this case, the first `Fixnum 2` object). `mid:+`
    means “method id = +” and is the name of the method we want to call. The `argc:1`
    parameter tells YARV there is one argument to this method call (the second `Fixnum
    2` object). `ARGS_SKIP` indicates the arguments are simple values (not blocks
    or arrays of unnamed arguments), allowing YARV to skip some work it would have
    to do otherwise.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法调用 YARV 指令 `send <callinfo!mid:+, argc:1, ARGS_SKIP>`，这意味着“发送 + 消息”给接收者，也就是之前被推入
    YARV 栈中的对象（在此例中为第一个 `Fixnum 2` 对象）。`mid:+` 表示“方法 ID = +”，是我们想调用的方法的名称。`argc:1`
    参数告诉 YARV 该方法调用有一个参数（第二个 `Fixnum 2` 对象）。`ARGS_SKIP` 表示参数是简单值（而非块或未命名参数的数组），允许
    YARV 跳过一些原本需要做的工作。
- en: When Ruby executes the `send <callinfo!mid:+...` instruction it adds `2+2`,
    fetching those arguments from the stack, and leaves the result, `4`, as a new
    value on top of the stack. What’s fascinating about this is that YARV’s stack-oriented
    nature also helps Ruby compile the AST nodes more easily, as you can see when
    it finishes compiling the `NODE_FCALL`, as shown in [Figure 2-7](ch02.html#finallycomma_ruby_can_write_an_instructi
    "Figure 2-7. Finally, Ruby can write an instruction for the call to puts.").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ruby 执行 `send <callinfo!mid:+...` 指令时，它会将 `2+2` 相加，从栈中获取这些参数，并将结果 `4` 留在栈顶作为一个新值。令人着迷的是，YARV
    的栈导向特性也有助于 Ruby 更容易地编译 AST 节点，正如你在编译完 `NODE_FCALL` 时看到的那样，如[图 2-7](ch02.html#finallycomma_ruby_can_write_an_instructi
    "图 2-7. 最终，Ruby 可以为调用 puts 写一条指令.")所示。
- en: Now Ruby can assume that the return value of the `2+2` operation—that is, `4`—will
    be left at the top of the stack, just where it needs to be as the argument to
    the `puts` function call. Ruby’s stack-oriented virtual machine goes hand in hand
    with the way that it recursively compiles the AST nodes! As you can see at the
    right of [Figure 2-7](ch02.html#finallycomma_ruby_can_write_an_instructi "Figure 2-7. Finally,
    Ruby can write an instruction for the call to puts."), Ruby has added the `send
    <callinfo!mid:puts, argc:1` instruction, which calls `puts` and indicates that
    there is one argument to `puts`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Ruby 可以假设 `2+2` 操作的返回值——也就是 `4`——将留在栈顶，正好作为 `puts` 函数调用的参数。Ruby 的栈导向虚拟机与它递归编译
    AST 节点的方式相得益彰！正如你在[图 2-7](ch02.html#finallycomma_ruby_can_write_an_instructi "图
    2-7. 最终，Ruby 可以为调用 puts 写一条指令.")右侧所看到的，Ruby 已经添加了 `send <callinfo!mid:puts, argc:1`
    指令，该指令调用 `puts` 并表示 `puts` 有一个参数。
- en: '![Finally, Ruby can write an instruction for the call to puts.](httpatomoreillycomsourcenostarchimages1853911.png.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![最终，Ruby 可以为调用 puts 写一条指令。](httpatomoreillycomsourcenostarchimages1853911.png.jpg)'
- en: Figure 2-7. Finally, Ruby can write an instruction for the call to `puts`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-7. 最终，Ruby 可以为调用 `puts` 写一条指令。
- en: As it turns out, Ruby further modifies these YARV instructions before executing
    them as part of an optimize step. One of its optimizations is to replace some
    YARV instructions with *specialized instructions*, which are YARV instructions
    that represent commonly used operations, such as `size`, `not`, `less than`, `greater
    than`, and so on. One such instruction, `opt_plus`, is used for adding two numbers
    together. During optimization, Ruby replaces `send <callinfo!mid:+...` with `opt_plus`,
    as shown in [Figure 2-8](ch02.html#ruby_replaces_some_instructions_with_spe "Figure 2-8. Ruby
    replaces some instructions with specialized instructions.").
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，Ruby 在执行这些 YARV 指令之前，会进一步修改它们作为优化步骤的一部分。它的一项优化是用*专用指令*替换一些 YARV 指令，专用指令是代表常用操作的
    YARV 指令，比如`size`、`not`、`less than`、`greater than`等。其中一条指令，`opt_plus`，用于将两个数字相加。在优化过程中，Ruby
    会将 `send <callinfo!mid:+...` 替换为 `opt_plus`，如[图 2-8](ch02.html#ruby_replaces_some_instructions_with_spe
    "图 2-8. Ruby 用专用指令替换一些指令.")所示。
- en: '![Ruby replaces some instructions with specialized instructions.](httpatomoreillycomsourcenostarchimages1853913.png.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 用专用指令替换一些指令。](httpatomoreillycomsourcenostarchimages1853913.png.jpg)'
- en: Figure 2-8. Ruby replaces some instructions with specialized instructions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-8. Ruby 用专用指令替换一些指令。
- en: As you can see in [Figure 2-8](ch02.html#ruby_replaces_some_instructions_with_spe
    "Figure 2-8. Ruby replaces some instructions with specialized instructions."),
    Ruby also replaces the second `send` with `opt_send_simple`, which runs a bit
    faster when all of the arguments are simple values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图 2-8](ch02.html#ruby_replaces_some_instructions_with_spe "Figure 2-8.
    Ruby replaces some instructions with specialized instructions.")中看到的，Ruby 还将第二个
    `send` 替换为 `opt_send_simple`，当所有参数都是简单值时，它运行得更快。
- en: Compiling a Call to a Block
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译调用块
- en: Next, let’s compile my `10.times do` example from [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)") in [Chapter 1](ch01.html
    "Chapter 1. Tokenization and Parsing") (see [Example 2-2](ch02.html#simple_script_that_calls_a_block
    "Example 2-2. A simple script that calls a block")).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编译我在[示例 1-1](ch01.html#very_simple_ruby_program_left_parenthe "Example
    1-1. A very simple Ruby program (simple.rb)")中给出的 `10.times do` 示例，位于[第 1 章](ch01.html
    "Chapter 1. Tokenization and Parsing")（参见[示例 2-2](ch02.html#simple_script_that_calls_a_block
    "Example 2-2. A simple script that calls a block")）。
- en: Example 2-2. A simple script that calls a block
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-2. 一个简单的调用块的脚本
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that this example contains a block parameter to the `times` method. This
    is interesting because it will give us a chance to see how the Ruby compiler handles
    blocks. [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "Figure 2-9. The
    AST for the call to 10.times, passing a block") shows the AST for the `10.times
    do` example again, using the actual node names rather than the simplified output
    from Ripper.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个示例包含了传递给 `times` 方法的块参数。这很有趣，因为它将让我们有机会看看 Ruby 编译器如何处理块。[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block")再次显示了 `10.times
    do` 示例的 AST，使用实际的节点名称，而不是 Ripper 简化的输出。
- en: '![The AST for the call to 10.times, passing a block](httpatomoreillycomsourcenostarchimages1853915.png.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![调用 10.times 时传递块的 AST](httpatomoreillycomsourcenostarchimages1853915.png.jpg)'
- en: Figure 2-9. The AST for the call to `10.times`, passing a block
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-9. 调用 `10.times` 时传递块的 AST
- en: This looks very different than `puts 2+2`, mostly because of the inner block
    shown at the right. (Ruby handles the inner block differently, as we’ll see shortly.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与 `puts 2+2` 非常不同，主要是因为右侧显示的内部块。（Ruby 对内部块的处理方式不同，稍后我们会看到。）
- en: Let’s break down how Ruby compiles the main portion of the script shown on the
    left of [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "Figure 2-9. The
    AST for the call to 10.times, passing a block"). As before, Ruby starts with the
    first `NODE_SCOPE` and creates a new snippet of YARV instructions, as shown in
    [Figure 2-10](ch02.html#each_nodeunderscorescope_is_compiled_int "Figure 2-10. Each
    NODE_SCOPE is compiled into a new snippet of YARV instructions.").
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下 Ruby 如何编译位于左侧的[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block")所示的脚本的主要部分。如同之前一样，Ruby
    从第一个 `NODE_SCOPE` 开始，并创建一个新的 YARV 指令片段，如[图 2-10](ch02.html#each_nodeunderscorescope_is_compiled_int
    "Figure 2-10. Each NODE_SCOPE is compiled into a new snippet of YARV instructions.")所示。
- en: '![Each NODE_SCOPE is compiled into a new snippet of YARV instructions.](httpatomoreillycomsourcenostarchimages1853917.png.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![每个 NODE_SCOPE 都被编译成一个新的 YARV 指令片段。](httpatomoreillycomsourcenostarchimages1853917.png.jpg)'
- en: Figure 2-10. Each `NODE_SCOPE` is compiled into a new snippet of YARV instructions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-10. 每个 `NODE_SCOPE` 都被编译成一个新的 YARV 指令片段。
- en: Next, Ruby steps down the AST nodes to `NODE_ITER`, as shown in [Figure 2-11](ch02.html#ruby_stepping_through_an_ast
    "Figure 2-11. Ruby stepping through an AST").
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 继续遍历 AST 节点，直到 `NODE_ITER`，如[图 2-11](ch02.html#ruby_stepping_through_an_ast
    "Figure 2-11. Ruby stepping through an AST")所示。
- en: '![Ruby stepping through an AST](httpatomoreillycomsourcenostarchimages1853919.png.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 遍历 AST](httpatomoreillycomsourcenostarchimages1853919.png.jpg)'
- en: Figure 2-11. Ruby stepping through an AST
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-11. Ruby 遍历 AST
- en: 'At this point, there is still no code generated, but notice in [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block") that two arrows
    lead from `NODE_ITER`: one to `NODE_CALL`, which represents the `10.times` call,
    and another to the inner block. Ruby will first continue down the AST and compile
    the nodes corresponding to the `10.times` code. The resulting YARV code, following
    the same receiver-arguments-message pattern we saw in [Figure 2-6](ch02.html#nextcomma_ruby_writes_instructions_for_c
    "Figure 2-6. Next, Ruby writes instructions for calculating 2+2, the argument
    to puts."), is shown in [Figure 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call
    "Figure 2-12. Ruby compiles the 10.times method call.").'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，仍然没有生成代码，但请注意在[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "图 2-9.
    调用 10.times 时的 AST，传递一个块")中，两条箭头从 `NODE_ITER` 指向：一条指向 `NODE_CALL`，表示 `10.times`
    调用，另一条指向内部块。Ruby 将首先继续沿着 AST 向下编译与 `10.times` 代码对应的节点。生成的 YARV 代码遵循我们在[图 2-6](ch02.html#nextcomma_ruby_writes_instructions_for_c
    "图 2-6. 接下来，Ruby 为计算 2+2 写入指令")中看到的相同的接收者-参数-消息模式，并在[图 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call
    "图 2-12. Ruby 编译 10.times 方法调用")中显示。
- en: '![Ruby compiles the 10.times method call.](httpatomoreillycomsourcenostarchimages1853921.png.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 编译 10.times 方法调用](httpatomoreillycomsourcenostarchimages1853921.png.jpg)'
- en: Figure 2-12. Ruby compiles the `10.times` method call.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-12. Ruby 编译 `10.times` 方法调用
- en: 'Notice that the new YARV instructions shown in [Figure 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call
    "Figure 2-12. Ruby compiles the 10.times method call.") push the receiver (the
    integer object `10`) onto the stack first, after which Ruby generates an instruction
    to execute the `times` method call. But notice, too, the `block:block in <compiled>`
    argument in the `send` instruction. This indicates that the method call also contains
    a block argument: my `do |n| puts n end` block. In this example, `NODE_ITER` has
    caused the Ruby compiler to include this block argument because the AST above
    shows an arrow from `NODE_ITER` to the second `NODE_SCOPE`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[图 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call "图 2-12. Ruby
    编译 10.times 方法调用")中显示的新 YARV 指令，首先将接收者（整数对象 `10`）压入栈中，然后 Ruby 生成一条指令来执行 `times`
    方法调用。但同样要注意的是，`send` 指令中的 `block:block in <compiled>` 参数。这表明该方法调用还包含一个块参数：我的 `do
    |n| puts n end` 块。在这个例子中，`NODE_ITER` 导致 Ruby 编译器包含了这个块参数，因为上面的 AST 显示了从 `NODE_ITER`
    到第二个 `NODE_SCOPE` 的箭头。
- en: Ruby continues by compiling the inner block, beginning with the second `NODE_SCOPE`
    shown at right in [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "Figure 2-9. The
    AST for the call to 10.times, passing a block"). [Figure 2-13](ch02.html#branch_of_the_ast_for_the_contents_o
    "Figure 2-13. The branch of the AST for the contents of the block") shows what
    the AST for that inner block looks like.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 继续编译内部块，从右侧的第二个 `NODE_SCOPE` 开始，正如在[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "图 2-9. 调用 10.times 时的 AST，传递一个块")中所示。[图 2-13](ch02.html#branch_of_the_ast_for_the_contents_o
    "图 2-13. AST 分支，表示块的内容") 显示了内部块对应的 AST 结构。
- en: This looks simple enough—just a single function call and a single argument `n`.
    But notice the value for `table` and `args` in `NODE_SCOPE`. These values were
    empty in the parent `NODE_SCOPE`, but they’re set here in the inner `NODE_SCOPE`.
    As you might guess, these values indicate the presence of the block parameter
    `n`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单——只有一个函数调用和一个单一的参数 `n`。但请注意 `NODE_SCOPE` 中 `table` 和 `args` 的值。这些值在父
    `NODE_SCOPE` 中是空的，但在内部的 `NODE_SCOPE` 中被设置了。正如你所猜测的，这些值表明了块参数 `n` 的存在。
- en: '![The branch of the AST for the contents of the block](httpatomoreillycomsourcenostarchimages1853923.png.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![AST 分支，表示块的内容](httpatomoreillycomsourcenostarchimages1853923.png.jpg)'
- en: Figure 2-13. The branch of the AST for the contents of the block
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-13. AST 分支，表示块的内容
- en: Also notice that the Ruby parser created `NODE_DVAR` instead of `NODE_LIT`,
    which we saw earlier in [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block"). This is the
    case because `n` is not just a literal string; it’s a block parameter passed in
    from the parent scope.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，Ruby 解析器创建了 `NODE_DVAR` 而不是我们在[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "图 2-9. 调用 10.times 时的 AST，传递一个块")中看到的 `NODE_LIT`。这是因为 `n` 不仅仅是一个字面量字符串；它是一个从父作用域传递过来的块参数。
- en: From a relatively high level, [Figure 2-14](ch02.html#how_ruby_compiles_a_call_to_a_block
    "Figure 2-14. How Ruby compiles a call to a block") shows how Ruby compiles the
    inner block.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从相对较高的层次来看，[图 2-14](ch02.html#how_ruby_compiles_a_call_to_a_block "图 2-14. Ruby
    如何编译对一个块的调用") 展示了 Ruby 如何编译内部块。
- en: How Ruby Iterates Through the AST
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 如何遍历 AST
- en: Let’s look more closely at how Ruby actually iterates through the AST structure,
    converting each node into YARV instructions. The MRI C source code file that implements
    the Ruby compiler is called *compile.c*. To learn how the code in *compile.c*
    works, we first look for the function `iseq_compile_each`. [Example 2-3](ch02.html#this_c_function_compiles_each_node_in_th
    "Example 2-3. This C function compiles each node in the AST.") shows the beginning
    of that function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 Ruby 是如何实际遍历 AST 结构的，将每个节点转换为 YARV 指令。实现 Ruby 编译器的 MRI C 源代码文件叫做 *compile.c*。为了了解
    *compile.c* 中的代码是如何工作的，我们首先查找 `iseq_compile_each` 函数。[示例 2-3](ch02.html#this_c_function_compiles_each_node_in_th
    "示例 2-3. 这个 C 函数编译了 AST 中的每个节点。") 显示了该函数的开头。
- en: Example 2-3. This C function compiles each node in the AST.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-3. 这个 C 函数编译了 AST 中的每个节点。
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function is very long, with a very, very long `switch` statement that runs
    to thousands of lines! The `switch` statement branches based on the type of the
    current AST node and generates the corresponding YARV code. [Example 2-4](ch02.html#this_c_switch_statement_looks_at_the_typ
    "Example 2-4. This C switch statement looks at the type of each AST node.") shows
    the start of the `switch` statement ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常长，包含一个非常非常长的 `switch` 语句，运行了几千行！`switch` 语句根据当前 AST 节点的类型进行分支，并生成相应的 YARV
    代码。[示例 2-4](ch02.html#this_c_switch_statement_looks_at_the_typ "示例 2-4. 这个 C switch
    语句查看每个 AST 节点的类型。") 显示了 `switch` 语句的开头 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。
- en: Example 2-4. This C `switch` statement looks at the type of each AST node.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-4. 这个 C `switch` 语句查看每个 AST 节点的类型。
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this statement, `node` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    is a parameter passed into `iseq_compile_each`, and `nd_type` is a C macro that
    returns the type from the given node structure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在此语句中，`node` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 是传递给
    `iseq_compile_each` 的参数，而 `nd_type` 是一个 C 宏，用于返回给定节点结构的类型。
- en: Now we’ll look at how Ruby compiles function or method call nodes into YARV
    instructions using the receiver-arguments-function call pattern. First, search
    *compile.c* for the C `case` statement shown in [Example 2-5](ch02.html#this_case_of_the_switch_compiles_method
    "Example 2-5. This case of the switch compiles method calls in your Ruby code.").
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看 Ruby 如何使用接收者-参数-方法调用模式将函数或方法调用节点编译成 YARV 指令。首先，在 *compile.c* 中搜索 [示例
    2-5](ch02.html#this_case_of_the_switch_compiles_method "示例 2-5. 这个 switch 语句的情况编译了你
    Ruby 代码中的方法调用。") 中显示的 C `case` 语句。
- en: Example 2-5. This case of the switch compiles method calls in your Ruby code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-5. 这个 `switch` 语句的情况编译了你 Ruby 代码中的方法调用。
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`NODE_CALL` represents a real method call (like `10.times`), `NODE_FCALL` is
    a function call (like `puts`), and `NODE_VCALL` is a variable or function call.
    Skipping over some of the C code details (including the optional `SUPPORT_JOKE`
    code used for implementing the `goto` statement), [Example 2-6](ch02.html#this_c_code_compiles_the_receiver_value
    "Example 2-6. This C code compiles the receiver value for a method call.") shows
    what Ruby does next to compile these AST nodes.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`NODE_CALL` 代表真实的方法调用（例如 `10.times`），`NODE_FCALL` 是函数调用（例如 `puts`），而 `NODE_VCALL`
    是变量或函数调用。跳过一些 C 代码的细节（包括用于实现 `goto` 语句的可选 `SUPPORT_JOKE` 代码），[示例 2-6](ch02.html#this_c_code_compiles_the_receiver_value
    "示例 2-6. 这段 C 代码编译了方法调用的接收者值。") 展示了 Ruby 下一步如何编译这些 AST 节点。'
- en: Example 2-6. This C code compiles the receiver value for a method call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-6. 这段 C 代码编译了方法调用的接收者值。
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, Ruby calls either `COMPILE` or `ADD_CALL_RECEIVER` as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Ruby 调用 `COMPILE` 或 `ADD_CALL_RECEIVER`，如下所示：
- en: In the case of real method calls (like `NODE_CALL`), Ruby calls `COMPILE` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    to recursively call into `iseq_compile_each` again, processing the next AST node
    down the tree that corresponds to the receiver of the method call or message.
    This will create YARV instructions to evaluate whatever expression was used to
    specify the target object.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在真实方法调用的情况下（例如 `NODE_CALL`），Ruby 调用 `COMPILE` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    来递归调用 `iseq_compile_each`，继续处理与方法调用或消息的接收者对应的 AST 树中的下一个节点。这将创建 YARV 指令，用于评估用于指定目标对象的任何表达式。
- en: If there is no receiver (`NODE_FCALL` or `NODE_VCALL`), Ruby calls `ADD_CALL_RECEIVER`
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg), which creates a `putself`
    YARV instruction.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有接收者（`NODE_FCALL` 或 `NODE_VCALL`），Ruby 会调用 `ADD_CALL_RECEIVER` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)，这会创建一个
    `putself` YARV 指令。
- en: Next, as shown in [Example 2-7](ch02.html#this_snippet_of_c_code_compiles_the_argu
    "Example 2-7. This snippet of C code compiles the arguments to every Ruby method
    call."), Ruby creates YARV instructions to push each argument of the method/function
    call onto the stack.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如在[示例 2-7](ch02.html#this_snippet_of_c_code_compiles_the_argu "示例 2-7.
    这段 C 代码编译每个 Ruby 方法调用的参数")中所示，Ruby 创建 YARV 指令将每个方法/函数调用的参数压入栈中。
- en: Example 2-7. This snippet of C code compiles the arguments to every Ruby method
    call.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-7. 这段 C 代码编译每个 Ruby 方法调用的参数。
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For `NODE_CALL` and `NODE_FCALL`, Ruby calls into the `setup_args` function
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg), which will recursively
    call into `iseq_compile_each` again as needed in order to compile each argument
    to the method/function call. For `NODE_VCALL`, there are no arguments, so Ruby
    simply sets `argc` to 0 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `NODE_CALL` 和 `NODE_FCALL`，Ruby 会调用 `setup_args` 函数 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，该函数将在需要时递归调用
    `iseq_compile_each` 以编译每个方法/函数调用的参数。对于 `NODE_VCALL`，没有参数，因此 Ruby 只需将 `argc` 设置为
    0 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。
- en: 'Finally, Ruby creates YARV instructions to execute the actual method or function
    call, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Ruby 创建 YARV 指令来执行实际的方法或函数调用，如下所示：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This C macro will create the new `send` YARV instruction, which will cause the
    actual method call to occur when YARV executes it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 C 宏将创建新的 `send` YARV 指令，当 YARV 执行它时，将导致实际的方法调用发生。
- en: '![How Ruby compiles a call to a block](httpatomoreillycomsourcenostarchimages1853925.png.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 如何编译对块的调用](httpatomoreillycomsourcenostarchimages1853925.png.jpg)'
- en: Figure 2-14. How Ruby compiles a call to a block
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-14. Ruby 如何编译对块的调用
- en: You can see the parent `NODE_SCOPE` at the top, along with the YARV code from
    [Figure 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call "Figure 2-12. Ruby
    compiles the 10.times method call."). Below that I’ve listed the YARV code compiled
    from the inner block’s AST.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在顶部看到父级 `NODE_SCOPE`，以及来自[图 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call
    "图 2-12. Ruby 编译 10.times 方法调用")的 YARV 代码。在下面，我列出了从内部块的 AST 编译的 YARV 代码。
- en: The key point here is that Ruby compiles each distinct scope in your Ruby program—methods,
    blocks, classes, or modules, for example—into a separate snippet of YARV instructions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于，Ruby 会将你程序中每个独立的作用域——例如方法、块、类或模块——编译成一段独立的 YARV 指令。
- en: 'Experiment 2-1: Displaying YARV Instructions'
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 2-1：显示 YARV 指令
- en: One easy way to see how Ruby compiles your code is with the `RubyVM::InstructionSequence`
    object, which gives you access to Ruby’s YARV engine from your Ruby program! Like
    the Ripper tool, its use is very straightforward, as you can see in [Example 2-8](ch02.html#how_to_view_the_yarv_instructions_for_pu
    "Example 2-8. How to view the YARV instructions for puts 2+2").
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Ruby 如何编译代码的一个简单方法是使用 `RubyVM::InstructionSequence` 对象，它让你可以从 Ruby 程序中访问
    Ruby 的 YARV 引擎！像 Ripper 工具一样，它的使用非常直接，正如你在[示例 2-8](ch02.html#how_to_view_the_yarv_instructions_for_pu
    "示例 2-8. 如何查看 puts 2+2 的 YARV 指令")中看到的那样。
- en: Example 2-8. How to view the YARV instructions for `puts 2+2`
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-8. 如何查看 `puts 2+2` 的 YARV 指令
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The challenge lies in understanding what the output actually means. For example,
    [Example 2-9](ch02.html#yarv_instructions_for_puts_2plus2 "Example 2-9. The YARV
    instructions for puts 2+2") shows the output for `puts 2+2`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于理解输出的实际含义。例如，[示例 2-9](ch02.html#yarv_instructions_for_puts_2plus2 "示例 2-9.
    `puts 2+2` 的 YARV 指令") 展示了 `puts 2+2` 的输出。
- en: Example 2-9. The YARV instructions for `puts 2+2`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-9. `puts 2+2` 的 YARV 指令
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in [Example 2-9](ch02.html#yarv_instructions_for_puts_2plus2
    "Example 2-9. The YARV instructions for puts 2+2"), the output contains all of
    the same instructions from [Figure 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir
    "Figure 2-5. To compile a function call, Ruby first creates an instruction to
    push the receiver.") to [Figure 2-8](ch02.html#ruby_replaces_some_instructions_with_spe
    "Figure 2-8. Ruby replaces some instructions with specialized instructions.")
    and two new ones: `trace` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and `leave` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). The `trace`
    instruction is used to implement the `set_trace_func` feature, which will call
    a given function for each Ruby statement executed in your program. The `leave`
    function is like a return statement. The line numbers on the left show the position
    of each instruction in the bytecode array that the compiler actually produces.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[示例 2-9](ch02.html#yarv_instructions_for_puts_2plus2 "示例 2-9. puts 2+2 的
    YARV 指令")中看到的，输出包含了从[图 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir
    "图 2-5. Ruby 如何编译函数调用，首先会创建一条指令来推送接收者。")到[图 2-8](ch02.html#ruby_replaces_some_instructions_with_spe
    "图 2-8. Ruby 如何用专用指令替换一些指令。")的所有相同指令，并增加了两条新指令：`trace` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    和 `leave` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。`trace` 指令用于实现
    `set_trace_func` 功能，这将在程序中执行每条 Ruby 语句时调用给定的函数。`leave` 功能类似于返回语句。左侧的行号显示了每条指令在编译器实际生成的字节码数组中的位置。
- en: '`RubyVM::InstructionSequence` makes it easy to explore how Ruby compiles different
    Ruby scripts. For example, [Example 2-10](ch02.html#displaying_the_yarv_instructions_for_a_c
    "Example 2-10. Displaying the YARV instructions for a call to a block") shows
    how to compile my `10.times do` example.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`RubyVM::InstructionSequence` 使得探索 Ruby 如何编译不同 Ruby 脚本变得容易。例如，[示例 2-10](ch02.html#displaying_the_yarv_instructions_for_a_c
    "示例 2-10. 显示调用块的 YARV 指令") 演示了如何编译我的 `10.times do` 示例。'
- en: Example 2-10. Displaying the YARV instructions for a call to a block
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-10. 显示调用块的 YARV 指令
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output that I get now is shown below in [Example 2-11](ch02.html#yarv_instructions_for_a_call_to_a_bl
    "Example 2-11. The YARV instructions for a call to a block and for the block itself").
    Notice that the `send <callinfo!mid:times` YARV instruction shows `block:block
    in <compiled>` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg), which
    indicates that I’m passing a block to the `10.times` method call.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在得到的输出如下所示，在[示例 2-11](ch02.html#yarv_instructions_for_a_call_to_a_bl "示例 2-11.
    调用块和块本身的 YARV 指令")中显示。注意，`send <callinfo!mid:times` YARV 指令显示了 `block:block in
    <compiled>` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)，这表示我正在向
    `10.times` 方法调用传递一个块。
- en: Example 2-11. The YARV instructions for a call to a block and for the block
    itself
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-11. 调用块和块本身的 YARV 指令
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, Ruby displays the two YARV instruction snippets separately.
    The first corresponds to the global scope ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and the second to the inner block scope ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Ruby 将两个 YARV 指令片段分别显示。第一个对应全局作用域 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，第二个对应内部块作用域
    ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)。
- en: The Local Table
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地表
- en: In [Figure 2-3](ch02.html#ast_ruby_produces_after_parsing_the "Figure 2-3. The
    AST Ruby produces after parsing the code in Example 2-1") through [Figure 2-14](ch02.html#how_ruby_compiles_a_call_to_a_block
    "Figure 2-14. How Ruby compiles a call to a block"), you may have noticed that
    each `NODE_SCOPE` element in the AST contained information I labeled `table` and
    `args`. These values in the inner `NODE_SCOPE` structure contain information about
    the block’s parameter `n` (see [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block")).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-3](ch02.html#ast_ruby_produces_after_parsing_the "图 2-3. Ruby 在解析示例 2-1
    中的代码后生成的 AST")到[图 2-14](ch02.html#how_ruby_compiles_a_call_to_a_block "图 2-14.
    Ruby 如何编译调用块的代码")之间，你可能已经注意到，AST 中的每个 `NODE_SCOPE` 元素包含了我标记为 `table` 和 `args`
    的信息。这些值存在于内部的 `NODE_SCOPE` 结构中，包含关于块参数 `n` 的信息（请参见[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "图 2-9. 调用 10.times 时传递块的 AST")）。
- en: 'Ruby generated the information about this block parameter during the parsing
    process. As I discussed in [Chapter 1](ch01.html "Chapter 1. Tokenization and
    Parsing"), Ruby parses the block parameter along with the rest of my Ruby code
    using grammar rules. In fact, I showed the specific rule for parsing block parameters
    back in [Figure 1-30](ch01.html#entire_block_matches_the_braceunders "Figure 1-30. The
    entire block matches the brace_block rule."): `opt_block_param`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 在解析过程中生成了关于这个块参数的信息。正如我在[第 1 章](ch01.html "第 1 章. 词法分析与解析")中讨论的那样，Ruby
    会使用语法规则解析块参数以及其他 Ruby 代码。实际上，我在[图 1-30](ch01.html#entire_block_matches_the_braceunders
    "图 1-30. 整个块匹配 brace_block 规则")中展示了解析块参数的具体规则：`opt_block_param`。
- en: Once Ruby’s compiler runs, however, the information about the block parameter
    is copied out of the AST and into another data structure called the *local table*,
    saved nearby the newly generated YARV instructions. Each snippet of YARV instructions,
    each scope in your Ruby program, has its own local table.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦 Ruby 的编译器运行时，关于块参数的信息会被从 AST 中复制到另一个数据结构中，这个结构被称为*局部表格*，并保存在新生成的 YARV
    指令附近。你的 Ruby 程序中的每个 YARV 指令片段，每个作用域，都有它自己的局部表格。
- en: '[Figure 2-15](ch02.html#snippet_of_yarv_instructions_with_a_lo "Figure 2-15. A
    snippet of YARV instructions with a local table") shows the local table attached
    to the YARV instructions that Ruby generated for the sample block code from [Example 2-2](ch02.html#simple_script_that_calls_a_block
    "Example 2-2. A simple script that calls a block").'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-15](ch02.html#snippet_of_yarv_instructions_with_a_lo "图 2-15. 一个带有局部表格的
    YARV 指令片段")展示了 Ruby 为[示例 2-2](ch02.html#simple_script_that_calls_a_block "示例 2-2.
    一个调用块的简单脚本")中的示例块代码生成的 YARV 指令和附带的局部表格。'
- en: '![A snippet of YARV instructions with a local table](httpatomoreillycomsourcenostarchimages1853927.png.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![带有局部表格的 YARV 指令片段](httpatomoreillycomsourcenostarchimages1853927.png.jpg)'
- en: Figure 2-15. A snippet of YARV instructions with a local table
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-15. 一个带有局部表格的 YARV 指令片段
- en: Notice on the right side of [Figure 2-15](ch02.html#snippet_of_yarv_instructions_with_a_lo
    "Figure 2-15. A snippet of YARV instructions with a local table") that Ruby has
    associated the number 2 with the block parameter `n`. As we’ll see in [Chapter 3](ch03.html
    "Chapter 3. How Ruby Executes Your Code"), the YARV instructions that refer to
    `n` will use this index 2\. The `getlocal` instruction is an example of this.
    The `<Arg>` notation indicates that this value is an argument to the block.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[图 2-15](ch02.html#snippet_of_yarv_instructions_with_a_lo "图 2-15. 一个带有局部表格的
    YARV 指令片段")的右侧，Ruby 已经将数字 2 与块参数 `n` 关联。如我们在[第 3 章](ch03.html "第 3 章. Ruby 如何执行你的代码")中将看到的那样，引用
    `n` 的 YARV 指令将使用这个索引 2。`getlocal` 指令就是一个例子。`<Arg>` 表示该值是块的一个参数。
- en: As it turns out, Ruby also saves information about local variables in this table,
    hence the name *local table*. [Figure 2-16](ch02.html#this_local_table_contains_one_local_vari
    "Figure 2-16. This local table contains one local variable and two arguments.")
    shows the YARV instructions and local table Ruby will generate when compiling
    a method that uses one local variable and takes two arguments.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，Ruby 还会在这个表格中保存关于局部变量的信息，因此这个表格被称为*局部表格*。[图 2-16](ch02.html#this_local_table_contains_one_local_vari
    "图 2-16. 这个局部表格包含一个局部变量和两个参数。")展示了 Ruby 在编译使用一个局部变量并接收两个参数的方法时，会生成的 YARV 指令和局部表格。
- en: '![This local table contains one local variable and two arguments.](httpatomoreillycomsourcenostarchimages1853929.png.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![这个局部表格包含一个局部变量和两个参数。](httpatomoreillycomsourcenostarchimages1853929.png.jpg)'
- en: Figure 2-16. This local table contains one local variable and two arguments.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-16. 这个局部表格包含一个局部变量和两个参数。
- en: Here, you can see that Ruby lists all three values in the local table. As we’ll
    see in [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code"), Ruby treats
    local variables and method arguments in the same way. (Notice that the local variable
    `sum` does not have the `<Arg>` label.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 Ruby 在局部表格中列出了所有三个值。正如我们在[第 3 章](ch03.html "第 3 章. Ruby 如何执行你的代码")中将看到的那样，Ruby
    以相同的方式对待局部变量和方法参数。（请注意，局部变量 `sum` 没有 `<Arg>` 标签。）
- en: 'Think of the local table as a key to help you understand what the YARV instructions
    do, similar to the legend on a map. As you can see in [Figure 2-16](ch02.html#this_local_table_contains_one_local_vari
    "Figure 2-16. This local table contains one local variable and two arguments."),
    local variables have no label, but Ruby uses the following labels to describe
    different types of method and block arguments:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把本地表格看作是帮助你理解 YARV 指令的钥匙，类似于地图上的图例。如同在[图 2-16](ch02.html#this_local_table_contains_one_local_vari
    "图 2-16. 这个本地表格包含一个本地变量和两个参数")中所示，本地变量没有标签，但 Ruby 使用以下标签来描述不同类型的方法和块参数：
- en: '| **`<Arg>`** | A standard method or block argument |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **`<Arg>`** | 一个标准的函数或块参数 |'
- en: '| **`<Rest>`** | An array of unnamed arguments that are passed together using
    a splat (`*`) operator |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **`<Rest>`** | 一个无名参数数组，通过 splat (`*`) 运算符一起传递 |'
- en: '| **`<Post>`** | A standard argument that appears after the splat array |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **`<Post>`** | 一个出现在 splat 数组之后的标准参数 |'
- en: '| **`<Block>`** | A Ruby proc object that is passed using the `&` operator
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **`<Block>`** | 一个 Ruby proc 对象，通过 `&` 运算符传递 |'
- en: '| **`<Opt=i>`** | A parameter defined with a default value. The integer value
    `i` is an index into a table that stores the actual default value. This table
    is stored along with the YARV snippet but not in the local table itself. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **`<Opt=i>`** | 定义了默认值的参数。整数值 `i` 是一个索引，指向一个存储实际默认值的表格。这个表格与 YARV 代码片段一起存储，但不在本地表格中。
    |'
- en: Understanding the information displayed by the local table can help you understand
    how Ruby’s complex argument syntax works and how to take full advantage of the
    language.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 理解本地表格显示的信息可以帮助你理解 Ruby 复杂的参数语法如何工作，以及如何充分利用这门语言。
- en: To help you understand what I mean, let’s look at how Ruby compiles a method
    call that uses an array of unnamed arguments, as shown [Example 2-12](ch02.html#method_that_takes_standard_arguments_a
    "Example 2-12. A method that takes standard arguments and an array of unnamed
    arguments").
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解我的意思，让我们来看一下 Ruby 如何编译一个使用无名参数数组的函数调用，如[示例 2-12](ch02.html#method_that_takes_standard_arguments_a
    "示例 2-12. 一个接受标准参数和无名参数数组的方法")所示。
- en: Example 2-12. A method that takes standard arguments and an array of unnamed
    arguments
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-12. 一个接受标准参数和无名参数数组的方法
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here `a`, `b`, and `c` are standard arguments, and `args` is an array of other
    arguments that appear between `b` and `c`. [Figure 2-17](ch02.html#ruby_saves_information_about_special_arg
    "Figure 2-17. Ruby saves information about special arguments in the local table.")
    shows how the local table saves all of this information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `a`、`b` 和 `c` 是标准参数，`args` 是一个位于 `b` 和 `c` 之间的其他参数数组。[图 2-17](ch02.html#ruby_saves_information_about_special_arg
    "图 2-17. Ruby 将有关特殊参数的信息保存在本地表格中。") 展示了本地表格如何保存所有这些信息。
- en: As in [Figure 2-16](ch02.html#this_local_table_contains_one_local_vari "Figure 2-16. This
    local table contains one local variable and two arguments."), `<Arg>` refers to
    a standard argument. But now Ruby uses `<Rest>` to indicate that value 3 contains
    the “rest” of the arguments and `<Post>` to indicate that value 2 contains the
    argument that appears after the unnamed array, the last one.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[图 2-16](ch02.html#this_local_table_contains_one_local_vari "图 2-16. 这个本地表格包含一个本地变量和两个参数")中所示，`<Arg>`
    代表标准参数。但现在 Ruby 使用 `<Rest>` 来表示值 3 包含“其余”参数，并使用 `<Post>` 来表示值 2 包含出现在无名数组之后的参数，即最后一个参数。
- en: '![Ruby saves information about special arguments in the local table.](httpatomoreillycomsourcenostarchimages1853931.png.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 将有关特殊参数的信息保存在本地表格中。](httpatomoreillycomsourcenostarchimages1853931.png.jpg)'
- en: Figure 2-17. Ruby saves information about special arguments in the local table.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-17. Ruby 将有关特殊参数的信息保存在本地表格中。
- en: Compiling Optional Arguments
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译可选参数
- en: As you probably know, you can make an argument optional by specifying a default
    value for it in the argument list. Later, Ruby will use the default value if you
    don’t provide a value for that argument when you call the method or block. [Example 2-13](ch02.html#method_that_takes_an_optional_argument
    "Example 2-13. A method that takes an optional argument") shows a simple example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，你可以通过在参数列表中为某个参数指定默认值，使该参数变为可选的。之后，如果你在调用方法或块时没有提供该参数的值，Ruby 会使用默认值。[示例
    2-13](ch02.html#method_that_takes_an_optional_argument "示例 2-13. 一个接受可选参数的方法")展示了一个简单的例子。
- en: Example 2-13. A method that takes an optional argument
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-13. 一个接受可选参数的方法
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you provide a value for `b`, the method will use that value as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为 `b` 提供一个值，方法将按照以下方式使用该值：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But if you don’t, Ruby will assign the default value of 5 to `b`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你不提供，Ruby会将默认值5赋给`b`：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ruby has a bit more work to do in this situation. Where does the default value
    go? Where does the Ruby compiler put it? [Figure 2-18](ch02.html#rubyapostrophes_compiler_generates_extra
    "Figure 2-18. Ruby’s compiler generates extra code to handle optional arguments.")
    shows how Ruby generates a few extra YARV instructions during the compile process
    that set the default value.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Ruby需要做更多工作。默认值放在哪里？Ruby编译器将其放在哪里？[图2-18](ch02.html#rubyapostrophes_compiler_generates_extra
    "图2-18. Ruby的编译器生成额外的代码来处理可选参数")显示了Ruby如何在编译过程中生成一些额外的YARV指令来设置默认值。
- en: '![Ruby’s compiler generates extra code to handle optional arguments.](httpatomoreillycomsourcenostarchimages1853933.png.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby的编译器生成额外的代码来处理可选参数。](httpatomoreillycomsourcenostarchimages1853933.png.jpg)'
- en: Figure 2-18. Ruby’s compiler generates extra code to handle optional arguments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-18. Ruby的编译器生成额外的代码来处理可选参数。
- en: Ruby’s compiler generates the bolded YARV instructions, `putobject` and `setlocal`,
    to set the value of `b` to 5 when you call the method. (As we’ll see in [Chapter 3](ch03.html
    "Chapter 3. How Ruby Executes Your Code"), YARV will call these instructions if
    you don’t provide a value for `b` but skip them if you do.) You can also see that
    Ruby lists the optional argument `b` in the local table as `b<Opt=0>`. The `0`
    here is an index into a table that stores the default values for all the arguments.
    Ruby stores this data near the YARV snippet but not in the local table itself.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby的编译器生成了加粗的YARV指令`putobject`和`setlocal`，在你调用方法时将`b`的值设为5。（正如我们在[第3章](ch03.html
    "第3章. Ruby如何执行你的代码")中看到的那样，YARV会在你没有为`b`提供值时调用这些指令，但如果你提供了值，它们则会被跳过。）你还可以看到，Ruby在本地表中将可选参数`b`列出为`b<Opt=0>`。这里的`0`是一个索引，指向一个存储所有参数默认值的表。Ruby将这些数据存储在接近YARV代码片段的位置，而不是在本地表中本身。
- en: Compiling Keyword Arguments
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译关键字参数
- en: In Ruby 2.0, we can specify a name along with a default value for each method
    or block argument. Arguments written this way are known as *keyword arguments*.
    For example, [Example 2-14](ch02.html#method_that_takes_a_keyword_argument "Example 2-14. A
    method that takes a keyword argument") shows the same argument `b` declared using
    Ruby 2.0’s new keyword argument syntax.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby 2.0中，我们可以为每个方法或块参数指定一个名称和默认值。这样写的参数被称为*关键字参数*。例如，[示例 2-14](ch02.html#method_that_takes_a_keyword_argument
    "示例 2-14. 一个接受关键字参数的方法")展示了使用Ruby 2.0新关键字参数语法声明的相同参数`b`。
- en: Example 2-14. A method that takes a keyword argument
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-14. 一个接受关键字参数的方法
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now to provide a value for `b`, I need to use its name:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要为`b`提供一个值，我需要使用它的名称：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or, if I don’t specify `b` at all, Ruby will use the default value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我根本不指定`b`，Ruby将使用默认值：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How does Ruby compile keyword arguments? [Figure 2-19](ch02.html#ruby_compiler_generates_many_more_in
    "Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments.") shows Ruby needs to add quite a bit of additional code to the method’s
    YARV snippet.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby是如何编译关键字参数的？[图2-19](ch02.html#ruby_compiler_generates_many_more_in "图2-19.
    Ruby编译器生成更多指令来处理关键字参数")显示Ruby需要为方法的YARV代码片段添加相当多的额外代码。
- en: '![The Ruby compiler generates many more instructions to handle keyword arguments.](httpatomoreillycomsourcenostarchimages1853935.png.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby编译器生成更多指令来处理关键字参数。](httpatomoreillycomsourcenostarchimages1853935.png.jpg)'
- en: Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-19. Ruby编译器生成更多指令来处理关键字参数。
- en: 'The Ruby compiler generates all of the YARV instructions in bold—13 new instructions—to
    implement the keyword argument `b`. In [Chapter 3](ch03.html "Chapter 3. How Ruby
    Executes Your Code") and [Chapter 4](ch04.html "Chapter 4. Control Structures
    and Method Dispatch"), I’ll cover how YARV works in detail and what these instructions
    actually mean, but for now, we can guess what’s going on here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby的编译器生成了所有加粗的YARV指令，共13条新指令，用于实现关键字参数`b`。[第3章](ch03.html "第3章. Ruby如何执行你的代码")和[第4章](ch04.html
    "第4章. 控制结构和方法调度")中，我会详细讲解YARV的工作原理以及这些指令的实际含义，但现在，我们可以大致猜测这里发生了什么：
- en: In the local table, we can see a new mystery value shown as `[ 3]?`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地表中，我们可以看到一个新的神秘值，显示为`[ 3]?`。
- en: To the left of [Figure 2-19](ch02.html#ruby_compiler_generates_many_more_in
    "Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments."), new YARV instructions call the `key?` and `delete` methods.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[图2-19](ch02.html#ruby_compiler_generates_many_more_in "图2-19. Ruby编译器生成更多指令来处理关键字参数")的左侧，新的YARV指令调用了`key?`和`delete`方法。
- en: Which Ruby class contains the `key?` and `delete` methods? The `Hash`. [Figure 2-19](ch02.html#ruby_compiler_generates_many_more_in
    "Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments.") shows evidence that Ruby must implement keyword arguments using an
    internal, hidden hash object. All of these additional YARV instructions automatically
    add some logic to my method that checks this hash for the argument `b`. If Ruby
    finds the value of `b` in the hash, it uses it. If not, it uses the default value
    of 5\. The mystery element `[3]?` in the local table must be this hidden hash
    object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个Ruby类包含`key?`和`delete`方法？是`Hash`。 [图2-19](ch02.html#ruby_compiler_generates_many_more_in
    "图2-19. Ruby编译器生成更多指令来处理关键字参数")显示了Ruby必须使用一个内部的、隐藏的哈希对象来实现关键字参数的证据。所有这些额外的YARV指令会自动在我的方法中添加一些逻辑，用于检查这个哈希中是否有参数`b`。如果Ruby在哈希中找到了`b`的值，它就使用它。如果没有，它就使用默认值5。局部表中的神秘元素`[3]?`必须就是这个隐藏的哈希对象。
- en: 'Experiment 2-2: Displaying the Local Table'
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验2-2：显示局部表
- en: Along with YARV instructions, `RubyVM::InstructionSequence` will also display
    the local table associated with each YARV snippet or scope. Finding and understanding
    the local table for your code will help you to understand what the corresponding
    YARV instructions do. In this experiment, we’ll look at where the local table
    appears in the output generated by the `RubyVM::InstructionSequence` object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了YARV指令，`RubyVM::InstructionSequence` 还会显示与每个YARV片段或作用域相关的局部表。查找并理解你代码的局部表将帮助你理解相应的YARV指令的作用。在这个实验中，我们将查看`RubyVM::InstructionSequence`对象生成的输出中局部表的位置。
- en: '[Example 2-15](ch02.html#displaying_the_yarv_instructions-id00006 "Example 2-15. Displaying
    the YARV instructions for a call to a block") repeats [Example 2-10](ch02.html#displaying_the_yarv_instructions_for_a_c
    "Example 2-10. Displaying the YARV instructions for a call to a block") from [Experiment
    2-1: Displaying YARV Instructions](ch02.html#experiment_2-1_displaying_yarv_instructi
    "Experiment 2-1: Displaying YARV Instructions").'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例2-15](ch02.html#displaying_the_yarv_instructions-id00006 "示例2-15. 显示调用块的YARV指令")重复了[示例2-10](ch02.html#displaying_the_yarv_instructions_for_a_c
    "示例2-10. 显示调用块的YARV指令")，来自[实验2-1：显示YARV指令](ch02.html#experiment_2-1_displaying_yarv_instructi
    "实验2-1：显示YARV指令")。'
- en: Example 2-15. Displaying the YARV instructions for a call to a block
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-15. 显示调用块的YARV指令
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And [Example 2-16](ch02.html#along_with_the_yarv_instructionscomma_ru "Example 2-16. Along
    with the YARV instructions, RubyVM::InstructionSequence displays the local table.")
    repeats the output we saw earlier in [Experiment 2-1: Displaying YARV Instructions](ch02.html#experiment_2-1_displaying_yarv_instructi
    "Experiment 2-1: Displaying YARV Instructions").'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 而[示例2-16](ch02.html#along_with_the_yarv_instructionscomma_ru "示例2-16. 除了YARV指令，RubyVM::InstructionSequence还显示局部表")重复了我们在[实验2-1：显示YARV指令](ch02.html#experiment_2-1_displaying_yarv_instructi
    "实验2-1：显示YARV指令")中看到的输出。
- en: Example 2-16. Along with the YARV instructions, `RubyVM::InstructionSequence`
    displays the local table.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-16. 除了YARV指令，`RubyVM::InstructionSequence` 显示局部表。
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Just above the YARV snippet for the inner scope—the block—we see information
    about its local table at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    This displays the total size of the table (`size: 2`), the argument count (`argc:
    1`), and other information about the types of parameters (`opts: 0, rest: -1,
    post: 0`).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '在内层作用域的YARV代码片段——即块——上方，我们可以看到其局部表的信息，位于 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。这显示了表的总大小（`size:
    2`）、参数计数（`argc: 1`）以及其他关于参数类型的信息（`opts: 0, rest: -1, post: 0`）。'
- en: The second line ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) shows
    the actual contents of the local table. In this example, we have just one argument,
    `n`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 显示了局部表的实际内容。在这个示例中，我们只有一个参数，`n`。
- en: '[Example 2-17](ch02.html#this_method_uses_unnamed_arguments_with "Example 2-17. This
    method uses unnamed arguments with a splat operator.") shows how to use `RubyVM::InstructionSequence`
    in the same way to compile my unnamed arguments example from [Example 2-12](ch02.html#method_that_takes_standard_arguments_a
    "Example 2-12. A method that takes standard arguments and an array of unnamed
    arguments").'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-17](ch02.html#this_method_uses_unnamed_arguments_with "示例 2-17. 该方法使用带星号操作符的未命名参数")展示了如何以相同的方式使用`RubyVM::InstructionSequence`来编译我的未命名参数示例，参考[示例
    2-12](ch02.html#method_that_takes_standard_arguments_a "示例 2-12. 一个接受标准参数和未命名参数数组的方法")。'
- en: Example 2-17. This method uses unnamed arguments with a splat operator.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-17. 该方法使用带星号操作符的未命名参数。
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And [Example 2-18](ch02.html#displaying_the_yarv_instructions-id00007 "Example 2-18. Displaying
    the YARV instructions for a call to a block") shows the output.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 而[示例 2-18](ch02.html#displaying_the_yarv_instructions-id00007 "示例 2-18. 显示调用块的YARV指令输出")展示了输出结果。
- en: Example 2-18. Displaying the YARV instructions for a call to a block
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-18. 显示调用块的YARV指令输出
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The top YARV scope, around ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    shows the instructions YARV uses to define a new method. Notice the call to `core#define_method`
    at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg), an internal C function
    that YARV uses to create new Ruby methods. This corresponds to calling `def complex_formula`
    in my script. (I’ll discuss how Ruby implements methods in more detail in [Chapter 5](ch05.html
    "Chapter 5. Objects and Classes"), [Chapter 6](ch06.html "Chapter 6. Method Lookup
    and Constant Lookup"), and [Chapter 9](ch09.html "Chapter 9. Metaprogramming").)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层YARV作用域，位于![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)附近，展示了YARV用来定义新方法的指令。请注意在![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)处调用了`core#define_method`，这是一个YARV用于创建Ruby新方法的内部C函数。这对应于我脚本中调用`def
    complex_formula`的部分。（我将在[第5章](ch05.html "第5章. 对象与类")、[第6章](ch06.html "第6章. 方法查找与常量查找")和[第9章](ch09.html
    "第9章. 元编程")中更详细地讨论Ruby是如何实现方法的。）
- en: 'Notice the local table for the lower YARV snippet at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
    This line now shows more information about the unnamed arguments (`rest: 2`) and
    the last standard argument following them (`post: 1`). Finally, the line at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    shows the contents of the local table that I showed back in [Figure 2-17](ch02.html#ruby_saves_information_about_special_arg
    "Figure 2-17. Ruby saves information about special arguments in the local table.").'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意位于![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)处的较低YARV片段的局部表。此行现在显示了更多关于未命名参数（`rest:
    2`）和它们后面的最后一个标准参数（`post: 1`）的信息。最后，位于![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)的这一行显示了我之前在[图2-17](ch02.html#ruby_saves_information_about_special_arg
    "图2-17. Ruby将特殊参数的信息保存在局部表中")中展示的局部表内容。'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how Ruby compiles our code. You may think of Ruby
    as a dynamic scripting language, but, in fact, it uses a compiler just like C,
    Java, and many other programming languages. The obvious difference is that Ruby’s
    compiler runs automatically behind the scenes; you never need to worry about compiling
    your Ruby code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Ruby是如何编译我们的代码的。你可能认为Ruby是一个动态脚本语言，但事实上，它使用的编译器和C、Java以及许多其他编程语言一样。明显的区别在于，Ruby的编译器自动在后台运行；你不需要担心编译Ruby代码。
- en: We’ve learned that Ruby’s compiler works by iterating through the AST produced
    by the tokenizing and parsing processes, generating a series of bytecode instructions
    along the way. Ruby translates your code from Ruby into a language tailored for
    the YARV virtual machine, and it compiles every scope or section of your Ruby
    program into a different snippet or set of these YARV instructions. Every block,
    method, lambda, or other scope in your program has a corresponding set of bytecode
    instructions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，Ruby的编译器通过遍历由分词和解析过程生成的抽象语法树（AST）来工作，并在此过程中生成一系列字节码指令。Ruby将您的代码从Ruby语言转换为专门为YARV虚拟机量身定制的语言，它会将Ruby程序中的每个作用域或部分编译成一组或一段YARV指令。您程序中的每个块、方法、lambda或其他作用域都有一组对应的字节码指令。
- en: We’ve also seen how Ruby handles different types of arguments. We were able
    to use the local table as a key or legend for understanding which YARV instructions
    accessed which arguments or local variables. And we saw how Ruby’s compiler generates
    additional, special YARV instructions to handle optional and keyword parameters.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也已经了解了 Ruby 如何处理不同类型的参数。我们能够使用本地表作为一个关键或图例，帮助理解哪些 YARV 指令访问了哪些参数或局部变量。并且我们看到了
    Ruby 的编译器如何生成额外的特殊 YARV 指令来处理可选参数和关键字参数。
- en: In [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code"), I’ll begin
    to explain how YARV executes the instructions produced by the compiler—that is,
    how YARV executes your Ruby program.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。Ruby 如何执行你的代码")中，我将开始解释 YARV 如何执行编译器生成的指令——也就是 YARV 如何执行你的
    Ruby 程序。
