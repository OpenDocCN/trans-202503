- en: '12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '12'
- en: FILSKA
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: FILSKA
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: It’s time to design our first esolang, Filska. Filska, pronounced “full-ska,”
    is a word in the dialect of the Shetland Islands. It means “high-spirited fun.”
    Whether a programming language can embody such a thing is up for reasonable debate,
    but, as with most esolangs, fun is an ingredient, so the name seems appropriate.
    (As an aside, if you happen to enjoy Scottish fiddle music, as I do, you might
    look for music by a band from Shetland with the same name. The convergence of
    names is pure chance, I assure you.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是设计我们第一个 esolang 的时候了，Filska。Filska（发音为“full-ska”）是设得兰群岛方言中的一个词，意思是“充满活力的乐趣”。是否编程语言能体现这样的特质是值得合理讨论的，但和大多数
    esolang 一样，乐趣是其中的一个元素，所以这个名字似乎是合适的。（顺便说一句，如果你像我一样喜欢苏格兰小提琴音乐，可以找一支来自设得兰的乐队的音乐，乐队的名字和这个语言一样。这个名字的巧合纯属偶然，我向你保证。）
- en: In this chapter, we’ll outline Filska’s philosophy and design. Then, we’ll create
    an interpreter for it in Python. We’ll experiment with Filska itself in [Chapter
    13](ch13.xhtml#ch13).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述 Filska 的哲学与设计。接下来，我们将在 Python 中为它创建一个解释器。在 [第 13 章](ch13.xhtml#ch13)
    中，我们将实际尝试使用 Filska。
- en: '**Philosophy and Design**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**哲学与设计**'
- en: 'Filska is an answer to this question: what is it like to program in a language
    where each subprogram can manipulate only a single memory location?'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 是对这个问题的回答：在一个每个子程序只能操作一个内存位置的语言中编程是什么感觉？
- en: Filska works with floating-point numbers and the language itself is simple to
    make implementing the interpreter easy. As we’ve seen, this is often the case
    with esolangs. So superficially, Filska looks a bit like assembly language. We’re
    interested in the experience of trying to code in a restricted language, one where
    each subprogram is allowed to manipulate only a single memory location; therefore,
    we might be excused for making the syntax simple.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 支持浮点数，并且语言本身非常简单，使得实现解释器变得容易。正如我们所看到的，这通常是 esolang 的特点。所以表面上看，Filska
    有点像汇编语言。我们更感兴趣的是尝试在一种受限语言中编码的体验，在这种语言中，每个子程序只被允许操作一个内存位置；因此，我们或许可以理解为什么语法如此简单。
- en: Of course, if each subprogram manipulates only its own memory location, there
    is no way to share information between subprograms. A typical solution to such
    a problem is to use a stack, á la Forth, but we’ll be even more restrictive and
    emulate simple microprocessors. Therefore, Filska supports three floating-point
    registers, X, Y, and Z, which any subprogram can manipulate along with its memory
    location. And, as with many simple microprocessors, the registers are somewhat
    limited in their abilities. We might think of each Filska subprogram as having
    its own accumulator along with access to the three index registers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果每个子程序只能操作其自身的内存位置，那么子程序之间就无法共享信息。解决这种问题的典型方法是使用栈，类似于 Forth，但我们会更加严格，模拟简单的微处理器。因此，Filska
    支持三个浮点寄存器，X、Y 和 Z，任何子程序都可以在操作自己的内存位置的同时操作这些寄存器。与许多简单的微处理器一样，这些寄存器的能力是有限的。我们可以将每个
    Filska 子程序视为拥有自己的累加器，并能访问三个索引寄存器。
- en: Conceptually, a Filska program looks like [Figure 12-1](ch12.xhtml#ch012fig1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上看，一个 Filska 程序的结构如 [图 12-1](ch12.xhtml#ch012fig1) 所示。
- en: '![Image](Images/12fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/12fig01.jpg)'
- en: '*Figure 12-1: The conceptual structure of a Filska program*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：Filska 程序的概念结构*'
- en: 'The code in [Figure 12-1](ch12.xhtml#ch012fig1) is part of the example program
    outputting the points of the Sierpiński triangle. There are three subprograms:
    `main`, `loop`, and `print`. All Filska programs have at least a `main` subprogram
    where execution begins. The similarity to assembly language is clear.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-1](ch12.xhtml#ch012fig1) 中的代码是输出 Sierpiński 三角形各点的示例程序的一部分。程序有三个子程序：`main`、`loop`
    和 `print`。所有 Filska 程序至少有一个 `main` 子程序，执行从这里开始。与汇编语言的相似性非常明显。'
- en: Each subprogram is responsible for a single memory location. In [Figure 12-1](ch12.xhtml#ch012fig1),
    the values in the memory location represent a possible state of the program. The
    `set,1` instruction in `main` sets `main`’s memory location to 1.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子程序负责一个单一的内存位置。在 [图 12-1](ch12.xhtml#ch012fig1) 中，内存位置中的值代表程序可能的状态。`main`
    中的 `set,1` 指令将 `main` 的内存位置设置为 1。
- en: Also indicated are the three general purpose registers, X, Y, and Z. In the
    figure, X is set to 1 because of the `tmx` instruction in `main`, which transfers
    the current subprogram’s memory value (1) to X.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图中还指示了三个通用寄存器，X、Y 和 Z。在图中，X 被设置为 1，这是因为 `main` 中的 `tmx` 指令将当前子程序的内存值（1）转移到 X。
- en: There’s more to say about what’s happening in [Figure 12-1](ch12.xhtml#ch012fig1),
    but we need a better understanding of Filska first. Therefore, let’s detail Filska
    so we can implement it in Python.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[图 12-1](ch12.xhtml#ch012fig1)中发生的事情还有更多内容可以讨论，但我们首先需要更好地理解 Filska。因此，让我们详细介绍
    Filska，以便在 Python 中实现它。
- en: '***Program Structure and Syntax***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***程序结构和语法***'
- en: 'A Filska program is a set of one or more subprograms. Execution begins with
    the `main` subprogram, which must exist. Filska’s syntax is especially simple:
    tokens are separated by whitespace. Each token is either part of a subprogram
    declaration or an instruction associated with a subprogram. Comments are allowed;
    they begin with a double quote (`"`) and run to the end of the line.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Filska 程序是一个或多个子程序的集合。程序从 `main` 子程序开始执行，而 `main` 子程序必须存在。Filska 的语法特别简单：标记由空格分隔。每个标记要么是子程序声明的一部分，要么是与子程序相关的指令。允许注释；注释以双引号（`"`)
    开头，直到行尾。
- en: '[Listing 12-1](ch12.xhtml#ch012list1) shows the complete source code to a simple
    program counting from 10 down to 1.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-1](ch12.xhtml#ch012list1)展示了一个完整的源代码，它是一个从 10 倒数到 1 的简单程序。'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 12-1: Counting down from 10 to 1*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-1：从 10 倒数到 1*'
- en: The first items to notice are the comment lines beginning with double quotes.
    As you expect, comments are ignored by the interpreter. Next, a single subprogram,
    the required `main`, is defined. Syntactically, a subprogram is an opening brace
    (`{`), a name, one or more instructions, and a closing brace (`}`). All tokens
    are separated by whitespace, implying that a complete instruction, even if it
    consists of several parts, must not have spaces within it. Again, we do this to
    make our implementation easier so we can focus on the language itself. Lastly,
    Filska is not case sensitive, so `hlt` and `HLT` are the same instruction. We’ll
    use `hlt` in the text, but in code, any combination of case is fine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是以双引号开头的注释行。正如你所期望的，注释会被解释器忽略。接下来，定义了一个单一的子程序，即必需的 `main`。从语法上讲，一个子程序由一个左大括号（`{`）、一个名称、一个或多个指令和一个右大括号（`}`）组成。所有标记由空格分隔，意味着即使一个完整的指令由多个部分组成，它内部也不能有空格。同样，这样做是为了让我们的实现更简单，以便我们可以专注于语言本身。最后，Filska
    不区分大小写，所以 `hlt` 和 `HLT` 是相同的指令。我们在文本中将使用 `hlt`，但在代码中，任何大小写组合都是可以的。
- en: If you run the program in [Listing 12-1](ch12.xhtml#ch012list1) with
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行[清单 12-1](ch12.xhtml#ch012list1)中的程序
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: you’ll get output counting down from 10 to 1 with one number per line. We’ll
    walk through this example later in the chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个从 10 倒数到 1 的输出，每行一个数字。我们将在本章稍后详细讲解这个例子。
- en: 'If this were all there is to the idea of Filska, I wouldn’t waste time with
    it. However, there are some interesting constraints that make working with the
    language a bit of a challenge. It’s also fun: Filska requires alternative thinking
    to do things that might be second nature to you if you are used to standard programming
    languages.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Filska 的概念仅此而已，我也不会浪费时间讲解它。然而，它有一些有趣的约束，使得使用这个语言略显挑战。它也很有趣：Filska 需要不同的思维方式来做一些在标准编程语言中可能很自然的事情。
- en: We already mentioned how each Filska subprogram manipulates its own memory.
    That’s one constraint. The other constraint has to do with program flow between
    subprograms. Filska does not have a call stack. There is no idea of a subroutine
    or function. Instead, a subprogram runs and, if instructed, transfers flow to
    another subprogram. Filska only runs one subprogram at a time, so we aren’t talking
    about concurrency here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过每个 Filska 子程序如何操作其自己的内存。这是一个约束。另一个约束涉及子程序之间的程序流。Filska 没有调用栈。它没有子程序或函数的概念。相反，一个子程序运行，如果指示了，它会将程序流转移到另一个子程序。Filska
    一次只运行一个子程序，因此我们这里讨论的并不是并发。
- en: All subprograms run forever unless instructed otherwise. If the last instruction
    in a subprogram is executed, flow starts again at the top of the subprogram. Thus,
    a single Filska subprogram acts as a loop on its own. However, the example above
    ended with a call to `hlt` (halt). If you remove the `hlt` instruction, the countdown
    will repeat forever. Try it. Use CTRL-C to quit the interpreter when you get tired
    of watching the numbers flash by.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有子程序都会无限运行，除非另有指示。如果一个子程序的最后一条指令被执行，程序流会从子程序的顶部重新开始。因此，单个 Filska 子程序本身就充当了一个循环。然而，上面的例子以调用
    `hlt`（停止）指令结束。如果你移除 `hlt` 指令，倒计时将永远重复。试试看吧。当你看得厌烦时，可以使用 CTRL-C 来退出解释器。
- en: So infinite loops are implicit in Filska. What else is there to know? Each Filska
    subprogram maintains its own program counter, which is its own pointer to the
    instruction that should be executed next. In some fashion, all the programming
    languages we used do this. If we have a function like the following in Python
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Filska 中的无限循环是隐式的。还有什么需要知道的吗？每个 Filska 子程序都保持自己的程序计数器，它是指向下一条应执行指令的指针。以某种方式，所有我们使用过的编程语言都执行了类似的操作。如果我们在
    Python 中有如下的函数
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: we would expect to call `f(3)` and get a return value of 23\. If we call `f`
    a second time with a different value, say `f(4)`, we would expect it to begin
    again from the first instruction and run through the `return` to give us 40 as
    the output. The program counter for `f` resets to 0 after the first call.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会期望调用 `f(3)` 时返回值为 23。如果我们第二次以不同的值调用 `f`，比如 `f(4)`，我们希望它从第一条指令重新开始，经过 `return`
    返回 40 作为输出。`f` 的程序计数器在第一次调用后会重置为 0。
- en: In Filska, unless we are explicit about resetting them, program counters persist
    when transferring to another subprogram. We’ll see how this works in the next
    section, but for now, it means if subprogram *A* moves to subprogram *B* and,
    after some sequence of instructions, subprogram *B* moves back to subprogram *A*,
    execution of *A* will begin *with the next instruction* and not with the first
    instruction. Therefore, it is incorrect to think of Filska subprograms as subroutines,
    as they don’t reset themselves, but rather persist in their current state between
    transfers to and from them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Filska 中，除非明确重置程序计数器，否则在转移到另一个子程序时，程序计数器会持续存在。我们将在下一节看到这如何运作，但目前的意思是，如果子程序
    *A* 转到子程序 *B*，并且经过一系列指令后，子程序 *B* 再次转回子程序 *A*，那么 *A* 的执行将从 *下一条指令* 开始，而不是从第一条指令开始。因此，认为
    Filska 子程序是子例程是错误的，因为它们不会重置自己，而是在转移过程中保持当前状态。
- en: 'We can express the environment in which Filska operates with the following
    statements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下语句来表达 Filska 运作的环境：
- en: Filska programs are collections of independent subprograms.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Filska 程序是独立子程序的集合。
- en: Filska subprograms manipulate a single floating-point memory location, M.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Filska 子程序操作一个单一的浮点内存位置 M。
- en: 'Filska subprograms have access to three floating-point registers shared between
    them: X, Y, and Z.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Filska 子程序可以访问三个共享的浮点寄存器：X、Y 和 Z。
- en: Filska subprograms loop when the last instruction is executed.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Filska 子程序在执行完最后一条指令时会循环。
- en: Transfers between subprograms do not automatically reset the caller’s program
    counter.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子程序之间的转移不会自动重置调用者的程序计数器。
- en: This environment is nonstandard, that is, it’s different from what we are used
    to in traditional programming languages. We might think of Filska as some sort
    of weird machine from the early days of computers, but that, of course, would
    be grossly unfair to those early machines. Perhaps we can agree that Filska is
    just a bit weird, but in a good way, because working with it forces us to expand
    our thinking—the usual approach to even basic programs doesn’t always work, as
    we’ll see in [Chapter 13](ch13.xhtml#ch13).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个环境是非标准的，也就是说，它不同于我们在传统编程语言中习惯的环境。我们可能会把 Filska 想象成某种早期计算机时代的奇怪机器，但当然，这样的想法对那些早期机器是不公平的。或许我们可以同意，Filska
    确实有些奇怪，但这是一种好的奇怪，因为与之工作迫使我们拓展思维——即使是处理基本程序的通常方法也并不总是适用，正如我们将在[第 13 章](ch13.xhtml#ch13)中看到的那样。
- en: '***Flow Control***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***流程控制***'
- en: 'Filska supports five instructions affecting program flow. We’ll talk about
    four of them here and defer the fifth until we discuss comparisons. The four instructions
    are: `jpr`, `jmp`, `gto`, and `hlt`. We’ll discuss them in reverse order beginning
    with `hlt`, which, as we’ve already seen, stops the Filska program and exits.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 支持五条影响程序流程的指令。我们将在这里讨论其中四条，并将第五条推迟到讨论比较时再讲。这四条指令是：`jpr`、`jmp`、`gto` 和
    `hlt`。我们将按相反的顺序讨论它们，从 `hlt` 开始，正如我们已经看到的，它停止 Filska 程序并退出。
- en: To control flow within a subprogram, use `gto`, which is a three-letter mnemonic
    for “goto,” the bane of early computer programming. In Filska, `gto` accepts an
    offset in terms of instructions. An offset of 1 would move to the next instruction,
    an offset of 2 would move to the instruction after that, and so forth. To go backward,
    make the offset values negative. Primitive, yes, but doing this helps simplify
    the implementation and adds another small twist to the language. If you find yourself
    writing large Filska programs, feel free to add labels to the implementation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要在子程序内控制流程，请使用`gto`，它是“goto”的三字母助记符，早期计算机编程中的祸根。在Filska中，`gto`接受以指令为单位的偏移量。偏移量为1将跳转到下一条指令，偏移量为2将跳转到再下一条指令，依此类推。要向后跳转，可以将偏移值设置为负数。虽然很原始，但这样做有助于简化实现，并为语言增添了另一个小变化。如果你发现自己在编写较大的Filska程序，可以自由地在实现中添加标签。
- en: Use `gto` to execute an unconditional jump *within* a subprogram. For example,
    this little block of code will set the subprogram’s memory location to 0 then
    loop forever, adding 1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gto`执行子程序内部的无条件跳转。例如，这段小代码将把子程序的内存位置设置为0，然后无限循环，每次加1。
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use `gto,-1` to go back to the instruction immediately before the `gto`.
    Note the syntax `gto,<offset>`, where no spaces are allowed, the comma is required,
    and `<offset>` is an integer, that is, the number of instructions to skip. Note
    that Filska does not insist on a single instruction per line, so
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`gto,-1`跳回到`gto`之前的指令。注意语法`gto,<offset>`，其中不允许有空格，逗号是必需的，`<offset>`是一个整数，即要跳过的指令数。注意，Filska并不要求每行只有一条指令，因此
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: works just as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样有效。
- en: To move program flow from one subprogram to another, use `jmp` or `jpr` followed
    by the new subprogram’s name. For example, in [Figure 12-1](ch12.xhtml#ch012fig1),
    the `main` subprogram transfers to `loop` with `jmp,loop`. Note that the name
    of the target subprogram is fixed. Filska does not support any form of indirection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要将程序流程从一个子程序转移到另一个子程序，请使用`jmp`或`jpr`，后跟新子程序的名称。例如，在[图 12-1](ch12.xhtml#ch012fig1)中，`main`子程序通过`jmp,loop`转移到`loop`。请注意，目标子程序的名称是固定的，Filska不支持任何形式的间接寻址。
- en: We said before that Filska does not reset the program counter for a subprogram
    when transferring to a new subprogram. This is true if `jmp` is used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，当使用`jmp`转移到新子程序时，Filska不会重置子程序的程序计数器。
- en: However, if you use `jpr` instead, then the current subprogram’s counter *is*
    reset to 0, so the next time the subprogram is started, it will start from the
    beginning.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果使用`jpr`，当前子程序的计数器*会*重置为0，这样下次启动该子程序时，它将从头开始。
- en: Let’s set up an example. First, let’s write a small program to output some numbers
    to the console, one number per line. The code is shown in [Listing 12-2](ch12.xhtml#ch012list2).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设立一个示例。首先，编写一个小程序，将一些数字输出到控制台，每行一个数字。代码显示在[清单 12-2](ch12.xhtml#ch012list2)中。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 12-2: jmp example*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-2：jmp示例*'
- en: There are a few things to note in [Listing 12-2](ch12.xhtml#ch012list2). First,
    there are two subprograms, `main` and `newline`. Second, we stated already that
    `set,1` sets `main`’s memory to one. Also, `prt` will display the current subprogram’s
    memory as a floating-point number. So the first line of `main` will display `1`
    at the console.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 12-2](ch12.xhtml#ch012list2)中有一些需要注意的事项。首先，有两个子程序，`main`和`newline`。其次，我们已经说明，`set,1`将`main`的内存设置为1。另外，`prt`将显示当前子程序的内存值，作为浮点数。因此，`main`的第一行将在控制台上显示`1`。
- en: The next line transfers control from `main` to `newline`. This subprogram sets
    its memory to 10 and calls `chr`. Recall that ASCII 10 is the character code for
    a newline character on Linux. For Windows, it’s ASCII 13\. The Filska interpreter
    is happy with either character. It’s the same as using `"\n"` in Python. The `chr`
    instruction displays the subprogram’s memory as a character. So the point of `newline`
    is to move output to the next line.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将控制从`main`转移到`newline`。这个子程序将其内存设置为10，并调用`chr`。回想一下，ASCII 10是Linux上换行符的字符编码，对于Windows来说是ASCII
    13。Filska解释器对这两种字符都能正常工作。这就像在Python中使用`"\n"`一样。`chr`指令将子程序的内存显示为一个字符。因此，`newline`的作用是将输出移到下一行。
- en: The last instruction in `newline` is `jmp,main` to transfer control back to
    `main`. But *where* in `main` will execution start? Because `main` called `newline`
    with `jmp`, `main`’s program counter was not reset, so the next instruction executed
    is `set,2` followed by another transfer of control to `newline`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`newline`中的最后一条指令是`jmp,main`，用于将控制权转移回`main`。但是，*在*`main`中执行将从哪里开始？因为`main`是通过`jmp`调用`newline`的，所以`main`的程序计数器没有被重置，因此接下来执行的指令是`set,2`，然后又会转移控制到`newline`。'
- en: Where will `newline` pick up? Previously, it transferred control back to `main`
    with a `jmp` instruction as well, so it will pick up at the next instruction.
    However, that was the last instruction in `newline`, so, according to our design,
    program flow will loop back to the beginning, making `set,13` the next instruction
    executed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`newline`会从哪里继续执行？之前，它也是通过`jmp`指令将控制权转移回`main`的，因此它会从下一条指令继续执行。然而，那是`newline`中的最后一条指令，因此根据我们的设计，程序流程会循环回到开头，使得`set,13`成为下一个执行的指令。'
- en: Therefore, each `jmp` to `newline` will effectively run the entire subprogram
    again. Good. This is what we want. Similarly, each transfer to `newline` from
    `main` uses `jmp`, so when `newline` transfers back to `main`, the next instruction
    is executed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次跳转到`newline`时，实际上都会重新运行整个子程序。很好。这正是我们想要的。类似地，从`main`跳转到`newline`时，使用的是`jmp`，所以当`newline`跳转回`main`时，下一个指令会继续执行。
- en: '[Listing 12-2](ch12.xhtml#ch012list2) will output `1`, then `2`, followed by
    `3`, and then stop because of the `hlt` instruction. The jumps to `newline` ensure
    each number is on its own line in the output.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 12-2](ch12.xhtml#ch012list2)将输出`1`，然后是`2`，接着是`3`，最后由于`hlt`指令的原因停止。跳转到`newline`确保每个数字都单独显示在输出的每一行。'
- en: Note that because `newline` transfers to `main` via its final instruction, it
    has the effect and feel of a subroutine or function. But don’t be fooled. If another
    subprogram were to transfer control to `newline`, the result wouldn’t be to transfer
    back to that subprogram when done. Instead, `newline` would transfer control to
    `main`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`newline`通过其最后一条指令将控制权转移到`main`，它表现得像一个子程序或函数。但不要被误导。如果另一个子程序将控制权转移到`newline`，结果不会是在完成后返回到该子程序。相反，`newline`将把控制权转移回`main`。
- en: '[Listing 12-2](ch12.xhtml#ch012list2) shows us how to use `jmp` to transfer
    control between sub-programs and how to pick up where we left off if we return
    to the transferring subprogram. Now, let’s mess things up a bit. We’ll keep the
    code of [Listing 12-2](ch12.xhtml#ch012list2), but replace the first instance
    of `jmp,newline` with `jpr,newline`, using `jpr` in the place of `jmp`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 12-2](ch12.xhtml#ch012list2)展示了如何使用`jmp`在子程序之间传递控制权，以及如何在返回到转移控制的子程序时从上次离开的地方继续执行。现在，让我们来搞乱一下。我们保留[Listing
    12-2](ch12.xhtml#ch012list2)中的代码，但将第一个`jmp,newline`替换为`jpr,newline`，用`jpr`代替`jmp`。'
- en: If you make this change and run the code, you won’t see `1`, `2`, `3` at the
    console. Instead, you’ll see `1` repeating forever until you hit CTRL-C. Why?
    Because `jpr` transfers control to a new subprogram, just like `jmp`, but it also
    resets the caller’s program counter to 0\. So when `main` transfers control to
    `newline`, `main`’s program counter is set to 0, causing it to pick up at `set,1`
    again when `newline` transfers back to `main`. This sets up an endless loop that
    outputs `1` repeatedly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行这个修改并运行代码，你将不会看到控制台上的`1`、`2`、`3`。相反，你会看到`1`永远重复，直到按下CTRL-C。为什么？因为`jpr`将控制权转移到一个新的子程序，就像`jmp`一样，但它还会将调用者的程序计数器重置为0。因此，当`main`将控制权转移到`newline`时，`main`的程序计数器被设置为0，这导致它在`newline`转回`main`时从`set,1`开始。这样就形成了一个无尽的循环，不断输出`1`。
- en: As an exercise, restore the `jmp,newline` instruction in `main`, replace `jmp,main`
    in `newline` with `jpr,main`, and run the code. Is there any difference in the
    output compared to our earlier output? If not, why?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，恢复`main`中的`jmp,newline`指令，将`newline`中的`jmp,main`替换为`jpr,main`，然后运行代码。与我们之前的输出相比，输出有什么不同吗？如果没有，为什么？
- en: The answer is no, there is no difference; both versions output `1`, `2`, and
    `3` at the console. This is because the transfer back to `main` from `newline`
    is the *last* instruction, so resetting `newline`’s program counter is irrelevant
    in this case. If the program counter is reset, `newline` starts from its first
    instruction. If the program counter isn’t reset, it will loop back around to the
    beginning and start with the first instruction anyway.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的，没什么区别；两个版本都在控制台输出`1`、`2`和`3`。这是因为从`newline`转移回`main`的是*最后*一条指令，所以在这种情况下重置`newline`的程序计数器并不重要。如果程序计数器被重置，`newline`将从它的第一条指令开始。如果程序计数器没有被重置，它也会循环回到开头并从第一条指令开始。
- en: '[Table 12-1](ch12.xhtml#ch012tab1) summarizes Filska’s flow control instructions.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-1](ch12.xhtml#ch012tab1) 总结了 Filska 的流程控制指令。'
- en: '**Table 12-1:** Flow Control Instructions'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-1：** 流程控制指令'
- en: '| **Instruction** | **Description** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `*jmp*` | Transfer to a new subprogram and preserve the caller’s program
    counter. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `*jmp*` | 转移到一个新的子程序并保留调用者的程序计数器。 |'
- en: '| `*jpr*` | Transfer to a new subprogram and reset the caller’s program counter.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `*jpr*` | 转移到一个新的子程序并重置调用者的程序计数器。 |'
- en: '| `*gto*` | Jump forward or backward within the current subprogram. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `*gto*` | 在当前子程序内向前或向后跳转。 |'
- en: '| `*hlt*` | Halt. Stop the program immediately and exit. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `*hlt*` | 停止。立即停止程序并退出。 |'
- en: Let’s move on now to see how Filska handles its little bit of memory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续看看 Filska 如何处理它那一小部分内存。
- en: '***Memory***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存***'
- en: We already know that each Filska subprogram manages a single floating-point
    number. We also know subprograms share access to three floating-point index registers.
    Let’s look at the instructions that manipulate these data values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道每个 Filska 子程序管理一个单一的浮点数。我们还知道子程序共享对三个浮点索引寄存器的访问权限。让我们来看一下操作这些数据值的指令。
- en: To set a subprogram’s memory, use `set`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置子程序的内存，请使用 `set`。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only way to directly set a memory value to a constant is via `set`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将内存值设置为常量的唯一方法是通过 `set`。
- en: 'Several instructions transfer subprogram memory to or from an index register.
    The form of the instruction is straightforward: the source of the data comes before
    the destination. So to transfer a memory value to the X register, use `tmx`. Similarly,
    to transfer memory to the Z register, use `tmz`. To move data from an index register
    to memory, reverse the letters. Therefore, `tym` moves the current value of the
    Y register to memory.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一些指令将子程序内存传输到索引寄存器或从索引寄存器传输。该指令的格式很直接：数据源在目标之前。因此，要将内存值传输到 X 寄存器，使用 `tmx`。类似地，要将内存传输到
    Z 寄存器，使用 `tmz`。要将数据从索引寄存器移动到内存，反转字母。因此，`tym` 将 Y 寄存器的当前值移动到内存。
- en: The transfer instructions are destructive, meaning that the destination value
    is overwritten. The `swp` instruction swaps two data values instead. The instruction
    takes a two-letter argument representing the two data sources to swap. The current
    subprogram’s memory is denoted as `M`. For example,
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 转移指令是破坏性的，这意味着目标值会被覆盖。`swp` 指令则交换两个数据值。该指令接受一个两字母的参数，表示要交换的两个数据源。当前子程序的内存表示为
    `M`。例如，
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: will first swap memory and the X register and then swap the Y and Z register
    values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将内存和 X 寄存器的值交换，然后再交换 Y 和 Z 寄存器的值。
- en: Filska does not support arrays or any form of heap memory, so that immediately
    precludes many possible programs. However, there is no practical upper bound on
    the number of subprograms allowed, so creative programming might mimic some larger
    memory operations. [Listing 12-3](ch12.xhtml#ch012list3) shows how to use a subprogram
    as a set-once, read-many memory location.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 不支持数组或任何形式的堆内存，因此这立即排除了许多可能的程序。然而，允许的子程序数量没有实际上限，因此创意编程可能模仿一些更大的内存操作。[清单
    12-3](ch12.xhtml#ch012list3) 显示了如何将子程序用作一次设置、多次读取的内存位置。
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 12-3: Using a subprogram as ROM*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-3：* 使用子程序作为 ROM'
- en: The main program of [Listing 12-3](ch12.xhtml#ch012list3) loads the X register
    with 123 by first setting `main`’s memory to 123 followed by a transfer to the
    X register ➊. Then, a `jmp` to `mem` moves the 123 from X to `mem`’s memory. Just
    to show we can, we increment the memory before returning to `main` via `jmp`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-3](ch12.xhtml#ch012list3) 中的主程序通过先将 `main` 的内存设置为 123，然后传输到 X 寄存器 ➊，将
    123 加载到 X 寄存器。然后，`jmp` 跳转到 `mem`，将 123 从 X 移动到 `mem` 的内存。为了演示我们能够做到这一点，我们在返回到
    `main` 之前通过 `jmp` 增加了内存。'
- en: This first call to `mem` sets the local data value to 124 (as we incremented
    it). Subsequent calls to `mem` from `main` will start `mem` at the `tmx` instruction
    to transfer the 124 to the X register. In `main`, we set its memory to 1 and print
    it at the console along with a newline character to show that `main`’s memory
    is now changed ➋.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `mem` 时，将本地数据值设置为 124（因为我们已将其增量化）。随后从 `main` 调用 `mem` 时，会从 `tmx` 指令开始，传输
    124 到 X 寄存器。在 `main` 中，我们将其内存设置为 1，并将其与换行符一起打印到控制台，显示 `main` 的内存已发生变化 ➋。
- en: Next, we make three calls to `mem`. After each call, the X register will contain
    `mem`’s local data value (124). Back in `main`, we transfer the X value to `main`’s
    memory and print it at the console ➌. It is not hard to imagine using a second
    index register, say Y, as an argument of sorts to tell `mem` to set its local
    memory to whatever is in X instead of setting X to the local memory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用三次`mem`。每次调用后，X寄存器将包含`mem`的局部数据值（124）。回到`main`中，我们将X的值转移到`main`的内存，并在控制台打印出来➌。不难想象，使用第二个索引寄存器，例如Y，可以作为某种参数，告诉`mem`将其局部内存设置为X中的值，而不是将X设置为局部内存中的值。
- en: '***Arithmetic***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***算术运算***'
- en: By *arithmetic* we mean binary math operations like addition and multiplication.
    The full list of supported binary operations is in [Table 12-2](ch12.xhtml#ch012tab2).
    The general format of the instruction is
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的*算术运算*指的是加法、乘法等二元数学运算。支持的所有二元运算的完整列表见[表格12-2](ch12.xhtml#ch012tab2)。指令的一般格式是
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: with `<op>` being the command, `<dst>` the destination, and `<op1>` and `<op2>`
    the operands. The infix version is `<dst> = <op1><op><op2>` as in *c* = *a – b*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`<op>`是命令，`<dst>`是目标，`<op1>`和`<op2>`是操作数。中缀版本是`<dst> = <op1><op><op2>`，如同*c*
    = *a – b*。
- en: '**Table 12-2:** Binary Arithmetic Instructions'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格12-2：** 二元算术指令'
- en: '| **Instruction** | **Example** | **Operation** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **示例** | **操作** |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `*add*` | `*add*, *m*=*xy*` | Addition, *M* ← *X* + *Y* |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `*add*` | `*add*, *m*=*xy*` | 加法运算, *M* ← *X* + *Y* |'
- en: '| `*sub*` | `*sub*, *x*=*yz*` | Subtraction, *X* ← *Y – Z* |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `*sub*` | `*sub*, *x*=*yz*` | 减法运算, *X* ← *Y – Z* |'
- en: '| `*mul*` | `*mul*, *z*=*xy*` | Multiplication, *Z* ← *X* × *Y* |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `*mul*` | `*mul*, *z*=*xy*` | 乘法运算, *Z* ← *X* × *Y* |'
- en: '| `*div*` | `*div*, *m*=*zx*` | Division, *M* ← *Z* ÷ *X* |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `*div*` | `*div*, *m*=*zx*` | 除法运算, *M* ← *Z* ÷ *X* |'
- en: '| `*mod*` | `*mod*, *y*=*mz*` | Modulo, *Y* ← *M* mod *Z* |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `*mod*` | `*mod*, *y*=*mz*` | 取模运算, *Y* ← *M* mod *Z* |'
- en: '| `*pow*` | `*pow*, *z*=*xy*` | Power, *Z* ← *X*^(*Y*) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `*pow*` | `*pow*, *z*=*xy*` | 幂运算, *Z* ← *X*^(*Y*) |'
- en: You’ll notice from the examples in [Table 12-2](ch12.xhtml#ch012tab2) that the
    operands and the destination must be subprogram memory or one of the index registers.
    No constants are allowed. However, any combination of memory and registers is
    permitted. And as usual, to simplify the implementation, no spaces are allowed
    in the command.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从[表格12-2](ch12.xhtml#ch012tab2)中的例子可以看出，操作数和目标必须是子程序内存或其中一个索引寄存器。常量是不允许的。然而，任何内存和寄存器的组合都是允许的。并且，像往常一样，为了简化实现，命令中不允许有空格。
- en: '***Comparisons***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比较运算***'
- en: Filska handles logical comparisons via a flags register and two instructions.
    The flags register is a list of Boolean values indicating the result of the most
    recent comparison instruction (`cmp`). The flags are zero (`Z`), equal (`E`),
    less than (`L`), and greater than (`G`). The `cmp` instruction accepts a single
    argument and compares it to the subprogram’s memory, setting the appropriate flags
    as needed. The argument is a constant or one of the index registers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Filska通过一个标志寄存器和两条指令来处理逻辑比较。标志寄存器是一个布尔值列表，表示最近一次比较指令（`cmp`）的结果。标志包括零标志（`Z`）、相等标志（`E`）、小于标志（`L`）和大于标志（`G`）。`cmp`指令接受一个参数并将其与子程序内存进行比较，必要时设置相应的标志。该参数可以是常量或其中一个索引寄存器。
- en: For example, these instructions first set memory and then call `cmp`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这些指令首先设置内存，然后调用`cmp`。
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The comparison asks about the relationship between memory and the current value
    of the X index register. Let’s say X is 4\. The comparison code is
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 比较询问的是内存与当前X索引寄存器值之间的关系。假设X是4，比较代码是
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: with `mem` being the current subprogram’s memory and `n` being the value of
    the X register.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`mem`是当前子程序的内存，`n`是X寄存器的值。
- en: 'Which flags are set depends on the values, but for this example, 3 < 4, so
    the `L` flag will be set and the others will remain unset. If X were 3, the `E`
    flag would be set instead. Now, consider these instructions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些标志被设置取决于值的比较，但在这个例子中，3 < 4，因此`L`标志将被设置，其他标志将保持未设置。如果X是3，`E`标志将被设置。现在，考虑这些指令：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, `cmp` will set two flags. First, it will set the `L` flag because
    0 < 5\. Second, `cmp` will also set the zero flag (`Z`) because memory is 0.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`cmp`将设置两个标志。首先，它会设置`L`标志，因为0 < 5。其次，`cmp`还会设置零标志（`Z`），因为内存中的值是0。
- en: The code above actually sets the zero flag twice. Checking whether a value is
    0 is so common that all of Filska’s instructions that modify subprogram memory
    check if the result is 0 and if so, set the zero flag. So the `set,0` instruction
    set the zero flag even before the `cmp` instruction, which sets it a second time.
    We’ll often use this fact in our example programs to branch on memory becoming
    0 without an explicit call to `cmp`. Note that even the transfer instructions
    affect the zero flag when moving values from the index registers to subprogram
    memory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码实际上设置了零标志两次。检查一个值是否为 0 是如此常见，以至于 Filska 所有修改子程序内存的指令都会检查结果是否为 0，如果是，则设置零标志。因此，`set,0`
    指令会在 `cmp` 指令之前就设置零标志，而 `cmp` 指令会再次设置它。在我们的示例程序中，我们经常利用这个事实，在内存变为 0 时进行跳转，而无需显式调用
    `cmp`。请注意，即使是传输指令在将值从索引寄存器移动到子程序内存时也会影响零标志。
- en: 'If `cmp` performs tests and sets flags, how do we act on the results? That’s
    where the test instruction, `tst`, comes into play. The `tst` instruction branches
    within the current subprogram based on the value of a flag. The syntax of the
    instruction is `tst,<flag>,<offset>`. For example, consider this sequence of instructions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `cmp` 执行测试并设置标志，那么我们如何根据结果采取行动呢？这时，`tst` 指令就派上用场了。`tst` 指令根据标志的值在当前子程序中进行跳转。该指令的语法为
    `tst,<flag>,<offset>`。例如，考虑以下指令序列：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We first set memory to 1 and then execute `tst` to branch forward 10 instructions
    if the zero flag is set. Assigning a 1 to memory does not set the zero flag, so
    the `tst` instruction does not branch and execution continues with the next instruction.
    The `dec` instruction decrements memory, making it 0\. This operation *does* set
    the zero flag, so the next `tst` instruction will branch eight instructions forward.
    Note that branching eight instructions forward from the second `tst` instruction
    sets the program counter to the same instruction that the first `tst` instruction
    was targeting.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将内存设置为 1，然后执行 `tst`，如果零标志被设置，则跳转 10 条指令。将 1 分配给内存不会设置零标志，因此 `tst` 指令不会跳转，执行继续进行到下一条指令。`dec`
    指令将内存递减为 0。此操作 *确实* 设置了零标志，因此接下来的 `tst` 指令将跳转八条指令。请注意，从第二个 `tst` 指令跳转八条指令会将程序计数器设置为第一个
    `tst` 指令所指向的相同指令。
- en: 'To test for conditions other than memory is 0, use `cmp` followed by the `tst`
    instruction. For example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 若要测试内存不为 0 以外的条件，请使用 `cmp` 指令，然后跟随 `tst` 指令。例如：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These instructions compare memory to X and branch backward if memory is less
    than or equal to X. Note that for the equal test to branch to the same location
    as the less-than test, we must account for the presence of the less-than `tst`
    instruction, which explains using *–*15 and *–*16, respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将内存与X进行比较，并在内存小于或等于X时进行回跳。请注意，为了使等于测试跳转到与小于测试相同的位置，我们必须考虑到`tst`指令的存在，这也解释了为何分别使用
    *–*15 和 *–*16。
- en: 'The `tst` instruction’s first argument is the flag to test: `Z`, `L`, `G`,
    or `E`. However, `tst` accepts one more flag, `N`, which means “not zero.” We
    saw this version of `tst` in [Listing 12-1](ch12.xhtml#ch012list1) earlier.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`tst` 指令的第一个参数是要测试的标志：`Z`、`L`、`G` 或 `E`。然而，`tst` 还接受一个额外的标志 `N`，表示“非零”。我们在
    [列表 12-1](ch12.xhtml#ch012list1) 中已经看到过这种版本的 `tst`。'
- en: '***Mathematical Functions***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数学函数***'
- en: Filska’s intended use is to crunch numbers. That’s why it manipulates floating-point
    values. To that end, Filska supports a set of mathematical functions, all of which
    operate on the current subprogram’s memory. [Table 12-3](ch12.xhtml#ch012tab3)
    has the complete set of supported functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 的设计目的是进行数字运算。这就是为什么它操作浮点值。为此，Filska 支持一组数学函数，所有这些函数都作用于当前子程序的内存。完整的支持函数集请见
    [表 12-3](ch12.xhtml#ch012tab3)。
- en: '**Table 12-3:** Filska’s Mathematical Functions'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-3：** Filska 的数学函数'
- en: '| **Instruction** | **Operation** | **Description** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **操作** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `inc` | *M* ← *M* + 1 | Increment memory by one |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `inc` | *M* ← *M* + 1 | 将内存递增 1 |'
- en: '| `dec` | *M* ← *M –* 1 | Decrement memory by one |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `dec` | *M* ← *M –* 1 | 将内存递减 1 |'
- en: '| `sin` | *M* ← *sin*(*M*) | Sine of *M* (radians) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `sin` | *M* ← *sin*(*M*) | *M* 的正弦（弧度） |'
- en: '| `cos` | *M* ← *cos*(*M*) | Cosine of *M* (radians) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `cos` | *M* ← *cos*(*M*) | *M* 的余弦（弧度） |'
- en: '| `tan` | *M* ← *tan*(*M*) | Tangent of *M* (radians) |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `tan` | *M* ← *tan*(*M*) | *M* 的正切（弧度） |'
- en: '| `asn` | *M* ← *sin* ^(*–*1) (*M*) | Inverse sine of *M* (radians) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `asn` | *M* ← *sin* ^(*–*1) (*M*) | *M* 的反正弦（弧度） |'
- en: '| `acs` | *M* ← *cos* ^(*–*1) (*M*) | Inverse cosine of *M* (radians) |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `acs` | *M* ← *cos* ^(*–*1) (*M*) | *M* 的反余弦（弧度） |'
- en: '| `atn` | *M* ← *tan* ^(*–*1) (*M*) | Inverse tangent of *M* (radians) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `atn` | *M* ← *tan* ^(*–*1) (*M*) | *M* 的反正切（弧度） |'
- en: '| `log` | *M* ← *log*(*M*) | Natural log |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `log` | *M* ← *log*(*M*) | 自然对数 |'
- en: '| `exp` | *M* ← *e*^(*M*) | Exponential |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `exp` | *M* ← *e*^(*M*) | 指数函数 |'
- en: '| `flr` | *M* ← ⌊*M* ⌋ | Floor of *M* |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `flr` | *M* ← ⌊*M* ⌋ | *M* 的下舍整数 |'
- en: '| `cel` | *M* ← ⌈*M* ⌉ | Ceiling of *M* |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `cel` | *M* ← ⌈*M* ⌉ | *M* 的上舍整数 |'
- en: '| `rnd` | *M* ← *U*[0, 1) | Uniform random number, [0, 1) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `rnd` | *M* ← *U*[0, 1) | 均匀随机数，[0, 1) |'
- en: '| `neg` | *M* ← *–M* | Negation of *M* |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `neg` | *M* ← *–M* | *M* 的负值 |'
- en: '| `sqr` | ![Image](Images/f0329-01.jpg) | Square root of *M* |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `sqr` | ![图片](Images/f0329-01.jpg) | *M* 的平方根 |'
- en: The set of functions in [Table 12-3](ch12.xhtml#ch012tab3) are the minimal set
    supported by most programming languages. With these, it’s possible to implement
    many mathematical expressions, at least in pieces.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-3](ch12.xhtml#ch012tab3) 中的一组函数是大多数编程语言支持的最小集合。有了这些函数，就可以实现许多数学表达式，至少是部分表达式。'
- en: Internally, our implementation of Filska will use Python floats, meaning IEEE
    754 *binary64* values (C `double`). We have a good range available numerically,
    but if our algorithm naturally uses integers, we might be limited a bit, as we
    will not take advantage of Python’s abilities with arbitrary-sized integers. We’ll
    see this effect in [Chapter 13](ch13.xhtml#ch13) when we develop a Filska program
    to output the Fibonacci sequence.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 内部实现中，我们的 Filska 使用 Python 浮点数，意味着采用 IEEE 754 *binary64* 值（C 语言中的 `double`）。我们在数值上有很好的范围，但如果算法本身自然使用整数，我们可能会有些限制，因为我们不会利用
    Python 对任意大小整数的支持。我们将在 [第 13 章](ch13.xhtml#ch13) 中看到这一效应，当时我们将开发一个 Filska 程序来输出斐波那契数列。
- en: '***Input and Output***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***输入和输出***'
- en: 'Filska supports three input/output instructions: `prt`, `chr`, and `ipt`. The
    first two we’ve seen several times already in the examples above. Use `prt` to
    output subprogram memory as a floating-point number. Filska’s implementation does
    check to see if memory is actually an integer and outputs it with an integer format
    if so. Otherwise, the format is explicitly for floating-point with 10 digits after
    the decimal.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 支持三种输入/输出指令：`prt`、`chr` 和 `ipt`。前两者我们在上面的示例中已经多次见过。使用 `prt` 输出子程序内存为浮点数格式。Filska
    的实现会检查内存是否为整数，如果是，它会以整数格式输出；否则，格式将明确为浮点数格式，保留小数点后 10 位数字。
- en: The `chr` instruction interprets memory as an ASCII code. This casts memory
    to an integer and then keeps only the lowest eight bits to ensure it is in the
    range [0, 255]. Then, it outputs the character associated with the resulting ASCII
    value.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`chr` 指令将内存解释为 ASCII 代码。这将内存转换为整数，然后只保留最低的八位，以确保其位于 [0, 255] 范围内。然后，它输出与结果
    ASCII 值相关联的字符。'
- en: The final instruction, `ipt`, accepts input from the user as a floating-point
    number. If the input received cannot be properly interpreted as a floating-point
    number, `ipt` unceremoniously returns 0\. The `ipt` instruction sets the zero
    flag as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条指令 `ipt` 从用户接收输入作为浮点数。如果接收到的输入无法正确解析为浮点数，`ipt` 会直接返回 0。`ipt` 指令还会设置零标志。
- en: '[Listing 12-4](ch12.xhtml#ch012list4) is a simple program that asks the user
    for a number and multiplies it by 2.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-4](ch12.xhtml#ch012list4) 是一个简单的程序，要求用户输入一个数字并将其乘以 2。'
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 12-4: Getting input from the user*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-4：从用户获取输入*'
- en: The program first prints a `?` and then uses `ipt` to set memory to whatever
    number the user enters. Filska does not allow constants in arithmetic operations,
    so to multiply memory by 2, the user’s value is moved to the X register and memory
    is set to 2\. The `mul` instruction multiplies memory and X stores the result
    in memory. Next, the program prints the product (`prt`) with a newline character
    and then halts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先打印一个 `?`，然后使用 `ipt` 将内存设置为用户输入的数字。Filska 不允许在算术运算中使用常量，因此要将内存中的数字乘以 2，用户的输入值被移至
    X 寄存器，内存则被设置为 2。`mul` 指令将内存和 X 相乘，并将结果存储回内存。接下来，程序打印乘积（`prt`），并在输出后添加换行符，然后停止。
- en: Input and output to the console are as straightforward as can be; however, when
    combined with input/output redirection, Filska can operate on a file and produce
    a new file as output. A simple modification to [Listing 12-4](ch12.xhtml#ch012list4)
    makes it possible to multiply a file of numbers by 2 (see [Listing 12-5](ch12.xhtml#ch012list5)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台的输入和输出尽可能直接；然而，结合输入/输出重定向，Filska 可以操作文件并生成一个新的输出文件。对 [示例 12-4](ch12.xhtml#ch012list4)
    的简单修改，使得能够将一个包含数字的文件中的每个数字都乘以 2（见 [示例 12-5](ch12.xhtml#ch12list5)）。
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 12-5: Multiplying a file by 2*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-5：将文件乘以 2*'
- en: '[Listing 12-5](ch12.xhtml#ch012list5) removes the question mark prompt and
    `hlt` instruction to make `main` loop forever. By design, Filska exits if the
    call to `ipt` fails for some reason, including if reading from a redirected file
    fails.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 12-5](ch12.xhtml#ch012list5) 移除了问号提示符和 `hlt` 指令，使 `main` 循环永远执行。根据设计，Filska
    会在调用 `ipt` 失败时退出，原因可能是重定向文件读取失败等。'
- en: To try [Listing 12-5](ch12.xhtml#ch012list5), first create a file of numbers,
    one per line. I used 1 through 10\. Ensure the final number does not have an empty
    line after it, as empty lines are read as 0\. With the file of numbers in place,
    run the program.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试[Listing 12-5](ch12.xhtml#ch012list5)，首先创建一个包含数字的文件，每行一个。我使用了从1到10的数字。确保最后一个数字后面没有空行，因为空行会被读取为0。创建好数字文件后，运行程序。
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Assuming you stored the code in *example_input_file.filska* and your table of
    numbers in *input.txt*, you should see your table output at the console with each
    number multiplied by 2\. Naturally, you can redirect Filska output to a different
    file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将代码存储在*example_input_file.filska*中，并将数字表存储在*input.txt*中，你应该能在控制台上看到表格输出，每个数字都被乘以2。当然，你也可以将
    Filska 输出重定向到其他文件。
- en: Now that we know what Filska is as a language and the instructions it supports,
    let’s implement it in Python.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Filska 作为一种语言及其支持的指令，让我们开始用 Python 来实现它。
- en: '**Implementating Filska**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实现 Filska**'
- en: In this section, we’ll implement portions of Filska. I won’t be so pedantic
    as to dump every line of Python code on you here. The code for Filska is in the
    file *Filska.py*. Please read through it. All told, *Filska.py* is less than 700
    lines, including comments and blanks.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将实现 Filska 的部分内容。我不会过于苛求地将每一行 Python 代码都抛给你。Filska 的代码在文件*Filska.py*中。请自行阅读。总的来说，*Filska.py*
    的代码不到700行，包括注释和空白行。
- en: Here, we’ll detail the essential parts of the implementation. For example, a
    single instance of a particular class of instruction is all you need to understand
    the implementation of the entire class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将详细介绍实现的关键部分。例如，理解某个特定指令类别的单一实例，就足以理解整个类别的实现。
- en: Therefore, we’ll present the implementation in a top-down fashion, starting
    with the code’s overall structure and operation. Then we’ll discuss parsing, which
    is especially easy given Filska’s design, and the execution loop.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将以自上而下的方式呈现实现，首先介绍代码的整体结构与操作。然后我们将讨论解析过程，由于 Filska 的设计，解析过程特别简单，接着是执行循环。
- en: Next comes an example of an instruction without arguments, followed by instructions
    that accept arguments. Lastly, we’ll end with flow control within and between
    subprograms. Again, I assume that you’ll look at *Filska.py* yourself. After all,
    at this point in the book we’ve gained enough experience with source code to learn
    directly from it most of the time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是没有参数的指令示例，随后是接受参数的指令。最后，我们将介绍子程序内部及其之间的流程控制。同样，我假设你会自己查看*Filska.py*。毕竟，书中的内容到目前为止，我们已经积累了足够的源代码经验，可以直接从中学习。
- en: '***Overall Structure and Operation***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***整体结构与操作***'
- en: Conceptually, a Filska interpreter parses the input source code into tokens,
    ignoring comments, and sorts those tokens into a dictionary of subprograms indexed
    by the subprogram name. Each subprogram has an associated local memory value,
    local flags, and a local program counter, an index into the subprogram’s token
    list. Tokens, memory, flags, and program counters are stored in Python dictionaries,
    each indexed by the subprogram name. Execution happens one token at a time for
    the current subprogram, looping at the end of the subprogram, and persisting the
    program counter between transfers to and from other subprograms, unless the `jpr`
    instruction is used, in which case the subprogram’s counter is set to 0.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，Filska 解释器将输入源代码解析为标记，忽略注释，并将这些标记排序成一个按子程序名称索引的子程序字典。每个子程序都有一个关联的本地内存值、本地标志和本地程序计数器，后者是指向子程序标记列表的索引。标记、内存、标志和程序计数器都存储在
    Python 字典中，每个字典由子程序名称索引。执行过程是按当前子程序的标记逐个进行的，子程序执行结束后会循环，并在子程序之间切换时保持程序计数器的状态，除非使用了`jpr`指令，在这种情况下，子程序的计数器会被重置为0。
- en: The Filska interpreter itself is a single Python class, `Filska`. The constructor
    expects a string, the text of the code to be run, and, optionally, a Boolean flag
    to turn on runtime execution tracing. We’ll get to tracing later on when we start
    working with our example programs. We won’t look at how tracing is implemented
    here. Review the Filska source code to see how it’s done.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 解释器本身是一个单独的 Python 类，`Filska`。构造函数需要一个字符串，即要运行的代码文本，并且可以选择一个布尔标志来开启运行时执行跟踪。我们稍后会在处理示例程序时讨论跟踪功能。这里我们不会查看跟踪的实现方式。可以查看
    Filska 源代码了解具体实现。
- en: Using a class to implement a Filska interpreter enables the easy embedding of
    Filska into another program. Why you’d want to embed a Filska interpreter is a
    reasonable question, but you can if you want a quirky scripting language for your
    larger application. Modifications to Filska’s input/output instructions might
    make embedding more attractive. Imagine a version of the `Run` method (see below)
    that accepts a list of inputs and returns the program output as a list of tokens,
    and so on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类来实现 Filska 解释器使得将 Filska 嵌入到其他程序中变得简单。如果你想将 Filska 嵌入到你的应用程序中，可能会有合理的原因，尽管这样做会让你得到一个较为独特的脚本语言。对
    Filska 的输入/输出指令进行修改，可能会使嵌入变得更具吸引力。想象一下 `Run` 方法的一个版本（见下文），它接受一个输入列表并将程序输出作为标记列表返回，等等。
- en: When run from the command line, Filska expects the program’s name and an optional
    `-t` flag to turn on execution tracing. On startup, Filska runs `main`, the traditional
    name for a Python program’s startup function (see [Listing 12-6](ch12.xhtml#ch012list6)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当从命令行运行时，Filska 需要程序的名称和一个可选的 `-t` 标志来开启执行跟踪。在启动时，Filska 会运行 `main`，这是 Python
    程序的传统启动函数名（参见 [Listing 12-6](ch12.xhtml#ch012list6)）。
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 12-6: Creating a Filska interpreter from the command line*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-6: 从命令行创建 Filska 解释器*'
- en: If no arguments are given, Filska displays a short usage message (not shown
    in the listing). Otherwise, `main` looks to see if a second command line argument
    is present and sets `trace` appropriately. The following line creates an instance
    of a Filska interpreter passing in the actual text of the program to run. Next,
    execution begins with a call to `Run`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供任何参数，Filska 会显示一条简短的使用消息（未在列表中显示）。否则，`main` 会检查是否存在第二个命令行参数，并根据情况设置 `trace`。以下行创建了一个
    Filska 解释器实例，并传入实际的程序文本进行运行。接下来，执行将通过调用 `Run` 开始。
- en: The constructor defines state member variables, including the index registers,
    a dictionary holding per subprogram memory (`mem`), a dictionary of subprogram
    instructions (`prog`), the per subprogram program counter (`PC`), and the name
    of the currently running subprogram (`CP`) initialized to `main`. The status flags
    come next (`flags`), also defined as a dictionary. Dictionaries are used for memory,
    program text, program counters, and status flags to isolate subprogram state.
    The only link between subprograms is the ability for each subprogram to interact
    with the shared index registers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数定义了状态成员变量，包括索引寄存器、一个字典用于存储每个子程序的内存（`mem`）、一个子程序指令字典（`prog`）、每个子程序的程序计数器（`PC`），以及当前运行子程序的名称（`CP`），初始化为
    `main`。接下来是状态标志（`flags`），同样作为字典定义。字典被用来管理内存、程序文本、程序计数器和状态标志，从而隔离子程序的状态。子程序之间唯一的联系是每个子程序可以与共享的索引寄存器进行交互。
- en: Filska programs are tokenized; therefore, running a subprogram means interpreting
    token by token. When instructions are encountered as tokens, the instruction is
    parsed if there are arguments. Then the instruction is looked up in a table, `exe`,
    which holds references to Python methods implementing the function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 程序是经过标记化的；因此，运行子程序意味着逐个标记地解释。当遇到指令作为标记时，如果有参数，指令会被解析。然后，指令会在 `exe` 表中查找，该表包含实现该功能的
    Python 方法的引用。
- en: '***Parsing***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解析***'
- en: Parsing a Filska program means splitting the source code string into tokens,
    ignoring comments, and separating the subprogram tokens and storing them in the
    `prog` dictionary. The `Parse` method tokenizes a program string to return a list
    of tokens. Next, `InitializeProg` sorts the subprograms and places them in the
    `prog` dictionary.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 Filska 程序意味着将源代码字符串拆分成标记，忽略注释，分离子程序标记并将其存储在 `prog` 字典中。`Parse` 方法会对程序字符串进行标记化并返回标记列表。接下来，`InitializeProg`
    会对子程序进行排序并将其放入 `prog` 字典中。
- en: '[Listing 12-7](ch12.xhtml#ch012list7) shows how to split a source code string
    into tokens separated by whitespace.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 12-7](ch12.xhtml#ch012list7) 显示了如何将源代码字符串拆分成由空格分隔的标记。'
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 12-7: Tokenizing the source code*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-7: 对源代码进行标记化*'
- en: Filska comments begin with a double quote (`"`) and run to the end of the line.
    The `Parse` method scans the input source code character by character, keeping
    all characters that are not part of a comment line. This means a double quote
    is not allowed as part of a token.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Filska的注释以双引号（`"`)开始，并一直持续到行末。`Parse`方法逐字符扫描输入源代码，保留所有不属于注释行的字符。这意味着双引号不能作为令牌的一部分。
- en: With comments removed, the `return` statement uses standard Python functionality
    to first split on whitespace and then join again with a single space between tokens.
    The new string is made uppercase, thereby requiring Filska to be case insensitive,
    so `main` and `MAIN` refer to the same subprogram. Lastly, the last call to `split`
    tokenizes the program text returning a Python list of tokens.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除注释后，`return`语句使用标准的Python功能，首先按空白字符分割，然后再通过单个空格将令牌连接起来。新字符串被转换为大写字母，这要求Filska不区分大小写，因此`main`和`MAIN`指向同一个子程序。最后，最后一次调用`split`对程序文本进行分词，返回一个Python的令牌列表。
- en: '[Listing 12-8](ch12.xhtml#ch012list8) scans the list of tokens looking for
    opening braces (`{`).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-8](ch12.xhtml#ch012list8)扫描令牌列表，查找左大括号（`{`）。'
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 12-8: Separating subprogram text*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-8：分离子程序文本*'
- en: When the parser encounters an opening brace, a new subprogram starts. The `ExtractProg`
    method captures the subprogram’s tokens using the first token as the new subprogram
    name. Subprogram state, meaning memory, program counter, and flags, is also defined
    at the same time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析器遇到一个左大括号时，表示开始一个新的子程序。`ExtractProg`方法使用第一个令牌作为新的子程序名称，捕获子程序的令牌。子程序的状态，包括内存、程序计数器和标志，也会在同一时间定义。
- en: When `InitializeProg` exits, all subprograms have been defined and all their
    states initialized. The Filska program is then ready to execute with a call to
    `Run`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当`InitializeProg`退出时，所有子程序已经定义完毕，且它们的状态已被初始化。然后，通过调用`Run`，Filska程序准备执行。
- en: '***The Execution Loop***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行循环***'
- en: The `Run` method starts the execution loop (see [Listing 12-9](ch12.xhtml#ch012list9)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run`方法启动执行循环（见[清单 12-9](ch12.xhtml#ch012list9)）。'
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 12-9: The execution loop*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-9：执行循环*'
- en: The execution loop is quite short. If not in trace mode, `Run` is nothing more
    than an endless loop that executes instruction after instruction until `hlt` quits
    inside `Execute` or the user hits CTRL-C. The value of `naptime` controls the
    overall speed of a Filska program. The default sleep time is 0.00001 seconds,
    which basically means “run as fast as possible.”
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 执行循环非常简短。如果没有开启追踪模式，`Run`实际上就是一个无限循环，指令一条接着一条地执行，直到`Execute`中的`hlt`退出或用户按下CTRL-C。`naptime`的值控制Filska程序的整体速度。默认的休眠时间是0.00001秒，这基本上意味着“尽可能快地运行”。
- en: The `Execute` method in [Listing 12-10](ch12.xhtml#ch012list10) executes a single
    instruction of the current subprogram.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-10](ch12.xhtml#ch012list10)中的`Execute`方法执行当前子程序的单个指令。'
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 12-10: Executing a single instruction*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-10：执行单个指令*'
- en: First, the current program (`prog`), program counter (`pc`), flags, and local
    memory (`mem`) are loaded for the current subprogram (`CP`). Next, the instruction
    executes by calling `Exec`, which we’ll detail shortly. When `Exec` returns, it
    passes back updated values for the current subprogram, program counter, local
    memory, and local flags. The state of the current subprogram is updated along
    with the name of the current subprogram if a `jmp` or `jpr` instruction was executed.
    Notice that `mem`, `pc`, and `flags` are updated first before the current subprogram
    name, as they refer to the subprogram whose instruction was just executed. If
    transferring to a new subprogram, the new subprogram’s flags are reset.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当前子程序（`prog`）、程序计数器（`pc`）、标志和本地内存（`mem`）会被加载进当前子程序（`CP`）。接着，指令通过调用`Exec`来执行，我们稍后将详细介绍。当`Exec`返回时，它会传回更新后的当前子程序、程序计数器、本地内存和本地标志的值。如果执行了`jmp`或`jpr`指令，还会更新当前子程序的名称。注意，`mem`、`pc`和`flags`首先被更新，然后才是当前子程序名称，因为它们指的是刚执行过指令的子程序。如果转移到一个新子程序，新的子程序的标志将被重置。
- en: The `Exec` method in [Listing 12-11](ch12.xhtml#ch012list11) is responsible
    for processing a single instruction.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-11](ch12.xhtml#ch012list11)中的`Exec`方法负责处理单个指令。'
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 12-11: Evaluating a single instruction*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-11：评估单个指令*'
- en: '`Exec` receives the token representing the instruction (`inst`), the number
    of instructions in the current subprogram (`proglen`), the current value of subprogram
    memory (`mem`), the program counter (`pc`), and the flags (`flags`). `Exec` returns
    the name of the subprogram to execute next (`cp`), which is usually unchanged,
    and the updated state for the subprogram whose instruction was just executed.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exec` 接收表示指令的标记（`inst`）、当前子程序中的指令数量（`proglen`）、当前的子程序内存值（`mem`）、程序计数器（`pc`）和标志（`flags`）。`Exec`
    返回下一个要执行的子程序的名称（`cp`），通常不变，以及刚刚执行过的指令所更新的子程序状态。'
- en: 'Each Filska instruction is processed by a method with the same name as the
    instruction. If the instruction affects flow control, like `jmp`, `jpr`, `gto`,
    or `tst`, it is processed with a varying set of arguments and return values. We’ll
    return to these instructions shortly. All other instructions follow the same format:
    they accept any remaining instruction text (`rest` ➊), memory, and flags as input,
    and return updated memory and flags ➋. Because most Filska instructions do not
    affect program flow, the program counter is updated by adding 1 and rolling over
    to 0 if the subprogram’s length is exceeded ➌.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Filska 指令都由与指令同名的方法处理。如果指令影响流程控制，例如 `jmp`、`jpr`、`gto` 或 `tst`，它将使用一组不同的参数和返回值进行处理。我们稍后会回到这些指令。所有其他指令遵循相同的格式：它们接受任何剩余的指令文本（`rest`
    ➊）、内存和标志作为输入，并返回更新后的内存和标志 ➋。因为大多数 Filska 指令不影响程序流程，程序计数器会通过加 1 来更新，如果超出了子程序的长度则回绕到
    0 ➌。
- en: '***Instructions Without Arguments***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无参数的指令***'
- en: 'Non-flow control instructions come in two varieties: with arguments and without
    arguments. Let’s see how Filska instructions without arguments are implemented.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 非流程控制指令有两种类型：带参数和不带参数。让我们看看 Filska 不带参数的指令是如何实现的。
- en: '[Listing 12-12](ch12.xhtml#ch012list12) implements the `cos` instruction.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-12](ch12.xhtml#ch012list12) 实现了 `cos` 指令。'
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 12-12: A representative no-argument instruction*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-12：一个典型的无参数指令*'
- en: The arguments are any remaining portion of the instruction token after the three-character
    instruction has been removed, the current subprogram’s memory value, and the associated
    flags. For no-argument instructions, `rest` is an empty string. No-argument instructions
    operate on the subprogram’s memory or one of the index registers. Here, the cosine
    of memory is used to update it. As with almost all Filska instructions, a 0 result
    sets the zero flag. All instruction implementations return any new value of the
    memory and any updated flags.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是指令标记中移除三字符指令后的剩余部分、当前子程序的内存值以及相关的标志。对于没有参数的指令，`rest` 是一个空字符串。没有参数的指令操作子程序的内存或其中一个索引寄存器。在这里，内存的余弦值用于更新内存。与几乎所有
    Filska 指令一样，结果为 0 时会设置零标志。所有指令实现都会返回内存的新值以及任何更新的标志。
- en: '***Instructions with Arguments***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***带参数的指令***'
- en: Filska instructions with arguments include `set`, `swp`, and all binary math
    operators. Of the latter, we’ll only detail `add`, as the others operate similarly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 带参数的 Filska 指令包括 `set`、`swp` 和所有二进制数学运算符。对于后者，我们将只详细说明 `add`，因为其他的操作类似。
- en: Let’s begin with `SET` (see [Listing 12-13](ch12.xhtml#ch012list13)). The `swp`
    instruction is similar.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `SET` 开始（见 [列表 12-13](ch12.xhtml#ch012list13)）。`swp` 指令类似。
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 12-13: Implementation of SET*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-13：SET 实现*'
- en: The single argument passed to `SET`, meaning the text of the token beyond the
    string `SET`, is in `rest`. Filska attempts to interpret `rest` as a floating-point
    number and uses 0 if the conversion fails. Naturally, a more sophisticated approach
    would issue an error message, but we can live with the simplification. If `n`
    is 0, the zero flag is set, and the updated memory value and flags returned (see
    [Listing 12-14](ch12.xhtml#ch012list14)).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `SET` 的单个参数，也就是 `SET` 字符串之后的标记文本，位于 `rest` 中。Filska 会尝试将 `rest` 解析为浮动点数，如果转换失败则使用
    0。自然，采用更复杂的方法会发出错误信息，但我们可以接受这种简化。如果 `n` 为 0，零标志会被设置，并返回更新后的内存值和标志（见 [列表 12-14](ch12.xhtml#ch012list14)）。
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 12-14: Implementation of ADD*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-14：ADD 实现*'
- en: Binary math operations like `ADD` use a four-character argument of the form
    <dst>= <op1><op2>. where <dst> is a destination, either memory or an index register,
    and <op1> and <op2> are sources. Memory is denoted as `M` and index registers
    by their names.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `ADD` 这样的二进制数学运算使用四个字符的参数，形式为 <dst>= <op1><op2>，其中 <dst> 是目标，可以是内存或索引寄存器，<op1>
    和 <op2> 是操作数。内存用 `M` 表示，索引寄存器用其名称表示。
- en: '[Listing 12-14](ch12.xhtml#ch012list14) implements addition. The text of the
    argument is in `rest`, as with `SET`. Interpretation of the argument happens in
    the `ops` method, which returns the operand values and the destination register’s
    name (or memory). The operation `ADD` adds the two operands (`ans`) and updates
    memory or index registers based on the destination by calling the `assign` method.
    The other binary operations are similarly implemented, differing only in the line
    defining `ans`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-14](ch12.xhtml#ch012list14) 实现了加法。参数的文本存储在 `rest` 中，类似于 `SET`。参数的解释在
    `ops` 方法中进行，该方法返回操作数的值和目标寄存器的名称（或内存）。操作 `ADD` 将两个操作数（`ans`）相加，并通过调用 `assign` 方法更新内存或索引寄存器，具体取决于目标。其他二元操作也类似实现，唯一不同的是定义
    `ans` 的那一行。'
- en: The `ops` method parses the four-character argument returning numeric values
    pulled from memory, or the index registers for the operands and the single character
    indicating the destination. The `assign` method takes the result, destination,
    current memory value, and flags, and updates the proper destination with the result.
    If the destination is memory and 0, the zero flag is also updated. Lastly, memory
    and flags are returned.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ops` 方法解析四个字符的参数，返回从内存或索引寄存器中提取的操作数的数值，并返回表示目标的单个字符。`assign` 方法接受结果、目标、当前内存值和标志，并使用结果更新正确的目标。如果目标是内存且为
    0，则还会更新零标志。最后，返回内存和标志的值。'
- en: '***Flow Control Instructions***'
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***流程控制指令***'
- en: Instructions controlling program flow are implemented separately, as their inputs
    and outputs vary depending on the instruction. We’ll begin with the jump instructions
    (`JMP` and `JPR`, which transfer program flow between subprograms (see [Listing
    12-15](ch12.xhtml#ch012list15)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 控制程序流程的指令被单独实现，因为它们的输入和输出根据指令的不同而变化。我们将从跳转指令（`JMP` 和 `JPR`，它们用于在子程序之间转移程序流程（见
    [清单 12-15](ch12.xhtml#ch012list15)））开始。
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 12-15: The JMP and JPR instructions*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-15：JMP 和 JPR 指令*'
- en: The only implementation difference between `JMP` and `JPR` is how the program
    counter of the current subprogram is modified. For `JMP`, the program counter
    is incremented, rolling over if necessary, so the next transfer to the current
    subprogram begins with the instruction following `JMP`. For `JPR`, the program
    counter is set to 0 instead. Both instructions return the name of the subprogram
    to which execution is transferred.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`JMP` 和 `JPR` 之间唯一的实现区别是当前子程序的程序计数器的修改方式。对于 `JMP`，程序计数器递增，如果需要会发生溢出，因此下一个转移到当前子程序的指令是
    `JMP` 后面的指令。对于 `JPR`，程序计数器会被重置为 0。两个指令都返回执行转移到的子程序的名称。'
- en: The remaining flow control instructions, `GTO` and `TST`, operate within the
    current subprogram. [Listing 12-16](ch12.xhtml#ch012list16) presents the `GTO`
    instruction.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的流程控制指令 `GTO` 和 `TST` 在当前子程序内运行。[清单 12-16](ch12.xhtml#ch012list16) 展示了 `GTO`
    指令。
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 12-16: Unconditional jump within a subprogram*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-16：子程序内的无条件跳转*'
- en: The `GTO` instruction’s argument is an integer offset to the current program
    counter value, that is, a relative number of instructions to branch from the current
    instruction. First, `GTO` extracts the `offset` from the instruction text and
    converts it to an integer. If the conversion fails, the offset is silently set
    to 1 to move to the next instruction. Updating the program counter comes next.
    The instruction adds the offset, which may be positive or negative, to the program
    counter, with suitable checks for jumping too far back or forward. The updated
    program counter value is then returned.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`GTO` 指令的参数是当前程序计数器值的整数偏移量，也就是说，指令之间的相对跳转数。首先，`GTO` 从指令文本中提取 `offset` 并将其转换为整数。如果转换失败，则偏移量默认为
    1，跳转到下一条指令。接下来更新程序计数器。指令将偏移量（可以是正数或负数）加到程序计数器，并进行适当的检查，确保不会跳得太远（无论是向前还是向后）。更新后的程序计数器值将返回。'
- en: The most complex Filska instruction is `TST` (see [Listing 12-17](ch12.xhtml#ch012list17)).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的 Filska 指令是 `TST`（见 [清单 12-17](ch12.xhtml#ch012list17)）。
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 12-17: Conditional branching within a subprogram*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-17：子程序内的条件分支*'
- en: The first part of the `TST` instruction examines the first argument, the flag
    to test ➊. The current value of the flag is put into `v`. Notice how checking
    for “not zero” asks if the zero flag is currently false. The second part of the
    instruction interprets the offset argument if the desired flag is set ➋. This
    code matches `GTO` in that the offset is extracted and added to the program counter.
    If the flag is not set, the program counter is incremented as usual ➌.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`TST`指令的第一部分检查第一个参数，即要测试的标志➊。当前标志的值被存入`v`。请注意，检查“非零”是询问零标志当前是否为假。指令的第二部分解释了偏移量参数，如果所需标志已设置➋。这段代码与`GTO`相匹配，因为偏移量被提取并加到程序计数器中。如果标志未设置，程序计数器将像平常一样递增➌。'
- en: The core of Filska is in the code above, but not all of it. Again, please spend
    some time reading through *filska.py* to familiarize yourself with the entire
    implementation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Filska的核心在于上面的代码，但并不全是。再次提醒，请花些时间阅读*filska.py*，以熟悉整个实现。
- en: '**Summary**'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter introduced Filska by discussing its design and the thinking behind
    it. We then detailed key portions of the Python implementation to see an embodiment
    of the design.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过讨论Filska的设计及其背后的思维方式来介绍了Filska。接着，我们详细讲解了Python实现中的关键部分，以展示设计的体现。
- en: Now that Filska exists, let’s try to write some programs with it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 既然Filska已经存在，让我们尝试用它写些程序吧。
