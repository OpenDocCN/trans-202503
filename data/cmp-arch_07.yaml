- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**DIGITAL LOGIC**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**数字逻辑**'
- en: '![Image](../images/f0113-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0113-01.jpg)'
- en: 'Switches such as the semiconductor transistors seen in the previous chapter
    are the most basic building block of modern electronic computation. But architects
    don’t usually think in terms of switches. Instead, they build up a hierarchy of
    more complex structures from them, eventually forming a CPU. The next layer of
    this hierarchy consists of logic gates: devices formed from a few switches in
    standard circuits representing basic Boolean functions, such as AND and OR. Logic
    gates, in turn, can be used to build up larger structures such as simple machines
    for arithmetic and memory.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所见，前面提到的半导体晶体管等开关是现代电子计算的最基本构建块。但架构师通常并不以开关的形式思考。相反，他们从开关构建出更复杂的层次结构，最终形成中央处理器（CPU）。这个层次结构的下一层由逻辑门组成：这些设备由少数开关组成的标准电路构成，表示基本的布尔函数，如与（AND）和或（OR）。逻辑门又可以用来构建更大的结构，例如简单的算术和存储机器。
- en: In this chapter, we’ll examine some common types of logic gates and see how
    they’re constructed from switches. We’ll discuss how universal gates such as NAND
    can replace all the others and how Boolean logic can model and simplify circuits
    made from logic gates. But first, a little history.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将研究一些常见的逻辑门类型，并了解它们是如何由开关构建的。我们将讨论如何使用像NAND这样的通用门来替代其他所有门，并讨论如何利用布尔逻辑来简化由逻辑门组成的电路。但首先，我们先了解一点历史。
- en: Claude Shannon and Logic Gates
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 克劳德·香农与逻辑门
- en: By 1936, complex electronic switching circuits were in heavy use in telephone
    exchanges. These circuits automated the work previously performed by human telephone
    operators, making and breaking connections between users’ telephone wires to enable
    their calls. For example, a circuit might calculate functions such as, “If the
    caller has sent us a sequence of pulses encoding number 024 680 2468, and there
    is an available wire from here to the exchange managing 024 numbers, then connect
    the caller to the available wire and transmit 680 2468 in binary on it until the
    exchange replies with a connection code, and start billing them. Otherwise, connect
    the caller to a line-busy signal.” These call-routing functions grew in complexity
    as more telephones, wires, exchanges, and companies connected to the network.
    There was an urgent economic need to reduce their wiring and complexity if at
    all possible. Many hacks existed for replacing complex groups of switches with
    simpler ones that seemed to have the same function, but how to do this reliably
    or optimally wasn’t understood.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到1936年，复杂的电子开关电路在电话交换机中得到广泛应用。这些电路自动化了以前由人工电话接线员完成的工作，通过连接和断开用户的电话线路来实现通话。例如，一个电路可能会计算以下功能：“如果呼叫者发送了一系列脉冲，编码为024
    680 2468，并且从这里到管理024号码的交换机有可用线路，那么就将呼叫者连接到该可用线路，并通过该线路以二进制方式传输680 2468，直到交换机回复连接代码，并开始计费。否则，将呼叫者连接到忙线信号。”随着越来越多的电话、线路、交换机和公司接入网络，这些呼叫路由功能变得越来越复杂。迫切需要减少电路的布线和复杂性，尽可能简化它们。许多临时解决方法存在，用于用看似具有相同功能的更简单开关替换复杂的开关组，但如何可靠或最优地做到这一点仍未被理解。
- en: As we saw in the last chapter, switching devices use energy, so the energy of
    their outputs is less than that of their inputs; this made it difficult to reuse
    an output of one switch as an input to the next. For example, an electrical implementation
    using 0 V and 5 V to represent binary 0 and 1 as inputs will produce something
    like 0 V and 4.9999 V as outputs, because the switching mechanism loses some of
    the energy and voltage. If you build a large system from many switches, these
    voltage drops will accumulate until the output is no longer recognizable as representing
    the binary code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所看到的，开关设备使用能量，因此它们的输出能量低于输入能量；这使得将一个开关的输出重新用于下一个开关的输入变得困难。例如，使用0伏和5伏代表二进制0和1作为输入的电气实现会产生类似0伏和4.9999伏的输出，因为开关机制损失了一部分能量和电压。如果你从许多开关构建一个大型系统，这些电压下降会逐渐积累，直到输出不再能识别为二进制代码。
- en: All this changed in the great computing year of 1936, when Claude Shannon began
    his master’s degree at MIT, which produced arguably the greatest master’s thesis
    of all time. Shannon’s thesis introduced two innovations to computer architecture
    that solved the switch simplification problem.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切在伟大的计算年份1936年发生了变化，那时克劳德·香农开始在麻省理工学院攻读硕士学位，这篇论文可以说是有史以来最伟大的硕士论文。香农的论文为计算机架构引入了两个创新，解决了开关简化的问题。
- en: First, it defined a method to organize groups of switches into a new higher-level
    abstraction, the *logic gate*. Logic gates are defined as devices that take a
    representation of one or more binary variables as inputs, and produce one or more
    binary outputs using the *same representation*. Simple switches are *not* logic
    gates because they lose energy, so the output representation has lower energy
    and is different from the input representation. In contrast, a logic gate must
    top up any energy lost from switching so that its output coding is exactly the
    same as its input coding. This property enables the output of one gate to be cleanly
    used as the input to the next gate, and thus for arbitrarily long sequences of
    gates to be connected together without having to worry about noise introduced
    by the energy loss at each step.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它定义了一种方法，将一组开关组织成一种新的、更高层次的抽象——*逻辑门*。逻辑门被定义为接收一个或多个二进制变量的表示作为输入，并使用*相同的表示*产生一个或多个二进制输出的设备。简单的开关*不是*逻辑门，因为它们会损失能量，导致输出表示的能量低于输入表示的能量，因此与输入表示不同。相比之下，逻辑门必须补充开关过程中损失的能量，使得其输出编码与输入编码完全相同。这个特性使得一个门的输出可以干净利落地作为下一个门的输入，因此可以将任意长的逻辑门序列连接起来，而不必担心每一步中能量损失所带来的噪声。
- en: It’s much easier for a circuit designer to think in terms of logic gates because
    they no longer have to keep track of the lower-level energy considerations. Shannon
    showed how to implement logic gates from the switch technology of his day (electromechanical
    relays), but they can be implemented using many technologies, including water
    switches and modern metal-oxide-semiconductor field-effect transistors (MOSFETs).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对电路设计师来说，使用逻辑门思考要容易得多，因为他们不再需要关注低层次的能量问题。香农展示了如何利用他那个时代的开关技术（机电继电器）来实现逻辑门，但这些逻辑门也可以通过多种技术来实现，包括水开关和现代金属氧化物半导体场效应晶体管（MOSFET）。
- en: Second, Shannon showed that any computation could be performed by combining
    instances of small sets of standard logic gates, such as AND, OR, and NOT. He
    showed how to map these gates and their connections onto the mathematical logic
    of George Boole, *Boolean algebra*, which had been discovered 100 years earlier,
    around 1836\. Boole’s theory can be used to find equivalent expressions to complex
    circuits to simplify them and retain the same functionality using fewer gates
    and switches.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，香农证明了任何计算都可以通过组合标准逻辑门的小集合来实现，例如与门、或门和非门。他展示了如何将这些逻辑门及其连接映射到乔治·布尔的数学逻辑上，*布尔代数*，该代数大约在
    1836 年由布尔发现。布尔的理论可以用来找到复杂电路的等效表达式，简化它们，并使用更少的门和开关保持相同的功能。
- en: '**NOTE**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As if this work weren’t enough for one lifetime, Shannon also went on to invent
    communication theory, an entirely separate and equally brilliant contribution
    to computer science. Smart guy.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果说这项工作还不足以填满一生，那么香农还发明了通信理论，这是计算机科学领域的另一个完全独立且同样卓越的贡献。真是个聪明人。*'
- en: Logic Gates
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑门
- en: In modern terms, a logic gate is any device that has some binary inputs and
    some binary outputs and doesn’t contain any memory, where the inputs and outputs
    use exactly the same physical representations for two symbols, 0 and 1\. A logic
    gate’s function can be completely and deterministically described by a *truth
    table*, which lists the resulting outputs for each configuration of the inputs.
    You’ll see some examples soon.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用现代术语来说，逻辑门是任何具有一些二进制输入和一些二进制输出且不包含任何存储器的设备，其中输入和输出使用完全相同的物理表示来表示两个符号，0 和 1。逻辑门的功能可以通过*真值表*完全且确定性地描述，真值表列出了每种输入配置下的输出结果。你很快会看到一些例子。
- en: It’s possible to invent infinitely many different logic gates, but the most
    common ones today, and those studied by Shannon, are those with only one or two
    inputs and only one output. These standard gates include AND, OR, NOT, XOR, NOR,
    and NAND gates. [Figures 5-1](ch05.xhtml#ch05fig1) to [5-6](ch05.xhtml#ch05fig6)
    show these gates and their truth tables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能发明无限多种不同的逻辑门，但今天最常见的、香农研究过的逻辑门，都是只有一个或两个输入、一个输出的逻辑门。这些标准的逻辑门包括与门、或门、非门、异或门、或非门和与非门。[图
    5-1](ch05.xhtml#ch05fig1) 至 [5-6](ch05.xhtml#ch05fig6) 展示了这些逻辑门及其真值表。
- en: '![Image](../images/f0115-01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0115-01.jpg)'
- en: '*Figure 5-1: An AND gate and its truth table*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：与门及其真值表*'
- en: '![Image](../images/f0115-02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0115-02.jpg)'
- en: '*Figure 5-2: An OR gate and its truth table*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：或门及其真值表*'
- en: '![Image](../images/f0115-03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0115-03.jpg)'
- en: '*Figure 5-3: A NOT (inverter) gate and its truth table*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：非门（反向器）及其真值表*'
- en: '![Image](../images/f0116-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0116-01.jpg)'
- en: '*Figure 5-4: An XOR (exclusive OR) gate and its truth table*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：一个 XOR（排他或）门及其真值表*'
- en: '![Image](../images/f0116-02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0116-02.jpg)'
- en: '*Figure 5-5: A NOR gate and its truth table*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：一个 NOR 门及其真值表*'
- en: '![Image](../images/f0116-03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0116-03.jpg)'
- en: '*Figure 5-6: A NAND gate and its truth table*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：一个 NAND 门及其真值表*'
- en: Each gate’s truth table lists every possible combination of inputs in the left-hand
    columns, and shows the corresponding output in the rightmost column. For example,
    the AND gate’s output is 1 if and only if both of its inputs X and Y are 1\. For
    any other combination of inputs its output is 0.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个门的真值表列出了左侧列中的所有可能输入组合，并在最右侧列中显示相应的输出。例如，只有当与门的两个输入 X 和 Y 都为 1 时，其输出才为 1；对于任何其他输入组合，输出为
    0。
- en: The names and functions of these gates are intended to mimic our human sense
    of logical combinations, with 1 corresponding to truth and 0 to falsehood. For
    example, the AND gate says that X AND Y is true if and only if X is true and Y
    is true. An XOR gate, short for “exclusive OR,” requires *exactly* one of its
    two inputs to be true; the output is false if both inputs are true. This is distinct
    from regular OR, which is true if *either or both* of its inputs are true. (Students
    of digital logic have been known to reply “yes” to questions such as “Would you
    like beer or wine?”) NOR stands for “neither X nor Y,” and the output is true
    only when both inputs are false. NAND can be read as “not X and Y,” and its truth
    table is the opposite of AND.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些逻辑门的名称和功能旨在模仿我们人类对逻辑组合的感知，其中 1 对应于真，0 对应于假。例如，和门（AND）表示 X 和 Y 的与为真，仅当 X 和
    Y 都为真时才成立。异或门（XOR），即“排他或”，要求其两个输入中*恰好*有一个为真；如果两个输入都为真，则输出为假。这与普通的或门（OR）不同，后者只要*其中一个或两个*输入为真时，就输出为真。（数字逻辑的学生有时会对类似“你想喝啤酒还是葡萄酒？”这样的问题回答“是”。）NOR
    代表“既不是 X 也不是 Y”，只有当两个输入都为假时，输出才为真。NAND 可以解释为“非 X 和 Y”，它的真值表与与门（AND）相反。
- en: Logic gates can be connected together into networks to represent more complex
    expressions. For example, [Figure 5-7](ch05.xhtml#ch05fig7) represents X OR (Z
    AND NOT Y), and will set the output to 1 if X is 1, or if Z is 1 and Y is 0\.
    Note that “or” here is inclusive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑门可以连接成网络，表示更复杂的表达式。例如，[图 5-7](ch05.xhtml#ch05fig7)表示 X 或（Z 与非 Y），如果 X 为 1，或者如果
    Z 为 1 且 Y 为 0，则输出为 1。请注意，这里的“或”是包括的。
- en: '![Image](../images/f0117-01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0117-01.jpg)'
- en: '*Figure 5-7: The logic gates for F(X, Y, Z) = X + YZ*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：逻辑门用于 F(X, Y, Z) = X + YZ*'
- en: The network of gates in [Figure 5-7](ch05.xhtml#ch05fig7) may be used, for example,
    in Shannon’s telephone switching application, where it might be a circuit that
    disconnects a call if the receiver hasn’t picked up after 30 seconds (X), or if
    the call previously began (Z) and the caller has no remaining credit (Y).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-7](ch05.xhtml#ch05fig7)中的逻辑门网络可以用于例如香农的电话交换应用中，其中可能是一个电路，如果接听方在 30 秒内没有接起电话（X），或者如果电话之前已经开始（Z），并且呼叫者没有剩余余额（Y），则断开电话。'
- en: '*Identifying Universal Gates*'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*识别通用逻辑门*'
- en: In his research, Shannon wanted to identify a set of *universal gates*, a group
    of different types of logic gates that could be reconfigured to build any machine
    at the hardware level. He showed that several universal sets exist. For example,
    if you have a drawer containing an infinite number of AND and NOT gates, you can
    build anything from them. You could also do this with an infinite number of OR
    and NOT gates, but you can’t build arbitrary functions from only a drawer of AND
    and OR gates. Most interestingly, a drawer containing only NAND gates, or only
    NOR gates, is universal. For example, [Figure 5-8](ch05.xhtml#ch05fig8) shows
    how to build the standard NOT, AND, and OR gates from only NANDs. You’ll get a
    chance to explore this figure more in an exercise at the end of the chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的研究中，香农希望识别一组*通用逻辑门*，这是一组可以重新配置以构建任何硬件级机器的不同类型的逻辑门。他证明了存在多个通用集。例如，如果你有一个抽屉，里面装有无限数量的与门（AND）和非门（NOT），你可以用它们构建任何东西。你也可以使用无限数量的或门（OR）和非门（NOT）来做到这一点，但仅使用与门和或门的抽屉，你无法构建任意函数。最有趣的是，只有
    NAND 门或 NOR 门的抽屉是通用的。例如，[图 5-8](ch05.xhtml#ch05fig8)展示了如何仅通过 NAND 门构建标准的非门、与门和或门。你将在本章末尾的一个练习中有机会进一步探索这个图。
- en: '![Image](../images/f0117-02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0117-02.jpg)'
- en: '*Figure 5-8: Building NOT, AND, and OR gates from universal NAND gates*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：从通用 NAND 门构建非门、与门和或门*'
- en: Universal gates are important because they allow us to reduce the number of
    types of physical gates we need to manufacture down to just one. This is what
    we do in modern integrated circuits (ICs).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通用门之所以重要，是因为它们允许我们将所需制造的物理门的类型数量减少到仅剩一个。这正是我们在现代集成电路（IC）中所做的。
- en: '*Making Logic Gates from Transistors*'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*用晶体管制造逻辑门*'
- en: You might initially think that we could just use a single electrical switch,
    such as a transistor, as an AND gate. After all, a switch takes two inputs, its
    emitter and a base, and turns on one output, the collector, if and only if both
    inputs are on, which is the definition of logical AND. However, we’ve seen that
    a switch must convert some of the incoming energy to heat, so the output is not
    quite in the same form as the inputs and can’t be used directly as an input to
    the next logic gate. To keep the output in the same form as the inputs, we instead
    combine several switches, while using an external power source to keep topping
    up the energy that they lose as heat.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能最初会认为我们可以仅使用一个单独的电气开关，比如晶体管，作为一个 AND 门。毕竟，一个开关接受两个输入：发射极和基极，并且仅当两个输入都打开时，才会将一个输出（集电极）导出，这正是逻辑
    AND 的定义。然而，我们已经看到一个开关必须将一些输入能量转换为热量，因此输出的形式与输入不完全相同，不能直接作为下一个逻辑门的输入。为了保持输出与输入相同的形式，我们反而将几个开关组合在一起，同时使用外部电源不断补充它们因热量损失的能量。
- en: There are many different ways to do this. Shannon’s original designs were optimized
    for electromagnetic relay switches rather than transistors. Modern chips use so-called
    *CMOS (complementary metal-oxide semiconductor)* style, which forms NAND gates
    from two positive-type and two negative-type transistors, as shown in [Figure
    5-9](ch05.xhtml#ch05fig9). With NAND as a universal gate, you can make all the
    other gates out of these CMOS NAND gates.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的方法可以做到这一点。香农的最初设计是针对电磁继电器开关而非晶体管优化的。现代芯片使用所谓的*CMOS（互补金属氧化物半导体）*样式，它由两个正型晶体管和两个负型晶体管组成
    NAND 门，如[图 5-9](ch05.xhtml#ch05fig9)所示。由于 NAND 是一个通用门，你可以用这些 CMOS NAND 门构建所有其他逻辑门。
- en: '![Image](../images/f0118-01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0118-01.jpg)'
- en: '*Figure 5-9: A NAND gate made from p-type and n-type transistors*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：由 p 型和 n 型晶体管构成的 NAND 门*'
- en: An electrical *circuit* is a concept that exists at the transistor level, where
    electrons flow from the power source to ground, then are pumped back from ground
    to power by a power source, creating a closed loop. While it’s common to informally
    refer to networks of logic gates as “digital logic circuits,” this is technically
    incorrect because at that higher level of abstraction, the networks don’t usually
    form closed circuits and instead can have arbitrary network topologies. If we
    were to implement the same networks using non-electronic implementations of logic
    gates, there might not be any circuit even at lower abstraction levels. When we
    draw diagrams and build systems made from logic gates, we should therefore more
    properly call them “digital logic networks” rather than “digital logic circuits.”
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 电气*电路*是一个存在于晶体管层次上的概念，其中电子从电源流向地面，然后通过电源将其从地面泵回电源，形成一个闭合回路。虽然我们通常非正式地将逻辑门网络称为“数字逻辑电路”，但从技术上讲，这是不正确的，因为在更高层次的抽象下，这些网络通常不会形成闭合电路，反而可能具有任意的网络拓扑结构。如果我们使用非电子的逻辑门实现相同的网络，在更低层次的抽象下甚至可能根本没有电路。因此，当我们绘制图表并构建由逻辑门组成的系统时，应该更准确地称它们为“数字逻辑网络”而不是“数字逻辑电路”。
- en: '**MAKING LOGIC GATES FROM BILLIARD BALLS**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**用台球制造逻辑门**'
- en: Logic gates don’t have to be made from transistors or even electricity. For
    example, billiard-ball computers are a theoretical invention where computation
    is done with balls in a complex geometric maze environment, in which versions
    of logic gates such as AND and OR are implemented through geometric structures
    and mechanics. The gates are arranged so that, for example, an AND gate tests
    for the collisions of two balls and directs one of them to the positive output
    only if the collision occurred, as in the following figure.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑门不一定必须由晶体管或电流构成。例如，台球计算机是一种理论发明，其中计算是在一个复杂的几何迷宫环境中通过台球进行的，像 AND 和 OR 这样的逻辑门版本是通过几何结构和力学实现的。这些门的排列方式是，例如，AND
    门检测两个台球的碰撞，并且只有当碰撞发生时，才会将其中一个台球导向正输出，如下图所示。
- en: '![Image](../images/f0119-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0119-01.jpg)'
- en: Due to the mechanical laws of conservation of energy, the billiard-ball computer
    models can be used to show that computation needs the same amount of energy and
    therefore the same number of bits of information to exit and enter. This isn’t
    the case for a normal AND gate, which has two inputs and one output. The model
    shows that we should add a second “garbage” output for the exhausted second bit.
    This has the interesting property that it makes the computation *reversible* in
    the sense that the input could be reconstructed if we know the output. This allows
    us to run the machine backward. If that sounds strange, consider that there are
    many programming situations where it would be nice to have a reverse debugger
    that could undo the effects of recent lines of code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于能量守恒的机械定律，台球计算机模型可以用来表明，计算需要相同数量的能量，因此也需要相同数量的比特信息来进出。这与普通的与门（AND gate）不同，后者有两个输入和一个输出。模型表明，我们应该为消耗的第二比特添加一个额外的“垃圾”输出。这具有一个有趣的特性，即使得计算在某种意义上是*可逆的*，即如果我们知道输出，就可以重建输入。这使得我们能够反向运行机器。如果这听起来很奇怪，可以考虑到许多编程场景中，拥有一个反向调试器来撤销最近几行代码的效果将是非常有用的。
- en: The billiard-ball computer was intended to enable us to think clearly about
    the role of energy usage and heat in computation. This has become a big topic
    recently as the rise of portable computers dependent on small batteries has increased
    the need to conserve computational energy, and as concerns have mounted about
    the environment, fuel resources and costs, carbon emissions, and heat pollution.
    A conventional AND gate has two inputs and only one output, so one billiard ball’s
    worth of energy is lost as physical heat every time we do an AND operation. The
    billiard-ball model suggests that we could build electric AND gates that don’t
    waste energy if we were to keep track of a second output bit from the gate—the
    same bit needed to make it reversible. Heat is actually energy that we’ve lost
    track of, in this case by throwing information away. This is why your phone gets
    hot when doing heavy computation, and it’s why your processor needs a large fan.
    The fan is pumping waste information in bits out of your computer’s vents. (In
    this sense, the world running out of fuel isn’t an energy crisis, but rather an
    information crisis. Energy can’t be created or destroyed, but we can lose the
    information about where the energy is—information we’d need to make the energy
    do useful work for us.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 台球计算机的目的是帮助我们清楚地思考能量使用和热量在计算中的角色。随着依赖小型电池的便携式计算机的兴起，越来越需要节省计算能量，尤其是随着环境问题、燃料资源和成本、碳排放和热污染的关注不断增加，这个话题变得更加重要。传统的与门有两个输入和一个输出，因此每次执行与操作时都会有一个台球的能量作为物理热量损失。台球模型表明，如果我们跟踪门的第二个输出比特——这个比特同样用于使计算可逆——我们可以构建不会浪费能量的电气与门。热量实际上是我们丢失的能量，在这种情况下是通过丢弃信息造成的。这就是为什么你的手机在进行大量计算时会变热，也解释了为什么你的处理器需要一个大风扇。风扇正把废弃的信息以比特的形式从计算机的通风口排出。（从这个意义上说，世界上燃料枯竭不是能源危机，而是信息危机。能量不能被创造或摧毁，但我们可以丢失关于能量去向的信息——这是我们需要的信息，才能让能量为我们做有用的工作。）
- en: '*Putting Logic Gates on Chips*'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*将逻辑门放入芯片中*'
- en: When you first look at a chip through a microscope, or at any computer built
    from any kind of logic gates, you won’t be able to point to a single component
    and say, “That’s a logic gate.” What you’ll actually see is a whole load of transistors,
    organized into gates. For example, take a look at [Figure 5-10](ch05.xhtml#ch05fig10),
    which shows a microscope photo (“die shot”) of a very simple silicon chip containing
    only four CMOS NAND gates, each formed from four transistors (as you saw in [Figure
    5-9](ch05.xhtml#ch05fig9)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次通过显微镜查看芯片时，或者查看任何由逻辑门构建的计算机时，你无法指向单个组件并说：“那是一个逻辑门。”你实际上会看到一堆晶体管，它们被组织成门。例如，看看[图
    5-10](ch05.xhtml#ch05fig10)，这张图片展示了一个非常简单的硅芯片的显微镜照片（“die shot”），其中只包含四个 CMOS NAND
    门，每个门由四个晶体管构成（正如你在[图 5-9](ch05.xhtml#ch05fig9)中看到的）。
- en: '![Image](../images/f0120-01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0120-01.jpg)'
- en: '*Figure 5-10: A die shot of a simple silicon chip containing four CMOS NAND
    gates*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-10：包含四个 CMOS NAND 门的简单硅芯片的显微镜照片*'
- en: '[Figure 5-11](ch05.xhtml#ch05fig11) is a mask set for a single CMOS NAND gate,
    showing how to physically lay out the p- and n-doping regions along with the copper
    wiring.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-11](ch05.xhtml#ch05fig11)是一个单一 CMOS NAND 门的掩模集，展示了如何物理布局 p 型和 n 型掺杂区以及铜线。'
- en: Modern processors may have billions of transistors grouped into logic gates.
    But older-style ICs containing just a few logic gates are still manufactured and
    are very useful for building your own circuits. The 7400 TTL series is a famous
    example of such simple chips. Originally produced by Texas Instruments in the
    1960s, they’re now widely manufactured as generic products. Most chips in this
    series contain just a handful of logic gates of a single type, such as four AND
    gates, four NAND gates, or four NOR gates, as shown in [Figure 5-12](ch05.xhtml#ch05fig12).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现代处理器可能包含数十亿个晶体管，这些晶体管被分组到逻辑门中。但仍然生产包含少量逻辑门的老式集成电路，这些电路对于构建你自己的电路非常有用。7400 TTL系列就是这样简单芯片的一个著名例子。最初由德州仪器在1960年代生产，它们现在已作为通用产品广泛生产。该系列的大多数芯片只包含少量单一类型的逻辑门，例如四个与门、四个与非门或四个或非门，正如[图
    5-12](ch05.xhtml#ch05fig12)所示。
- en: '![Image](../images/f0121-01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0121-01.jpg)'
- en: '*Figure 5-11: A CMOS NAND gate made from transistors and copper wire as a chip
    layout*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11：用晶体管和铜线制作的CMOS NAND门芯片布局*'
- en: '![Image](../images/f0121-02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0121-02.jpg)'
- en: '*Figure 5-12: Some 7400 TTL series chips, each containing a few logic gates*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-12：一些7400 TTL系列芯片，每个芯片包含几个逻辑门*'
- en: These diagrams show the physical layouts and pinouts of the chips; to connect
    the logic gates you attach physical wires to the appropriate pins. You can buy
    bags of these chips for a few dollars on eBay and wire them up on a breadboard
    with a 5 V power source and ground, as in [Figure 5-13](ch05.xhtml#ch05fig13),
    to make your own physical digital logic networks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图表展示了芯片的物理布局和引脚排列；要连接逻辑门，你需要将物理导线连接到适当的引脚。你可以在eBay上花几美元购买这些芯片的袋装，然后在面包板上将它们与5V电源和接地连接，就像在[图
    5-13](ch05.xhtml#ch05fig13)中那样，制作你自己的物理数字逻辑网络。
- en: '![Image](../images/f0122-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0122-01.jpg)'
- en: '*Figure 5-13: Building a digital logic network (forming a 4-bit CPU) using
    the logic gates on TTL 7400 series chips on a breadboard*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-13：使用TTL 7400系列芯片上的逻辑门在面包板上构建数字逻辑网络（形成一个4位CPU）*'
- en: 'You can see from [Figure 5-13](ch05.xhtml#ch05fig13) that the wiring for digital
    logic networks can get quite complicated. Wouldn’t it be nice if we had a way
    to simplify networks to use fewer gates and wires, while still performing the
    same functionality? This is where the next part of Shannon’s innovation comes
    in: how to use George Boole’s logic to perform such simplifications.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图 5-13](ch05.xhtml#ch05fig13)中你可以看到，数字逻辑网络的接线可能会变得非常复杂。如果我们有一种方法，能够简化网络，使用更少的逻辑门和导线，同时仍然实现相同的功能，那该多好？这正是香农创新的下一部分：如何利用乔治·布尔的逻辑来进行这种简化。
- en: Boolean Logic
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔逻辑
- en: Logic allows us to formalize statements and inferences about truth and falsehood.
    It was developed by the ancient Greeks and remained largely unchanged until George
    Boole’s work around 1836\. Boole’s work was picked up by Shannon in 1936, who
    realized that it could be used to model, simplify, and verify circuits built from
    his logic gates.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑允许我们形式化关于真与假的陈述和推理。它由古希腊人发明，并一直保持不变，直到乔治·布尔在1836年左右的工作。布尔的工作被香农于1936年采纳，他意识到它可以用来建模、简化和验证由他的逻辑门构建的电路。
- en: Boolean logic uses variable *names* to represent conceptual statements whose
    *values* are either true or false. It then provides connective symbols for AND,
    OR, and NOT, and rules that give truth values to expressions built from variables
    and these connectives.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔逻辑使用变量*名称*来表示概念性命题，且这些命题的*值*要么为真，要么为假。接着，它提供了AND、OR和NOT的连接符号，以及用于给由变量和这些连接符构建的表达式赋予真值的规则。
- en: 'Consider the following example. We have two variables: X represents the statement
    “God exists” and Y represents “snow is white.” We can then represent “God exists
    and snow is white” with X AND Y. Or we can represent “Either God doesn’t exist
    and snow is white, or God does exist and snow is white” with (NOT X AND Y) OR
    (X AND Y).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下示例为例。我们有两个变量：X代表命题“上帝存在”，Y代表“雪是白色的”。那么我们可以用X AND Y来表示“上帝存在且雪是白色的”。或者我们可以用（NOT
    X AND Y）OR（X AND Y）来表示“要么上帝不存在且雪是白色的，要么上帝存在且雪是白色的”。
- en: Now let’s see how to work with these statements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何处理这些陈述。
- en: '*Logic as Arithmetic*'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*逻辑即算术*'
- en: Boole discovered a structural similarity between logic and arithmetic. Previously,
    these had been two entirely different fields of study. Logic was an “arts subject”
    performed using natural language text and by studying rules to analyze arguments.
    Arithmetic was a “STEM subject” made of numbers and equations. As mathematicians
    had managed to unify geometry and algebra, so Boole managed to unify logic and
    arithmetic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔发现了逻辑与算术之间的结构相似性。以前，这两者是完全不同的学科。逻辑是通过自然语言文本和研究规则来分析论证的“文科科目”。算术是由数字和方程式组成的“STEM科目”。正如数学家们成功地统一了几何学和代数一样，布尔成功地统一了逻辑和算术。
- en: He did this by noticing that truth, represented by the symbol T, behaves like
    the number 1, and falsehood, represented by the symbol F, behaves like the number
    0, if we replace AND with multiplication, OR with addition, and NOT with inversion
    about 1.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 他通过注意到真值（用符号T表示）像数字1一样运作，而假值（用符号F表示）像数字0一样运作，来完成这一点。如果我们将与运算用乘法代替，将或运算用加法代替，将非运算用对1的取反代替，就能得出这一结论。
- en: As we write *x* + *y* for addition and *xy* for multiplication in arithmetic,
    we can thus use these same notations for OR and AND. When using this notation,
    it’s common to also write *x* for NOT *x*, which corresponds to the arithmetic
    operation (1 – *x*).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在算术中我们用 *x* + *y* 表示加法，用 *xy* 表示乘法一样，我们可以用这些相同的符号表示或运算和与运算。当使用这种符号时，通常也会将
    *x* 写作非 *x*，这对应算术运算（1 – *x*）。
- en: The similarity isn’t quite perfect, because 1 + 1 = 2 in arithmetic but we need
    1 + 1 = 1 in logic. Boole worked around this by choosing to work in a number system
    with only two numbers, 0 and 1, and by defining 1 plus anything to equal 1 within
    this system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相似性并不完全相同，因为在算术中1 + 1 = 2，但在逻辑中我们需要1 + 1 = 1。布尔通过选择仅使用两个数字0和1的数字系统，并定义在此系统内1加任何数都等于1，来绕过了这个问题。
- en: Using Boole’s system, logical arguments can be converted into simple arithmetic.
    The advantage of doing this is that we know a lot about arithmetic already, in
    particular how to use laws such as associativity, commutativity, and others listed
    in [Table 5-1](ch05.xhtml#ch05tab1) to simplify expressions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔的系统，逻辑论证可以转化为简单的算术。这样做的优点是我们已经知道很多算术知识，特别是如何使用如结合律、交换律等[表5-1](ch05.xhtml#ch05tab1)中列出的规律来简化表达式。
- en: '**Table 5-1:** Useful Arithmetic Theorems for Simplifying Boolean Logic'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-1：** 简化布尔逻辑的有用算术定理'
- en: '| **Name** | **AND form** | **OR form** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **与运算形式** | **或运算形式** |'
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Identity law | 1*A* = *A* | 0 + *A* = *A* |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 恒等律 | 1*A* = *A* | 0 + *A* = *A* |'
- en: '| Null law | 0*A* = 0 | 1 + *A* = 1 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 零律 | 0*A* = 0 | 1 + *A* = 1 |'
- en: '| Idempotent law | *AA* = *A* | *A* + *A* = *A* |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 幂等律 | *AA* = *A* | *A* + *A* = *A* |'
- en: '| Inverse law | *AA* = 0 | *A* + *A* = 1 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 反演律 | *AA* = 0 | *A* + *A* = 1 |'
- en: '| Commutative law | *AB* = *BA* | *A* + *B* = *B* + *A* |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 交换律 | *AB* = *BA* | *A* + *B* = *B* + *A* |'
- en: '| Associative law | (*AB*)*C* = *A* (*BC*) | (*A* + *B*) + *C* = *A* + (*B*
    + *C*) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 结合律 | (*AB*)*C* = *A* (*BC*) | (*A* + *B*) + *C* = *A* + (*B* + *C*) |'
- en: '| Distributive law | *A* + *BC* = (*A* + *B*)(*A* + *C*) | *A*(*B* + *C*) =
    *AB* + *AC* |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 分配律 | *A* + *BC* = (*A* + *B*)(*A* + *C*) | *A*(*B* + *C*) = *AB* + *AC*
    |'
- en: '| Absorption law | *A*(*A* + *B*) = *A* | *A* + *AB* = *A* |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 吸收律 | *A*(*A* + *B*) = *A* | *A* + *AB* = *A* |'
- en: '| De Morgan’s law | *AB* = *A* + *B* | (*A* + *B*) = *AB* |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 德摩根定律 | *AB* = *A* + *B* | (*A* + *B*) = *AB* |'
- en: 'For example, say we want to calculate the truth value of:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想计算以下的真值：
- en: (F AND (T OR F)) OR ((F OR NOT T) AND T)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: (F AND (T OR F)) OR ((F OR NOT T) AND T)
- en: 'We can do it by converting the logic to arithmetic, then using standard arithmetic
    rules to simplify the expression:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将逻辑转化为算术，然后使用标准的算术规则来简化表达式：
- en: (0(1) + 0(0)) + ((0)1 + (1 – 1)1)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: (0(1) + 0(0)) + ((0)1 + (1 – 1)1)
- en: = (0 + 0) + (0 + (0)1)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: = (0 + 0) + (0 + (0)1)
- en: = (0) + (0 + 0)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: = (0) + (0 + 0)
- en: = 0 + 0
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: = 0 + 0
- en: = 0
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: = 0
- en: Finally, we convert the resulting number, 0, back to the logical value false.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将得到的数字0转回逻辑值假。
- en: 'This also works using variables rather than particular values; for example,
    the previous statement about God and snow can be written and then manipulated
    arithmetically as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于使用变量而不是特定值；例如，之前关于上帝和雪的陈述可以写成并以算术方式操作：
- en: ((1 – *x*)*y*) + (*xy*)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ((1 – *x*)*y*) + (*xy*)
- en: = (*y* – *xy*) + (*xy*)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: = (*y* – *xy*) + (*xy*)
- en: = *y* – *xy* + *xy*
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: = *y* – *xy* + *xy*
- en: = *y*
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: = *y*
- en: This can then be converted from the arithmetical number *y* back to the logical
    value *Y*. This shows that the truth of the statement is actually independent
    of the existence of God (*X*) and depends only on whether snow is white (*Y*).
    So assuming that snow is indeed white, the statement is true.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以将算术数字*y*转换回逻辑值*Y*。这表明命题的真值实际上与上帝的存在(*X*)无关，仅依赖于雪是否是白色(*Y*)。所以假设雪确实是白色的，那么命题就是真的。
- en: '**NOTE**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The ability to move back and forth between logical truth values and integer
    0s and 1s is now often used (or arguably misused) in languages such as C that
    play fast and loose with these types.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在，往返于逻辑真值和整数0、1之间的能力通常在诸如C等语言中使用（或者可以说是误用），这些语言在处理这些类型时非常灵活。*'
- en: '*Model Checking vs. Proof*'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*模型检查与证明*'
- en: We often want to know whether two Boolean expressions are equal. There are two
    main ways to go about determining this.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要知道两个布尔表达式是否相等。确定这一点有两种主要的方法。
- en: 'The first is called *model checking*. Given a potential equality, we simply
    compute truth tables for both the left side and the right side of the potential
    equation. If the truth tables match completely, then the expressions are equal.
    As an example, let’s check that the AND form of the distributive law from [Table
    5-1](ch05.xhtml#ch05tab1) always holds. First, we calculate and compute the table
    for the left side of the equality, *A* + *BC*. We begin with three columns for
    our variables: *A*, *B*, and *C*. We then add a column for our intermediate term,
    *BC*, and use this to compute the value of the whole expression in the rightmost
    column, as in [Table 5-2](ch05.xhtml#ch05tab2).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个叫做*模型检查*。给定一个潜在的等式，我们只需计算潜在等式左右两边的真值表。如果真值表完全匹配，那么表达式是相等的。例如，我们来检查[表5-1](ch05.xhtml#ch05tab1)中的分配律的与形式是否始终成立。首先，我们计算并计算等式左边的表格，即
    *A* + *BC*。我们从三列变量开始：*A*、*B* 和 *C*。然后我们为中间项*BC*添加一列，并用此列计算整个表达式在最右边列的值，如[表5-2](ch05.xhtml#ch05tab2)所示。
- en: '**Table 5-2:** The Truth Table for *A* + *BC*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-2：** *A* + *BC* 的真值表'
- en: '| ***A*** | ***B*** | ***C*** | ***BC*** | ***A*** + ***BC*** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| ***A*** | ***B*** | ***C*** | ***BC*** | ***A*** + ***BC*** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 0 | 0 | 0 | 0 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 0 | 0 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 0 |'
- en: '| 0 | 1 | 0 | 0 | 0 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 | 0 |'
- en: '| 0 | 1 | 1 | 1 | 1 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 | 1 |'
- en: '| 1 | 0 | 0 | 0 | 1 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 | 1 |'
- en: '| 1 | 0 | 1 | 0 | 1 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 | 0 | 1 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 1 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 |'
- en: Next, we do the same for the right side of the equality, *(A* + *B*)(*A* + *C*),
    in [Table 5-3](ch05.xhtml#ch05tab3).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对等式右边的表达式*(A* + *B*)(*A* + *C*)进行相同的操作，见[表5-3](ch05.xhtml#ch05tab3)。
- en: '**Table 5-3:** The Truth Table for (*A* + *B*)(*A* + *C*)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-3：** (*A* + *B*)(*A* + *C*) 的真值表'
- en: '| ***A*** | ***B*** | ***C*** | (***A*** + ***B***) | (***A*** + ***C***) |
    (***A*** + ***B***)(***A*** + ***C***) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| ***A*** | ***B*** | ***C*** | (***A*** + ***B***) | (***A*** + ***C***) |
    (***A*** + ***B***)(***A*** + ***C***) |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 0 | 1 | 0 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 1 | 0 |'
- en: '| 0 | 1 | 0 | 1 | 0 | 0 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 0 | 0 |'
- en: '| 0 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 | 1 | 1 |'
- en: '| 1 | 0 | 0 | 1 | 1 | 1 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | 1 | 1 |'
- en: '| 1 | 0 | 1 | 1 | 1 | 1 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 | 1 | 1 |'
- en: '| 1 | 1 | 0 | 1 | 1 | 1 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 | 1 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 |'
- en: Finally, we compare the tables. Here we can see that for every possible assignment
    of values to the variables, the resulting value is the same in both tables. Therefore,
    by model checking, the left side equals the right side.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们比较这些表格。在这里我们可以看到，对于每种可能的变量值分配，两张表格中的结果值是相同的。因此，通过模型检查，左边等于右边。
- en: Model checking makes use of the *values* of the terms. If an equality has been
    shown by model checking, we say that it has been *entailed*, and that it is *true*,
    and we write ⊧ *A* + *BC* = (*A* + *B*)(*A* + *C*).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 模型检查利用了项的*值*。如果通过模型检查已经证明了一个等式，我们就说它已经被*蕴含*，并且它是*真的*，我们写作 ⊧ *A* + *BC* = (*A*
    + *B*)(*A* + *C*)。
- en: The second way to show equalities is by *proof*. If some equalities have already
    been established, such as the laws of [Table 5-1](ch05.xhtml#ch05tab1), we can
    make use of their results symbolically without having to grind through the truth
    tables of everything. A proof is a list of transformations from the first to the
    second expression, where each transformation is justified by stating which law
    has been applied. If an equality has been shown by proof, we say it is *proved*
    and write ⊢ *A* + *BC* = (*A* + *B*)(*A* + *C*).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 证明等式的第二种方式是通过*证明*。如果一些等式已经建立，如[表5-1](ch05.xhtml#ch05tab1)中的法则，我们可以在符号上利用它们的结果，而不必对所有内容逐一进行真值表推导。证明是从第一个表达式到第二个表达式的转换列表，每个转换都通过说明应用了哪条法则来证明。如果通过证明展示了某个等式，我们说它已经被*证明*，并写作
    ⊢ *A* + *BC* = (*A* + *B*)(*A* + *C*)。
- en: 'For example, here’s one way to prove that *A* + *BC* = (*A* + *B*)(*A* + *C*):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一种方法可以证明 *A* + *BC* = (*A* + *B*)(*A* + *C*)：
- en: '| *A* + *BC* | = (1*A*) + (*BC*) | : by AND identity law |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| *A* + *BC* | = (1*A*) + (*BC*) | : 根据与的恒等律 |'
- en: '|  | = (*A*(1 + *B*)) + (*BC*) | : by OR null law |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  | = (*A*(1 + *B*)) + (*BC*) | : 根据或的空律 |'
- en: '|  | = (*A*1) + (*AB*) + (*BC*) | : by OR distributive law |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|  | = (*A*1) + (*AB*) + (*BC*) | : 根据或的分配律 |'
- en: '|  | = (*A*(1 + *C*)) + (*AB*) + (*BC*) | : by OR null law |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  | = (*A*(1 + *C*)) + (*AB*) + (*BC*) | : 根据或的空律 |'
- en: '|  | = (*A*(*A* + *C*)) + *B*(*A* + *C*) | : by OR distributive law |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  | = (*A*(*A* + *C*)) + *B*(*A* + *C*) | : 根据或的分配律 |'
- en: '|  | = (*A* + *C*)(*A* + *B*) | : by OR distributive law |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  | = (*A* + *C*)(*A* + *B*) | : 根据或的分配律 |'
- en: '**NOTE**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*For Boolean logic it can be shown that any equality established through model
    checking can also be proved, and vice versa, so you can use either method according
    to taste. It may seem obvious that model checking and proof give the same answers
    in Boolean logic, but this isn’t always the case for other logics, as found later
    by Gödel.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于布尔逻辑，可以证明任何通过模型检查建立的等式也可以通过证明得出，反之亦然，所以你可以根据个人喜好选择任何一种方法。虽然在布尔逻辑中，模型检查和证明给出的答案看似是一样的，但对于其他逻辑系统，这并不总是成立，正如哥德尔后来发现的那样。*'
- en: The ability to check whether two expressions are equal isn’t purely academic.
    Shannon recognized its value in simplifying his digital logic networks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个表达式是否相等的能力并非纯粹是学术问题。香农认识到它在简化数字逻辑网络中的价值。
- en: '**GEORGE BOOLE**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**乔治·布尔**'
- en: George Boole published his books *The Mathematical Analysis of Logic* (1847)
    and *The Laws of Thought* (1854) a few years after Babbage’s Engines. Boole grew
    up and formed his ideas in Lincoln, England. Unlike most historical academic heroes
    from rich families able to buy their way into Cambridge—such as Babbage and Turing—Boole
    came from an ordinary, poor family. His father was a shoemaker. Boole had no formal
    education, going instead to the public library and reading books to teach himself,
    *like you can do today*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 乔治·布尔在巴贝奇的机械计算机问世几年后，出版了他的著作《逻辑的数学分析》（1847年）和《思想的法则》（1854年）。布尔在英国林肯成长并形成了他的思想。与大多数历史上来自富裕家庭、能够买通进入剑桥的学术英雄不同，如巴贝奇和图灵，布尔来自一个普通且贫困的家庭。他的父亲是一个鞋匠。布尔没有接受正式教育，而是去了公共图书馆，通过阅读书籍自学，*就像今天你可以做的那样*。
- en: Boole created many new ideas outside the academic system, without that system’s
    constraints on his thinking. In particular, no one told him that arts and sciences
    were supposed to be kept separate, so he would physically wander between both
    sections of the library, making comparisons between them. While his name is strongly
    associated with Boolean logic and the boolean or bool data types in modern programming
    languages, he also worked on probabilistic and other forms of reasoning, and was
    motivated by trying to understand and model human intelligence, as in modern AI
    and cognitive science. His real motivation for studying logic and other forms
    of reasoning was to formalize, analyze, and check the many arguments from classical
    philosophy, especially concerning the existence of God. He wanted to find out
    if these arguments were valid, breaking them down into their parts and testing
    each step so he could find out which of their conclusions were true and what to
    believe.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔在没有学术体系的约束下创造了许多新的思想。他没有受到该体系对思维的限制。尤其是没有人告诉他，艺术和科学应该分开，因此他会在图书馆的两个部分之间走动，进行比较。虽然他的名字与布尔逻辑和现代编程语言中的布尔或（bool）数据类型密切相关，但他也研究了概率学和其他形式的推理，并且他受到理解和建模人类智能的动机，正如现代的人工智能和认知科学所做的那样。他研究逻辑和其他推理形式的真正动机是为了形式化、分析和检验经典哲学中的许多论证，尤其是关于上帝存在的论证。他想弄明白这些论证是否有效，通过将它们拆解成各个部分并测试每一步，看看哪些结论是真实的，哪些是值得相信的。
- en: 'For example, here’s part of Boole’s logic for the existence of God (from *The
    Laws of Thought*, [Chapter 13](ch13.xhtml)):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是布尔关于上帝存在的逻辑（摘自《思维的法则》，[第 13 章](ch13.xhtml)）：
- en: Let *x* = Something has always existed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *x* = 某物一直存在。
- en: '*y* = There has existed some one unchangeable and independent being.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = 曾经存在某个不变且独立的存在。'
- en: '*z* = There has existed a succession of changeable and dependent beings.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*z* = 曾经存在一系列可变化且相互依赖的存在。'
- en: '*p* = That series has had a cause from without.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*p* = 该系列具有外部原因。'
- en: '*q* = That series has had a cause from within.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*q* = 该系列具有内部原因。'
- en: 'Then we have the following system of equations, viz.: 1st. *x* = 1;'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到以下方程组，即：1st. *x* = 1;
- en: 2nd. *x* = *v*{*y*(1 –*z*) + *z* (1 –*y*)};
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 2nd. *x* = *v*{*y*(1 –*z*) + *z* (1 –*y*)};
- en: 3rd. *z* = *v*{*p*(1 –*q*) + (1 –*p*)*q*};
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 3rd. *z* = *v*{*p*(1 –*q*) + (1 –*p*)*q*};
- en: 4th. *p* = 0;
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 4th. *p* = 0;
- en: '5th. *q* = 0:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 5th. *q* = 0;
- en: Boole’s short life—the founder of modern logic was killed by his homeopathic
    wife’s theory of wrapping him in ice-cold blankets to cure pneumonia—was a subset
    of Babbage’s, so they would likely have read each other’s work. Boole wasn’t interested
    in computer science, however. His ultimate interests were philosophical, and his
    work understanding and modeling intelligence was primarily intended as a contribution
    to the philosophical method. Still, he would have been aware that creating such
    formalisms would also enable them to be mechanized as AI, as discussed by Lovelace.
    It’s a great shame the two never got together to develop this idea.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔的短暂一生——现代逻辑的创始人被他妻子用冰冷的毛毯包裹以治疗肺炎的顺势疗法所致死——是巴贝奇的一部分，因此他们很可能会阅读彼此的作品。然而，布尔对计算机科学并不感兴趣。他的最终兴趣是哲学性的，他对理解和建模智能的工作主要是为了为哲学方法做出贡献。尽管如此，他仍然会意识到，创造这样的形式化方法也能够使其机械化为人工智能，正如洛夫莱斯所讨论的那样。很遗憾，二人从未共同合作开发这一思想。
- en: Simplifying Logic Circuits Using Boolean Logic
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用布尔逻辑简化逻辑电路
- en: Shannon discarded Boole’s conceptual interpretations of the variables, and instead
    showed that Boole’s algebra could be used to simplify physical digital logic networks
    composed of logic gates. Simplification can include reducing both the number of
    gates and also the number of *types* of gates, such as reduction to all NAND gates.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 香农抛弃了布尔对变量的概念性解释，转而展示了布尔代数可以用来简化由逻辑门组成的物理数字逻辑网络。简化可以包括减少门的数量，以及减少门的*类型*，例如将所有逻辑门简化为
    NAND 门。
- en: 'This is done by translating a logic gate network into a Boolean expression,
    simplifying the expression using the laws of arithmetic, then translating the
    result back into a smaller logic gate network. Simplifying networks is useful
    because it reduces the number of transistors needed, which in turn reduces manufacturing
    costs and energy usage. Nowadays, CAD software is available that performs simplifications
    automatically: you input your digital logic network, click an icon, and get back
    a smaller and more efficient version.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过将逻辑门网络转换为布尔表达式，使用算术法则简化表达式，然后将结果转换回更小的逻辑门网络来完成的。简化网络是有用的，因为它减少了所需的晶体管数量，从而降低了制造成本和能源使用。如今，已经有了自动执行简化的
    CAD 软件：你输入你的数字逻辑网络，点击一个图标，便能得到一个更小、更高效的版本。
- en: For example, suppose we’ve designed the digital logic network on the left-hand
    side of [Figure 5-14](ch05.xhtml#ch05fig14). Using Boole’s theory this can be
    converted to an arithmetic expression and simplified to obtain *(A* + *B*)(*A*
    + *C*) = *A* + *BC*. This corresponds to the smaller network on the right side
    of [Figure 5-14](ch05.xhtml#ch05fig14).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们已经设计了[图 5-14](ch05.xhtml#ch05fig14)左侧的数字逻辑网络。利用布尔理论，这可以转换为算术表达式并简化为*(A*
    + *B*)(*A* + *C*) = *A* + *BC*。这对应于[图 5-14](ch05.xhtml#ch05fig14)右侧的较小网络。
- en: '![Image](../images/f0127-01.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0127-01.jpg)'
- en: '*Figure 5-14: A logic network for (A + B)(A + C) (left) and reduced A + BC
    form (right)*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-14：逻辑网络 (A + B)(A + C)（左图）和简化后的 A + BC 形式（右图）*'
- en: We can use Boolean logic to further simplify the logic network to use only universal
    NAND gates, then reduce the number of NAND gates, as in [Figure 5-15](ch05.xhtml#ch05fig15).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用布尔逻辑进一步简化逻辑网络，使其仅使用通用的 NAND 门，然后减少 NAND 门的数量，如[图 5-15](ch05.xhtml#ch05fig15)所示。
- en: '![Image](../images/f0128-01.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0128-01.jpg)'
- en: '*Figure 5-15: The Boolean logic converting A + BC to NAND gates (left) and
    then reducing them (right)*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-15：将 A + BC 转换为 NAND 门（左图）并进行简化（右图）*'
- en: This allows us to convert any network into one that can be built more easily,
    using just one type of gate and as few of them as possible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就能将任何网络转换为一个更容易构建的网络，只需使用一种类型的门电路，并且尽可能少地使用它们。
- en: Laying Out Digital Logic
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布置数字逻辑
- en: Once you’ve designed and simplified a digital logic network, you’ll usually
    want to transfer it to real hardware. There are several ways to do this, which
    we’ll examine here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设计并简化了数字逻辑网络，通常你会希望将其转移到实际硬件上。这里有几种方法，我们将在接下来的部分进行讨论。
- en: '*7400 Chips*'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7400芯片*'
- en: 'One way to implement a simple logic network has remained unchanged since the
    1960s: lay it out across a bunch of 7400 chips and connect them together with
    a rat’s nest of wires.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个简单逻辑网络的方法自1960年代以来一直没有变化：将它布置在一堆7400芯片上，并用一堆乱七八糟的电线将它们连接起来。
- en: As you saw earlier, each 7400 series chip contains a number of gates, usually
    all of the same type. Unfortunately, a single chip doesn’t usually correspond
    to any particular topological region of your circuit. You need to consider each
    gate in your circuit and choose a specific gate on a specific chip to instantiate
    it. You can choose what goes where completely arbitrarily and your circuit will
    still work, but if you apply a bit of cleverness to the layout you’ll be able
    to considerably reduce the length of wire needed to connect it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所见，每个7400系列芯片包含多个门电路，通常都是相同类型的。不幸的是，单个芯片通常并不对应电路中的某个特定拓扑区域。你需要考虑电路中的每个门电路，并选择一个特定芯片上的特定门电路来实例化它。你可以完全任意地选择各个元件的位置，电路仍然可以正常工作，但如果你在布局中应用一些巧妙的方法，你将能够显著减少连接所需的电线长度。
- en: 'For example, suppose you want to build the network shown on the upper left
    of [Figure 5-16](ch05.xhtml#ch05fig16) and you have two TTL chips available in
    your electronics drawer: one containing four XORs and one containing four NANDs.
    The upper right of [Figure 5-16](ch05.xhtml#ch05fig16) shows the result of using
    Boolean logic to convert the network to use the available gates, and the lower
    part of the figure shows one possible way to lay this out across the two TTL chips.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想构建[图5-16](ch05.xhtml#ch05fig16)左上角所示的网络，并且你有两个TTL芯片可用：一个包含四个XOR门，另一个包含四个NAND门。[图5-16](ch05.xhtml#ch05fig16)右上角展示了使用布尔逻辑将网络转换为使用可用门电路的结果，图的下部则显示了如何将其布置到两个TTL芯片上的一种可能方式。
- en: You can buy the TTL chips, plus a breadboard, switches, LEDs, 9 V battery, and
    resistors to drop the battery down to the 5 V used by the TTL chips (plus a resistor
    for each LED to prevent them exploding), and wire them up as in [Figure 5-17](ch05.xhtml#ch05fig17)
    to implement your design.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以购买TTL芯片，再加上面包板、开关、LED、9V电池以及电阻来将电池降至TTL芯片使用的5V（每个LED还需要一个电阻以防止它们爆炸），并按照[图5-17](ch05.xhtml#ch05fig17)中的示意图连接它们，来实现你的设计。
- en: '![Image](../images/f0129-01.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0129-01.jpg)'
- en: '*Figure 5-16: A plan for converting a network to NANDs and laying it out using
    TTL chips*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-16：将网络转换为NAND门并使用TTL芯片布置的方案*'
- en: It’s possible to build a whole CPU from TTL chips in this way, and indeed this
    is how many early CPUs were built.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你确实可以通过这种方式用TTL芯片构建整个CPU，事实上，许多早期的CPU就是通过这种方式构建的。
- en: '![Image](../images/f0129-02.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0129-02.jpg)'
- en: '*Figure 5-17: The TTL plan laid out on a breadboard (using Fritzing)*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-17：使用面包板布置的TTL方案（使用Fritzing）*'
- en: '**NOTE**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The “bit of cleverness” required to optimize the wiring will very quickly
    grow in size as you try to do it for larger circuits. Similar cleverness is needed
    to optimize the physical layouts for the other hardware methods we’ll discuss
    next. Designing algorithms to do this automatically and at scale is a major area
    of computer science and is heavily used, researched, and developed by chip companies.*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*“巧妙”的布线优化方法在你尝试为更大电路进行优化时，所需的技巧会迅速增加规模。类似的巧妙方法也适用于优化我们接下来要讨论的其他硬件方法的物理布局。设计自动化且大规模执行这些任务的算法是计算机科学的一个主要领域，并且被芯片公司广泛使用、研究和开发。*'
- en: '*Photolithography*'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*光刻技术*'
- en: The ASIC process described in [Chapter 4](ch04.xhtml) is the most heavyweight
    method for implementing digital logic networks, costing $5 million to make a mask
    set. Here, masks are prepared containing the transistor layouts needed to form
    the logic gates. This process gives the smallest, fastest hardware, but it’s economical
    only at large scales to justify the setup costs.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml)中描述的ASIC工艺是实现数字逻辑网络的最重型方法，制作掩模集的成本为500万美元。在这里，准备了包含形成逻辑门所需晶体管布局的掩模。该工艺提供了最小、最快的硬件，但只有在大规模生产时，才能通过其设定成本来证明其经济性。
- en: '*Programmable Logic Arrays*'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*可编程逻辑阵列*'
- en: A *programmable logic array (PLA)* is a chip with many inputs and many outputs,
    made with photolithography, such that every input and every input’s negation are
    connected to a series of AND and OR gates by fuses. [Figure 5-18](ch05.xhtml#ch05fig18)
    shows a small example of a PLA structure. The plane in the figure is stacked multiple
    times, with each layer sharing the same AND and OR gates. The circles are fuses.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*可编程逻辑阵列（PLA）* 是一种芯片，具有多个输入和多个输出，通过光刻技术制造，使得每个输入和每个输入的反向信号都通过保险丝与一系列与门和或门相连。[图
    5-18](ch05.xhtml#ch05fig18)展示了一个小型PLA结构的例子。图中的平面被多次叠加，每层共享相同的与门和或门。圆圈表示保险丝。'
- en: '![Image](../images/f0130-01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0130-01.jpg)'
- en: '*Figure 5-18: A PLA schematic showing the interconnectivity of inputs and outputs*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-18：展示输入和输出互联性的PLA原理图*'
- en: Beginning with this structure, you can make any Boolean logic function by blowing
    out some subset of the fuses to effectively remove those wires. If you have a
    big enough PLA, you can take any digital logic design, perform some Boolean logic
    transformations to get it into the best form, then “burn” it into the PLA by blowing
    the fuses. This is nice because instead of having to custom-design your chip and
    spend $5 million on making a set of photolithography masks, only one set of masks
    is ever needed—the one to make the generic PLAs. You can then buy generic PLAs
    from a mass-producer and turn them into your own chips.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个结构开始，你可以通过断开某些保险丝来制作任何布尔逻辑功能，从而有效地移除那些连接。如果你有一个足够大的PLA，你可以将任何数字逻辑设计进行一些布尔逻辑变换，以使其达到最佳形式，然后通过熔断保险丝将其“烧录”到PLA中。这是很好的，因为你不需要定制设计你的芯片，也不需要花费500万美元去制作一套光刻掩模，只需要一套掩模——用于制作通用的PLA。然后你可以从大规模生产商那里购买通用PLA，并将它们转化为自己的芯片。
- en: '*Field Programmable Gate Arrays*'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*现场可编程门阵列*'
- en: A *field programmable gate array (FPGA)* is similar to a PLA, but you can rewrite
    it whenever you like with new digital logic rather than only being able to burn
    it once. This is because rather than physically blowing fuses, FPGAs operate by
    electronically switching on and off connections between blocks of standard logic.
    Each of these blocks can be configured to act as some small simple machine. [Figure
    5-19](ch05.xhtml#ch05fig19) shows an example of this design.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*现场可编程门阵列（FPGA）* 类似于PLA，但你可以随时用新的数字逻辑重写它，而不仅仅是一次性烧录。这是因为，FPGA并不是通过物理熔断保险丝来实现，而是通过电子方式切换标准逻辑块之间的连接开关。每个逻辑块都可以配置成某种小型的简单机器。[图
    5-19](ch05.xhtml#ch05fig19)展示了这种设计的例子。'
- en: '![Image](../images/f0131-01.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0131-01.jpg)'
- en: '*Figure 5-19: The structure of an FPGA chip, made from configurable blocks
    and connections between them*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-19：由可配置模块和它们之间的连接构成的FPGA芯片结构*'
- en: Boolean logic is again used to transform any initial digital logic design into
    a collection of such simple machines and connections between them. This is almost
    a software approach, with a list of the connections to enable and disable sent
    to some firmware memory on the FPGA board, then used to make the electronic configurations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔逻辑再次被用来将任何初始的数字逻辑设计转化为一系列简单的机器及其之间的连接。这几乎是一种软件方法，通过向FPGA板上的固件内存发送启用和禁用的连接列表，然后用这些连接来配置电子结构。
- en: 'FPGAs are often sold on a development board with extra hardware around the
    FPGA chip to help connect it to a PC and program it. You can buy cheap, maker-friendly
    consumer FPGA boards starting at around $30\. There are two main manufacturers
    of FPGAs: Xilinx and Altera (the former is now part of AMD; the latter is now
    part of Intel). Alternatively, FPGAs intended for use in production can be obtained
    without any supporting structure, in which case an external programmer machine
    is needed. FPGAs come in a variety of sizes; the larger of these chips are used
    for prototyping CPU designs before more expensive ASIC photolithography, while
    the smaller ones are intended for embedded systems.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: FPGAs通常以开发板的形式出售，FPGA芯片周围有额外的硬件，用来帮助将其连接到PC并进行编程。你可以购买便宜的、适合创客的消费级FPGA开发板，价格大约从$30起。有两家主要的FPGA制造商：Xilinx和Altera（前者现在是AMD的一部分；后者现在是Intel的一部分）。另外，面向生产用途的FPGA可以在没有任何支持结构的情况下购买，这时需要一个外部编程器。FPGAs有多种尺寸；其中较大的芯片用于在进行更昂贵的ASIC光刻之前对CPU设计进行原型验证，而较小的芯片则用于嵌入式系统。
- en: '[Figure 5-20](ch05.xhtml#ch05fig20) shows a typical example layout of some
    digital logic on a physical FPGA surface, and the development board used to place
    it there.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-20](ch05.xhtml#ch05fig20) 展示了在物理 FPGA 表面上某些数字逻辑的典型布局，以及用于将其放置在该位置的开发板。'
- en: '![Image](../images/f0132-01.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0132-01.jpg)'
- en: '*Figure 5-20: A display of the logic configuration inside an FPGA (left) and
    an FPGA (the large, central chip) on its development board (right)*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-20：显示 FPGA 内部逻辑配置（左）和 FPGA（中央的大芯片）在其开发板上的位置（右）*'
- en: When humans lay out digital logic manually, they tend to organize it spatially
    so that different regions correspond to different structures. Automated layouts,
    as seen inside the FPGA, tend to be visually unstructured and thus hard or impossible
    for humans to understand.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当人类手动布置数字逻辑时，他们倾向于通过空间布局组织它，使得不同的区域对应不同的结构。而 FPGA 内部看到的自动布局通常视觉上没有结构，因此对于人类来说，往往难以理解甚至不可能理解。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'Logic gates are abstractions: they’re one way to organize small groups of switches,
    such as transistors, into functional units. Human designers like to think at this
    level rather than at the level of switches, so they design circuits using logic
    gates. Each logic gate is then “compiled” into small groups of switches. (A few
    professional chip designers really can “see” the logic gates on the silicon. They
    get so used to looking at the standard patterns of transistors created by the
    gates that these patterns jump out in their perception. But for the rest of us,
    we see only the transistors.)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑门是抽象概念：它们是将小组开关（如晶体管）组织成功能单元的一种方式。人类设计师倾向于在这一层次上思考，而不是在开关层次上，因此他们使用逻辑门设计电路。每个逻辑门随后被“编译”成小组的开关。（一些专业的芯片设计师确实能“看到”硅片上的逻辑门。他们已经习惯于观察由逻辑门创建的标准晶体管模式，这些模式在他们的感知中会自动跳出来。但对我们大多数人来说，我们只能看到晶体管。）
- en: Unlike simple switches, logic gates have the key property that their output
    preserves the same representation as their input. For example, transistor-based
    logic gates don’t produce lower voltages on their outputs than they receive as
    input. This means they can be combined into complex logic networks.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与简单开关不同，逻辑门具有一个关键特性，即它们的输出保持与输入相同的表示。例如，基于晶体管的逻辑门不会在其输出端产生比输入端更低的电压。这意味着它们可以组合成复杂的逻辑网络。
- en: Claude Shannon showed us that we can use George Boole’s algebra to simplify
    circuits of logic gates, often reducing the number of gates needed, and replacing
    all other types of gates with only NAND gates. This reduces the number of transistors
    that we need to fit onto silicon and simplifies the design.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 克劳德·香农向我们展示了我们可以使用乔治·布尔的代数来简化逻辑门电路，通常减少所需的门数量，并将所有其他类型的门替换为仅使用 NAND 门。这减少了我们需要在硅片上放置的晶体管数量，并简化了设计。
- en: Exercises
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Universal Gates**'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通用门**'
- en: Work out the truth tables for each of the NAND gate–based circuits in [Figure
    5-8](ch05.xhtml#ch05fig8), or otherwise convince yourself that they are equivalent
    to the standard NOT, AND, and OR gates.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 [图 5-8](ch05.xhtml#ch05fig8) 中每个基于 NAND 门的电路的真值表，或者以其他方式证明它们与标准的 NOT、AND
    和 OR 门等效。
- en: '**Setting up LogiSim Evolution**'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**设置 LogiSim Evolution**'
- en: LogiSim Evolution is a graphical digital logic simulator. It was used to create
    the digital logic circuit figures in this book. It can simulate circuits that
    you design, and later also transfer them onto real chips.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: LogiSim Evolution 是一款图形化数字逻辑模拟器。它被用来创建本书中的数字逻辑电路图。它可以模拟你设计的电路，并且稍后将这些电路转移到真实的芯片上。
- en: Install and run LogiSim Evolution from *[https://github.com/logisim-evolution/logisim-evolution](https://github.com/logisim-evolution/logisim-evolution)*.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *[https://github.com/logisim-evolution/logisim-evolution](https://github.com/logisim-evolution/logisim-evolution)*
    安装并运行 LogiSim Evolution。
- en: Create a project and play around to create some gates and wires connecting them.
    Components are connected by clicking the output of one and then the input of another.
    Activate a component or wire by clicking it. Delete components with the DEL key
    and the latest wire with ESC. Press the Simulation button to run the simulation.
    Voltages on the wires are shown as black for 0 and red for 1\. Some components
    can be right-clicked to edit their properties.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个项目，尝试创建一些门并连接它们。组件通过点击一个门的输出然后连接到另一个门的输入来连接。点击组件或电线来激活它。使用 DEL 键删除组件，使用
    ESC 删除最新的电线。点击仿真按钮运行仿真。电线上的电压以黑色表示 0，红色表示 1。一些组件可以通过右键点击来编辑其属性。
- en: Use constant inputs and LED outputs to build and test the circuits in [Figure
    5-14](ch05.xhtml#ch05fig14).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用常量输入和LED输出构建并测试[图5-14](ch05.xhtml#ch05fig14)中的电路。
- en: '**Simplifying Circuits**'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**简化电路**'
- en: In LogiSim, use only NAND gates to build each of the other gate types.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在LogiSim中，仅使用NAND门来构建其他所有类型的门。
- en: Use model checking or proof to show why the circuits in the section “Simplifying
    Logic Circuits Using Boolean Logic” are all equivalent. How would you find the
    forms on the right of the figures from those on the left? Is there an algorithm
    guaranteed to give the minimal NAND form?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模型检测或证明来展示“使用布尔逻辑简化逻辑电路”一节中的电路为何是等效的。你如何从左侧的形式找到右侧的形式？是否存在一种算法能够保证得到最小的NAND形式？
- en: Calculate the truth table for a Boolean function such as *W*(*YZ* + *XY*) and
    check it by building and simulating an equivalent circuit in LogiSim.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算布尔函数如 *W*(*YZ* + *XY*) 的真值表，并通过在LogiSim中构建并模拟等效电路来检查。
- en: Use Boolean identities to simplify the function from the previous problem, and
    build a new LogiSim circuit of the simplified version. Simulate it to check that
    the truth table remains the same.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用布尔恒等式简化前一个问题中的函数，并构建简化版本的新LogiSim电路。通过模拟检查真值表是否保持不变。
- en: Further Reading
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入阅读
- en: To learn about Boole’s logic (and theology) straight from the source, see George
    Boole, *The Laws of Thought* (1854), *[https://www.gutenberg.org/ebooks/15114](https://www.gutenberg.org/ebooks/15114)*.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要直接了解布尔逻辑（以及神学），请参见George Boole的《思想法则》（1854年），* [https://www.gutenberg.org/ebooks/15114](https://www.gutenberg.org/ebooks/15114)*。
- en: For arguably the greatest master’s thesis of all time, see Claude Shannon, “A
    Symbolic Analysis of Relay and Switching Circuits” (master’s thesis, MIT, 1940),
    *[https://dspace.mit.edu/handle/1721.1/11173#files-area](https://dspace.mit.edu/handle/1721.1/11173#files-area)*.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可能是有史以来最伟大的硕士论文，请参见Claude Shannon的《继电器和开关电路的符号分析》（硕士论文，麻省理工学院，1940年），* [https://dspace.mit.edu/handle/1721.1/11173#files-area](https://dspace.mit.edu/handle/1721.1/11173#files-area)*。
