- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: CLIPS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: CLIPS
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: 'Back in the 1980s and 1990s, there was a hot new topic in artificial intelligence:
    *expert systems*, that is, programs that attempt to capture the knowledge of human
    experts in a particular domain in the form of rules, particularly `if-then` rules.
    In 1985, NASA developed CLIPS (“C Language Integrated Production System”) to create
    expert systems. CLIPS has been developed and maintained since then, becoming public
    domain software in 1996.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代和1990年代，人工智能领域有一个热门话题：*专家系统*，即尝试通过规则，特别是 `if-then` 规则，来捕捉特定领域内人类专家的知识的程序。1985年，NASA开发了CLIPS（“C语言集成生产系统”）来创建专家系统。自那时起，CLIPS一直在开发和维护，并于1996年成为公共领域软件。
- en: 'In this chapter, we’ll use CLIPS to get a feel for what an expert system is
    and how to create one, at least a primitive one. We’ll introduce CLIPS, and with
    it, the concepts behind expert systems. Then we’ll explore the language through
    a series of four examples: a calculator, a second look at the family relationships
    we explored with Prolog in [Chapter 1](ch01.xhtml#ch01), a simple factory simulation,
    and a complete expert system for the classification of iris flowers. We’ll end
    the chapter with a brief discussion of CLIPS as an atypical programming language.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用CLIPS来感受什么是专家系统，以及如何创建一个专家系统，至少是一个原始的版本。我们将介绍CLIPS，并借此了解专家系统背后的概念。接着，我们将通过四个示例探索这一语言：一个计算器、一个回顾我们在[第1章](ch01.xhtml#ch01)中用Prolog探讨的家庭关系、一个简单的工厂模拟、以及一个完整的用于鸢尾花分类的专家系统。最后，我们将简要讨论CLIPS作为一种非典型编程语言。
- en: '**Installation**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装**'
- en: Installing CLIPS is similar to installing SNOBOL. First, we need the tarball,
    *clips_core_source_631.tar.gz*, which we download from *[https://sourceforge.net/projects/clipsrules/files/CLIPS/6.31/](https://sourceforge.net/projects/clipsrules/files/CLIPS/6.31/)*.
    Example files are in *examples_631.tar.gz*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 安装CLIPS类似于安装SNOBOL。首先，我们需要tarball文件，*clips_core_source_631.tar.gz*，我们从 *[https://sourceforge.net/projects/clipsrules/files/CLIPS/6.31/](https://sourceforge.net/projects/clipsrules/files/CLIPS/6.31/)*
    下载。示例文件位于 *examples_631.tar.gz* 中。
- en: Expand the archive and build CLIPS.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 解压归档文件并构建CLIPS。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, run CLIPS to make sure it works.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行CLIPS以确保其正常工作。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the expression `(1+2)*3` becomes `(* (+ 1 2) 3)`. CLIPS, like Lisp,
    uses *S-expressions*, which are lists of items surrounded by parentheses. S-expressions
    are often nested, as in the example here, where the S-expression `(+ 1 2)` is
    nested inside the outer expression beginning with `*`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表达式 `(1+2)*3` 变成了 `(* (+ 1 2) 3)`。CLIPS像Lisp一样使用 *S表达式*，它们是由圆括号包围的项的列表。S表达式通常是嵌套的，正如这里的例子所示，其中S表达式
    `(+ 1 2)` 嵌套在以 `*` 开头的外部表达式中。
- en: The main CLIPS site is at *[http://www.clipsrules.net/](http://www.clipsrules.net/)*.
    You can download the CLIPS 6.31 documentation from there, though we’ll introduce
    the essential elements of the system as we use it. If you see a version later
    than 6.31, go ahead and use it. The probability of CLIPS changing to the point
    where our examples no longer work is extremely low.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CLIPS的主站点在 *[http://www.clipsrules.net/](http://www.clipsrules.net/)*。你可以从那里下载CLIPS
    6.31的文档，尽管我们将在使用过程中介绍系统的基本要素。如果你看到比6.31更高版本，可以直接使用。CLIPS发生变化，导致我们的示例不再适用的可能性极低。
- en: '**Origins and Philosophy**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**起源与哲学**'
- en: To understand CLIPS, we must first better understand what an expert system is.
    Expert systems were popular in the 1980s, and it was hoped then that they would
    prove helpful as a more general approach to artificial intelligence. We’ll discuss
    whether this hope was realized later in the chapter, but for now, note that the
    large-scale application of expert systems never happened.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解CLIPS，我们必须先更好地理解什么是专家系统。专家系统在1980年代非常流行，当时人们希望它们能作为一种更通用的人工智能方法发挥作用。我们将在本章后面讨论这种期望是否得以实现，但现在要注意，专家系统的大规模应用从未发生过。
- en: An *expert system* is a computer program capable of inferring conclusions from
    a set of rules and facts. The rules are intended to capture the knowledge of a
    human expert in a specific domain, thereby allowing the software to perform similarly
    depending on the facts available. This is an abstract definition, and there is
    certainly room for other nuanced statements related to what an expert system is,
    but you’ll appreciate what an expert system is as we explore CLIPS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*专家系统* 是一种能够根据一组规则和事实推理得出结论的计算机程序。这些规则旨在捕捉特定领域内人类专家的知识，从而使软件能够根据可用的事实进行类似的推理。这是一个抽象的定义，关于什么是专家系统，肯定还有其他细致的说法，但随着我们探索CLIPS，你会更好地理解专家系统的含义。'
- en: 'An expert system is a collection of facts, rules (a knowledge base), and an
    inference engine to use those facts and rules to reach conclusions. Expert systems
    use facts and rules to determine behavior. For example, an expert system monitoring
    a building might have a rule like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 专家系统是一个由事实、规则（知识库）和推理引擎组成的系统，用于根据这些事实和规则得出结论。专家系统通过使用事实和规则来确定行为。例如，一个监控建筑物的专家系统可能包含如下规则：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `door-is-open`, `time-is-after-midnight`, and `signal-the-police` are
    all facts. Note that the last fact is one that the rule puts into the knowledge
    base when the rule fires. In other words, the rule *asserts* the fact, which later
    might cause another rule to fire.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`door-is-open`、`time-is-after-midnight` 和 `signal-the-police` 都是事实。请注意，最后一个事实是规则在触发时将其添加到知识库中的。换句话说，规则
    *断言* 了这个事实，这个事实稍后可能会导致另一条规则被触发。
- en: In CLIPS this might be written as
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CLIPS 中，这可能被写作：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll get to the exact syntax of a CLIPS rule in a bit, but even now, we can
    start to see what is going on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会讨论 CLIPS 规则的确切语法，但即使现在，我们也可以开始理解其中发生的事情。
- en: Put enough of these rules together and you have a system embodying a tiny knowledge
    domain. In other words, the system is an expert in that tiny domain. At least,
    that’s the hope.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将足够多的这些规则组合在一起，你就拥有了一个体现微小知识领域的系统。换句话说，系统是该小领域的专家。至少，这是我们的期望。
- en: Viewed this way, an expert system might be thought of as a glorified set of
    `if-then` statements. And in a way, it is, but much can happen in the `then` part,
    thereby enabling the system to respond in a sophisticated manner, provided the
    developer captured the essential knowledge of the domain expert and properly arranged
    that knowledge in the form of rules firing in response to a particular set of
    facts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，专家系统可以被看作是一个复杂的 `if-then` 语句集。某种程度上，它确实如此，但在 `then` 部分可以发生许多事情，从而使得系统能够以一种复杂的方式做出反应，前提是开发者已经捕捉了领域专家的核心知识，并将这些知识以规则的形式组织好，以便在特定事实集出现时触发。
- en: Expert systems rely on forward chaining. This is in contrast to a language like
    Prolog, which uses backward chaining. *Forward chaining* systems process the data
    embodied in the facts they know to find valid conclusions. In contrast, *backward
    chaining* systems work from the goal to find true statements that support the
    goal.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 专家系统依赖于前向链式推理。这与像 Prolog 这样的语言形成对比，后者使用反向链式推理。*前向链式* 系统处理它们所知道的事实中体现的数据，以找到有效的结论。与此相对，*反向链式*
    系统则从目标出发，寻找支持该目标的真实陈述。
- en: A forward chaining system explores all known facts to select rules to evaluate,
    or *fire*. A system like CLIPS places rules to fire on an *agenda* and then uses
    *conflict resolution* to select which specific rule to fire. Firing a rule may
    update the set of known facts, causing other rules to fire, in which case, CLIPS
    continues to run until the agenda is empty or until it is explicitly told to stop.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前向链式系统会探索所有已知的事实，以选择需要评估或 *触发* 的规则。像 CLIPS 这样的系统将规则放置在 *议程* 上，然后通过 *冲突解决* 机制来选择具体的规则进行触发。触发规则可能会更新已知事实的集合，从而导致其他规则被触发，在这种情况下，CLIPS
    会继续运行，直到议程为空，或者明确告诉它停止。
- en: Internally, CLIPS uses the *Rete algorithm* to perform inference, that is, to
    find conclusions by applying a set of rules to a collection of facts. Unlike the
    other programming languages we’ve explored (except Prolog), CLIPS incorporates
    advanced concepts in its inference engine that are worth digging into if you are
    curious; however, these concepts are well beyond what we intend to explore here.
    Our concern is the language and how to think in terms of it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，CLIPS 使用 *Rete 算法* 来执行推理，也就是通过将一组规则应用于一系列事实来得出结论。与我们之前探讨过的其他编程语言不同（除了 Prolog），CLIPS
    在其推理引擎中融入了先进的概念，如果你感兴趣，值得深入研究；然而，这些概念远远超出了我们在这里打算探讨的范围。我们的关注点是语言本身以及如何从语言的角度思考问题。
- en: As you saw earlier, syntactically, CLIPS looks like Lisp, using S-expressions,
    or prefix notation, where *f* (*x*, *y*) becomes (*f* *x* *y*) so the function
    moves inside the parentheses.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从语法上讲，CLIPS 看起来像 Lisp，使用 S 表达式，或前缀表示法，其中 *f* (*x*, *y*) 变成 (*f* *x* *y*)，使得函数移动到括号内。
- en: 'CLIPS is a multiparadigm language: it is declarative at its base because of
    the inference engine and how code normally runs, but it is also procedural, with
    standard control structures, and object oriented, though we’ll completely ignore
    that aspect of the language here. CLIPS runs from the command line with its REPL,
    which is how we’ll use it; however, it’s also possible to embed it in another
    application.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CLIPS 是一种多范式语言：它在底层是声明式的，因为有推理引擎以及代码通常的运行方式，但它也具有过程式特性，拥有标准的控制结构，并且支持面向对象，尽管在这里我们将完全忽略该语言的这一方面。CLIPS
    通过命令行的 REPL 运行，这也是我们将使用的方式；不过，它也可以嵌入到其他应用程序中。
- en: Let’s see CLIPS in action and then walk through some examples to show us how
    to work with the system. Along the way, we’ll introduce different aspects of the
    language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 CLIPS 是如何工作的，然后通过一些示例帮助我们理解如何与系统进行交互。在这个过程中，我们将介绍语言的不同方面。
- en: '**The Language**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**语言**'
- en: Let’s run one of the demos that comes with CLIPS. We won’t look at the code—it’s
    beyond what we want to consider—but it will show us how to work with the system
    and serves as a nice example of how an expert system works. The example is in
    *wine.clp*. The purpose of the expert system is to recommend a wine to go with
    a dinner we are preparing. The program will ask us questions and, based on our
    responses, generate a list of recommended wines with probabilities to select a
    good pairing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个 CLIPS 附带的演示程序。我们不会查看代码——这超出了我们的讨论范围——但它将向我们展示如何与系统进行交互，并且作为一个专家系统如何工作的很好的示例。该示例位于
    *wine.clp* 文件中。专家系统的目的是根据我们正在准备的晚餐推荐一款葡萄酒。程序会向我们提出问题，根据我们的回答，生成一份带有概率的推荐葡萄酒列表，以便选择合适的搭配。
- en: '***Working with CLIPS***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与 CLIPS 一起工作***'
- en: 'A typical session with *wine.clp* looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *wine.clp* 的典型会话如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we load *wine.clp*. Not shown is CLIPS reporting the successful compilation
    of the various code components in the file. After loading, CLIPS must be reset
    before running. Resetting is necessary to configure CLIPS because it places a
    set of initial facts on the facts list. If the `(reset)` step is skipped, running
    *wine.clp* will display the `SELECTED WINES` banner and nothing more.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载 *wine.clp*。未显示的是 CLIPS 成功编译文件中各个代码组件的报告。加载后，必须重置 CLIPS 才能运行。重置是必要的，因为它会将一组初始事实放入事实列表中。如果跳过
    `(reset)` 步骤，运行 *wine.clp* 将仅显示 `SELECTED WINES` 横幅，而不会有其他内容。
- en: The wine demo asks the user a series of questions. Based on the user’s response,
    the demo provides a list of selected wines with a probability of pairing with
    the indicated meal. Reset and run the demo a second time, enter the same responses,
    and the list should be the same. CLIPS is working through a set of rules and will
    arrive at the same conclusion each time the inputs match. There is nothing stochastic,
    no randomness, to what CLIPS is doing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 酒类演示程序会向用户提出一系列问题。根据用户的回答，演示程序会提供一个包含推荐葡萄酒及其与指定菜肴搭配可能性的列表。重置并第二次运行演示程序，输入相同的回答，列表应该是相同的。CLIPS
    通过一组规则进行工作，每次输入相匹配时，它都会得出相同的结论。CLIPS 所做的没有任何随机性或随机因素。
- en: 'While the system is running, the set of facts may change and new inputs may
    be read. The agenda changes in response to rules that can fire. A `reset` configures
    CLIPS by defining the initial set of facts. For example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统运行时，事实集可能会发生变化，并且可能会读取新的输入。议程会根据可以触发的规则发生变化。`reset` 通过定义初始事实集来配置 CLIPS。例如：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we tell CLIPS to run the wine program without issuing a `(reset)` first.
    The header is shown, nothing more. Asking for the current set of facts returns
    only the default initial fact (`f-0`). Asking for the agenda returns nothing as
    the agenda is empty. When the agenda is empty, CLIPS stops. We then reset CLIPS
    and ask for the facts a second time. Now we see the initial set of facts defined
    by *wine.clp*. We don’t need to understand the structure right now, only see that
    the list of facts has been configured. Asking for the agenda now shows one activation,
    `start`. An activated rule is one where the conditions have been met. The wine
    demo is now ready. When we call `run`, the `start` rule will become active.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 CLIPS 运行葡萄酒程序，但不首先执行 `(reset)`。显示的是标题，除此之外没有其他内容。请求当前的事实集只会返回默认的初始事实（`f-0`）。请求议程返回空，因为议程是空的。当议程为空时，CLIPS
    停止。然后我们重置 CLIPS 并第二次请求事实。现在我们看到了由 *wine.clp* 定义的初始事实集。我们现在不需要理解其结构，只需看到事实列表已经被配置。现在请求议程时，显示了一个激活项，`start`。一个已激活的规则是指其条件已经满足的规则。葡萄酒演示程序现在已经准备好。当我们调用
    `run` 时，`start` 规则将变为激活状态。
- en: '***Implementing Hello World***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现 Hello World***'
- en: Let’s implement our old friend, “Hello, world!” We’ll write two versions. The
    first uses the inference engine by defining a rule that always fires. The second
    is purely procedural, proving that CLIPS does support imperative programming.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现经典的“Hello, world!”程序。我们将编写两个版本。第一个通过定义一个总是触发的规则来使用推理引擎。第二个则完全是过程式的，证明 CLIPS
    也支持命令式编程。
- en: The file *hello0.clp* contains
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *hello0.clp* 包含：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ll detail the syntax of `defrule` in the next section. For now, know that
    it defines a rule named `hello`. The portion of a rule after the arrow (`=>`)
    is the part that runs, which is the `then` portion. There is nothing to the left
    of the arrow because this rule always fires or fires if `initial-fact`, `f-0`
    above, is defined, which it is by default.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中详细介绍 `defrule` 的语法。目前，你只需知道它定义了一个名为 `hello` 的规则。规则箭头（`=>`）右侧的部分是执行部分，也就是
    `then` 部分。箭头左侧没有内容，因为这个规则总是触发，或者在 `initial-fact`（上面的 `f-0`）定义时触发，而它默认是定义的。
- en: 'To execute the rule we need only use `(run)` as there is nothing to configure
    regarding other facts and the agenda. Running the program looks like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行规则，我们只需要使用 `(run)`，因为无需配置其他事实和议程。运行程序的过程如下所示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Excellent; our rule fired. However, you might have a question. If the rule `hello`
    is set to fire when `initial-fact` is present, which it always is, why doesn’t
    CLIPS print “Hello, world!” forever? There is nothing removing the initial fact,
    so it’s still present. Why doesn’t the rule match again and again? This is because
    CLIPS fires a rule only once for each set of matching conditions. This is known
    as *refraction* (this term is borrowed from neuroscience, where it is related
    to the time delay after a neuron fires before it can fire again).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们的规则触发了。然而，你可能有一个问题。如果规则 `hello` 被设置为在 `initial-fact` 存在时触发，而 `initial-fact`
    总是存在，为什么 CLIPS 不会一直打印“Hello, world!”？因为没有去除初始事实，所以它仍然存在。为什么规则没有一次又一次地匹配呢？这是因为
    CLIPS 每次匹配条件时只触发一次规则。这种现象称为 *折射*（这一术语来源于神经科学，指的是神经元触发后需要一定的时间才能再次触发）。
- en: 'The file *hello0.clp* defined a rule and used CLIPS’s inference engine to fire
    it. CLIPS allows imperative programming as well. The file *hello1.clp* contains
    the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *hello0.clp* 定义了一个规则，并使用 CLIPS 的推理引擎来触发它。CLIPS 同样支持命令式编程。文件 *hello1.clp*
    包含以下内容：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can run this from the command line as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式从命令行运行：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Use `-f` or `-f2` to execute a program from the command line. The second option
    (`-f2`) disables load messages. Calling `(exit)` keeps the program from showing
    the `CLIPS>` prompt after running. The file *hello1.clp* uses `deffunction` to
    define a function named `hello` that is then called before exiting to print the
    message. The `t` after `printout` specifies the output file—in this case the terminal.
    CLIPS’s support for imperative programming covers all the expected control structures
    like `if-then` and `while`. We won’t discuss those elements here, but do consult
    the CLIPS documentation to learn about them. A good place for control structures
    is in the action part of a rule.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-f` 或 `-f2` 可以从命令行执行程序。第二个选项（`-f2`）禁用加载消息。调用 `(exit)` 可以在运行后避免显示 `CLIPS>`
    提示符。文件 *hello1.clp* 使用 `deffunction` 定义了一个名为 `hello` 的函数，在退出之前调用该函数来打印消息。`printout`
    后面的 `t` 指定了输出文件——在这种情况下是终端。CLIPS 对命令式编程的支持涵盖了所有预期的控制结构，如 `if-then` 和 `while`。我们在这里不讨论这些元素，但可以参考
    CLIPS 文档了解更多。控制结构的理想位置是在规则的动作部分。
- en: CLIPS manipulates facts with rules and input. The rules, when active, affect
    the agenda, and it is the agenda that drives a CLIPS program. Let’s learn more
    about facts and rules.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CLIPS 通过规则和输入来处理事实。当规则被激活时，它们会影响议程，而正是议程驱动着 CLIPS 程序。让我们深入了解事实和规则。
- en: '***Facts and Rules***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***事实和规则***'
- en: You’ve already seen a bit about facts and rules, but to understand the examples
    that follow, we’ll need a more thorough understanding. Let’s dive in.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了一些事实和规则的内容，但为了理解接下来的示例，我们需要更深入的理解。让我们深入探讨。
- en: '**Facts**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**事实**'
- en: '*Facts* are asserted (`assert`) and retracted (`retract`) as needed when rules
    fire. Simple facts are straightforward to add. For example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*事实* 在规则触发时根据需要被声明（`assert`）和撤销（`retract`）。简单事实很容易添加。例如：'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Three facts are asserted. The first might indicate to a running system managing
    a car that the emergency brake is on. The other two are the symbols `roses-are`
    and `violets-are` along with symbols for colors. Equivalent to an atom in Prolog,
    a *symbol* in CLIPS is a set of characters that represents itself, unlike a variable,
    which is a name given to a value. A symbol has no value. A set of facts may be
    defined at one time with `deffacts`. Facts defined this way are put on the facts
    list when `(reset)` is executed. Consider the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 三个事实被声明。第一个可能指示一个运行中的系统正在管理一辆车，表示紧急刹车已被激活。另两个则是`roses-are`和`violets-are`符号，以及与颜色相关的符号。在
    CLIPS 中，相当于 Prolog 中的原子，*符号*是一组代表自身的字符，与变量不同，变量是赋予值的名称。符号没有值。一组事实可以通过`deffacts`一次性定义。通过这种方式定义的事实将在执行`(reset)`时被放入事实列表中。考虑以下例子：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, CLIPS has only the initial fact at first. Then, a `deffacts`
    statement named `arthropods` defines a set of facts. There are three facts defined,
    each a type of arthropod followed by the number of legs. (Of course, some arthropod
    enthusiasts may object that trilobites vary in the number of legs, but 48 isn’t
    a bad guess.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，CLIPS 最初只有一个初始事实。然后，一个名为`arthropods`的`deffacts`语句定义了一组事实。定义了三个事实，每个事实是某种类型的节肢动物，后面跟着它的腿数。（当然，一些节肢动物爱好者可能会反对三叶虫的腿数不固定，但48条腿也不是一个差的猜测。）
- en: The next line uses `(facts)`, but our newly declared facts are not present.
    When `assert` was used above, the facts appeared immediately. However, with `deffacts`,
    we must use `(reset)` first and then the facts appear. Any previously defined
    facts are lost as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行使用了`(facts)`，但我们新声明的事实并不存在。当上面使用`assert`时，事实立即出现。然而，使用`deffacts`时，我们必须先使用`(reset)`，然后事实才会出现。之前定义的任何事实也会丢失。
- en: 'Complex facts have many parts, some of which may be updated as CLIPS runs.
    CLIPS provides a mechanism for defining complex facts. For example, the file *coin.clp*
    defines a fact template for ancient Roman coins along with facts related to specific
    Roman coins:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂事实有很多部分，其中一些部分可能会在 CLIPS 运行时被更新。CLIPS 提供了一种定义复杂事实的机制。例如，文件*coin.clp*定义了一个关于古罗马硬币的事实模板，并包含与特定罗马硬币相关的事实：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, `deftemplate` defines a fact template named `roman-coin` with an optional
    comment string. The fields of a fact are called *slots*. The template defines
    four fields: `emperor`, `denomination`, `obverse`, and `reverse`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`deftemplate`定义了一个名为`roman-coin`的事实模板，并可附带一个可选的注释字符串。事实的字段称为*槽*。该模板定义了四个字段：`emperor`、`denomination`、`obverse`和`reverse`。
- en: With `roman-coin` defined, we can then assert some facts about specific coins
    using `deffacts`. The first relates to a silver denarius of the first-century
    emperor Otho, one of the “Twelve Caesars” who ruled from January 15 to April 16
    in the year 69\. A denarius was the usual day’s wage for a Roman soldier. The
    second coin is a small bronze coin, loose change of the time, minted by Constantine
    the Great around the year 325.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`roman-coin`之后，我们可以使用`deffacts`来断言一些特定硬币的事实。第一个涉及的是公元一世纪的皇帝奥图（Otho）的银德纳里乌斯硬币，他是“十二凯撒”之一，统治时间为公元69年1月15日至4月16日。德纳里乌斯是罗马士兵的常规日薪。第二枚硬币是一枚小型铜币，是当时的零钱，约公元325年由大帝君士坦丁铸造。
- en: Let’s inform CLIPS about these coins.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些硬币信息告知 CLIPS。
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After loading *coin.clp*, we reset and look at the known facts. There are the
    new coins. During execution, CLIPS will often assert and retract facts. Here,
    we manually retract the first coin fact with `retract`, and after running `(facts)`
    again we see that it is no longer present. Notice that the fact numbers do not
    change after this. Fact `f-2` is still fact `f-2`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 加载*coin.clp*后，我们进行重置并查看已知的事实。新的硬币信息已显示。在执行过程中，CLIPS 会经常断言和撤回事实。在这里，我们通过`retract`手动撤回第一个硬币事实，运行`(facts)`后，我们看到该事实已不再存在。请注意，在此之后，事实编号没有发生变化。事实`f-2`仍然是事实`f-2`。
- en: '**Rules**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**规则**'
- en: '*Rules* are `if-then` constructs. The syntax for a rule is'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*规则*是`if-then`结构。规则的语法是'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The (<lefthand-side>), or LHS, is a set of zero or more conditions that attempt
    to match facts. The conditions are ANDed, which means that all must match for
    the rule to fire. When the rule does fire, everything on the (<righthand-side>),
    or RHS, is executed. These are the rule’s *actions*. Typically, the actions alter
    the set of facts in some way to move the program forward. However, the actions
    may also have side effects, like printing information or requesting information
    from the user (this is where CLIPS’s imperative coding abilities come into play).
    Rules with a matching LHS are placed on the agenda to execute their respective
    RHSs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (<左边>)，或称LHS，是一组零个或多个条件，用于尝试匹配事实。这些条件是通过AND操作组合的，这意味着所有条件必须匹配才能触发规则。当规则触发时，(<右边>)，或称RHS，将执行。这些是规则的*动作*。通常，动作会以某种方式改变事实集，以推动程序向前发展。然而，动作也可能有副作用，比如打印信息或请求用户输入信息（这就是CLIPS的命令式编码能力发挥作用的地方）。具有匹配LHS的规则会被放置到议程中，以执行它们各自的RHS。
- en: As rules match, they may also bind variables that are local to the rule. CLIPS
    variables follow the expected naming convention, but they must be referenced with
    a leading question mark. For example, `?x` refers to the variable `x`. Binding
    on the LHS of a rule is useful as the bound variables may be used on the RHS.
    We’ll see examples of this later in the chapter. To bind a variable directly,
    that is, to assign something to it, use the `bind` statement.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当规则匹配时，它们还可能绑定规则内局部的变量。CLIPS的变量遵循预期的命名约定，但必须以问号开头。例如，`?x`表示变量`x`。在规则的LHS上进行绑定是有用的，因为绑定的变量可能会在RHS中使用。我们将在本章稍后的部分看到这些示例。要直接绑定变量，即给它赋值，使用`bind`语句。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here’s a hypothetical rule to react to a security breach.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个假设的规则，用于响应安全漏洞。
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The rule name is `react-security-breach`. The LHS, the part before `=>`, is
    the condition that matches a fact of the form `security-breach` `<type>`, where
    the actual type is bound to `?typ`. For example, `(security-breach hacker)` would
    match the rule and bind the symbol `hacker` to the variable `?typ`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 规则名称是`react-security-breach`。LHS，即`=>`之前的部分，是匹配形如`security-breach <type>`的事实，其中实际的`type`绑定到`?typ`。例如，`(security-breach
    hacker)`将匹配该规则，并将符号`hacker`绑定到变量`?typ`。
- en: 'The LHS has a funny bit of syntax: `?r <-`. When the `security-breach` fact
    matches, it returns the fact number, which is bound to `?r`. The RHS of the rule,
    the part after `=>`, uses `?r` to `retract` the matched fact. As we are processing
    the security breach, we remove the trigger for this rule. Because of refraction,
    the rule will fire only once for the specific fact `(security-breach` `hacker)`.
    Retracting the fact removes it, so when it is asserted again, the rule will fire
    once more.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: LHS有一段有趣的语法：`?r <-`。当`security-breach`事实匹配时，它会返回事实编号，并将其绑定到`?r`。规则的RHS部分，即`=>`之后的部分，使用`?r`来`retract`匹配的事实。在我们处理安全漏洞时，我们移除了该规则的触发条件。由于反射作用，规则只会为特定事实`(security-breach
    hacker)`触发一次。撤销该事实后，它被移除，因此当它再次被断言时，规则将再次触发。
- en: The RHS of this rule asserts `(log-security-breach ?typ)` to add a new fact.
    Note the use of `?typ`, which CLIPS extracted from the LHS of the rule. Asserting
    this fact acts as a trigger for another rule that will write some information
    to a logfile or perhaps send an alert email to the IT department. The final part
    of the rule prints the alert so we can see it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则的RHS断言`(log-security-breach ?typ)`，以添加一个新的事实。注意`?typ`的使用，这是CLIPS从规则的LHS提取的。断言这个事实会触发另一个规则，后者会将一些信息写入日志文件，或者可能发送一封警报邮件给IT部门。规则的最后部分打印出警报信息，以便我们可以看到它。
- en: 'If the rule is in *security.clp*, we load and run it as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果规则位于*security.clp*中，我们可以按如下方式加载并运行它：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To trigger the rule after reset, we must assert a security breach, which in
    this case is a hacker security breach. Running it shows us the security alert
    message indicating the rule fired. If we examine the known facts, we see a new
    one, `f-2`, which is the fact asserted by our rule.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在重置后触发规则，我们必须断言一个安全漏洞，在这个例子中是黑客安全漏洞。运行该规则后，我们会看到安全警报信息，表明规则已经触发。如果我们检查已知事实，会看到一个新事实`f-2`，它是我们的规则断言的事实。
- en: CLIPS is large, powerful, and reasonably complex. Let’s spend the remainder
    of the chapter exploring selected examples to illustrate how CLIPS works, at least
    at the level we’ll use it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: CLIPS庞大、强大且相当复杂。让我们利用本章剩余的部分，通过选定的示例来展示CLIPS的工作原理，至少是我们将要使用的层面。
- en: '**CLIPS in Action**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**CLIPS实践**'
- en: To build our intuition about CLIPS, in this section we’ll walk through four
    examples. The first is an elementary calculator, just enough to get our feet wet.
    Next, we’ll revisit the Greek god family tree from [Chapter 1](ch01.xhtml#ch01)
    to see CLIPS’s take on it. Following that is a basic factory simulation, which
    illustrates how a CLIPS expert system might operate when monitoring something
    in the real world. Lastly, we’ll build an expert system for iris flowers to compare
    a rule-based classifier with the SNOBOL nearest neighbor classifier of [Chapter
    5](ch05.xhtml#ch05).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立我们对CLIPS的直觉，在本节中我们将通过四个示例进行讲解。第一个是一个基础计算器，足以让我们入门。接下来，我们将回顾[第1章](ch01.xhtml#ch01)中的希腊神话家族树，看看CLIPS如何处理它。然后是一个基础工厂模拟，展示了当监控现实世界中的某些事物时，CLIPS专家系统如何运作。最后，我们将为鸢尾花建立一个专家系统，以将基于规则的分类器与[第5章](ch05.xhtml#ch05)中的SNOBOL最近邻分类器进行比较。
- en: '***An Elementary Calculator***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个基础计算器***'
- en: This example implements a calculator. For the calculator, we need four rules.
    The first rule handles the startup message and informs the user. The next rule
    handles binary operators like plus and multiply. Next, we need a rule for unary
    operations like sine and cosine. The final rule accepts input from the user and
    asserts the operation for the binary or unary rule to act upon. The source code
    is in *math.clp*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例实现了一个计算器。对于计算器，我们需要四条规则。第一条规则处理启动信息并告知用户。接下来，第二条规则处理加法和乘法等二目运算符。然后，我们需要一条规则来处理像正弦和余弦这样的单目运算。最后一条规则接受用户输入，并断言该操作以供二目或单目规则执行。源代码在*math.clp*文件中。
- en: '[Listing 6-1](ch06.xhtml#ch06list1) contains the set of initial facts and the
    `start` rule.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单6-1](ch06.xhtml#ch06list1)包含了初始事实集和`start`规则。'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 6-1: Initializing the calculator*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-1：初始化计算器*'
- en: Here, there are two initial facts. The first is `(startup)`, and the second
    is `@ 0`. We’ll use the `@` fact to keep the result of the last operation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个初始事实。第一个是`(startup)`，第二个是`@ 0`。我们将使用`@`事实来保存上一个操作的结果。
- en: 'The LHS of the `start` rule matches `(startup)`, which is asserted when CLIPS
    is reset because of `deffacts`. This rule does three things: first, it prints
    a set of instructions for the user; second, it retracts `(startup)` so it is no
    longer in the facts list; and third, it asserts `(get-next-operation)`. We’ll
    use this fact to request input from the user.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`规则的左侧匹配`(startup)`，当因为`deffacts`重置CLIPS时，这个事实会被断言。这个规则执行三件事：首先，它打印出一组给用户的指令；其次，它撤销`(startup)`，使其不再出现在事实列表中；第三，它断言`(get-next-operation)`。我们将利用这个事实来请求用户输入。'
- en: '[Listing 6-2](ch06.xhtml#ch06list2) shows the `get-operation` rule.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单6-2](ch06.xhtml#ch06list2)展示了`get-operation`规则。'
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-2: Processing user input*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-2：处理用户输入*'
- en: The `get-operation` rule fires only when `(get-next-operation)` is in the facts
    list. As `start` places this fact on the list after it is done, the `get-operation`
    rule will fire immediately after `start` ends. As CLIPS fires rules only once,
    when matched, we retract `(get-next-operation)` so the rule will fire the next
    time it is asserted.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`get-operation`规则仅在事实列表中包含`(get-next-operation)`时才会触发。当`start`规则完成后，它会将此事实添加到事实列表中，`get-operation`规则将在`start`结束后立即触发。由于CLIPS只在规则匹配时触发一次，当规则被触发时，我们会撤销`(get-next-operation)`，以便下次它被断言时规则可以再次触发。'
- en: The remainder of `get-operation` displays a prompt of spaces and then binds
    `?expr` to the string typed by the user. After a quick check to see if the user
    entered `end`, the operation is asserted. The `explode$` function takes a string
    and splits it into a list, the elements of which become the fields of the `operation`
    fact. CLIPS refers to lists as *multifields*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`get-operation`的其余部分显示了一个空格提示，然后将`?expr`绑定到用户输入的字符串。经过简单检查，如果用户输入了`end`，操作就会被断言。`explode$`函数将一个字符串拆分成一个列表，列表的元素成为`operation`事实的字段。CLIPS将列表称为*多值字段*。'
- en: The instructions tell the user to enter expressions carefully. A unary expression
    is the function name followed by one or more spaces and an argument consisting
    of either a number or `@` to use the previous result. A binary expression is the
    first operand, spaces, operation, spaces, and second operand. When exploded, the
    `operation` fact will contain three fields if it’s a binary expression or two
    if it’s a unary expression.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令告知用户如何小心地输入表达式。单目表达式是函数名后跟一个或多个空格以及由数字或`@`（表示使用上一个结果）构成的参数。二目表达式是第一个操作数、空格、运算符、空格和第二个操作数。当被拆分时，`operation`事实将包含三个字段，如果是二目表达式，或者两个字段，如果是单目表达式。
- en: Now consider [Listing 6-3](ch06.xhtml#ch06list3), which processes unary expressions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 [清单 6-3](ch06.xhtml#ch06list3)，它处理一元表达式。
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 6-3: Processing a unary expression*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-3：处理一元表达式*'
- en: The `unary-math` rule is triggered by an `operation` fact with two fields. The
    first is the function (`?func`) and the second is the argument to the function
    (`?x`). The last result is also part of the LHS, so we can pull it from the facts
    list. Both the operation and last result are retracted, meaning they will be asserted
    again later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`unary-math` 规则通过一个包含两个字段的 `operation` 事实触发。第一个字段是函数（`?func`），第二个字段是函数的参数（`?x`）。最后的结果也是
    LHS 的一部分，因此我们可以从事实列表中提取它。操作和上一个结果都会被撤销，意味着它们会在稍后重新断言。'
- en: The rule asserts `(get-next-operation)` to fire `get-operation` again to acquire
    the next expression from the user. The remainder of the rule performs the requested
    operation. If `?x` is `@`, `?x` is updated to be the previous result (`?last`).
    The actual operation generates an output value, `?y`, which is printed and asserted
    as the new previous result, which is the `@` fact.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 规则断言 `(get-next-operation)`，触发 `get-operation` 以再次获取用户输入的下一个表达式。规则的其余部分执行请求的操作。如果
    `?x` 是 `@`，则将 `?x` 更新为上一个结果（`?last`）。实际操作会生成一个输出值 `?y`，该值被打印并作为新的上一个结果断言，也就是 `@`
    事实。
- en: Binary expressions are processed by [Listing 6-4](ch06.xhtml#ch06list4).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 二元表达式通过 [清单 6-4](ch06.xhtml#ch06list4) 处理。
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 6-4: Processing a binary expression*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-4：处理二元表达式*'
- en: This rule is substantially the same as the unary expression case, but matches
    an operation with two arguments instead of one. CLIPS knows which rule to fire,
    `unary-math` or `binary-math`, because of the number of fields in the `operation`
    fact.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则与一元表达式的情况基本相同，但它匹配的是一个有两个参数的操作，而不是一个。CLIPS 知道该触发哪个规则——`unary-math` 还是 `binary-math`，因为
    `operation` 事实中的字段数量不同。
- en: Let’s see *math.clp* in action.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 *math.clp* 的实际应用。
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: User entries are in bold, demonstrating both binary and unary expressions, most
    of which use the previous result. Note that spaces are required between operands
    and operators.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入以粗体显示，演示了二元和一元表达式，其中大多数使用了之前的结果。请注意，操作数和运算符之间需要有空格。
- en: 'This example exposes a general pattern: store information on the facts list
    and use assertions and retractions to arrange the flow of the program. The calculator
    begins with the startup message, which then asserts a fact to cause `get-operation`
    to fire, thereby acquiring and processing input from the user. In turn, that rule
    asserts the fact of the desired operation. The inference engine causes the proper
    binary or unary rule to fire to process the request. Those rules retract and reassert
    the last result, so the version in the fact list is always correct. They also
    reassert `(get-next-operation)` to acquire more input from the user. This keeps
    the program running until `(halt)` is executed.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子揭示了一个通用模式：将信息存储在事实列表中，并使用断言和撤销来安排程序的流程。计算器从启动消息开始，然后断言一个事实以触发 `get-operation`，从而获取并处理用户输入。接下来，该规则断言所需的操作事实。推理引擎会触发适当的一元或二元规则来处理请求。那些规则会撤销并重新断言上一个结果，以确保事实列表中的版本始终是正确的。它们还会重新断言
    `(get-next-operation)`，以获取更多的用户输入。这使得程序在执行 `(halt)` 之前一直运行。
- en: '***Family Redux***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***家庭重启***'
- en: In [Chapter 1](ch01.xhtml#ch01), we used Prolog to explore the sometimes unusual
    family relationships among the ancient Greek gods. Let’s revisit that example
    now to understand what CLIPS might do with the same set of facts. This example
    is in *family.clp*. Let’s walk through the code, then run it to see what manner
    of output we get.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.xhtml#ch01) 中，我们使用 Prolog 探讨了古希腊神祇之间有时异常的家庭关系。现在让我们回顾这个例子，以了解
    CLIPS 对同一组事实可能做些什么。这个例子在 *family.clp* 文件中。让我们先浏览代码，然后运行它，看看我们得到的输出是什么。
- en: '[Listing 6-5](ch06.xhtml#ch06list5) is only partial. See *family.clp* for the
    complete set of facts.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-5](ch06.xhtml#ch06list5) 只是部分内容。完整的事实集请参见 *family.clp* 文件。'
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 6-5: Some facts about the Olympians*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-5：一些关于奥林匹斯神祇的事实*'
- en: As with Prolog, we declare some gods as male and other gods as female before
    listing parent-child relationships in the form `(parent x y)`, which means `X`
    is a parent of `Y`. If gods were considered married, the facts list captures that
    as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Prolog 一样，我们在列出父子关系之前，先将一些神祇声明为男性，另一些神祇声明为女性，关系形式为 `(parent x y)`，这意味着 `X`
    是 `Y` 的父亲。如果神祇被认为是已婚的，事实列表也会包含这一点。
- en: '[Listing 6-6](ch06.xhtml#ch06list6) gives us rules capturing basic family relationships.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-6](ch06.xhtml#ch06list6) 给出了捕捉基本家庭关系的规则。'
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 6-6: Rules capturing basic relationships*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-6：捕捉基本关系的规则*'
- en: As we can see in the first `defrule` in [Listing 6-6](ch06.xhtml#ch06list6),
    `x` is the father of `y` if `x` is a parent of `y` and `x` is male. The LHS of
    the rules captures the relationship from the facts binding variables. For example,
    the `father` rule binds both `?x` and `?y`, meaning it will fire if there is a
    set of `(parent x y)` and `(male x)` facts in the facts list where the same `x`
    is parent of `y` and also male. Therefore, for a rule’s LHS, variables with the
    same name must be the same for every part of the condition to be true. When the
    rule fires, it simply outputs the now proven fact that `x` is the father of `y`.
    Notice that nothing is added to or removed from the facts list by these rules.
    These rules produce output only. Refraction will prevent the rule from firing
    more than once for the same set of facts.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[列表6-6](ch06.xhtml#ch06list6)中的第一个`defrule`所见，如果`x`是`y`的父亲，那么`x`必须是`y`的父母之一，且`x`是男性。规则的LHS通过绑定变量来捕捉事实中的关系。例如，`father`规则绑定了`?x`和`?y`，意味着当事实列表中存在一组`(parent
    x y)`和`(male x)`的事实时，规则会触发，前提是同一个`x`既是`y`的父母，又是男性。因此，对于规则的LHS，具有相同名称的变量必须在条件的每个部分中都相同，条件才会成立。当规则触发时，它会输出已经证明的`x`是`y`父亲的事实。注意，这些规则不会向事实列表中添加或删除任何内容。这些规则只会产生输出。折射（refraction）将防止规则在相同的事实集上触发多次。
- en: The rule for `mother` is almost the same as `father`. The rules for `wife` and
    `husband` include a logical-OR because `married` might be specified as `(married`
    `zeus hera)` or `(married hera zeus)`. Again, the rules make no change to the
    facts list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`mother`的规则几乎与`father`相同。`wife`和`husband`的规则包含了逻辑“或”（logical-OR），因为`married`可能被指定为`(married
    zeus hera)`或`(married hera zeus)`。同样，规则不会改变事实列表。'
- en: '[Listing 6-7](ch06.xhtml#ch06list7) shows us three more rules from *family.clp*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6-7](ch06.xhtml#ch06list7)展示了*family.clp*中的另外三条规则。'
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 6-7: Rules capturing sibling relationships*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-7：捕捉兄妹关系的规则*'
- en: The first rules capture the idea of siblings and the following two rules embody
    the ideas of sister and brother.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则捕捉了兄妹的概念，接下来的两条规则则体现了姐妹和兄弟的概念。
- en: For `x` to be the brother of Y, `x` must be male and `x` and `y` must be siblings.
    To be siblings, `x` and `y` must have a parent in common. The rules of [Listing
    6-7](ch06.xhtml#ch06list7) capture siblings and then assert that `x` and `y` are
    siblings. Once asserted, the `brother` and `sister` rules can fire because the
    new fact that `x` and `y` are siblings is now part of the fact list.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`x`成为`y`的兄弟，`x`必须是男性，且`x`和`y`必须是兄妹关系。要成为兄妹，`x`和`y`必须有共同的父母。[列表6-7](ch06.xhtml#ch06list7)的规则捕捉兄妹关系，并声明`x`和`y`是兄妹。一旦声明，`brother`和`sister`规则就可以触发，因为`x`和`y`是兄妹的事实已成为事实列表的一部分。
- en: The LHS of the rules includes a `test` to make sure that `x` and `y` are not
    the same person, as we don’t normally think of ourselves as our own siblings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的LHS包含一个`test`，以确保`x`和`y`不是同一个人，因为我们通常不会认为自己是自己的兄弟姐妹。
- en: There is no startup rule in *family.clp* like we had for *math.clp*. Instead,
    the fact list is initialized by `(reset)`, and `(run)` immediately begins using
    the fact list to satisfy the rules, place them on the agenda, and execute the
    RHS for all possible matches. Therefore, unlike Prolog, which gave us a result
    and waited patiently for us to request another or stop, CLIPS will run as long
    as it can match facts to rules and execute them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在*family.clp*中没有像在*math.clp*中那样的启动规则。相反，事实列表通过`(reset)`进行初始化，`(run)`立即开始使用事实列表来满足规则，将其置于议程上，并为所有可能的匹配执行RHS。因此，与Prolog不同，Prolog会给我们一个结果并耐心等待我们请求另一个结果或停止，而CLIPS只要能将事实匹配到规则并执行，就会一直运行下去。
- en: If you load *family.clp* and execute `(reset)` and `(run)`, you should see a
    flurry of output—119 lines’ worth, to be exact. The output is all the possible
    relationships CLIPS was able to pull out of the initial set of facts. For example,
    the list begins with
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你加载*family.clp*并执行`(reset)`和`(run)`，你应该会看到一大堆输出——准确来说是119行。输出是CLIPS从初始事实集提取的所有可能关系。例如，列表从以下内容开始：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: giving us a mix of husbands, wives, fathers, sisters, and so on. It would be
    nice to organize this list in some way, that is, to programmatically capture the
    relationships by type instead of dumping line after line. Fortunately, CLIPS is
    a full-service programming language. One way we can apply some order to the output
    is to capture instances of different types so we can report them at will.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们得到了混合的丈夫、妻子、父亲、姐妹等。最好以某种方式组织这个列表，也就是说，通过编程捕捉不同类型的关系，而不是一行一行地输出。幸运的是，CLIPS是一种全功能编程语言。我们可以通过捕获不同类型的实例来为输出应用某些顺序，这样就可以随时报告它们。
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 6-8: Storing relationship output*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-8: 存储关系输出*'
- en: The file *family2.clp* stores brothers and sisters in global lists. Only brothers
    and sisters are considered in this case, but it would be straightforward to include
    other family relationships. The essential pieces of *family2.clp* are in [Listing
    6-8](ch06.xhtml#ch06list8). The initial set of facts has been excluded from the
    listing, as has the rule `sibling`, which is unchanged from the version in [Listing
    6-7](ch06.xhtml#ch06list7).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*family2.clp*将兄弟姐妹存储在全局列表中。在这个例子中，只考虑了兄弟姐妹关系，但将其他家庭关系包括在内是非常简单的。*family2.clp*的核心内容在[Listing
    6-8](ch06.xhtml#ch06list8)中。初始事实集已从列表中省略，规则`sibling`也没有改变，仍然是[Listing 6-7](ch06.xhtml#ch06list7)中的版本。
- en: '[Listing 6-8](ch06.xhtml#ch06list8) begins with two new lines, instances of
    `defglobal`, which is CLIPS-speak for defining a global variable. CLIPS uses asterisks
    around the names of global variables, so we define two empty lists, the output
    of `create$` with no arguments, to hold brothers and sisters: `?*brothers*` and
    `?*sisters*`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 6-8](ch06.xhtml#ch06list8)以两行新的`defglobal`实例开始，这是CLIPS中定义全局变量的方式。CLIPS使用星号包围全局变量的名称，因此我们定义了两个空列表，它们是`create$`无参数调用的输出，用于存储兄弟姐妹：`?*brothers*`和`?*sisters*`。'
- en: To accumulate information about brothers and sisters, we modify the `brother`
    and `sister` rules. The LHS of each rule remains the same, but the RHS consists
    of two calls to `bind`. The first uses `create$` to make a list of `?x`, the symbols
    `is`, `sister` or `brother`, `to`, and `?y`. This list is passed to `implode$`,
    which makes a string from a list. Therefore, the output of `implode$` is a string,
    such as `dionysus is brother to artemis`, that we store in `?msg`. The second
    `bind` again uses `create$` to append the new string to the end of the existing
    list. In this way, every discovery of a brother or sister relationship is stored
    in the corresponding string.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了积累兄弟姐妹之间的信息，我们修改了`brother`和`sister`规则。每个规则的左边（LHS）保持不变，但右边（RHS）由两次调用`bind`构成。第一次调用使用`create$`生成一个包含`?x`、符号`is`、`sister`或`brother`、`to`和`?y`的列表。该列表被传递给`implode$`，它将列表转换成一个字符串。因此，`implode$`的输出是一个字符串，例如`dionysus
    is brother to artemis`，我们将其存储在`?msg`中。第二次`bind`再次使用`create$`将新字符串附加到现有列表的末尾。通过这种方式，每次发现兄弟姐妹关系时，都会将其存储在相应的字符串中。
- en: If we load *family2.clp* and call `(reset)` followed by `(run)`, we get no output.
    However, CLIPS did its job. To see this we need functions to print the lists.
    Enter the functions `brothers` and `sisters`. Neither function requires arguments
    and both use CLIPS’s `foreach` loop to iterate over the lists to print one element
    per line.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们加载*family2.clp*并调用`(reset)`，然后执行`(run)`，我们将不会看到任何输出。然而，CLIPS已经完成了它的工作。要查看这一点，我们需要一些函数来打印这些列表。输入`brothers`和`sisters`函数。这两个函数都不需要参数，并且都使用CLIPS的`foreach`循环来遍历列表，并每行打印一个元素。
- en: 'Give *family2.clp* a try. First load, reset, and run as usual, and then list
    the sisters. For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看*family2.clp*。首先像往常一样加载、重置并运行，然后列出姐妹。例如：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Calling `(brothers)` produces the other list. The *family2.clp* example shows
    how to combine procedural (imperative) programming with CLIPS’s rules engine.
    Now, let’s look at a factory simulation to see how rules can be ordered to fire
    in a specified sequence.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`(brothers)`会生成另一个列表。*family2.clp*示例展示了如何将过程式（命令式）编程与CLIPS的规则引擎结合使用。现在，让我们来看一个工厂模拟，看看如何按指定顺序排列规则的触发。
- en: '***At the Factory***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在工厂***'
- en: For this example, we’ll simulate the monitoring of a factory. The factory has
    pumps that must be turned on and then turned off three seconds later. Additionally,
    from time to time, an emergency must be serviced before turning on the pumps.
    Our simulation’s true purpose is to demonstrate *salience*, which determines the
    firing order for rules if multiple rules are on the agenda. Salience should be
    used with care, but it is sometimes necessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将模拟监控一个工厂。工厂有泵必须开启，并在三秒后关闭。此外，偶尔需要在开启泵之前处理紧急情况。我们模拟的真正目的是展示 *显著性*，它决定了在多个规则在议程上时规则触发的顺序。显著性应该谨慎使用，但有时是必要的。
- en: '[Listing 6-9](ch06.xhtml#ch06list9) shows us a few necessary utility functions.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-9](ch06.xhtml#ch06list9) 显示了几个必要的实用函数。'
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 6-9: Some utility functions*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-9：一些实用函数*'
- en: The first line defines a global variable, `?*base*`, which holds the current
    epoch seconds value returned by `(time)`. It’s set when the program loads. We’re
    using it with the `ftime` function to return the number of seconds since the program
    was loaded.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了一个全局变量 `?*base*`，它保存 `(time)` 返回的当前纪元秒值。它在程序加载时被设置。我们将它与 `ftime` 函数一起使用，返回自程序加载以来的秒数。
- en: CLIPS has a function called `(random)` to return a random integer, which is
    really the return value of the C `rand` function. To get a floating-point value
    in [0, 1), we take the remainder of this integer when divided by 1,000,000 and
    divide that by 1,000,000\. This approach is adequate for our purposes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: CLIPS 有一个名为 `(random)` 的函数，用于返回一个随机整数，实际上是 C 语言 `rand` 函数的返回值。为了获得一个 [0, 1)
    之间的浮动值，我们将这个整数除以 1,000,000 后取余，再将其除以 1,000,000。这个方法对于我们的目的足够了。
- en: The system pauses before monitoring the state of the factory, hence defining
    `(pause)`, which accepts the number of seconds and runs a `while` loop waiting
    for the time to elapse. This is very CPU intensive, but, again, it is acceptable
    for our purposes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 系统在监控工厂状态之前会暂停，因此定义了 `(pause)`，它接受秒数并运行一个 `while` 循环等待时间的流逝。这会非常消耗 CPU，但对于我们的目的来说是可以接受的。
- en: The rules responding to events in the factory are in [Listing 6-10](ch06.xhtml#ch06list10).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 响应工厂事件的规则在 [清单 6-10](ch06.xhtml#ch06list10) 中。
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 6-10: The factory rules*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-10：工厂规则*'
- en: 'There are three rules: `emergency`, `pumps-on`, and `pumps-off`. As before,
    the rules have a LHS and a RHS. There is also a new statement, `declare`, which
    sets the `salience` to an integer, which must be in the range [–10,000, 10,000].
    Higher salience rules fire before lower salience rules when multiple rules are
    on the agenda. The default salience value is 0.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个规则：`emergency`、`pumps-on` 和 `pumps-off`。如前所述，规则有一个 LHS 和一个 RHS。还有一个新的语句 `declare`，它将
    `salience` 设置为一个整数，必须在 [–10,000, 10,000] 范围内。显著性高的规则会在显著性低的规则之前触发，尤其是当多个规则在议程上时。默认的显著性值为
    0。
- en: The first rule in [Listing 6-10](ch06.xhtml#ch06list10) uses a salience of `100`.
    This is the emergency rule, and we want to ensure it fires immediately after being
    placed on the agenda; therefore, we give it a salience larger than any other rule.
    The `pumps-on` and `pumps-off` rules each have a salience of `5`. Salience is
    for ordering execution on the agenda, and the numeric value has no other meaning.
    Therefore, the fact that `emergency` has a salience 20 times greater than that
    of the other rules doesn’t mean anything other than that it fires first.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-10](ch06.xhtml#ch06list10) 中的第一个规则使用了 `100` 的显著性。这是紧急规则，我们希望它在被放入议程后立即触发；因此，我们给它设置了比任何其他规则更大的显著性。`pumps-on`
    和 `pumps-off` 规则的显著性都是 `5`。显著性用于在议程上排序执行，数值本身没有其他含义。因此，`emergency` 的显著性比其他规则高
    20 倍并不意味着其他任何事情，除了它会首先触发。'
- en: The `emergency` rule does nothing more than inform the user that an emergency
    condition exists, that is, the fact `emergency-alert` has been asserted. Notice
    that the fact has been retracted. If not, the rule would not fire again when a
    new `emergency-alert` is placed on the facts list.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`emergency` 规则仅仅是通知用户存在紧急情况，即 `emergency-alert` 事实已被断言。注意，该事实已经被撤回。如果没有撤回，规则将在新的
    `emergency-alert` 被放入事实列表时不会再次触发。'
- en: The `pumps-on` rule displays the pump start time and then asserts `pumps-off`
    `-time` as three seconds beyond the current time. The assertion fires `pumps-off`.
    This rule uses `if` to check whether the current time is beyond the desired stop
    time. If it is, the `pumps-off-time` fact is retracted and the off message displayed.
    If the full three seconds has not yet elapsed, `refresh` is used to cause `pumps-off`
    to fire again even though it already matched the `pumps-off-time` fact. Using
    `refresh` eliminates the need to retract the `pumps-off-time` fact only to assert
    it again.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`pumps-on`规则显示泵的启动时间，然后将`pumps-off` `-time`设定为当前时间后的三秒。该断言触发`pumps-off`。此规则使用`if`检查当前时间是否已经超过了预定的停止时间。如果超过，`pumps-off-time`事实将被撤回并显示关闭消息。如果三秒钟的时间尚未到达，使用`refresh`使得`pumps-off`再次触发，尽管它已经匹配了`pumps-off-time`事实。使用`refresh`消除了撤回`pumps-off-time`事实然后再次断言的需要。'
- en: The main factory monitor loop is the rule `monitor` (see [Listing 6-11](ch06.xhtml#ch06list11)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 主工厂监控循环是规则`monitor`（见[清单6-11](ch06.xhtml#ch06list11)）。
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 6-11: The monitor rule*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-11：监控规则*'
- en: The `monitor` rule uses a salience of `0`, which is the default value. Doing
    this means the pump and emergency rules will always fire before this rule. The
    idea is to monitor the factory until something worthwhile happens and then react
    to the situation before returning to monitor the factory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`monitor`规则使用了`0`的显著性，这是默认值。这样做意味着泵和紧急规则将总是先于该规则触发。其思想是监控工厂，直到有值得关注的事情发生，然后对情况做出反应，再返回继续监控工厂。'
- en: This is a simulation, so “monitor the factory” means use `(rand)` to assert
    events with random probabilities. For any execution of `monitor`, there’s a 20
    percent chance the pumps will be turned on. Likewise, there is a 5 percent chance
    an emergency alert will be issued. After a 0.2 second pause, the program refreshes
    the `monitor` rule to make it fire again. To prep the system, `deffacts` places
    `monitor-loop` on the facts list when `(reset)` is executed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仿真，所以“监控工厂”意味着使用`(rand)`以随机概率断言事件。每次执行`monitor`时，泵有20%的概率会被开启。同样，也有5%的概率会发出紧急警报。在0.2秒的暂停后，程序会刷新`monitor`规则，使其再次触发。为了准备系统，当执行`(reset)`时，`deffacts`会将`monitor-loop`放入事实列表中。
- en: Now, let’s run the simulation and see what it tells us.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行仿真，看看它会告诉我们什么。
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This run activated the pumps and, as desired, turned them off after three seconds.
    There was one emergency alert. The factory simulation has no end condition, so
    use CTRL-`\` to exit. This is the source of the `Quit` message in the listing
    above.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本次运行激活了泵，并且如预期的那样，在三秒后将其关闭。发生了一次紧急警报。工厂仿真没有结束条件，因此请使用CTRL-`\`退出。这就是上面清单中`Quit`消息的来源。
- en: '***An Iris Expert System***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***虹膜专家系统***'
- en: In [Chapter 5](ch05.xhtml#ch05), we built a nearest neighbor classifier in SNOBOL.
    The nearest neighbor classifier is an example of machine learning, a statistical
    approach using training data to build a model that captures something essential
    about the data and allows for predictions when given new, unknown data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml#ch05)中，我们用SNOBOL构建了一个最近邻分类器。最近邻分类器是机器学习的一个例子，这是一种使用训练数据构建模型的统计方法，模型能够捕捉数据中的某些本质内容，并在给定新的未知数据时做出预测。
- en: An expert system attempts to encapsulate expert knowledge to capture enough
    about a particular domain to make informed decisions. This section uses “expert”
    knowledge of iris flowers to build a simple expert system. The result is a system
    that asks us questions about an unknown iris flower to decide what type of iris
    it is.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 专家系统尝试将专家知识封装起来，以捕捉特定领域的足够信息，从而做出明智的决策。本节使用“专家”知识构建一个关于虹膜花的简单专家系统。其结果是一个系统，能够根据我们对未知虹膜花的问题回答，来决定它是什么类型的虹膜花。
- en: Unfortunately, I’m not an expert in iris flowers. But that isn’t too much of
    a limitation in this case, as we can cheat a bit. We’ll use machine learning to
    build a *decision tree* classifier for irises. A decision tree is a series of
    yes or no questions that ultimately lead from the tree’s root to a leaf, which
    identifies the flower. Translating a decision tree into a simple expert system
    is straightforward, so we’ll use the “expertise” captured by the decision tree
    to build the expert system. This isn’t all that different from a human interviewing
    an iris expert to extract essential knowledge then encoded in a series of questions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我不是鸢尾花的专家。但在这种情况下，这并不是什么太大的限制，因为我们可以稍微作弊一下。我们将使用机器学习为鸢尾花构建一个*决策树*分类器。决策树是一系列是或否的问题，最终从树的根节点到达一个叶子节点，叶子节点标识了花的种类。将决策树转换为一个简单的专家系统是直接的，因此我们将利用决策树中捕捉到的“专业知识”来构建专家系统。这与人类采访鸢尾花专家以提取基本知识，然后将其编码为一系列问题并无太大不同。
- en: 'Therefore, our plan of attack is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的攻击计划如下：
- en: Use the iris training data to build a decision tree classifier.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鸢尾花训练数据来构建决策树分类器。
- en: Use the associated test data to characterize the resulting tree’s accuracy.
    Our expert system will use the same sequence of questions, so we’ll get the same
    accuracy from CLIPS if we implement things correctly.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关的测试数据来表征生成的树的准确性。我们的专家系统将使用相同的问题序列，因此如果我们正确实现，它将从CLIPS中得到相同的准确度。
- en: Translate the questions of the decision tree into a set of CLIPS rules.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将决策树的问题翻译成一组CLIPS规则。
- en: Test the system with the iris test dataset.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鸢尾花测试数据集来测试系统。
- en: First is the decision tree classifier. The code to train the classifier and
    output a tree representation is in the file *make_iris_tree.py*. You do not need
    to run it. The tree we’ll work with is in *iris_tree.png*. If you want to generate
    a new tree, perhaps as an exercise in doing the translation to CLIPS yourself,
    you’ll need to install scikit-learn (*[https://scikit-learn.org/](https://scikit-learn.org/)*)
    and Matplotlib (*[https://matplotlib.org/](https://matplotlib.org/)*). scikit-learn
    uses some randomization when building the tree; therefore, each run of *make_iris_tree.py*
    results in a slightly different level of performance. The particular tree we’re
    using here is 98 percent accurate on the iris test dataset (*iris_test_data.txt*).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是决策树分类器。训练分类器并输出树形表示的代码在文件*make_iris_tree.py*中。你无需运行它。我们将使用的树位于*iris_tree.png*中。如果你想生成一棵新的树，也许作为自己将其翻译为CLIPS的练习，你需要安装scikit-learn（*[https://scikit-learn.org/](https://scikit-learn.org/)）和Matplotlib（*[https://matplotlib.org/](https://matplotlib.org/)*）。scikit-learn在构建树时会使用一些随机化，因此每次运行*make_iris_tree.py*都会得到略有不同的性能表现。我们在这里使用的这棵树在鸢尾花测试数据集（*iris_test_data.txt*）上的准确度为98%。
- en: '[Figure 6-1](ch06.xhtml#ch06fig1) shows us the decision tree classifier.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](ch06.xhtml#ch06fig1)展示了决策树分类器。'
- en: '![Image](Images/06fig01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/06fig01.jpg)'
- en: '*Figure 6-1: The iris classifier decision tree*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：鸢尾花分类器决策树*'
- en: 'The root of the tree is at the top, following normal computer science convention
    for representing a tree data structure. Each box is a node of the tree. If the
    box isn’t a leaf, the first line of the box is a question asked of the user. If
    the answer to the question is “yes,” move to the next lower box on the left. If
    the answer is “no,” move to the lower box on the right. Answer enough questions
    and you’ll eventually get to a leaf. The class label given there identifies the
    flower: *I. setosa*, *I. versicolor*, or *I. virginica*.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 树的根位于顶部，遵循计算机科学表示树形数据结构的常规方式。每个框是树的一个节点。如果框不是叶子节点，框的第一行是询问用户的问题。如果问题的答案是“是”，则移动到左侧的下一个框。如果答案是“否”，则移动到右侧的下一个框。回答足够的问题后，你最终会到达一个叶子节点。叶子节点给出的类别标签标识了花的种类：*I.
    setosa*、*I. versicolor* 或 *I. virginica*。
- en: All boxes have additional lines of text. The *Gini score* is a measure used
    to generate the decision tree. Samples is a vector of three elements, one for
    each of the three iris flower types. It shows the split by type at that node when
    using the training data. The class label is the most correct label to give the
    flower if one stops at that node. For the leaves, the class label matches a value
    vector with only one class, meaning the decision tree was able to successfully
    partition the training data with 100 percent accuracy.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有框中都有额外的文本行。*基尼系数*是用来生成决策树的一个度量。样本是一个包含三个元素的向量，每个元素代表三种鸢尾花类型中的一种。它显示了使用训练数据时该节点按类型的分裂情况。类别标签是当停在该节点时，给花朵分配的最正确的标签。对于叶节点，类别标签与一个仅包含一个类的值向量匹配，这意味着决策树成功地将训练数据以
    100% 准确度进行了划分。
- en: 'How do we use the decision tree? Let’s walk through a test sample. The expert
    system will ask us about measurements made from an unknown iris flower. There
    are four measurements: sepal length, sepal width, petal length, and petal width,
    all in centimeters. See [Figure 6-2](ch06.xhtml#ch06fig2) if you need a reminder
    of basic flower anatomy.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用决策树？让我们通过一个测试样本来演示。专家系统会询问我们关于一朵未知鸢尾花的测量值。有四个测量值：萼片长度、萼片宽度、花瓣长度和花瓣宽度，单位是厘米。如果你需要回顾花卉的基本解剖结构，请参考[图
    6-2](ch06.xhtml#ch06fig2)。
- en: '![Image](Images/06fig02.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig02.jpg)'
- en: '*Figure 6-2: Basic flower anatomy*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：基本花卉解剖结构*'
- en: Our test case has the measurements
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试样本具有以下测量值：
- en: '| sepal length | 6.8 cm |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 萼片长度 | 6.8 cm |'
- en: '| sepal width | 2.8 cm |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 萼片宽度 | 2.8 cm |'
- en: '| petal length | 4.8 cm |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 花瓣长度 | 4.8 cm |'
- en: '| petal width | 1.4 cm |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 花瓣宽度 | 1.4 cm |'
- en: and is an instance of *I. versicolor* (class label 1). The path through the
    decision tree for this example is in [Figure 6-3](ch06.xhtml#ch06fig3).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该实例属于 *I. versicolor*（类别标签 1）。这个例子的决策树路径见[图 6-3](ch06.xhtml#ch06fig3)。
- en: '![Image](Images/06fig03.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig03.jpg)'
- en: '*Figure 6-3: A path through the decision tree*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：通过决策树的路径*'
- en: We can place the questions asked at each node of the decision tree into [Table
    6-1](ch06.xhtml#ch06tab1).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将决策树中每个节点所问的问题放入[表 6-1](ch06.xhtml#ch06tab1)。
- en: '**Table 6-1:** The Questions and Responses for the Iris Expert System'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：** Iris 专家系统中的问题与回答'
- en: '| **Question** | **Text** | **Yes** | **No** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | **文本** | **是** | **否** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Q1 | Is petal width ≤ 0.8? | setosa | Q2 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| Q1 | 花瓣宽度 ≤ 0.8 吗？ | setosa | Q2 |'
- en: '| Q2 | Is petal length ≤ 4.75? | Q3 | Q4 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| Q2 | 花瓣长度 ≤ 4.75 吗？ | Q3 | Q4 |'
- en: '| Q3 | Is petal width ≤ 1.65? | versicolor | virginica |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| Q3 | 花瓣宽度 ≤ 1.65 吗？ | versicolor | virginica |'
- en: '| Q4 | Is petal width ≤ 1.75? | Q5 | Q6 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| Q4 | 花瓣宽度 ≤ 1.75 吗？ | Q5 | Q6 |'
- en: '| Q5 | Is petal length ≤ 5.05? | versicolor | Q7 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| Q5 | 花瓣长度 ≤ 5.05 吗？ | versicolor | Q7 |'
- en: '| Q6 | Is petal length ≤ 4.85? | Q8 | virginica |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| Q6 | 花瓣长度 ≤ 4.85 吗？ | Q8 | virginica |'
- en: '| Q7 | Is sepal length ≤ 6.05? | versicolor | virginica |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| Q7 | 萼片长度 ≤ 6.05 吗？ | versicolor | virginica |'
- en: '| Q8 | Is sepal length ≤ 5.95? | versicolor | virginica |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| Q8 | 萼片长度 ≤ 5.95 吗？ | versicolor | virginica |'
- en: Each row of the table is a question. If the answer to a question is yes, we
    move to the indicated question or, if we now know the type, return the label.
    Notice that if the petal width is ≤ 0.8, the flower is an instance of *I. setosa*
    and there is no need to ask any further questions. This means of the three classes
    in the dataset, one is easily distinguished from the other two, but the remaining
    two need more work to tell apart. With the table, we now have what we need to
    implement the expert system. We begin with Q1, as that is the root of the tree,
    and move to other questions or endpoints based on the user’s response to each
    question.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的每一行都是一个问题。如果问题的答案是“是”，我们将跳到指定的问题，或者如果已经知道花的类型，则返回标签。注意，如果花瓣宽度 ≤ 0.8，则该花为
    *I. setosa*，无需再问其他问题。这意味着在数据集中，三种类别中有一种可以轻松区分出来，而剩下的两种则需要更多工作来区分。通过表格，我们现在已经拥有实现专家系统所需的信息。我们从
    Q1 开始，因为它是树的根节点，然后根据用户对每个问题的回答，跳转到其他问题或终点。
- en: The full expert system is in *irises.clp*. We’ll work through the code in sections
    beginning with the initial facts and helper rules (see [Listing 6-12](ch06.xhtml#ch06list12)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的专家系统在 *irises.clp* 文件中。我们将分段讲解代码，首先从初始事实和辅助规则开始（参见[清单 6-12](ch06.xhtml#ch06list12)）。
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 6-12: Facts and helper rules*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-12：事实和辅助规则*'
- en: 'The program begins with the `start` rule, which fires because `initial-facts`
    places it on the facts list when `(reset)` is run. It also defines a `state` fact,
    set to `1` for question Q1, and the text of the question itself. When `startup`
    fires, it prints instructions for the user and retracts itself. The presence of
    the `question` rule fires `ask-question`, which displays the question text and
    asserts the user’s response: `y` or `n`. A full system would, naturally, validate
    the user’s input. Rule `output-result` reports when we have a valid label and
    halts.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从 `start` 规则开始运行，因为 `(reset)` 执行时，`initial-facts` 会将其添加到事实列表中。它还定义了一个 `state`
    事实，将其设置为 Q1 的 `1`，以及问题本身的文本。当 `startup` 被触发时，它会打印用户指令并撤销自身。`question` 规则的存在触发了
    `ask-question`，该规则显示问题文本并断言用户的回答：`y` 或 `n`。一个完整的系统自然会验证用户的输入。规则 `output-result`
    在我们获得有效标签时报告结果并停止。
- en: Asserting a `response` fact causes a question rule to fire. There are 16 of
    them, two each for Q1 through Q8 in [Table 6-1](ch06.xhtml#ch06tab1), one each
    for a yes or no response. Let’s look at the first pair of rules. You should review
    *irises.clp* yourself to see the entire program.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 断言一个 `response` 事实会触发一个问题规则。共有 16 个规则，每个问题 Q1 到 Q8 在 [表 6-1](ch06.xhtml#ch06tab1)
    中有两个规则，分别对应“是”或“否”的回答。让我们来看一下第一对规则。你应该自己查看 *irises.clp* 以了解整个程序。
- en: '[Listing 6-13](ch06.xhtml#ch06list13) shows us the first two rules for Q1,
    that is, the first row of [Table 6-1](ch06.xhtml#ch06tab1).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-13](ch06.xhtml#ch06list13) 向我们展示了 Q1 的前两条规则，即 [表 6-1](ch06.xhtml#ch06tab1)
    的第一行。'
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 6-13: Some iris rules*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-13：一些鸢尾花规则*'
- en: As you can see, if the user’s response to Q1 is “yes,” rule `q1-yes` fires.
    [Table 6-1](ch06.xhtml#ch06tab1) says a “yes” response to Q1 means the sample
    is an instance of *I. setosa*. Therefore, rule `q1-yes` asserts `label`, causing
    `output-result` from [Listing 6-12](ch06.xhtml#ch06list12) to fire, tell us the
    iris type, and halt.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果用户对 Q1 的回答是“是”，则会触发规则 `q1-yes`。[表 6-1](ch06.xhtml#ch06tab1) 说明对 Q1 的“是”回答意味着样本属于
    *I. setosa*。因此，规则 `q1-yes` 会断言 `label`，使得 [清单 6-12](ch06.xhtml#ch06list12) 中的
    `output-result` 被触发，告诉我们鸢尾花的类型并停止运行。
- en: If the user’s response to Q1 is “no,” rule `q1-no` fires instead. [Table 6-1](ch06.xhtml#ch06tab1)
    says to move to Q2 in this case, so the RHS of `q1-no` asserts `state 2` and the
    proper `question`, which `ask-question` in [Listing 6-12](ch06.xhtml#ch06list12)
    dutifully asks.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户对 Q1 的回答是“否”，则触发规则 `q1-no`。此时，[表 6-1](ch06.xhtml#ch06tab1) 指示移动到 Q2，因此 `q1-no`
    的右侧规则（RHS）会断言 `state 2` 和适当的 `question`，然后在 [清单 6-12](ch06.xhtml#ch06list12) 中的
    `ask-question` 会忠实地提出该问题。
- en: 'As the user answers questions, CLIPS moves from state to state until it reaches
    a rule with a known label. For example, if we run *irises.clp* for the test sample
    above we get the output shown in [Listing 6-14](ch06.xhtml#ch06list14):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户回答问题时，CLIPS 会在状态之间转换，直到遇到一个已知标签的规则。例如，如果我们运行上面的测试样本并执行 *irises.clp*，我们将得到
    [清单 6-14](ch06.xhtml#ch06list14) 中显示的输出：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 6-14: Using the expert system*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-14：使用专家系统*'
- en: If you are patient enough, you can work through every example in the *iris_test_data.txt*
    file in the *SNOBOL/datasets* directory. Matching the reported labels against
    the known labels in *iris_test_labels.txt* will tell you that the iris expert
    system is 98 percent accurate, meaning it makes one mistake out of every 50 test
    samples. The SNOBOL nearest neighbor classifier is 96 percent accurate on the
    same test data using the same training data. Therefore, in this case, the expert
    system is quite good. Of course, our “expert knowledge” of iris flowers came from
    the training data in the first place, so we didn’t implement a true expert system.
    We merely encapsulated knowledge synthesized from a statistical model. I’ll have
    more to say about this in the discussion up next.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够耐心，可以逐步处理 *SNOBOL/datasets* 目录中的 *iris_test_data.txt* 文件中的每个示例。将报告的标签与
    *iris_test_labels.txt* 中已知的标签进行匹配，你会发现鸢尾花专家系统的准确率为 98%，这意味着它每 50 个测试样本会出错一次。使用相同的训练数据，SNOBOL
    最近邻分类器在相同的测试数据上准确率为 96%。因此，在这种情况下，专家系统的表现相当不错。当然，我们对鸢尾花的“专家知识”最初来自于训练数据，因此我们并没有实现真正的专家系统。我们仅仅是封装了从统计模型中合成的知识。接下来的讨论中我会进一步阐述这一点。
- en: The examples in this section give us a good feel for CLIPS, but, as stated earlier,
    CLIPS is much more than we can explore here. For example, we ignored CLIPS’s object-oriented
    abilities and the fact that CLIPS is designed to play nicely when integrated into
    other applications. A quick review of Google Scholar shows that academic papers
    referencing CLIPS are still being written, to say nothing of industrial uses for
    CLIPS that are likely never discussed in print.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的例子让我们对CLIPS有了很好的了解，但正如前面所提到的，CLIPS远远不止这些内容。比如，我们忽略了CLIPS的面向对象能力以及CLIPS在与其他应用集成时能够友好配合的事实。通过快速查看Google
    Scholar，可以发现仍然有学术论文引用CLIPS，更不用说那些可能永远不会在出版物中讨论的CLIPS工业应用了。
- en: '**Discussion**'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Expert systems are often considered “old-school” or even “failures,” but that
    isn’t fair. You won’t hear the term *expert system* too much these days, but they
    are alive and well under the term *business rule management system.* For example,
    DROOLS (*[https://www.drools.org/](https://www.drools.org/)*) is an open source
    rules-based system in active development with a large user base and supporting
    documentation, including multiple books. As a general approach to artificial intelligence,
    expert systems are passé, replaced by the phenomenal success of deep learning
    and neural networks, which represent a connectionist view of cognition, not the
    computational view embodied by an expert system.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 专家系统通常被认为是“过时的”或甚至是“失败的”，但这并不公平。如今你不会经常听到*专家系统*这个词，但它们以*业务规则管理系统*的名义依然存在并运行。例如，DROOLS
    (*[https://www.drools.org/](https://www.drools.org/)*) 是一个开源的基于规则的系统，正在积极开发中，拥有庞大的用户基础和支持文档，包括多本书籍。作为一种人工智能的通用方法，专家系统已经过时，被深度学习和神经网络的惊人成就所取代，后者代表了认知的连接主义视角，而不是专家系统所体现的计算视角。
- en: Expert systems are rigid. Once coded, they are not easily modified. Additionally,
    the rules often contain gaps, missing elements, or paths that are not specified.
    If a rule-based system claims to cover a topic, how would we know we’ve tested
    all the corner cases and all the possible sets of inputs? It becomes difficult,
    perhaps exponentially difficult, as the rules become more complex and intertwined.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 专家系统是僵化的。一旦编码，它们就不容易修改。此外，规则往往存在缺口、遗漏元素或未指定的路径。如果一个基于规则的系统声称覆盖了某个话题，我们怎么知道自己已经测试了所有极端情况和所有可能的输入集呢？随着规则变得更加复杂和交织，这变得困难，甚至可能呈指数级增长。
- en: The iris expert system shown earlier used “knowledge” extracted from a machine
    learning model. What if, instead, we needed to extract the rules from an expert
    gardener? The expert certainly knows how to identify iris flowers, but how do
    we get that knowledge out of the expert’s head and into a set of rules for CLIPS?
    The process of mapping an expert’s knowledge to rules is known as *knowledge extraction*,
    and it is an Achilles’ heel of sorts for expert systems. The concept of an expert
    system is seductive, but the realization is difficult at best. To be sure, the
    iris expert won’t know that a petal width less than 0.8 cm means the flower is
    almost certainly *I. setosa*, even if able to identify that species with almost
    perfect precision. How is that then captured and coded? Careful interviewing,
    which is highly time consuming, to say nothing of potentially irritating to the
    interviewee, might generate more general rules, but none would be as specific
    as those extracted by the decision tree. For example, one rule asks in a particular
    circumstance if the petal length is less than 4.75 cm, versus less than 4.85 cm
    in another. I doubt any expert would consider a millimeter difference in petal
    length of any importance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的虹膜专家系统使用了从机器学习模型中提取的“知识”。如果我们需要从一位专家园丁那里提取规则，而不是使用机器学习模型怎么办？专家当然知道如何识别虹膜花，但我们如何将这些知识从专家的脑海中提取出来，并转化为CLIPS的规则集呢？将专家知识映射到规则的过程被称为*知识提取*，它是专家系统的一个“致命弱点”。专家系统的概念非常吸引人，但实现起来极为困难。可以肯定的是，虹膜专家不会知道花瓣宽度小于0.8厘米意味着这朵花几乎肯定是*I.
    setosa*，即使专家能以几乎完美的精度识别出这种物种。那么，这些信息又是如何被捕捉并编码的呢？仔细的访谈，虽然非常耗时，而且可能会令受访者感到烦扰，可能会产生更一般的规则，但没有任何规则能像决策树提取的规则那样具体。例如，在某种情况下，一条规则会询问花瓣长度是否小于4.75厘米，而在另一种情况下则是小于4.85厘米。我怀疑任何专家都会认为花瓣长度相差一毫米有任何重要性。
- en: CLIPS’s use has faded as expert systems have fallen out of favor, but it is
    still maintained. There are likely many CLIPS-based expert systems out there,
    quietly running in the background and invisible to the general public.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 随着专家系统的逐渐被冷落，CLIPS的使用也有所减少，但它仍在维护中。很可能有许多基于CLIPS的专家系统在后台默默运行，对公众而言却是隐形的。
- en: Because of its multiparadigm nature, CLIPS is, of course, a Turing-complete
    language. Indeed, one could use CLIPS without any reference to the rules engine
    if desired. As a framework for an expert system, CLIPS has stood the test of time,
    so if you find yourself in a situation where an expert system seems appropriate,
    CLIPS is an option. For us, CLIPS is an atypical language, but one we should be
    familiar with and keep in our back pocket for those times when the appropriate
    situation arises. In terms of thinking about coding, CLIPS requires a different
    approach if we want to use the rules engine. That fact alone warrants including
    CLIPS in our explorations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其多范式的特性，CLIPS当然是一种图灵完备的语言。事实上，如果需要，完全可以在不涉及规则引擎的情况下使用CLIPS。作为专家系统的框架，CLIPS经受住了时间的考验，所以如果你发现自己处于一个专家系统似乎合适的场景中，CLIPS是一个选择。对我们来说，CLIPS是一种非典型的语言，但我们应该熟悉它，并在适当的时候将其作为备选。考虑到编码的方式，如果我们希望使用规则引擎，CLIPS需要一种不同的方法。仅仅这一点就足以让CLIPS进入我们的探索范围。
- en: '**Summary**'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'The CLIPS expert system was the focus of this chapter. We introduced the language
    and the concept of an expert system before exploring the basics: facts and rules.
    The bulk of the chapter saw us work through four examples illustrating the core
    of CLIPS. We learned how rules respond to facts by building an elementary calculator.
    We then re-explored family relationships to illustrate the difference between
    CLIPS and Prolog when generating inferences from collections of facts. The next
    example used a factory simulation to demonstrate arranging the firing sequence
    of rules by manipulating their salience. The final example was our most elaborate.
    We used a learned decision tree to implement a collection of rules, those that
    might have been created by an expert to let us categorize different types of iris
    flowers by answering a few yes or no questions.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是CLIPS专家系统。我们在介绍语言和专家系统的概念后，探索了基础内容：事实和规则。大部分内容是通过四个示例来展示CLIPS的核心功能。我们通过构建一个基础计算器来学习规则如何响应事实。接着，我们重新探讨了家庭关系，以说明CLIPS和Prolog在从事实集合中推导推论时的区别。下一个示例使用了一个工厂模拟，演示了通过调整规则的重要性来排列规则的触发顺序。最后一个示例是我们最复杂的。我们使用一个学习得到的决策树来实现一组规则，这些规则可能是专家创建的，帮助我们通过回答几个是或否的问题来对不同类型的鸢尾花进行分类。
- en: CLIPS is our last atypical programming language. We move now to the first of
    our esolangs and into the realm of what I’m calling “eccentric programming languages.”
    We’ll begin with ABC, a tiny language that will serve us well to introduce the
    weirdly wonderful world of esolangs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: CLIPS是我们最后一种非典型的编程语言。接下来，我们将进入第一个esolang，并进入我所称之为“古怪编程语言”的领域。我们将从ABC语言开始，这是一种微小的语言，将帮助我们很好地介绍这个奇异而美妙的esolang世界。
