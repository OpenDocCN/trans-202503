- en: '![](../images/pg117.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg117.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-14.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-14.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">IF
    STATEMENTS AND CONDITIONAL EXPRESSIONS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">IF语句和条件表达式</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: In the last chapter, you learned how to compile programs that execute a list
    of statements. But most C programs have a more complicated execution path; they
    often need to decide what statements to execute at runtime based on the current
    state of the program. The order in which a program executes statements is its
    *control flow*, and the language constructs that let you change a program’s control
    flow are called *control structures*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何编译执行一系列语句的程序。但是大多数C程序的执行路径更为复杂；它们通常需要根据程序的当前状态，在运行时决定执行哪些语句。程序执行语句的顺序就是它的*控制流*，允许你更改程序控制流的语言结构称为*控制结构*。
- en: 'In this chapter, you’ll implement your first control structure: <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements. You’ll also implement *conditional expressions*. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, conditional expressions let you control what code to run. For example,
    the conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0)
    ? 3 : 4</samp> evaluates to 3 if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and 4 otherwise.
    We laid a lot of the groundwork for <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions when we implemented the short-circuiting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    operators in [Chapter 4](chapter4.xhtml). We already have TACKY constructs that
    let us conditionally run or skip over code, so we don’t need to change any stages
    after TACKY generation. Let’s get started!'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，你将实现第一个控制结构：<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句。你还将实现*条件表达式*。和<sup
    class="SANS_TheSansMonoCd_W5Regular_11">if</sup>语句一样，条件表达式也让你控制运行哪些代码。例如，条件表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0) ? 3 : 4</samp>在a等于<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>时评估为3，否则评估为4。在实现短路运算符<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>时，我们已经为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">if</sup>语句和条件表达式奠定了很多基础，具体见[第4章](chapter4.xhtml)。我们已经有了TACKY结构，允许我们有条件地运行或跳过代码，因此在TACKY生成后，我们无需更改任何阶段。让我们开始吧！'
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add four tokens in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍四个令牌：
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">if</samp> | A keyword indicating
    the start of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">if</samp> | 一个关键字，表示<sup class="SANS_TheSansMonoCd_W5Regular_11">if</sup>语句的开始
    |'
- en: '| --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">else</samp> | A keyword indicating
    the start of the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause
    in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">else</samp> | 一个关键字，表示<sup class="SANS_TheSansMonoCd_W5Regular_11">else</sup>子句在<sup
    class="SANS_TheSansMonoCd_W5Regular_11">if</sup>语句中的开始 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> | A question mark,
    the delimiter between the first and second operands in a conditional expression
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> | 问号，条件表达式中第一个和第二个操作数之间的分隔符
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">:</samp> | A colon, the delimiter
    between the second and third operands in a conditional expression |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">:</samp> | 冒号，条件表达式中第二个和第三个操作数之间的分隔符
    |'
- en: Once your lexer supports these four tokens, you can test it out.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的词法分析器支持这四个令牌，你就可以进行测试了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: Now we’ll update the parser to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions. Because these are two distinct language
    constructs, we’ll handle them one at a time, beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新解析器以支持 `if` 语句和条件表达式。由于这两者是不同的语言结构，我们将逐一处理，首先从 `if` 语句开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing if Statements</samp>
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析 if 语句</samp>
- en: We’ll start by extending the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST node to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements.
    [Listing 6-1](chapter6.xhtml#list6-1) gives the updated definition of this node.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过扩展 `statement` AST 节点来支持 `if` 语句。[清单 6-1](chapter6.xhtml#list6-1) 给出了这个节点的更新定义。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: The definition
    for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-1: 定义</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AST 节点，包括</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>'
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp> constructor
    takes three arguments. The <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    expression, sometimes called the *controlling expression*, determines whether
    the body of the statement is executed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>
    statement is the first clause of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, which executes when the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    is nonzero. The second clause, the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statement, is optional. If it’s present, it executes when the result of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> is 0.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `If` 构造函数接受三个参数。`condition` 表达式，有时称为 *控制表达式*，决定语句体是否被执行。`then` 语句是 `if` 语句的第一个子句，当
    `condition` 的结果非零时执行。第二个子句，`else` 语句是可选的。如果它存在，当 `condition` 的结果为 0 时执行。
- en: As I mentioned in the previous chapter, each clause in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is itself a single statement. Although it may look like multiple statements,
    the body of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    like the one in [Listing 6-2](chapter6.xhtml#list6-2) is really a single compound
    statement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在前一章中提到的，`if` 语句中的每个子句本身就是一个独立的语句。尽管它看起来像是多个语句，但像[清单 6-2](chapter6.xhtml#list6-2)中的
    `if` 语句体实际上是一个复合语句。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    whose body is a compound statement</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-2: 一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">其语句体为复合语句的
    if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>'
- en: We haven’t implemented compound statements yet, so at this point we can’t compile
    code like [Listing 6-2](chapter6.xhtml#list6-2). [Listing 6-3](chapter6.xhtml#list6-3)
    gives an example of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement that we can compile.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有实现复合语句，因此此时我们无法编译像 [清单 6-2](chapter6.xhtml#list6-2) 中的代码。[清单 6-3](chapter6.xhtml#list6-3)
    给出了我们可以编译的 `if` 语句示例。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    that doesn’t contain any compound statements</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-3: 一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">不包含任何复合语句的
    if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>'
- en: We can also compile <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements nested inside other <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, like [Listing 6-4](chapter6.xhtml#list6-4).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以编译嵌套在其他 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句内的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句，就像 [列表 6-4](chapter6.xhtml#list6-4)
    中那样。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    nested inside another</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-4：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句嵌套在另一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句内</samp>
- en: Note that the AST definition in [Listing 6-1](chapter6.xhtml#list6-1) doesn’t
    have an <samp class="SANS_TheSansMonoCd_W5Regular_11">else if</samp> construct,
    because an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement can
    have at most one <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause.
    An <samp class="SANS_TheSansMonoCd_W5Regular_11">else if</samp> clause is really
    just an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause that
    contains another <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement.
    Take [Listing 6-5](chapter6.xhtml#list6-5) as an example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，[列表 6-1](chapter6.xhtml#list6-1) 中的 AST 定义没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">else
    if</samp> 构造，因为一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句最多只能有一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 子句。<samp class="SANS_TheSansMonoCd_W5Regular_11">else
    if</samp> 子句实际上只是一个包含另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句的 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 子句。以 [列表 6-5](chapter6.xhtml#list6-5)
    为例。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    nested inside an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">clause</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-5：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句嵌套在一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">子句内</samp>
- en: 'Let’s reformat this in a way that better reflects how it will be parsed:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一种更能反映其解析方式的格式重新排版：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The AST for [Listing 6-5](chapter6.xhtml#list6-5) will look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-5](chapter6.xhtml#list6-5) 的 AST 将如下所示：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Listing 6-6](chapter6.xhtml#list6-6) shows the changes to the grammar, which
    exactly mirror the changes to the AST.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-6](chapter6.xhtml#list6-6) 显示了语法的变化，这些变化与抽象语法树（AST）的变化完全一致。'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: The grammar rules
    for statements, including</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-6：语句的语法规则，包括</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: 'We can handle this new production rule with straightforward recursive descent
    parsing. Interestingly, this rule is ambiguous, but that ambiguity won’t pose
    any problems for our parser. Let’s take another look at [Listing 6-4](chapter6.xhtml#list6-4):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的递归下降解析法来处理这个新的产生式规则。有趣的是，这个规则是模糊的，但这种模糊性不会对我们的解析器造成任何问题。让我们再看看 [列表
    6-4](chapter6.xhtml#list6-4)：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are two ways to parse this listing that both follow our new grammar rule:
    we could group the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause
    with either the first or the second <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. In other words, we could parse this listing like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以解析这个列表，两种方法都遵循我们新的语法规则：我们可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    子句与第一个或第二个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句组合在一起。换句话说，我们可以这样解析这个列表：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or we could parse it like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们也可以这样解析：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The C standard clarifies that the first of these alternatives is correct; an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause should always
    be grouped with the closest <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. However, the grammar by itself doesn’t tell us which of these options
    to choose. This quirk of the grammar is called the *dangling else* ambiguity,
    and it can cause problems for parser generators that automatically convert formal
    grammars into parsing code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C标准明确规定，第一种选择是正确的；`<samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>`子句应始终与最接近的`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>`语句组合。然而，语法本身并未告诉我们应选择哪个选项。语法中的这个怪癖被称为*悬挂的else*歧义，它可能会给自动将形式语法转换为解析代码的解析器生成器带来问题。
- en: Luckily, the dangling else ambiguity isn’t an issue for handwritten recursive
    descent parsers like ours. Whenever we parse an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, we’ll look for an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    keyword right after the statement body; if we find one, we’ll go ahead and parse
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause. In cases
    like [Listing 6-4](chapter6.xhtml#list6-4), this means that we’ll end up parsing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause as part of
    the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, which
    is the correct behavior.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，悬挂的else歧义对像我们这样的手写递归下降解析器来说并不是问题。每当我们解析一个`<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>`语句时，我们会在语句主体之后查找一个`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">else</samp>`关键字；如果找到，我们将继续解析`<samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>`子句。在像[Listing
    6-4](chapter6.xhtml#list6-4)这样的情况下，这意味着我们会将`<samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>`子句解析为内层`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>`语句的一部分，这是正确的行为。
- en: Go ahead and implement this production rule now; then, we’ll move on to conditional
    expressions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就实现这个产生规则吧；然后，我们将继续讨论条件表达式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Conditional
    Expressions</samp>
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析条件表达式</samp>
- en: 'The conditional <samp class="SANS_TheSansMonoCd_W5Regular_11">: ?</samp> operator
    is a *ternary* operator, which takes three operands. In [Listing 6-7](chapter6.xhtml#list6-7),
    we add this operator to the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST node.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '条件`<samp class="SANS_TheSansMonoCd_W5Regular_11">: ?</samp>`操作符是一个*三元*操作符，接受三个操作数。在[Listing
    6-7](chapter6.xhtml#list6-7)中，我们将此操作符添加到`<samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>`
    AST节点。'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: The definition
    for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including conditional expressions</samp>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: </samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11"> AST节点的定义，包括条件表达式</samp>'
- en: In [Listing 6-8](chapter6.xhtml#list6-8), we add it to the <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    grammar rule.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 6-8](chapter6.xhtml#list6-8)中，我们将其添加到`<samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>`语法规则中。
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: The grammar rule
    for expressions, including conditional expressions</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: 表达式的语法规则，包括条件表达式</samp>'
- en: 'Now we need to figure out its precedence and associativity. It’s not immediately
    obvious how precedence and associativity work for a ternary expression. The trick
    is to think of it as a binary expression where the operator in the middle is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"?" <exp> ":"</samp>. The “operator” is
    easy to parse because it’s delimited by <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> tokens; it just happens
    to include an entire subexpression. (You should think of it this way only during
    parsing, not during later stages. We can *parse* this like a binary expression,
    but we’ll *evaluate* it completely differently!) This lets us define the conditional
    operator’s precedence relative to other binary operators: it has higher precedence
    than assignment and lower precedence than everything else. For example, the expression'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要弄清楚它的优先级和结合性。对于三元表达式，优先级和结合性如何工作并不显而易见。诀窍是将其视为一个二元表达式，其中中间的操作符是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"?" <exp> ":"</samp>。这个“操作符”容易解析，因为它被
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>
    符号所分隔；它恰好包括了一个完整的子表达式。（你应该仅在解析阶段这样理解它，而不是在后续阶段。我们可以像解析二元表达式那样*解析*它，但我们会以完全不同的方式*评估*它！）这使我们能够定义条件操作符相对于其他二元操作符的优先级：它的优先级高于赋值操作符，低于其他所有操作符。例如，表达式
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: is parsed as
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 被解析为
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: but
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'is parsed as:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 被解析为：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The same logic applies for the third operand. We parse
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的逻辑适用于第三个操作数。我们解析为
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: as
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: but we parse
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们解析为
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'as:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The semantic analysis pass will reject this last expression, since <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    ? 2 : a</samp> isn’t a valid lvalue. However, any expression can appear between
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>
    tokens, even an assignment expression. Those tokens act like parentheses, delimiting
    where an expression starts and ends. So, the conditional expression'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '语义分析阶段会拒绝这个最后的表达式，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1 ? 2 :
    a</samp> 不是一个有效的左值。然而，任何表达式都可以出现在 <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> 符号之间，甚至是赋值表达式。这些符号像括号一样，限定了表达式的开始和结束位置。所以，条件表达式'
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'is equivalent to:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The same logic applies when you nest one conditional expression inside another,
    meaning
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个条件表达式嵌套在另一个条件表达式内时，逻辑同样适用，这意味着
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'is parsed as:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 被解析为：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, let’s look at associativity. The conditional operator is right-associative,
    so
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下结合性。条件操作符是右结合的，所以
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'is parsed as:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 被解析为：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since conditional expressions can be parsed like weird binary expressions, we
    can (almost) handle them with our existing precedence climbing code. First, we’ll
    add <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> to our precedence table;
    [Table 6-1](chapter6.xhtml#tab6-1) lists all our precedence values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于条件表达式可以像奇怪的二元表达式一样被解析，我们几乎可以用现有的优先级爬升代码处理它们。首先，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    添加到我们的优先级表中；[表 6-1](chapter6.xhtml#tab6-1)列出了所有的优先级值。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp> <samp class="SANS_Futura_Std_Book_11">Precedence
    Values of Binary and Ternary Operators</samp>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 6-1：</samp> <samp class="SANS_Futura_Std_Book_11">二元和三元操作符的优先级值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp>
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">操作符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">优先级</samp>
    |'
- en: '| --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp> | <samp
    class="SANS_Futura_Std_Book_11">5</samp> |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp> | <samp
    class="SANS_Futura_Std_Book_11">5</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp>
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
- en: We look at only the first token of the <samp class="SANS_TheSansMonoCd_W5Regular_11">?
    <exp> :</samp> “operator” during precedence climbing, so <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    goes in the table but <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> doesn’t.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在优先级爬升中，我们只考虑 <samp class="SANS_TheSansMonoCd_W5Regular_11">? <exp> :</samp>
    的“操作符”的第一个标记，所以 <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> 放在表中而 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp> 不放。
- en: Next, we’ll update our precedence climbing code again. In the previous chapter,
    we handled assignment as a special case so we could use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    AST node for it. Now we’ll treat conditional expressions as a special case too.
    [Listing 6-9](chapter6.xhtml#list6-9) shows the updated precedence climbing pseudocode.
    Changes from the previous version of this algorithm, in [Listing 5-8](chapter5.xhtml#list5-8),
    are bolded.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将再次更新我们的优先级爬升代码。在上一章中，我们将赋值作为特殊情况处理，以便我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    AST 节点。现在，我们也将条件表达式视为特殊情况处理。[列表 6-9](chapter6.xhtml#list6-9) 显示了更新后的优先级爬升伪代码。与此算法的上一个版本，[列表
    5-8](chapter5.xhtml#list5-8)，相比，已经用粗体标记出来。
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: Precedence climbing
    with support for conditional expressions</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-9：支持条件表达式的优先级爬升</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_conditional_middle</samp>
    function, which I haven’t included code for here, should just consume the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp> token, then parse an expression
    (with the minimum precedence reset to 0), then consume the <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>
    token. Next, we parse the third operand the same way we parse the right-hand side
    of any other expression: by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    recursively. Since the conditional operator is right-associative, like assignment,
    we set the minimum precedence on the recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp>,
    not <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Finally, we construct a <samp class="SANS_TheSansMonoCd_W5Regular_11">Conditional</samp>
    AST node from our three operands.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_conditional_middle</samp>，这里没有包含代码，应该只消耗
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> 标记，然后解析表达式（将最小优先级重置为 0），然后消耗
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> 标记。接下来，我们像解析其他表达式的右侧一样解析第三个操作数：通过递归调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>。由于条件运算符是右结合的，就像赋值一样，我们在递归调用中将最小优先级设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp>，而不是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。最后，我们从这三个操作数构造一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Conditional</samp> AST 节点。
- en: '[Listing 6-10](chapter6.xhtml#list6-10) gives the complete AST definition,
    with the changes to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions bolded. These are the same changes we introduced
    earlier in this section; I’ve pulled them all together here for easier reference.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-10](chapter6.xhtml#list6-10)给出了完整的AST定义，支持<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句和条件表达式的更改已加粗。这些更改与本节早些时候介绍的更改相同；我把它们整理在这里，便于参考。'
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-10: The abstract
    syntax tree with conditional expressions and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-10：包含条件表达式和</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">语句的抽象语法树</samp>
- en: '[Listing 6-11](chapter6.xhtml#list6-11) shows the corresponding changes to
    the grammar.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-11](chapter6.xhtml#list6-11)展示了相应的语法更改。'
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-11: The grammar with
    conditional expressions and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-11：包含条件表达式和</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">语句的语法</samp>
- en: Once you’ve implemented these changes, you’re ready to test your parser.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你实现了这些更改，你就可以开始测试你的解析器了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variable Resolution</samp>
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">变量解析</samp>
- en: The changes to this pass are minor. You’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> to handle
    the new constructs we added in this chapter, traversing their substatements and
    subexpressions. That will update variable names in <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions in exactly the same way as variables that
    appear in other constructs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这次修改较小。你将扩展<samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>，以处理我们在本章中添加的新结构，遍历它们的子语句和子表达式。这将以与其他结构中的变量相同的方式更新<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句和条件表达式中的变量名。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY生成</samp>
- en: 'We can implement <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements
    and conditional expressions with our existing TACKY instructions. We’ll use the
    same basic approach here as for the short-circuiting <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators in [Chapter
    4](chapter4.xhtml): first we’ll evaluate the controlling expression, then we’ll
    use conditional jumps to go to the appropriate clause of the statement or expression.
    Let’s implement <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements
    first.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用现有的TACKY指令实现<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句和条件表达式。我们将在这里使用与[第4章](chapter4.xhtml)中短路运算符<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>相同的基本方法：首先我们会评估控制表达式，然后使用条件跳转去到语句或表达式的相应分支。让我们先实现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting if Statements
    to TACKY</samp>
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将if语句转换为TACKY</samp>
- en: A statement of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">if (</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)
    then</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement></samp>
    should translate to the TACKY in [Listing 6-12](chapter6.xhtml#list6-12).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为<samp class="SANS_TheSansMonoCd_W5Regular_11">if (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">) then</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement></samp>的语句应该转换为[清单
    6-12](chapter6.xhtml#list6-12)中的TACKY。
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-12: The TACKY for
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-12：用于</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">语句的TACKY</samp>
- en: That’s it! First, we evaluate the controlling expression, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>.
    If the result is 0, we jump to the end of the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. Otherwise, we execute the instructions for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement></samp>.
    If the statement also has an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    clause, the resulting TACKY is only a tiny bit more complicated. The statement
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">) then</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement2></samp>
    translates to the TACKY in [Listing 6-13](chapter6.xhtml#list6-13).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！首先，我们评估控制表达式，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>。如果结果为0，我们跳到整个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句的结尾。否则，我们执行 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement></samp>
    中的指令。如果语句还有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 子句，那么生成的
    TACKY 就会稍微复杂一些。语句 <samp class="SANS_TheSansMonoCd_W5Regular_11">if (</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)
    then</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement2></samp>
    转换为 [清单6-13](chapter6.xhtml#list6-13) 中的 TACKY。
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-13: The TACKY for
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    with an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">clause</samp>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单6-13：带有</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句和</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">子句的TACKY</samp>
- en: Just like in [Listing 6-12](chapter6.xhtml#list6-12), we evaluate the controlling
    expression, then perform a conditional jump if the result is 0\. But instead of
    jumping to the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, in this case we jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">else_label</samp>,
    then execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement2></samp>.
    If the controlling expression evaluates to a nonzero value, we execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement1></samp>,
    then jump to the end of the entire statement. We can handle conditional expressions
    in a similar way; we’ll look at those next.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 [清单6-12](chapter6.xhtml#list6-12) 中一样，我们先评估控制表达式，然后在结果为0时执行条件跳转。但与跳到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句的结尾不同，在这种情况下，我们跳到 <samp class="SANS_TheSansMonoCd_W5Regular_11">else_label</samp>，然后执行
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement2></samp>。如果控制表达式评估为非零值，我们执行
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement1></samp>，然后跳到整个语句的结尾。我们可以以类似的方式处理条件表达式；接下来我们将看看这些。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Conditional
    Expressions to TACKY</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将条件表达式转换为TACKY</samp>
- en: For conditional expressions, like short-circuiting expressions, the C standard
    provides guarantees about which subexpressions are executed and when. To evaluate
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>,
    you have to evaluate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    first, then evaluate either <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>, depending
    on the result of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>.
    You can’t, for example, evaluate both clauses, then evaluate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    to decide which result to use, since that might produce unexpected side effects.
    The upshot is that we’ll handle conditional expressions very similarly to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. The only difference
    is that an expression, unlike a statement, produces a result that we need to store
    in the right destination. The expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><e1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><e2></samp>
    will produce the TACKY in [Listing 6-14](chapter6.xhtml#list6-14).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条件表达式，像短路表达式一样，C标准提供了关于哪些子表达式会被执行以及执行时机的保证。要评估表达式 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>，你必须首先评估
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>，然后根据
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp> 的结果，评估
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp> 中的一个。例如，你不能先评估两个子句，然后再评估
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp> 来决定使用哪个结果，因为那可能会产生意外的副作用。结果是，我们将非常类似于处理
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句的方式来处理条件表达式。唯一的区别是，表达式与语句不同，它会产生一个需要存储到正确目标位置的结果。表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><e1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><e2></samp>
    将生成 [列表 6-14](chapter6.xhtml#list6-14) 中的TACKY。
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-14: The TACKY for
    a conditional expression</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-14：用于条件表达式的TACKY</samp>
- en: This looks almost exactly like the TACKY in [Listing 6-13](chapter6.xhtml#list6-13).
    The only difference is that we end each clause by copying the result into the
    temporary <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> variable.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来几乎与 [列表 6-13](chapter6.xhtml#list6-13) 中的TACKY 完全相同。唯一的区别是我们在每个子句结束时将结果复制到临时
    <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> 变量中。
- en: As usual, all the labels and temporary variable names you generate while handling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional
    expressions should be unique. Once your TACKY generation stage is working, you’ll
    be able to compile this chapter’s test cases.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，在处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句和条件表达式时，你生成的所有标签和临时变量名应该是唯一的。一旦你的TACKY生成阶段工作正常，你就可以编译本章的测试用例。
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Labeled Statements and
    goto</samp>'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">额外积分：带标签的语句和goto</samp>
- en: Now that you have some practice adding new kinds of statements, you have the
    option to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>,
    the statement everyone loves to hate. You’ll also need to add support for labeled
    statements so that <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> has
    somewhere to go to. You can implement these two statements without changing anything
    after the TACKY generation stage; however, you’ll need to detect a few new error
    cases, like using the same label for two labeled statements in the same function.
    I recommend writing a new semantic analysis pass to catch these errors, rather
    than trying to catch them in the variable resolution stage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一些添加新类型语句的经验，你可以选择实现<samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>，这是一个大家又爱又恨的语句。你还需要添加对标签语句的支持，以便<samp
    class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>能跳转到某个地方。你可以在TACKY生成阶段之后实现这两种语句，而无需更改任何内容；但是，你需要检测一些新的错误情况，比如在同一个函数中为两个标签语句使用相同的标签。我建议编写一个新的语义分析过程来捕捉这些错误，而不是在变量解析阶段尝试捕捉它们。
- en: 'To test out this feature, run the test script with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--goto</samp>
    flag:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个功能，请运行测试脚本并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">--goto</samp>标志：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you’ve implemented the extra credit features in the previous chapters as
    well, you can test all of them at once by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在前面的章节中也实现了额外加分功能，你可以通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>标志一次性测试所有功能。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: You’ve just implemented your first control structures! All your work in the
    early chapters is starting to pay off. The basic TACKY instructions you added
    to support <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    let you easily implement the more complex features in this chapter. You also built
    on the parsing techniques you learned earlier, extending your precedence climbing
    code to handle ternary operators. But the sorts of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements you can compile are still very limited; you can’t declare variables
    or execute longer blocks of code in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement body. In the next chapter, you’ll remove those limitations by adding
    support for compound statements. The most exciting changes will be in the semantic
    analysis stage, where you’ll learn how to deal with nested scopes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚实现了第一个控制结构！你在早期章节中所做的所有工作开始发挥作用了。你为了支持<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">||</samp>所添加的基本TACKY指令让你可以轻松实现本章节中的更复杂功能。你还建立了在之前学习的解析技术的基础上，扩展了优先级提升代码来处理三元运算符。但是，你能编译的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句仍然非常有限；你不能在<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句的主体中声明变量或执行更长的代码块。在下一章中，你将通过添加对复合语句的支持来消除这些限制。最令人兴奋的变化将在语义分析阶段，你将学习如何处理嵌套作用域。
