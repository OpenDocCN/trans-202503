- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Exploiting Authorization
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 利用授权漏洞
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'In this chapter, we will cover two authorization vulnerabilities: BOLA and
    BFLA. These vulnerabilities reveal weaknesses in the authorization checks that
    ensure authenticated users are only able to access their own resources or use
    functionality that aligns with their permission level. In the process, we’ll discuss
    how to identify resource IDs, use A-B and A-B-A testing, and speed up your testing
    with Postman and Burp Suite.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍两种授权漏洞：BOLA 和 BFLA。这些漏洞暴露了授权检查的弱点，授权检查确保经过身份验证的用户只能访问他们自己的资源或使用与其权限级别相匹配的功能。在此过程中，我们将讨论如何识别资源
    ID，使用 A-B 和 A-B-A 测试，以及如何通过 Postman 和 Burp Suite 加速测试。
- en: Finding BOLAs
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找 BOLA 漏洞
- en: 'BOLA continues to be one of the most prominent API-related vulnerabilities,
    but it can also be one of the easiest to test for. If you see that the API lists
    resources following a certain pattern, you can test other instances using that
    pattern. For instance, say you notice that after making a purchase, the app uses
    an API to provide you with a receipt at the following location: */api/v1/receipt/135*.
    Knowing this, you could then check for other numbers by using 135 as the payload
    position in Burp Suite or Wfuzz and changing 135 to numbers between 0 and 200\.
    This was exactly what we did in the Chapter 4 lab when testing *reqres.in* for
    the total number of user accounts.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: BOLA 仍然是最突出的与 API 相关的漏洞之一，但它也可能是最容易测试的漏洞之一。如果你看到 API 列出了遵循某种模式的资源，你可以使用该模式测试其他实例。例如，假设你注意到在完成购买后，应用程序通过
    API 在以下位置提供收据：*/api/v1/receipt/135*。知道这一点后，你可以通过在 Burp Suite 或 Wfuzz 中使用 135 作为负载位置，并将
    135 更改为 0 到 200 之间的数字来检查其他数字。这正是我们在第 4 章实验中对 *reqres.in* 进行用户账户总数测试时所做的。
- en: This section will cover additional considerations and techniques pertinent to
    hunting for BOLA. When you’re on the hunt for BOLA vulnerabilities, remember that
    they aren’t only found using GET requests. Attempt to use all possible methods
    to interact with resources you shouldn’t be authorized to access. Likewise, vulnerable
    resource IDs aren’t limited to the URL path. Make sure to consider other possible
    locations to check for BOLA weaknesses, including the body of the request and
    headers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍与寻找 BOLA 漏洞相关的其他考虑因素和技术。在寻找 BOLA 漏洞时，请记住，它们不仅仅是通过 GET 请求发现的。尝试使用所有可能的方法与你不应该有权限访问的资源进行交互。同样，易受攻击的资源
    ID 不仅仅局限于 URL 路径。确保考虑其他可能的位置来检查 BOLA 漏洞，包括请求的主体和头部。
- en: Locating Resource IDs
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位资源 ID
- en: 'So far, this book has illustrated BOLA vulnerabilities using examples like
    performing sequential requests for resources:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书已经通过类似顺序请求资源的例子演示了 BOLA 漏洞：
- en: '`GET /api/v1/user/account/``1111`'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET /api/v1/user/account/``1111`'
- en: '`GET /api/v1/user/account/``1112`'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET /api/v1/user/account/``1112`'
- en: To test for this vulnerability, you could simply brute-force all account numbers
    within a certain range and check whether requests result in a successful response.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个漏洞，你可以简单地暴力破解某个范围内的所有账户号码，并检查请求是否返回成功响应。
- en: Sometimes, finding instances of BOLA will actually be this straightforward.
    However, to perform thorough BOLA testing, you’ll need to pay close attention
    to the information the API provider is using to retrieve resources, as it may
    not be so obvious. Look for user ID names or numbers, resource ID names or numbers,
    organization ID names or numbers, emails, phone numbers, addresses, tokens, or
    encoded payloads used in requests to retrieve resources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，找到 BOLA 漏洞实际上是如此简单。然而，要进行全面的 BOLA 测试，你需要密切关注 API 提供者用来获取资源的信息，因为这些信息可能并不那么显而易见。查找用户
    ID 名称或号码、资源 ID 名称或号码、组织 ID 名称或号码、电子邮件、电话号码、地址、令牌，或在请求中用于获取资源的编码负载。
- en: Keep in mind that predictable request values don’t make an API vulnerable to
    BOLA; the API is considered vulnerable only when it provides an unauthorized user
    access to the requested resources. Often, insecure APIs will make the mistake
    of validating that the user is authenticated but fail to check whether that user
    is authorized to access the requested resources.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，可预测的请求值并不会让 API 容易受到 BOLA 攻击；只有当 API 允许未经授权的用户访问请求的资源时，API 才被认为是脆弱的。通常，不安全的
    API 会犯一个错误，即验证用户是否已通过身份验证，但未检查该用户是否被授权访问请求的资源。
- en: As you can see in [Table 10-1](#table10-1), there are plenty of ways you can
    attempt to obtain resources you shouldn’t be authorized to access. These examples
    are based on actual successful BOLA findings. In each of these requests, the requester
    used the same UserA token.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表 10-1](#table10-1)所示，你可以尝试多种方式获取你不应有权限访问的资源。这些例子基于实际成功的BOLA发现。在每一个请求中，请求者都使用了相同的UserA令牌。
- en: 'Table 10-1: Valid Requests for Resources and the Equivalent BOLA Test'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '表 10-1: 资源的有效请求及其对应的BOLA测试'
- en: '| **Type** | **Valid request** | **BOLA test** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **有效请求** | **BOLA 测试** |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Predictable ID | `GET /api/v1/account/``2222` `Token: UserA_token` | `GET
    /api/v1/account/``3333` `Token: UserA_token` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 可预测 ID | `GET /api/v1/account/``2222` `Token: UserA_token` | `GET /api/v1/account/``3333`
    `Token: UserA_token` |'
- en: '| ID combo | `GET /api/v1/``UserA``/data`/`2222` `Token: UserA_token` | `GET
    /api/v1/``UserB``/data/``3333` `Token: UserA_token` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| ID 组合 | `GET /api/v1/``UserA``/data`/`2222` `Token: UserA_token` | `GET /api/v1/``UserB``/data/``3333`
    `Token: UserA_token` |'
- en: '| Integer as ID | `POST /api/v1/account/` `Token: UserA_token`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '| 整数作为 ID | `POST /api/v1/account/` `Token: UserA_token`'
- en: '`{"Account":` `2222``}` | `POST /api/v1/account/` `Token: UserA_token`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"Account":` `2222``}` | `POST /api/v1/account/` `Token: UserA_token`'
- en: '`{"Account": [``3333``]}` |'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"Account": [``3333``]}` |'
- en: '| Email as user ID | `POST /api/v1/user/account` `Token: UserA_token`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '| 电子邮件作为用户 ID | `POST /api/v1/user/account` `Token: UserA_token`'
- en: '`{"email": "``UserA@email.com``"}` | `POST /api/v1/user/account` `Token: UserA_token`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"email": "``UserA@email.com``"}` | `POST /api/v1/user/account` `Token: UserA_token`'
- en: '`{"email": "``UserB@email.com``"}` |'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"email": "``UserB@email.com``"}` |'
- en: '| Group ID | `GET /api/v1/group/``CompanyA` `Token: UserA_token` | `GET /api/v1/group/``CompanyB`
    `Token: UserA_token` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 组 ID | `GET /api/v1/group/``CompanyA` `Token: UserA_token` | `GET /api/v1/group/``CompanyB`
    `Token: UserA_token` |'
- en: '| Group and user combo | `POST /api/v1/group/``CompanyA` `Token: UserA_token`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '| 组和用户组合 | `POST /api/v1/group/``CompanyA` `Token: UserA_token`'
- en: '`{"email": "``userA@CompanyA.com``"}` | `POST /api/v1/group/``CompanyB` `Token:
    UserA_token`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"email": "``userA@CompanyA.com``"}` | `POST /api/v1/group/``CompanyB` `Token:
    UserA_token`'
- en: '`{"email": "``userB@CompanyB.com``"}` |'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"email": "``userB@CompanyB.com``"}` |'
- en: '| Nested object | `POST /api/v1/user/checking` `Token: UserA_token`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '| 嵌套对象 | `POST /api/v1/user/checking` `Token: UserA_token`'
- en: '`{"Account":` `2222``}` | `POST /api/v1/user/checking` `Token: UserA_token`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"Account":` `2222``}` | `POST /api/v1/user/checking` `Token: UserA_token`'
- en: '`{"Account":``{"Account" :3333}}` |'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"Account":``{"Account" :3333}}` |'
- en: '| Multiple objects | `POST /api/v1/user/checking` `Token: UserA_token`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '| 多个对象 | `POST /api/v1/user/checking` `Token: UserA_token`'
- en: '`{"Account":` `2222``}` | `POST /api/v1/user/checking` `Token: UserA_token`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"Account":` `2222``}` | `POST /api/v1/user/checking` `Token: UserA_token`'
- en: '`{"Account":` `2222, "Account": 3333, "Account": 5555``}` |'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"Account":` `2222, "Account": 3333, "Account": 5555``}` |'
- en: '| Predictable token | `POST /api/v1/user/account` `Token: UserA_token`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '| 可预测令牌 | `POST /api/v1/user/account` `Token: UserA_token`'
- en: '`{"data": "DflK1df7jSdfa``1ac``aa"}` | `POST /api/v1/user/account` `Token:
    UserA_token`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"data": "DflK1df7jSdfa``1ac``aa"}` | `POST /api/v1/user/account` `Token:
    UserA_token`'
- en: '`{"data": "DflK1df7jSdfa`**2df**`aa"}` |'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"data": "DflK1df7jSdfa`**2df**`aa"}` |'
- en: Sometimes, just requesting the resource won’t be enough; instead, you’ll need
    to request the resource as it was meant to be requested, often by supplying both
    the resource ID and the user’s ID. Thus, due to the nature of how APIs are organized,
    a proper request for resources may require the *ID* *combo* format shown in [Table
    10-1](#table10-1). Similarly, you may need to know the group ID along with the
    resource ID, as in the *group and user combo* format.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，仅请求资源并不足够；你需要以正确的方式请求资源，通常需要同时提供资源 ID 和用户 ID。因此，由于 API 的组织方式，正确的资源请求可能需要如[表
    10-1](#table10-1)所示的*ID* *组合*格式。同样，你可能需要知道组 ID 和资源 ID，就像在*组和用户组合*格式中那样。
- en: '*Nested objects* are a typical structure found in JSON data. These are simply
    additional objects created within an object. Since nested objects are a valid
    JSON format, the request will be processed if user input validation does not prevent
    it. Using a nested object, you could escape or bypass security measures applied
    to the outer key/value pair by including a separate key/value pair within the
    nested object that may not have the same security controls applied to it. If the
    application processes these nested objects, they are an excellent vector for an
    authorization weakness.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*嵌套对象*是 JSON 数据中常见的结构。这些对象是创建在一个对象内部的额外对象。由于嵌套对象是有效的 JSON 格式，只要用户输入验证未阻止，系统会处理该请求。通过使用嵌套对象，你可以通过在嵌套对象中包括一个没有相同安全控制的键/值对，从而绕过或逃避应用于外部键/值对的安全措施。如果应用程序处理这些嵌套对象，它们是授权漏洞的一个优秀载体。'
- en: A-B Testing for BOLA
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A-B 测试中的 BOLA
- en: 'What we call *A-B testing* is the process of creating resources using one account
    and attempting to retrieve those resources as a different account. This is one
    of the best ways to identify how resources are identified and what requests are
    used to obtain them. The A-B testing process looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的*A-B 测试*是通过一个账户创建资源，然后尝试以另一个账户获取这些资源的过程。这是识别资源如何被识别以及用于获取它们的请求的最佳方法之一。A-B
    测试过程如下：
- en: '**Create resources as UserA.** Note how the resources are identified and how
    the resources are requested.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以 UserA 的身份创建资源。** 注意资源如何被识别，以及资源是如何被请求的。'
- en: '**Swap out your UserA token for another user’s token.** In many instances,
    if there is an account registration process, you will be able to create a second
    account (UserB).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将您的 UserA 令牌替换为另一个用户的令牌。** 在许多情况下，如果存在账户注册过程，您将能够创建第二个账户（UserB）。'
- en: '**Using UserB’s token, make the request for UserA’s resources.** Focus on resources
    for private information. Test for any resources that UserB should not have access
    to, such as full name, email, phone number, Social Security number, bank account
    information, legal information, and transaction data.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 UserB 的令牌，发起请求获取 UserA 的资源。** 重点关注私人信息资源。测试任何 UserB 不应访问的资源，如全名、电子邮件、电话号码、社会保障号码、银行账户信息、法律信息和交易数据。'
- en: The scale of this testing is small, but if you can access one user’s resources,
    you could likely access all user resources of the same privilege level.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的规模较小，但如果您能够访问一个用户的资源，您可能能够访问所有同一特权级别用户的资源。
- en: 'A variation on A-B testing is to create three accounts for testing. That way,
    you can create resources in each of the three different accounts, detect any patterns
    in the resource identifiers, and check which requests are used to request those
    resources, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: A-B 测试的一种变体是创建三个账户进行测试。这样，您可以在这三个不同的账户中创建资源，检测资源标识符中的任何模式，并检查哪些请求用于请求这些资源，如下所示：
- en: '**Create multiple accounts at each privilege level to which you have access.**
    Keep in mind that your goal is to test and validate security controls, not destroy
    someone’s business. When performing BFLA attacks, there is a chance you could
    successfully delete the resources of other users, so it helps to limit a dangerous
    attack like this to a test account you create.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在您有权限的每个特权级别上创建多个账户。** 请记住，您的目标是测试和验证安全控制，而不是破坏某人的业务。在执行 BFLA 攻击时，您可能会成功删除其他用户的资源，因此最好将此类危险攻击限制在您创建的测试账户上。'
- en: '**Using your accounts, create a resource with UserA’s account and attempt to
    interact with it using UserB’s.** Use all the methods at your disposal.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用您的账户，在 UserA 的账户中创建一个资源，并尝试使用 UserB 的账户与其交互。** 使用所有可以使用的方法。'
- en: Side-Channel BOLA
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旁路通道 BOLA
- en: One of my favorite methods of obtaining sensitive information from an API is
    through side-channel disclosure. Essentially, this is any information gleaned
    from unexpected sources, such as timing data. In past chapters, we discussed how
    APIs can reveal the existence of resources through middleware like `X-Response-Time`.
    Side-channel discoveries are another reason why it is important to use an API
    as it was intended and develop a baseline of normal responses.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的从 API 获取敏感信息的方法之一是通过旁路通道泄露。实质上，这指的是从意外的来源获取的信息，比如时间数据。在前面的章节中，我们讨论了 API
    如何通过中间件（如 `X-Response-Time`）揭示资源的存在。旁路通道发现是为什么使用 API 按照预期的方式进行并开发正常响应基准的另一个原因。
- en: In addition to timing, you could use response codes and lengths to determine
    if resources exist. For example, if an API responds to nonexistent resources with
    a 404 Not Found but has a different response for existing resources, such as 405
    Unauthorized, you’ll be able to perform a BOLA side-channel attack to discover
    existing resources such as usernames, account IDs, and phone numbers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了时间因素，您还可以使用响应代码和响应长度来判断资源是否存在。例如，如果 API 对不存在的资源返回 404 Not Found，但对存在的资源返回不同的响应，如
    405 Unauthorized，您将能够进行 BOLA 旁路通道攻击，发现现有的资源，如用户名、账户 ID 和电话号码。
- en: '[Table 10-2](#table10-2) gives a few examples of requests and responses that
    could be useful for side-channel BOLA disclosures. If 404 Not Found is a standard
    response for nonexistent resources, the other status codes could be used to enumerate
    usernames, user ID numbers, and phone numbers. These requests provide just a few
    examples of information that could be gathered when the API has different responses
    for nonexistent resources and existing resources that you are not authorized to
    view. If these requests successful, they can result in a serious disclosure of
    sensitive data.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-2](#table10-2)给出了几种可能对侧信道 BOLA 信息泄露有用的请求和响应示例。如果 404 Not Found 是不存在资源的标准响应，那么其他状态码可以用于枚举用户名、用户
    ID 和电话号码。当 API 对不存在的资源和你没有权限查看的现有资源返回不同响应时，这些请求仅提供了可以收集的一些信息示例。如果这些请求成功，它们可能会导致敏感数据的严重泄露。'
- en: 'Table 10-2: Examples of Side-Channel BOLA Disclosures'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '表 10-2: 侧信道 BOLA 信息泄露示例'
- en: '| **Request** | **Response** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **请求** | **响应** |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GET /api/user/test987123` | `404 Not Found HTTP/1.1` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `GET /api/user/test987123` | `404 Not Found HTTP/1.1` |'
- en: '| `GET /api/user/hapihacker` | `405 Unauthorized HTTP/1.1` `{`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '| `GET /api/user/hapihacker` | `405 Unauthorized HTTP/1.1` `{`'
- en: '`}` |'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: '| `GET /api/user/1337` | `405 Unauthorized HTTP/1.1` `{`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '| `GET /api/user/1337` | `405 Unauthorized HTTP/1.1` `{`'
- en: '`}` |'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: '| `GET /api/user/phone/2018675309` | `405 Unauthorized HTTP/1.1` `{`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '| `GET /api/user/phone/2018675309` | `405 Unauthorized HTTP/1.1` `{`'
- en: '`}` |'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: On its own, this BOLA finding may seem minimal, but information like this can
    prove to be valuable in other attacks. For example, you could leverage information
    gathered through a side-channel disclosure to perform brute-force attacks to gain
    entry to valid accounts. You could also use information gathered in a disclosure
    like this to perform other BOLA tests, such as the ID combo BOLA test shown in
    [Table 10-1](#table10-1).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这个 BOLA 漏洞可能显得微不足道，但类似的信息在其他攻击中可能会变得非常有价值。例如，你可以利用通过侧信道信息泄露收集到的信息，进行暴力破解攻击，以便访问有效的账户。你还可以利用这种信息执行其他
    BOLA 测试，比如在[表 10-1](#table10-1)中展示的 ID 组合 BOLA 测试。
- en: Finding BFLAs
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找 BFLA
- en: Hunting for BFLA involves searching for functionality to which you should not
    have access. A BFLA vulnerability might allow you to update object values, delete
    data, and perform actions as other users. To check for it, try to alter or delete
    resources or gain access to functionality that belongs to another user or privilege
    level.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找 BFLA 就是寻找你不该访问的功能。BFLA 漏洞可能允许你更新对象值、删除数据，或者以其他用户的身份执行操作。要检查此漏洞，可以尝试更改或删除资源，或者访问属于其他用户或权限级别的功能。
- en: Note that if you successfully send a DELETE request, you’ll no longer have access
    to the given resource . . . because you’ll have deleted it. For that reason, avoid
    testing for DELETE while fuzzing, unless you’re targeting a test environment.
    Imagine that you send DELETE requests to 1,000 resource identifiers; if the requests
    succeed, you’ll have deleted potentially valuable information, and your client
    won’t be happy. Instead, start your BFLA testing on a small scale to avoid causing
    huge interruptions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你成功发送了 DELETE 请求，你将不再能够访问给定的资源……因为你已将其删除。因此，除非你在测试环境中进行测试，否则在模糊测试时避免进行
    DELETE 测试。假设你向 1,000 个资源标识符发送 DELETE 请求；如果请求成功，你将删除可能有价值的信息，而你的客户端肯定不会高兴。相反，从小规模开始进行
    BFLA 测试，避免造成重大中断。
- en: A-B-A Testing for BFLA
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A-B-A 测试用于 BFLA
- en: 'Like A-B testing for BOLA, A-B-A testing is the process of creating and accessing
    resources with one account and then attempting to alter the resources with another
    account. Finally, you should validate any changes with the original account. The
    A-B-A process should look something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 BOLA 的 A-B 测试一样，A-B-A 测试是指使用一个账户创建和访问资源，然后尝试用另一个账户更改资源。最后，你应该使用原始账户验证任何更改。A-B-A
    测试过程应该是这样的：
- en: '**Create, read, update, or delete resources as UserA.** Note how the resources
    are identified and how the resources are requested.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为 UserA 创建、读取、更新或删除资源。** 注意资源是如何标识的，以及资源是如何被请求的。'
- en: '**Swap out your UserA token for UserB’s.** In instances where there is an account
    registration process, create a second test account.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将你的 UserA 令牌换成 UserB 的。** 如果存在账户注册流程，可以创建第二个测试账户。'
- en: '**Send GET, PUT, POST, and DELETE requests for UserA’s resources using UserB’s
    token.** If possible, alter resources by updating the properties of an object.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 UserB 的令牌发送 GET、PUT、POST 和 DELETE 请求，以访问 UserA 的资源。** 如果可能，通过更新对象的属性来更改资源。'
- en: '**Check UserA’s resources to validate changes have been made by using UserB’s
    token.** Either by using the corresponding web application or by making API requests
    using UserA’s token, check the relevant resources. If, for example, the BFLA attack
    was an attempt to delete UserA’s profile picture, load UserA’s profile to see
    if the picture is missing.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查 UserA 的资源，以验证是否通过 UserB 的令牌进行了更改。** 无论是使用相应的 Web 应用程序，还是通过使用 UserA 的令牌发送
    API 请求，都需要检查相关资源。例如，如果 BFLA 攻击是试图删除 UserA 的个人资料图片，则加载 UserA 的个人资料，查看图片是否丢失。'
- en: In addition to testing authorization weaknesses at a single privilege level,
    ensure that you check for weaknesses at other privilege levels. As previously
    discussed, APIs could have all sorts of different privilege levels, such as basic
    user, merchant, partner, and admin. If you have access to accounts at the various
    privilege levels, your A-B-A testing can take on a new layer. Try making UserA
    an administrator and UserB a basic user. If you’re able to exploit BLFA in that
    situation, it will have become a privilege escalation attack.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在单一权限级别下测试授权漏洞外，还需确保检查其他权限级别的漏洞。如前所述，API 可能具有各种不同的权限级别，例如普通用户、商户、合作伙伴和管理员。如果你能够访问不同权限级别的帐户，那么你的
    A-B-A 测试可以增加新的层次。尝试将 UserA 设置为管理员，将 UserB 设置为普通用户。如果你能够在这种情况下利用 BLFA，那么它就会变成权限升级攻击。
- en: Testing for BFLA in Postman
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Postman 中测试 BFLA
- en: 'Begin your BFLA testing with authorized requests for UserA’s resources. If
    you were testing whether you could modify another user’s pictures in a social
    media app, a simple request like the one shown in [Listing 10-1](#listing10-1)
    would do:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从授权请求 UserA 资源开始你的 BFLA 测试。如果你正在测试是否能够修改社交媒体应用中其他用户的图片，像 [清单 10-1](#listing10-1)
    中显示的那样发送一个简单的请求就足够了：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 10-1: Sample request for BFLA testing'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-1：BFLA 测试的示例请求
- en: This request tells us that resources are identified by numeric values in the
    path. Moreover, the response, shown in [Listing 10-2](#listing10-2), indicates
    that the username of the resource (`"UserA"`) matches the request token.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求告诉我们，资源是通过路径中的数字值来识别的。此外，如 [清单 10-2](#listing10-2) 所示，响应表明资源的用户名（`"UserA"`）与请求令牌匹配。
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 10-2: Sample response from a BFLA test'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-2：BFLA 测试的示例响应
- en: Now, given that this is a social media platform where users can share pictures,
    it wouldn’t be too surprising if another user had the ability to send a successful
    GET request for picture 2\. This isn’t an instance of BOLA but rather a feature.
    However, UserB shouldn’t be able to delete pictures that belong to UserA. That
    is where we cross into a BFLA vulnerability.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，鉴于这是一个用户可以共享图片的社交媒体平台，如果其他用户能够成功发送一个 GET 请求来获取图片 2，这并不令人惊讶。这不是 BOLA 的实例，而是一个功能特性。然而，UserB
    不应能够删除属于 UserA 的图片。这就是我们跨入 BFLA 漏洞的地方。
- en: In Postman, try sending a DELETE request for UserA’s resource containing UserB’s
    token. As you see in [Figure 10-1](#figure10-1), a DELETE request using UserB’s
    token was able to successfully delete UserA’s picture. To validate that the picture
    was deleted, send a follow-up GET request for `picture_id=2`, and you will confirm
    that UserA’s picture with the ID of 2 no longer exists. This is a very important
    finding, since a single malicious user could easily delete all other users’ resources.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Postman 中，尝试发送一个 DELETE 请求，删除包含 UserB 令牌的 UserA 资源。如 [图 10-1](#figure10-1)
    所示，使用 UserB 令牌的 DELETE 请求能够成功删除 UserA 的图片。为了验证图片是否已删除，发送后续的 GET 请求，查询 `picture_id=2`，你会确认
    UserA 的 ID 为 2 的图片不再存在。这是一个非常重要的发现，因为单个恶意用户可能轻易删除所有其他用户的资源。
- en: '![screenshot of postman that shows photo 2 has been deleted successfully](image_fi/502444c10/F10001.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 截图，显示照片 2 已成功删除](image_fi/502444c10/F10001.png)'
- en: 'Figure 10-1: Successful BFLA attack with Postman'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：使用 Postman 成功进行 BFLA 攻击
- en: You can simplify the process of finding privilege escalation–related BFLA vulnerabilities
    if you have access to documentation. Alternatively, you might find administrative
    actions clearly labeled in a collection, or you might have reverse engineered
    administrative functionality. If this isn’t the case, you’ll need to fuzz for
    admin paths.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有文档访问权限，找出与权限升级相关的 BFLA 漏洞会更为简便。或者，你可能会在集合中找到清晰标注的管理操作，或者你可能已经反向工程了管理功能。如果不是这种情况，你需要对管理员路径进行模糊测试。
- en: One of the simplest ways to test for BFLA is to make administrative requests
    as a low-privileged user. If an API allows administrators to search for users
    with a POST request, try making that exact admin request to see if any security
    controls are in place to prevent you from succeeding. Look at the request in [Listing
    10-3](#listing10-3). In the response ([Listing 10-4](#listing10-4)), we see that
    the API did not have any such restrictions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试BFLA最简单的方法之一是以低权限用户身份发出管理请求。如果一个API允许管理员通过POST请求搜索用户，尝试发出相同的管理员请求，看看是否有任何安全控制措施阻止你成功。查看[清单
    10-3](#listing10-3)中的请求。在[清单 10-4](#listing10-4)的响应中，我们看到API并没有做出此类限制。
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 10-3: Request for user information'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-3：请求用户信息
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 10-4: Response with user information'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-4：带有用户信息的响应
- en: The ability to search for users and gain access to another user’s sensitive
    information was meant to be restricted to only those with an administrative token.
    However, by making a request to the */admin/find/user* endpoint, you can test
    to see if there is any technical enforcement. Since this is an administrative
    request, a successful response could also provide sensitive information, such
    as a user’s full name, balance, and personal identification number (PIN).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索用户并获取另一个用户的敏感信息本应仅限于持有管理员令牌的人员。然而，通过请求*/admin/find/user*端点，你可以测试是否存在任何技术性限制。由于这是一个管理请求，成功响应可能还会提供敏感信息，比如用户的全名、余额和个人识别号码（PIN）。
- en: If restrictions are in place, try changing the request method. Use a POST request
    instead of a PUT request, or vice versa. Sometimes an API provider has secured
    one request method from unauthorized requests but has overlooked another.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在限制，可以尝试更改请求方法。使用POST请求代替PUT请求，或反之。有时API提供者会针对某一种请求方法做出授权保护，但可能忽略了另一种方法。
- en: Authorization Hacking Tips
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权绕过技巧
- en: 'Attacking a large-scale API with hundreds of endpoints and thousands of unique
    requests can be fairly time-consuming. The following tactics should help you test
    for authorization weaknesses across an entire API: using Collection variables
    in Postman and using the Burp Suite Match and Replace feature.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击一个拥有数百个端点和成千上万独特请求的大型API可能非常耗时。以下策略应有助于你在整个API中测试授权漏洞：在Postman中使用集合变量，和使用Burp
    Suite的匹配与替换功能。
- en: Postman’s Collection Variables
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Postman的集合变量
- en: As you would when fuzzing wide, you can use Postman to perform variable changes
    across a collection, setting the authorization token for your collection as a
    variable. Begin by testing various requests for your resources to make sure they
    work properly as UserA. Then replace the token variable with the UserB token.
    To help you find anomalous responses, use a Collection test to locate 200 response
    codes or the equivalent for your API.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就像进行广泛模糊测试时一样，你可以使用Postman对一个集合中的变量进行修改，将你的授权令牌设置为集合变量。首先测试你的资源的各种请求，确保它们在UserA身份下正常工作。然后将令牌变量替换为UserB的令牌。为了帮助你找到异常响应，使用集合测试来定位200响应码或API的等效响应。
- en: In Collection Runner, select only the requests that are likely to contain authorization
    vulnerabilities. Good candidate requests include those that contain private information
    belonging to UserA. Launch the Collection Runner and review the results. When
    checking results, look for instances in which the UserB token results in a successful
    response. These successful responses will likely indicate either BOLA or BFLA
    vulnerabilities and should be investigated further.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合运行器中，仅选择那些可能包含授权漏洞的请求。好的候选请求包括那些包含属于UserA的私人信息的请求。启动集合运行器并检查结果。检查结果时，留意那些UserB令牌能够返回成功响应的实例。这些成功响应可能表示BOLA或BFLA漏洞，应该进一步调查。
- en: Burp Suite Match and Replace
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Burp Suite 匹配与替换
- en: When you’re attacking an API, your Burp Suite history will populate with unique
    requests. Instead of sifting through each request and testing it for authorization
    vulnerabilities, use the Match and Replace option to perform a large-scale replacement
    of a variable like an authorization token.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你攻击一个API时，你的Burp Suite历史记录将会填充上独特的请求。与其筛选每个请求并对其进行授权漏洞测试，不如使用匹配与替换选项，进行大规模的变量替换，比如替换授权令牌。
- en: Begin by collecting several requests in your history as UserA, focusing on actions
    that should require authorization. For instance, focus on requests that involve
    a user’s account and resources. Next, match and replace the authorization headers
    with UserB’s and repeat the requests (see [Figure 10-2](#figure10-2)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，作为UserA收集你历史中的几个请求，重点关注那些应该需要授权的操作。例如，关注涉及用户账户和资源的请求。接下来，将授权头替换为UserB的，并重复这些请求（参见[图10-2](#figure10-2)）。
- en: '![screenshot of burp suite’s match and replace tool (found under proxy > options)
    that shows tokena being replaced with tokenb](image_fi/502444c10/F10002.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite的匹配与替换工具截图（在proxy > options下找到），显示tokena被tokenb替换](image_fi/502444c10/F10002.png)'
- en: 'Figure 10-2: Burp Suite’s Match and Replace feature'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2：Burp Suite的匹配与替换功能
- en: Once you find an instance of BOLA or BFLA, try to exploit it for all users and
    related resources.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你发现了BOLA或BFLA漏洞，尝试利用它来获取所有用户和相关资源的信息。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a close look at techniques for attacking common weaknesses
    in API authorization. Since each API is unique, it’s important not only to figure
    out how resources are identified but also to make requests for resources that
    don’t belong to the account you’re using.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们详细查看了攻击API授权常见弱点的技术。由于每个API都是独一无二的，重要的不仅是弄清楚资源是如何标识的，还要发出请求，访问不属于你当前账户的资源。
- en: Authorization can lead to some of the most severe consequences. A BOLA vulnerability
    could allow an attacker to compromise an organization’s most sensitive information,
    whereas a BFLA vulnerability could allow you to escalate privileges or perform
    unauthorized actions that could compromise an API provider.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 授权漏洞可能会导致一些最严重的后果。BOLA漏洞可能允许攻击者泄露组织的最敏感信息，而BFLA漏洞则可能允许你提升权限或执行未经授权的操作，从而危及API提供者。
- en: 'Lab #7: Finding Another User’s Vehicle Location'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验#7：查找另一个用户的车辆位置
- en: In this lab, we’ll search crAPI to discover the resource identifiers in use
    and test whether we can gain unauthorized access to another user’s data. In doing
    so, we’ll see the value of combining multiple vulnerabilities to increase the
    impact of an attack. If you’ve followed along in the other labs, you should have
    a crAPI Postman collection containing all sorts of requests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们将搜索crAPI以发现正在使用的资源标识符，并测试我们是否能未经授权访问另一个用户的数据。在此过程中，我们将看到将多个漏洞结合起来以增强攻击影响力的价值。如果你已经完成了其他实验，你应该已经有一个包含各种请求的crAPI
    Postman集合。
- en: 'You may notice that the use of resource IDs is fairly light. However, one request
    does include a unique resource identifier. The “refresh location” button at the
    bottom of the crAPI dashboard issues the following request:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，资源ID的使用相对较轻。然而，有一个请求确实包含了一个独特的资源标识符。crAPI仪表板底部的“刷新位置”按钮发出了以下请求：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This request takes the user’s GUID and requests the current location of the
    user’s vehicle. The location of another user’s vehicle sounds like sensitive information
    worth collecting. We should see if the crAPI developers depend on the complexity
    of the GUID for authorization or if there are technical controls making sure users
    can only check the GUID of their own vehicle.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求获取用户的GUID并请求用户车辆的当前位置。另一个用户车辆的位置听起来像是值得收集的敏感信息。我们应该检查crAPI开发者是否依赖GUID的复杂性来进行授权，或者是否有技术控制确保用户只能查看自己车辆的GUID。
- en: So the question is, how should you perform this test? You might want to put
    your fuzzing skills from Chapter 9 to use, but an alphanumeric GUID of this length
    would take an impossible amount of time to brute-force. Instead, you can obtain
    another existing GUID and use it to perform A-B testing. To do this, you will
    need to register for a second account, as shown in [Figure 10-3](#figure10-3).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题是，你应该如何执行这个测试呢？你可能想利用第9章中的模糊测试技巧，但如此长度的字母数字GUID需要极其巨大的时间来进行暴力破解。相反，你可以获取另一个现有的GUID，并用它进行A-B测试。为了做到这一点，你需要注册一个第二个帐户，如[图10-3](#figure10-3)所示。
- en: '![screenshot of crapi’s new user sign-up window](image_fi/502444c10/F10003.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![crapi新用户注册窗口的截图](image_fi/502444c10/F10003.png)'
- en: 'Figure 10-3: Registering UserB with crAPI'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3：在crAPI中注册UserB
- en: In [Figure 10-3](#figure10-3), you can see that we’ve created a second account,
    called UserB. With this account, go through the steps to register a vehicle using
    MailHog. As you may remember, back in the Chapter 6 lab we performed reconnaissance
    and discovered some other open ports associated with crAPI. One of these was port
    8025, which is where MailHog is located.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 10-3](#figure10-3)中，你可以看到我们创建了第二个账户，名为UserB。使用这个账户，按照步骤通过MailHog注册一辆车。正如你可能记得的，在第6章的实验中，我们进行了侦查并发现了一些与crAPI相关的开放端口。其中一个端口是8025，MailHog就位于这个端口。
- en: As an authenticated user, click the **Click Here** link on the dashboard, as
    seen in [Figure 10-4](#figure10-4). This will generate an email with your vehicle’s
    information and send it to your MailHog account.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为已认证用户，点击仪表板上的**点击这里**链接，如[图 10-4](#figure10-4)所示。这将生成一封包含你车辆信息的邮件，并将其发送到你的MailHog账户。
- en: '![screenshot of crapi’s new user dashboard that states “no vehicles found”
    under vehicles details. within this message is a clickable button labeled “click
    here.”](image_fi/502444c10/F10004.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![crAPI新用户仪表板的截图，显示“未找到车辆”在车辆详情下，信息中包含一个可点击的按钮标为“点击这里”](image_fi/502444c10/F10004.png)'
- en: 'Figure 10-4: A crAPI new user dashboard'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4：crAPI新用户仪表板
- en: 'Update the URL in the address bar to visit port 8025 using the following format:
    *http://yourIPaddress:8025*. Once in MailHog, open the “Welcome to crAPI” email
    (see [Figure 10-5](#figure10-5)).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 更新地址栏中的URL，使用以下格式访问端口8025：*http://yourIPaddress:8025*。进入MailHog后，打开“Welcome
    to crAPI”邮件（参见[图 10-5](#figure10-5)）。
- en: '![screenshot of “welcome to crapi” email in mailhog that states your vehicle’s
    vin and pincode](image_fi/502444c10/F10005.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![MailHog中“欢迎使用crAPI”邮件的截图，邮件中包含你车辆的vin和pincode信息](image_fi/502444c10/F10005.png)'
- en: 'Figure 10-5: The crAPI MailHog email service'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-5：crAPI MailHog邮件服务
- en: Take the VIN and pincode information provided in the email and use that to register
    your vehicle back on the crAPI dashboard by clicking the **Add a Vehicle** button.
    This results in the window shown in [Figure 10-6](#figure10-6).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 获取邮件中提供的VIN和pincode信息，并使用这些信息通过点击**添加车辆**按钮重新在crAPI仪表板上注册你的车辆。这将导致[图 10-6](#figure10-6)所示的窗口。
- en: '![screenshot of crapi’s add a vehicle window that has boxes to type in the
    vehicle’s pin code and vin](image_fi/502444c10/F10006.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![crAPI添加车辆窗口的截图，窗口中有框可以输入车辆的pin代码和vin](image_fi/502444c10/F10006.png)'
- en: 'Figure 10-6: The crAPI Vehicle Verification screen'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-6：crAPI车辆验证屏幕
- en: 'Once you’ve registered the UserB vehicle, capture a request using the **Refresh
    Location** button. It should look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你注册了UserB的车辆，点击**刷新位置**按钮捕获请求。它应该像这样：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that you have UserB’s GUID, you can swap out the UserB Bearer token and
    send the request with UserA’s bearer token. [Listing 10-5](#listing10-5) shows
    the request, and [Listing 10-6](#listing10-6) shows the response.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了UserB的GUID，你可以替换掉UserB的Bearer token，并使用UserA的Bearer token发送请求。[列表 10-5](#listing10-5)显示了请求，[列表
    10-6](#listing10-6)显示了响应。
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 10-5: A BOLA attempt'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-5：BOLA攻击
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 10-6: Response to the BOLA attempt'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-6：对BOLA攻击的响应
- en: 'Congratulations, you’ve discovered a BOLA vulnerability. Perhaps there is a
    way to discover the GUIDs of other valid users to take this finding to the next
    level. Well, remember that, in Chapter 7, an intercepted GET request to */community/api/v2/community/posts/recent*
    resulted in an excessive data exposure. At first glance, this vulnerability did
    not seem to have severe consequences. However, we now have plenty of use for the
    exposed data. Take a look at the following object from that excessive data exposure:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，发现了BOLA漏洞。也许有办法发现其他有效用户的GUID，将这一发现提升到新的层次。好吧，记住在第7章中，拦截的GET请求到*/community/api/v2/community/posts/recent*导致了数据过度曝光。乍一看，这个漏洞似乎没有严重的后果。然而，现在我们可以充分利用这些暴露的数据。看看从过度数据暴露中得到的以下对象：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This data reveals a `vehicleid` that closely resembles the GUID used in the
    Refresh Location request. Substitute these GUIDs using UserA’s token. [Listing
    10-7](#listing10-7) shows the request, and [Listing 10-8](#listing10-8) shows
    the response.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据揭示了一个`vehicleid`，它与刷新位置请求中使用的GUID非常相似。用UserA的token替换这些GUID。[列表 10-7](#listing10-7)显示了请求，[列表
    10-8](#listing10-8)显示了响应。
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 10-7: A request for another user’s GUID'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-7：请求另一个用户的GUID
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 10-8: The response'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-8：响应
- en: Sure enough, you can exploit the BOLA vulnerability to discover the location
    of the user’s vehicle. Now you’re one Google Maps search away from discovering
    the user’s exact location and gaining the ability to track any user’s vehicle
    location over time. Combining vulnerability findings, as you do in this lab, will
    make you a master API hacker.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，你可以利用BOLA漏洞来发现用户车辆的位置。现在，你只需通过一次Google地图搜索，就能发现用户的确切位置，并获得随时间追踪任何用户车辆位置的能力。像本实验中一样结合漏洞发现，将使你成为一名API黑客大师。
