- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: CROSS-SITE SCRIPTING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本（XSS）**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: One of the most famous examples of a *cross-site scripting (XSS)* vulnerability
    is the Myspace Samy Worm created by Samy Kamkar. In October 2005, Kamkar exploited
    a vulnerability on Myspace that allowed him to store a JavaScript payload on his
    profile. Whenever a logged-in user would visit his Myspace profile, the payload
    code would execute, making the viewer Kamkar’s friend on Myspace and updating
    the viewer’s profile to display the text “but most of all, samy is my hero.” Then
    the code would copy itself to the viewer’s profile and continue infecting other
    Myspace user pages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*跨站脚本（XSS）*漏洞的最著名例子之一是Samy Kamkar创建的Myspace Samy蠕虫。2005年10月，Kamkar利用Myspace的一个漏洞，使他能够在个人资料中存储一个JavaScript有效载荷。每当一个登录用户访问他的Myspace个人资料时，载荷代码会执行，使得该用户成为Kamkar的朋友，并将该用户的个人资料更新为显示文本“但最重要的是，samy是我的英雄。”然后，这段代码会复制到该用户的个人资料中，并继续感染其他Myspace用户页面。'
- en: Although Kamkar didn’t create the worm with malicious intent, the government
    raided Kamkar’s residence as a result. Kamkar was arrested for releasing the worm
    and pleaded guilty to a felony charge.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Kamkar并没有恶意创建这个蠕虫，但由于此事，政府突袭了Kamkar的住所。Kamkar因释放该蠕虫而被逮捕，并对一项重罪指控表示认罪。
- en: Kamkar’s worm is an extreme example, but his exploit shows the broad impact
    an XSS vulnerability could have on a website. Similar to other vulnerabilities
    I’ve covered so far, XSS occurs when websites render certain characters unsanitized,
    causing browsers to execute malicious JavaScript. Characters that allow an XSS
    vulnerability to occur include double quotes (`"`), single quotes (`'`), and angle
    brackets (`< >`).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Kamkar的蠕虫是一个极端的例子，但他的攻击展示了XSS漏洞对网站可能造成的广泛影响。与我目前介绍的其他漏洞类似，XSS发生在网站未对某些字符进行净化时，导致浏览器执行恶意的JavaScript。允许XSS漏洞发生的字符包括双引号（`"`）、单引号（`'`）和尖括号（`<
    >`）。
- en: 'If a site properly sanitizes characters, the characters render as HTML entities.
    For example, the page source for a web page would show these characters as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个网站正确地净化字符，这些字符将作为HTML实体呈现。例如，网页的源代码将以以下方式显示这些字符：
- en: A double quote (`"`) as `&quot;` or `&#34;`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个双引号（`"`)可以表示为`&quot;`或`&#34;`
- en: A single quote (`'`) as `&apos;` or `&#39;`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单引号（`'`）可以表示为`&apos;`或`&#39;`
- en: An opening angle bracket (`<`) as `&lt;` or `&#60;`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个开头的尖括号（`<`）可以表示为`&lt;`或`&#60;`
- en: A closing angle bracket (`>`) as `&gt;` or `&#62;`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个结束的尖括号（`>`）可以表示为`&gt;`或`&#62;`
- en: 'These special characters, when unsanitized, define a web page’s structure in
    HTML and JavaScript. For example, if a site doesn’t sanitize angle brackets, you
    could insert `<script></script>` to inject a payload, like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊字符在未净化的情况下，在HTML和JavaScript中定义了网页的结构。例如，如果一个网站没有净化尖括号，你可以插入`<script></script>`来注入一个有效载荷，像这样：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you submit this payload to a website that renders it unsanitized, the `<script></script>`
    tags instruct the browser to execute the JavaScript between them. The payload
    executes the `alert` function, creating a pop-up dialog that displays the information
    passed to `alert`. The reference to `document` inside the parentheses is the DOM,
    which returns the domain name of the site. For example, if the payload executes
    on *https://www.<example>.com/foo/bar/*, the pop-up dialog displays *www.<example>.com*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这个有效载荷提交到一个未净化的网页时，`<script></script>`标签会指示浏览器执行其中的JavaScript。这个有效载荷执行`alert`函数，弹出一个显示传递给`alert`的内容的对话框。括号中的`document`是DOM，它返回网站的域名。例如，如果这个有效载荷在*https://www.<example>.com/foo/bar/*执行，弹出的对话框将显示*www.<example>.com*。
- en: When you’ve found an XSS vulnerability, confirm its impact because not all XSS
    vulnerabilities are the same. Confirming the impact of a bug and including this
    analysis improves your report, helps triagers validate your bug, and might raise
    your bounty.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现XSS漏洞时，确认其影响范围，因为并非所有XSS漏洞都是相同的。确认漏洞的影响并包括这一分析可以改善你的报告，帮助漏洞评估者验证你的漏洞，甚至可能提高你的赏金。
- en: For example, an XSS vulnerability on a site that doesn’t use the `httponly`
    flag on sensitive cookies is different from an XSS vulnerability that does. When
    a site has no `httponly` flag, your XSS can read cookie values; if those values
    include session-identifying cookies, you could steal a target’s session and access
    their account. You can alert `document.cookie` to confirm that you can read sensitive
    cookies (knowing which cookies a site considers sensitive requires trial and error
    on each site). Even when you can’t access sensitive cookies, you can alert `document.domain`
    to confirm whether you can access sensitive user information from the DOM and
    perform actions on behalf of the target.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个没有使用`httponly`标志的敏感cookie的XSS漏洞与使用了该标志的XSS漏洞是不同的。当一个站点没有`httponly`标志时，你的XSS可以读取cookie的值；如果这些值包括会话识别cookie，你可以窃取目标的会话并访问他们的账户。你可以警告`document.cookie`来确认你能读取敏感的cookie（知道一个站点认为哪些cookie是敏感的需要在每个站点上进行试验）。即使你不能访问敏感的cookie，你也可以警告`document.domain`来确认是否可以从DOM中访问敏感的用户信息，并代表目标执行操作。
- en: But the XSS might not be a vulnerability for the site if you don’t alert the
    correct domain. For example, if you alert `document.domain` from a sandboxed iFrame,
    your JavaScript could be harmless because it can’t access cookies, perform actions
    on the user’s account, or access sensitive user information from the DOM.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你没有正确警告域名，XSS可能不会成为该站点的漏洞。例如，如果你从一个沙盒iFrame中警告`document.domain`，你的JavaScript可能是无害的，因为它无法访问cookies，无法在用户账户上执行操作，或无法从DOM中访问敏感的用户信息。
- en: The JavaScript is rendered harmless because browsers implement a *Same Origin
    Policy (SOP)* as a security mechanism. The SOP restricts how documents (the D
    in DOM) can interact with resources loaded from another origin. The SOP protects
    innocent websites from malicious sites attempting to exploit the website through
    the user. For example, if you visited *www.<malicious>.com* and it invoked a `GET`
    request to *www.<example>.com/profile* in your browser, the SOP would prevent
    *www.<malicious>.com* from reading the *www.<example>.com/profile* response. The
    *www.<example>.com* site might allow sites from a different origin to interact
    with it, but usually those interactions are limited to specific websites *www.<example>.com*
    trusts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器实施了*同源策略（SOP）*作为安全机制，JavaScript被渲染为无害。SOP限制了文档（DOM中的D）如何与来自不同来源的资源进行交互。SOP保护无辜的网站免受恶意网站通过用户进行的攻击。例如，如果你访问了*www.<malicious>.com*并且它发起了一个`GET`请求到*www.<example>.com/profile*，SOP会阻止*www.<malicious>.com*读取*www.<example>.com/profile*的响应。*www.<example>.com*网站可能允许来自不同来源的站点与其交互，但通常这些交互仅限于特定的网站，*www.<example>.com*信任的网站。
- en: A website’s protocol (e.g., HTTP or HTTPS), host (e.g., *www.<example>.com*),
    and port determine a site’s origin. Internet Explorer is an exception to this
    rule. It doesn’t consider the port to be part of the origin. [Table 7-1](ch07.xhtml#ch07tab01)
    shows examples of origins and whether they would be considered the same as *http://www.<example>.com/*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的协议（例如，HTTP或HTTPS）、主机（例如，*www.<example>.com*）和端口决定了网站的来源。Internet Explorer是这一规则的例外，它不会将端口视为来源的一部分。[表格7-1](ch07.xhtml#ch07tab01)展示了不同来源的示例，并且指示它们是否与*http://www.<example>.com/*被视为相同来源。
- en: '**Table 7-1:** Examples of SOP'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格7-1：** SOP示例'
- en: '| **URL** | **Same origin?** | **Reason** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **网址** | **同源？** | **原因** |'
- en: '| *http://www.<example>.com/countries* | Yes | N/A |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| *http://www.<example>.com/countries* | 是 | 不适用 |'
- en: '| *http://www.<example>.com/countries/Canada* | Yes | N/A |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| *http://www.<example>.com/countries/Canada* | 是 | 不适用 |'
- en: '| *https://www.<example>.com/countries* | No | Different protocol |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| *https://www.<example>.com/countries* | 否 | 不同协议 |'
- en: '| *http://store.<example>.com/countries* | No | Different host |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| *http://store.<example>.com/countries* | 否 | 不同主机 |'
- en: '| *http://www.<example>.com:8080/countries* | No | Different port |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| *http://www.<example>.com:8080/countries* | 否 | 不同端口 |'
- en: 'In some situations, the URL won’t match the origin. For example, `about:blank`
    and `javascript:` schemes inherit the origin of the document opening them. The
    `about:blank` context accesses information from or interacts with the browser,
    whereas `javascript:` executes JavaScript. The URL doesn’t provide information
    about its origin, so browsers handle these two contexts differently. When you
    find an XSS vulnerability, using `alert(document.domain)` in your proof of concept
    is helpful: it confirms the origin where the XSS executes, especially when the
    URL shown in the browser is different from the origin the XSS executes against.
    This is exactly what happens when a website opens a `javascript:` URL. If *www.<example>.com*
    opened a `javascript:alert(document.domain)` URL, the browser address would show
    `javascript:alert(document.domain)`. But the alert box would show *www.<example>.com*
    because the alert inherits the origin of the previous document.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，URL的源与实际来源不匹配。例如，`about:blank`和`javascript:`方案会继承打开它们的文档的来源。`about:blank`上下文访问或与浏览器交互，而`javascript:`则执行JavaScript。URL本身并没有提供关于其来源的信息，因此浏览器会以不同的方式处理这两种上下文。当你发现XSS漏洞时，在你的概念验证中使用`alert(document.domain)`是很有帮助的：它确认了XSS执行的来源，尤其是在浏览器显示的URL与XSS执行的来源不同的情况下。这正是当一个网站打开`javascript:`
    URL时发生的情况。如果*www.<example>.com*打开了`javascript:alert(document.domain)`的URL，浏览器地址栏会显示`javascript:alert(document.domain)`，但弹出框会显示*www.<example>.com*，因为弹出框继承了前一个文档的来源。
- en: 'Although I’ve only covered an example that uses the HTML `<script>` tag to
    achieve XSS, you can’t always submit HTML tags when you find a potential injection.
    In those cases, you might be able to submit single or double quotes to inject
    an XSS payload. The XSS could be significant depending on where your injection
    occurs. For example, let’s say you can access the following code’s `value` attribute:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我这里只举了使用HTML `<script>`标签来实现XSS的例子，但在发现潜在注入点时，您并不总是能够提交HTML标签。在这些情况下，您可能能够提交单引号或双引号来注入XSS有效载荷。根据注入位置的不同，XSS的影响可能会很大。例如，假设你能够访问以下代码的`value`属性：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By injecting a double quote in the `value` attribute, you could close the existing
    quote and inject a malicious XSS payload into the tag. You might do this by changing
    the `value` attribute to `hacker" onfocus=alert(document.cookie) autofocus "`,
    which would result in the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`value`属性中注入双引号，你可以关闭现有的引号，并将恶意的XSS有效载荷注入到标签中。你可以通过将`value`属性改为`hacker" onfocus=alert(document.cookie)
    autofocus "`来实现，这会导致以下结果：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `autofocus` attribute instructs the browser to place the cursor focus on
    the input text box as soon as the page loads. The `onfocus` JavaScript attribute
    tells the browser to execute JavaScript when the input text box is the focus (without
    `autofocus`, the `onfocus` would occur when a person clicks the text box). But
    these two attributes have limits: you can’t autofocus on a hidden field. Also,
    if multiple fields are on a page with autofocus, either the first or last element
    will be the focus depending on the browser. When the payload runs, it would alert
    on `document.cookie`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`autofocus`属性指示浏览器在页面加载完成后立即将光标焦点放在输入框上。`onfocus` JavaScript属性告诉浏览器当输入框获得焦点时执行JavaScript（没有`autofocus`时，`onfocus`会在用户点击输入框时触发）。但这两个属性有其局限性：你不能在隐藏字段上使用自动聚焦。此外，如果页面上有多个字段设置了自动聚焦，焦点会落在第一个或最后一个元素上，这取决于浏览器。当有效载荷运行时，它会在`document.cookie`上触发警报。'
- en: 'Similarly, let’s say you had access to a variable within a `<script>` tag.
    If you could inject single quotes into the value for the `name` variable in the
    following code, you could close the variable and execute your own JavaScript:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，假设你有权限访问`<script>`标签中的一个变量。如果你能将单引号注入到以下代码中的`name`变量值里，你就能关闭该变量并执行你自己的JavaScript：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Because we control the value `hacker`, changing the `name` variable to `hacker'';alert(document.cookie);''`
    would result in the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们控制着`hacker`的值，将`name`变量改为`hacker';alert(document.cookie);'`会导致以下结果：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Injecting a single quote and semicolon closes the variable `name`. Because we’re
    using a `<script>` tag, the JavaScript function `alert(document.cookie)`, which
    we also injected, will execute. We add an additional `;'` to end our function
    call and ensure the JavaScript is syntactically correct because the site includes
    a `';` to close the `name` variable. Without the `';` syntax at the end, there
    would be a dangling single quote, which could break the page syntax.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注入一个单引号和分号后，变量 `name` 会被关闭。由于我们使用的是 `<script>` 标签，JavaScript 函数 `alert(document.cookie)`（我们也注入了这个函数）会执行。我们添加了额外的
    `;'` 来结束函数调用并确保 JavaScript 语法正确，因为网站包含了一个 `';` 来关闭 `name` 变量。如果没有 `';` 语法结尾，可能会留下一个悬空的单引号，从而破坏页面的语法。
- en: As you now know, you can execute XSS using several methods. The website *[http://html5sec.org/](http://html5sec.org/)*,
    which the penetration testing experts at Cure53 maintain, is a great reference
    for XSS payloads.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，你可以使用几种方法执行 XSS。由 Cure53 的渗透测试专家维护的网站 *[http://html5sec.org/](http://html5sec.org/)*
    是一个关于 XSS payloads 的优秀参考。
- en: '**Types of XSS**'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**XSS 类型**'
- en: 'There are two main types of XSS: reflected and stored. *Reflected XSS* occurs
    when a single HTTP request that isn’t stored anywhere on the site delivers and
    executes the XSS payload. Browsers, including Chrome, Internet Explorer, and Safari,
    try to prevent this type of vulnerability by introducing *XSS Auditors* (in July
    2018, Microsoft announced they are retiring the XSS Auditor in the Edge browser
    due to other security mechanisms available to prevent XSS). XSS Auditors attempt
    to protect users from malicious links that execute JavaScript. When an XSS attempt
    occurs, the browser shows a broken page with a message stating the page has been
    blocked to protect users. [Figure 7-1](ch07.xhtml#ch07fig01) shows an example
    in Google Chrome.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 主要有两种类型：反射型和存储型。*反射型 XSS* 是指一个没有存储在网站上的单一 HTTP 请求，传送并执行 XSS payload。包括 Chrome、Internet
    Explorer 和 Safari 在内的浏览器，尝试通过引入 *XSS 审计器* 来防止这种漏洞（2018 年 7 月，微软宣布他们将在 Edge 浏览器中退休
    XSS 审计器，因为有其他安全机制可以防止 XSS）。XSS 审计器尝试保护用户免受执行 JavaScript 的恶意链接。当发生 XSS 尝试时，浏览器会显示一个损坏的页面，并提示页面已被阻止以保护用户。[图
    7-1](ch07.xhtml#ch07fig01) 显示了 Google Chrome 中的一个示例。
- en: '![image](../images/07fig01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig01.jpg)'
- en: '*Figure 7-1: A page blocked by the XSS Auditor in Google Chrome*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：Google Chrome 中被 XSS 审计器阻止的页面*'
- en: Despite browser developers’ best efforts, attackers frequently bypass XSS Auditors
    because JavaScript can execute in complex ways on a site. Because these methods
    of bypassing XSS Auditors often change, they’re beyond the scope of this book.
    But two great resources to learn more are FileDescriptor’s blog post at *[https://blog.innerht.ml/the-misunderstood-x-xss-protection/](https://blog.innerht.ml/the-misunderstood-x-xss-protection/)*
    and Masato Kinugawa’s filter bypass cheat sheet at *https://github.com/masatokinugawa/filterbypass/wiki/Browser’s-XSS-Filter-Bypass-Cheat-Sheet/*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管浏览器开发者们付出了巨大努力，但攻击者仍然经常绕过 XSS 审计器，因为 JavaScript 在网站上的执行方式复杂多变。由于绕过 XSS 审计器的方法经常变化，它们超出了本书的讨论范围。不过，有两个很好的资源可以进一步了解，分别是
    FileDescriptor 的博客文章 *[https://blog.innerht.ml/the-misunderstood-x-xss-protection/](https://blog.innerht.ml/the-misunderstood-x-xss-protection/)*
    和 Masato Kinugawa 的过滤器绕过备忘单 *https://github.com/masatokinugawa/filterbypass/wiki/Browser’s-XSS-Filter-Bypass-Cheat-Sheet/*。
- en: In contrast, *stored XSS* occurs when a site saves a malicious payload and renders
    it unsanitized. Sites might also render the inputted payload in various locations.
    The payload might not execute immediately after submission, but it could execute
    when another page is accessed. For example, if you create a profile on a website
    with an XSS payload as your name, the XSS might not execute when you view your
    profile; instead, it might execute when someone searches for your name or sends
    you a message.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，*存储型 XSS* 是指当网站保存恶意 payload 并渲染它时未经过消毒处理。网站也可能在多个位置渲染输入的 payload。payload
    可能不会在提交后立即执行，但它可能在访问其他页面时执行。例如，如果你在一个网站上创建了一个包含 XSS payload 的个人资料作为你的名字，那么 XSS
    可能不会在你查看个人资料时执行；相反，它可能在别人搜索你的名字或给你发信息时执行。
- en: 'You can also sort XSS attacks into the following three subcategories: DOM-based,
    blind, and self. *DOM-based XSS* attacks involve manipulating a website’s existing
    JavaScript code to execute malicious JavaScript; it can be either stored or reflected.
    For example, let’s say the web page *www.<example>.com/hi/* used the following
    HTML to replace its page contents with a value from a URL without checking for
    malicious input. It might be possible to execute XSS.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 XSS 攻击分为以下三种子类别：基于 DOM 的、盲型和自我型。*基于 DOM 的 XSS* 攻击涉及操控网站现有的 JavaScript
    代码来执行恶意的 JavaScript；它可以是存储型或反射型的。例如，假设网页 *www.<example>.com/hi/* 使用以下 HTML 代码来替换页面内容，且未检查
    URL 中的恶意输入。这样就可能执行 XSS 攻击。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example web page, the script tag calls the document object’s `getElementById`
    method to find the HTML element with the ID `'name'`. The call returns a reference
    to the span element in the `<h1>` tag. Next, the script tag modifies the text
    between the `<span id="name"></span>` tags using the `innerHTML` method. The script
    sets the text between `<span></span>` to the value from the `location.hash`, which
    is any text that occurs after a `#` in the URL (`location` is another browser
    API, similar to the DOM; it provides access to information about the current URL).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例网页中，脚本标签调用文档对象的 `getElementById` 方法来查找具有 ID `'name'` 的 HTML 元素。该调用返回指向
    `<h1>` 标签中 `<span>` 元素的引用。接下来，脚本标签使用 `innerHTML` 方法修改 `<span id="name"></span>`
    标签之间的文本。脚本将 `<span></span>` 之间的文本设置为来自 `location.hash` 的值，`location.hash` 是 URL
    中 `#` 后的任何文本（`location` 是另一个浏览器 API，类似于 DOM；它提供了关于当前 URL 的信息）。
- en: 'Thus, visiting *www.<example>.com/hi#Peter/* would result in the page’s HTML
    dynamically being updated to `<h1><span id="name">Peter</span></h1>`. But this
    page doesn’t sanitize the `#` value in the URL before updating the `<span>` element.
    So if a user visited *www.<example>.com/h1#<img src=x onerror=alert(document.domain)>*,
    a JavaScript alert box would pop up and display *www.<example>.com* (assuming
    no image `x` was returned to the browser). The resulting HTML from the page would
    look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，访问 *www.<example>.com/hi#Peter/* 会导致页面的 HTML 动态更新为 `<h1><span id="name">Peter</span></h1>`。但该页面在更新
    `<span>` 元素之前没有清理 URL 中的 `#` 值。所以，如果用户访问 *www.<example>.com/h1#<img src=x onerror=alert(document.domain)>*，一个
    JavaScript 警告框会弹出并显示 *www.<example>.com*（假设浏览器没有返回图片 `x`）。页面的最终 HTML 将会像这样：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This time, instead of rendering Peter between `<h1>` tags, the webpage would
    display a JavaScript alert box with the `document.domain` name. An attacker could
    use this because, to execute any JavaScript, they provide the JavaScript attribute
    of the `<img>` tag to the `onerror`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，网页不会在 `<h1>` 标签之间渲染 Peter，而是会显示一个 JavaScript 警告框，里面显示 `document.domain` 名称。攻击者可以利用这一点，因为为了执行任何
    JavaScript，他们将 `<img>` 标签的 JavaScript 属性提供给 `onerror`。
- en: '*Blind XSS* is a stored XSS attack in which another user renders the XSS payload
    from a location of the website a hacker can’t access. For example, this might
    happen if you could add XSS as your first and last name when you create a personal
    profile on a site. Those values can be escaped when regular users view your profile.
    But when an administrator visits an administrative page listing all new users
    on the site, the values might not be sanitized and the XSS might execute. The
    tool XSSHunter (*[https://xsshunter.com/](https://xsshunter.com/)*) by Matthew
    Bryant is ideal for detecting blind XSS. The payloads Bryant designed execute
    JavaScript, which loads a remote script. When the script executes, it reads the
    DOM, browser information, cookies, and other information the payload sends back
    to your XSSHunter account.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*盲型 XSS* 是一种存储型 XSS 攻击，其中另一个用户从黑客无法访问的网站位置渲染 XSS 负载。例如，如果你在创建个人资料时将 XSS 作为你的名字和姓氏添加，这可能会发生。这些值在普通用户查看你的个人资料时可能会被转义，但当管理员访问列出所有新用户的管理页面时，可能不会清理这些值，从而执行
    XSS。Matthew Bryant 提供的 XSSHunter 工具 (*[https://xsshunter.com/](https://xsshunter.com/)*)
    非常适合检测盲型 XSS。Bryant 设计的负载会执行 JavaScript，加载远程脚本。当脚本执行时，它会读取 DOM、浏览器信息、Cookies 和其他返回到
    XSSHunter 账户的信息。'
- en: '*Self XSS* vulnerabilities are those that can impact only the user entering
    the payload. Because an attacker can attack only themselves, self XSS is considered
    low severity and doesn’t qualify for a reward in most bug bounty programs. For
    example, it can occur when the XSS is submitted via a `POST` request. But because
    the request is protected by CSRF, only the target can submit the XSS payload.
    Self XSS may or may not be stored.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*Self XSS* 漏洞是指仅影响输入有效载荷的用户的漏洞。由于攻击者只能攻击自己，因此自我 XSS 被认为是低严重性漏洞，并且在大多数漏洞悬赏计划中不符合奖励资格。例如，当
    XSS 通过 `POST` 请求提交时，可能会发生这种漏洞。但由于请求受到 CSRF 的保护，只有目标用户才能提交 XSS 有效载荷。自我 XSS 可能会被存储，也可能不会。'
- en: If you find a self XSS, look for opportunities to combine it with another vulnerability
    that can affect other users, such as *login/logout CSRF*. In this type of attack,
    a target is logged out of their account and logged into the attacker’s account
    to execute the malicious JavaScript. Typically, a login/logout CSRF attack requires
    the ability to log the target back into an account using malicious JavaScript.
    We won’t look at a bug that uses login/logout CSRF, but a great example is one
    that Jack Whitton found on an Uber site, which you can read about at *https://whitton.io/articles/uber-turning-self-xss-into-good-xss/*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自我 XSS，尝试寻找机会将其与其他可能影响其他用户的漏洞结合，例如 *登录/登出 CSRF*。在这种攻击中，目标用户会被登出自己的账户，并登录到攻击者的账户以执行恶意的
    JavaScript。通常，登录/登出 CSRF 攻击需要能够使用恶意 JavaScript 将目标用户重新登录到账户中。我们不会讨论使用登录/登出 CSRF
    的漏洞，但一个很好的例子是 Jack Whitton 在 Uber 网站上发现的漏洞，你可以在 *https://whitton.io/articles/uber-turning-self-xss-into-good-xss/*
    阅读详细信息。
- en: 'XSS’s impact depends on a variety of factors: whether it’s stored or reflected,
    whether cookies are accessible, where the payload executes, and so on. Despite
    the potential damage XSS can cause on a site, fixing XSS vulnerabilities is often
    easy, requiring only that software developers sanitize user input (just as with
    HTML injection) before rendering it.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 的影响取决于多种因素：它是存储型还是反射型，是否能访问 cookies，有效载荷在哪个位置执行等等。尽管 XSS 可能对网站造成潜在的损害，但修复
    XSS 漏洞通常很容易，只需要软件开发人员在渲染之前对用户输入进行过滤（就像 HTML 注入一样）。
- en: '**Shopify Wholesale**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Shopify 批发**'
- en: '**Difficulty:** Low'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 低'
- en: '**URL:** *[wholesale.shopify.com/](http://wholesale.shopify.com/)*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**网址：** *[wholesale.shopify.com/](http://wholesale.shopify.com/)*'
- en: '**Source:** *[https://hackerone.com/reports/106293/](https://hackerone.com/reports/106293/)*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://hackerone.com/reports/106293/](https://hackerone.com/reports/106293/)*'
- en: '**Date reported:** December 21, 2015'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2015 年 12 月 21 日'
- en: '**Bounty paid:** $500'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**支付悬赏：** $500'
- en: 'XSS payloads don’t have to be complicated, but you do need to tailor them to
    the location where they’ll be rendered and whether they’ll be contained in HTML
    or JavaScript tags. In December 2015, Shopify’s wholesale website was a simple
    web page with a distinct search box at the top. The XSS vulnerability on this
    page was simple but easily missed: text input into the search box was being reflected
    unsanitized within existing JavaScript tags.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 有效载荷不需要复杂，但你需要根据它们渲染的位置以及它们是否包含在 HTML 或 JavaScript 标签中来定制。在 2015 年 12 月，Shopify
    的批发网站是一个简单的网页，顶部有一个独特的搜索框。该页面上的 XSS 漏洞很简单，但容易被忽略：输入到搜索框中的文本被未经过滤地反射在现有的 JavaScript
    标签中。
- en: People overlooked this bug because the XSS payload wasn’t exploiting unsanitized
    HTML. When XSS exploits how HTML is rendered, attackers can see the effect of
    the payload because HTML defines the look and feel of a site. In contrast, JavaScript
    code can *change* the look and feel of a site or perform another action, but it
    doesn’t *define* the site’s look and feel.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 人们忽视了这个漏洞，因为 XSS 有效载荷并没有利用未经过滤的 HTML。当 XSS 利用 HTML 的渲染方式时，攻击者可以看到有效载荷的效果，因为
    HTML 定义了网站的外观和感觉。相比之下，JavaScript 代码可以 *改变* 网站的外观和感觉或执行其他操作，但它并不 *定义* 网站的外观和感觉。
- en: In this case, entering `"><script>alert('XSS')</script>` wouldn’t execute the
    XSS payload `alert('XSS')` because Shopify was encoding the HTML tags `<>`. These
    characters would have been rendered harmlessly as `&lt;` and `&gt;`. A hacker
    realized the input was being rendered unsanitized within `<script></script>` tags
    on the web page. Most likely, the hacker reached this conclusion by viewing the
    page’s source, which contains the HTML and JavaScript for the page. You can view
    the source for any web page by entering *view-source:URL* in a browser address
    bar. As an example, [Figure 7-2](ch07.xhtml#ch07fig02) shows part of the *[https://nostarch.com/](https://nostarch.com/)*
    site’s page source.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输入 `"><script>alert('XSS')</script>` 并不会执行 XSS 载荷 `alert('XSS')`，因为 Shopify
    对 HTML 标签 `<>` 进行了编码。这些字符会被无害地呈现为 `&lt;` 和 `&gt;`。黑客意识到该输入在网页中的 `<script></script>`
    标签内没有被清理。很可能，黑客是通过查看页面的源代码得出这个结论的，源代码包含了页面的 HTML 和 JavaScript。你可以通过在浏览器地址栏中输入
    *view-source:URL* 来查看任何网页的源代码。例如，[图 7-2](ch07.xhtml#ch07fig02) 显示了 *[https://nostarch.com/](https://nostarch.com/)*
    网站的部分页面源代码。
- en: After realizing the input was rendered unsanitized, the hacker entered `test';alert('XSS');'`
    into Shopify’s search box, creating a JavaScript alert box with the text `'XSS'`
    in it when rendered. Although it’s unclear in the report, it’s likely that Shopify
    was rendering the searched term in a JavaScript statement, like `var search_term
    = '`<INJECTION>`'`. The first part of the injection, `test';`, would have closed
    that tag and inserted the `alert('XSS');` as a separate statement. The final `'`
    would have ensured the JavaScript syntax was correct. The result would presumably
    have looked like `var search_term = 'test';alert('xss'); '';`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在意识到输入没有被清理后，黑客将 `test';alert('XSS');'` 输入到 Shopify 的搜索框中，当呈现时，会创建一个 JavaScript
    警告框，显示文本 `'XSS'`。虽然报告中没有明确说明，但很可能 Shopify 是在 JavaScript 语句中呈现搜索词，例如 `var search_term
    = '`<INJECTION>`'`。注入的第一部分 `test';` 会关闭该标签，并将 `alert('XSS');` 插入为一个独立的语句。最后的 `'`
    会确保 JavaScript 语法正确。最终结果可能会像 `var search_term = 'test';alert('xss'); '';`。
- en: '![image](../images/07fig02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig02.jpg)'
- en: '*Figure 7-2: The page source for* [https://nostarch.com/](https://nostarch.com/)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：* [https://nostarch.com/](https://nostarch.com/) *网站的页面源代码*'
- en: '***Takeaways***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重点总结***'
- en: 'XSS vulnerabilities don’t have to be intricate. The Shopify vulnerability wasn’t
    complex: it was just a simple input text field that didn’t sanitize user input.
    When you’re testing for XSS, be sure to view the page source and confirm whether
    your payloads are being rendered in HTML or JavaScript tags.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 漏洞不一定复杂。Shopify 的漏洞并不复杂：它只是一个没有清理用户输入的简单输入文本字段。在测试 XSS 时，务必查看页面源代码，确认你的载荷是否被呈现在
    HTML 或 JavaScript 标签中。
- en: '**Shopify Currency Formatting**'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Shopify 货币格式化**'
- en: '**Difficulty:** Low'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 低'
- en: '**URL:** *<YOURSITE>.myshopify.com/admin/settings/general/*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**网址：** *<YOURSITE>.myshopify.com/admin/settings/general/*'
- en: '**Source:** *[https://hackerone.com/reports/104359/](https://hackerone.com/reports/104359/)*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://hackerone.com/reports/104359/](https://hackerone.com/reports/104359/)*'
- en: '**Report date:** December 9, 2015'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2015年12月9日'
- en: '**Bounty paid:** $1,000'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励金额：** $1,000'
- en: XSS payloads don’t always execute immediately. Because of this, hackers should
    make sure the payload is properly sanitized in all the places it might be rendered.
    In this example, Shopify’s store settings allowed users to change currency formatting.
    In December 2015, the values from those input boxes weren’t properly sanitized
    when setting up social media pages. A malicious user could set up a store and
    inject an XSS payload in a store’s currency settings field, as shown in [Figure
    7-3](ch07.xhtml#ch07fig03). The payload was rendered in the store’s social media
    sales channel. The malicious user could configure the store to execute the payload
    when another store administrator visited the sales channel.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 载荷并不总是立即执行。因此，黑客应确保在所有可能呈现的地方正确清理载荷。在这个例子中，Shopify 的商店设置允许用户更改货币格式。2015年12月，当设置社交媒体页面时，这些输入框中的值没有得到正确清理。恶意用户可以设置一个商店，并在商店的货币设置字段中注入一个
    XSS 载荷，如 [图 7-3](ch07.xhtml#ch07fig03) 所示。该载荷在商店的社交媒体销售渠道中被呈现。恶意用户可以配置商店，以便当另一个商店管理员访问该销售渠道时执行载荷。
- en: Shopify uses the Liquid template engine to dynamically render content on shop
    pages. For example, `${{ }}` is the syntax for Liquid; the variable to be rendered
    is entered inside the inner set of braces. In [Figure 7-3](ch07.xhtml#ch07fig03),
    `${{amount}}` is a legitimate value but is appended with the value `"><img src=x
    onerror=alert(document.domain)>`, which is the XSS payload. The `">` closes the
    HTML tag that the payload is being injected into. When the HTML tag is closed,
    the browser renders the image tag and looks for an image `x` indicated in the
    `src` attribute. Because an image with this value is unlikely to exist on Shopify’s
    website, the browser encounters an error and calls the JavaScript event handler
    `onerror`. The event handler executes the JavaScript defined in the handler. In
    this case, it’s the function `alert(document.domain)`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Shopify 使用 Liquid 模板引擎动态渲染商店页面上的内容。例如，`${{ }}` 是 Liquid 的语法；要渲染的变量放在内层的大括号中。在
    [图 7-3](ch07.xhtml#ch07fig03) 中，`${{amount}}` 是一个合法的值，但被追加了值 `"><img src=x onerror=alert(document.domain)>`，这是
    XSS 有效载荷。`">` 关闭了 HTML 标签，正在将有效载荷注入到其中。当 HTML 标签关闭时，浏览器渲染该图像标签，并查找 `src` 属性中指示的图像
    `x`。由于 Shopify 网站上不太可能存在此值的图像，浏览器会遇到错误并调用 JavaScript 事件处理程序 `onerror`。事件处理程序执行处理程序中定义的
    JavaScript。在此情况下，它是 `alert(document.domain)` 函数。
- en: '![image](../images/07fig03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig03.jpg)'
- en: '*Figure 7-3: Shopify’s currency settings page at the time of the report*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：报告时 Shopify 的货币设置页面*'
- en: While the JavaScript wouldn’t execute when a user visited the currency page,
    the payload also appeared in the Shopify store’s social media sales channel. When
    other store administrators clicked the vulnerable sales channel tab, the malicious
    XSS would be rendered unsanitized and execute the JavaScript.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当用户访问货币页面时 JavaScript 不会执行，但有效载荷也会出现在 Shopify 商店的社交媒体销售渠道中。当其他商店管理员点击易受攻击的销售渠道标签时，恶意的
    XSS 会被渲染为未经清理并执行 JavaScript。
- en: '***Takeaways***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重点总结***'
- en: XSS payloads don’t always execute immediately after they’re submitted. Because
    a payload could be used in multiple locations on a site, be sure to visit each
    location. In this case, simply submitting the malicious payload on the currency
    page didn’t execute the XSS. The bug reporter had to configure another website
    feature to cause the XSS to execute.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 有效载荷并不总是在提交后立即执行。由于有效载荷可以在网站的多个位置使用，因此必须访问每个位置。在这种情况下，仅仅提交恶意有效载荷在货币页面上并未执行
    XSS。错误报告者必须配置另一个网站功能，才能使 XSS 执行。
- en: '**Yahoo! Mail Stored XSS**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Yahoo! Mail 存储型 XSS**'
- en: '**Difficulty:** Medium'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 中等'
- en: '**URL:** Yahoo! Mail'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL：** Yahoo! Mail'
- en: '**Source:** *[https://klikki.fi/adv/yahoo.html](https://klikki.fi/adv/yahoo.html)*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://klikki.fi/adv/yahoo.html](https://klikki.fi/adv/yahoo.html)*'
- en: '**Date reported:** December 26, 2015'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2015年12月26日'
- en: '**Bounty paid:** $10,000'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**悬赏金额：** $10,000'
- en: Sanitizing user input by modifying the inputted text can sometimes lead to problems
    if done incorrectly. In this example, Yahoo! Mail’s editor allowed people to embed
    images in an email via HTML using an `<img>` tag. The editor sanitized the data
    by removing any JavaScript attributes, such as `onload`, `onerror`, and so on,
    to avoid XSS vulnerabilities. However, it failed to avoid vulnerabilities that
    occurred when a user intentionally submitted malformed `<img>` tags.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改输入的文本来清理用户输入有时会导致问题，尤其是在处理不当时。在这个例子中，Yahoo! Mail 的编辑器允许用户通过 HTML 在电子邮件中嵌入图像，使用
    `<img>` 标签。编辑器通过移除所有 JavaScript 属性，如 `onload`、`onerror` 等，来清理数据，避免 XSS 漏洞。然而，它未能避免用户故意提交格式错误的
    `<img>` 标签时发生的漏洞。
- en: Most HTML tags accept attributes, which are additional information about the
    HTML tag. For example, the `<img>` tag requires a `src` attribute pointing to
    the address of the image to render. The tag also allows for `width` and `height`
    attributes to define the image’s size.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 HTML 标签都接受属性，它们是关于 HTML 标签的附加信息。例如，`<img>` 标签需要一个指向图像地址的 `src` 属性来渲染图像。该标签还允许使用
    `width` 和 `height` 属性来定义图像的大小。
- en: 'Some HTML attributes are Boolean attributes: when they’re included in the HTML
    tag, they’re considered true, and when they’re omitted, they’re considered false.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 HTML 属性是布尔属性：当它们包含在 HTML 标签中时，被视为 true，省略时被视为 false。
- en: 'With this vulnerability, Jouko Pynnonen found that if he added Boolean attributes
    to HTML tags with a value, Yahoo! Mail would remove the value but leave the attribute’s
    equal sign. Here is one of Pynnonen’s examples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个漏洞，Jouko Pynnonen 发现如果他将布尔属性添加到带有值的 HTML 标签中，Yahoo! Mail 会移除该值，但保留属性的等号。这是
    Pynnonen 提供的一个示例：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, the HTML input tag might include a `CHECKED` attribute denoting whether
    a check box should be rendered as checked off. Based on Yahoo’s tag parsing, the
    line would become this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，HTML 输入标签可能包含一个 `CHECKED` 属性，用来表示是否应该将复选框渲染为选中状态。根据 Yahoo 的标签解析，该行将变为：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This may look harmless, but HTML allows zero or more space characters around
    the equal sign in an unquoted attribute value. So browsers read this as `CHECKED`
    having the value of `NAME="check` and the input tag having a third attribute named
    `box`, which doesn’t have a value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来无害，但 HTML 允许在未加引号的属性值周围有零个或多个空格字符。因此，浏览器会将其读取为 `CHECKED` 的值为 `NAME="check`，而
    input 标签有一个名为 `box` 的第三个属性，但没有值。
- en: 'To exploit this, Pynnonen submitted the following `<img>` tag:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这一点，Pynnonen 提交了以下 `<img>` 标签：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Yahoo! Mail filtering would change this to the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Yahoo! 邮件过滤会将其更改为以下内容：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `ismap` value is a Boolean `<img>` tag attribute that indicates whether
    an image has clickable areas. In this case, Yahoo! removed `'xxx'`, and the single
    quote from the end of the string was moved to the end of the `yyy`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ismap` 值是一个布尔型的 `<img>` 标签属性，指示图像是否有可点击区域。在这个案例中，Yahoo! 删除了 `''xxx''`，并且字符串末尾的单引号被移动到了
    `yyy` 的末尾。'
- en: Sometimes, the backend of a site will be a black box and you won’t know how
    code is being processed, as in this case. We don’t know why the `'xxx'` was removed
    or why the single quote was moved to the end of `yyy`. Yahoo’s parsing engine
    or the way the browser handled whatever Yahoo! returned could have made these
    changes. Still, you can use these oddities to find vulnerabilities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，网站的后端是一个黑箱，你不知道代码是如何被处理的，就像这个案例一样。我们不知道为什么 `'xxx'` 被删除，或者为什么单引号被移到 `yyy`
    的末尾。可能是 Yahoo 的解析引擎，或者浏览器处理 Yahoo 返回的内容时做出了这些更改。不过，你可以利用这些异常找到漏洞。
- en: Because of the way the code was processed, an `<img>` tag with a height and
    width of 100 percent was rendered, making the image take up the entire browser
    window. When a user moved their mouse over the web page, the XSS payload would
    execute because of the `onmouseover=alert(/XSS/)` part of the injection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码处理的方式，一个 `<img>` 标签的高度和宽度为 100%，这导致图片占据了整个浏览器窗口。当用户将鼠标移到网页上时，XSS payload
    会因为注入中的 `onmouseover=alert(/XSS/)` 部分而执行。
- en: '***Takeaways***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点***'
- en: When sites sanitize user input by modifying it instead of encoding or escaping
    values, you should continue testing the site’s server-side logic. Think about
    how a developer might have coded their solution and what assumptions they’ve made.
    For example, check whether the developer considered what happens if two `src`
    attributes are submitted or if spaces are replaced with slashes. In this case,
    the bug reporter checked what would happen when Boolean attributes were submitted
    with values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当网站通过修改用户输入而不是对值进行编码或转义来清理输入时，你应该继续测试网站的服务器端逻辑。考虑开发者如何编写他们的解决方案以及他们做出了哪些假设。例如，检查开发者是否考虑过如果提交了两个
    `src` 属性，或者如果空格被替换为斜杠会发生什么。在这个案例中，漏洞报告者检查了当布尔属性提交值时会发生什么。
- en: '**Google Image Search**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Google 图片搜索**'
- en: '**Difficulty:** Medium'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 中等'
- en: '**URL:** *[images.google.com/](http://images.google.com/)*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**网址：** *[images.google.com/](http://images.google.com/)*'
- en: '**Source:** *[https://mahmoudsec.blogspot.com/2015/09/how-i-found-xss-vulnerability-in-google.html](https://mahmoudsec.blogspot.com/2015/09/how-i-found-xss-vulnerability-in-google.html)*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://mahmoudsec.blogspot.com/2015/09/how-i-found-xss-vulnerability-in-google.html](https://mahmoudsec.blogspot.com/2015/09/how-i-found-xss-vulnerability-in-google.html)*'
- en: '**Date reported:** September 12, 2015'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2015 年 9 月 12 日'
- en: '**Bounty paid:** Undisclosed'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励支付：** 未公开'
- en: Depending on where your input is being rendered, you don’t always need to use
    special characters to exploit XSS vulnerabilities. In September 2015, Mahmoud
    Jamal was using Google Images to find an image for his HackerOne profile. While
    browsing, he noticed the image URL *[http://www.google.com/imgres?imgurl=https://lh3.googleuser.com/](http://www.google.com/imgres?imgurl=https://lh3.googleuser.com/)*...
    from Google.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的输入渲染位置，你并不总是需要使用特殊字符来利用 XSS 漏洞。在 2015 年 9 月，Mahmoud Jamal 使用 Google 图片搜索为他的
    HackerOne 个人资料寻找一张图片。在浏览时，他注意到图片 URL *[http://www.google.com/imgres?imgurl=https://lh3.googleuser.com/](http://www.google.com/imgres?imgurl=https://lh3.googleuser.com/)*...
    来自 Google。
- en: Noting the reference to `imgurl` in the URL, Jamal realized he could control
    the parameter’s value; it would likely be rendered on the page as a link. When
    hovering over the thumbnail image for his profile, Jamal confirmed that the `<a>`
    tag `href` attribute included the same URL. He tried changing the `imgurl` parameter
    to `javascript:alert(1)` and noticed that the `href` attribute also changed to
    the same value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到URL中提到`imgurl`，Jamal意识到他可以控制该参数的值；它可能会作为链接渲染在页面上。当他将鼠标悬停在他个人资料的缩略图上时，Jamal确认`<a>`标签的`href`属性包含了相同的URL。他尝试将`imgurl`参数更改为`javascript:alert(1)`，并注意到`href`属性也更改为相同的值。
- en: 'This `javascript:alert(1)` payload is useful when special characters are sanitized
    because the payload doesn’t contain special characters for the website to encode.
    When clicking a link to `javascript:alert(1)`, a new browser window opens and
    the `alert` function executes. In addition, because the JavaScript executes in
    the context of the initial web page, which contains the link, the JavaScript can
    access the DOM of that page. In other words, a link to `javascript:alert(1)` would
    execute the `alert` function against Google. This result shows that a malicious
    attacker could potentially access information on the web page. If clicking a link
    to the JavaScript protocol didn’t inherit the context of the initial site rendering
    the link, the XSS would be harmless: attackers couldn’t access the vulnerable
    web page’s DOM.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`javascript:alert(1)`有效载荷在特殊字符被清理时非常有用，因为该载荷不包含需要网站编码的特殊字符。当点击指向`javascript:alert(1)`的链接时，会打开一个新的浏览器窗口，并执行`alert`函数。此外，由于JavaScript是在初始网页的上下文中执行的，而该网页包含了该链接，因此JavaScript可以访问该页面的DOM。换句话说，指向`javascript:alert(1)`的链接将对Google执行`alert`函数。这个结果表明，恶意攻击者可能会访问网页上的信息。如果点击指向JavaScript协议的链接没有继承初始站点渲染该链接的上下文，那么XSS攻击就无害了：攻击者无法访问易受攻击网页的DOM。
- en: Excited, Jamal clicked what he thought would be his malicious link, but no JavaScript
    executed. Google had sanitized the URL address when the mouse button was clicked
    via the anchor tag’s `onmousedown` JavaScript attribute.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 充满期待的Jamal点击了他认为是恶意链接的内容，但没有JavaScript被执行。当鼠标点击通过锚标签的`onmousedown`JavaScript属性时，Google已经清理了URL地址。
- en: As a workaround, Jamal tried tabbing through the page. When he got to the View
    Image button, he pressed ENTER. The JavaScript was triggered because he could
    visit the link without clicking the mouse button.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决方法，Jamal尝试通过页面进行切换。当他到达“查看图片”按钮时，他按下了ENTER键。JavaScript被触发，因为他可以在不点击鼠标的情况下访问链接。
- en: '***Takeaways***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点***'
- en: Always be on the lookout for URL parameters that might be reflected on the page
    because you have control over those values. If you find any URL parameters that
    are rendered on a page, consider their context as well. URL parameters might present
    opportunities to get around filters that remove special characters. In this example,
    Jamal didn’t need to submit any special characters because the value was rendered
    as the `href` attribute in an anchor tag.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 始终留意那些可能在页面上反射的URL参数，因为你可以控制这些值。如果你发现任何在页面上渲染的URL参数，也要考虑它们的上下文。URL参数可能会提供绕过清理特殊字符的过滤器的机会。在这个例子中，Jamal不需要提交任何特殊字符，因为该值作为锚标签中的`href`属性被渲染。
- en: Additionally, look for vulnerabilities even on Google and other major sites.
    It’s easy to assume that just because a company is huge, all its vulnerabilities
    have been discovered. Clearly, that isn’t always the case.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，甚至在Google和其他大型网站上也要寻找漏洞。很容易认为仅仅因为一个公司很大，它的所有漏洞都已经被发现了。显然，情况并非总是如此。
- en: '**Google Tag Manager Stored XSS**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Google Tag Manager 存储型 XSS**'
- en: '**Difficulty:** Medium'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 中等'
- en: '**URL:** *[tagmanager.google.com/](http://tagmanager.google.com/)*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL:** *[tagmanager.google.com/](http://tagmanager.google.com/)*'
- en: '**Source:** *[https://blog.it-securityguard.com/bugbounty-the-5000-google-xss/](https://blog.it-securityguard.com/bugbounty-the-5000-google-xss/)*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Source:** *[https://blog.it-securityguard.com/bugbounty-the-5000-google-xss/](https://blog.it-securityguard.com/bugbounty-the-5000-google-xss/)*'
- en: '**Date reported:** October 31, 2014'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2014年10月31日'
- en: '**Bounty paid:** $5,000'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励金额：** $5,000'
- en: 'A common best practice of websites is to sanitize user input when rendering
    it instead of when it’s being saved on submission. The reason is that it’s easy
    to introduce new ways to submit data to a site (like a file upload) and to forget
    to sanitize the input. In some cases, however, companies don’t follow this practice:
    Patrik Fehrenbach of HackerOne discovered this lapse in October 2014 when he was
    testing Google for XSS vulnerabilities.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的常见最佳实践是在渲染时清理用户输入，而不是在提交时保存输入。原因是，向网站提交数据的方式（如文件上传）容易引入新的方式，且可能会忘记清理输入。然而，在某些情况下，公司并未遵循这一做法：HackerOne
    的 Patrik Fehrenbach 在2014年10月测试 Google 的XSS漏洞时发现了这一疏漏。
- en: Google Tag Manager is an SEO tool that makes it easy for marketers to add and
    update website tags. To do this, the tool has a number of web forms that users
    interact with. Fehrenbach began by finding available form fields and entering
    XSS payloads, such as `#"><img src=/ onerror=alert(3)>`. If the payload was accepted
    by the form field, the payload would close the existing HTML tag and then try
    to load a nonexistent image. Because the image wouldn’t be found, the website
    would execute the `onerror` JavaScript function `alert(3)`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Google Tag Manager 是一款SEO工具，可以让营销人员轻松添加和更新网站标签。为了实现这一点，该工具提供了多个用户可以互动的网页表单。Fehrenbach
    从查找可用的表单字段开始，并输入了XSS负载，例如 `#"><img src=/ onerror=alert(3)>`。如果该负载被表单字段接受，负载将关闭现有的HTML标签，然后尝试加载一个不存在的图片。由于找不到该图片，网站将执行
    `onerror` JavaScript 函数 `alert(3)`。
- en: 'But Fehrenbach’s payload didn’t work. Google was properly sanitizing his input.
    Fehrenbach noticed an alternative way to submit his payload. In addition to the
    form fields, Google provides the ability to upload a JSON file with multiple tags.
    So Fehrenbach uploaded the following JSON file to Google’s service:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Fehrenbach 的负载并未生效。Google 正确地清理了他的输入。Fehrenbach 注意到了一种提交负载的替代方式。除了表单字段，Google
    还提供了上传包含多个标签的 JSON 文件的功能。因此，Fehrenbach 向 Google 的服务上传了以下 JSON 文件：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that the value of the `name` attribute is the same XSS payload Fehrenbach
    tried previously. Google wasn’t following best practices and was sanitizing input
    from the web form on submission instead of at the time of rendering. As a result,
    Google forgot to sanitize input from the file upload, so Fehrenbach’s payload
    executed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`name` 属性的值与 Fehrenbach 之前尝试的相同的 XSS 负载。Google 没有遵循最佳实践，而是在提交表单时进行输入清理，而不是在渲染时进行。因此，Google
    忘记对文件上传的输入进行清理，导致 Fehrenbach 的负载执行。
- en: '***Takeaways***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关键要点***'
- en: Two details are worth noting in Fehrenbach’s report. First, Fehrenbach found
    an alternative input method for his XSS payload. You should look for an alternative
    input method as well. Be sure to test all methods a target provides to enter input,
    because the way each input is processed might be different. Second, Google was
    attempting to sanitize on input instead of at the time of rendering. Google could
    have prevented this vulnerability by following best practices. Even when you know
    website developers typically use common countermeasures against certain attacks,
    check for vulnerabilities. Developers can make mistakes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Fehrenbach的报告中有两个值得注意的细节。首先，Fehrenbach 找到了另一种输入XSS负载的方法。你也应该寻找替代的输入方法。确保测试目标提供的所有输入方式，因为每种输入的处理方式可能不同。第二，Google
    尝试在输入时进行数据清理，而不是在渲染时进行。如果Google遵循最佳实践，本可以避免此漏洞。即使你知道网站开发人员通常会采取常见的防御措施来应对某些攻击，也要检查是否存在漏洞。开发人员也会犯错。
- en: '**United Airlines XSS**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**联合航空 XSS**'
- en: '**Difficulty:** Hard'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 难'
- en: '**URL:** *[checkin.united.com/](http://checkin.united.com/)*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL:** *[checkin.united.com/](http://checkin.united.com/)*'
- en: '**Source:** *[http://strukt93.blogspot.jp/2016/07/united-to-xss-united.html](http://strukt93.blogspot.jp/2016/07/united-to-xss-united.html)*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[http://strukt93.blogspot.jp/2016/07/united-to-xss-united.html](http://strukt93.blogspot.jp/2016/07/united-to-xss-united.html)*'
- en: '**Date reported:** July 2016'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2016年7月'
- en: '**Bounty paid:** Undisclosed'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**悬赏金：** 未公开'
- en: In July 2016, while searching for cheap flights, Mustafa Hasan began looking
    for bugs on United Airlines sites. He found that visiting the subdomain *[checkin.united.com](http://checkin.united.com)*
    redirected to a URL that included an `SID` parameter. Noticing that any value
    passed to the parameter was rendered in the page HTML, he tested `"><svg onload=confirm(1)>`.
    If rendered improperly, the tag would close the existing HTML tag and inject Hasan’s
    `<svg>` tag, resulting in a JavaScript pop-up courtesy of the `onload` event.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年7月，在寻找便宜机票时，Mustafa Hasan开始在United Airlines网站上寻找漏洞。他发现访问子域名*[checkin.united.com](http://checkin.united.com)*会重定向到一个包含`SID`参数的URL。注意到任何传递给该参数的值都会在页面HTML中渲染，他测试了`"><svg
    onload=confirm(1)>`。如果渲染不当，该标签将关闭现有的HTML标签并注入Hasan的`<svg>`标签，导致一个由`onload`事件触发的JavaScript弹窗。
- en: 'But when he submitted his HTTP request, nothing happened, although his payload
    was rendered as is, unsanitized. Rather than giving up, Hasan opened the site’s
    JavaScript files, likely with the browser’s development tools. He found the following
    code, which overrides JavaScript attributes that might lead to XSS, such as the
    attributes `alert`, `confirm`, `prompt`, and `write`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当他提交HTTP请求时，什么也没发生，尽管他的有效载荷以原样渲染，未经过清理。Hasan没有放弃，而是打开了网站的JavaScript文件，可能是使用浏览器的开发者工具。他发现了以下代码，该代码重写了可能导致XSS的JavaScript属性，如`alert`、`confirm`、`prompt`和`write`：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even if you don’t know JavaScript, you might guess what’s happening via the
    use of certain words. For example, the `exec_original` parameter name ➊ in the
    `XSSObject proxy` definition implies a relationship that executes something. Immediately
    below the parameter is a list of all our interesting functions and the value `false`
    being passed (except in the last instance) ➋. We can assume the site is trying
    to protect itself by disallowing the execution of the JavaScript attributes passed
    into `XSSObject proxy`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不懂JavaScript，你也许能通过某些词汇猜出发生了什么。例如，`XSSObject proxy`定义中的`exec_original`参数名
    ➊ 暗示了某种执行的关系。紧接着该参数下方是所有有趣函数的列表，并且传递了`false`值（除了最后一个实例） ➋。我们可以假设该站点试图通过不允许执行传递到`XSSObject
    proxy`中的JavaScript属性来保护自己。
- en: 'Notably, JavaScript allows you to override existing functions. So Hasan first
    tried to restore the `document.write` function by adding the following value in
    the `SID`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，JavaScript允许你重写现有的函数。因此，Hasan首先尝试通过在`SID`中添加以下值来恢复`document.write`函数：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This value sets the document’s `write` function to its original functionality
    by using the `write` function’s prototype. Because JavaScript is object oriented,
    all objects have a prototype. By calling on the `HTMLDocument`, Hasan set the
    current document’s `write` function back to the original implementation from `HTMLDocument`.
    He then called `document.write('STRUKT')` to add his name in plaintext to the
    page.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值通过使用`write`函数的原型，将文档的`write`函数恢复到其原始功能。由于JavaScript是面向对象的，所有对象都有一个原型。通过调用`HTMLDocument`，Hasan将当前文档的`write`函数恢复到了`HTMLDocument`的原始实现。然后，他调用了`document.write('STRUKT')`将他的名字以纯文本的形式添加到页面上。
- en: 'But when Hasan tried to exploit this vulnerability, he got stuck again. He
    reached out to Rodolfo Assis for help. Working together, they realized that United’s
    XSS filter was missing the override for a function similar to `write`: the `writeln`
    function. The difference between these two functions is that `writeln` adds a
    newline after writing its text, whereas `write` doesn’t.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当Hasan尝试利用这个漏洞时，他再次遇到了困难。他联系了Rodolfo Assis寻求帮助。两人合作后发现，United的XSS过滤器缺少对与`write`类似的函数的重写：`writeln`函数。这两个函数的区别在于，`writeln`在写入文本后会添加一个换行符，而`write`则不会。
- en: 'Assis believed he could use the `writeln` function to write content to the
    HTML document. Doing so would allow him to bypass one piece of United’s XSS filter.
    He did this with the following payload:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Assis认为他可以使用`writeln`函数将内容写入HTML文档。这样做可以绕过United的XSS过滤器。他通过以下有效载荷实现了这一点：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But his JavaScript still didn’t execute because the XSS filter was still being
    loaded and overriding the `alert` function: Assis needed to use a different method.
    Before we look at the final payload and how Assis worked around the `alert` override,
    let’s break down his initial payload.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但是他的JavaScript仍然没有执行，因为XSS过滤器仍然在加载并覆盖了`alert`函数：Assis需要使用不同的方法。在我们查看最终的有效载荷以及Assis如何绕过`alert`重写之前，让我们先分析一下他的初始有效载荷。
- en: The first piece, `";}`, closes the existing JavaScript being injected into.
    Next, `{` opens the JavaScript payload, and `document.writeln` calls the JavaScript
    document object’s `writeln` function to write content to the DOM. The `decodeURI`
    function passed to `writeln` decodes encoded entities in a URL (for example, `%22`
    will become `"`). The `location.hash` code passed to `decodeURI` returns all parameters
    after the `#` in the URL, which is defined later. After this initial setup is
    done, `-"` replaces the quote at the start of the payload to ensure proper JavaScript
    syntax.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分，`";}`，关闭了正在注入的现有 JavaScript。接下来，`{` 打开了 JavaScript payload，`document.writeln`
    调用了 JavaScript 文档对象的 `writeln` 函数，将内容写入 DOM。传递给 `writeln` 的 `decodeURI` 函数解码 URL
    中的编码实体（例如，`%22` 会变成 `"`）。传递给 `decodeURI` 的 `location.hash` 代码返回 URL 中 `#` 后的所有参数，这在后面定义。在完成这部分初始化后，`-"`
    替换了 payload 开头的引号，以确保 JavaScript 语法的正确性。
- en: The last piece, `#<img src=1 onerror=alert(1)>`, adds a parameter that is never
    sent to the server. This last piece is a defined, optional part of a URL, called
    a *fragment*, and it’s meant to refer to a part of the document. But in this case,
    Assis used a fragment to take advantage of the hash (`#`) that defines the start
    of the fragment. The reference to `location.hash` returns all content after the
    `#`. But the returned content will be URL encoded, so the input `<img src=1 onerror=alert(1)>`
    will be returned as `%3Cimg%20src%3D1%20onerror%3Dalert%281%29%3E%20`. To address
    the encoding, the function `decodeURI` decodes the content back to the HTML `<img
    src=1 onerror=alert(1)>`. This is important because the decoded value is passed
    to the `writeln` function, which writes the HTML `<img>` tag to the DOM. The HTML
    tag executes the XSS when the site can’t find the image `1` referenced in the
    `src` attribute of the tag. If the payload is successful, a JavaScript alert box
    would pop up with the number `1` in it. But it didn’t.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分，`#<img src=1 onerror=alert(1)>`，添加了一个从未发送到服务器的参数。这最后一部分是一个已定义的、可选的 URL
    部分，称为 *fragment*，它用于引用文档的一部分。但在这个案例中，Assis 利用定义 fragment 开始的哈希符号（`#`）。`location.hash`
    的引用返回所有 `#` 后的内容。但返回的内容将被 URL 编码，因此输入的 `<img src=1 onerror=alert(1)>` 将被返回为 `%3Cimg%20src%3D1%20onerror%3Dalert%281%29%3E%20`。为了处理编码，`decodeURI`
    函数将内容解码回 HTML `<img src=1 onerror=alert(1)>`。这很重要，因为解码后的值会传递给 `writeln` 函数，后者将
    HTML `<img>` 标签写入 DOM。当网站无法找到 `src` 属性中引用的图像 `1` 时，HTML 标签会执行 XSS。如果 payload 成功，一个
    JavaScript 提示框会弹出，显示数字 `1`。但它没有。
- en: 'Assis and Hasan realized they needed a fresh HTML document within the context
    of the United site: they needed a page that didn’t have the XSS filter JavaScript
    loaded but still had access to the United web page information, cookies, and so
    on. So they used an iFrame with the following payload:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Assis 和 Hasan 意识到他们需要在联合网站的上下文中创建一个新的 HTML 文档：他们需要一个没有加载 XSS 过滤 JavaScript，但仍能访问联合网页信息、cookies
    等的页面。所以他们使用了带有以下 payload 的 iFrame：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This payload behaved just like the original URL with the `<img>` tag. But in
    this one they wrote an `<iframe>` to the DOM and changed the `src` attribute to
    use the JavaScript scheme to `alert(document.domain)`. This payload is similar
    to the XSS vulnerability discussed in “[Google Image Search](ch07.xhtml#ch07lev1sec5)”
    on [page 65](ch07.xhtml#page_65), because the JavaScript scheme inherits the context
    of the parent DOM. Now the XSS could access the United DOM, so `document.domain`
    printed *[www.united.com](http://www.united.com)*. The vulnerability was confirmed
    when the site rendered a pop-up alert.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 payload 的行为和原始 URL 中的 `<img>` 标签完全相同。但在这个例子中，他们写入了一个 `<iframe>` 到 DOM 中，并将
    `src` 属性更改为使用 JavaScript 方案来 `alert(document.domain)`。这个 payload 类似于在 [第 65 页](ch07.xhtml#page_65)
    中讨论的 “[Google 图像搜索](ch07.xhtml#ch07lev1sec5)” 中提到的 XSS 漏洞，因为 JavaScript 方案继承了父
    DOM 的上下文。现在 XSS 可以访问联合 DOM，因此 `document.domain` 打印出 *[www.united.com](http://www.united.com)*。当站点渲染出一个弹出提示框时，漏洞被确认。
- en: An iFrame can take a source attribute to pull in remote HTML. As a result, Assis
    could set the source to be JavaScript, which immediately called the `alert` function
    with the document domain.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: iFrame 可以使用 `src` 属性来加载远程 HTML。因此，Assis 可以将源设置为 JavaScript，立即调用 `alert` 函数并显示文档域名。
- en: '***Takeaways***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点***'
- en: Note three important details about this vulnerability. First, Hasan was persistent.
    Rather than giving up when his payload wouldn’t fire, he dug into the JavaScript
    to find out why. Second, the use of a JavaScript attribute blacklist should tip
    off hackers that XSS bugs might exist in the code because they’re opportunities
    for developer mistakes. Third, having JavaScript knowledge is essential for successfully
    confirming more complex vulnerabilities.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意有关此漏洞的三个重要细节。首先，哈桑表现出了持续的坚持。当他的有效负载未能触发时，他并没有放弃，而是深入研究 JavaScript 查找原因。其次，使用
    JavaScript 属性黑名单应该让黑客意识到代码中可能存在 XSS 漏洞，因为这可能是开发者犯错的机会。第三，拥有 JavaScript 知识对于成功确认更复杂的漏洞至关重要。
- en: '**Summary**'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: XSS vulnerabilities represent real risk for site developers and are still prevalent
    on sites, often in plain sight. By submitting a malicious payload, like `<img
    src=x onerror=alert(document.domain)>`, you can check whether an input field is
    vulnerable. But this isn’t the only way to test for XSS vulnerabilities. Any time
    a site sanitizes input through modification (by removing characters, attributes,
    and so on), you should thoroughly test the sanitization functionality. Look for
    opportunities where sites are sanitizing input on submission rather than when
    rendering the input, and test all methods of input. Also, look for URL parameters
    you control being reflected on the page; these might allow you to find an XSS
    exploit that can bypass encoding, such as adding `javascript:alert(document.domain)`
    to the `href` value in an anchor tag.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 漏洞对网站开发者来说构成真实的风险，并且仍然在许多网站上普遍存在，常常暴露在明面上。通过提交恶意负载，例如`<img src=x onerror=alert(document.domain)>`，你可以检查输入字段是否存在漏洞。但这并不是测试
    XSS 漏洞的唯一方法。每当网站通过修改（如删除字符、属性等）来净化输入时，你应该彻底测试净化功能。寻找那些网站在提交时净化输入而不是在渲染输入时进行净化的机会，并测试所有的输入方法。此外，查找你控制的
    URL 参数是否反映在页面上；这些可能允许你找到绕过编码的 XSS 漏洞，例如在锚点标签的`href`值中添加`javascript:alert(document.domain)`。
- en: It’s important to consider all places that a site is rendering your input and
    whether it’s in HTML or JavaScript. Keep in mind that XSS payloads might not execute
    immediately.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要考虑网站渲染输入的所有地方，并且要了解这些地方是使用 HTML 还是 JavaScript。记住，XSS 有效负载可能不会立即执行。
