- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**Data Compression**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据压缩**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: Sometimes the hard work of software is obvious to everyone, as it is with movie
    CGI and video game graphics. You don’t have to know anything about how computers
    work to be impressed with the visuals in films like *Avatar* and games like *Crysis*.
    Sometimes, though, software is doing its most amazing work when it looks like
    it’s not working hard at all.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，软件的辛勤工作对每个人都显而易见，就像电影中的计算机生成图像（CGI）和电子游戏图形一样。你不需要知道计算机是如何工作的，就能为《阿凡达》这样的电影和《孤岛危机》这样的游戏中的视觉效果所惊叹。然而，有时，软件在看似毫不费力的情况下，正完成着最令人惊叹的工作。
- en: Watching a high-definition movie on a disc or streamed over the Internet is
    something most of us take for granted. Isn’t that just storing and displaying
    images? Why would that require special techniques? To understand why we should
    be impressed with Blu-ray video and Netflix streaming, let’s look at what video
    was like before these formats came to be.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，通过光盘或互联网流媒体观看高清视频是我们大多数人理所当然的事情。这不就是存储和显示图像吗？为什么这需要特殊的技术？为了理解为什么我们应该对蓝光视频和Netflix流媒体感到惊叹，让我们先回顾一下在这些格式出现之前的视频是怎样的。
- en: 'Videocassettes, the earliest home video medium, recorded images on a roll of
    magnetic tape. These were analog recordings—magnetic transcriptions of the same
    signal that would’ve been broadcast by television antennas. The video resolution
    was even lower than what we now call “standard definition,” and as with other
    analog recordings like audiocassettes and vinyl records, the quality of the video
    would degrade over time. The one upside to videocassettes was their capacity:
    a longer movie merely required a longer spool of tape.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 录像带，最早的家庭视频介质，通过磁带卷录制图像。这些是模拟录音——磁性转录的信号，与电视天线广播的信号相同。视频分辨率甚至低于我们现在称为“标清”的标准，而且与其他模拟录音设备如录音带和黑胶唱片一样，视频质量会随着时间的推移而退化。录像带的唯一优点是它的容量：一部更长的电影只需要一卷更长的磁带。
- en: Next came the LaserDisc. About the size of LP records, these discs looked like
    larger versions of today’s DVDs and Blu-ray discs, but like videocassettes, they
    were still storing the analog broadcast-format signal. However, LaserDiscs recorded
    a higher-resolution picture that came close to standard definition, and allowed
    you to jump to particular places in the video without having to rewind or fast-forward
    the way you would with a videocassette. For a while, the LaserDisc seemed like
    the future of video, but now capacity was a problem. Unlike the effectively limitless
    capacity of a magnetic tape roll, LaserDiscs could hold only 60 minutes of video
    per side, so watching a movie meant flipping the disc halfway through or even
    switching discs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是激光影碟。它的大小约与黑胶唱片相当，这些光盘看起来像是今天的DVD和蓝光光盘的更大版本，但与录像带一样，它们仍然存储的是模拟广播格式的信号。然而，激光影碟记录了更高分辨率的图像，接近标准清晰度，并且允许你直接跳到视频中的特定位置，而不需要像使用录像带那样倒带或快进。曾一度，激光影碟看起来是视频的未来，但现在容量成了问题。与磁带卷几乎无限的容量不同，激光影碟每面最多只能存储60分钟的视频，因此观看电影意味着在中途翻转光盘，甚至更换光盘。
- en: Today, the problem of capacity is even more serious. Our Blu-ray discs are much
    smaller than LaserDiscs, but our videos are a much higher resolution. Let me put
    the problem into numbers. In high-definition video each frame is a 1920×1080 bitmap,
    a total of 2,073,600 pixels. If each pixel is stored in three-byte RGB format,
    one frame of a high-definition movie would require 6,220,800 bytes, or about 6.2
    megabytes (*mega* means “million”). Movies are recorded at 24 or 30 frames per
    second, which is 1,800 frames per minute, 108,000 frames per hour, or 216,000
    frames for a two-hour film. If each frame is 6,220,800 bytes, then 216,000 frames
    is 1,343,693 megabytes, or about 1,345 gigabytes (*giga* means “billion”).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，容量问题变得更加严重。我们的蓝光光盘比激光影碟小得多，但我们的视频分辨率却高得多。让我用数字来说明这个问题。在高清晰度视频中，每一帧是一个1920×1080的位图，总共有2,073,600个像素。如果每个像素存储为三字节的RGB格式，那么一帧高清电影将需要6,220,800字节，约为6.2兆字节（*兆*意味着“百万”）。电影以每秒24或30帧的速度录制，每分钟1,800帧，每小时108,000帧，或者一部两小时的电影需要216,000帧。如果每帧需要6,220,800字节，那么216,000帧就是1,343,693兆字节，约为1,345千兆字节（*千兆*意味着“十亿”）。
- en: How can all of that data fit on a Blu-ray disc? Part of the answer is the “blu-ray”
    itself, a blue laser that’s narrower than the laser used on LaserDiscs or even
    conventional DVDs, allowing more data to be packed into a smaller area, just as
    smaller print allows more words on a page. Even so, a Blu-ray can store only about
    50 gigabytes(GB) of data, less than 4 percent of what’s required.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么所有这些数据如何能存储在一张蓝光光盘上呢？部分原因是“蓝光”本身，它使用的蓝激光比激光唱片或甚至传统DVD上使用的激光更窄，从而允许将更多数据压缩到更小的区域，就像更小的字体可以让一页上容纳更多的文字一样。即便如此，一张蓝光光盘最多也只能存储约50GB的数据，这还不到所需数据的4%。
- en: Streaming video has the same problem. If one frame of video is 6.2 megabytes
    (MB), and the video is running at 30 frames per second, then streaming requires
    an Internet connection of 186 megabytes per second (MBps). A typical home broadband
    connection is more like 4MBps. What’s worse, because of traffic congestion and
    hiccups in the network, you can’t count on maintaining the full rated bandwidth
    over the course of a long transmission. Realistically, streaming video should
    use no more than a couple of MBps at most.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 流媒体视频也面临同样的问题。如果一个视频帧是6.2兆字节（MB），并且视频以每秒30帧的速度播放，那么流媒体就需要每秒186兆字节（MBps）的互联网连接。而典型的家庭宽带连接大约只有4MBps。更糟糕的是，由于网络拥堵和波动，你无法指望在长时间传输过程中保持满负荷带宽。实际上，流媒体视频应该最多使用几兆字节每秒。
- en: So how can we fit giant amounts of video data into these small containers? The
    answer is *data compression*—storing data in a format that requires fewer bytes
    than the original format. Compression techniques can be broadly divided into two
    categories. With *lossless compression*, the compressed data can be restored to
    its exact original state. In contrast, *lossy compression* accepts that the restored
    data may be slightly different than the original. Video streaming and storage
    uses a combination of both types of compression. In this chapter, we’ll first
    investigate some general compression techniques using simple examples. Then we’ll
    see how these ideas apply to video, producing highly compressed sequences of images
    that look nearly as good as the uncompressed originals.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何将大量的视频数据存储进这些小容器中呢？答案是*数据压缩*——以比原始格式所需更少的字节来存储数据。压缩技术大致可以分为两类。*无损压缩*可以将压缩后的数据恢复到完全原始的状态。而*有损压缩*则接受恢复的数据可能与原始数据略有不同。视频流媒体和存储通常使用这两种压缩方式的结合。在本章中，我们将首先通过简单的例子研究一些通用的压缩技术。接着，我们将看到这些思想如何应用于视频，生成几乎与未压缩的原始图像一样清晰的高度压缩图像序列。
- en: '**Run-Length Encoding**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游程编码**'
- en: 'Most of us have employed some form of lossless compression, though we wouldn’t
    have called it that, because many techniques for lossless compression are commonsense
    ideas. One such method is *run-length encoding*. Suppose I were to show you a
    27-digit number for one minute to see whether you could remember it an hour later.
    That might sound hard, but look at the number:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人都使用过某种形式的无损压缩，虽然我们可能没这么称呼它，因为许多无损压缩的技术其实是常识性的方法。一个这样的例子是*游程编码*。假设我给你展示一个27位的数字，让你看一分钟，看看你是否能在一个小时后记住它。听起来可能很难，但看看这个数字：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I suspect you wouldn’t try to remember each digit individually. Instead, you’d
    count the occurrences of each digit, and remember it as “nine sevens, nine fives,
    and nine twos.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑你不会试图单独记住每个数字。相反，你会统计每个数字的出现次数，并把它记作“九个七，九个五，和九个二”。
- en: That’s run-length encoding in action. Repeats of the same piece of data (in
    this case, a digit) are called *runs*, and when runs are common, we can shorten
    the data by recording the lengths of the runs rather than the whole number. Run-length
    encoding is lossless compression, because if we remember the shorthand version
    of the number, we can reproduce the number in its original form whenever needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游程编码的作用。当相同的数据片段（在这个例子中是数字）重复出现时，这些重复的片段称为*游程*，当游程很常见时，我们可以通过记录游程的长度而不是整个数字来缩短数据。游程编码是无损压缩，因为如果我们记住了简写版本的数字，我们可以在需要时恢复出它的原始形式。
- en: Just by itself, run-length encoding can provide excellent compression for certain
    types of images, such as icons, logos, comic-book-style illustrations— any image
    with large blocks of solid color. When pixels have the same color as their neighbors,
    we can reduce the storage requirements considerably. As an example, I’ll describe
    the system used by the *TGA* image file format. TGA is short for *Truevision Graphics
    Adapter*, an early piece of graphics hardware designed for video editors. The
    file format, if not the adapter, is still in use in the video industry, and is
    probably the simplest example of run-length encoding for images.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅使用行程编码就可以为某些类型的图像提供极好的压缩效果，例如图标、标志、漫画风格的插图——任何具有大块单一颜色的图像。当像素与相邻像素颜色相同时，我们可以显著减少存储需求。举个例子，我将描述*TGA*图像文件格式使用的系统。TGA是*Truevision
    Graphics Adapter*（真视图图形适配器）的缩写，是一款早期的视频编辑硬件。尽管适配器已经不再使用，这种文件格式在视频行业中仍然被广泛应用，它可能是最简单的图像行程编码示例。
- en: The image data in a TGA file is compressed on a row-by-row basis. Within each
    row, each run of two or more pixels of exactly the same color is identified. The
    remaining pixels are called *raw* pixels. Consider the selected row in the sample
    image in [Figure 6-1](ch06.html#ch6fig1). In this row, there are several short
    runs of pixels, and several raw pixels that are different from their neighbors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: TGA文件中的图像数据是按行进行压缩的。在每一行中，所有两个或更多个完全相同颜色的像素连续块都会被识别出来。其余的像素被称为*原始*像素。考虑[图6-1](ch06.html#ch6fig1)中选中的示例图像行。在这一行中，有多个短的像素连续块，以及几个与邻近像素不同的原始像素。
- en: '![image](graphics/f06-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-01.jpg)'
- en: '*Figure 6-1: The selected row has a mix of runs and raw pixels.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：选中的行包含了连续块和原始像素的混合。*'
- en: The TGA format organizes runs and raw pixels into *packets*. Each packet begins
    with a one-byte header. The leftmost bit of the header byte determines whether
    it is a run packet or a raw packet. The other seven bits denote the size of the
    packet in pixels. Because the smallest packet has one pixel, TGA encodes the packet’s
    size as one less than its actual size; that is, a size field of 0000000 represents
    a size of 1, and 0000001 represents 2, and so on. Following the header is either
    the encoded color of all the pixels in the run, or for a raw packet, the colors
    of each individual pixel. Using the RGB color format, the row of pixels from [Figure
    6-1](ch06.html#ch6fig1) would be encoded as shown in [Table 6-1](ch06.html#ch6tab1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: TGA格式将连续的像素和原始像素组织成*数据包*。每个数据包以一个字节的头部开始。头部字节的最左侧位确定该数据包是连续块数据包还是原始数据包。其余七个位表示数据包的像素大小。因为最小的数据包包含一个像素，所以TGA将数据包的大小编码为比实际大小少1；即，大小字段为0000000表示大小为1，0000001表示大小为2，依此类推。头部后面跟着的是该连续块中所有像素的编码颜色，或者对于原始数据包，则是每个像素的单独颜色。使用RGB颜色格式时，[图6-1](ch06.html#ch6fig1)中的像素行将按照[表6-1](ch06.html#ch6tab1)中的方式进行编码。
- en: '**Table 6-1:** TGA Encoding of Pixel Row'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-1：TGA像素行的编码**'
- en: '| **Run/raw** | **Size** | **Red** | **Green** | **Blue** | **Description**
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **行程/原始** | **大小** | **红色** | **绿色** | **蓝色** | **描述** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 0000001 | 11111111 | 11111111 | 11111111 | Run of two white pixels |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0000001 | 11111111 | 11111111 | 11111111 | 两个白色像素的连续块 |'
- en: '| 1 | 0000010 | 11001100 | 11001100 | 00000000 | Run of three yellow pixels
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0000010 | 11001100 | 11001100 | 00000000 | 三个黄色像素的连续块 |'
- en: '| 0 | 0000001 | 11111111 | 11111111 | 11111111 | Raw packet of two pixels;
    first is white |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0000001 | 11111111 | 11111111 | 11111111 | 两个像素的原始数据包；第一个是白色 |'
- en: '|  |  | 00000000 | 10000000 | 00000000 | Second pixel in raw packet; dark green
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 00000000 | 10000000 | 00000000 | 原始数据包中的第二个像素；深绿色 |'
- en: '| 1 | 0000001 | 00000000 | 00000000 | 11111111 | Run of two blue pixels |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0000001 | 00000000 | 00000000 | 11111111 | 两个蓝色像素的连续块 |'
- en: '| 0 | 0000000 | 11111111 | 11111111 | 11111111 | One raw white pixel |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0000000 | 11111111 | 11111111 | 11111111 | 一个原始白色像素 |'
- en: This encoding requires 23 bytes versus the uncompressed size of 30 bytes. This
    *compression ratio* of 30:23, or about 4:3, isn’t very high, but note that a mere
    4 bytes are needed to store rows where every pixel is the same color, like the
    top row of [Figure 6-1](ch06.html#ch6fig1). The overall compression ratio of this
    bitmap in TGA format is an impressive 300:114, or about 5:2.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该编码需要23个字节，而未压缩的大小为30个字节。这个*压缩比*为30:23，约为4:3，虽然不算非常高，但需要注意的是，仅4个字节就足以存储每个像素颜色相同的行，例如[图6-1](ch06.html#ch6fig1)的顶行。这个TGA格式位图的整体压缩比为300:114，约为5:2，效果相当出色。
- en: '**Dictionary Compression**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典压缩**'
- en: Just by itself, run-length encoding can compress pictures with large blocks
    of solid colors, but most of the images in movies aren’t like that. For photographs
    and other types of digital images with lots of color variation, software has to
    work much harder to find patterns exploitable by compression. One of the key tools
    is known as *dictionary compression*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅使用自身，行程编码能够压缩包含大块纯色的图像，但电影中的大多数图像并不是这样。对于照片和其他类型的数字图像，其中有大量颜色变化，软件必须更加努力地寻找可以通过压缩利用的模式。一个关键工具被称为*词典压缩*。
- en: '***The Basic Method***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基本方法***'
- en: Later we’ll see how dictionary compression is used on images, but the idea is
    easiest to understand when it is applied to a text document, so let’s start there.
    An uncompressed text document is stored as a series of character codes such as
    ASCII.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将看到词典压缩如何应用于图像，但最容易理解这一概念的是将其应用于文本文件，因此我们从这里开始。未压缩的文本文件是作为一系列字符代码存储的，例如ASCII。
- en: 'We’ll compress this sample paragraph:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将压缩这个示例段落：
- en: Those pictures created by a computer are called computer graphics. When these
    pictures created by the computer are viewed in a sequence, that sequence is called
    an animation. An entire movie created from an animation, a sequence of pictures
    created by a computer, is called a computer-animated movie.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由计算机创建的图像称为计算机图形。当这些由计算机创建的图像按顺序查看时，这个顺序被称为动画。由动画组成的完整电影，即由计算机创建的一系列图像，称为计算机动画电影。
- en: 'To make this example simpler, I’ll ignore the spaces and punctuation in this
    text and just worry about the letters. There are 234 letters in this paragraph;
    stored as uncompressed ASCII text, the letters would require 234 bytes. To employ
    dictionary compression on this text, we first need a *dictionary*, which in this
    context is a numbered list of every word in the document being compressed. [Table
    6-2](ch06.html#ch6tab2) is our list of words, numbered both in decimal and binary.
    Note that capitalization counts: *an* and *An* are separate entries.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个示例，我将忽略文本中的空格和标点，只关注字母。这个段落中有234个字母；如果以未压缩的ASCII文本存储，这些字母将需要234字节。要对这些文本进行词典压缩，我们首先需要一个*词典*，在这个上下文中，词典是一个编号列表，列出了文档中每个被压缩的单词。[表6-2](ch06.html#ch6tab2)就是我们的单词列表，按十进制和二进制编号。请注意，大写字母和小写字母算作不同的条目：*an*
    和 *An* 是不同的条目。
- en: '**Table 6-2:** Dictionary Compression'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-2：** 词典压缩'
- en: '| **Position** | **Binary-encoded position** | **Word** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **二进制编码位置** | **单词** |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | 00000 | a |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 00000 | 一个 |'
- en: '| 2 | 00001 | an |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 00001 | 一个 |'
- en: '| 3 | 00010 | An |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 00010 | 一个 |'
- en: '| 4 | 00011 | animated |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 00011 | 动画 |'
- en: '| 5 | 00100 | animation |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 00100 | 动画 |'
- en: '| 6 | 00101 | are |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 00101 | 是 |'
- en: '| 7 | 00110 | by |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 00110 | 由 |'
- en: '| 8 | 00111 | called |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 00111 | 被称为 |'
- en: '| 9 | 01000 | computer |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 01000 | 计算机 |'
- en: '| 10 | 01001 | created |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 01001 | 创建 |'
- en: '| 11 | 01010 | entire |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 01010 | 整个 |'
- en: '| 12 | 01011 | from |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 01011 | 从 |'
- en: '| 13 | 01100 | graphics |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 01100 | 图形 |'
- en: '| 14 | 01101 | in |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 01101 | 在 |'
- en: '| 15 | 01110 | is |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 01110 | 是 |'
- en: '| 16 | 01111 | movie |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 01111 | 电影 |'
- en: '| 17 | 10000 | of |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 10000 | 的 |'
- en: '| 18 | 10001 | pictures |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 10001 | 图像 |'
- en: '| 19 | 10010 | sequence |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 10010 | 顺序 |'
- en: '| 20 | 10011 | the |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 10011 | 那个 |'
- en: '| 21 | 10100 | these |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 10100 | 这些 |'
- en: '| 22 | 10101 | Those |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 10101 | 那些 |'
- en: '| 23 | 10110 | viewed |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 10110 | 查看 |'
- en: '| 24 | 10111 | When |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 10111 | 当 |'
- en: As shown, 5 bits are sufficient to represent the range of positions used. Each
    word in the original paragraph is replaced with its position in this table. For
    example, instead of using eight ASCII codes (64 bits) for each appearance of the
    word *computer*, the 5-bit dictionary entry is used instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，5位足以表示所使用的位置范围。原文中的每个单词都被替换为该表中的位置。例如，代替每次出现的*计算机*使用八个ASCII码（64位），我们改用5位的词典条目。
- en: The dictionary itself takes up space, however, and must be included in the compressed
    document, so we save space only when a word appears more than once. In this example,
    the total number of letters for all words in our dictionary is 116, requiring
    116 bytes. Replacing each of the 48 words in the sample paragraph with a 5-bit
    dictionary reference requires 235 bits, or about 30 bytes. The total compressed
    storage, then, is 146 bytes, which compared to the original 234 uncompressed bytes
    is a compression ratio of about 8:5\. With longer documents the savings will be
    even better, because the text grows much faster than the dictionary. A typical
    novel, for example, is about 80,000 words long, but uses a vocabulary of only
    a few thousand words.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，字典本身需要占用空间，并且必须包含在压缩文档中，因此只有当一个单词出现超过一次时，我们才能节省空间。在这个例子中，字典中所有单词的总字母数为116，需占用116字节。将样本文本中48个单词中的每一个替换为一个5位字典引用需要235位，约为30字节。总的压缩存储量是146字节，相比原始未压缩的234字节，压缩比大约是8:5。对于较长的文档，节省的空间将会更明显，因为文本增长的速度远快于字典。例如，一本典型的小说大约有80,000个单词，但使用的词汇量只有几千个单词。
- en: '***Huffman Encoding***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***哈夫曼编码***'
- en: In almost every text, some words are used much more than others. A technique
    called *Huffman encoding* takes advantage of this fact to improve on basic dictionary
    compression.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有的文本中，某些单词的使用频率远高于其他单词。一种名为*哈夫曼编码*的技术利用了这一事实，以改进基本的字典压缩。
- en: To create a Huffman code, the words in the document are ranked by frequency.
    Imagine a children’s story with the 10-word vocabulary shown in [Table 6-3](ch06.html#ch6tab3).
    As with basic dictionary compression, each word is assigned a binary code, but
    here shorter codes are assigned to the words that appear most frequently in the
    story.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建哈夫曼编码，文档中的单词按频率排序。假设有一个儿童故事，词汇量为[表6-3](ch06.html#ch6tab3)中显示的10个单词。与基本字典压缩类似，每个单词都会被分配一个二进制编码，但在这里，出现频率最高的单词将被分配更短的编码。
- en: '**Table 6-3:** Huffman Code for a Children’s Story'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-3：** 儿童故事的哈夫曼编码'
- en: '| **Word** | **Frequency** | **Binary code** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **单词** | **频率** | **二进制编码** |'
- en: '| --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| the | 25% | 01 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| the | 25% | 01 |'
- en: '| a | 20% | 000 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| a | 20% | 000 |'
- en: '| princess | 12% | 100 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 公主 | 12% | 100 |'
- en: '| good | 11% | 110 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| good | 11% | 110 |'
- en: '| witch | 10% | 111 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 女巫 | 10% | 111 |'
- en: '| evil | 8% | 0010 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| evil | 8% | 0010 |'
- en: '| ate | 7% | 0011 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| ate | 7% | 0011 |'
- en: '| magic | 4% | 1010 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| magic | 4% | 1010 |'
- en: '| toadstool | 2% | 10110 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 蘑菇 | 2% | 10110 |'
- en: '| forevermore | 1% | 10111 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| forevermore | 1% | 10111 |'
- en: 'With the table in place, Huffman code compression is the same as basic dictionary
    compression: each word is replaced with its corresponding binary code. For example,
    the encoding for *the princess ate a magic toadstool* would start with 01 for
    *the*, then 100 for *princess*, and so on. In full, the encoding is:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦表格建立，哈夫曼编码压缩与基本字典压缩相同：每个单词都被其对应的二进制编码替换。例如，*the princess ate a magic toadstool*的编码将从*the*的01开始，接着是*princess*的100，依此类推。完整的编码是：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you may have noticed, the list of binary codes in [Table 6-3](ch06.html#ch6tab3)
    skips some possible codes, such as 011 or 0110\. Skipping codes is necessary to
    make this a *prefix code*, in which no binary code appears at the start of another.
    For example, because 01 is the code for *the*, other codes that begin with 01,
    such as 011 or 0110, are forbidden. Because the individual codes vary in length,
    a prefix code is necessary to know where each code ends. With our example, the
    01 that begins the bit sequence must be the code for *the* because no other code
    starts with 01; the only way to partition the whole sequence is as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，[表6-3](ch06.html#ch6tab3)中的二进制编码跳过了一些可能的编码，例如011或0110。跳过编码是必要的，以使其成为一个*前缀编码*，即没有任何二进制编码会出现在另一个编码的开头。例如，由于01是*the*的编码，其他以01开头的编码，如011或0110，都是禁止的。因为各个编码的长度不同，所以需要使用前缀编码来确定每个编码的结束位置。在我们的示例中，位序列开始的01必须是*the*的编码，因为没有其他编码以01开头；分割整个序列的唯一方式是：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we allowed a code that broke the prefix rule, the sequences could become
    ambiguous. Suppose *forevermore* is assigned the code 00\. While this is a shorter
    code, it means the example sequence could also be partitioned as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们允许一个违反前缀规则的编码，序列可能会变得模糊。假设*forevermore*被分配了编码00。虽然这是一个较短的编码，但它意味着该示例序列也可能被分解为：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This would decode as the phrase *the princess forevermore good forevermore magic
    toadstool*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解码为短语*the princess forevermore good forevermore magic toadstool*。
- en: By assigning the shortest codes to the most common words, Huffman encoding can
    achieve greater compression than dictionary compression alone when data can be
    stored as a relatively small set of codes and some codes are more common than
    others.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为最常见的单词分配最短的编码，霍夫曼编码在数据能够以相对较小的编码集存储且某些编码比其他编码更常见时，比仅使用字典压缩能获得更大的压缩效果。
- en: '**Reorganizing Data for Better Compression**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为了更好的压缩重组数据**'
- en: Unfortunately, the images we see in videos are not good candidates for Huffman
    encoding. Unlike the color-block images we compressed with the run-length technique,
    the pixels in a video image vary across the full range of possible colors. With
    16 million different possible RGB colors, it’s unlikely video images will have
    enough repetition to allow Huffman encoding to work. However, sometimes it’s possible
    to create repetition in varied data by changing how the data is stored.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们在视频中看到的图像并不是霍夫曼编码的理想对象。与我们使用游程编码压缩的色块图像不同，视频图像中的像素颜色覆盖了所有可能的颜色范围。由于RGB颜色有1600多万种不同的可能性，视频图像很可能没有足够的重复性来使霍夫曼编码有效。然而，有时可以通过改变数据存储方式，在变化的数据中创造出重复性。
- en: '***Predictive Encoding***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***预测编码***'
- en: 'For one such approach, consider a weather station that records the temperature
    once per hour, and over the course of one day stores the following readings:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以某种方法为例，考虑一个每小时记录一次温度的气象站，在一天的时间里，记录了以下数据：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**COMPRESSION IN ZIP FILES**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**ZIP文件中的压缩**'
- en: Dictionary compression and Huffman encoding are at the heart of most general
    compression schemes. The *.zip* archive format, for example, can choose from a
    half-dozen compression methods but usually employs an algorithm called *deflate*.
    Rather than replacing duplicated data with a reference number from a list of words,
    this algorithm employs a variation of dictionary compression called a *sliding
    window*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 字典压缩和霍夫曼编码是大多数通用压缩方案的核心。例如，*.zip*存档格式可以选择多种压缩方法，但通常使用一种叫做*deflate*的算法。与其用一个来自单词列表的参考编号替换重复数据，这个算法使用一种称为*滑动窗口*的字典压缩变体。
- en: With this method, duplicate data is replaced with numerical indicators showing
    where the data occurred previously. In the textual example of [Figure 6-2](ch06.html#ch6fig2),
    there are three duplicate runs of characters. The first member of each pair is
    the number of characters to go back, and the second number is the length of the
    run. For example, the pair 5, 2 means “go back five characters, and copy two characters.”
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，重复的数据被用数字指示符替换，显示数据之前出现的位置。在[图6-2](ch06.html#ch6fig2)中的文本示例中，有三个重复的字符序列。每一对数字的第一个数字是回溯的字符数，第二个数字是连续字符的长度。例如，数字对5,
    2表示“回溯五个字符，并复制两个字符。”
- en: '![image](graphics/f06-02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-02.jpg)'
- en: '*Figure 6-2: Sliding-window compression*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：滑动窗口压缩*'
- en: The compressed version of this text can be symbolically written as “Then t[5,2]
    scar[5,5]ed[16,4]m.” Instead of the number pairs being stored directly, though,
    they are Huffman-encoded, so the most commonly occurring pairs are assigned shorter
    codes. The deflate method is a highly effective general compression scheme, capable
    of reducing the 3,138,473 characters in a raw text version of Tolstoy’s *War and
    Peace* to a *.zip* file of around 930,000 bytes, about a 10:3 ratio.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段文本的压缩版本可以象征性地写成“Then t[5,2] scar[5,5]ed[16,4]m。”不过，这些数字对并不是直接存储的，而是经过霍夫曼编码的，因此最常见的数字对会被分配更短的编码。deflate方法是一种非常有效的通用压缩方案，能够将托尔斯泰《战争与和平》的原始文本版本中的3,138,473个字符压缩成大约930,000字节的*.zip*文件，压缩比大约为10:3。
- en: 'If we assume a temperature range of 120 to –50, we can store each temperature
    in an 8-bit byte, using 192 bits total. There aren’t many duplicates in this list,
    though, so Huffman encoding won’t be effective. The situation improves if we rewrite
    this list using *predictive encoding*. For every temperature after the first,
    we’ll record not the temperature itself, but its difference from the previous
    temperature. Now the list looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设温度范围从120到-50，我们可以用一个8位字节存储每个温度，共使用192位。不过，这个列表中没有太多重复项，因此霍夫曼编码并不有效。如果我们使用*预测编码*重新编写这个列表，情况就有所改善。对于第一个温度之后的每一个温度，我们记录的不是温度本身，而是它与前一个温度的差值。现在，列表看起来是这样的：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Whereas the original data had few duplicates, the predictive-encoded data has
    many. Now we can apply Huffman encoding with excellent results.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据重复较少，而预测编码后的数据重复性较强。现在我们可以应用霍夫曼编码，取得非常好的效果。
- en: '***Quantization***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***量化***'
- en: 'Another approach, if we are willing to accept some degradation of the data,
    is *quantization*, where we store the data with less precision. Suppose the weather
    station from the previous example also records daily rainfall amounts, taking
    the following readings over the course of three weeks:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是，如果我们愿意接受一定的数据劣化，可以采用*量化*，即以较低的精度存储数据。假设前面例子中的气象站还记录了每日降水量，并在三周内进行了如下读数：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These readings have two decimal places, but maybe we don’t actually need this
    much precision in the data. For one thing, any amount below 0.05 might represent
    condensation on the collector rather than actual rain; likewise, condensation
    might also be the only difference between readings like 1.23 and 1.21\. So let’s
    leave off the last digit of every number:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些读数有两位小数，但我们可能实际上不需要这么高的精度。首先，0.05以下的任何数值可能代表的是收集器上的冷凝水，而不是实际的降水；同样，1.23和1.21这样的读数之间的差异也可能只是冷凝水的区别。因此，我们可以省略每个数字的小数点后最后一位：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By itself, this compresses the data, since storing one place after the decimal
    will take fewer bits than storing two. In addition, the quantized data also has
    several runs of zeros that can be compressed with run-length encoding, and some
    duplicates that can be compressed by Huffman encoding.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，数据就被压缩了，因为存储小数点后一个位数所需的位数比存储两个位数所需的位数要少。此外，量化后的数据也有几个零的连续序列，可以通过行程长度编码进行压缩，还有一些重复的数据可以通过霍夫曼编码进行压缩。
- en: These techniques point to a general multistage approach for compression. First,
    reorganize the data to increase the runs and duplicates, by storing small differences
    between numbers rather than the raw numbers themselves, quantizing the data, or
    both. Then compress the data with run-length and Huffman encoding.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术指向了一种通用的多阶段压缩方法。首先，通过存储数字之间的小差异而不是原始数字本身，量化数据，或两者结合，来重新组织数据，从而增加行程和重复的出现。然后，使用行程长度编码和霍夫曼编码来压缩数据。
- en: '**JPEG Images**'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**JPEG 图像**'
- en: We now have almost all the tools needed to compress video. The logical first
    step in compressing a video is to compress the individual images in the video.
    However, we can’t directly apply predictive encoding and quantization to digital
    photographs and other images with lots of subtle color variation; we need to convert
    these pictures to another format first.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎拥有压缩视频所需的所有工具。压缩视频的逻辑第一步是压缩视频中的单个图像。然而，我们不能直接将预测编码和量化应用于具有大量细微色差的数字照片和其他图像；我们需要先将这些图片转换成另一种格式。
- en: That’s the idea behind *JPEG*, a common compressed-image format designed specifically
    for digital photographs. (The name is the acronym for the *Joint Photography Experts
    Group* that developed the format.) The compression method for this format is based
    on a couple of key observations of photography and human perception.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*JPEG*的基本思想，JPEG是一种专门为数字照片设计的常见压缩图像格式。（这个名字是由开发该格式的*联合摄影专家组*的缩写组成的。）该格式的压缩方法基于对摄影和人类感知的几个关键观察结果。
- en: First, although pixel colors may vary widely throughout an image, individual
    pixels tend to be similar to their neighbors. If you take a picture of a leafy
    tree against a partly cloudy sky, lots of green leaf pixels will be next to other
    green pixels, blue sky pixels will neighbor blue sky pixels, and gray cloud pixels
    will neighbor gray cloud pixels.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尽管像素颜色在图像中可能会有很大的变化，但单个像素往往与其邻近像素相似。如果你拍摄一棵树的照片，背景是部分多云的天空，那么许多绿色的叶片像素将与其他绿色像素相邻，蓝色的天空像素将与蓝色天空像素相邻，灰色的云朵像素将与灰色云朵像素相邻。
- en: Second, among neighboring pixels, there will be more noticeable variation in
    brightness levels than in color tone. For our tree photograph, each of the myriad
    leaf pixels will reflect a different quantity of sunlight, but the underlying
    color of each pixel will be roughly similar. Also, although the mechanisms of
    human vision are not completely understood, tests indicate that we perceive differences
    in brightness more distinctly than differences in color.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在相邻的像素之间，亮度的变化会比色调的变化更为显著。以我们的树木照片为例，每个无数的叶片像素都会反射不同数量的阳光，但每个像素的基础颜色大致相同。此外，虽然人类视觉机制尚未完全理解，但测试表明，我们对亮度差异的感知比对色差的感知更加明显。
- en: High compression of digital photographs is possible only with lossy compression;
    we have to accept some degradation of the image. Following these key observations,
    though, allows the JPEG format to throw away the data that is least likely to
    be missed. In our tree photograph, the most important distinctions are the broad
    differences between leaf and sky, or sky and cloud, not between two neighboring
    cloud pixels. After that, the most important distinction is the relative brightness
    of pixels, more so than relative color. The JPEG format therefore gives priority
    to broad differences over fine differences, and brightness over color.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 数字照片的高压缩仅能通过有损压缩实现；我们必须接受图像的某些退化。然而，遵循这些关键观察结果，可以使 JPEG 格式丢弃那些最不容易被察觉的数据。在我们的树木照片中，最重要的区分是树叶和天空之间的广泛差异，或者天空和云朵之间的差异，而不是两颗相邻云朵像素之间的差异。之后，最重要的区分是像素的相对亮度，而非相对颜色。因此，JPEG
    格式优先考虑广泛差异而非细微差异，优先考虑亮度而非颜色。
- en: '***A Different Way to Store Colors***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***另一种存储颜色的方式***'
- en: 'JPEG compression divides images into 8×8 blocks of pixels that are independently
    compressed. To compress brightness and color differently, each pixel’s R, G, and
    B values are converted to three other numbers *Y*, *Cb*, and *Cr*. Here, Y is
    the *luminance* of the pixel, or how much light the pixel produces. Cb is the
    *blue difference*, and Cr is the *red difference*. The simplest way to envision
    the YCbCr system is to imagine a dark green video screen with three knobs labeled
    Y, Cb, and Cr initially set to zero: turn up Y and the screen is brighter; turn
    up Cb and the screen becomes more blue and less green; turn up Cr and the screen
    becomes more red and less green. [Table 6-4](ch06.html#ch6tab4) lists a few named
    colors in both systems for comparison. (A historical note: YCbCr is derived from
    the color system used in broadcast television. In the early days of color television,
    the remaining black-and-white televisions could properly display color transmissions
    by interpreting only the Y component of the signal.)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG 压缩将图像划分为 8×8 像素块，并对每个块进行独立压缩。为了分别压缩亮度和颜色，每个像素的 R、G 和 B 值会被转换为三个其他数值 *Y*、*Cb*
    和 *Cr*。这里，Y 表示像素的 *亮度*，即像素产生的光的强度。Cb 是 *蓝色差值*，Cr 是 *红色差值*。最简单的理解 YCbCr 系统的方法是想象一个黑绿色的视频屏幕，屏幕上有三个旋钮标记为
    Y、Cb 和 Cr，初始时都设为零：提高 Y，屏幕变亮；提高 Cb，屏幕变得更蓝且绿色减少；提高 Cr，屏幕变得更红且绿色减少。[表 6-4](ch06.html#ch6tab4)列出了在两种系统中比较的几种命名颜色。（历史注：YCbCr
    来源于电视广播中使用的颜色系统。在早期彩色电视的时代，剩下的黑白电视机通过只解释信号中的 Y 分量就能正确显示彩色图像。）
- en: '**Table 6-4:** Select Colors in the RGB and YCbCr Color Systems'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-4：** RGB 和 YCbCr 颜色系统中的选择颜色'
- en: '| **R** | **G** | **B** | **Color description** | **Y** | **Cb** | **Cr** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **R** | **G** | **B** | **颜色描述** | **Y** | **Cb** | **Cr** |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 255 | 0 | Lime green | 145 | 54 | 34 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 255 | 0 | 青柠绿 | 145 | 54 | 34 |'
- en: '| 255 | 255 | 255 | Pure white | 235 | 128 | 128 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 255 | 255 | 255 | 纯白色 | 235 | 128 | 128 |'
- en: '| 0 | 255 | 255 | Aqua | 170 | 166 | 16 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 255 | 255 | 水绿色 | 170 | 166 | 16 |'
- en: '| 128 | 0 | 0 | Maroon | 49 | 109 | 184 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 0 | 0 | 栗色 | 49 | 109 | 184 |'
- en: JPEG compresses the Y, Cb, and Cr data separately, so we can think of each 8×8
    block of pixels as becoming three 8×8 blocks of Y, Cb, and Cr data. Separating
    the data this way takes advantage of the greater variation in brightness than
    in color. Under the YCbCr system, most of the differences between the pixels will
    be concentrated in the Y component. The lower variance in the Cb and Cr blocks
    will make them easier to compress, and because we’re more sensitive to variations
    in luminance than variations of color, the Cb and Cr blocks can be compressed
    more heavily.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG 分别压缩 Y、Cb 和 Cr 数据，因此我们可以将每个 8×8 像素块看作是由三个 8×8 的 Y、Cb 和 Cr 数据块组成。这种数据分离方式利用了亮度比颜色变化更大的特点。在
    YCbCr 系统下，大多数像素之间的差异会集中在 Y 分量中。Cb 和 Cr 数据块的低方差使得它们更容易压缩，而且由于我们对亮度变化的敏感度高于对颜色变化的敏感度，Cb
    和 Cr 数据块可以进行更高比例的压缩。
- en: '***The Discrete Cosine Transform***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***离散余弦变换***'
- en: The conversion to YCbCr follows the observation that brightness is more important
    than color. To take advantage of the greater importance of broad changes over
    narrow changes, though, we need to convert each 8×8 data blocks yet again. The
    *discrete cosine transform (DCT)* converts the absolute luminance and color data
    into relative measurements of how these values differ from pixel to pixel. Although
    this transformation is applied to an entire 8×8 block of numbers, I’ll first illustrate
    the idea with a single row of eight numbers from the luminance (Y) block, shown
    as shades of gray in [Figure 6-3](ch06.html#ch6fig3).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为 YCbCr 遵循亮度比颜色更重要的观察。为了利用宽范围变化相较于窄范围变化更重要的特点，我们需要再次转换每个 8×8 数据块。然而，*离散余弦变换（DCT）*
    将绝对亮度和颜色数据转换为这些值如何在像素之间变化的相对度量。尽管这种变换应用于整个 8×8 的数字块，但我首先将通过一个亮度（Y）块中的单行八个数字来说明这个概念，这些数字在
    [图 6-3](ch06.html#ch6fig3) 中以灰度表示。
- en: '![image](graphics/f06-03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-03.jpg)'
- en: '*Figure 6-3: A row of luminance levels*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：一行亮度级别*'
- en: To begin the DCT, we subtract 128 from each number, which has the effect of
    moving the 0–255 range to a range centered around 0, so that maximum brightness
    is 127 and absolute black is –128\. The resulting luminance levels for the row
    are depicted as a line chart in [Figure 6-4](ch06.html#ch6fig4).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始 DCT，我们从每个数字中减去 128，这样可以将 0-255 的范围移动到围绕 0 的新范围，因此最大亮度为 127，绝对黑色为 -128。该行的结果亮度级别在
    [图 6-4](ch06.html#ch6fig4) 中以折线图表示。
- en: '![image](graphics/f06-04.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-04.jpg)'
- en: '*Figure 6-4: Subtracting 128 from each luminance level centers the range of
    possible numbers around 0.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：从每个亮度级别中减去 128，使得可能数字的范围围绕 0 居中。*'
- en: The DCT produces eight new numbers that each combine the eight luminance levels
    in a different way. [Figure 6-5](ch06.html#ch6fig5) shows the DCT of the previous
    figure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 离散余弦变换（DCT）生成了八个新数字，每个数字以不同的方式组合了八个亮度级别。[图 6-5](ch06.html#ch6fig5) 显示了上一张图的
    DCT。
- en: '![image](graphics/f06-05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-05.jpg)'
- en: '*Figure 6-5: The discrete cosine transform of the data in [Figure 6-4](ch06.html#ch6fig4).*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：数据在 [图 6-4](ch06.html#ch6fig4) 中的离散余弦变换。*'
- en: 'Note that the numbers are labeled with a range from “coarse” to “fine.” The
    leftmost number in the DCT is the simplest combination of the luminance levels:
    their sum. Thus, the first number is the overall brightness of the pixels, and
    will be positive for a bright row of pixels and negative for a dark row. The second
    number effectively compares the luminance levels on the left end of the row against
    those on the right, and is positive in this example because our luminance levels
    are brighter on the left than on the right. The rightmost number effectively compares
    each luminance value against its immediate neighbors, and is close to 0 here because
    the numbers in [Figure 6-4](ch06.html#ch6fig4) change gradually.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数字按“粗糙”到“精细”的范围标记。DCT 中最左边的数字是亮度级别的最简单组合：它们的总和。因此，第一个数字是像素的总体亮度，对于亮度较高的像素行，它是正数，而对于较暗的像素行，它是负数。第二个数字有效地比较了行左端和右端的亮度级别，在本例中为正，因为我们左边的亮度级别比右边亮。最右边的数字有效地比较了每个亮度值与其邻近的像素，它在这里接近
    0，因为 [图 6-4](ch06.html#ch6fig4) 中的数字变化较为平缓。
- en: 'These DCT numbers are the coefficients that result from an operation called
    *matrix multiplication*. If your eyes just glazed over, don’t worry: the operation
    involves nothing more than multiplication and addition. We produce each coefficient
    by multiplying the luminance values by a different, predetermined vector. In this
    context, a *vector* is just an ordered list of numbers. The eight vectors used
    in the DCT are illustrated in [Figure 6-6](ch06.html#ch6fig6). (The numbers in
    each vector are related to the cosine function from trigonometry, which is where
    the discrete cosine transform gets its name, but we can safely ignore that for
    this discussion.)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 DCT 数字是由一种叫做 *矩阵乘法* 的操作得出的系数。如果你感到困惑，别担心：这个操作仅仅涉及乘法和加法。我们通过将亮度值与不同的预定向量相乘来生成每个系数。在这个上下文中，*向量*
    只是一个有序的数字列表。DCT 中使用的八个向量在 [图 6-6](ch06.html#ch6fig6) 中有示意图。（每个向量中的数字与三角学中的余弦函数相关，这也是离散余弦变换得名的原因，但我们可以忽略这一点，专注于讨论其他内容。）
- en: '![image](graphics/f06-06.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-06.jpg)'
- en: '*Figure 6-6: The vectors needed for our single-row DCT*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：我们单行 DCT 所需的向量*'
- en: To produce a coefficient for our luminance row, we multiply each number in a
    vector by the luminance in the same position. For example, [Table 6-5](ch06.html#ch6tab5)
    shows the computation of the Vector 2 coefficient for our luminance row. Each
    number from the luminance row is multiplied by the number in the same position
    in Vector 1; then, these products are summed to get 157.386.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算亮度行的系数，我们将向量中每个数字与相同位置的亮度相乘。例如，[表 6-5](ch06.html#ch6tab5) 显示了如何计算亮度行的向量
    2 系数。每个亮度行中的数字都与向量 1 中相同位置的数字相乘，然后将这些乘积求和，得到 157.386。
- en: '**Table 6-5:** Computing the Coefficient for Vector 2'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-5：** 计算向量 2 的系数'
- en: '| **Position** | **Luminance (from [Figure 6-4](ch06.html#ch6fig4))** | **Vector**
    | **Product** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **亮度（来自 [图 6-4](ch06.html#ch6fig4)）** | **向量** | **乘积** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | 76 | 0.49 | 37.24 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 76 | 0.49 | 37.24 |'
- en: '| 2 | 127 | 0.416 | 52.832 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 127 | 0.416 | 52.832 |'
- en: '| 3 | 127 | 0.278 | 35.306 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 127 | 0.278 | 35.306 |'
- en: '| 4 | 76 | 0.098 | 7.448 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 76 | 0.098 | 7.448 |'
- en: '| 5 | 25 | –0.098 | –2.45 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 25 | –0.098 | –2.45 |'
- en: '| 6 | –26 | –0.278 | 7.228 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 6 | –26 | –0.278 | 7.228 |'
- en: '| 7 | –77 | –0.416 | 32.032 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 7 | –77 | –0.416 | 32.032 |'
- en: '| 8 | 25 | –0.49 | –12.25 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 25 | –0.49 | –12.25 |'
- en: '| Total |  |  | 157.386 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 总计 |  |  | 157.386 |'
- en: Looking at the vectors of [Figure 6-6](ch06.html#ch6fig6), you can see how each
    combines the luminance levels differently. Because every number in Vector 1 is
    the same positive number, the Vector 1 coefficient becomes a measure of overall
    brightness. Because Vector 2’s numbers gradually sweep from high to low, the second
    coefficient will be positive when luminance tends to fall off from the left to
    right in the pixel row, and negative when luminance tends to increase. Vector
    3’s coefficient is a measure of how the ends of the row differ from the middle,
    and so on. You’ve already seen the resulting coefficients charted in [Figure 6-5](ch06.html#ch6fig5);
    [Table 6-6](ch06.html#ch6tab6) shows the result numerically.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [图 6-6](ch06.html#ch6fig6) 的向量，你可以看到每个向量如何以不同的方式组合亮度级别。由于向量 1 中的每个数值都是相同的正数，因此向量
    1 的系数成为整体亮度的度量。由于向量 2 中的数值逐渐从高到低变化，当亮度从左到右在像素行中逐渐下降时，第二个系数为正，而当亮度趋向增加时，系数为负。向量
    3 的系数衡量的是行的两端与中间的差异，依此类推。你已经在 [图 6-5](ch06.html#ch6fig5) 中看到了这些结果系数的图示；[表 6-6](ch06.html#ch6tab6)
    则通过数字展示了结果。
- en: '**Table 6-6:** Coefficients from the Discrete Cosine Transform of the Sample
    Luminance Row'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-6：** 从样本亮度行的离散余弦变换系数'
- en: '| **Vector number** | **Coefficient** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **向量编号** | **系数** |'
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 124.804 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 124.804 |'
- en: '| 2 | 157.296 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 157.296 |'
- en: '| 3 | –9.758 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 3 | –9.758 |'
- en: '| 4 | –87.894 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 4 | –87.894 |'
- en: '| 5 | 18.031 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 18.031 |'
- en: '| 6 | –49.746 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 6 | –49.746 |'
- en: '| 7 | 23.559 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 23.559 |'
- en: '| 8 | –13.096 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 8 | –13.096 |'
- en: 'The process is reversible: we can retrieve the original luminance numbers from
    [Figure 6-4](ch06.html#ch6fig4) by multiplying the eight coefficients against
    eight different vectors, a process called the *inverse discrete cosine transform
    (IDCT)*. [Table 6-7](ch06.html#ch6tab7) shows how the second luminance value,
    127, is extracted from the coefficients.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程是可逆的：我们可以通过将八个系数与八个不同的向量相乘来恢复原始的亮度数值，这个过程称为 *逆离散余弦变换（IDCT）*。[表 6-7](ch06.html#ch6tab7)
    展示了如何从系数中提取第二个亮度值 127。
- en: '**Table 6-7:** Computing the Second Luminance Value from the Coefficients'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-7：** 从系数计算第二个亮度值'
- en: '| **Position** | **Coefficient** | **Vector** | **Product** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **系数** | **向量** | **乘积** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | 124.804 | 0.354 | 44.125 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 124.804 | 0.354 | 44.125 |'
- en: '| 2 | 157.296 | 0.416 | 65.393 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 157.296 | 0.416 | 65.393 |'
- en: '| 3 | –9.758 | 0.191 | –1.867 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 3 | –9.758 | 0.191 | –1.867 |'
- en: '| 4 | –87.894 | –0.098 | 8.574 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 4 | –87.894 | –0.098 | 8.574 |'
- en: '| 5 | 18.031 | –0.354 | –6.375 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 18.031 | –0.354 | –6.375 |'
- en: '| 6 | –49.746 | –0.49 | 24.395 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 6 | –49.746 | –0.49 | 24.395 |'
- en: '| 7 | –23.559 | –0.462 | –10.833 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 7 | –23.559 | –0.462 | –10.833 |'
- en: '| 8 | –13.096 | –0.278 | 3.638 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 8 | –13.096 | –0.278 | 3.638 |'
- en: '| Total |  |  | 127 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 总计 |  |  | 127 |'
- en: 'The DCT, then, gives us a different way of storing the same numbers: as the
    relationship between the data rather than the data itself. Why is this useful?
    Remember that fine distinctions between pixels are less noticeable than broader
    distinctions. Later, you’ll see how the DCT allows the JPEG format to compress
    the fine details more than the broad.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 离散余弦变换（DCT）为我们提供了一种不同的方式来存储相同的数字：作为数据之间的关系，而不是数据本身。为什么这很有用？记住，像素之间的细微差别比大范围的差别不那么显眼。稍后你会看到，DCT
    如何让 JPEG 格式在压缩细节时比压缩大范围内容更有效。
- en: '***The DCT for Two Dimensions***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二维 DCT***'
- en: JPEG compression works not on rows of pixels but on 8×8 pixel blocks, so now
    let’s see how the DCT operates in two dimensions. The one-dimensional DCT multiplies
    eight vectors with the original eight numbers to produce eight coefficients. The
    two-dimensional DCT, though, requires 64 *matrices*, each matrix being an 8×8
    table of numbers. Like the vectors, each matrix will multiply all 64 pieces of
    data in the 8×8 block.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG 压缩不是在像素行上工作，而是在 8×8 像素块上工作，因此现在让我们来看一下二维 DCT 如何操作。一维 DCT 将八个向量与原始的八个数字相乘，产生八个系数。然而，二维
    DCT 需要 64 个 *矩阵*，每个矩阵是一个 8×8 的数字表。像向量一样，每个矩阵将与 8×8 块中的所有 64 个数据相乘。
- en: The matrices themselves are two-dimensional combinations of the vectors we saw
    earlier. This is easiest to understand pictorially. [Figure 6-7](ch06.html#ch6fig7)
    shows the combination of a horizontal Vector 1 and a vertical Vector 1\. Because
    the numbers in Vector 1 are all the same, the numbers in the resulting matrix
    are as well. In these matrix illustrations, lighter gray means a higher number.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些矩阵本身是我们之前看到的向量的二维组合。最容易理解的是通过图示。[图 6-7](ch06.html#ch6fig7) 显示了水平向量 1 与垂直向量
    1 的组合。由于向量 1 中的所有数字都是相同的，结果矩阵中的数字也是相同的。在这些矩阵示意图中，较浅的灰色表示较大的数字。
- en: '![image](graphics/f06-07.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-07.jpg)'
- en: '*Figure 6-7: The matrix combination of Vector 1 and itself*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-7：向量 1 与自身的矩阵组合*'
- en: In [Figure 6-8](ch06.html#ch6fig8), horizontal Vector 1 is combined with vertical
    Vector 2\. The resulting matrix gradually varies from top to bottom as Vector
    2 gradually varies, but doesn’t vary left to right because the numbers in Vector
    1 don’t vary.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-8](ch06.html#ch6fig8)中，水平向量 1 与垂直向量 2 组合。结果矩阵从上到下逐渐变化，因为向量 2 逐渐变化，但从左到右没有变化，因为向量
    1 中的数字没有变化。
- en: '![image](graphics/f06-08.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-08.jpg)'
- en: '*Figure 6-8: The matrix combination of Vector 1 and Vector 2*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-8：向量 1 和向量 2 的矩阵组合*'
- en: '[Figure 6-9](ch06.html#ch6fig9) shows a last example, Vector 8 combined with
    Vector 8\. Because Vector 8 swings back and forth from positive to negative, the
    combination matrix has a checkerboard quality.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-9](ch06.html#ch6fig9) 显示了最后一个例子，向量 8 与向量 8 的组合。由于向量 8 在正负之间来回摆动，组合矩阵呈现棋盘格样式。'
- en: '![image](graphics/f06-09.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-09.jpg)'
- en: '*Figure 6-9: The matrix combination of Vector 8 and itself*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-9：向量 8 与自身的矩阵组合*'
- en: The two-dimensional DCT replaces each of the 64 numbers in an 8×8 block with
    a matrix coefficient. [Figure 6-10](ch06.html#ch6fig10) shows which matrices are
    used for a few locations. Similar to the one-dimensional DCT, the coefficient
    in the upper left, which is the same shown in [Figure 6-7](ch06.html#ch6fig7),
    sums all the numbers in the original block equally. As we progress downward and
    to the right, the distinctions being measured grow finer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 二维离散余弦变换（DCT）将 8×8 块中的每一个 64 个数字替换为一个矩阵系数。[图 6-10](ch06.html#ch6fig10) 显示了用于几个位置的矩阵。与一维
    DCT 相似，左上角的系数（在[图 6-7](ch06.html#ch6fig7)中显示的是相同的）将原始块中的所有数字平均求和。随着我们向下和向右移动，测量的差异变得越来越细。
- en: '![image](graphics/f06-10.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-10.jpg)'
- en: '*Figure 6-10: Some of the matrices used in the two-dimensional DCT*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-10：用于二维离散余弦变换（DCT）的一些矩阵*'
- en: To demonstrate the two-dimensional DCT, I’ll use just the luminance values of
    the pixel block shown in [Figure 6-11](ch06.html#ch6fig11).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示二维 DCT，我将仅使用[图 6-11](ch06.html#ch6fig11)中显示的像素块的亮度值。
- en: '![image](graphics/f06-11.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-11.jpg)'
- en: '*Figure 6-11: A block of pixels and the associated luminance (Y) block*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-11：一个像素块及其关联的亮度（Y）块*'
- en: '[Figure 6-12](ch06.html#ch6fig12) shows the same luminance block with 128 subtracted
    from each number to make a range from –127 to 128 centered around 0.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-12](ch06.html#ch6fig12) 显示了相同的亮度块，其中每个数字都减去 128，使其范围从 –127 到 128，中心为 0。'
- en: '![image](graphics/f06-12.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-12.jpg)'
- en: '*Figure 6-12: The luminance block from [Figure 6-11](ch06.html#ch6fig11) with
    the range of possible values centered around 0*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-12：[图 6-11](ch06.html#ch6fig11)中的亮度块，值的范围围绕 0 进行居中*'
- en: '[Figure 6-13](ch06.html#ch6fig13) shows the luminance block after DCT. Each
    number is the coefficient resulting from multiplying the matrix of luminance values
    in [Figure 6-12](ch06.html#ch6fig12) with one of the matrices from [Figure 6-10](ch06.html#ch6fig10).
    Remember that these numbers, too, are centered around 0\. So the 132 in the upper
    left, for example, indicates a high luminance level for the block as a whole.
    Notice that the numbers in the upper left are largest in magnitude (furthest from
    0 in either direction), indicating that broad luminance differences are much greater
    than the fine differences in this pixel block. This result is typical of JPEG-encoded
    photographs.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-13](ch06.html#ch6fig13)显示了 DCT 后的亮度块。每个数字是通过将[图 6-12](ch06.html#ch6fig12)中亮度值的矩阵与[图
    6-10](ch06.html#ch6fig10)中的矩阵相乘得到的系数。记住，这些数字也是围绕 0 中心的。例如，左上角的 132 表示整个块的高亮度水平。注意，左上角的数字是最大的（远离
    0），这表明广泛的亮度差异比这个像素块中的细微差异要大得多。这一结果是 JPEG 编码照片的典型特征。'
- en: '![image](graphics/f06-13.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-13.jpg)'
- en: '*Figure 6-13: The DCT of the block in [Figure 6-12](ch06.html#ch6fig12)*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-13：在[图 6-12](ch06.html#ch6fig12)中的块的 DCT*'
- en: '***Compressing the Results***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***压缩结果***'
- en: Now the real compression can begin, the first step of which is quantization.
    [Figure 6-14](ch06.html#ch6fig14) shows the 8×8 block of divisors used for quantizing
    the luminance block. Each number in the coefficient block of [Figure 6-13](ch06.html#ch6fig13)
    is divided by the number in the same position in [Figure 6-14](ch06.html#ch6fig14),
    with results rounded to the nearest whole number. This degrades the image through
    quantization error, but note that the divisors in [Figure 6-14](ch06.html#ch6fig14)
    are smallest in the upper left. Thus, the quantization error is most pronounced
    in the coefficients that measure the finest distinctions, where the error is least
    likely to be noticed. The actual values of the divisors varies according to the
    compression quality, with larger divisors used to quantize the Cr and Cb blocks,
    but the divisor block always follows this general pattern (lower values in the
    upper left, higher in the bottom right).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正的压缩可以开始，第一步是量化。[图 6-14](ch06.html#ch6fig14)显示了用于量化亮度块的 8×8 除数块。[图 6-13](ch06.html#ch6fig13)中系数块中的每个数字都被除以[图
    6-14](ch06.html#ch6fig14)中相同位置的数字，结果四舍五入到最接近的整数。这通过量化误差降低了图像质量，但请注意，[图 6-14](ch06.html#ch6fig14)中的除数在左上角是最小的。因此，量化误差在测量最细微区别的系数中最为显著，而这些误差最不容易被察觉。除数的实际值根据压缩质量的不同而有所变化，用于量化
    Cr 和 Cb 块的除数较大，但除数块始终遵循这一一般模式（左上角的值较低，右下角的值较高）。
- en: '![image](graphics/f06-14.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-14.jpg)'
- en: '*Figure 6-14: The divisors used to quantize luminance blocks*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-14：用于量化亮度块的除数*'
- en: The result of quantization for our sample block is shown in [Figure 6-15](ch06.html#ch6fig15).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例块的量化结果显示在[图 6-15](ch06.html#ch6fig15)中。
- en: You can see how suitable these numbers are for run-length and Huffman encoding.
    Most of the coefficients have been quantized all the way down to 0, with many
    duplicate coefficients among the rest.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些数字是如何适合于运行长度编码和霍夫曼编码的。大多数系数已经被量化为 0，剩余部分中有许多重复的系数。
- en: After quantization, nonzero results tend to cluster in the upper left of the
    matrix, so the quantized numbers are listed in the zigzag pattern shown in [Figure
    6-16](ch06.html#ch6fig16).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 量化后，非零结果倾向于聚集在矩阵的左上角，因此量化后的数字以[图 6-16](ch06.html#ch6fig16)中所示的锯齿形模式列出。
- en: '![image](graphics/f06-15.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-15.jpg)'
- en: '*Figure 6-15: The quantized luminance block*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-15：量化后的亮度块*'
- en: '![image](graphics/f06-16.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-16.jpg)'
- en: '*Figure 6-16: Storing coefficients in a zigzag order*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-16：以锯齿形顺序存储系数*'
- en: 'This zigzag pattern tends to produce a very long run of zeros at the end, as
    it does in our example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这种锯齿形模式倾向于在结尾产生非常长的零值运行，正如我们示例中所示：
- en: '[PRE8]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To encode the runs of zeros, we replace each nonzero entry in the list by a
    pair of numbers: the number of zeros skipped (possibly none), and the coefficient
    itself. For example, the eighth number in our list is a –2 that is preceded by
    one 0\. This would become the number pair 1, –2\. At this stage, our list looks
    like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编码零值的运行，我们用一对数字替换列表中的每个非零项：跳过的零的数量（可能没有）和系数本身。例如，列表中的第八个数字是一个 –2，前面有一个 0。它将变成数字对
    1, –2。在这一阶段，我们的列表如下所示：
- en: '[PRE9]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Some of these number pairs, such as 0, –1, appear very frequently in these lists
    compared to other pairs like 0, 10\. For maximum compression, the JPEG standard
    defines a Huffman encoding for every possible number pair in these lists. The
    common 0, –1 pair, for example, becomes the short Huffman code 001, while the
    uncommon 0, 10 pair becomes the longer code 10110010\. There’s also a special
    code, 1010, to signal that all the rest of the coefficients in the list are 0\.
    The Huffman encoding for our list is shown in [Table 6-8](ch06.html#ch6tab8).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字对中，例如0，–1，在这些列表中出现的频率远高于其他对如0，10。为了实现最大压缩，JPEG标准为这些列表中的每个可能的数字对定义了霍夫曼编码。例如，常见的0，–1对被编码为短霍夫曼码001，而不常见的0，10对则被编码为较长的码10110010。还有一个特殊的编码1010，用于表示列表中其余的系数都是0。我们的列表的霍夫曼编码显示在[表6-8](ch06.html#ch6tab8)中。
- en: '**Table 6-8:** The Huffman Encoding of the Coefficients from [Figure 6-15](ch06.html#ch6fig15)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-8：** [图6-15](ch06.html#ch6fig15)中系数的霍夫曼编码'
- en: '| **Zeros skipped** | **Coefficient** | **Huffman encoding** |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **跳过零值** | **系数** | **霍夫曼编码** |'
- en: '| --- | --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 |   8 | 10110000 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 0 |   8 | 10110000 |'
- en: '| 0 | 10 | 10110010 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 10 | 10110010 |'
- en: '| 0 | –7 | 100111 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 0 | –7 | 100111 |'
- en: '| 0 | –7 | 100111 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 0 | –7 | 100111 |'
- en: '| 0 |   6 | 100010 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 0 |   6 | 100010 |'
- en: '| 0 | –4 | 100100 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 0 | –4 | 100100 |'
- en: '| 1 | –2 | 11100110 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 1 | –2 | 11100110 |'
- en: '| 0 |   1 | 000 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 0 |   1 | 000 |'
- en: '| 0 | –2 | 0110 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 0 | –2 | 0110 |'
- en: '| 0 | –1 | 001 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 0 | –1 | 001 |'
- en: '| 0 | –1 | 001 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 0 | –1 | 001 |'
- en: '| 0 |   1 | 000 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 0 |   1 | 000 |'
- en: '| 0 | –1 | 001 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 0 | –1 | 001 |'
- en: '| 1 | –1 | 11001 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 1 | –1 | 11001 |'
- en: '| 2 |   1 | 110110 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 2 |   1 | 110110 |'
- en: '| 2 | –1 | 110111 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 2 | –1 | 110111 |'
- en: '| (Nothing left but zeros) |  | 1010 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| (仅剩零值) |  | 1010 |'
- en: All of the bits in the rightmost column, strung together, represent the compressed
    encoding of our original luminance block. The original block represented the luminance
    levels as 64 bytes, or 512 bits total. In contrast, the encoding in [Table 6-8](ch06.html#ch6tab8)
    uses a mere 88 bits.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧列中的所有比特串联在一起，表示我们原始亮度块的压缩编码。原始块使用64字节或总共512位表示亮度级别。而[表6-8](ch06.html#ch6tab8)中的编码仅使用88位。
- en: The two color blocks, Cr and Cb, would show even higher compression because
    the divisors used on the color blocks are even larger, which produces smaller
    numbers with shorter Huffman codes and more zeros for the run-length encoding.
    Overall, JPEG images typically achieve a 10:1 compression ratio. The amount of
    compression can be increased or reduced by using smaller or larger divisors than
    those shown in [Figure 6-14](ch06.html#ch6fig14). These divisors are adjusted
    by the “quality” slider in image-manipulation programs. Sliding the control to
    “low quality” increases the divisors, reducing the file size while increasing
    the quantization error.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 两个颜色块Cr和Cb会表现出更高的压缩率，因为应用于颜色块的除数更大，这产生了更小的数值、较短的霍夫曼编码以及更多的零值进行行程长度编码。总体而言，JPEG图像通常能够达到10:1的压缩比。通过使用比[图6-14](ch06.html#ch6fig14)中显示的更小或更大的除数，可以增加或减少压缩量。这些除数通过图像编辑程序中的“质量”滑块进行调整。将滑块移至“低质量”会增加除数，从而减小文件大小，但会增加量化误差。
- en: '***JPEG Picture Quality***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***JPEG图像质量***'
- en: High compression is great only if the restored image is indistinguishable from
    the original, or nearly so. Typically the alterations JPEG compression makes to
    an image are difficult to see. To get a feel for the changes introduced by compression,
    let’s compare the original block of luminance values to the block that results
    from compressing and decompressing, as shown in [Figure 6-17](ch06.html#ch6fig17).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 高压缩比只有在恢复的图像与原始图像无法区分时才有意义，或者几乎无法区分。通常JPEG压缩对图像的改变是难以察觉的。为了感受压缩带来的变化，我们可以将原始的亮度值块与压缩和解压缩后的结果进行比较，正如在[图6-17](ch06.html#ch6fig17)中所示。
- en: '![image](graphics/f06-17.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-17.jpg)'
- en: '*Figure 6-17: The original luminance block, and the result of compressing and
    decompressing the block*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-17：原始亮度块，以及压缩和解压缩后的结果*'
- en: Since it’s tough to visually compare these two blocks of numbers, [Figure 6-18](ch06.html#ch6fig18)
    shows the differences as a grayscale matrix. As you can see, most of the matrix
    is neutral gray, indicating numbers very close to the original.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于很难直观地比较这两个数字块，[图6-18](ch06.html#ch6fig18)通过灰度矩阵显示了它们之间的差异。正如你所看到的，矩阵的大部分是中性色灰，表示这些数值与原始值非常接近。
- en: '![image](graphics/f06-19.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-19.jpg)'
- en: '*Figure 6-19: The amount of error in each location of the luminance block*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-19：每个位置的亮度块误差量*'
- en: The best evidence for the quality of JPEGs is shown in [Figure 6-19](ch06.html#ch6fig19).
    On the top is an uncompressed digital photograph. Because this photo is in grayscale,
    we don’t need RGB pixel color, just a single byte indicating the grayscale level.
    At a resolution of 975×731, this uncompressed photo requires just under 713 kilobytes
    of storage. In the middle is a compressed JPEG version of the original photo,
    requiring just 75 kilobytes of storage, which is virtually indistinguishable from
    the original. The photo on the bottom is a low-quality JPEG using larger divisors.
    While the photo takes up only about 7 kilobytes, compression artifacts are clearly
    visible. Many of the individual 8×8 pixel blocks have been reduced to solid squares
    of the same gray level. In general, JPEG can result in a 10:1 compression ratio
    without sacrificing visual quality.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG图像质量的最佳证据见[图6-19](ch06.html#ch6fig19)。上方是未压缩的数字照片。由于这张照片是灰度图，我们不需要RGB像素颜色，只需要一个字节来表示灰度级别。在975×731的分辨率下，这张未压缩的照片需要不到713千字节的存储空间。中间是原始照片的压缩JPEG版本，仅需75千字节的存储空间，几乎无法与原图区分。底部的照片是低质量JPEG，使用了较大的除数。虽然该照片仅占用大约7千字节，但压缩伪影非常明显。许多单独的8×8像素块已经变成了相同灰度级别的实心方块。一般来说，JPEG可以在不牺牲视觉质量的情况下达到10:1的压缩比。
- en: '**Compressing High-Definition Video**'
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**压缩高清视频**'
- en: The JPEG format does a fantastic job of compressing images with only small sacrifices
    in quality, but for high-definition video we need even more compression. Remember,
    uncompressed high-definition video requires about 186MBps. Individually compressing
    each image as a JPEG would reduce that requirement to about 18MBps—a big improvement,
    but for streaming or disc storage we need to shrink the data to just a few MBps
    per second.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG格式在压缩图像方面表现非常出色，几乎没有质量损失，但对于高清视频，我们需要更多的压缩。记住，未压缩的高清视频大约需要186MBps。单独将每个图像压缩为JPEG格式，可以将这一需求降低到约18MBps——这是一个巨大的改进，但对于流媒体或光盘存储，我们需要将数据压缩到每秒仅几MBps。
- en: '![image](graphics/f06-18.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-18.jpg)'
- en: '*Figure 6-18: An uncompressed photo (top), high-quality JPEG compression (middle),
    and low-quality JPEG compression (bottom)*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-18：未压缩照片（上）、高质量JPEG压缩（中）、低质量JPEG压缩（下）*'
- en: '***Temporal Redundancy***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***时间冗余***'
- en: To hit this target, video compression techniques take advantage of similarities
    between images in sequence. [Figure 6-20](ch06.html#ch6fig20) shows an image sequence
    from a movie’s opening credits.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目标，视频压缩技术利用了图像序列中图像之间的相似性。[图6-20](ch06.html#ch6fig20)展示了电影开场字幕的图像序列。
- en: '![image](graphics/f06-20.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-20.jpg)'
- en: '*Figure 6-20: A few frames of an opening title sequence*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-20：开场标题序列中的几帧*'
- en: Each of these images will be shown for several seconds; which means that the
    sequence will contain many duplicate frames in a row. Also, even as the video
    transitions from one image to the next, most of the picture remains unchanged.
    Only the area in the center varies.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像将显示几秒钟；这意味着序列中将包含许多连续的重复帧。此外，即使视频从一张图像过渡到另一张图像，大部分画面保持不变，只有中间区域发生变化。
- en: Now consider the image sequence shown in [Figure 6-21](ch06.html#ch6fig21).
    Although each frame differs from the next, the same elements are present in each
    frame, just in different places on the screen.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请参考[图6-21](ch06.html#ch6fig21)所示的图像序列。尽管每一帧与下一帧不同，但每一帧中都有相同的元素，只是它们在屏幕上的位置不同。
- en: '![image](graphics/f06-21.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-21.jpg)'
- en: '*Figure 6-21: An image sequence with a moving object*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-21：带有移动物体的图像序列*'
- en: These examples show two different forms of *temporal redundancy*, continuity
    of data from one frame to the next. Compression that exploits such redundancy
    is called *temporal compression*, and as we’ll see in the next section, it’s the
    key to achieving the compression ratios needed for video streaming and storage.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了两种不同形式的*时间冗余*，即从一帧到下一帧的数据连续性。利用这种冗余的压缩称为*时间压缩*，正如我们将在下一节中看到的，它是实现视频流媒体和存储所需压缩比的关键。
- en: '***MPEG-2 Video Compression***'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***MPEG-2视频压缩***'
- en: One method of temporal compression is employed by *MPEG-2*, a common video format
    supported by Blu-ray discs and digital broadcast television. More advanced techniques
    exist, but they are extensions of the ideas demonstrated here.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*MPEG-2*是一种常见的视频格式，支持蓝光光盘和数字广播电视，它采用了一种时间压缩方法。虽然更先进的技术已经存在，但它们是对这里展示的思想的扩展。'
- en: '**Groups of Frames**'
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**图像组**'
- en: MPEG-2 videos are divided into sequences of around 15 frames called *groups
    of pictures (GOPs)*. Exactly one frame in each GOP is selected to be a basic JPEG-encoded
    image called an *intracoded frame (I-Frame)*. This frame is the rock upon which
    the rest of the GOP is built. All of the other frames use temporal compression,
    which means they are stored not as the absolute colors of the pixels in the image,
    but by how those colors differ from those in another image in the GOP, as we’ll
    see shortly.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: MPEG-2 视频被划分为大约 15 帧的序列，称为*图像组（GOPs）*。每个 GOP 中正好有一帧被选为基本的 JPEG 编码图像，称为*内编码帧（I-Frame）*。这帧是整个
    GOP 的基石。其他所有帧都使用时间压缩，这意味着它们不是以图像中像素的绝对颜色存储，而是通过这些颜色与 GOP 中其他图像的颜色差异来存储，稍后我们将详细了解。
- en: The other frames in the group are assigned one of two types, *predicted frames
    (P-Frames)* and *bidirectional frames (B-Frames)*. A P-Frame stores the difference
    between its pixels and those of a previous frame, while a B-Frame stores the difference
    between its pixels and those of a previous *and* a later frame.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 组内的其他帧被分配为两种类型之一，*预测帧（P-Frames）*和*双向帧（B-Frames）*。P 帧存储其像素与前一帧像素之间的差异，而 B 帧则存储其像素与前一帧*和*后一帧像素之间的差异。
- en: A GOP is shown in [Figure 6-22](ch06.html#ch6fig22), with arrows indicating
    the frames referenced by the temporal compression. As you can see, everything
    depends on the I-Frame. During playback, it must be decoded before any other image
    in the GOP, after which the frames that directly reference the I-Frame can be
    decoded, and so on.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 6-22](ch06.html#ch6fig22)所示，一个 GOP（图像组）中包含箭头，表示时间压缩所引用的帧。如你所见，一切都依赖于 I 帧。在播放过程中，I
    帧必须先于其他任何图像解码，之后，直接引用 I 帧的其他帧才能解码，以此类推。
- en: '![image](graphics/f06-22.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-22.jpg)'
- en: '*Figure 6-22: A GOP, or group of pictures*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-22：一个 GOP，或图像组*'
- en: Grouping pictures this way simplifies encoding and decoding, and also limits
    the length of the reference “chain.” Just like a photocopy of a photocopy, the
    longer the chain of temporal compression, the fuzzier the image gets. The regular
    appearance of I-Frames is also what allows you to see images as you fast-forward
    or rewind; the video player just picks out the I-Frames, which can be decoded
    and displayed independently of the other frames in its GOP.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式对图像进行分组简化了编码和解码过程，同时也限制了引用“链条”的长度。就像复印复印件一样，时间压缩的链条越长，图像就越模糊。I 帧的定期出现也是你能够在快进或倒带时看到图像的原因；视频播放器只需提取
    I 帧，这些帧可以独立于其所在 GOP 的其他帧进行解码和显示。
- en: The MPEG specification gives encoding software wide discretion in forming GOPs.
    The number of I-Frames, which directly determines the size of GOPs, is up to the
    encoder, as is the number of B-Frames between the other frame types. Like the
    divisors used in JPEG quantization, the ability to change the relative numbers
    of the three frame types offers a trade-off between quality and compression. In
    applications where compression is paramount, like videoconferencing, I-Frames
    are rare and B-Frames are common, while in a Blu-ray, the encoder will use as
    many I-Frames as possible while still fitting all the video data on the disc.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: MPEG 规范赋予编码软件在形成 GOP 时较大的自由度。I 帧的数量直接决定了 GOP 的大小，由编码器决定，B 帧的数量也由编码器决定，这些 B 帧位于其他帧类型之间。与
    JPEG 量化中使用的除数类似，调整三种帧类型的相对数量提供了一种在质量与压缩之间的权衡。在压缩至关重要的应用中，例如视频会议，I 帧较少，而 B 帧较多；而在蓝光光盘中，编码器会尽可能多地使用
    I 帧，同时确保所有视频数据能够装入光盘。
- en: '**Temporal Compression**'
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**时间压缩**'
- en: 'So how does the temporal compression of P-Frames and B-Frames work? In this
    example, we’re compressing a P-Frame by referencing an I-Frame. First, the pixels
    in the P-Frame are divided into 16×16 *macroblocks*. For each macroblock, the
    I-Frame is searched for a matching block of pixels with the same color data. This
    matching block may not appear in exactly the same place in the I-Frame, though,
    so it is indicated by its *offset*: the difference between the location in the
    P-Frame and the location in the I-Frame, expressed in screen coordinates. For
    example, an offset of –100, 50 indicates that the macroblock’s location in the
    I-Frame is 100 pixels left and 50 pixels down from its location in the P-Frame,
    as shown in [Figure 6-23](ch06.html#ch6fig23).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 那么P帧和B帧的时间压缩是如何工作的呢？在这个例子中，我们通过引用I帧来压缩P帧。首先，P帧中的像素被划分为16×16的*宏块*。对于每个宏块，在I帧中搜索与其颜色数据相匹配的像素块。然而，这个匹配的块可能不会出现在I帧的完全相同位置，因此它由*偏移量*表示：即P帧位置和I帧位置之间的差异，表示为屏幕坐标。例如，偏移量为-100,
    50表示该宏块在I帧中的位置比在P帧中的位置左移100像素、下移50像素，如[图 6-23](ch06.html#ch6fig23)所示。
- en: '![image](graphics/f06-23.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-23.jpg)'
- en: '*Figure 6-23: A macroblock in a P-Frame referencing a matching block of pixels
    in a previous frame*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-23：P帧中的一个宏块，引用了前一帧中匹配的像素块*'
- en: In most cases, an exact match won’t be found, so in addition to storing the
    location of the best match, the differences between the two macroblocks must also
    be stored. [Figure 6-24](ch06.html#ch6fig24) shows a luminance block from the
    P-Frame and the best match in the I-Frame. (I’m using 8×8 blocks instead of a
    full 16×16 macroblock to keep the example manageable.)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，无法找到完全匹配，因此除了存储最佳匹配的位置外，还必须存储两个宏块之间的差异。[图 6-24](ch06.html#ch6fig24)展示了P帧中的一个亮度块及其在I帧中的最佳匹配。（为了使示例更易于理解，我使用了8×8的块，而不是完整的16×16宏块。）
- en: '![image](graphics/f06-24.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-24.jpg)'
- en: '*Figure 6-24: A luminance block and its best match in a prior frame*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-24：亮度块及其在前一帧中的最佳匹配*'
- en: 'Next, a block of differences is computed: each number in the I-Frame block
    is subtracted from the number in the same position in the P-Frame block. The result
    for our example is shown in [Figure 6-25](ch06.html#ch6fig25).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，计算差异块：将I帧块中的每个数值从P帧块中相同位置的数值中减去。我们的示例结果如[图 6-25](ch06.html#ch6fig25)所示。
- en: '![image](graphics/f06-25.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-25.jpg)'
- en: '*Figure 6-25: The difference between the two luminance blocks in [Figure 6-24](ch06.html#ch6fig24)*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-25：两个亮度块之间的差异，如[图 6-24](ch06.html#ch6fig24)所示*'
- en: Because the blocks are a close match, these values are all small. This is a
    form of predictive encoding, just like the list of temperatures shown earlier
    in the chapter. By storing differences, we’ve made the range of data much smaller,
    and therefore more easily compressed. When we apply the DCT and quantize the results,
    the numbers are downright tiny, as shown in [Figure 6-26](ch06.html#ch6fig26).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些块非常接近匹配，因此这些值都很小。这是一种预测编码的形式，就像本章前面展示的温度列表一样。通过存储差异，我们大大缩小了数据的范围，因此更容易进行压缩。当我们应用离散余弦变换（DCT）并量化结果时，数字变得极其微小，如[图
    6-26](ch06.html#ch6fig26)所示。
- en: '![image](graphics/f06-26.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-26.jpg)'
- en: '*Figure 6-26: The result of quantizing the block in [Figure 6-25](ch06.html#ch6fig25)
    and applying the DCT*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-26：量化[图 6-25](ch06.html#ch6fig25)中块并应用离散余弦变换（DCT）的结果*'
- en: 'This block is highly susceptible to the last stage of compression: the combination
    of run-length and Huffman encoding. As shown in [Table 6-9](ch06.html#ch6tab9),
    the original luminance block has been reduced to a mere 39 bits.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 该块对压缩的最后阶段非常敏感：即行程长度编码和哈夫曼编码的结合。如[表 6-9](ch06.html#ch6tab9)所示，原始的亮度块已被压缩至仅39个比特。
- en: '**Table 6-9:** The Huffman Encoding of the Numbers in [Figure 6-26](ch06.html#ch6fig26)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-9：** [图 6-26](ch06.html#ch6fig26)中数字的哈夫曼编码'
- en: '| **Run length** | **Coefficient** | **Huffman encoding** |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **行程长度** | **系数** | **哈夫曼编码** |'
- en: '| --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 4 |   1 | 1110110 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 4 |   1 | 1110110 |'
- en: '| 1 | –1 | 11001 |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 1 | –1 | 11001 |'
- en: '| 0 |   1 | 000 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 0 |   1 | 000 |'
- en: '| 0 |   1 | 000 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 0 |   1 | 000 |'
- en: '| 0 | –1 | 001 |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 0 | –1 | 001 |'
- en: '| 1 |   1 | 11000 |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 1 |   1 | 11000 |'
- en: '| 7 |   1 | 111110100 |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 7 |   1 | 111110100 |'
- en: '| (Nothing left but zeros) |  | 1010 |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| （只剩下零） |  | 1010 |'
- en: Not every macroblock in the P-Frame is encoded in this way. In some cases, a
    macroblock may not be similar enough to any block of pixels in the previous frame
    to save any space by storing the difference. Those macroblocks can be recorded
    directly, like the macroblocks in an I-Frame. For a B-Frame, matching macroblocks
    can be found in a previous frame or a later frame, which improves the odds of
    a close match.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 并非P帧中的每个宏块都以这种方式编码。在某些情况下，一个宏块可能与前一帧中的任何像素块相似度不足，无法通过存储差异来节省空间。这些宏块可以像I帧中的宏块一样直接记录。对于B帧，匹配的宏块可以在前一帧或后一帧中找到，这提高了匹配的几率。
- en: '***Video Quality with Temporal Compression***'
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***带有时间压缩的视频质量***'
- en: 'Temporal compression depends upon temporal redundancy—sequences of frames with
    few changes. For this reason, some videos compress much better than others. Movies
    with lots of camera movement, like *Cloverfield* or *The Blair Witch Project*,
    are difficult to compress, while movies with long takes where the camera doesn’t
    move, like *2001: A Space Odyssey*, are ideal.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 时间压缩依赖于时间冗余——即变化较少的帧序列。因此，某些视频比其他视频压缩得更好。像《科洛弗档案》或《女巫布莱尔计划》这样的电影，由于镜头运动频繁，压缩较为困难；而像《2001太空漫游》这类长镜头、摄像机不动的电影则理想适合压缩。
- en: Ultimately, video compression is a bit of an art as well as a science. As stated
    earlier, different MPEG-2 encoders can produce different results for the same
    sequence of images. Shorter GOPs, with more I-Frames and fewer B-Frames, produce
    better-looking video than longer GOPs, but longer GOPs mean better compression.
    An encoder can vary the mix of frames even within the same video, using longer
    GOPs when there’s high temporal redundancy and shorter GOPs when there isn’t.
    Also, good encoders will try to line up GOP boundaries with sharp cuts in a movie;
    if you’ve ever seen a video that was momentarily very blocky when the scene changed,
    it’s likely because a GOP stretched over the cut.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，视频压缩既是一门艺术，也是一门科学。如前所述，不同的MPEG-2编码器对同一组图像序列可能会产生不同的结果。较短的GOP（更多I帧、较少B帧）会产生更好看的视频，而较长的GOP则意味着更好的压缩效果。编码器可以根据时间冗余的程度来调整帧的组合，在高时间冗余时使用较长的GOP，在冗余较低时使用较短的GOP。此外，优秀的编码器会尽量使GOP边界与电影中的明显剪辑对齐；如果你曾看到过在场景切换时视频瞬间变得非常块状，那很可能是因为GOP跨越了这个剪辑。
- en: There’s also the question of performance, especially if the video is being compressed
    in real time, as with a live event. There might not be enough time to find the
    absolute best match for a macroblock in the other frame.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个性能问题，尤其是当视频实时压缩时，比如直播事件。可能没有足够的时间在另一帧中找到宏块的最佳匹配。
- en: Playback quality can vary as well. For example, because of how frames are broken
    into individually processed macroblocks, seams may appear along the borders of
    the blocks. To reduce this effect, a decoder may apply a *deblocking filter*.
    This smoothes block boundaries by averaging pixel colors, much like the anti-aliasing
    methods shown in previous chapters. The strength of the filter can be adjusted
    based on the likelihood of a clean boundary. In a B-Frame, for example, if one
    block references the previous frame while an adjacent block references the next
    frame, there’s a greater likelihood of a rough boundary, which calls for stronger
    filtering.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 播放质量也可能有所不同。例如，由于帧被拆分成单独处理的宏块，可能会在宏块的边界出现接缝。为减少这种效果，解码器可能会应用*去块滤镜*。这通过对像素颜色进行平均来平滑块边界，就像前几章展示的抗锯齿方法一样。滤镜的强度可以根据边界干净的可能性进行调整。例如，在B帧中，如果一个宏块引用了前一帧，而相邻的宏块引用了后一帧，那么边界粗糙的可能性更大，这时需要更强的滤镜处理。
- en: In other cases, the resolution of the video and the display resolution may not
    match. For example, when you’re streaming an episode of the old cop show *Adam-12*
    (it’s not just me, right?) on a high-definition television, either the television
    or the player has to convert the original 640×480 images to fill the 1920×1080
    display. This is the same problem we solved in [Chapter 5](ch05.html#ch05) with
    texture mapping—applying a bitmap to a larger area—and video devices can employ
    the same sorts of techniques. Early high-definition players effectively used nearest-neighbor
    sampling, which produced poor results. Newer players employ techniques similar
    to trilinear filtering. Instead of blending between bilinear samples from two
    different levels in a mipmap, however, they blend between successive frames. This
    is especially effective in smoothing objects in motion.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，视频的分辨率和显示分辨率可能不匹配。例如，当你在高清电视上播放老电视剧*Adam-12*（不仅仅是我对吧？）时，电视机或播放器必须将原始的640×480图像转换为填充1920×1080显示屏。这与我们在[第5章](ch05.html#ch05)中解决的纹理映射问题相同——将位图应用到更大的区域——视频设备也可以采用类似的技术。早期的高清播放器实际上使用了最近邻采样，这产生了较差的效果。较新的播放器采用了类似三线性过滤的技术。不同的是，它们不再在mipmap中的两个不同级别的双线性样本之间进行混合，而是在连续的帧之间进行混合。这在平滑运动物体方面尤其有效。
- en: Although not as computationally intense as the original encoding, playing back
    a temporally compressed video is still a lot of work for a processor. Also, the
    structure of a GOP requires decoding the frames out of order. This in turn requires
    that frames be *buffered*, held in a queue prior to display. For streaming video,
    much larger buffers are used so that minor hiccups in the network don’t disrupt
    playback.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管播放一个时间压缩视频的计算量不如原始编码那么强烈，但仍然需要处理器进行大量的计算。此外，GOP的结构要求解码帧的顺序与实际顺序不同。这也意味着需要对帧进行*缓冲*，在显示前将其保存在队列中。对于流媒体视频，使用了更大的缓冲区，以便网络中的小问题不会中断播放。
- en: '**The Present and Future of Video Compression**'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**视频压缩的现状与未来**'
- en: The latest video compression standard, known as H.264 or MPEG-4, extends the
    techniques used in MPEG-2 but isn’t fundamentally different. The primary differences
    improve the quality of macroblock matching. Instead of being matched against just
    one or two other frames, macroblocks can be matched against 32 other frames. Also,
    the 16×16 macroblocks themselves can be broken down into separately matched 8×8
    blocks.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的视频压缩标准，H.264或MPEG-4，扩展了MPEG-2中使用的技术，但并没有根本性的不同。主要的区别在于改进了宏块匹配的质量。宏块不再仅与一帧或两帧进行匹配，而是可以与32帧进行匹配。此外，16×16的宏块本身还可以分解为单独匹配的8×8块。
- en: Through such improvements, MPEG-4 can often achieve twice the compression ratio
    of MPEG-2 with the same quality result. For that reason, MPEG-4 is an industry
    standard for both streaming and storage. Most Blu-ray videos use it, as do YouTube
    and Netflix. Its chief competition is a format called Theora, which uses similar
    compression methods but is freely licensed, unlike the proprietary MPEG-4.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样的改进，MPEG-4通常能够在相同的质量下实现MPEG-2的两倍压缩比。因此，MPEG-4已成为流媒体和存储领域的行业标准。大多数蓝光视频都使用它，YouTube和Netflix也在使用它。它的主要竞争对手是名为Theora的格式，Theora使用类似的压缩方法，但它是免费的许可，而不像专有的MPEG-4。
- en: Today’s compression formats do an amazing job at shrinking video data, but they
    do so at a high computational cost. The next time you watch a clip on YouTube,
    think about a GOP, all the macroblocks being copied and updated from one frame
    to the next, and all the number crunching that goes into performing the DCT over
    and over again. It’s a dizzying amount of calculation just to show a cat falling
    off a piano.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的压缩格式在缩小视频数据方面表现出色，但它们的计算成本非常高。下次你在YouTube上观看一个视频片段时，可以想想GOP，所有宏块如何从一帧到下一帧被复制和更新，以及执行DCT时进行的所有数字运算。为了展示一只猫从钢琴上掉下来，进行这些计算是一项令人头晕的工作。
- en: Even more computational horsepower will be needed in the future. The new *ultra
    high definition (UHD)* format, seen in theaters in films like Peter Jackson’s
    *Hobbit* series, is starting to trickle down to home video. UHD images are 3840×2160,
    which is four times the number of pixels as current high definition. The frame
    rate will also increase, from today’s 24 or 30 fps to 48, 60, or even 120 fps.
    UHD video could increase the bit requirements from today’s 1,400Mbps to over 23,000,
    which will require a corresponding increase in bandwidth and disc storage capacity—unless
    someone clever comes up with an even better way for software to shrink the data.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 未来将需要更多的计算能力。像彼得·杰克逊的*《霍比特人》*系列电影中所展示的*超高清（UHD）*格式，正在逐渐进入家庭视频领域。UHD图像的分辨率为3840×2160，是当前高清分辨率的四倍。帧率也将增加，从今天的24或30帧每秒提高到48、60，甚至120帧每秒。UHD视频可能会将比特需求从今天的1,400Mbps增加到超过23,000，这将需要相应增加带宽和磁盘存储容量——除非有聪明的人能提出一种更好的方法，让软件能够压缩数据。
