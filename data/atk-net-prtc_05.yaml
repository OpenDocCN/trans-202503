- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**ANALYSIS FROM THE WIRE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自网络的分析**'
- en: In [Chapter 2](../Text/ch02.xhtml#ch02), I discussed how to capture network
    traffic for analysis. Now it’s time to put that knowledge to the test. In this
    chapter, we’ll examine how to analyze captured network protocol traffic from a
    chat application to understand the protocol in use. If you can determine which
    features a protocol supports, you can assess its security.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](../Text/ch02.xhtml#ch02)中，我讨论了如何捕获网络流量进行分析。现在是时候将这些知识付诸实践了。在本章中，我们将分析如何从聊天应用程序中捕获的网络协议流量，了解正在使用的协议。如果你能确定协议支持哪些功能，你就能评估它的安全性。
- en: Analysis of an unknown protocol is typically incremental. You begin by capturing
    network traffic, and then analyze it to try to understand what each part of the
    traffic represents. Throughout this chapter, I’ll show you how to use Wireshark
    and some custom code to inspect an unknown network protocol. Our approach will
    include extracting structures and state information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 分析一个未知协议通常是渐进的。你从捕获网络流量开始，然后分析它，尝试理解流量中的每个部分代表什么。在本章中，我将向你展示如何使用 Wireshark 和一些自定义代码来检查一个未知的网络协议。我们的方法将包括提取结构和状态信息。
- en: '**The Traffic-Producing Application: SuperFunkyChat**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**产生流量的应用程序：SuperFunkyChat**'
- en: The test subject for this chapter is a chat application I’ve written in C# called
    SuperFunkyChat, which will run on Windows, Linux, and macOS. Download the latest
    prebuild applications and source code from the GitHub page at *[https://github.com/tyranid/ExampleChatApplication/releases/](https://github.com/tyranid/ExampleChatApplication/releases/)*;
    be sure to choose the release binaries appropriate for your platform. (If you’re
    using Mono, choose the .NET version, and so on.) The example client and server
    console applications for SuperFunkyChat are called ChatClient and ChatServer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的测试对象是我用 C# 编写的一个聊天应用程序，名为 SuperFunkyChat，它将在 Windows、Linux 和 macOS 上运行。可以从
    GitHub 页面下载最新的预构建应用程序和源代码，网址是 *[https://github.com/tyranid/ExampleChatApplication/releases/](https://github.com/tyranid/ExampleChatApplication/releases/)*；请务必选择适合您平台的发布二进制文件。（如果您使用
    Mono，请选择 .NET 版本，依此类推。）SuperFunkyChat 的示例客户端和服务器控制台应用程序分别名为 ChatClient 和 ChatServer。
- en: After you’ve downloaded the application, unpack the release files to a directory
    on your machine so you can run each application. For the sake of simplicity, all
    example command lines will use the Windows executable binaries. If you’re running
    under Mono, prefix the command with the path to the main *mono* binary. When running
    files for .NET Core, prefix the command with the *dotnet* binary. The files for
    .NET will have a *.dll* extension instead of *.exe*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完应用程序后，将发布文件解压到你计算机上的一个目录，以便运行每个应用程序。为了简化起见，所有示例命令行将使用 Windows 可执行二进制文件。如果你在
    Mono 下运行，请在命令前加上主 *mono* 二进制文件的路径。当运行 .NET Core 的文件时，在命令前加上 *dotnet* 二进制文件。这些
    .NET 文件将以 *.dll* 扩展名而非 *.exe* 扩展名。
- en: '***Starting the Server***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动服务器***'
- en: Start the server by running *ChatServer.exe* with no parameters. If successful,
    it should print some basic information, as shown in [Listing 5-1](../Text/ch05.xhtml#ch5list1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行*ChatServer.exe*（不带参数）来启动服务器。如果成功，应该会打印一些基本信息，如[清单 5-1](../Text/ch05.xhtml#ch5list1)所示。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 5-1: Example output from running ChatServer*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：运行 ChatServer 的示例输出*'
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Pay attention to the warning! This application has not been designed to be
    a secure chat system.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意警告！此应用程序并未设计为一个安全的聊天系统。*'
- en: Notice in [Listing 5-1](../Text/ch05.xhtml#ch5list1) that the final line prints
    the port the server is running on (12345 in this case) and whether the server
    has bound to all interfaces (global). You probably won’t need to change the port
    (`--port NUM`), but you might need to change whether the application is bound
    to all interfaces if you want clients and the server to exist on different computers.
    This is especially important on Windows. It’s not easy to capture traffic to the
    local loopback interface on Windows; if you encounter any difficulties, you may
    need to run the server on a separate computer or a virtual machine (VM). To bind
    to all interfaces, specify the `--global` parameter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[清单 5-1](../Text/ch05.xhtml#ch5list1)中，最后一行打印了服务器运行的端口（此处为 12345）以及服务器是否已绑定到所有接口（全局）。你可能不需要更改端口（`--port
    NUM`），但如果你希望客户端和服务器存在于不同的计算机上，可能需要更改应用程序是否绑定到所有接口。特别是在 Windows 上，这一点尤为重要。在 Windows
    上捕获本地回环接口的流量并不容易；如果遇到困难，你可能需要在另一台计算机或虚拟机（VM）上运行服务器。要绑定到所有接口，请指定`--global`参数。
- en: '***Starting Clients***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动客户端***'
- en: With the server running, we can start one or more clients. To start a client,
    run *ChatClient.exe* (see [Listing 5-2](../Text/ch05.xhtml#ch5list2)), specify
    the username you want to use on the server (the username can be anything you like),
    and specify the server hostname (for example, `localhost`). When you run the client,
    you should see output similar to that shown in [Listing 5-2](../Text/ch05.xhtml#ch5list2).
    If you see any errors, make sure you’ve set up the server correctly, including
    requiring binding to all interfaces or disabling the firewall on the server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器运行的情况下，我们可以启动一个或多个客户端。启动客户端时，运行 *ChatClient.exe*（见[清单 5-2](../Text/ch05.xhtml#ch5list2)），指定你在服务器上使用的用户名（用户名可以是你喜欢的任何名称），并指定服务器主机名（例如，`localhost`）。当你运行客户端时，你应该会看到类似于[清单
    5-2](../Text/ch05.xhtml#ch5list2)所示的输出。如果看到任何错误，确保服务器已正确设置，包括要求绑定到所有接口或禁用服务器上的防火墙。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-2: Example output from running ChatClient*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：运行 ChatClient 的示例输出*'
- en: 'As you start the client, look at the running server: you should see output
    on the console similar to [Listing 5-3](../Text/ch05.xhtml#ch5list3), indicating
    that the client has successfully sent a “Hello” packet.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 启动客户端时，查看正在运行的服务器：你应该能在控制台看到类似于[清单 5-3](../Text/ch05.xhtml#ch5list3)的输出，表示客户端已经成功发送了一个“Hello”数据包。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-3: The server output when a client connects*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：客户端连接时服务器的输出*'
- en: '***Communicating Between Clients***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***客户端之间的通信***'
- en: After you’ve completed the preceding steps successfully, you should be able
    to connect multiple clients so you can communicate between them. To send a message
    to all users with the ChatClient, enter the message on the command line and press
    ENTER.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完成上述步骤后，你应该能够连接多个客户端，以便它们之间进行通信。要向所有用户发送消息，可以在命令行中输入消息并按 ENTER 键。
- en: The ChatClient also supports a few other commands, which all begin with a forward
    slash (`/`), as detailed in [Table 5-1](../Text/ch05.xhtml#ch5tab1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ChatClient 还支持一些其他命令，这些命令都以斜杠（`/`）开头，具体如下[表 5-1](../Text/ch05.xhtml#ch5tab1)所述。
- en: '**Table 5-1:** Commands for the ChatClient Application'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1：** ChatClient 应用程序的命令'
- en: '| **Command** | **Description** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/quit [message]` | Quit client with optional message |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `/quit [消息]` | 带可选消息退出客户端 |'
- en: '| `/msg user message` | Send a message to a specific user |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `/msg 用户消息` | 向特定用户发送消息 |'
- en: '| `/list` | List other users on the system |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `/list` | 列出系统中的其他用户 |'
- en: '| `/help` | Print help information |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `/help` | 打印帮助信息 |'
- en: You’re ready to generate traffic between the SuperFunkyChat clients and server.
    Let’s start our analysis by capturing and inspecting some traffic using Wireshark.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好在 SuperFunkyChat 客户端和服务器之间生成流量。让我们通过使用 Wireshark 捕获并检查一些流量来开始分析。
- en: '**A Crash Course in Analysis with Wireshark**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Wireshark 分析速成课程**'
- en: In [Chapter 2](../Text/ch02.xhtml#ch02), I introduced Wireshark but didn’t go
    into any detail on how to use Wireshark to analyze rather than simply capture
    traffic. Because Wireshark is a very powerful and comprehensive tool, I’ll only
    scratch the surface of its functionality here. When you first start Wireshark
    on Windows, you should see a window similar to the one shown in [Figure 5-1](../Text/ch05.xhtml#ch5fig1).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](../Text/ch02.xhtml#ch02)中，我介绍了 Wireshark，但并没有详细讲解如何使用 Wireshark 进行分析，而不仅仅是捕获流量。由于
    Wireshark 是一个非常强大且全面的工具，这里我只会简单介绍它的一些功能。当你在 Windows 上第一次启动 Wireshark 时，你应该会看到一个类似于[图
    5-1](../Text/ch05.xhtml#ch5fig1)所示的窗口。
- en: '![image](../Images/f05-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-01.jpg)'
- en: '*Figure 5-1: The main Wireshark window on Windows*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：Windows 上的 Wireshark 主窗口*'
- en: The main window allows you to choose the interface to capture traffic from.
    To ensure we capture only the traffic we want to analyze, we need to configure
    some options on the interface. Select **Capture** ▸ **Options** from the menu.
    [Figure 5-2](../Text/ch05.xhtml#ch5fig2) shows the options dialog that opens.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 主窗口允许你选择捕获流量的接口。为了确保我们只捕获想要分析的流量，我们需要在接口上配置一些选项。选择 **Capture** ▸ **Options**
    菜单项。[图 5-2](../Text/ch05.xhtml#ch5fig2) 显示了打开的选项对话框。
- en: '![image](../Images/f05-02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-02.jpg)'
- en: '*Figure 5-2: The Wireshark Capture Interfaces dialog*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：Wireshark 捕获接口对话框*'
- en: Select the network interface you want to capture traffic from, as shown at ➊.
    Because we’re using Windows, choose **Local Area Connection**, which is our main
    Ethernet connection; we can’t easily capture from Localhost. Then set a capture
    filter ➋. In this case, we specify the filter **ip host 192.168.10.102** to limit
    capture to traffic to or from the IP address 192.168.10.102\. (The IP address
    we’re using is the chat server’s address. Change the IP address as appropriate
    for your configuration.) Click the **Start** button to begin capturing traffic.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你希望捕获流量的网络接口，如图 ➊ 所示。因为我们使用的是 Windows 系统，选择 **本地连接**，这是我们的主要以太网连接；我们无法轻易地从本地主机捕获流量。然后设置一个捕获过滤器
    ➋。在这种情况下，我们指定过滤器 **ip host 192.168.10.102**，以限制只捕获到或来自 IP 地址 192.168.10.102 的流量。（我们使用的
    IP 地址是聊天服务器的地址。根据你的配置，适当更改 IP 地址。）点击 **开始** 按钮开始捕获流量。
- en: '***Generating Network Traffic and Capturing Packets***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成网络流量并捕获数据包***'
- en: The main approach to packet analysis is to generate as much traffic from the
    target application as possible to improve your chances of finding its various
    protocol structures. For example, [Listing 5-4](../Text/ch05.xhtml#ch5list4) shows
    a single session with ChatClient for `alice`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包分析的主要方法是尽可能多地生成来自目标应用程序的流量，以提高你找到其各种协议结构的机会。例如，[列表 5-4](../Text/ch05.xhtml#ch5list4)
    显示了 `alice` 的单个 ChatClient 会话。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-4: Single ChatClient session for `alice`.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：`alice` 的单个 ChatClient 会话。*'
- en: And [Listing 5-5](../Text/ch05.xhtml#ch5list5) and [Listing 5-6](../Text/ch05.xhtml#ch5list6)
    show two sessions for `bob`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-5](../Text/ch05.xhtml#ch5list5) 和 [列表 5-6](../Text/ch05.xhtml#ch5list6)
    显示了 `bob` 的两个会话。'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-5: First ChatClient session for `bob`*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：`bob` 的第一次 ChatClient 会话*'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-6: Second ChatClient session for `bob`*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：`bob` 的第二次 ChatClient 会话*'
- en: We run two sessions for `bob` so we can capture any connection or disconnection
    events that might only occur between sessions. In each session, a right angle
    bracket (`>`) indicates a command to enter into the ChatClient, and a left angle
    bracket (`<`) indicates responses from the server being written to the console.
    You can execute the commands to the client for each of these session captures
    to reproduce the rest of the results in this chapter for analysis.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `bob` 运行了两个会话，以便捕获可能仅发生在会话之间的连接或断开连接事件。在每个会话中，右尖括号（`>`）表示要输入 ChatClient
    的命令，左尖括号（`<`）表示从服务器写入控制台的响应。你可以执行这些会话捕获中的命令，重现本章中的其余结果以进行分析。
- en: Now turn to Wireshark. If you’ve configured Wireshark correctly and bound it
    to the correct interface, you should start seeing packets being captured, as shown
    in [Figure 5-3](../Text/ch05.xhtml#ch5fig3).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到 Wireshark。如果你已经正确配置了 Wireshark 并将其绑定到正确的接口，你应该开始看到捕获的数据包，如 [图 5-3](../Text/ch05.xhtml#ch5fig3)
    所示。
- en: '![image](../Images/f05-03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-03.jpg)'
- en: '*Figure 5-3: Captured traffic in Wireshark*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：Wireshark 中捕获的流量*'
- en: After running the example sessions, stop the capture by clicking the **Stop**
    button (highlighted) and save the packets for later use if you want.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完示例会话后，点击 **停止** 按钮（高亮显示）停止捕获，并保存数据包以备后续使用（如果需要）。
- en: '***Basic Analysis***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础分析***'
- en: Let’s look at the traffic we’ve captured. To get an overview of the communication
    that occurred during the capture period, choose among the options on the Statistics
    menu. For example, choose **Statistics** ▸ **Conversations**, and you should see
    a new window displaying high-level conversations such as TCP sessions, as shown
    in the Conversations window in [Figure 5-4](../Text/ch05.xhtml#ch5fig4).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们捕获的流量。要概览捕获期间发生的通信，可以在统计菜单中选择相应的选项。例如，选择 **统计** ▸ **会话**，你应该看到一个新窗口显示高层次的会话信息，如
    [图 5-4](../Text/ch05.xhtml#ch5fig4) 中会话窗口所示的 TCP 会话。
- en: '![image](../Images/f05-04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-04.jpg)'
- en: '*Figure 5-4: The Wireshark Conversations window*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：Wireshark 会话窗口*'
- en: The Conversations window shows three separate TCP conversations in the captured
    traffic. We know that the SuperFunkyChat client application uses port 12345, because
    we see three separate TCP sessions coming from port 12345\. These sessions should
    correspond to the three client sessions shown in [Listing 5-4](../Text/ch05.xhtml#ch5list4),
    [Listing 5-5](../Text/ch05.xhtml#ch5list5), and [Listing 5-6](../Text/ch05.xhtml#ch5list6).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 会话窗口显示了在捕获流量中三个独立的 TCP 会话。我们知道 SuperFunkyChat 客户端应用程序使用端口 12345，因为我们看到有三个独立的
    TCP 会话来自端口 12345。 这些会话应与 [列表 5-4](../Text/ch05.xhtml#ch5list4)、[列表 5-5](../Text/ch05.xhtml#ch5list5)
    和 [列表 5-6](../Text/ch05.xhtml#ch5list6) 中显示的三个客户端会话相对应。
- en: '***Reading the Contents of a TCP Session***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***读取 TCP 会话的内容***'
- en: To view the captured traffic for a single conversation, select one of the conversations
    in the Conversations window and click the **Follow Stream** button. A new window
    displaying the contents of the stream as ASCII text should appear, as shown in
    [Figure 5-5](../Text/ch05.xhtml#ch5fig5).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看单个对话的捕获流量，请在“会话”窗口中选择一个对话并点击**跟踪流**按钮。此时应该会弹出一个新窗口，显示流的内容，内容以 ASCII 文本形式呈现，如[图
    5-5](../Text/ch05.xhtml#ch5fig5)所示。
- en: '![image](../Images/f05-05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-05.jpg)'
- en: '*Figure 5-5: Displaying the contents of a TCP session in Wireshark’s Follow
    TCP Stream view*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：在 Wireshark 的“跟踪 TCP 流”视图中显示 TCP 会话内容*'
- en: Wireshark replaces data that can’t be represented as ASCII characters with a
    single dot character, but even with that character replacement, it’s clear that
    much of the data is being sent in plaintext. That said, the network protocol is
    clearly not exclusively a text-based protocol because the control information
    for the data is nonprintable characters. The only reason we’re seeing text is
    that SuperFunkyChat’s primary purpose is to send text messages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 将无法表示为 ASCII 字符的数据替换为一个点字符，但即使进行字符替换，我们也能清楚地看到许多数据以明文形式发送。也就是说，网络协议显然不是纯文本协议，因为数据的控制信息是不可打印字符。我们之所以看到文本，是因为
    SuperFunkyChat 的主要目的是发送文本消息。
- en: 'Wireshark shows the inbound and outbound traffic in a session using different
    colors: pink for outbound traffic and blue for inbound. In a TCP session, outbound
    traffic is from the client that initiated the TCP session, and inbound traffic
    is from the TCP server. Because we’ve captured all traffic to the server, let’s
    look at another conversation. To change the conversation, change the Stream number
    ➊ in [Figure 5-5](../Text/ch05.xhtml#ch5fig5) to 1\. You should now see a different
    conversation, for example, like the one in [Figure 5-6](../Text/ch05.xhtml#ch5fig6).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 使用不同的颜色显示会话中的进出流量：粉色表示出站流量，蓝色表示入站流量。在 TCP 会话中，出站流量来自发起 TCP 会话的客户端，而入站流量来自
    TCP 服务器。因为我们已经捕获了所有到服务器的流量，接下来让我们看一下另一段对话。要更改对话，请将[图 5-5](../Text/ch05.xhtml#ch5fig5)中的流号
    ➊更改为 1\. 现在你应该能看到一段不同的对话，比如[图 5-6](../Text/ch05.xhtml#ch5fig6)中的那一段。
- en: '![image](../Images/f05-06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-06.jpg)'
- en: '*Figure 5-6: A second TCP session from a different client*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：来自不同客户端的第二个 TCP 会话*'
- en: Compare [Figure 5-6](../Text/ch05.xhtml#ch5fig6) to [Figure 5-5](../Text/ch05.xhtml#ch5fig5);
    you’ll see the details of the two sessions are different. Some text sent by the
    client (in [Figure 5-6](../Text/ch05.xhtml#ch5fig6)), such as “How are you?”,
    is shown as received by the server in [Figure 5-5](../Text/ch05.xhtml#ch5fig5).
    Next, we’ll try to determine what those binary parts of the protocol represent.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将[图 5-6](../Text/ch05.xhtml#ch5fig6)与[图 5-5](../Text/ch05.xhtml#ch5fig5)进行比较，你会看到两个会话的详细信息不同。在[图
    5-6](../Text/ch05.xhtml#ch5fig6)中客户端发送的某些文本，比如“你好吗？”，会显示为服务器在[图 5-5](../Text/ch05.xhtml#ch5fig5)中接收到的内容。接下来，我们将尝试确定协议中的那些二进制部分表示什么。
- en: '**Identifying Packet Structure with Hex Dump**'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过十六进制转储识别数据包结构**'
- en: At this point, we know that our subject protocol seems to be part binary and
    part text, which indicates that looking at just the printable text won’t be enough
    to determine all the various structures in the protocol.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们知道我们的协议似乎既包含二进制数据也包含文本，这表明仅查看可打印文本不足以确定协议中所有的各种结构。
- en: To dig in, we first return to Wireshark’s Follow TCP Stream view, as shown in
    [Figure 5-5](../Text/ch05.xhtml#ch5fig5), and change the Show and save data as
    drop-down menu to the **Hex Dump** option. The stream should now look similar
    to [Figure 5-7](../Text/ch05.xhtml#ch5fig7).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入分析，我们首先回到 Wireshark 的“跟踪 TCP 流”视图，如[图 5-5](../Text/ch05.xhtml#ch5fig5)所示，并将“显示并保存数据为”下拉菜单更改为**十六进制转储**选项。此时流应该看起来像[图
    5-7](../Text/ch05.xhtml#ch5fig7)中的样子。
- en: '![image](../Images/f05-07.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-07.jpg)'
- en: '*Figure 5-7: The Hex Dump view of the stream*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：流的十六进制转储视图*'
- en: The Hex Dump view shows three columns of information. The column at the very
    left ➊ is the byte offset into the stream for a particular direction. For example,
    the byte at 0 is the first byte sent in that direction, the byte 4 is the fifth,
    and so on. The column in the center ➋ shows the bytes as a hex dump. The column
    at the right ➌ is the ASCII representation, which we saw previously in [Figure
    5-5](../Text/ch05.xhtml#ch5fig5).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制转储视图显示了三列信息。最左边的列 ➊ 是特定方向上数据流的字节偏移。例如，偏移量为 0 的字节是该方向上发送的第一个字节，偏移量为 4 的字节是第五个字节，以此类推。中间的列
    ➋ 显示的是字节的十六进制转储。右边的列 ➌ 是 ASCII 表示形式，我们之前在 [图 5-5](../Text/ch05.xhtml#ch5fig5)
    中看到过。
- en: '***Viewing Individual Packets***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看单个数据包***'
- en: Notice how the blocks of bytes shown in the center column in [Figure 5-7](../Text/ch05.xhtml#ch5fig7)
    vary in length. Compare this again to [Figure 5-6](../Text/ch05.xhtml#ch5fig6);
    you’ll see that other than being separated by direction, all data in [Figure 5-6](../Text/ch05.xhtml#ch5fig6)
    appears as one contiguous block. In contrast, the data in [Figure 5-7](../Text/ch05.xhtml#ch5fig7)
    might appear as just a few blocks of 4 bytes, then a block of 1 byte, and finally
    a much longer block containing the main group of text data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 [图 5-7](../Text/ch05.xhtml#ch5fig7) 中，中间列显示的字节块长度是如何变化的。再次与 [图 5-6](../Text/ch05.xhtml#ch5fig6)
    进行比较，你会发现，除了按方向分隔外，[图 5-6](../Text/ch05.xhtml#ch5fig6) 中的所有数据都呈现为一个连续的块。相比之下，[图
    5-7](../Text/ch05.xhtml#ch5fig7) 中的数据可能仅显示为几个 4 字节的小块，然后是一个 1 字节的块，最后是一个包含主要文本数据的大块。
- en: 'What we’re seeing in Wireshark are individual packets: each block is a single
    TCP packet, or *segment*, containing perhaps only 4 bytes of data. TCP is a stream-based
    protocol, which means that there are no real boundaries between consecutive blocks
    of data when you’re reading and writing data to a TCP socket. However, from a
    physical perspective, there’s no such thing as a real stream-based network transport
    protocol. Instead, TCP sends individual packets consisting of a TCP header containing
    information, such as the source and destination port numbers as well as the data.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Wireshark 中看到的是单个数据包：每个块都是一个单独的 TCP 数据包，或称为 *段*，可能仅包含 4 字节的数据。TCP 是基于流的协议，这意味着在你读取和写入数据到
    TCP 套接字时，连续的数据块之间没有真正的边界。然而，从物理角度来看，实际上并不存在一个真正的基于流的网络传输协议。相反，TCP 发送的是由包含信息的 TCP
    头部组成的单个数据包，这些信息包括源端口和目标端口号以及数据内容。
- en: In fact, if we return to the main Wireshark window, we can find a packet to
    prove that Wireshark is displaying single TCP packets. Select **Edit** ▸ **Find
    Packet**, and an additional drop-down menu appears in the main window, as shown
    [Figure 5-8](../Text/ch05.xhtml#ch5fig8).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果我们返回到主 Wireshark 窗口，我们可以找到一个数据包来证明 Wireshark 正在显示单个 TCP 数据包。选择 **编辑**
    ▸ **查找数据包**，主窗口中将出现一个额外的下拉菜单，如图 [5-8](../Text/ch05.xhtml#ch5fig8) 所示。
- en: '![image](../Images/f05-08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-08.jpg)'
- en: '*Figure 5-8: Finding a packet in Wireshark’s main window*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：在 Wireshark 主窗口中查找数据包*'
- en: We’ll find the first value shown in [Figure 5-7](../Text/ch05.xhtml#ch5fig7),
    the string `BINX`. To do this, fill in the Find options as shown in [Figure 5-8](../Text/ch05.xhtml#ch5fig8).
    The first selection box indicates where in the packet capture to search. Specify
    that you want to search in the Packet bytes ➊. Leave the second selection box
    as Narrow & Wide, which indicates that you want to search for both ASCII and Unicode
    strings. Also leave the Case sensitive box unchecked and specify that you want
    to look for a String value ➋ in the third drop-down menu. Then enter the string
    value we want to find, in this case the string `BINX` ➌. Finally, click the **Find**
    button, and the main window should automatically scroll and highlight the first
    packet Wireshark finds that contains the `BINX` string ➍. In the middle window
    at ➎, you should see that the packet contains 4 bytes, and you can see the raw
    data in the bottom window, which shows that we’ve found the `BINX` string ➏. We
    now know that the Hex Dump view Wireshark displays in [Figure 5-8](../Text/ch05.xhtml#ch5fig8)
    represents packet boundaries because the `BINX` string is in a packet of its own.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[图5-7](../Text/ch05.xhtml#ch5fig7)中找到第一个显示的值，即字符串`BINX`。为此，请按照[图5-8](../Text/ch05.xhtml#ch5fig8)所示填写查找选项。第一个选择框表示要在数据包捕获中查找的位置。指定要在数据包字节➊中进行查找。第二个选择框保持为“Narrow
    & Wide”，这表示您要查找ASCII和Unicode字符串。还请保持“区分大小写”框未选中，并在第三个下拉菜单中指定要查找字符串值➋。然后输入我们要查找的字符串值，在本例中是字符串`BINX`
    ➌。最后，点击**查找**按钮，主窗口应该会自动滚动并高亮显示Wireshark找到的第一个包含`BINX`字符串的数据包➍。在位于➎的中间窗口中，您应该看到数据包包含4个字节，并且您可以在底部窗口看到原始数据，这表明我们找到了`BINX`字符串➏。现在我们知道，Wireshark在[图5-8](../Text/ch05.xhtml#ch5fig8)中显示的十六进制转储视图代表数据包边界，因为`BINX`字符串位于一个独立的数据包中。
- en: '***Determining the Protocol Structure***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***确定协议结构***'
- en: To simplify determining the protocol structure, it makes sense to look only
    at one direction of the network communication. For example, let’s just look at
    the outbound direction (from client to server) in Wireshark. Returning to the
    Follow TCP Stream view, select the **Hex Dump** option in the Show and save data
    as drop-down menu. Then select the traffic direction from the client to the server
    on port 12345 from the drop-down menu at ➊, as shown in [Figure 5-9](../Text/ch05.xhtml#ch5fig9).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化协议结构的确定，最好只观察网络通信的一个方向。例如，我们只看Wireshark中的出站方向（从客户端到服务器）。回到“跟踪TCP流”视图，在“显示并保存数据为”下拉菜单中选择**十六进制转储**选项。然后，从➊的下拉菜单中选择从客户端到服务器的流量方向，端口号为12345，如[图5-9](../Text/ch05.xhtml#ch5fig9)所示。
- en: '![image](../Images/f05-09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-09.jpg)'
- en: '*Figure 5-9: A hex dump showing only the outbound direction*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-9：仅显示出站方向的十六进制转储*'
- en: Click the **Save as . . .** button to copy the outbound traffic hex dump to
    a text file to make it easier to inspect. [Listing 5-7](../Text/ch05.xhtml#ch5list7)
    shows a small sample of that traffic saved as text.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**另存为 . . .**按钮，将出站流量的十六进制转储复制到文本文件中，方便检查。[列表5-7](../Text/ch05.xhtml#ch5list7)显示了保存为文本的小部分流量。
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-7: A snippet of outbound traffic*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-7：出站流量的片段*'
- en: The outbound stream begins with the four characters `BINX` ➊. These characters
    are never repeated in the rest of the data stream, and if you compare different
    sessions, you’ll always find the same four characters at the start of the stream.
    If I were unfamiliar with this protocol, my intuition at this point would be that
    this is a magic value sent from the client to the server to tell the server that
    it’s talking to a valid client rather than some other application that happens
    to have connected to the server’s TCP port.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 出站流开始时有四个字符`BINX` ➊。这些字符在数据流的其余部分中从未重复出现，如果您比较不同的会话，您会发现流的开头总是这四个字符。如果我对这个协议不熟悉，此时我的直觉是，这是一个从客户端发送到服务器的魔法值，用来告诉服务器它正在与一个有效的客户端通信，而不是与一个偶然连接到服务器TCP端口的其他应用程序通信。
- en: Following the stream, we see that a sequence of four blocks is sent. The blocks
    at ➋ and ➌ are 4 bytes, the block at ➍ is 1 byte, and the block at ➎ is larger
    and contains mostly readable text. Let’s consider the first block of 4 bytes at
    ➋. Might these represent a small number, say the integer value 0xD or 13 in decimal?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着数据流，我们看到发送了四个块。位于➋和➌的块是4字节，位于➍的块是1字节，而位于➎的块较大，包含大部分可读文本。我们来考虑位于➋的第一个4字节块。这些字节可能代表一个小数字，比如十六进制值0xD或十进制值13吗？
- en: Recall the discussion of the Tag, Length, Value (TLV) pattern in [Chapter 3](../Text/ch03.xhtml#ch03).
    TLV is a very simple pattern in which each block of data is delimited by a value
    representing the length of the data that follows. This pattern is especially important
    for stream-based protocols, such as those running over TCP, because otherwise
    the application doesn’t know how much data it needs to read from a connection
    to process the protocol. If we assume that this first value is the length of the
    data, does this length match the length of the rest of the packet? Let’s find
    out.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾在[第3章](../Text/ch03.xhtml#ch03)中讨论的标签、长度、值（TLV）模式。TLV是一种非常简单的模式，其中每个数据块都由一个表示后续数据长度的值进行分隔。这个模式对于基于流的协议尤其重要，比如那些运行在TCP上的协议，因为如果没有这个模式，应用程序就无法知道它需要从连接中读取多少数据来处理协议。如果我们假设第一个值是数据的长度，这个长度与数据包其余部分的长度是否匹配呢？让我们来验证一下。
- en: Count the total bytes of the blocks at ➋, ➌, ➍, and ➎, which seem to be a single
    packet, and the result is 21 bytes, which is eight more than the value of 13 we
    were expecting (the integer value 0xD). The value of the length block might not
    be counting its own length. If we remove the length block (which is 4 bytes),
    the result is 17, which is 4 bytes more than the target length but getting closer.
    We also have the other unknown 4-byte block at ➌ following the potential length,
    but perhaps that’s not counted either. Of course, it’s easy to speculate, but
    facts are more important, so let’s do some testing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 统计➋、➌、➍和➎处数据块的总字节数，这些数据看起来是一个单独的数据包，结果为21字节，比我们预期的13字节多了8字节（即整数值0xD）。长度块的值可能没有计入它自己的长度。如果我们去掉长度块（4字节），结果是17字节，比目标长度多了4字节，但更接近了。我们还注意到在➌处有一个其他未知的4字节数据块，它可能紧跟在潜在的长度块之后，也许它没有被计算在内。当然，这只是猜测，事实更为重要，因此我们需要进行一些测试。
- en: '***Testing Our Assumptions***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试我们的假设***'
- en: At this point in such an analysis, I stop staring at a hex dump because it’s
    not the most efficient approach. One way to quickly test whether our assumptions
    are right is to export the data for the stream and write some simple code to parse
    the structure. Later in this chapter, we’ll write some code for Wireshark to do
    all of our testing within the GUI, but for now we’ll implement the code using
    Python on the command line.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这样的分析时，我通常会停止盯着十六进制转储，因为这不是最有效的方法。验证我们的假设是否正确的一种快速方法是导出流的数据，并编写一些简单的代码来解析结构。在本章后面，我们将为Wireshark编写一些代码，在GUI内进行所有测试，但现在我们将使用Python在命令行中实现代码。
- en: 'To get our data into Python, we could add support for reading Wireshark capture
    files, but for now we’ll just export the packet bytes to a file. To export the
    packets from the dialog shown in [Figure 5-9](../Text/ch05.xhtml#ch5fig9), follow
    these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据导入Python，我们本可以添加对Wireshark捕获文件的支持，但现在我们只会将数据包字节导出到一个文件。要从[图5-9](../Text/ch05.xhtml#ch5fig9)中显示的对话框中导出数据包，请按照以下步骤操作：
- en: In the Show and save data as drop-down menu, choose the **Raw** option.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“显示和保存数据为”下拉菜单中，选择**原始**选项。
- en: Click **Save As** to export the outbound packets to a binary file called *bytes_outbound.bin*.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**另存为**，将出站数据包导出为名为*bytes_outbound.bin*的二进制文件。
- en: We also want to export the inbound packets, so change to and select the inbound
    conversation. Then save the raw inbound bytes using the preceding steps, but name
    the file *bytes_inbound.bin*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要导出入站数据包，所以切换到并选择入站会话。然后，使用前面提到的步骤保存原始入站字节，并将文件命名为*bytes_inbound.bin*。
- en: Now use the XXD tool (or a similar tool) on the command line to be sure that
    we’ve successfully dumped the data, as shown in [Listing 5-8](../Text/ch05.xhtml#ch5list8).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在命令行中使用XXD工具（或类似工具）确保我们成功地导出了数据，如[清单5-8](../Text/ch05.xhtml#ch5list8)所示。
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-8: The exported packet bytes*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-8：导出的数据包字节*'
- en: '***Dissecting the Protocol with Python***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Python解析协议***'
- en: Now we’ll write a simple Python script to dissect the protocol. Because we’re
    just extracting data from a file, we don’t need to write any network code; we
    just need to open the file and read the data. We’ll also need to read binary data
    from the file—specifically, a network byte order integer for the length and unknown
    4-byte block.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个简单的Python脚本来解析协议。因为我们只是从文件中提取数据，所以不需要编写任何网络代码；我们只需要打开文件并读取数据。我们还需要从文件中读取二进制数据——具体来说，是网络字节顺序的整数值，表示长度和未知的4字节数据块。
- en: '**Performing the Binary Conversion**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**执行二进制转换**'
- en: We can use the built-in Python struct library to do the binary conversions.
    The script should fail immediately if something doesn’t seem right, such as not
    being able to read all the data we expect from the file. For example, if the length
    is 100 bytes and we can read only 20 bytes, the read should fail. If no errors
    occur while parsing the file, we can be more confident that our analysis is correct.
    [Listing 5-9](../Text/ch05.xhtml#ch5list9) shows the first implementation, written
    to work in both Python 2 and 3.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内置的 Python struct 库来进行二进制转换。如果出现任何问题，脚本应该立即失败，例如无法读取我们预期的所有数据。如果长度是100字节，而我们只能读取20字节，则读取应该失败。如果在解析文件时没有发生错误，我们可以更有信心地认为我们的分析是正确的。[清单
    5-9](../Text/ch05.xhtml#ch5list9)展示了第一个实现版本，适用于 Python 2 和 3。
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-9: An example Python script for parsing protocol data*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-9：解析协议数据的示例 Python 脚本*'
- en: Let’s break down the important parts of the script. First, we define some helper
    functions to read data from the file. The function `read_bytes()` ➊ reads a fixed
    number of bytes from the file specified as a parameter. If not enough bytes are
    in the file to satisfy the read, an exception is thrown to indicate an error ➋.
    We also define a function `read_int()` ➌ to read a 4-byte integer from the file
    in network byte order where the most significant byte of the integer is first
    in the file, as well as define a function to read a single byte ➍. In the main
    body of the script, we open a file passed on the command line and first read a
    4-byte value ➎, which we expect is the magic value `BINX`. Then the code enters
    a loop ➏ while there’s still data to read, reading out the length, the two unknown
    values, and finally the data and then printing the values to the console.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下脚本中的关键部分。首先，我们定义了一些辅助函数来从文件中读取数据。函数`read_bytes()` ➊从文件中读取指定数量的字节。如果文件中的字节不足以满足读取要求，将抛出一个异常，表示发生了错误
    ➋。我们还定义了一个函数`read_int()` ➌，用于按网络字节顺序读取4字节整数，其中整数的最高有效字节位于文件的最前面，并且定义了一个读取单个字节的函数
    ➍。在脚本的主体部分，我们打开命令行中传递的文件，并首先读取一个4字节的值 ➎，我们期望它是魔法值`BINX`。然后代码进入一个循环 ➏，只要还有数据可以读取，就继续读取长度、两个未知值，最后是数据，并将这些值打印到控制台。
- en: When you run the script in [Listing 5-9](../Text/ch05.xhtml#ch5list9) and pass
    it the name of a binary file to open, all data from the file should be parsed
    and no errors generated if our analysis that the first 4-byte block was the length
    of the data sent on the network is correct. [Listing 5-10](../Text/ch05.xhtml#ch5list10)
    shows example output in Python 3, which does a better job of displaying binary
    strings than Python 2.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行[清单 5-9](../Text/ch05.xhtml#ch5list9)脚本并传入一个二进制文件的名称时，如果我们分析认为文件的前4字节是网络上发送的数据长度，则文件中的所有数据应该会被正确解析且不会产生错误。[清单
    5-10](../Text/ch05.xhtml#ch5list10)展示了在 Python 3 中的示例输出，Python 3 在显示二进制字符串方面比
    Python 2 更好。
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 5-10: Example output from running [Listing 5-9](../Text/ch05.xhtml#ch5list9)
    against a binary file*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-10：运行[清单 5-9](../Text/ch05.xhtml#ch5list9)时对二进制文件的示例输出*'
- en: '**Handling Inbound Data**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**处理入站数据**'
- en: If you ran [Listing 5-9](../Text/ch05.xhtml#ch5list9) against an exported inbound
    data set, you would immediately get an error because there’s no magic string `BINX`
    in the inbound protocol, as shown in [Listing 5-11](../Text/ch05.xhtml#ch5list11).
    Of course, this is what we would expect if there were a mistake in our analysis
    and the length field wasn’t quite as simple as we thought.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对导出的入站数据集运行[清单 5-9](../Text/ch05.xhtml#ch5list9)，你将立即遇到错误，因为入站协议中没有魔法字符串`BINX`，如[清单
    5-11](../Text/ch05.xhtml#ch5list11)所示。当然，如果我们的分析有误，长度字段并不像我们想象的那么简单，那么这正是我们所预期的。
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 5-11 Error generated by [Listing 5-9](../Text/ch05.xhtml#ch5list9)
    on inbound data*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-11：[清单 5-9](../Text/ch05.xhtml#ch5list9)在入站数据上生成的错误*'
- en: We can clear up this error by modifying the script slightly to include a check
    for the magic value and reset the file pointer if it’s not equal to the string
    `BINX`. Add the following line just after the file is opened in the original script
    to reset the file pointer to the start if the magic value is incorrect.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过稍微修改脚本，增加对魔法值的检查，并在魔法值不等于字符串`BINX`时重置文件指针，从而解决这个错误。在原始脚本中，在文件打开后添加以下行，如果魔法值不正确，则将文件指针重置到开始位置。
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, with this small modification, the script will execute successfully on the
    inbound data and result in the output shown in [Listing 5-12](../Text/ch05.xhtml#ch5list12).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过这个小修改，脚本将在入站数据上成功执行，并生成[清单 5-12](../Text/ch05.xhtml#ch5list12)中显示的输出。
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-12: Output of modified script on inbound data*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-12：修改后的脚本在入站数据上的输出*'
- en: '**Digging into the Unknown Parts of the Protocol**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**深入挖掘协议中的未知部分**'
- en: We can use the output in [Listing 5-10](../Text/ch05.xhtml#ch5list10) and [Listing
    5-12](../Text/ch05.xhtml#ch5list12) to start delving into the unknown parts of
    the protocol. First, consider the field labeled `Unk1`. The values it takes seem
    to be different for every packet, but the values are low, ranging from 1 to 3146.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[清单 5-10](../Text/ch05.xhtml#ch5list10)和[清单 5-12](../Text/ch05.xhtml#ch5list12)中的输出，开始深入探索协议中未知的部分。首先，考虑标记为`Unk1`的字段。它的值似乎对每个数据包都不同，但这些值较小，范围从1到3146。
- en: But the most informative parts of the output are the following two entries,
    one from the outbound data and one from the inbound.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但输出中最有信息量的部分是以下两项，一项来自出站数据，一项来自入站数据。
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that in both entries the value of `Unk1` is the same as `Unk2`. That
    could be a coincidence, but the fact that both entries have the same value might
    indicate something important. Also notice that in the second entry the length
    is `2`, which includes the `Unk2` value and a `0` data value, whereas the length
    of the first entry is only `1` with no trailing data after the `Unk2` value. Perhaps
    `Unk1` is directly related to the data in the packet? Let’s find out.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在这两个条目中，`Unk1`的值与`Unk2`相同。这可能是巧合，但两个条目具有相同的值可能表明某些重要的东西。还要注意，第二个条目的长度是`2`，包括`Unk2`值和一个`0`数据值，而第一个条目的长度只有`1`，在`Unk2`值后没有跟随数据。也许`Unk1`直接与数据包中的数据有关？让我们来看看。
- en: '**Calculating the Checksum**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算校验和**'
- en: It’s common to add a checksum to a network protocol. The canonical example of
    a checksum is just the sum of all the bytes in the data you want to check for
    errors. If we assume that the unknown value is a *simple* checksum, we can sum
    all the bytes in the example outbound and inbound packets I highlighted in the
    preceding section, resulting in the calculated sum shown in [Table 5-2](../Text/ch05.xhtml#ch5tab2).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络协议中添加校验和是很常见的。校验和的典型示例就是对你想检查是否有错误的所有字节求和。如果我们假设未知值是一个*简单*的校验和，我们可以将前面部分中提到的出站和入站数据包中的所有字节求和，得到[表
    5-2](../Text/ch05.xhtml#ch5tab2)中显示的计算结果。
- en: '**Table 5-2:** Testing Checksum for Example Packets'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-2：** 示例数据包的校验和测试'
- en: '| **Unknown value** | **Data bytes** | **Sum of data bytes** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **未知值** | **数据字节** | **数据字节的和** |'
- en: '| --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 6 | 6 | 6 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 6 | 6 |'
- en: '| 1 | 1, 0 | 1 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1, 0 | 1 |'
- en: Although [Table 5-2](../Text/ch05.xhtml#ch5tab2) seems to confirm that the unknown
    value matches our expectation of a simple checksum for very simple packets, we
    still need to verify that the checksum works for larger and more complex packets.
    There are two easy ways to determine whether we’ve guessed correctly that the
    unknown value is a checksum over the data. One way is to send simple, incrementing
    messages from a client (like *A*, then *B*, then *C*, and so on), capture the
    data, and analyze it. If the checksum is a simple addition, the value should increment
    by 1 for each incrementing message. The alternative would be to add a function
    to calculate the checksum to see whether the checksum matches between what was
    captured on the network and our calculated value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[表 5-2](../Text/ch05.xhtml#ch5tab2)似乎确认了未知值与我们对非常简单数据包的简单校验和预期相符，但我们仍然需要验证校验和是否适用于更大和更复杂的数据包。有两种简单方法可以确定我们是否正确猜测未知值是数据的校验和。第一种方法是从客户端发送简单的递增消息（比如*A*，然后是*B*，然后是*C*，依此类推），捕获数据并进行分析。如果校验和是简单的加法，那么每条递增的消息值应该增加1。另一种方法是向脚本中添加计算校验和的函数，看看捕获的网络数据与我们计算的值之间是否匹配。
- en: To test our assumptions, add the code in [Listing 5-13](../Text/ch05.xhtml#ch5list13)
    to the script in Listing 5-7 and add a call to it after reading the data to calculate
    the checksum. Then just compare the value extracted from the network capture as
    `Unk1` and the calculated value to see whether our calculated checksum matches.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的假设，将[清单 5-13](../Text/ch05.xhtml#ch5list13)中的代码添加到清单 5-7中的脚本中，并在读取数据后调用它来计算校验和。然后，只需比较从网络捕获中提取的`Unk1`值和计算值，看看我们计算的校验和是否匹配。
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 5-13: Calculating the checksum of a packet*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-13：计算数据包的校验和*'
- en: And it does! The numbers calculated match the value of `Unk1`. So, we’ve discovered
    the next part of the protocol structure.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果确实如此！计算出来的数字与`Unk1`的值匹配。因此，我们已经发现了协议结构中的下一部分。
- en: '**Discovering a Tag Value**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**发现标签值**'
- en: Now we need to determine what `Unk2` might represent. Because the value of `Unk2`
    is considered part of the packet’s data, it’s presumably related to the meaning
    of what is being sent. However, as we saw at ➍ in [Listing 5-7](../Text/ch05.xhtml#ch5list7),
    the value of `Unk2` is being written to the network as a single byte value, which
    indicates that it’s actually separate from the data. Perhaps the value represents
    the Tag part of a TLV pattern, just as we suspect that Length is the Value part
    of that construction.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要确定`Unk2`可能代表什么。由于`Unk2`的值被视为数据包的数据的一部分，因此它很可能与所发送内容的含义有关。然而，正如我们在[清单 5-7](../Text/ch05.xhtml#ch5list7)的➍处所看到的，`Unk2`的值作为一个单字节值被写入网络，这表明它实际上与数据是分开的。也许这个值表示TLV模式中的标签部分，就像我们怀疑长度（Length）是该结构中的值部分一样。
- en: To determine whether `Unk2` is in fact the Tag value and a representation of
    how to interpret the rest of the data, we’ll exercise the ChatClient as much as
    possible, try all possible commands, and capture the results. We can then perform
    basic analysis comparing the value of `Unk2` when sending the same type of command
    to see whether the value of `Unk2` is always the same.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定`Unk2`是否确实是标签值，并代表如何解释其余数据，我们将尽可能多地测试ChatClient，尝试所有可能的命令，并捕获结果。然后，我们可以进行基本分析，比较发送相同类型命令时`Unk2`的值，以查看`Unk2`的值是否总是相同。
- en: For example, consider the client sessions in [Listing 5-4](../Text/ch05.xhtml#ch5list4),
    [Listing 5-5](../Text/ch05.xhtml#ch5list5), and [Listing 5-6](../Text/ch05.xhtml#ch5list6).
    In the session in [Listing 5-5](../Text/ch05.xhtml#ch5list5), we sent two messages,
    one after another. We’ve already analyzed this session using our Python script
    in [Listing 5-10](../Text/ch05.xhtml#ch5list10). For simplicity, [Listing 5-14](../Text/ch05.xhtml#ch5list14)
    shows only the first three capture packets (with the latest version of the script).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑[清单 5-4](../Text/ch05.xhtml#ch5list4)、[清单 5-5](../Text/ch05.xhtml#ch5list5)和[清单
    5-6](../Text/ch05.xhtml#ch5list6)中的客户端会话。在[清单 5-5](../Text/ch05.xhtml#ch5list5)中的会话里，我们连续发送了两个消息。我们已经通过[清单
    5-10](../Text/ch05.xhtml#ch5list10)中的Python脚本分析了这个会话。为了简便起见，[清单 5-14](../Text/ch05.xhtml#ch5list14)只显示了前三个捕获数据包（使用的是最新版本的脚本）。
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 5-14: The first three packets from the session represented by [Listing
    5-5](../Text/ch05.xhtml#ch5list5)*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-14：来自[清单 5-5](../Text/ch05.xhtml#ch5list5)会话的前三个数据包*'
- en: The first packet ➊ doesn’t correspond to anything we typed into the client session
    in [Listing 5-5](../Text/ch05.xhtml#ch5list5). The unknown value is `0`. The two
    messages we then sent in [Listing 5-5](../Text/ch05.xhtml#ch5list5) are clearly
    visible as text in the `Data` part of the packets at ➋ and ➌. The `Unk2` values
    for both of those messages is `3`, which is different from the first packet’s
    value of `0`. Based on this observation, we can assume that the value of `3` might
    represent a packet that is sending a message, and if that’s the case, we’d expect
    to find a value of `3` used in every connection when sending a single value. In
    fact, if you now analyze a different session containing messages being sent, you’ll
    find the same value of `3` used whenever a message is sent.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据包➊与我们在[清单 5-5](../Text/ch05.xhtml#ch5list5)客户端会话中输入的内容无关。未知值是`0`。我们在[清单
    5-5](../Text/ch05.xhtml#ch5list5)中发送的两个消息在数据包的`Data`部分清晰可见，分别位于➋和➌处。这两条消息的`Unk2`值为`3`，与第一个数据包的`0`值不同。根据这一观察，我们可以推测`3`的值可能代表发送消息的数据包，如果是这样的话，我们就会期望在每次发送单个值时，连接中都使用`3`这个值。实际上，如果你现在分析包含发送消息的其他会话，你会发现每次发送消息时，都会使用相同的`3`值。
- en: '**NOTE**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*At this stage in my analysis, I’d return to the various client sessions and
    try to correlate the action I performed in the client with the messages sent.
    Also, I’d correlate the messages I received from the server with the client’s
    output. Of course, this is easy when there’s likely to be a one-to-one match between
    the command we use in the client and the result on the network. However, more
    complex protocols and applications might not be that obvious, so you’ll have to
    do a lot of correlation and testing to try to discover all the possible values
    for particular parts of the protocol.*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*在我的分析阶段，我会回到各种客户端会话，并尝试将我在客户端执行的操作与发送的消息进行关联。同时，我会将从服务器收到的消息与客户端的输出进行关联。当然，当我们在客户端使用的命令与网络上的结果之间可能有一一对应关系时，这很容易做到。然而，更复杂的协议和应用程序可能不会这么明显，因此你需要进行大量的关联和测试，试图发现协议中特定部分的所有可能值。*'
- en: We can assume that `Unk2` represents the Tag part of the TLV structure. Through
    further analysis, we can infer the possible Tag values, as shown in [Table 5-3](../Text/ch05.xhtml#ch5tab3).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设 `Unk2` 代表 TLV 结构中的 Tag 部分。通过进一步分析，我们可以推断出可能的 Tag 值，如 [表 5-3](../Text/ch05.xhtml#ch5tab3)
    所示。
- en: '**Table 5-3:** Inferred Commands from Analysis of Captured Sessions'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-3：** 从捕获的会话分析推测的命令'
- en: '| **Command number** | **Direction** | **Description** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **命令编号** | **方向** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Outbound | Sent when client connects to server. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 出站 | 客户端连接到服务器时发送。 |'
- en: '| 1 | Inbound | Sent from server after client sends command `''0''` to the
    server. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 入站 | 服务器在客户端向服务器发送命令 `''0''` 后发送。 |'
- en: '| 2 | Both | Sent from client when `/quit` command is used. Sent by server
    in response. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 双向 | 客户端使用 `/quit` 命令时发送。服务器响应时发送。 |'
- en: '| 3 | Both | Sent from client with a message for all users. Sent from server
    with the message from all users. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 双向 | 客户端发送给所有用户的消息。服务器发送所有用户的消息。 |'
- en: '| 5 | Outbound | Sent from client when `/msg` command is used. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 出站 | 客户端使用 `/msg` 命令时发送。 |'
- en: '| 6 | Outbound | Sent from client when `/list` command is used. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 出站 | 客户端使用 `/list` 命令时发送。 |'
- en: '| 7 | Inbound | Sent from server in response to `/list` command. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 入站 | 服务器响应 `/list` 命令时发送。 |'
- en: '**NOTE**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ve built a table of commands but we still don’t know how the data for each
    of these commands is represented. To further analyze that data, we’ll return to
    Wireshark and develop some code to dissect the protocol and display it in the
    GUI. It can be difficult to deal with simple binary files, and although we could
    use a tool to parse a capture file exported from Wireshark, it’s best to have
    Wireshark handle a lot of that work.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们已经建立了一个命令表，但仍然不知道每个命令的数据是如何表示的。为了进一步分析这些数据，我们将返回到 Wireshark，编写代码来解析该协议并在图形界面中显示出来。处理简单的二进制文件可能很困难，尽管我们可以使用工具解析从
    Wireshark 导出的捕获文件，但最好让 Wireshark 处理很多这项工作。*'
- en: '**Developing Wireshark Dissectors in Lua**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在 Lua 中开发 Wireshark 解析器**'
- en: 'It’s easy to analyze a known protocol like HTTP with Wireshark because the
    software can extract all the necessary information. But custom protocols are a
    bit more challenging: to analyze them, we’ll have to manually extract all the
    relevant information from a byte representation of the network traffic.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Wireshark 分析已知协议，如 HTTP，很容易，因为该软件可以提取所有必要的信息。但自定义协议则稍微有些挑战性：为了分析这些协议，我们需要手动从网络流量的字节表示中提取所有相关信息。
- en: Fortunately, you can use the Wireshark plug-in Protocol Dissectors to add additional
    protocol analysis to Wireshark. Doing so used to require building a dissector
    in C to work with your particular version of Wireshark, but modern versions of
    Wireshark support the Lua scripting language. The scripts you write in Lua will
    also work with the tshark command line tool.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用 Wireshark 插件协议解析器来为 Wireshark 添加额外的协议分析功能。过去，做到这一点需要用 C 语言构建一个解析器，以便与特定版本的
    Wireshark 一起工作，但现代版本的 Wireshark 支持 Lua 脚本语言。你在 Lua 中编写的脚本同样可以与 tshark 命令行工具一起使用。
- en: This section describes how to develop a simple Lua script dissector for the
    SuperFunkyChat protocol that we’ve been analyzing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍如何为我们一直在分析的 SuperFunkyChat 协议开发一个简单的 Lua 脚本解析器。
- en: '**NOTE**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Details about developing in Lua and the Wireshark APIs are beyond the scope
    of this book. For more information on how to develop in Lua, visit its official
    website at [https://www.lua.org/docs.html](https://www.lua.org/docs.html). The
    Wireshark website, and especially the Wiki, are the best places to visit for various
    tutorials and example code* ([https://wiki.wireshark.org/Lua/](https://wiki.wireshark.org/Lua/)).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于在 Lua 中开发和 Wireshark API 的详细信息超出了本书的范围。如需了解如何在 Lua 中开发，请访问其官方网站 [https://www.lua.org/docs.html](https://www.lua.org/docs.html)。Wireshark
    的官方网站，特别是 Wiki，是访问各种教程和示例代码的最佳去处* ([https://wiki.wireshark.org/Lua/](https://wiki.wireshark.org/Lua/))。'
- en: Before developing the dissector, make sure your copy of Wireshark supports Lua
    by checking the About Wireshark dialog at **Help** ▸ **About Wireshark**. If you
    see the word *Lua* in the dialog, as shown in [Figure 5-10](../Text/ch05.xhtml#ch5fig10),
    you should be good to go.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发解析器之前，请确保你的 Wireshark 版本支持 Lua，可以通过 **帮助** ▸ **关于 Wireshark** 对话框来检查。如果你在对话框中看到
    *Lua* 字样，如 [图 5-10](../Text/ch05.xhtml#ch5fig10) 所示，说明一切正常，可以继续操作。
- en: '![image](../Images/f05-10.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-10.jpg)'
- en: '*Figure 5-10: The Wireshark About dialog showing Lua support*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-10：Wireshark 关于对话框显示 Lua 支持*'
- en: '**NOTE**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you run Wireshark as root on a Unix-like system, Wireshark will typically
    disable Lua support for security reasons, and you’ll need to configure Wireshark
    to run as a nonprivileged user to capture and run Lua scripts. See the Wireshark
    documentation for your operating system to find out how to do so securely.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你以 root 用户身份在类 Unix 系统上运行 Wireshark，Wireshark 通常会出于安全原因禁用 Lua 支持，且你需要将 Wireshark
    配置为非特权用户来捕获并运行 Lua 脚本。请参阅你的操作系统的 Wireshark 文档，了解如何安全地进行配置。*'
- en: You can develop dissectors for almost any protocol that Wireshark will capture,
    including TCP and UDP. It’s much easier to develop dissectors for UDP protocols
    than it is for TCP, because each captured UDP packet typically has everything
    needed by the dissector. With TCP, you’ll need to deal with such problems as data
    that spans multiple packets (which is exactly why we needed to account for length
    block in our work on SuperFunkyChat using the Python script in [Listing 5-9](../Text/ch05.xhtml#ch5list9)).
    Because UDP is easier to work with, we’ll focus on developing UDP dissectors.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为 Wireshark 捕获的几乎任何协议开发解码器，包括 TCP 和 UDP。开发 UDP 协议的解码器比 TCP 更容易，因为每个捕获的 UDP
    包通常包含了解码器所需的所有信息。而对于 TCP，你需要处理跨多个数据包的数据（这正是我们在使用 Python 脚本处理 SuperFunkyChat 时需要考虑数据长度块问题的原因，见[清单
    5-9](../Text/ch05.xhtml#ch5list9)）。由于 UDP 更易处理，我们将专注于开发 UDP 解码器。
- en: Conveniently enough, SuperFunkyChat supports a UDP mode by passing the `--udp`
    command line parameter to the client when starting. Send this flag while capturing,
    and you should see packets similar to those shown in [Figure 5-11](../Text/ch05.xhtml#ch5fig11).
    (Notice that Wireshark mistakenly tries to dissect the traffic as an unrelated
    GVSP protocol, as displayed in the Protocol column ➊. Implementing our own dissector
    will fix the mistaken protocol choice.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，SuperFunkyChat 支持通过在启动客户端时传递 `--udp` 命令行参数来启用 UDP 模式。在捕获数据时发送此标志，你应该能看到类似于[图
    5-11](../Text/ch05.xhtml#ch5fig11)所示的包。（注意，Wireshark 错误地试图将流量解析为不相关的 GVSP 协议，如协议列
    ➊ 所示。实现我们自己的解码器将修正这一错误的协议选择。）
- en: '![image](../Images/f05-11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-11.jpg)'
- en: '*Figure 5-11: Wireshark showing captured UDP traffic*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11: Wireshark 显示捕获的 UDP 流量*'
- en: 'One way to load Lua files is to put your scripts in the *%APPDATA%\Wireshark\plugins*
    directory on Windows and in the *~/.config/wireshark/plugins* directory on Linux
    and macOS. You can also load a Lua script by specifying it on the command line
    as follows, replacing the path information with the location of your script:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 Lua 文件的一种方法是将脚本放置在 Windows 系统中的 *%APPDATA%\Wireshark\plugins* 目录下，或在 Linux
    和 macOS 系统中的 *~/.config/wireshark/plugins* 目录下。你也可以通过在命令行中指定 Lua 脚本来加载，方法如下，将路径信息替换为你脚本的存储位置：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If there’s an error in your script’s syntax, you should see a message dialog
    similar to [Figure 5-12](../Text/ch05.xhtml#ch5fig12). (Granted, this isn’t exactly
    the most efficient way to develop, but it’s fine as long as you’re just prototyping.)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的脚本语法有误，你应该会看到类似于[图 5-12](../Text/ch05.xhtml#ch5fig12)所示的消息对话框。（虽然这不是开发过程中最高效的方式，但只要你只是进行原型开发，这样也没问题。）
- en: '![image](../Images/f05-12.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-12.jpg)'
- en: '*Figure 5-12: The Wireshark Lua error dialog*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-12: Wireshark Lua 错误对话框*'
- en: '***Creating the Dissector***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建解码器***'
- en: To create a protocol dissector for the SuperFunkyChat protocol, first create
    the basic shell of the dissector and register it in Wireshark’s list of dissectors
    for UDP port 12345\. Copy [Listing 5-15](../Text/ch05.xhtml#ch5list15) into a
    file called *dissector.lua* and load it into Wireshark along with an appropriate
    packet capture of the UDP traffic. It should run without errors.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 SuperFunkyChat 协议创建协议解码器，首先创建解码器的基本框架，并将其注册到 Wireshark 的 UDP 端口 12345 的解码器列表中。将[清单
    5-15](../Text/ch05.xhtml#ch5list15)复制到一个名为 *dissector.lua* 的文件中，并将其与相应的 UDP 流量数据包捕获一起加载到
    Wireshark 中。它应该能够无误地运行。
- en: dissector.lua
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: dissector.lua
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 5-15: A basic Lua Wireshark dissector*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-15: 基本的 Lua Wireshark 解码器*'
- en: When the script initially loads, it creates a new instance of the `Proto` class
    ➊, which represents an instance of a Wireshark protocol and assigns it the name
    `chat_proto`. Although you can build the dissected tree manually, I’ve chosen
    to define specific fields for the protocol at ➋ so the fields will be added to
    the display filter engine, and you’ll be able to set a display filter of `chat.command
    == 0` so Wireshark will only show packets with command `0`. (This technique is
    very useful for analysis because you can filter down to specific packets easily
    and analyze them separately.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本初次加载时，它会创建`Proto`类的新实例➊，该实例表示Wireshark协议的一个实例，并将其命名为`chat_proto`。虽然你可以手动构建解码树，但我选择在➋处为协议定义特定字段，这样这些字段将被添加到显示过滤器引擎中，你就可以设置`chat.command
    == 0`的显示过滤器，这样Wireshark只会显示命令为`0`的数据包。（这种技术对于分析非常有用，因为你可以轻松过滤出特定的数据包并单独分析它们。）
- en: 'At ➌, the script creates a `dissector()` function on the instance of the `Proto`
    class. This `dissector()` will be called to dissect a packet. The function takes
    three parameters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，脚本在`Proto`类的实例上创建了一个`dissector()`函数。这个`dissector()`函数将被调用来解析一个数据包。该函数接受三个参数：
- en: • A buffer containing the packet data that is an instance of something Wireshark
    calls a Testy Virtual Buffer (TVB).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个包含数据包数据的缓冲区，它是Wireshark所称的Testy Virtual Buffer (TVB)的一个实例。
- en: • A packet information instance that represents the display information for
    the dissection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个表示解码显示信息的数据包实例。
- en: • The root tree object for the UI. You can attach subnodes to this tree to generate
    your display of the packet data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: • 用于UI的根树对象。你可以将子节点附加到这棵树上，以生成数据包数据的显示。
- en: At ➍, we set the name of the protocol in the UI column (as shown in [Figure
    5-11](../Text/ch05.xhtml#ch5fig11)) to `CHAT`. Next, we build a tree of the protocol
    elements ➎ we’re dissecting. Because UDP doesn’t have an explicit length field,
    we don’t need to take that into account; we only need to extract the checksum
    field. We add to the subtree using the protocol fields and use the `buffer` parameter
    to create a range, which takes a start index into the buffer and an optional length.
    If no length is specified, the rest of the buffer is used.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在➍处，我们设置了UI列中协议的名称（如[图 5-11](../Text/ch05.xhtml#ch5fig11)所示）为`CHAT`。接下来，我们构建了我们正在解析的协议元素的树形结构➎。由于UDP没有明确的长度字段，我们不需要考虑这个因素；我们只需要提取校验和字段。我们使用协议字段将其添加到子树中，并使用`buffer`参数创建一个范围，该范围从缓冲区的起始索引开始，并可选地指定一个长度。如果没有指定长度，则使用缓冲区的其余部分。
- en: Then we register the protocol dissector with Wireshark’s UDP dissector table.
    (Notice that the function we defined at ➌ hasn’t actually executed yet; we’ve
    simply defined it.) Finally, we get the UDP table and add our `chat_proto` object
    to the table with port 12345 ➏. Now we’re ready to start the dissection.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将协议解码器注册到Wireshark的UDP解码器表中。（注意，我们在➌处定义的函数实际上并未执行；我们只是定义了它。）最后，我们获取UDP表并将`chat_proto`对象添加到端口12345的表中➏。现在我们已经准备好开始解码了。
- en: '***The Lua Dissection***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Lua解码***'
- en: Start Wireshark using the script in [Listing 5-15](../Text/ch05.xhtml#ch5list15)
    (for example, using the `–X` parameter) and then load a packet capture of the
    UDP traffic. You should see that the dissector has loaded and dissected the packets,
    as shown in [Figure 5-13](../Text/ch05.xhtml#ch5fig13).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[清单 5-15](../Text/ch05.xhtml#ch5list15)中的脚本（例如，使用`–X`参数）启动Wireshark，然后加载UDP流量的数据包捕获。你应该看到解码器已经加载并解析了数据包，如[图
    5-13](../Text/ch05.xhtml#ch5fig13)所示。
- en: At ➊, the Protocol column has changed to `CHAT`. This matches the first line
    of our dissector function in [Listing 5-15](../Text/ch05.xhtml#ch5list15) and
    makes it easier to see that we’re dealing with the correct protocol. At ➋, the
    resulting tree shows the different fields of the protocol with the checksum printed
    in hex, as we specified. If you click the Data field in the tree, the corresponding
    range of bytes should be highlighted in the raw packet display at the bottom of
    the window ➌.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，协议列已更改为`CHAT`。这与我们在[清单 5-15](../Text/ch05.xhtml#ch5list15)中的解码器函数的第一行相匹配，这使得更容易看到我们正在处理正确的协议。在➋处，生成的树显示了协议的不同字段，校验和以十六进制格式打印，正如我们所指定的那样。如果你点击树中的数据字段，相应的字节范围应在窗口底部的原始数据包显示中高亮显示➌。
- en: '![image](../Images/f05-13.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-13.jpg)'
- en: '*Figure 5-13: Dissected SuperFunkyChat protocol traffic*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-13：解析后的SuperFunkyChat协议流量*'
- en: '***Parsing a Message Packet***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解析消息数据包***'
- en: Let’s augment the dissector to parse a particular packet. We’ll use command
    `3` as our example because we’ve determined that it marks the sending or receiving
    of a message. Because a received message should show the ID of the sender as well
    as the message text, this packet data should contain both components; this makes
    it a perfect example for our purposes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展解剖器，解析一个特定的数据包。我们将使用命令`3`作为示例，因为我们已经确定它标记了消息的发送或接收。由于接收到的消息应该显示发送者的ID以及消息文本，因此这个数据包应包含这两个组件；这使得它成为一个非常合适的示例。
- en: '[Listing 5-16](../Text/ch05.xhtml#ch5list16) shows a snippet from [Listing
    5-10](../Text/ch05.xhtml#ch5list10) when we dumped the traffic using our Python
    script.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-16](../Text/ch05.xhtml#ch5list16)显示了从[清单 5-10](../Text/ch05.xhtml#ch5list10)中提取的片段，我们通过Python脚本转储了流量。'
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-16: Example message data*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-16：示例消息数据*'
- en: '[Listing 5-16](../Text/ch05.xhtml#ch5list16) shows two examples of message
    packet data in a binary Python string format. The `\xXX` characters are actually
    nonprintable bytes, so `\x05` is really the byte 0x05 and `\x16` is 0x16 (or 22
    in decimal). Two printable strings are in each packet shown in the listing: the
    first is a username (in this case `bob`), and the second is the message. Each
    string is prefixed by a nonprintable character. Very simple analysis (counting
    characters, in this case) indicates that the nonprintable character is the length
    of the string that follows the character. For example, with the username string,
    the nonprintable character represents 0x03, and the string `bob` is three characters
    in length.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-16](../Text/ch05.xhtml#ch5list16)显示了两条消息数据包的示例，数据采用二进制Python字符串格式。`\xXX`字符实际上是不可打印字节，因此`\x05`实际上是字节0x05，`\x16`是0x16（或十进制的22）。每个数据包中都有两个可打印的字符串，第一个是用户名（在这个例子中是`bob`），第二个是消息。每个字符串前都有一个不可打印字符。通过非常简单的分析（例如，字符计数），我们可以看到不可打印字符表示后续字符串的长度。例如，在用户名字符串中，不可打印字符表示0x03，而字符串`bob`的长度为三个字符。'
- en: Let’s write a function to parse a single string from its binary representation.
    We’ll update [Listing 5-15](../Text/ch05.xhtml#ch5list15) to add support for parsing
    the message command in [Listing 5-17](../Text/ch05.xhtml#ch5list17).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来写一个函数，用于解析单个字符串的二进制表示。我们将更新[清单 5-15](../Text/ch05.xhtml#ch5list15)，以支持解析[清单
    5-17](../Text/ch05.xhtml#ch5list17)中的消息命令。
- en: dissector_with
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: dissector_with
- en: _commands.lua
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: _commands.lua
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-17: The updated dissector script used to parse the `Message` command*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-17：用于解析`Message`命令的更新后的解剖脚本*'
- en: In [Listing 5-17](../Text/ch05.xhtml#ch5list17), the added `read_string()` function
    ➊ takes a TVB object (`buffer`) and a starting offset (`start`), and it returns
    the length of the buffer and then the string.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 5-17](../Text/ch05.xhtml#ch5list17)中，添加的`read_string()`函数➊接受一个TVB对象（`buffer`）和一个起始偏移量（`start`），它返回缓冲区的长度和字符串内容。
- en: '**NOTE**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*What if the string is longer than the range of a byte value? Ah, that’s one
    of the challenges of protocol analysis. Just because something looks simple doesn’t
    mean it actually is simple. We’ll ignore issues such as the length because this
    is only meant as an example, and ignoring length works for any examples we’ve
    captured.*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果字符串长度超过字节值的范围怎么办？啊，这是协议分析中的一个挑战。仅仅因为某些东西看起来很简单，并不意味着它实际上就简单。我们将忽略长度等问题，因为这仅作为一个示例，忽略长度对于我们捕获的任何示例都适用。*'
- en: With a function to parse the binary strings, we can now add the `Message` command
    to the dissection tree. The code begins by adding the original data tree and creates
    a new TVB object ➋ that only contains the packet’s data. It then extracts the
    command field as an integer and checks whether it’s our `Message` command ➌. If
    it’s not, we leave the existing data tree, but if the field matches, we proceed
    to parse the two strings and add them to the data subtree ➍. However, instead
    of defining specific fields, we can add text nodes by specifying only the proto
    object rather than a field object. If you now reload this file into Wireshark,
    you should see that the username and message strings are parsed, as shown in [Figure
    5-14](../Text/ch05.xhtml#ch5fig14).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个解析二进制字符串的函数，我们现在可以将`Message`命令添加到解剖树中。代码首先通过添加原始数据树并创建一个新的TVB对象➋，该对象仅包含数据包的内容。接着，它将命令字段提取为整数并检查是否是我们的`Message`命令➌。如果不是，我们保持原有的数据树不变；但如果字段匹配，我们继续解析两个字符串并将它们添加到数据子树中➍。然而，我们并不需要定义特定的字段，只需指定proto对象而不是字段对象，就可以添加文本节点。如果现在将这个文件重新加载到Wireshark中，你应该能看到用户名和消息字符串被正确解析，如[图
    5-14](../Text/ch05.xhtml#ch5fig14)所示。
- en: '![image](../Images/f05-14.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-14.jpg)'
- en: '*Figure 5-14: A parsed `Message` command*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-14：一个解析过的 `Message` 命令*'
- en: Because the parsed data ends up as filterable values, we can select a `Message`
    command by specifying `chat.command == 3` as a display filter, as shown at ➊ in
    [Figure 5-14](../Text/ch05.xhtml#ch5fig14). We can see that the username and message
    strings have been parsed correctly in the tree, as shown at ➋.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解析后的数据最终成为可过滤的值，我们可以通过指定 `chat.command == 3` 作为显示过滤器来选择 `Message` 命令，如[图 5-14](../Text/ch05.xhtml#ch5fig14)中的
    ➊ 所示。我们可以看到，用户名和消息字符串在树形结构中已正确解析，如 ➋ 所示。
- en: That concludes our quick introduction to writing a Lua dissector for Wireshark.
    Obviously, there is still plenty you can do with this script, including adding
    support for more commands, but you have enough for prototyping.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对为 Wireshark 编写 Lua 解码器的简要介绍。显然，你仍然可以对这个脚本做很多事情，包括增加对更多命令的支持，但这些内容已经足够用来进行原型设计。
- en: '**NOTE**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Be sure to visit the Wireshark website for more on how to write parsers, including
    how to implement a TCP stream parser.*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*务必访问 Wireshark 网站，了解如何编写解析器，包括如何实现 TCP 流解析器。*'
- en: '**Using a Proxy to Actively Analyze Traffic**'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用代理主动分析流量**'
- en: Using a tool such as Wireshark to passively capture network traffic for later
    analysis of network protocols has a number of advantages over active capture (as
    discussed in [Chapter 2](../Text/ch02.xhtml#ch02)). Passive capture doesn’t affect
    the network operation of the applications you’re trying to analyze and requires
    no modifications of the applications. On the other hand, passive capture doesn’t
    allow you to interact easily with live traffic, which means you can’t modify traffic
    easily on the fly to see how applications will respond.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如 Wireshark 之类的工具被动地捕获网络流量，以便稍后分析网络协议，相较于主动捕获（如[第 2 章](../Text/ch02.xhtml#ch02)所讨论的），具有许多优势。被动捕获不会影响你想要分析的应用程序的网络操作，也不需要对应用程序进行任何修改。另一方面，被动捕获不允许你轻松地与实时流量进行交互，这意味着你不能轻易地修改流量，来查看应用程序如何响应。
- en: In contrast, active capture allows you to manipulate live traffic but requires
    more setup than passive capture. It may require you to modify applications, or
    at the very least to redirect application traffic through a proxy. Your choice
    of approach will depend on your specific scenario, and you can certainly combine
    passive and active capture.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，主动捕获允许你操作实时流量，但比被动捕获需要更多的设置。它可能需要你修改应用程序，或者至少将应用程序流量通过代理进行重定向。你选择的方式将取决于你的具体场景，当然你也可以结合被动和主动捕获。
- en: In [Chapter 2](../Text/ch02.xhtml#ch02), I included some example scripts to
    demonstrate capturing traffic. You can combine these scripts with the Canape Core
    libraries to generate a number of proxies, which you might want to use instead
    of passive capture.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](../Text/ch02.xhtml#ch02)中，我包含了一些示例脚本，演示了如何捕获流量。你可以将这些脚本与 Canape Core
    库结合使用，以生成多个代理，可能会在某些情况下代替被动捕获。
- en: Now that you have a better understanding of passive capture, I’ll spend the
    rest of this chapter describing techniques for implementing a proxy for the SuperFunkyChat
    protocol and focus on how best to use active network capture.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对被动捕获有了更好的理解，我将在本章剩余部分介绍如何实现 SuperFunkyChat 协议的代理，并重点讲解如何最好地使用主动网络捕获。
- en: '***Setting Up the Proxy***'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置代理***'
- en: To set up the proxy, we’ll begin by modifying one of the capture examples in
    [Chapter 2](../Text/ch02.xhtml#ch02), specifically [Listing 2-4](../Text/ch02.xhtml#ch2list4),
    so we can use it for active network protocol analysis. To simplify the development
    process and configuration of the SuperFunkyChat application, we’ll use a port-forwarding
    proxy rather than something like SOCKS.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置代理，我们将首先修改[第 2 章](../Text/ch02.xhtml#ch02)中的一个捕获示例，特别是[清单 2-4](../Text/ch02.xhtml#ch2list4)，以便可以用于主动网络协议分析。为了简化
    SuperFunkyChat 应用程序的开发过程和配置，我们将使用端口转发代理，而不是像 SOCKS 这样的工具。
- en: Copy [Listing 5-18](../Text/ch05.xhtml#ch5list18) into the file `chapter5_proxy.csx`
    and run it using Canape Core by passing the script’s filename to the *CANAPE.Cli*
    executable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 5-18](../Text/ch05.xhtml#ch5list18)复制到文件 `chapter5_proxy.csx` 中，并通过将脚本的文件名传递给
    *CANAPE.Cli* 可执行文件来使用 Canape Core 运行它。
- en: chapter5
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: chapter5
- en: _proxy.csx
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: _proxy.csx
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 5-18: The active analysis proxy*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-18：主动分析代理*'
- en: At ➊, we tell the proxy to listen locally on port 4444 and make a proxy connection
    to 127.0.0.1 port 12345\. This should be fine for testing the chat application,
    but if you want to reuse the script for another application protocol, you’ll need
    to change the port and IP address as appropriate.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们告诉代理在本地端口4444上监听，并与127.0.0.1端口12345建立代理连接。这对于测试聊天应用程序应该没问题，但如果您想将脚本用于其他应用协议，则需要根据需要更改端口和IP地址。
- en: 'At ➋, we make one of the major changes to the script in [Chapter 2](../Text/ch02.xhtml#ch02):
    we add an event handler that is called whenever a packet needs to be logged, which
    allows us to print the packet as soon it arrives. At ➌, we add some event handlers
    to print when a new connection is created and then closed.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处，我们对[第2章](../Text/ch02.xhtml#ch02)中的脚本进行了一项重大修改：我们添加了一个事件处理程序，当数据包需要记录时会被调用，这使得我们可以在数据包到达时立即打印出来。在➌处，我们添加了一些事件处理程序，用于在新连接建立并关闭时打印信息。
- en: 'Next, we reconfigure the ChatClient application to communicate with local port
    4444 instead of the original port 12345\. In the case of ChatClient, we simply
    add the `--port NUM` parameter to the command line as shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重新配置ChatClient应用程序，使其与本地端口4444通信，而不是原始端口12345。对于ChatClient，我们只需在命令行中添加`--port
    NUM`参数，如下所示：
- en: '[PRE21]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**NOTE**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Changing the destination in real-world applications may not be so simple.
    Review [Chapters 2](../Text/ch02.xhtml#ch02) and [4](../Text/ch04.xhtml#ch04)
    for ideas on how to redirect an arbitrary application into your proxy.*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实际应用中，更改目标可能并不这么简单。请参考[第2章](../Text/ch02.xhtml#ch02)和[第4章](../Text/ch04.xhtml#ch04)，了解如何将任意应用程序重定向到您的代理。*'
- en: The client should successfully connect to the server via the proxy, and the
    proxy’s console should begin displaying packets, as shown in Listing 5-19.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应通过代理成功连接到服务器，并且代理的控制台应开始显示数据包，如清单5-19所示。
- en: '[PRE22]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 5-19: Example output from proxy when a client connects*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-19：客户端连接时代理的示例输出*'
- en: Output indicating that a new proxy connection has been made is shown at ➊. Each
    packet is displayed with a header containing information about its direction (outbound
    or inbound), using the descriptive tags `Out` ➋ and `In` ➍.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，输出显示新代理连接已建立。每个数据包都会显示带有方向信息（出站或入站）的标题，使用描述性标签`Out` ➋和`In` ➍。
- en: 'If your terminal supports 24-bit color, as do most Linux, macOS, and even Windows
    10 terminals, you can enable color support in Canape Core using the `--color`
    parameter when starting a proxy script. The colors assigned to inbound packets
    are similar to those in Wireshark: pink for outbound and blue for inbound. The
    packet display also shows which proxy connection it came from ➌, matching up with
    the output at ➊. Multiple connections could occur at the same time, especially
    if you’re proxying a complex application.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端支持24位颜色（大多数Linux、macOS甚至Windows 10终端都支持），则可以通过在启动代理脚本时使用`--color`参数来启用Canape
    Core中的颜色支持。分配给入站数据包的颜色类似于Wireshark中的颜色：粉色表示出站，蓝色表示入站。数据包显示还会显示它来自哪个代理连接 ➌，这与➊处的输出相匹配。可能会同时发生多个连接，特别是当您代理一个复杂的应用程序时。
- en: 'Each packet is dumped in hex and ASCII format. As with capture in Wireshark,
    the traffic might be split between packets as in ➎. However, unlike with Wireshark,
    when using a proxy, we don’t need to deal with network effects such as retransmitted
    packets or fragmentation: we simply access the raw TCP stream data after the operating
    system has dealt with all the network effects for us.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据包都以十六进制和ASCII格式转储。如同在Wireshark中捕获的情况一样，流量可能会分割成多个数据包，如在➎所示。然而，与Wireshark不同的是，使用代理时，我们不需要处理网络效应，例如重传数据包或分片：我们只需在操作系统为我们处理了所有网络效应之后，直接访问原始TCP流数据。
- en: At ➏, the proxy prints that the connection is closed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在➏处，代理打印出连接已关闭的信息。
- en: '***Protocol Analysis Using a Proxy***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用代理进行协议分析***'
- en: With our proxy set up, we can begin the basic analysis of the protocol. The
    packets shown in [Listing 5-19](../Text/ch05.xhtml#ch5list19) are simply the raw
    data, but we should ideally write code to parse the traffic as we did with the
    Python script we wrote for Wireshark. To that end, we’ll write a `Data Parser`
    class containing functions to read and write data to and from the network. Copy
    [Listing 5-20](../Text/ch05.xhtml#ch5list20) into a new file in the same directory
    as you copied *chapter5_proxy.csx* in Listing 5-18 and call it *parser.csx*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好代理后，我们可以开始对协议进行基本分析。显示在[列表 5-19](../Text/ch05.xhtml#ch5list19)中的数据包只是原始数据，但我们理应编写代码来解析这些流量，正如我们为
    Wireshark 编写的 Python 脚本一样。为此，我们将编写一个`数据解析器`类，包含用于读取和写入网络数据的函数。将[列表 5-20](../Text/ch05.xhtml#ch5list20)中的代码复制到与您在列表
    5-18 中复制的*chapter5_proxy.csx*文件相同的目录中新文件，并命名为*parser.csx*。
- en: parser.csx
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: parser.csx
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 5-20: A basic parser code for proxy*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-20：代理的基本解析器代码*'
- en: 'The negotiation method ➊ is called before any other communication takes place
    and is passed to two C# stream objects: one connected to the Chat Server and the
    other to the Chat Client. We can use this negotiation method to handle the magic
    value the protocol uses, but we could also use it for more complex tasks, such
    as enabling encryption if the protocol supports it.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 协商方法 ➊ 在任何其他通信发生之前被调用，并传递给两个C#流对象：一个连接到聊天服务器，另一个连接到聊天客户端。我们可以使用此协商方法来处理协议使用的魔法值，但我们也可以将其用于更复杂的任务，例如启用加密（如果协议支持的话）。
- en: The first task for the negotiation method is to read the magic value from the
    client and pass it to the server. To simply read and write the 4-byte magic value,
    we first wrap the streams in `DataReader` and `DataWriter` classes ➋. We then
    read the magic value from the client, print it to the console, and write it to
    the server ➌.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 协商方法的第一个任务是从客户端读取魔法值并将其传递给服务器。为了简单地读取和写入4字节的魔法值，我们首先将流包装在`DataReader`和`DataWriter`类中
    ➋。然后，我们从客户端读取魔法值，将其打印到控制台，并将其写入服务器 ➌。
- en: Add the line `#load "parser.csx"` to the very top of *chapter5_proxy.csx*. Now
    when the main *chapter5_proxy.csx* script is parsed, the *parser.csx* file is
    automatically included and parsed with the main script. Using this loading feature
    allows you to write each component of your parser in a separate file to make the
    task of writing a complex proxy manageable. Then add the line `template.AddLayer<Parser>();`
    just after `template.Port = 12345;` to add the parsing layer to every new connection.
    This addition will instantiate a new instance of the `Parser` class in [Listing
    5-20](../Text/ch05.xhtml#ch5list20) with every connection so you can store any
    state you need as members of the class. If you start the proxy script and connect
    a client through the proxy, only important protocol data is logged; you’ll no
    longer see the magic value (other than in the console output).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在*chapter5_proxy.csx*的最顶部添加行`#load "parser.csx"`。现在，当解析主*chapter5_proxy.csx*脚本时，*parser.csx*文件将与主脚本一起自动加载和解析。使用此加载功能，您可以将解析器的每个组件写入单独的文件，从而使编写复杂代理的任务变得可管理。然后，在`template.Port
    = 12345;`后面添加行`template.AddLayer<Parser>();`，以将解析层添加到每个新连接中。此添加将在每个连接时实例化[列表 5-20](../Text/ch05.xhtml#ch5list20)中`Parser`类的新实例，因此您可以将任何需要的状态作为类的成员进行存储。如果您启动代理脚本并通过代理连接客户端，只有重要的协议数据会被记录；您将不再看到魔法值（除了控制台输出中）。
- en: '***Adding Basic Protocol Parsing***'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加基础协议解析***'
- en: Now we’ll reframe the network protocol to ensure that each packet contains only
    the data for a single packet. We’ll do this by adding functions to read the length
    and checksum fields from the network and leave only the data. At the same time,
    we’ll rewrite the length and checksum when sending the data to the original recipient
    to keep the connection open.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重新构建网络协议，以确保每个数据包只包含一个单独数据包的数据。我们将通过添加函数来读取网络中的长度和校验和字段，并只保留数据。同时，我们将在将数据发送到原始接收方时重写长度和校验和，以保持连接打开状态。
- en: By implementing this basic parsing and proxying of a client connection, all
    nonessential information, such as lengths and checksums, should be removed from
    the data. As an added bonus, if you modify data inside the proxy, the sent packet
    will have the correct checksum and length to match your modifications. Add [Listing
    5-21](../Text/ch05.xhtml#ch5list21) to the `Parser` class to implement these changes
    and restart the proxy.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现基本的解析和代理客户端连接，所有非必要的信息，如长度和校验和，应该从数据中移除。额外的好处是，如果你在代理内部修改数据，发送的包将具有正确的校验和和长度，以匹配你的修改。将[Listing
    5-21](../Text/ch05.xhtml#ch5list21)添加到`Parser`类中以实现这些更改，并重启代理。
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 5-21: Parser code for SuperFunkyChat protocol*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-21：SuperFunkyChat协议的解析器代码*'
- en: Although the code is a bit verbose (blame C# for that), it should be fairly
    simple to understand. At ➊, we implement the checksum calculator. We could check
    packets we read to verify their checksums, but we’ll only use this calculator
    to recalculate the checksum when sending the packet onward.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码有些冗长（这可以怪C#语言），但应该相当容易理解。在➊处，我们实现了校验和计算器。我们可以检查我们读取的包以验证其校验和，但我们只会使用这个计算器在发送包时重新计算校验和。
- en: The `ReadData()` function at ➋ reads a packet from the network connection. It
    first reads a big endian 32-bit integer, which is the length, then the 32-bit
    checksum, and finally the data as bytes before calling a function to convert that
    byte array to a `DataFrame`. (A `DataFrame` is an object to contain network packets;
    you can convert a byte array or a string to a frame depending on what you need.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ➋处的`ReadData()`函数从网络连接中读取一个数据包。它首先读取一个大端32位整数，表示长度，然后是32位的校验和，最后是数据的字节，之后调用一个函数将字节数组转换为`DataFrame`。（`DataFrame`是一个包含网络包的对象，您可以根据需要将字节数组或字符串转换为数据帧。）
- en: The `WriteData()` function at ➌ does the reverse of `ReadData()`. It uses the
    `ToArray()` method on the incoming `DataFrame` to convert the packet to bytes
    for writing. Once we have the byte array, we can recalculate the checksum and
    the length, and then write it all back to the `DataWriter` class. At ➍, we implement
    the various functions to read and write data from the inbound and outbound streams.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ➌处的`WriteData()`函数执行`ReadData()`的反操作。它使用`ToArray()`方法将传入的`DataFrame`转换为字节，以便写入。一旦我们得到字节数组，我们可以重新计算校验和和长度，然后将其写回`DataWriter`类。在➍处，我们实现了从入站和出站流中读取和写入数据的各种函数。
- en: Put together all the different scripts for network proxy and parsing and start
    a client connection through the proxy, and all nonessential information, such
    as lengths and checksums, should be removed from the data. As an added bonus,
    if you modify data inside the proxy, the sent packet will have the correct checksum
    and length to match your modifications.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有用于网络代理和解析的脚本整合起来，并通过代理启动客户端连接，所有非必要的信息，如长度和校验和，应该从数据中移除。额外的好处是，如果你在代理内部修改数据，发送的包将具有正确的校验和和长度，以匹配你的修改。
- en: '***Changing Protocol Behavior***'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***改变协议行为***'
- en: Protocols often include a number of optional components, such as encryption
    or compression. Unfortunately, it’s not easy to determine how that encryption
    or compression is implemented without doing a lot of reverse engineering. For
    basic analysis, it would be nice to be able to simply remove the component. Also,
    if the encryption or compression is optional, the protocol will almost certainly
    indicate support for it while negotiating the initial connection. So, if we can
    modify the traffic, we might be able to change that support setting and disable
    that additional feature. Although this is a trivial example, it demonstrates the
    power of using a proxy instead of passive analysis with a tool like Wireshark.
    We can modify the connection to make analysis easier.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 协议通常包括多个可选组件，如加密或压缩。不幸的是，要确定加密或压缩的实现方式，通常需要进行大量的逆向工程。对于基础分析来说，最好能够简单地移除这些组件。此外，如果加密或压缩是可选的，协议几乎肯定会在初始连接协商时指示支持这些功能。所以，如果我们能够修改流量，可能可以更改该支持设置，并禁用这个附加功能。虽然这是一个微不足道的例子，但它展示了使用代理而不是像Wireshark这样的被动分析工具的威力。我们可以修改连接，使得分析变得更加容易。
- en: For example, consider the chat application. One of its optional features is
    XOR encryption (although see [Chapter 7](../Text/ch07.xhtml#ch07) on why it’s
    not really encryption). To enable this feature, you would pass the `--xor` parameter
    to the client. [Listing 5-22](../Text/ch05.xhtml#ch5list22) compares the first
    couple of packets for the connection without the XOR parameter and then with the
    XOR parameter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑聊天应用程序。它的一个可选功能是 XOR 加密（尽管请参阅[第 7 章](../Text/ch07.xhtml#ch07)了解它为何实际上并非加密）。要启用此功能，您需要将`--xor`参数传递给客户端。[清单
    5-22](../Text/ch05.xhtml#ch5list22)比较了在连接时不带 XOR 参数和带 XOR 参数时的前两个数据包。
- en: '[PRE25]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 5-22: Example packets with and without XOR encryption enabled*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-22：启用和禁用 XOR 加密的示例数据包*'
- en: I’ve highlighted in bold two differences in [Listing 5-22](../Text/ch05.xhtml#ch5list22).
    Let’s draw some conclusions from this example. In the outbound packet (which is
    command 0 based on the first byte), the final byte is a 1 when XOR is enabled
    but 0x00 when it’s not enabled. My guess would be that this flag indicates that
    the client supports XOR encryption. For inbound traffic, the final byte of the
    first packet (command 1 in this case) is 0xE7 when XOR is enabled and 0x00 when
    it’s not. My guess would be that this is a key for the XOR encryption.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经用粗体标出了[清单 5-22](../Text/ch05.xhtml#ch5list22)中的两个差异。让我们从这个例子中得出一些结论。在出站数据包（即基于第一个字节的命令
    0）中，当启用 XOR 时，最后一个字节是 1，而当未启用时则为 0x00。我猜测这个标志表示客户端是否支持 XOR 加密。对于入站流量，第一个数据包（在这种情况下为命令
    1）的最后一个字节在启用 XOR 时为 0xE7，在未启用时为 0x00。我猜测这是 XOR 加密的密钥。
- en: In fact, if you look at the client console when you’re enabling XOR encryption,
    you’ll see the line `ReKeying connection to key 0xE7`, which indicates it is indeed
    the key. Although the negotiation is valid traffic, if you now try to send a message
    with the client through the proxy, the connection will no longer work and may
    even be disconnected. The connection stops working because the proxy will try
    to parse fields, such as the length of the packet, from the connection but will
    get invalid values. For example, when reading a length, such as 0x10, the proxy
    will instead read 0x10 XOR 0xE7, which is 0xF7\. Because there are no 0xF7 bytes
    on the network connection, it will hang. The short explanation is that to continue
    the analysis in this situation, we need to do something about the XOR.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果您在启用 XOR 加密时查看客户端控制台，您会看到一行`ReKeying connection to key 0xE7`，这表明确实是密钥。尽管协商是有效的流量，但如果您现在尝试通过代理发送客户端消息，连接将不再工作，甚至可能会断开连接。连接停止工作是因为代理将尝试从连接中解析诸如数据包长度之类的字段，但将获得无效值。例如，在读取长度为
    0x10 的数据时，代理实际上会读取 0x10 XOR 0xE7，即 0xF7。因为网络连接中没有 0xF7 字节，所以会挂起。简而言之，在这种情况下继续分析，我们需要对
    XOR 做些处理。
- en: While implementing the code to de-XOR the traffic when we read it and re-XOR
    it again when we write it wouldn’t be especially difficult, it might not be so
    simple to do if this feature were implemented to support some proprietary compression
    scheme. Therefore, we’ll simply disable XOR encryption in our proxy irrespective
    of the client’s setting. To do so, we read the first packet in the connection
    and ensure that the final byte is set to 0\. When we forward that packet onward,
    the server will not enable XOR and will return the value of 0 as the key. Because
    0 is a NO-OP in XOR encryption (as in A XOR 0 = A), this technique will effectively
    disable the XOR.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在读取流量时实现去 XOR 化代码，并在写入时重新 XOR 化代码，这并不是特别困难，但如果此功能用于支持某些专有的压缩方案，实现起来可能就不那么简单了。因此，我们将简单地在代理中禁用
    XOR 加密，而不管客户端的设置如何。为此，我们读取连接中的第一个数据包，并确保最后一个字节设置为 0。当我们将该数据包转发时，服务器将不启用 XOR 并将返回
    0 作为密钥的值。因为在 XOR 加密中，0 是一个 NO-OP（即 A XOR 0 = A），这种技术将有效地禁用 XOR。
- en: Change the `ReadOutbound()` method in the parser to the code in Listing 5-23
    to disable the XOR encryption.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 修改解析器中的`ReadOutbound()`方法为清单 5-23 中的代码以禁用 XOR 加密。
- en: '[PRE26]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 5-23: Disable XOR encryption*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-23：禁用 XOR 加密*'
- en: If you now create a connection through the proxy, you’ll find that regardless
    of whether the XOR setting is enabled or not, the client will not be able to enable
    XOR.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在通过代理创建连接，您会发现无论 XOR 设置是否启用，客户端都无法启用 XOR。
- en: '**Final Words**'
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最后的话**'
- en: In this chapter, you learned how to perform basic protocol analysis on an unknown
    protocol using passive and active capture techniques. We started by doing basic
    protocol analysis using Wireshark to capture example traffic. Then, through manual
    inspection and a simple Python script, we were able to understand some parts of
    an example chat protocol.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用被动和主动捕获技术对未知协议进行基本的协议分析。我们首先通过Wireshark捕获示例流量来进行基本的协议分析。然后，通过手动检查和一个简单的Python脚本，我们能够理解一些示例聊天协议的部分内容。
- en: We discovered in the initial analysis that we were able to implement a basic
    Lua dissector for Wireshark to extract protocol information and display it directly
    in the Wireshark GUI. Using Lua is ideal for prototyping protocol analysis tools
    in Wireshark.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初的分析中，我们发现能够实现一个基本的Lua解码器用于Wireshark，以提取协议信息并直接在Wireshark图形界面中显示。使用Lua是Wireshark中原型化协议分析工具的理想选择。
- en: Finally, we implemented a man-in-the-middle proxy to analyze the protocol. Proxying
    the traffic allows demonstration of a few new analysis techniques, such as modifying
    protocol traffic to disable protocol features (such as encryption) that might
    hinder the analysis of the protocol using purely passive techniques.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了一个中间人代理来分析该协议。代理流量使得我们能够展示一些新的分析技巧，例如修改协议流量以禁用可能会妨碍使用纯粹被动技术分析协议的协议功能（如加密）。
- en: The technique you choose will depend on many factors, such as the difficulty
    of capturing the network traffic and the complexity of the protocol. You’ll want
    to apply the most appropriate combination of techniques to fully analyze an unknown
    protocol.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的技术将取决于许多因素，例如捕获网络流量的难度和协议的复杂性。你需要应用最合适的技术组合，来全面分析一个未知协议。
