- en: '## **2'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **2'
- en: BINARY IN ACTION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制的实际应用**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In the previous chapter we defined a computer as an electronic device that can
    be programmed to carry out a set of logical instructions. We then learned at a
    high level how everything in a computer, from the data it uses to the instructions
    it carries out, is stored in binary, 0s and 1s. In this chapter, I shed some light
    on how exactly 0s and 1s can be used to represent nearly any kind of data. We
    also cover how binary lends itself to logical operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将计算机定义为一种可以编程执行一系列逻辑指令的电子设备。随后，我们以高层次了解了计算机中所有内容，从它使用的数据到它执行的指令，都是以二进制形式存储的，即0和1。在本章中，我将进一步阐明0和1是如何被用来表示几乎任何类型的数据。我们还将讨论二进制如何适用于逻辑操作。
- en: '**Representing Data Digitally**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数字化数据表示**'
- en: 'So far, we’ve focused on storing numbers in binary. More specifically, we covered
    how to store the positive integers, sometimes called whole numbers, and zero.
    However, computers store all data as bits: negative numbers, fractional numbers,
    text, colors, images, audio, and video, to name a few. Let’s consider how various
    types of data might be represented using binary.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们关注的是如何在二进制中存储数字。更具体地说，我们讨论了如何存储正整数（有时称为整数）和零。然而，计算机将所有数据都存储为比特：负数、分数、文本、颜色、图像、音频和视频，等等。让我们来考虑一下如何使用二进制表示各种类型的数据。
- en: '***Digital Text***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字文本***'
- en: Let’s begin with text as our first example of how bits, 0s and 1s, can represent
    something other than a number. In the context of computing, *text* means a collection
    of alphanumeric and related symbols, also called *characters*. Text is usually
    used to represent words, sentences, paragraphs, and so forth. Text does not include
    formatting (bold, italics). For the purposes of this discussion, let’s limit our
    character set to the English alphabet and related characters. In computer programming,
    the term *string* is also commonly used to refer to a sequence of text characters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以文本为例，看看比特、0和1如何表示数字以外的其他东西。在计算机的语境中，*文本*指的是一组字母数字和相关符号，也称为*字符*。文本通常用来表示单词、句子、段落等等。文本不包括格式（粗体、斜体）。为了便于讨论，我们将字符集限定为英语字母和相关字符。在计算机编程中，术语*字符串*通常用来指代一串文本字符。
- en: Keeping that definition of text in mind, what exactly do we need to represent?
    We need A through Z, uppercase and lowercase, meaning A is a different symbol
    than a. We also want punctuation marks like commas and periods. We need a way
    to represent spaces. We also need digits 0 through 9\. The digit requirement can
    be confusing; here I’m talking about including the *symbols* or *characters* that
    are used to represent the numbers 0 through 9, which is a different thing than
    storing the *numbers* 0 through 9.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 保持对文本的这个定义，我们究竟需要表示什么呢？我们需要大写和小写的A到Z，即A和a是不同的符号。我们还需要标点符号，如逗号和句号。我们需要表示空格的方式。我们还需要数字0到9。数字的需求可能会让人困惑；这里我所指的是包括表示数字0到9的*符号*或*字符*，这与存储数字0到9是不同的概念。
- en: If we add up all the unique symbols we need to represent, just described, we
    have around 100 characters. So, if we need to have a unique combination of bits
    to represent each character, how many bits do we need per character? A 6-bit number
    gives us 64 unique combinations, which isn’t quite enough. But a 7-bit number
    gives us 128 combinations, enough to represent the 100 or so characters we need.
    However, since computers usually work in bytes, it makes sense to just round up
    and use a full 8 bits, one byte, to represent each character. With a byte we can
    represent 256 unique characters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有需要表示的独特符号加起来，刚才提到的，差不多有100个字符。那么，如果我们需要为每个字符拥有一个独特的比特组合，我们每个字符需要多少比特呢？一个6位数给我们64种独特的组合，这还不够。但一个7位数给我们128种组合，足以表示我们需要的100个左右的字符。然而，由于计算机通常以字节为单位工作，因此直接向上取整，使用一个完整的8位字节来表示每个字符是有意义的。使用字节，我们可以表示256个独特字符。
- en: So how might we go about using 8 bits to represent each character? As you may
    expect, there’s already a standard way of representing text in binary, and we’ll
    get to that in a minute. But before we do that, it’s important to understand that
    we can make up any scheme we want to represent each character, as long as the
    software running on a computer knows about our scheme. That said, some schemes
    are better than others for representing certain types of data. Software designers
    prefer schemes that make common operations easy to perform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们该如何用8个比特来表示每个字符呢？正如你可能预料到的那样，已经有一种标准的方法可以用二进制表示文本，我们很快就会讲到。但在此之前，重要的是要理解，我们可以制定任何方案来表示每个字符，只要计算机上运行的软件知道我们的方案。话虽如此，一些方案比其他方案更适合表示某些类型的数据。软件设计师更喜欢那些使常见操作易于执行的方案。
- en: Imagine that you are responsible for creating your own system that represents
    each character as a set of bits. You might decide to assign 0b00000000 to represent
    character A, and 0b00000001 to represent character B, and so on. This process
    of translating data into a digital format is known as *encoding*; when you interpret
    that digital data, it’s known as *decoding*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你负责创建自己的系统，将每个字符表示为一组比特。你可能决定将0b00000000表示字符A，0b00000001表示字符B，依此类推。将数据转换为数字格式的过程称为*编码*；当你解释这些数字数据时，它被称为*解码*。
- en: '**EXERCISE 2-1: CREATE YOUR OWN SYSTEM FOR REPRESENTING TEXT**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2-1：创建你自己的文本表示系统**'
- en: 'Define a way to represent the uppercase letters A through D as 8-bit numbers,
    and then encode the word *DAD* into 24 bits using your system. There’s no single
    right answer to this; see [Appendix A](appa.xhtml) for an example answer. Bonus:
    show your encoded 24-bit number in hexadecimal too.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一种方法，将大写字母A到D表示为8位数字，然后使用你的系统将单词*DAD*编码为24位。这个问题没有唯一的正确答案；请参见[附录A](appa.xhtml)获取示例答案。额外任务：同时展示你的24位编码数字的十六进制表示。
- en: '#### ***ASCII***'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***ASCII***'
- en: Fortunately, we already have several standard ways to represent text digitally,
    so we don’t have to invent our own! *American Standard Code for Information Interchange
    (ASCII)* is a format that represents 128 characters using 7 bits per character,
    although each character is commonly stored using a full byte, 8 bits. Using 8
    bits instead of 7 just means we have an extra leading bit, left as 0\. ASCII handles
    the characters needed for English, and another standard, called *Unicode*, handles
    characters used in nearly all languages, English included. For now, let’s focus
    on ASCII to keep things simple. [Table 2-1](ch02.xhtml#ch2tab1) shows the binary
    and hexadecimal values for a subset of ASCII characters. The first 32 characters
    aren’t shown; they are control codes such as carriage return and form feed, originally
    intended for controlling devices rather than storing text.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经有几种标准的数字文本表示方法，因此我们不必自己发明！*美国信息交换标准代码（ASCII）*是一种格式，它使用每个字符7个比特表示128个字符，尽管每个字符通常使用完整的字节（8个比特）存储。使用8个比特而不是7个比特，意味着我们多了一个前导比特，值为0。ASCII处理英语所需的字符，另一个标准叫做*Unicode*，它处理几乎所有语言（包括英语）中使用的字符。现在，我们先集中在ASCII上，以保持简单。[表2-1](ch02.xhtml#ch2tab1)显示了部分ASCII字符的二进制和十六进制值。前32个字符未显示，它们是控制码，如回车和换页，最初用于控制设备，而不是存储文本。
- en: '**EXERCISE 2-2: ENCODE AND DECODE ASCII**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2-2：编码与解码ASCII**'
- en: Using [Table 2-1](ch02.xhtml#ch2tab1), encode the following words to ASCII binary
    and hexadecimal, using a byte for each character. Remember that there are different
    values for uppercase and lowercase letters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[表2-1](ch02.xhtml#ch2tab1)，将以下单词编码为ASCII二进制和十六进制，每个字符使用一个字节。记住，大写字母和小写字母的值不同。
- en: Hello
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你好
- en: 5 cats
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5只猫
- en: Using [Table 2-1](ch02.xhtml#ch2tab1), decode the following words. Each character
    is represented as an 8-bit ASCII value with spaces added for clarity.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[表2-1](ch02.xhtml#ch2tab1)，解码以下单词。每个字符由一个8位的ASCII值表示，空格用于增加清晰度。
- en: 01000011 01101111 01100110 01100110 01100101 01100101
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 01000011 01101111 01100110 01100110 01100101 01100101
- en: 01010011 01101000 01101111 01110000
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 01010011 01101000 01101111 01110000
- en: Using [Table 2-1](ch02.xhtml#ch2tab1), decode the following word. Each character
    is represented as an 8-bit hexadecimal value with spaces added for clarity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[表2-1](ch02.xhtml#ch2tab1)，解码以下单词。每个字符由一个8位的十六进制值表示，空格用于增加清晰度。
- en: 43 6C 61 72 69 6E 65 74
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 43 6C 61 72 69 6E 65 74
- en: Answers are in [Appendix A](appa.xhtml).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 答案见[附录A](appa.xhtml)。
- en: '**Table 2-1:** ASCII Characters 0x20 Through 0x7F'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** ASCII字符 0x20至0x7F'
- en: '| **Binary** | **Hex** | **Char** | **Binary** | **Hex** | **Char** | **Binary**
    | **Hex** | **Char** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **十六进制** | **字符** | **二进制** | **十六进制** | **字符** | **二进制** | **十六进制**
    | **字符** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| `00100000` | `20` | `[Space]` | `01000000` | `40` | `@` | `01100000` | `60`
    | `` ` `` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `00100000` | `20` | `[空格]` | `01000000` | `40` | `@` | `01100000` | `60`
    | `` ` `` |'
- en: '| `00100001` | `21` | `!` | `01000001` | `41` | `A` | `01100001` | `61` | `a`
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `00100001` | `21` | `!` | `01000001` | `41` | `A` | `01100001` | `61` | `a`
    |'
- en: '| `00100010` | `22` | `"` | `01000010` | `42` | `B` | `01100010` | `62` | `b`
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `00100010` | `22` | `"` | `01000010` | `42` | `B` | `01100010` | `62` | `b`
    |'
- en: '| `00100011` | `23` | `#` | `01000011` | `43` | `C` | `01100011` | `63` | `c`
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `00100011` | `23` | `#` | `01000011` | `43` | `C` | `01100011` | `63` | `c`
    |'
- en: '| `00100100` | `24` | `$` | `01000100` | `44` | `D` | `01100100` | `64` | `d`
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `00100100` | `24` | `$` | `01000100` | `44` | `D` | `01100100` | `64` | `d`
    |'
- en: '| `00100101` | `25` | `%` | `01000101` | `45` | `E` | `01100101` | `65` | `e`
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `00100101` | `25` | `%` | `01000101` | `45` | `E` | `01100101` | `65` | `e`
    |'
- en: '| `00100110` | `26` | `&` | `01000110` | `46` | `F` | `01100110` | `66` | `f`
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `00100110` | `26` | `&` | `01000110` | `46` | `F` | `01100110` | `66` | `f`
    |'
- en: '| `00100111` | `27` | `''` | `01000111` | `47` | `G` | `01100111` | `67` |
    `g` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `00100111` | `27` | `''` | `01000111` | `47` | `G` | `01100111` | `67` |
    `g` |'
- en: '| `00101000` | `28` | `(` | `01001000` | `48` | `H` | `01101000` | `68` | `h`
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `00101000` | `28` | `(` | `01001000` | `48` | `H` | `01101000` | `68` | `h`
    |'
- en: '| `00101001` | `29` | `)` | `01001001` | `49` | `I` | `01101001` | `69` | `i`
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `00101001` | `29` | `)` | `01001001` | `49` | `I` | `01101001` | `69` | `i`
    |'
- en: '| `00101010` | `2A` | `*` | `01001010` | `4A` | `J` | `01101010` | `6A` | `j`
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `00101010` | `2A` | `*` | `01001010` | `4A` | `J` | `01101010` | `6A` | `j`
    |'
- en: '| `00101011` | `2B` | `+` | `01001011` | `4B` | `K` | `01101011` | `6B` | `k`
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `00101011` | `2B` | `+` | `01001011` | `4B` | `K` | `01101011` | `6B` | `k`
    |'
- en: '| `00101100` | `2C` | `,` | `01001100` | `4C` | `L` | `01101100` | `6C` | `l`
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `00101100` | `2C` | `,` | `01001100` | `4C` | `L` | `01101100` | `6C` | `l`
    |'
- en: '| `00101101` | `2D` | `-` | `01001101` | `4D` | `M` | `01101101` | `6D` | `m`
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `00101101` | `2D` | `-` | `01001101` | `4D` | `M` | `01101101` | `6D` | `m`
    |'
- en: '| `00101110` | `2E` | `.` | `01001110` | `4E` | `N` | `01101110` | `6E` | `n`
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `00101110` | `2E` | `.` | `01001110` | `4E` | `N` | `01101110` | `6E` | `n`
    |'
- en: '| `00101111` | `2F` | `/` | `01001111` | `4F` | `O` | `01101111` | `6F` | `o`
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `00101111` | `2F` | `/` | `01001111` | `4F` | `O` | `01101111` | `6F` | `o`
    |'
- en: '| `00110000` | `30` | `0` | `01010000` | `50` | `P` | `01110000` | `70` | `p`
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `00110000` | `30` | `0` | `01010000` | `50` | `P` | `01110000` | `70` | `p`
    |'
- en: '| `00110001` | `31` | `1` | `01010001` | `51` | `Q` | `01110001` | `71` | `q`
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `00110001` | `31` | `1` | `01010001` | `51` | `Q` | `01110001` | `71` | `q`
    |'
- en: '| `00110010` | `32` | `2` | `01010010` | `52` | `R` | `01110010` | `72` | `r`
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `00110010` | `32` | `2` | `01010010` | `52` | `R` | `01110010` | `72` | `r`
    |'
- en: '| `00110011` | `33` | `3` | `01010011` | `53` | `S` | `01110011` | `73` | `s`
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `00110011` | `33` | `3` | `01010011` | `53` | `S` | `01110011` | `73` | `s`
    |'
- en: '| `00110100` | `34` | `4` | `01010100` | `54` | `T` | `01110100` | `74` | `t`
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `00110100` | `34` | `4` | `01010100` | `54` | `T` | `01110100` | `74` | `t`
    |'
- en: '| `00110101` | `35` | `5` | `01010101` | `55` | `U` | `01110101` | `75` | `u`
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `00110101` | `35` | `5` | `01010101` | `55` | `U` | `01110101` | `75` | `u`
    |'
- en: '| `00110110` | `36` | `6` | `01010110` | `56` | `V` | `01110110` | `76` | `v`
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `00110110` | `36` | `6` | `01010110` | `56` | `V` | `01110110` | `76` | `v`
    |'
- en: '| `00110111` | `37` | `7` | `01010111` | `57` | `W` | `01110111` | `77` | `w`
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `00110111` | `37` | `7` | `01010111` | `57` | `W` | `01110111` | `77` | `w`
    |'
- en: '| `00111000` | `38` | `8` | `01011000` | `58` | `X` | `01111000` | `78` | `x`
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `00111000` | `38` | `8` | `01011000` | `58` | `X` | `01111000` | `78` | `x`
    |'
- en: '| `00111001` | `39` | `9` | `01011001` | `59` | `Y` | `01111001` | `79` | `y`
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `00111001` | `39` | `9` | `01011001` | `59` | `Y` | `01111001` | `79` | `y`
    |'
- en: '| `00111010` | `3A` | `:` | `01011010` | `5A` | `Z` | `01111010` | `7A` | `z`
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `00111010` | `3A` | `:` | `01011010` | `5A` | `Z` | `01111010` | `7A` | `z`
    |'
- en: '| `00111011` | `3B` | `;` | `01011011` | `5B` | `[` | `01111011` | `7B` | `{`
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `00111011` | `3B` | `;` | `01011011` | `5B` | `[` | `01111011` | `7B` | `{`
    |'
- en: '| `00111100` | `3C` | `<` | `01011100` | `5C` | `\` | `01111100` | `7C` | `&#124;`
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `00111100` | `3C` | `<` | `01011100` | `5C` | `\` | `01111100` | `7C` | `&#124;`
    |'
- en: '| `00111101` | `3D` | `=` | `01011101` | `5D` | `]` | `01111101` | `7D` | `}`
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `00111101` | `3D` | `=` | `01011101` | `5D` | `]` | `01111101` | `7D` | `}`
    |'
- en: '| `00111110` | `3E` | `>` | `01011110` | `5E` | `^` | `01111110` | `7E` | `~`
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `00111110` | `3E` | `>` | `01011110` | `5E` | `^` | `01111110` | `7E` | `~`
    |'
- en: '| `00111111` | `3F` | `?` | `01011111` | `5F` | `_` | `01111111` | `7F` | `[Delete]`
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `00111111` | `3F` | `?` | `01011111` | `5F` | `_` | `01111111` | `7F` | `[删除]`
    |'
- en: It’s fairly straightforward to represent text in a digital format. A system
    like ASCII maps each character, or symbol, to a unique sequence of bits. A computing
    device then interprets that sequence of bits and displays the appropriate symbol
    to the user.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以数字格式表示文本相当简单。像ASCII这样的系统将每个字符或符号映射到一个独特的位序列。然后，计算设备解释这些位序列并显示相应的符号给用户。
- en: '***Digital Colors and Images***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字颜色与图像***'
- en: 'Now that we’ve seen how to represent numbers and text in binary, let’s explore
    another type of data: color. Any computing device that has a color graphics display
    needs to have some system for describing colors. As you might expect, as with
    text, we already have standard ways of storing color data. We’ll get to them,
    but first let’s design our own system for digitally describing colors.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何以二进制表示数字和文本，让我们探索另一种数据类型：颜色。任何具有彩色图形显示的计算设备都需要有一种描述颜色的系统。如你所料，就像文本一样，我们已经有了标准的颜色数据存储方式。我们会介绍这些方法，但首先让我们设计自己的数字颜色描述系统。
- en: Let’s limit our range of colors to black, white, and shades of gray. This limited
    set of colors is known as *grayscale*. Just like we did with text, let’s begin
    by deciding how many unique shades of gray we want to represent. Let’s keep it
    simple and go with black, white, dark gray, and light gray. That’s four total
    grayscale colors, so how many bits do we need to represent four colors? Only 2
    bits are needed. A 2-bit number can represent four unique values, since 2 raised
    to the power of 2 is 4.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将颜色范围限制为黑色、白色和不同深浅的灰色。这种有限的颜色集合称为 *灰度*。就像我们处理文本一样，首先决定我们要表示多少种不同的灰度。我们保持简单，使用黑色、白色、深灰色和浅灰色。这总共是四种灰度颜色，那么我们需要多少位来表示这四种颜色呢？只需要
    2 位。因为 2 的 2 次方等于 4，所以 2 位数字可以表示四个唯一的值。
- en: '**EXERCISE 2-3: CREATE YOUR OWN SYSTEM FOR REPRESENTING GRAYSCALE**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2-3：创建你自己的灰度表示系统**'
- en: Define a way to digitally represent black, white, dark gray, and light gray.
    There’s no single right answer to this; see [Appendix A](appa.xhtml) for an example
    answer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一种数字方式来表示黑色、白色、深灰色和浅灰色。没有单一的正确答案；请参见 [附录 A](appa.xhtml) 获取示例答案。
- en: Once you’ve designed a system for representing shades of gray in binary, you
    can build on that approach and create your own system for describing a simple
    grayscale image. An image is essentially an arrangement of colors on a two-dimensional
    plane. Those colors are typically arranged in a grid composed of single-color
    squares called *pixels*. Here’s a simple example in [Figure 2-1](ch02.xhtml#ch2fig1).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设计了表示灰度的二进制系统，你可以在此基础上构建自己的系统来描述一个简单的灰度图像。图像本质上是颜色在二维平面上的排列。这些颜色通常以一个由单色方块组成的网格排列，这些方块称为
    *像素*。这里是 [图 2-1](ch02.xhtml#ch2fig1) 中的一个简单例子。
- en: '![image](../images/fig2-1.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig2-1.jpg)'
- en: '*Figure 2-1: A simple image*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：一个简单的图像*'
- en: 'The image in [Figure 2-1](ch02.xhtml#ch2fig1) has a width of 4 pixels and a
    height of 4 pixels, giving it a total of 16 pixels. If you squint and use your
    imagination, you may see a white flower and a dark sky beyond. The image consists
    of only three colors: white, light gray, and dark gray.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.xhtml#ch2fig1) 中的图像宽度为 4 像素，高度为 4 像素，总共有 16 个像素。如果你眯起眼睛并发挥想象力，你可能会看到一个白色的花朵和背后的暗天空。该图像由三种颜色组成：白色、浅灰色和深灰色。'
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Figure 2-1](ch02.xhtml#ch2fig1) is composed of some really large pixels to
    illustrate a point. Modern televisions, computer monitors, and smartphone screens
    can also be thought of as a grid of pixels, but each pixel is very small. For
    example, a high definition display is typically 1920 pixels (width) by 1080 pixels
    (height), for a total of about 2 million pixels! As another example, digital photographs
    often contain more than 10 million pixels in a single image*.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图 2-1](ch02.xhtml#ch2fig1)由一些非常大的像素组成，用来说明一个观点。现代电视、计算机显示器和智能手机屏幕也可以看作是像素网格，但每个像素非常小。例如，高清显示屏通常为
    1920 像素（宽度）乘 1080 像素（高度），总共有大约 200 万个像素！再举一个例子，数字照片通常包含超过 1000 万个像素*。'
- en: '**EXERCISE 2-4: CREATE YOUR OWN APPROACH FOR REPRESENTING SIMPLE IMAGES**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2-4：创建你自己的简单图像表示方法**'
- en: '**Part 1**   Building upon your previous system for representing grayscale
    colors, design an approach for representing an image composed of those colors.
    If you want to simplify things, you can assume that the image will always be 4
    pixels by 4 pixels, like the one in [Figure 2-1](ch02.xhtml#ch2fig1).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一部分** 基于你之前表示灰度颜色的系统，设计一个表示由这些颜色组成的图像的方法。如果你想简化问题，可以假设图像总是 4 像素乘 4 像素，就像
    [图 2-1](ch02.xhtml#ch2fig1) 中的那个图像。'
- en: '**Part 2**   Using your approach from part 1, write out a binary representation
    of the flower image in [Figure 2-1](ch02.xhtml#ch2fig1).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二部分** 使用第一部分中的方法，写出 [图 2-1](ch02.xhtml#ch2fig1) 中花朵图像的二进制表示。'
- en: '**Part 3**   Explain your approach for representing images to a friend. Then
    give your friend your binary data and see if they can draw the image above without
    seeing the original image!'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 3 部分** 解释你表示图像的方法给朋友听。然后把你的二进制数据给朋友，看看她是否能在不看原始图像的情况下画出上面的图像！'
- en: There’s no single right answer to this; see [Appendix A](appa.xhtml) for an
    example answer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题没有唯一的正确答案；可以参考[附录 A](appa.xhtml)中的示例答案。
- en: In [Exercise 2-4](ch02.xhtml#ch2ex4), in part 2, you acted like a computer program
    that was responsible for encoding an image into binary data. In part 3, your friend
    acted like a computer program that was responsible for the reverse, decoding binary
    data into an image. Hopefully she was able to decipher your binary data and draw
    a flower! If your friend pulled it off, then great, together you demonstrated
    how software encodes and decodes data! If things didn’t go so well, and she ended
    up drawing something more like a pickle than a flower, that’s okay too; you demonstrated
    how sometimes software has flaws, leading to unexpected results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在[练习 2-4](ch02.xhtml#ch2ex4)的第 2 部分，你像一个计算机程序一样负责将图像编码成二进制数据。在第 3 部分，你的朋友像一个计算机程序一样负责解码，将二进制数据还原成图像。希望她能够解码你的二进制数据并画出一朵花！如果她成功了，那太好了，你们一起展示了软件如何编码和解码数据！如果情况不太顺利，她画出的可能更像是腌黄瓜而不是花朵，那也没关系；你们展示了有时软件存在缺陷，导致意外结果。
- en: '***Approaches for Representing Colors and Images***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表示颜色和图像的方法***'
- en: As mentioned earlier, there are already standard approaches defined for representing
    colors and images in a digital manner. For grayscale images, one common approach
    is to use 8 bits per pixel, allowing for 256 shades of gray. Each pixel’s value
    typically represents the intensity of light, so 0 represents no light intensity
    (black) and 255 represents full intensity (white), and values in between are varying
    shades of gray, from dark to light. [Figure 2-2](ch02.xhtml#ch2fig2) illustrates
    various shades of gray using an 8-bit encoding scheme.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，已经有标准的方法定义了以数字方式表示颜色和图像。对于灰度图像，一种常见的方法是每个像素使用 8 位，允许表示 256 种灰度级别。每个像素的值通常表示光的强度，因此
    0 代表无光强度（黑色），255 代表最大光强度（白色），介于两者之间的是不同的灰度，从深到浅。[图 2-2](ch02.xhtml#ch2fig2)展示了使用
    8 位编码方案的不同灰度级别。
- en: '![image](../images/fig2-2.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig2-2.jpg)'
- en: '*Figure 2-2: Shades of gray represented with 8 bits, shown as binary, hex,
    and decimal*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：使用 8 位表示的灰度，显示为二进制、十六进制和十进制*'
- en: Representing colors beyond shades of gray works in a similar manner. Although
    grayscale can be represented with a single 8-bit number, an approach known as
    *RGB* uses three 8-bit numbers to represent the intensity of Red, Green, and Blue
    that combine to make a single color. Dedicating 8 bits to each of the three component
    colors means 24 bits are needed to represent the overall color.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表示除了灰度以外的颜色采用类似的方法。虽然灰度图像可以通过一个 8 位数表示，称为 *RGB* 的方法使用三个 8 位数表示红色、绿色和蓝色的强度，这三种颜色组合起来形成一个单一的颜色。为每种颜色分配
    8 位意味着需要 24 位来表示整体颜色。
- en: '**NOTE**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*RGB is based on an* additive color model, *where colors are composed of a
    mix of red, green, and blue light. This is in contrast to the* subtractive color
    model *used in painting, where the mixed colors are red, yellow, and blue*.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*RGB 基于一种* 加色模型，*其中颜色由红色、绿色和蓝色光的混合组成。这与绘画中使用的* 渐变色模型 *不同，在后者中，混合的颜色是红色、黄色和蓝色*。'
- en: For example, the color red is represented in RGB with all 8 red bits set to
    1, and the remaining 16 bits for the other two colors set to 0\. Or if you wanted
    to represent yellow, which is a combination of red and green, but no blue, you
    could set the red and green bits to all 1s and leave the blue bits as all 0s.
    This is illustrated in [Figure 2-3](ch02.xhtml#ch2fig3).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，红色在 RGB 中通过将所有 8 位红色设为 1，其余 16 位的两个颜色设为 0 来表示。或者，如果你想表示黄色，这是一种红色和绿色的组合，但没有蓝色，你可以将红色和绿色的位设为
    1，蓝色的位保持为 0。这个过程在[图 2-3](ch02.xhtml#ch2fig3)中有说明。
- en: '![image](../images/fig2-3.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig2-3.jpg)'
- en: '*Figure 2-3: Red and yellow represented using RGB*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：使用 RGB 表示的红色和黄色*'
- en: In both the examples in [Figure 2-3](ch02.xhtml#ch2fig3), the colors that are
    “on” are all 1s, but the RGB system allows for the red, blue, and green component
    colors to be partial strength as well. Each component color can vary from 00000000
    (0 decimal/0 hex) to 11111111 (255 decimal/FF hex). A lower value represents a
    darker shade of that color, and a higher value represents a brighter shade of
    that color. With this flexibility of mixing colors, we can represent nearly any
    shade imaginable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-3](ch02.xhtml#ch2fig3)中的两个例子中，所有“开启”的颜色都是1，但RGB系统也允许红色、蓝色和绿色的组成颜色部分强度不一。每个组成颜色的值可以从00000000（0十进制/0十六进制）到11111111（255十进制/FF十六进制）。较低的值表示该颜色的较暗阴影，较高的值表示该颜色的较亮阴影。通过这种颜色混合的灵活性，我们几乎可以表示任何想象得到的颜色。
- en: Not only are there standard ways of representing colors, but there are also
    multiple, commonly used approaches for representing an entire image. As you saw
    in [Figure 2-1](ch02.xhtml#ch2fig1), we can construct images using a grid of pixels,
    with each pixel set to a particular color. Over the years, multiple image formats
    have been devised to do just that. A simplistic approach of representing an image
    is called a *bitmap*. Bitmap images store the RGB color data for each individual
    pixel. Other image formats, such as JPEG and PNG, use compression techniques to
    reduce the number of bytes required to store an image, as compared to a bitmap.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅有标准的颜色表示方法，还有多种常用的方法来表示整个图像。正如你在[图 2-1](ch02.xhtml#ch2fig1)中看到的，我们可以通过一个像素网格来构建图像，每个像素设置为特定的颜色。多年来，已经设计出了多种图像格式来实现这一点。一种简单的表示图像的方法称为*位图*。位图图像存储每个单独像素的RGB颜色数据。其他图像格式，如JPEG和PNG，使用压缩技术来减少存储图像所需的字节数，相比位图格式更为高效。
- en: '***Interpreting Binary Data***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解读二进制数据***'
- en: 'Let’s examine one more binary value: 011000010110001001100011\. What do you
    think it represents? If we assume it is an ASCII text string, it represents “abc.”
    On the other hand, perhaps it represents a 24-bit RGB color, making it a shade
    of gray. Or maybe it is a positive integer, in which case it is 6,382,179 in decimal.
    These various interpretations are illustrated in [Figure 2-4](ch02.xhtml#ch2fig4).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来分析一个二进制值：011000010110001001100011。你认为它代表什么？如果我们假设它是一个ASCII文本字符串，那么它表示“abc”。另一方面，也许它表示一个24位RGB颜色，从而是某种灰度色调。或者它可能是一个正整数，在这种情况下，它在十进制下的值是6,382,179。这些不同的解释在[图
    2-4](ch02.xhtml#ch2fig4)中有所展示。
- en: '![image](../images/fig2-4.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig2-4.jpg)'
- en: '*Figure 2-4: Interpretations of 011000010110001001100011*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：011000010110001001100011 的解释*'
- en: So which is it? It can be any of these, or something else entirely. It all depends
    on the context in which the data is interpreted. A text editor program will assume
    the data is text, whereas an image viewer may assume it is the color of a pixel
    in an image, and a calculator may assume it is a number. Each program is written
    to expect data in a particular format, and so a single binary value has different
    meanings in various contexts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它到底代表什么呢？它可以是这些中的任何一种，或者完全是其他的东西。这完全取决于数据被解释的上下文。文本编辑器程序会假设数据是文本，而图像查看器可能会假设它是图像中某个像素的颜色，计算器则可能会假设它是一个数字。每个程序都被设计为期望某种特定格式的数据，因此一个二进制值在不同的上下文中有不同的含义。
- en: We’ve demonstrated how binary data can be used to represent numbers, text, colors,
    and images. From this you can make some educated guesses about how other types
    of data can be stored, such as video or audio. There’s no limit on what kinds
    of data can be represented digitally. The digital representation isn’t always
    a perfect replica of the original data, but in many cases that isn’t a problem.
    Being able to represent anything as a sequence of 0s and 1s is enormously useful,
    since once we’ve built a device that works with binary data we can adapt it, through
    software, to deal with any kind of data!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用二进制数据来表示数字、文本、颜色和图像。从这些例子中，你可以对如何存储其他类型的数据，如视频或音频，做出一些推测。数字化表示的数据类型没有限制。数字表示不一定是原始数据的完美复制，但在许多情况下这并不是问题。能够将任何事物表示为一串0和1是极其有用的，因为一旦我们构建了能够处理二进制数据的设备，我们就可以通过软件将其适配为处理任何类型的数据！
- en: '**Binary Logic**'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二进制逻辑**'
- en: We’ve established the utility of using binary to represent data, but computers
    do more than simply store data. They allow us to work with data as well. With
    a computer’s help, we can read, edit, create, transform, share, and otherwise
    manipulate data. Computers give us the capability to process data in many ways
    using hardware that we can program to execute a sequence of simple instructions—instructions
    like “add two numbers together” or “check if two values are equal.” Computer processors
    that implement these instructions are fundamentally based on *binary logic*, a
    system for describing logical statements where variables can only be one of two
    values—true or false. Let’s now examine binary logic, and in the process, we’ll
    again see how everything in a computer comes down to 1s and 0s.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了使用二进制表示数据的实用性，但计算机不仅仅是存储数据。它们还让我们能够处理数据。在计算机的帮助下，我们可以读取、编辑、创建、转换、分享以及以其他方式操作数据。计算机赋予我们以多种方式处理数据的能力，利用硬件，我们可以编写程序来执行一系列简单的指令——像“将两个数字相加”或“检查两个值是否相等”这样的指令。实现这些指令的计算机处理器本质上基于*二进制逻辑*，这是一种描述逻辑陈述的系统，其中变量只能是两个值之一——真或假。现在，让我们来研究一下二进制逻辑，在这个过程中，我们将再次看到计算机中的一切都归结为
    1 和 0。
- en: Let’s consider how binary is a natural fit for logic. Typically, when someone
    speaks of logic, they mean reasoning, or thinking through what is known in order
    to arrive at a valid conclusion. When presented with a set of facts, logic allows
    us to determine whether another related statement is also factual. Logic is all
    about truth—what is true, and what is false. Likewise, a bit can only be one of
    two values, 1 or 0\. Therefore, a single bit can be used to represent a logical
    state of true (1) or false (0).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下二进制如何自然地与逻辑契合。通常，当有人提到逻辑时，他们指的是推理，或者说通过已知的事实进行思考，以得出有效的结论。当面对一组事实时，逻辑帮助我们判断另一个相关的陈述是否也为事实。逻辑关注的是真理——什么是真的，什么是假的。同样，一个位（bit）只能有两个值之一：1
    或 0。因此，单个比特可以表示逻辑状态中的“真”（1）或“假”（0）。
- en: 'Let’s look at an example logical statement:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个逻辑陈述的例子：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example has two conditions (four sides, four right angles) that must *both*
    be true for the conclusion to be true as well. For this kind of situation, we
    use the logical operator AND to join the two statements together. If either of
    the conditions is false, then the conclusion is false as well. I’ve expressed
    that same logic in [Table 2-2](ch02.xhtml#ch2tab2).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有两个条件（四条边，四个直角），它们必须*都*为真，结论才能为真。对于这种情况，我们使用逻辑运算符 AND 将两个陈述连接在一起。如果其中任何一个条件为假，那么结论也为假。我在[表
    2-2](ch02.xhtml#ch2tab2)中表达了相同的逻辑。
- en: '**Table 2-2:** Logical Statement for a Rectangle'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-2：** 矩形的逻辑陈述'
- en: '| **Four sides** | **Four right angles** | **Is a rectangle** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **四条边** | **四个直角** | **是矩形** |'
- en: '| --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| False | False | False |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 假 | 假 | 假 |'
- en: '| False | True | False |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 假 | 真 | 假 |'
- en: '| True | False | False |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 真 | 假 | 假 |'
- en: '| True | True | True |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 真 | 真 | 真 |'
- en: 'Using [Table 2-2](ch02.xhtml#ch2tab2), we can interpret each row as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[表 2-2](ch02.xhtml#ch2tab2)，我们可以按如下方式解释每一行：
- en: If the shape does *not* have four sides and does *not* have four right angles,
    it is *not* a rectangle.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个形状*不*有四条边且*不*有四个直角，那么它*不是*矩形。
- en: If the shape does *not* have four sides and *does* have four right angles, it
    is *not* a rectangle.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个形状*不*具有四条边且*有*四个直角，那么它*不是*矩形。
- en: If the shape *does* have four sides and does *not* have four right angles, it
    is *not* a rectangle.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个形状*有*四条边且*没有*四个直角，那么它*不是*矩形。
- en: If the shape *does* have four sides and *does* have four right angles, it *is*
    a rectangle!
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个形状*有*四条边且*有*四个直角，那么它*是*矩形！
- en: 'This type of table is known as a *truth table*: a table that shows all the
    possible combinations of conditions (inputs) and their logical conclusions (outputs).
    [Table 2-2](ch02.xhtml#ch2tab2) was written specifically for our statement about
    a rectangle, but really, the same table applies to any logical statement joined
    with AND.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的表格被称为*真值表*：一种展示所有可能的条件组合（输入）及其逻辑结论（输出）的表格。[表 2-2](ch02.xhtml#ch2tab2)是专门为我们关于矩形的陈述编写的，但实际上，这张表适用于任何通过
    AND 连接的逻辑陈述。
- en: In [Table 2-3](ch02.xhtml#ch2tab3), I’ve made this table more generic, using
    A and B to represent our two input conditions, and Output to represent the logical
    result. Specifically, for this table Output is the result of A AND B.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 2-3](ch02.xhtml#ch2tab3)中，我将这个表格做得更加通用，使用 A 和 B 来表示我们的两个输入条件，使用 Output 来表示逻辑结果。具体来说，对于这个表格，Output
    是 A AND B 的结果。
- en: '**Table 2-3:** AND Truth Table (Using True and False)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-3：** 与（AND）真值表（使用真和假）'
- en: '| **A** | **B** | **Output** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **输出** |'
- en: '| --- | --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| False | False | False |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 假 | 假 | 假 |'
- en: '| False | True | False |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 假 | 真 | 假 |'
- en: '| True | False | False |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 真 | 假 | 假 |'
- en: '| True | True | True |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 真 | 真 | 真 |'
- en: In [Table 2-4](ch02.xhtml#ch2tab4), I’ve made one more modification to our table.
    Since this book is about computing, I’ve represented false as 0 and true as 1,
    just like computers do.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 2-4](ch02.xhtml#ch2tab4)中，我对我们的表格做了一点修改。由于本书讲的是计算机，我将假表示为 0，将真表示为 1，就像计算机一样。
- en: '**Table 2-4:** AND Truth Table'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-4：** 与（AND）真值表'
- en: '| **A** | **B** | **Output** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **输出** |'
- en: '| --- | --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 0 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 0 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 |'
- en: '| 1 | 0 | 0 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: '[Table 2-4](ch02.xhtml#ch2tab4) is the standard form of an AND truth table
    when you’re dealing with digital systems that use 0 and 1\. Computer engineers
    use such tables to express how components will behave when they’re presented with
    a certain set of inputs. Now let’s examine how this works with other logical operators
    and more complex logical statements.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-4](ch02.xhtml#ch2tab4) 是当你处理使用 0 和 1 的数字系统时，标准的与（AND）真值表。计算机工程师使用这样的表格来表达组件在面对某一组输入时的行为。现在让我们看看这如何与其他逻辑运算符和更复杂的逻辑表达式一起工作。'
- en: 'Let’s say you work at a shop that gives a discount to only two types of customers:
    children and people wearing sunglasses. No one else is eligible for a discount.
    If you wanted to state the store’s policy as a logical expression, you could say
    the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一家商店工作，该商店仅对两种类型的顾客提供折扣：儿童和戴太阳镜的人。其他人都不符合折扣条件。如果你想用逻辑表达式陈述商店的政策，你可以这样说：
- en: '[PRE1]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we have two conditions (child, wearing sunglasses) where *at least one*
    condition must be true for the conclusion to be true. In this situation we use
    the logical operator OR to join the two statements together. If either condition
    is true, then the conclusion is true as well. We can express this as a truth table,
    as shown in [Table 2-5](ch02.xhtml#ch2tab5).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个条件（儿童，戴太阳镜），其中*至少一个*条件必须为真，结论才为真。在这种情况下，我们使用逻辑运算符“或”（OR）将两个语句连接起来。如果其中任何一个条件为真，那么结论也为真。我们可以将其表示为一个真值表，如[表
    2-5](ch02.xhtml#ch2tab5)所示。
- en: '**Table 2-5:** OR Truth Table'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-5：** 或（OR）真值表'
- en: '| **A** | **B** | **Output** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **输出** |'
- en: '| --- | --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 0 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 1 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: By observing the inputs and output in [Table 2-5](ch02.xhtml#ch2tab5), we can
    quickly see that a discount will be given (Output = 1) when either the customer
    is a child (A = 1) or the customer is wearing sunglasses (B = 1). Note that the
    input column values for A and B are exactly the same for both [Table 2-4](ch02.xhtml#ch2tab4)
    and [Table 2-5](ch02.xhtml#ch2tab5). This makes sense, because both tables have
    two inputs and thus the same possible set of input combinations. What differs
    is the Output column.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察[表 2-5](ch02.xhtml#ch2tab5)中的输入和输出，我们可以快速看到，当顾客是儿童（A = 1）或顾客戴太阳镜（B = 1）时，会给予折扣（输出
    = 1）。请注意，A 和 B 的输入列值在[表 2-4](ch02.xhtml#ch2tab4)和[表 2-5](ch02.xhtml#ch2tab5)中完全相同。这是有道理的，因为这两张表都有两个输入，因此有相同的输入组合。不同之处在于输出列。
- en: 'Let’s combine AND with OR in a more complex logical statement. For the purposes
    of this example, assume that I go to the beach every day that is sunny and warm,
    and also assume that I go to the beach every year on my birthday. In fact, I only
    and always go to the beach under these specific circumstances—my wife says I’m
    overly stubborn in this way. Combining those ideas gives us the following logical
    statement:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将与（AND）与或（OR）结合起来，形成一个更复杂的逻辑表达式。为了这个例子，假设我每天都去海滩，如果天气晴朗且温暖，而且假设我每年生日时也去海滩。事实上，我只在这些特定情况下去海滩——我妻子说我在这方面太固执了。将这些想法结合起来，我们得到以下逻辑表达式：
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s label our input conditions, then write a truth table for this expression.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们标记输入条件，然后为这个表达式写一个真值表。
- en: '**Condition A**   It is sunny.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件 A**   天气晴朗。'
- en: '**Condition B**   It is warm.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件 B**   天气温暖。'
- en: '**Condition C**   It is my birthday.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件 C**   今天是我的生日。'
- en: 'Our logical expression will look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的逻辑表达式看起来像这样：
- en: '[PRE3]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just like in an algebraic expression, the parentheses around A AND B mean that
    part of the expression should be evaluated first. [Table 2-6](ch02.xhtml#ch2tab6)
    gives us a truth table for this logical expression.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在代数表达式中，A 且 B 周围的括号意味着该部分表达式应首先进行评估。[表 2-6](ch02.xhtml#ch2tab6) 为此逻辑表达式提供了一个真值表。
- en: '**Table 2-6:** (A AND B) OR C Truth Table'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-6：** (A 且 B) 或 C 真值表'
- en: '| **A** | **B** | **C** | **Output** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **C** | **输出** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 0 | 0 | 0 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 1 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 |'
- en: '| 0 | 1 | 0 | 0 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 |'
- en: '| 0 | 1 | 1 | 1 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 |'
- en: '| 1 | 0 | 0 | 0 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 |'
- en: '| 1 | 0 | 1 | 1 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 |'
- en: '| 1 | 1 | 0 | 1 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 1 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 |'
- en: '[Table 2-6](ch02.xhtml#ch2tab6) is a bit more complex than a simple AND truth
    table, but it’s still understandable. The table format makes it easy to look up
    a certain condition and see the outcome. For example, the third row tells us that
    if A = 0 (it is *not* sunny), B = 1 (it *is* warm), C = 0 (it is *not* my birthday),
    then Output = 0 (I’m *not* going to the beach today).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-6](ch02.xhtml#ch2tab6) 比简单的 AND 真值表稍微复杂一些，但仍然可以理解。表格格式使得查找特定条件并查看结果变得容易。例如，第三行告诉我们，如果
    A = 0（今天*不*是晴天），B = 1（今天*很*暖和），C = 0（今天*不是*我的生日），那么输出 = 0（我今天*不*去海滩）。'
- en: This kind of logic is something that computers regularly need to handle. In
    fact, as mentioned earlier, the fundamental capabilities of a computer distill
    down to sets of logical operations. Although a simple AND operator may seem far
    removed from the capabilities of a smartphone or laptop, these logical operators
    serve as the conceptual building blocks of all digital computers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑是计算机经常需要处理的。事实上，正如之前提到的，计算机的基本功能归结为一组逻辑操作。虽然一个简单的 AND 运算符看起来与智能手机或笔记本电脑的功能相差甚远，但这些逻辑运算符是所有数字计算机的概念性构建块。
- en: '**EXERCISE 2-5: WRITE A TRUTH TABLE FOR A LOGICAL EXPRESSION**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2-5：编写一个逻辑表达式的真值表**'
- en: '[Table 2-7](ch02.xhtml#ch2tab7) shows three inputs for a logical expression.
    Complete the truth table output for the expression (A OR B) AND C. The answer
    is in [Appendix A](appa.xhtml).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-7](ch02.xhtml#ch2tab7) 显示了一个逻辑表达式的三个输入。完成表达式 (A 或 B) 且 C 的真值表输出。答案见 [附录
    A](appa.xhtml)。'
- en: '**Table 2-7:** (A OR B) AND C Truth Table'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-7：** (A 或 B) 且 C 真值表'
- en: '| **A** | **B** | **C** | **Output** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **C** | **输出** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 0 | 0 |  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |  |'
- en: '| 0 | 0 | 1 |  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |  |'
- en: '| 0 | 1 | 0 |  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 |  |'
- en: '| 0 | 1 | 1 |  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |  |'
- en: '| 1 | 0 | 0 |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 |  |'
- en: '| 1 | 0 | 1 |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |  |'
- en: '| 1 | 1 | 0 |  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |  |'
- en: '| 1 | 1 | 1 |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |  |'
- en: Besides AND and OR, several other common logical operators are used in the design
    of digital systems. I cover each operator in the following pages and provide a
    truth table for each. We use these again in [Chapter 4](ch04.xhtml) on digital
    circuits.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 AND 和 OR，还有一些其他常用的逻辑运算符用于数字系统的设计。在接下来的几页中，我将介绍每个运算符，并为每个运算符提供一个真值表。在 [第 4
    章](ch04.xhtml) 关于数字电路的部分，我们将再次使用这些运算符。
- en: The logical operator NOT is just what it sounds like, the output is the opposite
    of the input condition. That is, if A is true, then the output is *not* true,
    and vice versa. As you can see in [Table 2-8](ch02.xhtml#ch2tab8), NOT only takes
    a single input, rather than two inputs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符 NOT 就是它听起来的意思，输出是输入条件的反面。也就是说，如果 A 为真，则输出为 *不* 真，反之亦然。如 [表 2-8](ch02.xhtml#ch2tab8)
    所示，NOT 仅接受一个输入，而不是两个输入。
- en: '**Table 2-8:** NOT Truth Table'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-8：** NOT 真值表'
- en: '| **A** | **Output** |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **输出** |'
- en: '| --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 1 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 |'
- en: '| 1 | 0 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 |'
- en: The operator NAND means NOT AND, so the output is the reverse of AND. If both
    inputs are true, the result is false. Otherwise, the result is true. This is shown
    in [Table 2-9](ch02.xhtml#ch2tab9).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 NAND 意味着 NOT AND，因此输出是 AND 的反向。如果两个输入都为真，则结果为假。否则，结果为真。这一点在 [表 2-9](ch02.xhtml#ch2tab9)
    中有显示。
- en: '**Table 2-9:** NAND Truth Table'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-9：** NAND 真值表'
- en: '| **A** | **B** | **Output** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **输出** |'
- en: '| --- | --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 1 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 0 | 1 | 1 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: The NOR operator means NOT OR, so the output is the reverse of OR. If both inputs
    are false, the result is true. Otherwise, the result is false. [Table 2-10](ch02.xhtml#ch2tab10)
    shows this as a truth table.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: NOR 运算符意味着 NOT OR，因此输出是 OR 的反向。如果两个输入都为假，则结果为真。否则，结果为假。[表 2-10](ch02.xhtml#ch2tab10)
    显示了这一点。
- en: '**Table 2-10:** NOR Truth Table'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-10：** NOR 真值表'
- en: '| **A** | **B** | **Output** |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **输出** |'
- en: '| --- | --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 1 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 0 | 1 | 0 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 |'
- en: '| 1 | 0 | 0 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: XOR is Exclusive OR, meaning that only a single (exclusive) input can be true
    for the result to be true. That is, the output is true if only A is true or only
    B is true, while the output is false if both inputs are true. This is detailed
    in [Table 2-11](ch02.xhtml#ch2tab11).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: XOR 是“异或”运算，意味着只有一个（排他性）输入为真时，结果才为真。也就是说，输出为真时，只有 A 为真或者只有 B 为真，而当两个输入都为真时，输出为假。详情见
    [表 2-11](ch02.xhtml#ch2tab11)。
- en: '**Table 2-11:** XOR Truth Table'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-11：** XOR 真值表'
- en: '| **A** | **B** | **Output** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **输出** |'
- en: '| --- | --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 0 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 1 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: The study of logical functions of two-value variables (true or false) is known
    as *Boolean algebra* or *Boolean logic*. George Boole described this approach
    to logic in the 1800s, well before the advent of the digital computer. His work
    proved to be foundational to the development of digital electronics, including
    the computer.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 研究二值变量（真或假）逻辑功能的学科称为 *布尔代数* 或 *布尔逻辑*。乔治·布尔在 19 世纪描述了这种逻辑方法，早于数字计算机的出现。他的工作为数字电子学的发展，包括计算机的诞生，奠定了基础。
- en: '**Summary**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we covered how binary is used to represent both data and logical
    states. You learned how 0s and 1s can be used to represent nearly any kind of
    data. We looked at text, colors, and images as examples of data in a binary format.
    You were introduced to various logical operators, such as AND and OR, and you
    learned about using truth tables to express a logical statement. Understanding
    this is important because the complex processors found in today’s computers are
    based on an intricate system of logic.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了二进制如何用来表示数据和逻辑状态。你学习了如何使用 0 和 1 来表示几乎任何类型的数据。我们以文本、颜色和图像作为二进制格式数据的示例。你还了解了各种逻辑运算符，如与（AND）和或（OR），并学习了如何使用真值表来表达逻辑语句。理解这些非常重要，因为今天计算机中复杂的处理器是基于复杂的逻辑系统。
- en: We return to the topic of binary when we discuss digital circuits in [Chapter
    4](ch04.xhtml), but first, to prepare you for that topic, we will take a detour
    in [Chapter 3](ch03.xhtml) to cover the fundamentals of electrical circuits. We’ll
    explore the laws of electricity, see how electrical circuits work, and get familiar
    with some basic components found in many circuits. You’ll even have an opportunity
    to build your own circuits!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [第 4 章](ch04.xhtml)讨论数字电路时，我们将回到二进制的主题，但在此之前，为了为你准备好这个话题，我们将在 [第 3 章](ch03.xhtml)中绕道讲解电路基础知识。我们将探讨电学定律，了解电路是如何工作的，并熟悉一些在许多电路中常见的基本元件。你甚至还会有机会构建自己的电路！
