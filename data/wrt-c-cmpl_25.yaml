- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DEBUGGING
    ASSEMBLY CODE WITH GDB OR LLDB</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A</samp> <samp class="SANS_Dogma_OT_Bold_B_11">使用GDB或LLDB调试汇编代码</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: At some point, your compiler is going to generate assembly code that doesn’t
    behave correctly, and you’ll need to figure out why. When that happens, a command
    line debugger is indispensable for understanding what’s going wrong. A debugger
    lets you pause a running program, step through it one instruction at a time, and
    examine the program state at different points. You can use either GDB (the GNU
    debugger) or LLDB (the debugger from the LLVM Project) to debug the assembly code
    your compiler generates. I recommend using GDB if you’re on Linux and LLDB if
    you’re on macOS (I think GDB has a slightly nicer UI for working with assembly,
    but getting it to run on macOS can be a challenge).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，你的编译器可能会生成不正确行为的汇编代码，这时你需要找出原因。当发生这种情况时，命令行调试器对于理解问题所在至关重要。调试器可以让你暂停运行中的程序，逐条执行指令，并在不同的时刻检查程序状态。你可以使用GDB（GNU调试器）或LLDB（LLVM项目的调试器）来调试编译器生成的汇编代码。如果你使用的是Linux，建议使用GDB；如果你使用的是macOS，则建议使用LLDB（我认为GDB在处理汇编时的UI略好，但在macOS上运行它可能会有些挑战）。
- en: This appendix is a brief guide to debugging assembly programs with GDB or LLDB.
    It introduces the basics that you’ll need to know if you’ve never used a debugger
    before. It also covers the most important commands and options that you’ll need
    to use to work with assembly code in particular, which may be new to you even
    if you’re comfortable using these tools to debug source code. I’ve included separate
    walk-throughs for the two debuggers; even though they have very similar functionality,
    the details of many commands are different. Follow the walk-through for whichever
    debugger you’re using.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录是一个简短的指南，介绍如何使用GDB或LLDB调试汇编程序。它介绍了如果你以前没有使用过调试器，你需要了解的基础知识。它还涵盖了调试汇编代码时你需要使用的最重要命令和选项，即使你已经熟悉使用这些工具调试源代码，某些命令的细节可能对你来说是新的。我为这两个调试器分别提供了单独的操作流程；尽管它们具有非常相似的功能，但许多命令的细节是不同的。请根据你使用的调试器，遵循相应的操作流程。
- en: Before you get started, you should be familiar with the basics of assembly code
    covered in [Chapters 1](chapter1.xhtml) and [2](chapter2.xhtml). A few aspects
    of assembly from later chapters will also come up, but you can gloss over those
    if you haven’t gotten to them yet.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你应该熟悉[第1章](chapter1.xhtml)和[第2章](chapter2.xhtml)中涵盖的汇编代码基础知识。后续章节中的一些汇编内容也会涉及，但如果你还没有学习到那些内容，可以暂时跳过。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Program</samp>
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">程序</samp>
- en: We’ll use the assembly program in [Listing A-1](#listA-1) as a running example.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[清单A-1](#listA-1)中的汇编程序作为示例进行演示。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-1: A pointless assembly
    program</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单A-1：一个无意义的汇编程序</samp>
- en: 'This program doesn’t do anything useful; it just gives us the opportunity to
    try out the most important features of the debuggers. It includes a couple of
    static variables for us to inspect: <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp> ❷. In <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    ❸, it first calls a very small function, <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>,
    so we can practice stepping into and out of function calls ❹, then moves some
    data into registers and onto the stack so we can practice examining the state
    of the program ❺. It ends with a loop that decrements ECX on every iteration,
    stopping once it reaches 0 ❻. We’ll use this loop to practice setting conditional
    breakpoints.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序没有做任何有用的事情，它只是给我们提供了一个机会来尝试调试器的最重要功能。它包括几个静态变量，供我们检查：<samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    ❶ 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp> ❷。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    ❸ 中，首先调用了一个非常小的函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>，这样我们就可以练习进入和退出函数调用
    ❹，然后将一些数据移动到寄存器和栈中，以便我们可以练习检查程序状态 ❺。程序最后包含一个循环，每次迭代都会递减ECX，直到它达到0 ❻。我们将利用这个循环来练习设置条件断点。
- en: Download this program from *[https://<wbr>norasandler<wbr>.com<wbr>/book<wbr>/#appendix<wbr>-a](https://norasandler.com/book/#appendix-a)*,
    then save it as *hello_debugger.s*. There are two different versions of this file
    for Linux and macOS, so make sure to pick the right one for your operating system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://<wbr>norasandler<wbr>.com<wbr>/book<wbr>/#appendix<wbr>-a](https://norasandler.com/book/#appendix-a)*
    下载该程序，然后将其保存为 *hello_debugger.s*。该文件有两个不同版本，分别适用于 Linux 和 macOS，因此请确保选择适合您操作系统的版本。
- en: 'Once you’ve saved the file, assemble and link it and confirm that it runs:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，组装并链接它，并确认它是否能够运行：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On macOS, include the <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp>
    option when you assemble and link the file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，组装并链接文件时，请包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp>
    选项：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp> option generates
    extra debug information. Make sure to include it when assembling and linking your
    own compiler’s assembly output for debugging too.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp> 选项会生成额外的调试信息。确保在组装和链接您自己的编译器汇编输出时也包含此选项以便调试。
- en: Now you can start the walk-through. If you’re using GDB, follow the walk-through
    in the next section. If you’re using LLDB, skip to “Debugging with LLDB” on [page
    687](#pg_687).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以开始逐步讲解。如果您使用 GDB，请按照下一部分的说明进行操作。如果您使用 LLDB，请跳转到 [第 687 页](#pg_687)的“使用
    LLDB 调试”部分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Debugging with GDB</samp>
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 GDB 调试</samp>
- en: 'Run this command to start up GDB:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令启动 GDB：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This sets <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp>
    as the executable to debug but doesn’t actually execute it. Before we start running
    this executable, let’s configure the UI to make working with assembly code easier.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp> 为要调试的可执行文件，但并不实际执行它。在开始运行此可执行文件之前，我们来配置
    UI，以便更方便地处理汇编代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Configuring the GDB
    UI</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">配置 GDB UI</samp>
- en: During a GDB session, you can open up different text windows that display different
    information about the running program. For our purposes, the most important of
    these is the *assembly window*, which displays the assembly code as we step through
    it. The *register window* is also useful; by default, it shows the current contents
    of every general-purpose register.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GDB 会话期间，您可以打开不同的文本窗口，以显示运行程序的不同信息。对于我们的目的来说，最重要的是 *汇编窗口*，它会在我们逐步执行时显示汇编代码。*寄存器窗口*
    也很有用；默认情况下，它显示每个通用寄存器的当前内容。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">layout</samp> command controls
    which windows are visible. Let’s open up the assembly and register windows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">layout</samp> 命令控制哪些窗口是可见的。让我们打开汇编窗口和寄存器窗口：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should now see three windows in your terminal: the register window, the
    assembly window, and the command window with the <samp class="SANS_TheSansMonoCd_W5Regular_11">(gdb)</samp>
    prompt. It should look similar to [Figure A-1](#figA-1).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能在终端中看到三个窗口：寄存器窗口、汇编窗口和带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">(gdb)</samp>
    提示符的命令窗口。它应该类似于 [图 A-1](#figA-1)。
- en: '![](../images/figA-1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figA-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-1: A GDB session with
    the assembly and register windows open [Description](description-89.xhtml)</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 A-1：一个 GDB 会话，打开了汇编窗口和寄存器窗口
    [描述](description-89.xhtml)</samp>
- en: The register window won’t display any information until you start the program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动程序之前，寄存器窗口不会显示任何信息。
- en: 'You can scroll in whichever window is currently in focus. Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">focus</samp>
    command to change the in-focus window:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在当前聚焦的窗口中滚动。使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">focus</samp>
    命令来更改聚焦窗口：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Starting and
    Stopping the Program</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">启动与停止程序</samp>'
- en: Next, we’ll set a *breakpoint*—a location where the debugger will pause the
    program—and run the program up to that breakpoint. If we start the program without
    setting a breakpoint first, it will run all the way through without stopping,
    which isn’t very useful.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置一个 *断点*—即调试器暂停程序执行的位置—并运行程序直到该断点。如果我们在未设置断点的情况下启动程序，它将直接执行到底部，这样不太有用。
- en: 'The command <samp class="SANS_TheSansMonoCd_W5Regular_11">break <</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">function name></samp> sets a
    breakpoint at the start of a function. Let’s set a breakpoint at the entrance
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 <samp class="SANS_TheSansMonoCd_W5Regular_11">break <</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">function
    name></samp> 在函数的开始设置断点。我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    的入口处设置一个断点：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let’s start the program:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始程序：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output of this command tells us that the program has hit the breakpoint
    we just set ❶. Notice that the current instruction is highlighted in the assembly
    window and the current values of the general-purpose registers are displayed in
    the register window, as shown in [Figure A-2](#figA-2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出告诉我们程序已经命中我们刚设置的断点 ❶。请注意，当前的指令在汇编窗口中被高亮显示，通用寄存器的当前值也在寄存器窗口中显示，如[图 A-2](#figA-2)所示。
- en: '![](../images/figA-2.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figA-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-2: A GDB session when
    the program is stopped at a breakpoint [Description](description-90.xhtml)</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 A-2：程序在断点处停止时的 GDB 会话 [描述](description-90.xhtml)</samp>
- en: 'Once a program is paused, there are a few commands you can use to move it forward:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序暂停，你可以使用一些命令来让程序继续执行：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">continue</samp> resumes the program
    and runs until we hit another breakpoint or exit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">continue</samp> 恢复程序，并运行直到我们遇到另一个断点或退出。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">finish</samp> resumes the program
    and pauses again when we return from the current function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">finish</samp> 恢复程序，并在我们从当前函数返回时再次暂停。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">stepi</samp> executes the next
    instruction, then pauses. It steps into <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instructions, pausing at the first instruction in the callee. The command <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stepi</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp>
    will execute *n* instructions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">stepi</samp> 执行下一条指令，然后暂停。它会进入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> 指令，在被调用函数的第一条指令处暂停。命令
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp>
    将执行 *n* 条指令。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">nexti</samp> executes the next
    instruction, then pauses. It steps over <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instructions, pausing at the next instruction after <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    in the current function. The command <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp> will execute
    *n* instructions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">nexti</samp> 执行下一条指令，然后暂停。它会跳过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> 指令，在当前函数中 <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    后的下一条指令处暂停。命令 <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp> 将执行 *n* 条指令。
- en: 'Most GDB instructions can be abbreviated to one or two letters: you can type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi</samp>,
    and so on. [Table A-1](#tabA-1) on [page 687](#pg_687) gives full and shortened
    versions of all the commands we discuss.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 GDB 指令可以缩写为一到两个字母：你可以输入 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    来代替 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>，输入 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    来代替 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>，输入 <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>
    来代替 <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi</samp>，等等。[表 A-1](#tabA-1)
    以及 [第 687 页](#pg_687) 给出了我们讨论的所有命令的完整和简写版本。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">WARNING</samp>
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">警告</samp>
- en: '*While the nexti and stepi commands step through assembly instructions, the
    next and step commands step through lines in the original source file. Since we
    don’t have any information about the original source file, entering one of these
    commands will run the program until the end of the current function. These commands
    are abbreviated to n and s, respectively, so it’s easy to run them by accident
    when you meant to use nexti or stepi.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然 nexti 和 stepi 命令可以逐步执行汇编指令，但 next 和 step 命令是逐行执行原始源代码文件中的代码。由于我们没有原始源代码文件的信息，输入其中一个命令将导致程序运行直到当前函数的结束。这些命令分别简写为
    n 和 s，因此在你打算使用 nexti 或 stepi 时，容易不小心执行它们。*'
- en: 'Let’s try out our new commands. First, we’ll execute two instructions, which
    should take us into the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试新的命令。首先，我们将执行两条指令，这将使我们进入对 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    的调用：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see from the command output ❶ and from the highlighted instruction in
    the assembly window that we’re stopped in <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. Next, we’ll
    return from <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令输出 ❶ 和汇编窗口中高亮的指令来看，我们被停在了 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>。接下来，我们将从 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    返回：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’re now back in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    at the instruction right after <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp>.
    Let’s continue:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到了 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp>
    后面的指令。让我们继续：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we didn’t hit any more breakpoints, the program ran until it exited.
    To keep debugging it, we’ll have to restart it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有触发更多的断点，程序运行直到退出。为了继续调试，我们需要重新启动它：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we’re paused at the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    again. We’ll step forward two instructions one more time, but this time we’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti</samp> to step over <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f</samp> instead of stepping into it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 的起始位置暂停。我们将再向前执行两条指令，但这次我们将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti</samp> 来跳过 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>，而不是进入它：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This puts us back at the instruction right after <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp>.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们带回到 <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp> 后面的指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Breakpoints by Address</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">按地址设置断点</samp>
- en: 'In addition to setting breakpoints on functions, you can break on specific
    machine instructions. Let’s set a breakpoint on the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    0xdeadbeef, -4(%rbp)</samp>. First, we’ll find this instruction in the assembly
    window. It should look something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在函数上设置断点，你还可以在特定的机器指令上设置断点。我们将设置一个在指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    0xdeadbeef, -4(%rbp)</samp> 上的断点。首先，我们将在汇编窗口中找到这个指令。它应该看起来像这样：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The instruction’s address in memory is at the beginning of the line ❶, followed
    by the byte offset of that address from the start of the function ❷. The exact
    address may be different on your machine, but the offset should be the same. To
    set this breakpoint, you can type either
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 指令在内存中的地址位于行的开始 ❶，后面是该地址相对于函数起始位置的字节偏移量 ❷。确切的地址可能在你的机器上有所不同，但偏移量应该是相同的。要设置此断点，你可以输入以下任一命令
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: or
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">MEMORY_ADDRESS</samp>
    is the address you found in the assembly window. The <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    symbol tells GDB that we’re specifying an exact address rather than a function
    name.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">MEMORY_ADDRESS</samp>
    是你在汇编窗口中找到的地址。<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 符号告诉 GDB
    我们指定的是一个精确的地址，而不是函数名。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Managing Breakpoints</samp>
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">管理断点</samp>
- en: 'Let’s list all the breakpoints we’ve set:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出所有已设置的断点：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Every breakpoint has a unique number, which you can refer to if you need to
    delete, disable, or modify it. Let’s delete breakpoint 1:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个断点都有一个唯一的编号，如果需要删除、禁用或修改它，你可以参考这个编号。我们来删除断点1：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we’ll look at a couple of different ways to examine the program’s state.  ###
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Printing Expressions</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍几种不同的方式来检查程序的状态。### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">打印表达式</samp>
- en: 'You can print out expressions with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">print/</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format> <expr></samp>, where:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用命令 <samp class="SANS_TheSansMonoCd_W5Regular_11">print/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format>
    <expr></samp> 打印出表达式的值，其中：
- en: '<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><format></samp> is a one-letter
    format specifier. You can use most of the same format specifiers you’d use in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    to display a value as a hexadecimal integer, <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>
    to display it as a signed integer, and so on.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><format></samp> 是一个单字符的格式说明符。你可以使用大多数在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> 中使用的格式说明符：<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    用于以十六进制整数的形式显示一个值，<samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> 用于以有符号整数的形式显示它，等等。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><expr></samp> is an arbitrary
    expression. This expression can refer to registers, memory addresses, and symbols
    in the running program. It can also include C operations like arithmetic, pointer
    dereferencing, and cast expressions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><expr></samp> 是一个任意的表达式。这个表达式可以引用寄存器、内存地址以及运行程序中的符号。它还可以包含像算术运算、指针解引用和强制类型转换等C语言操作。
- en: 'Let’s try some examples. Right now, the program should be paused at the instruction
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0x87654321, %eax</samp>. We’ll
    step through this instruction, then print out the value of EAX in a few different
    formats:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些示例。现在，程序应该已经在指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0x87654321,
    %eax</samp> 处暂停。我们将逐步执行这条指令，然后以几种不同的格式打印出EAX的值：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By default, GDB formats the values in general-purpose registers as signed integers
    ❶. Here, we also display the value in EAX in hexadecimal ❷ and as an unsigned
    integer ❸. The symbols <samp class="SANS_TheSansMonoCd_W5Regular_11">$1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">$2</samp>, and so on are *convenience
    variables*, which GDB automatically generates to store the result of each expression.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，GDB会将通用寄存器中的值格式化为有符号整数❶。在这里，我们还将EAX的值以十六进制❷和无符号整数❸的形式显示。符号 <samp class="SANS_TheSansMonoCd_W5Regular_11">$1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">$2</samp> 等是 *便捷变量*，是GDB自动生成的，用来存储每个表达式的结果。
- en: 'You can find the full list of format specifiers in the documentation for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> command, which we’ll talk
    more about in a moment:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 命令的文档中找到完整的格式说明符列表，我们稍后会详细介绍：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Chapter 13](chapter13.xhtml) introduces the XMM registers, which hold floating-point
    values. The next instruction in our program, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd
    dbl(%rip), %xmm0</samp>, copies the value <samp class="SANS_TheSansMonoCd_W5Regular_11">3.5</samp>
    from the static <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp> variable
    into XMM0.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章](chapter13.xhtml)介绍了XMM寄存器，它们用于存储浮点值。我们程序中的下一条指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd
    dbl(%rip), %xmm0</samp> 将静态变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp>
    中的值 <samp class="SANS_TheSansMonoCd_W5Regular_11">3.5</samp> 复制到XMM0寄存器中。'
- en: 'Let’s step through this instruction, then inspect XMM0:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步执行这条指令，然后检查XMM0：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'GDB is showing us lots of different views of the same data: <samp class="SANS_TheSansMonoCd_W5Regular_11">v4_float</samp>
    displays this register’s contents as an array of four 32-bit floats, <samp class="SANS_TheSansMonoCd_W5Regular_11">v2_double</samp>
    displays it as an array of 64-bit doubles, and so on. Since we’ll use XMM registers
    only to store individual doubles, you can always examine them with a command like
    this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: GDB向我们展示了相同数据的多种不同视图：<samp class="SANS_TheSansMonoCd_W5Regular_11">v4_float</samp>
    以四个32位浮点数组的形式显示这个寄存器的内容，<samp class="SANS_TheSansMonoCd_W5Regular_11">v2_double</samp>
    以64位双精度浮点数组的形式显示它，等等。由于我们将仅使用XMM寄存器来存储单个双精度浮点数，你可以通过类似这样的命令来检查它们：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This prints out the value in the register’s lower 64 bits, interpreted as a
    double.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出寄存器低64位的值，并将其解释为双精度浮点数。
- en: 'In addition to registers, we can print out the values of objects in the symbol
    table. Let’s inspect the two static variables in this program, <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp>:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了寄存器，我们还可以打印符号表中对象的值。让我们检查程序中的两个静态变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp>：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since GDB doesn’t have any information about these objects’ types, we have to
    cast them to the correct type explicitly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GDB对这些对象的类型没有任何信息，我们必须显式地将它们强制转换为正确的类型。
- en: Let’s look at a few examples of more complex expressions. Aside from the fact
    that they refer directly to hardware registers, these expressions all use ordinary
    C syntax.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些更复杂表达式的示例。除了直接引用硬件寄存器之外，这些表达式都使用普通的C语法。
- en: 'We can perform basic arithmetic:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行基本的算术运算：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can call functions that are defined in the current program or the standard
    library. Here, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>,
    which returns <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用当前程序或标准库中定义的函数。在这里，我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>，它返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also dereference pointers. Let’s execute the next instruction, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl 0xdeadbeef, -4(%rbp)</samp>, then
    inspect the value at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以解引用指针。让我们执行下一个指令，<samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0xdeadbeef,
    -4(%rbp)</samp>，然后检查<samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>处的值：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we calculate the memory address we want to inspect, <samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp
    - 4</samp>. Then, we cast this address to the correct pointer type, <samp class="SANS_TheSansMonoCd_W5Regular_11">(int
    *)</samp>. Finally, we dereference it with the dereference operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>.
    This produces an integer, which we print out in hexadecimal with the <samp class="SANS_TheSansMonoCd_W5Regular_11">/x</samp>
    specifier.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算出要检查的内存地址，<samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp - 4</samp>。然后，我们将此地址强制转换为正确的指针类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(int *)</samp>。最后，我们使用解引用操作符<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>对其进行解引用。这将得到一个整数，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/x</samp>说明符以十六进制打印出来。
- en: Next, we’ll look at a more flexible way to inspect values in memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看一种更灵活的检查内存中值的方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Examining Memory</samp>
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检查内存</samp>
- en: 'We can examine memory with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">x/<</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n><format><unit> <expr></samp>,
    where:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过命令<samp class="SANS_TheSansMonoCd_W5Regular_11">x/<</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n><format><unit>
    <expr></samp>来检查内存，其中：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><n></samp> is the number
    of units of memory to display (given the unit size specified by <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><unit></samp>).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><n></samp>是要显示的内存单位数（根据<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><unit></samp>指定的单位大小）。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><format></samp> specifies
    how to format each unit. These are the same format specifiers we used in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">print</samp> command.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><format></samp>指定了如何格式化每个单位。这些格式说明符与我们在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">print</samp>命令中使用的格式说明符相同。
- en: '<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><unit></samp> is a one-letter
    specifier for the size of a unit: <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    for a byte, <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> for a 2-byte
    halfword, <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> for a 4-byte
    word, or <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> for an 8-byte
    “giant” word.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><unit></samp>是单位大小的一个单字母说明符：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>表示字节，<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>表示2字节半字，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w</samp>表示4字节字，或<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>表示8字节“大”字。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><expr></samp> is an arbitrary
    expression that evaluates to some valid memory address. These are the same kinds
    of expressions we can use in the <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>
    command.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><expr></samp> 是一个任意表达式，它会被计算为某个有效的内存地址。这些表达式与我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp> 命令中使用的表达式相同。
- en: 'Let’s use the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> command
    to inspect the integer at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 命令来检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    处的整数：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command tells GDB to print out one 4-byte word in hexadecimal. The output
    includes both the memory address ❶ and the value at that address ❷.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令告诉 GDB 打印出一个 4 字节的十六进制数字。输出包括内存地址 ❶ 和该地址上的值 ❷。
- en: 'The next three instructions in [Listing A-1](#listA-1) store three more integers
    on the stack:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 A-1](#listA-1) 中的下三条指令将三个整数存储到栈上：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ll use the commands in [Listing A-2](#listA-2) to step through these instructions,
    then print out the whole stack frame.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 [清单 A-2](#listA-2) 中的命令逐步执行这些指令，然后打印出整个栈帧。
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-2: Stepping forward
    three instructions, then printing out the current stack frame</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 A-2：前进三条指令，然后打印当前栈帧</samp>
- en: The command <samp class="SANS_TheSansMonoCd_W5Regular_11">x/6xw $rsp</samp>
    tells GDB to print out six 4-byte words, starting at the address in RSP. We print
    out six words because the stack frame for this particular function is 24 bytes.
    At the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, we
    saved the old value of RBP onto the stack. That’s 8 bytes. Then, we allocated
    another 16 bytes with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">subq
    $16, %rsp</samp>. Keep in mind that RSP always holds the address of the top of
    the stack, which is the *lowest* stack address.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 <samp class="SANS_TheSansMonoCd_W5Regular_11">x/6xw $rsp</samp> 告诉 GDB 从
    RSP 地址开始打印六个 4 字节的字。我们打印六个字是因为这个特定函数的栈帧是 24 字节的。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    开始时，我们将 RBP 的旧值保存在栈上。这是 8 字节。然后，我们使用命令 <samp class="SANS_TheSansMonoCd_W5Regular_11">subq
    $16, %rsp</samp> 再分配了 16 字节。请记住，RSP 总是保存栈顶的地址，也就是*最低*的栈地址。
- en: This command displays the four integers we saved to the stack, with <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfeedface</samp>
    at the top ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">0xdeadbeef</samp>
    at the bottom ❷, followed by the old value of RBP ❸. On some systems, this value
    will be 0 because we’re in the outermost stack frame; on others, it will be a
    valid memory address.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令显示了我们保存到栈上的四个整数，顶部是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfeedface</samp>
    ❶，底部是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xdeadbeef</samp> ❷，接着是 RBP
    的旧值 ❸。在某些系统中，这个值会是 0，因为我们处于最外层的栈帧；而在其他系统中，它会是一个有效的内存地址。
- en: 'The saved value of RBP is at the bottom of the current stack frame. Right after
    it, on top of the *caller’s* stack frame, we’ll find the caller’s return address—that
    is, the address we’ll jump to when we return from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    (We covered this in detail when we implemented function calls in [Chapter 9](chapter9.xhtml).)
    Let’s inspect this return address:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 保存的 RBP 值位于当前栈帧的底部。紧接着，在*调用者*的栈帧顶部，我们将找到调用者的返回地址——也就是我们从 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    返回时跳转到的地址。（我们在 [第 9 章](chapter9.xhtml) 中详细讲解了这一点。）让我们检查这个返回地址：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command will print out four 8-byte “giant” words, starting with the value
    at the address in RSP. The <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    specifier tells GDB to format these values as memory addresses; this means it
    will print each address in hexadecimal and, if possible, print out its offset
    from the nearest symbol in the program. Because function and static variable names
    are defined in the symbol table, GDB can display the relative offsets of assembly
    instructions and static data. It won’t display relative offsets of stack addresses,
    heap addresses, or invalid addresses, because they would be completely meaningless.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将打印出四个 8 字节的“巨型”字，首先是 RSP 地址上的值。<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    修饰符告诉 GDB 以内存地址的格式输出这些值；这意味着它会以十六进制打印每个地址，并且如果可能，还会打印出它与程序中最近的符号的偏移量。由于函数和静态变量的名称在符号表中已定义，GDB
    可以显示汇编指令和静态数据的相对偏移。它不会显示栈地址、堆地址或无效地址的相对偏移，因为这些完全没有意义。
- en: The first line of output includes the four integers we saved onto the stack,
    now displayed as two 8-byte values instead of four 4-byte values. The null pointer
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x0</samp> on the next line is the
    saved value of RBP. None of these three 8-byte values are valid addresses, so
    GDB can’t display their offsets from symbols. The next value on the stack is the
    return address ❶. GDB tells us that this is the address of an instruction in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_libc_start_main</samp>, the standard
    library function responsible for calling <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    and cleaning up after it exits.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行包括我们保存在栈上的四个整数，现在它们显示为两个 8 字节的值，而不是四个 4 字节的值。下一行中的空指针 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x0</samp>
    是保存的 RBP 值。由于这三个位 8 字节的值都不是有效的地址，所以 GDB 无法显示它们与符号的偏移量。栈上的下一个值是返回地址 ❶。GDB 告诉我们这是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_libc_start_main</samp> 中一条指令的地址，该函数负责调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 并在它退出后进行清理。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> specifier makes it
    easy to spot return addresses and pointers to static variables. This is particularly
    useful if your program’s stack frame is corrupted; finding each stack frame’s
    return address can help you get your bearings.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 修饰符可以帮助我们轻松识别返回地址和指向静态变量的指针。如果你的程序的栈帧已经损坏，找到每个栈帧的返回地址会帮助你定位当前的执行位置。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Conditional
    Breakpoints</samp>
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设置条件断点</samp>
- en: To wrap up this walk-through, we’ll look at how to set *conditional breakpoints*.
    The program will pause at a conditional breakpoint only if the associated condition
    is true. This condition can be an arbitrary expression; GDB will consider it false
    if it evaluates to 0 and true otherwise.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次操作演示的最后，我们将介绍如何设置 *条件断点*。程序只会在条件为真时暂停在条件断点处。这个条件可以是任意表达式；如果该表达式的结果为 0，GDB
    会认为其为假，否则为真。
- en: 'Let’s set a breakpoint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp>
    instruction at the end of the last loop iteration in <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp>.
    First, we need to find this instruction in the assembly window. It should be 65
    bytes after the start of the function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp> 中最后一次循环迭代的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> 指令上设置一个断点。首先，我们需要在汇编窗口中找到这个指令。它应该在函数开始后的第
    65 字节位置：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We’ll set a conditional breakpoint to pause on this instruction if ECX is 0:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个条件断点，当 ECX 为 0 时暂停在该指令处：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since this loop repeats until ECX is 0, the condition <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    will be true only on the last iteration. Let’s continue until this breakpoint,
    then verify that the condition is true:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该循环会重复执行，直到 ECX 为 0，因此条件 <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    只有在最后一次迭代时才会为真。让我们继续执行直到这个断点，然后验证该条件是否为真：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So far, so good. If you get a different value for ECX, check whether you set
    the breakpoint correctly:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切正常。如果你得到的 ECX 值不同，检查一下你是否正确设置了断点：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Make sure that your breakpoint is at the location <samp class="SANS_TheSansMonoCd_W5Regular_11">main+65</samp>
    ❶ and that it includes the condition <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    ❷. If your breakpoint looks different, you might have mistyped something; delete
    it and try again.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的断点位于 <samp class="SANS_TheSansMonoCd_W5Regular_11">main+65</samp> ❶ 处，并且包含条件
    <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> ❷。若你的断点不同，可能是输入错误，删除后再试一次。
- en: 'We should be on the last loop iteration, so let’s step forward one instruction
    and make sure that the jump isn’t taken:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该处于最后一次循环迭代，因此让我们执行一步指令并确保跳转没有发生：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Usually, <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> will jump
    back to the start of the loop, but on the last iteration it moves forward to the
    next instruction.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，<samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> 会跳回循环的起始位置，但在最后一次迭代时，它会跳到下一条指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting Help</samp>
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">获取帮助</samp>
- en: 'To learn about commands and options that we didn’t cover here, see the GDB
    documentation at *[https://<wbr>sourceware<wbr>.org<wbr>/gdb<wbr>/current<wbr>/onlinedocs<wbr>/gdb<wbr>/index<wbr>.html](https://sourceware.org/gdb/current/onlinedocs/gdb/index.html)*.
    As you saw earlier, you can also type <samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp>
    at the prompt to learn more about any GDB command. For example, to see the documentation
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp> command, type:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们在此未涵盖的命令和选项，请参阅 GDB 文档，访问 *[https://<wbr>sourceware<wbr>.org<wbr>/gdb<wbr>/current<wbr>/onlinedocs<wbr>/gdb<wbr>/index<wbr>.html](https://sourceware.org/gdb/current/onlinedocs/gdb/index.html)*。正如你之前看到的，你也可以在提示符下输入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> 来了解更多有关 GDB 命令的信息。例如，要查看
    <samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp> 命令的文档，请输入：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Table A-1](#tabA-1) summarizes the commands and options we covered, including
    full and abbreviated forms for each command (except <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    which can’t be abbreviated any further). Both forms take the same arguments.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 A-1](#tabA-1) 总结了我们所介绍的命令和选项，包括每个命令的完整形式和简写形式（除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>，它无法进一步简化）。这两种形式接受相同的参数。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table A-1:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Summary of GDB Commands</samp>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 A-1：</samp> <samp class="SANS_Futura_Std_Book_11">GDB
    命令汇总</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Command</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">命令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp> | <samp class="SANS_Futura_Std_Book_11">Start
    the program.</samp> |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp> | <samp class="SANS_Futura_Std_Book_11">启动程序。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> | <samp class="SANS_Futura_Std_Book_11">Resume
    the program.</samp> |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> | <samp class="SANS_Futura_Std_Book_11">恢复程序。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">finish</samp> | <samp class="SANS_Futura_Std_Book_11">Resume
    the program and continue until the current function exits.</samp> |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">finish</samp> | <samp class="SANS_Futura_Std_Book_11">恢复程序，并继续执行直到当前函数退出。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fin</samp> |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fin</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">Execute
    one instruction (or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp>
    <samp class="SANS_Futura_Std_Book_11">instructions), stepping into function calls.</samp>
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">执行一条指令（或</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">条指令），进入函数调用。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">Execute
    one instruction (or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp>
    <samp class="SANS_Futura_Std_Book_11">instructions), stepping over function calls.</samp>
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">执行一条指令（或</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">条指令），跳过函数调用。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ni</samp> |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ni</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><loc></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a breakpoint at</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><loc></samp>
    <samp class="SANS_Futura_Std_Book_11">(conditional on</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp><samp
    class="SANS_Futura_Std_Book_11">, if provided).</samp> |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><loc></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">在</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><loc></samp> <samp class="SANS_Futura_Std_Book_11">设置断点（如果提供，则基于</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp><samp class="SANS_Futura_Std_Book_11">进行条件设置）。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">info break</samp> | <samp class="SANS_Futura_Std_Book_11">List
    all breakpoints. (Other</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">info</samp>
    <samp class="SANS_Futura_Std_Book_11">subcommands display other information.)</samp>
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">info break</samp> | <samp class="SANS_Futura_Std_Book_11">列出所有断点。（其他的</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">info</samp> <samp class="SANS_Futura_Std_Book_11">子命令显示其他信息。）</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">i b</samp> |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">i b</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">delete [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><id></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">Delete
    all breakpoints (or the breakpoint specified by</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><id></samp><samp
    class="SANS_Futura_Std_Book_11">).</samp> |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">delete [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><id></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">删除所有断点（或删除由</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><id></samp><samp class="SANS_Futura_Std_Book_11">指定的断点）。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">print/<</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">format>
    <expr></samp> | <samp class="SANS_Futura_Std_Book_11">Evaluate</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><expr></samp>
    <samp class="SANS_Futura_Std_Book_11">and display the result according to format
    specifier</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">print/<</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">format>
    <expr></samp> | <samp class="SANS_Futura_Std_Book_11">求值</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><expr></samp>
    <samp class="SANS_Futura_Std_Book_11">并根据格式说明符</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp><samp
    class="SANS_Futura_Std_Book_11">显示结果。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n><format><unit></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">addr></samp>
    | <samp class="SANS_Futura_Std_Book_11">Print out memory starting at</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp> <samp class="SANS_Futura_Std_Book_11">in</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">chunks
    of size</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><unit></samp><samp
    class="SANS_Futura_Std_Book_11">, formatted according to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n><format><unit></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">addr></samp>
    | <samp class="SANS_Futura_Std_Book_11">从</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp>
    <samp class="SANS_Futura_Std_Book_11">开始打印内存</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp>
    <samp class="SANS_Futura_Std_Book_11">个大小为</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><unit></samp><samp
    class="SANS_Futura_Std_Book_11">的块，按照</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp><samp
    class="SANS_Futura_Std_Book_11">格式化。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">layout</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><window></samp>
    | <samp class="SANS_Futura_Std_Book_11">Open</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><window></samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">layout</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><window></samp>
    | <samp class="SANS_Futura_Std_Book_11">打开</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><window></samp><samp
    class="SANS_Futura_Std_Book_11">。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">la</samp> |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">la</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">focus</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><window></samp>
    | <samp class="SANS_Futura_Std_Book_11">Change focus to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><window></samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">focus</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><window></samp>
    | <samp class="SANS_Futura_Std_Book_11">将焦点更改为</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><window></samp><samp
    class="SANS_Futura_Std_Book_11">。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fs</samp> |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fs</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cmd></samp>
    | <samp class="SANS_Futura_Std_Book_11">Display help text about</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cmd></samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cmd></samp>
    | <samp class="SANS_Futura_Std_Book_11">显示关于</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cmd></samp><samp
    class="SANS_Futura_Std_Book_11">的帮助文本。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> |'
- en: Now you’re ready to start debugging with GDB!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您准备好使用GDB开始调试了！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Debugging with LLDB</samp>
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用LLDB调试</samp>
- en: 'Run this command to start up LLDB:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令以启动LLDB：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will set <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp>
    as the executable to debug but won’t execute it yet. If prompted, enter your username
    and password to give LLDB permission to control <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp>.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置<sup class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</sup>为调试的可执行文件，但不会立即执行它。如果提示，请输入您的用户名和密码以授权LLDB控制<sup
    class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</sup>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Starting and Stopping
    the Program</samp>
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">启动和停止程序</samp>
- en: Next, we’ll set a *breakpoint*—a location where the debugger will pause the
    program—and run the program up to that breakpoint. If we start the program without
    setting a breakpoint first, it will run all the way through without stopping,
    which isn’t very useful.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置一个*断点*——调试器将暂停程序的位置——并运行程序直到该断点。如果我们在没有首先设置断点的情况下启动程序，它将一直运行到结束，这样就没什么用处了。
- en: 'Let’s set a breakpoint at the entrance to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在<sup class="SANS_TheSansMonoCd_W5Regular_11">main</sup>入口处设置一个断点：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> may be at
    a different memory address on your machine. The <samp class="SANS_TheSansMonoCd_W5Regular_11">break
    set</samp> command creates a new breakpoint; the <samp class="SANS_TheSansMonoCd_W5Regular_11">-n</samp>
    option specifies the name of the function where we want to break. We’ll look at
    other ways to set breakpoints in a moment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>函数可能在您机器上的内存地址不同。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break set</samp>命令创建了一个新的断点；<samp class="SANS_TheSansMonoCd_W5Regular_11">-n</samp>选项指定了我们希望设置断点的函数名称。稍后我们将了解其他设置断点的方法。
- en: 'Now let’s run the program:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行程序：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">stop reason</samp> ❶ tells
    us that the program has hit the breakpoint we just set. LLDB also helpfully tells
    us that we’re stopped in the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function in <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp>
    ❷ and prints out the next few assembly instructions ❸.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">stop reason</samp> ❶ 告诉我们程序已命中我们刚设置的断点。LLDB还贴心地告诉我们，我们已暂停在<sup
    class="SANS_TheSansMonoCd_W5Regular_11">main</sup>函数中，并打印出接下来的几条汇编指令 ❸。
- en: 'Once a program is paused, there are a few commands we can use to keep executing
    it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序被暂停，我们可以使用一些命令继续执行它：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">continue</samp> resumes the program
    and runs until we hit another breakpoint or exit.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">continue</samp> 恢复程序运行，直到遇到另一个断点或程序退出。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">finish</samp> resumes the program
    and pauses again when we return from the current function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">finish</samp> 恢复程序运行，当我们从当前函数返回时再次暂停。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">stepi</samp> executes the next
    instruction, then pauses. It steps into <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instructions, pausing at the first instruction in the callee. The command <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stepi -c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp>
    steps through *n* instructions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">stepi</samp> 执行下一条指令，然后暂停。它会进入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> 指令，暂停在被调用函数中的第一条指令。命令
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi -c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp>
    会逐步执行 *n* 条指令。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">nexti</samp> executes the next
    instruction, then pauses. It steps over <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instructions, pausing at the next instruction after <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    in the current function. The command <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti
    -c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp> steps
    through *n* instructions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">nexti</samp> 执行下一条指令，然后暂停。它会跳过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> 指令，暂停在当前函数中 <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    后的下一条指令。命令 <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti -c</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp> 会逐步执行 *n* 条指令。
- en: Most LLDB commands have several aliases. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    is a shortcut for <samp class="SANS_TheSansMonoCd_W5Regular_11">process continue</samp>,
    and it can be shortened even further to the one-letter command <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
    See [Table A-2](#tabA-2) on [page 697](#pg_697) for full and abbreviated versions
    of all the commands we cover.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 LLDB 命令都有多个别名。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">process continue</samp> 的快捷方式，甚至可以进一步简化为一个字母命令
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>。有关我们涵盖的所有命令的完整版本和简化版本，请参阅
    [表 A-2](#tabA-2) 和 [第 697 页](#pg_697)。
- en: 'Let’s try out these new commands. First, we’ll execute four instructions, which
    should take us into the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试这些新命令。首先，我们将执行四条指令，应该会进入对 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    函数的调用：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can see from the command output that we’re stopped in <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> ❶. Now we’ll
    return from <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令输出中可以看到，我们停在了 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 函数而不是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> ❶。现在我们将从 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    返回：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This puts us back in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    at the instruction right after <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp>.
    Let’s continue:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带回到 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>，并停在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">callq</samp> 后的指令。让我们继续：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since we didn’t hit any more breakpoints, the program ran until it exited.
    To keep debugging it, we have to restart it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有遇到更多的断点，程序一直运行直到退出。要继续调试它，我们必须重新启动程序：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we’re paused at the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    again. Once again, we’ll move forward four instructions, but this time we’ll use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti</samp> to step over <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f</samp> instead of stepping into it:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数的开头暂停。我们将再次向前执行四条指令，但这次我们将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti</samp> 跳过 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>，而不是进入它：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This puts us back at the instruction right after <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp>.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带回到 <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp> 后的指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Breakpoints by Address</samp>
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">按地址设置断点</samp>
- en: 'In addition to setting breakpoints on functions, you can break on specific
    machine instructions. Let’s set a breakpoint on the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    0xdeadbeef, -4(%rbp)</samp>. First, we need to find this instruction’s address.
    Luckily, LLDB has already given us this information. The output from the last
    command should look something like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在函数上设置断点之外，你还可以在特定的机器指令上设置断点。我们来在指令<samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    0xdeadbeef, -4(%rbp)</samp>上设置一个断点。首先，我们需要找到该指令的地址。幸运的是，LLDB已经给出了这个信息。上一条命令的输出应该像这样：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This shows the next few instructions, including the one we want to break on.
    We can see that instruction’s memory address ❶ and the byte offset of that address
    from the start of the function ❷. The exact address may be different on your machine,
    but the offset should be the same. To set this breakpoint, type
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了接下来的几条指令，包括我们想要设置断点的那条。我们可以看到该指令的内存地址❶以及该地址相对于函数开始位置的字节偏移量❷。准确的地址在你的机器上可能不同，但偏移量应该是相同的。要设置这个断点，输入
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">MEMORY_ADDRESS</samp>
    is the instruction’s address on your machine. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-a</samp>
    option indicates that we’re specifying an address rather than a function name.
    We can also use more complex expressions to specify instruction addresses. Here’s
    another way to set a breakpoint on the same instruction:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">MEMORY_ADDRESS</samp>是该指令在你机器上的地址。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-a</samp>选项表示我们指定的是地址而不是函数名称。我们还可以使用更复杂的表达式来指定指令的地址。以下是另一种设置断点在同一指令上的方法：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we cast <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> to
    a function type so that LLDB can use it in address calculations. (It doesn’t matter
    which function type we cast it to.) Then, we add a 26-byte offset to get the address
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction we
    want to break on. Since this address expression includes spaces and special characters,
    we have to wrap the whole thing in quotes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>转换为函数类型，这样LLDB就可以在地址计算中使用它。（我们可以将其转换为任何函数类型。）然后，我们加上26字节的偏移量，以获取我们想要在其上设置断点的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>指令的地址。由于这个地址表达式包含空格和特殊字符，我们必须将整个表达式用引号括起来。
- en: In a minute, we’ll see how to disassemble the whole function and see every instruction’s
    address. First, let’s look at a couple of other useful commands for managing breakpoints.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一会儿我们将看到如何反汇编整个函数，并查看每条指令的地址。首先，让我们看看一些管理断点的其他有用命令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Managing Breakpoints</samp>
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">管理断点</samp>
- en: 'Let’s list all the breakpoints we’ve set:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出所有已经设置的断点：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Every breakpoint has a unique number, which you can refer to if you need to
    delete, disable, or modify it. In the last section, we set breakpoints 2 and 3
    at the same location, <samp class="SANS_TheSansMonoCd_W5Regular_11">main+26</samp>.
    Let’s delete one of them:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每个断点都有一个唯一的编号，如果你需要删除、禁用或修改它，可以通过这个编号来引用。在上一节中，我们在相同的位置<samp class="SANS_TheSansMonoCd_W5Regular_11">main+26</samp>设置了断点2和3。我们来删除其中一个：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Next, we’ll look at how to display all the assembly instructions in a function,
    along with their addresses.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何显示一个函数中的所有汇编指令，以及它们的地址。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Displaying Assembly
    Code</samp>
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">显示汇编代码</samp>
- en: 'The command <samp class="SANS_TheSansMonoCd_W5Regular_11">disassemble -n</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><function name></samp>
    tells LLDB to print out all the assembly instructions in a function. Let’s try
    this out on <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 命令<samp class="SANS_TheSansMonoCd_W5Regular_11">disassemble -n</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><function name></samp>告诉LLDB打印出一个函数中的所有汇编指令。我们可以尝试在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp>上运行这个命令：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> symbol points to
    the current instruction. We can also print out a fixed number of instructions,
    starting at a specific address. Let’s disassemble five instructions, starting
    with the third instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    In the disassembled code shown here, this instruction’s address is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100003f69</samp>;
    it might have a different address on your machine. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp>
    option specifies the address where LLDB should start disassembling, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> specifies how many instructions
    to display, so we’ll disassemble these five instructions with the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> 符号指向当前指令。我们还可以打印出固定数量的指令，从特定地址开始。让我们从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 中的第三条指令开始，反汇编五条指令。在这里显示的反汇编代码中，该指令的地址是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100003f69</samp>；在您的机器上，它可能有不同的地址。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-s</samp> 选项指定了 LLDB 开始反汇编的地址，<samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    选项指定了要显示的指令数量，因此我们将使用以下命令反汇编这五条指令：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--pc</samp>
    option to start disassembling at the current instruction:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--pc</samp> 选项从当前指令开始反汇编：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This command displays three instructions, starting with the current instruction.
    We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> option
    when we specify a starting address with <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">--pc</samp> but not when we disassemble
    a whole function with <samp class="SANS_TheSansMonoCd_W5Regular_11">-n</samp>.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令显示三条指令，从当前指令开始。当我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">--pc</samp> 指定起始地址时，可以使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> 选项，但在使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-n</samp>
    反汇编整个函数时则不能使用该选项。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Printing Expressions</samp>
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">打印表达式</samp>
- en: 'You can evaluate expressions with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">exp
    -f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><expr></samp>,
    where:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用命令 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp -f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><expr></samp>
    来评估表达式，其中：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><format></samp> is a format
    specifier that tells LLDB how to display the result of the expression.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><format></samp> 是一种格式说明符，告诉
    LLDB 如何显示表达式的结果。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><expr></samp> is an arbitrary
    expression. This expression can refer to registers, memory addresses, and symbols
    in the running program. It can also include C operations like arithmetic, pointer
    dereferencing, and cast expressions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><expr></samp> 是一个任意表达式。该表达式可以引用寄存器、内存地址和正在运行程序中的符号。它还可以包括
    C 操作，例如算术运算、指针解引用和类型转换表达式。
- en: 'Let’s try some examples. Right now, the program should be paused at the instruction
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0x87654321, %eax</samp>. We’ll
    step through this instruction, then print out the value of EAX in a few different
    formats:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些例子。目前，程序应该在指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0x87654321,
    %eax</samp> 处暂停。我们将逐步执行该指令，然后以不同的格式打印出 EAX 的值：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: By default, LLDB formats the values in general-purpose registers as unsigned
    integers ❶. Here, we also display the value of EAX in hexadecimal ❷ and as a signed
    integer ❸. (For a full list of formats, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">help
    format</samp> command.) The symbols <samp class="SANS_TheSansMonoCd_W5Regular_11">$0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">$1</samp>, and so on are *convenience
    variables*, which LLDB automatically generates to store the result of each expression.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，LLDB 将通用寄存器中的值格式化为无符号整数 ❶。在这里，我们还将 EAX 的值显示为十六进制 ❷ 和带符号整数 ❸。（要查看完整的格式列表，可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">help format</samp> 命令。）符号 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">$0</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">$1</samp>
    等是 *便利变量*，LLDB 会自动生成这些变量来存储每个表达式的结果。
- en: '[Chapter 13](chapter13.xhtml) introduces the XMM registers, which hold floating-point
    values. The next instruction in our program, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd
    dbl(%rip), %xmm0</samp>, copies the value <samp class="SANS_TheSansMonoCd_W5Regular_11">3.5</samp>
    from the static <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp> variable
    into XMM0\. Let’s step through this instruction, then inspect XMM0\. We’ll use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">float64[]</samp> format, which
    displays the register’s contents as an array of two doubles:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章](chapter13.xhtml)介绍了 XMM 寄存器，它们保存浮点值。程序中的下一条指令，<samp class="SANS_TheSansMonoCd_W5Regular_11">movsd
    dbl(%rip), %xmm0</samp>，将静态变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp>
    中的值 <samp class="SANS_TheSansMonoCd_W5Regular_11">3.5</samp> 复制到 XMM0 中。让我们逐步执行这条指令，然后检查
    XMM0。我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">float64[]</samp> 格式，它将寄存器的内容显示为两个
    double 数值的数组：'
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first array element corresponds to the register’s lower 64 bits ❶, which
    we updated with the <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    instruction. The second element corresponds to the register’s upper 64 bits, which
    we can ignore.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数组元素对应于寄存器的低 64 位 ❶，我们已经使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    指令更新了它。第二个元素对应于寄存器的高 64 位，我们可以忽略它。
- en: 'In addition to registers, we can print out the values of objects in the symbol
    table. Let’s inspect the two static variables in this program, <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp>:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了寄存器外，我们还可以打印符号表中对象的值。让我们检查一下程序中的两个静态变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp>：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now let’s look at a few examples of more complex expressions. We can perform
    basic arithmetic:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看几个更复杂表达式的例子。我们可以进行基本的算术运算：
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can call functions from the current program or the standard library. Here
    we call <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>, which returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用当前程序或标准库中的函数。这里我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>，它返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>：
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can also dereference pointers. Let’s execute the next instruction, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl 0xdeadbeef, -4(%rbp)</samp>, then
    inspect the value at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以解引用指针。让我们执行下一条指令，<samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0xdeadbeef,
    -4(%rbp)</samp>，然后检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    处的值：
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: First, we calculate the memory address we want to inspect, <samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp
    - 4</samp>. Then, we cast this address to the correct pointer type, <samp class="SANS_TheSansMonoCd_W5Regular_11">(int
    *)</samp>. Finally, we dereference it with the dereference operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>.
    This produces an integer, which we print out in hexadecimal with the option <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-f x</samp>.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算出要检查的内存地址，<samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp - 4</samp>。然后，我们将此地址转换为正确的指针类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(int *)</samp>。最后，我们使用解引用操作符 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    对其进行解引用。这将生成一个整数，我们可以使用选项 <samp class="SANS_TheSansMonoCd_W5Regular_11">-f x</samp>
    以十六进制形式打印出来。
- en: Next, we’ll look at a more flexible way to inspect values in memory.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看一种更灵活的方式来检查内存中的值。
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Examining Memory</samp>'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检查内存</samp>'
- en: 'We can examine memory with the <samp class="SANS_TheSansMonoCd_W5Regular_11">memory
    read</samp> command. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>,
    it takes an arbitrary expression, which must evaluate to a valid memory address.
    This gives us another way to inspect the integer at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">memory read</samp> 命令检查内存。像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> 一样，它接受一个任意表达式，该表达式必须评估为有效的内存地址。这为我们提供了另一种检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp> 处整数的方式：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-f x</samp> option says to
    print the output in hexadecimal; <samp class="SANS_TheSansMonoCd_W5Regular_11">-s
    4</samp> says to interpret the contents of memory as a sequence of 4-byte values;
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-c 1</samp> says to print just
    one of those values. In other words, this command prints out the single 4-byte
    integer at <samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp - 4</samp>, formatted
    as hexadecimal. We have to wrap the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp
    - 4</samp> in quotes because it contains spaces.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-f x</samp> 选项表示以十六进制格式打印输出；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-s 4</samp> 表示将内存内容解释为 4 字节的值序列；而 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-c 1</samp> 表示只打印其中一个值。换句话说，这条命令打印出 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">$rbp - 4</samp> 处的单个 4 字节整数，并以十六进制格式显示。我们必须将表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp - 4</samp> 包含在引号中，因为它包含空格。
- en: 'The next three instructions in [Listing A-1](#listA-1) store three more integers
    on the stack:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 A-1](#listA-1) 中的接下来的三条指令将另外三个整数存储到堆栈上：'
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let’s step through these instructions, then print out the whole stack frame.
    We’ll tell LLDB to print out six 4-byte words, starting at the address in RSP.
    We’ll use the option <samp class="SANS_TheSansMonoCd_W5Regular_11">-l 1</samp>
    to print out each word on a separate line:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步执行这些指令，然后打印出整个堆栈帧。我们会告诉 LLDB 打印出六个 4 字节的字，从 RSP 中的地址开始。我们将使用选项 <samp class="SANS_TheSansMonoCd_W5Regular_11">-l
    1</samp> 让每个字打印在单独的一行上：
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We print out six words because the stack is 24 bytes in this particular function.
    At the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, we
    saved the old value of RBP onto the stack. That’s 8 bytes. Then, we allocated
    another 16 bytes with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">subq
    $16, %rsp</samp>. Keep in mind that RSP always holds the address of the top of
    the stack, which is the *lowest* stack address.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出六个字是因为在这个特定函数中堆栈是 24 字节的。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数开始时，我们将旧的 RBP 值保存到堆栈中。那是 8 字节。然后，我们用命令 <samp class="SANS_TheSansMonoCd_W5Regular_11">subq
    $16, %rsp</samp> 分配了另外 16 字节。请记住，RSP 始终保存堆栈顶部的地址，也就是 *最低* 的堆栈地址。
- en: 'This command shows us the four integers we saved to the stack, with <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfeedface</samp>
    at the top ❶ and the old value of RBP at the bottom ❷. Since the value at ❷ is
    really an 8-byte address, we can read it more easily if we group the stack into
    8-byte values:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这条命令显示了我们保存到堆栈中的四个整数，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfeedface</samp>
    在最上面 ❶，而旧的 RBP 值在最下面 ❷。由于 ❷ 处的值实际上是一个 8 字节的地址，我们可以更容易地读取它，如果我们将堆栈分组为 8 字节的值：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now it’s clear that the bottom 8 bytes on the stack hold a single memory address
    ❶.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很清楚，堆栈底部的 8 字节保存着一个单一的内存地址 ❶。
- en: 'Just below the saved value of RBP, on top of the caller’s stack frame, we’d
    expect to find the caller’s return address—that is, the address we’ll jump to
    when we return from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    (We cover this in detail when we implement function calls in [Chapter 9](chapter9.xhtml).)
    Let’s inspect this address:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接在保存的 RBP 值下方，即调用者的堆栈帧上方，我们应该会找到调用者的返回地址——也就是我们从 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    返回时跳转的地址。（当我们在 [第 9 章](chapter9.xhtml) 中实现函数调用时，会详细讲解这一部分。）让我们检查一下这个地址：
- en: '[PRE62]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This command is almost identical to the previous one, except that we use the
    option <samp class="SANS_TheSansMonoCd_W5Regular_11">-c 4</samp> to print out
    four values instead of three and the option <samp class="SANS_TheSansMonoCd_W5Regular_11">-f
    A</samp> to format each value as a memory address. The <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    format specifier tells LLDB to print each address in hexadecimal and, if possible,
    print out its offset from the nearest symbol in the program. Because function
    and static variable names are defined in the symbol table, LLDB can display the
    relative offsets of assembly instructions and static data. It won’t display relative
    offsets of stack addresses, heap addresses, or invalid addresses, because they
    would be completely meaningless.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这条命令与前一条几乎相同，唯一的区别是我们使用了选项 <samp class="SANS_TheSansMonoCd_W5Regular_11">-c
    4</samp> 来打印出四个值而不是三个，使用选项 <samp class="SANS_TheSansMonoCd_W5Regular_11">-f A</samp>
    来将每个值格式化为内存地址。<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> 格式说明符告诉 LLDB
    以十六进制打印每个地址，并且如果可能的话，打印出其相对于程序中最近符号的偏移量。由于函数和静态变量名称在符号表中定义，LLDB 可以显示汇编指令和静态数据的相对偏移量。它不会显示堆栈地址、堆地址或无效地址的相对偏移量，因为它们完全没有意义。
- en: The first three lines of output are the same as before. The first two values
    aren’t valid memory addresses and the third is a stack address, so LLDB can’t
    display their offsets from symbols. The next value on the stack is the return
    address ❶. The label <samp class="SANS_TheSansMonoCd_W5Regular_11">dyld`start</samp>
    tells us this is the address of an instruction in the <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>
    function in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dyld</samp> shared
    library. (The <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> function
    is responsible for calling <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    and cleaning up after it exits; <samp class="SANS_TheSansMonoCd_W5Regular_11">dyld</samp>
    is the dynamic linker.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前三行与之前相同。前两个值不是有效的内存地址，第三个是栈地址，因此 LLDB 无法显示它们与符号的偏移量。栈上的下一个值是返回地址 ❶。标签 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dyld`start</samp> 告诉我们这是 <samp class="SANS_TheSansMonoCd_W5Regular_11">dyld</samp>
    动态库中 <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> 函数中某条指令的地址。（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">start</samp> 函数负责调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    并在其退出后进行清理；<samp class="SANS_TheSansMonoCd_W5Regular_11">dyld</samp> 是动态链接器。）
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-f A</samp> option makes it
    easy to spot return addresses and pointers to static variables. This is particularly
    useful if your program’s stack frame is corrupted; finding each stack frame’s
    return address can help you get your bearings.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-f A</samp> 选项使得找到返回地址和指向静态变量的指针变得容易。这在程序的栈帧损坏时特别有用；找到每个栈帧的返回地址有助于你重新确定位置。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Conditional
    Breakpoints</samp>
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设置条件断点</samp>
- en: To wrap up this walk-through, we’ll look at how to set *conditional breakpoints*.
    The program will pause at a conditional breakpoint only if the associated condition
    is true. This condition can be an arbitrary expression; LLDB will consider it
    false if it evaluates to 0 and true otherwise.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次演练的最后，我们将介绍如何设置 *条件断点*。程序仅在关联的条件为真时才会在条件断点处暂停。这个条件可以是任意表达式；如果它的计算结果为 0，LLDB
    会认为它为假，否则为真。
- en: 'Let’s set a breakpoint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp>
    instruction at the end of the last loop iteration in <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp>.
    First, we’ll find this instruction’s address in the disassembled <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp> 的最后一个循环迭代的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> 指令处设置一个断点。首先，我们将在反汇编的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数中找到此指令的地址：
- en: '[PRE63]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100003fa6</samp> ❶. Now we’ll
    set a conditional breakpoint to pause on the <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp>
    instruction if ECX is 0\. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    option to specify a condition:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> 的地址是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100003fa6</samp>
    ❶。现在我们将设置一个条件断点，当 ECX 为 0 时暂停在 <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp>
    指令上。我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> 选项来指定条件：
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Since this loop repeats until ECX is 0, the condition <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    will be true only on the last iteration. Let’s continue until the breakpoint,
    then verify that this condition is true:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该循环会重复执行直到 ECX 为 0，条件 <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    仅在最后一次迭代时为真。让我们继续执行直到断点，然后验证这个条件是否为真：
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you get a different value for ECX, check whether you set the breakpoint
    correctly:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到不同的 ECX 值，请检查是否正确设置了断点：
- en: '[PRE66]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Make sure that your breakpoint includes the condition <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    ❶ and that it’s at the location <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger`main</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">65</samp>
    ❷. If your breakpoint looks different, you might have mistyped something; delete
    it and try again.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的断点包含条件 <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> ❶，并且位于位置 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger`main</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">65</samp>
    ❷。如果你的断点看起来不同，可能是打字错误；删除它并重新尝试。
- en: 'We should be on the last loop iteration, so let’s step forward one instruction
    and make sure that the jump isn’t taken:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在最后一次循环迭代，所以让我们向前执行一条指令，确保跳转没有发生：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Usually, <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> will jump
    back to the start of the loop, but on the last iteration it moves forward to the
    next instruction.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，<samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> 会跳回循环的开始，但在最后一次迭代时，它会跳到下一条指令。
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting Help</samp>'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">获取帮助</samp>'
- en: 'To learn more about the commands and options we didn’t cover here, see the
    LLDB documentation at *[https://<wbr>lldb<wbr>.llvm<wbr>.org<wbr>/index<wbr>.html](https://lldb.llvm.org/index.html)*.
    You can also type <samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> at
    the prompt to learn more about any LLDB command. For example, to see the documentation
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp> command, type:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多我们未在此覆盖的命令和选项，请参阅 LLDB 文档，链接为 *[https://<wbr>lldb<wbr>.llvm<wbr>.org<wbr>/index<wbr>.html](https://lldb.llvm.org/index.html)*。你还可以在提示符下键入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> 来了解更多关于任何 LLDB 命令的信息。例如，要查看
    <samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp> 命令的文档，请键入：
- en: '[PRE68]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[Table A-2](#tabA-2) summarizes the commands and options we covered. The version
    of each command that we used in the walk-through is listed first, followed by
    a shorter abbreviation (except for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>,
    which isn’t normally shortened further), then the full form when it differs from
    the one we used. All versions of each command take the same arguments.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 A-2](#tabA-2) 总结了我们所覆盖的命令和选项。我们在演示中使用的每个命令版本会列在前面，后跟更短的缩写（<samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    除外，通常不会进一步缩写），然后是当与我们使用的版本不同的完整形式。每个命令的所有版本都接受相同的参数。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table A-2:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Summary of LLDB Commands</samp>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 A-2：</samp> <samp class="SANS_Futura_Std_Book_11">LLDB
    命令总结</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Command</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">命令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp> | <samp class="SANS_Futura_Std_Book_11">Start
    the program.</samp> |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp> | <samp class="SANS_Futura_Std_Book_11">启动程序。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">process launch --</samp> |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">process launch --</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> | <samp class="SANS_Futura_Std_Book_11">Resume
    the program.</samp> |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> | <samp class="SANS_Futura_Std_Book_11">恢复程序。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">process continue</samp> |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">process continue</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">finish</samp> | <samp class="SANS_Futura_Std_Book_11">Resume
    the program and continue until the current function exits.</samp> |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">finish</samp> | <samp class="SANS_Futura_Std_Book_11">恢复程序，并继续执行直到当前函数退出。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fin</samp> |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fin</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">thread step-out</samp> |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">thread step-out</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi [-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">Execute
    one instruction (or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp>
    <samp class="SANS_Futura_Std_Book_11">instructions), stepping into function calls.</samp>
    |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi [-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">执行一条指令（或</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">条指令），并进入函数调用。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">thread step-inst</samp> |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">线程步进-指令</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti [-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">Execute
    one instruction (or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp>
    <samp class="SANS_Futura_Std_Book_11">instructions), stepping over function calls.</samp>
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti [-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><n></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">执行一条指令（或</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">条指令），并跳过函数调用。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ni</samp> |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ni</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">thread step-inst-over</samp>
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">线程步进-指令覆盖</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">break set [-n</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><fun></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;
    -a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[-c</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp><samp class="SANS_Futura_Std_Book_11">]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Set a breakpoint at start of function</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><fun></samp> <samp class="SANS_Futura_Std_Book_11">or
    at address</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp>
    <samp class="SANS_Futura_Std_Book_11">(conditional on</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp><samp
    class="SANS_Futura_Std_Book_11">, if provided).</samp> |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">设置断点 [-n</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><fun></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124; -a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[-c</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp><samp class="SANS_Futura_Std_Book_11">]</samp>
    | <samp class="SANS_Futura_Std_Book_11">在函数</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><fun></samp>
    <samp class="SANS_Futura_Std_Book_11">的开始处或在地址</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp>
    <samp class="SANS_Futura_Std_Book_11">处设置断点（若提供，按</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp><samp
    class="SANS_Futura_Std_Book_11">进行条件设置）。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">br s</samp> |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">br s</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">breakpoint set</samp> |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">设置断点</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">break list</samp> | <samp class="SANS_Futura_Std_Book_11">List
    all breakpoints.</samp> |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">断点列表</samp> | <samp class="SANS_Futura_Std_Book_11">列出所有断点。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">br l</samp> |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">br l</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">breakpoint list</samp> |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">断点列表</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">break delete [</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><id></samp><samp class="SANS_Futura_Std_Book_11">]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Delete all breakpoints (or the breakpoint
    specified by</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><id></samp><samp
    class="SANS_Futura_Std_Book_11">).</samp> |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">删除断点 [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><id></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">删除所有断点（或指定的断点</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><id></samp><samp class="SANS_Futura_Std_Book_11">）。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">br del</samp> |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">删除 br</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">breakpoint delete</samp> |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">删除断点</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">exp -f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><expr></samp>
    | <samp class="SANS_Futura_Std_Book_11">Evaluate</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><expr></samp>
    <samp class="SANS_Futura_Std_Book_11">and display the result in format</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp><samp class="SANS_Futura_Std_Book_11">.</samp>
    |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">exp -f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><expr></samp>
    | <samp class="SANS_Futura_Std_Book_11">评估</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><expr></samp>
    <samp class="SANS_Futura_Std_Book_11">并以格式显示结果</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp><samp
    class="SANS_Futura_Std_Book_11">。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">expression</samp> |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">表达式</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memory read -f</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><size></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><num-per-line> <addr></samp>
    | <samp class="SANS_Futura_Std_Book_11">Print out memory in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp>
    <samp class="SANS_Futura_Std_Book_11">chunks of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><size></samp>
    <samp class="SANS_Futura_Std_Book_11">bytes, starting at address</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp><samp class="SANS_Futura_Std_Book_11">.
    Display</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><num</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">-per-line></samp> <samp
    class="SANS_Futura_Std_Book_11">chunks on each line in format</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memory read -f</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><size></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><num-per-line> <addr></samp>
    | <samp class="SANS_Futura_Std_Book_11">以</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp>
    <samp class="SANS_Futura_Std_Book_11">字节为单位打印内存块，起始地址为</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp><samp
    class="SANS_Futura_Std_Book_11">。</samp> <samp class="SANS_Futura_Std_Book_11">在每行中以格式显示</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><format></samp><samp class="SANS_Futura_Std_Book_11">的内存块</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><num-per-line></samp><samp
    class="SANS_Futura_Std_Book_11">。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">me read</samp> |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">我读取</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">disassemble [-n</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><fun></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;
    -s</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124; --pc -c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">Disassemble
    all instructions in function</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><fun></samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp>
    <samp class="SANS_Futura_Std_Book_11">instructions starting at address</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp><samp class="SANS_Futura_Std_Book_11">,
    or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp>
    <samp class="SANS_Futura_Std_Book_11">instructions starting at the current instruction.</samp>
    |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">disassemble [-n</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><fun></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;
    -s</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124; --pc -c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp><samp
    class="SANS_Futura_Std_Book_11">]</samp> | <samp class="SANS_Futura_Std_Book_11">反汇编函数</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><fun></samp><samp class="SANS_Futura_Std_Book_11">中的所有指令，或者</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp> <samp class="SANS_Futura_Std_Book_11">从地址</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><addr></samp><samp class="SANS_Futura_Std_Book_11">开始的指令，或者</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><count></samp> <samp class="SANS_Futura_Std_Book_11">从当前指令开始的指令。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">di</samp> |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">di</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cmd></samp>
    | <samp class="SANS_Futura_Std_Book_11">Display help text about</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cmd></samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cmd></samp>
    | <samp class="SANS_Futura_Std_Book_11">显示有关</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cmd></samp><samp
    class="SANS_Futura_Std_Book_11">的帮助文本。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> |'
- en: Now you’re ready to start debugging with LLDB!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好开始使用 LLDB 进行调试了！
