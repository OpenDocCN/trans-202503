- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONTROLLING
    AC MAINS POWER OUTLETS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">控制交流电源插座</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: In this chapter, you’ll learn to safely control mains AC power outlets using
    various forms of automation and remote control. This technique lets you easily
    manipulate devices such as lamps, fans, and pumps from a distance, without any
    direct connection to the mains power wiring.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学会如何通过各种自动化和远程控制方式安全地控制主电源交流插座。此技术让你能够轻松地从远程操作设备，如灯具、风扇和水泵，而无需与主电源线路直接连接。
- en: 'You’ll learn to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学到：
- en: Use optocouplers to isolate electrical signals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光耦合器来隔离电气信号
- en: Hack a wireless AC mains remote-control transmitter and connect it to an Arduino
    circuit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改装无线交流电源远程控制发射器，并将其连接到Arduino电路
- en: Create a timer-controlled wireless AC mains outlet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个定时控制的无线交流电源插座
- en: Control AC mains outlets remotely with SMS text messages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用短信控制远程交流电源插座
- en: <samp class="SANS_Futura_Std_Bold_B_11">Optocouplers</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">光耦合器</samp>
- en: An *optocoupler* is a small device that allows the transmission of a signal
    between parts of a circuit while keeping those two parts electrically isolated.
    Inside a typical optocoupler are an LED and a phototransistor, a device that responds
    to light by amplifying an electric current. When a current runs through the LED,
    it switches on; the phototransistor detects the light and allows another current
    to flow through it. When the LED is off, current cannot flow through the phototransistor.
    The two currents are completely electrically isolated throughout the process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*光耦合器*是一种小型设备，它可以在电路的不同部分之间传输信号，同时保持这两部分电气隔离。在典型的光耦合器内部，有一个LED和一个光电晶体管，后者通过响应光线放大电流。当电流通过LED时，它会打开；光电晶体管检测到光线后，允许另一个电流通过。当LED关闭时，电流无法通过光电晶体管。整个过程中，这两个电流是完全电气隔离的。'
- en: '[Figure 7-1](chapter7.xhtml#fig7-1) shows the schematic symbol for an optocoupler.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-1](chapter7.xhtml#fig7-1)展示了光耦合器的原理符号。'
- en: '![THE SCHEMATIC SYMBOL FOR A TYPICAL OPTOCOUPLER](../images/fig7-1.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![典型光耦合器的原理符号](../images/fig7-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: The schematic symbol
    for a typical optocoupler</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-1：典型光耦合器的原理符号</samp>
- en: In the schematic, an LED is connected to pins 1 (the anode) and 2 (the cathode).
    Pins 4, 5, and 6 are the phototransistor, while pin 3 is not used. The optocoupler
    model you’ll use, the 4N28, is in a six-pin dual in-line (DIL) package, as shown
    in [Figure 7-2](chapter7.xhtml#fig7-2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在原理图中，LED连接到1引脚（阳极）和2引脚（阴极）。4、5、6引脚是光电晶体管，而3引脚没有使用。你将使用的光耦合器型号4N28是一个六脚双排直插（DIL）封装，如[图7-2](chapter7.xhtml#fig7-2)所示。
- en: '![A PHOTO OF A 4N28 OPTOCOUPLER INSERTED INTO A SOLDERLESS BREADBOARD](../images/fig7-2.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![插入无焊面包板中的4N28光耦合器的照片](../images/fig7-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: A 4N28 optocoupler
    inserted into a solderless breadboard</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-2：插入无焊面包板中的4N28光耦合器</samp>
- en: To use the optocoupler, you’ll need a current-limiting resistor for the LED.
    You’ll use 1 kΩ for this chapter. Connect the circuit to switch on or off across
    pins 4 and 5\. If you’d like to experiment with an optocoupler, build the circuit
    shown in [Figure 7-3](chapter7.xhtml#fig7-3).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用光耦合器时，你需要为LED添加一个限流电阻。在本章中，你将使用1 kΩ的电阻。将电路连接到4和5引脚之间的开关，以控制开关的开启或关闭。如果你想实验光耦合器，可以构建[图7-3](chapter7.xhtml#fig7-3)中显示的电路。
- en: '![THE SCHEMATIC FOR AN OPTOCOUPLER DEMONSTRATION CIRCUIT](../images/fig7-3.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![光耦合器演示电路的原理图](../images/fig7-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: An optocoupler
    demonstration circuit</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-3：光耦合器演示电路</samp>
- en: When SW[1] is closed, current runs through the resistor R[1], and the LED inside
    the optocoupler illuminates. This in turn triggers the photoresistor, which allows
    current to flow through from pin 5 to pin 4, turning on LED D[1]. Pin 3 on the
    optocoupler is not electrically connected. This makes the optocoupler a switch
    of sorts, without any electrical or mechanical contact between the two sides of
    the switch.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当SW[1]闭合时，电流通过电阻R[1]，光耦合器内的LED发光。接着，光电晶体管被触发，允许电流从5引脚流向4引脚，从而点亮LED D[1]。光耦合器的3引脚没有电气连接。这使得光耦合器像一个开关一样工作，但两侧之间没有任何电气或机械接触。
- en: You’ll use optocouplers to interface with the transmitter of the wireless remote
    AC outlet in the following projects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的项目中，你将使用光耦合器与无线遥控交流电插座的发射器进行接口连接。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Remote-Control AC Outlets</samp>
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">遥控交流电插座</samp>
- en: Inexpensive wireless remote-control AC outlets, like the one shown in [Figure
    7-4](chapter7.xhtml#fig7-4), allow you to safely control mains power. In [Figure
    7-4](chapter7.xhtml#fig7-4), the transmitter is on the right, and the receiver
    outlet is on the left.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 像[图 7-4](chapter7.xhtml#fig7-4)所示的廉价无线遥控交流电插座，能够安全地控制市电。在[图 7-4](chapter7.xhtml#fig7-4)中，发射器位于右侧，接收器插座位于左侧。
- en: '![A PHOTO OF THE EXAMPLE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER AND
    RECEIVER](../images/fig7-4.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![无线遥控交流电插座发射器和接收器的照片](../images/fig7-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: A typical wireless
    remote-control AC outlet</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-4：典型的无线遥控交流电插座</samp>
- en: 'The transmitter needs separate on and off buttons for control. Try to find
    one with as much space as possible between the buttons; the farther apart they
    are, the easier it will be to hack into the transmitter unit in Project #22, allowing
    you to connect it to an Arduino circuit to control the power outlet. You can find
    these units from the usual retailers, such as Amazon, Walmart, and so on.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器需要独立的开关按钮进行控制。尽量找一个按钮之间有较大间距的型号；按钮间距越大，在第22个项目中破解发射器时就越容易，这样可以将其连接到Arduino电路，以控制电源插座。你可以从常见零售商那里购买这些设备，如亚马逊、沃尔玛等。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">警告</samp>
- en: '*Under no circumstances are you to open or modify the receiver unit containing
    the mains outlet, as exposing yourself to mains wiring can be lethal.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*无论如何，你绝对不应打开或修改包含市电插座的接收器单元，因为暴露在市电线路中可能会致命。*'
- en: 'To work through this chapter, I recommend buying two sets of controls: one
    to experiment with (so you don’t need to worry too much about breaking it) and
    another to use for the project.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了顺利完成本章内容，我建议购买两套控制设备：一套用于实验（这样你就不用太担心弄坏它），另一套用于项目。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hacking the Outlet Transmitter</samp>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">破解插座发射器</samp>
- en: This section explains how to hack into your wireless transmitter to control
    it via an Arduino. I’ll show you with a series of photographs how I hacked into
    my remote, and you can use these guidelines to experiment with your remote to
    achieve the same goal. This requires some soldering and de-soldering, so be sure
    you’re equipped with a hobbyist 20 to 50 W soldering iron, hand tools such as
    side-cutters, and some de-soldering wick.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释如何破解无线发射器，并通过Arduino进行控制。我将通过一系列照片展示如何破解我的遥控器，你可以参考这些指导方针，对你的遥控器进行实验，达到相同的目的。此过程需要一定的焊接和拆焊操作，因此请确保你准备了一个20到50瓦的爱好者级焊接铁、一些手工工具（如侧切钳），以及一些拆焊丝。
- en: Transmitters will be slightly different in shape, size, and so on, but make
    sure the one you purchase runs from a little 12 V A23-style battery and has separate
    on and off buttons, as noted earlier. Before doing any damage to the unit, insert
    the battery and test it to get an idea of how far between the transmitter and
    receiver in which you can use the outlet. [Figure 7-5](chapter7.xhtml#fig7-5)
    shows the battery in my transmitter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器在形状、大小等方面会有所不同，但请确保你购买的发射器使用小型12V A23型电池，并且有独立的开关按钮，如前所述。在对设备进行任何损坏之前，插入电池并进行测试，以了解发射器与接收器之间的有效距离，从而确定你可以使用该插座的距离。[图
    7-5](chapter7.xhtml#fig7-5)展示了我发射器中的电池。
- en: '![A PHOTO OF A BATTERY INSIDE A WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER](../images/fig7-5.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![无线遥控交流电插座发射器内部的电池照片](../images/fig7-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: The battery in
    a wireless remote-control transmitter</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-5：无线遥控发射器中的电池</samp>
- en: Check for any screws or tabs you can use to pop the transmitter enclosure apart,
    and open it, as shown in [Figure 7-6](chapter7.xhtml#fig7-6).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否有任何螺丝或卡扣可以用来打开发射器外壳，并按照[图 7-6](chapter7.xhtml#fig7-6)所示将其打开。
- en: '![A PHOTO OF INSIDE THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER](../images/fig7-6.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![无线遥控交流电插座发射器内部的照片](../images/fig7-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: The wiring inside
    the wireless remote-control transmitter</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-6：无线遥控发射器内部接线</samp>
- en: This should reveal the PCB for the circuit, along with the buttons used to control
    the outputs. Carefully remove the PCB to check whether it looks possible to de-solder
    some of the buttons; if not, reassemble the unit and return it to your retailer.
    You should be able to de-solder buttons on any transmitters that fit the specs
    described earlier in this section, but it’s best to make sure, for example, that
    they’re the type that have buttons with through-hole pins.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这样应该能看到电路板和控制输出的按钮。小心地取下电路板，检查是否有可能去除某些按钮的焊接；如果不行，就重新组装设备并将其退还给零售商。对于符合本节之前描述规格的任何发射器，你应该能去除按钮，但最好确认这些按钮是通过孔脚的类型。
- en: You’ll also need to connect power. If there are already wires running from the
    battery holder to the PCB, like those shown in [Figure 7-7](chapter7.xhtml#fig7-7),
    carefully cut off or de-solder them using the solder wick from the battery holder
    ends.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要连接电源。如果电池架到电路板（PCB）之间已经有电线连接，如[图 7-7](chapter7.xhtml#fig7-7)所示，仔细将其切断或使用吸锡带将电池架两端的电线去除。
- en: '![A PHOTO OF INSIDE THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER AND THE
    PCB PULLED OUT](../images/fig7-7.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![无线遥控插座发射器内部照片，PCB被拔出](../images/fig7-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-7: The power wires
    in the PCB</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-7: 电路板中的电源电线</samp>'
- en: Next, identify the PCB pads that contain the pins of the on and off buttons
    for the first (or only) outlet in the system by locating the buttons and then
    finding their matching pins on the other side of the PCB. Viewing the buttons
    from the bottom of the PCB (the side with the copper tracks), match the buttons’
    pins to the PCB pads.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过定位按钮，并找到PCB另一侧与按钮匹配的引脚，识别系统中第一个（或唯一）插座的开关按钮的焊盘。从电路板底部查看按钮（即有铜轨的一面），将按钮引脚与电路板的焊盘匹配。
- en: In our example, the PCB uses standard tactile buttons with four legs, two for
    each contact. In [Figure 7-8](chapter7.xhtml#fig7-8), I’ve drawn lines between
    the pads of each side of the tactile switch to note which PCB pads I needed to
    de-solder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，电路板使用了标准的四脚触觉按钮，每个触点有两根引脚。在[图 7-8](chapter7.xhtml#fig7-8)中，我用线条标记了触觉开关两侧的焊盘，以标注出我需要去除焊接的焊盘。
- en: '![A PHOTO OF THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER PCB MARKED TO
    SHOW WHICH PCB TRACKS TO MODIFY](../images/fig7-8.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![无线遥控插座发射器电路板，标记出需要修改的电路板轨道](../images/fig7-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-8: The transmitter
    PCB with button pins separated out with a black marker</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-8: 发射器电路板，按钮引脚用黑色标记笔分开</samp>'
- en: Once you’ve located the PCB pads for the on and off buttons, de-solder the pins,
    ideally using some solder wick, as shown in [Figure 7-9](chapter7.xhtml#fig7-9).
    Be careful not to overheat and destroy the pads.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到了开关按钮的焊盘，使用吸锡带去除引脚，最好使用一些吸锡带，如[图 7-9](chapter7.xhtml#fig7-9)所示。小心不要过热并损坏焊盘。
- en: '![A PHOTO OF DE-SOLDERING BUTTONS FROM THE WIRELESS REMOTE CONTROL AC OUTLET
    TRANSMITTER PCB](../images/fig7-9.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![从无线遥控插座发射器电路板上去除按钮的照片](../images/fig7-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-9: De-soldering buttons
    from the transmitter</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-9: 从发射器上去除按钮的焊接</samp>'
- en: Now gently pry the buttons out from the PCB. This will leave you with some blank
    button spaces, as shown in [Figure 7-10](chapter7.xhtml#fig7-10).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，轻轻地从电路板上撬出按钮。这样，你将得到一些空白的按钮位置，如[图 7-10](chapter7.xhtml#fig7-10)所示。
- en: '![A PHOTO OF THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER PCB WITH TWO
    BUTTONS REMOVED](../images/fig7-10.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![无线遥控插座发射器电路板，两个按钮已移除](../images/fig7-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-10: The transmitter
    PCB with control buttons removed</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-10: 移除控制按钮的发射器电路板</samp>'
- en: In these empty holes, solder in some jumper wires long enough to reach from
    the transmitter PCB to a solderless breadboard. I’ve chopped the ends from some
    preformed jumpers for easy connections to external circuitry, as shown in [Figure
    7-11](chapter7.xhtml#fig7-11).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些空的孔位中，焊接一些足够长的跳线，以便将电路板与无焊面包板连接。我已将一些预制跳线的两端剪掉，以便轻松连接到外部电路，如[图 7-11](chapter7.xhtml#fig7-11)所示。
- en: '![A PHOTO OF THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER PCB WITH NEW
    WIRES REPLACING BUTTONS](../images/fig7-11.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![无线遥控插座发射器电路板，按钮已被新线替换的照片](../images/fig7-11.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-11: Modified wiring
    on the transmitter PCB</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-11：修改后的发射器电路板接线</samp>
- en: It’s time to check the operation of the transmitter PCB. Connect 12 V to the
    power leads and short out the on and off wire pairs in turn to check the receiver
    still switches on and off. If it doesn’t, the (now removed) buttons may have formed
    part of the circuit—that is, both button contacts for each side were used as a
    PCB track connection. This happened with my example buttons, so I placed a short
    wire across the side of the button and soldered it into the PCB, as shown in [Figure
    7-12](chapter7.xhtml#fig7-12).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是检查发射器电路板操作的时候了。将 12V 电源连接到电源引线，然后依次短接开关的开和关导线对，检查接收器是否仍能开关。如果不能，可能是（已拆除的）按钮形成了电路的一部分——也就是说，每个按钮的两边接触点都作为
    PCB 轨道连接使用。我遇到的情况是这样的，因此我将一根短导线横跨按钮的一侧并将其焊接到电路板上，如[图 7-12](chapter7.xhtml#fig7-12)所示。
- en: '![A PHOTO OF WIRES BRIDGING PCB PADS ON THE REMOTE CONTROL AC OUTLET TRANSMITTER
    PCB](../images/fig7-12.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![一张展示遥控插座发射器电路板上 PCB 引脚间用导线桥接的照片](../images/fig7-12.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-12: Adding links to
    the transmitter’s button pads</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-12：为发射器按钮焊盘添加连接</samp>
- en: Give the system another test if necessary. If it’s successful, cover the link
    wires’ joints with some hot glue so they don’t come off by accident later, as
    shown in [Figure 7-13](chapter7.xhtml#fig7-13).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如有必要，再次测试系统。如果测试成功，将连接线的焊点用热熔胶覆盖，以防止它们以后意外脱落，如[图 7-13](chapter7.xhtml#fig7-13)所示。
- en: '![A PHOTO OF HOT GLUE PUT OVER THE SOLDER JOINTS ON THE WIRELESS REMOTE CONTROL
    PCB](../images/fig7-13.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![一张展示无线遥控 PCB 上用热熔胶覆盖焊接接点的照片](../images/fig7-13.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-13: Protecting the
    extra soldered links with hot glue</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-13：用热熔胶保护额外焊接的连接</samp>
- en: You now have a transmitter PCB that can be controlled by an Arduino and an external
    optocoupler circuit. Let’s put it to work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个可以通过 Arduino 和外部光耦电路控制的发射器电路板。让我们开始使用它吧。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #22: Controlling the Transmitter
    Board</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #22：控制发射器电路板</samp>'
- en: 'This project briefly demonstrates controlling a hacked transmitter board, which
    will give you the framework to control the outlet in your own projects. You’ll
    need the following parts:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目简要演示了如何控制一个被破解的发射器电路板，这为你在自己的项目中控制插座提供了框架。你将需要以下部件：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块 Arduino Uno 或兼容板和 USB 数据线
- en: 'A 12 V DC, 1A power supply, wall wart, or plugpack (if you like, you can use
    the DC socket breakout described for Project #19 in [Chapter 6](chapter6.xhtml))'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个12V DC、1A 电源适配器，墙插电源适配器，或插头电源（如果需要，你可以使用[第6章](chapter6.xhtml)中为项目 #19 描述的
    DC 插座插座扩展模块）'
- en: A hacked wireless outlet transmitter and receiver from the previous section
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自上一节的被破解的无线插座发射器和接收器
- en: Two 1 kΩ, 0.25 W, 1 percent resistors
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 1 kΩ、0.25 W、1% 的电阻器
- en: Two 4N28 optocouplers
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 4N28 光耦合器
- en: A solderless breadboard
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊面包板
- en: Various jumper wires
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: Assemble the circuit as shown in [Figure 7-14](chapter7.xhtml#fig7-14).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图 7-14](chapter7.xhtml#fig7-14)所示组装电路。
- en: '![SCHEMATIC FOR PROJECT #22](../images/fig7-14.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #22 的电路图](../images/fig7-14.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-14: The schematic
    for Project #22</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-14：项目 #22 的电路图</samp>'
- en: The TX_On and TX_Off pairs in the schematic represent the wiring to the transmitter
    PCB control buttons, and TX_12VDC+ and <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>
    represent the 12 V power leads to the transmitter PCB. As the 12 V DC is supplying
    the entire circuit, the power to the Arduino is via the Vin pin. Arduino pins
    D2 and D3 are used to turn the transmitter on and off.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 电路图中的 TX_On 和 TX_Off 对应发射器电路板控制按钮的接线，而 TX_12VDC+ 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>
    则表示连接到发射器电路板的 12V 电源引线。由于 12V DC 为整个电路提供电源，因此 Arduino 的电源通过 Vin 引脚供电。Arduino 的
    D2 和 D3 引脚用来控制发射器的开关。
- en: 'Now upload the Project #22 sketch. After a few moments, the mains outlet should
    repeatedly switch on and off around every five seconds.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '现在上传项目 #22 的草图。几秒钟后，主电源插座应每隔大约五秒钟开关一次。'
- en: 'Let’s see how this works:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To control the transmitter, the sketch simply closes the contacts for the on
    and off switches, now represented by the optocouplers, with the functions at ❶
    and ❷. The delay in these functions ensures the transmitter has activated long
    enough to trigger the receiver unit.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制发射器，草图只需关闭开关的触点，这些触点现在由光耦合器表示，使用 ❶ 和 ❷ 中的函数。这些函数中的延迟确保发射器已激活足够长的时间以触发接收单元。
- en: The delay in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>
    helps to test the circuit, as otherwise the transmitter would sometimes turn on
    immediately when power was applied to the Arduino. You should leave this delay
    in your own projects to avoid unnecessary or unwanted outlet activation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> 中的延迟有助于测试电路，否则发射器在为
    Arduino 通电时可能会立即开启。你应该在自己的项目中保留这个延迟，以避免不必要或不希望的插座激活。
- en: Finally, the code demonstrates the control by turning the AC on and off slowly
    ❸ ❹. You might connect a lamp or a small fan to the AC outlet to see the effects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码通过慢慢打开和关闭交流电来演示控制 ❸ ❹。你可以将灯或小风扇连接到交流电源插座，以查看效果。
- en: Keep this project’s hardware together, as you’ll expand upon it in the next
    project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将本项目的硬件保留好，因为你将在下一个项目中扩展使用它。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #23: Controlling the Mains
    Outlet with a Timer</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #23：用定时器控制交流电源插座</samp>'
- en: In this project, you’ll use the DS1307 or DS3231 real-time clock IC to build
    an AC mains outlet that turns on or off at the required point(s) in time. This
    is a great way to control small irrigation pumps, night lights, alarms, or similar
    devices.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用 DS1307 或 DS3231 实时时钟 IC 来构建一个交流电源插座，可以在所需的时间点打开或关闭。这是控制小型灌溉泵、夜灯、警报器或类似设备的绝佳方法。
- en: 'To build this project, you’ll need the same hardware setup used in Project
    #22, along with a DS3231 or DS1307 RTC module or the logging shield used with
    Project #21 in [Chapter 6](chapter6.xhtml). Assemble the circuit as shown in [Figure
    7-15](chapter7.xhtml#fig7-15).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '要构建这个项目，你需要与项目 #22 中使用的相同硬件设置，以及 DS3231 或 DS1307 RTC 模块，或者是项目 #21 中使用的日志盾牌，详见[第
    6 章](chapter6.xhtml)。按照[图 7-15](chapter7.xhtml#fig7-15)中的示意图组装电路。'
- en: '![THE SCHEMATIC FOR PROJECT #23](../images/fig7-15.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #23 的原理图](../images/fig7-15.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-15: The schematic
    for Project #23</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-15：项目 #23 的原理图</samp>'
- en: 'Now upload the Project #23 sketch (which should work for either RTC IC you’ve
    used). Don’t forget to set the time with your current time data using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">setDS3231time()</samp> function in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>. Once you’ve updated
    the time values, uncomment the function, upload the sketch, and then re-comment
    the function and upload the sketch again. I’ve used the DS3231 library as demonstrated
    with Project #21 in [Chapter 6](chapter6.xhtml).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '现在上传项目 #23 草图（它应该适用于你使用的任何 RTC IC）。别忘了使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">setDS3231time()</samp>
    函数在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> 中设置当前时间数据。一旦你更新了时间值，取消注释该函数，上传草图，然后重新注释该函数并再次上传草图。我使用了
    DS3231 库，如在[第 6 章](chapter6.xhtml)的项目 #21 中所示。'
- en: 'Let’s see how this works:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The sketch first includes the I²C and RTC libraries and then creates an instance
    of the real-time clock to reference ❶. It then declares the required variables
    to hold the time and data information ❷. These include three Boolean variables,
    which are left as false by default, since the sketch uses 24-hour time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先包含 I²C 和 RTC 库，然后创建一个实时时钟实例以进行引用 ❶。接着，它声明所需的变量来保存时间和数据 ❷。这些变量包括三个布尔值变量，默认设置为
    false，因为草图使用的是 24 小时制时间。
- en: The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">setTimeData()</samp>
    function contains the functions to set all the time and date parameters. The variables
    declared earlier are placed in each matching function. This function needs to
    be called only once ❸, as you initially set the time and date and then comment
    out the function before re-uploading the sketch; otherwise, the clock will reset
    to the value of the variables.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">setTimeData()</samp> 函数包含设置所有时间和日期参数的函数。之前声明的变量被放置到每个匹配的函数中。这个函数只需要调用一次
    ❸，因为你最初设置了时间和日期，然后在重新上传草图之前注释掉该函数；否则，时钟将重置为变量的值。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">mainsOff()</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mainsOn()</samp> functions also use the
    Arduino’s LED on D13 to indicate the system’s on or off status. For outlet control
    at a certain time, the two <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOn()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">turnoff()</samp> functions each
    accept an hour and minute and compare them against the current time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">mainsOff()</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">mainsOn()</samp>
    函数还使用Arduino板上D13的LED指示系统的开关状态。对于在特定时间控制插座，两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOn()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">turnoff()</samp> 函数各自接受一个小时和分钟参数，并将其与当前时间进行比较。
- en: If there’s a match, the outlet is turned on or off, respectively, as shown with
    the examples in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>.
    You can include as many on or off functions as required; the sketch will continually
    loop about the functions checking to turn on or off. There is a long delay in
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOn()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOff()</samp>
    to stop multiple activations of the transmitter during the times when there is
    a match of time for on or off.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果时间匹配，插座就会被打开或关闭，如在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>
    中的示例所示。你可以根据需要添加任意多的开关函数；代码将不断循环，检查是否需要开关插座。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOn()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOff()</samp> 函数中有一个较长的延迟，目的是防止在开关时间匹配时发生多次触发。
- en: For a challenge, you can modify the sketch to allow the user to select the date
    or day of the week along with the time to turn on or off.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想增加一些挑战性，可以修改代码，让用户可以选择日期或星期几，并结合时间来控制开关。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #24: Controlling the Mains
    Outlet with SMS</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #24：通过短信控制主电源插座</samp>'
- en: 'This project takes wireless control to the next level, using the Project #22
    hardware in conjunction with a 3G cellular shield to create an AC mains outlet
    controllable by text message (wherever there’s cell phone service). Doing so is
    surprisingly simple.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '这个项目将无线控制提升到了一个新水平，结合使用项目 #22 的硬件和一个3G蜂窝盾牌，创建一个可以通过短信控制的交流主电源插座（只要有手机信号覆盖）。这样做出奇的简单。'
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You may have built similar projects to this in Chapter 22 of* Arduino Workshop*,
    2nd edition.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能在《Arduino工作坊》第2版的第22章中构建过类似的项目。*'
- en: For this project to work, you’ll need access to a cellular network that operates
    at UMTS (3G) 850 MHz, 900 MHz, 1900 MHz, or 2100 MHz and allows the use of devices
    not supplied by the network provider. This information should be available from
    your cellular provider. You will also need a SIM card for your network—prepaid
    or otherwise—for this shield, in addition to the one already in your phone. Also
    make sure the requirement to enter a PIN to use the SIM card is turned off. (You
    should be able to do this by inserting the SIM card into a regular cell phone
    and changing the setting in the Security menu.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此项目正常运行，你需要接入一个支持UMTS（3G）850 MHz、900 MHz、1900 MHz或2100 MHz频段的蜂窝网络，并且允许使用非网络提供商提供的设备。你的蜂窝服务提供商应该能提供此类信息。此外，你还需要为该盾牌准备一个SIM卡（可为预付费卡或其他类型的卡），并确保SIM卡的PIN码设置已关闭。（你可以通过将SIM卡插入普通手机并在安全菜单中修改设置来实现这一点。）
- en: This project uses the SIM5320-type 3G GSM shield and antenna shown in [Figure
    7-16](chapter7.xhtml#fig7-16). This shield is available from TinySine ([*https://<wbr>www<wbr>.tinyosshop<wbr>.com*](https://www.tinyosshop.com))
    and its distributors. There are two types of SIM5320 shield, the SIM5320A and
    SIM5320E. The latter uses the UMTS/HSDPA 900/2100MHz frequency bands (mainly for
    European users), and the former uses the UMTS/HSDPA 850/1900MHz frequency band
    (mainly for US-based users and Australians using the Telstra network).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目使用的是SIM5320型3G GSM盾牌和天线，具体如[图7-16](chapter7.xhtml#fig7-16)所示。该盾牌可以通过TinySine（[*https://<wbr>www<wbr>.tinyosshop<wbr>.com*](https://www.tinyosshop.com)）及其经销商购买。SIM5320盾牌有两种类型，SIM5320A和SIM5320E。后者使用UMTS/HSDPA
    900/2100MHz频段（主要供欧洲用户使用），前者使用UMTS/HSDPA 850/1900MHz频段（主要供美国用户和使用Telstra网络的澳大利亚用户使用）。
- en: '![A PHOTO OF A 3G CELLULAR SHIELD FOR ARDUINO WITH ANTENNA](../images/fig7-16.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![带天线的3G蜂窝盾牌用于Arduino](../images/fig7-16.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-16: A 3G shield with
    an antenna</samp>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-16：带天线的 3G shield</samp>
- en: Since these shields require 12 V external power, begin by connecting the power
    supply you used in earlier projects in this chapter via the Vin and GND pins.
    To configure pins D2 and D3, which the shield uses with SoftwareSerial to communicate
    with the Arduino, connect the jumpers over the RX 3 and TX 2 pins, as shown in
    [Figure 7-17](chapter7.xhtml#fig7-17).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些 shields 需要 12V 外部电源，首先通过 Vin 和 GND 引脚连接你在本章早期项目中使用的电源。为了配置 D2 和 D3 引脚，shield
    使用这些引脚通过 SoftwareSerial 与 Arduino 通信，请按照[图 7-17](chapter7.xhtml#fig7-17)所示，连接跳线到
    RX 3 和 TX 2 引脚。
- en: '![A PHOTO OF A 3G CELLULAR SHIELD FOR ARDUINO CONFIGURATION JUMPERS](../images/fig7-17.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![3G 移动通信 Arduino Shield 配置跳线的照片](../images/fig7-17.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-17: Shield serial
    configuration jumpers</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-17：Shield 串行配置跳线</samp>
- en: Next, turn the shield over and insert your carrier SIM card into the holder,
    as shown in [Figure 7-18](chapter7.xhtml#fig7-18).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 shield 翻转过来，并将你的运营商 SIM 卡插入卡槽，如[图 7-18](chapter7.xhtml#fig7-18)所示。
- en: '![A PHOTO OF A SIM CARD HOLDER ON THE 3G SHIELD](../images/fig7-18.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![3G Shield 上 SIM 卡插槽的照片](../images/fig7-18.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-18: A SIM card in
    its holder</samp>'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-18：SIM 卡及其卡槽</samp>
- en: Gently insert the 3G shield into the Arduino. Connect the external power and
    the USB cable between the Arduino and the PC, then screw in the external antenna.
    Finally, turn the SIM module on using the power button on the top left of the
    shield, as shown in [Figure 7-19](chapter7.xhtml#fig7-19). Press the button for
    two seconds, then let go.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 轻轻地将 3G shield 插入 Arduino。连接外部电源和 USB 电缆到 Arduino 和 PC 之间，然后拧上外部天线。最后，按下 shield
    左上角的电源按钮开启 SIM 模块，如[图 7-19](chapter7.xhtml#fig7-19)所示。按下按钮 2 秒钟，然后松开。
- en: '![A PHOTO OF A 3G CELLULAR SHIELD FOR ARDUINO. ALL THREE LEDS ARE ON FOR POWER,
    STATUS AND NETWORK ACTIVITY](../images/fig7-19.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![3G 移动通信 Arduino Shield 的照片。所有三个 LED 都亮起，分别表示电源、状态和网络活动](../images/fig7-19.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-19: The 3G shield
    power button and status LEDs, which are on for power, status, and network activity</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-19：3G shield 电源按钮和状态 LED，当电源、状态和网络活动时，LED
    会亮起</samp>
- en: The P (for power) and S (for status) LEDs should come on. The blue W (for network
    activity) LED should start blinking once the 3G shield has registered with the
    cellular network, meaning you’re ready to use the shield and all is well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: P（电源）和 S（状态）LED 应该会亮起。蓝色的 W（网络活动）LED 应该会开始闪烁，一旦 3G shield 注册到蜂窝网络，表示你已经准备好使用这个
    shield，一切正常。
- en: 'To build this project, you’ll need the 3G shield you’ve just put together,
    along with the hardware setup you built in Project #22\. Assemble the circuit
    as shown in [Figure 7-20](chapter7.xhtml#fig7-20). Note that the optocoupler inputs
    have changed from the pins used in Project #22 to Arduino pins D4 and D5, as we
    use D2 and D3 for the 3G shield’s serial communications.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '要构建这个项目，你需要刚刚组装好的 3G shield，以及在项目 #22 中搭建的硬件设置。按照[图 7-20](chapter7.xhtml#fig7-20)所示组装电路。请注意，光耦合器输入引脚已从项目
    #22 中使用的引脚更改为 Arduino 的 D4 和 D5 引脚，因为我们将 D2 和 D3 用于 3G shield 的串行通信。'
- en: '![THE SCHEMATIC FOR PROJECT #24](../images/fig7-20.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #24 的原理图](../images/fig7-20.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-20: The schematic
    for Project #24</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-20：项目 #24 的原理图</samp>'
- en: Enter and upload the following sketch. Once the shield turns on and the blue
    LED starts blinking, send <samp class="SANS_TheSansMonoCd_W7Bold_B_11">#1</samp>
    as an SMS to the SIM card’s cellular number. The mains outlet should turn on;
    send <samp class="SANS_TheSansMonoCd_W7Bold_B_11">#0</samp> to turn it off again.
    I hope this inspires a brief sense of wonder—these moments make learning and building
    projects quite enjoyable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输入并上传以下代码。一旦 shield 开机并且蓝色 LED 开始闪烁，向 SIM 卡的蜂窝号码发送 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">#1</samp>
    作为短信。主电源插座应该打开；发送 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">#0</samp> 则可以关闭它。我希望这能激发你短暂的好奇心——这些时刻让学习和构建项目变得非常愉快。
- en: 'Let’s see how this works:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的：
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The sketch initializes the software serial port for communication with the 3G
    shield ❶ and then declares the variable used to interrogate incoming data from
    the shield. The transmitter control functions appear at ❷ and ❸, and the code
    configures the digital pins in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> ❹.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码初始化了软件串口，用于与3G扩展板进行通信❶，然后声明了用于查询来自扩展板的传入数据的变量。发射器控制功能出现在❷和❸位置，代码在<samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>中配置了数字引脚❹。
- en: Starting at ❺, the sketch turns on and configures the 3G shield for use, using
    the AT command <samp class="SANS_TheSansMonoCd_W5Regular_11">AT+CMGF=1</samp>
    to convert incoming SMS messages to text and send them to the software serial
    port ❻. Whenever the 3G shield receives a text message, the details are sent to
    the Arduino via the software serial port, one character at a time ❼. The sketch
    tests each incoming character to see if it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>
    ❽; if so, it checks for a <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and then turns the transmitter
    off ❾ or on ❿ respectively.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从❺开始，代码启动并配置3G扩展板以供使用，使用AT命令<samp class="SANS_TheSansMonoCd_W5Regular_11">AT+CMGF=1</samp>将传入的短信转换为文本，并将其发送到软件串口❻。每当3G扩展板接收到短信时，详细信息会通过软件串口逐个字符发送到Arduino❼。代码测试每个传入的字符，看看它是否是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">#</samp>❽；如果是，它会检查是否为<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，然后分别关闭❾或打开❿发射器。
- en: The shield’s power button is connected to digital pin 8, so you can also control
    the power from the project sketch, instead of manually turning the button on or
    off.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展板的电源按钮连接到数字引脚8，因此你也可以通过项目中的代码控制电源，而不必手动开关按钮。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">继续前进</samp>
- en: In this chapter, you learned to safely control mains AC power outlets using
    various forms of automation and remote control. You can use the knowledge gained
    to control the AC mains outlet using various sensors, switches, or other inputs
    or code in your own projects. As long as your input device can control an LED,
    it can control the AC mains outlet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用各种形式的自动化和远程控制安全地控制主电源插座。你可以将所学知识应用于自己的项目中，通过各种传感器、开关或其他输入设备或代码来控制交流电源插座。只要你的输入设备能够控制LED，它也能控制交流电源插座。
- en: In the next chapter, you’ll use high-power shift registers to build even more
    interesting control applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将使用高功率移位寄存器构建更加有趣的控制应用。
