- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**Exploring Divisibility and Primes**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**探索可除性与质数**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: You can add, subtract, or multiply any two integers and get an integer back.
    But when you divide one integer by another, the answer doesn’t have to be an integer.
    The special case when the result of the division *is* an integer is worth noticing.
    Also notable are those rare cases where a number can’t be cleanly divided by any
    numbers besides 1 and itself. We call those *prime numbers*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对任意两个整数进行加法、减法或乘法运算，结果仍然是一个整数。但当你将一个整数除以另一个整数时，结果不一定是整数。值得注意的是，当除法的结果*是*一个整数时，这是一个特殊的情况。同样值得注意的是那些无法被除以除了1和它本身以外任何数的稀有情况。我们称这些为*质数*。
- en: In this chapter, we’ll investigate these two interesting phenomena. These concepts
    are fundamental to *number theory*, the study of the properties and mathematics
    of integers. Number theory is used for everything from random number generation
    in computer games and simulations to designing error-correcting codes for data
    transmission and storage. These real-world applications all start with divisibility
    and primes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究这两种有趣的现象。这些概念是*数论*的基础，数论是研究整数的性质和数学的学科。数论被广泛应用于从计算机游戏和模拟中的随机数生成，到数据传输和存储中的错误纠正码设计等各个领域。这些现实世界的应用都始于可除性和质数。
- en: The Divisibility Factor
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可除性因子
- en: 'We say that the integer *d* is a *divisor* of the integer *n* if the division
    *n* / *d* results in an integer. We can say it with multiplication as well: the
    number *n* is *divisible* by the number *d* if we can find an integer *k* so that
    *n* = *d* ⋅ *k*. Another way to say the same thing is that *d* is a *factor* of
    *n*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说整数*d*是整数*n*的*约数*，如果*n* / *d*的结果是一个整数。我们也可以用乘法来表达：如果我们能找到一个整数*k*，使得*n* = *d*
    ⋅ *k*，则数字*n*能被数字*d*整除。另一种说法是，*d*是*n*的*因子*。
- en: 'Here are some facts, observations, and vocabulary about divisibility:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于可除性的几个事实、观察和词汇：
- en: '![Image](../images/common-1.jpg) Every number is divisible by 1 because we
    can write *n* = *n* ⋅ 1.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 每个数字都能被1整除，因为我们可以写成*n* = *n* ⋅ 1。'
- en: '![Image](../images/common-1.jpg) Every number *n* is a divisor (or factor)
    of itself. If we don’t want to include *n* in the list of divisors, we can specify
    the others as *proper divisors*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 每个数字*n*都是它自己的约数（或因子）。如果我们不想将*n*包括在约数列表中，我们可以指定其他约数为*真约数*。'
- en: '![Image](../images/common-1.jpg) Integers are *even* or *odd* depending on
    whether they’re divisible by 2.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 整数是*偶数*还是*奇数*，取决于它是否能被2整除。'
- en: '![Image](../images/common-1.jpg) Every integer divisible by 5 is guaranteed
    to have a last digit of 0 or 5.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 每个能被5整除的整数，最后一位数字一定是0或5。'
- en: '![Image](../images/common-1.jpg) Every integer divisible by 10 ends in a 0.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 每个能被10整除的整数，最后一位数字是0。'
- en: '![Image](../images/common-1.jpg) The set of positive divisors of 6 is {1, 2,
    3, 6}. The number 6 is considered *perfect* because the sum of its proper divisors,
    1 + 2 + 3, is 6 itself.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 6的正约数集合是{1, 2, 3, 6}。数字6被认为是*完美数*，因为它的所有真约数1
    + 2 + 3的和等于6本身。'
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenge'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**2.1** Fizz-Buzz is a game that can be played by any number of players seated
    in a circle. Players take turns counting up from 1, but if the number they’re
    supposed to say is divisible by 5, the player says “Fizz” instead of the number.
    If the number is divisible by 7, the player says “Buzz.” If the number is divisible
    by both 5 and 7, the player says “Fizz Buzz.” If a player says the wrong thing,
    they’re out, and the last player left wins. Write a program so Scratch Cat can
    play Fizz-Buzz with you.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.1** Fizz-Buzz是一个可以由任何数量的玩家围成一圈玩的小游戏。玩家轮流从1开始计数，但如果他们要说的数字能被5整除，玩家就说“Fizz”而不是数字。如果数字能被7整除，玩家就说“Buzz”。如果数字能同时被5和7整除，玩家就说“Fizz
    Buzz”。如果玩家说错了，便被淘汰，最后剩下的玩家获胜。写一个程序，让Scratch Cat和你一起玩Fizz-Buzz。'
- en: Modular Arithmetic
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟算术
- en: 'Even though dividing one integer by another doesn’t necessarily result in another
    integer, *modular arithmetic* gives us a way to express any division operation
    using integers. The answer to a modular division problem is reported as two separate
    integers: the *quotient* itself, with any decimal component removed, and an extra
    part called the *remainder*. Symbolically, we say the integer *b* divided by the
    positive integer *a* gives a quotient *q* and a remainder *r*, where 0 ≤ *r* <
    *a*. The relationship is given by the equation *b* = (*q* ⋅ *a*) + *r*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将一个整数除以另一个整数不一定会得到另一个整数，*模运算*却为我们提供了一种用整数表示任何除法运算的方法。模除法问题的答案通常以两个整数的形式呈现：*商*本身，去掉任何小数部分，和一个额外的部分叫做*余数*。从符号上讲，我们说整数*b*除以正整数*a*得到一个商*q*和一个余数*r*，其中
    0 ≤ *r* < *a*。这一关系由公式*b* = (*q* ⋅ *a*) + *r* 给出。
- en: Division is the process of determining a quotient and remainder given *b* and
    *a*. The *division algorithm* identifies the quotient and remainder. Scratch has
    a built-in operation to capture the remainder *r*, called `mod`. To find the quotient
    *q*, we do the division using the `/` operator and indicate that we want to keep
    only the integer part of the result by using the `floor` operation. [Figure 2-1](ch02.xhtml#ch2fig1)
    gives an example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除法是给定*b*和*a*后，确定商和余数的过程。*除法算法*用来识别商和余数。Scratch有一个内建的操作来捕获余数*r*，叫做`mod`。为了找到商*q*，我们使用`/`运算符进行除法，并通过使用`floor`操作来指示我们只保留结果的整数部分。[图2-1](ch02.xhtml#ch2fig1)给出了一个示例。
- en: '![Image](../images/pg42_Image_30.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg42_Image_30.jpg)'
- en: '*Figure 2-1: Calculating the quotient and remainder of 45/7*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-1：计算45/7的商和余数*'
- en: 'Here, `floor of 45 / 7` gives us a quotient of `6`, and `45 mod 7` gives us
    a remainder of `3`. To check this is right, we can plug the results into our formula:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`floor of 45 / 7`给我们一个商`6`，而`45 mod 7`给我们一个余数`3`。为了验证这是正确的，我们可以将结果代入我们的公式中：
- en: '![Image](../images/pg43_Image_31.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg43_Image_31.jpg)'
- en: We say two numbers *x* and *y* are *congruent modulo n* if *x* mod *n* = *y*
    mod *n*. In this case, when *x* and *y* are divided by *n*, they have the same
    remainder *r*. For example, 7 and 19 are congruent mod 6 because 7 and 19 divided
    by 6 both yield a remainder of 1\. Congruence isn’t as strong as equality, in
    that equal numbers must be congruent, but congruent numbers need not be equal.
    Instead of an equal sign (=), we use the triple bar symbol (≡) for congruence,
    so we write 7 ≡ 19 mod 6.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说两个数字*x*和*y*对模*n*是*同余*的，如果*x* mod *n* = *y* mod *n*。在这种情况下，当*x*和*y*分别除以*n*时，它们有相同的余数*r*。例如，7和19对模6同余，因为7和19除以6都得到余数1。*同余*的概念没有*等于*那么严格，等于的数字必须是同余的，但同余的数字不一定相等。我们使用三条横线符号（≡）表示同余，而不是等号（=），所以我们写作7
    ≡ 19 mod 6。
- en: 'Here are some facts connecting modular arithmetic to divisibility:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些将模运算与整除性联系起来的事实：
- en: '![Image](../images/common-1.jpg) We can test for divisibility of *b* by *a*
    with Scratch by seeing if *b* mod *a* is 0.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 我们可以通过在Scratch中查看*b* mod *a*是否为0来测试*b*是否能被*a*整除。'
- en: '![Image](../images/common-1.jpg) Odd numbers are all congruent to 1 mod 2,
    and even numbers are congruent to 0 mod 2.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 奇数对模2同余1，偶数对模2同余0。'
- en: '![Image](../images/common-1.jpg) Numbers that end in 0 are congruent to 0 mod
    10\. They’re also divisible by 10.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 以0结尾的数字对模10同余。它们也能被10整除。'
- en: '![Image](../images/common-1.jpg) Numbers that end in 0 or 5 are congruent to
    0 mod 5\. They’re also divisible by 5.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 以0或5结尾的数字对模5同余。它们也能被5整除。'
- en: '![Image](../images/common-1.jpg) When we represent *b* = (*q* ⋅ *a*) + *r*
    by the division algorithm, the set of all possible remainders is {0, 1, 2, . .
    . , *a* – 1}, a set of *a* elements. Sometimes it’s more useful to use another
    set of *a* elements where every integer is congruent to one element of the set.
    Since Scratch numbers elements in lists starting from 1, the set {1, 2, 3, . .
    . , *a*} is often a good choice.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 当我们用除法算法表示*b* = (*q* ⋅ *a*) + *r*时，所有可能的余数的集合是{0,
    1, 2, . . . , *a* – 1}，这是一个包含*a*个元素的集合。有时，使用另一个包含*a*个元素的集合更有用，其中每个整数都与该集合中的一个元素同余。由于Scratch中的列表元素从1开始编号，集合{1,
    2, 3, . . . , *a*}通常是一个不错的选择。'
- en: We’ll explore a simple hack that uses modular arithmetic to help check the results
    of a calculation in the next project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，我们将探索一个简单的技巧，使用模运算帮助检查计算结果。
- en: 'Project 5: A Trick for Checking Your Math'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目5：检查数学结果的小技巧
- en: '*Casting out nines* is a trick for verifying the answer to a large addition
    or multiplication problem. To see how it works, first notice that every power
    of 10 leaves a remainder of 1 when it’s divided by 9\. For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*除九求余*是一种验证大数加法或乘法答案的技巧。为了理解它是如何工作的，首先要注意到每一个10的幂数在除以9时的余数都是1。例如：'
- en: '![Image](../images/pg43_Image_32.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg43_Image_32.jpg)'
- en: 'This points to a broader rule that when you divide a number *n* by 9, you get
    the same remainder as when you divide the sum of the digits of *n* by 9\. Take
    the case of 347 divided by 9\. To determine the remainder, we first sum the digits:
    3 + 4 + 7 = 14\. At this point, we could notice that 14 = (1 ⋅ 9) + 5, giving
    us a remainder of 5\. Or we could do the casting out nines trick a second time
    to get the result in an easier way: 1 + 4 = 5\. (In fact, 347 divided by 9 is
    38 remainder 5.)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这指出了一个更广泛的规则：当你将一个数字*n*除以9时，你得到的余数和将*n*的各位数字之和除以9得到的余数是相同的。例如，347除以9。为了确定余数，首先我们将各位数字相加：3
    + 4 + 7 = 14。此时，我们可以注意到14 = (1 ⋅ 9) + 5，从而得到余数为5。或者，我们可以再一次使用除九求余技巧，以更简单的方式得到结果：1
    + 4 = 5。（事实上，347除以9的结果是38余5。）
- en: Casting out nines is a good way to check your work after a big addition or multiplication
    operation because it’s much easier to do arithmetic mod 9 (by summing a number’s
    digits) than to keep track of multidigit sums and products. Suppose, for example,
    you calculate 347 + 264 and get the answer 601\. We’ve already seen that 347 mod
    9 is 5\. For 264, 2 + 6 + 4 = 12 and 1 + 2 = 3, so 264 mod 9 is 3\. That means
    (347 + 264) mod 9 should be 5 + 3 = 8\. But 601 mod 9 is 6 + 0 + 1 = 7, so something
    is wrong. It looks like somebody forgot to carry the 1 in the original addition!
    When we fix the sum to be 611, casting out nines works as expected.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除九求余是检查大加法或乘法计算是否正确的好方法，因为做模9的算术（通过数字之和）比追踪多位数的加法和乘法更容易。例如，假设你计算了347 + 264并得到了601的答案。我们已经看到347模9的结果是5。对于264，2
    + 6 + 4 = 12，1 + 2 = 3，所以264模9的结果是3。这意味着(347 + 264)模9应该是5 + 3 = 8。但是，601模9的结果是6
    + 0 + 1 = 7，显然哪里出了问题。看起来是原始加法时有人忘记进位了！当我们将和修正为611时，除九求余结果符合预期。
- en: Even though adding up the digits of a number is pretty easy mental math, let’s
    have Scratch Cat do the work for us. The program in [Figure 2-2](ch02.xhtml#ch2fig2)
    uses the casting out nines technique to find any number mod 9.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将一个数字的各个数字相加是相对简单的心算，我们还是让Scratch Cat来为我们完成这项工作。图[2-2](ch02.xhtml#ch2fig2)中的程序使用除九求余技巧来计算任何数字的模9。
- en: '![Image](../images/pg44_Image_33.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg44_Image_33.jpg)'
- en: '*Figure 2-2: A program for finding `x mod 9` by calculating digit sums*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-2：一个通过计算数字之和来找出`x mod 9`的程序*'
- en: The trick is to have Scratch see the number `x` as a string of digits. The `length
    of` operator reports how many digits the number has, and the `letter of` operator
    lets us pick off one digit at a time so we can add them up. The code is nested
    inside a `repeat until` loop that makes it continue until the length of `x` is
    `1`, meaning the number has only one digit. If that single digit is in the range
    0 through 8, we have our answer. The single digit could also be a 9, though, which
    is congruent to 0 mod 9\. In that case, the last `if` statement picks 0 as the
    answer to report instead of 9.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧是让Scratch把数字`x`视为一串数字。`length of`操作符报告数字的位数，`letter of`操作符允许我们逐个取出数字进行相加。代码嵌套在一个`repeat
    until`循环中，直到`x`的长度为`1`时才停止，这意味着数字只有一位。如果这个单一的数字在0到8的范围内，我们就得到了答案。不过，这个单一数字也可能是9，这在模9运算中等同于0。在这种情况下，最后的`if`语句选择0作为报告的答案，而不是9。
- en: The Results
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 2-3](ch02.xhtml#ch2fig3) shows a sample run of the program, using 601
    as the input.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-3](ch02.xhtml#ch2fig3)显示了程序的一个示例运行，输入为601。'
- en: '![Image](../images/pg45_Image_34.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg45_Image_34.jpg)'
- en: '*Figure 2-3: Finding 601 mod 9*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-3：计算601模9*'
- en: The last line of the program uses `join` operations to make the output pretty,
    reminding us of the input number and the result of the casting out nines process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一行使用`join`操作使输出更加美观，提醒我们输入的数字以及除九求余过程的结果。
- en: Hacking the Code
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: 'We have the same problem here that we had in [Chapter 1](ch01.xhtml#ch01):
    Scratch is happy to run the code on input that isn’t a number. The way the program
    is written, it even gets in trouble with what ought to be perfectly allowable
    inputs, like negative integers. For example, the number –3 interpreted as a string
    has a length of 2, and according to Scratch, the first character, the minus sign,
    has a numerical value of 0\. So Scratch reports that the sum of the digits of
    –3 is 0 + 3 = 3\. The trouble is that –3 mod 9 is equal to 6, not 3.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里遇到的问题与[第 1 章](ch01.xhtml#ch01)中遇到的问题相同：Scratch 很乐意在非数字输入上运行代码。按照程序的写法，它甚至会对本应完全允许的输入（如负整数）出现问题。例如，数字
    -3 被当作字符串解释时，长度为 2，而根据 Scratch 的规定，第一个字符即负号的数值为 0。因此，Scratch 报告说 -3 的各位数字之和是 0
    + 3 = 3。但问题是，-3 除以 9 的余数是 6，而不是 3。
- en: 'Because we’ll run into problems with negative integers and non-integer inputs,
    before we put the code out for general use, we should make it safe by screening
    possible inputs to allow only the ones we want: positive integers. We can create
    a custom block to screen the input, as shown in [Figure 2-4](ch02.xhtml#ch2fig4).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将遇到负整数和非整数输入的问题，因此在将代码发布供一般使用之前，我们应该通过筛选输入确保安全，只允许我们想要的输入：正整数。我们可以创建一个自定义块来筛选输入，如[图
    2-4](ch02.xhtml#ch2fig4)所示。
- en: '![Image](../images/pg46_Image_35.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg46_Image_35.jpg)'
- en: '*Figure 2-4: Making sure the input is a positive integer*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：确保输入是正整数*'
- en: The Boolean statement `round test = test` is a hack that lets us kill a few
    birds with one stone. It screens out non-numeric input (such as the word *banana*),
    since trying to round a non-number in Scratch produces 0 as a result. It also
    screens out numbers with nonzero decimal components, which will no longer be equal
    to themselves after rounding. Combined with `text > 0`, our `if` statement is
    true if the input `test` is a positive integer and false otherwise, so we can
    set the value of the variable `positive integer?` to `true` if the two conditions
    are satisfied.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔语句 `round test = test` 是一种技巧，它让我们一举多得。它筛选掉非数字输入（例如单词 *banana*），因为在 Scratch
    中尝试对非数字进行四舍五入会得到 0 作为结果。它还会筛选掉带有非零小数部分的数字，这些数字四舍五入后将不再等于它们自己。结合 `text > 0`，我们的
    `if` 语句会在输入 `test` 是正整数时为真，否则为假。因此，如果满足这两个条件，我们可以将变量 `positive integer?` 的值设置为
    `true`。
- en: '**NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some programming languages have special Boolean variables that can take on
    only the values* true *or* false, *but Scratch doesn’t. Here, we simply use the
    words* true *and* false *instead. Some programmers prefer to use the numerical
    values 1 and 0 to keep track of truth values.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*某些编程语言有特殊的布尔变量，只能取值为* true *或* false，*但 Scratch 并没有。在这里，我们简单地使用* true *和*
    false *这两个词。某些程序员更喜欢使用数字值 1 和 0 来表示真假值。*'
- en: Once we have a screening block, we can modify the code in [Figure 2-2](ch02.xhtml#ch2fig2)
    to execute for only appropriate values, as shown in [Figure 2-5](ch02.xhtml#ch2fig5).
    Paste the original program from the `repeat until` block onward into the empty
    slot after the `if`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了筛选块，就可以修改[图 2-2](ch02.xhtml#ch2fig2)中的代码，使其仅对适当的值执行，如[图 2-5](ch02.xhtml#ch2fig5)所示。将
    `repeat until` 块后面的原始程序粘贴到 `if` 之后的空白位置。
- en: '![Image](../images/pg46_Image_36.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg46_Image_36.jpg)'
- en: '*Figure 2-5: Don’t let Scratch Cat make a mistake!*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：别让 Scratch Cat 犯错误！*'
- en: Of course, you don’t actually have to go through the casting out nines process
    to perform this calculation. You can just use Scratch’s `mod` block! Still, writing
    the program is good practice for figuring out how to solve a problem and how to
    analyze a number one digit at a time. The program also generalizes to other cases,
    such as the one in Challenge 2.2.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你实际上不必经过去除九的过程来进行此计算。你可以直接使用 Scratch 的 `mod` 块！不过，编写程序对你来说是解决问题的好练习，能够帮助你逐位分析数字。该程序同样可以推广到其他情况，比如挑战
    2.2 中的情况。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**2.2** Casting out nines gives a test for divisibility by 9, since if the
    sum of the digits is 0 or 9, the number is divisible by 9\. A test for divisibility
    by 11 works similarly, except instead of adding all the digits, you alternately
    subtract and add them. For example, 1,342 is divisible by 11 because 1 – 3 + 4
    – 2 = 0\. Program Scratch to calculate the –/+ digit sum for a given number to
    see if it’s divisible by 11.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.2** 去九法可以测试一个数字是否能被 9 整除，因为如果数字的各位数字之和为 0 或 9，那么该数字就能被 9 整除。测试一个数字是否能被
    11 整除的方式类似，不同之处在于，计算时不是将所有数字相加，而是交替地加和减。例如，1,342 可以被 11 整除，因为 1 – 3 + 4 – 2 =
    0。编写 Scratch 程序计算给定数字的加减位数之和，看看它是否能被 11 整除。'
- en: '**2.3** Scratch has an operator that lets you pick a random number in a specified
    range. Write a program to pick 10 random numbers between 1 and 100\. Predict how
    many are likely to be divisible by 9, then use Scratch to check if your prediction
    was right.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.3** Scratch 有一个运算符，允许你从指定范围内随机选择一个数字。编写一个程序，选择 1 到 100 之间的 10 个随机数字。预测其中有多少个能被
    9 整除，然后使用 Scratch 检查你的预测是否正确。'
- en: '**2.4** Sometimes when you have to enter a number into a computer form (like
    a credit card number or a book’s ISBN code), the number includes a *check digit*
    to make sure you haven’t made a mistake. One way to implement this is to add an
    extra digit at the end that’s derived from the original number. For example, the
    extra digit could be the original number mod 9, found by casting out nines as
    in the program in [Figure 2-2](ch02.xhtml#ch2fig2). Extend this program to give
    the original number with its check digit added.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.4** 有时，当你需要在计算机表单中输入一个数字（例如信用卡号码或书籍的 ISBN 代码）时，数字中会包含一个 *校验位* 来确保你没有输入错误。一种实现方式是，在数字的末尾加上一个额外的数字，这个数字是从原始数字派生出来的。例如，额外的数字可以是原始数字
    mod 9，通过像 [图 2-2](ch02.xhtml#ch2fig2) 中的程序那样使用去九法计算得出。扩展此程序，给出包含校验位的原始数字。'
- en: '**2.5** When copying numbers we sometimes make *transposition* errors, where
    two digits are switched. For example, we might miswrite 1,467 as 1,647\. Could
    you use the casting out nines trick to help catch this kind of mistake?'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.5** 在复制数字时，我们有时会犯 *位数交换* 错误，即交换两个数字的位置。例如，我们可能将 1,467 错写为 1,647。你能否使用“去九法”来帮助发现这种错误？'
- en: Prime Numbers
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 质数
- en: 'Some integers have many divisors, and some have only a few. The integer 1 is
    a special case, in that it’s divisible only by itself. For any other number, the
    smallest number of divisors is two: 1 and the number itself. As mentioned at the
    beginning of this chapter, numbers with only two divisors are called prime numbers.
    Numbers with more than two divisors are called *composite numbers*.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些整数有很多除数，而一些只有少数几个。整数 1 是一个特殊的情况，它只能被自身整除。对于任何其他数字，最少的除数数量是两个：1 和该数字本身。正如本章开始所提到的，只有两个除数的数字被称为质数。除数超过两个的数字被称为
    *合成数*。
- en: The first few prime numbers are 2, 3, 5, 7, 11, 13, and 17\. To find more, we’ll
    turn to Scratch.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个质数是 2、3、5、7、11、13 和 17。为了找到更多的质数，我们将使用 Scratch。
- en: 'Project 6: Is It Prime?'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 6：它是质数吗？
- en: One way to determine if a number is prime is to try out possible factors one
    by one, a process called *trial division*. If there aren’t any other divisors
    between 1 and the number, then the number is prime. For the number 5, for example,
    we would try dividing 5 by 2, then 3, then 4\. None of those numbers divide evenly
    into 5, so 5 is prime.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个数字是否为质数的一种方法是逐一尝试可能的因子，这个过程叫做 *试除法*。如果 1 和该数字之间没有其他除数，那么该数字就是质数。例如，对于数字
    5，我们会先尝试将 5 除以 2，再除以 3，再除以 4。没有任何一个数字能整除 5，所以 5 是质数。
- en: Doing trial division manually quickly gets tedious, so we’ll write a program
    to make Scratch do it for us. [Figure 2-6](ch02.xhtml#ch2fig6) shows a simple
    version of the code that doesn’t worry about improper inputs that could cause
    incorrect answers (for example, strings or numbers that aren’t positive integers).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 手动进行试除法很快就会变得乏味，因此我们将编写一个程序，让 Scratch 为我们完成这项工作。[图 2-6](ch02.xhtml#ch2fig6)
    显示了一个简单版本的代码，它并未考虑可能导致错误答案的不当输入（例如，字符串或不是正整数的数字）。
- en: '![Image](../images/pg48_Image_37.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg48_Image_37.jpg)'
- en: '*Figure 2-6: Checking for primes by trial division*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：通过试除法检查质数*'
- en: The code prompts for a number to test and decides if the number is prime by
    working with the Boolean `prime?` variable. We perform the trial division in a
    `repeat until` loop ❶ by calculating `answer mod trial` ➋, where the variable
    `trial` is the trial divisor. If the result is `0`, we know that we have a divisor
    and that `answer` isn’t prime, so we exit the loop. Otherwise, we add `1` to `trial`
    and try again. At the end, we report an answer based on whether `prime?` is `true`
    or `false`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 代码提示输入一个待测试的数字，并通过与布尔变量 `prime?` 配合使用来决定该数字是否为素数。我们在 `repeat until` 循环 ❶ 中执行试除法，通过计算
    `answer mod trial` ➋，其中变量 `trial` 是试除数。如果结果为 `0`，我们知道已经找到一个除数，且 `answer` 不是素数，因此退出循环。否则，我们将
    `1` 加到 `trial` 中并重新尝试。最后，我们根据 `prime?` 的值是 `true` 还是 `false` 来报告结果。
- en: The Results
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 2-7](ch02.xhtml#ch2fig7) shows some sample runs of the trial division
    program.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-7](ch02.xhtml#ch2fig7) 显示了试除法程序的示例运行。'
- en: '![Image](../images/pg49_Image_38.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg49_Image_38.jpg)'
- en: '*Figure 2-7: Sample runs of the trial division program*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：试除法程序的示例运行*'
- en: The program correctly identifies 29 as prime and 30 as not prime.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序正确识别了 29 是素数，30 不是素数。
- en: Hacking the Code
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: We should screen the input so Scratch is considering only positive integers.
    A custom block like the one we made for the casting out nines program (see [Figure
    2-4](ch02.xhtml#ch2fig4)) would work, put into an `if` statement (as in [Figure
    2-5](ch02.xhtml#ch2fig5)). There are a few more conditions to put into the screening
    code, though. First, the integer 1 is neither prime nor composite, but 1 would
    survive the `repeat until` loop in our trial division program and be labeled as
    prime. The custom block in [Figure 2-8](ch02.xhtml#ch2fig8) includes an initial
    `if` test to disallow an input of 1.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该筛选输入，以便 Scratch 仅考虑正整数。像我们为“去九程序”创建的自定义块（见[图 2-4](ch02.xhtml#ch2fig4)）可以使用，并将其放入一个`if`语句中（如[图
    2-5](ch02.xhtml#ch2fig5)所示）。不过，筛选代码中还有一些额外的条件。首先，整数 1 既不是素数也不是合成数，但 1 会在我们的试除法程序中的`repeat
    until`循环中存活并被标记为素数。[图 2-8](ch02.xhtml#ch2fig8)中的自定义块包括一个初步的`if`测试，禁止输入 1。
- en: '![Image](../images/pg50_Image_39.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg50_Image_39.jpg)'
- en: '*Figure 2-8: Limiting the input for the trial division program*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：限制试除法程序的输入*'
- en: A more subtle problem is that, as we saw in [Chapter 1](ch01.xhtml#ch01), integer
    arithmetic is exact only up to flintmax. That means the divisibility test works
    only for numbers up to 9,007,199,254,740,992\. After that, Scratch Cat thinks
    every number is composite! The check code in [Figure 2-8](ch02.xhtml#ch2fig8)
    accounts for this as well by verifying that `test` is less than flintmax. The
    block also returns a `message` variable giving more information for the program
    to report when the input can’t reliably be tested.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更微妙的问题是，正如我们在[第 1 章](ch01.xhtml#ch01)中看到的，整数运算仅在 flintmax 以内是精确的。这意味着可除性测试仅对最大为
    9,007,199,254,740,992 的数字有效。之后，Scratch Cat 会认为所有数字都是合成数！[图 2-8](ch02.xhtml#ch2fig8)中的检查代码也考虑到了这一点，通过验证`test`是否小于
    flintmax。该代码块还返回一个`message`变量，当输入无法可靠测试时，程序会报告更多信息。
- en: 'Another consideration with this program is that trial division on large numbers
    potentially takes many steps—so many that even on a fast computer you might have
    to wait a long time to get an answer. The test in the `repeat until` loop ➊ in
    [Figure 2-6](ch02.xhtml#ch2fig6) is a hack to speed up the process: we really
    have to consider only trial divisors up to the square root of the input number.
    This works because if a number *n* isn’t prime, it must have a factorization *n*
    = *a* ⋅ *b* other than the trivial factorization 1 ⋅ *n*. Since *n* = ![Images](../images/pg50_Image_40.jpg),
    one of *a* or *b* must be at least as big as ![Image](../images/pg50_Image_41.jpg)
    and the other must be ![Image](../images/pg50_Image_41.jpg) or smaller. We have
    to do trial division only up to ![Image](../images/pg50_Image_41.jpg) to find
    the smaller one, if it exists.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的另一个考虑因素是，处理大数字的试除法可能需要很多步骤——如此之多，以至于即使在快速计算机上，你也可能需要等待很长时间才能得到答案。[图 2-6](ch02.xhtml#ch2fig6)中`repeat
    until`循环的测试 ➊ 是一种加速过程的技巧：我们实际上只需要考虑试除数，直到输入数字的平方根。这是因为如果一个数字 *n* 不是素数，它必须具有一个因式分解
    *n* = *a* ⋅ *b*，而不是简单的因式分解 1 ⋅ *n*。由于 *n* = ![Images](../images/pg50_Image_40.jpg)，所以
    *a* 或 *b* 中的一个必须至少与 ![Image](../images/pg50_Image_41.jpg) 一样大，另一个则必须小于或等于 ![Image](../images/pg50_Image_41.jpg)。我们只需要进行试除法，直到
    ![Image](../images/pg50_Image_41.jpg) 来找到较小的那个，若它存在的话。
- en: This hack provides a huge savings! We can test numbers up to 1,000,000 with
    no more than ![Image](../images/pg50_Image_42.jpg) = 1,000 trial divisions. To
    speed up the code even further, once we’ve checked on divisibility by 2, we could
    test only for divisibility by odd numbers. This is because if a number *n* is
    divisible by any even number, it will also be divisible by 2.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧带来了巨大的节省！我们可以测试高达1,000,000的数字，最多只需![Image](../images/pg50_Image_42.jpg)
    = 1,000次试除。为了进一步加速代码，一旦检查完2的可整除性，我们就只需要测试奇数的可整除性。这是因为如果一个数字*n*能被任何偶数整除，它也一定能被2整除。
- en: All these improvements allow for shorter runtimes, but they also make for a
    longer, more complicated program. Whether the trade-off is worth it will depend
    on who will be using your work, and for what. Improvements that make the program
    easier to use are usually worth it. Improvements that speed up runtime have to
    be dramatic to be noticeable, but they may be worthwhile if users will be looking
    for quick results.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些改进都能缩短运行时间，但也使程序变得更长、更复杂。是否值得做这些权衡取决于谁会使用你的作品，以及用途如何。使程序更易用的改进通常是值得的。而加速运行时间的改进需要显著才能被注意到，但如果用户需要快速的结果，这些改进可能是值得的。
- en: 'Project 7: The Sieve of Eratosthenes'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目7：埃拉托斯特尼筛法
- en: 'Trial division isn’t the only way to find prime numbers. In this project, we’ll
    explore a different technique: looking at a list of all numbers up to some limit
    and throwing away the numbers that are composite. This approach sifts, or *sieves*,
    out the primes and is called the *sieve of Eratosthenes* after the Greek mathematician
    who first used it. Scratch Cat uses sieving in [Figure 2-9](ch02.xhtml#ch2fig9),
    where the numbers 1 through 120 have been arranged in a grid.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 试除法不是唯一的质数查找方法。在这个项目中，我们将探索另一种技术：查看所有数字列表，直到某个限制，并丢弃那些合数。这种方法筛选出质数，称为*埃拉托斯特尼筛法*，以首次使用该方法的古希腊数学家命名。Scratch
    Cat在[图2-9](ch02.xhtml#ch2fig9)中使用了筛法，其中1到120的数字已被排列成网格。
- en: '![Image](../images/pg51_Image_43.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg51_Image_43.jpg)'
- en: '*Figure 2-9: Sieving out the primes by throwing away non-primes*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-9：通过丢弃非质数来筛选质数*'
- en: First, we cross out 1, which is neither prime nor composite, in red. Then, we
    cross out all multiples of 2 in green, as shown on the left side of [Figure 2-10](ch02.xhtml#ch2fig10),
    and see what’s left. We continue by identifying the next few primes after 2 (3,
    5, and 7) and crossing out any multiples of them, as shown on the right side of
    [Figure 2-10](ch02.xhtml#ch2fig10).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们用红色划掉1，因为它既不是质数也不是合数。接着，我们用绿色划掉所有2的倍数，如[图2-10](ch02.xhtml#ch2fig10)左侧所示，看看剩下的是什么。然后，我们继续识别2之后的下几个质数（3、5、7），并划掉它们的倍数，如[图2-10](ch02.xhtml#ch2fig10)右侧所示。
- en: '![Image](../images/pg52_Image_44.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg52_Image_44.jpg)'
- en: '*Figure 2-10: Eliminating all the even numbers after 2 (left) and all multiples
    of 3, 5, and 7 (right)*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-10：去除2之后的所有偶数（左）和所有3、5、7的倍数（右）*'
- en: Notice that multiples of 2 and 3 are crossed out with vertical lines down the
    columns of the grid. This works because the grid is set up to be six numbers wide,
    and 6 is divisible by both 2 and 3\. Multiples of 5, crossed out in pink, step
    backward on the diagonal. This is because to get from one multiple of 5 to the
    next multiple we add 5, which is 6 – 1\. So to find the next multiple of 5, we
    go down one row for the 6 and back one column for the –1\. Similarly, to find
    multiples of 7, crossed out in yellow, we go down one row and step one column
    to the right (because 7 = 6 + 1), giving us lines along the other diagonal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，2和3的倍数在网格的列中被竖线划掉。这是因为网格被设置为宽度为6，而6能被2和3同时整除。5的倍数被粉色划掉，沿对角线向后移动。这是因为要从一个5的倍数跳到下一个，我们需要加5，也就是6
    – 1。因此，要找到下一个5的倍数，我们沿着6的行向下移动一行，再沿着-1的列回退一列。同样，要找到7的倍数（黄色划掉），我们沿着行向下移动一行，再向右移动一列（因为7
    = 6 + 1），这样我们就得到了沿着另一条对角线的线条。
- en: '![Image](../images/pg52_Image_47.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg52_Image_47.jpg)'
- en: '*Figure 2-11: All the primes up to 120, after sieving*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-11：筛选后到120为止的所有质数*'
- en: 'Here’s the payoff of sieving: if a number *n* is composite and has a factorization
    *n* = *a* ⋅ *b* where 1 < *a* ≤ *b* < *n*, then *a* ≤ ![Image](../images/pg52_Image_45.jpg).
    In our example, *n* = 120, so any composite number in the grid must have a prime
    factor less than ![Image](../images/pg52_Image_46.jpg), or approximately 10.95\.
    Once we’ve sieved up to 7, the next number that hasn’t already been crossed out
    is 11, which is greater than ![Image](../images/pg52_Image_46.jpg), so 7 is as
    far as we need to sieve. Every number that remains, meaning it hasn’t been crossed
    off as a multiple of 2, 3, 5, or 7, must be a prime number (see [Figure 2-11](ch02.xhtml#ch2fig11)).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是筛法的回报：如果一个数字*n*是合数，并且有因式分解 *n* = *a* ⋅ *b*，其中 1 < *a* ≤ *b* < *n*，那么 *a* ≤
    ![Image](../images/pg52_Image_45.jpg)。在我们的例子中，*n* = 120，因此网格中的任何合数必须有一个小于 ![Image](../images/pg52_Image_46.jpg)
    的素因数，大约是 10.95。一旦我们筛到7，接下来没有被筛去的数字是11，它大于 ![Image](../images/pg52_Image_46.jpg)，因此筛法就不需要继续了。剩下的每个数字，即未被筛去为2、3、5或7的倍数的数字，必须是素数（见[图
    2-11](ch02.xhtml#ch2fig11)）。
- en: This is the second time the square root hack has been useful. First, it made
    the trial division program in [Figure 2-6](ch02.xhtml#ch2fig6) run faster. Now
    it’s telling us when to stop sieving, allowing us (in this example) to find all
    primes less than 120 just by sieving up to 7.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是平方根技巧第二次发挥作用。首先，它使得[图 2-6](ch02.xhtml#ch2fig6)中的试除法程序运行更快。现在，它告诉我们何时停止筛法，使我们（在此例中）通过筛到7就能找到所有小于120的素数。
- en: We could use the same technique to sieve up to a much higher bound. All we have
    to do is get rid of all the multiples of each prime as they’re discovered, up
    to the square root of the bound. That’s what we do in the Scratch program in [Figure
    2-12](ch02.xhtml#ch2fig12).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的技术将筛法扩展到更高的范围。我们只需在发现每个素数时，去除它的所有倍数，直到平方根为止。这就是我们在[图 2-12](ch02.xhtml#ch2fig12)的Scratch程序中所做的。
- en: '![Image](../images/pg53_Image_48.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg53_Image_48.jpg)'
- en: '*Figure 2-12: The sieve program*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-12：筛法程序*'
- en: We start by asking how far to go, then seed the list `primes` with that many
    entries ❶. (Since we’re using a list, our upper bound is limited by the maximum
    list size that Scratch supports, which is 200,000.) Scratch indexes lists starting
    with 1, so the list entry at index *n* will keep track of whether *n* is a prime.
    Initially we set each entry to `true`, but we’ll change non-prime entries to `false`
    as we sieve.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先询问筛到多远，然后将`primes`列表初始化为相应的大小❶。（由于我们使用的是列表，我们的上限受Scratch支持的最大列表大小限制，最大为200,000。）Scratch的列表索引从1开始，因此列表中索引为*n*的条目将用于跟踪*n*是否是素数。初始时，我们将每个条目设置为`true`，但我们会在筛法过程中将非素数条目改为`false`。
- en: First, we handle the special case of 1, which is neither prime nor composite
    ➋. Then, we look for the next number not crossed out by sieving so far. We leave
    that number as `true` but set all multiples of that number to `false` ➌. We repeat
    this process until the next number not crossed out is greater than the square
    root of the limit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们处理特殊情况1，1既不是素数也不是合数➋。然后，我们寻找下一个未被筛去的数字。我们将该数字保持为`true`，但将它的所有倍数设置为`false`
    ➌。我们重复这个过程，直到下一个未被筛去的数字大于限制的平方根。
- en: Once we have a complete list, we can access it and answer questions about the
    prime numbers we’ve found. [Figure 2-13](ch02.xhtml#ch2fig13) has a little piece
    of code to count how many primes there are up to the sieve limit.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了完整的列表，就可以访问它并回答关于我们找到的素数的问题。[图 2-13](ch02.xhtml#ch2fig13)中有一段小代码，用来计算筛法限制以内有多少个素数。
- en: '![Image](../images/pg54_Image_49.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg54_Image_49.jpg)'
- en: '*Figure 2-13: Counting primes with the sieve program*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-13：使用筛法计数素数*'
- en: Here, we step through the list we’ve built and count how many `true` entries
    there are, incrementing the variable `primecount` each time. [Figure 2-14](ch02.xhtml#ch2fig14)
    shows another extra piece of code that lists the primes we’ve found.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们逐步检查我们构建的列表，并计算其中有多少个`true`条目，每次增加变量`primecount`的值。[图 2-14](ch02.xhtml#ch2fig14)展示了另一段额外的代码，用于列出我们找到的素数。
- en: '![Image](../images/pg54_Image_50.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg54_Image_50.jpg)'
- en: '*Figure 2-14: Listing primes with the sieve program*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-14：使用筛法列出素数*'
- en: This block finds the `true` items in the list and stores their corresponding
    index numbers in a separate list.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块会找到列表中的`true`项，并将它们对应的索引号存储到一个单独的列表中。
- en: Hacking the Code
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: Sometimes it’s useful to have the data that Scratch generates as a separate
    file so you can import it into a text editor or a spreadsheet. Fortunately, Scratch
    gives us the option to import and export lists by right-clicking the list in the
    graphics window (see [Figure 2-15](ch02.xhtml#ch2fig15)). This way, you can take
    your sieved list of primes out of Scratch to play with it further.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将 Scratch 生成的数据保存为单独的文件是很有用的，这样你就可以将其导入到文本编辑器或电子表格中。幸运的是，Scratch 允许我们通过右键点击图形窗口中的列表来导入和导出列表（见
    [图 2-15](ch02.xhtml#ch2fig15)）。通过这种方式，你可以将筛选出的素数列表从 Scratch 中取出，进一步处理。
- en: '![Image](../images/pg55_Image_51.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg55_Image_51.jpg)'
- en: '*Figure 2-15: Saving the list to work on later*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-15：保存列表以便稍后使用*'
- en: Text editors, word processors, and spreadsheet programs are happy to work with
    the text output from Scratch. Try importing your data into a spreadsheet program
    such as Excel, Numbers, or Open Office. If you want several entries per row, make
    sure you have Scratch insert commas separating the entries in your text file (using
    the `join` block), and then use the *CSV* format, short for *comma-separated values*,
    to import it. The default carriage returns in the file that Scratch produces will
    list the entries in separate rows in the spreadsheet.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑器、文字处理软件和电子表格程序都能很方便地处理 Scratch 输出的文本数据。试着将数据导入 Excel、Numbers 或 Open Office
    等电子表格程序。如果你希望每行包含多个条目，确保 Scratch 在文本文件中插入逗号分隔条目（使用 `join` 块），然后使用 *CSV* 格式（即 *逗号分隔值*
    格式）导入数据。Scratch 生成的文件中的默认换行符将把条目列在电子表格的不同行中。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**2.6** Use the sieve program to find how many primes there are between 1 and
    10, 100, 1,000, 10,000, and 100,000\. Keep track of the ratio between the number
    of primes and the size of the list, and display your results in a table. How does
    the relative number of primes appear to be changing as the upper bound increases?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.6** 使用筛选程序找出 1 到 10、100、1,000、10,000 和 100,000 之间有多少个素数。记录素数数量与列表大小之间的比例，并以表格形式展示结果。当上限增大时，素数的相对数量是如何变化的？'
- en: '**2.7** Write a block to scan the list of integers that the sieve program produces,
    looking for long sequences of consecutive composite numbers. What’s the longest
    sequence you can find?'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.7** 编写一个块来扫描筛选程序生成的整数列表，寻找长的连续合数序列。你能找到最长的序列吗？'
- en: '**2.8** *Twin primes* are pairs of primes that differ by exactly 2; for example,
    3 and 5 or 11 and 13\. Write a block to scan the sieve program’s output and count
    how many pairs of twin primes there are up to the sieving limit.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.8** *双生素数*是相差恰好为 2 的一对素数；例如，3 和 5 或 11 和 13。编写一个块来扫描筛选程序的输出，并计算在筛选限制范围内有多少对双生素数。'
- en: '**2.9** Rewrite the sieve program in [Figure 2-12](ch02.xhtml#ch2fig12) so
    it displays the results in a table six entries wide, like the table in [Figure
    2-9](ch02.xhtml#ch2fig9). Use the language of congruences to explain why the only
    prime numbers that appear after the first row of the table are in columns 1 and
    5.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.9** 重写 [图 2-12](ch02.xhtml#ch2fig12) 中的筛选程序，使其将结果以六列的表格显示，像 [图 2-9](ch02.xhtml#ch2fig9)
    中的表格一样。使用同余语言解释为什么表格第一行之后出现的唯一素数仅位于第 1 列和第 5 列。'
- en: Nothing Common About Common Divisors
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公约数与最大公约数的关系
- en: Given two integers *a* and *b*, the *set of common divisors* refers to all the
    integers that evenly divide both *a* and *b*. There will always be at least one
    common divisor, the number 1, since 1 is a factor of all integers. But larger
    common divisors might exist as well. Of particular interest is the *greatest common
    divisor (GCD)*, the largest number that evenly divides *a* and *b*. If this largest
    common divisor is *d*, we write GCD(*a*, *b*) = *d*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个整数 *a* 和 *b*，*公约数集合*指的是所有能整除 *a* 和 *b* 的整数。总是至少有一个公约数，那就是数字 1，因为 1 是所有整数的因子。但也可能存在更大的公约数。特别关注的是
    *最大公约数（GCD）*，它是能够整除 *a* 和 *b* 的最大数。如果这个最大公约数是 *d*，我们写作 GCD(*a*, *b*) = *d*。
- en: As with identifying primes, there are several methods for finding the GCD of
    two numbers, with varying degrees of efficiency. We’ll explore two such techniques
    in the next two projects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与识别素数一样，求两个数的最大公约数（GCD）有多种方法，它们的效率各不相同。在接下来的两个项目中，我们将探讨两种这种方法。
- en: 'Project 8: Greatest Common Divisors the Slow Way'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 8：慢速求最大公约数
- en: Here’s one way to find the greatest common divisor between two integers *a*
    and *b*. Starting from 1, try dividing *a* and *b* by every number. If it divides
    evenly into both of them, you’ve found a common divisor. Stop once you reach *a*
    or *b*, whichever comes first. The highest common divisor you’ve found is the
    GCD. The program in [Figure 2-16](ch02.xhtml#ch2fig16) uses this approach.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是找到两个整数 *a* 和 *b* 最大公约数的一种方法。从 1 开始，尝试用每个数字分别除以 *a* 和 *b*。如果它能同时整除这两个数，你就找到了一个公约数。一旦你到达
    *a* 或 *b*，取先到的为止。你找到的最大的公约数就是最大公约数。图 [Figure 2-16](ch02.xhtml#ch2fig16) 中的程序使用了这种方法。
- en: We use a custom block to identify the minimum of the two input values, `a` and
    `b`. Then we count up from `1` to the minimum, checking if the `mod` of both `a`
    and `b` is `0`. If it is, we store the current divisor in the variable `gcd`,
    which holds our answer when the program finishes running.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个自定义块来识别两个输入值 `a` 和 `b` 中的最小值。然后我们从 `1` 开始向上计数，检查 `a` 和 `b` 的 `mod` 是否为
    0。如果是，我们将当前的除数存储在变量 `gcd` 中，程序运行结束时，这个变量保存了答案。
- en: This technique of testing every number as a possible common divisor is known
    as a *brute-force* approach. It’s like trying to guess someone’s computer password
    by testing out every possible sequence of letters and numbers. For our GCD program,
    brute force is fast enough for smaller values of `a` and `b`, say up to 1 million,
    but it’s noticeably slower for larger numbers. As the numbers being screened get
    closer to flintmax, it becomes especially annoying to wait. Luckily, there’s a
    better way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试每个数字作为可能的公约数的方法被称为 *暴力破解* 方法。就像通过测试每一种可能的字母和数字组合来猜测某人的计算机密码一样。对于我们的 GCD
    程序，暴力破解对于较小的 `a` 和 `b` 值（例如最大到 100 万）足够快，但对于更大的数字来说，它明显变得更慢。当筛选的数字接近最大值时，等待时间特别烦人。幸运的是，有更好的方法。
- en: '![Image](../images/pg57_Image_52.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg57_Image_52.jpg)'
- en: '*Figure 2-16: Finding the GCD the slow way*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-16：使用慢方法查找 GCD*'
- en: 'Project 9: Greatest Common Divisors the Fast Way'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 9：快速求最大公约数
- en: The Greek mathematician Euclid described a more efficient method for calculating
    the greatest common divisor of two numbers in his textbook *The Elements*, which
    was written around 300 BCE. *The Elements* covers topics in several different
    areas of mathematics, focusing on geometry and number theory. The book was so
    influential that Euclid’s organization of the material was used to teach mathematics
    for centuries, and it continues to be used today.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 古希腊数学家欧几里得在其公元前300年左右写成的教材《几何原本》中描述了一种更高效的计算两个数最大公约数的方法。《几何原本》涵盖了多个数学领域的主题，重点是几何学和数论。该书影响深远，欧几里得的材料组织方式在几个世纪内用于教学，直到今天仍然被沿用。
- en: Euclid’s approach to calculating greatest common divisors is based on the observation
    that for two positive integers *a* and *b* where *a* < *b*, any common divisor
    of *a* and *b* is also a divisor of *b* – *a*. For example, say *a* = 330 and
    *b* = 876\. A common divisor of 330 and 876 is 6, and 6 is also a divisor of 876
    – 330 = 546.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得计算最大公约数的方法基于这样一个观察：对于两个正整数 *a* 和 *b*，其中 *a* < *b*，任何 *a* 和 *b* 的公约数也是 *b*
    - *a* 的约数。例如，假设 *a* = 330 且 *b* = 876。330 和 876 的公约数是 6，6 同时也是 876 - 330 = 546
    的约数。
- en: 'By extension, if we divide the larger of the two numbers, *b*, by the smaller,
    *a*, and keep track of the division with a quotient and remainder, *b* = *q* ⋅
    *a* + *r*, then any common divisor of *b* and *a* is also a divisor of *a* and
    *r*. Then we can repeat the process with *a* and *r*, and so on until there’s
    a last remainder of 0\. At this point, the next-to-last remainder is the greatest
    common divisor of *a* and *b*. The sequence of divisions looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展，如果我们用较大的数 *b* 除以较小的数 *a*，并通过商和余数跟踪除法，即 *b* = *q* ⋅ *a* + *r*，那么 *b* 和 *a*
    的任何公约数也是 *a* 和 *r* 的公约数。然后我们可以用 *a* 和 *r* 重复这个过程，直到最后的余数为 0。在这个时候，倒数第二个余数就是 *a*
    和 *b* 的最大公约数。除法序列如下所示：
- en: '![Image](../images/pg58_Image_53.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg58_Image_53.jpg)'
- en: The remainders decrease, so *a* > *r*[1] > *r*[2] > . . . > *r*[*k*], with *r*[*k*]
    = GCD(*b*, *a*) and *r*[*k* + 1] = 0.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 余数逐渐减少，因此 *a* > *r*[1] > *r*[2] > . . . > *r*[*k*]，其中 *r*[*k*] = GCD(*b*, *a*)
    且 *r*[*k* + 1] = 0。
- en: 'Here are the steps to calculate that 6 is the greatest common divisor of *b*
    = 876 and *a* = 330, interpreted both with the division algorithm and with modular
    arithmetic. Notice how the values shift positions from right to left as we move
    from one line to the next:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是计算 6 是 *b* = 876 和 *a* = 330 的最大公约数的步骤，分别使用除法算法和模算术进行解释。注意，随着我们从一行到下一行，数值的顺序是如何从右到左变化的：
- en: '![Image](../images/pg58_Image_54.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg58_Image_54.jpg)'
- en: The Scratch program in [Figure 2-17](ch02.xhtml#ch2fig17) implements Euclid’s
    algorithm.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-17](ch02.xhtml#ch2fig17)中的 Scratch 程序实现了欧几里得算法。'
- en: '![Image](../images/pg58_Image_55.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg58_Image_55.jpg)'
- en: '*Figure 2-17: Finding the GCD with Euclid’s algorithm*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-17：使用欧几里得算法求最大公约数*'
- en: The program is organized so all the work of the repeated division occurs in
    the custom `gcd` block ❶. The block’s definition is surprisingly short compared
    to our brute-force GCD program ([Figure 2-16](ch02.xhtml#ch2fig16)). Inside a
    `repeat until` loop, we keep taking `b mod a` ➋ and shuffling the values of `a`
    and `r` back into `b` and `a` until we finally get down to a remainder of 0\.
    That’s where the loop stops, and the last value of `a` can be reported as the
    GCD ➌.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的组织方式是将所有重复除法的工作放在自定义的 `gcd` 块 ❶ 中。与我们的蛮力 GCD 程序（[图 2-16](ch02.xhtml#ch2fig16)）相比，这个块的定义异常简短。在一个
    `repeat until` 循环中，我们不断进行 `b mod a` ➋ 运算，并将 `a` 和 `r` 的值交换回 `b` 和 `a`，直到最终得到余数为
    0\。这时，循环停止，最后的 `a` 值可以作为 GCD 报告 ➌。
- en: The Results
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 2-18](ch02.xhtml#ch2fig18) shows a sample run of the GCD program with
    two very large numbers as inputs.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-18](ch02.xhtml#ch2fig18)展示了一个示例，运行 GCD 程序，输入为两个非常大的数字。'
- en: '![Image](../images/pg59_Image_56.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg59_Image_56.jpg)'
- en: '*Figure 2-18: A calculation with Euclid’s algorithm*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-18：使用欧几里得算法的计算*'
- en: Unlike our brute-force approach, the code works very quickly, even for numbers
    close to flintmax.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的蛮力方法不同，代码运行非常迅速，即使对于接近 flintmax 的数字也是如此。
- en: Hacking the Code
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: So far, the language we’ve used to talk about how efficient an algorithm is
    has been pretty general. We talk about a program running quickly or slowly, but
    it would be good to know just how quickly or slowly that turns out to be on your
    computer. It would also be useful to see how the program’s performance changes
    as we go from working with numbers in the tens or hundreds to numbers in the thousands
    or millions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们谈论算法效率的语言还比较笼统。我们说一个程序运行得快或慢，但最好知道在你的计算机上实际的速度有多快或多慢。看到程序性能随着数字从十位或百位到千位或百万位的变化也会很有用。
- en: Scratch has a built-in timer that measures elapsed time in seconds from the
    moment a program starts executing. It’s accessible via the `timer` block in the
    Sensing section of the block menu. We can take any program and wrap it in a few
    lines of code to time how long an algorithm takes to run, as shown in [Figure
    2-19](ch02.xhtml#ch2fig19).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch 内置了一个计时器，可以从程序开始执行的那一刻起，按秒计量经过的时间。通过块菜单中的 `timer` 块可以访问该计时器。我们可以将任何程序包装在几行代码中，来计算算法运行的时间，如
    [图 2-19](ch02.xhtml#ch2fig19) 所示。
- en: '![Image](../images/pg59_Image_57.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg59_Image_57.jpg)'
- en: '*Figure 2-19: Timing how fast a program runs*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-19：计时程序运行速度*'
- en: Here, the `initialize` block would contain any setup code that you don’t want
    to time, such as prompting the user for input, while the `run code` block would
    contain the code for the algorithm you want to time. We record the value of `timer`
    before and after executing `run code`, then take the difference between the two
    times to see how long the execution took.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`initialize` 块包含任何你不希望计时的设置代码，比如提示用户输入，而 `run code` 块则包含你想要计时的算法代码。我们在执行
    `run code` 之前和之后记录 `timer` 的值，然后取两者之间的差值来查看执行花费了多少时间。
- en: '![Image](../images/pg60_Image_58.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg60_Image_58.jpg)'
- en: '*Figure 2-20: Testing a big prime number*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-20：测试一个大素数*'
- en: '[Figure 2-20](ch02.xhtml#ch2fig20) shows the result of wrapping the trial division
    prime testing program from [Figure 2-6](ch02.xhtml#ch2fig6) in the timer code,
    including the value of `elapsed time` when the program finishes. For a prime close
    to flintmax, it takes my computer a little over a minute to report.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-20](ch02.xhtml#ch2fig20)展示了将 [图 2-6](ch02.xhtml#ch2fig6) 中的试除法素数测试程序包装在计时器代码中的结果，包括程序结束时
    `elapsed time` 的值。对于一个接近 flintmax 的素数，程序运行结果大约需要一分钟。'
- en: For many programs with small test values, the elapsed time will show as `0`,
    since the algorithm takes only a fraction of a second to run. The reported time
    might also vary across runs because your computer is doing other things in the
    background, which limits the amount of resources Scratch has available to do its
    job. To get an accurate time, run the program lots of times in a row and keep
    track of the cumulative runtime, then divide by the number of times you ran the
    program to find the average time for each run.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多具有小测试值的程序，经过的时间将显示为 `0`，因为算法运行只需要一小部分时间。报告的时间也可能在不同的运行之间有所不同，因为计算机在后台执行其他任务，这限制了
    Scratch 可用的资源。为了获得准确的时间，连续多次运行程序并记录累积的运行时间，然后将其除以运行次数，得到每次运行的平均时间。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**2.10** Use timing loops to compare the runtimes for the two GCD calculating
    programs (the brute-force version in [Figure 2-16](ch02.xhtml#ch2fig16) and the
    Euclidean version in [Figure 2-17](ch02.xhtml#ch2fig17)).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.10** 使用计时循环来比较两个最大公约数计算程序的运行时间（[图 2-16](ch02.xhtml#ch2fig16) 中的暴力版本和[图
    2-17](ch02.xhtml#ch2fig17) 中的欧几里得版本）。'
- en: '**2.11** Program a counter to count how many steps Euclid’s algorithm takes.
    Experiment to see what numbers make the algorithm take the highest number of steps
    to run.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.11** 编写一个计数器来计算欧几里得算法需要多少步。进行实验，看看哪些数字会使算法需要最多的步骤来运行。'
- en: Conclusion
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Computations involving divisibility are much easier and faster to do with computer
    assistance. If I had to work out if a number was prime by doing trial division
    by hand, I would probably give up after a few dozen calculations. Even if I were
    punching possible divisors into a calculator, I would get bored pretty quickly
    and probably start making mistakes (“trial and error” is mostly error!). But Scratch
    Cat is eager to help out for as long as I want. Scratch is a telescope that lets
    us look deeper into the universe of numbers than we could ever do ourselves. All
    we have to do is ask.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及可除性的计算在计算机帮助下要容易和快速得多。如果我必须通过手工试除来判断一个数字是否为素数，我可能在几次计算后就会放弃。即使我在计算器上输入可能的除数，我也会很快感到厌烦，并可能开始犯错（“试错法”大多是错误！）。但
    Scratch 猫愿意在我需要时提供帮助。Scratch 是一个望远镜，它让我们能够比自己做得到的更深入地观察数字的世界。我们所需要做的就是提出请求。
