- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    WINDOWS KERNEL</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS
    内核</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: Windows is a secure, multiuser operating system. However, it’s also one of the
    most challenging modern operating systems to understand in detail. Before we delve
    into the intricacies of its security, in this part of the book I’ll provide you
    with an overview of the operating system’s structure. We’ll also take this opportunity
    to understand how to use the PowerShell module that will form the core of this
    book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 是一个安全的多用户操作系统。然而，它也是现代操作系统中最难以深入理解的系统之一。在我们深入探讨其安全性之前，本书的这一部分将为你提供操作系统结构的概述。我们还将借此机会了解如何使用本书核心的
    PowerShell 模块。
- en: 'We’ll consider the two parts of the running operating system: the kernel and
    the user-mode applications. The kernel makes the security decisions that determine
    what a user can do on the system. However, most of the applications you use on
    a Windows machine run in user mode. This chapter will focus on the kernel; the
    next chapter will focus on user-mode applications.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑运行中的操作系统的两个部分：内核和用户模式应用程序。内核做出决定，确定用户在系统上能做什么。然而，你在 Windows 机器上使用的大多数应用程序都运行在用户模式下。本章将重点介绍内核；下一章将重点讨论用户模式应用程序。
- en: In the following sections, we’ll examine the various subsystems that make up
    the Windows kernel. For each subsystem, I’ll explain its purpose and how it’s
    used. We’ll begin with the object manager, where we’ll also explore system calls,
    which allow a user-mode application to access kernel objects. We’ll then discuss
    the input/output manager, how applications are created through the process and
    thread manager, and how memory is represented with the memory manager. Throughout,
    I’ll outline how you can inspect the behavior of these subsystems using PowerShell.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论构成 Windows 内核的各个子系统。对于每个子系统，我将解释其用途以及如何使用它。我们将从对象管理器开始，同时探索系统调用，它们允许用户模式的应用程序访问内核对象。接着我们将讨论输入/输出管理器、通过进程和线程管理器创建应用程序的方式，以及内存管理器如何表示内存。整个过程中，我将概述如何使用
    PowerShell 检查这些子系统的行为。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Windows Kernel Executive</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Windows 内核执行</samp>
- en: The *Windows NTOS kernel executive*, or *kernel* for short, is the heart of
    Windows. It provides all the operating system’s privileged functionality, as well
    as interfaces through which the user applications can communicate with the hardware.
    The kernel is split into multiple subsystems, each with a dedicated purpose. [Figure
    2-1](chapter2.xhtml#fig2-1) shows a diagram of the components in which we’ll be
    most interested in this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Windows NTOS 内核执行*，简称*内核*，是 Windows 的核心。它提供了操作系统的所有特权功能，并通过接口使用户应用程序能够与硬件进行通信。内核被划分为多个子系统，每个子系统都有其专门的功能。[图
    2-1](chapter2.xhtml#fig2-1)展示了我们在本书中最为关注的组件的示意图。'
- en: '![](../images/Figure2-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The Windows kernel
    executive modules</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-1：Windows 内核执行模块</samp>
- en: Each subsystem in the kernel executive exposes APIs for other subsystems to
    call. If you are looking at kernel code, you can quickly determine what subsystem
    each API belongs to using its two-character prefix. The prefixes for the subsystems
    in [Figure 2-1](chapter2.xhtml#fig2-1) are shown in [Table 2-1](chapter2.xhtml#tab2-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内核执行中的每个子系统都暴露了供其他子系统调用的 API。如果你正在查看内核代码，可以通过每个 API 的两个字符前缀迅速确定它属于哪个子系统。[图 2-1](chapter2.xhtml#fig2-1)中子系统的前缀在[表
    2-1](chapter2.xhtml#tab2-1)中有所展示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">API
    Prefix-to-Subsystem Mapping</samp>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-1：</samp> <samp class="SANS_Futura_Std_Book_11">API
    前缀与子系统映射</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Prefix</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Subsystem</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp> |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">前缀</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">子系统</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">示例</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> | <samp class="SANS_Futura_Std_Book_11">System
    call interface</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenFile</samp><samp
    class="SANS_Futura_Std_Book_11">/</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">ZwOpenFile</samp>
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> <samp class="SANS_Futura_Std_Book_11">或</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> | <samp class="SANS_Futura_Std_Book_11">系统调用接口</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenFile</samp><samp class="SANS_Futura_Std_Book_11">/</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZwOpenFile</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Se</samp> | <samp class="SANS_Futura_Std_Book_11">Security
    Reference Monitor</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Se</samp> | <samp class="SANS_Futura_Std_Book_11">安全参考监视器</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ob</samp> | <samp class="SANS_Futura_Std_Book_11">Object
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ObReferenceObjectByHandle</samp>
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ob</samp> | <samp class="SANS_Futura_Std_Book_11">对象管理器</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ObReferenceObjectByHandle</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ps</samp> | <samp class="SANS_Futura_Std_Book_11">Process
    and thread manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">PsGetCurrentProcess</samp>
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ps</samp> | <samp class="SANS_Futura_Std_Book_11">进程和线程管理器</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">PsGetCurrentProcess</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Cm</samp> | <samp class="SANS_Futura_Std_Book_11">Configuration
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">CmRegisterCallback</samp>
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Cm</samp> | <samp class="SANS_Futura_Std_Book_11">配置管理器</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">CmRegisterCallback</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mm</samp> | <samp class="SANS_Futura_Std_Book_11">Memory
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MmMapIoSpace</samp>
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mm</samp> | <samp class="SANS_Futura_Std_Book_11">内存管理器</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">MmMapIoSpace</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Io</samp> | <samp class="SANS_Futura_Std_Book_11">Input/output
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IoCreateFile</samp>
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Io</samp> | <samp class="SANS_Futura_Std_Book_11">输入/输出管理器</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">IoCreateFile</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ci</samp> | <samp class="SANS_Futura_Std_Book_11">Code
    integrity</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">CiValidateFileObject</samp>
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ci</samp> | <samp class="SANS_Futura_Std_Book_11">代码完整性</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">CiValidateFileObject</samp> |'
- en: We’ll explore all of these subsystems in the sections that follow.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中探讨所有这些子系统。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Security Reference Monitor</samp>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">安全参考监视器</samp>
- en: For the purposes of this book, the *Security Reference Monitor (SRM)* is the
    most important subsystem in the kernel. It implements the security mechanisms
    that restrict which users can access different resources. Without the SRM, you
    wouldn’t be able to prevent other users from accessing your files. [Figure 2-2](chapter2.xhtml#fig2-2)
    shows the SRM and its related system components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的目的，*安全参考监视器 (SRM)* 是内核中最重要的子系统。它实现了安全机制，限制了哪些用户可以访问不同的资源。如果没有SRM，你将无法防止其他用户访问你的文件。[图
    2-2](chapter2.xhtml#fig2-2)展示了SRM及其相关系统组件。
- en: '![](../images/Figure2-2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: Components of the
    Security Reference Monitor</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-2：安全参考监视器的组成部分</samp>
- en: Every process running on the system is assigned an *access token* when it’s
    created. This access token is managed by the SRM and defines the identity of the
    user associated with that process. The SRM can then perform an operation called
    an *access check*. This operation queries a resource’s security descriptor, compares
    it to the process’s access token, and either calculates the level of granted access
    or indicates that access is denied to the caller.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在系统中运行的进程在创建时都会分配一个*访问令牌*。这个访问令牌由SRM管理，并定义与该进程关联的用户身份。然后，SRM可以执行一种叫做*访问检查*的操作。该操作查询资源的安全描述符，将其与进程的访问令牌进行比较，计算授予的访问级别，或者指示拒绝对调用者的访问。
- en: The SRM is also responsible for generating audit events whenever a user accesses
    a resource. Auditing is disabled by default due to the volume of events it can
    produce, so an administrator must enable it first. These audit events can be used
    to identify malicious behavior on a system as well as to diagnose security misconfigurations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SRM 还负责在用户访问资源时生成审计事件。由于它可能产生大量事件，默认情况下审计功能是禁用的，因此管理员必须首先启用它。这些审计事件可以用于识别系统上的恶意行为，并帮助诊断安全配置错误。
- en: The SRM expects users and groups to be represented as binary structures called
    *security identifiers (SIDs)*. However, passing around raw binary SIDs isn’t very
    convenient for users, who normally refer to users and groups by meaningful names
    (for example, the user *bob* or the *Users* group). These names need to be converted
    to SIDs before the SRM can use them. The task of name–SID conversion is handled
    by the *Local Security Authority Subsystem (LSASS)*, which runs inside a privileged
    process independent from any logged-in users.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SRM 期望用户和组被表示为称为*安全标识符 (SIDs)* 的二进制结构。然而，传递原始二进制 SID 对用户并不方便，因为用户通常通过有意义的名称（例如，用户
    *bob* 或 *Users* 组）来引用用户和组。在 SRM 使用这些名称之前，需要将它们转换为 SID。名称到 SID 的转换任务由 *本地安全权限子系统
    (LSASS)* 处理，它在一个与任何登录用户独立的特权进程中运行。
- en: It’s infeasible to represent every possible SID as a name, so Microsoft defines
    the *Security Descriptor Definition Language (SDDL)* format to represent a SID
    as a string. SDDL can represent the entire security descriptor of a resource,
    but for now we’ll just use it to represent the SID. In [Listing 2-1](chapter2.xhtml#Lis2-1),
    we use PowerShell to look up the *Users* group name using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    command; this should retrieve the SDDL string for the SID.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法将每个可能的 SID 表示为名称，因此 Microsoft 定义了*安全描述符定义语言 (SDDL)* 格式，用于将 SID 表示为字符串。SDDL
    可以表示资源的整个安全描述符，但目前我们仅使用它来表示 SID。在[列表 2-1](chapter2.xhtml#Lis2-1)中，我们使用 PowerShell
    通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> 命令查找 *Users*
    组的名称；这应该会检索该 SID 的 SDDL 字符串。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: Querying the SID of the <samp class="SANS_Futura_Std_Book_11">Users</samp>
    group using Get-NtSid'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-1：使用 Get-NtSid 查询 *Users* 组的 SID
- en: 'We pass the name of the *Users* group to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>,
    which returns the fully qualified name, with the local domain *BUILTIN* attached.
    The *BUILTIN\Users* SID is always the same between different Windows systems.
    The output also contains the SID in SDDL format, which can be broken down into
    the following dash-separated parts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 *Users* 组的名称传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>，它返回完全限定的名称，并附加上本地域
    *BUILTIN*。*BUILTIN\Users* SID 在不同的 Windows 系统之间始终相同。输出还包含 SID 的 SDDL 格式，它可以分解为以下破折号分隔的部分：
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp> character prefix.
    This indicates that what follows is an SDDL SID.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp>字符前缀。这表示接下来的内容是一个 SDDL
    SID。
- en: The version of the SID structure in decimal. This has a fixed value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SID 结构的十进制版本。其固定值为<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。
- en: The security authority. Authority <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    indicates the built-in NT authority.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全权限。权限<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>表示内置的 NT 权限。
- en: Two relative identifiers (RIDs), in decimal. The RIDs (here, <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">545</samp>) represent the NT
    authority group.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个相对标识符 (RIDs)，以十进制表示。RIDs（这里是 <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">545</samp>）表示 NT 权限组。
- en: We can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    to perform the reverse operation, converting an SDDL SID back to a name, as shown
    in [Listing 2-2](chapter2.xhtml#Lis2-2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> 执行反向操作，将
    SDDL SID 转换回名称，如[列表 2-2](chapter2.xhtml#Lis2-2)所示。
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 2-2: Using Get-NtSid to find the name associated with a SID'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-2：使用 Get-NtSid 查找与 SID 关联的名称
- en: I’ll describe the SRM and its functions in much greater depth in [Chapters 4](chapter4.xhtml)
    through [9](chapter9.xhtml), and we’ll revisit the SID structure in [Chapter 5](chapter5.xhtml),
    when we discuss security descriptors. For now, remember that SIDs represent users
    and groups and that we can represent them as strings in SDDL form. Next, we’ll
    move on to another of the core Windows kernel executive subsystems, the object
    manager.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第4章](chapter4.xhtml)到[第9章](chapter9.xhtml)中更深入地描述SRM及其功能，并且在[第5章](chapter5.xhtml)中，我们会在讨论安全描述符时重新访问SID结构。现在，请记住，SID代表用户和组，我们可以将其表示为SDDL格式的字符串。接下来，我们将继续介绍Windows内核执行子系统中的另一个核心组件——对象管理器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Object Manager</samp>
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">对象管理器</samp>
- en: On Unix-like operating systems, everything is a file. On Windows, everything
    is an object, meaning that every file, process, and thread is represented in kernel
    memory as an object structure. Importantly for security, each of these objects
    can have an assigned security descriptor, which restricts which users can access
    the object and determines the type of access they have (for example, read or write).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在类Unix操作系统中，一切都是文件。而在Windows中，一切都是对象，这意味着每个文件、进程和线程都在内核内存中作为对象结构表示。对于安全性来说非常重要的是，每个对象都可以有一个分配的安全描述符，它限制了哪些用户可以访问该对象，并确定他们的访问权限类型（例如，读或写）。
- en: The *object manager* is the component of the kernel responsible for managing
    these resource objects, their memory allocations, and their lifetimes. In this
    section, we’ll first discuss the types of objects the object manager supports.
    Then, we’ll explore how kernel objects can be opened through a naming convention
    using a system call. Finally, we’ll look at how to use a handle returned by the
    system call to access the object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象管理器*是内核中负责管理这些资源对象、它们的内存分配和生命周期的组件。在本节中，我们将首先讨论对象管理器支持的对象类型。然后，我们将探讨如何通过命名约定使用系统调用打开内核对象。最后，我们将看看如何使用系统调用返回的句柄访问该对象。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Types</samp>
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对象类型</samp>
- en: The kernel maintains a list of all the types of objects it supports. This is
    necessary, as each object type has different supported operations and security
    properties. [Listing 2-3](chapter2.xhtml#Lis2-3) shows how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp>
    command to list all supported types in the kernel.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 内核维护着它支持的所有对象类型的列表。这是必要的，因为每种对象类型具有不同的支持操作和安全属性。[列表 2-3](chapter2.xhtml#Lis2-3)展示了如何使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp>命令列出内核中所有支持的类型。
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 2-3: Executing Get-NtType'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-3：执行 Get-NtType
- en: I’ve truncated the list of types (the machine I’m using supports 72 of them),
    but there are some noteworthy entries even in this short section. The first entry
    in the generated list is <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>;
    even the list of kernel types is built from objects! Other types of note here
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp>,
    which represent the kernel objects for a process and a thread, respectively. We’ll
    examine other object types in more detail later in this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经截断了类型列表（我使用的机器支持72种类型），但即使在这个简短的部分中，也有一些值得注意的条目。生成的列表中的第一个条目是<samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>；即使是内核类型的列表也是由对象构建的！这里还有其他值得注意的类型，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp>，分别表示进程和线程的内核对象。我们将在本章稍后部分更详细地探讨其他对象类型。
- en: You can display the properties of a type with <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>,
    which returns additional information about that type. We’ll look at an example
    later, but for now the question is how to access each of these types. To answer
    it, we’ll need to talk about the object manager namespace.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>显示类型的属性，它会返回该类型的附加信息。稍后我们会看一个例子，但现在的问题是如何访问这些类型。为了回答这个问题，我们需要讨论对象管理器命名空间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Object Manager
    Namespace</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对象管理器命名空间</samp>
- en: As a user of Windows, you typically see your filesystem drives in Explorer.
    But underneath the user interface is a whole additional filesystem just for kernel
    objects. Access to this filesystem, referred to as the *object manager namespace
    (OMNS)*, isn’t very well documented or exposed to most developers, which makes
    it even more interesting.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Windows 用户，你通常在资源管理器中看到你的文件系统驱动。然而，在用户界面下方，实际上还有一个专门为内核对象设计的额外文件系统。对这个文件系统的访问，称为
    *对象管理器命名空间 (OMNS)*，大多数开发人员都没有详细文档或直接访问权限，这使得它更加有趣。
- en: The OMNS is built out of <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    objects. The objects act as if they were in a filesystem, so each directory contains
    other objects, which you can consider to be files. However, they are distinct
    from the file directories you’re used to. Each directory is configured with a
    security descriptor that determines which users can list its contents and which
    users can create new subdirectories and objects inside it. You can specify the
    full path to an object with a backslash-separated string.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: OMNS 是由 <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> 对象构建的。这些对象的行为类似于文件系统，因此每个目录都包含其他对象，你可以将它们视为文件。然而，它们与你熟悉的文件目录不同。每个目录都配置了一个安全描述符，用于确定哪些用户可以列出其内容，哪些用户可以在其中创建新的子目录和对象。你可以使用反斜杠分隔的字符串指定对象的完整路径。
- en: We can enumerate the OMNS by using a drive provider that is part of this book’s
    PowerShell module. As shown in [Listing 2-4](chapter2.xhtml#Lis2-4), this exposes
    the OMNS as if it were a filesystem by listing the *NtObject* drive.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用本书 PowerShell 模块中的驱动提供程序来枚举 OMNS。如[示例 2-4](chapter2.xhtml#Lis2-4)所示，这将
    OMNS 显示为一个文件系统，通过列出 *NtObject* 驱动。
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 2-4: Listing the root OMNS directory'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-4：列出根 OMNS 目录
- en: '[Listing 2-4](chapter2.xhtml#Lis2-4) shows a short snippet of the root OMNS
    directory. By default, this output includes the name of each object and its type.
    We can see a few <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    objects; you can list them if you have permission to do so. We can also see another
    important type, <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>.
    You can use symbolic links to redirect one OMNS path to another. A <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>
    object contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp>
    property, which itself contains the target that the link should open. For example,
    [Listing 2-5](chapter2.xhtml#Lis2-5) shows the target for a symbolic link in the
    root of the OMNS.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-4](chapter2.xhtml#Lis2-4)展示了根 OMNS 目录的简短片段。默认情况下，输出包括每个对象的名称及其类型。我们可以看到几个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> 对象；如果你有权限，可以列出它们。我们还可以看到另一个重要的类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>。你可以使用符号链接将一个 OMNS
    路径重定向到另一个路径。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>
    对象包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp>
    属性，它本身包含该链接应打开的目标。例如，[示例 2-5](chapter2.xhtml#Lis2-5)展示了 OMNS 根目录中符号链接的目标。'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 2-5: Showing the target of a symbolic link'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-5：显示符号链接的目标
- en: Here, we list the *\Dfs* OMNS path, then extract the <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp>
    property to get the real target. Next, we check the target path, *Device\DfsClient*,
    to show it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> type,
    which is what the symbolic link can be used to access.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们列出 *\Dfs* OMNS 路径，然后提取 <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp>
    属性以获取实际目标。接着，我们检查目标路径 *Device\DfsClient*，以展示它是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    类型，这也是符号链接可以用来访问的内容。
- en: Windows preconfigures several important object directories, shown in [Table
    2-2](chapter2.xhtml#tab2-2).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 预先配置了几个重要的对象目录，见[表 2-2](chapter2.xhtml#tab2-2)。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-2:</samp> <samp class="SANS_Futura_Std_Book_11">Well-Known
    Object Directories and Descriptions</samp>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-2：</samp> <samp class="SANS_Futura_Std_Book_11">已知对象目录及描述</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">路径</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\BaseNamedObjects</samp>
    | <samp class="SANS_Futura_Std_Book_11">Global directory for user objects</samp>
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\BaseNamedObjects</samp>
    | <samp class="SANS_Futura_Std_Book_11">用户对象的全局目录</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Device</samp> | <samp class="SANS_Futura_Std_Book_11">Directory
    containing devices such as mounted filesystems</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Device</samp> | <samp class="SANS_Futura_Std_Book_11">包含诸如已挂载文件系统等设备的目录</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\GLOBAL??</samp> | <samp
    class="SANS_Futura_Std_Book_11">Global directory for symbolic links, including
    drive mappings</samp> |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\GLOBAL??</samp> | <samp
    class="SANS_Futura_Std_Book_11">符号链接的全局目录，包括驱动器映射</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\KnownDlls</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory containing special, known DLL mappings</samp>
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\KnownDlls</samp> | <samp
    class="SANS_Futura_Std_Book_11">包含特殊已知 DLL 映射的目录</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\ObjectTypes</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory containing named object types</samp>
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\ObjectTypes</samp> | <samp
    class="SANS_Futura_Std_Book_11">包含命名对象类型的目录</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Sessions</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory for separate console sessions</samp>
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Sessions</samp> | <samp
    class="SANS_Futura_Std_Book_11">用于单独控制台会话的目录</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Windows</samp> | <samp class="SANS_Futura_Std_Book_11">Directory
    for objects related to the Window Manager</samp> |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Windows</samp> | <samp class="SANS_Futura_Std_Book_11">与窗口管理器相关的对象目录</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\RPC Control</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory for remote procedure call endpoints</samp>
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\RPC Control</samp> | <samp
    class="SANS_Futura_Std_Book_11">远程过程调用端点的目录</samp> |'
- en: The first directory in [Table 2-2](chapter2.xhtml#tab2-2), *BaseNamedObjects
    (BNO)*, is important in the context of the object manager. It allows any user
    to create named kernel objects. This single directory allows the sharing of resources
    between different users on the local system. Note that you don’t have to create
    objects in the BNO directory; it’s only a convention.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-2](chapter2.xhtml#tab2-2) 中的第一个目录，*BaseNamedObjects (BNO)*，在对象管理器的上下文中非常重要。它允许任何用户创建命名的内核对象。这个单一的目录允许在本地系统的不同用户之间共享资源。请注意，你不必在
    BNO 目录中创建对象；这仅仅是一种约定。'
- en: I’ll describe the other object directories in more detail later in this chapter.
    For now, you can list them in PowerShell by prefixing the path with *NtObject:*,
    as I’ve shown in [Listing 2-5](chapter2.xhtml#Lis2-5).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章稍后更详细地描述其他对象目录。现在，你可以通过在路径前加上*NtObject:*来列出它们，正如我在[示例 2-5](chapter2.xhtml#Lis2-5)中所示。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">System Calls</samp>
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">系统调用</samp>
- en: How can we access the named objects in the OMNS from a user-mode application?
    If we’re in a user-mode application, we need the kernel to access the objects,
    and we can call kernel-mode code in a user-mode application using the system call
    interface. Most system calls perform some operation on a specific type of kernel
    object exposed by the object manager. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, a mutual exclusion primitive used for locking and thread synchronization.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在用户模式应用程序中访问 OMNS 中的命名对象？如果我们处于用户模式应用程序中，需要通过内核来访问这些对象，我们可以通过系统调用接口在用户模式应用程序中调用内核模式代码。大多数系统调用会对对象管理器暴露的特定类型的内核对象执行某些操作。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> 系统调用创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    对象，这是一个用于锁定和线程同步的互斥原语。
- en: The name of a system call follows a common pattern. It starts with either <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>.
    For user-mode callers, the two prefixes are equivalent; however, if the system
    call is invoked by code executing in the kernel, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    prefix changes the security checking process. We’ll come back to the implications
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> prefix in [Chapter
    7](chapter7.xhtml), when we talk about access modes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用的名称遵循一种常见的模式。它以<samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>开头。对于用户模式调用者，这两个前缀是等效的；然而，如果系统调用由在内核中执行的代码调用，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>前缀会改变安全检查过程。我们将在[第7章](chapter7.xhtml)中讨论<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>前缀的影响，届时我们会讲到访问模式。
- en: 'After the prefix comes the operation’s verb: <samp class="SANS_TheSansMonoCd_W5Regular_11">Create</samp>,
    in the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>.
    The rest of the name relates to the kernel object type the system call operates
    on. Common system-call verbs that perform an operation on a kernel object include:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀之后是操作的动词：在<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>的情况下是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Create</samp>。名称的其余部分与系统调用操作的内核对象类型相关。常见的系统调用动词包括：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Create  </samp>Creates a new object.
    Maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Nt</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><Type></samp>
    PowerShell commands.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Create  </samp>创建一个新对象。映射到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-Nt</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><Type></samp>
    PowerShell命令。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Open  </samp>Opens an existing
    object. Maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Nt</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><Type></samp> PowerShell commands.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Open  </samp>打开现有对象。映射到<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Nt</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><Type></samp> PowerShell命令。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryInformation  </samp>Queries
    object information and properties.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryInformation  </samp>查询对象信息和属性。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetInformation  </samp>Sets object
    information and properties.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetInformation  </samp>设置对象信息和属性。
- en: Certain system calls perform type-specific operations. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryFile</samp>
    is used to query the entries in a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    object directory. Let’s look at the C-language prototype for the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call to understand what parameters need to be passed to a typical call.
    As shown in [Listing 2-6](chapter2.xhtml#Lis2-6), the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 某些系统调用执行特定类型的操作。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryFile</samp>用于查询<samp
    class="SANS_TheSansMonoCd_W5Regular_11">File</samp>对象目录中的条目。让我们看一下<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>系统调用的C语言原型，以理解典型调用需要传递哪些参数。如[清单2-6](chapter2.xhtml#Lis2-6)所示，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>系统调用创建一个新的<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象。
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 2-6: The C prototype for NtCreateMutant'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-6：NtCreateMutant的C语言原型
- en: The first parameter for the system call is an outbound pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">HANDLE</samp>.
    Common in many system calls, this parameter is used to retrieve an opened handle
    to the object (in this case, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>)
    when the function succeeds. We use handles along with other system calls to access
    properties and perform operations. In the case of our <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, the handle allows us to acquire and release the lock to synchronize threads.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用的第一个参数是指向<samp class="SANS_TheSansMonoCd_W5Regular_11">HANDLE</samp>的输出指针。许多系统调用中都常见此参数，它用于在函数成功时检索已打开的对象句柄（在此情况下是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>）。我们使用句柄与其他系统调用一起访问属性并执行操作。在我们的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象的例子中，句柄允许我们获取和释放锁，以便同步线程。
- en: Next is <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>,
    which represents the operations the caller wants to be able to perform on the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> using the handle.
    For example, we could request access that allows us to wait for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    to be unlocked. If we didn’t request that access, any application that tried to
    wait on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> would
    immediately fail. The access granted depends on the results of the SRM’s access
    check. We’ll discuss handles and <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    in more detail in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>，它表示调用者希望对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 句柄执行的操作。例如，我们可以请求允许我们等待
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 解锁的访问权限。如果我们没有请求该权限，任何尝试等待
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 的应用程序将立即失败。授予的访问权限取决于
    SRM 访问检查的结果。我们将在下一节中更详细地讨论句柄和 <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>。
- en: Third is the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectAttributes</samp>
    parameter, which defines the attributes for the object to open or create. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> structure
    is defined as shown in [Listing 2-7](chapter2.xhtml#Lis2-7).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectAttributes</samp>，它定义了要打开或创建的对象的属性。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> 结构的定义请参见 [列表
    2-7](chapter2.xhtml#Lis2-7)。
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 2-7: The OBJECT_ATTRIBUTES structure'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-7：OBJECT_ATTRIBUTES 结构
- en: This C-language structure starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>,
    which represents the length of the structure. Specifying the structure length
    at the start is a common C-style idiom to ensure that the correct structure has
    been passed to the system call.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 C 语言结构从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp> 开始，表示结构的长度。在开始时指定结构长度是
    C 风格常见的写法，用来确保正确的结构已经传递到系统调用中。
- en: Next come <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>. These are
    taken together, as they indicate how the system call should look up the resource
    being accessed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp>
    is a handle to an opened kernel object to use as the base for looking up the object.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp> field is a
    pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    structure. This is a counted string, defined in [Listing 2-8](chapter2.xhtml#Lis2-8)
    as a C-language structure.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>。这两个参数一起使用，因为它们指示系统调用应该如何查找正在访问的资源。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp> 是一个已打开内核对象的句柄，用作查找对象的基准。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp> 字段是指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    结构的指针。该结构是一个计数字符串，定义在 [列表 2-8](chapter2.xhtml#Lis2-8) 中，作为 C 语言结构。
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 2-8: The UNICODE_STRING structure'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-8：UNICODE_STRING 结构
- en: The structure references the string data through <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>,
    which is a pointer to an array of 16-bit Unicode characters. The string is represented
    in UCS-2 encoding; Windows predates many of the changes to Unicode, such as UTF-8
    and UTF-16.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 引用字符串数据，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 是指向 16 位 Unicode 字符数组的指针。该字符串以
    UCS-2 编码表示；Windows 在 Unicode 许多变化（如 UTF-8 和 UTF-16）之前就已经存在。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp> structure
    also contains two length fields, <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumLength</samp>. The first
    length field represents the total valid length of the string pointed to by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>, in bytes (not in Unicode
    characters). If you’re coming from a C programming background, this length does
    not include any NUL terminating character. In fact, a NUL character is permitted
    in object names.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp> 结构还包含两个长度字段：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Length</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumLength</samp>。第一个长度字段表示由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 指向的字符串的有效总长度，以字节为单位（而不是
    Unicode 字符）。如果你有 C 语言编程背景，注意这个长度不包括任何 NUL 终止字符。事实上，NUL 字符在对象名称中是允许的。
- en: The second length field represents the maximum length of the string pointed
    to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>, in bytes. Because
    the structure has two separate lengths, it’s possible to allocate an empty string
    with a large maximum length and a valid length of zero, then update the string
    value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> pointer.
    Note that the lengths are stored as <samp class="SANS_TheSansMonoCd_W5Regular_11">USHORT</samp>
    values, which are unsigned 16-bit integers. Coupled with the length-representing
    bytes, this means a string can be at most 32,767 characters long.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个长度字段表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 所指向的字符串的最大长度（以字节为单位）。由于结构体有两个独立的长度字段，因此可以分配一个空字符串，具有较大的最大长度和有效长度为零，然后使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 指针更新字符串值。请注意，长度以 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">USHORT</samp> 值存储，这是无符号的16位整数。结合表示长度的字节，这意味着字符串的最大长度为
    32,767 个字符。
- en: 'To specify the name of an object, you have two options: you can set <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    to an absolute path of, for example, *\BaseNamedObjects\ABC*, or you can set <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object for *\BaseNamedObjects* and then pass <samp class="SANS_TheSansMonoCd_W5Regular_11">ABC</samp>
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>. These
    two actions will open the same object.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定一个对象的名称，您有两种选择：您可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    设置为绝对路径，例如 *\BaseNamedObjects\ABC*，或者您可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> 对象，为 *\BaseNamedObjects*，然后将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ABC</samp> 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    传递。这两种操作都会打开相同的对象。
- en: Returning to [Listing 2-7](chapter2.xhtml#Lis2-7), after the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    parameter comes <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>,
    which is a set of flags to modify the object name lookup process or change the
    returned handle’s properties. [Table 2-3](chapter2.xhtml#tab2-3) shows the valid
    values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>
    field.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 [清单 2-7](chapter2.xhtml#Lis2-7)，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    参数之后是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>，它是一组标志，用于修改对象名称查找过程或更改返回句柄的属性。[表
    2-3](chapter2.xhtml#tab2-3) 显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>
    字段的有效值。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-3:</samp> <samp class="SANS_Futura_Std_Book_11">Object
    Attribute Flags and Descriptions</samp>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-3:</samp> <samp class="SANS_Futura_Std_Book_11">对象属性标志和描述</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">PowerShell name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">PowerShell 名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp> | <samp class="SANS_Futura_Std_Book_11">Marks
    the handle as inheritable.</samp> |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp> | <samp class="SANS_Futura_Std_Book_11">将句柄标记为可继承。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Permanent</samp> | <samp class="SANS_Futura_Std_Book_11">Marks
    the handle as permanent.</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Permanent</samp> | <samp class="SANS_Futura_Std_Book_11">将句柄标记为永久。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Exclusive</samp> | <samp class="SANS_Futura_Std_Book_11">Marks
    the handle as exclusive if creating a new object. Only the same process can open
    a handle to the object.</samp> |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Exclusive</samp> | <samp class="SANS_Futura_Std_Book_11">如果创建新对象，则将句柄标记为独占。只有相同的进程可以打开该对象的句柄。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CaseInsensitive</samp> | <samp
    class="SANS_Futura_Std_Book_11">Looks up the object name in a case-insensitive
    manner.</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CaseInsensitive</samp> | <samp
    class="SANS_Futura_Std_Book_11">以不区分大小写的方式查找对象名称。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenIf</samp> | <samp class="SANS_Futura_Std_Book_11">If
    using a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Create</samp> <samp
    class="SANS_Futura_Std_Book_11">call, opens a handle to an existing object if
    available.</samp> |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenIf</samp> | <samp class="SANS_Futura_Std_Book_11">如果使用</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Create</samp> <samp class="SANS_Futura_Std_Book_11">调用，则如果存在，则打开现有对象的句柄。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenLink</samp> | <samp class="SANS_Futura_Std_Book_11">Opens
    the object if it’s a link to another object; otherwise, follows the link. This
    is used only by the configuration manager.</samp> |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenLink</samp> | <samp class="SANS_Futura_Std_Book_11">如果该对象是指向另一个对象的链接，则打开该对象；否则，跟随该链接。此操作仅由配置管理器使用。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelHandle</samp> | <samp
    class="SANS_Futura_Std_Book_11">Opens the handle as a kernel handle when used
    in kernel mode. This prevents user-mode applications from accessing the handle
    directly.</samp> |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelHandle</samp> | <samp
    class="SANS_Futura_Std_Book_11">在内核模式下使用时，将句柄打开为内核句柄。这防止了用户模式应用程序直接访问该句柄。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceAccessCheck</samp> | <samp
    class="SANS_Futura_Std_Book_11">When used in kernel mode, ensures all access checks
    are performed, even if calling the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    <samp class="SANS_Futura_Std_Book_11">version of the system call.</samp> |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceAccessCheck</samp> | <samp
    class="SANS_Futura_Std_Book_11">在内核模式下使用时，确保执行所有访问检查，即使是调用</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    <samp class="SANS_Futura_Std_Book_11">版本的系统调用时。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IgnoreImpersonatedDeviceMap</samp>
    | <samp class="SANS_Futura_Std_Book_11">Disables the device map when impersonating.</samp>
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IgnoreImpersonatedDeviceMap</samp>
    | <samp class="SANS_Futura_Std_Book_11">在模拟时禁用设备映射。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DontReparse</samp> | <samp
    class="SANS_Futura_Std_Book_11">Indicates not to follow any path that contains
    a symbolic link.</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DontReparse</samp> | <samp
    class="SANS_Futura_Std_Book_11">指示不要跟随包含符号链接的任何路径。</samp> |'
- en: The final two fields in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>
    structure allow the caller to specify the Security Quality of Service (SQoS) and
    security descriptor for the object. We’ll come back to SQoS in [Chapter 4](chapter4.xhtml)
    and the security descriptor in [Chapter 5](chapter5.xhtml).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> 结构中的最后两个字段允许调用者指定对象的安全服务质量（SQoS）和安全描述符。我们将在[第4章](chapter4.xhtml)中回到SQoS的内容，在[第5章](chapter5.xhtml)中讨论安全描述符。
- en: Next in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call in [Listing 2-6](chapter2.xhtml#Lis2-6) is the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitialOwner</samp>
    Boolean parameter, which is specific to this type. In this case, it represents
    whether the created <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    is owned by the caller or not. Many other system calls, especially for files,
    have more complex parameters, which we’ll discuss in more detail later in the
    book.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是[清单2-6](chapter2.xhtml#Lis2-6)中 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    系统调用中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">InitialOwner</samp> 布尔参数，这个参数是特定于此类型的。在这种情况下，它表示创建的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 是否由调用者拥有。许多其他系统调用，尤其是与文件相关的调用，具有更复杂的参数，我们将在本书后续部分更详细地讨论这些内容。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NTSTATUS Codes</samp>
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NTSTATUS 状态码</samp>
- en: All system calls return a 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    code. This status code is composed of multiple components packed into the 32 bits,
    as shown in [Figure 2-3](chapter2.xhtml#fig2-3).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有系统调用都会返回一个32位的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    状态码。该状态码由多个组件组成，并打包在32位中，如[图2-3](chapter2.xhtml#fig2-3)所示。
- en: '![](../images/Figure2-3.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The NT status code
    structure</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-3：NT 状态码结构</samp>
- en: The most significant two bits (31 and 30) indicate the *severity* of the status
    code. [Table 2-4](chapter2.xhtml#tab2-4) shows the available values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的两个位（31 和 30）表示状态码的 *严重性*。[表 2-4](chapter2.xhtml#tab2-4) 显示了可用的值。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-4:</samp> <samp class="SANS_Futura_Std_Book_11">NT
    Status Severity Codes</samp>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-4:</samp> <samp class="SANS_Futura_Std_Book_11">NT
    状态严重性代码</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Severity name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp>
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">严重性名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">值</samp>
    |'
- en: '| --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_SUCCESS</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_SUCCESS</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_INFORMATIONAL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_INFORMATIONAL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_WARNING</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_WARNING</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_ERROR</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_ERROR</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> |'
- en: If the severity level indicates a warning or error, then bit 31 of the status
    code will be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. If
    the status code is treated as a signed 32-bit integer, this bit represents a negative
    value. It’s a common coding practice to assume that if the status code is negative
    it represents an error, and if it’s positive it represents a success. As we can
    see from the table, this assumption isn’t completely true—the negative status
    code could also be a warning—but it works well enough in practice.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果严重性级别指示一个警告或错误，则状态码的第31位将被设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。如果状态码被视为一个带符号的32位整数，这一位表示一个负值。常见的编码实践是认为，如果状态码为负，则表示错误；如果为正，则表示成功。从表格中可以看出，这个假设并不完全正确——负状态码也可能是警告——但在实践中通常足够有效。
- en: The next component in [Figure 2-3](chapter2.xhtml#fig2-3), *CC*, is the customer
    code. This is a single-bit flag that indicates whether the status code is defined
    by Microsoft (a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>)
    or defined by a third party (a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>).
    Third parties are not obliged to follow this specification, so don’t treat it
    as fact.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-3](chapter2.xhtml#fig2-3)中的下一个组件，*CC*，是客户代码。它是一个单比特标志，用于指示状态码是由微软定义的（值为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>），还是由第三方定义的（值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>）。第三方并没有义务遵循这个规范，因此不能将其视为事实。'
- en: Following the customer code is the *R* bit, a reserved bit that must be set
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随客户代码的是 *R* 位，这是一个保留位，必须设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。
- en: The next 12 bits indicate the *facility*—that is, the component or subsystem
    associated with the status code. Microsoft has predefined around 50 facilities
    for its own purposes. Third parties should define their own facility and combine
    it with the customer code to distinguish themselves from Microsoft. [Table 2-5](chapter2.xhtml#tab2-5)
    shows a few commonly encountered facilities.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的12位表示 *facility* ——即与状态码相关的组件或子系统。微软已经为自己的目的预定义了约50个facility。第三方应定义自己的facility，并将其与客户代码结合，以便与微软区分开来。[表2-5](chapter2.xhtml#tab2-5)展示了一些常见的facility。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-5:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Status Facility Values</samp>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表2-5：</samp> <samp class="SANS_Futura_Std_Book_11">常见状态facility值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Facility name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Facility名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">值</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEFAULT</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">The
    default used for common status codes</samp> |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEFAULT</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">用于常见状态码的默认值</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEBUGGER</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">Used
    for codes associated with the debugger</samp> |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEBUGGER</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">用于与调试器相关的代码</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_NTWIN32</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">Used
    for codes that originated from the Win32 APIs</samp> |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_NTWIN32</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">用于来自
    Win32 API 的代码</samp> |'
- en: The final component, the *status code*, is a 16-bit number chosen to be unique
    for the facility. It’s up to the implementer to define what each number means.
    The PowerShell module contains a list of known status codes, which we can query
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtStatus</samp> command
    with no parameters ([Listing 2-9](chapter2.xhtml#Lis2-9)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分，即 *状态码*，是一个16位数字，用于为该功能选择一个唯一的值。具体的含义由实现者定义。PowerShell 模块包含一个已知状态码的列表，我们可以通过使用无参数的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtStatus</samp> 命令查询此列表（[列表
    2-9](chapter2.xhtml#Lis2-9)）。
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 2-9: Example output from Get-NtStatus'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-9：来自 Get-NtStatus 的示例输出
- en: Notice how some status values, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PENDING</samp>,
    have a human-readable message. This message isn’t embedded in the PowerShell module;
    instead, it’s stored inside a Windows library and can be extracted at runtime.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一些状态值，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PENDING</samp>，具有可读的消息。这个消息并没有嵌入到
    PowerShell 模块中；而是存储在 Windows 库中，并可以在运行时提取。
- en: When we call a system call via a PowerShell command, its status code is surfaced
    through a .NET exception. For example, if we try to open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object that doesn’t exist, we’ll see the exception shown in [Listing 2-10](chapter2.xhtml#Lis2-10)
    displayed in the console.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 PowerShell 命令调用系统调用时，其状态代码会通过 .NET 异常呈现。例如，如果我们尝试打开一个不存在的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    对象，我们将在控制台中看到[列表 2-10](chapter2.xhtml#Lis2-10)中显示的异常。
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 2-10: An NTSTATUS exception generated when trying to open a nonexistent
    directory'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-10：尝试打开不存在的目录时生成的 NTSTATUS 异常
- en: In [Listing 2-10](chapter2.xhtml#Lis2-10), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectory</samp>
    to open the nonexistent path *THISDOESNOTEXIST*. This generates the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS
    0xC0000034</samp> exception, shown here along with the decoded message ❶. If you
    want more information about the status code, you can pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtStatus</samp>
    and format the output as a list to view all its properties, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Facility</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Severity</samp>. The NT status
    code is an unsigned integer value; however, it’s common to also see it printed
    (incorrectly) as a signed value ❷.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 2-10](chapter2.xhtml#Lis2-10)中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectory</samp>
    打开不存在的路径 *THISDOESNOTEXIST*。这会生成 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS
    0xC0000034</samp> 异常，如下所示，并显示解码后的消息 ❶。如果你想获取更多关于状态代码的信息，可以将其传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtStatus</samp>
    并将输出格式化为列表，以查看所有属性，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">Facility</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Severity</samp>。NT 状态代码是一个无符号整数值；但是，常见的做法是将其错误地打印为带符号值
    ❷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Handles</samp>
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对象句柄</samp>
- en: 'The object manager deals with pointers to kernel memory. A user-mode application
    cannot directly read or write to kernel memory, so how can it access an object?
    It does this using the handle returned by a system call, as discussed in the previous
    section. Each running process has an associated *handle table* containing three
    pieces of information:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对象管理器处理指向内核内存的指针。用户模式的应用程序无法直接读写内核内存，那么它是如何访问对象的呢？它通过系统调用返回的句柄来实现，如上一节所述。每个运行中的进程都有一个相关的
    *句柄表*，其中包含三项信息：
- en: The handle’s numeric identifier
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 句柄的数字标识符
- en: The granted access to the handle; for example, read or write
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授予句柄的访问权限；例如，读取或写入
- en: The pointer to the object structure in kernel memory
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向内核内存中对象结构的指针
- en: Before the kernel can use a handle, the system call implementation must look
    up the kernel object pointer from the handle table using a kernel API such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ObReferenceObjectByHandle</samp>.
    By providing this handle indirectly, a kernel component can return the handle
    number to the user-mode application without exposing the kernel object directly.
    [Figure 2-4](chapter2.xhtml#fig2-4) shows the handle lookup process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核使用句柄之前，系统调用实现必须通过内核 API（如<samp class="SANS_TheSansMonoCd_W5Regular_11">ObReferenceObjectByHandle</samp>）从句柄表中查找内核对象指针。通过间接提供该句柄，内核组件可以将句柄编号返回给用户态应用程序，而不会直接暴露内核对象。[图
    2-4](chapter2.xhtml#fig2-4)展示了句柄查找过程。
- en: '![](../images/Figure2-4.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: The handle table
    lookup process</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-4：句柄表查找过程</samp>
- en: In [Figure 2-4](chapter2.xhtml#fig2-4), the user process is trying to perform
    some operation on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object. When a user process wants to use a handle, it must first pass the handle’s
    value to the system call we defined in the previous section ❶. The system call
    implementation then calls a kernel API to convert the handle to a kernel pointer
    by referencing the handle’s numeric value in the process’s handle table ❷.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-4](chapter2.xhtml#fig2-4)中，用户进程正尝试对一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象执行某些操作。当用户进程想要使用句柄时，它必须首先将句柄的值传递给我们在上一节定义的系统调用❶。然后，系统调用实现会调用一个内核
    API，通过引用进程句柄表中的句柄数字值，将句柄转换为内核指针❷。
- en: To determine whether to grant the access, the conversion API considers the type
    of access that the user has requested for the system call’s operation, as well
    as the type of object being accessed. If the requested access doesn’t match the
    granted access recorded in the handle table entry, the API will return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>
    and the conversion operation will fail. Likewise, if the object types don’t match
    ❸, the API will return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_OBJECT_TYPE_MISMATCH</samp>.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定是否授予访问权限，转换 API 会考虑用户请求的访问类型，以及正在访问的对象类型。如果请求的访问与句柄表条目中记录的授予访问权限不匹配，API
    会返回<samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>，并且转换操作会失败。同样，如果对象类型不匹配❸，API
    会返回<samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_OBJECT_TYPE_MISMATCH</samp>。
- en: These two checks are crucial for security. The access check ensures that the
    user can’t perform an operation on a handle to which they don’t have access (for
    example, writing to a file for which they have only read access). The type check
    ensures the user hasn’t passed an unrelated kernel object type, which might result
    in type confusion in the kernel, causing security issues such as memory corruption.
    If the conversion succeeds, the system call now has a kernel pointer to the object,
    which it can use to perform the user’s requested operation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个检查对于安全性至关重要。访问检查确保用户无法对其没有访问权限的句柄执行操作（例如，对只具有读取权限的文件进行写入）。类型检查确保用户没有传递不相关的内核对象类型，这可能导致内核中的类型混淆，进而引发内存损坏等安全问题。如果转换成功，系统调用现在拥有指向对象的内核指针，可以用它来执行用户请求的操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Access Masks</samp>
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">访问掩码</samp>
- en: The granted access value in the handle table is a 32-bit bitfield called an
    *access mask*. This is the same bitfield used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    parameter specified in the system call. We’ll discuss how <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    and the access check process determine the granted access in more detail in [Chapter
    7](chapter7.xhtml).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 句柄表中授予的访问值是一个 32 位位域，称为*访问掩码*。这与系统调用中指定的<samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>参数使用的位域相同。我们将在[第
    7 章](chapter7.xhtml)中详细讨论<samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>和访问检查过程如何确定授予的访问权限。
- en: An access mask has four components, as shown in [Figure 2-5](chapter2.xhtml#fig2-5).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 访问掩码有四个组成部分，如[图 2-5](chapter2.xhtml#fig2-5)所示。
- en: '![](../images/Figure2-5.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: The access mask
    structure</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-5：访问掩码结构</samp>
- en: The most important one is the 16-bit *type-specific access component*, which
    defines the operations that are allowed on a particular kernel object type. For
    example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> object might
    have separate bits to specify whether the file is allowed to be read or written
    to when using the handle. In contrast, a synchronization <samp class="SANS_TheSansMonoCd_W5Regular_11">Event</samp>
    might only have a single bit that allows the event to be signaled.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是16位*类型特定访问组件*，它定义了对特定内核对象类型允许的操作。例如，一个<samp class="SANS_TheSansMonoCd_W5Regular_11">文件</samp>对象可能有单独的位来指定在使用句柄时是否允许读取或写入该文件。相比之下，一个同步的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">事件</samp>可能只有一个位，允许事件被触发。
- en: 'Working backward, the *standard access* component of the access mask defines
    operations that can apply to any object type. These operations include:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从后向前，访问掩码的*标准访问*组件定义了可以应用于任何对象类型的操作。这些操作包括：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Delete  </samp>Removes the object;
    for example, by deleting it from disk or from the registry
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">删除  </samp>移除对象；例如，从磁盘或注册表中删除它
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadControl  </samp>Reads the security
    descriptor information for the object
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">读取控制  </samp>读取对象的安全描述符信息
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteDac  </samp>Writes the security
    descriptor’s discretionary access control (DAC) to the object
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">写入DAC  </samp>将安全描述符的自由裁量访问控制（DAC）写入对象
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteOwner  </samp>Writes the owner
    information to the object
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">写入所有者  </samp>将所有者信息写入对象
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Synchronize  </samp>Waits on the
    object; for example, waits for a process to exit or a mutant to be unlocked
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">同步  </samp>等待对象；例如，等待一个进程退出或一个突变体被解锁
- en: We’ll cover security-related access in more detail in [Chapters 5](chapter5.xhtml)
    and [6](chapter6.xhtml).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](chapter5.xhtml)和[第6章](chapter6.xhtml)中更详细地讨论与安全相关的访问。
- en: 'Before this are the *reserved* and *special access* bits. Most of these bits
    are reserved, but they include two access values:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前是*保留*和*特殊访问*位。大多数这些位是保留的，但它们包括两个访问值：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AccessSystemSecurity  </samp>Reads
    or writes audit information on the object
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">访问系统安全  </samp>读取或写入对象的审计信息
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">MaximumAllowed  </samp>Requests
    the maximum access to an object when performing an access check
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">最大允许  </samp>在执行访问检查时请求对象的最大访问权限
- en: We’ll cover <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access in [Chapter 9](chapter9.xhtml) and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumAllowed</samp>
    access in [Chapter 7](chapter7.xhtml).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](chapter9.xhtml)中详细讨论<samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>访问，并在[第7章](chapter7.xhtml)中讨论<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MaximumAllowed</samp>访问。
- en: 'Finally, the four high-order bits of the access mask (the *generic access*
    component) are used only when requesting access to a kernel object using the system
    call’s <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp> parameter.
    There are four broad categories of access: <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericExecute</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，访问掩码的四个高位（*通用访问*组件）仅在通过系统调用的<samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>参数请求对内核对象的访问时使用。访问有四个大类：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GenericExecute</samp>，和<samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>。
- en: When you request one of these generic access rights, the SRM will first convert
    the access into the corresponding type-specific access. This means you’ll never
    receive access to a handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>;
    instead, you’ll be granted access to the specific access mask that represents
    read operations for that type. To facilitate the conversion, each type contains
    a *generic mapping table*, which maps the four generic categories to type-specific
    access. We can display the mapping table using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp>,
    as shown in [Listing 2-11](chapter2.xhtml#Lis2-11).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你请求其中一种通用访问权限时，SRM 会首先将该访问转换为相应的特定类型访问。这意味着你永远不会获得一个带有<samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>的句柄；相反，你将获得表示该类型读取操作的特定访问掩码。为了便于转换，每个类型包含一个*通用映射表*，该表将四个通用类别映射到特定类型的访问。我们可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp>显示映射表，如[清单 2-11](chapter2.xhtml#Lis2-11)所示。
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 2-11: Displaying the generic mapping table for object types'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-11：显示对象类型的通用映射表
- en: The type data doesn’t provide names for each specific access mask. However,
    for all common types, the PowerShell module provides an enumerated type that represents
    the type-specific access. We can access this type through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp>
    command. [Listing 2-12](chapter2.xhtml#Lis2-12) shows an example for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">File</samp> type.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 类型数据没有为每个特定访问掩码提供名称。但是，对于所有常见类型，PowerShell 模块提供了一个枚举类型，用于表示特定类型的访问。我们可以通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp>命令访问此类型。[清单 2-12](chapter2.xhtml#Lis2-12)展示了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">File</samp>类型的示例。
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 2-12: Displaying the access mask for the File object type'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-12：显示 File 对象类型的访问掩码
- en: The output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp>
    command shows the access mask value, the name of the access as known to the PowerShell
    module, and the generic access from which it will be mapped. Note how some access
    types are granted only to <samp class="SANS_TheSansMonoCd_W5Regular_11">All</samp>;
    this means that even if you requested generic read, write, and execute access,
    you wouldn’t be granted access to those rights.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp>命令的输出显示访问掩码值、PowerShell
    模块已知的访问名称，以及它将被映射的通用访问。请注意，有些访问类型仅授予给<samp class="SANS_TheSansMonoCd_W5Regular_11">All</samp>；这意味着即使你请求了通用的读取、写入和执行权限，你也不会获得这些权限。
- en: You can convert between a numeric access mask and specific object types using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp> command,
    as shown in [Listing 2-13](chapter2.xhtml#Lis2-13).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp>命令在数字访问掩码和特定对象类型之间进行转换，如[清单
    2-13](chapter2.xhtml#Lis2-13)所示。
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 2-13: Converting access masks using Get-NtAccessMask'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-13：使用 Get-NtAccessMask 转换访问掩码
- en: In [Listing 2-13](chapter2.xhtml#Lis2-13), we first request the access mask
    from a set of <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> access
    names and receive the numeric access mask in hexadecimal. Next, we get the access
    mask for the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    access; as you can see, the value returned is just the numeric value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>. We then request the
    access mask for <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    but specify that we want to map the generic access to a specific access by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapGenericRights</samp> parameter.
    As we’ve specified the access for the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    type, this command uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    type’s generic mapping to convert to the specific access mask. Finally, we convert
    the raw access mask back to a type access using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsTypeAccess</samp>
    parameter, specifying the kernel type to use.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 2-13](chapter2.xhtml#Lis2-13)中，我们首先从一组 <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    访问名称请求访问掩码，并以十六进制接收数值访问掩码。接下来，我们获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    访问的访问掩码；如您所见，返回的值仅仅是 <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    的数值。然后，我们请求 <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> 的访问掩码，但指定希望通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MapGenericRights</samp> 参数将通用访问映射到特定访问。由于我们已经为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> 类型指定了访问权限，该命令将使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">File</samp> 类型的通用映射来转换为特定访问掩码。最后，我们通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AsTypeAccess</samp> 参数将原始访问掩码转换回类型访问，指定要使用的内核类型。
- en: As shown in [Listing 2-14](chapter2.xhtml#Lis2-14), you can query an object
    handle’s granted access mask through the PowerShell object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccess</samp>
    property. This returns the enumerated type format for the access mask. To retrieve
    the numeric value, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccessMask</samp>
    property.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表 2-14](chapter2.xhtml#Lis2-14)所示，您可以通过 PowerShell 对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccess</samp>
    属性查询对象句柄的授权访问掩码。这将返回访问掩码的枚举类型格式。要获取数值，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccessMask</samp>
    属性。
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 2-14: Displaying the numeric value of the access mask using GrantedAccessMask'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-14：使用 GrantedAccessMask 显示访问掩码的数值
- en: The kernel provides a facility to dump all handle table entries on the system
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    system call. We can access the handle table from PowerShell using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>
    command, as illustrated in [Listing 2-15](chapter2.xhtml#Lis2-15).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 内核提供了一种通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    系统调用转储系统中所有句柄表条目的功能。我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>
    命令从 PowerShell 访问句柄表，如[列表 2-15](chapter2.xhtml#Lis2-15)所示。
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 2-15: Displaying the handle table for the current process using Get-NtHandle'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-15：使用 Get-NtHandle 显示当前进程的句柄表
- en: Each handle entry contains the type of the object, the address of the kernel
    object in kernel memory, and the granted access mask.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个句柄条目包含对象类型、内核对象在内核内存中的地址和授权访问掩码。
- en: Once an application has finished with a handle, it can be closed using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp> API. If you’ve received
    a PowerShell object from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Get</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">New</samp> call, then you can
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> method on
    the object to close the handle. You can also close an object handle automatically
    in PowerShell by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Use-NtObject</samp>
    command to invoke a script block that closes the handle once it finishes executing.
    [Listing 2-16](chapter2.xhtml#Lis2-16) provides examples of both approaches.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序完成对句柄的使用，可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp>
    API 关闭句柄。如果您从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">New</samp> 调用中接收到 PowerShell 对象，则可以调用该对象的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> 方法来关闭句柄。您还可以通过使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Use-NtObject</samp> 命令，在 PowerShell 中自动关闭对象句柄，调用脚本块，在执行完成后关闭句柄。[列表
    2-16](chapter2.xhtml#Lis2-16)提供了这两种方法的示例。
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 2-16: Closing an object handle'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-16：关闭对象句柄
- en: If you do not close handles manually, the .NET garbage collector will close
    them automatically for objects that are not referenced (for example, held in a
    PowerShell variable). You should get into the habit of manually closing handles,
    though; otherwise, you might have to wait a long time for the resources to be
    released, as the garbage collector could run at any time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有手动关闭句柄，.NET 垃圾回收器将会自动关闭那些未被引用的对象的句柄（例如，存储在 PowerShell 变量中的对象）。不过，你应该养成手动关闭句柄的习惯；否则，你可能需要等待很长时间才能释放资源，因为垃圾回收器随时可能运行。
- en: If the kernel object structure is no longer referenced, either through a handle
    or by a kernel component, then the object will also be destroyed. Once an object
    is destroyed, all its allocated memory is cleaned up and, if it exists, its name
    in the OMNS is removed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内核对象结构不再被引用，无论是通过句柄还是由内核组件引用，那么该对象也会被销毁。一旦对象被销毁，所有分配的内存都会被清理，如果存在，它在 OMNS
    中的名称也会被移除。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handle Duplication</samp>
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">句柄复制</samp>
- en: You can duplicate handles using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp>
    system call. The primary reason you might want to do this is to allow a process
    to take an additional reference to a kernel object. The kernel object won’t be
    destroyed until all handles to it are closed, so creating a new handle maintains
    the kernel object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp>
    系统调用来复制句柄。你可能想这么做的主要原因是允许一个进程对内核对象进行额外的引用。只有当所有指向该内核对象的句柄都被关闭时，内核对象才会被销毁，因此创建一个新的句柄可以保持该内核对象的存在。
- en: Handle duplication can additionally be used to transfer handles between processes
    if the source and destination process handles have <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>
    access. You can also use handle duplication to reduce the access rights on a handle.
    For example, when you pass a file handle to a new process, you could grant the
    duplicated handle only read access, preventing the new process from writing to
    the object. However, you should not rely on this approach for reducing the handle’s
    granted access; if the process with the handle has access to the resource, it
    can just reopen it to get write access.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 句柄复制还可以用来在进程之间传递句柄，前提是源进程和目标进程的句柄具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>
    访问权限。你也可以通过句柄复制来减少句柄的访问权限。例如，当你将文件句柄传递给新进程时，可以仅授予复制的句柄读取权限，从而防止新进程对该对象进行写操作。然而，你不应该依赖这种方式来减少句柄的授权访问权限；如果持有句柄的进程可以访问该资源，它可以重新打开该资源来获得写权限。
- en: '[Listing 2-17](chapter2.xhtml#Lis2-17) shows some examples of using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtObject</samp> command, which wraps
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp>, to perform
    some duplication in the same process. We’ll come back to handle duplication and
    security checks in [Chapter 8](chapter8.xhtml).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-17](chapter2.xhtml#Lis2-17) 展示了使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtObject</samp>
    命令的示例，该命令封装了 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp>，用于在同一进程内进行一些句柄复制。我们将在
    [第 8 章](chapter8.xhtml) 中回到句柄复制和安全检查的讨论。'
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 2-17: Using Copy-NtObject to duplicate handles'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-17：使用 Copy-NtObject 来复制句柄
- en: First, we create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object to test handle duplication and extract the current granted access, which
    shows six access rights ❶. For the initial duplication, we’ll keep the same granted
    access ❷. You can see in the first column of the output that the handles are different.
    However, our call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtObject</samp>
    to determine whether the two handles refer to the same underlying kernel object
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Next, we get
    an access mask for <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant ModifyState</samp>
    access and duplicate the handle, requesting that access ❸. We can see in the output
    that the granted access is now only <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>.
    However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtObject</samp>
    return value still indicates the handles refer to the same object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象来测试句柄重复并提取当前授予的访问权限，结果显示六个访问权限❶。对于初始的重复，我们将保持相同的授予访问权限❷。你可以在输出的第一列看到句柄不同。然而，我们调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtObject</samp>来判断这两个句柄是否指向相同的底层内核对象，返回值是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。接下来，我们获取<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant
    ModifyState</samp>访问的访问掩码并复制句柄，请求该访问权限❸。我们可以在输出中看到，授予的访问权限现在仅为<samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtObject</samp>的返回值仍然表明这两个句柄指向相同的对象。
- en: Also relevant to handle duplication are the handle attributes <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp>. Setting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp> allows a new process
    to inherit the handle when it’s created. This allows you to pass handles to a
    new process to perform tasks such as redirecting console output text to a file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与句柄复制相关的还有句柄属性<samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp>。设置<samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp>可以让新进程在创建时继承该句柄。这使得你可以将句柄传递给新进程，执行诸如将控制台输出文本重定向到文件等任务。
- en: Setting <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp>
    protects the handle from being closed. You can set this attribute by setting the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp> property
    on the object, which will set the attribute on the native handle. [Listing 2-18](chapter2.xhtml#Lis2-18)
    shows an example of its use.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 设置<samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp>可以保护句柄不被关闭。你可以通过在对象上设置<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp>属性来设置该属性，这会在本地句柄上设置该属性。[列表
    2-18](chapter2.xhtml#Lis2-18)展示了其使用示例。
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 2-18: Testing the ProtectFromClose handle attribute'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-18：测试 ProtectFromClose 句柄属性
- en: Any attempt to close the handle will fail with a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_HANDLE_NOT_CLOSABLE</samp>
    status code, and the handle will stay open.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 任何尝试关闭句柄的操作都将失败，并返回<samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_HANDLE_NOT_CLOSABLE</samp>状态码，句柄将保持打开状态。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Query and Set Information
    System Calls</samp>
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查询和设置信息的系统调用</samp>
- en: A kernel object typically stores information about its state. For example, a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object stores a timestamp
    of when it was created. To allow us to retrieve this information, the kernel could
    have implemented a specific “get process creation time” system call. However,
    due to the volume of information stored for the various types of objects, this
    approach would quickly become unworkable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一个内核对象通常会存储关于其状态的信息。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>对象会存储其创建时间戳。为了让我们能够检索这些信息，内核本可以实现一个特定的“获取进程创建时间”系统调用。然而，由于各种类型对象存储的信息量庞大，这种方法很快就会变得不可行。
- en: Instead, the kernel implements generic <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> information system
    calls whose parameters follow a common pattern for all kernel object types. [Listing
    2-19](chapter2.xhtml#Lis2-19) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    information system call’s pattern, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    type as an example; for other types, just replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    with the name of the kernel type.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，内核实现了通用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> 信息系统调用，其参数遵循所有内核对象类型的共同模式。[清单
    2-19](chapter2.xhtml#Lis2-19) 显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    信息系统调用的模式，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> 类型作为示例；对于其他类型，只需将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> 替换为内核类型的名称。
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 2-19: An example Query information system call for the Process type'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-19：一个示例的 Query 信息系统调用，用于 Process 类型
- en: All <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> information system
    calls take an object handle as the first parameter. The second parameter, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InformationClass</samp>, describes the
    type of process information to query. The information class is an enumerated value;
    the SDK specifies the names of the information classes, which we can extract and
    implement in PowerShell. Querying certain kinds of information might require special
    privileges or administrator access.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> 信息系统调用都将对象句柄作为第一个参数。第二个参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InformationClass</samp> 描述要查询的进程信息类型。信息类是一个枚举值；SDK
    指定了信息类的名称，我们可以在 PowerShell 中提取并实现这些名称。查询某些类型的信息可能需要特殊权限或管理员访问权限。
- en: 'For every information class, we need to specify an opaque buffer to receive
    the queried information, as well as the length of the buffer. The system call
    also returns a length value, which serves two purposes: it indicates how much
    of the buffer was populated if the system call was successful, and if the system
    call failed, it indicates how big the buffer needs to be with <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INFO_LENGTH_MISMATCH</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BUFFER_TOO_SMALL</samp>.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个信息类，我们需要指定一个不透明的缓冲区来接收查询到的信息，以及缓冲区的长度。系统调用还会返回一个长度值，具有两个用途：如果系统调用成功，它表示缓冲区中填充了多少数据；如果系统调用失败，它表示缓冲区需要多大，并返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INFO_LENGTH_MISMATCH</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BUFFER_TOO_SMALL</samp>。
- en: You should be careful about relying on the returned length to determine how
    big a buffer to pass to the query, however. Some information classes and types
    do not correctly set the length needed if you supply a buffer that is too small.
    This makes it difficult to query data without knowing its format in advance. Unfortunately,
    even the SDK rarely documents the exact sizes required.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该小心依赖返回的长度来确定传递给查询的缓冲区大小。一些信息类和类型如果提供的缓冲区太小，可能不会正确设置所需的长度。这使得在没有提前了解其格式的情况下查询数据变得困难。不幸的是，甚至
    SDK 也很少记录所需的精确大小。
- en: As shown in [Listing 2-20](chapter2.xhtml#Lis2-20), the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp>
    information call follows a similar pattern. The main differences are that there’s
    no return length parameter, and in this case the buffer is an input to the system
    call rather than an output.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 2-20](chapter2.xhtml#Lis2-20)所示，<samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp>
    信息调用遵循类似的模式。主要区别在于没有返回长度参数，在这种情况下，缓冲区是系统调用的输入而不是输出。
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 2-20: An example Set information system call for the Process type'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-20：一个示例的 Set 信息系统调用，用于 Process 类型
- en: In the PowerShell module, you can query a type’s information class names using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformationClass</samp>
    command, as shown in [Listing 2-21](chapter2.xhtml#Lis2-21). Bear in mind that
    some information class names might be missing from the list, as Microsoft doesn’t
    always document them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 模块中，你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformationClass</samp>
    命令查询类型的类名，如[清单 2-21](chapter2.xhtml#Lis2-21)所示。请记住，某些信息类的名称可能会缺失，因为 Microsoft
    并不总是会记录它们。
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 2-21: Listing the information classes for the Process type'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-21：列出 Process 类型的信息类
- en: To call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> information
    system call, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>,
    specifying an open object handle and the information class. To call <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp>,
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtObjectInformation</samp>.
    [Listing 2-22](chapter2.xhtml#Lis2-22) shows an example of how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> 信息系统调用，使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>，指定一个打开的对象句柄和信息类。要调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp>，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtObjectInformation</samp>。[列表
    2-22](chapter2.xhtml#Lis2-22) 显示了如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>
    的示例。
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 2-22: Querying a Process object for basic information'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-22：查询进程对象的基本信息
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> type doesn’t
    set the return length for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTimes</samp>
    information class, so if you don’t specify any length, the operation generates
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BUFFER_TOO_SMALL</samp>
    error ❶. However, through inspection or brute force, you can discover that the
    length of the data is 32 bytes. Specifying this value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>
    parameter ❷ allows the query to succeed and return the data as an array of bytes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> 类型没有为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTimes</samp>
    信息类设置返回长度，因此如果没有指定长度，操作会生成 <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BUFFER_TOO_SMALL</samp>
    错误 ❶。但是，通过检查或暴力破解，你可以发现数据的长度是 32 字节。通过在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>
    参数中指定该值 ❷，可以使查询成功并将数据作为字节数组返回。
- en: For many information classes, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>
    command knows the size and structure of the query data. If you specify the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AsObject</samp> parameter ❸, you can get
    a preformatted object rather than an array of bytes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多信息类，<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>
    命令已经知道查询数据的大小和结构。如果你指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">AsObject</samp>
    参数 ❸，则可以获得预格式化的对象，而不是字节数组。
- en: Also, for many information classes the handle object already exposes properties
    and methods to set or query values. The values will be decoded into a usage format;
    for example, in [Listing 2-22](chapter2.xhtml#Lis2-22), the times are in an internal
    format. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreationTime</samp>
    property on the object will take this internal format and convert it to a human-readable
    date and time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于许多信息类，句柄对象已经暴露了用于设置或查询值的属性和方法。这些值将被解码为使用格式；例如，在 [列表 2-22](chapter2.xhtml#Lis2-22)
    中，时间以内部格式呈现。对象上的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreationTime</samp>
    属性将使用此内部格式并将其转换为人类可读的日期和时间。
- en: You can easily inspect properties by accessing them on the object or using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp> command. For
    example, [Listing 2-23](chapter2.xhtml#Lis2-23) lists all the properties on a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object, then queries
    for the formatted <samp class="SANS_TheSansMonoCd_W5Regular_11">CreationTime</samp>.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问对象上的属性或使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>
    命令轻松检查属性。例如，[列表 2-23](chapter2.xhtml#Lis2-23) 列出了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    对象上的所有属性，然后查询格式化的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreationTime</samp>。
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 2-23: Querying a handle object for properties and inspecting the CreationTime'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-23：查询句柄对象的属性并检查 CreationTime
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInformation</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp> classes for
    a type typically have the same enumerated values. The kernel can restrict the
    information class’s enumerated values to one type of operation, returning the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID _INFO_CLASS</samp>
    status code if it’s not a valid value. For some types, such as registry keys,
    the information class differs between querying and setting, as you can see in
    [Listing 2-24](chapter2.xhtml#Lis2-24).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某种类型，`<samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInformation</samp>`和`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp>`类通常具有相同的枚举值。内核可以将信息类的枚举值限制为某种操作类型，如果不是有效值，则返回`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_INFO_CLASS</samp>`状态码。对于某些类型，例如注册表项，信息类在查询和设置时有所不同，如[Listing
    2-24](chapter2.xhtml#Lis2-24)所示。
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 2-24: Inspecting the QueryInformation and SetInformation classes for
    the Key type'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-24: 检查Key类型的QueryInformation和SetInformation类'
- en: Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformationClass</samp>
    with just the type name returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInformation</samp>
    class. If you specify the type name and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp>
    parameter, you get the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp>
    class. Notice how the two entries shown have different names and therefore represent
    different information.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用类型名称调用`<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformationClass</samp>`将返回`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">QueryInformation</samp>`类。如果指定类型名称和`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Set</samp>`参数，则会得到`<samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp>`类。注意，显示的两个条目名称不同，因此代表不同的信息。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Input/Output Manager</samp>
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">输入/输出管理器</samp>
- en: The input/output (I/O) manager provides access to I/O devices through *device
    drivers*. The primary purpose of these drivers is to implement a filesystem. For
    example, when you open a document on your computer, the file is made available
    through a filesystem driver. The I/O manager supports other kinds of drivers,
    for devices such as keyboards and video cards, but these other drivers are really
    just filesystem drivers in disguise.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出 (I/O) 管理器通过*设备驱动程序*提供对I/O设备的访问。这些驱动程序的主要目的是实现文件系统。例如，当你在计算机上打开一个文档时，文件通过文件系统驱动程序提供。I/O管理器还支持其他类型的驱动程序，例如键盘和显卡，但这些其他驱动程序实际上只是伪装成文件系统驱动程序。
- en: You can manually load a new driver through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp>
    system call or do so automatically using the Plug and Play (PnP) manager. For
    every driver, the I/O manager creates an entry in the *Driver* directory. You
    can list the contents of this directory only if you’re an administrator. Fortunately,
    as a normal user, you don’t need to access anything in the *Driver* directory.
    Instead, you can interact with the driver through a <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    object, normally created in the *Device* directory.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`<samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp>`系统调用手动加载一个新驱动程序，或者通过即插即用
    (PnP) 管理器自动加载。对于每个驱动程序，I/O管理器都会在*Driver*目录中创建一个条目。只有管理员才可以列出该目录的内容。幸运的是，作为普通用户，你无需访问*Driver*目录中的任何内容。相反，你可以通过一个`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>`对象与驱动程序进行交互，该对象通常是在*Device*目录中创建的。
- en: Drivers are responsible for creating new <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    objects using the <samp class="SANS_TheSansMonoCd_W5Regular_11">IoCreateDevice</samp>
    API. A driver can have more than one <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    object associated with it; it may also have zero associated <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    objects if it doesn’t require user interaction. As [Listing 2-25](chapter2.xhtml#Lis2-25)
    shows, we can list the contents of the *Device* directory as a normal user through
    the OMNS.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序负责使用`<samp class="SANS_TheSansMonoCd_W5Regular_11">IoCreateDevice</samp>`API创建新的`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>`对象。一个驱动程序可以有多个与之关联的`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>`对象；如果驱动程序不需要与用户交互，它也可以没有任何关联的`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>`对象。如[Listing 2-25](chapter2.xhtml#Lis2-25)所示，我们可以通过OMNS作为普通用户列出*Device*目录的内容。
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 2-25: Displaying the Device objects'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-25: 显示设备对象'
- en: In the output, we can see that the objects’ type names are all <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>.
    However, if you go looking for a system call with <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    in the name, you’ll come up empty. That’s because we don’t interact with the I/O
    manager using dedicated system calls; rather, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    object system calls such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>.
    We can access these system calls through <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtFile</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFile</samp>, which create
    and open files, respectively, as shown in [Listing 2-26](chapter2.xhtml#Lis2-26).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到这些对象的类型名称都是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>。然而，如果你去寻找带有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> 名称的系统调用，你将一无所获。这是因为我们并不通过专门的系统调用与
    I/O 管理器交互；相反，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> 对象的系统调用，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>。我们可以通过 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-NtFile</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFile</samp>
    来访问这些系统调用，分别用于创建和打开文件，具体如在 [列表 2-26](chapter2.xhtml#Lis2-26) 中所示。
- en: '[PRE25]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 2-26: Opening a device object and displaying its volume path'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-26：打开设备对象并显示其卷路径
- en: In this example, we open *notepad.exe* from the *Windows* directory. The *SystemRoot*
    symbolic link points to the *Windows* directory on the system drive. As the *SystemRoot*
    symbolic link is part of the OMNS, the OMNS initially handles file access. With
    an open handle, we can select the full path to the file and the type name.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们从 *Windows* 目录打开 *notepad.exe*。*SystemRoot* 符号链接指向系统驱动器上的 *Windows*
    目录。由于 *SystemRoot* 符号链接是 OMNS 的一部分，因此最初由 OMNS 处理文件访问。通过打开的句柄，我们可以选择文件的完整路径和类型名称。
- en: Looking at the result, we can see that the full path starts with *Device\HarddiskVolume3\*,
    followed by *Windows\notepad.exe* ❶. If we try to display the device, we find
    it’s of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>. Once
    the object manager finds the <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    object, it hands off responsibility for the rest of the path to the I/O manager,
    which calls an appropriate method inside the kernel driver.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 查看结果，我们可以看到完整路径以 *Device\HarddiskVolume3\* 开头，后跟 *Windows\notepad.exe* ❶。如果我们尝试显示该设备，会发现它是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> 类型。一旦对象管理器找到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> 对象，它就会将路径的其余部分的处理交给 I/O
    管理器，后者调用内核驱动程序中的相应方法。
- en: We can list the drivers loaded into the kernel using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKernelModule</samp>
    command ([Listing 2-27](chapter2.xhtml#Lis2-27)).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKernelModule</samp>
    命令列出加载到内核中的驱动程序（[列表 2-27](chapter2.xhtml#Lis2-27)）。
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 2-27: Enumerating all loaded kernel drivers'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-27：枚举所有已加载的内核驱动程序
- en: Unlike other operating systems, such as Linux, Windows does not implement core
    network protocols like TCP/IP using built-in system calls. Instead, Windows has
    an I/O manager driver, the *Ancillary Function Driver (AFD)*, which provides access
    to networking services for an application. You don’t need to deal with the driver
    directly; Win32 provides a BSD sockets-style API, called *WinSock*, to handle
    access to it. In addition to the standard internet protocol suite, such as TCP/IP,
    AFD also implements other network socket types, such as Unix sockets and bespoke
    Hyper-V sockets for communication with virtual machines.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他操作系统（如 Linux）不同，Windows 并没有通过内置的系统调用实现核心网络协议（如 TCP/IP）。相反，Windows 有一个 I/O
    管理器驱动程序——*辅助功能驱动程序 (AFD)*，它为应用程序提供访问网络服务的能力。你不需要直接处理该驱动程序；Win32 提供了一个 BSD 套接字风格的
    API，称为 *WinSock*，用于处理访问。除了标准的互联网协议套件（如 TCP/IP）外，AFD 还实现了其他网络套接字类型，如 Unix 套接字和为虚拟机通信定制的
    Hyper-V 套接字。
- en: That’s all we’ll say for now about the I/O manager. Next, let’s turn to another
    important subsystem, the process and thread manager.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们就先讲到这里关于 I/O 管理器的内容。接下来，让我们转向另一个重要的子系统——进程和线程管理器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Process and Thread Manager</samp>
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进程和线程管理器</samp>
- en: 'All user-mode code lives in the context of a *process*, each of which has one
    or more *threads* that control the execution of the code. Processes and threads
    are both securable resources. This makes sense: if you could access a process,
    you could modify its code and execute it in the context of a different user identity.
    So, unlike most other kernel objects, you can’t open a process or thread by name.
    Instead, you must open them via a unique, numeric *process ID (PID)* or *thread
    ID (TID)*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用户模式代码都运行在一个 *进程* 的上下文中，每个进程都有一个或多个 *线程* 来控制代码的执行。进程和线程都是可以被安全管理的资源。这是有道理的：如果你可以访问一个进程，你就能修改它的代码，并以不同用户身份的上下文执行它。因此，与大多数其他内核对象不同，你不能通过名称打开一个进程或线程。相反，你必须通过唯一的数字
    *进程 ID (PID)* 或 *线程 ID (TID)* 来打开它们。
- en: To get a list of running processes and threads you could brute-force the ID
    space by calling the open system call with every possible ID, but that would take
    a while. Fortunately, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    system call provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemProcessInformation</samp>
    information class, which lets us enumerate processes and threads without having
    access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取正在运行的进程和线程列表，你可以通过对每个可能的 ID 调用系统调用来强制获取 ID 空间，但那会花费一些时间。幸运的是，<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    系统调用提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemProcessInformation</samp>
    信息类，这让我们可以枚举进程和线程，而无需访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    对象。
- en: We can access the list of processes and threads by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> commands
    and passing them the <samp class="SANS_TheSansMonoCd_W5Regular_11">InfoOnly</samp>
    parameter, as shown in [Listing 2-28](chapter2.xhtml#Lis2-28). We can also use
    the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Process</samp>
    command to produce a similar output. Each of the returned objects has a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Threads</samp> property that we can query
    for the thread information.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> 命令，并传递 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InfoOnly</samp> 参数来访问进程和线程列表，如 [列表 2-28](chapter2.xhtml#Lis2-28)
    所示。我们还可以使用内置的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Process</samp>
    命令来产生类似的输出。每个返回的对象都有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Threads</samp>
    属性，我们可以查询该属性获取线程信息。
- en: '[PRE27]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 2-28: Displaying processes and threads without high privilege'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-28：显示没有高权限的进程和线程
- en: The first two processes listed in the output are special. The first is the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Idle</samp> process, with PID <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    This process contains threads that execute when the operating system is idle,
    hence its name. It’s not a process you’ll need to deal with regularly. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">System</samp> process, with PID <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, is important because it runs
    entirely in kernel mode. When the kernel or a driver needs to execute a background
    thread, the thread is associated with the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    process.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中列出的前两个进程是特殊的。第一个是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Idle</samp>
    进程，PID 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。这个进程包含在操作系统空闲时执行的线程，因此得名。它不是你需要经常处理的进程。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">System</samp> 进程，PID 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，非常重要，因为它完全在内核模式下运行。当内核或驱动程序需要执行后台线程时，线程将与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> 进程相关联。
- en: To open a process or thread, we can pass <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> the PID or
    TID we want to open. The command will return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object that we
    can then interact with. For example, [Listing 2-29](chapter2.xhtml#Lis2-29) shows
    how to query the command line and executable path of the current process.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开一个进程或线程，我们可以传递 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> 所需的 PID 或
    TID。该命令将返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> 对象，然后我们可以与之交互。例如，[列表 2-29](chapter2.xhtml#Lis2-29)
    显示了如何查询当前进程的命令行和可执行路径。
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 2-29: Opening the current process by its process ID'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-29：通过进程ID打开当前进程
- en: When you open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object using its
    ID, you’ll receive a handle. For convenience, the kernel also supports two *pseudo
    handles* that refer to the current process and the current thread. The current
    process’s pseudo handle is the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    converted to a handle, and for the current thread, it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>.
    You can access these pseudo handles by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Current</samp>
    parameter instead of an ID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> commands.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用一个ID打开一个<samp class="SANS_TheSansMonoCd_W5Regular_11">进程</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">线程</samp>对象时，你会获得一个句柄。为了方便起见，内核还支持两个*伪句柄*，分别指向当前进程和当前线程。当前进程的伪句柄是将值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>转换为句柄，当前线程的伪句柄则是<samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>。你可以通过将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Current</samp>参数传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp>命令，而不是ID，来访问这些伪句柄。
- en: Note that the security of a process and its threads is independent. If you know
    the ID of a thread, it’s possible to access the thread handle inside a process
    even if you can’t access the process itself.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，进程及其线程的安全性是独立的。如果你知道一个线程的ID，那么即使无法访问进程本身，仍然可以访问进程内的线程句柄。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Memory Manager</samp>
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">内存管理器</samp>
- en: Every process has its own virtual memory address space for a developer to use
    as they see fit. A 32-bit process can access up to 2GB of virtual memory address
    space (4GB on 64-bit Windows), while a 64-bit process can access up to 128TB.
    The kernel’s *memory manager* subsystem controls the allocation of this address
    space.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有自己的虚拟内存地址空间，开发者可以根据需求自由使用。32位进程可以访问最多2GB的虚拟内存地址空间（64位Windows上为4GB），而64位进程可以访问最多128TB的虚拟内存地址空间。内核的*内存管理器*子系统控制着这个地址空间的分配。
- en: You’re unlikely to have 128TB of physical memory in your computer, but the memory
    manager has ways of making it look like you have more physical memory than you
    do. For example, it can use a dedicated file on your filesystem, called a *pagefile*,
    to temporarily store memory when it’s not currently needed. As your filesystem’s
    available storage space is much larger than your computer’s physical memory, this
    can provide the appearance of a large amount of memory.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你的计算机不太可能有128TB的物理内存，但内存管理器有办法让它看起来像你有比实际更多的物理内存。例如，它可以使用一个文件系统上的专用文件，称为*页面文件*，在内存不再需要时临时存储数据。由于文件系统的可用存储空间远大于计算机的物理内存，这就能给人一种拥有大量内存的假象。
- en: The virtual memory space is shared by memory allocations, and it stores each
    process’s running state as well as its executable code. Each memory allocation
    can have a range of protection states, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>, which must
    be set according to the memory’s purpose. For example, for code to be executed,
    the memory must have a protection state of <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp>.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存空间是由内存分配共享的，它存储着每个进程的运行状态以及可执行代码。每个内存分配可以有不同的保护状态，如<samp class="SANS_TheSansMonoCd_W5Regular_11">只读</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">读写</samp>，这些必须根据内存的用途进行设置。例如，要执行的代码，内存必须设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">执行只读</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">执行读写</samp>的保护状态。
- en: You can query all memory status information for a process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryVirtualMemory</samp>,
    if you have the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>
    access right on the process handle. However, reading and writing the memory data
    requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">VmRead</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VmWrite</samp> access rights, respectively,
    and a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryVirtualMemory</samp>查询进程的所有内存状态信息，如果您拥有该进程句柄的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>访问权限。然而，读取和写入内存数据分别需要<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VmRead</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">VmWrite</samp>访问权限，并且需要调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>。
- en: It’s possible to allocate new memory and free memory in a process using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtFreeVirtualMemory</samp>, which both
    require the <samp class="SANS_TheSansMonoCd_W5Regular_11">VmOperation</samp> access
    right. Finally, you can change the protection on memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>,
    which also requires <samp class="SANS_TheSansMonoCd_W5Regular_11">VmOperation</samp>
    access.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtFreeVirtualMemory</samp>在进程中分配和释放内存，这两者都需要<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VmOperation</samp>访问权限。最后，您可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>更改内存的保护，这也需要<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VmOperation</samp>访问权限。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NtVirtualMemory Commands</samp>
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NtVirtualMemory命令</samp>
- en: PowerShell wraps these system calls using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtVirtualMemory</samp> commands.
    Note that these commands all accept an optional <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    parameter that lets you access memory in a different process from the current
    one. [Listing 2-30](chapter2.xhtml#Lis2-30) shows the commands in action.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Add-</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Read-</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Write-</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtVirtualMemory</samp> 命令包装这些系统调用。请注意，这些命令都接受一个可选的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>参数，允许您访问不同进程中的内存。[Listing
    2-30](chapter2.xhtml#Lis2-30)展示了这些命令的实际操作。
- en: '[PRE29]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 2-30: Performing various memory operations on a process'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-30：对进程执行各种内存操作
- en: 'Here, we perform several operations. First we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    to list all the memory regions being used by the current process ❶. The returned
    list will be large, but the excerpt shown here should give you a rough idea of
    how the information is presented. It includes the address of the memory region,
    its size, its protection, and its state. There are three possible state values:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们执行了几个操作。首先，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>列出当前进程正在使用的所有内存区域
    ❶。返回的列表会很大，但这里展示的摘录应能让您大致了解信息的展示方式。它包括内存区域的地址、大小、保护状态和状态。可能的状态值有三种：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Commit  </samp>Indicates that the
    virtual memory region is allocated and available for use.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Commit  </samp>表示虚拟内存区域已分配并可供使用。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reserve  </samp>Indicates that
    the virtual memory region has been allocated but there is currently no backing
    memory. Using a reserved memory region will cause a crash.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reserve  </samp>表示虚拟内存区域已经分配，但当前没有后备内存。使用保留的内存区域会导致崩溃。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Free  </samp>Indicates that the
    virtual memory region is unused. Using a free memory region will cause a crash.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Free  </samp>表示该虚拟内存区域未被使用。使用一个空闲的内存区域将导致崩溃。
- en: You may wonder what the difference is between <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp>, if using both reserved
    and free memory regions will cause a crash. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp>
    state allows you to reserve virtual memory regions for later use so that nothing
    else can allocate memory within that range of memory addresses. You can later
    convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp> state
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Commit</samp> by re-calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Free</samp> state indicates regions freely
    available for allocation. We’ll cover what the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> columns indicate
    later in this section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，如果使用保留和空闲内存区域都会导致崩溃，那么<samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Free</samp>之间有什么区别。<samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp>状态允许你保留虚拟内存区域以供后续使用，这样其他程序就不能在该内存地址范围内分配内存。你可以通过重新调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>将<samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp>状态转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Commit</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp>状态表示该区域可以自由分配。我们将在本节后面介绍<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>列表示的内容。
- en: Next, we allocate a 1,000-byte read/write region and capture the address in
    a variable ❷. Passing the address to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    allows us to query only that specific virtual memory region. You might notice
    that although we requested a 1,000-byte region, the size of the region returned
    is 4,096 bytes. This is because all virtual memory allocations on Windows have
    a minimum allocation size; on the system I’m using, the minimum is 4,096 bytes.
    It’s therefore not possible to allocate a smaller region. For this reason, these
    system calls are not particularly useful for general program allocations; rather,
    they’re primitives on which “heap” memory managers are built, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    from the C library.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分配一个1,000字节的读/写区域，并将地址捕获到变量❷中。将地址传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>允许我们仅查询该特定的虚拟内存区域。你可能会注意到，尽管我们请求了一个1,000字节的区域，但返回的区域大小是4,096字节。这是因为在Windows上所有虚拟内存分配都有一个最小分配大小；在我使用的系统中，最小值为4,096字节。因此，不可能分配更小的区域。正因如此，这些系统调用对于一般的程序分配并不特别有用；它们更多是构建“堆”内存管理器的基础，例如C库中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>。
- en: Next, we read and write to the memory region we just allocated. First we use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-NtVirtualMemory</samp> to read
    out 4 bytes of the memory region and find that the bytes are all zeros ❸. Next,
    we write the bytes 1, 2, 3, and 4 to the memory region using <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>
    ❹. We read the bytes to confirm that the write operation succeeded ❺; the two
    values should match, as shown in the output.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对刚刚分配的内存区域进行读写操作。首先，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Read-NtVirtualMemory</samp>读取该内存区域的4个字节，发现字节全为零❸。接着，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>将字节1、2、3和4写入内存区域❹。我们读取这些字节以确认写操作是否成功❺；这两个值应该匹配，如输出所示。
- en: With the memory allocated, we can change the protection using <samp class="SANS_TheSansMonoCd_W5Regular_11">Set
    -NtVirtualMemory</samp>. In this case, we make the allocated memory executable
    by specifying the protection as <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    ❻. Querying the current state of the memory region using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    command ❼ shows that the protection has changed from <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>. Also notice
    that although we requested to change the protection of only 4 bytes, the entire
    4,096-byte region is now executable. This is again due to the minimum memory allocation
    size.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配内存后，我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Set -NtVirtualMemory</samp>
    来更改保护。在这种情况下，我们通过将保护设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    ❻ 来使分配的内存可执行。使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    命令 ❼ 查询当前内存区域的状态，显示保护已从 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>
    更改为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>。还请注意，尽管我们请求仅更改4个字节的保护，但整个4,096字节的区域现在都可以执行。这是由于最小内存分配大小的原因。
- en: Finally, we free the memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtVirtualMemory</samp>
    and verify that the memory is now in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp>
    state ❽. Memory allocated using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    is considered private, as indicated by the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    property shown in [Listing 2-30](chapter2.xhtml#Lis2-30).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtVirtualMemory</samp>
    释放内存，并验证内存现在处于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp> 状态 ❽。使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> 分配的内存被视为私有的，如
    [列表2-30](chapter2.xhtml#Lis2-30) 中 <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    属性所示。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Section Objects</samp>
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">节对象</samp>
- en: 'Another way of allocating virtual memory is through <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object
    is a kernel type that implements memory-mapped files. We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects for two related purposes:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种分配虚拟内存的方式是通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    对象。<samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> 对象是实现内存映射文件的内核类型。我们可以将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> 对象用于两个相关的目的：
- en: Reading or writing a file as if it were all read into memory
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件当作完全读入内存的方式进行读写
- en: Sharing memory between processes so that the modification in one process is
    reflected in the other
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进程之间共享内存，以便一个进程中的修改能够反映到另一个进程
- en: We can create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object via the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>
    system call or the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSection</samp>
    PowerShell command. We must specify the size of the mapping, the protection for
    the memory, and an optional file handle; in return, we get a handle to the section.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>
    系统调用或 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSection</samp> PowerShell
    命令创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> 对象。我们必须指定映射的大小、内存的保护以及一个可选的文件句柄；作为回报，我们会获得该节的句柄。
- en: However, creating a section doesn’t automatically allow us to access the memory;
    we first need to map it into the virtual memory address space using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>. [Listing
    2-31](chapter2.xhtml#Lis2-31) provides an example in which we create an anonymous
    section and map it into memory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建节并不会自动允许我们访问内存；我们首先需要使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp> 将其映射到虚拟内存地址空间。[列表2-31](chapter2.xhtml#Lis2-31)
    提供了一个示例，我们在其中创建了一个匿名节并将其映射到内存中。
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 2-31: Creating a section and mapping it into memory'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2-31：创建节并将其映射到内存
- en: To start, we create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object with a size of 4,096 bytes and protection of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>
    ❶. We don’t specify a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    parameter, which means it’s anonymous and not backed by any file. If we gave the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object an OMNS path,
    the anonymous memory it represents could be shared with other processes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个大小为4,096字节、保护模式为<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象❶。我们没有指定<samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>参数，这意味着它是匿名的，并且没有任何文件支持。如果我们为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象指定一个OMNS路径，它所代表的匿名内存可以与其他进程共享。
- en: We then map the section into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>,
    specifying the protection we want for the memory, and query the mapped address
    to verify that the operation succeeded ❷. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp>. When we’re
    done with the mapping, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSection</samp>
    to unmap the section and then verify that it’s now free ❸.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>将部分映射到内存中，指定我们希望的内存保护，并查询映射地址以验证操作是否成功❷。请注意，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp>。当我们完成映射后，我们调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSection</samp>解除映射部分，然后验证它是否已经被释放❸。
- en: Finally, we demonstrate that we can’t map a section with different protection
    than that granted when we created the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object ❹. When we try to map the section with read and execute permissions, which
    aren’t compatible, we see an exception.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们演示了在创建<samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象时授予的保护权限与映射时的保护权限不相符的情况❹。当我们尝试以读取和执行权限映射该部分时，由于这两者不兼容，我们会看到一个异常。
- en: The protection you’re allowed to use to map a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object into memory depends on two things. The first is the protection specified
    when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object was
    created. For example, if the section was created with <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>
    protection, you can never map it to be writable.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 映射<samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象到内存时，你可以使用的保护权限取决于两个因素。第一个因素是创建<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象时指定的保护权限。例如，如果该部分使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>保护创建，则你永远无法将其映射为可写。
- en: The second dependency is the access granted to the section handle you’re mapping.
    If you want to map the section as readable, then the handle must have <samp class="SANS_TheSansMonoCd_W5Regular_11">MapRead</samp>
    access. To map it to be writable, you need both <samp class="SANS_TheSansMonoCd_W5Regular_11">MapRead</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access. (And,
    of course, having just <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access isn’t sufficient to map the section as writable if the original <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object was not specified with a writable protection.)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个依赖因素是映射部分句柄时授予的访问权限。如果你想将部分映射为可读，那么句柄必须具有<samp class="SANS_TheSansMonoCd_W5Regular_11">MapRead</samp>访问权限。要将其映射为可写，你需要同时拥有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MapRead</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>访问权限。（当然，仅有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>访问权限不足以将部分映射为可写，如果原始<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象没有指定可写的保护权限。）
- en: It’s possible to map a section into another process by specifying a process
    handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>.
    We don’t need to specify the process to <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSection</samp>,
    as the mapping object knows what process it was mapped in. In the memory information
    output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column would
    be populated by the name of the backing file, if it exists.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为<samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>指定一个进程句柄，可以将部分映射到另一个进程中。我们不需要为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSection</samp>指定进程，因为映射对象已经知道它是在哪个进程中映射的。在内存信息输出中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>列将填充支持文件的名称（如果存在）。
- en: The section we created was anonymous, so we don’t see anything in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column, but we can perform
    a query to find mapped sections that are backed by files using the command shown
    in [Listing 2-32](chapter2.xhtml#Lis2-32).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的节是匿名的，因此在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> 列中看不到任何内容，但我们可以执行查询来查找由文件支持的映射节，使用
    [列表 2-32](chapter2.xhtml#Lis2-32) 中显示的命令。
- en: '[PRE31]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 2-32: Listing mapped files with names'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-32：列出带名称的映射文件
- en: In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp> types, there is
    a third section type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>
    type. When provided with a file handle to a Windows executable, the kernel will
    automatically parse the format and generate multiple subsections that represent
    the various components of the executable. To create a mapped image from a file,
    we need only <samp class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp> access
    on the file handle; the file doesn’t need to be readable for us.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp>
    类型之外，还有第三种节类型，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp> 类型。当提供给
    Windows 可执行文件的文件句柄时，内核会自动解析该格式，并生成表示可执行文件各个组件的多个子节。要从文件创建映射图像，我们只需要对文件句柄具有 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp> 权限；文件不需要对我们可读。
- en: Windows uses image sections extensively to simplify the mapping of executables
    into memory. We can specify an image section by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>
    flag when creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object or by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSectionImage</samp>
    command, as shown in [Listing 2-33](chapter2.xhtml#Lis2-33).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 广泛使用映像节来简化将可执行文件映射到内存中的过程。我们可以在创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    对象时，通过传递 <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp> 标志，或者使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-NtSectionImage</samp> 命令，来指定映像节，如
    [列表 2-33](chapter2.xhtml#Lis2-33) 所示。
- en: '[PRE32]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 2-33: Mapping <samp class="SANS_Futura_Std_Book_11">notepad.exe</samp>
    and viewing the loaded image'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-33：映射 <samp class="SANS_Futura_Std_Book_11">notepad.exe</samp> 并查看加载的映像
- en: As you can see, we don’t need to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp> protection
    when mapping the image section. Any protection, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>,
    will work ❶. When we get the memory information for a map-based address, we see
    that there is no executable memory there and that the allocation is only 4,096
    bytes ❷, which seems far too small for *notepad.exe*. This is because the section
    is made up of multiple smaller mapped regions. If we filter out the memory information
    for the mapped name ❸, we can see the executable memory. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Out-HexDump</samp>
    command, we can print the contents of the mapped file buffer ❹.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在映射图像节时不需要指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp> 保护。任何保护，包括
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>，都可以正常工作❶。当我们获取基于映射地址的内存信息时，我们发现那里的内存不可执行，而且分配的大小只有
    4,096 字节❷，这对于 *notepad.exe* 来说似乎太小了。这是因为该节由多个较小的映射区域组成。如果我们筛选出映射名称的内存信息❸，就可以看到可执行内存。使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Out-HexDump</samp> 命令，我们可以打印映射文件缓冲区的内容❹。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Integrity</samp>
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码完整性</samp>
- en: One important security task is ensuring that the code running on your computer
    is the same code the manufacturer intended you to run. If a malicious user has
    modified operating system files, you might encounter security issues such as the
    leaking of private data.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的安全任务是确保在计算机上运行的代码与制造商原本希望你运行的代码相同。如果恶意用户修改了操作系统文件，你可能会遇到安全问题，例如私密数据泄露。
- en: Microsoft considers the integrity of code running on Windows to be so important
    that there is an entire subsystem to deal with it. This *code integrity* subsystem
    verifies and restricts what files can execute in the kernel, and optionally in
    user mode, by checking the code’s integrity. The memory manager can consult with
    the code integrity subsystem when it loads an image file if it needs to check
    whether the executable is correctly signed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 微软认为在Windows上运行的代码完整性非常重要，以至于有一个完整的子系统来处理它。这个*代码完整性*子系统通过检查代码的完整性来验证并限制可以在内核中执行的文件，选择性地也包括用户模式。当加载图像文件时，如果需要检查可执行文件是否被正确签名，内存管理器可以咨询代码完整性子系统。
- en: Almost every executable on a default Windows installation is signed using a
    mechanism called *Authenticode*. This mechanism allows a cryptographic signature
    to be embedded in the executable file or collected inside a catalog file. The
    code integrity subsystem can read this signature, verify that it’s valid, and
    make trust decisions based on it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个默认安装的Windows可执行文件都使用名为*Authenticode*的机制进行签名。此机制允许将加密签名嵌入到可执行文件中或收集到目录文件中。代码完整性子系统可以读取此签名，验证其有效性，并基于此做出信任决策。
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AuthenticodeSignature</samp>
    command to query the signing status of an executable, as shown in [Listing 2-34](chapter2.xhtml#Lis2-34).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AuthenticodeSignature</samp>命令查询可执行文件的签名状态，如[列表2-34](chapter2.xhtml#Lis2-34)所示。
- en: '[PRE33]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 2-34: Displaying the Authenticode signature for a kernel driver'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-34：显示内核驱动程序的 Authenticode 签名
- en: Here, we query the signing status of the *notepad.exe* executable file, formatting
    the command’s output as a list. The output starts with information about the signer’s
    X.509 certificate. Here, I’ve shown only the subject name, which clearly indicates
    that this file is signed by Microsoft.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们查询*notepad.exe*可执行文件的签名状态，并将命令的输出格式化为列表。输出从签名者的X.509证书信息开始。在这里，我只显示了主题名称，清楚地表明该文件是由微软签名的。
- en: Next is the status of the signature; in this case, the status indicates that
    the file is valid and that the signature has been verified. It’s possible to have
    a signed file whose signature is invalid; for example, when the certificate has
    been revoked. In that case, the status is likely to show an error, such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NotSigned</samp>.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是签名的状态；在这种情况下，状态表示文件有效且签名已通过验证。也有可能存在签名无效的签名文件；例如，当证书被撤销时。在这种情况下，状态可能会显示错误，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NotSigned</samp>。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SignatureType</samp> property
    shows that this signature was based on a catalog file rather than being embedded
    in the file. We can also see that this file is an operating system binary, as
    determined by information embedded in the signature.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SignatureType</samp>属性显示该签名是基于目录文件，而不是嵌入到文件中的。我们还可以看到，这个文件是一个操作系统二进制文件，这是通过签名中嵌入的信息来判断的。
- en: The most common trust decision the code integrity subsystem makes is checking
    whether a kernel driver can load. Each driver file must have a signature that
    derives its trust from a Microsoft-issued key. If the signature is invalid or
    doesn’t derive from a Microsoft-issued key, then the kernel can block loading
    of the driver to preserve system integrity.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 代码完整性子系统做出的最常见信任决策是检查是否可以加载内核驱动程序。每个驱动程序文件必须有一个签名，该签名的信任来源于微软颁发的密钥。如果签名无效或不来源于微软颁发的密钥，内核就会阻止加载该驱动程序，以维护系统完整性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Advanced Local Procedure Call</samp>
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">高级本地过程调用</samp>
- en: The *advanced local procedure call (ALPC)* subsystem implements local, cross-process
    communication. To use ALPC, you must first create a server ALPC port using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateAlpcPort</samp> system call
    and specify a name for it inside the OMNS. A client can then use this name by
    calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtConnectAlpcPort</samp>
    system call to connect to the server port.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*高级本地过程调用（ALPC）*子系统实现了本地的跨进程通信。要使用ALPC，首先必须使用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateAlpcPort</samp>系统调用创建一个服务器ALPC端口，并在OMNS中为其指定一个名称。客户端可以通过调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtConnectAlpcPort</samp>系统调用，使用这个名称连接到服务器端口。'
- en: At a basic level, the ALPC port allows the secure transmission of discrete messages
    between a server and a client. ALPC provides the underlying transport for local
    remote procedure call APIs implemented in Windows.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面，ALPC 端口允许服务器和客户端之间安全地传输离散消息。ALPC 提供了 Windows 中实现的本地远程过程调用 API 的底层传输。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Configuration Manager</samp>
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">配置管理器</samp>
- en: The *configuration manager*, known more commonly as the *registry*, is an important
    component for configuring the operating system. It stores a variety of configuration
    information, ranging from the system-critical list of available I/O manager device
    drivers to the (less critical) last position on the screen of your text editor’s
    window.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*配置管理器*，通常被称为*注册表*，是操作系统配置中的一个重要组件。它存储了各种配置信息，从系统关键的可用 I/O 管理器设备驱动程序列表，到（较不关键的）文本编辑器窗口上最后的位置。'
- en: You can think of the registry as a filesystem in which *keys* are like folders
    and *values* are like files. You can access it through the OMNS, although you
    must use registry-specific system calls. The root of the registry is the OMNS
    path *REGISTRY*. You can list the registry in PowerShell using the *NtObject*
    drive, as shown in [Listing 2-35](chapter2.xhtml#Lis2-35).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将注册表视为一个文件系统，其中*键*像文件夹，*值*像文件。你可以通过 OMNS 访问它，尽管你必须使用特定于注册表的系统调用。注册表的根是 OMNS
    路径*REGISTRY*。你可以在 PowerShell 中使用*NtObject*驱动程序列出注册表，如[列表 2-35](chapter2.xhtml#Lis2-35)所示。
- en: '[PRE34]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 2-35: Enumerating the registry root key'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-35：枚举注册表根键
- en: You can replace <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObject:\REGISTRY</samp>
    in [Listing 2-35](chapter2.xhtml#Lis2-35) with <samp class="SANS_TheSansMonoCd_W5Regular_11">NtKey:\</samp>
    to make accessing the registry simpler.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将[列表 2-35](chapter2.xhtml#Lis2-35)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">NtObject:\REGISTRY</samp>替换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtKey:\</samp>，以便更简单地访问注册表。
- en: The kernel pre-creates the four keys shown here when it initializes. Each of
    the keys is a special *attachment point* at which you can attach a registry hive.
    A *hive* is a hierarchy of <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp>
    objects underneath a single root key. An administrator can load new hives from
    a file and attach them to these preexisting keys.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: "内核在初始化时会预创建这里显示的四个键。每个键都是一个特殊的*附加点*，在这里可以附加一个注册表配置单元。*配置单元*是一个在单一根键下的<\tsamp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">键</samp>对象的层级结构。管理员可以从文件加载新的配置单元，并将其附加到这些已存在的键上。"
- en: Note that PowerShell already comes with a drive provider that you can use to
    access the registry. However, this drive provider exposes only the Win32 view
    of the registry, which hides the internal details about the registry from view.
    We’ll cover the Win32 view of the registry separately in [Chapter 3](chapter3.xhtml).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PowerShell 已经带有一个驱动程序提供者，可以用来访问注册表。然而，这个驱动程序提供者仅暴露注册表的 Win32 视图，隐藏了注册表的内部细节。我们将在[第
    3 章](chapter3.xhtml)中单独介绍注册表的 Win32 视图。
- en: You can interact with the registry directly, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtKey</samp> commands to
    open and create <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> objects,
    respectively. You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKeyValue</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtKeyValue</samp> to get
    and set key values. To remove keys or values, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtKey</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtKeyValue</samp>. [Listing
    2-36](chapter2.xhtml#Lis2-36) shows a few of these commands in action.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接与注册表交互，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-NtKey</samp>命令分别打开和创建<samp class="SANS_TheSansMonoCd_W5Regular_11">键</samp>对象。你还可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKeyValue</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtKeyValue</samp>来获取和设置键值。要删除键或值，请使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtKey</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtKeyValue</samp>。[列表
    2-36](chapter2.xhtml#Lis2-36)展示了这些命令的应用实例。
- en: '[PRE35]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 2-36: Opening a registry key and querying its values'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-36：打开注册表项并查询其值
- en: We open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> object using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp> command. We
    can then query the values stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp>
    object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKeyValue</samp>
    command. Each entry in the output shows the name of the value, the type of data
    stored, and a string representation of the data.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp>命令打开一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Key</samp>对象。然后，我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKeyValue</samp>命令查询存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Key</samp>对象中的值。输出中的每一项都显示了值的名称、存储的数据类型以及数据的字符串表示。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">工作示例</samp>
- en: Using PowerShell, you can easily change this book’s example scripts to do many
    different things. To encourage experimentation, each chapter wraps up with a set
    of worked examples repurposing the various commands you’ve learned.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PowerShell，你可以轻松修改本书中的示例脚本来完成许多不同的任务。为了鼓励实验，每一章的结尾都会有一组工作示例，重新利用你所学的各种命令。
- en: In these examples, I’ll also highlight times where I’ve discovered security
    vulnerabilities using this tooling. This should give you a clear indication of
    what to look for in Microsoft or third-party applications if you’re a security
    researcher; likewise, for developers, it will help you avoid certain pitfalls.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我还将突出显示我使用此工具发现的安全漏洞。如果你是安全研究员，这应该能清楚地指示你在 Microsoft 或第三方应用程序中需要关注的事项；同样，对于开发人员来说，它将帮助你避免某些陷阱。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Open Handles
    by Name</samp>
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按名称查找打开的句柄</samp>
- en: The objects returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>
    command have additional properties that allow you to query the object’s name and
    security descriptor. These properties are not shown by default, as they’re expensive
    to look up; doing so requires opening the process containing the handle for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access, duplicating the
    handle back to the calling PowerShell instance, and finally querying the property.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>命令返回的对象具有附加属性，允许你查询对象的名称和安全描述符。这些属性默认情况下不会显示，因为查询它们代价较高；要执行此操作，需要打开包含句柄的进程以获得<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>访问权限，将句柄复制回调用的 PowerShell
    实例，最后查询属性。
- en: If performance doesn’t matter to you, then you can use the code in [Listing
    2-37](chapter2.xhtml#Lis2-37) to find all open files matching a specific filename.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能对你来说不重要，那么你可以使用[列表 2-37](chapter2.xhtml#Lis2-37)中的代码来查找所有匹配特定文件名的打开文件。
- en: '[PRE36]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 2-37: Finding File object handles that match a specific name'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-37：查找匹配特定名称的文件对象句柄
- en: This script queries for all <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    object handles and filters them to only the ones with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Windows</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> property, which
    represents the filepath. Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    property has been queried, it’s cached so you can then display it to the console
    with a custom selection.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本查询所有<samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>对象句柄，并将其筛选为仅包含在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>属性中包含字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">Windows</samp>的句柄，该属性表示文件路径。一旦查询了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>属性，它就会被缓存，以便你可以使用自定义选择将其显示到控制台上。
- en: Note that because it duplicates the handle from the process, this script can
    only show handles in processes the caller can open. To get the best results, run
    it as an administrator user who can open the maximum number of processes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于它重复了进程中的句柄，因此此脚本只能显示调用者可以打开的进程中的句柄。为了获得最佳结果，作为管理员用户运行它，这样你就可以打开最大数量的进程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Shared Objects</samp>
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查找共享对象</samp>
- en: When you query the list of handles using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>
    command, you also get the address of the object in kernel memory. When you open
    the same kernel object, you’ll get different handles, but they will still point
    to the same kernel object address.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp> 命令查询句柄列表时，你还会得到对象在内核内存中的地址。当你打开相同的内核对象时，你会得到不同的句柄，但它们仍然指向相同的内核对象地址。
- en: You can use the object address to find processes that share handles. This can
    be interesting for security in cases where an object is shared between two processes
    with different privileges. The lower-privileged process might be able to modify
    the properties of the object to bypass security checks in the higher-privileged
    process, enabling it to gain additional privileges.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用对象地址来查找共享句柄的进程。这在安全性方面可能非常重要，特别是在一个对象被两个具有不同权限的进程共享的情况下。权限较低的进程可能能够修改该对象的属性，从而绕过权限较高的进程的安全检查，进而获得额外的权限。
- en: In fact, I used this technique to find security issue CVE-2019-0943 in Windows.
    At the root of the issue was a privileged process, the Windows Font Cache, that
    shared section handles with a low-privileged process. The low-privileged process
    could map the shared section to be writable and modify contents that the privileged
    process assumed couldn’t be modified. This effectively allowed the low-privileged
    process to modify arbitrary memory in the privileged process, resulting in privileged
    code execution.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我使用这项技术在 Windows 中发现了安全漏洞 CVE-2019-0943。问题的根源是一个特权进程，即 Windows 字体缓存，它与一个低权限的进程共享了
    Section 句柄。低权限的进程可以将共享的 Section 映射为可写，并修改特权进程认为无法修改的内容。这实际上使得低权限进程能够修改特权进程中的任意内存，从而实现特权代码执行。
- en: '[Listing 2-38](chapter2.xhtml#Lis2-38) gives an example of finding writable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects shared between
    two processes.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-38](chapter2.xhtml#Lis2-38) 给出了查找两个进程之间共享的可写 <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    对象的示例。'
- en: '[PRE37]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 2-38: Finding shared Section handles'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-38：查找共享的 Section 句柄
- en: We first get the handles, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">GroupByAddress</samp>
    parameter. This returns a list of groups organized based on the kernel object
    address, instead of a list of handles. You can also group handles using the built-in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Group-Object</samp> command; however,
    the groups returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">GroupByAddress</samp>
    have additional properties, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ShareCount</samp>,
    which indicates the number of unique processes an object is shared with. Here,
    we filter to include only handles that are shared between two processes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取句柄，指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">GroupByAddress</samp>
    参数。这样会返回根据内核对象地址组织的组列表，而不是句柄列表。你也可以使用内置的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Group-Object</samp>
    命令来对句柄进行分组；然而，<samp class="SANS_TheSansMonoCd_W5Regular_11">GroupByAddress</samp>
    返回的组包含额外的属性，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">ShareCount</samp>，它表示对象与多少个唯一的进程共享。在这里，我们进行筛选，仅包括在两个进程之间共享的句柄。
- en: Next, we want to find <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects that can be mapped as writable. We first check that all the handles have
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access. As mentioned
    earlier, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object’s
    protection must also be writable for us to be able to map it as writable. Oddly,
    we can’t query for the original protection that was assigned when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object was created, but checking for <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access is a simple proxy. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessIntersection</samp>
    property, which contains the granted access rights shared among all the handles.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要查找可以映射为可写的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    对象。我们首先检查所有句柄是否具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    访问权限。如前所述，<samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> 对象的保护也必须是可写的，才能将其映射为可写。奇怪的是，我们无法查询
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> 对象创建时分配的原始保护，但检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> 访问权限是一个简单的代理。我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessIntersection</samp> 属性，它包含所有句柄共享的授权访问权限。
- en: 'Now that we have potential candidates for shared sections, we need to work
    out which meet the criterion that we can access only one of the processes containing
    the section handle. We’re making another assumption here: if we can open only
    one of the two processes that share the handle for <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>
    access, then we’ve got a section shared between a privileged and a low-privileged
    process. After all, if you had <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>
    access to both processes, you could already compromise the processes by stealing
    all their handles or duplicating their process handles, and if you couldn’t get
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access to either
    process, then you couldn’t get access to the section handle at all.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了潜在的共享节候选项，我们需要确定哪些满足以下标准：我们只能够访问包含该节句柄的其中一个进程。我们在这里做出另一个假设：如果我们只能打开共享句柄的两个进程中的一个进行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>访问，那么我们就有一个在特权进程和低特权进程之间共享的节。毕竟，如果你对两个进程都有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>访问权限，你已经可以通过窃取所有句柄或复制它们的进程句柄来破坏这些进程；如果你无法访问任何一个进程的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>权限，那么你根本无法访问该节句柄。
- en: The result shown in [Listing 2-38](chapter2.xhtml#Lis2-38) is a section shared
    between Chrome and the Audio Device Graph process. The shared section is used
    to play audio from the browser, and it’s probably not a security issue. However,
    if you run the script on your own system, you might find shared sections that
    are.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-38](chapter2.xhtml#Lis2-38)中显示的结果是Chrome和音频设备图形进程之间共享的一个节。该共享节用于从浏览器播放音频，可能不是安全问题。然而，如果你在自己的系统上运行该脚本，你可能会找到一些共享节存在安全问题。'
- en: Note that once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object is mapped into memory, the handle is no longer required. Therefore, you
    might miss some shared sections that were mapped when the original handle closed.
    It’s also highly likely you’ll get false positives, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects that are intentionally writable by everyone. The goal here is to find
    a potential attack surface on Windows. You must then go and inspect the handles
    to see if sharing them has introduced a security issue.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦<samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象被映射到内存中，句柄就不再需要。因此，你可能会错过一些在原始句柄关闭时已映射的共享节。也很可能会出现误报，例如那些故意对所有人可写的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象。这里的目标是找到Windows上的潜在攻击面。你必须进一步检查句柄，看看共享它们是否引入了安全问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Modifying a Mapped
    Section</samp>
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">修改映射的节</samp>
- en: If you find an interesting <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object to modify, you can map it into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>.
    But how do you modify the mapped memory? The simplest approach from the command
    line is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>
    command, which supports passing a mapped section and an array of bytes to write.
    [Listing 2-39](chapter2.xhtml#Lis2-39) demonstrates this technique by assuming
    you have a handle of interest in the <samp class="SANS_TheSansMonoCd_W5Regular_11">$handle</samp>
    variable.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找到一个有趣的<samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象进行修改，你可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>将其映射到内存中。但是，如何修改映射后的内存呢？从命令行的最简单方法是使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>命令，该命令支持传递映射的节和一个字节数组进行写入。[列表
    2-39](chapter2.xhtml#Lis2-39)通过假设你在<samp class="SANS_TheSansMonoCd_W5Regular_11">$handle</samp>变量中有一个感兴趣的句柄来演示这一技术。
- en: '[PRE38]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 2-39: Mapping and modifying a Section object'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-39：映射和修改一个Section对象
- en: We first call the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetObject</samp>
    method on the handle to duplicate it into the current process and return a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object. For this to succeed,
    the process in which we’re running this command must be able to access the process
    with the handle. We then map the handle as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>
    into the current process’s memory.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在句柄上调用<samp class="SANS_TheSansMonoCd_W5Regular_11">GetObject</samp>方法，将其复制到当前进程并返回一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象。为了成功执行此操作，运行该命令的进程必须能够访问具有该句柄的进程。然后，我们将句柄映射为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>模式到当前进程的内存中。
- en: We can now create a random array of bytes up to the size of the mapped section
    and write them to the memory region using <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>.
    This is a quick and dirty fuzzer for the shared memory. The hope is that by modifying
    the memory, the privileged process will mishandle the contents of the memory region.
    If the privileged process crashes, we should investigate to determine whether
    we can control the crash using a more targeted modification of the shared memory.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个随机字节数组，大小不超过映射段的大小，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>将其写入内存区域。这是一个简单而粗糙的共享内存模糊测试工具。希望通过修改内存，特权进程会错误处理内存区域的内容。如果特权进程崩溃，我们应该调查并确定是否可以通过更有针对性的共享内存修改来控制崩溃。
- en: We can display the memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Out-HexDump</samp>.
    One of the useful features of this command over the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Hex</samp>
    is that it’ll print the address in memory based on the mapped file, whereas <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-Hex</samp> just prints an offset
    starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Out-HexDump</samp>来显示内存。与内置的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-Hex</samp>相比，这个命令的一个有用功能是它会根据映射文件打印内存地址，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-Hex</samp>仅打印一个从<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>开始的偏移量。
- en: 'You can also create a GUI hex editor with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtSection</samp>
    command, specifying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object to edit. As the section can be mapped into any process, writing it in the
    GUI hex editor will also modify all other mappings of that section. Here is the
    command to display the hex editor:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtSection</samp>命令创建一个GUI十六进制编辑器，并指定一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象进行编辑。由于该段可以映射到任何进程，使用GUI十六进制编辑器编辑它也会修改该段的所有其他映射。以下是显示十六进制编辑器的命令：
- en: '[PRE39]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[Figure 2-6](chapter2.xhtml#fig2-6) shows an example of the editor generated
    by running the previous command.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-6](chapter2.xhtml#fig2-6)显示了运行先前命令后生成的编辑器示例。'
- en: '![](../images/Figure2-6.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: The section editor
    GUI</samp>'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-6：段编辑器GUI</samp>
- en: The GUI shown in [Figure 2-6](chapter2.xhtml#fig2-6) maps the section into memory
    and then displays it in a hex editor form. If the section is writable, you can
    modify the contents of the memory through the editor.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-6](chapter2.xhtml#fig2-6)中显示的GUI将段映射到内存中，然后以十六进制编辑器的形式显示。如果该段是可写的，你可以通过编辑器修改内存的内容。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Writable
    and Executable Memory</samp>
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">寻找可写且可执行的内存</samp>
- en: In Windows, for a process to execute instructions, the memory must be marked
    as executable. However, it’s also possible to map the memory as both writable
    and executable. Malware sometimes uses this combination of permissions to inject
    shell code into a process and run malicious code using the host process’s identity.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，为了让一个进程执行指令，内存必须被标记为可执行。然而，也可以将内存同时映射为可写和可执行。恶意软件有时利用这种权限组合将Shell代码注入到进程中，并利用主机进程的身份执行恶意代码。
- en: '[Listing 2-40](chapter2.xhtml#Lis2-40) shows how to check for memory in a process
    that is both writable and executable. Finding such memory might indicate that
    something malicious is going on, although in most cases this memory will be benign.
    For example, the .NET runtime creates writable and executable memory to perform
    just-in-time (JIT) compilation of the .NET byte code into native instructions.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单2-40](chapter2.xhtml#Lis2-40)展示了如何检查一个既可写又可执行的进程内存。找到这种内存可能表明存在恶意行为，尽管在大多数情况下，这种内存是良性的。例如，.NET运行时会创建可写和可执行的内存，用于将.NET字节码即时（JIT）编译为本地指令。'
- en: '[PRE40]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 2-40: Finding executable and writable memory in a process'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-40：在进程中找到可执行和可写的内存
- en: We start by opening a process for <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>
    access, which is all we need to enumerate the virtual memory regions. Here, we’re
    opening the current PowerShell process; as PowerShell is .NET, we know it will
    have some writable and executable memory regions, but the process you open can
    be anything you want to check.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先以<samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>权限打开一个进程，这是枚举虚拟内存区域所需的全部权限。在这里，我们打开当前的
    PowerShell 进程；由于 PowerShell 是 .NET，我们知道它会有一些可写且可执行的内存区域，但你可以打开任何你想检查的进程。
- en: We then enumerate all the memory regions using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    and filter on the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp>
    protection type. We need to use a bitwise AND operation as there are additional
    flags that can be added to the protection, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Guard</samp>,
    which creates a guard page that prevents doing a direct equality check.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>枚举所有内存区域，并过滤出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp>保护类型。由于可能有额外的标志添加到保护类型中，我们需要使用按位与操作，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Guard</samp>，它会创建一个保护页，防止进行直接的相等检查。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter provided a tour through the Windows kernel and its internals. The
    kernel consists of many separate subsystems, such as the Security Reference Monitor,
    the object manager, the configuration manager (or registry), the I/O manager,
    and the process and thread manager.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Windows 内核及其内部结构。内核由许多独立的子系统组成，如安全参考监视器、对象管理器、配置管理器（或注册表）、I/O 管理器以及进程和线程管理器。
- en: You learned about how the object manager manages kernel resources and types,
    how to access kernel resources through system calls, and how handles are allocated
    with specific access rights. You also accessed object manager resources through
    the *NtObject* drive provider as well as through individual commands.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了对象管理器如何管理内核资源和类型，如何通过系统调用访问内核资源，以及如何分配具有特定访问权限的句柄。你还通过*NtObject*驱动程序提供者以及各个命令访问了对象管理器资源。
- en: I then discussed the basics of process and thread creation and demonstrated
    the use of commands such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    to query for process information on the system. I explained how to inspect the
    virtual memory of a process, as well as some of the individual memory types.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我讨论了进程和线程创建的基础，并演示了如何使用诸如<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>之类的命令来查询系统中的进程信息。我解释了如何检查进程的虚拟内存，以及一些不同的内存类型。
- en: A user doesn’t directly interact with the kernel; instead, user-mode applications
    power the user experience. In the next chapter, we’ll discuss the user-mode components
    in more detail.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 用户不会直接与内核交互；相反，用户模式应用程序驱动用户体验。在下一章中，我们将更详细地讨论用户模式组件。
