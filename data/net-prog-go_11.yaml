- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Writing HTTP Clients
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 HTTP 客户端
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The *HyperText Transfer Protocol**(HTTP)* is an application layer protocol used
    by the World Wide Web. In an HTTP communication, a web client sends a *uniform
    resource locator**(URL)* to a web server, and the web server responds with the
    corresponding media resources. In this context, a *resource* could be an image,
    a style sheet, an HTML document, a JavaScript file, and so on. For example, if
    your web browser sent the URL *www.google.com* to Google’s web servers, the servers
    would return Google’s main page. Most of us make such web transactions daily,
    whether they originate from our phones, computers, or Internet of Things (IoT)
    devices, such as doorbells, thermostats, or toasters (yes, really).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*超文本传输协议**(HTTP)* 是一种应用层协议，被万维网使用。在 HTTP 通信中，Web 客户端向 Web 服务器发送一个 *统一资源定位符**(URL)*，然后
    Web 服务器返回相应的媒体资源。在这个上下文中，*资源* 可以是图像、样式表、HTML 文档、JavaScript 文件等。例如，如果您的 Web 浏览器向
    Google 的 Web 服务器发送了 URL *www.google.com*，服务器将返回 Google 的主页。我们中的大多数人每天都会进行这种 Web
    交易，无论它们是来自我们的手机、电脑，还是物联网（IoT）设备，如门铃、温控器或烤面包机（是的，真的）。'
- en: This chapter will introduce you to Go’s HTTP client. First, you’ll learn the
    basics of HTTP, including request methods and response codes. Next, you’ll explore
    Go’s HTTP client to request resources from web servers, paying attention to potential
    pitfalls along the way. Then, you’ll move into the standard library code and learn
    the implementations that facilitate the request-response communication between
    an HTTP client and server. Finally, you’ll see common pitfalls to look for when
    interacting with web servers using Go’s HTTP client.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍 Go 的 HTTP 客户端。首先，您将学习 HTTP 的基础知识，包括请求方法和响应代码。接下来，您将探索 Go 的 HTTP 客户端，向
    Web 服务器请求资源，并注意过程中可能遇到的问题。然后，您将进入标准库代码，学习实现 HTTP 客户端与服务器之间请求响应通信的相关内容。最后，您将了解使用
    Go 的 HTTP 客户端与 Web 服务器交互时常见的问题。
- en: This chapter will give you the basics for interacting with services over HTTP.
    You’ll need this foundation to understand how to handle requests from the server’s
    point of view in the next chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您提供与服务进行 HTTP 交互的基础知识。您需要掌握这些基础，才能在下一章中了解如何从服务器的角度处理请求。
- en: Understanding the Basics of HTTP
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 HTTP 的基础知识
- en: HTTP is a sessionless client-server protocol in which the client initiates a
    request to the server and the server responds to the client. HTTP is an application
    layer protocol and serves as the foundation for communication over the web. It
    uses TCP as its underlying transport layer protocol.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是一种无状态的客户端-服务器协议，在该协议中，客户端向服务器发起请求，服务器对客户端进行响应。HTTP 是一种应用层协议，作为 Web 上通信的基础。它使用
    TCP 作为底层传输层协议。
- en: This chapter assumes that you’re using HTTP version 1.1 (HTTP/1.1). We’ll also
    cover functionality introduced in HTTP version 2.0 (HTTP/2). Thankfully, Go abstracts
    many of the differences between these protocols, so we can easily use either protocol
    with the same bit of code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您使用的是 HTTP 1.1 版本（HTTP/1.1）。我们还将介绍 HTTP 2.0 版本（HTTP/2）中引入的功能。幸运的是，Go 对这些协议之间的差异进行了抽象处理，因此我们可以使用相同的代码轻松地使用任意一个协议。
- en: Uniform Resource Locators
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统一资源定位符
- en: 'A *URL* is an address of sorts used by the client to locate a web server and
    identify the requested resource. It’s composed of five parts: a required *scheme*
    indicating the protocol to use for the connection, an optional *authority* for
    the resource, the *path* to the resource, an optional *query*, and an optional
    *fragment*. A colon (:) followed by two forward slashes (//) separates the scheme
    from the authority. The authority includes an optional colon-delimited username
    and password suffixed with an at symbol (@), a hostname, and an optional port
    number preceded by a colon. The path is a series of segments preceded by a forward
    slash. A question mark (?) indicates the start of the query, which is conventionally
    composed of key-value pairs separated by an ampersand (&). A hash mark (#) precedes
    the fragment, which is an identifier to a subsection of the resource. Taken together,
    a URL follows this pattern:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*URL*是客户端用来定位网页服务器并识别请求资源的一种地址。它由五个部分组成：一个必需的*scheme*，表示用于连接的协议，一个可选的*authority*，表示资源的权限，一个表示资源路径的*path*，一个可选的*query*，以及一个可选的*fragment*。冒号（:）后跟两个斜杠（//）将scheme和authority分开。authority包括一个可选的由冒号分隔的用户名和密码，后接一个@符号，一个主机名，以及一个可选的端口号，端口号前面有冒号。path是由斜杠分隔的一系列段。问号（?）表示query的开始，通常由键值对组成，键值对之间用&符号分隔。井号（#）前置fragment，它是资源的子部分标识符。综合来看，URL遵循如下模式：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The typical URL you use over the internet includes a scheme and a hostname
    at minimum. For example, if you felt compelled to look up images of gophers, you
    could visit Google’s image search by entering the following URL in your web browser’s
    address bar, then searching for *gophers* in the image search tab:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你在互联网上使用的典型URL至少包括一个scheme和一个hostname。例如，如果你想查找地松鼠的图片，你可以通过在浏览器地址栏中输入以下URL来访问Google的图像搜索，然后在图像搜索标签中搜索*gophers*：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The scheme 1 informs your browser that you want to use HTTPS to connect to
    the address *images.google.com*2 and that you want the default resource 3. If
    you specify the web server address without any specific resource, the web server
    will respond with a default resource. Just as it’s helpful for large corporations
    to send your call to a receptionist when you omit an extension number, it’s helpful
    for web servers to serve up a default resource if you don’t specify the resource
    you want. Google receives your request and responds with the image search page.
    When you type *gophers* in the search box and submit the form, your browser sends
    a request using a URL like this, truncated for brevity:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: scheme 1告知浏览器你希望使用HTTPS协议连接到地址*images.google.com*2，并且你希望获取默认资源3。如果你指定了网页服务器的地址而没有明确指定资源，网页服务器将响应一个默认资源。就像大公司在你没有输入分机号时会将电话转接给接待员一样，网页服务器在你没有指定想要的资源时也会提供一个默认资源。谷歌接收到你的请求并返回图像搜索页面。当你在搜索框中输入*gophers*并提交表单时，浏览器会发送一个像这样的网址请求，以下是简化后的示例：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This URL asks Google for a resource named *search*1 and includes a *query string*.
    The query string, indicated by the question mark 2, contains ampersand-separated
    parameters defined by, and meaningful to, the web server. In this example, the
    value of the `q` parameter 3 is your search query, `gophers`. The `tbm` parameter’s
    value of `isch` tells Google you’re performing an image search. Google defines
    the parameters and their values. You pass them along to Google’s web servers as
    part of the request. The actual URL in your browser’s address bar is quite a bit
    longer and includes other details Google needs in order to satisfy your request.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URL向谷歌请求一个名为*search*1的资源，并包含一个*query string*。query string由问号2开始，包含由&符号分隔的参数，这些参数由网页服务器定义，并对其有意义。在这个例子中，`q`参数3的值是你的搜索查询，`gophers`。`tbm`参数的值是`isch`，告诉谷歌你正在进行图像搜索。谷歌定义了这些参数及其值，你将它们作为请求的一部分传递给谷歌的网页服务器。实际上，浏览器地址栏中的URL要长得多，并包含谷歌为了满足你的请求所需的其他详细信息。
- en: 'If my wife were to send me shopping using HTTP, the URL she would give me might
    look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我的妻子让我使用HTTP去购物，她可能会给我这样的URL：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tells me I’m to drive my car to the grocery store and pick up Irish butter,
    a dozen eggs, and dark roast coffee. It’s important to mention that the scheme
    is relevant only to the context in which it’s used. My web browser wouldn’t know
    what to do with the *automobile* scheme, but for the sake of my marriage, I sure
    do.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我，我应该开车去杂货店，买爱尔兰黄油、一打鸡蛋和深烘焙咖啡。值得提到的是，scheme仅与使用它的上下文相关。我的网页浏览器不知道该如何处理*automobile*这个scheme，但为了我的婚姻，我可得知道怎么做。
- en: Client Resource Requests
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端资源请求
- en: An *HTTP request* is a message sent from a client to a web server that asks
    the server to respond with a specific resource. The request consists of a method,
    a target resource, headers, and a body. The *method* tells the server what you
    want it to do with the target resource. For example, the `GET` method followed
    by *robots.txt* tells the server you want it to send you the *robots.txt* file,
    whereas the `DELETE` method indicates to the server that you want it to delete
    that resource.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP 请求* 是从客户端发送到 Web 服务器的一条消息，要求服务器返回特定的资源。请求包括方法、目标资源、头部信息和正文。*方法* 告诉服务器你希望它如何处理目标资源。例如，`GET`
    方法后跟 *robots.txt* 告诉服务器你希望它将 *robots.txt* 文件发给你，而 `DELETE` 方法则表示你希望服务器删除该资源。'
- en: '*Request headers* contain metadata about the content of the request you are
    sending. The `Content-Length` header, for example, specifies the size of the request
    body in bytes. The *request body* is the payload of the request. If you upload
    a new profile picture to a web server, the request body will contain the image
    encoded in a format suitable for transport over the network, and the `Content-Length`
    header’s value will be set to the size in bytes of the image in the request body.
    Not all request methods require a request body.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*请求头部* 包含关于你发送的请求内容的元数据。例如，`Content-Length` 头部指定请求体的大小（以字节为单位）。*请求体* 是请求的有效负载。如果你上传一张新的个人资料图片到
    Web 服务器，请求体将包含以适合通过网络传输的格式编码的图像，而 `Content-Length` 头部的值则会被设置为图像在请求体中的字节大小。并非所有的请求方法都需要请求体。'
- en: '[Listing 8-1](#listing8-1) details a simple `GET` request for Google’s *robots.txt*
    file over Netcat to Google’s web server. “Testing the Service with Netcat” on
    page 159 walks you through installing Netcat.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-1](#listing8-1) 详细介绍了通过 Netcat 向 Google 的 Web 服务器发送简单的 `GET` 请求以获取 *robots.txt*
    文件的过程。《使用 Netcat 测试服务》在第 159 页会引导你安装 Netcat。'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 8-1: Sending a request for Google’s *robots.txt* file and receiving
    a response with its contents'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-1：请求 Google 的 *robots.txt* 文件并接收其内容的响应
- en: The `GET` request 1 tells Google’s web server you want the */robots.txt* file
    using HTTP/1.1\. Following the request, you press the enter key twice to send
    the request followed by an empty line. The web server promptly responds with a
    status line 2, a series of headers 3, an empty line delimiting the headers from
    the response body, and the contents of the *robots.txt* file in the response body
    4. You’ll learn about server responses a bit later in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 请求 1 告诉 Google 的 Web 服务器，你想要通过 HTTP/1.1 获取 */robots.txt* 文件。请求之后，你按下回车键两次以发送请求，后面跟着一个空行。Web
    服务器会迅速响应，返回状态行 2、一系列头部信息 3、一个空行用来分隔头部和响应体，最后是 *robots.txt* 文件的内容在响应体中 4。你将在本章稍后学习关于服务器响应的内容。'
- en: 'Using Go’s `net/http` package, you can create a request with nothing but an
    HTTP method and a URL. The `net/http` package includes constants for the most
    common RFC 7231 and RFC 5789 request methods. The RFCs contain quite a bit of
    jargon with respect to request methods. The following descriptions describe how
    to use these methods in practice:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 的 `net/http` 包，你可以只使用 HTTP 方法和 URL 来创建一个请求。`net/http` 包包括最常用的 RFC 7231
    和 RFC 5789 请求方法的常量。这些 RFC 中包含了大量关于请求方法的术语。以下描述了如何在实践中使用这些方法：
- en: '`GET` As in the earlier example, the `GET` method instructs the server to send
    you the target resource. The server will deliver the target resource in the response’s
    body. It’s important to note that the target resource does not need to be a file;
    the response could deliver you dynamically generated content, like the *gophers*
    image search result discussed earlier. The server should never change or remove
    the resource as the result of a `GET` request.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET` 就像之前的例子一样，`GET` 方法指示服务器将目标资源发送给你。服务器将在响应的正文中提供目标资源。需要注意的是，目标资源不一定是文件；响应也可以返回动态生成的内容，比如前面讨论的
    *gophers* 图片搜索结果。服务器在收到 `GET` 请求后不应该修改或删除资源。'
- en: '`HEAD` The `HEAD` method is like `GET` except it tells the server to exclude
    the target resource in its response. The server will send only the response code
    and other various bits of metadata stored in the response headers. You can use
    this method to retrieve meaningful details about a resource, such as its size,
    to determine whether you want to retrieve the resource in the first place. (The
    resource may be larger than you expect.)'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HEAD` `HEAD` 方法类似于 `GET`，不过它告诉服务器在响应中排除目标资源。服务器只会发送响应代码和存储在响应头中的各种元数据。你可以使用这种方法来检索有关资源的有意义的细节，例如资源的大小，以便决定是否要获取该资源。（该资源可能比你预期的要大。）'
- en: '`POST` A `POST` request is a way for you to upload data included in the request
    body to a web server. The `POST` method tells the server that you are sending
    data to associate with the target resource. For example, you may post a new comment
    to a news story, in which case the news story would be the target resource. In
    simple terms, think of the `POST` method as the method for creating new resources
    on the server.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST` `POST` 请求是一种将请求体中的数据上传到 Web 服务器的方式。`POST` 方法告诉服务器你正在发送数据，以便与目标资源关联。例如，你可以发布一个新的评论到新闻故事中，在这种情况下，新闻故事就是目标资源。简单来说，可以将
    `POST` 方法视为在服务器上创建新资源的方法。'
- en: '`PUT` Like `POST`, you can use a `PUT` request to upload data to a web server.
    In practice, the `PUT` method usually updates or completely replaces an existing
    resource. You could use `PUT` to edit the comment you `POST`ed to the news story.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PUT` 与 `POST` 类似，你可以使用 `PUT` 请求将数据上传到 Web 服务器。实际上，`PUT` 方法通常用于更新或完全替换现有资源。你可以使用
    `PUT` 编辑你已发布到新闻故事中的评论。'
- en: '`PATCH` The `PATCH` method specifies partial changes to an existing resource,
    leaving the rest of the resource unmodified. In this way, it’s like a *diff*.
    Let’s assume you are buying a Gopher Plush for that someone special in your life,
    and you’ve proceeded past the shipping address step of the checkout process when
    you realize you made a typo in your street address. You jump back to the shipping
    address form and correct the typo. Now, you could `POST` the form again and send
    all its contents to the server. But a `PATCH` request would be more efficient
    since you made only a single correction. You’ll likely encounter the `PATCH` method
    in APIs, rather than HTML forms.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PATCH` `PATCH` 方法指定对现有资源的部分修改，其他部分保持不变。这样，它就像是一个*差异比较*。假设你正在为你生命中那个特别的人购买一只河狸毛绒玩具，并且已经完成了结账流程中的配送地址步骤，这时你发现自己在街道地址中打了个错别字。你跳回到配送地址表单并纠正了这个错误。现在，你可以再次使用
    `POST` 提交表单并将所有内容发送到服务器。但 `PATCH` 请求会更高效，因为你只做了一个小修正。你很可能会在 API 中遇到 `PATCH` 方法，而不是在
    HTML 表单中。'
- en: '`DELETE` The `DELETE` method instructs the server to remove the target resource.
    Let’s say your comment on the news story was too controversial, and now your neighbors
    avoid making eye contact with you. You can make a `DELETE` request to the server
    to remove your comment and restore your social status.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DELETE` `DELETE` 方法指示服务器删除目标资源。假设你在新闻故事中的评论太过争议性，现在邻居们避免和你进行眼神交流。你可以向服务器发送
    `DELETE` 请求，删除你的评论并恢复你的社交地位。'
- en: '`OPTIONS` You can ask the server what methods a target resource supports by
    using the `OPTIONS` method. For example, you could send an `OPTIONS` request with
    your news story comment as the target resource and learn that the `DELETE` method
    is not one of the methods the server will support for your comment, meaning your
    best option now is to find another place to live and meet new neighbors.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OPTIONS` 你可以使用 `OPTIONS` 方法向服务器询问目标资源支持哪些方法。例如，你可以发送一个 `OPTIONS` 请求，目标资源是你的新闻评论，结果得知
    `DELETE` 方法并不是服务器支持的操作，这意味着你现在最好的选择是另找地方住并结交新邻居。'
- en: '`CONNECT` The client uses `CONNECT` to request that the web server perform
    *HTTP tunneling,* or establish a TCP session with a target destination and proxy
    data between the client and the destination.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CONNECT` 客户端使用 `CONNECT` 请求 Web 服务器执行*HTTP 隧道*，或者与目标地址建立 TCP 会话并在客户端和目标之间代理数据。'
- en: '`TRACE` The `TRACE` method instructs the web server to echo the request back
    to you instead of processing it. This method allows you to see whether any intermediate
    nodes modify your request before it reaches the web server.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TRACE` `TRACE` 方法指示 Web 服务器将请求回显给你，而不是处理它。此方法允许你查看是否有任何中间节点在请求到达 Web 服务器之前修改了请求。'
- en: It’s important to mention that web servers are under no obligation to implement
    these request methods. In addition, you may find that some web servers don’t correctly
    implement them. Trust, but verify.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Web 服务器没有义务实现这些请求方法。此外，您可能会发现一些 Web 服务器未能正确实现它们。相信，但要验证。
- en: Server Responses
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器响应
- en: Whereas the client request always specifies a method and a target resource,
    the web server’s response always includes a status code to inform the client of
    the status of its request. A successful request results in a response containing
    a 200-class status code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 而客户端的请求始终指定一个方法和目标资源，Web 服务器的响应始终包括一个状态码，以通知客户端其请求的状态。成功的请求会导致响应中包含 200 类状态码。
- en: If the client makes a request that requires further action on the client’s part,
    the server will return a 300-class status code. For example, if the client requests
    a resource that has not changed since the client’s last request for the resource,
    the server may return a 304 status code to inform the client that it should instead
    render the resource from its cache.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端发出的请求需要客户端进一步操作，服务器将返回 300 类状态码。例如，如果客户端请求一个自上次请求以来没有变化的资源，服务器可能返回 304
    状态码，通知客户端应该从缓存中渲染该资源。
- en: If an error occurs because of the client’s request, the server will return a
    400-class status code in its response. The most common example of this scenario
    occurs when a client requests a nonexistent target resource, in which case the
    server responds with a 404 status code to inform the client that it could not
    find the resource.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于客户端的请求发生错误，服务器将在响应中返回 400 类状态码。此情形中最常见的例子是客户端请求一个不存在的目标资源，在这种情况下，服务器将返回
    404 状态码，通知客户端未能找到该资源。
- en: The 500-class status codes inform the client that an error has occurred on the
    server side that prevents the server from fulfilling the request. Let’s assume
    that your request requires the web server to retrieve assets from an upstream
    server to satisfy your request, but that the upstream server fails to respond.
    The web server will respond to you with a 504 status code indicating that a time-out
    occurred during the communication with its upstream server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 500 类状态码通知客户端服务器端发生了错误，导致服务器无法完成请求。假设您的请求需要 Web 服务器从上游服务器获取资源以满足请求，但上游服务器未能响应。Web
    服务器将返回 504 状态码，表示在与上游服务器的通信过程中发生了超时。
- en: A handful of 100-class status codes exist in HTTP/1.1 to give direction to the
    client. For example, the client can ask for guidance from the server while sending
    a `POST` request. To do so, the client would send the `POST` method, target resource,
    and request headers to the server, one of which tells the server that the client
    wants permission to proceed sending the request body. The server can respond with
    a 100 status code indicating that the client can continue the request and send
    the body.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP/1.1 中存在一些 100 类状态码，用于给客户端提供指示。例如，客户端在发送 `POST` 请求时可以向服务器请求指导。为此，客户端将发送
    `POST` 方法、目标资源和请求头到服务器，其中之一告诉服务器客户端希望获得继续发送请求体的许可。服务器可以返回 100 状态码，表示客户端可以继续请求并发送请求体。
- en: The IANA maintains the official list of HTTP status codes, which you can find
    at [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml).
    If you encounter a relatively obscure status code, you can typically find a description
    of it in RFC 7231 at [https://tools.ietf.org/html/rfc7231#section-6](https://tools.ietf.org/html/rfc7231#section-6).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: IANA 维护着 HTTP 状态码的官方列表，您可以在[https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml)找到它。如果您遇到一个相对不常见的状态码，通常可以在
    RFC 7231 的[https://tools.ietf.org/html/rfc7231#section-6](https://tools.ietf.org/html/rfc7231#section-6)中找到对其的描述。
- en: 'Go defines many of these status codes as constants in its `net/http` package,
    and I suggest you use the constants in your code. It’s much easier to read `http.StatusOK`
    than it is to remember what 200 means. The most common HTTP status codes you’ll
    encounter include the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Go 定义了许多这样的状态码作为常量在其 `net/http` 包中，我建议您在代码中使用这些常量。读取 `http.StatusOK` 比记住 200
    的含义要容易得多。您将遇到的最常见的 HTTP 状态码包括以下内容：
- en: '`200 OK` Indicates a successful request. If the request method was `GET`, the
    response body contains the target resource.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`200 OK` 表示请求成功。如果请求方法是 `GET`，响应体包含目标资源。'
- en: '`201 Created` Returned when the server has successfully processed a request
    and added a new resource, as may be the case with a `POST` request.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`201 Created` 当服务器成功处理请求并添加了一个新资源时返回，通常是在 `POST` 请求的情况下。'
- en: '`202 Accepted` Often returned if the request was successful but the server
    hasn’t yet created a new resource. The creation of the resource may still fail
    despite the successful request.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`202 Accepted` 如果请求成功，但服务器尚未创建新资源时，通常会返回此状态码。尽管请求成功，资源的创建仍可能失败。'
- en: '`204 No Content` Often returned if the request was successful but the response
    body is empty.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`204 No Content` 如果请求成功但响应体为空，通常会返回此状态码。'
- en: '`304 Not Modified` Returned when a client requests an unchanged resource. The
    client should instead use its cached copy of the resource. One method of caching
    is using an entity tag (ETag) header. When a client requests a resource from the
    server, the response may include an optional server-derived ETag header, which
    has meaning to the server. If the client requests the same resource in the future,
    the client can pass along the cached ETag header and value in its request. The
    server will check the ETag value in the client’s request to determine whether
    the requested resource has changed. If it is unchanged, the server will likely
    respond with a 304 status code and an empty response body.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`304 Not Modified` 当客户端请求一个未更改的资源时返回。客户端应该使用其缓存的资源副本。一种缓存方法是使用实体标签（ETag）头部。当客户端向服务器请求资源时，响应中可能会包含一个可选的服务器派生的ETag头部，它对服务器有意义。如果客户端在未来再次请求相同的资源，可以将缓存的ETag头部及其值传递到请求中。服务器将检查客户端请求中的ETag值，以确定请求的资源是否已更改。如果未更改，服务器可能会返回304状态码和空的响应体。'
- en: '`400 Bad Request` Returned if the server outright rejects the client’s request
    for some reason. This may be due to a malformed request, like one that includes
    a request method but no target resource.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`400 Bad Request` 如果服务器因某种原因直接拒绝客户端的请求，则返回此状态码。这可能是由于请求格式不正确，例如请求方法中没有指定目标资源。'
- en: '`403 Forbidden` Often returned if the server accepts your request but determines
    you do not have permission to access the resource, or if the server itself does
    not have permission to access the requested resource.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`403 Forbidden` 如果服务器接受了你的请求，但确定你没有权限访问该资源，或者服务器本身没有权限访问请求的资源时，通常会返回此状态码。'
- en: '`404 Not Found` Returned if you request a nonexistent resource. You may also
    find this status code used as a *Glomar response* when a server does not want
    to confirm or deny your permission to access a resource. In other words, a web
    server may respond with a 404 status code for a resource you do not have permission
    to access instead of explicitly responding with a 403 status code confirming your
    lack of permissions to the resource. Attackers attempting to access sensitive
    resources on your web server would want to focus their efforts only on existing
    resources, even if they currently lack permissions to access those resources.
    Returning a 404 status code for both nonexistent and forbidden resources prevents
    attackers from differentiating between the two, providing a measure of security.
    The downside to this approach is you’ll have a harder time debugging your permissions
    on your server, because you won’t know whether the resource you’re requesting
    exists or you simply lack permissions. I suggest you articulate the difference
    in your server logs.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`404 Not Found` 如果你请求一个不存在的资源，服务器会返回此状态码。你也可能看到此状态码作为 *Glomar响应*，当服务器不想确认或否认你是否有权限访问某个资源时。换句话说，网络服务器可能会对你没有权限访问的资源返回404状态码，而不是明确地返回403状态码确认你没有访问权限。试图访问你网络服务器上敏感资源的攻击者希望将精力集中在现有资源上，即使他们当前没有访问这些资源的权限。返回404状态码对于不存在和被禁止的资源来说是一种安全措施，防止攻击者区分这两者。这样做的缺点是，你更难调试服务器上的权限问题，因为你无法知道你请求的资源是否存在，或者你只是缺乏权限。我建议你在服务器日志中明确区分这两者。'
- en: '`405 Method Not Allowed` Returned if you specify a request method for a target
    resource that the server does not support. Remember the controversial comment
    you attempted to delete in our discussion of the `OPTIONS` request method? You
    would receive a 405 status code in response to that `DELETE` request.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`405 Method Not Allowed` 如果你为目标资源指定了服务器不支持的请求方法，则返回此状态码。还记得你在我们讨论 `OPTIONS`
    请求方法时试图删除的有争议评论吗？你会收到405状态码作为对该 `DELETE` 请求的响应。'
- en: '`426 Upgrade Required` Returned to instruct the client to first upgrade to
    TLS before requesting the target resource.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`426 升级要求` 返回此代码是为了指示客户端在请求目标资源之前，必须首先升级到TLS。'
- en: '`500 Internal Server Error` A catchall code of sorts returned when an error
    occurs on the server that prevents it from satisfying the client’s request but
    that doesn’t match the criteria of any other status code. Servers have returned
    many a 500 error because of some sort of configuration error or syntax error in
    server-side code. If your server returns this code, check your logs.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`500 服务器内部错误` 是一种通用的错误代码，当服务器发生错误，无法满足客户端的请求，但该错误不符合其他状态码的标准时，服务器会返回此错误代码。由于服务器端代码中的配置错误或语法错误，服务器经常返回500错误。如果你的服务器返回此代码，请检查日志。'
- en: '`502 Bad Gateway` Returned when the server proxies data between the client
    and an upstream service, but the upstream service is unavailable and not accepting
    requests.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`502 错误网关` 当服务器在客户端与上游服务之间代理数据时，如果上游服务不可用且不接受请求，服务器将返回此错误。'
- en: '`503 Service Unavailable` Returned if a web server is unavailable to accept
    a request. For example, a web server may return a 503 status code for all incoming
    connections when it’s put into maintenance mode.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`503 服务不可用` 如果网络服务器无法接受请求，则会返回此代码。例如，当网络服务器进入维护模式时，它可能会为所有传入连接返回503状态码。'
- en: '`504 Gateway Timeout` Returned by a proxy web server to indicate that the upstream
    service accepted the request but did not provide a timely reply.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`504 网关超时` 由代理服务器返回，表示上游服务已接受请求，但未能及时提供回复。'
- en: From Request to Rendered Page
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从请求到渲染页面
- en: A web page is often composed of various resources, such as images, videos, layout
    instructions for your web browser, third-party ads, and so on. Accessing each
    resource requires a separate request to the server. In HTTP version 1.0 (HTTP/1.0),
    clients must initiate a separate TCP connection for each request. HTTP/1.1 eliminates
    this requirement, reducing the latency and request-connection overhead associated
    with multiple HTTP requests to the same web server. Instead, it allows multiple
    requests and responses over the same TCP connection. (All contemporary web server
    software and web browsers support HTTP/1.1 at a minimum, so you’re unlikely to
    use HTTP/1.0 at all.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网页通常由各种资源组成，如图像、视频、网页浏览器的布局指令、第三方广告等。访问每个资源需要向服务器发起单独的请求。在HTTP 1.0（HTTP/1.0）版本中，客户端必须为每个请求单独发起TCP连接。HTTP/1.1消除了这一要求，减少了与多个HTTP请求同一服务器的请求-连接开销和延迟。相反，它允许通过同一个TCP连接发送多个请求和响应。（所有现代的Web服务器软件和网页浏览器至少支持HTTP/1.1，因此你不太可能使用HTTP/1.0。）
- en: '[Table 8-1](#table8-1) demonstrates the retrieval of an HTML document and the
    subsequent `GET` calls of all resources specified in that document.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[表8-1](#table8-1)演示了检索HTML文档以及随后对该文档中所有指定资源的`GET`调用。'
- en: 'Table 8-1: Retrieving Additional Resources After Requesting the Index HTML
    Document'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1：请求索引HTML文档后检索附加资源
- en: '| Status | Method | Domain | Resource | Type | Bytes transferred | Duration
    of transfer |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 方法 | 域名 | 资源 | 类型 | 传输字节 | 传输时长 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 200 | GET | *woodbeck.net* | */* | HTML | 1.83KB | 49 ms |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 200 | GET | *woodbeck.net* | */* | HTML | 1.83KB | 49毫秒 |'
- en: '| 200 | GET | *woodbeck.net* | *main.min.css* | CSS | 1.30KB | 20 ms |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 200 | GET | *woodbeck.net* | *main.min.css* | CSS | 1.30KB | 20毫秒 |'
- en: '| 200 | GET | *woodbeck.net* | *code.css* | CSS | 0.99KB | 20 ms |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 200 | GET | *woodbeck.net* | *code.css* | CSS | 0.99KB | 20毫秒 |'
- en: '| 304 | GET | *woodbeck.net* | *avatar.jpeg* | JPEG | 0 bytes | 0 ms |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 304 | GET | *woodbeck.net* | *avatar.jpeg* | JPEG | 0字节 | 0毫秒 |'
- en: '| 404 | GET | *woodbeck.net* | *favicon.ico* | IMG | 0 bytes | 0 ms |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 404 | GET | *woodbeck.net* | *favicon.ico* | IMG | 0字节 | 0毫秒 |'
- en: The initial `GET` request for [https://woodbeck.net/](https://woodbeck.net/)
    successfully retrieved the HTML document specified by the default resource. This
    HTML document included links to additional resources necessary to properly render
    the page, so the web browser requested those too. Since this transfer used HTTP/1.1,
    the web browser used the same TCP connection to retrieve the remaining resources.
    The web server instructed the web browser to use its cached copy of *avatar.jpeg*,
    since that resource hadn’t changed since the last time the web browser received
    it. The web server was unable to find the *favicon.ico* file, so it returned a
    404 status code to the web browser.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对 [https://woodbeck.net/](https://woodbeck.net/) 的初始 `GET` 请求成功地检索了由默认资源指定的
    HTML 文档。这个 HTML 文档包含了渲染页面所需的附加资源的链接，因此 web 浏览器也请求了这些资源。由于这次传输使用了 HTTP/1.1，web
    浏览器使用相同的 TCP 连接来检索剩余的资源。由于该资源自上次 web 浏览器接收以来没有变化，web 服务器指示浏览器使用其缓存的 *avatar.jpeg*
    副本。由于 web 服务器未能找到 *favicon.ico* 文件，因此返回了 404 状态码给浏览器。
- en: The latest version of HTTP, HTTP/2, aims to further reduce latency. In addition
    to reusing the same TCP connection for subsequent requests, the HTTP/2 server
    can proactively push resources to the client. If the conversation in [Table 8-1](#table8-1)
    occurred over HTTP/2, it may have transpired like this. The client requested the
    default resource. The server responded with the default resource. But since the
    server knew that the default resource had dependent resources, it *pushed* those
    resources to the client without the client’s needing to make separate requests
    for each resource.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 的最新版本 HTTP/2 旨在进一步减少延迟。除了对后续请求重用相同的 TCP 连接外，HTTP/2 服务器还可以主动将资源推送到客户端。如果
    [表 8-1](#table8-1) 中的对话是通过 HTTP/2 进行的，它可能是这样发生的。客户端请求了默认资源，服务器响应了默认资源。但由于服务器知道默认资源有依赖的资源，它*推送*这些资源到客户端，而无需客户端为每个资源单独发起请求。
- en: The Go HTTP client and server transparently support HTTP/1.0, HTTP/1.1, and
    HTTP/2, meaning that you can write your code to retrieve and serve resources while
    letting code in Go’s `net/http` package negotiate the optimal HTTP version. However,
    while the Go HTTP/2 server implementation can push resources to clients, the Go
    HTTP/2 client implementation cannot yet consume those server pushes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 HTTP 客户端和服务器透明地支持 HTTP/1.0、HTTP/1.1 和 HTTP/2，这意味着你可以编写代码来检索和提供资源，同时让 Go
    的 `net/http` 包中的代码来协商最佳的 HTTP 版本。然而，尽管 Go 的 HTTP/2 服务器实现可以将资源推送到客户端，但 Go 的 HTTP/2
    客户端实现目前还无法接收这些服务器推送。
- en: Retrieving Web Resources in Go
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Go 中检索 Web 资源
- en: Just like your web browser, Go can communicate with web servers by using the
    `net/http` package’s HTTP client. Unlike your web browser, Go won’t directly render
    an HTML page to your screen. Instead, you could use Go to scrape data from websites
    (such as financial stock details), submit form data, or interact with APIs that
    use HTTP for their application protocol, to name a few examples.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你的 web 浏览器一样，Go 可以使用 `net/http` 包的 HTTP 客户端与 web 服务器进行通信。与 web 浏览器不同，Go 不会直接将
    HTML 页面渲染到屏幕上。相反，你可以使用 Go 来从网站抓取数据（如财务股票详情）、提交表单数据，或与使用 HTTP 作为应用协议的 API 进行交互，举几个例子。
- en: Despite the simplicity of making HTTP requests in Go, you’ll have to handle
    some client-side pitfalls. You’ll learn about these pitfalls shortly. First, let’s
    look at a simple example request.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Go 中发起 HTTP 请求很简单，但你需要处理一些客户端的陷阱。你将在接下来的内容中学习这些陷阱。首先，让我们看一个简单的示例请求。
- en: Using Go’s Default HTTP Client
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Go 的默认 HTTP 客户端
- en: The `net/http` package includes a default client that allows you to make one-off
    HTTP requests. For example, you can use the `http.Get` function to send a `GET`
    request to a given URL.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http` 包包括一个默认客户端，允许你发起一次性的 HTTP 请求。例如，你可以使用 `http.Get` 函数向指定的 URL 发送 `GET`
    请求。'
- en: '[Listing 8-2](#listing8-2) demonstrates one way you can retrieve the current
    time from a trusted authority—*time.gov*’s web server—and compare it with the
    local time on your computer. This will give you a rough idea of how far ahead
    or behind the local time is on your computer. You certainly wouldn’t want to rely
    on this method for any sort of forensics, but the example serves to demonstrate
    the Go HTTP client workflow by using a `HEAD` request and response.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-2](#listing8-2) 演示了你可以从受信任的机构 —— *time.gov* 的 web 服务器检索当前时间，并与计算机本地时间进行比较的一种方式。这将让你大致了解计算机本地时间的提前或滞后情况。你当然不想依赖这种方法来进行任何形式的取证，但这个示例用来展示通过
    `HEAD` 请求和响应来演示 Go HTTP 客户端工作流。'
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 8-2: Retrieving a timestamp from *time.gov* (*time_test.go*)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-2：从 *time.gov* 获取时间戳（*time_test.go*）
- en: The `net/http` package includes a few helper functions to make `GET`, `HEAD`,
    or `POST` requests. Here, we use the `http.Get` function 1 to [https://www.time.gov/](https://www.time.gov/)
    to retrieve the default resource. Go’s HTTP client automatically upgrades to HTTPS
    for you because that’s the protocol indicated by the URL’s scheme. Although you
    don’t read the contents of the response body, you must close it 2. The next section
    covers why you need to close the response body in every case.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http` 包包含一些辅助函数，用于发起 `GET`、`HEAD` 或 `POST` 请求。在这里，我们使用 `http.Get` 函数 1
    来访问 [https://www.time.gov/](https://www.time.gov/) 以获取默认资源。Go 的 HTTP 客户端会自动为你升级到
    HTTPS，因为这是 URL 协议中指明的协议。虽然你没有读取响应体的内容，但你必须关闭它 2。下一节将讨论为何在每种情况下都需要关闭响应体。'
- en: Now that you have a response, you retrieve the `Date` header 3, which indicates
    the time at which the server created the response. You can then use this value
    to calculate the clock skew of your computer. Granted, you lose accuracy because
    of latency between the server’s generating the header and your code’s processing
    it, as well as the lack of nanosecond resolution of the `Date` header itself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了响应，你可以获取 `Date` 头部 3，这个头部指示了服务器生成响应的时间。你可以使用这个值来计算你计算机的时钟偏差。当然，由于服务器生成头部和你的代码处理它之间存在延迟，并且
    `Date` 头部本身缺乏纳秒级的精度，你会失去一些准确性。
- en: Closing the Response Body
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭响应体
- en: As mentioned earlier, HTTP/1.1 allows the client to maintain a TCP connection
    with a server for multiple HTTP requests (we call this *keepalive support*). Even
    so, the client cannot reuse a TCP session when unread bytes from the previous
    response remain on the wire. Go’s HTTP client automatically drains the response
    body when you close it. This allows your code to reuse the underlying TCP session
    if you are diligent about closing every response body.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，HTTP/1.1 允许客户端与服务器保持一个 TCP 连接，进行多个 HTTP 请求（我们称之为 *keepalive 支持*）。即便如此，当先前响应中的未读取字节仍然在网络上时，客户端无法重用
    TCP 会话。Go 的 HTTP 客户端在你关闭响应体时会自动清空响应体，这使得你的代码可以重用底层的 TCP 会话，只要你始终如一地关闭每一个响应体。
- en: Let’s revisit the response from [Listing 8-1](#listing8-1) to see how Go parses
    the response ([Listing 8-3](#listing8-3)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下来自[示例 8-1](#listing8-1)的响应，看看 Go 是如何解析响应的（[示例 8-3](#listing8-3)）。
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-3: Parsing the HTTP response'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-3：解析 HTTP 响应
- en: Go’s HTTP client reads the response status and headers 1 from the network socket,
    and this data immediately becomes available to your code as part of the response
    object. The client doesn’t automatically read the response body, however 2. The
    body remains unconsumed until your code explicitly reads it or until you close
    it and Go implicitly drains any unread bytes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 HTTP 客户端会从网络套接字中读取响应的状态和头部 1，这些数据会立即作为响应对象的一部分提供给你的代码。然而，客户端并不会自动读取响应体
    2。直到你显式地读取它，或者直到你关闭它并且 Go 隐式地清空所有未读取的字节，响应体才会被处理。
- en: The Go HTTP client’s implicit draining of the response body on closing could
    potentially bite you. For example, let’s assume you send a `GET` request for a
    file and receive a response from the server. You read the response’s `Content-Length`
    header and realize the file is much larger than you anticipated. If you close
    the response body without reading any of its bytes, Go will download the entire
    file from the server as it drains the body regardless.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go HTTP 客户端在关闭时隐式地清空响应体，这可能会对你造成困扰。例如，假设你发送了一个 `GET` 请求请求一个文件，并且收到了来自服务器的响应。你读取了响应中的
    `Content-Length` 头部，发现文件比你预期的要大得多。如果你在没有读取任何字节的情况下关闭响应体，Go 会在清空响应体时从服务器下载整个文件。
- en: A better alternative would be to send a `HEAD` request to retrieve the `Content-Length`
    header. This way, no unread bytes exist in the response body, so closing the response
    body will not incur any additional overhead while draining it. You properly closed
    the response body in [Listing 8-2](#listing8-2), so the Go HTTP client could reuse
    the TCP session if you made additional calls in the future.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的替代方法是发送一个 `HEAD` 请求来获取 `Content-Length` 头部。这样，响应体中就不会有未读取的字节，因此关闭响应体时不会产生任何额外的开销。你在[示例
    8-2](#listing8-2)中已正确关闭了响应体，因此如果以后你发出更多请求，Go 的 HTTP 客户端可以重用 TCP 会话。
- en: 'On the rare occasion that you make an HTTP request and want to explicitly drain
    the response body, the most efficient way is to use the `io.Copy` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果你进行 HTTP 请求并且希望显式地清空响应体，最有效的方法是使用 `io.Copy` 函数：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `io.Copy` function drains the `response.Body` by reading all bytes from
    it and writing those bytes to `ioutil.Discard`. As its name indicates, `ioutil.Discard`
    is a special `io.Writer` that discards all bytes written to it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Copy` 函数通过从 `response.Body` 中读取所有字节并将这些字节写入 `ioutil.Discard` 来清空 `response.Body`。顾名思义，`ioutil.Discard`
    是一个特殊的 `io.Writer`，会丢弃所有写入它的字节。'
- en: You do not have to ignore the return values of `io.Copy` and `response.Close`,
    but doing so lets other developers know you intentionally ignored these values.
    Some developers may regard this as unnecessary verbosity, and it’s true that `io.Copy`
    or `response.Close` will rarely return errors in this context, but it’s still
    a good practice. I’ve encountered code that implicitly ignores errors, presumably
    out of habit, when the developer should have otherwise handled the errors.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必忽略 `io.Copy` 和 `response.Close` 的返回值，但这样做可以让其他开发人员知道你故意忽略了这些值。一些开发人员可能会认为这是多余的冗长，的确，在这种情况下，`io.Copy`
    或 `response.Close` 很少会返回错误，但这仍然是一个好习惯。我曾遇到过代码在隐式忽略错误，可能是出于习惯，而开发人员本应处理这些错误。
- en: The bottom line is that you must close the response body no matter whether you
    read it or not, to avoid resource leaks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，无论是否读取响应体，都必须关闭它，以避免资源泄漏。
- en: Implementing Time-outs and Cancellations
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现超时和取消
- en: 'Go’s default HTTP client and the requests created with the `http.Get`, `http.Head`,
    and `http.Post` helper functions do not time out. The consequences of this may
    not be obvious until you get bit by the following fact (after which you’ll never
    forget it): the lack of a time-out or deadline means that a misbehaving or malicious
    service could cause your code to block indefinitely without producing an error
    to indicate that anything’s wrong. You might not find out that your service is
    malfunctioning until users start calling you to complain.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的默认 HTTP 客户端以及通过 `http.Get`、`http.Head` 和 `http.Post` 辅助函数创建的请求不会超时。这个问题的后果可能不会立刻显现，直到你遇到以下事实（从此你将永远记住）：没有超时或截止日期意味着一个表现不正常或恶意的服务可能会导致你的代码无限期阻塞，并且不会产生错误来表明出了问题。你可能直到用户开始投诉时才会发现你的服务出了问题。
- en: For example, [Listing 8-4](#listing8-4) demonstrates a simple test that causes
    the HTTP client to block indefinitely.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[示例 8-4](#listing8-4) 展示了一个简单的测试，导致 HTTP 客户端无限期阻塞。
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-4: The test server causes the default HTTP client to block indefinitely
    (*block_test.go*).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-4：测试服务器使默认的 HTTP 客户端无限期阻塞 (*block_test.go*)。
- en: The `net/http/httptest` package includes a useful HTTP test server. The `httptest.NewServer`1
    function accepts an `http.HandlerFunc`2, which in turn wraps the `blockIndefinitely`
    function 3. The test server passes any request it receives at its URL 4 to the
    `http.HandlerFunc`’s `ServeHTTP` method. This method sends the request and response
    objects to the `blockIndefinitely` function, where control blocks indefinitely.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http/httptest` 包包含一个有用的 HTTP 测试服务器。`httptest.NewServer`1 函数接受一个 `http.HandlerFunc`2，后者又包装了
    `blockIndefinitely` 函数3。测试服务器将它接收到的任何请求通过其 URL 4 传递给 `http.HandlerFunc` 的 `ServeHTTP`
    方法。该方法将请求和响应对象传递给 `blockIndefinitely` 函数，在该函数中控制将无限期阻塞。'
- en: Because the helper function `http.Get` uses the default HTTP client, this `GET`
    request won’t time out. Instead, the `go test` runner will eventually time out
    and halt the test, printing the stack trace.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因为辅助函数 `http.Get` 使用默认的 HTTP 客户端，所以这个 `GET` 请求不会超时。相反，`go test` 运行器最终会超时并停止测试，打印堆栈跟踪。
- en: To solve this issue, production code should use the technique you learned for
    timing out network sockets in “Using a Context with a Deadline to Time Out a Connection”
    on page 57. Create a context and use it to initialize a new request. You can then
    manually cancel the request by either using the context’s `cancel` function or
    creating a context with a deadline or time-out.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，生产代码应该使用你在第 57 页“使用带有截止日期的上下文来超时连接”中学到的技术。创建一个上下文，并用它初始化一个新的请求。然后，你可以通过使用上下文的
    `cancel` 函数，或者创建一个带有截止日期或超时的上下文，手动取消该请求。
- en: Let’s fix the test in [Listing 8-4](#listing8-4) by replacing it with the test
    in [Listing 8-5](#listing8-5). The new test will time out the request after five
    seconds without an answer from the server.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将 [示例 8-4](#listing8-4) 中的测试替换为 [示例 8-5](#listing8-5) 来修复测试。新的测试将在五秒钟内没有收到服务器响应时超时。
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 8-5: Adding a time-out to the GET request (*block_test.go*)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-5：为 GET 请求添加超时 (*block_test.go*)
- en: First, you create a new request 1 by passing in the context, the request method,
    the URL, and a `nil` request body, since your request does not have a payload.
    Keep in mind that the context’s timer starts running as soon as you initialize
    the context. The context controls the entire life cycle of the request. In other
    words, the client has five seconds to connect to the web server, send the request,
    read the response headers, and pass the response to your code. You then have the
    remainder of the five seconds to read the response body. If you are in the middle
    of reading the response body when the context times out, your next read will immediately
    return an error. So, use generous time-out values for your specific application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你通过传入上下文、请求方法、URL 和一个 `nil` 请求体来创建一个新的请求 1，因为你的请求没有负载。请记住，上下文的计时器在你初始化上下文时就开始运行。上下文控制着请求的整个生命周期。换句话说，客户端有五秒钟的时间连接到
    Web 服务器，发送请求，读取响应头，并将响应传递给你的代码。接下来，你有剩余的五秒钟时间来读取响应体。如果你正在读取响应体时上下文超时，你的下一个读取操作会立即返回错误。因此，请为你的特定应用程序使用宽松的超时值。
- en: 'Alternatively, create a context without a time-out or deadline and control
    the cancellation of the context exclusively by using a timer and the context’s
    `cancel` function, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，创建一个没有超时或截止时间的上下文，并仅通过使用计时器和上下文的 `cancel` 函数来控制上下文的取消，如下所示：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This snippet demonstrates how to use a timer that will call the context’s `cancel`
    function 1 after it expires. You can reset the timer as needed to push the call
    to `cancel` further into the future.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了如何使用一个计时器，该计时器将在超时后调用上下文的 `cancel` 函数 1。你可以根据需要重置计时器，将 `cancel` 调用推迟到更远的未来。
- en: Disabling Persistent TCP Connections
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用持久化 TCP 连接
- en: By default, Go’s HTTP client maintains the underlying TCP connection to a web
    server after reading its response unless explicitly told to disconnect by the
    server. Although this is desirable behavior for most use cases because it allows
    you to use the same TCP connection for multiple requests, you may inadvertently
    deny your computer the ability to open new TCP connections with other web servers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Go 的 HTTP 客户端在读取完响应后会保持与 Web 服务器的底层 TCP 连接，除非服务器明确要求断开连接。虽然这在大多数使用场景中是期望的行为，因为它允许你在多个请求中复用同一个
    TCP 连接，但你可能会不小心让计算机无法与其他 Web 服务器建立新的 TCP 连接。
- en: This is because the number of active TCP connections a computer can maintain
    is finite. If you write a program that makes one-off requests to numerous web
    servers, you could find that your program stops working after exhausting all your
    computer’s available TCP connections, leaving it unable to open new ones. In this
    scenario, TCP session reuse can work against you. Instead of disabling TCP session
    reuse in the client, a more flexible option is to inform the client what to do
    with the TCP socket on a per-request basis.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为计算机能够保持的活动 TCP 连接数是有限的。如果你编写了一个向多个 Web 服务器发送一次性请求的程序，你可能会发现，当所有计算机的 TCP
    连接耗尽后，程序停止工作，无法打开新的连接。在这种情况下，TCP 会话重用可能会对你不利。与其在客户端禁用 TCP 会话重用，不如更灵活的做法是按请求告知客户端如何处理
    TCP 套接字。
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Setting the request’s `Close` field 1 to `true` tells Go’s HTTP client that
    it should close the underlying TCP connection after reading the web server’s response.
    If you know you’re going to send four requests to a web server and no more, you
    could set the `Close` field to `true` on the fourth request. All four requests
    will use the same TCP session, and the client will terminate the TCP connection
    after receiving the fourth response.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将请求的 `Close` 字段 1 设置为 `true` 告诉 Go 的 HTTP 客户端，在读取完 Web 服务器的响应后，它应该关闭底层的 TCP
    连接。如果你知道你将发送四个请求到 Web 服务器且不会再发送更多请求，你可以在第四个请求上将 `Close` 字段设置为 `true`。所有四个请求将使用同一个
    TCP 会话，并且客户端将在接收到第四个响应后终止 TCP 连接。
- en: Posting Data over HTTP
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 HTTP 发送数据
- en: Sending a `POST` request and its payload to a web server is like the calls you’ve
    made thus far. The difference, of course, is that the request body contains a
    payload. This payload can be any object that implements the `io.Reader` interface,
    including a file handle, standard input, an HTTP response body, or a Unix domain
    socket, to name a few. But as you’ll see, sending data to the web server involves
    a little more code than a `GET` request because you must prepare that request
    body.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 发送`POST`请求及其负载到Web服务器，就像你之前发出的请求一样。不同之处在于，请求体包含负载。这个负载可以是任何实现了`io.Reader`接口的对象，包括文件句柄、标准输入、HTTP响应体或Unix域套接字等。但正如你将看到的，向Web服务器发送数据涉及比`GET`请求更多的代码，因为你必须准备请求体。
- en: Posting JSON to a Web Server
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向Web服务器发布JSON
- en: Before you can send data to a test server, you need to create a handler that
    can accept it. [Listing 8-6](#listing8-6) creates a new type named `User` that
    you will encode to JavaScript Object Notation (JSON) and post to the handler.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能向测试服务器发送数据之前，你需要创建一个能够接收数据的处理器。[列表 8-6](#listing8-6) 创建了一个名为`User`的新类型，你将其编码为
    JavaScript 对象表示法（JSON）并发布到该处理器。
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 8-6: A handler that can decode JSON into a User object (*post_test.go*)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-6：一个可以将JSON解码为`User`对象的处理器（*post_test.go*）
- en: The `handlePostUser` function 1 returns a function that will handle `POST` requests.
    If the request method is anything other than `POST`3, it returns a status code
    indicating that the server disallows the method 4. The function then attempts
    to decode the JSON in the request body to a `User` object. If successful, the
    response’s status is set to *Accepted*5.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlePostUser`函数1返回一个处理`POST`请求的函数。如果请求方法是除`POST`外的其他任何方法3，它将返回一个状态码，表示服务器不允许该方法4。该函数然后尝试将请求体中的JSON解码为`User`对象。如果解码成功，响应的状态将设置为*Accepted*5。'
- en: Unlike the Go HTTP client, the Go HTTP server must explicitly drain the request
    body 2 before closing it. We’ll discuss this in more detail in Chapter 9.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与Go HTTP客户端不同，Go HTTP服务器必须显式地在关闭请求体之前先排空它2。我们将在第9章中详细讨论这个问题。
- en: The test in [Listing 8-7](#listing8-7) encodes a `User` object into JSON and
    sends it in a `POST` request to the test server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-7](#listing8-7)中的测试将`User`对象编码为JSON并通过`POST`请求发送到测试服务器。'
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-7: Encoding a User object to `JSON` and POST to the test server (*post_test.go*)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-7：将`User`对象编码为`JSON`并发布到测试服务器（*post_test.go*）
- en: The test first makes sure that the test server’s handler properly responds with
    an error if the client sends the wrong type of request 1. If the test server receives
    anything other than a `POST` request, it will respond with a Method Not Allowed
    error. Then, the test encodes a `User` object into JSON and writes the data to
    a bytes buffer 2. It makes a `POST` request to the test server’s URL with the
    content type *application/json* because the bytes buffer, representing the request
    body, contains JSON 3. The content type informs the server’s handler about the
    type of data to expect in the request body. If the server’s handler properly decoded
    the request body, the response status code is 202 Accepted 4.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 测试首先确保如果客户端发送错误类型的请求1，测试服务器的处理器能正确响应错误。如果测试服务器收到非`POST`请求，它会响应方法不被允许错误。然后，测试会将`User`对象编码为JSON，并将数据写入字节缓冲区2。它向测试服务器的URL发送`POST`请求，并将内容类型设置为*application/json*，因为字节缓冲区（表示请求体）包含JSON3。内容类型告知服务器的处理器请求体中预计的数据类型。如果服务器的处理器正确解码了请求体，响应的状态码将是202
    Accepted4。
- en: Posting a Multipart Form with Attached Files
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布带有附件文件的Multipart表单
- en: 'Posting JSON to a web server is easy. Simply set the appropriate content type
    and send along the JSON payload in the request body. But how do you handle sending
    various bits of data to a web server in a single `POST` request? Answer: use the
    `mime/multipart` package.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 向Web服务器发布JSON很简单。只需设置适当的内容类型并将JSON负载放入请求体中。但如何在单个`POST`请求中向Web服务器发送多个数据块呢？答案是：使用`mime/multipart`包。
- en: The `mime/multipart` package allows you to craft multipart *Multipurpose Internet
    Mail Extensions (MIME) messages*, which separate each bit of data you want to
    send from the other bits of data by a string known as a *boundary*. You’ll see
    an example of a boundary a bit later in this section, though it isn’t something
    you typically need to worry about.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`mime/multipart`包允许你构建多部分*多用途互联网邮件扩展（MIME）消息*，通过一个称为*边界*的字符串将你想发送的每个数据块与其他数据块分开。稍后你将在本节中看到边界的示例，尽管这通常不是你需要担心的事情。'
- en: Each MIME part includes optional headers that describe the content, as well
    as a body that contains the content itself. For example, if a web server parsed
    a MIME part with a `Content-Type` header set to *text/plain*, it would treat the
    part’s body as plaintext.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MIME部分都包括描述内容的可选头部，以及包含实际内容的主体。例如，如果Web服务器解析了一个`Content-Type`头部设置为*text/plain*的MIME部分，它将把该部分的主体视为纯文本。
- en: '[Listing 8-8](#listing8-8) introduces a new test that walks you through the
    process of building up a multipart request body using the `mime/multipart` package.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-8](#listing8-8)介绍了一个新的测试，带领你通过使用`mime/multipart`包构建multipart请求体的过程。'
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 8-8: Creating a new request body, multipart writer, and write form
    data (*post_test.go*)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-8：创建一个新的请求体、multipart writer并写入表单数据（*post_test.go*）
- en: First, you create a new buffer 1 to act as the request body. You then create
    a new multipart writer 2 that wraps the buffer. The multipart writer generates
    a random boundary upon initialization. Finally, you write form fields to the multipart
    writer 3. The multipart writer separates each form field into its own part, writing
    the boundary, appropriate headers, and the form field value to each part’s body.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个新的缓冲区1作为请求体。然后你创建一个新的multipart writer 2，将其包装到缓冲区中。multipart writer在初始化时会生成一个随机的边界。最后，你将表单字段写入multipart
    writer 3。multipart writer将每个表单字段分隔到独立的部分中，并为每个部分的主体写入边界、适当的头部和表单字段值。
- en: At this point, your request body has two parts, one for the *date* form field
    and one for the *description* form field. Let’s attach a couple of files in [Listing
    8-9](#listing8-9).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，你的请求体有两个部分，一个是*date*表单字段，一个是*description*表单字段。接下来，让我们在[Listing 8-9](#listing8-9)中附加一些文件。
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 8-9: Writing two files to the request body, each in its own MIME part
    (*post_test.go*)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-9：将两个文件写入请求体，每个文件独立为一个MIME部分（*post_test.go*）
- en: Attaching a field to a request body isn’t as straightforward as adding form
    field data. You have an extra step. First, you need to create a multipart section
    writer from [Listing 8-8](#listing8-8)’s multipart writer 1. The `CreateFormField`
    method accepts a field name and a filename. The server uses this filename when
    parsing the MIME part. It does not need to match the filename you attach. Now,
    you just open the file and copy its contents to the MIME part writer 2.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将字段附加到请求体中并不像添加表单字段数据那样直接。你需要额外的步骤。首先，你需要从[Listing 8-8](#listing8-8)中的multipart
    writer 1创建一个multipart部分写入器。`CreateFormField`方法接受字段名和文件名。服务器在解析MIME部分时使用这个文件名，它不需要与附加的文件名匹配。现在，你只需打开文件并将其内容复制到MIME部分写入器2中。
- en: When you’re done adding parts to the request body, you must close the multipart
    writer 3, which finalizes the request body by appending the boundary.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成向请求体中添加各个部分后，必须关闭multipart writer 3，这将通过附加边界来最终确定请求体。
- en: '[Listing 8-10](#listing8-10) posts the request to a well-regarded test server,
    *httpbin.org*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-10](#listing8-10)将请求发布到一个知名的测试服务器*httpbin.org*。'
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 8-10: Sending a `POST` request to *httpbin.org* with Go’s default HTTP
    client (*post_test.go*)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-10：使用Go的默认HTTP客户端发送`POST`请求到*httpbin.org*（*post_test.go*）
- en: First, you create a new request and pass it a context that will time out in
    60 seconds. Since you’re making this call over the internet, you don’t have as
    much certainty that your request will reach its destination as you do when testing
    over localhost. The `POST` request is destined for [https://www.httpbin.org/](https://www.httpbin.org/)1
    and will send the multipart request body 2 in its payload.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个新的请求，并传递一个将在60秒后超时的上下文。由于你是通过互联网发起这个请求，所以不像在本地测试时那样有那么高的确定性，无法确保请求会顺利到达目标地址。这个`POST`请求的目标是[https://www.httpbin.org/](https://www.httpbin.org/)1，并将在其有效载荷中发送multipart请求体2。
- en: Before you send the request, you need to set the `Content-Type` header to inform
    the web server you’re sending multiple parts in this request. The multipart writer’s
    `FormDataContentType` method 3 returns the appropriate `Content-Type` value that
    includes its boundary. The web server uses the boundary from this header to determine
    where one part stops and another starts as it reads the request body.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送请求之前，你需要设置`Content-Type`头部，告知Web服务器你正在发送多个部分。multipart writer的`FormDataContentType`方法3返回适当的`Content-Type`值，其中包含边界。Web服务器使用这个头部中的边界来确定请求体的每一部分的起始和结束。
- en: Once you run the test with the `-v` flag, you should see output like the JSON
    in [Listing 8-11](#listing8-11).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用`-v`标志运行测试，你应该会看到像[Listing 8-11](#listing8-11)中的JSON输出。
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 8-11: Response body from the multipart `POST` request'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-11：multipart `POST`请求的响应体
- en: This is *httpbin.org*’s standard `POST` response and includes some fields irrelevant
    to the request you sent. But if you have a look, you’ll see the contents of each
    text file you attached 1 and the form fields you submitted 2. You can also see
    the `Content-Type` header 3 added by the multipart writer. Notice the boundary
    is a random string. With your code as is, the boundary will randomly change with
    each request. But you can set a boundary by using the multipart writer’s `SetBoundary`
    method if you so choose.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 *httpbin.org* 的标准 `POST` 响应，包含一些与你发送的请求无关的字段。但是，如果你查看，你会看到你附加的每个文本文件的内容 1
    和你提交的表单字段 2。你还可以看到 multipart 写入器添加的 `Content-Type` 头 3。请注意，边界是一个随机字符串。在你的代码中，每次请求时，边界都会随机变化。但如果你愿意，可以通过使用
    multipart 写入器的 `SetBoundary` 方法来设置一个边界。
- en: What You’ve Learned
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你所学到的内容
- en: HTTP allows clients to send requests to, and receive resources from, servers
    over the World Wide Web. This chapter showed you how to use Go to craft HTTP requests.
    Target resources can take the form of web pages, images, videos, documents, files,
    games, and so on. To retrieve a resource, the HTTP client sends a `GET` request
    with a URL to the web server. The web server uses the URL to locate the correct
    resource and send it along to the client in the server’s response. The client
    always initiates this HTTP request-response workflow.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 允许客户端向服务器发送请求，并从服务器接收资源，通过全球信息网进行通信。本章向你展示了如何使用 Go 构建 HTTP 请求。目标资源可以是网页、图片、视频、文档、文件、游戏等。为了检索资源，HTTP
    客户端向 Web 服务器发送带有 URL 的 `GET` 请求。Web 服务器使用该 URL 定位正确的资源，并将其发送到客户端的响应中。客户端始终发起这个
    HTTP 请求-响应流程。
- en: The client can send diverse types of resource requests to the server. The most
    used request methods are `GET`, `HEAD`, `POST`, `PUT`, and `DELETE`. A `GET` request
    asks the server to retrieve the specified resource. The client may send a `HEAD`
    request to retrieve the response headers without the requested payload. This can
    be useful for determining whether a resource exists and inspecting response headers
    before retrieving the resource. A `POST` request allows the client to send a resource
    to the server, whereas you typically use a `PUT` request to update an existing
    resource on the server. The client can request a resource’s deletion from the
    server by sending a `DELETE` request.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以向服务器发送多种类型的资源请求。最常用的请求方法有 `GET`、`HEAD`、`POST`、`PUT` 和 `DELETE`。`GET` 请求要求服务器检索指定的资源。客户端可以发送
    `HEAD` 请求，以获取响应头部，而不包含请求的负载。这对于确定资源是否存在，以及在检索资源之前检查响应头部非常有用。`POST` 请求允许客户端向服务器发送资源，而
    `PUT` 请求通常用于更新服务器上的现有资源。客户端可以通过发送 `DELETE` 请求来请求服务器删除某个资源。
- en: The `net/http` package provides all necessary types and functions to interact
    with servers over HTTP. It includes a default HTTP client that allows you to make
    a quick, one-off HTTP request and receive the response. However, you must diligently
    close the response body to prevent resource leaks, no matter whether you read
    the body’s contents or not. It’s also important to note that the default HTTP
    client and the requests sent using helper functions such as `http.Get`, `http.Head`,
    and `http.Post` do not time out. This means that a misbehaving or malicious service
    could cause your code to block indefinitely. Therefore, it’s important to manage
    request cancellation yourself by using a context.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http` 包提供了所有必要的类型和函数，以便通过 HTTP 与服务器进行交互。它包括一个默认的 HTTP 客户端，允许你快速发起一次性 HTTP
    请求并接收响应。然而，无论你是否读取响应体的内容，你都必须认真关闭响应体，以防止资源泄露。还要注意，默认的 HTTP 客户端以及通过 `http.Get`、`http.Head`
    和 `http.Post` 等助手函数发送的请求不会超时。这意味着，某个行为异常或恶意的服务可能会导致你的代码无限期阻塞。因此，重要的是通过使用上下文来自己管理请求的取消。'
- en: The `mime/multipart` package allows you to easily add multiple MIME parts to
    a request body. You can efficiently craft requests that upload files and form
    content to a web server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`mime/multipart` 包允许你轻松地向请求体中添加多个 MIME 部分。你可以高效地构建上传文件和表单内容到 Web 服务器的请求。'
