- en: '![](../images/pg347.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg347.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-35.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-35.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">POINTERS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">指针</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: So far, you’ve implemented only *arithmetic types*. These types have a lot in
    common; they all support the same basic mathematical operations, and you can always
    implicitly convert from one type to another. In the rest of [Part II](part2.xhtml),
    we’ll add several non-arithmetic types, like pointers, arrays, and structures.
    These types are quite different both from the arithmetic types and from each other.
    They don’t support ordinary arithmetic. Instead, each type supports its own distinct
    set of operations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只实现了*算术类型*。这些类型有很多共同之处；它们都支持相同的基本数学运算，而且你总是可以从一种类型隐式转换为另一种类型。在[第二部分](part2.xhtml)的其余部分，我们将添加几种非算术类型，如指针、数组和结构体。这些类型与算术类型以及彼此之间差别很大。它们不支持普通的算术运算。相反，每种类型支持自己独特的一组操作。
- en: 'In this chapter, you’ll implement *pointer types*, which represent memory addresses.
    You’ll also add two new operators for working with pointers: the address operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, and the dereference operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>. You’ll learn how to parse
    complex type specifiers and how to detect several new kinds of type errors. During
    TACKY and assembly generation, you’ll add a few new constructs to read from and
    write to locations in memory. You’ll continue to build on these changes as you
    add more non-arithmetic types in later chapters.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将实现*指针类型*，它们表示内存地址。你还将添加两个用于操作指针的新运算符：地址运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    和解引用运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>。你将学习如何解析复杂的类型说明符，并如何检测几种新的类型错误。在TACKY和汇编生成过程中，你将添加一些新结构来读取和写入内存中的位置。随着后续章节中更多非算术类型的加入，你将继续在这些更改的基础上构建。
- en: 'First, let’s discuss a few key concepts that I’ll refer to throughout this
    chapter: objects, values, and lvalue conversion.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一些在本章中会提到的关键概念：对象、值和左值转换。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Objects and Values</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">对象与值</samp>
- en: Objects and values have come up in earlier chapters, but I never precisely defined
    either term or explained how they differ from each other. You can think of a *value*
    as a sequence of bits with a type. For example, the bits
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和值在之前的章节中已经提到过，但我从未精确定义过这两个术语，也没有解释它们之间的区别。你可以将*值*理解为带有类型的位序列。例如，位
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: with the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> have
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>. So far, we’ve
    encountered only integer and floating-point values.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的变量，其值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>。到目前为止，我们只遇到过整数值和浮点值。
- en: An *object* is a location in memory that contains a value. Variables are the
    only objects we’ve seen so far. From the programmer’s perspective, every object
    has a memory address, which is fixed throughout its lifetime, and a value, which
    you can update using an assignment expression. (In practice, some objects may
    be stored in registers rather than memory, and you can’t update every object’s
    value, but we can ignore those exceptions for now.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象*是内存中的一个位置，存储着一个值。到目前为止，我们只见过变量是对象。从程序员的角度来看，每个对象都有一个内存地址，这个地址在其生命周期内是固定的，并且有一个值，你可以通过赋值表达式更新它。（在实践中，有些对象可能存储在寄存器中而非内存中，并且你不能更新每个对象的值，但我们暂时可以忽略这些例外情况。）'
- en: 'In [Chapter 5](chapter5.xhtml), I described an lvalue as an expression that
    can appear on the left side of an assignment expression. Now we can use the more
    precise definition from section 6.3.2.1, paragraph 1, of the C standard: “An lvalue
    is an expression … that potentially designates an object.” (Note that an lvalue
    is *not* a value, in spite of its name; it’s an expression.) Evaluating a non-lvalue
    expression produces a value. Evaluating an lvalue, on the other hand, “determin[es]
    the identity of the designated object,” according to section 5.1.2.3, paragraph
    2, of the standard. If an expression designates an object, you can assign to it.
    Otherwise, you can’t.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第5章](chapter5.xhtml)中，我将 lvalue 描述为可以出现在赋值表达式左侧的表达式。现在我们可以使用 C标准第6.3.2.1节，第1段中更精确的定义：“lvalue
    是一个… 可能表示一个对象的表达式。”（请注意，尽管名为 lvalue，它*并不是*一个值；它是一个表达式。）求值一个非 lvalue 表达式会产生一个值。而求值一个
    lvalue 则“确定指定对象的身份”，根据标准第5.1.2.3节第2段的定义。如果一个表达式表示一个对象，你可以对它进行赋值。否则，你不能。
- en: When you use an object in an expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    you’re actually using its current value. But when you assign to an object, you
    don’t care about its current value, which you’re just going to overwrite; you
    care about its location, which you’re trying to write to. In other words, if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    you sometimes treat it like a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and sometimes like a container where you can store a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    The C standard refers to the first case, where you use an object’s value in an
    expression, as *lvalue conversion*. This is a “conversion” in the sense that you’re
    converting an lvalue, which designates an object, into an ordinary value. If an
    lvalue appears as the left operand of an assignment expression or as the operand
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator, it doesn’t
    undergo lvalue conversion. If it appears anywhere else in an expression, it does.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is an lvalue
    in the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>, but it’s not an lvalue
    in the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(x)</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    In later chapters, we’ll encounter other expressions that aren’t lvalue converted.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在像 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 这样的表达式中使用一个对象时，你实际上是在使用它的当前值。但是当你给一个对象赋值时，你并不关心它的当前值，因为你只是要覆盖它；你关心的是它的位置，也就是你要写入的地方。换句话说，如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型的变量，你有时把它当作一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的值来处理，有时又把它当作一个可以存储
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型值的容器来处理。C标准将第一种情况，即在表达式中使用对象的值，称为
    *lvalue 转换*。这是一种“转换”，因为你将一个表示对象的 lvalue 转换为一个普通的值。如果一个 lvalue 出现在赋值表达式的左操作数位置，或作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 运算符的操作数，它不会经过 lvalue 转换。如果它出现在表达式的其他任何地方，它会经过
    lvalue 转换。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 在表达式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>
    中是一个 lvalue，但在表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(x)</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    中，它不是一个 lvalue。在后续章节中，我们会遇到其他没有经过 lvalue 转换的表达式。
- en: This terminology lets us talk about pointers without getting hopelessly confused.
    Now we can discuss precisely what operations pointers support.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语让我们能够在讨论指针时不至于感到困惑。现在我们可以准确地讨论指针支持哪些操作。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Operations on Pointers</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">指针操作</samp>
- en: In this section I’ll introduce the address operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>,
    which gets a pointer to an object, and the dereference operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    which you use to access an object through a pointer. I’ll also discuss casting
    and comparing pointers, plus one special case involving the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator. I won’t talk about pointer addition or subtraction yet; we’ll implement
    those in the next chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍地址运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>，它用于获取指向对象的指针，以及解引用运算符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>，通过指针访问对象。我还会讨论指针的类型转换和比较，以及涉及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 运算符的一个特殊情况。至于指针的加法和减法，我暂时不会讨论；我们将在下一章实现这些操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Address and Dereference
    Operations</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">地址和解引用操作</samp>
- en: To see how the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operations work, let’s walk through
    the program in [Listing 14-1](chapter14.xhtml#list14-1). We’ll pay special attention
    to which expressions in this program designate objects and which ones result in
    values.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    操作是如何工作的，我们来逐步分析 [Listing 14-1](chapter14.xhtml#list14-1) 中的程序。我们将特别关注程序中哪些表达式表示对象，哪些表达式结果是值。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: A simple program
    using</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">&</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">*</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operations</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1：一个简单的程序，使用</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">&</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">*</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">操作</samp>
- en: We start by declaring a variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is an object, it
    has an address, although that address won’t be the same every time you run the
    program. Let’s say that, during one run of [Listing 14-1](chapter14.xhtml#list14-1),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> winds up at memory address
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>. It also has
    a value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. Since the type
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    we’ll interpret its value as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    too.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从声明一个变量开始，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。由于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 是一个对象，它有一个地址，尽管每次运行程序时这个地址都不会相同。假设在运行[Listing
    14-1](chapter14.xhtml#list14-1)时，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    最终位于内存地址 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>。它的值也是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，我们也将其值解释为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型。
- en: 'Next, we declare the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    which is also an object. The type of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, or “pointer to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,” which represents the
    address of an object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Like <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    has an address; let’s say it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b940</samp>.
    It also has a value: the result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator takes the
    address of its operand, which implies that its operand must designate an object
    with an address. In other words, the operand must be an lvalue. The result of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator, however,
    is not an object; it’s a value of pointer type.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明变量<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>，它也是一个对象。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>的类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>，即“指向<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的指针”，表示一个类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>对象的地址。像<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>一样，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>也有一个地址；假设它是<samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b940</samp>。它还有一个值：表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>的结果。<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>操作符获取其操作数的地址，这意味着其操作数必须指代一个有地址的对象。换句话说，操作数必须是左值。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&</samp>操作符的结果不是一个对象，而是一个指针类型的值。
- en: In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>, the
    operand is the lvalue <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    Evaluating <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp> results in
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>,
    which is the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    We assign this value to the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    just like we can assign any value to a variable with a compatible type. To help
    us keep things straight, [Figure 14-1](#fig14-1) shows the contents of the stack
    at this point in the program.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>中，操作数是左值<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。计算<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>的结果是值<samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>，这是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>的地址。我们将此值赋给变量<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>，就像我们可以将任何兼容类型的值赋给一个变量一样。为了帮助我们理清思路，[图14-1](#fig14-1)显示了此时程序栈的内容。
- en: '![](../images/fig14-1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: The addresses
    and initial values of the objects declared in [Listing 14-1](chapter14.xhtml#list14-1)
    [Description](description-36.xhtml)</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-1：在[清单14-1](chapter14.xhtml#list14-1)
    [描述](description-36.xhtml)中声明的对象的地址和初始值</samp>
- en: As this figure shows, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>
    is both the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>. I said
    earlier that a value is a sequence of bits with a type; the type of the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> because it’s the address of an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，<samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>既是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>的地址，也是<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>的值。我之前说过，值是具有类型的比特序列；值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>的类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>，因为它是类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>对象的地址。
- en: On the next line of [Listing 14-1](chapter14.xhtml#list14-1), we have the assignment
    expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, which consists of several
    subexpressions. On the right, we have the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>;
    on the left, we have the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    itself part of the dereference expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>.
    The constant isn’t particularly interesting, but the other two subexpressions
    are. The innermost of these expressions, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    designates an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. We don’t assign to it or take its address; we just read its value. Therefore,
    we implicitly lvalue convert it, which results in a *value* of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>.
    We use this value in a dereference expression, <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>.
    A dereference expression is an lvalue, so its result is an object. In this case,
    it’s the object at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>,
    since that’s the value being dereferenced. Because we’re assigning to the object
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>, rather than using its
    value, it doesn’t undergo lvalue conversion. [Figure 14-2](#fig14-2) shows the
    contents of the stack after this statement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 14-1](chapter14.xhtml#list14-1)的下一行，我们有赋值表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，该表达式由多个子表达式组成。在右边，我们有常量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>；在左边，我们有变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>，它本身是解引用表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp> 的一部分。常量并不特别有趣，但另外两个子表达式很有意思。这些表达式中最内层的，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>，表示一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> 的对象。我们没有给它赋值或取它的地址；我们只是读取它的值。因此，我们隐式地将其转换为左值，结果是类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> 的*值*，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>。我们在解引用表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp> 中使用了这个值。解引用表达式是一个左值，因此其结果是一个对象。在这个例子中，它是地址为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp> 的对象，因为这是被解引用的值。由于我们对对象
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp> 进行赋值，而不是使用它的值，它不需要进行左值转换。[图
    14-2](#fig14-2) 显示了此语句执行后堆栈的内容。
- en: '![](../images/fig14-2.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: The contents of
    the stack after assignment through a dereferenced pointer [Description](description-37.xhtml)</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-2：通过解引用指针赋值后的堆栈内容 [描述](description-37.xhtml)</samp>
- en: We dereference <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> one
    more time in the final <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. Once again, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>
    is the object at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>.
    This time, however, we aren’t assigning to this object or applying the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator to it. Therefore, we perform lvalue conversion, which results in the
    object’s current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在最后的 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句中再次解引用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>。同样，<samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>
    的结果是地址为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp> 的对象。然而，这次我们并没有对该对象进行赋值，也没有对其应用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 操作符。因此，我们进行了左值转换，结果是该对象当前的值，即
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>。
- en: Now that you understand how <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operate on objects
    and values, let’s talk about conversions to and from pointer types.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    如何作用于对象和数值，接下来让我们讨论指针类型之间的转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Null Pointers and
    Type Conversions</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">空指针与类型转换</samp>
- en: 'An integer constant expression whose value is 0, called a *null pointer constant*,
    can be converted implicitly to any pointer type. The result of this conversion
    is a *null pointer*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值为0的整数常量表达式，称为*空指针常量*，可以隐式转换为任何指针类型。这种转换的结果是一个*空指针*：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because a null pointer is not a valid memory address, the result of dereferencing
    it is undefined. In practice, dereferencing a null pointer will likely crash your
    program. The C standard permits constant expressions like <samp class="SANS_TheSansMonoCd_W5Regular_11">(long)
    0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">10 - 10</samp> as null
    pointer constants, but we’ll support only constant literals like <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">0ul</samp>. (This is the same
    limitation we placed on static initializers in [Chapter 10](chapter10.xhtml).)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为空指针不是一个有效的内存地址，所以解引用空指针的结果是未定义的。实际上，解引用空指针很可能会导致程序崩溃。C标准允许像<samp class="SANS_TheSansMonoCd_W5Regular_11">(long)
    0</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">10 - 10</samp>这样的常量表达式作为空指针常量，但我们只支持像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">0ul</samp>这样的常量字面值。（这与我们在[第10章](chapter10.xhtml)中对静态初始化器施加的限制相同。）
- en: 'With the exception of null pointer constants, it’s illegal to implicitly convert
    integers to pointers or vice versa. Consider this code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了空指针常量外，隐式地将整数转换为指针或将指针转换为整数是非法的。考虑以下代码片段：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, it’s illegal to assign it
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>, which has type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. For the same reason, it’s
    illegal to assign a nonzero constant to a pointer:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>的类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，所以将其赋值给类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>（类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>）是非法的。出于同样的原因，将非零常量赋值给指针也是非法的：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These declarations of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2</samp> are both illegal
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>
    are integers, not pointers. Note that the type of an expression has nothing to
    do with whether its value is a valid memory address. Even if <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>
    happens to be a valid address, the constant expression <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>
    is still a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> rather than
    a pointer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2</samp>的声明都是非法的，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">3</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>是整数，而不是指针。请注意，表达式的类型与其值是否是有效的内存地址无关。即使<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>恰好是一个有效的地址，常量表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>仍然是一个<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>，而不是一个指针。
- en: 'It’s also illegal to implicitly convert from one pointer type to another (with
    the exception of conversions to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>, which I’ll introduce in [Chapter 17](chapter17.xhtml)). For example,
    you can’t implicitly convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double
    *</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long *</samp>:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将一种指针类型隐式转换为另一种指针类型也是非法的（<samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>的转换除外，我将在[第17章](chapter17.xhtml)中介绍）。例如，你不能将<samp class="SANS_TheSansMonoCd_W5Regular_11">double
    *</samp>隐式转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">long *</samp>：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: GCC warns about the implicit conversions in the previous three code snippets,
    but it still compiles them. We’ll take a stricter approach and treat these implicit
    conversions as errors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: GCC会对前三个代码片段中的隐式转换发出警告，但仍然会编译它们。我们将采取更严格的做法，将这些隐式转换视为错误。
- en: On the other hand, *explicit* casts between pointer types, and between pointer
    and integer types, are legal. [Listing 14-2](chapter14.xhtml#list14-2) shows an
    example of an explicit cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">double
    *</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long *</samp>.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*显式*地在指针类型之间，或者在指针类型和整数类型之间进行转换是合法的。[清单14-2](chapter14.xhtml#list14-2)展示了一个从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double *</samp>到<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long *</samp>的显式转换示例。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: An explicit pointer
    type conversion</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-2：显式指针类型转换</samp>
- en: After the explicit cast and assignment ❶, <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> contain the same memory
    address, interpreted as two different pointer types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在显式转换和赋值❶之后，<samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>包含相同的内存地址，但被解释为两种不同的指针类型。
- en: One important caveat is that dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    after this cast would result in undefined behavior. With a few exceptions, if
    we declare an object with some type (called its *effective type*) and then access
    it using an expression of a different type, the result is undefined. In other
    words, casting from one pointer type to another is always legal, but using the
    result of that cast expression may not be. In [Listing 14-2](chapter14.xhtml#list14-2),
    the effective type of <samp class="SANS_TheSansMonoCd_W5Regular_11">negative_zero</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, so we can’t access
    it with the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*l</samp>,
    which has type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. The complete set of rules
    about which types of expressions you can use to access an object—unofficially
    called the *strict aliasing rules*—are spelled out in section 6.5, paragraphs
    6–7, of the C standard. Luckily, since we don’t need to detect undefined behavior
    or handle it gracefully, we can ignore these rules; our implementation will happily
    compile programs that violate them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的警告是，在进行此类型转换后，如果取消引用<samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>，会导致未定义的行为。除了少数例外情况，如果我们声明一个具有某种类型的对象（称为其*有效类型*），然后使用不同类型的表达式访问它，结果是未定义的。换句话说，从一种指针类型转换到另一种指针类型总是合法的，但使用该类型转换的结果可能不合法。在[列表
    14-2](chapter14.xhtml#list14-2)中，<samp class="SANS_TheSansMonoCd_W5Regular_11">negative_zero</samp>的有效类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，因此我们不能使用表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">*l</samp>来访问它，因为该表达式的类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>。关于可以用来访问对象的表达式类型的完整规则——非正式地称为*严格别名规则*——在C标准的第6.5节第6至7段中有详细说明。幸运的是，由于我们不需要检测未定义的行为或优雅地处理它，因此可以忽略这些规则；我们的实现将愉快地编译违反这些规则的程序。
- en: Finally, you can explicitly cast between pointer types and integer types. When
    you cast a null pointer constant to a pointer type, the result is a null pointer.
    When you cast any other integer to a pointer type, or any pointer to an integer
    type, the result is implementation-defined. On an x64 system, memory addresses
    are unsigned 64-bit integers, like <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>.
    Therefore, if you convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> to a pointer (or vice versa), its value won’t change. Casting any
    other integer type to or from a pointer type has the same effect as casting to
    or from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. For
    example, if you cast a signed <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> with value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> to a pointer type, it will result
    in the largest representable memory address, <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>.
    This address is unlikely to hold a valid object, so dereferencing it will probably
    result in undefined behavior.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以显式地在指针类型和整数类型之间进行转换。当你将一个空指针常量转换为指针类型时，结果是一个空指针。当你将任何其他整数转换为指针类型，或将任何指针转换为整数类型时，结果是实现定义的。在x64系统上，内存地址是无符号64位整数，类似于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>。因此，如果你将一个<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>转换为指针（或反之），其值不会改变。将任何其他整数类型转换为指针类型，或将指针类型转换为整数类型的效果与转换为或从<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>的效果相同。例如，如果你将一个带有值<samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>的有符号<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>转换为指针类型，它将导致表示的最大内存地址<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>。这个地址不太可能包含有效的对象，因此取消引用它很可能会导致未定义的行为。
- en: Casting a pointer type to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    or a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to a pointer
    type is illegal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将指针类型强制转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 或将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 强制转换为指针类型是非法的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Comparisons</samp>
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">指针比较</samp>
- en: You can compare pointers of the same type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> operators. Two non-null
    pointers compare equal if they point to the same object (or just past the end
    of the same array, once we implement arrays). They compare unequal otherwise.
    A pointer to a valid object always compares unequal to a null pointer, and two
    null pointers always compare equal to each other. You can also use a pointer in
    any construct that compares an expression to zero, including logical <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    expressions; the condition in a conditional expression; and the controlling condition
    in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement or loop.
    In each of these cases, a null pointer counts as zero, and any non-null pointer
    is nonzero.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>
    操作符比较相同类型的指针。两个非空指针相等时，它们指向同一个对象（或者正好指向同一个数组的末尾，等我们实现数组后）。否则它们不相等。指向有效对象的指针总是与空指针不相等，而两个空指针总是相等。你还可以在任何比较表达式是否为零的结构中使用指针，包括逻辑
    <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> 表达式；条件表达式中的条件；以及 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句或循环中的控制条件。在这些情况下，空指针算作零，任何非空指针算作非零。
- en: You can also compare pointers using the other relational operators, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp>, but we won’t support that yet.
    This sort of pointer comparison is most useful when you’re working with pointers
    to array elements, so we’ll implement it when we add arrays in the next chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用其他关系运算符（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>）比较指针，但我们暂时不支持这类操作。这种类型的指针比较在处理指向数组元素的指针时最为有用，因此我们将在下一章添加数组时实现它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">& Operations on Dereferenced
    Pointers</samp>
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">& 解引用指针的操作</samp>
- en: We saw earlier that the operand of the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator must be an lvalue. Since a dereferenced pointer is an lvalue, you can
    take its address with this operator, like we do in [Listing 14-3](chapter14.xhtml#list14-3).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到过，<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 操作符的操作数必须是一个左值。由于解引用指针是一个左值，你可以使用这个操作符获取它的地址，就像我们在
    [示例 14-3](chapter14.xhtml#list14-3) 中做的那样。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-3: Taking the address
    of a dereferenced pointer</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 14-3：获取解引用指针的地址</samp>
- en: The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&*ptr</samp> is
    valid, but it’s not very useful. The inner expression designates the object stored
    at some address, and the outer expression takes the address of that object. You
    just end up with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    which is the address you dereferenced to begin with.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">&*ptr</samp> 是有效的，但它并不太有用。内部表达式指定了存储在某个地址的对象，而外部表达式获取该对象的地址。最终你得到的是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 的值，即你最初解引用的地址。
- en: 'In fact, the C standard treats <samp class="SANS_TheSansMonoCd_W5Regular_11">&*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp> as a special case:
    section 6.5.3.2, paragraph 3, states that “neither [the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    operator] nor the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator
    is evaluated and the result is as if both were omitted, except that the constraints
    on the operators still apply and the result is not an lvalue.” In other words,
    the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">&*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>
    is always the value of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>.
    Usually, like in [Listing 14-3](chapter14.xhtml#list14-3), it doesn’t matter whether
    we evaluate the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operators; we end up with <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp> either way. The
    one exception is when <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>
    is not a valid memory address, like in [Listing 14-4](chapter14.xhtml#list14-4).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，C标准将 <samp class="SANS_TheSansMonoCd_W5Regular_11">&*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>
    视为一个特殊情况：第 6.5.3.2 节第 3 段指出：“[* 运算符]和 & 运算符都不会被求值，结果就像两个都被省略一样，唯一的区别是这些运算符的约束仍然适用，而且结果不是左值。”换句话说，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>
    的结果始终是 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp> 的值。通常情况下，像在[列表
    14-3](chapter14.xhtml#list14-3)中，无论我们是否求值 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 运算符，最终结果都是 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>。唯一的例外是当
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp> 不是有效的内存地址时，像在[列表
    14-4](chapter14.xhtml#list14-4)中那样。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-4: Taking the address
    of a dereferenced null pointer</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-4：获取反引用空指针的地址</samp>
- en: 'Dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp>
    would usually cause a runtime error. However, since the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> expressions in [Listing
    14-4](chapter14.xhtml#list14-4) aren’t evaluated, this code is equivalent to:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用 <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp> 通常会导致运行时错误。然而，由于[列表
    14-4](chapter14.xhtml#list14-4)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 表达式并没有被求值，所以这段代码的等效形式是：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Therefore, [Listing 14-4](chapter14.xhtml#list14-4) runs without error; it initializes
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2</samp>
    as null pointers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，[列表 14-4](chapter14.xhtml#list14-4)可以顺利运行，没有错误；它将 <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2</samp> 初始化为空指针。
- en: Now that we’re experts on pointer semantics, let’s start on the lexer!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经掌握了指针语义，让我们开始处理词法分析器（lexer）吧！
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'In this chapter, you’ll add a single token:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你将添加一个单独的令牌：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&</samp> An ampersand, the address
    operator
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&</samp> 一个和号，地址运算符
- en: You already added the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    token to support multiplication. If you implemented the bitwise operators for
    extra credit in [Chapter 3](chapter3.xhtml), you’ve already added the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    token too, so you won’t need to modify the lexer at all.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 令牌来支持乘法。如果你在[第
    3 章](chapter3.xhtml)实现了位运算符的附加功能，那么你也已经添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    令牌，因此你不需要修改词法分析器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: 'Next, we’ll add pointer types and the two new pointer operators to the AST.
    A pointer type is constructed recursively from the type of the object it points
    to; <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">double
    *</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long *</samp>
    are all valid types. You can also declare pointers to pointers, so <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    **</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long ***</samp>, and
    so on are valid types as well. Therefore, the AST defines pointer types recursively:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向抽象语法树（AST）添加指针类型和两个新的指针运算符。指针类型是通过递归构造的，来自它所指向对象的类型；例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">double *</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long *</samp> 都是有效的类型。你还可以声明指向指针的指针，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int **</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">long
    ***</samp> 等也是有效的类型。因此，AST通过递归定义指针类型：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In C, types that are built up from simpler types are called *derived types*.
    Pointer types and function types are both derived types. The array and structure
    types we’ll implement in later chapters are derived types too. The type that a
    pointer points to is its *referenced type*. For example, the referenced type of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，由更简单类型构建的类型称为*派生类型*。指针类型和函数类型都是派生类型。我们将在后续章节中实现的数组类型和结构类型也是派生类型。指针所指向的类型称为*引用类型*。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> 的引用类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。
- en: 'We’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST
    node to represent the dereference and address operators:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST节点，以表示解引用和取地址运算符：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Syntactically, these are both unary operators, so you can extend <samp class="SANS_TheSansMonoCd_W5Regular_11">unary
    _operator</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    if you want. But I think it’s easier to make them distinct expressions because
    we’ll handle these quite differently from the other unary operators during type
    checking and TACKY generation. [Listing 14-5](chapter14.xhtml#list14-5) shows
    the updated AST, with this chapter’s additions bolded.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，这两个运算符都是一元运算符，因此你可以扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">unary
    _operator</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>，如果你想这样做。但是我认为将它们作为不同的表达式处理会更容易，因为我们在类型检查和TACKY生成过程中将以不同的方式处理这些运算符。[列表
    14-5](chapter14.xhtml#list14-5) 显示了更新后的AST，本章的新增部分已加粗。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-5: The abstract
    syntax tree with pointer types and the dereference and address operators</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-5：包含指针类型以及解引用和取地址运算符的抽象语法树</samp>
- en: 'Next, we’ll update the grammar and figure out how to parse it. We can parse
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operators like any other unary operator, so we add them to the <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp>
    grammar rule:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新语法并找出如何解析它。我们可以像解析其他一元运算符一样解析 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 运算符，因此我们将它们添加到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp> 语法规则中：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Parsing pointer types in declarations and cast expressions is more challenging.
    We need an approach that we can extend to handle derived types in general, not
    just pointers; otherwise, we’ll have to completely rewrite it to deal with arrays
    in the next chapter. We’ll start by updating the parser to support derived types
    in declarations. Then, we’ll handle derived types in cast expressions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明和强制类型转换表达式中解析指针类型更具挑战性。我们需要一种方法来扩展它，以处理一般的派生类型，而不仅仅是指针；否则，我们将不得不完全重写它，以应对下一章中的数组。我们将从更新解析器开始，以支持声明中的派生类型。然后，我们将处理强制类型转换表达式中的派生类型。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Declarations</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析声明</samp>'
- en: 'A function or variable declaration consists of three parts: a list of specifiers,
    a declarator, and an optional initializer or function body. You already know what
    initializers and function bodies look like, so I won’t talk about them here. The
    specifiers are also familiar from earlier chapters: they include storage class
    specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>, which
    determine the identifier’s storage class and linkage, and type specifiers like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, which determine what
    I’ll call its *basic type*. The basic type is either the type of the identifier
    or the starting point for deriving its type. (This particular term doesn’t appear
    in the C standard, but it sometimes shows up in other discussions of C declarations.)
    The *declarator* is everything else: it indicates the identifier being declared
    and the sequence of derivations we’ll apply to the basic type. For example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">*var</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(int a)</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">foo[3]</samp>
    are all declarators.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数或变量声明由三部分组成：一组说明符、一个声明符和一个可选的初始化器或函数体。你已经知道初始化器和函数体是什么样子，所以我这里不再讨论它们。说明符是之前章节中已经熟悉的内容：它们包括像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> 这样的存储类说明符，用于确定标识符的存储类和链接性，和像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 这样的类型说明符，用于确定我所说的 *基本类型*。基本类型是标识符的类型，或者是派生其类型的起始点。（这个术语在
    C 标准中并没有出现，但它有时出现在 C 声明的其他讨论中。）*声明符* 是其他所有内容：它表示正在声明的标识符，以及我们将应用于基本类型的派生序列。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">*var</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo(int a)</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">foo[3]</samp>
    都是声明符。
- en: 'The simplest declarator is an identifier:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的声明符是标识符：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, the basic type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and the declarator is <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>,
    so it declares a variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. This declaration
    doesn’t include any type derivations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，基本类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，声明符是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp>，因此它声明了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    的变量，其类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。这个声明没有包含任何类型派生。
- en: 'To derive a new type, we nest a declarator like <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    inside another declarator:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要派生一个新类型，我们将像 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> 这样的声明符嵌套在另一个声明符中：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we have a pointer declarator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*(var)</samp>,
    which contains the nested declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>.
    A pointer declarator takes some type *t* and derives the type “pointer to *t*,”
    so this declaration declares <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    with the type “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.”
    Note that C’s syntax allows us to wrap any declarator in parentheses. I’ve wrapped
    <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> in parentheses to make
    the nesting here explicit, but the declaration has the same meaning if we omit
    them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个指针声明符 <samp class="SANS_TheSansMonoCd_W5Regular_11">*(var)</samp>，它包含嵌套声明符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>。指针声明符采用某种类型 *t*，并派生出“指向
    *t* 的指针”类型，因此这个声明声明了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    的变量，类型为“指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的指针”。请注意，C
    的语法允许我们将任何声明符包裹在括号中。我将 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    包裹在括号中，以使嵌套关系变得显式，但如果我们省略括号，声明的意义是一样的：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We use multiple layers of nested declarators to specify multiple type derivations;
    these are applied from the outside in to determine the final type. The innermost
    declarator is always a plain identifier. Here’s an example with three nested declarators:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用多层嵌套声明符来指定多个类型派生；这些派生从外到内应用，以确定最终类型。最内层的声明符始终是一个普通的标识符。这里是一个包含三个嵌套声明符的例子：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The full declarator is <samp class="SANS_TheSansMonoCd_W5Regular_11">*(*(var))</samp>,
    which contains <samp class="SANS_TheSansMonoCd_W5Regular_11">*(var)</samp>, which
    contains <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>. As in the previous
    example, the parentheses in this declarator have no effect; I’ve just included
    them for clarity.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的声明符是 <samp class="SANS_TheSansMonoCd_W5Regular_11">*(*(var))</samp>，它包含 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">*(var)</samp>，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">*(var)</samp>
    又包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>。就像前面的例子一样，这个声明符中的括号没有任何作用；我只是为了清晰起见才加上的。
- en: Let’s walk through the type derivations here. Working from the outside in, we
    start with the basic type, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Next, we see a pointer declarator, so we derive the type “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.”
    Then, we see another pointer declarator, so we derive “pointer to pointer to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.” Finally, we encounter the
    identifier, which completes the declaration but doesn’t add any type information.
    We end up with a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    whose type is “pointer to pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.”
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐步解析类型推导。从外到内，我们首先看到基本类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。接下来，我们看到一个指针声明符，因此我们推导出类型“指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的指针”。然后，我们看到另一个指针声明符，所以我们推导出“指向指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的指针”。最后，我们遇到标识符，这完成了声明，但没有增加任何类型信息。最终我们得到一个变量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>，其类型是“指向指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    的指针”。
- en: 'The other two kinds of declarators are *function declarators*, which we already
    support, and *array declarators*, which we’ll add in the next chapter. A function
    declarator takes a type *t* and derives the type “function returning *t*.” Let’s
    break down a function declaration:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两种声明符是 *函数声明符*（我们已经支持）和 *数组声明符*（我们将在下一章添加）。函数声明符接受一个类型 *t*，并推导出类型“返回 *t* 的函数”。让我们拆解一个函数声明：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The full declarator here is <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(void)</samp>,
    which contains the nested declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
    Parenthesizing each declarator gives us the following equivalent declaration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的完整声明符是 <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(void)</samp>，它包含嵌套声明符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>。为每个声明符加上括号，得到以下等效声明：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We start with the basic type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    The outer declarator tells us to derive the type “function returning <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,”
    and the inner declarator indicates that we’re declaring the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
    Of course, a function declarator also declares the function’s parameters. Each
    parameter, much like a declaration, includes a basic type and a declarator:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基本类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 开始。外部声明符告诉我们推导出类型“返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的函数”，而内部声明符则表明我们正在声明标识符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>。当然，函数声明符还声明了函数的参数。每个参数就像一个声明一样，包含基本类型和声明符：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we already know, a parameter list of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">(void)</samp>
    is a special case: it declares that the function has no parameters.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，形式为 <samp class="SANS_TheSansMonoCd_W5Regular_11">(void)</samp> 的参数列表是一种特殊情况：它声明函数没有参数。
- en: 'Finally, an array declarator starts with type *t* and derives the type “array
    of *n* elements of type *t*.” For example, the following code includes the declarator
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[3]</samp>, which has a nested
    declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数组声明符以类型 *t* 开始，并推导出类型“类型为 *t* 的 *n* 个元素的数组”。例如，以下代码包含声明符 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[3]</samp>，它有一个嵌套的声明符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This declares that <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    is an array of three elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 是一个包含三个元素的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型数组。
- en: More complicated declarations can include a mix of nested pointer, array, and
    function declarators. The function and array declarators, which we indicate with
    postfix expressions, have higher precedence than the pointer declarator, so
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的声明可以包括嵌套指针、数组和函数声明符的混合。我们用后缀表达式表示的函数和数组声明符优先级高于指针声明符，因此
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'is equivalent to:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To interpret this declaration, we start with <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    apply the outer pointer declarator to derive “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,”
    apply the inner array declarator to derive “array of three pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,”
    and end with the innermost declarator, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>.
    To declare a pointer to an array instead, we override this precedence with parentheses:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这个声明，我们从 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 开始，应用外部指针声明符得出“指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的指针”，应用内部数组声明符得出“一个包含三个指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的指针的数组”，最后得出最内层声明符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>。如果要声明一个指向数组的指针，我们可以用括号覆盖这一优先级：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Along the same lines, this declaration declares a pointer to a function with
    a single parameter:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个声明声明了一个指向具有单一参数的函数的指针：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Function pointers are legal in C, but we won’t implement them in this book.
    You can also nest declarators to specify types that are straight-up illegal. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">int foo(void)(void);</samp>
    declares a function that returns a function that returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    This declaration is syntactically well formed but semantically invalid; a function
    can’t return another function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针在C中是合法的，但在本书中我们不会实现它们。你还可以嵌套声明符来指定完全非法的类型。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    foo(void)(void);</samp> 声明了一个返回函数的函数，而该返回的函数又返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。这个声明在语法上是正确的，但在语义上无效；一个函数不能返回另一个函数。
- en: Now that you understand the basic syntax of declarators, we’re ready to write
    grammar rules for them. For the full description of declarators, see section 6.7.6
    of the C standard. I also recommend “Reading C Type Declarations” by Steve Friedl,
    which describes their syntax in a more comprehensible way than the standard does
    (*[http://<wbr>unixwiz<wbr>.net<wbr>/techtips<wbr>/reading<wbr>-cdecl<wbr>.html](http://unixwiz.net/techtips/reading-cdecl.html)*).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了声明符的基本语法，我们准备为它们编写语法规则。有关声明符的完整描述，请参见C标准的第6.7.6节。我还推荐Steve Friedl的《阅读C类型声明》，它以比标准更易理解的方式描述了声明符的语法（*
    [http://<wbr>unixwiz<wbr>.net<wbr>/techtips<wbr>/reading<wbr>-cdecl<wbr>.html](http://unixwiz.net/techtips/reading-cdecl.html)
    *）。
- en: 'Since declarators have several precedence levels, we need several grammar rules
    to define their syntax. At the highest precedence level, a <samp class="SANS_TheSansMonoCd_W5Regular_11"><simple-declarator></samp>
    is a single identifier or parenthesized declarator:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于声明符有多个优先级层次，我们需要多个语法规则来定义它们的语法。在最高优先级层次，<samp class="SANS_TheSansMonoCd_W5Regular_11"><simple-declarator></samp>
    是一个单独的标识符或带括号的声明符：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At the next precedence level, we have what the C grammar calls *direct declarators*,
    including function and array declarators. We support only function declarators
    in this chapter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个优先级层次，我们有C语法中称为*直接声明符*的部分，包括函数和数组声明符。本章仅支持函数声明符：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11"><direct-declarator></samp>,
    a direct declarator may be either a simple declarator or a function declarator,
    indicated by the presence of a parameter list. Notice that we’ve changed <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp> a bit from previous
    chapters, refactoring this symbol to include the parentheses around the parameter
    list and moving the definition of a single parameter into a separate <samp class="SANS_TheSansMonoCd_W5Regular_11"><param></samp>
    symbol. Most importantly, the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11"><param></samp>
    now includes a declarator instead of a plain identifier. This lets us parse parameters
    with pointer types (and eventually with array types as well). Finally, we’ll define
    a top-level <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator></samp>
    that includes pointer declarators:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在<samp class="SANS_TheSansMonoCd_W5Regular_11"><direct-declarator></samp>的定义中，直接声明符可以是简单声明符或函数声明符，后者通过存在参数列表来表示。请注意，我们已经稍微修改了<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>，将该符号重构为包含参数列表周围的括号，并将单个参数的定义移入单独的<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><param></samp>符号中。最重要的是，<samp class="SANS_TheSansMonoCd_W5Regular_11"><param></samp>的定义现在包括了声明符，而不是一个普通的标识符。这使得我们能够解析带有指针类型（最终也包括数组类型）的参数。最后，我们将定义一个顶级的<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><declarator></samp>，其中包括指针声明符：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Unfortunately, this grammar doesn’t really correspond with our AST definition.
    One minor problem is that it allows us to specify types we don’t support, including
    function pointers, functions that return functions, and functions that take other
    functions as arguments. A more serious problem is that in our grammar, type derivations
    are applied from the outside in, but in the AST definition, they’re applied from
    the inside out. Let’s revisit a declaration we looked at earlier:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个语法实际上与我们的抽象语法树（AST）定义不完全匹配。一个小问题是，它允许我们指定一些不支持的类型，包括函数指针、返回函数的函数，以及将其他函数作为参数的函数。更严重的问题是，在我们的语法中，类型推导是从外到内应用的，而在AST定义中，它们是从内到外应用的。让我们重新审视一下之前看过的一个声明：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We want to parse this declaration and construct the type “pointer to array of
    three elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.”
    What happens if we try to construct this type using recursive descent parsing?
    First, we’ll encounter the basic type, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Then, we’ll see an open parenthesis, which indicates the start of a direct declarator.
    Inside that direct declarator, we’ll find a pointer declarator—and then we’ll
    be stuck. We should derive a pointer type, but a pointer to what? The basic type
    we’ve seen so far is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    but “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>” is incorrect.
    Because type derivations are applied from the outside in, we ought to derive the
    array type first. But we can’t, because the parser has to consume the inner, parenthesized
    declarator before it can reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>
    that specifies the array type.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想解析这个声明并构造类型“指向类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的三元素数组的指针”。如果我们尝试使用递归下降解析来构造这个类型，会发生什么呢？首先，我们会遇到基本类型<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。然后，我们会看到一个左括号，表示直接声明符的开始。在该直接声明符内，我们会看到一个指针声明符——然后我们就会卡住。我们应该推导出指针类型，但指向什么呢？到目前为止我们看到的基本类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，但“指向<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的指针”是不正确的。由于类型推导是从外到内应用的，我们应该首先推导出数组类型。但我们无法做到，因为解析器必须先消费内层的带括号的声明符，才能到达指定数组类型的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>。
- en: We get stuck here because the order in which we can recognize grammar symbols
    doesn’t match the order in which we apply type derivations. When we parse a declaration,
    we can’t derive its type as we go. Instead, we’ll first parse each declarator
    to a one-off representation that more closely mirrors the grammar, like the one
    in [Listing 14-6](chapter14.xhtml#list14-6).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里卡住了，因为我们能够识别语法符号的顺序与应用类型推导的顺序不匹配。当我们解析一个声明时，不能一边解析一边推导其类型。相反，我们首先会将每个声明符解析为一种临时表示形式，这种表示形式更接近语法，如[清单
    14-6](chapter14.xhtml#list14-6)中的那样。
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-6: Representing
    the syntax of a declarator</samp>'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-6：表示声明符的语法</samp>
- en: We can produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    construct with standard recursive descent parsing, following the grammar rules
    we just introduced.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准的递归下降解析法生成一个<samp class="SANS_TheSansMonoCd_W5Regular_11">声明符</samp>构造，遵循我们刚刚介绍的语法规则。
- en: 'The next step is to traverse that <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    and derive all the information we’ll use to construct an AST node: the declaration’s
    type, its identifier, and the identifiers of any parameters. At every layer, we’ll
    apply the appropriate type derivation, then recursively handle the inner declarator.
    [Listing 14-7](chapter14.xhtml#list14-7) presents the pseudocode for this step.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是遍历该<samp class="SANS_TheSansMonoCd_W5Regular_11">声明符</samp>，并推导出所有我们将用于构造
    AST 节点的信息：声明的类型、标识符以及任何参数的标识符。在每一层，我们都会应用适当的类型推导，然后递归地处理内层声明符。[清单 14-7](chapter14.xhtml#list14-7)展示了此步骤的伪代码。
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-7: Deriving type
    and identifier information from a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">declarator</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-7：从声明符中推导类型和标识符信息</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">声明符</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>
    function takes two arguments. The first is the declarator itself. The second,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>, is the type we’ve
    derived so far. Initially, this will be the basic type indicated by the list of
    specifiers at the start of the declaration. For example, if we were processing
    the declaration <samp class="SANS_TheSansMonoCd_W5Regular_11">double **fun(int
    x)</samp>, we’d start with a <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. The result of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp> will be
    a tuple of three values: the declaration’s identifier, its derived type, and the
    names of any parameters. If the declaration declares a variable, or if it declares
    a function with no parameters, the list of parameter names will be empty. Using
    these three values, we’ll be able to construct a <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    AST node.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>函数接受两个参数。第一个是声明符本身。第二个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>是我们迄今为止推导出的类型。最初，这将是声明开始时由说明符列表指示的基本类型。例如，如果我们正在处理声明<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double **fun(int x)</samp>，我们将从<samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>开始。<samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>的结果将是一个包含三个值的元组：声明的标识符、推导出的类型以及任何参数的名称。如果声明声明的是变量，或者声明的是没有参数的函数，则参数名称列表将为空。使用这三个值，我们将能够构造一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">声明</samp> AST 节点。
- en: Let’s walk through how to extract these values from a <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    construct. In the simplest case, the declarator is an identifier ❶. We don’t need
    to apply any type derivations or introduce any parameters, so we return the identifier,
    the unchanged <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>,
    and an empty list of parameter names. For example, while processing the declaration
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int x;</samp>, we’d immediately
    reach this case and return <samp class="SANS_TheSansMonoCd_W5Regular_11">("x",
    Int, [])</samp>.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解如何从<samp class="SANS_TheSansMonoCd_W5Regular_11">声明符</samp>构造中提取这些值。在最简单的情况下，声明符是一个标识符
    ❶。我们不需要应用任何类型推导或引入任何参数，因此我们返回标识符、不变的<samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>，以及一个空的参数名列表。例如，在处理声明<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int x;</samp>时，我们会立即遇到这种情况，并返回<samp class="SANS_TheSansMonoCd_W5Regular_11">("x",
    Int, [])</samp>。
- en: In the second case, we handle pointer declarators ❷. In this case, we derive
    a pointer type from <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>.
    We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>
    recursively on the type we just derived and the inner declarator that still needs
    to be processed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们处理指针声明符 ❷。在这种情况下，我们从<samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>推导出指针类型。然后，我们递归地调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>，对刚刚推导出的类型和仍需要处理的内层声明符进行处理。
- en: In the last case, we handle function declarators ❸. This case is a little different
    because the inner declarator must be a plain identifier. If it’s another function
    declarator, we’ll end up with a function that returns a function, which isn’t
    legal. If it’s a pointer declarator, we’ll end up with a function pointer, which
    we aren’t implementing. Therefore, we validate that the inner declarator is a
    plain identifier instead of parsing it recursively ❹.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，我们处理函数声明符❸。这一情况有些不同，因为内部声明符必须是一个普通标识符。如果它是另一个函数声明符，我们将得到一个返回函数的函数，这是不合法的。如果它是一个指针声明符，我们将得到一个函数指针，但我们并没有实现函数指针。因此，我们验证内部声明符是一个普通标识符，而不是递归解析它❹。
- en: Assuming the inner declarator is valid, the next step is figuring out the function
    type and parameter names. We’ll iterate over the parameters in the declarator,
    recursively calling <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>
    to get the type and name of each one ❺. While we’re at it, we’ll validate that
    none of these function parameters are functions themselves. (The C standard actually
    lets you declare parameters with function type, but it requires the compiler to
    implicitly adjust them to function pointer type. Since we don’t support function
    pointers, we’ll reject them.) Once we’ve handled every parameter, we construct
    the whole function type and return all the relevant information about this declaration.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设内部声明符是有效的，下一步是确定函数类型和参数名称。我们将遍历声明符中的参数，递归调用<samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>来获取每个参数的类型和名称❺。同时，我们会验证这些函数参数中没有是函数本身的情况。（C标准实际上允许你声明函数类型的参数，但它要求编译器隐式地将其调整为函数指针类型。由于我们不支持函数指针，因此会拒绝这种情况。）一旦处理完所有参数，我们将构建完整的函数类型，并返回关于此声明的所有相关信息。
- en: '[Listing 14-8](chapter14.xhtml#list14-8) shows how to put all the pieces together
    to parse an entire declaration.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-8](chapter14.xhtml#list14-8)展示了如何将所有部分组合在一起解析整个声明。'
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-8: Parsing an entire
    declaration</samp>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-8：解析整个声明</samp>
- en: 'We first determine the declaration’s base type in the usual way: we consume
    a list of specifiers from <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>,
    then convert those specifiers to a type and storage class. Next, we parse the
    declarator, and then we call <samp class="SANS_TheSansMonoCd_W5Regular_11">process
    _declarator</samp> to determine its complete type and name. Finally, we examine
    the resulting type to determine whether it’s a function or variable declaration
    and parse the rest of the declaration accordingly.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先按照常规方式确定声明的基本类型：我们从<samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>中消耗一个说明符列表，然后将这些说明符转换为类型和存储类别。接下来，我们解析声明符，然后调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>来确定其完整类型和名称。最后，我们检查结果类型以确定它是函数声明还是变量声明，并相应地解析声明的其余部分。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Type Names</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析类型名称</samp>
- en: 'Pointer types can also appear in cast expressions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 指针类型也可以出现在强制类型转换表达式中：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But you can’t use a declarator in a cast expression, because a declarator must
    contain an identifier. C syntax solves this problem with *abstract declarators*,
    which are declarators without identifiers. We’ll add abstract pointer declarators
    now and abstract array declarators in the next chapter. (We won’t need abstract
    function declarators, because they’re used only to specify function pointers.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你不能在强制类型转换表达式中使用声明符，因为声明符必须包含一个标识符。C语言通过*抽象声明符*解决了这个问题，抽象声明符是没有标识符的声明符。我们现在将添加抽象指针声明符，并在下一章添加抽象数组声明符。（我们不需要抽象函数声明符，因为它们只用于指定函数指针。）
- en: 'An abstract declarator might be a sequence of one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    tokens, indicating a sequence of pointer type derivations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个抽象声明符可能是一个或多个<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>符号的序列，表示指针类型派生的序列：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Abstract declarators can be parenthesized, like their non-abstract counterparts:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象声明符也可以像它们的非抽象对应物一样被括起来：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And an outer abstract declarator can contain an inner parenthesized one:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个外部抽象声明符可以包含一个内部括号声明符：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The parentheses are pointless at the moment. They’ll be more useful when we
    add arrays in the next chapter. For example, the expression
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 括号此时并没有实际意义。当我们在下一章添加数组时，它们将变得更有用。例如，表达式
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'casts <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> to an array
    of three pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    because the abstract array declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>
    is parsed with higher precedence. This cast expression is illegal because you
    can’t cast expressions to array type. On the other hand, this expression is fine:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将<samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>转换为指向三个指针的数组，指向<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，因为抽象数组声明符<samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>的优先级更高。这个类型转换表达式是非法的，因为你不能将表达式转换为数组类型。另一方面，这个表达式是合法的：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This casts <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> to a pointer
    to an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    elements; the parenthesized pointer declarator has higher precedence, so the array
    declarator is applied to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    first.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个将<samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>转换为指向三个<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>元素数组的指针；括号中的指针声明符优先级更高，因此数组声明符首先应用于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。
- en: 'We define abstract declarators using two grammar rules:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两条语法规则来定义抽象声明符：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: An <samp class="SANS_TheSansMonoCd_W5Regular_11"><abstract-declarator></samp>,
    like a regular <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator></samp>,
    consists of either a pointer declarator or a direct declarator. The key difference
    between the two is that in an abstract pointer declarator, the inner declarator
    is optional. In other words, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    by itself is a valid abstract declarator but not a valid regular declarator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个<samp class="SANS_TheSansMonoCd_W5Regular_11"><abstract-declarator></samp>，像普通的<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><declarator></samp>一样，由指针声明符或直接声明符组成。两者之间的关键区别在于，在抽象指针声明符中，内部声明符是可选的。换句话说，单独的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>是一个有效的抽象声明符，但不是有效的普通声明符。
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11"><direct-abstract-declarator></samp>
    is an <samp class="SANS_TheSansMonoCd_W5Regular_11"><abstract-declarator></samp>
    wrapped in parentheses. In the next chapter, this symbol will cover abstract array
    declarators too. We’ll parse abstract declarators to a one-off <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>
    structure, like we did with normal declarators. [Listing 14-9](chapter14.xhtml#list14-9)
    defines this structure.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个<samp class="SANS_TheSansMonoCd_W5Regular_11"><direct-abstract-declarator></samp>是一个用括号括起来的<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><abstract-declarator></samp>。在下一章中，这个符号也将涵盖抽象数组声明符。我们将像处理普通声明符一样，解析抽象声明符为一次性的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>结构。[Listing
    14-9](chapter14.xhtml#list14-9)定义了这个结构。
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-9: Representing
    the syntax of an abstract declarator</samp>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-9: 表示抽象声明符的语法</samp>'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">AbstractBase</samp> represents
    the base case, where a <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    token isn’t followed by an inner declarator. For example, we’d parse the abstract
    declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">*(*)</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AbstractPointer(AbstractPointer(AbstractBase))</samp>.
    At the moment, <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract _declarator</samp>
    just tells us how many layers of pointer indirection we found (two, in this example).
    This is a fairly elaborate way to convey a single number, but it lays the groundwork
    for array declarators in the next chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">AbstractBase</samp>表示基本情况，其中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>标记后面没有跟随内部声明符。例如，我们会将抽象声明符<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*(*)</samp>解析为<samp class="SANS_TheSansMonoCd_W5Regular_11">AbstractPointer(AbstractPointer(AbstractBase))</samp>。目前，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>仅告诉我们找到了多少层指针间接引用（在这个例子中是两层）。这是一种相当复杂的方式来传达一个数字，但它为下一章的数组声明符打下了基础。
- en: 'The type name in a cast expression is a sequence of type specifiers followed
    by an optional abstract declarator, all wrapped in parentheses:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类型名称在类型转换表达式中是由类型说明符序列组成，后面跟一个可选的抽象声明符，所有内容都被括号括起来：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To handle cast expressions, you’ll need a <samp class="SANS_TheSansMonoCd_W5Regular_11">process_abstract_declarator</samp>
    function, similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>
    from [Listing 14-7](chapter14.xhtml#list14-7), to convert a basic type and an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp> into
    a derived type. This function will be simpler than <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>;
    it won’t deal with function declarators and it will return only a type, not an
    identifier or a list of parameters.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理强制转换表达式，你需要一个与[示例 14-7](chapter14.xhtml#list14-7)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>类似的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process_abstract_declarator</samp>函数，用于将基本类型和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>转换为派生类型。这个函数比<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>要简单，它不会处理函数声明符，而且只会返回类型，而不是标识符或参数列表。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将所有内容整合在一起</samp>
- en: We’ve covered every change we’ll make to the parser. [Listing 14-10](chapter14.xhtml#list14-10)
    shows the full grammar, with this chapter’s changes bolded.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了对解析器所做的所有更改。[示例 14-10](chapter14.xhtml#list14-10)显示了完整的语法，新增的内容已加粗。
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-10: The grammar
    with pointer types and the dereference and address operators</samp>'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 14-10：带指针类型和解引用及取地址操作符的语法</samp>
- en: We’ve made three major changes to the grammar. First, we’re using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><declarator></samp> symbol instead of
    simple identifiers in function, variable, and parameter declarations. Second,
    we use the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11"><abstract
    -declarator></samp> symbol to specify pointer types in cast expressions. Third,
    we’ve added the new unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operators.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对语法做了三处重大更改。首先，我们在函数、变量和参数声明中使用< samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator></samp>符号，而不是简单的标识符。其次，我们使用相应的<
    samp class="SANS_TheSansMonoCd_W5Regular_11"><abstract-declarator></samp>符号，在强制转换表达式中指定指针类型。第三，我们增加了新的一元操作符<
    samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>和< samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">语义分析</samp>
- en: On to semantic analysis! We’ll extend the type checker to validate expressions
    that involve pointers and infer the types of these expressions. The identifier
    resolution pass will change a little bit too; we’ll move one piece of validation
    from this pass into the type checker.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是语义分析！我们将扩展类型检查器，以验证涉及指针的表达式并推断这些表达式的类型。标识符解析阶段也会有所变化；我们将把一部分验证从这个阶段移到类型检查器中。
- en: 'We need to detect three kinds of type errors:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检测三种类型错误：
- en: Applying an operator to a type it doesn’t support. For example, you can’t multiply
    or divide pointers, and you can’t dereference arithmetic values.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对不支持的类型应用操作符。例如，你不能对指针进行乘法或除法操作，也不能对算术值进行解引用。
- en: Operating on values of two incompatible types. This includes errors like trying
    to compare a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    We run into this kind of error because C generally doesn’t allow implicit conversions
    to and from pointer types, the way it does for arithmetic types.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对两种不兼容类型的值进行操作。这包括像尝试将指针与< s>double</s>进行比较这样的错误。我们遇到这种错误的原因是，C语言通常不允许像对待算术类型那样对指针类型进行隐式转换。
- en: Not using an lvalue where one is required. We already require the left side
    of an assignment expression to be an lvalue. Now we’ll require the operand of
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression to be
    an lvalue too. We’ll also expand our definition of lvalue to include dereferenced
    pointers as well as variables.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要左值的地方未使用左值。我们已经要求赋值表达式的左边必须是左值。现在，我们还要求< s>AddrOf</s>表达式的操作数也必须是左值。我们还将扩展左值的定义，包含解引用指针和变量。
- en: This third kind of error is the one we currently handle during identifier resolution.
    Remove this validation from the identifier resolution pass now; you’ll add it
    to the type checker in a moment. (While you’re at it, make sure the identifier
    resolution pass traverses the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions.)
    Next, we’ll update the logic to type check expressions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第三类错误是我们目前在标识符解析过程中处理的错误。现在从标识符解析过程中移除这种验证；稍后你会将其添加到类型检查器中。（在此期间，确保标识符解析过程遍历新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    表达式。）接下来，我们将更新逻辑以进行表达式的类型检查。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Pointer
    Expressions</samp>
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型检查指针表达式</samp>
- en: We need to tweak how we type check almost every expression we support. Let’s
    start with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions. Then,
    we’ll update the type checking logic for our existing constructs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调整几乎所有我们支持的表达式的类型检查方法。让我们从新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 表达式开始。然后，我们将更新现有构造的类型检查逻辑。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dereference and AddrOf Expressions</samp>
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">解引用与 AddrOf 表达式</samp>
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> expression
    must take an operand of pointer type. It produces a result with its operand’s
    referenced type (the type it points to). [Listing 14-11](chapter14.xhtml#list14-11)
    demonstrates how to type check a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    expression and annotate it with the correct result type.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> 表达式必须接受一个指针类型的操作数。它会产生一个具有其操作数引用类型（即它所指向的类型）的结果。[清单
    14-11](chapter14.xhtml#list14-11) 演示了如何检查一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    表达式的类型，并用正确的结果类型进行标注。
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-11: Type checking
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Dereference</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">expression</samp>'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-11：类型检查一个</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">Dereference</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">表达式</samp>
- en: We start by type checking the expression’s operand, as usual. Then, we look
    up the operand’s type. If it’s a pointer to some type, <samp class="SANS_TheSansMonoCd_W5Regular_11">referenced_t</samp>,
    we set <samp class="SANS_TheSansMonoCd_W5Regular_11">referenced_t</samp> as the
    result type of the whole expression. Otherwise, we throw an error.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先像往常一样进行表达式操作数的类型检查。然后，我们查找操作数的类型。如果它是指向某种类型的指针，<samp class="SANS_TheSansMonoCd_W5Regular_11">referenced_t</samp>，我们将<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">referenced_t</samp>设置为整个表达式的结果类型。否则，我们抛出一个错误。
- en: To type check an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expression, we first check that its operand is an lvalue (that is, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> expression).
    Then, we record its result type, which is a pointer to the type of its operand.
    [Listing 14-12](chapter14.xhtml#list14-12) demonstrates how to type check <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 表达式的类型，我们首先检查它的操作数是否是左值（也就是说，它是一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    表达式）。然后，我们记录它的结果类型，即指向其操作数类型的指针。[清单 14-12](chapter14.xhtml#list14-12)演示了如何检查 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 的类型。
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-12: Type checking
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddrOf</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">expression</samp>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-12：类型检查一个</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">AddrOf</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">表达式</samp>
- en: Next, we’ll type check pointer comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp>. (We’ll deal
    with other pointer comparisons using <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>, and the other relational
    operators in [Chapter 15](chapter15.xhtml).) We’ll also handle conditional expressions,
    which follow similar typing rules.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp>进行指针比较类型检查。（我们将在[第15章](chapter15.xhtml)中处理使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>以及其他关系运算符的指针比较。）我们还将处理条件表达式，它们遵循类似的类型规则。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparisons and Conditional
    Expressions</samp>
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">比较和条件表达式</samp>
- en: As you learned in earlier chapters, both operands in a comparison must have
    the same type, or at least be implicitly converted to the same type. However,
    we can’t perform implicit conversions to or from pointer types. Therefore, if
    either operand to an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> operation is
    a pointer, we require the types of both operands to be the same. At the moment,
    null pointer constants are the one exception to this rule; they’re the only expressions
    that we can implicitly convert to a pointer type. (Once we implement <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    we’ll also permit implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> and other pointer types.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的章节中所学，比较中的两个操作数必须具有相同的类型，或者至少可以隐式转换为相同的类型。然而，我们不能对指针类型进行隐式转换。因此，如果某个操作数是指针类型，则需要两个操作数的类型相同。目前，空指针常量是此规则的唯一例外；它们是唯一可以隐式转换为指针类型的表达式。（一旦我们实现了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，我们也将允许在<samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>和其他指针类型之间进行隐式转换。）
- en: 'For example, this code snippet compares a pointer to a null pointer constant:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段将指针与空指针常量进行比较：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When we type check <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    in this example, we implicitly cast <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    to a null pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">double
    *</samp>. [Listing 14-13](chapter14.xhtml#list14-13) defines a helper function
    to identify null pointer constants.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本例中进行类型检查<samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>时，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>隐式转换为类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double *</samp>的空指针。[清单14-13](chapter14.xhtml#list14-13)定义了一个辅助函数，用于识别空指针常量。
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-13: Checking whether
    an expression is a null pointer constant</samp>'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-13：检查一个表达式是否为空指针常量</samp>
- en: 'This function captures our three requirements for an expression to count as
    a null pointer constant: it must be a constant literal, it must be an integer,
    and its value must be 0\. (Remember that we’re defining null pointer constants
    more narrowly than the C standard does; the standard permits more complex constant
    expressions as well as constant literals.)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数捕获了我们对表达式作为空指针常量的三个要求：它必须是常量文字，它必须是整数，并且它的值必须为0。（请记住，我们定义空指针常量的标准比C标准更严格；C标准允许更复杂的常量表达式以及常量文字。）
- en: '[Listing 14-14](chapter14.xhtml#list14-14) defines another helper function
    to determine whether two expressions, at least one of which results in a pointer,
    have compatible types.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-14](chapter14.xhtml#list14-14)定义了另一个辅助函数，用于确定两个表达式（其中至少一个是指针）是否具有兼容的类型。'
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-14: Getting the
    common type of two expressions, where at least one has pointer type</samp>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-14：获取两个表达式的共同类型，其中至少一个具有指针类型</samp>
- en: When an expression that operates on pointers expects both its operands to have
    the same type, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>
    will determine what that type should be. If its arguments have different types
    and neither of them is a null pointer constant, they’re incompatible, so we throw
    an error.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个操作指针的表达式期望两个操作数具有相同的类型时，<samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>会确定该类型应该是什么。如果它的参数类型不同，并且都不是空指针常量，它们就不兼容，因此会抛出错误。
- en: Now that we’ve defined <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>,
    we’re finally ready to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> expressions.
    [Listing 14-15](chapter14.xhtml#list14-15) demonstrates how to type check an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> expression; we’ll handle
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> the same way.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了<samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>，终于可以对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp>表达式进行类型检查了。[列表
    14-15](chapter14.xhtml#list14-15)展示了如何对<samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>表达式进行类型检查；我们会以相同的方式处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp>。
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-15: Type checking
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Equal</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expression</samp>'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-15：对</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">Equal</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">表达式进行类型检查</samp>
- en: 'This follows the usual pattern for type checking comparisons: we type check
    both operands, find their common type, convert them both to that type, and then
    set the type of the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>.
    The key change from earlier chapters is how we find the common type. If either
    operand is a pointer, we use the helper function that we just defined ❶. Otherwise,
    we’ll stick with <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp>
    ❷.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了类型检查比较的常见模式：我们对两个操作数进行类型检查，找到它们的共同类型，将它们都转换为该类型，然后将结果的类型设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>。与之前章节的关键变化是我们如何找到共同类型。如果任一操作数是指针，我们使用刚才定义的帮助函数❶。否则，我们将继续使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp>❷。
- en: 'When we convert two operands to a common pointer type, we’ll see one of three
    possible outcomes:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将两个操作数转换为通用指针类型时，我们将看到三种可能的结果之一：
- en: Both operands already have the same type, so neither <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp>
    call has any effect.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个操作数已经具有相同的类型，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp>调用不会产生任何效果。
- en: One operand is a null pointer constant, which we implicitly convert to the other
    operand’s type.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个操作数是空指针常量，我们会将其隐式转换为另一个操作数的类型。
- en: The operands have incompatible types, so <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>
    throws an error.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作数具有不兼容的类型，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>会抛出错误。
- en: We’ll use similar logic to type check conditional expressions. The second and
    third operands in the expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>
    are subject to the same type constraints as the operands in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> expression. If
    either one is a pointer, we’ll validate both operands and find their common type
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>,
    then convert them to that type. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp>
    expression can be either a pointer or an arithmetic value, since we can compare
    it to zero either way.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类似的逻辑来进行条件表达式的类型检查。在表达式 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>
    中的第二个和第三个操作数与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> 表达式中的操作数受到相同的类型约束。如果其中任何一个是指针，我们将验证两个操作数并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp> 找到它们的公共类型，然后将它们转换为该类型。<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp> 表达式可以是指针也可以是算术值，因为我们可以将其与零进行比较。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Assignment and Conversion
    as if by Assignment</samp>
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">赋值与仿佛通过赋值进行的类型转换</samp>
- en: Next, we’ll handle assignment expressions. We first validate that the left-hand
    side of an assignment expression is an lvalue. Then, we convert the value on the
    right side of the expression to the type of the object on the left, or fail if
    the conversion is illegal. What the C standard calls type conversion “as if by
    assignment” turns up in a few places, not just in assignment expressions, so we’ll
    write yet another helper function to handle it. [Listing 14-16](chapter14.xhtml#list14-16)
    defines this helper function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理赋值表达式。我们首先验证赋值表达式左侧是否是左值。然后，我们将表达式右侧的值转换为左侧对象的类型，如果转换不合法则失败。C标准所称的“仿佛通过赋值进行的类型转换”在多个地方出现，不仅限于赋值表达式，因此我们将编写另一个辅助函数来处理它。[Listing
    14-16](chapter14.xhtml#list14-16) 定义了这个辅助函数。
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-16: Converting an
    expression to a target type as if by assignment</samp>'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-16: 将表达式转换为目标类型，仿佛是通过赋值操作</samp>'
- en: 'The rules here are unsurprising: we can assign a value to an object of the
    same type, we can implicitly convert any arithmetic type to any other arithmetic
    type, and we can implicitly convert a null pointer constant to any pointer type.
    Otherwise, we’ll raise an error.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的规则并不令人惊讶：我们可以将值赋给相同类型的对象，我们可以隐式地将任何算术类型转换为任何其他算术类型，并且我们可以隐式地将空指针常量转换为任何指针类型。否则，我们将引发错误。
- en: 'We’ll use this helper function to convert the right side of assignment expressions
    and in a few other spots too. To type check a function call, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    to convert each argument to the type of the corresponding parameter. We’ll also
    use it to convert variable initializers to the correct type and to detect initializers
    with invalid types, like the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个辅助函数来转换赋值表达式的右侧值，也会在其他一些地方使用它。为了进行函数调用的类型检查，我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    将每个参数转换为相应参数的类型。我们还将用它将变量初始化器转换为正确的类型，并检测无效类型的初始化器，例如以下内容：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    to convert the value in a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement to the function’s return type and detect functions that return the wrong
    type, like [Listing 14-17](chapter14.xhtml#list14-17).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    将 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句中的值转换为函数的返回类型，并检测返回错误类型的函数，如
    [Listing 14-17](chapter14.xhtml#list14-17) 所示。
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-17: A function that
    returns a value with an incompatible type</samp>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-17: 返回不兼容类型值的函数</samp>'
- en: Later, when we implement <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    we’ll extend both <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    to accept implicit conversions to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，当我们实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 时，我们将扩展 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>，以接受隐式转换到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 和从 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> 的转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Other Expressions</samp>
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">其他表达式</samp>
- en: We still need to deal with cast expressions, unary operators, and binary operators
    besides <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp>.
    Let’s start with casts. As you learned earlier, it’s illegal to cast a pointer
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to a pointer. If your type checker encounters this kind of cast, it should throw
    an error. Otherwise, it can handle casts to and from pointer types exactly like
    any other cast expression.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要处理类型转换表达式、一元运算符和二元运算符，除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp>。让我们从类型转换开始。如你之前所学，指针不能转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型，或者 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    不能转换为指针。如果类型检查器遇到这种类型转换，它应该抛出一个错误。否则，它可以像处理其他类型的转换表达式一样处理指针类型的转换。
- en: Next, we’ll handle unary operators. Applying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp> operator to
    a pointer is illegal, since negating or taking the bitwise complement of a memory
    address won’t produce a meaningful result. Applying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    operator to a pointer is fine, since it makes sense to compare a memory address
    to zero.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理一元运算符。将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp> 运算符应用于指针是非法的，因为对内存地址取反或按位取反不会产生有意义的结果。而将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> 运算符应用于指针是可以的，因为将内存地址与零进行比较是有意义的。
- en: Binary operators deal with pointers in several different ways. First, we have
    the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Or</samp> operators. The type checking
    logic for these operators won’t change. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>,
    they both accept pointers. Since they don’t convert their operands to a common
    type, they can operate on any combination of pointer and arithmetic operands.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 二元运算符以几种不同的方式处理指针。首先，我们有布尔运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Or</samp>。这些运算符的类型检查逻辑不会改变。像 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> 一样，它们都接受指针。由于它们不会将操作数转换为共同类型，因此可以对指针和算术操作数的任意组合进行操作。
- en: The arithmetic <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Remainder</samp>
    operators, on the other hand, don’t accept pointers. Applying any of these to
    an operand of pointer type should produce an error. Pointer addition and subtraction
    are legal, as are pointer comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp>, but we won’t
    implement them until the next chapter. They won’t come up in this chapter’s tests.
    For now, your compiler can either assume it will never see these expressions or
    explicitly reject them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，算术 <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Remainder</samp>
    运算符不接受指针。将这些运算符应用于指针类型的操作数应该产生一个错误。而指针加法和减法是合法的，指针比较也可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp>，但我们将在下一章实现这些功能。它们在本章的测试中不会出现。现在，你的编译器可以假设它永远不会遇到这些表达式，或者明确拒绝它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tracking Static Pointer
    Initializers in the Symbol Table</samp>
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在符号表中跟踪静态指针初始化器</samp>
- en: 'Now let’s talk about static initializers. Static variables of pointer type,
    like non-static variables, can be initialized to null pointers:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈静态初始化器。像非静态变量一样，指针类型的静态变量可以初始化为空指针：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We therefore need a way to represent a null pointer as a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    in the symbol table. Rather than defining a dedicated construct for null pointers,
    we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(0)</samp>
    initializer, since pointers are unsigned 64-bit integers.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一种方法将空指针表示为符号表中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>。我们将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(0)</samp> 初始化器，而不是定义一个专门用于空指针的构造，因为指针是无符号
    64 位整数。
- en: 'It’s also legal to initialize static variables of pointer type with the address
    of other static variables:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他静态变量的地址来初始化指针类型的静态变量也是合法的：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: However, our implementation won’t support this sort of static initializer; we’ve
    already decided that constant literals are the only static initializers we’ll
    accept.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的实现不支持这种类型的静态初始化器；我们已经决定，只有常量字面量才是我们接受的静态初始化器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>
- en: 'We’ll introduce three new TACKY instructions that operate on pointers in this
    chapter. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>,
    corresponds to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    operator in the AST:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍三条新的 TACKY 指令，这些指令作用于指针。第一条，<samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>，对应
    AST 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 操作符：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This instruction copies the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>—which
    must be a variable, not a constant—into <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>.
    We’ll also add two instructions to dereference pointers:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将 <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> 的地址（必须是一个变量，而不是常量）复制到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>。我们还将添加两条指令来解引用指针：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction takes
    a memory address, <samp class="SANS_TheSansMonoCd_W5Regular_11">src_ptr</samp>,
    as its source operand. It retrieves the current value at that memory address and
    copies it to <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction takes a memory
    address, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_ptr</samp>, as its
    destination operand and writes the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    to that address. [Listing 14-18](chapter14.xhtml#list14-18) defines the complete
    TACKY IR, with the three new instructions bolded.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> 指令将一个内存地址 <samp class="SANS_TheSansMonoCd_W5Regular_11">src_ptr</samp>
    作为源操作数。它从该内存地址获取当前值，并将其复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> 指令将一个内存地址 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_ptr</samp>
    作为目标操作数，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> 的值写入该地址。[示例
    14-18](chapter14.xhtml#list14-18) 定义了完整的 TACKY IR，三条新指令已加粗。
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-18: Adding pointer
    operations to TACKY</samp>'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 14-18：向 TACKY 添加指针操作</samp>
- en: 'It’s tricky to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> to TACKY, because
    these conversions depend on context. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    expression can be used in one of three ways: you can lvalue convert it, assign
    to it, or take its address. We’ll produce different TACKY instructions in each
    of these three cases. Similarly, we’ll process <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    one way if its operand is a variable and a different way if its operand is a dereferenced
    pointer. First, let’s see what instructions we should generate in each case. Then,
    I’ll present a strategy for TACKY conversion that minimizes the number of special
    cases we need to handle.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将<samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>转换为TACKY是很棘手的，因为这些转换依赖于上下文。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>表达式可以有三种用法：你可以将其转换为左值、对其进行赋值或取其地址。我们将在这三种情况下生成不同的TACKY指令。同样地，当<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>的操作数是变量时，我们会以一种方式处理它，而如果操作数是解除引用的指针，则以另一种方式处理它。首先，让我们看看在每种情况下应生成哪些指令。然后，我将提出一种TACKY转换策略，以尽量减少我们需要处理的特殊情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Operations
    in TACKY</samp>
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TACKY中的指针操作</samp>
- en: To dereference a pointer and then lvalue convert the result, we’ll use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction. In this case,
    we can translate the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp> to [Listing 14-19](chapter14.xhtml#list14-19).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要解除引用一个指针并对结果进行左值转换，我们将使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>指令。在这种情况下，我们可以将表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>翻译为[Listing
    14-19](chapter14.xhtml#list14-19)。
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-19: The TACKY implementation
    of a pointer dereference that undergoes lvalue conversion</samp>'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-19：TACKY实现指针解除引用并进行左值转换</samp>
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> when we
    want to assign to a dereferenced pointer instead of lvalue converting it. We’ll
    translate an assignment expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><left></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><right></samp> to [Listing
    14-20](chapter14.xhtml#list14-20).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要对解除引用的指针进行赋值，而不是将其转换为左值时，我们会使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>。我们将把形如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><left></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><right></samp>的赋值表达式翻译为[Listing
    14-20](chapter14.xhtml#list14-20)。
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-20: The TACKY implementation
    of a pointer dereference on the left-hand side of an assignment expression</samp>'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-20：TACKY实现赋值表达式左侧的指针解除引用</samp>
- en: We first calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    which is the address of some object, and <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>,
    which is the value we want to assign to that object. Then, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    to perform the assignment. Note that the single <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction here implements both the deference and assignment operations from
    the original expression.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>，即某个对象的地址，以及<samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp>，即我们想要赋值给该对象的值。然后，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>来执行赋值操作。请注意，这里唯一的<samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>指令实现了原始表达式中的解除引用和赋值操作。
- en: 'Finally, let’s consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expression. If its operand is a variable, we’ll get a pointer to it with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>. Therefore, we’ll translate
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&var</samp> to:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑<samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>表达式。如果它的操作数是变量，我们将使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>获取指向它的指针。因此，我们将把<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&var</samp>翻译为：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: But if the operand is a dereferenced pointer, neither the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    nor the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    expression is evaluated. When we see an expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">&*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>, we’ll translate
    only the inner <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>
    to TACKY.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果操作数是解引用指针，外部的<samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>和内部的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>表达式都不会被求值。当我们看到形式为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>的表达式时，我们只会将内部的<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>翻译成TACKY。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Strategy for TACKY
    Conversion</samp>
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TACKY转换策略</samp>
- en: To manage all these different cases, we’ll use two different functions to convert
    expressions to TACKY. The first is our existing <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>
    function. This function will no longer return a TACKY operand. Instead, it will
    return a new construct, <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>,
    which represents an expression result that hasn’t been lvalue converted. The second
    function, <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>,
    will call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>, lvalue
    convert the result (if it’s an lvalue rather than a constant), and return it as
    a TACKY operand. In most contexts, we’ll process expressions with <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>.
    But to process expressions that shouldn’t be lvalue converted—like the left-hand
    side of assignment expressions—we’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>
    directly.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理所有这些不同的情况，我们将使用两个不同的函数将表达式转换为TACKY。第一个是我们现有的<samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>函数。这个函数不再返回一个TACKY操作数。相反，它将返回一个新的构造体<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>，它表示一个尚未进行左值转换的表达式结果。第二个函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>将调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>，对结果进行左值转换（如果它是一个左值而非常量），并将其作为TACKY操作数返回。在大多数情况下，我们将使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>来处理表达式。但对于那些不应该进行左值转换的表达式——例如赋值表达式的左侧——我们将直接调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>。
- en: 'First, let’s define <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义<samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    represents the object designated by a dereferenced pointer, as the name suggests.
    It takes a single argument: a TACKY operand of pointer type. A <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>
    represents an ordinary constant or variable. Its argument is a TACKY operand of
    any type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>
    construct isn’t a TACKY operand itself, so it doesn’t appear in TACKY instructions.
    It just helps us process <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    and assignment expressions, which operate on objects instead of values. For each
    of these expressions, we’ll generate different instructions depending on whether
    its operand is a dereferenced pointer or a normal variable. In later chapters,
    we’ll add more operators that dereference pointers, like array subscripting and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator to access
    structure members. At that point, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    constructor will be especially useful because it will let us represent the results
    of all of these different operators in a uniform way.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>表示通过解引用指针指定的对象，顾名思义。它接受一个参数：一个TACKY指针类型的操作数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>表示一个普通的常量或变量。它的参数是任何类型的TACKY操作数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>构造体本身不是一个TACKY操作数，因此它不会出现在TACKY指令中。它只是帮助我们处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>和赋值表达式，这些表达式操作的是对象而非值。对于这些表达式，我们将根据其操作数是解引用的指针还是普通变量，生成不同的指令。在后面的章节中，我们将添加更多解引用指针的操作符，比如数组下标和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp>操作符来访问结构体成员。到那时，<samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>构造器将特别有用，因为它将帮助我们以统一的方式表示所有这些不同操作符的结果。
- en: Now let’s update <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>.
    We’ll make a couple of changes throughout this function. First, wherever we currently
    call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> recursively
    on a subexpression—except on the left-hand side of an assignment expression— we’ll
    instead call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>.
    This function will convert the subexpression to TACKY and then lvalue convert
    the result. Second, wherever we currently return a TACKY operand, we’ll wrap that
    operand in a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>
    constructor. [Listing 14-21](chapter14.xhtml#list14-21) shows how to handle unary
    expressions, with this chapter’s changes bolded.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>。我们将在整个函数中进行一些更改。首先，在我们当前对子表达式递归调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> 的地方——除非是在赋值表达式的左侧——我们将改为调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>。该函数将把子表达式转换为
    TACKY，并对结果进行左值转换。其次，在我们当前返回一个 TACKY 操作数的地方，我们将把这个操作数包装在一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>
    构造函数中。[列表 14-21](chapter14.xhtml#list14-21) 展示了如何处理一元表达式，并在本章中标出了更改的部分。
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-21: Translating
    a unary expression to TACKY</samp>'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-21：将一元表达式翻译为 TACKY</samp>
- en: We’ll make the same changes for every kind of expression that <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>
    currently handles.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对 <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> 当前处理的每一种表达式类型进行相同的修改。
- en: Next, let’s deal with <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    expressions. [Listing 14-22](chapter14.xhtml#list14-22) demonstrates how to handle
    these in <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">解引用</samp> 表达式。[列表 14-22](chapter14.xhtml#list14-22)
    演示了如何在 <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> 中处理这些。
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-22: Translating
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Dereference</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">expression to TACKY</samp>'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-22：将</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">解引用</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">表达式翻译为 TACKY</samp>
- en: To process this expression, we first process and lvalue convert its operand.
    This produces a TACKY operand of pointer type, <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>.
    Then, we return a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    to represent the object <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    points to.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个表达式，我们首先处理并进行左值转换它的操作数。这会生成一个指针类型的 TACKY 操作数，<samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>。然后，我们返回一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp> 来表示 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp> 所指向的对象。
- en: After <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> returns
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>, we either
    assign to it, get its address, or lvalue convert it. [Listing 14-23](chapter14.xhtml#list14-23)
    illustrates how to handle assignment.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> 返回一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp> 后，我们要么对其进行赋值，要么获取它的地址，或者进行左值转换。[列表
    14-23](chapter14.xhtml#list14-23) 展示了如何处理赋值。
- en: '[PRE63]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-23: Translating
    an assignment expression to TACKY</samp>'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-23：将赋值表达式翻译为 TACKY</samp>
- en: We don’t lvalue convert the left side of the assignment expression ❶, but we
    do lvalue convert the right side ❷. If the left side is a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>,
    we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction,
    like in earlier chapters ❸. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>,
    we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction
    to write to the location that the inner pointer indicates ❹. Note that even when
    we assign through a pointer, we return a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>
    as the result. That’s because the result of an assignment expression is the value
    stored in the object on the left-hand side, not the object itself.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会对赋值表达式的左侧进行左值转换❶，但会对右侧进行左值转换❷。如果左侧是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>，我们会像之前章节中那样发出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令❸。如果它是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>，我们会发出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> 指令，将数据写入内部指针指向的位置❹。请注意，即使我们通过指针进行赋值，返回的结果仍然是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>。这是因为赋值表达式的结果是存储在左侧对象中的值，而不是对象本身。
- en: We use a similar pattern to process <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>.
    [Listing 14-24](chapter14.xhtml#list14-24) gives the pseudocode.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类似的模式来处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>。 [列表
    14-24](chapter14.xhtml#list14-24) 给出了伪代码。
- en: '[PRE64]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-24: Translating
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddrOf</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">expression to TACKY</samp>'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-24：将</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddrOf</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">表达式翻译成 TACKY</samp>
- en: We process the expression’s operand without lvalue converting it ❶, then pattern
    match on the result to decide how to proceed. If it’s a normal value, we emit
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> instruction
    ❷. If it’s a dereferenced pointer, we drop the dereference and return the pointer
    ❸.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先处理表达式的操作数，但不进行左值转换❶，然后根据结果进行模式匹配，以决定如何继续。如果是一个普通值，我们发出 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    指令❷。如果是一个解引用指针，我们就丢弃解引用，返回指针❸。
- en: Finally, in [Listing 14-25](chapter14.xhtml#list14-25), we define <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>,
    which performs lvalue conversions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 [列表 14-25](chapter14.xhtml#list14-25) 中，我们定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>，它执行左值转换。
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-25: Translating
    an expression to TACKY and performing lvalue conversion</samp>'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-25：将表达式翻译成 TACKY 并执行左值转换</samp>
- en: To lvalue convert a dereferenced pointer, we’ll retrieve its value with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction. Other operands
    can be returned as is, without emitting any extra instructions. A *full expression*,
    which isn’t part of another expression, always undergoes lvalue conversion. That
    means you should use <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and
    _convert</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>,
    to process a full expression and get its result. For example, you’ll use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp> to process
    the controlling expressions in loops and <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要对解引用指针进行左值转换，我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    指令来检索其值。其他操作数可以原样返回，无需发出额外的指令。一个 *完整表达式*，如果它不是另一个表达式的一部分，总是会进行左值转换。这意味着你应该使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>，而不是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>，来处理完整表达式并获取其结果。例如，你将在循环和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>
    来处理控制表达式。
- en: The results of some full expressions—specifically, expression statements and
    the first and third clauses in <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop headers—are not used. As an optimization, you can process these expressions
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>, which saves
    you an unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一些完整表达式的结果——特别是`for`循环头部的表达式语句以及第一个和第三个子句——并未被使用。作为优化，你可以使用`emit_tacky`来处理这些表达式，这样可以节省掉不必要的`Load`指令。
- en: To wrap up this section, we’ll implement casts to and from pointer types. For
    the purposes of casting, we treat pointer types exactly like <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. For example, we cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to any pointer type with a <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>
    instruction and from a pointer type to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>. The TACKY
    implementations of other expressions, like logical operations and comparisons,
    won’t change.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这一节，我们将实现指针类型之间的类型转换。对于类型转换的目的，我们将指针类型视为与`unsigned long`完全相同。例如，我们通过`SignExtend`指令将`int`转换为任何指针类型，通过`Truncate`指令将指针类型转换为`int`。其他表达式的TACKY实现，如逻辑运算和比较操作，将保持不变。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>
- en: In the previous section, we added <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions that
    allow us to read from and write to memory. This means that TACKY has finally caught
    up with assembly, which we’ve been using to read from and write to memory since
    [Chapter 2](chapter2.xhtml). The operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>,
    for example, identifies a location in memory, which we can read or write with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们添加了`Load`和`Store`指令，允许我们从内存中读取和写入数据。这意味着TACKY终于赶上了汇编，正如我们从[第2章](chapter2.xhtml)开始一直在使用汇编读取和写入内存一样。例如，操作数`-4(%rbp)`标识内存中的一个位置，我们可以使用`mov`指令从该位置读取或写入数据。
- en: 'There’s nothing special about RBP, though; we can access memory through an
    address stored in any register. Here’s how to read the value from an address stored
    in the RAX register and copy it into RCX:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 但是RBP并没有什么特别的；我们可以通过存储在任何寄存器中的地址来访问内存。以下是如何从存储在RAX寄存器中的地址读取值并将其复制到RCX：
- en: '[PRE66]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax)</samp> is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0(%rax)</samp>.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`(%rax)`等同于`0(%rax)`。
- en: 'The assembly AST will change slightly to handle operands like <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax)</samp>.
    First, we’ll add the RBP register to the AST:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编的抽象语法树（AST）将略有变化，以处理像`(%rax)`这样的操作数。首先，我们将RBP寄存器添加到抽象语法树中：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we’ll replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operand, which lets us access memory at some offset from the address in RBP, with
    a more generic <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> operand,
    which can use a base address stored in any register:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将替换`Stack`操作数，该操作数允许我们访问RBP中某个偏移地址的内存，换成一个更通用的`Memory`操作数，该操作数可以使用存储在任何寄存器中的基地址：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This makes converting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction to assembly
    very simple. We’ll translate
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得将`Load`或`Store`指令转换为汇编变得非常简单。我们将翻译
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'to:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为：
- en: '[PRE70]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the first instruction, we move the memory address <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    to a register. In the second instruction, we move the value stored at that address,
    which we access with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand, to the destination. In this example, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    into RAX, but any general-purpose register will do (aside from R10, R11, or a
    callee-saved register).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一条指令中，我们将内存地址 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 移动到寄存器中。在第二条指令中，我们将该地址处存储的值（通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> 操作数访问）移动到目标位置。在这个例子中，我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 复制到 RAX，但任何通用寄存器都可以（除了
    R10、R11 或被调用者保存的寄存器）。
- en: Along the same lines, we’ll translate
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 按照同样的思路，我们将翻译
- en: '[PRE71]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'to:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 转到：
- en: '[PRE72]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that when we copy a pointer into a register, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    operand type, since pointers are 8 bytes. But when we copy a value to or from
    the memory location that a pointer indicates, the value’s type determines the
    type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们将指针复制到寄存器时，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    操作数类型，因为指针占 8 个字节。但是，当我们将值从指针所指示的内存位置复制到或复制到该内存位置时，值的类型决定了 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    指令的类型。
- en: 'We’ll implement <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    using a new assembly instruction: <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>,
    which is short for *load effective address*. The instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">lea
    src, dst</samp> copies the *address* of its source (which must be a memory operand)
    to its destination. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">lea
    (%rbp), %rax</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    %rbp, %rax</samp>. You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>
    to get RIP-relative addresses, so'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种新的汇编指令：<samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>（即*加载有效地址*）来实现
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>。指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">lea
    src, dst</samp> 将源操作数（必须是内存操作数）的*地址*复制到目标。举例来说，<samp class="SANS_TheSansMonoCd_W5Regular_11">lea
    (%rbp), %rax</samp> 相当于 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov %rbp,
    %rax</samp>。你还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> 来获取
    RIP 相对地址，因此
- en: '[PRE73]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: stores the address of the symbol <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    in the RAX register.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将符号 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的地址存储在 RAX 寄存器中。
- en: With this new instruction, converting <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    to assembly is straightforward. We’ll translate
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新指令，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> 转换为汇编非常简单。我们将翻译
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'to:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 转到：
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As I mentioned earlier, <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    here must be a memory operand, not a constant or register, for obvious reasons.
    At the moment, we’re guaranteed to satisfy this constraint; we map every pseudoregister
    to a memory address, and the type checker catches any attempts to take the address
    of a constant. But in [Part III](part3.xhtml), when we implement register allocation,
    we’ll store some variables in registers instead of in memory. At that point, it
    will take some extra work to make sure that <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>
    never tries to load the address of a register.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，这里 <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> 必须是内存操作数，而不是常量或寄存器，原因显而易见。目前，我们能够确保满足这一约束；我们将每个伪寄存器映射到一个内存地址，并且类型检查器会捕捉到任何试图取常量地址的操作。但是在[第三部分](part3.xhtml)中，当我们实现寄存器分配时，我们将把一些变量存储在寄存器中，而不是内存中。到那时，我们需要额外的工作来确保
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> 不会尝试加载寄存器的地址。
- en: '[Listing 14-26](chapter14.xhtml#list14-26) defines the whole assembly AST,
    including the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand, <samp class="SANS_TheSansMonoCd_W5Regular_11">BP</samp> register, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-26](chapter14.xhtml#list14-26) 定义了整个汇编抽象语法树（AST），包括新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    操作数、<samp class="SANS_TheSansMonoCd_W5Regular_11">BP</samp> 寄存器和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp>
    指令。'
- en: '[PRE76]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-26: The assembly
    AST with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Memory</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">operand,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">BP</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">register, and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Lea</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp>'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-26：带有</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Memory</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">操作数、</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">BP</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">寄存器和</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Lea</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">指令的汇编AST</samp>
- en: When we translate other TACKY instructions to assembly, we’ll treat pointer
    types exactly like <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>.
    We’ll convert pointer types to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    assembly type, compare pointers with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    instruction, pass return values of pointer type in the RAX register, and pass
    parameters of pointer type in the same general-purpose registers as integer parameters.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将其他TACKY指令转换为汇编时，我们将指针类型视为与 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> 完全相同。我们将指针类型转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    汇编类型，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> 指令比较指针，将指针类型的返回值传递给RAX寄存器，并将指针类型的参数传递给与整数参数相同的一般用途寄存器。
- en: 'We’ll also make one entirely mechanical change: everywhere we previously used
    an operand of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>,
    we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory(BP,</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    instead. [Tables 14-1](chapter14.xhtml#tab14-1) through [14-3](chapter14.xhtml#tab14-3)
    summarize this chapter’s updates to the conversion from TACKY to assembly; as
    usual, new constructs and changes to the conversions for existing constructs are
    bolded.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将进行一次完全机械性的修改：在我们之前使用过的操作数形式 <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    中，我们将改为使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory(BP,</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>。
    [表14-1](chapter14.xhtml#tab14-1) 到 [14-3](chapter14.xhtml#tab14-3) 总结了本章关于TACKY到汇编的转换更新；像往常一样，新构造和现有构造的转换更改都以粗体显示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表14-1：</samp> <samp class="SANS_Futura_Std_Book_11">将顶层TACKY构造转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY顶层构造</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层构造</samp>
    |'
- en: '| --- | --- |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE77]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '|'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE78]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '|'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表14-2：</samp> <samp class="SANS_Futura_Std_Book_11">将TACKY指令转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp>
    |'
- en: '| --- | --- |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Load(ptr, dst)</samp> |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Load(ptr, dst)</samp> |'
- en: '[PRE79]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '|'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Store(src, ptr)</samp> |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Store(src, ptr)</samp> |'
- en: '[PRE80]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '|'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">GetAddress(src, dst)</samp> |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">GetAddress(src, dst)</samp> |'
- en: '[PRE81]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表14-3：</samp> <samp class="SANS_Futura_Std_Book_11">将类型转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">源类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编类型</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">对齐方式</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Pointer(referenced_t)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Quadword</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8</samp>
    |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Pointer(referenced_t)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Quadword</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8</samp>
    |'
- en: Next, we’ll update the pseudoregister replacement and instruction fix-up passes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新伪寄存器替换和指令修正的处理过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters
    with Memory Operands</samp>
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">用内存操作数替换伪寄存器</samp>
- en: We’ll use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand instead of the old <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operand throughout this pass. We’ll also extend this pass to replace pseudoregisters
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction. We
    won’t make any other changes. When we converted TACKY pointer variables to pseudoregisters,
    we assigned them the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    assembly type; now we’ll allocate stack space for them like any other <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整个处理过程中使用新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    操作数，取代旧的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> 操作数。我们还将扩展这个处理过程，替换
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> 指令中的伪寄存器。我们不会做其他更改。当我们将
    TACKY 指针变量转换为伪寄存器时，我们为它们分配了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    汇编类型；现在，我们将像分配其他 <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    一样为它们分配栈空间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the lea
    and push Instructions</samp>
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">修正 lea 和 push 指令</samp>
- en: The destination of the <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>
    instruction must be a register; we’ll rewrite it in the usual fashion. We’ll also
    add a new rewrite rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instructions. As I mentioned in the previous chapter, it’s illegal to <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    an XMM register, so we’ll rewrite an instruction like
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> 指令的目标必须是一个寄存器；我们将按照常规方式重写它。我们还将为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> 指令添加一个新的重写规则。如我在上一章中提到的，不能对
    XMM 寄存器执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> 操作，因此我们将重写类似的指令。
- en: '[PRE82]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'as:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如下：
- en: '[PRE83]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction decrements
    the stack pointer by 8 bytes, then moves its operand to the top of the stack.
    When we can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>, we’ll
    perform the same operation in two instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rsp)</samp> operand designates the memory
    location at the top of the stack.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> 指令将栈指针减去 8 字节，然后将操作数移到栈顶。当我们无法使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> 时，我们将在两条指令中执行相同的操作：先是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>，然后是 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rsp)</samp> 操作数指定栈顶的内存位置。
- en: Because we don’t generate any <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instructions that operate on XMM registers, this rewrite rule isn’t strictly necessary
    yet. It will become necessary once we implement register allocation in [Part III](part3.xhtml);
    then, values that we currently store in memory might be assigned to XMM registers
    instead.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不会生成任何作用于 XMM 寄存器的 <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    指令，所以这个重写规则目前并非严格必要。一旦我们在[第三部分](part3.xhtml)实现寄存器分配，它将变得必要；那时，我们当前存储在内存中的值可能会被分配到
    XMM 寄存器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码生成</samp>
- en: Our final task will be to update the code emission stage to handle the new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand, and <samp class="SANS_TheSansMonoCd_W5Regular_11">BP</samp> register.
    [Tables 14-4](chapter14.xhtml#tab14-4) and [14-5](chapter14.xhtml#tab14-5) summarize
    how to print out these new constructs. (I haven’t bolded new constructs and changes
    in these tables, because all three of these constructs are entirely new.)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终任务是更新代码生成阶段，以处理新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp>
    指令、<samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> 操作数和 <samp class="SANS_TheSansMonoCd_W5Regular_11">BP</samp>
    寄存器。[表 14-4](chapter14.xhtml#tab14-4) 和 [14-5](chapter14.xhtml#tab14-5) 总结了如何输出这些新结构。（我没有在这些表格中加粗新结构和变更，因为这三种结构完全是新的。）
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-4:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 14-4：</samp> <samp class="SANS_Futura_Std_Book_11">汇编指令格式化</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea(src, dst)</samp> |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea(src, dst)</samp> |'
- en: '[PRE84]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-5:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 14-5：</samp> <samp class="SANS_Futura_Std_Book_11">汇编操作数格式化</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(BP)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%rbp</samp>
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(BP)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%rbp</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory(reg, int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><reg></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory(reg, int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><reg></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    |'
- en: We’ll always use the 8-byte aliases for the base register in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand and the destination register in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp>
    instruction, because memory addresses are 8-byte integers.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是使用 8 字节别名来表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    操作数中的基址寄存器和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> 指令中的目标寄存器，因为内存地址是
    8 字节整数。
- en: When the offset in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand is zero, you can either print it or omit it; <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">0(%rax)</samp> are equally valid.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> 操作数中的偏移量为零时，你可以选择打印它或省略它；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rax)</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">0(%rax)</samp>
    都是有效的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you added support for pointers to your compiler. You learned
    how to parse complex declarators into derived types and how to type check operations
    on pointers. During TACKY generation, you established a uniform way to process
    pointer dereference expressions, regardless of how they’re used. On the backend,
    you took the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operand that accessed memory relative to the address in RBP and tweaked it to
    work with addresses stored in any register.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你为编译器添加了对指针的支持。你学习了如何将复杂的声明符解析为派生类型，并如何进行指针操作的类型检查。在 TACKY 生成阶段，你建立了一种统一的方式来处理指针解引用表达式，无论它们如何使用。在后端，你调整了现有的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> 操作数，它访问相对于 RBP 地址的内存，并修改它以支持存储在任意寄存器中的地址。
- en: In the next chapter, you’ll implement arrays, your first non-scalar type. You’ll
    also implement array subscripting and pointer arithmetic and explore the ways
    in which they’re equivalent. Because pointers and arrays are so closely related,
    the concepts, techniques, and instructions introduced in this chapter will be
    crucial in the next chapter too.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将实现数组，这是你遇到的第一个非标量类型。你还将实现数组下标和指针运算，并探索它们之间的等价性。由于指针和数组关系密切，本章中介绍的概念、技术和指令将在下一章中也至关重要。
