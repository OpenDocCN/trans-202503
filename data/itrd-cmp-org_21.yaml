- en: '**21'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**21'
- en: EXCEPTIONS AND INTERRUPTS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 异常与中断**
- en: '![Image](../images/pg495_Image_321.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg495_Image_321.jpg)'
- en: Thus far, we’ve viewed each application as having exclusive use of the computer.
    But like most operating systems, Raspberry Pi OS allows multiple applications
    to run concurrently. It manages the hardware in an interleaved fashion, providing
    each application, and the operating system itself, with the use of the hardware
    components it needs at any given time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将每个应用程序视为独占使用计算机。但与大多数操作系统一样，Raspberry Pi OS允许多个应用程序并行运行。它以交替的方式管理硬件，按照需求为每个应用程序及操作系统本身提供所需的硬件资源。
- en: There are two issues here. First, for the operating system to carry out its
    management tasks, it needs to maintain control over the interaction between applications
    and hardware. It does this by using a system of privilege levels in the CPU that
    allows the operating system to control a gateway between itself and the applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个问题。首先，操作系统为了执行管理任务，必须保持对应用程序与硬件交互的控制。它通过使用CPU中的特权级别系统来实现这一点，从而让操作系统控制其与应用程序之间的网关。
- en: Second, we saw in [Chapter 20](ch20.xhtml) that most I/O devices can interrupt
    the ongoing activity of the CPU when they are ready to provide input or to accept
    output. The CPU has a mechanism to direct I/O interruptions through this gateway
    and invoke functions that are under the control of the operating system, thus
    allowing the operating system to maintain its control over the I/O devices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，在[第20章](ch20.xhtml)中我们看到，大多数I/O设备在准备好提供输入或接受输出时，可以中断CPU正在进行的活动。CPU有一个机制来通过这个网关引导I/O中断，并调用由操作系统控制的功能，从而允许操作系统保持对I/O设备的控制。
- en: In this chapter, I’ll start by discussing how the CPU uses privilege levels
    to enforce its control over the hardware. Then I’ll cover what sorts of events
    can cause a change in the privilege level and how the CPU reacts to such events.
    I’ll end the chapter with a discussion of an instruction that allows applications
    to traverse the gateway between application and system software to directly call
    utility functions in the operating system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将首先讨论CPU如何利用特权级别来强化对硬件的控制。然后，我将讲解什么样的事件会导致特权级别的变化，以及CPU如何响应这些事件。最后，我将以一条指令为结束，讨论这条指令如何让应用程序穿越应用软件与系统软件之间的网关，直接调用操作系统中的实用功能。
- en: A full treatment of this material would require a detailed understanding of
    the internal structure of the operating system and how to program the specific
    hardware you’re using, which is beyond the scope of this book. The goal here is
    to provide you with a very general overview.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对这一材料的全面讨论需要详细了解操作系统的内部结构以及如何编程使用特定的硬件，这超出了本书的范围。这里的目标是为你提供一个非常概括的概览。
- en: '**Application vs. System Software**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**应用软件与系统软件**'
- en: Software can generally be classified as application software or system software.
    We use *application software* for most of what we do on a computer, while *system
    software* manages usage of hardware resources, providing controlled access to
    the hardware by application software.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 软件通常可以分为应用软件和系统软件。我们使用*应用软件*来处理计算机上的大部分任务，而*系统软件*则管理硬件资源的使用，为应用软件提供对硬件的受控访问。
- en: The split between system and application software is maintained by a system
    of *privilege levels*. The operating system executes at a *privileged* level,
    allowing it to manage most of the hardware resources. Application programs execute
    at an *unprivileged* level to prevent them from directly accessing much of the
    hardware. The operating system, being privileged, acts as a supervisor over the
    use of the computer resources by applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 系统软件与应用软件之间的划分是通过*特权级别*系统来维持的。操作系统在*特权*级别上执行，使其能够管理大多数硬件资源。应用程序则在*非特权*级别上执行，以防止它们直接访问大部分硬件。操作系统作为特权程序，充当应用程序对计算机资源使用的监督者。
- en: This separation of privileges allows the operating system to manage the resources
    needed to execute several application programs concurrently. For example, we could
    be running a media application to play music while using an editor application
    to edit a source file. While waiting for us to press another key, the operating
    system lets the media application use the CPU. When we press the key, the operating
    system pauses the media application long enough to read the keystroke and then
    passes control back to the media application while waiting for the very slow (in
    CPU time) human to press the next key.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特权分离使操作系统能够管理执行多个应用程序所需的资源。例如，我们可以运行一个媒体应用程序播放音乐，同时使用编辑器应用程序编辑源文件。在等待我们按下另一个键时，操作系统允许媒体应用程序使用CPU。当我们按下键时，操作系统暂停媒体应用程序足够长的时间来读取按键，然后将控制权交回给媒体应用程序，同时等待非常缓慢（在CPU时间内）的我们按下下一个键。
- en: An *exception* is an event that causes the currently executing code stream to
    be suspended and CPU control to be passed to software running at a privileged
    level. An *interrupt* is a type of exception event that comes from a device connected
    to the CPU. Before discussing what can cause an exception and what takes place
    when one occurs, let’s look at the privilege levels.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常*是指导致当前执行的代码流被暂停，并将CPU控制权交给运行在特权级别软件的事件。*中断*是来自连接到CPU的设备引发的一种异常事件。在讨论可能导致异常的原因以及异常发生时的处理过程之前，让我们先看看特权级别。'
- en: '**NOTE**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although the general concepts are the same, the terminology varies, so you
    need to be mindful when reading the respective manuals. For example, ARM uses*
    exception *as the more general term, with an* interrupt *being a type of exception.
    Intel, on the other hand, uses* interrupt *as the more general term, with an*
    exception *being a type of interrupt.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然一般概念相同，但术语有所不同，因此在阅读相关手册时需要注意。例如，ARM使用*异常*作为更通用的术语，其中*中断*是异常的一种类型。另一方面，Intel使用*中断*作为更通用的术语，而*异常*是中断的一种类型。*'
- en: '**Privilege and Exception Levels**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**特权和异常级别**'
- en: The operating system uses *exception levels* in the CPU to enforce privilege
    levels for the currently executing software. At any given time, the CPU is running
    at one of four possible exception levels. [Table 21-1](ch21.xhtml#ch21tab1) shows
    the levels, from least privileged to most.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统使用*异常级别*来执行当前正在运行的软件的特权级别。任何时候，CPU都在四个可能的异常级别中的一个级别运行。[表21-1](ch21.xhtml#ch21tab1)显示了从最低特权到最高特权的各个级别。
- en: '**Table 21-1:** The AArch64 Exception Levels'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**表21-1：** AArch64异常级别'
- en: '| **Level** | **Usage** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **用途** |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| EL0 | Application programs |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| EL0 | 应用程序 |'
- en: '| EL1 | Operating system |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| EL1 | 操作系统 |'
- en: '| EL2 | Hypervisor |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| EL2 | 虚拟机监控程序 |'
- en: '| EL3 | Firmware/secure monitor |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| EL3 | 固件/安全监视器 |'
- en: Application programs execute with the CPU set at the lowest exception level,
    EL0\. The operating system executes at exception level EL1.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在最低的异常级别EL0下执行。操作系统在异常级别EL1下执行。
- en: A *hypervisor* allows us to run multiple operating systems concurrently on the
    same computer by coordinating their interactions with the hardware resources.
    A hypervisor executes at exception level EL2, giving it supervisorial control
    over the operating systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟机监控程序*允许我们在同一计算机上同时运行多个操作系统，通过协调它们与硬件资源的交互。虚拟机监控程序在异常级别EL2下执行，赋予它对操作系统的监督控制。'
- en: '*Firmware* provides low-level control of device hardware. It’s stored in read-only
    memory and is executed at the highest exception level, EL3\. When the Raspberry
    Pi is first booted up, the CPU starts at EL3 so that it has access to all the
    hardware.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*固件*提供对设备硬件的低级控制。它存储在只读存储器中，并在最高的异常级别EL3下执行。当Raspberry Pi首次启动时，CPU从EL3开始，以便可以访问所有硬件。'
- en: The AArch64 architecture defines a *secure state* and a *non-secure state*.
    All the hardware can be accessed in the secure state, while access is limited
    in the non-secure state. Switching between the two states is controlled by a *secure
    monitor*, which is software that can be executed only when the exception level
    is at EL3.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: AArch64架构定义了*安全状态*和*非安全状态*。在安全状态下，可以访问所有硬件，而在非安全状态下，访问受到限制。两个状态之间的切换由*安全监视器*控制，安全监视器是一种只能在异常级别为EL3时执行的软件。
- en: In [Chapter 20](ch20.xhtml), you learned that the memory management unit (MMU)
    uses a page table to map virtual memory addresses to physical memory addresses.
    The entry in the page table for each virtual memory range includes a 2-bit *access
    permissions (AP)* field for that memory range. [Table 21-2](ch21.xhtml#ch21tab2)
    shows what these permissions are at each CPU exception level.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第20章](ch20.xhtml)中，你学习了内存管理单元（MMU）如何使用页表将虚拟内存地址映射到物理内存地址。页表中的每个虚拟内存范围条目包括一个2位的*访问权限（AP）*字段，用于该内存范围。[表21-2](ch21.xhtml#ch21tab2)展示了每个CPU异常级别下的这些权限。
- en: '**Table 21-2:** The AArch64 Memory Access Permission Levels'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**表21-2：** AArch64内存访问权限级别'
- en: '| **AP** | **EL0 (unprivileged)** | **EL1/2/3 (privileged)** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **AP** | **EL0（非特权）** | **EL1/2/3（特权）** |'
- en: '| --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `00` | No access | Read/write |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `00` | 无访问 | 读/写 |'
- en: '| `01` | Read/write | Read/write |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `01` | 读/写 | 读/写 |'
- en: '| `10` | No access | Read only |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `10` | 无访问 | 只读 |'
- en: '| `11` | Read only | Read only |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `11` | 只读 | 只读 |'
- en: Application programs execute with their instructions and read-only data loaded
    into virtual memory that has its access permission set to `11`. If they have any
    global variables, those are loaded into virtual memory with access permission
    set to `01`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在其指令和只读数据加载到访问权限设置为`11`的虚拟内存中执行。如果它们有任何全局变量，这些变量将被加载到访问权限设置为`01`的虚拟内存中。
- en: The operating system’s instructions and read-only data are loaded into virtual
    memory that has its access permission set to `10`, and its global variables exist
    in virtual memory with access permission set to `00`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的指令和只读数据被加载到访问权限设置为`10`的虚拟内存中，其全局变量则加载到访问权限设置为`00`的虚拟内存中。
- en: You saw an example of dealing with these memory access permissions when programming
    the GPIO device in [Listing 20-2](ch20.xhtml#ch20list2) in [Chapter 20](ch20.xhtml).
    The operating system maps a range of its privileged virtual memory address space
    to the hardware addresses of the GPIO device registers. We used the `mmap` system
    call function to map unprivileged memory in our application program to the operating
    system’s GPIO addressing space so that our application program could access it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第20章](ch20.xhtml)的[清单20-2](ch20.xhtml#ch20list2)中，你看到过如何处理这些内存访问权限的例子，当时是在编程GPIO设备时。操作系统将一段特权虚拟内存地址空间映射到GPIO设备寄存器的硬件地址。我们使用`mmap`系统调用函数，将应用程序中的非特权内存映射到操作系统的GPIO地址空间，以便我们的应用程序能够访问它。
- en: In addition to exception level, the Armv8-A processor has two execution states,
    AArch32 and AArch64, as discussed in the introduction to [Chapter 9](ch09.xhtml).
    The operating system sets the execution state when it first starts up.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异常级别外，Armv8-A处理器还有两种执行状态，AArch32和AArch64，如[第9章](ch09.xhtml)介绍中所述。操作系统在启动时设置执行状态。
- en: Exceptions provide a way to change the execution state. When an exception takes
    the CPU to a higher exception level, we can tell the processor to stay at the
    same execution state or transition to AArch64\. When returning from an exception
    to a lower exception level, we can tell the processor to stay at the same execution
    state or transition to AArch32\. This allows us to run 32-bit applications under
    our 64-bit Raspberry Pi OS but prevents us from running 64-bit applications under
    a 32-bit version of Raspberry Pi OS.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 异常提供了一种改变执行状态的方法。当一个异常将CPU带到更高的异常级别时，我们可以告诉处理器保持当前执行状态或转换到AArch64。在从异常返回到较低的异常级别时，我们可以告诉处理器保持当前执行状态或转换到AArch32。这使得我们可以在64位的树莓派操作系统下运行32位应用程序，但在32位版本的树莓派操作系统下无法运行64位应用程序。
- en: In the next sections, you’ll see how exceptions allow the use of privileged
    software.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将看到异常如何允许使用特权软件。
- en: '**Exception Events**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**异常事件**'
- en: There are several kinds of events that can cause an exception. One of the most
    common causes is when an application program (unprivileged) needs a service provided
    by the operating system (privileged).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种事件可能会导致异常。最常见的原因之一是应用程序（非特权）需要操作系统（特权）提供的服务。
- en: An example is when we call the `write` system call function to display text
    on the screen. As illustrated in [Figure 2-1](ch02.xhtml#ch2fig1) in [Chapter
    2](ch02.xhtml), the `write` function communicates directly with the operating
    system, which in turn sends the characters to the screen. It does this with an
    `svc` instruction, which causes an exception to occur. You’ll see how to use `svc`
    later in this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是当我们调用`write`系统调用函数来在屏幕上显示文本时。如[第2章](ch02.xhtml)中的[图2-1](ch02.xhtml#ch2fig1)所示，`write`函数直接与操作系统通信，操作系统再将字符发送到屏幕。这是通过`svc`指令完成的，它会引发异常。你将在本章后面看到如何使用`svc`。
- en: An exception caused by the `svc` instruction is a *synchronous exception*, which
    is when the timing is synchronized with that of the CPU. Other causes of synchronous
    exceptions include an attempt to execute an instruction that is not valid at the
    current exception level, an attempt to access a memory address that is out of
    the range of the current exception level, and a debugger inserting a breakpoint
    in a program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由`svc`指令引发的异常是*同步异常*，即其时序与CPU的时序同步。其他同步异常的原因包括尝试执行在当前异常级别无效的指令，尝试访问超出当前异常级别范围的内存地址，以及调试器在程序中插入断点。
- en: An *asynchronous exception* is not related to the timing of the CPU. Asynchronous
    exceptions, also called *interrupts*, typically come from an I/O device.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步异常*与CPU的时序无关。异步异常，也称为*中断*，通常来自I/O设备。'
- en: An example of an asynchronous exception is when we use the `read` system call
    function to get characters from the keyboard. As you saw in [Figure 2-1](ch02.xhtml#ch2fig1),
    the `read` function also communicates directly with the operating system. However,
    when the `read` function requests characters from the keyboard, the operating
    system has no idea when the next key will be pressed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 异步异常的一个例子是当我们使用`read`系统调用函数从键盘获取字符时。如[图2-1](ch02.xhtml#ch2fig1)所示，`read`函数也直接与操作系统通信。然而，当`read`函数请求从键盘获取字符时，操作系统无法预知下一个按键何时会被按下。
- en: The operating system notifies the keyboard device controller that it’s waiting
    for a character and places the currently running program in a waiting state. If
    there’s another program ready to run, the operating system gives CPU control to
    that program. When a user finally presses a key on the keyboard, the keyboard
    device controller sends an interrupt signal to the CPU, which causes an exception.
    When the CPU finishes executing the current instruction, it processes the interrupting
    exception, which typically places the waiting program in a ready state.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通知键盘设备控制器它正在等待一个字符，并将当前运行的程序置于等待状态。如果有另一个程序准备运行，操作系统将把CPU控制权交给该程序。当用户按下键盘上的某个键时，键盘设备控制器向CPU发送中断信号，从而引发异常。当CPU完成当前指令的执行后，它会处理该中断异常，通常会将等待的程序置于就绪状态。
- en: Exception processing is done by a piece of code called an *exception handler*.
    The CPU responds to an exception by executing the handler code. Let’s look at
    how the CPU does this.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是由一段称为*异常处理程序*的代码完成的。CPU通过执行处理程序代码来响应异常。我们来看一下CPU是如何做到这一点的。
- en: '**CPU Response to an Exception**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**CPU对异常的响应**'
- en: The processor includes a set of *system registers* that hold the configuration
    settings for the processor. These include registers that hold data needed for
    responding to and handling exceptions. Some of the system registers used for exceptions
    are shown in [Table 21-3](ch21.xhtml#ch21tab3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器包含一组*系统寄存器*，用于保存处理器的配置设置。这些寄存器包括保存响应和处理异常所需数据的寄存器。部分用于异常的系统寄存器如[表21-3](ch21.xhtml#ch21tab3)所示。
- en: '**Table 21-3:** Some of the System Registers for Handling Exceptions'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**表21-3：** 处理异常的部分系统寄存器'
- en: '| **Name** | **Register** | **Usage** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **寄存器** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `currentel` | Current exception level | Bits 3 and 2 hold the exception level
    (`00` for EL0, `01` for EL1, `10` for EL2, `11` for EL3) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `currentel` | 当前异常级别 | 位3和位2保存异常级别（`00`表示EL0，`01`表示EL1，`10`表示EL2，`11`表示EL3）
    |'
- en: '| `elr` | Exception link | Address of instruction that caused the exception
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `elr` | 异常链接 | 引发异常的指令地址 |'
- en: '| `esr` | Exception syndrome | Information about the reasons for the exception
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `esr` | 异常综合 | 关于异常原因的信息 |'
- en: '| `far` | Fault address | Address of access that caused the fault |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `far` | 错误地址 | 引发故障的访问地址 |'
- en: '| `hcr` | Hypervisor configuration | Virtualization settings related to EL2
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `hcr` | 虚拟化配置 | 与 EL2 相关的虚拟化设置 |'
- en: '| `scr` | Secure configuration | Secure state settings related to EL3 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `scr` | 安全配置 | 与 EL3 相关的安全状态设置 |'
- en: '| `sctlr` | System control | Information about the system |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `sctlr` | 系统控制 | 关于系统的信息 |'
- en: '| `spsr` | Saved program status | PSTATE when exception was taken to this exception
    level |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `spsr` | 保存的程序状态 | 异常发生时该异常级别的 PSTATE |'
- en: '| `vbar` | Vector base address | Exception base address for exception taken
    to this exception level |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `vbar` | 向量基地址 | 异常发生时跳转到该异常级别的基地址 |'
- en: These registers are accessible only from software running at a privileged level.
    There is only one `currentel` register. The `hcr` register exists at EL2 and the
    `scr` register at EL3\. The other system registers in this table have instances
    at levels EL1, EL2, and EL3.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些寄存器只能通过在特权级别运行的软件访问。只有一个 `currentel` 寄存器。`hcr` 寄存器位于 EL2，`scr` 寄存器位于 EL3。此表中的其他系统寄存器在
    EL1、EL2 和 EL3 上都有实例。
- en: 'The current exception level of the CPU is determined by bits 3 and 2 in `currentel`.
    The other 62 bits are reserved for possible future use. The content can be loaded
    into a general-purpose register with the `mrs x`d, `currentel` instruction executed
    at a privileged level:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 CPU 的异常级别由 `currentel` 中的第 3 位和第 2 位确定。其他 62 位保留供未来使用。该内容可以通过在特权级别执行 `mrs
    x`d, `currentel` 指令加载到通用寄存器中：
- en: mrs**—Move system register**
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: mrs**—移动系统寄存器**
- en: '`mrs x`d`,` systemreg copies the content of a system register, systemreg, into
    `x`d. Valid only at exception levels EL1 and higher.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`mrs x`d, `systemreg` 将系统寄存器 `systemreg` 的内容复制到 `x`d。仅在异常级别 EL1 及以上有效。'
- en: There is also an `msr` instruction for storing content in some system registers,
    but not the `currentel` register. The content of the 2-bit exception level field
    in the `currentel` register can be changed only by an exception.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `msr` 指令，用于将内容存储到某些系统寄存器中，但不能存储到 `currentel` 寄存器中。`currentel` 寄存器中的 2 位异常级别字段的内容只能通过异常来更改。
- en: 'The exception level can be increased only by an exception event, which can
    either increase the level or keep it the same, except for an exception event at
    EL0, which can only increase the level. The only way to decrease the exception
    level is with the `eret` instruction, which will either decrease the level or
    keep it the same:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 异常级别只能通过异常事件增加，异常事件可以增加级别或保持不变，但 EL0 的异常事件只能增加级别。减少异常级别的唯一方法是使用 `eret` 指令，它将降低级别或保持不变：
- en: eret**—Exception return**
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: eret**—异常返回**
- en: '`eret` restores PSTATE from the `spsr` register for the current exception level
    and loads the address in the `elr` register for the current exception level into
    `pc`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`eret` 从 `spsr` 寄存器恢复当前异常级别的 PSTATE，并将当前异常级别的 `elr` 寄存器中的地址加载到 `pc`。'
- en: PSTATE is an abstraction for the bit settings of the system registers that define
    the current processor state. For example, bits 3 and 2 of the `currentel` register
    are included in PSTATE. The condition flags in the `nzcv` register listed in [Table
    9-2](ch09.xhtml#ch9tab2) in [Chapter 9](ch09.xhtml) are also included in PSTATE.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: PSTATE 是系统寄存器位设置的抽象，定义了当前的处理器状态。例如，`currentel` 寄存器中的第 3 位和第 2 位包含在 PSTATE 中。[第
    9 章](ch09.xhtml)中 [表 9-2](ch09.xhtml#ch9tab2) 中列出的 `nzcv` 寄存器中的条件标志也包含在 PSTATE
    中。
- en: In response to an exception, the CPU performs an operation that is similar to
    the `bl` instruction, but there are some significant differences. The most obvious
    difference is that we specify the address in our program code that the `bl` instruction
    branches to, but an exception causes a branch to a block of code in an *exception
    vector table*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 响应异常时，CPU 执行的操作类似于 `bl` 指令，但有一些显著的不同之处。最明显的区别是，我们在程序代码中指定 `bl` 指令跳转的地址，而异常会导致跳转到
    *异常向量表* 中的一段代码。
- en: An exception vector table has 16 entries, arranged in groups of 4, as shown
    in [Table 21-4](ch21.xhtml#ch21tab4).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 异常向量表有 16 个条目，按 4 个一组排列，如 [表 21-4](ch21.xhtml#ch21tab4) 所示。
- en: '**Table 21-4:** The Entries in an Exception Vector Table'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 21-4：** 异常向量表中的条目'
- en: '| **Offset** | **Type** | **Conditions** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **偏移** | **类型** | **条件** |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0x000` | Synchronous | From current EL while using EL0’s SP |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `0x000` | 同步 | 从当前 EL 使用 EL0 的 SP |'
- en: '| `0x080` | IRQ |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `0x080` | IRQ |  |'
- en: '| `0x100` | FIQ |  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `0x100` | FIQ |  |'
- en: '| `0x180` | SError |  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `0x180` | SError |  |'
- en: '| `0x200` | Synchronous | From current EL while using current level’s SP |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `0x200` | 同步 | 从当前 EL 使用当前级别的 SP |'
- en: '| `0x280` | IRQ |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `0x280` | IRQ |  |'
- en: '| `0x300` | FIQ |  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `0x300` | FIQ |  |'
- en: '| `0x380` | SError |  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `0x380` | SError |  |'
- en: '| `0x400` | Synchronous | From lower EL, next lower EL using AArch64 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `0x400` | 同步 | 从较低的EL，使用AArch64跳转到下一个较低的EL |'
- en: '| `0x480` | IRQ |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `0x480` | IRQ |  |'
- en: '| `0x500` | FIQ |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `0x500` | FIQ |  |'
- en: '| `0x580` | SError |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `0x580` | SError |  |'
- en: '| `0x600` | Synchronous | From lower EL, next lower EL using AArch32 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `0x600` | 同步 | 从较低的EL，使用AArch32跳转到下一个较低的EL |'
- en: '| `0x680` | IRQ |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `0x680` | IRQ |  |'
- en: '| `0x700` | FIQ |  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `0x700` | FIQ |  |'
- en: '| `0x780` | SError |  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `0x780` | SError |  |'
- en: Exception levels EL1, EL2, and EL3 each have their own copies of the 2KiB exception
    vector table shown here. Each of the 16 entries contains the code that handles
    the type and conditions of the exception corresponding to that entry. The length
    of each entry, 128 bytes, allows for up to 32 instructions for the exception handler.
    If more than 32 instructions are needed to handle an exception, a function outside
    the table can be called from the table entry program code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 异常级别EL1、EL2和EL3各自拥有自己的2KiB异常向量表。每个16个条目包含处理与该条目对应的异常类型和条件的代码。每个条目的长度为128字节，可以容纳最多32条异常处理指令。如果需要超过32条指令来处理异常，则可以从该条目程序代码中调用表外的函数。
- en: Each exception vector table is created when the operating system first starts
    up. The address of each table is stored in the vector base address register, `vbar`,
    for its respective exception level. An exception causes a branch to the first
    instruction at the beginning of one of these entries, depending on the type of
    exception and the conditions when the exception occurred.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个异常向量表在操作系统首次启动时创建。每个表的地址存储在相应异常级别的向量基地址寄存器`vbar`中。异常会根据异常类型和异常发生时的条件，跳转到这些条目中某一条目的第一条指令。
- en: A synchronous exception comes from the CPU, as covered in the previous section.
    Of the three types of asynchronous exceptions, an *IRQ* is an interrupt request
    that usually comes from an I/O device controller. In previous versions of the
    ARM architecture, an *FIQ* was a fast interrupt request that also came from an
    I/O device controller but that had a higher priority than an IRQ. Starting with
    the Armv8-A architecture, an FIQ has the same priority as an IRQ; it simply provides
    another path for interrupts. How the two paths are used is dependent on the implementation
    of the architecture.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 同步异常来自CPU，如前一节所述。在三种异步异常中，*IRQ* 是通常来自I/O设备控制器的中断请求。在早期版本的ARM架构中，*FIQ* 是来自I/O设备控制器的快速中断请求，其优先级高于IRQ。从Armv8-A架构开始，FIQ与IRQ具有相同的优先级；它只是提供了另一条中断路径。这两条路径的使用取决于架构的实现。
- en: An *SError* is a system error meant to signal an unexpected event in the memory
    system. The events that cause an SError exception also vary based on the implementation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*SError* 是一种系统错误，用于指示内存系统中发生了意外事件。导致SError异常的事件也会根据实现方式有所不同。'
- en: The entry selected for each type of exception is dependent on whether the exception
    comes from the same exception level or from a lower level. If it’s from the current
    exception level, the selection depends on whether the stack pointer at EL0 or
    at the current exception level is being used.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的异常选择的入口取决于异常是否来自相同的异常级别，或者来自较低的级别。如果异常来自当前异常级别，选择将依赖于是否使用EL0或当前异常级别的堆栈指针。
- en: If the exception comes from a lower exception level, the entry selected depends
    on whether the exception level immediately below the level you’re going to is
    executing in AArch32 or AArch64\. For example, you might have a 32-bit virtual
    machine running alongside a 64-bit operating system. Applications in the 32-bit
    virtual machine run at EL0, and their 32-bit operating system runs at EL1\. An
    exception occurring while in the AArch32 mode that goes to the hypervisor at EL2
    would go to one of the entries in the fourth group in [Table 21-4](ch21.xhtml#ch21tab4).
    All the handlers in this group would be from the 32-bit virtual machine’s operating
    system. The exception handler in the appropriate entry would execute within the
    32-bit operating system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常来自较低的异常级别，则选择的入口取决于紧接着的较低级别是使用AArch32还是AArch64执行。例如，可能有一个32位虚拟机与64位操作系统并行运行。32位虚拟机中的应用程序运行在EL0，而其32位操作系统运行在EL1。当处于AArch32模式时发生的异常，若跳转到EL2的虚拟机监控器（hypervisor），将进入[表21-4](ch21.xhtml#ch21tab4)的第四组中的一个条目。该组中的所有处理程序都来自32位虚拟机的操作系统。适当条目的异常处理程序将在32位操作系统内执行。
- en: The CPU’s response to an exception is based on the assumption that we want to
    return to the place where the execution stream was interrupted by the exception
    and to continue with the CPU in the same state it was in before the exception
    occurred.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: CPU对异常的响应假设我们希望返回到被异常中断的执行流位置，并以异常发生前的状态继续执行CPU。
- en: 'When responding to an exception, the CPU does the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应异常时，CPU执行以下操作：
- en: Saves the contents of PSTATE in the `spsr` register of the exception level it’s
    going to
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PSTATE的内容保存在它即将进入的异常级别的`spsr`寄存器中
- en: Stores the address of the last completed instruction in the `elr` register
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最后执行完的指令地址存储到`elr`寄存器中
- en: For synchronous and system error exceptions, writes the cause to the `esr` register
    of the exception level it’s going to
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于同步和系统错误异常，将原因写入它即将进入的异常级别的`esr`寄存器
- en: For address-related synchronous exceptions, writes the cause to the `far` register
    of the exception level it’s going to
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于地址相关的同步异常，将原因写入它即将进入的异常级别的`far`寄存器
- en: Updates PSTATE to the new exception level
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新PSTATE为新的异常级别
- en: Loads into `pc` the address of the appropriate entry in the exception vector
    table
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将适当条目的地址加载到`pc`寄存器中，指向异常向量表
- en: It’s the responsibility of the exception handler to save and restore any general-purpose
    registers it uses. There is a separate stack pointer register at each exception
    level, so separate stacks can be set up at each level. When executing at EL1,
    EL2, or EL3, either the stack pointer at the current level or the stack pointer
    at EL0 can be used.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理程序负责保存和恢复它使用的任何通用寄存器。每个异常级别都有一个单独的堆栈指针寄存器，因此可以在每个级别设置单独的堆栈。当在EL1、EL2或EL3执行时，可以使用当前级别的堆栈指针或EL0的堆栈指针。
- en: After the exception handler has restored any saved general-purpose registers,
    it uses the `eret` instruction to restore PSTATE to where it was and to return
    to the place where the exception occurred. PSTATE includes the 2-bit exception
    level in the `currentel` register, so this operation also returns the CPU to the
    exception level it came from.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常处理程序恢复所有保存的通用寄存器后，它使用`eret`指令将PSTATE恢复到异常发生前的状态，并返回到异常发生的地方。PSTATE包括在`currentel`寄存器中的2位异常级别，因此此操作还会将CPU返回到它原先所在的异常级别。
- en: Writing an exception handler is an advanced topic beyond the scope of this book,
    but in the next section you’ll see how you can use an exception to call on the
    services of the operating system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编写异常处理程序是一本书超出范围的高级话题，但在下一节中你将看到如何通过异常调用操作系统的服务。
- en: '**Supervisor Calls**'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**监控调用**'
- en: The operating system, being privileged, acts as a supervisor over the resources
    of the computer. When an unprivileged application program needs to use privileged
    resources, it calls upon the operating system using a *supervisor call*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统作为特权实体，负责管理计算机资源。当一个没有特权的应用程序需要使用特权资源时，它通过*监控调用*向操作系统请求服务。
- en: In [Listing 13-3](ch13.xhtml#ch13list3) in [Chapter 13](ch13.xhtml), we used
    the `write` system call function to write `Hello, World!` on the screen one character
    at a time. The `write` function is a C wrapper for a supervisor call. The program
    in [Listing 21-1](ch21.xhtml#ch21list1) is called *freestanding* because it doesn’t
    use any C library functions. Instead, we’re using a supervisor call directly when
    we need the services of the operating system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 13-3](ch13.xhtml#ch13list3)中，[第13章](ch13.xhtml)里我们使用了`write`系统调用函数，将`Hello,
    World!`一个字符一个字符地写到屏幕上。`write`函数是对监控调用的C语言封装。在[清单 21-1](ch21.xhtml#ch21list1)中的程序被称为*独立的*，因为它没有使用任何C语言库函数。相反，当我们需要操作系统的服务时，我们直接使用监控调用。
- en: '*hello_world.s*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world.s*'
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 21-1: The* Hello, World! *freestanding program*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 21-1：* Hello, World! *独立程序*'
- en: 'The `gcc` compiler assumes we are using the C hosted environment and requires
    that the first function be named `main`. Since we’re not using the C libraries,
    we don’t need to use the C hosted environment and can give our function any name
    we wish ❷. After assembling this function, we go directly to the loader and tell
    it where to start execution of the function with the `-e` option:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc`编译器假设我们使用C语言托管环境，并要求第一个函数必须命名为`main`。由于我们没有使用C语言库，我们不需要使用C语言托管环境，可以随意命名我们的函数
    ❷。组装完这个函数后，我们直接进入加载程序，并用`-e`选项告诉它从哪个位置开始执行该函数：'
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we need the operating system to output a character, we use the `svc` instruction
    ❸:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要操作系统输出一个字符时，我们使用`svc`指令 ❸：
- en: svc**—Supervisor call**
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: svc**—超级用户调用**
- en: '`svc` imm causes an exception to be taken from exception level EL0 to EL1\.
    It stores `0x15` in bits 31 through 26 and imm, a 16-bit unsigned integer, in
    bits 15 through 0 of the `esr` register.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`svc` imm 会导致从异常级别 EL0 跳转到 EL1 的异常。它将 `0x15` 存储在 `esr` 寄存器的第 31 到 26 位，并将 imm（一个
    16 位无符号整数）存储在 `esr` 寄存器的第 15 到 0 位。'
- en: Exception level EL1 is handled in the operating system. The `svc` handler uses
    the integer in the `x8` register to determine what action it should take. The
    number for the write operation is `0x40` ❶. The other arguments to the write operation
    in the operating system are the same as those to the C library `write` function.
    The argument to the `svc` instruction, imm, is not used in Linux.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 异常级别 EL1 由操作系统处理。`svc` 处理程序使用 `x8` 寄存器中的整数来确定应采取的操作。写操作的编号是 `0x40` ❶。操作系统中写操作的其他参数与
    C 库中的 `write` 函数参数相同。`svc` 指令的参数 imm 在 Linux 中未使用。
- en: Our `my_hello` function was launched directly by the operating system as a new
    process, not called from the C hosted environment. We terminate this process with
    another supervisor call ❹.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `my_hello` 函数是由操作系统直接启动的一个新进程，而不是从 C 托管环境中调用的。我们通过另一个 supervisor 调用 ❹ 来终止此进程。
- en: Notice that we do not need to create a stack frame or save any registers in
    this freestanding program. The exception handler for `svc` will restore the state
    of the general-purpose registers when it returns. Because this program doesn’t
    return to the C hosted environment, we don’t need to save the `sp` and `fp` registers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个独立的程序中，我们不需要创建栈帧或保存任何寄存器。`svc` 的异常处理程序将在返回时恢复通用寄存器的状态。由于这个程序不会返回到 C 托管环境，我们不需要保存
    `sp` 和 `fp` 寄存器。
- en: 'The numbers for the operating system operations, the arguments to the operations,
    and the registers that these are all passed in are listed at *[https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/](https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/)*.
    There are four tables on this site: x86_64 (64-bit), arm (32-bit), arm64 (64-bit),
    and x86 (32-bit). Make sure you use the arm64 table with this book.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统操作的编号、操作的参数以及传递这些参数的寄存器可以在 *[https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/](https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/)*
    上找到。该网站上有四个表格：x86_64（64 位）、arm（32 位）、arm64（64 位）和 x86（32 位）。确保使用与本书配套的 arm64 表格。
- en: '[Table 21-5](ch21.xhtml#ch21tab5) lists some common `svc` codes.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 21-5](ch21.xhtml#ch21tab5) 列出了常见的 `svc` 代码。'
- en: '**Table 21-5:** Some Register Contents for the `svc` Call'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 21-5：** `svc` 调用的一些寄存器内容'
- en: '| **Operation** | x8 | x0 | x1 | x2 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | x8 | x0 | x1 | x2 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `read` | `0x3f` | File descriptor | Address of character(s) | Number of characters
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `read` | `0x3f` | 文件描述符 | 字符地址 | 字符数量 |'
- en: '| `write` | `0x40` | File descriptor | Address of character(s) | Number of
    characters |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `write` | `0x40` | 文件描述符 | 字符地址 | 字符数量 |'
- en: '| `exit` | `0x5d` | Error code | — | — |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `exit` | `0x5d` | 错误代码 | — | — |'
- en: 'For completeness, here are the instructions that cause an exception to be taken
    to the hypervisor, `hvc`, and to the secure monitor, `smc`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，以下是导致异常跳转到虚拟机监控器的指令 `hvc` 和跳转到安全监控器的指令 `smc`：
- en: hvc**—Hypervisor call**
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: hvc**—虚拟机监控器调用**
- en: '`hvc` imm causes an exception to be taken from exception level EL1 to EL2\.
    It stores `0x16` in bits 31 through 26 and imm, a 16-bit unsigned integer, in
    bits 15 through 0 of the `esr` register.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`hvc` imm 会导致从异常级别 EL1 跳转到 EL2 的异常。它将 `0x16` 存储在 `esr` 寄存器的第 31 到 26 位，并将 imm（一个
    16 位无符号整数）存储在 `esr` 寄存器的第 15 到 0 位。'
- en: smc**—Secure monitor call**
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: smc**—安全监控器调用**
- en: '`smc` imm causes an exception to be taken from exception level EL1 or EL2 to
    EL3\. It stores `0x17` in bits 31 through 26 and imm, a 16-bit unsigned integer,
    in bits 15 through 0 of the `esr` register.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`smc` imm 会导致从异常级别 EL1 或 EL2 跳转到 EL3 的异常。它将 `0x17` 存储在 `esr` 寄存器的第 31 到 26
    位，并将 imm（一个 16 位无符号整数）存储在 `esr` 寄存器的第 15 到 0 位。'
- en: Further details of the exception processing mechanism in the AArch64 architecture
    are complex and beyond the scope of this book. A good next step is reading *Learn
    the Architecture—AArch64 Exception Model*, available at *[https://developer.arm.com/documentation/102412/0103](https://developer.arm.com/documentation/102412/0103)*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: AArch64 架构中的异常处理机制非常复杂，超出了本书的范围。一个好的下一步是阅读 *Learn the Architecture—AArch64 Exception
    Model*，该文档可以在 *[https://developer.arm.com/documentation/102412/0103](https://developer.arm.com/documentation/102412/0103)*
    上找到。
- en: '**YOUR TURN**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 21.1     Pick a program you’ve written in assembly language. Add the instruction
    `mrs x0, currentel` in a place where you know it will be executed. Your program
    should still assemble and link fine, but what happens when you run the program?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 21.1 选择一个你用汇编语言编写的程序。在你知道它将被执行的地方添加指令`mrs x0, currentel`。你的程序仍然可以成功汇编和链接，但当你运行该程序时会发生什么？
- en: 21.2     Modify the three functions `write_char`, `write_str`, and `read_str`
    in “Your Turn” [exercise 14.4](ch14.xhtml#ch14exe4) on [page 293](ch14.xhtml#ch14you1)
    so that they use the `svc` instruction instead of calling the C `write` and `read`
    functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 21.2 修改“你的练习”中的三个函数`write_char`、`write_str`和`read_str`，[练习14.4](ch14.xhtml#ch14exe4)位于[第293页](ch14.xhtml#ch14you1)，使它们使用`svc`指令，而不是调用C语言的`write`和`read`函数。
- en: 21.3     What is the supervisor call number for the `mmap` operation we used
    in [Listing 20-2](ch20.xhtml#ch20list2) in [Chapter 20](ch20.xhtml)?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 21.3 我们在[第20章](ch20.xhtml)中的[代码清单20-2](ch20.xhtml#ch20list2)中使用的`mmap`操作的监控调用号是多少？
- en: '**What You’ve Learned**'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你所学到的**'
- en: '**Privilege levels** The operating system maintains its privilege over the
    hardware resources by tagging memory addresses and running applications with the
    CPU set at a lower exception level.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**特权级别** 操作系统通过标记内存地址和在较低异常级别的CPU上运行应用程序，保持对硬件资源的特权。'
- en: '**Exception levels** The CPU runs software at one of four exception levels:
    from least to most privileged, EL0, EL1, EL2, or EL3.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常级别** CPU以四个异常级别之一运行软件：从最不特权到最特权，依次为EL0、EL1、EL2或EL3。'
- en: '**Exception** An interruption in the currently executing code stream that causes
    CPU control to be passed to software running at a privileged level (EL1–EL3).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常** 当前执行的代码流中发生中断，导致CPU控制权转交给在特权级别（EL1–EL3）运行的软件。'
- en: '**Interrupt** Other hardware devices can interrupt the regular execution cycle
    of the CPU and trigger an exception.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**中断** 其他硬件设备可以中断CPU的常规执行周期，并触发异常。'
- en: svc The instruction that causes an exception in AArch64.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: svc 在AArch64中触发异常的指令。
- en: '**Exception handler** A function in the operating system that gets called by
    the CPU when an exception or interrupt occurs.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常处理程序** 操作系统中的一个函数，当发生异常或中断时，CPU会调用它。'
- en: '**Exception vector table** An array of exception handlers.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常向量表** 一个异常处理程序的数组。'
- en: '**Freestanding program** A program that does not use the C library functions.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**独立程序** 一个不使用C库函数的程序。'
- en: This has been a brief overview of exceptions and interrupts. The details are
    complex and require a thorough knowledge of the specific model of CPU you’re working
    with.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对异常和中断的简要概述。其细节较为复杂，需要对你所使用的CPU的具体型号有深入了解。
- en: This concludes my introduction to computer organization. I hope it has provided
    you with the tools you need to further pursue any of the topics that interest
    you.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我对计算机组织的介绍。我希望它为你提供了继续深入探索你感兴趣的任何主题所需的工具。
