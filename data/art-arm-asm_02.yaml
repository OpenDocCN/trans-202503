- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 1 HELLO, WORLD OF ASSEMBLY LANGUAGE
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 汇编语言的世界，你好
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This “quick-start” chapter gets you writing basic assembly language programs
    as rapidly as possible, giving you the skills you need to learn new assembly language
    features in the following chapters. You’ll learn the foundations of 64-bit ARM
    architecture and the basic syntax of the GNU assembler (Gas) program, a compiler
    for assembly language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个“快速入门”章节，旨在让您尽可能快速地开始编写基本的汇编语言程序，为您学习后续章节中的新汇编语言特性提供必要的技能。您将学习64位ARM架构的基础知识以及GNU汇编器（Gas）程序的基本语法，Gas是一个汇编语言编译器。
- en: You’ll also learn to set aside memory for variables, control the CPU by using
    machine instructions, and link a Gas program with C/C++ code so that you can call
    routines in the C standard library (C stdlib). Gas running under Linux and macOS
    is by far the most common assembler for writing real-world ARM assembly language
    programs. Vendors (especially Apple) have produced variants of Gas with slightly
    different syntax; for instance, under macOS, Gas is known as the *Clang* or *Mach-O*
    assembler. To make the source code in this book portable between macOS and Linux,
    this chapter also introduces a header file, *aoaa.inc*, that eliminates the differences
    between Gas and the Clang assembler.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将学习为变量分配内存、通过使用机器指令控制CPU，并将Gas程序与C/C++代码链接，以便调用C标准库（C stdlib）中的例程。Linux和macOS下运行的Gas汇编器是编写实际ARM汇编语言程序最常用的汇编器。供应商（特别是苹果公司）生产了Gas的变体，具有略微不同的语法；例如，在macOS下，Gas被称为*Clang*或*Mach-O*汇编器。为了使本书中的源代码能够在macOS和Linux之间可移植，本章还介绍了一个头文件*aoaa.inc*，它消除了Gas和Clang汇编器之间的差异。
- en: 1.1 What You’ll Need
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1 您需要的工具
- en: To learn assembly language programming with Gas, you’ll need a version of the
    assembler for your platform, plus a text editor for creating and modifying Gas
    source files, a linker, various library files, and a C++ compiler. You’ll learn
    to set up the Gas assembler and text editor in this section, and the other tools
    later in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Gas学习汇编语言编程，您需要为您的平台准备一个汇编器版本，以及一个文本编辑器，用于创建和修改Gas源文件，还有一个链接器、各种库文件和一个C++编译器。您将在本节中学习如何设置Gas汇编器和文本编辑器，其他工具将在本章后续部分介绍。
- en: 1.1.1 Setting Up Gas
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1 设置Gas
- en: The GNU Compiler Collection (GCC) emits Gas source code as its output (which
    Gas then converts to object code). Therefore, if you have the compiler suite running
    on your system, you also have Gas. Apple macOS uses a compiler based on the LLVM
    compiler suite rather than GCC, so if you have a macOS, you’ll need to install
    its Xcode integrated development environment (IDE) to gain access to the assembler
    (see [Appendix C](appendix-C.xhtml)). Otherwise, if you don’t have the GCC compiler,
    install it with the instructions in your operating system (OS) documentation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: GNU编译器集合（GCC）将Gas源代码作为其输出（然后Gas将其转换为目标代码）。因此，如果您的系统上已经安装了编译器套件，那么您也就拥有了Gas。苹果macOS使用基于LLVM编译器套件的编译器，而不是GCC，因此如果您使用macOS，您需要安装其Xcode集成开发环境（IDE）以访问汇编器（见[附录C](appendix-C.xhtml)）。如果没有GCC编译器，请根据您的操作系统（OS）文档中的说明安装它。
- en: NOTE
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The GNU assembler and the Clang assembler’s executable name is actually* as
    *(assembler). The examples in this book rarely invoke the assembler directly,
    so you won’t use the* as *program often. Therefore, this book refers to the assembler
    by using the name* Gas *rather than* as *(or Clang assembler).*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU汇编器和Clang汇编器的可执行文件名实际上是*as*（汇编器）。本书中的示例很少直接调用汇编器，因此您不会经常使用*as*程序。因此，本书使用*Gas*而不是*as*（或Clang汇编器）来指代汇编器。*'
- en: 1.1.2 Setting Up a Text Editor
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2 设置文本编辑器
- en: To write ARM assembly language programs, you will need some sort of programmer’s
    text editor to create assembly language source files. The choice of editor is
    dictated by personal tastes and editor availability for your OS or development
    suite.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写ARM汇编语言程序，您需要某种程序员文本编辑器来创建汇编语言源文件。编辑器的选择取决于个人喜好以及操作系统或开发套件中可用的编辑器。
- en: The standard suffix for assembly language source files is *.s*, since GCC emits
    this suffix when it converts a C/C++ file into assembly language during compilation.
    For handwritten assembly language source files, the *.S* suffix is a better choice,
    since it tells the assembler to route the source file through the C preprocessor
    (CPP) before assembly. Since this allows the use of CPP macros (#define statements),
    conditional compilation, and other facilities, all example files in this book
    use *.S*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言源文件的标准后缀是 *.s*，因为在编译时，GCC 会在将 C/C++ 文件转换为汇编语言时发出这个后缀。对于手写的汇编语言源文件，*.S* 后缀是更好的选择，因为它告诉汇编器在汇编之前通过
    C 预处理器（CPP）处理源文件。由于这样可以使用 CPP 宏（#define 语句）、条件编译和其他功能，因此本书中的所有示例文件都使用 *.S*。
- en: GCC always produces assembly language output files, which are then processed
    by Gas. GCC automatically invokes the assembler and then deletes the assembly
    source file after the assembly is complete.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 总是生成汇编语言输出文件，然后由 Gas 处理。GCC 会自动调用汇编器，并在汇编完成后删除汇编源文件。
- en: 1.1.3 Understanding C/C++ Examples
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3 理解 C/C++ 示例
- en: Today’s software engineers drop into assembly language only when their C/C++,
    C#, Java, Swift, or Python code is running too slowly and they need to improve
    the performance of certain modules or functions. The examples in this book use
    C/C++ because you’ll typically interface assembly language with C/C++ or other
    high-level language (HLL) code in the real world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件工程师只有在 C/C++、C#、Java、Swift 或 Python 代码运行得过慢，需要提升某些模块或函数的性能时，才会进入汇编语言。书中的示例使用
    C/C++，因为在实际应用中，你通常会将汇编语言与 C/C++ 或其他高级语言（HLL）代码进行接口对接。
- en: The C/C++ standard library is another good reason to use this language. To make
    the C stdlib immediately accessible to Gas programs, I present examples with a
    short C++ main function that calls a single external function written in assembly
    language using Gas. Compiling the C++ main program along with the Gas source file
    produces a single executable file that you can run and test.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 标准库是使用该语言的另一个重要原因。为了让 C 标准库能够立即在 Gas 程序中使用，我提供了一个示例，其中包含一个简短的 C++ 主函数，该函数调用一个用汇编语言编写的外部函数（使用
    Gas）。将 C++ 主程序与 Gas 源文件一起编译，生成一个单独的可执行文件，你可以运行并进行测试。
- en: This book spoon-feeds you the C++ you’ll need to run the example HLL programs,
    so you’ll be able to follow even if you’re not fluent in the language. However,
    you’ll have an easier time if you have a little prior familiarity with C/C++.
    At minimum, this book assumes that you have some experience in a language such
    as Pascal (or Delphi), Java, Swift, Rust, BASIC, Python, or any other imperative
    or object-oriented programming language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书会手把手地教你运行示例高级语言程序所需的 C++，即使你不精通该语言，也能跟得上。不过，如果你对 C/C++ 有一点基础，会更加容易理解。本书至少假设你有使用
    Pascal（或 Delphi）、Java、Swift、Rust、BASIC、Python 或其他任何命令式或面向对象的编程语言的经验。
- en: 1.2 The Anatomy of an Assembly Language Program
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2 汇编语言程序的结构
- en: A typical (stand-alone) Gas program takes the form shown in Listing 1-1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的（独立的）Gas 程序呈现出示例 1-1 所示的形式。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assembly language programs are broken into *sections*. Some sections contain
    data, some contain constants, some contain machine instruction (executable statements),
    and so on. Listing 1-1 contains a single code section, called *text* in macOS
    and Linux. The .text statement ❶ tells the assembler that the following statements
    are associated with the code section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言程序被分为*段*。有些段包含数据，有些包含常量，有些包含机器指令（可执行语句），依此类推。示例 1-1 包含一个单独的代码段，在 macOS 和
    Linux 中称为*text*。`.text` 语句 ❶ 告诉汇编器，接下来的语句属于代码段。
- en: 'In assembly language source files, symbols are usually local or private to
    a source file. When creating an executable source file, you must pass one or more
    symbols to the system linker—at least the name of the main program. You can accomplish
    this by using the .global statement, specifying the global name as an operand:
    _main in the macOS case, main in the Linux case. Leaving out this statement gives
    you an error when you try to compile the source file.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言源文件中，符号通常是局部的或私有的，仅限于某个源文件。在创建可执行源文件时，你必须将一个或多个符号传递给系统链接器——至少是主程序的名称。你可以通过使用
    `.global` 语句来实现，并将全局名称作为操作数指定：在 macOS 中为 _main，在 Linux 中为 main。如果省略这个语句，在尝试编译源文件时会出现错误。
- en: The ARM instruction set requires all machine instructions to begin on a 32-bit
    (4-byte) boundary in memory. Therefore, before the first machine instruction in
    a .text section, tell the assembler to align the addresses on a 4-byte boundary.
    The .align statement ❷ raises 2 to the power specified by its operand and aligns
    the next instruction on that boundary. Since 2² is equal to 4, this statement
    aligns the next instruction on a 4-byte boundary.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 指令集要求所有机器指令在内存中以 32 位（4 字节）边界开始。因此，在 .text 区段中的第一条机器指令之前，您需要告诉汇编器将地址对齐到
    4 字节边界。 .align 语句 ❷ 将其操作数指定的指数作为 2 的幂来对齐下一条指令。由于 2² 等于 4，因此此语句将下一条指令对齐到 4 字节边界。
- en: 'A procedure, or function, in ARM assembly simply consists of the name of that
    function (_main or main in this case) followed by a colon. The machine instructions
    follow. The main program in this example consists of a single machine instruction:
    ret (return). This instruction immediately returns control to whatever called
    the main program—that is, the OS.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ARM 汇编中，一个过程或函数仅由该函数的名称（此例中为_main 或 main）后跟冒号组成。接下来是机器指令。此示例中的主程序由一条机器指令组成：ret（返回）。该指令立即将控制权返回给调用主程序的地方——即操作系统。
- en: Identifiers in Gas are similar to identifiers in most HLLs. Gas identifiers
    may begin with a dollar sign ($), an underscore (_), or an alphabetic character
    and may be followed by zero or more alphanumeric, dollar sign, or underscore characters.
    Symbols are case sensitive.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 中的标识符类似于大多数高级语言中的标识符。Gas 标识符可以以美元符号（$）、下划线（_）或字母字符开头，并且可以后跟零个或多个字母数字、美元符号或下划线字符。符号区分大小写。
- en: While the program in Listing 1-1 doesn’t really *do* anything, you can use it
    to learn how to use the assembler, linker, and other tools necessary for writing
    ARM assembly language programs, as we’ll do in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然清单 1-1 中的程序实际上什么也不做，但您可以通过它学习如何使用汇编器、链接器以及编写 ARM 汇编语言程序所需的其他工具，正如我们将在下一节中所做的那样。
- en: 1.3 Running Your First Assembly Language Program
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3 运行您的第一个汇编语言程序
- en: 'Once you have an assembly source file, you can compile and run that program.
    In theory, you could run the assembler (as) and then the linker (ld, supplying
    appropriate library files needed by the OS). Here’s how that would look for macOS
    (where the $ appearing at the beginning of each line is the OS’s shell prompt):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了汇编源文件，就可以编译并运行该程序。理论上，您可以先运行汇编器（as），然后再运行链接器（ld，提供操作系统所需的适当库文件）。以下是在 macOS
    上的操作示例（每行开头的 $ 是操作系统的 shell 提示符）：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, the command lines differ depending on your OS, and producing an executable
    in this way takes a lot of typing. An easier way to compile the program and produce
    an executable is to use the GCC compiler (g++) by running this command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，命令行在不同的操作系统中有所不同，而且以这种方式生成可执行文件需要大量的输入。更简单的编译程序并生成可执行文件的方法是使用 GCC 编译器（g++），通过运行以下命令：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command line even works on macOS, which uses the Clang compiler rather
    than GCC; macOS has an alias for Clang named g++. On macOS, you could also use
    the clang -o Listing1-1 Listing1-1.S command line. This book, however, will stick
    to the g++ command line, as that works on macOS and Linux.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令行甚至可以在 macOS 上运行，macOS 使用 Clang 编译器而不是 GCC；macOS 为 Clang 创建了一个名为 g++ 的别名。在
    macOS 上，您也可以使用 clang -o Listing1-1 Listing1-1.S 命令行。不过，本书将坚持使用 g++ 命令行，因为它在 macOS
    和 Linux 上都有效。
- en: The g++ command is smart enough to note that this is an assembly language source
    file and run Gas on it to produce an object file. GCC will then run the linker
    (ld) and supply all the default libraries the OS requires.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: g++ 命令足够智能，能够识别这是一个汇编语言源文件，并运行 Gas 来生成目标文件。GCC 接着会运行链接器（ld），并提供操作系统所需的所有默认库。
- en: 'You can run the resulting executable file from the command line as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式从命令行运行生成的可执行文件：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This program immediately returns without any output, since that’s all Listing
    1-1 does; it’s simply intended to demonstrate how to compile and run ARM assembly
    language programs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序立即返回且没有任何输出，因为清单 1-1 只做这件事；它仅仅是用来演示如何编译和运行 ARM 汇编语言程序的。
- en: 'In addition to reducing the amount of typing required, using g++ to assemble
    your assembly language source files provides another advantage: it’s the easiest
    way to run the CPP, which many of the example files in this book require. You
    can invoke the CPP (by itself) on an assembly source file by using a command like
    the following, to see the modifications the CPP makes to your assembly source
    files:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了减少所需输入的字符数外，使用g++来汇编你的汇编语言源文件还提供了另一个好处：它是运行CPP的最简单方式，而本书中的许多示例文件都需要这个CPP。你可以像下面这样单独调用CPP来处理汇编源文件，以查看CPP对你的汇编源文件所做的修改：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can even pipe the output from the CPP to Gas, using the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用以下命令将CPP的输出通过管道传递给Gas：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, at that point, you may as well have typed
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在那时，你完全可以输入
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: as it’s shorter and easier to input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它更短且更易于输入。
- en: 1.4 Running Your First Gas/C++ Hybrid Program
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4 运行你的第一个Gas/C++混合程序
- en: This book commonly combines an assembly language module containing one or more
    functions written in assembly language with a C/C++ main program that calls those
    functions. Because the compilation and execution process is slightly different
    from a stand-alone Gas program, this section demonstrates how to create, compile,
    and run a hybrid assembly/C++ program. Listing 1-2 provides the main C++ program
    that calls the assembly language module.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本书通常将包含一个或多个用汇编语言编写的函数的汇编语言模块与一个调用这些函数的C/C++主程序相结合。由于编译和执行过程与独立的Gas程序略有不同，本节将演示如何创建、编译和运行一个混合汇编/C++程序。列表1-2提供了调用汇编语言模块的主要C++程序。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 1-3, a slight modification of the stand-alone Gas program, contains
    the asmMain() function that the C++ program calls. The main difference between
    Listing 1-3 and Listing 1-1 is that the function’s name changes from _main to
    _asmMain. The C++ compiler and linker would get confused if we continued to use
    the name _main, as that’s also the name of the C++ main function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-3是一个稍微修改过的独立Gas程序，其中包含C++程序调用的asmMain()函数。列表1-3和列表1-1之间的主要区别是函数名从_main更改为_asmMain。如果我们继续使用_main这个名字，C++编译器和链接器会感到困惑，因为_main也是C++主函数的名称。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, to compile and run these source files, run the following commands:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了编译和运行这些源文件，请运行以下命令：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Granted, this assembly language example doesn’t accomplish much other than demonstrate
    how to compile and run some assembly code. To write real assembly code, you’re
    going to need a lot of support code. The next section describes the *aoaa.inc*
    header file that provides some of this support.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这个汇编语言示例除了演示如何编译和运行一些汇编代码外，并没有做太多其他事情。要编写真正的汇编代码，你需要大量的支持代码。下一节将介绍提供部分支持的*aoaa.inc*头文件。
- en: 1.5 The aoaa.inc Include File
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5 aoaa.inc包含文件
- en: The example code in this book was written to be as portable between macOS and
    Linux assemblers as possible, a difficult task requiring considerable advanced
    behind-the-scenes trickery. Many of those tricks are a bit too advanced to easily
    explain to beginning ARM programmers, so I’ve incorporated all this magic code
    in a special header file, *aoaa.inc*, that I use in most of the example programs
    from this point forward.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例代码旨在尽可能使macOS和Linux汇编器之间的代码具有可移植性，这是一项艰巨的任务，需要相当多的幕后高级技巧。许多这些技巧对于初学者ARM程序员来说有些过于高级，因此我将所有这些魔法代码包含在一个特殊的头文件*aoaa.inc*中，从此以后我会在大部分示例程序中使用它。
- en: 'This human-readable include file is little more than a typical advanced C/C++
    header file; it just contains a bunch of macros (for example, C/C++ #define statements)
    that help smooth out some of the differences between the macOS and Linux versions
    of the assembler. By the time you get to the end of this book (especially by the
    time you read [Chapter 13](chapter13.xhtml)), most of the material in the header
    file will make perfect sense. For now, I won’t distract you with advanced macros
    and conditional assembly information.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个人类可读的包含文件几乎和典型的高级C/C++头文件一样；它仅包含一些宏（例如C/C++的#define语句），帮助平滑处理macOS和Linux版本的汇编器之间的差异。当你读到本书的最后（特别是当你阅读[第13章](chapter13.xhtml)时），头文件中的大部分内容将变得完全清晰。现在，我不会用高级宏和条件汇编的信息来分散你的注意力。
- en: You can find *aoaa.inc* along with all the other example code at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*.
    If you’re curious about this file’s content and don’t want to wait for [Chapter
    13](chapter13.xhtml), load it into a text editor and take a look.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在* [https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)
    *找到*aoaa.inc*及所有其他示例代码。如果你对这个文件的内容感兴趣，并且不想等到[第13章](chapter13.xhtml)，可以将其加载到文本编辑器中查看。
- en: 'To include this file in an assembly, use the following CPP statement in your
    assembly language source files:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要在汇编中包含此文件，请在你的汇编语言源文件中使用以下 CPP 语句：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just as in C/C++, this statement will automatically insert the content of this
    file into the current source file during assembly (at the point of the #include
    statement).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '就像在 C/C++ 中一样，这条语句将在汇编时自动将该文件的内容插入到当前源文件中（在 #include 语句处）。'
- en: 'Gas has its own include statement, used as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 有自己的 include 语句，使用方法如下：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, don’t use this statement to include *aoaa.inc* in your source files.
    The Gas .include directive executes after the CPP runs, but *aoaa.inc* contains
    CPP macros, conditional compilation statements, and other code that must be processed
    by the CPP. If you use the .include directive rather than #include, the CPP will
    never see the contents of the *aoaa.inc* file, and Gas will generate errors when
    it processes the file.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，不要使用这个语句在源文件中包含 *aoaa.inc*。Gas 的 .include 指令在 CPP 运行之后执行，但 *aoaa.inc* 包含
    CPP 宏、条件编译语句和其他必须由 CPP 处理的代码。如果你使用 .include 指令而不是 #include，CPP 将无法看到 *aoaa.inc*
    文件的内容，而 Gas 在处理该文件时会产生错误。'
- en: 'The *aoaa.inc* file must be present in the same directory as your assembly
    source file during the assembly process (or you must supply an appropriate path
    to the file in the #include "aoaa.inc" statement). If the header file isn’t in
    the current directory, Gas will complain that it can’t find the file and terminate
    the assembly. Also remember to use the *.S* suffix with your assembly source files
    when using #include "aoaa.inc", or GCC won’t run the CPP on those files.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '在汇编过程中，*aoaa.inc* 文件必须与汇编源文件位于同一目录（或者你必须在 #include "aoaa.inc" 语句中提供文件的适当路径）。如果头文件不在当前目录，Gas
    会提示找不到文件并终止汇编。还要记得在使用 #include "aoaa.inc" 时，使用 *.S* 后缀命名你的汇编源文件，否则 GCC 不会对这些文件运行
    CPP。'
- en: '### 1.6 The ARM64 CPU Architecture'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '### 1.6 ARM64 CPU 架构'
- en: Thus far, you’ve seen a pair of Gas programs that compile and run. However,
    the statements appearing in those programs do nothing more at this point than
    return control to the OS. Before you learn some real assembly language, you’ll
    need to understand the basic structure of the ARM CPU family so you can follow
    the machine instructions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了成对的 Gas 程序，它们能够编译并运行。然而，这些程序中出现的语句目前仅仅是在将控制权返回给操作系统。在你学习一些真正的汇编语言之前，你需要了解
    ARM CPU 家族的基本结构，这样你才能理解机器指令。
- en: 'The ARM CPU family is generally classified as a Von Neumann architecture machine.
    Von Neumann computer systems contain three main building blocks: the *central
    processing unit (CPU)*, *memory*, and *input/output (I/0) devices*. These three
    components are interconnected via the *system bus* (consisting of the address,
    data, and control buses). [Figure 1-1](chapter1.xhtml#fig1-1) shows this relationship.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU 家族通常被归类为冯·诺依曼架构机器。冯·诺依曼计算机系统包含三个主要组成部分：*中央处理单元（CPU）*、*内存*和*输入/输出（I/O）设备*。这三个组件通过*系统总线*（由地址、数据和控制总线组成）相互连接。[图
    1-1](chapter1.xhtml#fig1-1)展示了这种关系。
- en: '![](../images/Figure1-1.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-1.jpg)'
- en: 'Figure 1-1: A Von Neumann computer system block diagram'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：冯·诺依曼计算机系统框图
- en: The CPU communicates with memory and I/O devices by placing a numeric value
    on the address bus to select one of the memory or I/O device port locations, each
    of which has a unique binary numeric *address*. Then the CPU, memory, and I/O
    devices pass data among themselves by placing the data on the data bus. The control
    bus contains signals that determine the direction of the data transfer (to/from
    memory and to/from an I/O device).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 通过在地址总线上放置一个数字值来选择内存或 I/O 设备端口位置，从而与内存和 I/O 设备通信，每个位置都有一个唯一的二进制数字*地址*。然后，CPU、内存和
    I/O 设备通过将数据放置在数据总线上相互传递数据。控制总线包含决定数据传输方向（到/从内存和到/从 I/O 设备）的信号。
- en: 1.6.1 ARM CPU Registers
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.1 ARM CPU 寄存器
- en: 'There are two categories of ARM CPU registers: *general-purpose registers*
    and *special-purpose kernel-mode registers*. The special-purpose registers are
    intended for writing OSes, debuggers, and other system-level tools. Such software
    construction is well beyond the scope of this text.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU寄存器分为两类：*通用寄存器*和*特殊用途内核模式寄存器*。特殊用途寄存器是为编写操作系统、调试器及其他系统级工具而设计的。这类软件的构建远远超出了本文的范围。
- en: The ARM64 supports 32 general-purpose 64-bit registers (named X0 through X31)
    and 32 general-purpose 32-bit registers (named W0 through W31). This doesn’t imply
    there are 64 registers total; instead, the 32-bit registers overlay the low-order
    (LO) 32 bits of each of the 64-bit registers. ([Chapter 2](chapter2.xhtml) discusses
    LO components in more depth.) Modifying one of the 32-bit registers also modifies
    the corresponding 64-bit register, and vice versa, as outlined in [Figure 1-2](chapter1.xhtml#fig1-2).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ARM64支持32个通用64位寄存器（命名为X0至X31）和32个通用32位寄存器（命名为W0至W31）。这并不意味着总共有64个寄存器；相反，32位寄存器覆盖了每个64位寄存器的低32位部分。([第2章](chapter2.xhtml)将更深入地讨论低位（LO）部分。)
    修改其中一个32位寄存器也会修改对应的64位寄存器，反之亦然，具体请参见[图1-2](chapter1.xhtml#fig1-2)。
- en: '![](../images/Figure1-2.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-2.jpg)'
- en: 'Figure 1-2: The 32- and 64-bit registers on the ARM'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2：ARM上的32位和64位寄存器
- en: Those new to assembly language are often surprised that all calculations on
    the ARM64 involve a register. For example, to add two variables together, storing
    the sum into a third variable, you must load one of the variables into a register,
    add the second operand to the value in the register, and then store the register
    away in the destination variable. Registers are a middleman in nearly every calculation,
    so they’re important in ARM64 assembly language programs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚接触汇编语言的人来说，通常会惊讶于在ARM64上所有的计算都涉及一个寄存器。例如，要将两个变量相加，并将和存储到第三个变量中，你必须将其中一个变量加载到寄存器中，将第二个操作数加到寄存器中的值，然后将寄存器的值存储到目标变量中。寄存器几乎参与了每一个计算过程，因此它们在ARM64汇编语言程序中非常重要。
- en: 'Although these registers are known as *general-purpose* registers, a few of
    them have special purposes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些寄存器被称为*通用寄存器*，但其中有一些具有特殊用途：
- en: X31, usually referred to as *SP* in code, is called the *stack pointer*, since
    it’s used to maintain a *hardware stack* on the ARM (another non-RISC, or reduced
    instruction set computer, feature), always as a 64-bit register. Because it’s
    used as the stack pointer, SP cannot be used for other purposes in most code.
    This register is accessible only by a few instructions.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X31，在代码中通常称为*SP*，是*栈指针*，因为它用于在ARM上维护*硬件栈*（另一个非RISC或精简指令集计算机的特性），始终作为64位寄存器使用。由于它被用作栈指针，因此在大多数代码中，SP不能用于其他用途。此寄存器只能通过少数指令访问。
- en: The XZR/WZR register (also treated as X31/W31 by the hardware) is called the
    *zero* register. It always returns 0 when read and is a convenient way to obtain
    the constant 0 in a program.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XZR/WZR寄存器（硬件上也称为X31/W31）被称为*零寄存器*。它在读取时总是返回0，是程序中获取常量0的便捷方式。
- en: Register X30 is the *link register*, referred to by the name *LR* rather than
    X30\. The ARM CPU uses this register to hold *return addresses* when the code
    makes a function call. ([Chapter 5](chapter5.xhtml) discusses the LR in greater
    detail.) This register is also always accessed in 64-bit mode. While you could
    theoretically use X30/W30 as a general-purpose register, you should avoid doing
    so, because function calls will wipe out the value in this register.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器X30是*链接寄存器*，通常用*LR*而不是X30来表示。ARM CPU使用这个寄存器保存*返回地址*，当代码执行函数调用时。([第5章](chapter5.xhtml)将更详细地讨论LR。)
    此寄存器始终在64位模式下访问。虽然理论上你可以将X30/W30作为通用寄存器使用，但应该避免这样做，因为函数调用会清除此寄存器中的值。
- en: Although this special purpose isn’t enforced by the hardware, most software
    uses X29 as a 64-bit *frame pointer (FP)*. Software generally uses this register
    to provide access to function parameters and local variables. Technically, you
    could use any of the general-purpose registers for this purpose, but using X29/FP
    is conventional.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这个特殊用途不是硬件强制要求的，但大多数软件将X29用作64位的*帧指针（FP）*。软件通常使用这个寄存器来访问函数参数和局部变量。从技术上讲，你可以使用任何通用寄存器来实现这一目的，但使用X29/FP是惯例。
- en: Apple reserves X18 for its own internal purposes. Programs written for macOS,
    iOS, iPadOS, and so on must not use this register. Since 29 other registers are
    available, the examples in this book don’t use X18, even for Linux examples.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple为其内部用途保留了X18寄存器。为macOS、iOS、iPadOS等编写的程序不得使用此寄存器。由于还有29个其他寄存器可用，本书中的示例不使用X18，即使是Linux示例也是如此。
- en: 'In addition to the 32 general-purpose registers, the ARM64 CPUs have two additional
    special-purpose registers accessible to user programs: the 32-bit *processor state
    (PSTATE)* register and the 64-bit *program counter (PC)* register. The PC register
    always contains the address of the machine instruction being executed. Because
    instructions are always 32 bits long, the CPU will increment this register by
    4 whenever it finishes the execution of one instruction and moves on to the next
    (more on this activity in [Chapter 2](chapter2.xhtml)).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了32个通用寄存器，ARM64 CPU还拥有两个额外的特殊用途寄存器，用户程序可以访问：32位的*处理器状态（PSTATE）*寄存器和64位的*程序计数器（PC）*寄存器。PC寄存器始终包含正在执行的机器指令的地址。由于指令始终是32位长，CPU在每次执行完一条指令并进入下一条指令时，会将该寄存器的值增加4（有关此活动的更多内容，请参见[第2章](chapter2.xhtml)）。
- en: NOTE
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*32-bit ARM CPUs refer to the PSTATE register as the* CPSR *or* PSR*. You may
    see references to those names in various documents.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*32位ARM CPU将PSTATE寄存器称为* CPSR *或* PSR*。你可能会在各种文档中看到这些名称的引用。*'
- en: The PSTATE register is 32 bits wide (of which only 16 bits are used at the time
    of this writing) and is really just a collection of individual Boolean flags.
    Its layout appears in [Figure 1-3](chapter1.xhtml#fig1-3).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: PSTATE寄存器宽度为32位（其中只有16位在写作时被使用），实际上它只是由一组单独的布尔标志组成。其布局如[图1-3](chapter1.xhtml#fig1-3)所示。
- en: '![](../images/Figure1-3.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-3.jpg)'
- en: 'Figure 1-3: The PSTATE register layout'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3：PSTATE寄存器布局
- en: 'Most user applications use only the N, Z, C, and V bits in the PSTATE register.
    These bits, also known as the *condition codes*, have the following meanings:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户应用程序仅使用PSTATE寄存器中的N、Z、C和V位。这些位也称为*条件码*，它们具有以下含义：
- en: '**N**    Negative (sign) flag, set when an instruction produces a negative
    result'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**N**    负数（符号）标志，当指令产生负结果时设置'
- en: '**Z**    Zero flag, set when an instruction produces a zero result'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Z**    零标志，当指令产生零结果时设置'
- en: '**C**    Carry flag, set when an unsigned arithmetic overflow occurs'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**C**    进位标志，发生无符号算术溢出时设置'
- en: '**V**    Overflow flag, set when a signed arithmetic overflow occurs'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**V**    溢出标志，发生带符号算术溢出时设置'
- en: Most of the remaining flags are inaccessible or of little use in user programs.
    UAO and PAN control CPU access features, allowing user programs to access kernel
    memory. SS is the single-step control bit for debugging. IL is the illegal instruction
    flag, set when the CPU executes an illegal instruction. D, A, I, and F are interrupt
    flags. cEL selects an exception level, usually 00 for user mode. SPS selects a
    stack pointer to use (kernel versus user mode).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其余大多数标志对用户程序不可访问或几乎没有用处。UAO和PAN控制CPU的访问特性，允许用户程序访问内核内存。SS是调试时的单步控制位。IL是非法指令标志，当CPU执行非法指令时设置。D、A、I和F是中断标志。cEL选择异常级别，通常用户模式为00。SPS选择要使用的堆栈指针（内核与用户模式）。
- en: In addition to the 32 general-purpose registers, the ARM64 provides 32 floating-point
    and vector registers to handle nonintegral arithmetic. [Chapters 6](chapter6.xhtml)
    and [11](chapter11.xhtml) discuss these registers in greater detail when covering
    floating-point arithmetic and single-instruction/multiple data (SIMD) operations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了32个通用寄存器，ARM64还提供了32个浮点寄存器和向量寄存器，用于处理非整数算术运算。[第6章](chapter6.xhtml)和[第11章](chapter11.xhtml)在讨论浮点运算和单指令/多数据（SIMD）操作时，会更详细地讨论这些寄存器。
- en: 1.6.2 The Memory Subsystem
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.2 内存子系统
- en: A typical ARM64 processor running a modern 64-bit OS can access a maximum of
    2^(48) memory locations, or just over 256TB—probably far more than any of your
    programs will ever need. Since the ARM64 supports byte-addressable memory, the
    basic memory unit is a byte, which is sufficient to hold a single character or
    a very small integer value (discussed further in [Chapter 2](chapter2.xhtml)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一台运行现代64位操作系统的典型ARM64处理器可以访问最多2^(48)个内存位置，约为256TB——这可能远远超过你的任何程序所需的内存。由于ARM64支持字节寻址内存，基本的内存单元是字节，足以容纳一个字符或一个非常小的整数值（在[第2章](chapter2.xhtml)中有进一步讨论）。
- en: Because 2^(48) is a frightfully large number, the following discussion uses
    the 4GB address space of 32-bit ARM processors. Scaled up, the same discussion
    applies to 64-bit ARM processors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 2^(48) 是一个非常大的数字，以下讨论使用的是 32 位 ARM 处理器的 4GB 地址空间。将其扩展后，相同的讨论适用于 64 位 ARM
    处理器。
- en: NOTE
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*While the ARM64 supports 64 address bits in software, the hardware supports
    only 48 to 52 address bits for virtual memory operations. Most OSes limit this
    to 48 bits.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然 ARM64 在软件中支持 64 位地址，但硬件仅支持 48 到 52 位地址用于虚拟内存操作。大多数操作系统将其限制为 48 位。*'
- en: 'Think of memory as a linear array of bytes. The address of the first byte is
    0, and the address of the last byte is 2^(32) – 1\. For an ARM processor, the
    following pseudo-Pascal array declaration is a good approximation of memory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存视为一个线性字节数组。第一个字节的地址是 0，最后一个字节的地址是 2^(32) – 1。对于 ARM 处理器，以下伪 Pascal 数组声明是内存的一个很好的近似：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'C/C++ and Java users might prefer the following syntax:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 和 Java 用户可能更喜欢以下语法：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To execute the equivalent of the Pascal statement Memory [125] := 0;, the CPU
    places the value 0 on the data bus, places the address 125 on the address bus,
    and asserts the write line (which generally involves setting that line to 0),
    as shown in [Figure 1-4](chapter1.xhtml#fig1-4).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行等同于 Pascal 语句 Memory [125] := 0; 的操作，CPU 将值 0 放到数据总线中，将地址 125 放到地址总线中，并且触发写入线（通常是将该线设置为
    0），如 [图 1-4](chapter1.xhtml#fig1-4) 所示。
- en: '![](../images/Figure1-4.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-4.jpg)'
- en: 'Figure 1-4: The memory write operation'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-4：内存写操作
- en: To execute the equivalent of CPU := Memory [125];, the CPU places the address
    125 on the address bus, asserts the read line (because the CPU is reading data
    from memory), and reads the resulting data from the data bus (see [Figure 1-5](chapter1.xhtml#fig1-5)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行等同于 CPU := Memory [125]; 的操作，CPU 将地址 125 放到地址总线中，触发读取线（因为 CPU 正在从内存读取数据），然后从数据总线中读取相应的数据（见
    [图 1-5](chapter1.xhtml#fig1-5)）。
- en: '![](../images/Figure1-5.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-5.jpg)'
- en: 'Figure 1-5: The memory read operation'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-5：内存读取操作
- en: This discussion applies only when accessing a single byte in memory. To store
    values larger than a single byte, like *half words* (2 bytes) and *words* (4 bytes),
    the ARM uses a sequence of consecutive memory locations, as shown in [Figure 1-6](chapter1.xhtml#fig1-6).
    The memory address is the address of each object’s first byte (that is, the lowest
    address).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论仅适用于访问内存中的单个字节。要存储大于单字节的值，如*半字*（2 字节）和*字*（4 字节），ARM 使用一系列连续的内存位置，如 [图 1-6](chapter1.xhtml#fig1-6)
    所示。内存地址是每个对象的第一个字节的地址（即最低地址）。
- en: '![](../images/Figure1-6.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-6.jpg)'
- en: 'Figure 1-6: Byte, half-word, and word storage in memory'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-6：内存中的字节、半字和字存储
- en: The ARM64 generally supports *unaligned memory access*, meaning the CPU can
    read or write an object of any size—byte, half word, word, or double word (dword)—at
    any address in memory. Certain instructions, however, require that memory access
    be aligned on the natural size of the transfer. Generally, this means that 16-,
    32-, and 64-bit memory accesses must take place on addresses that are a multiple
    of 2, 4, or 8; otherwise, the CPU may raise an exception. Regardless of exceptions,
    the CPU can usually access memory locations aligned on a natural boundary faster.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ARM64 通常支持*非对齐内存访问*，意味着 CPU 可以在内存的任何地址读取或写入任意大小的对象——字节、半字、字或双字（dword）。然而，某些指令要求内存访问在传输的自然大小上对齐。通常，这意味着
    16 位、32 位和 64 位内存访问必须在 2、4 或 8 的倍数地址上进行；否则，CPU 可能会引发异常。无论是否发生异常，CPU 通常能更快地访问在自然边界上对齐的内存位置。
- en: Modern ARM processors don’t connect directly to memory. Instead, a special memory
    buffer on the CPU known as the *cache* (pronounced “cash”) acts as a high-speed
    intermediary between the CPU and main memory. You’ll learn to set the alignment
    of memory objects and the effects of the cache on data alignment in [Chapter 3](chapter3.xhtml).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 ARM 处理器不会直接连接到内存。相反，CPU 上有一个特殊的内存缓冲区，称为*缓存*（发音为“cash”），它充当 CPU 和主内存之间的高速中介。你将在[第
    3 章](chapter3.xhtml)中学习如何设置内存对象的对齐方式以及缓存对数据对齐的影响。
- en: 1.7 Declaring Memory Variables in Gas
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7 在 Gas 中声明内存变量
- en: Referencing memory by using numeric addresses in assembly language is possible,
    but painful and error-prone. Rather than having your program state, “Give me the
    32-bit value held in memory location 192 and the 16-bit value held in memory location
    188,” it’s much nicer to state, “Give me the contents of elementCount and portNumber.”
    Using variable names, rather than memory addresses, makes your program much easier
    to write, read, and maintain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中使用数字地址引用内存是可行的，但很痛苦且容易出错。与其让程序说，“给我内存位置 192 中保存的 32 位值和内存位置 188 中保存的 16
    位值”，不如说，“给我元素计数（elementCount）和端口号（portNumber）的内容”。使用变量名而非内存地址，使程序更容易编写、阅读和维护。
- en: To create (writable) data variables, you have to put them in a data section
    of the Gas source file, defined using the .data directive. The .data directive
    tells Gas that all following statements (up to the next .text or other section-defining
    directive) will define data declarations to be grouped into a read/write section
    of memory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建（可写的）数据变量，必须将它们放置在 Gas 源文件的数据部分中，该部分通过 `.data` 指令定义。`.data` 指令告诉 Gas，接下来的所有语句（直到下一个
    `.text` 或其他定义节的指令）将定义数据声明，并将这些声明分组到内存的读/写部分。
- en: Within a .data section, Gas allows you to declare variable objects by using
    a set of data declaration directives. The basic form of a data declaration directive
    is
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.data` 部分中，Gas 允许你通过一组数据声明指令声明变量对象。数据声明指令的基本形式是：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'where label is a legal Gas identifier and directive is one of the directives
    in the following list:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，label 是合法的 Gas 标识符，directive 是以下列表中的某个指令之一：
- en: .byte    Byte (8-bit) values. One or more comma-separated 8-bit expressions
    appear in the operand field (values).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`.byte    字节（8位）值。一个或多个用逗号分隔的 8 位表达式出现在操作数字段中（值）。'
- en: .hword**,** .short**,** .2byte    Half-word (16-bit) values. One or more comma-separated
    16-bit expressions appear in the operand field.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`.hword**，** .short**，** .2byte    半字（16位）值。一个或多个用逗号分隔的 16 位表达式出现在操作数字段中。'
- en: .word**,** .4byte    Word (32-bit) values. One or more comma-separated 32-bit
    expressions appear in the operand field.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`.word**，** .4byte    字（32位）值。一个或多个用逗号分隔的 32 位表达式出现在操作数字段中。'
- en: .quad**,** .8byte    Dword (64-bit) values. One or more comma-separated 64-bit
    expressions appear in the operand field. .quad is an unfortunate misnomer for
    ARM64, since a 64-bit value is actually a double word, not a quad word (on the
    ARM, a quad word is 128 bits). The term predates the ARM assembler, coming from
    “quad word” in the x86 and 68000 assembly language days. To avoid confusion, this
    book uses the .dword directive in place of .quad.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`.quad**，** .8byte    双字（64位）值。一个或多个用逗号分隔的 64 位表达式出现在操作数字段中。`.quad` 是 ARM64
    的一个不幸的误称，因为 64 位值实际上是双字，而不是四字（在 ARM 中，四字是 128 位）。这个术语源自 x86 和 68000 汇编语言时代的“quad
    word”。为了避免混淆，本书使用 `.dword` 指令代替 `.quad`。'
- en: .dword    The .dword macro appearing in the *aoaa.inc* include file is a synonym
    for the .quad directive that emits 8 bytes (64 bits) for each operand. Using .dword
    is preferable to .quad. You must include the *aoaa.inc* file in order to use this
    directive.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dword    在 *aoaa.inc* 包含文件中出现的 `.dword` 宏是 `.quad` 指令的同义词，它为每个操作数发出 8 字节（64
    位）。使用 `.dword` 比使用 `.quad` 更好。必须包含 *aoaa.inc* 文件才能使用此指令。'
- en: .octa    Octaword (oword, 128-bit/16-byte) values. One or more comma-separated
    128-bit expressions appear in the operand field. .octa is an unfortunate misnomer
    for ARM64, since a 128-bit value is actually a quad word, not an “octa” word (on
    the ARM, an octaword is 256 bits). To avoid confusion, this book avoids the .octa
    directive and uses .qword instead.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`.octa    八字（oword，128位/16字节）值。一个或多个用逗号分隔的 128 位表达式出现在操作数字段中。`.octa` 是 ARM64
    的一个不幸的误称，因为 128 位值实际上是四字（quad word），而不是“八字”（在 ARM 中，八字是 256 位）。为了避免混淆，本书避免使用 `.octa`
    指令，改为使用 `.qword`。'
- en: .qword    This is a macro appearing the *aoaa.inc* include file. It is a synonym
    for the .octa directive and emits 16 bytes for each operand. You must include
    the *aoaa.inc* file in order to use this directive.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`.qword    这是在 *aoaa.inc* 包含文件中出现的一个宏。它是 `.octa` 指令的同义词，并为每个操作数发出 16 字节。必须包含
    *aoaa.inc* 文件才能使用此指令。'
- en: .ascii    String values. A single string constant (surrounded by quotation marks)
    appears in the operand field. Note that Gas does not terminate this string with
    a 0 byte.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ascii    字符串值。一个字符串常量（用引号括起来）出现在操作数字段中。请注意，Gas 不会在此字符串后加上 0 字节来终止字符串。'
- en: .asciz    Zero-terminated string values. A single string constant (surrounded
    by quotation marks) appears in the operand field. Gas will emit a 0 after the
    last character in the string operand.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: .asciz    零终止字符串值。一个单一的字符串常量（用引号括起来）出现在操作数字段中。Gas将在字符串操作数的最后一个字符后发出0。
- en: .float    Single-precision floating-point values. One or more comma-separated
    32-bit single-precision floating-point expressions appear in the operand field.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: .float    单精度浮动点值。一个或多个用逗号分隔的32位单精度浮动点表达式出现在操作数字段中。
- en: .double    Double-precision floating-point values. One or more comma-separated
    64-bit double-precision floating-point expressions appear in the operand field.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: .double    双精度浮动点值。一个或多个用逗号分隔的64位双精度浮动点表达式出现在操作数字段中。
- en: Gas provides additional synonyms for some of the directives in this list; see
    the link to the Gas documentation in section 1.12, “For More Information,” on
    [page 43](chapter1.xhtml#pg_43).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Gas为此列表中的某些指令提供了额外的同义词；请参阅第1.12节“更多信息”中的[第43页](chapter1.xhtml#pg_43)链接。
- en: 'Here are some examples of valid Gas data declarations:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有效的Gas数据声明示例：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Whenever you declare a variable in this manner, Gas will associate the current
    location in the output object-code file with the label at the beginning of the
    line. It will then emit the appropriate-sized data value into memory at that location,
    adjusting the assembler’s *location counter* (which tracks the current location)
    by the size of each operand it emits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你以这种方式声明变量时，Gas将会将输出目标代码文件中的当前位置与行首的标签关联。然后，它会将适当大小的数据值发出到该位置的内存中，并通过每个操作数发出时的大小来调整汇编器的*位置计数器*（该计数器跟踪当前的位置）。
- en: 'The label field in these data declaration directives is optional. If you do
    not include the label, Gas simply emits the data in the operand field, starting
    at the current location counter and incrementing the location counter afterward.
    This is useful, for example, when you want to insert a control character or special
    Unicode character into a string:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据声明指令中的标签字段是可选的。如果没有包含标签，Gas将简单地在操作数字段中发出数据，从当前位置计数器开始，并在之后递增位置计数器。这在你想将控制字符或特殊的Unicode字符插入字符串时非常有用：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Gas allows C-style escape sequences within quoted strings. Although Gas doesn’t
    support the full set of escape characters, it does support the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Gas允许在引号字符串中使用C风格的转义序列。尽管Gas不支持完整的转义字符集，但它支持以下转义序列：
- en: \b        Backspace character (0x08)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: \b        退格符（0x08）
- en: \n        Newline character/line feed (0x0A)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: \n        换行符/换行（0x0A）
- en: \r        Carriage return (0x0D)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: \r        回车符（0x0D）
- en: \t         Tab (0x09)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: \t        制表符（0x09）
- en: \f        Form feed character (0x0C)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: \f        换页符（0x0C）
- en: \\         Backslash character
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: \\        反斜杠字符
- en: \nnn    Where nnn is a three-digit octal value; emit the value to the code stream
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: \nnn    其中nnn是一个三位八进制值；将该值发出到代码流中。
- en: \xhh    Where hh is a two-digit hexadecimal value; emit the value to the code
    stream
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: \xhh    其中hh是一个两位十六进制值；将该值发出到代码流中。
- en: Gas does not support \a, \e, \f, \v, \', \", \?, \uhhhh, or \Uhhhh escape sequences.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Gas不支持\a, \e, \f, \v, \', \", \?, \uhhhh或\Uhhhh转义序列。
- en: '#### 1.7.1 Associating Memory Addresses with Variables'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 1.7.1 将内存地址与变量关联'
- en: 'With an assembler like Gas, you don’t have to worry about numeric memory addresses.
    Once you declare a variable in Gas, the assembler associates that variable with
    a unique set of memory addresses. For example, say you have the following declaration
    section:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Gas这样的汇编器时，你不必担心数字内存地址。一旦你在Gas中声明了一个变量，汇编器就会将该变量与一组唯一的内存地址关联。例如，假设你有以下声明部分：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Gas will find an unused 8-bit byte in memory and associate it with the i8 variable;
    it will likewise associate a pair of consecutive unused bytes with i16, 4 consecutive
    unused bytes with i32, and 8 consecutive unused bytes with i64. You’ll always
    refer to these variables by their names and generally don’t have to concern yourself
    with their numeric addresses. Still, be aware that Gas is doing this for you.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Gas将找到内存中未使用的8位字节，并将其与i8变量关联；它还会将一对连续的未使用字节与i16关联，将4个连续的未使用字节与i32关联，8个连续的未使用字节与i64关联。你将始终通过它们的名称来引用这些变量，通常无需关心它们的数字地址。不过，请注意Gas会为你完成这些操作。
- en: When Gas is processing declarations in a .data section, it assigns consecutive
    memory locations to each variable. Assuming i8 (in the previous declarations)
    as a memory address of 101, Gas will assign the addresses appearing in [Table
    1-1](chapter1.xhtml#tab1-1) to i8, i16, i32, and i64.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Gas 处理 .data 区段中的声明时，它会为每个变量分配连续的内存地址。假设 i8（在之前的声明中）是 101 号内存地址，Gas 会将出现在[表
    1-1](chapter1.xhtml#tab1-1)中的地址分配给 i8、i16、i32 和 i64。
- en: 'Table 1-1: Variable Address Assignments'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1：变量地址分配
- en: '| Variable | Memory address |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 内存地址 |'
- en: '| --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| i8 | 101 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| i8 | 101 |'
- en: '| i16 | 102 (address of i8 plus 1) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| i16 | 102（i8 地址加 1） |'
- en: '| i32 | 104 (address of i16 plus 2) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| i32 | 104（i16 地址加 2） |'
- en: '| i64 | 108 (address of i32 plus 4) |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| i64 | 108（i32 地址加 4） |'
- en: Technically, Gas assigns offsets into the .data section to variables. Linux/macOS
    converts these offsets to physical memory addresses when it loads the program
    into memory at runtime.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，Gas 将偏移量分配给 .data 区段中的变量。Linux/macOS 在程序加载到内存时，会将这些偏移量转换为物理内存地址。
- en: Whenever you have multiple operands in a data declaration statement, Gas will
    emit the values to sequential memory locations in the order in which they appear
    in the operand field. The label associated with the data declaration (if one is
    present) is associated with the address of the first (leftmost) operand’s value.
    See [Chapter 4](chapter4.xhtml) for more details.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在数据声明语句中有多个操作数时，Gas 会按照它们在操作数字段中出现的顺序将值输出到连续的内存位置。与数据声明相关的标签（如果有的话）将与第一个（最左边）操作数的值的地址相关联。有关更多详情，请参见[第
    4 章](chapter4.xhtml)。
- en: 1.7.2 Aligning Variables
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.7.2 对齐变量
- en: As noted already, your programs may run faster if your variables are aligned
    on a *natural boundary* (alignment to the size of the object). Alignment is accomplished
    with the .align directive, which you saw in Listing 1-1.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你的变量在*自然边界*上对齐（与对象的大小对齐），程序可能会运行得更快。对齐是通过 .align 指令完成的，你在列表 1-1 中已经见过这种指令。
- en: Byte variables don’t require any alignment. Use the .align 1 directive to put
    half words at an even address (2-byte boundary); remember, Gas will align the
    next statement on a boundary that is equal to 2*^n*, where *n* is the .align statement’s
    operand. For words, use the .align 2 directive. For double words (.dword), use
    the .align 3 directive.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 字节变量不需要任何对齐。使用 .align 1 指令将半字对齐到偶数地址（2 字节边界）；记住，Gas 会将下一条语句对齐到一个边界，该边界等于 2*^n*，其中
    *n* 是 .align 指令的操作数。对于字，使用 .align 2 指令。对于双字（.dword），使用 .align 3 指令。
- en: 'For example, let’s return to the declaration given earlier:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回到之前给出的声明：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Sticking .align directives in front of every declaration (except i8) will start
    to clutter up your code and make it harder to read:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个声明前（除了 i8）粘贴 .align 指令会让代码变得杂乱，且更难阅读：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If your variables don’t have to be declared in a particular order, you can
    clean this up by declaring the largest variables first and the remaining variables
    sorted by decreasing size. If you do this, you have to align only the first variable
    in your declaration list:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的变量不需要按特定顺序声明，你可以通过先声明最大的变量，然后按递减顺序排序剩余的变量来清理代码。如果这样做，你只需要对齐声明列表中的第一个变量：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because the i64 declaration appears immediately after the .align 3 statement
    in this code, the i64 address will be aligned on an 8-byte boundary. As i32 immediately
    follows i64 in memory, it will also be aligned on an 8-byte boundary (which, of
    course, is also a 4-byte boundary). This is because i64 is aligned on an 8-byte
    boundary and consumes 8 bytes; therefore, the address following i64 (the address
    of i32) will also be 8-byte aligned.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 i64 声明紧随 .align 3 指令之后，i64 的地址将在 8 字节边界对齐。由于 i32 紧跟 i64 之后，它也将被 8 字节对齐（这当然也是
    4 字节对齐）。这是因为 i64 在 8 字节边界对齐并占用 8 字节；因此，i64 后面的地址（i32 的地址）也会被 8 字节对齐。
- en: Meanwhile, because i16 immediately follows i32 in memory, it will be aligned
    on a 4-byte boundary (which is also an even address). The alignment of i8 doesn’t
    matter, but it happens to be at an even address, as it follows i16, which was
    aligned on a 4-byte boundary and consumes 2 bytes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，由于 i16 紧随 i32 之后，它将在 4 字节边界对齐（这也是一个偶数地址）。i8 的对齐方式无关紧要，但它恰好处于偶数地址，因为它紧随 i16
    之后，i16 已经在 4 字节边界对齐并占用了 2 字节。
- en: NOTE
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Gas also provides a* .balign *directive whose operand must be a power of 2
    (1, 2, 4, 8, 16, ...) to specify the alignment value directly, rather than as
    a power of 2\. While this book uses* .align *because it’s the original directive,
    feel free to use* .balign *if you prefer.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gas 还提供了一个* .balign *指令，它的操作数必须是 2 的幂（1、2、4、8、16，...），用于直接指定对齐值，而不是作为 2 的幂。虽然本书使用*
    .align *指令，因为它是原始指令，但如果你更喜欢的话，也可以使用* .balign*。'
- en: Strings are sequences of bytes, so their alignment usually doesn’t matter. However,
    it is possible to write very high-performance string functions in assembly language
    that process strings eight or more characters at a time. If you have access to
    such library code, it might run faster if your strings are aligned on an 8-byte
    boundary.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字节的序列，因此它们的对齐通常无关紧要。然而，确实可以编写高性能的字符串函数，这些函数一次处理八个或更多字符。如果你有访问这样的库代码的权限，如果你的字符串按
    8 字节边界对齐，它可能会运行得更快。
- en: Of course, floats and doubles should be aligned on 4-byte and 8-byte boundaries
    for the highest performance. In fact, as you’ll see in [Chapter 11](chapter11.xhtml),
    16-byte alignment is also sometimes better.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，浮点数和双精度数应该在 4 字节和 8 字节边界上对齐，以获得最佳性能。实际上，正如你将在 [第11章](chapter11.xhtml) 中看到的，有时
    16 字节对齐也更好。
- en: 1.7.3 Declaring Named Constants in Gas
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.7.3 在 Gas 中声明命名常量
- en: Gas allows you to declare manifest constants by using the .equ directive. A
    *manifest constant* is a symbolic name (identifier) that Gas associates with a
    value. Everywhere the symbol appears in the program, Gas will directly substitute
    its value.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 允许你使用 .equ 指令声明显式常量。一个 *显式常量* 是一个符号名称（标识符），Gas 将其与一个值关联。在程序中每次出现该符号时，Gas
    会直接替换它的值。
- en: 'A manifest constant declaration takes the following form:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显式常量声明的格式如下：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, label is a legal Gas identifier, and expression is a constant arithmetic
    expression (typically a single literal constant value). The following example
    defines the symbol dataSize to be equal to 256:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，label 是一个合法的 Gas 标识符，expression 是一个常量算术表达式（通常是一个单一的字面常量值）。以下示例将符号 dataSize
    定义为 256：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Constant declarations, or *equates* in Gas terminology, may appear anywhere
    in your Gas source file prior to their first use: in a .data section, in a .text
    section, or even outside any sections.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明，或者在 Gas 术语中称为 *equates*，可以出现在 Gas 源文件中的任何位置，位于第一次使用之前：可以在 .data 部分、.text
    部分，甚至可以在任何部分之外。
- en: 'Once you define a constant symbol with .equ, it cannot be further modified
    in the source file during assembly. If you need to reassign the value associated
    with a label during assembly (see [Chapter 13](chapter13.xhtml) for reasons you’d
    want to do this), use the .set directive:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用 .equ 定义了一个常量符号，它就不能在汇编过程中进一步修改。如果你需要在汇编过程中重新分配与标签关联的值（参见 [第13章](chapter13.xhtml)
    了解你为什么需要这样做），可以使用 .set 指令：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Equates can specify textual arguments as well as numeric constants.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 等式可以指定文本参数以及数字常量。
- en: 'Because Gas will run your source files through the CPP if the filename suffix
    is *.S*, you can also use the CPP #define macro definition to create named constants.
    Although the .equ directive is probably the better choice, the C macro form offers
    a few advantages, like allowing arbitrary textual substitution, not just numeric
    expression substitution. For more on this, see [Chapter 13](chapter13.xhtml).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '由于如果文件名后缀是 *.S*，Gas 会通过 CPP 运行你的源文件，你也可以使用 CPP 的 #define 宏定义来创建命名常量。尽管 .equ
    指令可能是更好的选择，但 C 宏形式有一些优势，比如允许任意文本替代，而不仅仅是数字表达式替代。有关更多信息，请参见 [第13章](chapter13.xhtml)。'
- en: 1.7.4 Creating Register Aliases in Gas and Substituting Text
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.7.4 在 Gas 中创建寄存器别名并进行文本替换
- en: 'As you begin to write more complex ARM assembly language programs, you’ll discover
    that the 32 general-purpose register names (X0 to X30 and SP) obscure the meaning
    of their values in the program. It’s been decades since BASIC supported only variable
    names like A0, A1, B2, and Z3\. To avoid returning to those days by using meaningless
    two-character names, Gas provides a way to create more meaningful aliases of register
    names in your programs: the .req directive.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写更复杂的 ARM 汇编语言程序时，你会发现那 32 个通用寄存器名（X0 到 X30 和 SP）使得它们在程序中的值难以理解。从 BASIC
    只支持像 A0、A1、B2 和 Z3 这样的变量名已经过去几十年了。为了避免通过使用无意义的两字符名称回到那些日子，Gas 提供了一种在程序中创建寄存器名称的更有意义的别名的方法：.req
    指令。
- en: The syntax of the .req directive is
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: .req 指令的语法是：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: where symbolicName is any valid Gas identifier and register is one of the 32-
    or 64-bit register names. After this statement in the source file, if you use
    symbolicName in place of register, Gas will automatically substitute that register
    for the name.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，symbolicName 是任何有效的 Gas 标识符，register 是 32 位或 64 位寄存器名称之一。在源文件中这条语句之后，如果你使用
    symbolicName 替代 register，Gas 将自动将该寄存器替换为名称。
- en: 'Sadly, the .req directive works only for creating register aliases; you can’t
    use it as a general-purpose text-substitution facility. However, if you name your
    assembly language source files with *.S*, Gas/GCC will first run your source file
    through the CPP. This allows you to embed C/C++ #define statements in your assembly
    source file, and the CPP will happily expand any symbols you define in such statements
    throughout your source file. The following example demonstrates using #define:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '遗憾的是，.req 指令仅适用于创建寄存器别名；你不能将其用作通用的文本替换工具。然而，如果你将汇编语言源文件命名为 *.S*，Gas/GCC 将首先通过
    CPP 处理你的源文件。这使得你可以在汇编源文件中嵌入 C/C++ 的 #define 语句，并且 CPP 将乐意扩展你在这些语句中定义的任何符号，贯穿整个源文件。以下示例演示了如何使用
    #define：'
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Typically, you’ll use .req for register aliases and #define for any other textual
    substitutions in the source file, though my personal preference is to use the
    #define statement for both purposes in this book. Since #define also accepts parameters,
    it’s flexible. Gas also supports textual substitution via *macros*; see [Chapter
    13](chapter13.xhtml) for more on this.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '通常，你会使用 .req 来定义寄存器别名，而使用 #define 来进行其他文本替换，尽管我个人更倾向于在本书中使用 #define 语句来处理这两种情况。由于
    #define 也接受参数，它具有灵活性。Gas 还支持通过*宏*进行文本替换；有关更多信息，请参见[第 13 章](chapter13.xhtml)。'
- en: 1.8 Basic ARM Assembly Language Instructions
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.8 基础 ARM 汇编语言指令
- en: Thus far, the programming examples in this chapter have consisted of functions
    that use only the ret instruction. This section describes a few more instructions
    to get you started writing more meaningful assembly language programs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中的编程示例仅包含使用 ret 指令的函数。本节将介绍一些其他指令，帮助你开始编写更有意义的汇编语言程序。
- en: '#### 1.8.1 ldr, str, adr, and adrp'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 1.8.1 ldr、str、adr 和 adrp'
- en: One solidly RISC feature of ARM is its use of *load/store architecture*. All
    computational activity takes place in the ARM’s registers; the only instructions
    that access main memory are those that load a value from memory or store a value
    into memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 的一个显著的 RISC 特性是其采用的*加载/存储架构*。所有的计算活动都在 ARM 的寄存器中进行；唯一访问主内存的指令是那些从内存加载值或将值存储到内存的指令。
- en: Although the ARM64 has many general-purpose registers for holding variable values
    (and thus can avoid using memory), most applications use more variable data than
    can fit in all the registers. This is especially true for larger objects like
    arrays, structs, and strings. Furthermore, programming conventions—known as the
    *application binary interface (ABI)*, discussed later in this chapter—often reserve
    many of ARM’s registers so they cannot be used to hold application variables for
    any length of time. So variables must be placed in main memory and accessed via
    these ldr (load) and str (store) instructions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ARM64 有许多通用寄存器来存储变量值（因此可以避免使用内存），但大多数应用程序使用的变量数据量超过了所有寄存器所能容纳的大小。对于数组、结构体和字符串等较大的对象，这一点尤其如此。此外，编程约定——即后面章节中讨论的*应用程序二进制接口（ABI）*——通常保留了许多
    ARM 寄存器，因此这些寄存器无法用于长时间保存应用程序变量。所以，变量必须存放在主内存中，并通过这些 ldr（加载）和 str（存储）指令来访问。
- en: This is the generic syntax for the load and store instructions
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是加载和存储指令的通用语法
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: where size is either absent or one of the character sequences b, h, sb, sh,
    or sw; reg is one of the ARM’s 32- or 64-bit registers; and mem is a memory addressing
    mode that specifies where to fetch the data from in memory. The ldr instruction
    loads the register specified by reg from the memory location specified by mem.
    The str instruction stores the value held in the register operand into the memory
    location.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，size 要么不存在，要么是字符序列 b、h、sb、sh 或 sw 之一；reg 是 ARM 的 32 位或 64 位寄存器之一；mem 是一种内存寻址模式，指定从内存中哪里获取数据。ldr
    指令从 mem 指定的内存位置加载 reg 指定的寄存器。str 指令将寄存器操作数中的值存储到内存位置。
- en: '[Chapter 2](chapter2.xhtml) discusses the size operand in greater depth, but
    this chapter largely ignores the size suffixes on the ldr and str instructions.
    Without a size prefix, the reg operand determines the operation’s size. If reg
    is X*n*, the instruction transfers 64 bits; if it’s W*n*, then the instruction
    transfers 32 bits.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 2 章](chapter2.xhtml)更深入地讨论了大小操作数，但本章大致忽略了 ldr 和 str 指令上的大小后缀。没有大小前缀时，reg
    操作数决定操作的大小。如果 reg 是 X*n*，则指令传输 64 位；如果是 W*n*，则指令传输 32 位。'
- en: The mem operand is either the name of a variable in your program, typically
    in the .data section (Linux only), or a register name surrounded by square brackets
    ([]). In this latter case, the register holds the numeric memory address of the
    memory location to access. See [Chapter 3](chapter3.xhtml) for more on mem.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: mem 操作数要么是程序中变量的名称，通常位于 .data 部分（仅限 Linux），要么是一个用方括号（[]）括起来的寄存器名称。在后一种情况下，寄存器保存的是要访问的内存位置的数值地址。有关
    mem 的更多信息，请参见[第 3 章](chapter3.xhtml)。
- en: 'Because macOS requires that your applications be written in a position-independent
    fashion (as we just discussed in “Linux vs. macOS: Position-Independent Executables”),
    you will not be able to use an ldr instruction of this form:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 macOS 要求你的应用程序必须以位置无关的方式编写（如我们在“Linux 与 macOS：位置无关可执行文件”一节中讨论的那样），你将无法使用以下形式的
    ldr 指令：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To access the i64 variable, you must first load its address into a 64-bit register,
    then access that data by using the *register-indirect addressing mode*, or X*n*.
    To do so, place the address of the variable you want to access in the register
    by using the adr and adrp instructions:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 i64 变量，必须首先将其地址加载到 64 位寄存器中，然后通过使用*寄存器间接寻址模式*或 X*n* 来访问该数据。为此，可以使用 adr 和
    adrp 指令将你想要访问的变量的地址放入寄存器中：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, reg64 is the name of a 64-bit general-purpose register, and mem is a memory
    addressing mode, like the name of a global variable. The adr instruction loads
    reg with the address of the memory variable, which must be ±1MB from the adr instruction
    if the operand is just the name of a variable (like i64 from the previous example).
    The adrp instruction loads the 64-bit destination register with the page (4,096-byte
    boundary) containing the memory object. That value will have the LO 12 bits containing
    all 0s.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，reg64 是一个 64 位通用寄存器的名称，mem 是一种内存寻址模式，类似于全局变量的名称。adr 指令将 reg 加载为内存变量的地址，如果操作数仅是一个变量的名称（像前面的
    i64），那么 adr 指令要求地址距离该指令的偏移量必须在 ±1MB 之内。adrp 指令将 64 位目标寄存器加载为包含内存对象的页（4,096 字节边界）。该值的低
    12 位将全为 0。
- en: 'Because of macOS’s PIE requirements, it doesn’t take kindly to instructions
    such as the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 macOS 的 PIE 要求，它不太接受如下的指令：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: On the Mac, you must use the register-indirect addressing mode to access a global
    variable. Unfortunately
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上，你必须使用寄存器间接寻址模式来访问全局变量。不幸的是
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'fails for the same reason: you’re not allowed to specify the name of a global
    variable.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的原因是相同的：你不能指定全局变量的名称。
- en: 'In this book, to get the address of a global variable into a register under
    macOS, we’ll use the following statement:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，为了在 macOS 下将全局变量的地址加载到寄存器中，我们将使用以下语句：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The lea (load effective address) macro, included in *aoaa.inc*, will expand
    into two instructions (different ones depending on your OS). These instructions
    will load the address of the second operand (mem) into the 64-bit register specified
    by the first operand (reg). You can use lea in any projects where you’ve included
    *aoaa.inc* at the beginning of your source file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*aoaa.inc* 中包含的 lea（加载有效地址）宏将展开为两条指令（取决于你的操作系统）。这些指令将第二个操作数（mem）的地址加载到第一个操作数（reg）指定的
    64 位寄存器中。你可以在任何包含了 *aoaa.inc* 的项目中使用 lea，它通常会在源文件的开头被引入。'
- en: As noted, the *aoaa.inc* macros make the code in this book portable between
    OSes. However, you can choose to go with the appropriate OS-specific code, which
    can sometimes be more efficient, once you master basic ARM assembly language programming.
    See [Chapter 7](chapter7.xhtml) for more details on lea.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*aoaa.inc* 宏使得本书中的代码能够在不同操作系统之间移植。然而，一旦你掌握了基本的 ARM 汇编语言编程，你可以选择使用适合操作系统的特定代码，这样有时可能会更加高效。有关
    lea 的更多细节，请参见[第 7 章](chapter7.xhtml)。
- en: 'To conclude this discussion of taking the address of a variable, let’s recap
    how to load and store values by using ldr and str:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 结束关于获取变量地址的讨论时，我们来总结一下如何使用 ldr 和 str 加载和存储值：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When loading X0 with a variable’s value, you can first load X0 with the address
    of the variable and then load X0 indirectly from the location held in X0\. This
    winds up using only a single register. However, when storing data to memory, you
    need a second register to hold the address (X1 in this example).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当将变量的值加载到X0时，你可以先将X0加载为该变量的地址，然后从X0保存的地址间接加载X0的值。这样最终只使用一个寄存器。然而，在将数据存储到内存时，你需要第二个寄存器来保存地址（在这个例子中是X1）。
- en: 'If you are referencing a particular variable several times within a small section
    of code, it’s more efficient to load its address into a register just once and
    reuse that register value multiple times, rather than constantly reloading the
    address:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在代码的小段落内多次引用特定变量，最好只将其地址加载到寄存器中一次，并多次重用该寄存器的值，而不是每次都重新加载地址：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Of course, this means you can’t use the register for any other purpose while
    it holds i64’s address. Fortunately, for just this reason, the ARM64 has lots
    of registers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着在寄存器保存i64的地址时，你不能将该寄存器用于其他任何目的。幸运的是，正因为这个原因，ARM64拥有大量的寄存器。
- en: 1.8.2 mov
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.8.2 mov
- en: 'Beyond the ldr and str instructions, the mov instruction handles two additional
    data movement operations: moving data between a pair of registers and copying
    a constant into a register. The generic syntax for mov is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了ldr和str指令外，mov指令还处理两种额外的数据移动操作：在一对寄存器之间移动数据以及将常量复制到寄存器中。mov的通用语法如下：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first mov instruction copies the data in the source register (regsrc) into
    the destination register (regdest). This instruction is equivalent to the C/C++
    statement regdest = regsrc;. The source and destination registers can be any of
    the general-purpose registers but must be the same size (32 or 64 bits).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条mov指令将源寄存器（regsrc）中的数据复制到目标寄存器（regdest）中。这个指令相当于C/C++语句regdest = regsrc;。源寄存器和目标寄存器可以是任何通用寄存器，但它们必须具有相同的大小（32位或64位）。
- en: 'The second mov instruction moves a small integer constant into the destination
    register. Constants encoded as part of the instruction are known as *immediate
    constants* and are generally preceded by a # character (though Gas often allows
    you to drop the # when specifying literal numeric constants). [Chapter 2](chapter2.xhtml)
    discusses limitations on constants, but for now, assume any constant less than
    ±2,047 will work.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条mov指令将一个小的整数常量移动到目标寄存器中。作为指令一部分编码的常量被称为*立即数常量*，通常会以#字符为前缀（尽管Gas通常允许在指定字面数值常量时省略#）。[第2章](chapter2.xhtml)讨论了常量的限制，但现在假设任何小于±2,047的常量都可以使用。
- en: 'Here are two examples of the mov instruction:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个mov指令的示例：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are many additional variants of mov, covered in depth in later chapters.
    For example, if you encounter a constant you cannot load into a register with
    a single mov instruction, other variants of mov let you load any arbitrary 32-
    or 64-bit constant by using two to three instructions. In the meantime, this variant
    of the ldr instruction will load any constant into a register:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: mov指令有许多额外的变体，后续章节会深入讲解。例如，如果你遇到一个常量，无法通过单条mov指令加载到寄存器中，其他变体的mov指令允许你通过使用两到三条指令加载任何任意的32位或64位常量。与此同时，以下这种ldr指令的变体将把任何常量加载到寄存器中：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The assembler will simply store veryLargeConstant in a memory location somewhere
    and then load the contents of that memory location to the specified register.
    Use this handy pseudo-instruction when you need to load a large constant into
    a register with a single instruction.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器将简单地将veryLargeConstant存储在某个内存位置，然后将该内存位置的内容加载到指定的寄存器中。当你需要通过单条指令将大常量加载到寄存器中时，可以使用这个方便的伪指令。
- en: '#### 1.8.3 add and sub'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 1.8.3 add和sub'
- en: 'The add and sub instructions handle simple arithmetic on the ARM CPU. These
    instructions take many forms covered more thoroughly in the next couple of chapters.
    Their basic forms are the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: add和sub指令处理ARM CPU上的简单算术运算。这些指令有多种形式，在接下来的几章中会更深入地讨论。它们的基本形式如下：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, regdest, reglsrc, and regrsrc are 32- or 64-bit registers (which must
    all be the same size for a given instruction), and const is an immediate constant
    in the range 0 to 4,095\. You’ll learn to specify larger constants later, but
    these forms are sufficient for the example programs in the next few chapters.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，regdest、reglsrc和regrsrc是32位或64位寄存器（对于给定的指令，它们必须具有相同的大小），const是一个范围在0到4,095之间的立即数常量。稍后你会学习如何指定更大的常量，但这些形式对于接下来几章的示例程序已经足够。
- en: NOTE
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Some assemblers allow a range of –4,095 to +4,095 and swap the* add *and*
    sub *instructions if the immediate constant is negative.*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些汇编器允许范围从 -4,095 到 +4,095，并在立即数为负时交换* add *和* sub *指令。*'
- en: 'The instructions with the s suffix affect the condition code flags. They set
    the flags according to the conditions specified in the following list:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 s 后缀的指令会影响条件码标志。它们根据以下列表中指定的条件设置标志：
- en: '**N**    Set if the arithmetic operation produces a negative result (high-order,
    or HO, bit is set); clear if it produces a nonnegative result (HO bit is clear).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**N**    如果算术操作产生负结果（高位或 HO 位被置位），则设置；如果产生非负结果（HO 位清零），则清除。'
- en: '**Z**    Set if the arithmetic operation produces a 0 result; clear if it produces
    a nonzero result.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**Z**    如果算术操作产生 0 结果，则设置；如果产生非零结果，则清除。'
- en: '**C**    Set if the addition operation produces an unsigned overflow (carry
    out of the HO bit). Clear if a subtraction operation produces a borrow (unsigned
    underflow), and set otherwise.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**C**    如果加法操作产生无符号溢出（HO 位溢出），则设置；如果减法操作产生借位（无符号下溢），则清除，否则设置。'
- en: '**V**    Set if the arithmetic operation produces a signed overflow (carry
    out of the next-to-HO bit).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**V**    如果算术操作产生符号溢出（下一个高位以外的位溢出），则设置。'
- en: 'The following instructions negate their source operands, because they subtract
    the source register from 0 (remember that WZR and XZR are the zero registers and
    return 0 when read):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令将源操作数取反，因为它们将源寄存器从 0 中减去（记住 WZR 和 XZR 是零寄存器，读取时返回 0）：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Gas provides synonyms for these instructions:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 为这些指令提供了同义词：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These forms are a little easier to read.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形式更容易阅读。
- en: 1.8.4 bl, blr, and ret
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.8.4 bl, blr 和 ret
- en: Calling procedures and functions is handled by the bl (branch and link) and
    blr (branch and link through register) instructions. Here’s their syntax
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 调用过程和函数是通过 bl（分支并链接）和 blr（通过寄存器分支并链接）指令处理的。以下是它们的语法：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: where label is a statement label preceding code in the .text section, and Xn
    represents one of the 64-bit registers. These two instructions copy the address
    of the next instruction (following the bl or blr instruction) into the link register
    (LR/X30), then transfer control either to the target label or to the address specified
    by the contents of X*n*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 label 是 .text 段中代码前的语句标签，Xn 代表其中一个 64 位寄存器。这两个指令将下一个指令的地址（bl 或 blr 指令后的指令）复制到链接寄存器
    (LR/X30) 中，然后将控制权转移到目标标签或由 X*n* 内容指定的地址。
- en: 'The bl instruction does have a minor limitation: it can transfer control only
    to a statement label within ±128MB of the current instruction. This is generally
    far more than enough for any function you’ll write. In theory, if the OS loads
    code into another section (besides .text), it could be placed sufficiently far
    away that it would exceed this range. The OS linker will probably complain if
    this occurs. This book generally places all code within the .text section, as
    it would be rare for such programs to exceed this limitation.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: bl 指令确实有一个小的限制：它只能将控制权转移到当前指令 ±128MB 范围内的语句标签。这对于你编写的任何函数来说通常已经足够了。理论上，如果操作系统将代码加载到另一个段（除了
    .text），它可能会被放置得足够远，以至于超出了这个范围。如果发生这种情况，操作系统的链接器可能会抱怨。由于此书通常将所有代码放置在 .text 段内，所以超出此限制的程序非常罕见。
- en: 'The blr instruction copies the full 64-bit address from X*n* into the PC (after
    copying the address of the next instruction into LR). Therefore, blr does not
    have the range limitation of the bl instruction. If you ever do encounter the
    range limitation when using bl, overcome it by using the following sequence:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: blr 指令将 X*n* 中的完整 64 位地址复制到 PC 中（在将下一个指令的地址复制到 LR 后）。因此，blr 不受 bl 指令的范围限制。如果你在使用
    bl 时遇到范围限制，可以通过以下序列克服它：
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will load the address of farAwayProcedure into X0 (no matter where it appears
    in memory), then transfer control to that procedure via blr.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 farAwayProcedure 的地址加载到 X0 中（无论它在内存中的位置如何），然后通过 blr 将控制权转移到该过程。
- en: The ret instruction has appeared in several examples up to this point. It copies
    the contents of the LR (X30) register into the PC. Assuming that LR was loaded
    with a value as a result of executing the bl or blr instruction, this returns
    control to the instruction following the bl/blr.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ret 指令在到目前为止的几个示例中都有出现。它将 LR (X30) 寄存器的内容复制到 PC 中。假设 LR 在执行 bl 或 blr 指令后被加载了一个值，那么这将把控制权返回到
    bl/blr 后的指令。
- en: 'The bl, blr, and ret instructions have one issue: the ARM architecture tracks
    only a single subroutine call with the LR register. Consider the following code
    fragment:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: bl、blr和ret指令有一个问题：ARM架构只用LR寄存器跟踪单一的子程序调用。考虑以下代码片段：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When the OS calls the main program, it loads the LR register with the return
    address back to the OS. Normally, when the main program completes execution, its
    ret instruction transfers control to this location. However, that’s not the case
    in this example: when the main program begins execution, it immediately calls
    someFunc with the bl instruction. This instruction copies its return address (the
    address of the main program’s ret instruction) into the LR register, wiping out
    the OS’s return address currently residing there. When someFunc executes the return
    instruction, it returns control back to the main program.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统调用主程序时，它将LR寄存器加载为返回地址，指向操作系统。通常，当主程序完成执行时，它的ret指令会将控制转移到这个位置。然而，在这个例子中情况并非如此：当主程序开始执行时，它会立即通过bl指令调用someFunc。这条指令将返回地址（主程序ret指令的地址）复制到LR寄存器中，覆盖了当前存储在其中的操作系统返回地址。当someFunc执行返回指令时，它将控制权返回给主程序。
- en: Upon return from someFunc, the main program executes the ret instruction. However,
    the LR register now contains the return address of the someFunc call, which is
    the address of the ret instruction in the main program, so control transfers there,
    re-executing ret. The LR register’s value hasn’t changed; it still points at that
    ret instruction, meaning this code enters an infinite loop continuously executing
    the return and transferring control back to the return (where LR continues to
    point).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从someFunc返回后，主程序执行ret指令。然而，LR寄存器现在包含someFunc调用的返回地址，即主程序中ret指令的地址，因此控制转移到该位置，重新执行ret。LR寄存器的值没有改变；它仍然指向该ret指令，这意味着这段代码进入了一个无限循环，不断执行返回并将控制权转移回返回指令（LR继续指向该位置）。
- en: '[Chapter 3](chapter3.xhtml) discusses the high-level solution to this problem.
    For the time being, we must save the LR register value in the main program before
    calling someFunc. One quick-and-dirty way to do this is to copy it into another
    (unused by main) register and restore LR before the final return:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](chapter3.xhtml)讨论了解决此问题的高层次方案。暂时，我们必须在调用someFunc之前在主程序中保存LR寄存器的值。一个快速且粗略的方法是将其复制到另一个（主程序未使用的）寄存器中，并在最终返回之前恢复LR：'
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code saves the return address (in LR) in the X1 register and restores it
    after returning from someFunc (the call to someFunc overwrote the value in LR).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将返回地址（保存在LR中）保存到X1寄存器，并在从someFunc返回后恢复它（对someFunc的调用覆盖了LR中的值）。
- en: In general, saving the return address in the X1 register is a bad idea, because
    the ARM’s designers reserve X1 for passing parameters. (Using X1 worked in this
    example because someFunc doesn’t have any parameters, as it just returns to its
    caller.) The next section covers in greater depth which registers are reserved
    for various purposes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将返回地址保存在X1寄存器中是一个不好的主意，因为ARM的设计者将X1保留用于传递参数。（在这个例子中使用X1是可行的，因为someFunc没有任何参数，它只是返回到调用者。）下一部分将更深入地讨论哪些寄存器被保留用于不同的目的。
- en: 1.9 The ARM64 Application Binary Interface
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.9 ARM64应用二进制接口
- en: A CPU’s *application binary interface (ABI)* describes how programs should use
    registers, pass parameters between functions, represent data, and many other conventions.
    Its primary purpose is to provide interoperability among programming languages
    and systems. The ARM64’s ABI, for example, describes the conventions that allow
    C/C++ programs to call functions written in Swift, Pascal, and other languages.
    Since the GCC (and Clang) compilers follow these rules, you must also follow them
    to pass information between your assembly language code and code written in an
    HLL such as C/C++.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CPU的*应用二进制接口（ABI）*描述了程序如何使用寄存器、在函数间传递参数、表示数据以及许多其他约定。它的主要目的是提供编程语言和系统之间的互操作性。例如，ARM64的ABI描述了允许C/C++程序调用用Swift、Pascal和其他语言编写的函数的约定。由于GCC（和Clang）编译器遵循这些规则，因此你也必须遵循这些规则，以便在汇编语言代码和用C/C++等高级语言编写的代码之间传递信息。
- en: An ABI is a *convention*, not an absolute rule. It is a contract between the
    code being called and the code making the call. When writing your own assembly
    language functions to be called by your own assembly language code, you are under
    no obligation to use the ABI and can use whatever inter-code communication scheme
    you like. However, if you call C/C++ code from your assembly functions, or if
    your assembly code is being called from C/C++, you must follow the ARM64 ABI.
    Since this book uses a considerable mixture of C/C++ and assembly code, understanding
    the ARM64 ABI is critical for our purposes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ABI 是一种*约定*，而不是绝对规则。它是被调用代码和调用代码之间的合约。当编写自己的汇编语言函数以供自己的汇编语言代码调用时，您没有义务使用 ABI，并且可以使用任何您喜欢的代码间通信方案。然而，如果从您的汇编函数调用
    C/C++ 代码，或者如果您的汇编代码被 C/C++ 调用，您必须遵循 ARM64 ABI。由于本书使用了大量的 C/C++ 和汇编代码混合，理解 ARM64
    ABI 对我们至关重要。
- en: 1.9.1 Register Usage
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.9.1 寄存器使用
- en: The ARM64 ABI reserves some of its 32 general-purpose registers for specific
    uses and defines whether registers are *volatile* (meaning you don’t have to preserve
    their values) or *nonvolatile* (meaning that you must preserve their values within
    a function). [Table 1-2](chapter1.xhtml#tab1-2) describes the special purposes
    and volatility of the 32 ARM registers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ARM64 ABI 保留了其 32 个通用寄存器中的一些用途，并定义了寄存器是*易失性*（即您不必保留其值）还是*非易失性*（即您必须在函数内保留其值）的情况。[表
    1-2](chapter1.xhtml#tab1-2) 描述了 32 个 ARM 寄存器的特殊用途和易失性。
- en: 'Table 1-2: ARM64 ABI Register Conventions'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-2：ARM64 ABI 寄存器约定
- en: '| Register | Volatile | Special meaning |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 寄存器 | 易失性 | 特殊含义 |'
- en: '| --- | --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| X0/W0 | Yes | Pass parameter 1 here, return function results here. Registers
    X0 through X7 can also be used as a scratchpad/temporary/ local variable if not
    used as a parameter. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| X0/W0 | 是 | 在这里传递参数 1，返回函数结果。寄存器 X0 到 X7 也可以用作临时变量/本地变量，如果未用作参数的话。 |'
- en: '| X1/W1 | Yes | Pass parameter 2 here, return function results here. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| X1/W1 | 是 | 在这里传递参数 2，返回函数结果。 |'
- en: '| X2/W2 | Yes | Pass parameter 3 here, return function results here. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| X2/W2 | 是 | 在这里传递参数 3，返回函数结果。 |'
- en: '| X3/W3 | Yes | Pass parameter 4 here, return function results here. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| X3/W3 | 是 | 在这里传递参数 4，返回函数结果。 |'
- en: '| X4/W4 | Yes | Pass parameter 5 here, return function results here. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| X4/W4 | 是 | 在这里传递参数 5，返回函数结果。 |'
- en: '| X5/W5 | Yes | Pass parameter 6 here, return function results here. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| X5/W5 | 是 | 在这里传递参数 6，返回函数结果。 |'
- en: '| X6/W6 | Yes | Pass parameter 7 here, return function results here. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| X6/W6 | 是 | 在这里传递参数 7，返回函数结果。 |'
- en: '| X7/W7 | Yes | Pass parameter 8 here, return function results here. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| X7/W7 | 是 | 在这里传递参数 8，返回函数结果。 |'
- en: '| X8/W8 | Yes | Pointer to large function return results (for example, a large
    C structure returned by value). |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| X8/W8 | 是 | 指向大型函数返回结果（例如，通过值返回的大型 C 结构体）。 |'
- en: '| X9/W9 X10/W10'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '| X9/W9 X10/W10'
- en: X11/W11
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: X11/W11
- en: X12/W12
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: X12/W12
- en: X13/W13
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: X13/W13
- en: X14/W14
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: X14/W14
- en: X15/W15 | Yes Yes
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: X15/W15 | 是 是
- en: 'Yes'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: 'Yes'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: 'Yes'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: 'Yes'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Yes | Can be used as a scratchpad/temporary/local variable. |
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 是 | 可用作临时变量/本地变量。 |
- en: '| X16/W16/IP0 | Yes, but ... | You can use this register as a temporary variable,
    but its value may change across the execution of a control-transfer instruction;
    the system linker/loader may use this register to create a veneer, also known
    as a trampoline (more on this in [Chapter 7](chapter7.xhtml)). |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| X16/W16/IP0 | 是，但是 ... | 您可以将此寄存器用作临时变量，但其值可能会在控制转移指令的执行过程中发生变化；系统链接器/加载器可能会使用此寄存器创建表面层，也称为跳板（更多信息请参见[第
    7 章](chapter7.xhtml)）。 |'
- en: '| X17/W17/IP1 | Yes, but ... | You can use this register as a temporary variable,
    but its value may change across the execution of a control-transfer instruction;
    the system linker/loader may use this register to create a veneer, also known
    as a trampoline (more on this in [Chapter 7](chapter7.xhtml)). |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| X17/W17/IP1 | 是，但是 ... | 您可以将此寄存器用作临时变量，但其值可能会在控制转移指令的执行过程中发生变化；系统链接器/加载器可能会使用此寄存器创建表面层，也称为跳板（更多信息请参见[第
    7 章](chapter7.xhtml)）。 |'
- en: '| X18/W18/Plat | No access | This register is reserved for use by the OS, and
    application programs must not modify its value. Under macOS, you definitely must
    not modify this register; under Linux, you may get away with using this register
    if you preserve its value, but the safe choice is to avoid using this register.
    |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| X18/W18/Plat | 无访问 | 此寄存器保留供操作系统使用，应用程序不能修改其值。在 macOS 下，绝对不能修改此寄存器；在 Linux
    下，如果保留其值，可以使用此寄存器，但安全起见，应避免使用此寄存器。 |'
- en: '| X19/W19 X20/W20'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '| X19/W19 X20/W20'
- en: X21/W21
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: X21/W21
- en: X22/W22
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: X22/W22
- en: X23/W23
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: X23/W23
- en: X24/W24
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: X24/W24
- en: X25/W25
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: X25/W25
- en: X26/W26
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: X26/W26
- en: X27/W27
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: X27/W27
- en: X28/W28 | No No
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: X28/W28 | 无 | 无
- en: 'No'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 无
- en: 'No'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 无
- en: 'No'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 无
- en: 'No'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 无
- en: 'No'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 无
- en: 'No'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 无
- en: 'No'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 无
- en: No | A function using this register must save and restore the register’s value
    so that it contains its original value when the function returns. |
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 无 | 使用此寄存器的函数必须保存并恢复该寄存器的值，以便它在函数返回时包含其原始值。 |
- en: '| X29/W29/FP | N/A | Reserved for use as the system frame pointer. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| X29/W29/FP | 不适用 | 保留用于系统帧指针。 |'
- en: '| X30/W30/LR | N/A | Reserved for holding function return addresses. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| X30/W30/LR | 不适用 | 保留用于保存函数返回地址。 |'
- en: '| SP /X31/W31 | N/A | Reserved for use as the system stack pointer. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| SP /X31/W31 | 不适用 | 保留用于系统栈指针。 |'
- en: Conveniently, when using volatile registers in a function, you don’t have to
    preserve (save and restore) their values within the function. However, this means
    that you also cannot expect them to maintain their values across any functions
    you call via bl or blr. Nonvolatile registers will maintain their values across
    function calls you make, but you must explicitly preserve their values if you
    modify them within your functions.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，当在函数中使用易失性寄存器时，你不必在函数内保存（保存并恢复）它们的值。然而，这也意味着你不能指望它们在你通过 `bl` 或 `blr` 调用的任何函数中保持其值。非易失性寄存器将在你调用的函数之间保持其值，但如果在函数内修改它们，你必须显式地保存其值。
- en: 1.9.2 Parameter Passing and Function Result Conventions
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.9.2 参数传递和函数结果约定
- en: '[Chapter 5](chapter5.xhtml) provides a complete discussion of parameter passing
    and function results in assembly language. However, when calling functions written
    in a different languages (particularly HLLs), you must adhere to the conventions
    that language uses. Most HLLs use the ARM ABI as the convention for passing parameters.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](chapter5.xhtml)提供了关于汇编语言中参数传递和函数结果的完整讨论。然而，当调用用其他语言编写的函数（尤其是高级语言）时，你必须遵循该语言使用的约定。大多数高级语言使用
    ARM ABI 作为参数传递的约定。'
- en: The ARM ABI uses registers X0 through X7 to pass up to eight integer parameters
    to a function. These parameters can be 8-, 16-, 32-, or 64-bit entities. You pass
    the first parameter in X0, the second in X1, and so on. To pass fewer than eight
    parameters, simply ignore the additional registers in this set. [Chapter 5](chapter5.xhtml)
    discusses how to pass more than eight parameters and how to pass data types larger
    than 64 bits, including arrays and structs. [Chapter 6](chapter6.xhtml) covers
    how to pass floating-point values to a function.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ARM ABI 使用寄存器 X0 到 X7 向函数传递最多八个整数参数。这些参数可以是 8 位、16 位、32 位或 64 位的实体。第一个参数传递在
    X0 中，第二个在 X1 中，依此类推。如果传递少于八个参数，只需忽略该组中额外的寄存器。[第 5 章](chapter5.xhtml)讨论了如何传递超过八个参数以及如何传递大于
    64 位的数据类型，包括数组和结构体。[第 6 章](chapter6.xhtml)介绍了如何将浮点值传递给函数。
- en: You can also return function results in these registers. Most functions return
    integer results in X0\. If you’re returning a large object by value, like a structure,
    array, or string, you typically use X8 to return a pointer to that data object.
    [Chapter 6](chapter6.xhtml) discusses returning floating-point function results.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在这些寄存器中返回函数结果。大多数函数将整数结果返回在 X0 中。如果你返回一个较大的对象值，比如结构体、数组或字符串，通常使用 X8 来返回指向该数据对象的指针。[第
    6 章](chapter6.xhtml)讨论了如何返回浮点函数结果。
- en: Registers X0 through X7 are volatile, meaning you can’t expect a called function
    to preserve the original register values on return. This is true even if you don’t
    use all eight registers to pass parameter values. If you want to preserve a value
    across function calls, use a nonvolatile register.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器 X0 到 X7 是易失性的，意味着你不能指望被调用的函数在返回时保留原始的寄存器值。即使你没有使用所有八个寄存器来传递参数值，这也是成立的。如果你想在函数调用之间保留一个值，应该使用非易失性寄存器。
- en: 1.10 Calling C Library Functions
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.10 调用 C 库函数
- en: All the coding examples in this book so far have immediately returned to the
    OS, apparently without accomplishing anything. While it is theoretically possible
    for a pure assembly language program to produce its own output, it takes a lot
    of work and is largely beyond the scope of this book. Instead, this book calls
    prewritten C/C++ library code to do the I/O. This section discusses how this is
    done.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有编码示例迄今为止都直接返回给操作系统，表面上看似没有做任何事情。虽然理论上纯汇编语言程序是可以产生自己的输出的，但这需要大量的工作，且大部分超出了本书的范围。因此，本书调用了预写的
    C/C++ 库代码来进行输入输出。本节讨论了如何实现这一点。
- en: Most other books on assembly language that use libraries in this way call the
    OS by using available *application programming interfaces (APIs)*. This is a reasonable
    approach, but such code is tied to the particular OS for which the calls are made
    (see [Chapter 16](chapter16.xhtml) for examples). This book instead relies on
    library functions written in the C stdlib, since it’s available on many OSes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用库的汇编语言书籍通过调用现有的 *应用程序编程接口 (APIs)* 来与操作系统交互。这是一种合理的方法，但这种代码与特定操作系统紧密相关（有关示例，请参见[第
    16 章](chapter16.xhtml)）。本书则依赖于 C 标准库中的库函数，因为它在许多操作系统上都可用。
- en: 'In most introductory programming books, the first programming example provided
    is the venerable “Hello, world!” program. Here’s that program written in C:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数入门编程书籍中，提供的第一个编程示例通常是经典的“Hello, world!”程序。以下是用 C 语言编写的该程序：
- en: '[PRE44]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Except for an actual printf() statement, the assembly language source files
    given thus far have fulfilled the purpose of the “Hello, world!” example: learning
    how to edit, compile, and run a simple program.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际的 printf() 语句外，迄今为止提供的汇编语言源文件已经实现了“Hello, world!”示例的目的：学习如何编辑、编译和运行一个简单的程序。
- en: Most of this book uses the C printf() function to handle program output to the
    console. This function requires one or more arguments—that is, a *variable-length*
    parameter list. The first argument is the address of a *format string*. If that
    string requires it, additional parameters provide data to convert to string form.
    For the “Hello, world!” program, the format string ("Hello, world!\n") is the
    only argument.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的大部分内容使用 C 的 printf() 函数来处理程序输出到控制台。这个函数需要一个或多个参数——即 *可变长度* 参数列表。第一个参数是 *格式字符串*
    的地址。如果该字符串需要，额外的参数将提供要转换为字符串的数据显示。对于“Hello, world!”程序，格式字符串（"Hello, world!\n"）是唯一的参数。
- en: 'The C stdlib—and all C functions, for that matter—adheres to the ARM ABI. Therefore,
    printf() expects its first argument, the format string, in the X0 register. Instead
    of trying to pass a string (with 14 characters, including the newline) in a 64-bit
    register, we pass the address of that string in memory. If we put the string "Hello,
    world!\n" in the .text section along with the program (out of the way, so the
    CPU doesn’t try to execute it as code), then we can compute the address of that
    string by using the lea macro:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准库——以及所有 C 函数——遵循 ARM ABI。因此，printf() 期望其第一个参数，即格式字符串，在 X0 寄存器中。我们不是尝试将一个包含
    14 个字符（包括换行符）的字符串传递给一个 64 位寄存器，而是将该字符串在内存中的地址传递过去。如果我们将字符串“Hello, world!\n”放置在
    .text 区段中，并与程序一起（避免 CPU 将其当作代码执行），那么我们可以通过使用 lea 宏来计算该字符串的地址：
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once we have this string address in X0, calling printf() prints that string
    to the standard output device:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 X0 寄存器中获取了该字符串的地址，调用 printf() 就可以将该字符串打印到标准输出设备上：
- en: '[PRE46]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To run, this program must be linked against the C stdlib and a small C/C++ program
    like the one in Listing 1-2\. Rather than grabbing that program, I’ll create a
    slightly better version in Listing 1-4 to use with almost every example program
    in the rest of this book.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行，本程序必须与 C 标准库以及类似清单 1-2 中的小型 C/C++ 程序链接。与其拿取那个程序，我将在清单 1-4 中创建一个稍微改进的版本，以供本书后续几乎所有示例程序使用。
- en: '[PRE47]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This program contains a few additional features over Listing 1-2\. First, the
    name of the assembly language function has changed to asmMain() ❶, the assembly
    language main program. This code also requires a second assembly function, getTitle()
    ❷. This function, provided by the assembly language source code, returns a pointer
    to a zero-terminated string containing the program’s title. The program displays
    this title before and after calling asmMain().
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序相较于清单 1-2 中的程序，新增了一些功能。首先，汇编语言函数的名称已更改为 asmMain() ❶，即汇编语言主程序。此代码还需要第二个汇编函数，getTitle()
    ❷。该函数由汇编语言源代码提供，返回一个指向零终止字符串的指针，该字符串包含程序的标题。程序在调用 asmMain() 之前和之后都会显示该标题。
- en: The readLine() function appears in the C program that reads a line of text from
    the user and stores that text into a buffer specified by the caller ❸. You can
    call this function from the example assembly code, sparing you from having to
    write the function in assembly (it’s grunt work better done in C). You’ll see
    examples of this function call in later chapters.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: readLine() 函数出现在 C 程序中，它读取用户输入的一行文本，并将该文本存储到调用者指定的缓冲区 ❸。你可以从示例汇编代码中调用这个函数，这样就不必在汇编中编写该函数（这是更适合在
    C 中完成的琐碎工作）。你将在后续章节中看到该函数调用的示例。
- en: This file (appearing as *Listing1-4.cpp* or *c.cpp* in the online code) requires
    the assembly code to provide a getTitle() function that returns the address of
    a string so the C program can display the name. This string is embedded in the
    assembly language source file, since most of the programs in this book use only
    one version of *c.cpp*. The getTitle() function is the same in every program
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件（在在线代码中显示为*Listing1-4.cpp* 或 *c.cpp*）要求汇编代码提供一个 getTitle() 函数，返回一个字符串的地址，以便
    C 程序可以显示该名称。这个字符串被嵌入在汇编语言源文件中，因为本书中的大多数程序只使用一个版本的*c.cpp*。getTitle() 函数在每个程序中都是相同的。
- en: '[PRE48]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'where title is a zero-terminated string appearing elsewhere in your program
    (usually in the .data section). That declaration will usually take this form:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 title 是一个在程序的其他地方出现的零终止字符串（通常在 .data 区段）。该声明通常采用以下形式：
- en: '[PRE49]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The getTitle function returns the address of this string to the *c.cpp* program.
    The string following the .asciz directive will typically be the name of the assembly
    language source file (I used *Listing1-5* in this example).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: getTitle 函数返回该字符串的地址给 *c.cpp* 程序。紧跟 .asciz 指令后的字符串通常是汇编语言源文件的名称（在此示例中，我使用了 *Listing1-5*）。
- en: 1.10.1 Assembling Programs Under Multiple OSes
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.10.1 在多个操作系统下汇编程序
- en: 'We could easily bang out a “Hello, world!” program for Linux or macOS at this
    point, but the programs would be slightly different for each OS. So that we don’t
    need to use a different include file for each OS, I’ve modified *aoaa.inc* to
    look for a couple of symbol definitions: isMacOS and isLinux. Both symbols must
    be defined with the CPP #define declaration, and one must be true (1) while the
    other is false (0). The *aoaa.inc* file uses these symbols to adjust the definitions
    present in the file for the appropriate OS.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '此时，我们可以轻松地为 Linux 或 macOS 编写一个“Hello, world!”程序，但每个操作系统的程序会略有不同。为了避免为每个操作系统使用不同的包含文件，我已经修改了*aoaa.inc*，使其查找几个符号定义：isMacOS
    和 isLinux。两个符号必须通过 CPP 的 #define 声明来定义，其中一个必须为真（1），另一个为假（0）。*aoaa.inc* 文件使用这些符号来调整文件中适用于特定操作系统的定义。'
- en: 'In theory, we could use code like the following to define these symbols:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以使用如下代码来定义这些符号：
- en: '[PRE50]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, this would force every example program to have two versions, one for
    macOS (the example just given) and one for Linux, containing the following statements:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将迫使每个示例程序都有两个版本，一个用于 macOS（如刚才给出的示例），另一个用于 Linux，包含以下语句：
- en: '[PRE51]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'GCC has a preferable command line option that lets you define a preprocessor
    symbol and give it a value:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 有一个更优的命令行选项，可以让你定义一个预处理器符号并为其赋值：
- en: '[PRE52]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This way, the following commands will automatically define the symbol prior
    to assembling the *source.S* file:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，以下命令将在汇编 *source.S* 文件之前自动定义符号：
- en: '[PRE53]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can specify the OS from the command line in this way so that the source files
    (*source.S* and *aoaa.inc*) don’t require any changes under either macOS or Linux.
    To avoid any extra typing required to assemble the program, we’ll use a command
    line program known as a *shell script*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这种方式在命令行中指定操作系统，以便源文件（*source.S* 和 *aoaa.inc*）在 macOS 或 Linux 下无需任何修改。为了避免在汇编程序时需要额外的输入，我们将使用一种命令行程序，称为*shell脚本*。
- en: While writing a shell script for this purpose, I also further automated the
    build process. The script, named *build*, accepts the base name of an example
    file without a suffix and automatically deletes any existing object or executable
    files with that base name (a *clean* operation, in Unix terminology). It then
    determines which OS *build* is running on and then automatically generates the
    appropriate GCC command line to build the example.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这个用途的 shell 脚本时，我还进一步自动化了构建过程。该脚本名为*build*，接受一个示例文件的基本名称（不带后缀），并自动删除任何具有该基本名称的现有目标文件或可执行文件（在
    Unix 术语中为*clean*操作）。然后，它确定*build*运行所在的操作系统，并自动生成适当的 GCC 命令行以构建示例。
- en: 'For example, to build a file named *example.S*, you’d execute the following
    command:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要构建一个名为 *example.S* 的文件，你将执行以下命令：
- en: '[PRE54]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Under Linux, this would generate the following command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 下，这将生成以下命令：
- en: '[PRE55]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Under macOS, it would generate the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 下，它将生成以下内容：
- en: '[PRE56]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The *build* script also supports a couple of command line options: -c and -pie.
    The -c (compile-only) option generates the following command line, which only
    assembles the assembly file to an object file; it does not compile *c.cpp*, nor
    does it produce an executable:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*build*脚本还支持几个命令行选项：-c 和 -pie。-c（仅编译）选项生成以下命令行，它只将汇编文件汇编为目标文件；它不会编译*c.cpp*，也不会生成可执行文件：'
- en: '[PRE57]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This executes the following command as appropriate:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据需要执行以下命令：
- en: '[PRE58]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: or
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The -pie option applies only to Linux. It issues the appropriate commands to
    tell Linux to produce a position-independent executable file (by default, Linux
    produces a non-position-independent executable). Because macOS’s assembler always
    produces PIE code, this option is ignored under macOS.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: -pie选项仅适用于Linux。它会发出相应的命令，告诉Linux生成一个位置无关的可执行文件（默认情况下，Linux会生成一个位置相关的可执行文件）。由于macOS的汇编器始终生成PIE代码，因此在macOS下此选项会被忽略。
- en: 'For the curious, I’ve provided the text for this shell script in the file *build*
    without further comment, as writing shell scripts is beyond the scope of this
    book:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的人，我已将这个shell脚本的文本提供在*build*文件中，没有进一步的注释，因为编写shell脚本超出了本书的范围：
- en: '[PRE60]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Check out a book on GNU’s bash shell interpreter if you want to learn how this
    works (see section 1.12, “For More Information,” on [page 43](chapter1.xhtml#pg_43)).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解其工作原理，可以查阅一本关于GNU bash shell解释器的书（请参见第1.12节，“更多信息”，在[第43页](chapter1.xhtml#pg_43)）。
- en: 'The *build* shell script is available in electronic form at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*.
    Execute the following command to make this file executable from the bash command
    line on your Linux or macOS system:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '*build*脚本以电子形式提供，网址为*[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*。在Linux或macOS系统的bash命令行中执行以下命令，以使此文件可执行：'
- en: '[PRE61]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This makes the *build* script executable. See [Appendix D](appendix-D.xhtml)
    for more information about the chmod command.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得*build*脚本变为可执行文件。有关chmod命令的更多信息，请参见[附录D](appendix-D.xhtml)。
- en: 1.10.2 Writing a “Hello, World!” Program
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.10.2 编写“Hello, World！”程序
- en: You finally have the pieces in place to write a complete “Hello, world!” program,
    as shown in Listing 1-5.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经完成了编写一个完整的“Hello, world！”程序的各个步骤，如Listing 1-5所示。
- en: '[PRE62]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The title string ❶ holds the program’s title ("Listing 1-5" in this example).
    The hwStr variable holds the Hello, world! string that the main program will pass
    to the printf() function. The getTitle() function ❷ returns the address of the
    title string to the *c.cpp* program. As per the ARM ABI, this function returns
    the function result in the X0 register.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 标题字符串❶包含程序的标题（在本例中是“Listing 1-5”）。hwStr变量包含主程序将传递给printf()函数的“Hello, world!”字符串。getTitle()函数❷将标题字符串的地址返回给*c.cpp*程序。根据ARM
    ABI，此函数将函数结果返回至X0寄存器。
- en: Upon entry into the asmMain() function (the assembly language main program),
    the code must preserve the contents of the LR register because the call to printf()
    will overwrite its value. This code saves the LR register (which holds the return
    address to the *c.cpp* main function) in the saveLR global variable in the .data
    section ❶.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 进入asmMain()函数（汇编语言主程序）时，代码必须保存LR寄存器的内容，因为调用printf()将覆盖其值。这段代码将LR寄存器（它保存着返回到*c.cpp*主函数的地址）保存到.data段中的saveLR全局变量❶。
- en: NOTE
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Saving the LR register value in this fashion is not good practice. In [Chapter
    3](chapter3.xhtml) you’ll learn about the ARM stack and discover a much better
    place to save return addresses held in LR.*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*以这种方式保存LR寄存器的值并不是一种好做法。在[第3章](chapter3.xhtml)中，你将了解ARM堆栈，并发现一个更好的地方来保存LR寄存器中保存的返回地址。*'
- en: The code that actually prints Hello, world! ❸ loads X0 with the printf() format
    string as per the ARM ABI, then calls printf() by using the bl instruction. Before
    returning to *c.cpp*, the assembly code must reload LR with the returned address
    held in saveLR ❹.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 实际打印“Hello, world!”的代码❸根据ARM ABI将printf()格式字符串加载到X0寄存器中，然后使用bl指令调用printf()。在返回到*c.cpp*之前，汇编代码必须使用保存在saveLR中的返回地址重新加载LR寄存器❹。
- en: 'Here are the commands to build and run the program in Listing 1-5, along with
    the program’s output:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建并运行Listing 1-5中的程序的命令，以及程序的输出：
- en: '[PRE63]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You now have a functioning “Hello, world!” program in assembly language.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有一个功能正常的汇编语言“Hello, world！”程序。
- en: 1.11 Moving On
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.11 继续前进
- en: This chapter equipped you with the prerequisites to start learning new assembly
    language features in the chapters that follow. You learned the basic syntax of
    a Gas program and the basic 64-bit ARM architecture, and how to use the *aoaa.inc*
    header file to make source files portable between macOS and Linux. You also learned
    how to declare some simple global variables, use a few machine instructions, and
    assemble a Gas program with C/C++ code so you can call routines in the C stdlib
    (using the *build* script file). Finally, you ran that program from the command
    line.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了学习后续章节中新汇编语言特性的必要基础。你学习了Gas程序的基本语法、基本的64位ARM架构，以及如何使用*aoaa.inc*头文件使源文件在macOS和Linux之间可移植。你还学习了如何声明一些简单的全局变量，使用几条机器指令，以及如何将Gas程序与C/C++代码组合，以便你可以调用C标准库中的例程（使用*build*脚本文件）。最后，你从命令行运行了该程序。
- en: The next chapter introduces you to *data representation*, one of the main reasons
    for learning assembly language in the first place.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍*数据表示*，这是学习汇编语言的主要原因之一。
- en: 1.12 For More Information
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.12 更多信息
- en: For more information about the bash shell interpreter, visit the reference manual
    at *[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/bash<wbr>/manual<wbr>/bash<wbr>.html](https://www.gnu.org/software/bash/manual/bash.html)*.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关bash shell解释器的更多信息，请访问参考手册中的*[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/bash<wbr>/manual<wbr>/bash<wbr>.html](https://www.gnu.org/software/bash/manual/bash.html)*。
- en: For more information about the GNU assembler, visit the reference manual at
    *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_chapter<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html)*.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关GNU汇编器的更多信息，请访问参考手册中的*[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_chapter<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html)*。
- en: You can find an online guide to 64-bit ARM assembly language at *[https://<wbr>modexp<wbr>.wordpress<wbr>.com<wbr>/2018<wbr>/10<wbr>/30<wbr>/arm64<wbr>-assembly<wbr>/](https://modexp.wordpress.com/2018/10/30/arm64-assembly/)*.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在*[https://<wbr>modexp<wbr>.wordpress<wbr>.com<wbr>/2018<wbr>/10<wbr>/30<wbr>/arm64<wbr>-assembly<wbr>/](https://modexp.wordpress.com/2018/10/30/arm64-assembly/)*找到64位ARM汇编语言的在线指南。
- en: If you’re interested in programming ARM assembly language on Apple platforms,
    see *[https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/xcode<wbr>/writing<wbr>-arm64<wbr>-code<wbr>-for<wbr>-apple<wbr>-platforms](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms)*.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你对在Apple平台上编程ARM汇编语言感兴趣，请参见*[https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/xcode<wbr>/writing<wbr>-arm64<wbr>-code<wbr>-for<wbr>-apple<wbr>-platforms](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms)*。
- en: The ARM developer portal at *[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*
    provides generic information about ARM CPUs and ARM assembly language programming.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM开发者门户网站*[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*提供有关ARM
    CPU和ARM汇编语言编程的通用信息。
