- en: Chapter 3. Building and Rebuilding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 构建与重建
- en: Knowing when and why targets are rebuilt and recipes run is fundamental to using
    GNU `make`. For simple makefiles, it’s easy to understand why a particular object
    file was built, but for real-world makefiles, building and rebuilding becomes
    complex. In addition, GNU `make` dependencies can be limiting because files are
    updated when the modification time of a prerequisite is later than the target.
    And in most cases, only a single target is updated by a single rule.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 了解何时以及为何重新构建目标和执行配方是使用 GNU `make` 的基础。对于简单的 makefile，很容易理解为什么会构建某个特定的目标文件，但对于现实世界中的
    makefile，构建和重新构建变得更加复杂。此外，GNU `make` 的依赖关系可能会受到限制，因为文件只有在先决条件的修改时间晚于目标文件时才会更新。而且在大多数情况下，只有一个目标会由一个规则更新。
- en: This chapter explains advanced techniques for handling dependencies in GNU `make`,
    including rebuilding when the recipe of a target changes, rebuilding when a checksum
    of a file changes, how best to implement recursive `make`, and how to build multiple
    targets in a single rule.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了在 GNU `make` 中处理依赖关系的高级技巧，包括在目标的配方发生变化时重新构建，在文件的校验和发生变化时重新构建，如何最好地实现递归
    `make`，以及如何在一个规则中构建多个目标。
- en: Rebuilding When CPPFLAGS Changes
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当 CPPFLAGS 变化时重新构建
- en: 'This section shows you how to implement an important “missing feature” of GNU
    `make`: the ability to rebuild targets when the commands for those targets change.
    GNU `make` rebuilds a target when it is *out of date*; that is, it rebuilds when
    some of the prerequisites are newer than the target itself. But what if the target
    appears up-to-date when looking at file timestamps, but the actual commands to
    build the target have changed?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何实现 GNU `make` 中一个重要的“缺失功能”：当目标的构建命令发生变化时，重新构建目标的能力。GNU `make` 在目标*过时*时重新构建目标；也就是说，当某些先决条件比目标本身更新时，它会重新构建。但是如果目标看起来是最新的（通过文件时间戳判断），但实际构建该目标的命令已经发生变化怎么办？
- en: For example, what happens when a non-debug build is followed by a debug build
    (perhaps by running `make` followed by `make DEBUG=1`)? Unless the build has been
    structured so the names of targets depend on whether the build is debug or non-debug,
    nothing happens.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当一个非调试构建之后跟着一个调试构建（可能是先运行 `make` 然后运行 `make DEBUG=1`）时会发生什么？除非构建结构设计得当，使得目标的名称依赖于是否为调试或非调试构建，否则不会发生任何变化。
- en: GNU `make` has no way of detecting that some targets ought to be rebuilt, because
    it doesn’t take into account any change to the commands in recipes. If, for example,
    `DEBUG=1` causes the flags passed to the compiler to change, the target should
    be rebuilt.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 无法检测某些目标是否应该重新构建，因为它没有考虑到配方中的命令发生变化的情况。例如，如果 `DEBUG=1` 导致传递给编译器的标志发生变化，那么目标应该重新构建。
- en: In this section you’ll learn how to make that happen in a few lines of GNU `make`
    code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将教你如何通过几行 GNU `make` 代码实现这一目标。
- en: An Example Makefile
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 makefile
- en: 'The example makefile in [Example 3-1](ch03.html#example_makefile_for_demonstrating_the_r
    "Example 3-1. An example makefile for demonstrating the rebuilding when commands
    change system.") is used throughout this section to demonstrate the *rebuilding
    when commands change* system. To make the operation of the system very clear,
    I’ve avoided using built-in GNU `make` rules, so this makefile isn’t as simple
    as it could be:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中使用的示例 makefile 来自 [示例 3-1](ch03.html#example_makefile_for_demonstrating_the_r
    "示例 3-1：用于演示命令变化时重新构建系统的示例 makefile")，用于演示*命令变化时重新构建*系统。为了使系统的操作更加清晰，我避免使用内建的
    GNU `make` 规则，因此这个 makefile 并不像它本可以那么简单：
- en: Example 3-1. An example makefile for demonstrating the rebuilding when commands
    change system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-1：用于演示命令变化时重新构建系统的示例 makefile。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The makefile creates two `.o` files, `foo.o` and `bar.o`, by compiling corresponding
    `.c` files. The compilation is done using the built-in variable `COMPILE.C` (which
    will normally be the name of a suitable compiler for the system, followed by references
    to variables like `CPPFLAGS` and use of `$@` and `$<` to compile the code into
    an object file).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该 makefile 通过编译相应的 `.c` 文件来创建两个 `.o` 文件，`foo.o` 和 `bar.o`。编译使用内建变量 `COMPILE.C`（通常是系统中适用的编译器名称，后面跟着类似
    `CPPFLAGS` 的变量以及使用 `$@` 和 `$<` 编译代码成目标文件）。
- en: A specific reference to `$(DEBUG)` is turned into a pre-processor variable called
    `DEBUG` using the compiler’s `-D` option. The contents of `foo.c` and `bar.c`
    have been omitted because they are irrelevant.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `$(DEBUG)` 的特定引用被转换为一个名为 `DEBUG` 的预处理器变量，使用编译器的 `-D` 选项。`foo.c` 和 `bar.c`
    的内容已被省略，因为它们无关紧要。
- en: 'Here’s what happens when `make` is run with no command line options (which
    means that `DEBUG` is undefined):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在没有命令行选项的情况下运行`make`时发生的情况（这意味着`DEBUG`是未定义的）：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now `foo.o` and `bar.o` have been created, so typing `make` again does nothing:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`foo.o`和`bar.o`已经被创建，因此再次输入`make`不会做任何事情：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Typing `make DEBUG=1` also does nothing, even though the object file `foo.o`
    would likely be different if it were rebuilt with `DEBUG` defined (for example,
    it would likely contain extra debugging code controlled by `#ifdef`s that use
    the `DEBUG` variable in the source code):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`make DEBUG=1`也不会产生任何效果，即使如果使用`DEBUG`定义重建，`foo.o`文件很可能会有所不同（例如，它可能会包含由`#ifdef`控制的额外调试代码，`DEBUG`变量在源代码中被使用）：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `signature` system in the next section will correct that problem and require
    very little work for the makefile maintainer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节中的`signature`系统将修正这个问题，并且对 Makefile 维护者几乎不需要任何额外工作。
- en: Changing Our Example Makefile
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改我们的示例 Makefile
- en: 'To fix the problem in the preceding section, we’ll use a helper makefile called
    `signature`. We’ll look at how `signature` works in a moment; first let’s look
    at how to modify the makefile in [Example 3-1](ch03.html#example_makefile_for_demonstrating_the_r
    "Example 3-1. An example makefile for demonstrating the rebuilding when commands
    change system.") to use it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决前面一节中的问题，我们将使用一个辅助的 Makefile，名为`signature`。我们稍后会看看`signature`是如何工作的；首先，让我们看看如何修改[示例
    3-1](ch03.html#example_makefile_for_demonstrating_the_r "示例 3-1：演示命令变更时重建的 Makefile
    示例")中的 Makefile 来使用它：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Three changes were made to the file: first, `include signature` was added at
    the start so the code that handles the updating of *signatures* is included. These
    signatures will capture the commands used to build files and be used to rebuild
    when the commands change.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 文件做了三个更改：首先，`include signature`被添加到开头，这样处理更新*签名*的代码就被包含了。这些签名将捕获用于构建文件的命令，并在命令发生变化时用于重新构建。
- en: Second, the commands in the two rules were wrapped with `$(call do,...)`, and
    the `$` signs for each command have been quoted with a second `$`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，两个规则中的命令被包裹在`$(call do,...)`中，并且每个命令的`$`符号被用第二个`$`进行了转义。
- en: Third, for each `.o` file being managed by signature, there’s an `include` of
    a corresponding `.sig` file. The final line of the makefile includes `foo.o.sig`
    (for `foo.o`) and `bar.o.sig` (for `bar.o`). Notice that `-include` is used instead
    of just `include` in case the `.sig` file is missing (`-include` doesn’t generate
    an error when one of the files to be included is not present).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，对于每个由`signature`管理的`.o`文件，都有一个对应的`.sig`文件的`include`。Makefile的最后一行包括了`foo.o.sig`（对于`foo.o`）和`bar.o.sig`（对于`bar.o`）。请注意，使用了`-include`而不是单纯的`include`，以防`.sig`文件缺失（`-include`在要包含的文件不存在时不会产生错误）。
- en: 'Before you see how this works, here are some examples of it in operation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在你看到它是如何工作的之前，以下是一些它运行时的示例：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, there’s a clean build (with no `.o` files present) and then a rerun of
    `make` to see that there’s nothing to do.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行一次干净的构建（没有`.o`文件），然后重新运行`make`，以查看没有任何操作。
- en: 'But setting `DEBUG` to `1` on the `make` command line now causes `foo.o` to
    rebuild:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，现在在`make`命令行中将`DEBUG`设置为`1`会导致`foo.o`重新构建：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This happens because its *signature* (the actual commands to be run to build
    `foo.o`) has changed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为它的*签名*（用于构建`foo.o`的实际命令）发生了变化。
- en: 'Of course, `bar.o` was not rebuilt because it was truly up-to-date (its object
    code was new and there were no command changes). Run `make DEBUG=1` again, and
    it’ll say there’s nothing to be done:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`bar.o`没有被重新构建，因为它确实是最新的（它的目标代码是新的，并且没有命令变化）。再次运行`make DEBUG=1`时，它会显示没有任何需要做的事情：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But just typing `make` (going back to a non-debug build) rebuilds `foo.o` again
    because `DEBUG` is now undefined.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，只需输入`make`（回到非调试构建模式）就会再次重建`foo.o`，因为`DEBUG`现在未定义。
- en: 'The signature system also works for variables within recursive variables. In
    GNU `make`, `COMPILE.C` actually expands `CPPFLAGS` to create the complete compiler
    command line. Here’s what happens if `CPPFLAGS` is modified on the GNU `make`
    command line by adding a definition:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`signature`系统同样适用于递归变量中的变量。在GNU `make`中，`COMPILE.C`实际上展开了`CPPFLAGS`以创建完整的编译器命令行。如果通过添加定义在GNU
    `make`命令行中修改了`CPPFLAGS`，会发生以下情况：'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Both `foo.o` and `bar.o` were rebuilt because `CPPFLAGS` changed (and because
    `CPPFLAGS` was part of the commands used to build those two object files).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CPPFLAGS`发生了变化（并且`CPPFLAGS`是用于构建这两个目标文件的命令的一部分），所以`foo.o`和`bar.o`都被重新构建了。
- en: 'Of course, changing a variable that isn’t referenced doesn’t update anything.
    For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，修改一个未被引用的变量并不会更新任何内容。例如：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we’re starting from a clean build and redefining `SOMEVAR`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们从一个干净的构建开始，并重新定义了`SOMEVAR`。
- en: How Signature Works
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名如何工作
- en: To understand how `signature` works, first look inside a `.sig` file. The `.sig`
    files are automatically generated by rules in the `signature` makefile for each
    rule that uses the `$(call do,...)` form.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`signature`是如何工作的，首先查看`.sig`文件。`.sig`文件是由`signature` makefile中的规则自动生成的，适用于每个使用`$(call
    do,...)`形式的规则。
- en: 'For example, here are the contents of the `foo.o.sig` file after the first
    clean build was run:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是第一次干净构建运行后`foo.o.sig`文件的内容：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first seven lines capture the state of the automatic variables as defined
    when the `foo.o` rule is being processed. We need the values of these variables
    so we can compare the current commands for a rule (which likely use automatic
    variables) with the commands the last time the rule was run.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前七行捕捉了在处理`foo.o`规则时定义的自动变量的状态。我们需要这些变量的值，以便将当前规则的命令（可能使用了自动变量）与上次运行该规则时的命令进行比较。
- en: 'Next comes the line `foo.o: foo.o.force`. This states that `foo.o` must be
    rebuilt if `foo.o.force` is newer. It’s this line that causes `foo.o` to get rebuilt
    when the commands change, and it’s the next line that touches `foo.o.force` if
    the commands have changed.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来是`foo.o: foo.o.force`这一行。这表示如果`foo.o.force`更新了，`foo.o`必须重新构建。正是这一行导致了`foo.o`在命令变化时被重建，下一行则会在命令发生变化时更新`foo.o.force`。'
- en: The long `$(if)` statement uses the GMSL `sne` (string not equal) function to
    compare the current commands for `foo.o` (by expanding them) against their value
    the last time they were expanded. If the commands have changed, `$(shell touch
    foo.o.force)` is called.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 长的`$(if)`语句使用GMSL的`sne`（字符串不等）函数，将`foo.o`的当前命令（通过展开它们）与上次展开时的值进行比较。如果命令发生变化，则会调用`$(shell
    touch foo.o.force)`。
- en: Because the `.sig` files are processed when the makefile is being parsed (they
    are just makefiles, read using `include`), all the `.force` files will have been
    updated before any rules run. And so this small `.sig` file does all the work
    of forcing an object file to rebuild when commands change.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`.sig`文件在解析makefile时被处理（它们只是使用`include`读取的makefile），所有`.force`文件将在任何规则运行之前被更新。因此，这个小小的`.sig`文件在命令发生变化时，完成了强制重建目标文件的工作。
- en: 'The `.sig` files are created by `signature`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sig`文件由`signature`创建：'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`signature` includes the GMSL and then defines the important `do` variable
    used to wrap the commands in a rule. When `do` is called, it creates the appropriate
    `.sig` file containing the state of all the automatic variables.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`signature`包含了GMSL，并定义了用于封装规则中命令的关键`do`变量。当调用`do`时，它会创建相应的`.sig`文件，包含所有自动变量的状态。'
- en: The `new_rule` function called by `do` captures the automatic variables. It
    uses the GMSL `map` function to call another function (`dump_var`) for each of
    `@ % < ? ^ + *`. The `new_rule` function also ensures that the corresponding `.force`
    file has been created.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`调用的`new_rule`函数捕捉了自动变量。它使用GMSL的`map`函数，调用另一个函数（`dump_var`），对每个`@ % < ?
    ^ + *`进行处理。`new_rule`函数还确保创建了相应的`.force`文件。'
- en: In addition, `do` writes out the complex `$(if)` statement that contains the
    unexpanded and expanded versions of the commands for the current rule. Then it
    actually runs the commands (that’s the `$C`) at the end.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`do`会写出复杂的`$(if)`语句，包含当前规则的命令的未展开和已展开版本。然后，它会在最后实际执行这些命令（那就是`$C`）。
- en: Limitations
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制
- en: The signature system has some limitations that could trap the unwary. First,
    if the commands in a rule contain any side effects—for example, if they call `$(shell)`—the
    system may misbehave if there was an assumption that the side effect happens only
    once.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 签名系统有一些限制，可能会让不小心的人陷入困境。首先，如果规则中的命令包含任何副作用——例如，如果它们调用了`$(shell)`——如果假设副作用只发生一次，系统可能会出现异常。
- en: Second, it’s vital that `signature` is included before any of the `.sig` files.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，必须确保在任何`.sig`文件之前包含`signature`。
- en: Third, if the makefile is edited and the commands in a rule change, the signature
    system will not notice. If that happens, it’s vital to regenerate the corresponding
    target so the `.sig` is updated.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，如果编辑了makefile并且规则中的命令发生了变化，签名系统不会注意到这一点。如果发生这种情况，必须重新生成相应的目标，以便更新`.sig`文件。
- en: 'Try adding the following line at the end of the definition of `new_rule`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在`new_rule`定义的末尾添加以下一行：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can make the signature system automatically rebuild when the makefile changes
    by having the makefile as a prerequisite to each of the makefile’s targets. This
    line is the simplest way to achieve that.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 makefile 作为每个 makefile 目标的前置条件来让签名系统在 makefile 发生变化时自动重新构建。这行代码是实现这一点的最简单方法。
- en: Rebuilding When a File’s Checksum Changes
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当文件的校验和发生变化时重新构建
- en: Besides having GNU `make` rebuild targets when commands change, another common
    technique is to rebuild when the contents of a file change, not just the file’s
    timestamp.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让 GNU `make` 在命令更改时重新构建目标外，另一种常见的技术是，当文件内容发生变化时重新构建，而不仅仅是文件的时间戳。
- en: This usually comes up because the timestamps on generated code, or in code extracted
    from a source code control system, are older than related objects, so GNU `make`
    does not know to rebuild the object. This can happen even when the contents of
    the file are different from the last time the object was built.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况通常出现是因为生成的代码的时间戳，或者从源代码控制系统提取的代码的时间戳，比相关对象的时间戳要旧，因此 GNU `make` 不知道需要重新构建该对象。即使文件的内容与上次构建该对象时不同，仍然可能发生这种情况。
- en: A common scenario is that an engineer working on a build on their local machine
    rebuilds all objects and later gets the latest version of source files from source
    code control. Some older source control systems set the timestamp on the source
    files to the timestamp of the file when it was checked in to source control; in
    that case, newly built object files may have timestamps that are newer than the
    (potentially changed) source code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的场景是，某个工程师在本地机器上进行构建，重新构建所有对象文件，然后从源代码控制中获取最新版本的源文件。一些较旧的源代码控制系统将源文件的时间戳设置为文件提交到源代码控制时的时间戳；在这种情况下，新构建的对象文件的时间戳可能比（可能已经更改的）源代码文件还要新。
- en: In this section you’ll learn a simple hack to get GNU `make` to do the right
    thing (rebuild) when the contents of a source file change.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习一种简单的技巧，让 GNU `make` 在源文件内容发生变化时正确地执行（重新构建）。
- en: An Example Makefile
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例 Makefile
- en: 'The simple makefile in [Example 3-2](ch03.html#simple_makefile_that_builds_foodoto_from
    "Example 3-2. A simple makefile that builds foo.o from foo.c and foo.h") builds
    object file `foo.o` from `foo.c` and `foo.h` using the built-in rule to make a
    `.o` file from a `.c`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-2](ch03.html#simple_makefile_that_builds_foodoto_from "示例 3-2. 一个简单的
    makefile，从 foo.c 和 foo.h 构建 foo.o") 中的简单 makefile 使用内置规则从 `.c` 文件构建 `.o` 文件，生成对象文件
    `foo.o`，方法是从 `foo.c` 和 `foo.h` 中构建：'
- en: Example 3-2. A simple makefile that builds `foo.o` from `foo.c` and `foo.h`
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-2. 一个简单的 makefile，从 `foo.c` 和 `foo.h` 构建 `foo.o`
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If either `foo.c` or `foo.h` are newer than `foo.o`, then `foo.o` will be rebuilt.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `foo.c` 或 `foo.h` 比 `foo.o` 更新，则 `foo.o` 将被重新构建。
- en: If `foo.h` were to change without updating its timestamp, GNU `make` would do
    nothing. For example, if `foo.h` were updated from source code control, this makefile
    might do the wrong thing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `foo.h` 发生变化而未更新其时间戳，GNU `make` 将不会做任何操作。例如，如果 `foo.h` 从源代码控制中更新，可能会导致该 makefile
    做出错误的操作。
- en: To work around this problem, we need a way to force GNU `make` to consider the
    contents of the file, not its timestamp. Because GNU `make` can handle timestamps
    internally only, we need to hack the makefile so that file timestamps are related
    to file contents.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要一种方法强制 GNU `make` 考虑文件的内容，而不是时间戳。因为 GNU `make` 仅能处理时间戳，所以我们需要修改
    makefile，使文件的时间戳与文件内容相关联。
- en: Digesting File Contents
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理文件内容
- en: An easy way to detect a change in a file is to use a message digest function,
    such as MD5, to generate a digest of the file. Because any change in the file
    will cause the digest to change, just examining the digest will be enough to detect
    a change in the file’s contents.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 检测文件变化的一个简单方法是使用消息摘要函数（如 MD5）来生成文件的摘要。因为文件的任何变化都会导致摘要变化，所以只需检查摘要即可检测文件内容的变化。
- en: To force GNU `make` to check the contents of each file, we’ll associate a file
    with the extension `.md5` with every source code file to be tested. Each `.md5`
    file will contain the MD5 checksum of the corresponding source code file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制 GNU `make` 检查每个文件的内容，我们将为每个待测试的源代码文件关联一个扩展名为 `.md5` 的文件。每个 `.md5` 文件将包含相应源代码文件的
    MD5 校验和。
- en: 'In [Example 3-2](ch03.html#simple_makefile_that_builds_foodoto_from "Example 3-2. A
    simple makefile that builds foo.o from foo.c and foo.h"), source code files `foo.c`
    and `foo.h` will have associated `.md5` files `foo.c.md5` and `foo.h.md5`. To
    generate the MD5 checksum, we use the `md5sum` utility: it outputs a hexadecimal
    string containing the MD5 checksum of its input file.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 3-2](ch03.html#simple_makefile_that_builds_foodoto_from "示例 3-2. 一个从 foo.c
    和 foo.h 构建 foo.o 的简单 Makefile")中，源代码文件`foo.c`和`foo.h`将分别有相关的`.md5`文件`foo.c.md5`和`foo.h.md5`。为了生成
    MD5 校验和，我们使用`md5sum`工具：它输出一个包含输入文件 MD5 校验和的十六进制字符串。
- en: If we arrange for the *timestamp* of the `.md5` file to change when the *checksum*
    of the related file changes, GNU `make` can check the timestamp of the `.md5`
    file in lieu of the actual source file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确保当相关文件的*校验和*变化时，`.md5`文件的*时间戳*也会变化，GNU `make`就可以检查`.md5`文件的时间戳，而不需要实际的源文件。
- en: In our example, GNU `make` would check the timestamp of `foo.c.md5` and `foo.h.md5`
    to determine whether `foo.o` needs to be rebuilt.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，GNU `make`会检查`foo.c.md5`和`foo.h.md5`的时间戳，以确定是否需要重新构建`foo.o`。
- en: The Modified Makefile
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改后的 Makefile
- en: 'Here’s the completed makefile that checks the MD5 checksum of source files
    so that objects are rebuilt when the contents of those files (and hence their
    checksums) change:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完整的 Makefile，它检查源文件的 MD5 校验和，以便当这些文件的内容（从而其校验和）发生变化时重新构建对象：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice first that the prerequisite list for `foo.o` has changed from `foo.c
    foo.h` to `$(call to-md5,foo.c foo.h)`. The `to-md5` function defined in the makefile
    adds the suffix `.md5` to all the filenames in its argument.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意到，`foo.o`的先决条件列表已从`foo.c foo.h`更改为`$(call to-md5,foo.c foo.h)`。在Makefile中定义的`to-md5`函数会在其参数的所有文件名后添加`.md5`后缀。
- en: 'So after expansion, the line reads:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，展开后，该行会变成：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This tells GNU `make` to rebuild `foo.o` if either of the `.md5` files is newer,
    as well as if either `foo.c` or `foo.h` is newer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉GNU `make`如果`.md5`文件中的任何一个更新，或者`foo.c`或`foo.h`中的任何一个更新，都需要重新构建`foo.o`。
- en: 'To ensure that the `.md5` files always contain the correct timestamp, they
    are always rebuilt. Each `.md5` file is remade by the `%.md5: FORCE` rule. The
    use of the empty rule `FORCE:` means that the `.md5` files are examined every
    time. Use of `FORCE` here is a little like using `.PHONY`: if there’s no file
    called `FORCE`, GNU `make` will build it (there’s no recipe so nothing happens)
    and then GNU `make` will consider `FORCE` to be newer than the `%.md5` file and
    rebuild it. Because we can’t do `.PHONY: %.md5`, we use this `FORCE` trick instead.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '为了确保`.md5`文件始终包含正确的时间戳，它们会被重新构建。每个`.md5`文件由`%.md5: FORCE`规则重新生成。使用空规则`FORCE:`意味着每次都会检查`.md5`文件。这里使用`FORCE`的方式有点类似于使用`.PHONY`：如果没有名为`FORCE`的文件，GNU
    `make`会构建它（由于没有配方，所以什么都不做），然后GNU `make`会认为`FORCE`比`%.md5`文件更新，并重新构建它。由于我们不能使用`.PHONY:
    %.md5`，因此我们改用这个`FORCE`技巧。'
- en: 'The commands for the `%.md5: FORCE` rule will only actually rebuild the `.md5`
    file if it doesn’t exist or if the checksum stored in the `.md5` file is different
    from the corresponding file’s checksum, which works as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`%.md5: FORCE`规则的命令只有在`.md5`文件不存在或`.md5`文件中存储的校验和与相应文件的校验和不同的情况下，才会实际重新构建`.md5`文件，其工作原理如下：'
- en: '`$(shell md5sum $*)` checksums the file that matches the `%` part of `%.md5`.
    For example, when this rule is being used to generate the `foo.h.md5` file, then
    `%` matches `foo.h` and `foo.h` is stored in `$*`.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$(shell md5sum $*)`对与`%.md5`的`%`部分匹配的文件进行校验和计算。例如，当这个规则用于生成`foo.h.md5`文件时，`%`匹配`foo.h`，然后`foo.h`会存储在`$*`中。'
- en: '`$(shell cat $@ 2>/dev/null)` gets the contents of the current `.md5` file
    (or a blank if it doesn’t exist; note how the `2>/dev/null` means that errors
    are ignored). Then, the `$(filter-out)` compares the checksum retrieved from the
    `.md5` file and the checksum generated by `md5sum`. If they are the same, the
    `$(filter-out)` is an empty string.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$(shell cat $@ 2>/dev/null)`获取当前`.md5`文件的内容（如果文件不存在则为空；请注意`2>/dev/null`表示忽略错误）。然后，`$(filter-out)`比较从`.md5`文件中获取的校验和和通过`md5sum`生成的校验和。如果它们相同，`$(filter-out)`将为空字符串。'
- en: If the checksum has changed, the rule will actually run `md5sum $* > $@`, which
    will update the `.md5` file’s contents and timestamp. The stored checksum will
    be available for later use when running GNU `make` again, and the changed timestamp
    on the `.md5` file will cause the related object file to be built.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果校验和发生了变化，规则将实际运行`md5sum $* > $@`，这将更新`.md5`文件的内容和时间戳。存储的校验和将在稍后再次运行GNU `make`时用于检测，`.md5`文件的时间戳变化将导致相关的目标文件被重新构建。
- en: The Hack in Action
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作中的黑客技术
- en: 'To see how the hack updates an object file when one of its prerequisites changes
    checksum, let’s create files `foo.c` and `foo.h` and run GNU `make`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这个黑客如何在其先决条件的校验和发生变化时更新目标文件，我们创建`foo.c`和`foo.h`文件并运行GNU `make`：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'GNU `make` generates the object file `foo.o` and two `.md5` files, `foo.c.md5`
    and `foo.h.md5`. Each `.md5` file contains the checksum of the file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`生成目标文件`foo.o`和两个`.md5`文件，`foo.c.md5`和`foo.h.md5`。每个`.md5`文件包含该文件的校验和：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First, we verify that everything is up-to-date and then verify that changing
    the timestamp on either `foo.c` or `foo.h` causes `foo.o` to be rebuilt:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们验证所有内容是否都是最新的，然后验证更改`foo.c`或`foo.h`上的时间戳是否会导致重新构建`foo.o`：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To demonstrate that changing the contents of a source file will cause `foo.o`
    to be rebuilt, we can cheat by changing the contents of, say, `foo.h` and then
    `touch foo.o` to make `foo.o` newer than `foo.h`, which would normally mean that
    `foo.o` would not be built.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示更改源文件的内容会导致重新构建`foo.o`，我们可以通过更改例如`foo.h`的内容并执行`touch foo.o`使`foo.o`比`foo.h`更新来作弊，这通常意味着`foo.o`不会被重新构建。
- en: 'As a result, we know that `foo.o` is newer than `foo.h` but that `foo.h`’s
    contents have changed since the last time `foo.o` was built:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道`foo.o`比`foo.h`更新，但自从上次构建`foo.o`以来，`foo.h`的内容已经发生了变化：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see that `foo.o` was rebuilt, even though it was newer than all the
    related source files, and that `foo.h.md5` has been updated with the new checksum
    of `foo.h`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到即使`foo.o`比所有相关的源文件都更新，它还是被重新构建了，而且`foo.h.md5`已更新为`foo.h`的新校验和。
- en: Improving the Code
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进代码
- en: 'We can make a couple of improvements to the code: the first is an optimization.
    When the checksum of a file has changed the rule to update, the `.md5` file actually
    ends up running `md5sum` twice on the same file with the same result. That’s a
    waste of time. If you are using GNU `make` 3.80 or later, it’s possible to store
    the output of `md5sum $*` in a temporary variable called `CHECKSUM` and just use
    the variable:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对代码做一些改进：第一个是优化。当文件的校验和发生变化时，更新规则会导致`.md5`文件实际上对同一个文件运行两次`md5sum`，结果相同。这是浪费时间。如果你使用的是GNU
    `make` 3.80或更高版本，可以将`md5sum $*`的输出存储在一个临时变量`CHECKSUM`中，并只使用该变量：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The second improvement is to make the checksum insensitive to changes in whitespace
    in a source file. After all, it would be a pity if two developers’ differing opinions
    on the right amount of indentation caused object files to rebuild when nothing
    else had changed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个改进是让校验和对源文件中的空格变化不敏感。毕竟，如果两个开发人员对于正确缩进的意见不同，导致对象文件重建，而其他内容没有变化，那将是一种遗憾。
- en: The `md5sum` utility does not have a way of ignoring whitespace, but it’s easy
    enough to pass the source file through `tr` to strip whitespace before handing
    it to `md5sum` for checksumming. (However, note that removing all whitespace might
    not be a good idea, at least not for most languages.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`md5sum`工具没有忽略空格的方法，但很容易将源文件通过`tr`过滤器去除空格，再交给`md5sum`计算校验和。（不过请注意，去除所有空格可能不是一个好主意，至少对于大多数语言而言不是。）'
- en: Automatic Dependency Generation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动依赖关系生成
- en: Any project larger than a simple example faces a dependency management problem.
    Dependencies must be generated and kept up to date as engineers modify the project.
    GNU `make` provides no tools for dealing with this. All GNU `make` provides is
    a mechanism for expressing the relationships between files with its familiar *`target`*
    `:` *`prerequisite1 prerequisite2`* `...` syntax.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大于简单示例的项目都会面临依赖管理问题。随着工程师修改项目，依赖关系必须被生成并保持最新。GNU `make`并未提供处理这些问题的工具。GNU `make`提供的仅仅是一个机制，用于表达文件之间的关系，使用其熟悉的*`target`*
    `:` *`prerequisite1 prerequisite2`* `...`语法。
- en: 'GNU `make`’s dependency syntax is flawed because it is more than just a list
    of prerequisites: the first prerequisite has a special meaning. Anything to the
    right of the `:` is a prerequisite, but the first prerequisite where there’s a
    recipe (that is, commands) is special: it’s the prerequisite that is assigned
    to the automatic variable `$<` and is also frequently the prerequisite passed
    to the compiler (or other command) to generate the target.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`的依赖语法有缺陷，因为它不仅仅是一个先决条件列表：第一个先决条件具有特殊含义。`:`右边的任何东西都是先决条件，但第一个带有规则（即命令）的先决条件是特殊的：它是被自动变量`$<`赋值的先决条件，并且通常也是传递给编译器（或其他命令）以生成目标的先决条件。
- en: 'The `$<` variable is also special in another way. Sometimes a target will have
    a recipe and other rules specifying prerequisites. For example, it’s not uncommon
    to see something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`$<` 变量在另一个方面也很特殊。有时目标会有配方和其他规则来指定先决条件。例如，像下面这样并不罕见：'
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The value of `$<` is set from the rule that has a recipe (it will be `foo.c`
    in this case).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`$<` 的值是通过具有配方的规则来设置的（在本例中将是 `foo.c`）。'
- en: 'Take a look at this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: which outputs
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它的输出是
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here `foo.o` is built if `foo.c`, `header.h`, or `system.h` change, but the
    rule also states that `foo.o` is made from `foo.c`. Say our example were written
    like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，如果 `foo.c`、`header.h` 或 `system.h` 改变，`foo.o` 会被重新构建，但规则也表明 `foo.o` 是由 `foo.c`
    构建的。假设我们的例子是这样写的：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output would be:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is clearly wrong.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是错误的。
- en: An Example Makefile
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例 Makefile
- en: 'The biggest problem is generating all the rules expressing all the dependencies
    for a large project. The rest of this section uses the following contrived example
    makefile as a starting point:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的问题是为大型项目生成所有表示所有依赖关系的规则。接下来的部分将使用以下构造的示例 makefile 作为起点：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Three object files (`foo.o`, `bar.o`, and `baz.o`) are built from corresponding
    `.c` files (`foo.c`, `bar.c`, and `baz.c`). Each `.o` file has dependencies on
    various different header files, as shown in the last three lines of the makefile.
    The makefile uses GNU `make`’s built-in rules to perform compilation using the
    system’s compiler.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 三个目标文件（`foo.o`、`bar.o` 和 `baz.o`）是从相应的 `.c` 文件（`foo.c`、`bar.c` 和 `baz.c`）构建的。每个
    `.o` 文件依赖于不同的头文件，如 makefile 中最后三行所示。makefile 使用 GNU `make` 的内置规则，通过系统的编译器执行编译。
- en: There’s no mention here of the final executable being built. The reason is that
    this example focuses on dealing with dependencies between sources and objects;
    relationships between objects are usually easier to maintain by hand because there
    are fewer of them and the relationships are part of the product design.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有提到最终可执行文件的构建。原因是这个例子专注于处理源文件和目标文件之间的依赖关系；对象文件之间的关系通常更容易手动维护，因为它们较少且这些关系是产品设计的一部分。
- en: makedepend and make depend
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: makedepend 和 make depend
- en: Because maintaining any real makefile by hand is impossible, many projects use
    the widely available `makedepend` program. `makedepend` reads C and C++ files,
    looks at the `#include` statements, opens the files that are included, and builds
    the dependency lines automatically. A basic way of incorporating `makedepend`
    in a project is a special `depend` target, as shown in [Example 3-3](ch03.html#using_makedepend_in_your_makefile
    "Example 3-3. Using makedepend in your makefile").
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为手动维护任何真实的 makefile 是不可能的，许多项目使用广泛可用的 `makedepend` 程序。`makedepend` 会读取 C 和
    C++ 文件，查看 `#include` 语句，打开被包含的文件，并自动构建依赖关系。将 `makedepend` 集成到项目中的一种基本方式是使用特殊的
    `depend` 目标，如 [示例 3-3](ch03.html#using_makedepend_in_your_makefile "示例 3-3. 在你的
    makefile 中使用 makedepend") 所示。
- en: Example 3-3. Using `makedepend` in your makefile
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-3. 在你的 makefile 中使用 `makedepend`
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Executing `make depend` with this makefile causes the `depend` rule to execute,
    which runs `makedepend` on the sources (defined in the `SRCS` variable) and outputs
    the dependency lines to a file called `dependencies.d` (defined by the `DEPENDS`
    variable).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `make depend` 时，makefile 会执行 `depend` 规则，这会对源文件（在 `SRCS` 变量中定义）运行 `makedepend`
    并将依赖关系输出到名为 `dependencies.d` 的文件中（由 `DEPENDS` 变量定义）。
- en: 'The makefile adds the dependencies in its final line by including the `dependencies.d`
    file. `dependencies.d` would look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: makefile 在最后一行通过包含 `dependencies.d` 文件来添加依赖关系。`dependencies.d` 的内容如下：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that `makedepend` doesn’t try to define the relationship between an object
    file (like `foo.o`) and the source file it is made from (`foo.c`). In this case
    GNU `make`’s standard rules will find the related `.c` file automatically.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`makedepend` 并不会尝试定义目标文件（如 `foo.o`）与它所生成的源文件（`foo.c`）之间的关系。在这种情况下，GNU `make`
    的标准规则会自动找到相关的 `.c` 文件。
- en: Automating makedepend and Removing make depend
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化 makedepend 和移除 make depend
- en: 'Two problems exist with the `make depend` style. Running `make depend` can
    be slow, because every source file must be searched, even if there are no changes.
    Also, it’s a manual step: before every `make` the user will have to do `make depend`
    to ensure that the dependencies are correct. The solution to these problems is
    automation.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`make depend` 风格存在两个问题。运行 `make depend` 可能很慢，因为即使没有变化，仍然必须搜索每个源文件。此外，它是一个手动步骤：在每次执行
    `make` 之前，用户必须先执行 `make depend` 来确保依赖关系是正确的。解决这些问题的办法是自动化。'
- en: '[Example 3-4](ch03.html#automatically_running_makedepend_when_ne "Example 3-4. Automatically
    running makedepend when needed") shows another version of the makefile from [Example 3-3](ch03.html#using_makedepend_in_your_makefile
    "Example 3-3. Using makedepend in your makefile"):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-4](ch03.html#automatically_running_makedepend_when_ne "示例 3-4. 当需要时自动运行
    makedepend") 显示了来自 [示例 3-3](ch03.html#using_makedepend_in_your_makefile "示例 3-3.
    在你的 makefile 中使用 makedepend") 的 makefile 另一个版本：'
- en: Example 3-4. Automatically running `makedepend` when needed
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-4. 当需要时自动运行 `makedepend`
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This version still uses `makedepend` to generate dependencies but automates
    the process and only runs `makedepend` for sources that have changed. It works
    by associating a `.d` file with each `.c`. For example, `foo.o` (built from `foo.c`)
    has a `foo.d` file that just contains the dependency line for `foo.o`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本仍然使用 `makedepend` 来生成依赖关系，但自动化了这个过程，并且只对已更改的源文件运行 `makedepend`。它通过将每个 `.c`
    文件与一个 `.d` 文件关联来工作。例如，`foo.o`（由 `foo.c` 构建）有一个 `foo.d` 文件，其中仅包含 `foo.o` 的依赖关系行。
- en: 'Here are the contents of `foo.d`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `foo.d` 的内容：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice one addition: this line specifies when to rebuild `foo.o`, but also
    that `foo.d` should be rebuilt under the same conditions. If any of the sources
    associated with `foo.o` change, `foo.d` is rebuilt. `foo.c` isn’t mentioned in
    this list because it’s mentioned as part of the pattern rule for rebuilding a
    `.d` file (the `%.d : %.c` rule in the main makefile means that `foo.d` will be
    rebuilt if `foo.c` changes). `foo.d` was added to the dependency line created
    by `makedepend` using the `sed` magic shown in [Example 3-4](ch03.html#automatically_running_makedepend_when_ne
    "Example 3-4. Automatically running makedepend when needed").'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意一项新增内容：这一行指定了何时重新构建 `foo.o`，但也指出在相同条件下应该重新构建 `foo.d`。如果任何与 `foo.o` 相关的源文件发生变化，`foo.d`
    会被重新构建。`foo.c` 没有出现在这个列表中，因为它是作为重新构建 `.d` 文件的模式规则的一部分提到的（主 makefile 中的 `%.d :
    %.c` 规则意味着如果 `foo.c` 发生变化，`foo.d` 会被重新构建）。`foo.d` 是通过 `makedepend` 使用 [示例 3-4](ch03.html#automatically_running_makedepend_when_ne
    "示例 3-4. 当需要时自动运行 makedepend") 中显示的 `sed` 魔法添加到由 `makedepend` 创建的依赖关系行中的。'
- en: 'The final line of the main makefile includes all the `.d` files: the `$(SRCS:.c=.d)`
    transforms the list of sources in the `SRCS` variable by changing the extension
    from `.c` to `.d`. The `include` also tells GNU `make` to check whether the `.d`
    files need rebuilding.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 主 makefile 的最后一行包括所有 `.d` 文件：`$(SRCS:.c=.d)` 将 `SRCS` 变量中源文件的列表转换，将扩展名从 `.c`
    更改为 `.d`。`include` 也告诉 GNU `make` 检查 `.d` 文件是否需要重新构建。
- en: 'GNU `make` will check if there are rules to rebuild included makefiles (in
    this case the `.d` files), rebuild them if necessary (following the dependencies
    specified in the makefile), and then restart. This makefile remaking feature (*[http://www.gnu.org/software/make/manual/html_node/Remaking-Makefiles.html](http://www.gnu.org/software/make/manual/html_node/Remaking-Makefiles.html)*)
    means that simply typing `make` will do the right thing: it’ll rebuild any dependency
    files that need rebuilding but only if the sources have changed. Then GNU `make`
    will perform the build, taking the new dependencies into account.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 将检查是否有规则来重新构建包含的 makefile（在这种情况下是 `.d` 文件），如有必要重新构建它们（按照 makefile
    中指定的依赖关系），然后重新启动。这个 makefile 重新构建功能（*[http://www.gnu.org/software/make/manual/html_node/Remaking-Makefiles.html](http://www.gnu.org/software/make/manual/html_node/Remaking-Makefiles.html)*)
    意味着只需键入 `make` 就会做正确的事：它会重新构建需要重新构建的任何依赖文件，但仅在源文件发生变化时。然后，GNU `make` 将根据新的依赖关系进行构建。
- en: Making Deleted Files Disappear from Dependencies
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让已删除的文件从依赖关系中消失
- en: 'Unfortunately, our makefile breaks with a fatal error if a source file is removed.
    If `header.h` is no longer needed, all references to it are removed from the `.c`
    files, the file is removed from disk, and running `make` produces the following
    error:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果源文件被删除，我们的 makefile 会因致命错误而中断。如果 `header.h` 不再需要，所有对它的引用都会从 `.c` 文件中移除，文件会从磁盘上删除，运行
    `make` 会产生以下错误：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This happens because `header.h` is still mentioned in `foo.d` as a prerequisite
    of `foo.d`; hence, `foo.d` cannot be rebuilt. You can fix this by making the generation
    of `foo.d` smarter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `header.h` 仍然在 `foo.d` 中作为 `foo.d` 的前提条件被提到；因此，`foo.d` 无法重新构建。你可以通过让 `foo.d`
    的生成更加智能来修复这个问题：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The new `foo.d` includes the dependencies for `foo.o` and `foo.d` separately.
    `foo.d`’s dependencies are wrapped in a call to GNU `make`’s `$(wildcard)` function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `foo.d` 分别包含了 `foo.o` 和 `foo.d` 的依赖关系。`foo.d` 的依赖关系被包裹在调用 GNU `make` 的 `$(wildcard)`
    函数中。
- en: 'And here’s the updated makefile with a new invocation of `makedepend` followed
    by a `sed` line that creates the modified `.d` file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新后的 makefile，它通过新一轮的 `makedepend` 调用和一个 `sed` 行来创建修改后的 `.d` 文件：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Removing a header file now doesn’t break the `make`: when `foo.d` is parsed,
    the dependency line for `foo.d` is passed through `$(wildcard)`. When there are
    no globbing symbols like `*` or `?` in the filename, `$(wildcard)` acts as a simple
    existence filter, removing from the list any files that do not exist. So if `header.h`
    had been removed, the first line of `foo.d` would be equivalent to this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在移除头文件不会破坏`make`：当解析`foo.d`时，`foo.d`的依赖行会通过`$(wildcard)`处理。当文件名中没有通配符如`*`或`?`时，`$(wildcard)`充当一个简单的存在性过滤器，将所有不存在的文件从列表中移除。所以如果`header.h`被移除，`foo.d`的第一行将相当于以下内容：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `make` would work correctly. This example makefile now works when `.c` files
    are added (the user just updates `SRCS` and the new `.d` file is created automatically),
    when `.c` files are removed (the user updates `SRCS` and the old `.d` file is
    ignored), when headers are added (because that requires altering an existing `.c`
    or `.h`, the `.d` file will be regenerated), and when headers are removed (the
    `$(wildcard)` hides the deletion and the `.d` file is regenerated).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`会正常工作。这个示例makefile现在在添加`.c`文件时可以正常工作（用户只需更新`SRCS`，新的`.d`文件会自动创建），在删除`.c`文件时（用户更新`SRCS`，旧的`.d`文件会被忽略），在添加头文件时（因为这需要修改现有的`.c`或`.h`文件，`.d`文件会重新生成），以及在删除头文件时（`$(wildcard)`隐藏了删除操作，`.d`文件会重新生成）。'
- en: 'A possible optimization is to remove the need for GNU `make` to restart by
    merging the rule that makes the `.d` file into the rule that makes the `.o`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的优化是通过将生成`.d`文件的规则与生成`.o`文件的规则合并，来避免GNU `make`重启的需要：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Because the `.d` file is updated if and only if the `.o` file needs to be updated
    (both are updated when any of the sources for the `.o` change), it’s possible
    to have the `makedepend` happen at the same time as the compilation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为只有在`.o`文件需要更新时，`.d`文件才会更新（当任何`.o`文件的源文件发生变化时，两者都会更新），所以可以在编译的同时进行`makedepend`。
- en: This rule uses `$*`, another GNU `make` variable. `$*` is the part of the pattern
    `%.c` that matches the `%`. If this rule is building `foo.o` from `foo.c`, `$*`
    is just `foo`. `$*` creates the name of the `.d` file that `makedepend` writes
    to.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则使用了`$*`，这是另一个GNU `make`变量。`$*`是模式`%.c`中与`%`匹配的部分。如果这个规则正在从`foo.c`构建`foo.o`，那么`$*`就是`foo`。`$*`生成`makedepend`写入的`.d`文件的名称。
- en: This version does not use GNU `make`’s makefile remaking system. There are no
    rules for making `.d` files (they are made as a side effect of making the `.o`
    files), so GNU `make` doesn’t have to restart. This provides the best combination
    of accuracy and speed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本不使用GNU `make`的makefile重建系统。没有创建`.d`文件的规则（它们是作为创建`.o`文件的副作用生成的），因此GNU `make`不需要重启。这提供了准确性和速度的最佳结合。
- en: 'In general, it’s a bad idea to have a rule that makes multiple files because
    it’s impossible for GNU `make` to find the rule that makes a file if it’s created
    as a side effect of something else. In this case, that behavior is desired: we
    want to hide the creation of `.d` files from GNU `make` so it doesn’t try to make
    them and then have to restart.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，创建多个文件的规则是一个不好的主意，因为GNU `make`无法找到由其他操作副作用创建的文件的规则。在这种情况下，这种行为是我们想要的：我们希望将`.d`文件的创建隐藏起来，以免GNU
    `make`尝试生成它们并导致重启。
- en: Tom Tromey proposed a similar idea without the `$(wildcard)` trick. You can
    find this and more information about building dependency files on GNU `make` maintainer
    Paul Smith’s website at *[http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/](http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/)*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Tom Tromey提出了一个类似的想法，没有使用`$(wildcard)`技巧。你可以在GNU `make`的维护者Paul Smith的网站上找到更多关于构建依赖文件的信息，网址是*[http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/](http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/)*。
- en: Doing Away with makedepend
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摆脱 makedepend
- en: Additionally, it’s possible to omit `makedepend` altogether if you are using
    GNU `gcc`, `llvm`, or `clang`, or a similar compiler.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果使用的是GNU `gcc`、`llvm`、`clang`或类似的编译器，可以完全省略`makedepend`。
- en: 'An `-MD` option does the work of `makedepend` at the same time as the compilation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`-MD`选项在编译的同时完成`makedepend`的工作：'
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For example, the compilation step for `foo.o` will create `foo.d` from `foo.c`.
    Then, `sed` is run on the `foo.d` to add the extra line for `foo.d` containing
    the `$(wildcard)`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`foo.o`的编译步骤会从`foo.c`生成`foo.d`。然后，会对`foo.d`运行`sed`，为`foo.d`添加包含`$(wildcard)`的额外行。
- en: Using gcc -MP
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用gcc -MP
- en: '`gcc` also has the `-MP` option, which attempts to deal with the problem of
    disappearing files by creating empty rules to “build” missing files. For example,
    it’s possible to eliminate the `sed` magic completely, using the `-MP` option
    in place of `-MD`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc`还有一个`-MP`选项，它试图通过创建空规则来“构建”缺失的文件，从而解决消失文件的问题。例如，可以完全消除`sed`魔法，使用`-MP`选项代替`-MD`：'
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `foo.d` file will look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo.d`文件将如下所示：'
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If, for example, `foo.h` is deleted, `make` will not complain because it will
    find the empty rule (`foo.h :`) to build it, and the missing file error will be
    prevented. However, it is vital that the `foo.d` file be updated every time `foo.o`
    is built. If it’s not, `foo.d` will still contain `foo.h` as a prerequisite, and
    `foo.o` will rebuild every time `make` is run because `make` will attempt to build
    `foo.h` (forcing a `foo.o` build) using the empty rule.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果`foo.h`被删除，`make`不会报错，因为它会找到空规则（`foo.h :`）来构建它，从而避免了缺失文件的错误。然而，每次构建`foo.o`时，更新`foo.d`文件是至关重要的。如果没有更新，`foo.d`中仍会包含`foo.h`作为前提条件，而每次运行`make`时，`foo.o`都会重新构建，因为`make`会尝试用空规则来构建`foo.h`（从而强制构建`foo.o`）。
- en: Atomic Rules in GNU make
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNU make中的原子规则
- en: A fundamental law of GNU `make` physics is that each rule builds one and only
    one file (called a *target*). There are exceptions to that rule (which we’ll see
    in the rest of this section), but nevertheless, for any normal GNU `make` rule
    such as
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`物理学的一个基本法则是每个规则只构建一个文件（称为*目标*）。这个规则是有例外的（我们将在本节后面看到），但无论如何，对于任何正常的GNU
    `make`规则，像
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: there’s only one file mentioned to the left of the `:`. That’s the filename
    that gets put into the `$@` automatic variable. It’s expected that `command` will
    actually update that file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧`:`的地方只有一个文件名被提及。这个文件名会被放入`$@`自动变量中。预计`command`会实际更新该文件。
- en: This section explains what to do if a command updates more than one file and
    how to express that so GNU `make` knows that more than one file was updated and
    behaves correctly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如果一个命令更新多个文件该怎么办，并且如何表达这一点，以便GNU `make`知道有多个文件被更新并且正确地执行。
- en: What Not to Do
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不该做的事
- en: Imagine a command that makes two files (`a` and `b`) from the same prerequisites
    in a single step. In this section, such a command is simulated with `touch a b`,
    but in reality it could be much more complex than that.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个命令可以在一个步骤中通过相同的前提条件构建两个文件（`a`和`b`）。在这一节中，这个命令通过`touch a b`来模拟，但实际上它可能比这复杂得多。
- en: '[Example 3-5](ch03.html#what_not_to_do-id00004 "Example 3-5. What not to do")
    shows what not to do:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-5](ch03.html#what_not_to_do-id00004 "示例 3-5. 不该做的事")展示了不该做的事情：'
- en: Example 3-5. What not to do
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-5. 不该做的事
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At first glance [Example 3-5](ch03.html#what_not_to_do-id00004 "Example 3-5. What
    not to do") looks correct; it seems to say that `a` and `b` are built from `c`
    and `d` by a single command. If you run this in `make`, you can get output like
    this (especially if you use the `-j` option to run a parallel build):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，[示例 3-5](ch03.html#what_not_to_do-id00004 "示例 3-5. 不该做的事")看起来是正确的；它似乎说明了`a`和`b`是通过一个命令从`c`和`d`构建的。如果你在`make`中运行它，你可能会得到类似这样的输出（尤其是在你使用`-j`选项来进行并行构建时）：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The command was run twice. In this case that’s harmless, but for a real command
    that does real work, running twice is almost certainly the wrong thing to do.
    Also, if you use the `-j` option to run in parallel, you can end up with the command
    running more than once and simultaneously with itself.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 命令被运行了两次。在这种情况下这是无害的，但对于一个真正执行工作的命令，运行两次几乎肯定是不对的。此外，如果你使用`-j`选项进行并行构建，命令可能会同时多次运行。
- en: 'The reason is that GNU `make` actually interprets the makefile as:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于GNU `make`实际上是这样解释makefile的：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There are two separate rules (one declares that it builds `a`; the other says
    it builds `b`) that both build `a` and `b`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个独立的规则（一个声明它构建`a`，另一个声明它构建`b`），这两个规则都构建`a`和`b`。
- en: Using Pattern Rules
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模式规则
- en: GNU `make` does have a way to build more than one target in a single rule using
    a pattern rule. Pattern rules can have an arbitrary number of target patterns
    and still be treated as a single rule.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`确实有一种方式可以在单个规则中构建多个目标，使用模式规则。模式规则可以拥有任意数量的目标模式，仍然被视为一个规则。
- en: 'For example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This means that files with the extensions `.foo`, `.bar`, and `.baz` (and of
    course the same prefix that will match against the `%`) will be built with a single
    invocation of `command`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着具有`.foo`、`.bar`和`.baz`扩展名的文件（当然还有与`%`匹配的相同前缀）将在一次`command`调用中构建。
- en: 'Suppose that the makefile looked like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 假设makefile像这样：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, `command` would be invoked just once. In fact, it’s enough to specify
    that just one of the targets and the pattern rule will run:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`command`只会被调用一次。事实上，仅指定一个目标并运行模式规则就足够了：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This can be very useful. For example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用。例如：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is an actual rule from a real makefile that builds a `.lib` and its associated
    `.dll` in one go.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实际的规则，来自一个真实的makefile，它一次性构建了`.lib`及其相关的`.dll`。
- en: Of course, if the files don’t have a common part in their names, using a pattern
    rule won’t work. It doesn’t work for the simple example at the beginning of this
    section, but there is an alternative.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果文件的名称中没有共同部分，使用模式规则将不起作用。它在本节开始时的简单示例中无法使用，但有一种替代方法。
- en: Using a Sentinel File
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用哨兵文件
- en: 'A possible workaround to using a pattern rule is to introduce a single file
    to indicate whether any of the targets of a multi-target rule have been built.
    Creating a single “indicator” file turns multiple files into a single file, and
    GNU `make` understands single files. Here’s [Example 3-5](ch03.html#what_not_to_do-id00004
    "Example 3-5. What not to do"), rewritten:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的替代方法是引入一个单独的文件，用来指示多目标规则中的任何目标是否已经构建。创建一个单一的“指示”文件将多个文件转化为一个文件，而GNU `make`可以理解单一文件。以下是[示例3-5](ch03.html#what_not_to_do-id00004
    "示例3-5. 什么不该做")的重写版本：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The rule to build `a` and `b` can be run only once because only one prerequisite
    is specified (`.sentinel`). If `c` or `d` are newer, `.sentinel` gets rebuilt
    (and hence `a` and `b` are rebuilt). If the makefile asks for either `a` or `b`,
    they are rebuilt via the `.sentinel` file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`a`和`b`的规则只能运行一次，因为只指定了一个前提条件（`.sentinel`）。如果`c`或`d`较新，`.sentinel`会被重新构建（从而`a`和`b`也会被重新构建）。如果makefile请求`a`或`b`中的任何一个，它们会通过`.sentinel`文件重新构建。
- en: The funny `@:` command in the `a b` rule just means that there are commands
    to build `a` and `b` but they do nothing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`a b`规则中的有趣`@:`命令只是意味着有构建`a`和`b`的命令，但它们什么也不做。'
- en: 'It would be nice to make this transparent. That’s where the `atomic` function
    comes in. The `atomic` function sets up the sentinel file automatically, based
    on the names of the targets to be built, and creates the necessary rules:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使这一过程透明化会很不错。这就是`atomic`函数的作用。`atomic`函数会根据要构建的目标名称自动设置哨兵文件，并创建必要的规则：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'All we’ve done is replace the original `a b : c d` rule with a call to `atomic`.
    The first argument is the list of targets that need to be built atomically; the
    second argument is the list of prerequisites.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '我们所做的只是将原来的`a b : c d`规则替换为对`atomic`的调用。第一个参数是需要原子化构建的目标列表；第二个参数是前提条件列表。'
- en: '`atomic` uses the `sentinel` function to create a unique sentinel filename
    (in the case of targets `a b` the sentinel filename is `.sentinel.a_b`) and then
    sets up the necessary rules.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`atomic`使用`sentinel`函数创建一个唯一的哨兵文件名（对于目标`a b`，哨兵文件名为`.sentinel.a_b`），然后设置必要的规则。'
- en: 'Expanding `atomic` in this makefile would be the same as doing this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个makefile中展开`atomic`就相当于这样做：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There’s one flaw with this technique. If you delete `a` or `b`, you must also
    delete the related sentinel file or the files won’t get rebuilt.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术有一个缺陷。如果删除了`a`或`b`，你还必须删除相关的哨兵文件，否则文件不会重新构建。
- en: 'To work around this, you can have the makefile delete the sentinel file if
    necessary by checking to see if any of the targets being built are missing. Here’s
    the updated code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以让makefile在必要时删除哨兵文件，通过检查是否有任何正在构建的目标丢失。以下是更新后的代码：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now `atomic` runs through the targets. If any are missing—detected by the `$(wildcard)`—the
    sentinel file is deleted.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`atomic`遍历这些目标。如果有任何目标丢失（通过`$(wildcard)`检测），则会删除哨兵文件。
- en: Painless Non-recursive make
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无痛非递归make
- en: 'Once a makefile project reaches a certain size (usually when it has dependencies
    on subprojects), it’s inevitable that the build master writes a rule that contains
    a call to `$(MAKE)`. And right there the build master has created a recursive
    `make`: a `make` that executes an entire other `make` process. It’s incredibly
    tempting to do this because conceptually, recursive `make` is simple: if you need
    to build a subproject, just go to its directory and run `make` via `$(MAKE)`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦makefile项目达到一定规模（通常是当它依赖于子项目时），构建管理者就不可避免地会写出包含对`$(MAKE)`调用的规则。而就在这时，构建管理者创建了递归的`make`：一个执行整个`make`过程的`make`。这样做非常诱人，因为从概念上讲，递归`make`很简单：如果你需要构建一个子项目，只需进入其目录并通过`$(MAKE)`运行`make`。
- en: 'But it has one major flaw: once you start a separate `make` process, all information
    about dependencies is lost. The parent `make` doesn’t know whether the subproject
    `make` really needed to happen, so it has to run it every time, and that can be
    slow. Fixing that problem isn’t easy, but non-recursive `make`s are powerful once
    implemented.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它有一个主要的缺陷：一旦启动了一个单独的 `make` 进程，所有关于依赖的信息都会丢失。父 `make` 并不知道子项目的 `make` 是否真的需要执行，所以它每次都必须运行，这可能会很慢。解决这个问题并不容易，但一旦实现，非递归
    `make` 是非常强大的。
- en: One common objection to using non-recursive `make` is that with recursive `make`
    it’s possible to go to anywhere in a source code tree and type `make`. Doing so
    typically builds the objects that are defined by the makefile at that level in
    the tree (and possibly below that, if the makefile recurses).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对使用非递归 `make` 的一个常见反对意见是，使用递归 `make` 时，可以在源代码树的任何地方输入 `make`。这样做通常会构建在该层次的 makefile
    中定义的对象（如果 makefile 递归，还可能构建下面的对象）。
- en: Non-recursive `make` systems (based on `include` statements instead of `make`
    invocations) often do not offer this flexibility, and GNU `make` must be run from
    the top-level directory. Even though non-recursive GNU `make` is typically more
    efficient (running from the top-level directory should be quick), it’s important
    to be able to give developers the same level of functionality as a recursive `make`
    system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 非递归的 `make` 系统（基于 `include` 语句而非 `make` 调用）通常无法提供这种灵活性，而 GNU `make` 必须在顶层目录中运行。尽管非递归的
    GNU `make` 通常更高效（从顶层目录运行应该很快），但能够为开发者提供与递归 `make` 系统相同的功能是很重要的。
- en: This section outlines a pattern for a non-recursive GNU `make` system that supports
    the familiar `make`-anywhere style common to recursive GNU `make` systems. Typing
    `make` in a directory will build everything in that directory and below, but there
    are no recursive `$(MAKE)` invocations. The single `make` that runs knows about
    all the dependencies across projects and subprojects, and it can build efficiently.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了一种非递归的 GNU `make` 系统模式，它支持递归的 GNU `make` 系统中常见的 `make` 随处可用的风格。在一个目录中输入
    `make` 会构建该目录及以下的所有内容，但没有递归的 `$(MAKE)` 调用。运行的唯一一个 `make` 知道跨项目和子项目的所有依赖关系，并且能够高效地构建。
- en: A Simple Recursive Make
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的递归 `make`
- en: 'Imagine a project with the following subdirectories:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个包含以下子目录的项目：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`/src/` is the top-level directory and is where you’d type `make` to get a
    full build. Inside `/src/` is a `library/` directory that builds a library called
    `lib.a` from source files `lib1.c` and `lib2.c`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/` 是顶层目录，在这里你可以输入 `make` 来进行完整的构建。在 `/src/` 目录下有一个 `library/` 目录，它从源文件
    `lib1.c` 和 `lib2.c` 构建一个名为 `lib.a` 的库：'
- en: '[PRE52]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `/src/executable/` directory builds an executable file called `exec` from
    two source files (`foo.c` and `bar.c`) and links with the library `lib.a`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/executable/` 目录从两个源文件（`foo.c` 和 `bar.c`）构建一个名为 `exec` 的可执行文件，并与库 `lib.a`
    链接：'
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The classic recursive `make` solution is to put a makefile in each subdirectory.
    Each makefile contains rules to build that directory’s objects, and a top-level
    makefile recurses into each subdirectory. Here are the contents of such a recursive
    makefile (`/src/makefile`):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的递归 `make` 解决方案是在每个子目录中放置一个 makefile。每个 makefile 包含构建该目录对象的规则，而顶层的 makefile
    会递归进入每个子目录。以下是一个递归 makefile (`/src/makefile`) 的内容：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This enters each directory in turn and runs `make` to build first the library
    and then the executable. The dependency between the executable and the library
    (that is, the fact that the library needs to be built before the executable) is
    implicit in the order in which the directories are specified in `SUBDIRS`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这会依次进入每个目录，并运行 `make` 来先构建库，再构建可执行文件。可执行文件和库之间的依赖关系（即库需要先于可执行文件构建）在 `SUBDIRS`
    中指定的目录顺序中是隐式的。
- en: 'Here’s an example of an improvement on using a `for` loop using phony targets
    for each directory:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 `for` 循环和每个目录的虚假目标来改进的一个例子：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You unwind the loop inside the rule for `all`, create separate rules for each
    subdirectory, and explicitly specify the dependency between `executable` and `library`.
    This code is much clearer, but it’s still recursive with separate `make` invocations
    for each subdirectory.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要解开 `all` 规则中的循环，为每个子目录创建独立的规则，并明确指定 `executable` 和 `library` 之间的依赖关系。这段代码更清晰，但它仍然是递归的，每个子目录都有单独的
    `make` 调用。
- en: A Flexible Non-recursive make System
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个灵活的非递归 `make` 系统
- en: When moving to non-recursive `make`, the ideal top-level makefile would look
    like [Example 3-6](ch03.html#small_non-recursive_makefile "Example 3-6. A small
    non-recursive makefile").
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当转向非递归 `make` 时，理想的顶级 makefile 应该像 [示例 3-6](ch03.html#small_non-recursive_makefile
    "示例 3-6：一个小型非递归 makefile") 这样。
- en: Example 3-6. A small non-recursive makefile
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-6：一个小型非递归 makefile
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This simply says to include the makefile from each subdirectory. The trick
    is to make that work! Before you see how, here are the skeletons of the contents
    of the makefiles in the `library` and `executable` subdirectories:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是说要包含每个子目录中的 makefile。诀窍是如何使其工作！在你看到如何做之前，这里是 `library` 和 `executable` 子目录中
    makefile 内容的框架：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: and
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Each of those makefiles specifies the source files to be built (in the `SRCS`
    variable), the name of the final linked binary (in the `BINARY` variable), and
    the type of the binary (using the `BINARY_EXT` variable, which is set from special
    variables `_LIBEXT` and `_EXEEXT`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 makefile 都指定了要构建的源文件（在 `SRCS` 变量中）、最终链接的二进制文件的名称（在 `BINARY` 变量中）和二进制文件的类型（使用
    `BINARY_EXT` 变量，该变量由特殊变量 `_LIBEXT` 和 `_EXEEXT` 设置）。
- en: Both the makefiles `include` the common makefiles `root.mak`, `top.mak`, and
    `bottom.mak`, which are located in the `/src/` directory.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 makefile 都 `include` 了位于 `/src/` 目录中的公共 makefile `root.mak`、`top.mak` 和
    `bottom.mak`。
- en: 'Because the `.mak` included makefiles are not in the subdirectories, GNU `make`
    needs to go looking for them. To find the `.mak` files in `/src`, do this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因为包含的 `.mak` makefile 不在子目录中，所以 GNU `make` 需要去寻找它们。要在 `/src` 中找到 `.mak` 文件，可以这样做：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, you use the `-I` command line option that adds a directory to the `include`
    search path.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用 `-I` 命令行选项将目录添加到 `include` 搜索路径中。
- en: 'It’s unfortunate to ask a user to add anything to the `make` command line.
    To avoid that, you can create a simple method of automatically walking up the
    source tree to find the `.mak` files. Here’s the actual makefile for `/src/ library`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要求用户在 `make` 命令行中添加任何内容是令人遗憾的。为了避免这种情况，你可以创建一个简单的方法，自动向上遍历源代码树以找到 `.mak` 文件。以下是
    `/src/library` 的实际 makefile：
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `_find` function walks up a directory tree starting from the directory in
    `$1`, looking for the file named `$2`. The actual find is achieved by calling
    the `_walk` function, which walks up the tree, finding every instance of the file
    `$2` in each of the successively shorter paths from `$1`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`_find` 函数从 `$1` 中指定的目录开始向上遍历目录树，查找名为 `$2` 的文件。实际的查找是通过调用 `_walk` 函数实现的，该函数沿着树向上遍历，找到
    `$1` 中每个逐渐缩短的路径中 `$2` 文件的每个实例。'
- en: The block of code at the start of the makefile finds the location of `root.mak`,
    which is in the same directory as `top.mak` and `bottom.mak` (namely, `/src`),
    and saves that directory in `_ROOT`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: makefile 开头的代码块找到 `root.mak` 的位置，它与 `top.mak` 和 `bottom.mak` 在同一目录下（即 `/src`），并将该目录保存在
    `_ROOT` 中。
- en: Then, the makefile can use `$(_ROOT)/` to `include` the `root.mak`, `top.mak`,
    and `bottom.mak` makefiles without any need to type anything other than `make`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，makefile 可以使用 `$(_ROOT)/` 来 `include` `root.mak`、`top.mak` 和 `bottom.mak`
    makefile，而无需输入除 `make` 之外的任何内容。
- en: 'Here are the contents of the first included makefile (`root.mak`):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第一个包含的 makefile (`root.mak`) 的内容：
- en: '[PRE61]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For the moment, ignore its contents and return to what these functions are
    used for when looking at dependencies between modules. The real work begins with
    `top.mak`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，忽略其内容，回到这些函数在查看模块之间的依赖关系时的作用。实际工作从 `top.mak` 开始：
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `_OUTTOP` variable defines the top-level directory into which all binary
    output (object files and so on) will be placed. Here it has the default value
    of `/tmp/out`, and it’s defined with `?=` so it can be overridden on the command
    line.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`_OUTTOP` 变量定义了所有二进制输出（目标文件等）将被放置的顶级目录。这里它的默认值是 `/tmp/out`，并且它是用 `?=` 定义的，因此可以在命令行中覆盖。'
- en: Next, `top.mak` sets up the default target for GNU `make` as the classic `all`.
    Here it has no dependencies, but they are added later for each module that will
    be built.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`top.mak` 设置 GNU `make` 的默认目标为经典的 `all`。这里它没有依赖项，但之后会为每个将要构建的模块添加依赖项。
- en: Thereafter, a number of variables end up setting the `_MODULE_PATH` to the full
    path to the module directory being built. For example, when building the `library`
    module, `_MODULE_PATH` would be `/src/library`. Setting this variable is complex
    because determining the module directory has to be independent of the directory
    from which GNU `make` was executed (so that the library can be built from the
    top-level, for a `make all`, or from the individual `library` directory, for an
    individual developer build, or the library can even be included as a dependency
    on a different module).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，多个变量会将`_MODULE_PATH`设置为正在构建的模块目录的完整路径。例如，在构建`library`模块时，`_MODULE_PATH`将是`/src/library`。设置这个变量是复杂的，因为确定模块目录必须独立于执行GNU
    `make`的目录（这样库文件既可以从顶层目录构建，适用于`make all`，也可以从单独的`library`目录构建，适用于单个开发者构建，甚至可以将库文件作为依赖项包含在另一个模块中）。
- en: 'The `_MODULE_NAME` is simply the path relative to the root of the tree with
    `/` replaced by `_`. In [Example 3-5](ch03.html#what_not_to_do-id00004 "Example 3-5. What
    not to do"), the two modules have `_MODULE_NAME`s: `library` and `executable`.
    But if `library` had a subdirectory containing a module called `sublibrary`, then
    its `_MODULE_NAME` would be `library_sublibrary`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`_MODULE_NAME`只是相对于树根路径的路径，其中`/`被替换为`_`。在[示例 3-5](ch03.html#what_not_to_do-id00004
    "示例 3-5. 不该做的事")中，这两个模块有`_MODULE_NAME`：`library`和`executable`。但是如果`library`有一个包含名为`sublibrary`的模块的子目录，那么它的`_MODULE_NAME`将是`library_sublibrary`。'
- en: The `_MODULE_NAME` is also used to create the `$(_MODULE_NAME)_OUTPUT` special
    variable, which has a computed name based on `_MODULE_NAME`. So for the `library`
    module, the variable `library_OUTPUT` is created with the full path of the directory
    into which `library`’s object files should be written. The output path is based
    on `_OUTTOP` and the relative path to the module being built. As a result, the
    `/tmp/out` tree mirrors the source tree.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`_MODULE_NAME`还用于创建`$(_MODULE_NAME)_OUTPUT`特殊变量，它的名称是基于`_MODULE_NAME`计算得出的。所以对于`library`模块，创建了变量`library_OUTPUT`，它包含将`library`的目标文件写入的目录的完整路径。输出路径是基于`_OUTTOP`和相对于正在构建模块的路径。因此，`/tmp/out`目录结构会镜像源代码目录结构。'
- en: Finally, some standard definitions of extensions used on filenames are set up.
    Definitions for Linux systems are used here, but these can easily be changed for
    systems such as Windows that don’t use `.o` for an object file or `.a` for a library.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置了一些用于文件名扩展名的标准定义。这里使用的是Linux系统的定义，但这些定义可以很容易地更改为不使用`.o`作为目标文件或`.a`作为库文件的系统（例如Windows）。
- en: '`bottom.mak` uses these variables to set up the rules that will actually build
    the module:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`bottom.mak`使用这些变量来设置实际构建模块的规则：'
- en: '[PRE63]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first thing `bottom.mak` does is set up two variables with computed names:
    `$(_MODULE_NAME)_OBJS` (which is the list of object files in the module computed
    from the `SRCS` variable by transforming the extension) and `$(_MODULE_NAME)_BINARY`
    (which is the name of the binary file created by the module; this would typically
    be the library or executable being built).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`bottom.mak`首先设置两个带有计算名称的变量：`$(_MODULE_NAME)_OBJS`（它是从`SRCS`变量通过转换扩展名计算得出的模块目标文件列表）和`$(_MODULE_NAME)_BINARY`（它是模块创建的二进制文件的名称；通常是正在构建的库文件或可执行文件）。'
- en: We include the `DEPS` variable, so the `$(_MODULE_NAME)_OBJS` variable also
    includes any object files that the module needs but doesn’t build. Later you’ll
    see how this is used to define a dependency between the library and executable.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了`DEPS`变量，因此`$(_MODULE_NAME)_OBJS`变量也包括该模块需要但不构建的任何目标文件。稍后你将看到如何使用这个变量在库和可执行文件之间定义依赖关系。
- en: Next, if rules for this module have not previously been set up (controlled by
    the `$(_MODULE_NAME)_DEFINED` variable) and have not been explicitly disabled
    by the `_NO_RULES` variable, the actual rules to build the module are defined.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果该模块的规则尚未设置（由`$(_MODULE_NAME)_DEFINED`变量控制），并且未被`_NO_RULES`变量明确禁用，则定义构建该模块的实际规则。
- en: In this example, rules for Linux are shown. This is where you’d change this
    example for another operating system.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，展示了Linux的规则。这是你为其他操作系统更改此示例的地方。
- en: '`all` has the current binary, from `$(_MODULE_NAME)_BINARY`, added as a prerequisite
    so that the module gets built when a full build is done. Then there’s a rule that
    associates the module name with the module binary so that it’s possible to type
    something like `make library` at the top level of the build to build just the
    library.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`包含当前的二进制文件，来自`$(_MODULE_NAME)_BINARY`，它作为前提条件添加到模块中，这样在执行完整构建时该模块会被构建。接着有一个规则将模块名与模块二进制文件关联，这样在顶层执行`make
    library`时，只会构建库文件。'
- en: Then there’s a general `clean` rule and a module-specific clean (for the `library`
    module there’s a rule called `clean-library` to just clean its objects). `clean`
    is implemented as a simple `rm -rf` because all the output is organized in a specific
    subdirectory of `_OUTTOP`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一个通用的`clean`规则和一个模块特定的清理规则（对于`library`模块，有一个叫做`clean-library`的规则，仅清理它的对象文件）。`clean`通过简单的`rm
    -rf`实现，因为所有的输出文件都被组织在`_OUTTOP`的特定子目录中。
- en: After that a `$(shell)` is used to set up the directory where the module’s output
    will go. Finally, specific rules associate the object files in this module’s output
    directory with source files in this module’s source directory.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`$(shell)`来设置模块输出文件的目录。最后，特定的规则将该模块输出目录中的目标文件与该模块源代码目录中的源文件关联起来。
- en: 'With all that infrastructure in place, we can finally come to the makefile
    in the `executable` directory:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了所有这些基础设施之后，我们终于可以查看`executable`目录中的makefile了：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This looks a lot like the makefile for the library, but there are differences.
    Because the executable needs the library, the `DEPS` line specifies that the executable
    depends on the binary file created by the library. And because each module has
    unique variables for objects and binaries, it’s easy to define that dependency
    by referring to `$(library_BINARY)`, which will expand to the full path to the
    library file created by the library module.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很像库的makefile，但也有一些不同之处。因为可执行文件需要库，所以`DEPS`行指定了可执行文件依赖于库所创建的二进制文件。由于每个模块有独特的对象和二进制文件变量，所以可以通过引用`$(library_BINARY)`来轻松定义这种依赖关系，它会展开为由库模块创建的库文件的完整路径。
- en: 'To ensure that `$(library_BINARY)` is defined, it’s necessary to include the
    makefile from the `library` directory. The `root.mak` file provides two functions
    that make this trivial: `DEPENDS_ON` and `DEPENDS_ON_NO_BUILD`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`$(library_BINARY)`被定义，需要包含来自`library`目录的makefile。`root.mak`文件提供了两个使这一过程变得简单的函数：`DEPENDS_ON`和`DEPENDS_ON_NO_BUILD`。
- en: '`DEPENDS_ON_NO_BUILD` just sets up the variables for the specified module so
    they can be used in the makefile. If that function were used in the `executable`
    makefile, the library (`lib.a`) would have to exist for the executable to build
    successfully. On the other hand, `DEPENDS_ON` is used here to ensure that the
    `library` will get built if necessary.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEPENDS_ON_NO_BUILD`仅设置指定模块的变量，以便在makefile中使用。如果在`executable`的makefile中使用该函数，库文件（`lib.a`）必须存在，才能使可执行文件成功构建。另一方面，`DEPENDS_ON`在这里用于确保在必要时构建`library`。'
- en: '`DEPENDS_ON_NO_BUILD` provides functionality similar to a classic recursive
    build, which doesn’t know how to build that library but depends on it. `DEPENDS_ON`
    is more flexible because without recursion, you can specify a relationship and
    make sure that code is built.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEPENDS_ON_NO_BUILD`提供了类似经典递归构建的功能，虽然它不知道如何构建该库，但却依赖于它。`DEPENDS_ON`更加灵活，因为在没有递归的情况下，你可以指定关系，并确保代码能够被构建。'
- en: Using the Non-recursive make System
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非递归make系统
- en: The non-recursive `make` system provides great flexibility. Here are a few examples
    that illustrate that the non-recursive `make` system is just as flexible as a
    recursive one (and more so!).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 非递归的`make`系统提供了很大的灵活性。以下是一些例子，展示了非递归的`make`系统与递归的`make`系统一样灵活（甚至更灵活！）。
- en: 'Building everything from the top level is a simple `make` (in these examples,
    we use the command `make -n` so the commands are clearly shown):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶层构建所有内容很简单，只需运行`make`（在这些示例中，我们使用命令`make -n`，这样命令就会清晰地显示出来）：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Cleaning everything is simple too:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 清理所有内容也很简单：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'From the top-level directory, it’s possible to ask for any individual module
    to be built or cleaned:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶层目录开始，可以请求构建或清理任何单独的模块：
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And if we ask that the `executable` module be built, the `library` gets built
    at the same time because of the dependency:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要求构建`executable`模块，由于依赖关系，`library`模块也会同时被构建：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Okay, so much for the top level. If we pop down into the `library` module,
    we can build or clean it just as easily:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，关于顶层就讲到这里。如果我们进入`library`模块，就可以像构建或清理其他模块一样轻松地操作：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Of course, doing this in the `executable` directory will build the `library`
    as well:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在`executable`目录中这样做也会构建`library`：
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: What About Submodules?
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，子模块如何处理呢？
- en: Suppose that the source tree was actually
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 假设源代码树实际上是
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'where there’s an additional `sublibrary` under the `library` that builds `slib.a`
    from `slib1.c` and `slib2.c` using the following makefile:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 其中在`library`下还有一个额外的`sublibrary`，该`sublibrary`使用以下makefile从`slib1.c`和`slib2.c`构建`slib.a`：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To specify that `library` has a dependency of `sublibrary` is as simple as
    adding a `DEPENDS_ON` call to the makefile in the library directory:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`library`依赖`sublibrary`非常简单，只需在`library`目录中的makefile里添加一个`DEPENDS_ON`调用：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this example, there’s no `DEPS` line, so the `library` doesn’t depend on
    `sublibrary` at the object level. We’re simply declaring `sublibrary` as a submodule
    of library that needs to be built if `library` is.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，没有`DEPS`行，因此`library`在对象级别上并不依赖于`sublibrary`。我们只是声明`sublibrary`是`library`的一个子模块，当`library`构建时，`sublibrary`也需要被构建。
- en: Going back and repeating the previous examples, we see that the `sublibrary`
    has been successfully included in the `library` build (and automatically in the
    `executable` build).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾并重复前面的示例，我们可以看到`sublibrary`已经成功地包含在`library`的构建中（并且自动包含在`executable`的构建中）。
- en: 'Here’s the full build from the top, followed by a `clean`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从头开始的完整构建，接下来是一个`clean`操作：
- en: '[PRE74]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here, we ask for the `sublibrary` to be built:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求构建`sublibrary`：
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And if we ask that the `executable` module be built, the `library` gets built
    at the same time (and also the `sublibrary`) because of the dependency:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要求构建`executable`模块，那么`library`会同时被构建（并且`sublibrary`也会被构建），因为有这个依赖关系：
- en: '[PRE76]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Although not as simple to code as a recursive `make`, this non-recursive system
    is very flexible. It allows dependencies between individual binary files across
    modules, which is not possible with recursive `make`, and it allows this without
    losing the “go to any directory and type `make`” notion that engineers know.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种非递归的系统比递归`make`更复杂，但它非常灵活。它允许模块之间的单独二进制文件之间存在依赖关系，而递归`make`无法做到这一点，并且它允许在不失去“去任何目录并输入`make`”这一工程师熟知的理念的情况下实现这一点。
- en: GNU `make` is incredibly powerful (which is partly why it’s still around after
    so many years), but when projects become large, makefiles can get unwieldy. With
    what you learned in this chapter, you can now simplify makefiles to work around
    GNU `make`’s weaknesses so that large projects are made simpler and more reliable.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`功能非常强大（这也是它多年仍然存在的部分原因），但当项目变得庞大时，makefile可能变得难以管理。通过本章所学的内容，你现在可以简化makefile，解决GNU
    `make`的不足，使大型项目变得更加简单和可靠。
